[{"categories":null,"content":" Bağlam: Bu sayfa, I2P’nin erken tasarım döneminden uzun süreli tartışmaları arşivler. Projenin, DNS tarzı sorgulara ya da çoğunluk oylamasına dayalı kayıt sistemlerine kıyasla yerel olarak güvenilen adres defterlerini neden tercih ettiğini açıklar. Güncel kullanım rehberi için Adlandırma belgeleri bölümüne bakın.\nElenen Alternatifler I2P\u0026rsquo;nin güvenlik hedefleri, alışılagelmiş adlandırma şemalarını dışlar:\nDNS tarzı ad çözümleme. Arama yolundaki herhangi bir çözücü yanıtları sahteleyebilir veya sansürleyebilir. DNSSEC olsa bile, ele geçirilmiş registrars (kayıt operatörleri) veya sertifika otoriteleri hâlâ tek hata noktasıdır. I2P\u0026rsquo;de hedefler açık anahtarlardır—bir sorguyu ele geçirmek bir kimliği tamamen tehlikeye atar. Oylamaya dayalı adlandırma. Bir saldırgan sınırsız sayıda kimlik üretebilir (Sybil saldırısı) ve popüler adlar için oyları “kazanabilir”. İş ispatı önlemleri maliyeti artırır ama ağır bir koordinasyon yükü getirir. Bunun yerine, I2P adlandırmayı bilinçli olarak taşıma katmanının üzerinde tutar. Birlikte gelen adlandırma kitaplığı, alternatif şemelerin bir arada var olabilmesini sağlayan bir hizmet sağlayıcı arayüzü sunar—kullanıcılar hangi adres defterlerine veya jump services (adres atlama hizmetleri) güveneceklerine kendileri karar verir.\nYerel ve Küresel Adlar (jrandom, 2005) I2P içindeki adlar yerel olarak benzersizdir, ancak insan tarafından okunabilirdir. Sizin boss.i2p adınız başkasının boss.i2p adıyla eşleşmeyebilir; bu, tasarım gereğidir. Kötü niyetli bir aktör sizi bir adın işaret ettiği destination\u0026rsquo;ı (hizmetin kriptografik adresi) değiştirmeniz için kandırırsa, bir hizmeti fiilen ele geçirmiş olur. Adların küresel olarak benzersiz olmasını reddetmek bu tür bir saldırıyı önler. Adları yer imleri veya anlık mesajlaşma takma adları gibi düşünün—belirli adres defterlerine abone olarak ya da anahtarları elle ekleyerek hangi destination\u0026rsquo;lara güveneceğinizi siz seçersiniz. Yaygın İtirazlar ve Yanıtlar (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. ## Verimlilik Fikirleri Tartışıldı Artımlı güncellemeler sunun (yalnızca son alımdan beri eklenen destinations (I2P hedef adresleri)). Tam hosts dosyalarının yanında (recenthosts.cgi) tamamlayıcı akışlar sunun. Akışları birleştirmek veya güven düzeylerine göre filtrelemek için (örneğin, i2host.i2p) betiklenebilir araçları keşfedin. Önemli Noktalar Güvenlik, küresel uzlaşıdan daha önemlidir: yerel olarak bakımı yapılan adres defterleri ele geçirilme riskini en aza indirir. Birden çok adlandırma yaklaşımı adlandırma API’si aracılığıyla birlikte var olabilir—kullanıcılar neye güveneceklerine kendileri karar verir. Tamamen merkeziyetsiz küresel adlandırma hâlâ açık bir araştırma sorunudur; güvenlik, insanlar tarafından hatırlanabilirlik ve küresel benzersizlik arasındaki ödünleşimler hâlâ Zooko’nun üçgenini yansıtır. Referanslar Adlandırma belgeleri Zooko’nun “İsimler: Merkeziyetsiz, Güvenli, İnsan için anlamlı: İkisini Seçin” Örnek artımlı besleme: stats.i2p/cgi-bin/newhosts.txt ","description":"I2P'nin adlandırma modeli ve küresel DNS benzeri şemaların neden reddedildiğine ilişkin tarihsel tartışma","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"Adlandırma Tartışması","url":"/tr/docs/legacy/naming/"},{"categories":null,"content":"Genel Bakış Bu belirtim, adres abonelik akışını komutlarla genişleterek ad sunucularının ana makine adı sahiplerinden gelen kayıt güncellemelerini yayınlamasına olanak tanır. İlk olarak Proposal 112 (Eylül 2014) kapsamında önerildi, 0.9.26 sürümünde (Haziran 2016) uygulandı ve CLOSED durumuyla ağ genelinde devreye alındı.\nSistem, ilk uygulanmasından bu yana istikrarlı ve değişmeden kalmış olup, I2P 2.10.0’da (Router API 0.9.65, Eylül 2025) aynı şekilde çalışmayı sürdürmektedir.\nMotivasyon Daha önce, hosts.txt abonelik sunucuları verileri yalnızca basit bir hosts.txt biçiminde gönderirdi:\nexample.i2p=b64destination Bu temel biçim birkaç sorun yarattı:\nAna makine adı sahipleri, ana makine adlarıyla ilişkili Hedefi güncelleyemezler (örneğin, imzalama anahtarını daha güçlü bir kriptografik türe yükseltmek için). Ana makine adı sahipleri ana makine adlarından keyfi olarak vazgeçemezler. İlgili Hedefin özel anahtarlarını doğrudan yeni sahibine vermeleri gerekir. Bir alt alan adının karşılık gelen temel ana makine adı tarafından kontrol edildiğini doğrulamanın bir yolu yoktur. Bu durum şu anda yalnızca bazı ad sunucuları tarafından tek tek uygulanmaktadır. Tasarım Bu belirtim, hosts.txt biçimine komut satırları ekler. Bu komutlarla, ad sunucuları hizmetlerini genişleterek ek özellikler sağlayabilir. Bu belirtimi uygulayan istemciler, bu özellikleri standart abonelik süreci aracılığıyla dinleyebilir.\nTüm komut satırları, ilgili Destination (bir hizmetin kriptografik adresi) tarafından imzalanmış olmalıdır. Bu, değişikliklerin yalnızca ana makine adı sahibinin talebi üzerine yapılmasını sağlar.\nGüvenlik Etkileri Bu belirtim anonimliği etkilemez.\nDestination (I2P hedef tanımlayıcısı) anahtarının kontrolünü kaybetme riski artmıştır; çünkü onu ele geçiren biri, ilişkili herhangi bir ana bilgisayar adı üzerinde değişiklik yapmak için bu komutları kullanabilir. Ancak bu, mevcut duruma kıyasla daha büyük bir sorun değildir; zira bir Destination ele geçiren biri bir ana bilgisayar adını taklit edebilir ve trafiğini (kısmen) ele geçirebilir. Artan risk, ana bilgisayar adı sahiplerine, bir ana bilgisayar adıyla ilişkilendirilmiş Destination’ı, Destination’ın ele geçirildiğine inandıkları durumda değiştirme olanağı verilerek dengelenmektedir. Bu, mevcut sistemde mümkün değildir.\nTeknik Şartname Yeni Satır Türleri İki yeni çizgi türü vardır:\nAdd ve Change komutları: example.i2p=b64destination#!key1=val1#key2=val2... Kaldırma komutları: #!key1=val1#key2=val2... Sıralama Bir besleme her zaman doğru sırada ya da eksiksiz olmayabilir. Örneğin, change komutu bir satırda add komutundan önce görünebilir ya da add komutu olmadan görünebilir.\nAnahtarlar herhangi bir sırada olabilir. Yinelenen anahtarlara izin verilmez. Tüm anahtarlar ve değerler büyük-küçük harfe duyarlıdır.\nOrtak Anahtarlar Tüm komutlarda zorunludur:\nsig : Hedefin imzalama anahtarı kullanılarak oluşturulmuş Base64 imza\nİkinci bir ana bilgisayar adına ve/veya hedefe referanslar:\noldname : İkinci bir ana makine adı (yeni veya değiştirilmiş)\nolddest : İkinci bir Base64 hedefi (yeni veya değiştirilmiş)\noldsig : olddest\u0026rsquo;teki imzalama anahtarını kullanan ikinci bir Base64 imzası\nDiğer yaygın anahtarlar:\neylem : Bir komut\nname : Ana makine adı; yalnızca kendisinden önce example.i2p=b64dest yoksa mevcuttur.\ndest : Base64 hedef, yalnızca öncesinde example.i2p=b64dest yoksa bulunur\ndate : epoch (Unix zaman başlangıcı) başlangıcından beri saniye cinsinden\nexpires : epoch (Unix zamanının başlangıcı) itibarıyla saniye cinsinden\nKomutlar \u0026ldquo;Add\u0026rdquo; komutu dışındaki tüm komutlar action=command anahtar/değer çifti içermelidir.\nEski istemcilerle uyumluluk için, aşağıda belirtildiği gibi komutların çoğunun başına example.i2p=b64dest eklenir. Değişiklikler için bunlar her zaman yeni değerlerdir. Eski değerlerin tümü anahtar/değer bölümüne dahil edilir.\nListelenen anahtarlar zorunludur. Tüm komutlar burada tanımlanmayan ek anahtar/değer çiftleri içerebilir.\nAna bilgisayar adı ekle Başında example.i2p=b64dest varsa : EVET, bu yeni ana makine adı ve hedeftir.\neylem : DAHİL EDİLMEZ, örtük olarak kabul edilir.\nsig : imza\nÖrnek:\nexample.i2p=b64dest#!sig=b64sig Ana Bilgisayar Adını Değiştir Başında example.i2p=b64dest varsa : EVET, bu yeni ana makine adı ve eski hedeftir.\neylem : ad değişikliği\noldname : eski ana makine adı, değiştirilecek\nsig : imza\nÖrnek:\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig Hedefi Değiştir Ön eki example.i2p=b64dest olan : EVET, bu eski ana makine adı ve yeni hedeftir.\naction : changedest\nolddest : eski hedef, değiştirilecek\noldsig : olddest kullanılarak oluşturulan imza\nsig : imza\nÖrnek:\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Ana Bilgisayar Adına Takma Ad Ekle Önünde example.i2p=b64dest var : EVET, bu yeni (takma ad) ana makine adı ve eski destination (hedef) anlamına gelir.\neylem : addname\noldname : eski ana bilgisayar adı\nsig : imza\nÖrnek:\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig Hedef Takma Adı Ekle (Şifreleme yükseltmesi için kullanılır)\nÖncesinde example.i2p=b64dest varsa : EVET, bu, eski ana makine adı ve yeni (alternatif) destination (hedef) demektir.\neylem : adddest\nolddest : eski hedef\noldsig : olddest kullanan imza\nsig : dest kullanılarak oluşturulan imza\nÖrnek:\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Alt Alan Adı Ekle Başına subdomain.example.i2p=b64dest eklenmiş : EVET, bu yeni alt alan adı ve destination (hedef).\naction : addsubdomain\noldname : bir üst düzeydeki ana makine adı (example.i2p)\nolddest : daha üst düzey hedef (örneğin example.i2p)\noldsig : olddest kullanılarak oluşturulan imza\nsig : dest kullanılarak oluşturulan imza\nÖrnek:\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Üstveriyi Güncelle example.i2p=b64dest ile başlayan : EVET, bu eski ana makine adı ve hedeftir.\neylem : güncelleme\nsig : imza\n(güncellenmiş anahtarları buraya ekleyin)\nÖrnek:\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig Ana bilgisayar adını kaldır Başına example.i2p=b64dest eklenmiş : HAYIR, bunlar seçeneklerde belirtilir\neylem : kaldır\nname : ana bilgisayar adı\ndest : hedef\nsig : imza\nÖrnek:\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig Bu hedefe sahip olanların tümünü kaldır Başına example.i2p=b64dest eklenmesi : HAYIR, bunlar seçeneklerde belirtilir\naction : removeall\ndest : hedef\nsig : imza\nÖrnek:\n#!action=removeall#dest=b64dest#sig=b64sig İmzalar Tüm komutlar, ilgili Destination (I2P hedef adresi) tarafından imzalanmalıdır. İki Destination içeren komutlar iki imza gerektirebilir.\noldsig her zaman \u0026ldquo;iç\u0026rdquo; imzadır. oldsig veya sig anahtarları mevcut değilken imzalayın ve doğrulayın. sig her zaman \u0026ldquo;dış\u0026rdquo; imzadır. oldsig anahtarı mevcutken ancak sig anahtarı mevcut değilken imzalayın ve doğrulayın.\nİmzalar için girdi İmzayı oluşturmak veya doğrulamak için bir bayt akışı üretmek üzere, aşağıdaki gibi serileştirin:\nsig anahtarını kaldırın Doğrulama oldsig ile yapılıyorsa, oldsig anahtarını da kaldırın Yalnızca Add veya Change komutları için, example.i2p=b64dest çıktısını verin Herhangi bir anahtar kalırsa, #! çıktısını verin Seçenekleri UTF-8 anahtarına göre sıralayın, yinelenen anahtarlar varsa hata verin Her anahtar/değer çifti için key=value çıktısını verin, ardından (son anahtar/değer çifti değilse) bir # ekleyin Notlar\nÇıktıya yeni satır eklemeyin Çıktı kodlaması UTF-8\u0026rsquo;dir Tüm hedef ve imza kodlaması, I2P alfabesi kullanılarak Base 64 biçimindedir Anahtarlar ve değerler büyük/küçük harfe duyarlıdır Ana makine adları küçük harfli olmalıdır Mevcut İmza Türleri I2P 2.10.0 itibarıyla, Destination\u0026rsquo;lar (hedef adresler) için aşağıdaki imza türleri desteklenmektedir:\nEdDSA_SHA512_Ed25519 (Tür 7): 0.9.15\u0026rsquo;ten beri hedefler için en yaygınıdır. 32 baytlık bir açık anahtar ve 64 baytlık bir imza kullanır. Bu, yeni hedefler için önerilen imza türüdür. RedDSA_SHA512_Ed25519 (Tür 13): Yalnızca hedefler ve şifrelenmiş leaseSet\u0026rsquo;ler için kullanılabilir (0.9.39\u0026rsquo;dan beri). Eski türler (DSA_SHA1, ECDSA varyantları): Hâlâ desteklenir ancak 0.9.58 itibarıyla yeni Router Kimlikleri için kullanımdan kaldırılmıştır. Not: Kuantum-sonrası kriptografik seçenekler I2P 2.10.0 itibarıyla kullanılabilir, ancak henüz varsayılan imza türleri değil.\nUyumluluk hosts.txt biçimindeki tüm yeni satırlar, baştaki yorum karakterleri (#!) kullanılarak uygulanır; bu nedenle daha eski tüm I2P sürümleri, yeni komutları yorum satırları olarak değerlendirip bunları sorunsuzca görmezden gelir.\nI2P router’lar yeni spesifikasyona güncelendiğinde, eski yorumları yeniden yorumlamayacaklar, ancak abonelik beslemelerini daha sonra getirirken yeni komutları dinlemeye başlayacaklar. Bu nedenle ad sunucularının komut girdilerini bir şekilde kalıcı olarak saklamaları ya da router’ların geçmiş tüm komutları alabilmeleri için ETag (HTTP Entity Tag üstbilgisi) desteğini etkinleştirmeleri önemlidir.\nUygulama Durumu İlk dağıtım: Sürüm 0.9.26 (7 Haziran 2016)\nMevcut durum: I2P 2.10.0\u0026rsquo;a kadar kararlı ve değişmeden kaldı (Router API 0.9.65, Eylül 2025)\nÖneri durumu: KAPALI (başarıyla ağ genelinde devreye alındı)\nGerçekleme konumu: apps/addressbook/java/src/net/i2p/addressbook/ I2P Java router içinde\nTemel sınıflar: - SubscriptionList.java: Abonelik işlemlerini yönetir - Subscription.java: Tek tek abonelik akışlarını işler - AddressBook.java: Adres Defteri\u0026rsquo;nin temel işlevleri - Daemon.java: Adres Defteri arka plan hizmeti\nVarsayılan abonelik URL\u0026rsquo;si: http://i2p-projekt.i2p/hosts.txt\nTaşıma Ayrıntıları Abonelikler, koşullu GET desteği olan HTTP’yi kullanır:\nETag başlığı: Verimli değişiklik tespitine olanak tanır Last-Modified başlığı: Abonelik güncelleme zamanlarını izler 304 Not Modified: İçerik değişmediğinde sunucuların bunu döndürmesi gerekir Content-Length: Tüm yanıtlar için şiddetle önerilir I2P router, uygun önbellekleme desteğiyle standart HTTP istemcisi davranışını kullanır.\nSürüm Bağlamı I2P sürümleme notu: Yaklaşık 1.5.0 sürümü (Ağustos 2021) civarında, I2P 0.9.x sürümlemesinden anlamsal sürümlemeye (1.x, 2.x vb.) geçti. Ancak, geriye dönük uyumluluk için dahili Router API sürümü 0.9.x numaralandırmasını kullanmaya devam ediyor. Ekim 2025 itibarıyla, güncel sürüm I2P 2.10.0 ve Router API sürümü 0.9.65’tir.\nBu spesifikasyon belgesi, aslen 0.9.49 sürümü (Şubat 2021) için yazılmış olup, abonelik besleme sisteminde 0.9.26’daki ilk uygulamasından bu yana hiçbir değişiklik yapılmadığından, mevcut 0.9.65 sürümü (I2P 2.10.0) için de tamamen doğrudur.\nReferanslar Öneri 112 (Orijinal) Resmi Spesifikasyon I2P Adlandırma Dokümantasyonu Ortak Yapılar Spesifikasyonu I2P Kaynak Kodu Deposu I2P Gitea Deposu İlgili Gelişmeler Abonelik besleme sistemi değişmemiş olsa da, I2P\u0026rsquo;nin adlandırma altyapısına ilişkin aşağıdaki ilgili gelişmeler ilginizi çekebilir:\nGenişletilmiş Base32 Adları (0.9.40+): Şifrelenmiş leasesets için 56+ karakterli base32 adreslerine destek. Abonelik akışı biçimini etkilemez. .i2p.alt TLD Kaydı (RFC 9476, 2023 sonları): .i2p.alt\u0026rsquo;ın alternatif bir TLD olarak resmi GANA kaydı. Gelecekteki router güncellemeleri .alt sonekini kaldırabilir, ancak abonelik komutlarında herhangi bir değişiklik gerekmez. Kuantum Sonrası Kriptografi (2.10.0+): Mevcut, ancak varsayılan değil. Abonelik akışlarında imza algoritmaları için gelecekte değerlendirilecektir. ","description":"Adres abonelik beslemelerine yönelik, ana makine adı sahiplerinin kayıtlarını güncelleyip yönetmelerini sağlayan bir uzantı","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"Adres Aboneliği Besleme Komutları","url":"/tr/docs/specs/subscription/"},{"categories":null,"content":" 1. Genel Bakış netDb, yalnızca iki tür veri içeren özel amaçlı bir dağıtık veritabanıdır: - RouterInfos – router iletişim bilgileri - LeaseSets – hedef (destination) iletişim bilgileri\nTüm veriler kriptografik olarak imzalanmıştır ve doğrulanabilir. Her bir kayıt, eskimiş kayıtların düşürülmesi ve güncelliğini yitirmiş olanların yenileriyle değiştirilmesi için liveliness (canlılık durumu) bilgisi içerir; böylece belirli saldırı sınıflarına karşı koruma sağlar.\nDağıtım, floodfill (I2P\u0026rsquo;de dağıtık veritabanını yayan bir mekanizma) kullanır, burada router\u0026rsquo;ların bir alt kümesi dağıtık veritabanını sürdürür.\n2. RouterInfo Router\u0026rsquo;ların diğer router\u0026rsquo;larla iletişime geçmesi gerektiğinde, şunları içeren RouterInfo (router bilgisi) paketlerini değiş tokuş ederler:\nRouter kimliği – şifreleme anahtarı, imzalama anahtarı, sertifika İletişim adresleri – router\u0026rsquo;a nasıl ulaşılacağı Yayımlanma zaman damgası – bu bilginin ne zaman yayımlandığı Serbest metin seçenekleri – yetenek bayrakları ve ayarlar Kriptografik imza – özgünlüğünü kanıtlar 2.1 Yetenek Bayrakları Router\u0026rsquo;lar kendi RouterInfo\u0026rsquo;larında harf kodları aracılığıyla yeteneklerini ilan eder:\nFlag Meaning f Floodfill participation R Reachable U Unreachable D, E, G, H Various capability indicators ### 2.2 Bant Genişliği Sınıflandırmaları Code Bandwidth K Under 12 KBps L 12–48 KBps (default) M 48–64 KBps N 64–128 KBps O 128–256 KBps P 256–2000 KBps X Over 2000 KBps ### 2.3 Ağ Kimliği Değerleri Value Purpose 0 Reserved 1 Current Network (default) 2 Reserved for Future Networks 3–15 Forks and Test Networks 16–254 Reserved 255 Reserved ### 2.4 RouterInfo İstatistikleri Router\u0026rsquo;lar ağ analizi için isteğe bağlı sağlık istatistikleri yayınlar: - Exploratory tunnel kurulumunda başarı/ret/zaman aşımı oranları - 1 saatlik ortalama katılımcı tunnel sayısı\nİstatistikler stat_(statname).(statperiod) biçimini izler ve değerler noktalı virgülle ayrılmıştır.\nÖrnek İstatistikler:\nstat_tunnel.buildExploratoryExpire.60m = 0;0;0;53.14 stat_tunnel.buildExploratoryReject.60m = 0;0;0;15.51 stat_tunnel.buildExploratorySuccess.60m = 0;0;0;31.35 stat_tunnel.participatingTunnels.60m = 289.20 Floodfill router\u0026rsquo;lar ayrıca şunları da yayınlayabilir: netdb.knownLeaseSets ve netdb.knownRouters\n2.5 Aile Seçenekleri 0.9.24 sürümünden itibaren, router\u0026rsquo;lar aile üyeliğini (aynı operatör) bildirebilir:\nfamily: Aile adı family.key: İmza türü kodu ile base64 ile kodlanmış imzalama açık anahtarının birleştirilmiş biçimi family.sig: Aile adının ve 32 baytlık router karmasının imzası Aynı ailedeki birden fazla router, tek bir tunnel içinde birlikte kullanılmaz.\n2.6 RouterInfo Zaman Aşımı Çalışma süresinin ilk saatinde zaman aşımı yok Saklanan RouterInfos (router bilgi kayıtları) 25 veya daha az ise zaman aşımı yok Yereldeki sayı arttıkça zaman aşımı süresi kısalır (120\u0026rsquo;den az router için 72 saat; 300 router için ~30 saat) SSU introducers (SSU tanıtıcıları) ~1 saatte zaman aşımına uğrar Floodfills tüm yerel RouterInfos için 1 saatlik zaman aşımı kullanır 3. LeaseSet LeaseSets, belirli hedefler için tunnel giriş noktalarını belgeler ve şunları belirtir:\nTunnel ağ geçidi router kimliği 4 baytlık tunnel kimliği Tunnel sona erme zamanı LeaseSets şunları içerir: - Hedef – şifreleme anahtarı, imzalama anahtarı, sertifika - Ek şifreleme açık anahtarı – uçtan uca garlic encryption için - Ek imzalama açık anahtarı – iptal için tasarlanmıştır (şu anda kullanılmıyor) - Kriptografik imza\n3.1 LeaseSet Varyantları Type Description Unpublished Destinations used only for outgoing connections aren't published to floodfill routers Revoked Published with zero leases, signed by additional signing key (not fully implemented) LeaseSet2 (LS2) As of 0.9.38, supports new encryption types, multiple encryption types, options, offline signing keys ([Proposal 123](/proposals/123-new-netdb-entries/)) Meta LeaseSet Tree-like DHT structure for multihomed services, supporting hundreds/thousands of destinations with long expirations (up to 18.2 hours) Encrypted LeaseSet (LS1) All leases encrypted with separate key; only those with the key can decode and contact the destination Encrypted LeaseSet (LS2) As of 0.9.38, destination hidden with only blinded public key and expiration visible to floodfill ### 3.2 LeaseSet'in Süresinin Dolması Standart LeaseSets (bir destinasyona ulaşmak için yayımlanan erişim kayıtları) içindeki kiraların en geç sona erme zamanında geçersiz hale gelir. LeaseSet2 (LeaseSet’in 2. sürümü) için sona erme zamanı başlıkta belirtilir. EncryptedLeaseSet (şifrelenmiş LeaseSet) ve MetaLeaseSet (birden fazla LeaseSet’i işaret eden meta kayıt) için sona erme süreleri değişebilir; ayrıca olası bir üst sınır uygulanabilir.\n4. Önyükleme Merkeziyetsiz netDb ağa entegre olabilmek için en az bir eş referansı gerektirir. Reseeding (yeniden tohumlama), gönüllülerin netDb dizinlerinden RouterInfo dosyalarını (routerInfo-$hash.dat) alır. İlk başlatma sırasında, rastgele seçilen sabit kodlanmış URL’lerden otomatik olarak getirilir.\n5. Floodfill Mekanizması floodfill netDb basit bir dağıtık depolama kullanır: veri en yakın floodfill eşine gönderilir. floodfill olmayan eşler store iletileri (depolama iletileri) gönderdiğinde, floodfill’ler bunları belirli anahtara en yakın floodfill eşlerinden oluşan bir altkümeye iletir.\nFloodfill katılımı, RouterInfo\u0026rsquo;da bir özellik bayrağı (f) olarak belirtilir.\n5.1 Floodfill\u0026rsquo;e İsteğe Bağlı Katılım Gereksinimleri Tor\u0026rsquo;un sabit kodlu güvenilir dizin sunucularının aksine, I2P\u0026rsquo;nin floodfill kümesi güvenilmez ve zamanla değişir.\nFloodfill, yalnızca şu gereksinimleri karşılayan yüksek bant genişliğine sahip router\u0026rsquo;larda otomatik olarak etkinleşir: - En az 128 KBytes/sec paylaşılan bant genişliği (elle yapılandırılmış) - Ek sağlık testlerini geçmelidir (giden ileti kuyruğu süresi, iş gecikmesi)\nMevcut otomatik katılım, yaklaşık %6 ağ floodfill katılımı ile sonuçlanıyor.\nElle yapılandırılmış floodfill’ler (I2P\u0026rsquo;de netDb\u0026rsquo;yi barındıran özel düğüm rolü), otomatik gönüllülere ek olarak vardır. floodfill sayısı eşik değerin altına düştüğünde, yüksek bant genişliğine sahip router’lar otomatik olarak gönüllü olur. Çok fazla floodfill bulunduğunda ise, floodfill rollerini bırakırlar.\n5.2 Floodfill Rolleri netDb (I2P ağ veritabanı) depolama iletilerini kabul etmek ve sorgulara yanıt vermenin ötesinde, floodfills (özel netDb düğümleri) standart router (yöneltici) işlevlerini yerine getirir. Daha yüksek bant genişlikleri genellikle daha fazla tunnel (tünel) katılımı anlamına gelir, ancak bu durum veritabanı hizmetleriyle doğrudan ilişkili değildir.\n6. Kademlia Yakınlık Metriği netDb, XOR tabanlı Kademlia tarzı mesafe ölçümü kullanır. RouterIdentity (router kimliği) veya Destination\u0026rsquo;ın SHA256 karması, Kademlia anahtarını oluşturur (LS2 Encrypted LeaseSets hariç; bunlar, tip baytı 3 ile körlenmiş açık anahtarın SHA256\u0026rsquo;sını kullanır).\n6.1 Anahtar Uzayı Rotasyonu Sybil saldırılarının maliyetlerini artırmak için, SHA256(key) kullanmak yerine sistem şunları kullanır:\nSHA256(key + yyyyMMdd) Burada tarih, 8 baytlık ASCII UTC tarihtir. Bu, yönlendirme anahtarını oluşturur ve UTC\u0026rsquo;ye göre her gün gece yarısında değişir—buna anahtar uzayı rotasyonu denir.\nYönlendirme anahtarları hiçbir zaman I2NP iletilerinde iletilmez; yalnızca yerel mesafe belirleme için kullanılır.\n7. Ağ Veritabanının Bölümlendirilmesi Geleneksel Kademlia DHT\u0026rsquo;leri, depolanan bilginin ilişkilendirilemezliğini korumaz. I2P, segmentasyon (bölümlendirme) uygulayarak client tunnels ile routers arasında ilişki kurulmasına yönelik saldırıları engeller.\n7.1 Bölümlendirme Stratejisi Routers şunları izler: - Kayıtların istemci tunnel\u0026rsquo;lar üzerinden mi yoksa doğrudan mı geldiği - Eğer tunnel üzerinden ise, hangi istemci tunnel/hedef - Birden fazla tunnel üzerinden gelenler izlenir - Depolama ile arama yanıtları birbirinden ayırt edilir\nJava ve C++ gerçeklemelerinin her ikisi de şunları kullanır: - \u0026ldquo;Ana\u0026rdquo; netDb router bağlamında doğrudan aramalar/floodfill işlemleri için - \u0026ldquo;İstemci Ağ Veritabanları\u0026rdquo; veya \u0026ldquo;Alt Veritabanları\u0026rdquo; istemci bağlamlarında, istemci tunnel\u0026rsquo;larına gönderilen kayıtları yakalayan\nClient netDbs yalnızca istemcinin yaşam süresi boyunca mevcuttur ve yalnızca istemci tunnel girişlerini içerir. İstemci tunnel kaynaklı girişler doğrudan varışlarla örtüşemez.\nHer netDb, girdilerin depolama olarak mı (arama isteklerine yanıt verir) yoksa arama yanıtı olarak mı (yalnızca daha önce aynı destination (I2P\u0026rsquo;de hedef adres) için depolanmışsa yanıt verir) geldiğini izler. İstemciler sorgulara Main netDb girdileriyle asla yanıt vermez, yalnızca istemci ağ veritabanı girdileriyle yanıt verir.\nBirleşik stratejiler, netDb\u0026rsquo;yi istemci-router ilişkilendirme saldırılarına karşı bölümlendirir.\n8. Depolama, Doğrulama ve Sorgulama 8.1 RouterInfo\u0026rsquo;nun Eşlere Depolanması NTCP veya SSU transport bağlantısı başlatılması sırasında yerel RouterInfo değişimini içeren I2NP DatabaseStoreMessage.\n8.2 LeaseSet\u0026rsquo;in Eşlere Depolanması Yerel LeaseSet içeren I2NP DatabaseStoreMessage iletileri, Destination (I2P adresi) trafiğiyle birlikte paketlenmiş ve garlic encryption ile şifrelenmiş iletiler üzerinden periyodik olarak değiş tokuş edilir; böylece LeaseSet sorguları olmadan yanıt verilmesine olanak tanır.\n8.3 Floodfill Seçimi DatabaseStoreMessage geçerli yönlendirme anahtarına en yakın floodfill\u0026rsquo;e gönderilir. En yakın floodfill yerel veritabanı aramasıyla bulunur. Gerçekte en yakın olmasa bile, flooding (yayma tekniği) onu birden fazla floodfill\u0026rsquo;e göndererek \u0026ldquo;daha yakın\u0026quot;a getirir.\nGeleneksel Kademlia, ekleme işleminden önce \u0026ldquo;en yakınını bulma\u0026rdquo; aramasını kullanır. I2NP\u0026rsquo;de bu tür mesajlar bulunmasa da, router\u0026rsquo;lar gerçek en yakın eşin keşfini sağlamak için en düşük anlamlı biti tersleyerek (key ^ 0x01) yinelemeli arama gerçekleştirebilir.\n8.4 RouterInfo\u0026rsquo;ların floodfill\u0026rsquo;lere (özel netDb dizin düğümleri) depolanması Routers, RouterInfo\u0026rsquo;yu bir floodfill\u0026rsquo;e doğrudan bağlanıp, sıfırdan farklı bir Yanıt Jetonu içeren I2NP DatabaseStoreMessage göndererek yayınlar. Mesaj, uçtan uca garlic encryption (I2P\u0026rsquo;de çoklu iletileri tek pakette sarmalayan şifreleme tekniği) ile şifrelenmez (doğrudan bağlantı, aracı yoktur). Floodfill, Yanıt Jetonunu Mesaj Kimliği olarak kullanarak DeliveryStatusMessage ile yanıt verir.\nRouter\u0026rsquo;lar ayrıca RouterInfo\u0026rsquo;yu keşif amaçlı tunnel üzerinden de gönderebilir (bağlantı sınırları, uyumsuzluk, IP gizleme). Floodfill\u0026rsquo;ler aşırı yük sırasında bu tür depolama isteklerini reddedebilir.\n8.5 LeaseSet\u0026rsquo;lerin Floodfill\u0026rsquo;lere Depolanması LeaseSet depolaması (I2P destinasyonunun erişim bilgisi kaydı), RouterInfo\u0026rsquo;ya kıyasla daha hassastır. Router\u0026rsquo;lar, LeaseSet\u0026rsquo;in kendileriyle ilişkilendirilmesini engellemelidir.\nRouter\u0026rsquo;lar, giden istemci tunnel üzerinden, sıfır olmayan bir Reply Token (yanıt jetonu) içeren DatabaseStoreMessage ile LeaseSet yayınlar. İleti, Destination (hedef kimlik) nesnesinin Session Key Manager\u0026rsquo;ı (oturum anahtarı yöneticisi) kullanılarak uçtan uca garlic encryption ile şifrelenir; böylece tunnel\u0026rsquo;in giden uç noktasından gizlenir. floodfill, gelen tunnel üzerinden geri dönen DeliveryStatusMessage ile yanıt verir.\n8.6 Flooding (ağda verinin komşu düğümlere iletilerek yayılması) Süreci Floodfills (floodfill düğümleri), yük, netdb boyutu ve diğer faktörlere bağlı uyarlanabilir ölçütleri kullanarak, yerelde saklamadan önce RouterInfo/LeaseSet\u0026rsquo;i doğrular.\nGeçerli ve daha yeni veriyi aldıktan sonra, floodfill\u0026rsquo;ler, yönlendirme anahtarına en yakın 3 floodfill router\u0026rsquo;ı bularak onu \u0026ldquo;flood\u0026rdquo; eder. Doğrudan bağlantılar, sıfır Reply Token (Yanıt Jetonu) ile I2NP DatabaseStoreMessage gönderir. Diğer router\u0026rsquo;lar yanıt vermez veya yeniden \u0026ldquo;flood\u0026rdquo; etmez.\nÖnemli kısıtlamalar: - Floodfills, tunnels üzerinden flood yapmamalıdır; yalnızca doğrudan bağlantılar - Floodfills, süresi dolmuş LeaseSet veya yayımlanmasının üzerinden bir saatten fazla geçmiş RouterInfo için asla flood yapmaz\n8.7 RouterInfo ve LeaseSet Sorgulaması I2NP DatabaseLookupMessage, floodfill router\u0026rsquo;lardan netDb girdilerini ister. Sorgular, giden keşif tunnel üzerinden gönderilir; yanıtlar, dönüş için kullanılacak gelen keşif tunnel\u0026rsquo;ini belirtir.\nSorgular genellikle, istenen anahtara en yakın iki \u0026ldquo;iyi\u0026rdquo; floodfill router\u0026rsquo;a, paralel olarak gönderilir.\nYerel eşleşme: I2NP DatabaseStoreMessage yanıtını alır Yerel eşleşme yok: anahtara yakın diğer floodfill router (netDb\u0026rsquo;yi tutup yayımlayan özel router) referanslarıyla birlikte I2NP DatabaseSearchReplyMessage alır LeaseSet sorguları, uçtan uca garlic encryption (garlic şifreleme tekniği) kullanır (0.9.5 itibarıyla). RouterInfo sorguları ise ElGamal’in hesaplama maliyeti nedeniyle şifrelenmez; bu da onları giden uç nokta dinlemesine karşı savunmasız hale getirir.\n0.9.7 sürümünden itibaren, sorgu yanıtları oturum anahtarı ve etiket içerir; bu da yanıtları gelen ağ geçidinden gizler.\n8.8 Yinelemeli Sorgular 0.8.9 öncesi: Özyinelemeli veya yinelemeli yönlendirme olmadan iki paralel yedekli sorgu.\n0.8.9 itibarıyla: Yinelemeli sorgular yedeksiz olarak uygulandı—daha verimli, güvenilir ve eksik floodfill bilgisine daha uygundur. Ağlar büyüdükçe ve router\u0026rsquo;lar daha az floodfill bildikçe, sorgular O(log n) karmaşıklığına yaklaşır.\nYinelemeli aramalar, daha yakın eş referansları olmasa bile sürdürülür; bu da kötücül black-holing (trafiği kasıtlı olarak kara deliğe yönlendirme) girişimlerini önler. Geçerli azami sorgu sayısı ve zaman aşımı uygulanır.\n8.9 Doğrulama RouterInfo Doğrulaması: \u0026ldquo;Practical Attacks Against the I2P Network\u0026rdquo; makalesinde açıklanan saldırıları önlemek için 0.9.7.1 itibarıyla devre dışı bırakıldı.\nLeaseSet (kiralama kümesi) Doğrulaması: Routers (yönlendiriciler) ~10 saniye bekler, ardından farklı bir floodfill (düğümü) üzerinden giden istemci tunnel (tünel) aracılığıyla sorgulama yapar. Uçtan uca garlic encryption (şifreleme tekniği) bunu giden uç noktadan gizler. Yanıtlar gelen tunnels üzerinden geri döner.\n0.9.7 sürümünden itibaren, yanıtlar, oturum anahtarı/etiket gizleme kullanılarak inbound gateway (gelen ağ geçidi) karşısında gizli kalacak biçimde şifrelenir.\n8.10 Keşif Keşif, yeni router\u0026rsquo;ları keşfetmek için rastgele anahtarlarla netdb araması yapmayı içerir. Floodfills, istenen anahtara yakın non-floodfill router hash\u0026rsquo;lerini içeren DatabaseSearchReplyMessage ile yanıt verir. Keşif sorguları DatabaseLookupMessage içinde özel bir bayrak ayarlar.\n9. MultiHoming (birden fazla ağ bağlantısı/sağlayıcı ile çalışma) Özdeş özel/açık anahtarlar (geleneksel eepPriv.dat) kullanan Destinasyonlar, aynı anda birden fazla router üzerinde barındırılabilir. Her örnek periyodik olarak imzalı LeaseSet\u0026rsquo;ler yayımlar; en son yayımlanan LeaseSet, sorgu yapanlara döner. LeaseSet yaşam süreleri en fazla 10 dakika olduğundan, kesintiler en fazla ~10 dakika sürer.\n0.9.38 itibarıyla, Meta LeaseSets, ortak hizmetler sunan ayrı Destinations kullanarak büyük multihomed (birden fazla bağımsız bağlantı/uç nokta barındıran) hizmetleri destekler. Meta LeaseSet girişleri, geçerlilik süreleri 18.2 saate kadar olan Destinations veya diğer Meta LeaseSets olup, ortak hizmetleri barındıran yüzlerce/binlerce Destinations’a olanak tanır.\n10. Tehdit Analizi Yaklaşık 1700 floodfill router şu anda çalışıyor. Ağın büyümesi, çoğu saldırıyı zorlaştırır veya etkisini azaltır.\n10.1 Genel Önlemler Büyüme: Daha fazla floodfills, saldırıları daha zor hale getirir veya daha az etkili kılar Yedeklilik: Tüm netdb girdileri, anahtara en yakın 3 floodfill routers üzerinde flooding (sel tipi yayma yöntemi) yoluyla depolanır İmzalar: Tüm girdiler, oluşturucuları tarafından imzalanır; sahtecilik imkansızdır 10.2 Yavaş veya Yanıt Vermeyen Routers Router\u0026rsquo;lar, floodfill\u0026rsquo;ler için genişletilmiş eş profili istatistiklerini tutar: - Ortalama yanıt süresi - Sorgu yanıtlama yüzdesi - Depolama doğrulaması başarı yüzdesi - Son başarılı depolama - Son başarılı sorgulama - Son yanıt\nRouter\u0026rsquo;lar, en yakın floodfill\u0026rsquo;i seçmeye yönelik \u0026ldquo;goodness\u0026rdquo; (uygunluk ölçütü) değerini belirlerken bu metrikleri kullanır. Tamamen yanıtsız router\u0026rsquo;lar hızla saptanır ve bunlardan kaçınılır; kısmen kötü niyetli router\u0026rsquo;lar ise daha büyük bir zorluk teşkil eder.\n10.3 Sybil Saldırısı (Tam Anahtar Uzayı) Saldırganlar, etkili bir DoS saldırısı olarak, anahtar uzayının geneline dağıtılmış çok sayıda floodfill router oluşturabilir.\n\u0026ldquo;bad\u0026rdquo; ataması için yeterince uygunsuz davranmıyorsa, olası yanıtlar şunları içerir: - Konsol haberleri, web sitesi, forum aracılığıyla duyurulan \u0026ldquo;bad\u0026rdquo; router hash/IP listelerinin derlenmesi - Ağ genelinde floodfill etkinleştirmesi (\u0026ldquo;daha fazla Sybil ile Sybil\u0026rsquo;e karşı savaş\u0026rdquo;) - Sabit kodlanmış \u0026ldquo;bad\u0026rdquo; listeleri içeren yeni yazılım sürümleri - Otomatik tanımlama için geliştirilmiş eş profili metrikleri ve eşik değerleri - Tek bir IP blok içinde birden fazla floodfill\u0026rsquo;i diskalifiye eden IP blok nitelendirmesi - Otomatik aboneliğe dayalı kara liste (Tor konsensüsüne benzer)\nDaha büyük ağlar bunu zorlaştırır.\n10.4 Sybil Saldırısı (Kısmi Anahtar Uzayı) Saldırganlar, anahtar uzayında birbirine çok yakın kümelenmiş 8–15 floodfill router oluşturabilir. Bu anahtar uzayına yönelik tüm arama/kaydetme işlemleri saldırgan router\u0026rsquo;lara yönlendirilir; bu da belirli I2P sitelerinde DoS (hizmet engelleme) yapılmasını mümkün kılar.\nAnahtar uzayı kriptografik SHA256 özetlerini indekslediğinden, saldırganların yeterli yakınlığa sahip routers oluşturmak için kaba kuvvete başvurması gerekir.\nSavunma: Kademlia yakınlık algoritması, SHA256(key + YYYYMMDD) kullanarak zaman içinde değişir; günlük değişim UTC gece yarısında gerçekleşir. Bu keyspace rotation (anahtar uzayı rotasyonu), saldırının her gün yeniden oluşturulmasını zorlar.\nNot: Son araştırmalar, anahtar uzayı rotasyonunun pek etkili olmadığını gösteriyor—saldırganlar router hash\u0026rsquo;lerini önceden hesaplayabilir ve rotasyondan sonra yarım saat içinde anahtar uzayının bazı kısımlarını gölgede bırakmak için yalnızca birkaç router yeterlidir.\nGünlük rotasyonun sonucu: dağıtılmış netdb, rotasyondan sonra birkaç dakika boyunca güvenilmez hale gelir—yeni en yakın router store iletilerini alana kadar sorgular başarısız olur.\n10.5 Önyükleme Saldırıları Saldırganlar reseed websites (yeni router’ların ağa ilk katılımında eş bilgilerini sağlamak için kullanılan web siteleri) ele geçirebilir veya geliştiricileri kötücül reseed websites eklemeye kandırabilir; böylece yeni router’ları izole/çoğunluk kontrolündeki ağlara önyükleyebilir.\nUygulanan Savunmalar: - Tek bir site yerine birden fazla reseed (ağ önyükleme) sitesinden RouterInfo (yöneltici bilgisi veri yapısı) alt kümelerinin alınması - Ağ dışı reseed izlemesiyle sitelerin periyodik olarak yoklanması - 0.9.14 itibarıyla, reseed veri paketleri imzalı zip dosyalarıdır ve indirilen imzalar doğrulanır (bkz. su3 specification )\n10.6 Sorgu Yakalama Floodfill router\u0026rsquo;lar, döndürülen referanslar aracılığıyla eşleri saldırganın kontrolündeki router\u0026rsquo;lara \u0026ldquo;yönlendirebilir\u0026rdquo;.\nDüşük sıklık nedeniyle keşif yoluyla olması pek olası değil; routers, eş referanslarını esas olarak normal tunnel oluşturma yoluyla edinir.\n0.8.9 itibarıyla, yinelemeli aramalar uygulanmıştır. DatabaseSearchReplyMessage floodfill referansları, arama anahtarına daha yakınsa izlenir. İstek yapan router\u0026rsquo;lar referans yakınlığına güvenmez. Daha yakın anahtarlar bulunmasa bile aramalar zaman aşımı/azami sorgu sayısına kadar sürer; bu da kötü niyetli black-holing (trafiği yutma saldırısı) girişimlerini önler.\n10.7 Bilgi Sızıntıları I2P\u0026rsquo;deki DHT (dağıtık karma tablosu) bilgi sızıntısı daha fazla araştırma gerektiriyor. floodfill router\u0026rsquo;lar, sorguları gözlemleyerek bilgi toplar. Kötücül düğüm oranı %20 seviyesindeyken, daha önce açıklanan Sybil (çoklu sahte kimlik) tehditleri birden fazla nedenle sorunlu hâle gelir.\n11. Gelecek Çalışmalar Ek netDb sorguları ve yanıtları için uçtan uca şifreleme Daha iyi sorgu yanıtı izleme yöntemleri keyspace (anahtar uzayı) rotasyonu güvenilirlik sorunlarına yönelik azaltma yöntemleri 12. Referanslar Ortak Yapılar Teknik Belirtimi – RouterInfo ve LeaseSet yapıları I2NP Teknik Belirtimi – Veritabanı mesaj türleri Öneri 123: Yeni netDb Girdileri – LeaseSet2 teknik belirtimi Tarihsel netDb Tartışması – Geliştirme geçmişi ve arşivlenmiş tartışmalar ","description":"I2P'nin dağıtık ağ veritabanının (netDb) anlaşılması - router iletişim bilgileri ve destination (hedef) sorguları için özelleşmiş bir DHT","id":"ef0a5e8bee4372a50a7f4562af717b0c","section":"docs","title":"Ağ Veritabanı","url":"/tr/docs/overview/network-database/"},{"categories":null,"content":" Not: Bu arşiv niteliğindeki tartışma, ağ veritabanına (netDb) yönelik tarihsel yaklaşımların ana hatlarını çizer. Güncel davranış ve yönlendirme için ana netDb belgelerine başvurun.\nTarihçe I2P\u0026rsquo;nin netDb\u0026rsquo;si basit bir floodfill algoritması kullanılarak dağıtılır. Erken sürümler ayrıca yedek olarak bir Kademlia DHT (dağıtık hash tablosu) uygulamasını da barındırıyordu, ancak bunun güvenilmez olduğu kanıtlandı ve 0.6.1.20 sürümünde tamamen devre dışı bırakıldı. Floodfill tasarımı, yayınlanan bir kaydı katılımcı bir router\u0026rsquo;a iletir, onay bekler ve gerekirse diğer floodfill eşleriyle yeniden dener. Floodfill eşleri, floodfill olmayan router\u0026rsquo;lardan gelen depolama (store) iletilerini diğer tüm floodfill katılımcılarına yayınlar.\n2009\u0026rsquo;un sonlarında, bireysel floodfill router\u0026rsquo;lar üzerindeki depolama yükünü azaltmak için Kademlia (bir DHT protokolü) sorguları kısmen yeniden devreye sokuldu.\nFloodfill\u0026rsquo;e Giriş (I2P\u0026rsquo;de netDb verilerini depolayıp dağıtan özel router rolü) Floodfill ilk olarak 0.6.0.4 sürümünde ortaya çıktı; bu sırada Kademlia (bir DHT protokolü) yedek olarak kullanılabilir olmaya devam etti. O dönemde, yüksek paket kaybı ve kısıtlı rotalar, en yakın dört eşten onay almayı zorlaştırıyor, çoğu zaman onlarca tekrarlı depolama girişimini gerektiriyordu. Dışarıdan erişilebilen routers\u0026rsquo;tan oluşan bir floodfill altkümesine geçiş, pragmatik bir kısa vadeli çözüm sağladı.\nKademlia’yı (bir dağıtık hash tablosu [DHT] protokolü) yeniden ele almak Göz önünde bulundurulan bazı alternatifler şunlardı:\nKatılıma isteğe bağlı olarak dahil olmayı seçen erişilebilir router\u0026rsquo;larla sınırlı bir Kademlia DHT (Kademlia tabanlı dağıtık karma tablosu) olarak netDb\u0026rsquo;yi çalıştırmak floodfill modelini (netDb verisini barındırıp dağıtan yüksek kapasiteli düğüm modeli) korumak ancak katılımı yeterli kapasiteye sahip router\u0026rsquo;larla sınırlamak ve dağıtımı rastgele denetimlerle doğrulamak floodfill yaklaşımı, dağıtması daha kolay olduğu ve netDb\u0026rsquo;nin kullanıcı yüklerini değil, yalnızca meta veriyi taşıdığı için tercih edildi. Çoğu hedef bir LeaseSet yayımlamaz; çünkü gönderici genellikle kendi LeaseSet\u0026rsquo;ini garlic mesajları içinde paketler.\nGüncel Durum (Tarihsel Bakış Açısı) netDb algoritmaları ağın ihtiyaçlarına göre uyarlanmıştır ve geçmişte rahatlıkla birkaç yüz router\u0026rsquo;ı kaldırabilmiştir. Erken tahminler, 3–5 floodfill router\u0026rsquo;ın yaklaşık 10.000 düğümü destekleyebileceğini öne sürüyordu.\nGüncellenmiş Hesaplamalar (Mart 2008) recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T Burada:\nN: Ağdaki router sayısı L: Her router başına ortalama istemci hedef sayısı (RouterInfo için +1) F: Tunnel başarısızlık yüzdesi R: Tunnel ömrünün bir kesri olarak Tunnel yeniden oluşturma süresi S: Ortalama netDb girdi boyutu T: Tunnel ömrü 2008 dönemine ait değerleri (N = 700, L = 0.5, F = 0.33, R = 0.5, S = 4 KB, T = 10 minutes) kullanmak şu sonucu verir:\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps Kademlia Geri Dönecek mi? Geliştiriciler 2007\u0026rsquo;nin başları civarında Kademlia\u0026rsquo;nın (bir dağıtık hash tablosu algoritması) yeniden devreye alınmasını tartıştılar. Uzlaşı, floodfill kapasitesinin ihtiyaç duyuldukça kademeli olarak genişletilebileceği; buna karşılık Kademlia\u0026rsquo;nın standart router kitlesi için kayda değer ölçüde karmaşıklık ve kaynak gereksinimleri eklediği yönündeydi. Yedek çözüm, floodfill kapasitesi yetersiz kalmadıkça pasif kalır.\nFloodfill Kapasite Planlaması Bant genişliği sınıfı O router\u0026rsquo;ların floodfill\u0026rsquo;e otomatik kabulü, cazip olsa da, düşman düğümlerin katılmayı seçmesi halinde denial-of-service (hizmet reddi) senaryoları riski taşır. Tarihsel analiz, floodfill havuzunun sınırlandırılmasının (örneğin, ~10K router\u0026rsquo;ı 3–5 eşin işlemesi) daha güvenli olduğunu öne sürmüştü. Yeterli ama kontrollü bir floodfill kümesini sürdürmek için güvenilir operatörler veya otomatik heuristics (sezgisel yöntemler) kullanılagelmiştir.\nFloodfill Yapılacaklar (Tarihsel) Bu bölüm arşiv amaçlı olarak tutulmaktadır. Ana netDb sayfası güncel yol haritasını ve tasarımla ilgili değerlendirmeleri takip eder.\n13 Mart 2008\u0026rsquo;de yalnızca bir kullanılabilir floodfill router\u0026rsquo;ın bulunduğu bir süre gibi operasyonel olaylar, 0.6.1.33 ile 0.7.x arasındaki sürümlerde sunulan çeşitli iyileştirmelere yol açtı; bunlar arasında şunlar vardı:\nAramalarda floodfill seçimini rastgeleleştirme ve yanıt veren eşlere öncelik verme router konsolu \u0026ldquo;Profiles\u0026rdquo; sayfasında ek floodfill metriklerinin görüntülenmesi floodfill bant genişliği kullanımını azaltmak için netDb giriş boyutunda kademeli azaltımlar profil verileri aracılığıyla toplanan performansa dayalı olarak sınıf O router\u0026rsquo;larının bir alt kümesi için otomatik opt-in (isteğe bağlı katılım) Geliştirilmiş engelleme listesi yönetimi, floodfill eş seçimi ve keşif sezgisel yöntemleri O dönemden kalan fikirler arasında şunlar vardı:\nfloodfill eşlerini daha iyi derecelendirmek ve seçmek için dbHistory istatistiklerini kullanma Başarısız olan eşlerle tekrar tekrar iletişime geçmekten kaçınmak için yeniden deneme davranışını iyileştirme Seçimde gecikme ölçümleri ve entegrasyon puanlarından yararlanma Başarısız olan floodfill router\u0026rsquo;ları daha hızlı tespit etme ve tepki verme Yüksek bant genişlikli ve floodfill düğümlerindeki kaynak gereksinimlerini azaltmaya devam etme Bu notların yazıldığı sırada bile, ağ dayanıklı kabul ediliyordu ve düşmanca floodfill\u0026rsquo;lere veya floodfill hedefli hizmet reddi saldırılarına hızla karşılık vermek için gerekli altyapı mevcuttu.\nEk Notlar router konsolu, floodfill güvenilirliğinin analiz edilmesine yardımcı olmak için geliştirilmiş profil verilerini uzun süredir sunmaktadır. Tarihsel yorumlar Kademlia (bir DHT algoritması) veya alternatif DHT şemeleri üzerine spekülasyon yapmış olsa da, floodfill üretim ağları için birincil algoritma olarak kalmıştır. Geleceğe dönük araştırmalar, kötüye kullanma fırsatlarını sınırlarken floodfill\u0026rsquo;e kabulü uyarlanabilir hâle getirmeye odaklandı. ","description":"floodfill, Kademlia deneyleri ve netDb için gelecekte yapılacak ayarlamalar hakkında tarihsel notlar","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"Ağ Veritabanı Tartışması","url":"/tr/docs/netdb/"},{"categories":null,"content":"Genel Bakış I2P Streaming Library (Akış Kütüphanesi), I2P\u0026rsquo;nin mesaj katmanı üzerinde güvenilir, sıralı ve kimliği doğrulanmış iletim sağlar; IP üzerinden TCP\u0026lsquo;ye benzer şekilde çalışır. I2CP protokolü \u0026rsquo;nün üstünde yer alır ve HTTP proxy\u0026rsquo;leri, IRC, BitTorrent ve e-posta dahil olmak üzere neredeyse tüm etkileşimli I2P uygulamaları tarafından kullanılır.\nTemel Özellikler Gidiş-dönüş sayısını azaltmak için yük verisiyle birlikte paketlenebilen SYN, ACK ve FIN bayraklarını kullanan tek fazlı bağlantı kurulumu. I2P\u0026rsquo;nin yüksek gecikmeli ortamına uyarlanmış yavaş başlangıç ve tıkanıklık önleme ile kayan pencere tıkanıklık kontrolü. Yeniden iletim maliyeti ve parçalanma gecikmesi arasında denge kuran paket sıkıştırma (varsayılan 4KB sıkıştırılmış segmentler). I2P destinasyonları arasında tamamen kimliği doğrulanmış, şifrelenmiş ve güvenilir kanal soyutlaması. Bu tasarım, küçük HTTP isteklerinin ve yanıtlarının tek bir gidiş-dönüş içinde tamamlanmasını sağlar. Bir SYN paketi istek yükünü taşıyabilirken, yanıtlayanın SYN/ACK/FIN paketi tam yanıt gövdesini içerebilir.\nAPI Temelleri Java streaming API\u0026rsquo;si standart Java soket programlamayı yansıtır:\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory, I2CP üzerinden bir router oturumunu müzakere eder veya yeniden kullanır. Eğer bir anahtar sağlanmazsa, yeni bir destination otomatik olarak oluşturulur. Geliştiriciler, I2CP seçeneklerini (örn. tunnel uzunlukları, şifreleme türleri veya bağlantı ayarları) options haritası aracılığıyla iletebilirler. I2PSocket ve I2PServerSocket, standart Java Socket arayüzlerini yansıtarak geçişi kolaylaştırır. Tam Javadocs belgeleri I2P router konsolundan veya buradan erişilebilir.\nYapılandırma ve Ayarlama Bir socket manager oluştururken yapılandırma özelliklerini şu şekilde iletebilirsiniz:\nI2PSocketManagerFactory.createManager(host, port, properties); Anahtar Seçenekleri Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false ### İş Yüküne Göre Davranış Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. Sürüm 0.9.4'ten bu yana eklenen yeni özellikler arasında reddetme günlüğü bastırma, DSA liste desteği (0.9.21) ve zorunlu protokol uygulaması (0.9.36) bulunmaktadır. 2.10.0 sürümünden itibaren router'lar, aktarım katmanında kuantum sonrası hibrit şifreleme (ML-KEM + X25519) içermektedir. Protokol Detayları Her akış bir Stream ID (Akış Kimliği) ile tanımlanır. Paketler TCP\u0026rsquo;ye benzer kontrol bayrakları taşır: SYNCHRONIZE, ACK, FIN ve RESET. Paketler aynı anda hem veri hem de kontrol bayrakları içerebilir, bu da kısa ömürlü bağlantılar için verimliliği artırır.\nBağlantı Yaşam Döngüsü SYN gönderildi — başlatıcı isteğe bağlı veri içerir. SYN/ACK yanıtı — yanıtlayıcı isteğe bağlı veri içerir. ACK sonlandırması — güvenilirlik ve oturum durumunu oluşturur. FIN/RESET — düzenli kapanış veya ani sonlandırma için kullanılır. Parçalama ve Yeniden Sıralama I2P tünelleri gecikme ve mesaj yeniden sıralamasına neden olduğundan, kütüphane bilinmeyen veya erken gelen akışlardan paketleri tamponlar. Tamponlanmış mesajlar senkronizasyon tamamlanana kadar saklanır ve böylece eksiksiz, sıralı teslimat sağlanır.\nProtokol Uygulaması i2p.streaming.enforceProtocol=true seçeneği (0.9.36 sürümünden beri varsayılan) bağlantıların doğru I2CP protokol numarasını kullanmasını sağlar ve tek bir hedefi paylaşan birden fazla alt sistem arasındaki çakışmaları önler.\nBirlikte Çalışabilirlik ve En İyi Uygulamalar Akış protokolü Datagram API ile birlikte çalışır ve geliştiricilere bağlantı yönelimli ve bağlantısız aktarım yöntemleri arasında seçim yapma imkanı sunar.\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram ### Paylaşımlı İstemciler Uygulamalar, paylaşımlı istemciler olarak çalışarak mevcut tunnel\u0026rsquo;ları yeniden kullanabilir, bu sayede birden fazla hizmetin aynı hedefi paylaşmasına olanak tanır. Bu yöntem yükü azaltırken, hizmetler arası ilişkilendirme riskini artırır—dikkatli kullanın.\nTıkanıklık Kontrolü Streaming katmanı, RTT tabanlı geri bildirim yoluyla ağ gecikmesine ve verimi sürekli olarak uyarlar. Uygulamalar, yönlendiriciler katkıda bulunan eşler olduğunda (katılımcı tüneller etkinleştirildiğinde) en iyi performansı gösterir. TCP benzeri tıkanıklık kontrol mekanizmaları, yavaş eşlerin aşırı yüklenmesini önler ve tüneller arasında bant genişliği kullanımını dengelemeye yardımcı olur. Gecikme Süreleri Hakkında Dikkat Edilmesi Gerekenler I2P birkaç yüz milisaniyelik temel gecikme eklediğinden, uygulamalar gidiş-dönüş sayısını en aza indirmelidir. Mümkün olduğunda verileri bağlantı kurulumu ile birleştirin (örneğin, SYN içinde HTTP istekleri). Birçok küçük sıralı veri alışverişine dayanan tasarımlardan kaçının.\nTest ve Uyumluluk Tam uyumluluğu sağlamak için her zaman hem Java I2P hem de i2pd\u0026lsquo;ye karşı test edin. Protokol standardize edilmiş olsa da küçük uygulama farklılıkları bulunabilir. Eski router\u0026rsquo;ları nazikçe ele alın—birçok eş hala 2.0 öncesi sürümleri çalıştırıyor. RTT ve yeniden iletim metriklerini okumak için I2PSocket.getOptions() ve getSession() kullanarak bağlantı istatistiklerini izleyin. Performans, tünel yapılandırmasına büyük ölçüde bağlıdır: - Kısa tunneller (1–2 hop) → düşük gecikme, azaltılmış anonimlik. - Uzun tunneller (3+ hop) → yüksek anonimlik, artmış RTT.\nTemel İyileştirmeler (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. --- Özet I2P Streaming Library, I2P içindeki tüm güvenilir iletişimin omurgasıdır. Sıralı, kimliği doğrulanmış, şifrelenmiş mesaj teslimatını sağlar ve anonim ortamlarda TCP için neredeyse hazır bir alternatif sunar.\nOptimum performans elde etmek için: - SYN+payload paketlemesi ile gidiş-dönüş sayısını minimize edin. - Pencere ve zaman aşımı parametrelerini iş yükünüze göre ayarlayın. - Gecikmeye duyarlı uygulamalar için daha kısa tunnel\u0026rsquo;ları tercih edin. - Eşleri (peer) aşırı yüklemekten kaçınmak için tıkanıklık dostu tasarımlar kullanın.\n","description":"Çoğu I2P uygulaması tarafından kullanılan TCP benzeri taşıma protokolü","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"Akış Protokolü","url":"/tr/docs/api/streaming/"},{"categories":null,"content":"Genel Bakış I2P Streaming Library (I2P Akış Kütüphanesi), I2P\u0026rsquo;nin güvenilir olmayan mesaj katmanının üzerinde — IP üzerinde TCP\u0026rsquo;ye benzer şekilde — güvenilir, sıralı ve kimliği doğrulanmış veri iletimi sağlar. Web gezintisi, IRC, e-posta ve dosya paylaşımı gibi etkileşimli I2P uygulamalarının neredeyse tamamı tarafından kullanılır.\nI2P’nin yüksek gecikmeli anonim tunnel’ları üzerinden güvenilir iletim, tıkanıklık denetimi, yeniden iletim ve akış kontrolü sağlar. Her akış, hedefler arasında uçtan uca tamamen şifrelenir.\nTemel Tasarım İlkeleri Akış kitaplığı, tek aşamalı bir bağlantı kurulumu uygular; burada SYN, ACK ve FIN bayrakları aynı mesajda veri yükleri taşıyabilir. Bu, yüksek gecikmeli ortamlarda gidiş-dönüşleri en aza indirir — küçük bir HTTP işlemi tek bir gidiş-dönüşte tamamlanabilir.\nTıkanıklık kontrolü ve yeniden iletim, TCP örnek alınarak modellenmiş, ancak I2P\u0026rsquo;nin ortamına uyarlanmıştır. Pencere boyutları bayt tabanlı değil, mesaj tabanlıdır ve tunnel gecikmesi ile ek yüke göre ayarlanmıştır. Protokol, TCP\u0026rsquo;nin AIMD algoritmasına benzer şekilde yavaş başlangıç, tıkanıklık önleme ve üstel geri çekilme destekler.\nMimari Akış kitaplığı, uygulamalar ile I2CP arayüzü arasında çalışır.\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels Çoğu kullanıcı ona I2PSocketManager, I2PTunnel ya da SAMv3 aracılığıyla erişir. Kütüphane, destination (hedef) yönetimi, tunnel kullanımı ve yeniden iletimleri şeffaf bir şekilde ele alır. Paket Formatı +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | Başlık Ayrıntıları Akış Kimlikleri: Yerel ve uzak akışları benzersiz şekilde tanımlayan 32-bit değerler. Sıra Numarası: SYN için 0\u0026rsquo;dan başlar, mesaj başına artar. Ack Through: (kümülatif onay) N değerine kadar olan tüm mesajları, NACK (olumsuz onay) listesindekiler hariç, onaylar. Bayraklar: Durumu ve davranışı kontrol eden bit maskesi. Seçenekler: RTT, MTU ve protokol görüşmesi için değişken uzunluklu liste. Anahtar Bayrakları Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive --- Akış Kontrolü ve Güvenilirlik Streaming, TCP\u0026rsquo;nin bayt tabanlı yaklaşımının aksine, mesaj tabanlı pencereleme kullanır. Aktarım halindeki onaylanmamış paketlere izin verilen sayı, mevcut pencere boyutuna eşittir (varsayılan 128).\nMekanizmalar Tıkanıklık kontrolü: Yavaş başlangıç ve AIMD (Toplamsal Artış, Çarpımsal Azalış) tabanlı kaçınma. Choke/Unchoke: Arabellek doluluğuna dayalı akış kontrolü sinyallemesi. Yeniden iletim: RFC 6298 tabanlı RTO (yeniden iletim zaman aşımı) hesaplaması ve üstel geri çekilme. Yinelenenleri filtreleme: Potansiyel olarak yeniden sıralanmış iletiler üzerinde güvenilirliği sağlar. Tipik yapılandırma değerleri:\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout --- Bağlantı Kurulumu Başlatıcı bir SYN gönderir (isteğe bağlı olarak payload (yük) ve FROM_INCLUDED ile). Yanıtlayıcı SYN+ACK ile yanıt verir (payload içerebilir). Başlatıcı kurulumu teyit eden son ACK\u0026rsquo;i gönderir. İsteğe bağlı başlangıç yükleri, tam el sıkışma tamamlanmadan önce veri iletimine izin verir.\nGerçekleme Ayrıntıları Yeniden İletim ve Zaman Aşımı Yeniden iletim algoritması RFC 6298\u0026rsquo;e uyar. - Başlangıç RTO\u0026rsquo;su: 9s - Minimum RTO: 100ms - Maksimum RTO: 45s - Alfa: 0.125 - Beta: 0.25\nKontrol Bloğu Paylaşımı Aynı eşe yapılan sonraki bağlantılar, daha hızlı artış için önceki RTT (gidiş-dönüş süresi) ve pencere verilerini yeniden kullanarak “soğuk başlangıç” gecikmesinden kaçınır. Kontrol bloklarının süresi birkaç dakika içinde dolar.\nMTU ve Parçalama Varsayılan MTU: 1730 bayt (iki I2NP mesajına sığar). ECIES (Elliptic Curve Integrated Encryption Scheme - Eliptik Eğri Entegre Şifreleme Şeması) hedefleri: 1812 bayt (azaltılmış ek yük). Minimum desteklenen MTU: 512 bayt. Faydalı yük boyutu, 22 baytlık asgari akış başlığını içermez.\nSürüm Geçmişi Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) --- Uygulama Düzeyinde Kullanım Java Örneği Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); SAMv3 ve i2pd Desteği SAMv3: Java dışı istemciler için STREAM ve DATAGRAM kipleri sağlar. i2pd: Yapılandırma dosyası seçenekleri aracılığıyla aynı akış parametrelerini sunar (örn. i2p.streaming.maxWindowSize, profile, vb.) Akış ve Datagramlar Arasında Seçim Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn --- Güvenlik ve Post-Kuantum Gelecek Akış oturumları I2CP katmanında uçtan uca şifrelenir. Post-kuantum hibrit şifreleme (ML-KEM + X25519) 2.10.0 sürümünde deneysel olarak desteklenir ancak varsayılan olarak devre dışıdır.\nKaynaklar Streaming API Genel Bakış Streaming Protokolü Belirtimi I2CP Belirtimi Öneri 144: Streaming MTU Hesaplamaları I2P 2.10.0 Sürüm Notları ","description":"Çoğu I2P uygulaması tarafından kullanılan, TCP benzeri güvenilir bir taşıma protokolü","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"Akış Protokolü","url":"/tr/docs/specs/streaming/"},{"categories":null,"content":"Ana I2P istemci uygulaması Java kullanır. Belirli bir sistemde Java kullanamıyor veya kullanmayı tercih etmiyorsanız, topluluk üyeleri tarafından geliştirilen ve sürdürülen alternatif I2P istemci uygulamaları mevcuttur. Bu programlar, farklı programlama dilleri veya yaklaşımlar kullanarak aynı temel işlevselliği sağlar.\nKarşılaştırma Tablosu Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements --- i2pd (C++) Web Sitesi: https://i2pd.website Açıklama: i2pd (I2P Daemon) C++ ile geliştirilmiş tam özellikli bir I2P istemcisidir. Uzun yıllardır (yaklaşık 2016\u0026rsquo;dan beri) üretim ortamında kullanım için kararlı durumdadır ve topluluk tarafından aktif olarak sürdürülmektedir. i2pd, I2P ağ protokollerini ve API\u0026rsquo;lerini tam olarak uygular, bu da Java I2P ağıyla tamamen uyumlu olmasını sağlar. Bu C++ router genellikle Java çalışma ortamının bulunmadığı veya istenmediği sistemlerde hafif bir alternatif olarak kullanılır. i2pd, yapılandırma ve izleme için yerleşik web tabanlı bir konsol içerir. Platformlar arası çalışır ve birçok paketleme formatında mevcuttur — hatta Android için bile bir i2pd sürümü bulunmaktadır (örneğin, F-Droid üzerinden).\nGo-I2P (Go) Depo: https://github.com/go-i2p/go-i2p Açıklama: Go-I2P, Go programlama dilinde yazılmış bir I2P istemcisidir. I2P router\u0026rsquo;ının bağımsız bir uygulamasıdır ve Go\u0026rsquo;nun verimliliği ve taşınabilirliğinden yararlanmayı amaçlar. Proje aktif geliştirme aşamasındadır, ancak hala erken aşamadadır ve henüz tüm özellikleri tamamlanmamıştır. 2025 itibariyle, Go-I2P deneysel olarak kabul edilmektedir — topluluk geliştiricileri tarafından aktif olarak üzerinde çalışılmaktadır, ancak daha fazla olgunlaşana kadar üretim ortamında kullanılması önerilmez. Go-I2P\u0026rsquo;nin amacı, geliştirme tamamlandığında I2P ağı ile tam uyumlu, modern ve hafif bir I2P router sağlamaktır.\nI2P+ (Java çatalı) Web sitesi: https://i2pplus.github.io Açıklama: I2P+, standart Java I2P istemcisinin topluluk tarafından sürdürülen bir çatallamasıdır (fork). Yeni bir dilde yeniden uygulama değil, ek özellikler ve optimizasyonlarla geliştirilmiş Java router\u0026rsquo;ının bir sürümüdür. I2P+, resmi I2P ağıyla tamamen uyumlu kalırken geliştirilmiş kullanıcı deneyimi ve daha iyi performans sunmaya odaklanır. Yenilenmiş bir web konsolu arayüzü, daha kullanıcı dostu yapılandırma seçenekleri ve çeşitli optimizasyonlar (örneğin, geliştirilmiş torrent performansı ve özellikle güvenlik duvarı arkasındaki router\u0026rsquo;lar için daha iyi ağ eşleri yönetimi) sunar. I2P+, resmi I2P yazılımı gibi bir Java ortamı gerektirir, dolayısıyla Java olmayan ortamlar için bir çözüm değildir. Ancak, Java\u0026rsquo;ya sahip olan ve ekstra yeteneklere sahip alternatif bir yapı isteyen kullanıcılar için I2P+ cazip bir seçenek sunar. Bu çatallama, upstream I2P sürümleriyle güncel tutulmaktadır (sürüm numaralandırmasına \u0026ldquo;+\u0026rdquo; ekleyerek) ve projenin web sitesinden edinilebilir.\n","description":"Topluluk tarafından sürdürülen I2P istemci uygulamaları (2025 için güncellenmiş)","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"Alternatif I2P İstemcileri","url":"/tr/docs/overview/alternative-clients/"},{"categories":null,"content":"Genel Bakış Bu belge, I2P blockfile (blok dosyası) dosya formatını ve Blockfile Adlandırma Hizmeti tarafından kullanılan hostsdb.blockfile içindeki tabloları tanımlar. Arka plan bilgisi için I2P Adlandırma ve Adres Defteri sayfasına bakın.\nblockfile (blok dosyası), kompakt bir ikili biçimde hızlı destination (hedef) sorgulamaları sağlar. Eski hosts.txt sistemine kıyasla:\nHedefler Base64 olarak değil, ikili biçimde saklanır. Keyfi meta veriler (ör. eklenme tarihi, kaynak, yorumlar) eklenebilir. Arama süreleri yaklaşık olarak 10× daha hızlıdır. Disk kullanımı hafifçe artar. Bir blockfile (blok dosyası), disk üzerinde bulunan sıralı eşlemelerden (anahtar-değer çiftleri) oluşan ve skiplists (atlama listeleri) kullanılarak uygulanmış bir koleksiyondur. Metanotion Blockfile Database ’ten türetilmiştir. Bu belirtim önce dosya yapısını tanımlar, ardından BlockfileNamingService tarafından nasıl kullanıldığını açıklar.\nBlockfile Naming Service (Blockfile Adlandırma Hizmeti), I2P 0.8.8 sürümünde eski hosts.txt uygulamasının yerini aldı. \u0026gt; Başlatma sırasında privatehosts.txt, userhosts.txt ve hosts.txt dosyalarındaki kayıtları içe aktarır.\nBlockfile Biçimi Biçim, 1024 baytlık sayfalardan oluşur, her birinin başına bütünlüğü sağlamak için bir sihirli sayı eklenmiştir. Sayfalar 1\u0026rsquo;den başlayarak numaralandırılır:\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) Tüm tam sayılar **ağ bayt sırası (big-endian)** kullanır. 2 baytlık değerler işaretsizdir; 4 baytlık değerler (sayfa numaraları) işaretlidir ve pozitif olmalıdır. İş parçacığı modeli: Veritabanı tek iş parçacıklı erişim için tasarlanmıştır; BlockfileNamingService senkronizasyon sağlar.\nSüperblok Biçimi Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused --- Atlama Listesi Blok Sayfa Biçimi Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused --- Atla Seviye Blok Sayfa Biçim Her seviyenin bir aralığı vardır, ancak her aralığın bir seviyesi yoktur.\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused --- Skip Span Blok Sayfa Biçimi Anahtar/değer çiftleri, spans (aralıklar) genelinde anahtara göre sıralanır. İlki dışındaki spans boş olmamalıdır.\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures --- Span Devam Bloğu Sayfa Biçimi Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures --- Anahtar/Değer Yapısının Biçimi Anahtar ve değer uzunluk alanları sayfa sınırını aşamaz (tüm 4 bayt sığmalıdır). Kalan alan yetersizse, en fazla 3 bayt dolgu ekleyin ve sonraki sayfanın 8 ofsetinden devam edin.\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each --- Serbest Liste Blok Sayfası Biçimi Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) --- Serbest Sayfa Bloğu Biçimi Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused --- Meta Dizin Sayfa 2\u0026rsquo;de bulunur. US-ASCII dizgelerini → 4 baytlık tamsayılara eşler. Anahtar, skiplist (atlamalı liste) adıdır; değer ise sayfa indeksidir.\nBlockfile (blok dosyası) Adlandırma Hizmeti Tabloları Hizmet birden çok skiplist (atlama listesi) tanımlar. Her aralık en fazla 16 öğeyi destekler.\nÖzellikler Atlama Listesi %%__INFO__%% tek bir girdi içerir:\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping Tipik alanlar: Property Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) --- Tersine Arama Skiplist (atlamalı liste) %%__REVERSE__%% Tamsayı → Özellikler girdileri içerir (DB v2\u0026rsquo;den beri).\nAnahtar: Destination\u0026rsquo;ın (I2P hedefi) SHA-256 karmasının ilk 4 baytı. Değer: Özellikler nesnesi (serileştirilmiş eşleme). Birden çok girdi, çakışmaları ve birden fazla ana bilgisayar adına sahip Destination nesnelerini işler. Her özellik anahtarı = ana bilgisayar adı; değer = boş dize. Ana Makine Veritabanı Skiplists (atlamalı listeler) hosts.txt, userhosts.txt ve privatehosts.txt dosyalarının her biri ana makine adlarını → Destination\u0026rsquo;lara (I2P hedef adresleri) eşler.\nSürüm 4, bir ana makine adı başına birden fazla Destinations (hedef adres) destekler (I2P 0.9.26 ile birlikte getirildi). Sürüm 3 veritabanları otomatik olarak taşınır.\nAnahtar UTF-8 dizesi (ana makine adı, küçük harfli, .i2p ile biten)\nDeğer Sürüm 4: Özellik/Hedef çiftlerinin sayısı (1 bayt) Her çift için: Özellikler → Hedef (ikili) Sürüm 3: Özellikler → Hedef (ikili) DestEntry Özellikleri Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) --- Uygulama Notları BlockfileNamingService Java sınıfı bu spesifikasyonu uygular.\nrouter bağlamı dışında, i2p.naming.blockfile.writeInAppContext=true olmadıkça veritabanı salt-okunur olarak açılır. multi-instance (birden çok örnek) veya multi-JVM (birden çok JVM) erişimi için tasarlanmamıştır. Üç birincil map (anahtar-değer haritası) (privatehosts, userhosts, hosts) ve hızlı aramalar için bir reverse map (ters harita) tutar. Kaynaklar I2P Adlandırma ve Adres Defteri Belgeleri Ortak Yapılar Spesifikasyonu Metanotion Blockfile Veritabanı BlockfileNamingService JavaDoc ","description":"I2P tarafından ana bilgisayar adı çözümlemesi için kullanılan disk üzerinde blockfile (blok dosyası) depolama biçimi","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"Blockfile Şartnamesi","url":"/tr/docs/specs/blockfile/"},{"categories":null,"content":" Uyarı: BOB yalnızca eski DSA-SHA1 imza türünü destekler. Java I2P, 1.7.0 (2022-02) sürümünde BOB\u0026rsquo;u dağıtmayı bıraktı; BOB yalnızca 1.6.1 veya daha önceki sürümlerle başlatılmış kurulumlarda ve bazı i2pd derlemelerinde bulunmaktadır. Yeni uygulamalar SAM v3 kullanmalıdır.\nDil Bağlamaları Go – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp Protokol Notları KEYS, base64 bir destination\u0026rsquo;ı (I2P adresi; açık + özel anahtarlar) ifade eder. KEY, base64 bir açık anahtardır. ERROR yanıtları ERROR \u0026lt;description\u0026gt;\\n biçimindedir. OK, komutun tamamlandığını belirtir; isteğe bağlı veriler aynı satırda yer alır. DATA satırları, son OK\u0026lsquo;tan önce ek çıktıyı akış halinde iletir. help komutu tek istisnadır: “böyle bir komut yok” olduğunu bildirmek için hiçbir şey döndürmeyebilir.\nBağlantı Karşılama Mesajı BOB, satır sonu karakteriyle sonlandırılmış ASCII satırlar (LF veya CRLF) kullanır. Bağlantı kurulduğunda şunu gönderir:\nBOB \u0026lt;version\u0026gt; OK Geçerli sürüm: 00.00.10. Önceki yapılar büyük harfli onaltılık basamaklar ve standart dışı numaralandırma kullanırdı.\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds ## Temel Komutlar Tam komut ayrıntıları için telnet localhost 2827 kullanarak bağlanın ve help komutunu çalıştırın.\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK Kullanımdan Kaldırma Özeti BOB modern imza türleri, şifrelenmiş LeaseSets veya taşıma katmanı özellikleri için destek sunmaz. API dondurulmuştur; yeni komutlar eklenmeyecektir. Hâlâ BOB\u0026rsquo;a dayanan uygulamalar mümkün olan en kısa sürede SAM v3\u0026rsquo;e geçmelidir. ","description":"Destination (I2P'de hedef/kimlik) yönetimi için kullanımdan kaldırılmış API (kullanımdan kaldırıldı)","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – Basic Open Bridge (Temel Açık Köprü)","url":"/tr/docs/legacy/bob/"},{"categories":null,"content":"Genel Bakış Datagramlar, I2CP üzerinde ve streaming kütüphanesine paralel olarak mesaj odaklı iletişim sağlar. Bağlantı odaklı stream\u0026rsquo;ler gerektirmeden yanıtlanabilir, doğrulanmış veya ham paketleri mümkün kılarlar. Router\u0026rsquo;lar, trafiği NTCP2 veya SSU2\u0026rsquo;nin taşımasına bakılmaksızın, datagramları I2NP mesajlarına ve tunnel mesajlarına kapsüller.\nTemel motivasyon, uygulamaların (tracker\u0026rsquo;lar, DNS çözümleyiciler veya oyunlar gibi) gönderenlerini tanımlayan bağımsız paketler göndermelerine izin vermektir.\n2025\u0026rsquo;te Yeni: I2P Projesi, on yıl içinde ilk kez tekrar oynatma koruması ve daha düşük yük gerektiren yanıtlanabilir mesajlaşma ekleyen Datagram2 (protokol 19) ve Datagram3 (protokol 20)\u0026lsquo;yi onayladı.\n1. Protokol Sabitleri Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) Protokol 19 ve 20, **Öneri 163 (Nisan 2025)** ile resmileştirildi. Geriye dönük uyumluluk için Datagram1 / RAW ile birlikte bulunurlar. 2. Datagram Türleri Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. ### Tipik Tasarım Kalıpları İstek → Yanıt: İmzalı bir Datagram2 gönderin (istek + nonce), ham veya Datagram3 yanıtı alın (nonce\u0026rsquo;u yankılayın). Yüksek frekanslı/düşük yük: Datagram3 veya RAW tercih edin. Kimlik doğrulamalı kontrol mesajları: Datagram2. Eski sürüm uyumluluğu: Datagram1 hala tam olarak desteklenmektedir. 3. Datagram2 ve Datagram3 Detayları (2025) Datagram2 (Protokol 19) Datagram1 için geliştirilmiş yedek. Özellikler: - Tekrar saldırısı önleme: 4 baytlık tekrar önleme belirteci. - Çevrimdışı imza desteği: çevrimdışı imzalı Destination\u0026rsquo;lar tarafından kullanımı mümkün kılar. - Genişletilmiş imza kapsamı: destination hash\u0026rsquo;i, bayrakları, seçenekleri, çevrimdışı imza bloğunu ve yükü içerir. - Kuantum sonrası hazır: gelecekteki ML-KEM hibrit çözümleriyle uyumlu. - Ek yük: ≈ 457 bayt (X25519 anahtarları).\nDatagram3 (Protokol 20) Ham ve imzalı tipler arasındaki boşluğu kapatır. Özellikler: - İmzasız yanıtlanabilir: gönderenin 32-byte hash\u0026rsquo;ini + 2-byte bayrakları içerir. - Küçük ek yük: ≈ 34 byte. - Tekrar saldırısı koruması yok — uygulama tarafından uygulanmalıdır.\nHer iki protokol de API 0.9.66 özellikleridir ve Sürüm 2.9.0\u0026rsquo;dan beri Java router\u0026rsquo;ında uygulanmıştır; henüz i2pd veya Go uygulamaları yoktur (Ekim 2025).\n4. Boyut ve Parçalama Sınırları Tunnel mesaj boyutu: 1 028 bayt (4 B Tunnel ID + 16 B IV + 1 008 B yük verisi). İlk parça: 956 B (tipik TUNNEL teslimi). Takip eden parça: 996 B. Maksimum parça sayısı: 63–64. Pratik sınır: ≈ 62 708 B (~61 KB). Önerilen sınır: Güvenilir teslimat için ≤ 10 KB (bu değerin ötesinde kayıplar üstel olarak artar). Ek yük özeti: - Datagram1 ≈ 427 B (minimum). - Datagram2 ≈ 457 B. - Datagram3 ≈ 34 B. - Ek katmanlar (I2CP gzip başlığı, I2NP, Garlic, Tunnel): + ~5,5 KB en kötü durumda.\n5. I2CP / I2NP Entegrasyonu Mesaj yolu: 1. Uygulama datagram oluşturur (I2P API veya SAM aracılığıyla). 2. I2CP, gzip başlığı (0x1F 0x8B 0x08, RFC 1952) ve CRC-32 sağlama toplamı ile sarar. 3. Protokol + Port numaraları gzip başlık alanlarında saklanır. 4. Router, I2NP mesajı → Garlic clove → 1 KB tunnel parçaları olarak kapsüller. 5. Parçalar outbound → ağ → inbound tunnel üzerinden geçer. 6. Yeniden birleştirilen datagram, protokol numarasına göre uygulama işleyicisine teslim edilir.\nBütünlük: CRC-32 (I2CP\u0026rsquo;den) + isteğe bağlı kriptografik imza (Datagram1/2). Datagram\u0026rsquo;ın kendisi içinde ayrı bir sağlama toplamı alanı yoktur.\n6. Programlama Arayüzleri Java API net.i2p.client.datagram paketi şunları içerir: - I2PDatagramMaker – imzalı datagramlar oluşturur. - I2PDatagramDissector – gönderen bilgisini doğrular ve çıkarır. - I2PInvalidDatagramException – doğrulama başarısız olduğunda fırlatılır.\nI2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl), bir Destination\u0026rsquo;ı paylaşan uygulamalar için protokol ve port çoklama (multiplexing) işlemini yönetir.\nJavadoc erişimi: - idk.i2p Javadoc (yalnızca I2P ağı) - Javadoc Yansı (clearnet yansısı) - Resmi Javadocs (resmi belgeler)\nSAM v3 Desteği SAM 3.2 (2016): PORT ve PROTOCOL parametreleri eklendi. SAM 3.3 (2016): PRIMARY/alt oturum modeli tanıtıldı; bir Destination üzerinde akışlar + datagramlara izin verir. Datagram2 / 3 oturum stilleri için destek 2025 spesifikasyonuna eklendi (uygulama beklemede). Resmi spesifikasyon: SAM v3 Specification i2ptunnel Modülleri udpTunnel: I2P UDP uygulamaları için tamamen işlevsel temel (net.i2p.i2ptunnel.udpTunnel). streamr: A/V akışı için çalışır durumda (net.i2p.i2ptunnel.streamr). SOCKS UDP: 2.10.0 sürümü itibariyle işlevsel değil (yalnızca UDP taslağı). Genel amaçlı UDP için Datagram API veya udpTunnel\u0026rsquo;ı doğrudan kullanın—SOCKS UDP\u0026rsquo;ye güvenmeyin.\n7. Ekosistem ve Dil Desteği (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental Java I2P şu anda tam SAM 3.3 alt oturumlarını ve Datagram2 API'sini destekleyen tek router'dır. 8. Örnek Kullanım – UDP Tracker (I2PSnark 2.10.0) Datagram2/3\u0026rsquo;ün ilk gerçek dünya uygulaması:\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return Desen, güvenlik ve performansı dengelemek için doğrulanmış ve hafif datagramların karma kullanımını gösterir. 9. Güvenlik ve En İyi Uygulamalar Kimlik doğrulaması gerektiren veya tekrar saldırılarının önemli olduğu durumlarda Datagram2 kullanın. Orta düzeyde güven ile hızlı yanıtlanabilir cevaplar için Datagram3\u0026rsquo;ü tercih edin. Genel yayınlar veya anonim veri için RAW kullanın. Güvenilir teslimat için yükleri ≤ 10 KB tutun. SOCKS UDP\u0026rsquo;nin çalışmadığını unutmayın. Alındığında her zaman gzip CRC ve dijital imzaları doğrulayın. 10. Teknik Özellikler Bu bölüm, düşük seviyeli datagram formatlarını, kapsüllemeyi ve protokol ayrıntılarını kapsar.\n10.1 Protokol Tanımlama Datagram formatları ortak bir başlık paylaşmaz. Router\u0026rsquo;lar sadece yük baytlarından türü çıkaramaz.\nBirden fazla datagram türünü karıştırırken—veya datagramları akış ile birleştirirken—açıkça ayarlayın: - Protokol numarasını (I2CP veya SAM aracılığıyla) - Uygulamanız hizmetleri çoğulluyorsa isteğe bağlı olarak port numarasını\nProtokolü ayarlanmamış bırakmak (0 veya PROTO_ANY) önerilmez ve yönlendirme veya iletim hatalarına yol açabilir.\n10.2 Ham Datagramlar Yanıtlanamaz datagramlar gönderen veya kimlik doğrulama verisi taşımaz. Bunlar opak yüklerdir, üst düzey datagram API\u0026rsquo;sinin dışında işlenir ancak SAM ve I2PTunnel aracılığıyla desteklenir.\nProtokol: 18 (PROTO_DATAGRAM_RAW)\nBiçim:\n+----+----+----+----+----// | payload... +----+----+----+----+----// Payload uzunluğu taşıma limitleriyle kısıtlanmıştır (pratik maksimum ≈32 KB, genellikle çok daha az).\n10.3 Datagram1 (Yanıtlanabilir Datagramlar) Gönderenin Destination bilgisini ve kimlik doğrulama ile yanıt adresleme için bir Signature içerir.\nProtokol: 17 (PROTO_DATAGRAM)\nEk Yük: ≥427 bayt Yük: ~31,5 KB\u0026rsquo;a kadar (taşıma ile sınırlı)\nFormat:\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from: bir Destination (387+ bayt) signature: anahtar tipiyle eşleşen bir İmza DSA_SHA1 için: Yükün SHA-256 hash\u0026rsquo;inin İmzası Diğer anahtar tipleri için: Doğrudan yük üzerindeki İmza Notlar: - DSA olmayan türler için imzalar I2P 0.9.14\u0026rsquo;te standartlaştırılmıştır. - LS2 (Öneri 123) çevrimdışı imzalar şu anda Datagram1\u0026rsquo;de desteklenmemektedir.\n10.4 Datagram2 Formatı Öneri 163 \u0026rsquo;te tanımlandığı gibi tekrar saldırısı direnci ekleyen geliştirilmiş yanıtlanabilir datagram.\nProtokol: 19 (PROTO_DATAGRAM2)\nUygulama devam etmektedir. Uygulamalar, yedeklilik için nonce veya zaman damgası kontrolleri içermelidir.\n10.5 Datagram3 Formatı Yanıtlanabilir ancak doğrulanmamış datagramlar sağlar. Gömülü hedef ve imza yerine router tarafından sağlanan oturum doğrulamasına dayanır.\nProtokol: 20 (PROTO_DATAGRAM3) Durum: 0.9.66\u0026rsquo;dan beri geliştirme aşamasında\nYararlı olduğu durumlar: - Hedefler büyük olduğunda (örn., kuantum sonrası anahtarlar) - Kimlik doğrulama başka bir katmanda gerçekleştiğinde - Bant genişliği verimliliği kritik olduğunda\n10.6 Veri Bütünlüğü Datagram bütünlüğü, I2CP katmanındaki gzip CRC-32 sağlama toplamı tarafından korunur. Datagram yük biçiminin içinde açık bir sağlama toplamı alanı bulunmaz.\n10.7 Paket Kapsülleme Her datagram, tek bir I2NP mesajı veya bir Garlic Message içinde ayrı bir clove olarak kapsüllenir. I2CP, I2NP ve tunnel katmanları uzunluk ve çerçeveleme işlemlerini yönetir — datagram protokolünde dahili bir sınırlayıcı veya uzunluk alanı bulunmaz.\n10.8 Kuantum Sonrası (PQ) Hususlar Eğer Proposal 169 (ML-DSA imzaları) uygulanırsa, imza ve hedef boyutları önemli ölçüde artacaktır — ~455 bayttan ≥3739 bayta çıkacaktır. Bu değişiklik datagram ek yükünü önemli ölçüde artıracak ve etkili yük kapasitesini azaltacaktır.\nDatagram3, oturum düzeyinde kimlik doğrulamaya dayanan (gömülü imzalar değil), kuantum-sonrası I2P ortamlarında muhtemelen tercih edilen tasarım haline gelecektir.\n11. Referanslar Öneri 163 – Datagram2 ve Datagram3 Öneri 160 – UDP Tracker Entegrasyonu Öneri 144 – Streaming MTU Hesaplamaları Öneri 169 – Kuantum Sonrası İmzalar I2CP Spesifikasyonu I2NP Spesifikasyonu Tunnel Mesajı Spesifikasyonu SAM v3 Spesifikasyonu i2ptunnel Dokümantasyonu 12. Değişiklik Günlüğü Öne Çıkanlar (2019 – 2025) Year Release Change 20190.9.43Datagram API stabilization 20210.9.50Protocol port handling reworked 20222.0.0SSU2 adoption completed 20242.6.0Legacy transport removal simplified UDP code 20252.9.0Datagram2/3 support added (Java API) 20252.10.0UDP Tracker implementation released --- 13. Özet Datagram alt sistemi artık tamamen kimlik doğrulamalı iletimden hafif ham iletişime kadar bir yelpaze sunan dört protokol varyantını desteklemektedir. Geliştiriciler, güvenlik açısından hassas kullanım senaryoları için Datagram2\u0026lsquo;ye ve verimli yanıtlanabilir trafik için Datagram3\u0026rsquo;e geçiş yapmalıdır. Uzun vadeli birlikte çalışabilirliği sağlamak için tüm eski türler uyumlu kalmaya devam etmektedir.\n","description":"I2CP üzerinde kimlik doğrulamalı, yanıtlanabilir ve ham mesaj formatları","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"Datagramlar","url":"/tr/docs/api/datagrams/"},{"categories":null,"content":" Durum: Bu sayfa eski “Low-level Cryptography Specification” belgesinin özetini sunar. Modern I2P sürümleri (2.10.0, Ekim 2025) yeni kriptografik ilkelere geçişi tamamladı. Uygulama ayrıntıları için ECIES , Encrypted LeaseSets , NTCP2 , Red25519 , SSU2 ve Tunnel Creation (ECIES) gibi uzmanlaşmış teknik belgelere başvurun.\nEvrim Anlık Görüntüsü Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) ## Asimetrik Şifreleme X25519 (eliptik eğri Diffie-Hellman anahtar değişimi algoritması) NTCP2, ECIES-X25519-AEAD-Ratchet, SSU2 ve X25519 tabanlı tunnel oluşturma için kullanılır. Noise protokol çerçevesi aracılığıyla kompakt anahtarlar, sabit zamanlı işlemler ve ileri gizlilik sağlar. 32 baytlık anahtarlar ve verimli anahtar değişimiyle 128 bit güvenlik sunar. ElGamal (Eski) Eski router\u0026rsquo;larla geriye dönük uyumluluk için korunmuştur. 2048 bitlik Oakley Group 14 asal sayısı (RFC 3526) üzerinde, üreteç 2 ile çalışır. AES oturum anahtarlarını ve IV\u0026rsquo;leri 514 baytlık şifreli metinler içinde şifreler. Kimliği doğrulanmış şifreleme ve ileri gizlilik yoktur; tüm modern uç noktalar ECIES\u0026rsquo;e geçmiştir. Simetrik Şifreleme ChaCha20/Poly1305 (ChaCha20 akış şifreleyicisi ve Poly1305 mesaj kimlik doğrulama koduna (MAC) dayalı doğrulanmış şifreleme (AEAD) şeması) NTCP2, SSU2 ve ECIES (Eliptik Eğri Entegre Şifreleme Şeması) genelinde varsayılan kimlik doğrulamalı şifreleme yapıtaşıdır. AES donanım desteği olmadan AEAD (İlişkili Verili Kimlik Doğrulamalı Şifreleme) güvenliği ve yüksek performans sağlar. RFC 7539’a göre uygulanmıştır (256‑bit anahtar, 96‑bit tek seferlik sayı, 128‑bit etiket). AES‑256/CBC (Eski) Hâlâ tunnel katmanı şifrelemesi için kullanılır; blok şifre yapısı I2P’nin katmanlı şifreleme modeline uygundur. PKCS#5 padding ve her atlama için IV dönüşümleri kullanır. Uzun vadeli bir inceleme için planlanmış olsa da kriptografik olarak sağlamlığını koruyor. İmzalar Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer ## Hash ve Anahtar Türetimi SHA‑256: DHT (Dağıtık Karma Tablosu) anahtarları, HKDF ve eski imzalar için kullanılır. SHA‑512: EdDSA/RedDSA tarafından ve Noise HKDF türetimlerinde kullanılır. HKDF‑SHA256: ECIES, NTCP2 ve SSU2 içinde oturum anahtarlarını türetir. Günlük olarak dönen SHA‑256 türetimleri, netDb içindeki RouterInfo (yönlendirici bilgisi) ve LeaseSet depolama konumlarını güvence altına alır. Taşıma Katmanı Özeti Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) Her iki taşıma, Noise_XK el sıkışma desenini kullanarak bağlantı düzeyinde ileri gizlilik (forward secrecy) ve yeniden oynatma koruması sağlar. Tunnel Katmanı Şifrelemesi Her atlama düzeyindeki katmanlı şifreleme için AES‑256/CBC kullanılmaya devam ediyor. Giden ağ geçitleri yinelemeli AES deşifre işlemi yapar; her atlama, kendi katman anahtarı ve IV (Initialization Vector - başlatma vektörü) anahtarını kullanarak yeniden şifreler. Çift IV şifreleme, korelasyon ve doğrulama saldırılarını hafifletir. AEAD (Authenticated Encryption with Associated Data - ilişkili verilerle kimliği doğrulanmış şifreleme) kullanımına geçiş inceleniyor, ancak şu anda planlanmıyor. Kuantum Sonrası Kriptografi I2P 2.10.0, deneysel hibrit post‑kuantum şifrelemeyi tanıtıyor. Test amacıyla Hidden Service Manager (Gizli Servis Yöneticisi) üzerinden elle etkinleştirilir. X25519’u kuantuma dayanıklı bir KEM ile birleştirir (hibrit mod). Varsayılan değildir; araştırma ve performans değerlendirmesi için tasarlanmıştır. Genişletilebilirlik Çerçevesi Şifreleme ve imza tür tanımlayıcıları birden fazla kriptografik ilkelin paralel olarak desteklenmesine olanak tanır. Mevcut eşleştirmeler şunları içerir: Şifreleme türleri: 0 = ElGamal/AES+SessionTags, 4 = ECIES‑X25519‑AEAD‑Ratchet. İmza türleri: 0 = DSA‑SHA1, 7 = EdDSA‑SHA512‑Ed25519, 11 = RedDSA‑SHA512‑Ed25519. Bu çerçeve, ağ bölünmeleri olmadan post‑quantum (kuantum sonrası) şemalar dahil gelecekteki yükseltmeleri mümkün kılar. Kriptografik Bileşim Taşıma katmanı: X25519 + ChaCha20/Poly1305 (Noise çerçevesi). Tunnel katmanı: Anonimlik için AES‑256/CBC katmanlı şifreleme. Uçtan uca: Gizlilik ve ileri gizlilik için ECIES‑X25519‑AEAD‑Ratchet. Veritabanı katmanı: Kimlik doğrulaması için EdDSA/RedDSA imzaları. Bu katmanlar derinlemesine savunma sağlar: bir katman kompromize edilse bile, diğerleri gizliliği ve ilişkilendirilemezliği korur.\nÖzet I2P 2.10.0 sürümünün kriptografik yığını şunlara odaklanır:\nCurve25519 (X25519) anahtar değişimi için ChaCha20/Poly1305 simetrik şifreleme için EdDSA / RedDSA dijital imzalar için SHA‑256 / SHA‑512 özetleme ve türetme için Deneysel kuantum‑sonrası hibrit modlar geleceğe dönük uyumluluk için Eski ElGamal, AES‑CBC ve DSA, geriye dönük uyumluluk için korunmaktadır, ancak artık etkin taşıma protokollerinde veya şifreleme yollarında kullanılmamaktadır.\n","description":"I2P genelinde kullanılan simetrik, asimetrik ve imza kriptografik primitiflerinin özeti","id":"f5b93f818161e04d49735c3df52fcbdc","section":"docs","title":"Düşük düzey kriptografi","url":"/tr/docs/specs/cryptography/"},{"categories":null,"content":"Genel Bakış Amaç ECIES-X25519-AEAD-Ratchet, I2P\u0026rsquo;nin modern uçtan uca şifreleme protokolüdür ve eski ElGamal/AES+SessionTags sisteminin yerini alır. İleriye dönük gizlilik, kimlik doğrulamalı şifreleme ve performans ile güvenlikte önemli iyileştirmeler sağlar.\nElGamal/AES+SessionTags\u0026rsquo;e Göre Başlıca İyileştirmeler Daha Küçük Anahtarlar: 32 baytlık anahtarlar, 256 baytlık ElGamal açık anahtarlarına karşı (%87,5 azalma) İleri Gizlilik: DH ratcheting (DH ratchet mekanizması) aracılığıyla sağlanır (eski protokolde mevcut değildir) Modern Kriptografi: X25519 DH, ChaCha20-Poly1305 AEAD, SHA-256 Kimlik Doğrulamalı Şifreleme: AEAD yapısı aracılığıyla yerleşik kimlik doğrulaması Çift Yönlü Protokol: Eşleştirilmiş gelen/giden oturumlar, tek yönlü eski protokole karşı Verimli Etiketler: 8 baytlık oturum etiketleri, 32 baytlık etiketlere karşı (%75 azalma) Trafik Gizleme: Elligator2 kodlaması, el sıkışmalarını rastgele veriden ayırt edilemez hale getirir Dağıtım Durumu İlk Sürüm: Sürüm 0.9.46 (25 Mayıs 2020) Ağ Dağıtımı: 2020 itibarıyla tamamlandı Güncel Durum: Olgun, yaygın olarak konuşlandırılmış (5+ yıldır üretimde) Router Desteği: Sürüm 0.9.46 veya üzeri gereklidir Floodfill Gereksinimleri: Şifreli sorgular için neredeyse %100 benimsenme Gerçekleştirme Durumu Tamamen Uygulandı: - Bağlama içeren New Session (NS) mesajları - New Session Reply (NSR) mesajları - Existing Session (ES) mesajları - DH ratchet (kademeli anahtar yenileme) mekanizması - Session tag ve simetrik anahtar ratchet\u0026rsquo;ları - DateTime, NextKey, ACK, ACK Request, Garlic Clove ve Padding blokları\nUygulanmadı (sürüm 0.9.50 itibarıyla): - MessageNumbers bloğu (tip 6) - Options bloğu (tip 5) - Termination bloğu (tip 4) - Protokol katmanı otomatik yanıtları - Sıfır statik anahtar modu - Multicast oturumları\nNot: 1.5.0\u0026rsquo;dan 2.10.0\u0026rsquo;a (2021-2025) kadar olan sürümlerin uygulama durumu, bazı özellikler eklenmiş olabileceğinden doğrulama gerektirir.\nProtokolün Temelleri Noise Protokol Çerçevesi ECIES-X25519-AEAD-Ratchet, Noise Protocol Framework (Noise Protokol Çatısı) (Revision 34, 2018-07-11) temelinde, özellikle I2P\u0026rsquo;ye özgü uzantılarla IK (Etkileşimli, uzaktaki statik anahtarı bilinen) el sıkışma desenini kullanır.\nNoise Protokol Tanımlayıcısı Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 Tanımlayıcı Bileşenler: - Noise - Temel çerçeve - IK - Bilinen uzak statik anahtarla etkileşimli el sıkışma deseni - elg2 - Geçici anahtarlar için Elligator2 kodlaması (I2P extension) - +hs2 - Etiketi karışıma katmak için ikinci iletiden önce çağrılan MixHash (I2P extension) - 25519 - X25519 Diffie-Hellman işlevi - ChaChaPoly - ChaCha20-Poly1305 AEAD şifreleme algoritması - SHA256 - SHA-256 özet işlevi\nNoise El Sıkışma Örüntüsü IK Desen Notasyonu:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) Kısaltmaların Anlamları: - e - Geçici anahtar iletimi - s - Statik anahtar iletimi - es - Alice\u0026rsquo;in geçici anahtarı ile Bob\u0026rsquo;un statik anahtarı arasındaki DH (Diffie-Hellman) - ss - Alice\u0026rsquo;in statik anahtarı ile Bob\u0026rsquo;un statik anahtarı arasındaki DH - ee - Alice\u0026rsquo;in geçici anahtarı ile Bob\u0026rsquo;un geçici anahtarı arasındaki DH - se - Bob\u0026rsquo;un statik anahtarı ile Alice\u0026rsquo;in geçici anahtarı arasındaki DH\nNoise Güvenlik Özellikleri Noise terminolojisini kullanarak, IK pattern (IK kalıbı) şunları sağlar:\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) **Kimlik Doğrulama Düzeyleri:** - **Düzey 1**: Yükün, gönderenin statik anahtarının sahibine ait olduğu doğrulanır, ancak Key Compromise Impersonation (KCI) (anahtar ele geçirilmesiyle kimliğe bürünme) saldırılarına karşı savunmasızdır - **Düzey 2**: NSR sonrasında KCI saldırılarına karşı dayanıklı Gizlilik Seviyeleri: - Seviye 2: Göndericinin statik anahtarı daha sonra ele geçirilirse ileri gizlilik - Seviye 4: Göndericinin geçici anahtarı daha sonra ele geçirilirse ileri gizlilik - Seviye 5: Her iki geçici anahtar da silindikten sonra tam ileri gizlilik\nIK (Noise protokolünde el sıkışma kalıbı) ile XK (Noise protokolünde el sıkışma kalıbı) Arasındaki Farklar IK pattern (IK deseni), NTCP2 ve SSU2\u0026rsquo;de kullanılan XK pattern (XK deseni) ile farklılık gösterir:\nDört DH İşlemi: IK, 4 DH işlemi (es, ss, ee, se) kullanır; XK için sayı 3\u0026rsquo;tür Anında Kimlik Doğrulama: Alice’nin kimliği ilk mesajda doğrulanır (Kimlik Doğrulama Düzeyi 1) Daha Hızlı İleri Gizlilik: Tam ileri gizlilik (Düzey 5), ikinci mesajdan sonra (1-RTT) sağlanır Ödün: İlk mesajın yükü ileri gizliliğe sahip değildir (XK\u0026rsquo;de tüm yükler ileri gizliliğe sahiptir) Özet: IK (Noise IK deseni), Bob\u0026rsquo;un yanıtının 1-RTT (tek gidiş-dönüş süresi) içinde tam ileri gizlilikle iletilmesini mümkün kılar; bunun bedeli olarak, ilk isteğin ileri gizlilik sağlamamasıdır.\nSignal Double Ratchet (çift mandallı anahtar yenileme mekanizması) Kavramları ECIES, Signal Double Ratchet Algorithm kavramlarını benimser:\nDH Mandalı: Yeni DH anahtarlarını periyodik olarak değiş tokuş ederek ileri gizlilik sağlar Simetrik Anahtar Mandalı: Her mesaj için yeni oturum anahtarları türetir Oturum Etiketi Mandalı: Tek kullanımlık oturum etiketlerini deterministik olarak üretir Signal\u0026rsquo;dan Temel Farklar: - Daha Seyrek Ratcheting: (ratchet/mandal mekanizması) I2P yalnızca gerektiğinde ratchet uygular (etiket tükenmesine yaklaşıldığında veya politikaya göre) - Başlık Şifrelemesi Yerine Oturum Etiketleri: Şifrelenmiş başlıklar yerine deterministik etiketler kullanır - Açık ACK\u0026rsquo;ler: (onay) Yalnızca ters trafiğe güvenmek yerine bant içi ACK bloklarını kullanır - Ayrı Etiket ve Anahtar Ratchet\u0026rsquo;leri: Alıcı için daha verimlidir (anahtar hesaplamasını erteleyebilir)\nNoise (kriptografik protokol çerçevesi) için I2P Uzantıları Kriptografik İlkel Yapılar X25519 Diffie-Hellman Belirtim: RFC 7748 Anahtar Özellikleri: - Özel Anahtar Boyutu: 32 bayt - Açık Anahtar Boyutu: 32 bayt - Paylaşılan Sır Boyutu: 32 bayt - Endianness (bayt sıralaması): Little-endian - Eğri: Curve25519\nİşlemler:\nX25519 GENERATE_PRIVATE() Rastgele 32 baytlık bir özel anahtar oluşturur:\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) İlgili açık anahtarı türetir:\npubkey = curve25519_scalarmult_base(privkey) 32 baytlık little-endian (küçük uçlu bayt sıralaması) açık anahtarı döndürür.\nX25519 DH(privkey, pubkey) Diffie-Hellman anahtar değişimini gerçekleştirir:\nsharedSecret = curve25519_scalarmult(privkey, pubkey) 32 bayt uzunluğunda bir paylaşılan sır döndürür.\nGüvenlik Notu: Uygulayıcılar, paylaşılan sırrın tamamının sıfırlardan oluşmadığını doğrulamalıdır (zayıf anahtar). Bu gerçekleşirse reddedin ve el sıkışmayı sonlandırın.\nChaCha20-Poly1305 AEAD (İlişkili Verili Kimlik Doğrulamalı Şifreleme) Belirtim: RFC 7539 bölüm 2.8\nParametreler: - Anahtar Boyutu: 32 bayt (256 bit) - Nonce Boyutu (tek kullanımlık sayı): 12 bayt (96 bit) - MAC Boyutu: 16 bayt (128 bit) - Blok Boyutu: 64 bayt (dahili)\nNonce (tek seferlik sayı) Biçimi:\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) AEAD (İlişkili Verili Kimlik Doğrulamalı Şifreleme) Kurgusu:\nAEAD (kimlik doğrulamalı şifreleme ve ilişkili veriler), ChaCha20 akış şifreleyicisini Poly1305 MAC (mesaj doğrulama kodu) ile birleştirir:\nAnahtar ve nonce (tek-kullanımlık sayı) kullanarak ChaCha20 anahtar akışını üretin Açık metni anahtar akışıyla XOR işlemi uygulayarak şifreleyin Poly1305 MAC (ileti kimlik doğrulama kodu) değerini (ilişkili veri || şifreli metin) üzerinde hesaplayın Şifreli metne 16 baytlık MAC ekleyin ChaCha20-Poly1305 ENCRYPT(k, n, plaintext, ad) Düz metni kimlik doğrulamalı olarak şifreler:\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 Özellikler: - Şifreli metin, açık metinle aynı uzunluktadır (akış şifresi) - Çıktı plaintext_length + 16 bayttır (MAC dahildir) - Anahtar gizliyse, tüm çıktı rastgele veriden ayırt edilemez - MAC hem ilişkili veriyi hem de şifreli metni doğrular\nChaCha20-Poly1305 ŞİFRE ÇÖZ(k, n, ciphertext, ad) Şifresini çözer ve kimlik doğrulamasını doğrular:\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext Kritik Güvenlik Gereksinimleri: - Nonces (tek seferlik değer) aynı anahtarla gönderilen her mesaj için MUTLAKA benzersiz olmalıdır - Nonces KESİNLİKLE yeniden kullanılmamalıdır (yeniden kullanılırsa felaket niteliğinde bir başarısızlık) - MAC doğrulaması zamanlama saldırılarını önlemek için sabit zamanlı karşılaştırma MUTLAKA kullanmalıdır - Başarısız MAC doğrulaması, mesajın tamamen reddedilmesiyle MUTLAKA sonuçlanmalıdır (kısmi şifre çözme yok)\nSHA-256 Özet Fonksiyonu Belirtim: NIST FIPS 180-4\nÖzellikler: - Çıktı Boyutu: 32 bayt (256 bit) - Blok Boyutu: 64 bayt (512 bit) - Güvenlik Seviyesi: 128 bit (çakışma direnci)\nİşlemler:\nSHA-256 H(p, d) Kişiselleştirme dizesiyle SHA-256 özeti:\nH(p, d) := SHA256(p || d) Burada || birleştirmeyi ifade eder, p kişiselleştirme dizesidir, d veridir.\nSHA-256 MixHash(d) Çalışan karma değerini yeni verilerle günceller:\nh = SHA256(h || d) Noise el sıkışması boyunca transkript karmasını sürdürmek için kullanılır.\nHKDF Anahtar Türetimi Spesifikasyon: RFC 5869 Açıklama: HMAC tabanlı, SHA-256 kullanan anahtar türetme fonksiyonu\nParametreler: - Karma Fonksiyonu: HMAC-SHA256 - Tuz Uzunluğu: En fazla 32 bayt (SHA-256 çıktı boyutu) - Çıktı Uzunluğu: Değişken (en fazla 255 * 32 bayt)\nHKDF Fonksiyonu:\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] Yaygın Kullanım Kalıpları:\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] ECIES\u0026rsquo;de Kullanılan Bilgi Dizeleri: - \u0026quot;KDFDHRatchetStep\u0026quot; - DH ratchet (kademeli anahtar yenileme mekanizması) için anahtar türetimi - \u0026quot;TagAndKeyGenKeys\u0026quot; - Etiket ve anahtar zinciri anahtarlarının başlatılması - \u0026quot;STInitialization\u0026quot; - Oturum etiketi ratchet başlatılması - \u0026quot;SessionTagKeyGen\u0026quot; - Oturum etiketi üretimi - \u0026quot;SymmetricRatchet\u0026quot; - Simetrik anahtar üretimi - \u0026quot;XDHRatchetTagSet\u0026quot; - DH ratchet etiket kümesi anahtarı - \u0026quot;SessionReplyTags\u0026quot; - NSR etiket kümesi üretimi - \u0026quot;AttachPayloadKDF\u0026quot; - NSR payload (yük) anahtar türetimi\nElligator2 Kodlaması Amaç: X25519 açık anahtarlarını, 32 baytlık eş-dağılımlı rastgele bayt dizilerinden ayırt edilemez olacak şekilde kodlamak.\nSpesifikasyon: Elligator2 Makalesi Sorun: Standart X25519 açık anahtarları tanınabilir bir yapıya sahiptir. Bir gözlemci, içerik şifrelenmiş olsa bile, bu anahtarları tespit ederek el sıkışma mesajlarını belirleyebilir.\nÇözüm: Elligator2, geçerli X25519 açık anahtarlarının yaklaşık %50\u0026rsquo;si ile rastgele görünümlü 254 bitlik bit dizileri arasında bijektif bir eşleme sağlar.\nElligator2 (kriptografik bir eşleme tekniği) ile Anahtar Üretimi:\nElligator2 GENERATE_PRIVATE_ELG2() Elligator2 (gizleme amaçlı bir kodlama yöntemi) ile kodlanabilir bir genel anahtara karşılık gelen bir özel anahtar üretir:\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue Önemli: Rastgele oluşturulan özel anahtarların yaklaşık %50\u0026rsquo;si kodlanamayan açık anahtarlar üretir. Bunlar atılmalı ve yeniden oluşturma denenmelidir.\nPerformans Optimizasyonu: El sıkışma sırasında gecikmeleri önlemek için uygun anahtar çiftlerinden oluşan bir havuzu koruyacak şekilde anahtarları arka plan iş parçacığında önceden oluşturun.\nElligator2 (elliptik eğri nokta kodlama yöntemi) ENCODE_ELG2(pubkey) Bir açık anahtarı rastgele görünümlü 32 bayta kodlar:\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey Kodlama Ayrıntıları: - Elligator2 254 bit üretir (tam 256 değil) - 31. baytın en anlamlı 2 biti rastgele dolgudur - Sonuç 32 baytlık uzayda uniform dağılımlıdır - Geçerli X25519 açık anahtarlarının yaklaşık %50\u0026rsquo;sini başarıyla kodlar\nElligator2 DECODE_ELG2(encodedKey) Orijinal açık anahtara geri çözülür:\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey Güvenlik Özellikleri: - Kodlanmış anahtarlar, hesaplama bakımından rastgele baytlardan ayırt edilemez - Hiçbir istatistiksel test, Elligator2 ile kodlanmış anahtarları güvenilir biçimde tespit edemez - Kod çözme deterministiktir (aynı kodlanmış anahtar her zaman aynı açık anahtarı üretir) - Kodlama, kodlanabilir altkümedeki anahtarların ~50%\u0026lsquo;si için bijektiftir\nUygulama Notları: - El sıkışma sırasında yeniden kodlamayı önlemek için kodlanmış anahtarları oluşturma aşamasında saklayın - Elligator2 (eliptik eğri anahtarlarını rastgele görünümlü baytlara eşleyen bir gizleme tekniği) üretiminden çıkan uygun olmayan anahtarlar, NTCP2 için kullanılabilir (Elligator2 gerektirmez) - Arka planda anahtar oluşturma, performans için kritik önemdedir - Ortalama oluşturma süresi, %50 reddedilme oranı nedeniyle iki katına çıkar\nMesaj Biçimleri Genel Bakış ECIES (Eliptik Eğri Tümleşik Şifreleme Şeması) üç mesaj türü tanımlar:\nNew Session (NS): Alice\u0026rsquo;den Bob\u0026rsquo;a gönderilen ilk el sıkışma mesajı New Session Reply (NSR): Bob\u0026rsquo;un Alice\u0026rsquo;e el sıkışma yanıtı Existing Session (ES): Her iki yönde de bundan sonraki tüm mesajlar Tüm mesajlar, ek şifreleme katmanlarıyla birlikte I2NP Garlic Message (I2NP \u0026lsquo;Garlic Message\u0026rsquo; mesaj biçimi) içinde kapsüllenir.\nI2NP Garlic Mesaj Kapsayıcısı (garlic: I2P\u0026rsquo;de kullanılan, birden fazla mesajı demetleme tekniği) Tüm ECIES (Eliptik Eğri Tabanlı Entegre Şifreleme Şeması) mesajları, standart I2NP Garlic Message başlıklarıyla kapsüllenir:\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ Alanlar: - type: 0x26 (Garlic Message - I2P\u0026rsquo;de özel bir mesaj türü) - msg_id: 4 baytlık I2NP mesaj kimliği - expiration: 8 baytlık Unix zaman damgası (milisaniye cinsinden) - size: 2 baytlık yük boyutu - chks: 1 baytlık sağlama toplamı - length: 4 baytlık şifrelenmiş veri uzunluğu - encrypted data: ECIES ile şifrelenmiş yük\nAmaç: I2NP katmanında mesaj tanımlama ve yönlendirme sağlar. length alanı, alıcıların toplam şifrelenmiş yük boyutunu bilmelerine olanak tanır.\nYeni Oturum (NS) Mesajı New Session mesajı, Alice\u0026rsquo;ten Bob\u0026rsquo;a yeni bir oturum başlatır. Üç varyantı vardır:\nBağlama ile (1b): Çift yönlü iletişim için Alice\u0026rsquo;in statik anahtarını içerir Bağlama olmadan (1c): Tek yönlü iletişim için statik anahtarı kullanmaz Tek Seferlik (1d): Oturum kurulumu olmadan tek mesaj kipi Bağlama içeren NS Mesajı (Tip 1b) Kullanım durumu: Akış, yanıtlanabilir datagramlar, yanıt gerektiren herhangi bir protokol\nToplam Uzunluk: 96 + payload_length bayt\nBiçim:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Alan Ayrıntıları:\nGeçici Açık Anahtar (32 bayt, açık metin): - Alice\u0026rsquo;in tek kullanımlık X25519 açık anahtarı - Elligator2 ile kodlanmıştır (rastgele veriden ayırt edilemez) - Her NS mesajı için yeni üretilir (asla yeniden kullanılmaz) - Little-endian format (en düşük anlamlı bayt önce)\nStatik Anahtar Bölümü (32 bayt şifreli, MAC ile 48 bayt): - Alice\u0026rsquo;in X25519 statik açık anahtarını (32 bayt) içerir - ChaCha20 ile şifrelenir - Poly1305 MAC (16 bayt) ile doğrulanır - Bob tarafından oturumu Alice\u0026rsquo;in hedefine bağlamak için kullanılır\nPayload Bölümü (değişken uzunlukta şifrelenmiş, +16 bayt MAC): - Garlic Clove (garlic şifrelemesindeki alt-mesaj) öğelerini ve diğer blokları içerir - İlk blok olarak DateTime bloğunu içermelidir - Genellikle uygulama verisi içeren Garlic Clove bloklarını içerir - Anında ratchet (anahtar yenilemesi) için NextKey bloğunu içerebilir - ChaCha20 ile şifrelenir - Poly1305 MAC (16 bayt) ile doğrulanır\nGüvenlik Özellikleri: - Geçici anahtar ileri gizlilik bileşeni sağlar - Statik anahtar, Alice\u0026rsquo;i kimlik doğrular (hedefe bağlayarak) - Her iki bölüm de alan ayrımı için ayrı MAC\u0026rsquo;lere sahiptir - Tüm el sıkışması 2 DH (Diffie-Hellman) işlemi gerçekleştirir (es, ss)\nBağlama olmadan NS mesajı (Tür 1c) Kullanım Senaryosu: Yanıtın beklenmediği veya istenmediği ham datagramlar\nToplam Uzunluk: 96 + payload_length bayt\nBiçim:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Temel Fark: Bayraklar Bölümü, statik anahtar yerine 32 bayt sıfır içerir.\nAlgılama: Bob, 32 baytlık bölümü şifresini çözerek ve tüm baytların sıfır olup olmadığını kontrol ederek mesaj türünü belirler: - Tümü sıfır → Bağlı olmayan oturum (type 1c) - Sıfır olmayan → Statik anahtarlı bağlı oturum (type 1b)\nÖzellikler: - Statik anahtar olmaması, Alice\u0026rsquo;in hedefiyle kriptografik bir bağ kurulmadığı anlamına gelir - Bob yanıt gönderemez (bilinen bir hedef yok) - Yalnızca 1 DH (Diffie-Hellman) işlemi gerçekleştirir - Noise \u0026ldquo;N\u0026rdquo; örüntüsünü \u0026ldquo;IK\u0026rdquo; yerine izler - Yanıtların hiç gerekmediği durumlarda daha verimlidir\nFlags Section (gelecekte kullanım için ayrılmış): Şu anda tamamı sıfır. Gelecek sürümlerde özellik müzakeresi için kullanılabilir.\nNS Tek Seferlik Mesaj (Tür 1d) Kullanım Senaryosu: Oturum veya yanıt beklenmeyen tek bir anonim mesaj\nToplam Uzunluk: 96 + payload_length bayt\nBiçim: Bağlama olmadan NS ile aynıdır (tip 1c)\nAyrım: - Tip 1c aynı oturumda birden fazla mesaj gönderebilir (ES mesajları ardından gelir) - Tip 1d oturum kurulumu olmadan tam olarak bir mesaj gönderir - Uygulamada, gerçekleştirimler başlangıçta bunları aynı şekilde ele alabilir\nÖzellikler: - Maksimum anonimlik (sabit anahtar yok, oturum yok) - Hiçbir taraf oturum durumunu tutmaz - Noise \u0026ldquo;N\u0026rdquo; desenini izler - Tek DH işlemi\nYeni Oturum Yanıtı (NSR) Mesajı Bob, Alice\u0026rsquo;in NS mesajına yanıt olarak bir veya daha fazla NSR mesajı gönderir. NSR, Noise IK el sıkışmasını (Noise protokolünün IK kalıbı) tamamlar ve iki yönlü bir oturum kurar.\nToplam Uzunluk: 72 + payload_length bayt\nBiçim:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Alan Ayrıntıları:\nOturum Etiketi (8 bayt, açık metin): - NSR etiket kümesinden üretilir (bkz. KDF bölümleri) - Bu yanıtı Alice\u0026rsquo;in NS mesajıyla ilişkilendirir - Alice\u0026rsquo;in bu NSR\u0026rsquo;nin hangi NS\u0026rsquo;ye yanıt verdiğini belirlemesini sağlar - Tek seferlik kullanım (asla yeniden kullanılmaz)\nGeçici Açık Anahtar (32 bayt, açık metin): - Bob\u0026rsquo;un tek kullanımlık X25519 açık anahtarı - Elligator2 ile kodlanmış - Her NSR mesajı için yeni üretilir - Gönderilen her NSR için farklı olmalıdır\nKey Section MAC (16 bayt): - Boş veriyi (ZEROLEN) kimlik doğrular - Noise IK protokolünün bir parçası (se pattern) - İlişkili veri olarak transkript karmasını kullanır - NSR\u0026rsquo;nin NS\u0026rsquo;ye bağlanması için kritiktir\nYük Bölümü (değişken uzunlukta): - Garlic cloves (garlic mesajındaki tekil alt-iletiler) ve bloklar içerir - Genellikle uygulama katmanı yanıtlarını içerir - Boş olabilir (ACK-only NSR) - Maksimum boyut: 65519 bayt (65535 - 16 bayt MAC)\nBirden Çok NSR Mesajı:\nBob, bir NS\u0026rsquo;ye (istek mesajı) yanıt olarak birden fazla NSR (yanıt mesajı) gönderebilir: - Her NSR benzersiz bir geçici anahtara sahiptir - Her NSR benzersiz bir oturum etiketine sahiptir - Alice, el sıkışma işlemini tamamlamak için aldığı ilk NSR\u0026rsquo;yi kullanır - Diğer NSR\u0026rsquo;ler yedeklilik içindir (paket kaybı durumunda)\nKritik Zamanlama: - Alice, ES mesajları göndermeden önce bir NSR almalıdır - Bob, ES mesajları göndermeden önce bir ES mesajı almalıdır - NSR, split() işlemi aracılığıyla çift yönlü oturum anahtarları kurar\nGüvenlik Özellikleri: - Noise IK el sıkışmasını tamamlar - 2 ek DH işlemi gerçekleştirir (ee, se) - NS+NSR genelinde toplam 4 DH işlemi - Karşılıklı kimlik doğrulamayı sağlar (Seviye 2) - NSR yükü için zayıf ileri gizlilik (Seviye 4) sağlar\nMevcut Oturum (ES) Mesajı NS/NSR el sıkışmasından sonra tüm mesajlar Existing Session (mevcut oturum) formatını kullanır. ES mesajları hem Alice hem de Bob tarafından çift yönlü olarak kullanılır.\nToplam Uzunluk: 8 + payload_length + 16 bayt (en az 24 bayt)\nBiçim:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ Alan Ayrıntıları:\nOturum Etiketi (8 bayt, açık metin): - Mevcut giden tagset (etiket kümesi) temel alınarak üretilir - Oturumu ve mesaj numarasını tanımlar - Alıcı, oturum anahtarını ve nonce (tek seferlik değer) bulmak için etiketi arar - Tek seferlik kullanım (her etiket tam olarak bir kez kullanılır) - Biçim: HKDF çıktısının ilk 8 baytı\nYük Bölümü (değişken uzunlukta): - Garlic cloves (garlic encryption bağlamında \u0026lsquo;clove\u0026rsquo; olarak adlandırılan alt mesajlar) ve bloklar içerir - Gerekli blok yoktur (boş olabilir) - Yaygın bloklar: Garlic Clove, NextKey, ACK, ACK Request, Padding - Maksimum boyut: 65519 bayt (65535 - 16 bayt MAC)\nMAC (16 bayt): - Poly1305 kimlik doğrulama etiketi - Tüm yük üzerinde hesaplanır - İlişkili veri: 8 baytlık oturum etiketi - Doğrulaması başarılı olmalıdır; aksi halde ileti reddedilir\nEtiket Sorgulama Süreci:\nAlıcı 8 baytlık etiketi çıkarır Geçerli tüm gelen etiket kümelerinde etiketi arar İlişkili oturum anahtarını ve mesaj numarası N\u0026rsquo;yi alır Nonce (tek kullanımlık sayı) oluşturur: [0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] Etiketi ilişkili veri olarak kullanarak AEAD (İlişkili verili kimlik doğrulamalı şifreleme) ile yükün şifresini çözer Etiketi etiket kümesinden kaldırır (tek kullanımlık) Çözülmüş blokları işler Oturum Etiketi Bulunamadı:\nEtiket herhangi bir tagset (etiket kümesi) içinde bulunamazsa: - NS mesajı olabilir → NS şifre çözmeyi dene - NSR mesajı olabilir → NSR şifre çözmeyi dene - Sıra dışı bir ES olabilir → tagset güncellemesi için kısa süre bekle - Yeniden oynatma saldırısı olabilir → reddet - Bozuk veri olabilir → reddet\nBoş Yük:\nES mesajları boş yükler (0 bayt) içerebilir: - ACK Request alındığında açık bir ACK işlevi görür - Uygulama verisi olmadan protokol katmanı yanıtı sağlar - Yine de bir session tag (oturum etiketi) tüketir - Üst katmanın hemen gönderecek verisi olmadığında kullanışlıdır\nGüvenlik Özellikleri: - NSR alındıktan sonra tam ileri gizlilik (Seviye 5) - AEAD (ek verilerle kimlik doğrulamalı şifreleme) aracılığıyla kimliği doğrulanmış şifreleme - Etiket, ek ilişkili veri olarak işlev görür - Ratchet (anahtar ilerletme mekanizması) gerekli hale gelmeden önce etiket kümesi başına en fazla 65535 ileti\nAnahtar Türetme Fonksiyonları Bu bölüm, ECIES\u0026rsquo;te kullanılan tüm KDF işlemlerini (anahtar türetme fonksiyonu) belgeler ve tam kriptografik türetimleri gösterir.\nNotasyon ve Sabitler Sabitler: - ZEROLEN - Sıfır uzunlukta bayt dizisi (boş dize) - || - Birleştirme işleci\nDeğişkenler: - h - Transkriptin kümülatif özeti (32 bayt) - chainKey - HKDF için zincirleme anahtarı (32 bayt) - k - Simetrik şifreleme anahtarı (32 bayt) - n - Nonce (tek-kullanımlık sayı) / mesaj numarası\nAnahtarlar: - ask / apk - Alice\u0026rsquo;in statik özel/açık anahtarı - aesk / aepk - Alice\u0026rsquo;in geçici özel/açık anahtarı - bsk / bpk - Bob\u0026rsquo;un statik özel/açık anahtarı - besk / bepk - Bob\u0026rsquo;un geçici özel/açık anahtarı\nNS Mesajı KDF\u0026rsquo;leri (anahtar türetme fonksiyonları) KDF 1: Başlangıç Zincir Anahtarı Protokol ilklendirmesinde bir kez yapılır (önceden hesaplanabilir):\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions Sonuç: - chainKey = Tüm sonraki KDF\u0026rsquo;ler (anahtar türetme fonksiyonları) için başlangıç zincirleme anahtarı - h = Başlangıç özet transkripti\nKDF 2: Bob\u0026rsquo;un Statik Anahtar Karıştırması Bob bunu bir kez yapar (tüm gelen oturumlar için önceden hesaplanabilir):\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF 3: Alice\u0026rsquo;nin Geçici Anahtar Üretimi Alice her NS message (NS mesajı) için yeni anahtarlar oluşturur:\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF 4: NS Statik Anahtar Bölümü (es DH) Alice\u0026rsquo;in statik anahtarını şifrelemek için anahtarlar türetir:\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF (Anahtar Türetme Fonksiyonu) 5: NS Payload Bölümü (ss DH, yalnızca bağlama amaçlı) Bağlı oturumlarda, yükü şifrelemek için ikinci DH\u0026rsquo;yi (Diffie-Hellman anahtar değişimi) gerçekleştirin:\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message Önemli Notlar:\nBound (bağlı) vs Unbound (bağsız):\nBound 2 DH işlemi gerçekleştirir (es + ss) Unbound 1 DH işlemi gerçekleştirir (yalnızca es) Unbound, yeni bir anahtar türetmek yerine nonce (tek kullanımlık sayı) değerini artırır Anahtar Yeniden Kullanım Güvenliği:\nFarklı nonce\u0026rsquo;lar (0 ve 1), anahtarın/nonce\u0026rsquo;un yeniden kullanılmasını önler Farklı ilişkili veriler (h farklı) alan ayrımı sağlar Hash Transkripti:\nh artık şunları içerir: protocol_name, empty prologue (önsöz), bpk, aepk, static_key_ciphertext, payload_ciphertext Bu transkript, NS mesajının tüm parçalarını birbirine bağlar NSR Reply Tagset KDF (yanıt etiket kümesi için anahtar türetme fonksiyonu) Bob, NSR (bir mesaj türü) mesajları için etiketler oluşturur:\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR NSR Mesajı KDF\u0026rsquo;leri (anahtar türetme fonksiyonları) KDF 6: NSR Geçici Anahtar Üretimi Bob, her NSR için yeni bir geçici anahtar üretir:\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7: NSR Anahtar Bölümü (ee ve se DH) NSR anahtar bölümü için anahtarlar türetir:\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR Kritik: Bu, Noise IK el sıkışmasını tamamlar. chainKey artık 4 DH işleminin tümünden (es, ss, ee, se) gelen katkıları içerir.\nKDF 8: NSR Yük Bölümü NSR yükü şifrelemesi için anahtarlar türetir:\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message Önemli Notlar:\nBölme İşlemi:\nHer yön için bağımsız anahtarlar oluşturur Alice→Bob ve Bob→Alice yönleri arasında anahtarın yeniden kullanılmasını önler NSR Yük Bağlama:\nYükü el sıkışmaya bağlamak için ilişkili veri olarak h kullanır Ayrı bir KDF (anahtar türetme fonksiyonu) (\u0026ldquo;AttachPayloadKDF\u0026rdquo;) alan ayrımı sağlar ES (ES adlı mesaj) Hazırlığı:\nNSR (NSR adlı mesaj) sonrasında, her iki taraf da ES mesajları gönderebilir Alice, ES göndermeden önce NSR almalıdır Bob, ES göndermeden önce ES almalıdır ES Mesaj KDF\u0026rsquo;leri (anahtar türetme fonksiyonları) ES iletileri, tagsets (etiket kümeleri) içindeki önceden oluşturulmuş oturum anahtarlarını kullanır:\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) Alıcı Süreci:\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) DH_INITIALIZE Fonksiyonu Tek bir yön için bir tagset (etiket kümesi) oluşturur:\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset Kullanım Bağlamları:\nNSR Etiket Kümesi: DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) ES Etiket Kümeleri: DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) Ratcheted (kademeli) Etiket Kümeleri: DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) Ratchet Mekanizmaları (tek yönlü anahtar yenileme mekanizmaları) ECIES, ileri gizlilik ve verimli oturum yönetimi sağlamak için üç eşzamanlı ratchet (anahtar yenileme mekanizması) kullanır.\nRatchet (mandal mekanizması) Genel Bakış Üç Ratchet (ilerlemeli anahtar yenileme mekanizması) Türleri:\nDH Ratchet (tek yönlü anahtar yenileme mekanizması): Yeni kök anahtarlar üretmek için Diffie-Hellman anahtar değişimleri gerçekleştirir Session Tag Ratchet: Tek kullanımlık oturum etiketlerini belirlenimli olarak türetir Symmetric Key Ratchet: Mesaj şifrelemesi için oturum anahtarlarını türetir İlişki:\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) Temel Özellikler:\nGönderici: Etiketleri ve anahtarları talep üzerine üretir (depolama gerekmez) Alıcı: İleri bakış penceresi için etiketleri önceden üretir (depolama gerekir) Senkronizasyon: Etiket indeksi, anahtar indeksini belirler (N_tag = N_key) İleri Gizlilik: Periyodik DH ratchet (Diffie-Hellman temelli artımlı anahtar yenileme mekanizması) ile sağlanır Verimlilik: Alıcı, etiket alınana kadar anahtar hesaplamasını erteleyebilir DH Ratchet (Diffie-Hellman temelli kademeli anahtar yenileme mekanizması) DH ratchet (Diffie-Hellman tabanlı kademeli anahtar yenileme mekanizması), periyodik olarak yeni geçici anahtarlar değiş tokuş ederek ileri gizlilik sağlar.\nDH Ratchet (Diffie-Hellman anahtar yenileme mekanizması) Frekansı Gerekli Ratchet (adım adım anahtar yenileme mekanizması) Koşulları: - Etiket kümesi tükenmeye yaklaşıyor (azami etiket değeri 65535\u0026rsquo;tir) - Uygulamaya özgü politikalar: - Mesaj sayısı eşiği (örn. her 4096 mesajda bir) - Zaman eşiği (örn. her 10 dakikada bir) - Veri hacmi eşiği (örn. her 100 MB\u0026rsquo;de bir)\nÖnerilen İlk Ratchet (kademeli anahtar yenileme mekanizması): Sınıra ulaşmamak için etiket numarası 4096 civarında\nMaksimum Değerler: - Maksimum tag set (etiket kümesi) kimliği: 65535 - Maksimum anahtar kimliği: 32767 - Tag set başına maksimum ileti: 65535 - Oturum başına teorik maksimum veri: ~6.9 TB (64K tag sets × 64K ileti × 1730 bayt ortalama)\nDH Ratchet (DH \u0026ldquo;ratchet\u0026rdquo; mekanizması) Etiket ve Anahtar Kimlikleri İlk Etiket Kümesi (el sıkışması sonrası): - Etiket kümesi kimliği: 0 - Henüz hiçbir NextKey bloğu gönderilmedi - Hiçbir anahtar kimliği atanmadı\nİlk Ratchet (kademeli anahtar yenileme mekanizması) Sonrası: - Etiket kümesi kimliği: 1 = (1 + Alice\u0026rsquo;in anahtar kimliği + Bob\u0026rsquo;un anahtar kimliği) = (1 + 0 + 0) - Alice, anahtar kimliği 0 olan NextKey (sonraki anahtar) gönderir - Bob, anahtar kimliği 0 olan NextKey ile yanıtlar\nSonraki Etiket Kümeleri: - Etiket kümesi kimliği = 1 + gönderenin anahtar kimliği + alıcının anahtar kimliği - Örnek: Etiket kümesi 5 = (1 + sender_key_2 + receiver_key_2)\nEtiket Kümesi İlerleme Tablosu:\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set \\* = Yeni anahtar bu ratchet (kademeli anahtar yenileme mekanizması) sırasında üretildi Anahtar Kimliği Kuralları: - Kimlikler 0\u0026rsquo;dan başlayarak ardışık olarak verilir - Kimlikler yalnızca yeni bir anahtar oluşturulduğunda artar - Maksimum anahtar kimliği 32767\u0026rsquo;dir (15 bit) - Anahtar kimliği 32767\u0026rsquo;den sonra yeni oturum gereklidir\nDH Ratchet (kademeli anahtar yenileme mekanizması) Mesaj Akışı Roller: - Tag Sender (Etiket Gönderici): giden etiket kümesine sahiptir, iletiler gönderir - Tag Receiver (Etiket Alıcı): gelen etiket kümesine sahiptir, iletiler alır\nKalıp: Etiket göndericisi, etiket kümesi neredeyse tükendiğinde ratchet (aşamalı anahtar yenileme mekanizması) başlatır.\nMesaj Akış Diyagramı:\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) Ratchet (mandal mekanizması) örüntüleri:\nÇift Numaralı Etiket Kümeleri Oluşturma (2, 4, 6, \u0026hellip;): 1. Gönderen yeni bir anahtar üretir 2. Gönderen yeni anahtar içeren NextKey bloğunu gönderir 3. Alıcı, eski anahtar kimliğiyle NextKey bloğunu gönderir (ACK) 4. Her ikisi de (yeni gönderen anahtarı × eski alıcı anahtarı) ile DH (Diffie-Hellman anahtar değişimi) gerçekleştirir\nTek Sayılı Etiket Kümeleri Oluşturma (3, 5, 7, \u0026hellip;): 1. Gönderici ters yöndeki anahtarı talep eder (istek bayrağı ile NextKey gönderir) 2. Alıcı yeni bir anahtar üretir 3. Alıcı yeni anahtarla NextKey bloğunu gönderir 4. Her ikisi de (eski gönderici anahtarı × yeni alıcı anahtarı) ile DH (Diffie-Hellman anahtar değişimi) gerçekleştirir\nNextKey (bir sonraki anahtar) Blok Biçimi Ayrıntılı NextKey (sonraki anahtar) blok belirtimi için Payload Format bölümüne bakın.\nTemel Öğeler: - Bayrak baytı: - Bit 0: Anahtar mevcut (1) veya yalnızca kimlik (0) - Bit 1: Reverse key (ters anahtar) (1) veya forward key (ileri anahtar) (0) - Bit 2: reverse key talep et (1) veya talep yok (0) - Anahtar Kimliği: 2 bayt, big-endian (0-32767) - Açık Anahtar: 32 bayt X25519 (eğer bit 0 = 1 ise)\nÖrnek NextKey Blocks (bir sonraki anahtar blokları):\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) DH Ratchet KDF (Anahtar Türetme Fonksiyonu) Yeni anahtarlar değiş tokuş edildiğinde:\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset Kritik Zamanlama:\nEtiket Gönderici: - Yeni giden etiket kümesini hemen oluşturur - Yeni etiketleri hemen kullanmaya başlar - Eski giden etiket kümesini siler\nEtiket Alıcısı: - Yeni bir gelen etiket kümesi oluşturur - Tolerans süresi (3 dakika) boyunca eski gelen etiket kümesini muhafaza eder - Tolerans süresi boyunca hem eski hem de yeni etiket kümelerinden etiketleri kabul eder - Tolerans süresinden sonra eski gelen etiket kümesini siler\nDH Ratchet (kademeli Diffie-Hellman anahtar yenileme mekanizması) Durum Yönetimi Gönderici Durumu: - Mevcut giden etiket kümesi - Etiket kümesi kimliği ve anahtar kimlikleri - Sonraki kök anahtar (bir sonraki ratchet (anahtar ilerletme mekanizması) için) - Mevcut etiket kümesindeki ileti sayısı\nAlıcı durumu: - Güncel gelen etiket kümesi(leri) (geçiş süresinde 2 olabilir) - Boşluk tespiti için önceki ileti numaraları (PN) - Önceden üretilmiş etiketler için ileriye bakış penceresi - Sonraki kök anahtar (bir sonraki ratchet (kademeli anahtar yenileme mekanizması) için)\nDurum Geçiş Kuralları:\nİlk Ratchet (kademeli anahtar yenileme) Öncesi:\nEtiket kümesi 0 kullanılıyor (NSR\u0026rsquo;den) Hiçbir anahtar kimliği atanmadı Ratchet (kademeli anahtar yenileme mekanizması) Başlatma:\nYeni anahtar üret (eğer gönderici bu turda üretiyorsa) ES mesajında NextKey bloğunu gönder Yeni bir giden etiket kümesi oluşturmadan önce NextKey yanıtını bekle Ratchet (anahtar sürgüsü) İsteğinin Alınması:\nYeni bir anahtar üret (bu turda alıcı üretiyorsa) Alınan anahtarla DH (Diffie-Hellman) gerçekleştir Yeni bir gelen etiket kümesi oluştur NextKey yanıtı gönder Eski gelen etiket kümesini bir müsaade süresi boyunca koru Ratchet\u0026rsquo;in Tamamlanması (anahtar yenileme mekanizması):\nNextKey yanıtını alın DH (Diffie-Hellman anahtar değişimi) gerçekleştirin Yeni giden etiket kümesi oluşturun Yeni etiketleri kullanmaya başlayın Session Tag Ratchet (oturum etiketi için kademeli güncelleme mekanizması) Session tag ratchet (kademeli kriptografik mekanizma), tek kullanımlık 8 baytlık oturum etiketlerini deterministik olarak üretir.\nOturum Etiketi Ratchet\u0026rsquo;in (kademeli anahtar yenileme mekanizması) Amacı Açık etiket iletiminin yerini alır (ElGamal 32 baytlık etiketler gönderirdi) Alıcının ileri bakış penceresi için etiketleri önceden üretmesini sağlar Gönderici talep üzerine üretir (depolama gerekmez) Simetrik anahtar ratchet (adım adım anahtar yenileme mekanizması) ile indeks aracılığıyla senkronize olur Oturum Etiketi Ratchet (mandallama mekanizması) Formülü Başlatma:\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset Etiket Üretimi (N etiketi için):\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 Tam Sekans:\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] Session Tag Ratchet (oturum etiketi ratchet mekanizması) Gönderici Gerçeklemesi class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) Gönderici Süreci: 1. Her mesaj için get_next_tag() çağrısını yap 2. Dönen etiketi ES mesajında kullan 3. Olası ACK (onay) takibi için indeks N\u0026rsquo;yi sakla 4. Etiket depolaması gerekmez (istek üzerine oluşturulur)\nSession Tag Ratchet (oturum etiketi için kademeli anahtar yenileme mekanizması) Alıcı Tarafı Uygulaması class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) Alıcı Süreci: 1. İleriye bakış penceresi için etiketleri önceden oluştur (örn., 32 etiket) 2. Etiketleri bir hash tablosunda veya sözlükte sakla 3. Mesaj geldiğinde, N indeksini almak için etiketi ara 4. Etiketi depodan kaldır (tek kullanımlık) 5. Etiket sayısı eşik değerin altına düşerse pencereyi genişlet\nOturum Etiketi İleriye Bakma Stratejisi Amaç: Bellek kullanımını sıralama dışı mesaj işleme ile dengelemek\nÖnerilen Look-Ahead (ileriye bakma) Boyutları:\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets **Uyarlanabilir İleriye Bakma:** # Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 Geriden Kırp:\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 Bellek Hesaplama:\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total Session Tag\u0026rsquo;lerin (Oturum Etiketleri) Sıra Dışı İşlenmesi Senaryo: Mesajlar sırayla gelmiyor\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 Alıcı Davranışı:\ntag_5\u0026rsquo;i al:\nAra: 5. indekste bulundu İletiyi işle tag_5\u0026rsquo;i kaldır Alınan en yüksek: 5 tag_7 (sırasız) alındığında:\nAra: indeks 7\u0026rsquo;de bulundu Mesajı işle tag_7\u0026rsquo;yi kaldır Alınan en yüksek: 7 Not: tag_6 hâlâ depoda (henüz alınmadı) tag_6 alındı (gecikmeli):\nSorgula: indeks 6\u0026rsquo;da bulundu Mesajı işle tag_6 öğesini kaldır En yüksek alınan: 7 (değişmedi) tag_8\u0026rsquo;i al:\nAra: indeks 8\u0026rsquo;de bulundu Mesajı işle tag_8\u0026rsquo;i kaldır Alınan en yüksek: 8 Pencere Bakımı: - Alınan en yüksek indeksi takip et - Eksik indekslerin (boşluklar) listesini tut - Pencereyi en yüksek indekse göre genişlet - İsteğe bağlı: Zaman aşımından sonra eski boşlukları kaldır\nSimetrik Anahtar Mandalı symmetric key ratchet (simetrik anahtarların kademeli yenileme mekanizması), oturum etiketleriyle eşzamanlı 32 baytlık şifreleme anahtarları üretir.\nSymmetric Key Ratchet (simetrik anahtar mandal mekanizması) Amacı Her mesaj için benzersiz bir şifreleme anahtarı sağlar session tag ratchet (oturum etiketi kademeli güncelleme mekanizması) ile eşzamanlıdır (aynı indeks) Gönderici talep üzerine oluşturabilir Alıcı, etiket alınana kadar oluşturmayı erteleyebilir Symmetric Key Ratchet (simetrik anahtar mandalı) formülü Başlatma:\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived Anahtar Oluşturma (anahtar N için):\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) Aşamaların Tamamı:\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] Symmetric Key Ratchet (mandal mekanizması) Gönderici Gerçeklemesi class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) Gönderici Süreci: 1. Sonraki etiketi ve onun N indisini al 2. N indisi için anahtar üret 3. Anahtarı kullanarak mesajı şifrele 4. Anahtar depolaması gerekmez\nSymmetric Key Ratchet (simetrik anahtar yenileme mekanizması) Alıcı Tarafı Gerçeklemesi Strateji 1: Ertelenmiş Oluşturma (Önerilen)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) Ertelenmiş Üretim Süreci: 1. Etiketli ES mesajını al 2. N indeksini elde etmek için etiketi sorgula 3. 0\u0026rsquo;dan N\u0026rsquo;ye kadar anahtarları üret (henüz üretilmediyse) 4. Mesajı çözmek için N anahtarını kullan 5. Zincir anahtarı artık N indeksinde konumlandı\nAvantajlar: - Minimal bellek kullanımı - Anahtarlar yalnızca gerektiğinde üretilir - Basit gerçekleştirim\nDezavantajlar: - İlk kullanımda 0\u0026rsquo;dan N\u0026rsquo;e kadar tüm anahtarları üretmelidir - Önbellekleme olmadan sıra dışı mesajları işleyemez\nStrateji 2: Etiket Penceresi ile Önceden Oluşturma (Alternatif)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None Önceden Oluşturma Süreci: 1. Etiket penceresiyle eşleşen anahtarları önceden oluştur (örn., 32 anahtar) 2. Anahtarları mesaj numarasına göre indekslenmiş olarak sakla 3. Etiket alındığında ilgili anahtarı bul 4. Etiketler kullanıldıkça pencereyi genişlet\nAvantajlar: - Sıralama dışı mesajları doğal olarak işler - Hızlı anahtar elde etme (oluşturma gecikmesi yok)\nDezavantajlar: - Daha yüksek bellek kullanımı (anahtar başına 32 bayt, etiket başına 8 bayta karşı) - Anahtarlar etiketlerle senkronize tutulmalıdır\nBellek Karşılaştırması:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB Oturum Etiketleri ile Simetrik Ratchet (simetrik anahtar yenileme mekanizması) Senkronizasyonu Kritik Gereksinim: Oturum etiketi indeksi, simetrik anahtar indeksine eşit olmak zorundadır\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) Hata Türleri:\nSenkronizasyon bozulursa: - Şifre çözme için yanlış anahtar kullanıldı - MAC doğrulaması başarısız olur - İleti reddedildi\nÖnleme: - Etiket ve anahtar için her zaman aynı indeksi kullanın - Her iki ratchet\u0026rsquo;te (anahtar ilerletme mekanizması) de indeksleri asla atlamayın - Sırası bozulmuş mesajları dikkatle ele alın\nSymmetric Ratchet (kademeli anahtar yenileme mekanizması) için Nonce (tek-kullanımlık sayı) Oluşturma Tek kullanımlık sayı, mesaj numarasından türetilir:\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) Örnekler:\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 Önemli Özellikler: - Nonce (tek kullanımlık sayı) değerleri bir etiket kümesindeki her mesaj için benzersizdir - Nonceler asla tekrar etmez (tek kullanımlık etiketler bunu sağlar) - 8 baytlık sayaç 2^64 mesaja izin verir (biz yalnızca 2^16 kullanıyoruz) - Nonce biçimi RFC 7539\u0026rsquo;un sayaç tabanlı yapısıyla uyumludur\nOturum Yönetimi Oturum Bağlamı Tüm gelen ve giden oturumlar belirli bir bağlama ait olmalıdır:\nRouter Bağlamı: router\u0026rsquo;ın kendisi için oturumlar Hedef Bağlamı: belirli bir yerel hedef (istemci uygulaması) için oturumlar Kritik Kural: Korelasyon saldırılarını önlemek için oturumlar bağlamlar arasında KESİNLİKLE paylaşılmamalıdır.\nUygulama:\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) Java I2P Gerçeklemesi:\nJava I2P\u0026rsquo;de, SessionKeyManager sınıfı şu işlevleri sağlar: - router başına bir SessionKeyManager - yerel hedef başına bir SessionKeyManager - her bağlamda ECIES ve ElGamal oturumlarının ayrı yönetimi\nOturum Bağlama Binding (bağlama), bir oturumu belirli bir karşı uçtaki hedefle ilişkilendirir.\nBağlı Oturumlar Özellikler: - NS mesajına gönderenin statik anahtarı dahil edilir - Alıcı, gönderenin hedefini belirleyebilir - Çift yönlü iletişimi sağlar - Her hedef için tek bir giden oturum - Birden çok gelen oturum olabilir (geçişler sırasında)\nKullanım Durumları: - Akış bağlantıları (TCP benzeri) - Yanıtlanabilir datagramlar - İstek/yanıt gerektiren herhangi bir protokol\nBağlama Süreci:\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) Faydalar: 1. Ephemeral-Ephemeral DH: (geçici-geçici Diffie-Hellman) Yanıt ee DH kullanır (tam ileri gizlilik) 2. Oturum Sürekliliği: Ratchets (kademeli anahtar yenileme mekanizmaları) aynı hedefe bağın korunmasını sağlar 3. Güvenlik: Oturum ele geçirmeyi önler (statik anahtarla kimliği doğrulanır) 4. Verimlilik: Her hedef için tek bir oturum (yinelenme yok)\nBağlı Olmayan Oturumlar Özellikler: - NS message (NS iletisi) içinde statik anahtar yok (flags bölümü tamamen sıfırdır) - Alıcı gönderenin kimliğini belirleyemez - Yalnızca tek yönlü iletişim - Aynı hedefe birden çok oturuma izin verilir\nKullanım Senaryoları: - Ham datagramlar (fire-and-forget - gönder-ve-unut) - Anonim yayınlama - Yayın tarzı mesajlaşma\nÖzellikler: - Daha anonim (gönderici tanımlaması yok) - Daha verimli (el sıkışmada 1 DH (Diffie-Hellman anahtar değişimi) ile 2 DH) - Yanıt mümkün değil (alıcı nereye yanıt vereceğini bilmiyor) - Oturum ratcheting (adımlı anahtar yenileme) yok (tek seferlik ya da sınırlı kullanım)\nOturum Eşleştirme Eşleştirme, çift yönlü iletişim için gelen bir oturumu giden bir oturumla bağlar.\nEşleştirilmiş Oturumlar Oluşturma Alice\u0026rsquo;in Bakış Açısı (başlatıcı):\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) Bob\u0026rsquo;un Bakış Açısı (yanıtlayan):\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) Oturum Eşleştirmenin Avantajları Bant içi ACK\u0026rsquo;ler: Ayrı bir clove (garlic mesajı içindeki alt iletisi) olmadan iletileri onaylayabilir Verimli ratchet (sürekli anahtar güncelleme mekanizması): Her iki yön birlikte ve eşgüdümlü olarak ilerler Akış denetimi: Eşleştirilmiş oturumlar arasında back-pressure (aşırı yükü kaynağa geri ileterek baskılama) uygulanabilir Durum tutarlılığı: Senkronize durumu sürdürmek daha kolaydır Oturum Eşleştirme Kuralları Giden oturum eşleşmemiş olabilir (bağlı olmayan NS) Bağlı NS için gelen oturum eşleştirilmiş olmalıdır Eşleştirme oturum oluşturma sırasında gerçekleşir, sonrasında değil Eşleştirilmiş oturumlar aynı hedefe bağlıdır Ratchet\u0026rsquo;lar (ardışık anahtar yenileme mekanizması) bağımsız olarak gerçekleşir ancak koordine edilir Oturum Yaşam Döngüsü Oturum Yaşam Döngüsü: Oluşturma Aşaması Giden Oturum Oluşturma (Alice):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session Gelen Oturum Oluşturma (Bob):\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session Oturum Yaşam Döngüsü: Aktif Aşama Durum Geçişleri:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED Aktif Oturum Bakımı:\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) Oturum Yaşam Döngüsü: Sona Erme Aşaması Oturum Zaman Aşımı Değerleri:\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet **Sona Erme Mantığı:** def check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) Kritik Kural: Desenkronizasyonu önlemek için giden oturumların süresi, gelen oturumlardan önce MUTLAKA dolmalıdır.\nDüzenli Sonlandırma:\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() Birden çok NS mesajı Senaryo: Alice\u0026rsquo;in NS iletisi kaybolur ya da NSR yanıtı kaybolur.\nAlice\u0026rsquo;in Davranışı:\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] Önemli Özellikler:\nBenzersiz Geçici Anahtarlar: Her NS farklı bir geçici anahtar kullanır Bağımsız El Sıkışmaları: Her NS ayrı bir el sıkışma durumu oluşturur NSR Korelasyonu: NSR etiketi, hangi NS\u0026rsquo;ye yanıt verdiğini belirler Durum Temizliği: Kullanılmayan NS durumları, başarılı bir NSR\u0026rsquo;den sonra atılır Saldırıların Önlenmesi:\nKaynak tükenmesini önlemek için:\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context Birden fazla NSR mesajı Senaryo: Bob birden fazla NSR gönderir (örn. yanıt verileri birden çok mesaja bölünmüştür).\nBob\u0026rsquo;un Davranışı:\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES Alice\u0026rsquo;nin Davranışı:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake Bob\u0026rsquo;un Temizliği:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED Önemli Özellikler:\nBirden Fazla NSR\u0026rsquo;ye İzin Verilir: Bob, NS başına birden fazla NSR gönderebilir Farklı Geçici Anahtarlar: Her NSR benzersiz bir geçici anahtar kullanmalıdır Aynı NSR Tagset (etiket kümesi): Bir NS için tüm NSR\u0026rsquo;lar aynı tagset kullanır İlk ES Kazanır: Alice\u0026rsquo;in ilk ES\u0026rsquo;si hangi NSR\u0026rsquo;nin başarılı olduğunu belirler ES Sonrası Temizlik: ES alındıktan sonra Bob kullanılmayan durumları atar Oturum Durum Makinesi Tam Durum Diyagramı:\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED Durum Açıklamaları:\nNEW: Giden oturum oluşturuldu, henüz NS gönderilmedi PENDING_REPLY: NS gönderildi, NSR bekleniyor AWAITING_ES: NSR gönderildi, Alice\u0026rsquo;ten ilk ES bekleniyor ESTABLISHED: El sıkışma tamamlandı, ES gönderip/alabilir ACTIVE: ES mesajlarını etkin biçimde değiş tokuş ediyor RATCHETING: DH ratchet (Diffie-Hellman mandalı) sürüyor (ACTIVE alt kümesi) EXPIRED: Oturum zaman aşımına uğradı, silinmeyi bekliyor TERMINATED: Oturum açıkça sonlandırıldı Yük Biçimi Tüm ECIES (Eliptik Eğri Entegre Şifreleme Şeması) iletilerinin (NS, NSR, ES) yük bölümü, NTCP2\u0026rsquo;ye benzer blok tabanlı bir biçim kullanır.\nBlok Yapısı Genel Biçim:\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Alanlar:\nblk: 1 bayt - Blok tür numarası size: 2 bayt - Veri alanının big-endian (büyük anlamlı bayt sıralaması) boyutu (0-65516) data: Değişken uzunluk - Bloğa özgü veri Kısıtlamalar:\nMaksimum ChaChaPoly çerçevesi: 65535 bayt Poly1305 MAC: 16 bayt Maksimum toplam blok boyutu: 65519 bayt (65535 - 16) Maksimum tek blok: 65519 bayt (3 baytlık başlık dahil) Maksimum tek blok verisi: 65516 bayt Blok Türleri Tanımlı Blok Türleri:\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension **Bilinmeyen Blokların İşlenmesi:** Gerçekleştirimler, tür numaraları bilinmeyen blokları yok saymak ve bunları dolgu olarak değerlendirmek zorundadır. Bu, ileriye dönük uyumluluğu sağlar.\nBlok Sıralama Kuralları NS Mesaj Sıralaması Zorunlu: - DateTime bloğu MUTLAKA en başta olmalıdır\nİzin verilenler: - Garlic Clove (garlic encryption içinde tekil mesaj parçası) (type 11) - Seçenekler (type 5) - uygulanmışsa - Dolgu (type 254)\nYasak: - NextKey (sonraki anahtar), ACK (alındı onayı), ACK Request (alındı onayı isteği), Termination (sonlandırma), MessageNumbers (ileti numaraları)\nÖrnek Geçerli NS Yükü:\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) NSR Mesaj Sıralaması Gerekli: - Yok (yük boş olabilir)\nİzin verilenler: - Garlic Clove (Garlic Message içindeki alt birim) (tip 11) - Options (tip 5) - eğer uygulanmışsa - Padding (tip 254)\nYasak: - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers\nGeçerli NSR Yükü Örneği:\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) veya\n(empty - ACK only) ES Mesaj Sıralaması Gerekli: - Yok (payload (yük) boş olabilir)\nİzin verilen (herhangi bir sırada): - Garlic Clove (garlic mesajındaki alt birim) (type 11) - NextKey (Sonraki Anahtar) (type 7) - ACK (type 8) - ACK Request (ACK İsteği) (type 9) - Termination (Sonlandırma) (type 4) - uygulanmışsa - MessageNumbers (Mesaj Numaraları) (type 6) - uygulanmışsa - Options (Seçenekler) (type 5) - uygulanmışsa - Padding (Dolgu) (type 254)\nÖzel Kurallar: - Sonlandırma bloğu (Padding hariç) en sonda OLMALIDIR - Padding (doldurma) bloğu en sonda OLMALIDIR - Birden fazla Garlic Cloves (garlic mesajındaki alt mesaj birimleri) kullanılabilir - En fazla 2 NextKey (bir sonraki anahtar bilgisi) bloğuna izin verilir (ileri ve geri) - Birden fazla Padding bloğuna İZİN VERİLMEZ\nGeçerli ES Yüklerine Örnekler:\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) Tarih-Saat Bloğu (Tür 0) Amaç: Yeniden oynatma (replay) saldırılarını önleme ve saat kayması (clock skew) doğrulaması için zaman damgası\nBoyut: 7 bayt (3 bayt başlık + 4 bayt veri)\nBiçim:\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Alanlar:\nblk: 0 size: 4 (big-endian - yüksek anlamlı bayt önce) timestamp: 4 bayt - saniye cinsinden Unix zaman damgası (işaretsiz, big-endian) Zaman Damgası Biçimi:\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) Doğrulama Kuralları:\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True Replay Saldırılarını Önleme:\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass Uygulama Notları:\nNS Mesajları: DateTime MUTLAKA ilk blok olmalıdır NSR/ES Mesajları: DateTime genellikle dahil edilmez Yeniden Oynatma Penceresi: 5 dakika önerilen asgari süredir Bloom Filtresi: Verimli yeniden oynatma tespiti için önerilir Saat Kayması: Geçmişte 5 dakikaya, gelecekte 2 dakikaya izin verin Garlic Clove Block (Sarımsak Dişi Bloğu) (Type 11) Amaç: İletilmek üzere I2NP mesajlarını kapsüller\nBiçim:\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ Alanlar:\nblk: 11 size: clove (garlic encryption içindeki alt-ileti) toplam boyutu (değişken) Delivery Instructions: I2NP spesifikasyonunda belirtildiği gibi type: I2NP mesaj türü (1 bayt) Message_ID: I2NP mesaj kimliği (4 bayt) Expiration: Saniye cinsinden Unix zaman damgası (4 bayt) I2NP Message body: Değişken uzunluklu mesaj verisi Teslimat Talimatı Biçimleri:\nYerel Teslimat (1 bayt):\n+----+ |0x00| +----+ Hedefe Teslim (33 bayt):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Router Teslimi (33 bayt):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Tunnel Teslimi (37 bayt):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ I2NP Mesaj Başlığı (toplam 9 bayt):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: I2NP mesaj türü (Database Store, Database Lookup, Data, vb.) msg_id: 4 baytlık mesaj kimliği expiration: 4 baytlık Unix zaman damgası (saniye) ElGamal Clove Formatı\u0026rsquo;ndan Önemli Farklar:\nSertifika Yok: Sertifika alanı dahil edilmedi (ElGamal\u0026rsquo;de kullanılmıyor) Clove ID Yok: Clove (garlic mesajı içindeki alt mesaj) ID\u0026rsquo;si dahil edilmedi (her zaman 0\u0026rsquo;dı) Clove Zaman Aşımı Yok: Bunun yerine I2NP mesaj zaman aşımı kullanılır Kompakt Başlık: 9 baytlık I2NP başlığı vs daha büyük ElGamal biçimi Her Clove Ayrı Bir Bloktur: CloveSet yapısı yok Birden Çok Clove (garlic mesajı içindeki alt-mesaj birimi):\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] Cloves (garlic mesajındaki alt mesajlar) içindeki yaygın I2NP mesaj türleri:\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages **Clove Processing (Clove'un işlenmesi):** def process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) NextKey Block (sonraki anahtar bloğu) (Tip 7) Amaç: DH ratchet (ardışık anahtar yenileme mekanizması) anahtar değişimi\nBiçim (Anahtar Mevcut - 38 bayt):\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ Biçim (Yalnızca Anahtar Kimliği - 6 bayt):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ Alanlar:\nblk: 7 size: 3 (yalnızca ID) veya 35 (anahtarla) flag: 1 bayt - Bayrak bitleri key ID: 2 bayt - Big-endian anahtar tanımlayıcısı (0-32767) Public Key: 32 bayt - X25519 ortak anahtar (little-endian), eğer bayrak bit 0 = 1 ise Bayrak Bitleri:\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) Bayrak Örnekleri:\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 Anahtar Kimliği Kuralları:\nID\u0026rsquo;ler ardışık: 0, 1, 2, \u0026hellip;, 32767 ID yalnızca yeni bir anahtar üretildiğinde artar Bir sonraki ratchet (anahtar ilerletme mekanizması) gerçekleşene kadar birden çok mesaj için aynı ID kullanılır En yüksek ID 32767\u0026rsquo;dir (sonrasında yeni bir oturum başlatılmalıdır) Kullanım Örnekleri:\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) İşleme Mantığı:\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) Birden Çok NextKey Bloğu:\nHer iki yön eşzamanlı olarak ratcheting (kademeli anahtar yenileme mekanizması) yapıyorsa, tek bir ES mesajı en fazla 2 NextKey bloğu içerebilir:\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] ACK Bloğu (Tip 8) Amaç: Alınan mesajları bant içi olarak onaylamak\nBiçim (Tekli ACK (onay) - 7 bayt):\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ Biçim (Birden Çok ACK):\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Alanlar:\nblk: 8 size: 4 * ACK sayısı (en az 4) Her ACK için: tagsetid: 2 bayt - Big-endian (en anlamlı bayt önce) etiket kümesi kimliği (0-65535) N: 2 bayt - Big-endian mesaj numarası (0-65535) Tag Set ID (etiket kümesi kimliği) Belirlenmesi:\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 Tek ACK Örneği:\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) Birden Çok ACK Örneği:\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) İşleme:\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) ACK\u0026rsquo;ler Ne Zaman Gönderilmeli:\nAçık ACK İsteği: ACK İsteği bloğuna her zaman yanıt verin LeaseSet Teslimi: Gönderen, iletiye LeaseSet eklediğinde Oturum Kurulumu: NS/NSR\u0026rsquo;yi ACK edebilir (NS/NSR: New Session/New Session Reply - Yeni Oturum/Yeni Oturum Yanıtı; protokol her ne kadar ES (Existing Session - Mevcut Oturum) üzerinden örtük ACK\u0026rsquo;i tercih etse de) Ratchet Onayı: NextKey (bir sonraki anahtar) alımını ACK edebilir (ratchet: kriptografik anahtar ilerletme mekanizması) Uygulama Katmanı: Üst katman protokolünün gerektirdiği şekilde (ör. Streaming (I2P akış katmanı)) ACK Zamanlaması:\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None ACK İstek Bloğu (Tip 9) Amaç: Mevcut mesaj için bant içi alındı onayı talep etmek\nBiçim:\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ Alanlar:\nblk: 9 size: 1 flg: 1 bayt - Bayraklar (tüm bitler şu anda kullanılmamaktadır, 0\u0026rsquo;a ayarlanmıştır) Kullanım:\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] Alıcı Yanıtı:\nACK isteği alındığında:\nAnlık Veriyle: ACK bloğunu anlık yanıta dahil edin Anlık Veri Olmadan: Bir zamanlayıcı başlatın (ör. 100ms) ve zamanlayıcı süresi dolarsa ACK ile boş bir ES gönderin Tag Set ID (etiket kümesi kimliği): Geçerli gelen tagset kimliğini kullanın Mesaj Numarası: Alınan session tag (oturum etiketi) ile ilişkili mesaj numarasını kullanın İşleme:\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) ACK İsteği ne zaman kullanılır:\nKritik Mesajlar: Alındı onayı verilmesi gereken mesajlar LeaseSet Teslimi: Bir LeaseSet\u0026rsquo;i paket içine dahil ederken Session Ratchet (oturum ratchet mekanizması): NextKey block (bir sonraki anahtar bloğu) gönderdikten sonra İletimin Sonu: Gönderenin artık gönderecek verisi kalmadığında ancak onay istediğinde Ne Zaman Kullanılmamalı:\nAkış Protokolü: Akış katmanı ACK\u0026rsquo;leri (alındı onayı) işler Yüksek Frekanslı Mesajlar: Her mesaj için ACK isteğinden kaçının (ek yük) Önemsiz Datagramlar: Ham datagramlar genellikle ACK\u0026rsquo;lere gerek duymaz Sonlandırma Bloğu (Tür 4) Durum: UYGULANMADI\nAmaç: Oturumu sorunsuz bir şekilde sonlandırmak\nBiçim:\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ Alanlar:\nblk: 4 size: 1 veya daha fazla bayt rsn: 1 bayt - Sebep kodu addl data: İsteğe bağlı ek veri (biçim nedene bağlıdır) Gerekçe Kodları:\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific **Kullanım (uygulandığında):** # Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) Kurallar:\nPadding (doldurma) dışında son blok olmak ZORUNLUDUR Varsa Termination (sonlandırma) sonrasında Padding gelmesi ZORUNLUDUR NS veya NSR iletilerinde izin verilmez Yalnızca ES iletilerinde izin verilir Seçenekler Bloğu (Tür 5) Durum: UYGULANMADI\nAmaç: Oturum parametrelerinin müzakere edilmesi\nBiçim:\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Alanlar:\nblk: 5 size: 21 veya daha fazla bayt ver: 1 bayt - Protokol sürümü (0 olmalı) flg: 1 bayt - Bayraklar (şu anda tüm bitler kullanılmıyor) STL: 1 bayt - Oturum etiketi uzunluğu (8 olmalı) STimeout: 2 bayt - Oturum boşta kalma zaman aşımı (saniye cinsinden, big-endian) SOTW: 2 bayt - Gönderen Giden Etiket Penceresi (big-endian) RITW: 2 bayt - Alıcı Gelen Etiket Penceresi (big-endian) tmin, tmax, rmin, rmax: Her biri 1 bayt - Dolgu parametreleri (4.4 sabit noktalı) tdmy: 2 bayt - Göndermeye istekli olunan en yüksek dummy traffic (sahte trafik) (bytes/sec, big-endian) rdmy: 2 bayt - İstenen dummy traffic (bytes/sec, big-endian) tdelay: 2 bayt - Eklemeye istekli olunan en yüksek mesaj içi gecikme (msec, big-endian) rdelay: 2 bayt - İstenen mesaj içi gecikme (msec, big-endian) more_options: Değişken uzunluklu - Gelecekteki genişletmeler Dolgu Parametreleri (4.4 Sabit Noktalı):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) Tag Window Negotiation (Etiket Penceresi Müzakeresi):\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size Varsayılan Değerler (Seçenekler müzakere edilmediğinde):\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } Mesaj Numaraları Bloğu (Tür 6) Durum: UYGULANMADI\nAmaç: Önceki etiket kümesinde gönderilen son mesajı belirtir (boşluk algılamayı etkinleştirir)\nBiçim:\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ Alanlar:\nblk: 6 size: 2 PN: 2 bayt - Önceki etiket kümesinin son ileti numarası (big-endian (yüksek anlamlı bayt önce), 0-65535) PN (Previous Number - Önceki Numara) Tanımı:\nPN, önceki etiket kümesinde gönderilen son etiketin indeksidir.\nKullanım (uygulandığında):\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] Alıcı Faydaları:\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) Kurallar:\n0 numaralı etiket kümesinde kesinlikle gönderilmemelidir (önceki etiket kümesi yok) Yalnızca ES messages (ES iletileri) içinde gönderilir Yalnızca yeni etiket kümesinin ilk ileti(ler)inde gönderilir PN değeri, gönderenin bakış açısına göredir (gönderenin gönderdiği son etiket) Signal ile ilişkisi:\nSignal Double Ratchet\u0026rsquo;te, PN mesaj başlığındadır. ECIES\u0026rsquo;te ise şifreli yük içinde bulunur ve isteğe bağlıdır.\nDolgu Bloğu (Tür 254) Amaç: Trafik analizine karşı direnç ve mesaj boyutunun gizlenmesi\nBiçim:\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Alanlar:\nblk: 254 size: 0-65516 bayt (big-endian; yüksek anlamlı bayt önde) padding: Rastgele veya sıfır veri Kurallar:\nMesajdaki son blok olmalıdır Birden fazla dolgu bloğuna izin verilmez Sıfır uzunlukta olabilir (yalnızca 3 baytlık başlık) Dolgu verisi sıfır değerli baytlar veya rastgele baytlar olabilir Varsayılan Doldurma:\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) Trafik Analizi Direncine Yönelik Stratejiler:\nStrateji 1: Rastgele Boyut (Varsayılan)\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Strateji 2: En Yakın Katına Yuvarlama\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Strateji 3: Sabit Mesaj Boyutları\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Strateji 4: Müzakere Edilen Dolgu (Seçenekler bloğu)\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Yalnızca Dolgudan Oluşan Mesajlar:\nMesajlar tamamen dolgudan oluşabilir (uygulama verisi içermez):\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] Uygulama Notları:\nTamamen Sıfır Dolgu: Kabul edilebilir (ChaCha20 tarafından şifrelenecektir) Rastgele Dolgu: Şifrelemeden sonra ek bir güvenlik sağlamaz ancak daha fazla entropi kullanır Performans: Rastgele dolgu üretimi hesaplama açısından maliyetli olabilir; sıfır kullanmayı değerlendirin Bellek: Büyük dolgu blokları bant genişliğini tüketir; maksimum boyut konusunda dikkatli olun Uygulama Kılavuzu Önkoşullar Kriptografik Kütüphaneler:\nX25519: libsodium, NaCl veya Bouncy Castle ChaCha20-Poly1305: libsodium, OpenSSL 1.1.0+ veya Bouncy Castle SHA-256: OpenSSL, Bouncy Castle veya yerleşik dil desteği Elligator2: Sınırlı kütüphane desteği; özel gerçekleştirim gerektirebilir Elligator2 (eliptik eğri noktalarını rastgele görünümlü veriye eşleyen teknik) Uygulaması:\nElligator2 yaygın olarak uygulanmıyor. Seçenekler:\nOBFS4: Tor\u0026rsquo;un obfs4 pluggable transport (takılabilir taşıma) özelliği Elligator2 gerçekleştirmesini içerir Özel Gerçekleme: Elligator2 makalesi temel alınarak kleshni/Elligator: GitHub\u0026rsquo;da referans uygulaması Java I2P Notu: Java I2P, özel Elligator2 (bir kriptografik gizleme tekniği) eklemeleriyle net.i2p.crypto.eddsa kütüphanesini kullanır.\nÖnerilen Uygulama Sırası Aşama 1: Temel Kriptografi 1. X25519 DH (Diffie-Hellman) anahtar üretimi ve değişimi 2. ChaCha20-Poly1305 AEAD (İlişkili Verili Kimlik Doğrulamalı Şifreleme) şifreleme/şifre çözme 3. SHA-256 karmalama ve MixHash (durum karmasını güncelleme işlemi) 4. HKDF (HMAC tabanlı anahtar türetme fonksiyonu) ile anahtar türetme 5. Elligator2 (eliptik eğri noktalarını rastgele görünüme eşleyen kodlama) kodlama/kod çözme (başlangıçta test vektörleri kullanılabilir)\nAşama 2: Mesaj Biçimleri 1. NS message (bağlı olmayan) - en basit biçim 2. NS message (bağlı) - statik anahtar ekler 3. NSR message 4. ES message 5. Blok ayrıştırma ve oluşturma\nAşama 3: Oturum Yönetimi 1. Oturum oluşturma ve depolama 2. Etiket kümesi yönetimi (gönderen ve alıcı) 3. Oturum etiketi ratchet (kademeli yenileme mekanizması) 4. Simetrik anahtar ratchet 5. Etiket arama ve pencere yönetimi\nAşama 4: DH Ratcheting (Diffie-Hellman kademeli mekanizması) 1. NextKey blokunun işlenmesi 2. DH ratchet KDF (Anahtar Türetme Fonksiyonu) 3. Ratchet sonrasında etiket kümesi oluşturma 4. Birden çok etiket kümesinin yönetimi\nAşama 5: Protokol Mantığı 1. NS/NSR/ES durum makinesi 2. Tekrar saldırısı önleme (DateTime, Bloom filtresi) 3. Yeniden iletim mantığı (çoklu NS/NSR) 4. ACK işleme\nAşama 6: Entegrasyon 1. I2NP Garlic Clove (garlic encryption içindeki \u0026lsquo;diş\u0026rsquo; öğesi) işleme 2. LeaseSet paketleme 3. Akış protokolü entegrasyonu 4. Datagram protokolü entegrasyonu\nGönderici Gerçeklemesi Giden Oturum Yaşam Döngüsü:\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() Alıcı Gerçeklemesi Gelen Oturumun Yaşam Döngüsü:\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() Mesaj Sınıflandırması Mesaj Türlerini Ayırt Etme:\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type Oturum Yönetimi En İyi Uygulamaları Oturum Depolama:\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] Bellek Yönetimi:\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 Test Stratejileri Birim Testleri:\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 Entegrasyon Testleri:\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 Test Vektörleri:\nSpesifikasyonda yer alan test vektörlerini uygulayın:\nNoise IK el sıkışması: Standart Noise test vektörlerini kullanın HKDF: RFC 5869 test vektörlerini kullanın ChaCha20-Poly1305: RFC 7539 test vektörlerini kullanın Elligator2: Elligator2 makalesinden veya OBFS4\u0026rsquo;ten test vektörlerini kullanın Birlikte Çalışabilirlik Testleri:\nJava I2P: Java I2P referans uygulamasına karşı test edin i2pd: C++ i2pd uygulamasına karşı test edin Paket Yakalamaları: Mesaj biçimlerini doğrulamak için Wireshark dissector (varsa) kullanın Uygulamalar Arası: Uygulamalar arasında gönderme/alma yapabilen bir test düzeneği oluşturun Performansla İlgili Hususlar Anahtar Üretimi:\nElligator2 (kriptografik eşleme yöntemi) anahtar üretimi hesaplama açısından pahalıdır (%50 reddedilme oranı):\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() Etiket Sorgulaması:\nO(1) etiket araması için hash tabloları kullanın:\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) Bellek Optimizasyonu:\nSimetrik anahtar üretimini ertele:\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key Toplu İşleme:\nBirden çok mesajı toplu olarak işleyin:\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results Güvenlik Hususları Tehdit Modeli Saldırganın Yetenekleri:\nPasif Gözlemci: Tüm ağ trafiğini gözlemleyebilir Aktif Saldırgan: İletileri enjekte edebilir, değiştirebilir, düşürebilir, yeniden oynatabilir Kompromize Düğüm: Bir router\u0026rsquo;ı veya bir hedefi kompromize edebilir Trafik Analizi: Trafik kalıpları üzerinde istatistiksel analiz yapabilir Güvenlik Hedefleri:\nGizlilik: Mesaj içerikleri gözlemciden gizlenir Kimlik Doğrulama: Göndericinin kimliği doğrulanır (bağlı oturumlar için) İleri Gizlilik: Anahtarlar ele geçirilse bile geçmiş mesajlar gizli kalır Yeniden Oynatmayı Önleme: Eski mesajlar yeniden oynatılamaz Trafik Gizleme: El sıkışmaları rastgele veriden ayırt edilemez Kriptografik Varsayımlar Zorluk Varsayımları:\nX25519 CDH: Curve25519 üzerinde Hesaplamalı Diffie-Hellman (CDH) probleminin çözümü hesaplamalı olarak zordur ChaCha20 PRF: ChaCha20 bir psödo-rastgele fonksiyondur Poly1305 MAC: Poly1305, seçilmiş mesaj saldırısı altında taklit edilemezlik sağlar SHA-256 CR: SHA-256 çakışmaya dayanıklıdır HKDF Security: HKDF, anahtarları eş dağılımlı olacak şekilde çıkarır ve genişletir Güvenlik Düzeyleri:\nX25519: ~128-bit güvenlik düzeyi (eğrinin mertebesi 2^252) ChaCha20: 256-bit anahtarlar, 256-bit güvenlik düzeyi Poly1305: 128-bit güvenlik düzeyi (çakışma olasılığı) SHA-256: 128-bit çakışma direnci, 256-bit ön-imaj direnci Anahtar Yönetimi Anahtar Oluşturma:\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) Anahtar Depolama:\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] Anahtar Döndürme:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age Saldırı Azaltma Önlemleri Yeniden Oynatma Saldırılarına Karşı Önlemler DateTime (tarih-saat) Doğrulaması:\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True NS Mesajları için Bloom Filtresi:\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] Session Tag (oturum etiketi) Tek Seferlik Kullanım:\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index Key Compromise Impersonation (KCI) (anahtar ele geçirilmesi kaynaklı kimlik taklidi) için Önlemler Sorun: NS mesaj kimlik doğrulaması KCI\u0026rsquo;ye (Key Compromise Impersonation - anahtar ele geçirilmesiyle kimlik taklidi) karşı savunmasızdır (Kimlik Doğrulama Düzeyi 1)\nAzaltma:\nMümkün olan en kısa sürede NSR (Authentication Level 2 - Kimlik Doğrulama Seviyesi 2) durumuna geçin Güvenlik açısından kritik işlemler için NS payload (yük)\u0026lsquo;a güvenmeyin Geri döndürülemez işlemleri gerçekleştirmeden önce NSR onayını bekleyin def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) Hizmet Reddi (DoS) Azaltma Önlemleri NS Flood Koruması:\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 Etiket Depolama Sınırları:\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count Uyarlanabilir Kaynak Yönetimi:\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } Trafik Analizi Direnci Elligator2 (eliptik eğri noktalarını rastgele veri gibi gösteren bir teknik) Kodlaması:\nEl sıkışma mesajlarının rastgele veriden ayırt edilemez olmasını sağlar:\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string Dolgu Stratejileri:\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) Zamanlama Saldırıları:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) Uygulama Tuzakları Yaygın Hatalar:\nNonce (tek kullanımlık sayı) Yeniden Kullanımı: (key, nonce) çiftlerini ASLA yeniden kullanmayın # BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC İYİ: Her mesaj için benzersiz nonce (tek kullanımlık sayı) ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) 2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR ```python # KÖTÜ: Geçici anahtarın yeniden kullanımı ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # KÖTÜ # İYİ: Her mesaj için yeni bir anahtar send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator KÖTÜ: Kriptografik olmayan rastgele sayı üreteci (RNG) import random key = bytes([random.randint(0, 255) for _ in range(32)]) # GÜVENSİZ DOĞRU: Kriptografik olarak güvenli rastgele sayı üreteci import os key = os.urandom(32) 4. **Timing Attacks**: Use constant-time comparisons ```python # KÖTÜ: Erken çıkışlı karşılaştırma if computed_mac == received_mac: # Zamanlama sızıntısı pass # İYİ: Sabit zamanlı karşılaştırma if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data YANLIŞ: Doğrulamadan önce şifre çözme plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # ÇOK GEÇ if not mac_ok: return error DOĞRU: AEAD (ek verili kimlik doğrulamalı şifreleme) şifre çözmeden önce doğrular try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError:\nreturn error 6. **Key Deletion**: Securely wipe keys from memory ```python # KÖTÜ: Basit silme del private_key # Hâlâ bellekte # İYİ: Silmeden önce üzerine yazın for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# Güvenlik açısından kritik test vakaları def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# Yalnızca ECIES (Eliptik Eğri Entegre Şifreleme Şeması) (yeni kurulumlar için önerilir) i2cp.leaseSetEncType=4 # Çift anahtarlı (uyumluluk için ECIES + ElGamal) i2cp.leaseSetEncType=4,0 # Yalnızca ElGamal (eski, önerilmez) i2cp.leaseSetEncType=0 LeaseSet Type:\n# Standart LS2 (en yaygın) i2cp.leaseSetType=3 # Şifreli LS2 (blinded destinations - körleştirilmiş hedefler) i2cp.leaseSetType=5 # Meta LS2 (birden fazla hedef) i2cp.leaseSetType=7 Additional Options:\n# ECIES (Eliptik Eğri Entegre Şifreleme Şeması) için statik anahtar (isteğe bağlı, belirtilmezse otomatik olarak oluşturulur) # Base64 ile kodlanmış 32 baytlık X25519 (elliptik eğri Diffie-Hellman anahtar değişimi) açık anahtar i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # İmza türü (LeaseSet için) i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# Router\u0026#39;dan router\u0026#39;a ECIES (Eliptik Eğri Entegre Şifreleme Şeması) i2p.router.useECIES=true Build Properties:\n// For I2CP clients (Java) Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[sınırlar] # ECIES (Eliptik Eğri Entegre Şifreleme Şeması) oturumlarının bellek sınırı ecies.memory = 128M [ecies] # ECIES\u0026#39;i etkinleştir (Eliptik Eğri Entegre Şifreleme Şeması) enabled = true # Yalnızca ECIES (Eliptik Eğri Bütünleşik Şifreleme Düzeni) veya çift anahtarlı compatibility = true # true = çift anahtarlı, false = yalnızca ECIES Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Yalnızca ECIES (Eliptik Eğri Tümleşik Şifreleme Şeması) ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# ElGamal\u0026#39;i koruyarak ECIES\u0026#39;i ekleyin i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# Bağlantı türlerini kontrol edin i2prouter.exe status # veya http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# ElGamal\u0026#39;ı kaldır i2cp.leaseSetEncType=4 Step 4: Restart Application\n# I2P router\u0026#39;ı veya uygulamayı yeniden başlatın systemctl restart i2p # veya i2prouter.exe restart Rollback Plan:\n# Sorunlar olursa yalnızca ElGamal\u0026#39;a geri dönün i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# Maksimum gelen oturum sayısı i2p.router.maxInboundSessions=1000 # En fazla giden oturum sayısı i2p.router.maxOutboundSessions=1000 # Oturum zaman aşımı (saniye) i2p.router.sessionTimeout=600 Memory Limits:\n# Etiket depolama sınırı (KB) i2p.ecies.maxTagMemory=10240 # 10 MB # İleri bakış penceresi i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# ratchet (anahtar yenileme mekanizması) öncesi mesajlar i2p.ecies.ratchetThreshold=4096 # Ratchet (kademeli anahtar yenileme mekanizması) başlamadan önceki süre (saniye) i2p.ecies.ratchetTimeout=600 # 10 dakika Monitoring and Debugging Logging:\n# ECIES (Eliptik Eğri Entegre Şifreleme Şeması) hata ayıklama günlüğünü etkinleştir logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # Örnekler print(\u0026#34;NS (bound, 1KB yük):\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;bayt\u0026#34;) # Çıktı: 1120 bayt print(\u0026#34;NSR (1KB veri yükü):\u0026#34;, calculate_nsr_size(1024), \u0026#34;bayt\u0026#34;) # Çıktı: 1096 bayt print(\u0026#34;ES (1KB veri yükü):\u0026#34;, calculate_es_size(1024), \u0026#34;bayt\u0026#34;) # Çıktı: 1048 bayt Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"I2P için Eliptik Eğri Bütünleşik Şifreleme Şeması (X25519 + AEAD)","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"ECIES-X25519-AEAD-Ratchet (kademeli anahtar yenileme mekanizması) Şifreleme Şartnamesi","url":"/tr/docs/specs/ecies/"},{"categories":null,"content":"Gerçekleştirim Durumu Güncel Dağıtım: - i2pd (C++ implementasyonu): ML-KEM-512, ML-KEM-768 ve ML-KEM-1024 desteğiyle 2.58.0 sürümünde (Eylül 2025) tamamen uygulanmıştır. OpenSSL 3.5.0 veya daha yenisi mevcut olduğunda post-kuantum uçtan uca şifreleme varsayılan olarak etkinleştirilir. - Java I2P: 0.9.67 / 2.10.0 sürümleri itibarıyla (Eylül 2025) henüz uygulanmamıştır. Spesifikasyon onaylanmış olup, uygulama gelecekteki sürümler için planlanmaktadır.\nBu belirtim, i2pd\u0026rsquo;de hâlihazırda devreye alınmış ve Java I2P gerçekleştirimleri için planlanan onaylı işlevselliği tanımlar.\nGenel Bakış Bu, ECIES-X25519-AEAD-Ratchet protokolünün ECIES kuantum sonrası hibrit varyantıdır. Onaylanması beklenen Öneri 169’un Prop169 ilk aşamasını temsil eder. Genel hedefler, tehdit modelleri, analiz, alternatifler ve ek bilgiler için söz konusu öneriye bakın.\nÖneri 169 durumu: Açık (hibrit ECIES uygulamasının ilk aşaması onaylandı).\nBu spesifikasyon, standart ECIES \u0026rsquo;ten yalnızca farkları içerir ve söz konusu spesifikasyonla birlikte okunmalıdır.\nTasarım Hibrit el sıkışmaları, klasik X25519 Diffie-Hellman’ı kuantum sonrası ML-KEM anahtar kapsülleme mekanizmalarıyla birleştirir. Bu yaklaşım, PQNoise araştırmasında belgelenen hibrit ileri gizlilik kavramlarına ve TLS 1.3, IKEv2 ve WireGuard’daki benzer uygulamalara dayanır.\nAnahtar Değişimi Ratchet (anahtar yenileme mekanizması) için hibrit bir anahtar değişimi tanımlıyoruz. Post-quantum KEM (anahtar kapsülleme mekanizması) yalnızca geçici anahtarlar sağlar ve Noise IK gibi statik anahtarlı el sıkışmalarını doğrudan desteklemez.\nFIPS203 \u0026rsquo;te belirtildiği üzere üç ML-KEM varyantını tanımlıyoruz; böylece toplamda 3 yeni şifreleme türü elde ediliyor. Hibrit türler yalnızca X25519 ile birlikte tanımlanır.\nYeni şifreleme türleri şunlardır:\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 **Not:** MLKEM768_X25519 (Type 6), makul düzeyde ek yükle güçlü kuantum sonrası güvenlik sağlayan önerilen varsayılan varyanttır. Yalnızca X25519 kullanan şifrelemeyle karşılaştırıldığında ek yük önemli ölçüde fazladır. IK pattern (Noise el sıkışma deseni) için tipik 1 ve 2 numaralı ileti boyutları (ek yükten önce) şu anda yaklaşık 96-103 bayttır. Bu değer, ileti türüne bağlı olarak MLKEM512 için yaklaşık 9-12 kat, MLKEM768 için 13-16 kat ve MLKEM1024 için 17-23 kat artacaktır.\nYeni Şifreleme Gerekli ML-KEM (eski adıyla CRYSTALS-Kyber) FIPS203 - Modül-örgü tabanlı Anahtar Kapsülleme Mekanizması Standardı SHA3-256 (eski adıyla Keccak-512) FIPS202 - SHA-3 Standardının parçası SHAKE128 and SHAKE256 (SHA3 için XOF uzantıları) FIPS202 - Genişletilebilir Çıktı Fonksiyonları SHA3-256, SHAKE128 ve SHAKE256 için test vektörleri NIST Kriptografik Algoritma Doğrulama Programı adresinde mevcuttur.\nKütüphane Desteği: - Java: Bouncycastle kütüphanesi sürüm 1.79 ve sonrası tüm ML-KEM (modül-kafes tabanlı anahtar kapsülleme mekanizması) varyantlarını ve SHA3/SHAKE işlevlerini destekler - C++: OpenSSL 3.5 ve sonrası tam ML-KEM desteği içerir (Nisan 2025\u0026rsquo;te yayımlandı) - Go: ML-KEM ve SHA3 gerçek­lemesi için birden çok kütüphane mevcut\nŞartname Ortak Yapılar Anahtar uzunlukları ve tanımlayıcılar hakkında bilgi için Common Structures Specification belgesine bakın.\nEl Sıkışma Desenleri El sıkışmaları, hibrit kuantum sonrası güvenlik için I2P\u0026rsquo;ye özgü uyarlamalarla Noise Protocol Framework (Noise Protokol Çerçevesi) el sıkışma kalıplarını kullanır.\nAşağıdaki harf eşlemesi kullanılır:\ne = tek kullanımlık geçici anahtar (X25519) s = statik anahtar p = mesaj yükü e1 = tek kullanımlık geçici PQ (post-quantum - kuantum-sonrası) anahtar, Alice\u0026rsquo;ten Bob\u0026rsquo;a gönderilen (I2P\u0026rsquo;ye özgü belirteç) ekem1 = KEM (Key Encapsulation Mechanism - Anahtar Kapsülleme Mekanizması) şifreli metni, Bob\u0026rsquo;dan Alice\u0026rsquo;e gönderilen (I2P\u0026rsquo;ye özgü belirteç) Önemli Not: \u0026ldquo;IKhfs\u0026rdquo; ve \u0026ldquo;IKhfselg2\u0026rdquo; desen adları ile \u0026ldquo;e1\u0026rdquo; ve \u0026ldquo;ekem1\u0026rdquo; belirteçleri, resmi Noise Protocol Framework spesifikasyonunda belgelenmeyen, I2P’ye özgü uyarlamalardır. Bunlar, ML-KEM’i Noise IK desenine entegre etmek için özel tanımları temsil eder. Hibrit X25519 + ML-KEM yaklaşımı post-kuantum kriptografi araştırmalarında ve diğer protokollerde yaygın olarak kabul görse de, burada kullanılan özgül adlandırma I2P’ye özgüdür.\nHibrit ileri gizlilik için IK\u0026rsquo;ye yönelik aşağıdaki değişiklikler uygulanır:\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. e1 deseni aşağıdaki gibi tanımlanır:\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) ekem1 örüntüsü aşağıdaki gibi tanımlanır:\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) Tanımlanmış ML-KEM (Modüler Kafes Tabanlı Anahtar Kapsülleme Mekanizması) İşlemleri FIPS203 \u0026rsquo;te belirtildiği gibi kriptografik yapı taşlarına karşılık gelen aşağıdaki fonksiyonları tanımlıyoruz.\n(encap_key, decap_key) = PQ_KEYGEN() : Alice kapsülleme ve dekapsülleme anahtarlarını oluşturur. Kapsülleme anahtarı NS mesajında gönderilir. Anahtar boyutları: - ML-KEM-512: encap_key = 800 bayt, decap_key = 1632 bayt - ML-KEM-768: encap_key = 1184 bayt, decap_key = 2400 bayt - ML-KEM-1024: encap_key = 1568 bayt, decap_key = 3168 bayt\n(ciphertext, kem_shared_key) = ENCAPS(encap_key) : Bob, NS mesajında alınan enkapsülasyon anahtarını kullanarak şifreli metni ve paylaşılan anahtarı hesaplar. Şifreli metin NSR mesajında gönderilir. Şifreli metin boyutları: - ML-KEM-512: 768 bayt - ML-KEM-768: 1088 bayt - ML-KEM-1024: 1568 bayt\nkem_shared_key, üç varyantın tamamında her zaman 32 bayt\u0026rsquo;tır.\nkem_shared_key = DECAPS(ciphertext, decap_key) : Alice, NSR mesajında aldığı şifreli metni kullanarak paylaşılan anahtarı hesaplar. kem_shared_key her zaman 32 bayt uzunluğundadır.\nÖnemli: encap_key ve ciphertext, Noise (kriptografik el sıkışma protokolü) el sıkışması mesajları 1 ve 2\u0026rsquo;deki ChaCha20-Poly1305 blokları içinde şifrelenir. El sıkışma sürecinin bir parçası olarak bunların şifresi çözülecektir.\nkem_shared_key, MixKey() ile zincirleme anahtarına karıştırılır. Ayrıntılar için aşağıya bakın.\nNoise Handshake KDF (anahtar türetme fonksiyonu) Genel Bakış Hibrit el sıkışması, klasik X25519 ECDH ile post-kuantum ML-KEM (Key Encapsulation Mechanism — anahtar kapsülleme mekanizması) birleştirir. Alice’ten Bob’a giden ilk mesaj, mesaj yükünden önce e1’i (ML-KEM kapsülleme anahtarı) içerir. Bu, ek anahtar malzemesi olarak değerlendirilir; bunun üzerinde (Alice olarak) EncryptAndHash() ya da (Bob olarak) DecryptAndHash() çağırın. Ardından mesaj yükünü her zamanki gibi işleyin.\nBob\u0026rsquo;dan Alice\u0026rsquo;e giden ikinci mesaj, mesaj yükünden önce ekem1\u0026rsquo;i (the ML-KEM ciphertext) (ML-KEM ile üretilmiş şifreli veri) içerir. Bu, ek anahtar malzemesi olarak değerlendirilir; ekem1 üzerinde EncryptAndHash() (Bob olarak) ya da DecryptAndHash() (Alice olarak) çağırın. Ardından kem_shared_key\u0026rsquo;i hesaplayın ve MixKey(kem_shared_key) çağırın. Sonra mesaj yükünü her zamanki gibi işleyin.\nNoise Tanımlayıcıları Bunlar, Noise (Noise protokol çerçevesi) başlatma dizeleridir (I2P\u0026rsquo;ye özgü):\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 NS Mesajı için Alice KDF (Anahtar Türetme Fonksiyonu) \u0026rsquo;es\u0026rsquo; mesaj deseninden sonra ve \u0026rsquo;s\u0026rsquo; mesaj deseninden önce, şunu ekleyin:\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). NS Mesajı için Bob KDF (anahtar türetme fonksiyonu) \u0026rsquo;es\u0026rsquo; mesaj kalıbından sonra ve \u0026rsquo;s\u0026rsquo; mesaj kalıbından önce şunu ekleyin:\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). NSR Mesajı için Bob tarafındaki KDF \u0026rsquo;ee\u0026rsquo; mesaj kalıbından sonra ve \u0026lsquo;se\u0026rsquo; mesaj kalıbından önce, şunu ekleyin:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. NSR Mesajı için Alice KDF\u0026rsquo;si \u0026rsquo;ee\u0026rsquo; mesaj deseninden sonra ve \u0026lsquo;ss\u0026rsquo; mesaj deseninden önce şunu ekleyin:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. split() için KDF split() fonksiyonu, standart ECIES spesifikasyonundaki haliyle aynen kullanılır. El sıkışma (handshake) tamamlandıktan sonra:\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] Bunlar, devam eden iletişim için çift yönlü oturum anahtarlarıdır.\nMesaj Biçimi NS (Yeni Oturum) Biçimi Değişiklikler: Mevcut ratchet (kademeli anahtar yenileme mekanizması) ilk ChaCha20-Poly1305 bölümünde statik anahtarı ve ikinci bölümde yükü içerir. ML-KEM ile artık üç bölüm vardır. Birinci bölüm, şifrelenmiş ML-KEM açık anahtarını (encap_key) içerir. İkinci bölüm statik anahtarı içerir. Üçüncü bölüm yükü içerir.\nMesaj Boyutları:\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl **Not:** Yük, bir DateTime bloğu içermelidir (en az 7 bayt: 1 baytlık tür, 2 baytlık boyut, 4 baytlık zaman damgası). Minimum NS boyutları buna göre hesaplanabilir. Bu nedenle, pratikte minimum NS boyutu X25519 için 103 bayttır ve hibrit varyantlarda 919 ile 1687 bayt arasında değişir. Üç ML-KEM (modül kafes tabanlı anahtar kapsülleme mekanizması) varyantı için 816, 1200 ve 1584 baytlık boyut artışları, ML-KEM açık anahtarının ve kimlik doğrulamalı şifreleme için 16 baytlık bir Poly1305 MAC\u0026rsquo;in dahil edilmesinden kaynaklanır.\nNSR (New Session Reply - Yeni Oturum Yanıtı) Formatı Değişiklikler: Mevcut ratchet (anahtar yenileme mekanizması), ilk ChaCha20-Poly1305 bölümünde veri yükünü boş bırakır ve veri yükü ikinci bölümde yer alır. ML-KEM ile artık üç bölüm vardır. Birinci bölüm, ML-KEM şifreli metnini içerir. İkinci bölümün veri yükü boştur. Üçüncü bölüm veri yükünü içerir.\nMesaj Boyutları:\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl Üç ML-KEM varyantı için 784, 1104 ve 1584 baytlık boyut artışları, ML-KEM şifreli metni ile kimlik doğrulamalı şifreleme için 16 baytlık Poly1305 MAC'in toplamından kaynaklanır. Ek Yük Analizi Anahtar Değişimi Hibrit şifrelemenin ek yükü, yalnızca X25519’a kıyasla oldukça fazladır:\nMLKEM512_X25519: El sıkışma mesajı boyutunda yaklaşık 9-12 kat artış (NS: 9.5 kat, NSR: 11.9 kat) MLKEM768_X25519: El sıkışma mesajı boyutunda yaklaşık 13-16 kat artış (NS: 13.5 kat, NSR: 16.3 kat) MLKEM1024_X25519: El sıkışma mesajı boyutunda yaklaşık 17-23 kat artış (NS: 17.5 kat, NSR: 23 kat) Bu ek yük, kuantum sonrası güvenliğin sağladığı ek avantajlar karşılığında kabul edilebilir. Çarpanlar, temel mesaj boyutları farklı olduğundan mesaj türüne göre değişir (NS en az 96 bayt, NSR en az 72 bayt).\nBant Genişliğiyle İlgili Hususlar Minimal yüklerle tipik bir oturum kurulumu için: - Yalnızca X25519 (anahtar değişim algoritması): toplam ~200 bayt (NS + NSR) - MLKEM512_X25519 (MLKEM: kuantuma dayanıklı anahtar kapsülleme; X25519 ile hibrit): toplam ~1,800 bayt (9x artış) - MLKEM768_X25519: toplam ~2,500 bayt (12.5x artış) - MLKEM1024_X25519: toplam ~3,400 bayt (17x artış)\nOturum kurulumu tamamlandıktan sonra, devam eden mesaj şifrelemesi, yalnızca X25519 kullanan oturumlarla aynı veri aktarım biçimini kullanır; bu nedenle sonraki mesajlar için ek yük yoktur.\nGüvenlik Analizi El sıkışmaları Hibrit el sıkışması, hem klasik (X25519) hem de kuantum sonrası (ML-KEM) güvenlik sağlar. Bir saldırganın oturum anahtarlarını kompromize edebilmesi için her ikisini de kırması gerekir: klasik ECDH\u0026rsquo;yi ve kuantum sonrası KEM\u0026rsquo;i.\nBu şunları sağlar: - Mevcut güvenlik: X25519 ECDH (eliptik eğri Diffie–Hellman anahtar değişimi) klasik saldırganlara karşı güvenlik sağlar (128-bit güvenlik seviyesi) - Geleceğe yönelik güvenlik: ML-KEM (kuantum sonrası anahtar kapsülleme mekanizması) kuantum saldırganlara karşı güvenlik sağlar (parametre setine göre değişir) - Hibrit güvenlik: Oturumu ele geçirmek için her ikisinin de kırılması gerekir (güvenlik seviyesi = iki bileşenden en büyüğü)\nGüvenlik Düzeyleri Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit **Not:** Hibrit güvenlik seviyesi, iki bileşenden daha zayıf olanıyla sınırlıdır. Tüm durumlarda X25519, 128 bit klasik güvenlik sağlar. Kriptografik açıdan ilgili bir kuantum bilgisayar kullanılabilir hâle gelirse, güvenlik seviyesi seçilen ML-KEM parametre kümesine bağlı olacaktır. İleri Gizlilik Hibrit yaklaşım, ileri gizlilik özelliklerini korur. Oturum anahtarları, hem geçici X25519 hem de geçici ML-KEM anahtar değişimlerinden türetilir. El sıkışmadan sonra X25519 veya ML-KEM geçici özel anahtarlarından herhangi biri imha edilirse, uzun vadeli statik anahtarlar ele geçirilmiş olsa bile geçmiş oturumların şifresi çözülemez.\nIK pattern (IK deseni), ikinci mesaj (NSR) gönderildikten sonra tam ileri gizlilik (Noise Confidentiality level 5) sağlar.\nTür Tercihleri Gerçeklemeler birden fazla hibrit türünü desteklemeli ve karşılıklı desteklenen en güçlü varyant üzerinde anlaşmalıdır. Tercih sırası şöyle olmalıdır:\nMLKEM768_X25519 (Type 6) - Önerilen varsayılan, güvenlik ve performans arasında en iyi denge MLKEM1024_X25519 (Type 7) - Hassas uygulamalar için en yüksek güvenlik MLKEM512_X25519 (Type 5) - Kaynak kısıtlı senaryolar için temel kuantum sonrası güvenlik X25519 (Type 4) - Yalnızca klasik, uyumluluk için geri dönüş seçeneği Gerekçe: MLKEM768_X25519, varsayılan olarak önerilir çünkü NIST Kategori 3 güvenliği (AES-192 eşdeğeri) sağlar; bu, kuantum bilgisayarlara karşı yeterli koruma olarak kabul edilirken makul mesaj boyutlarını da korur. MLKEM1024_X25519 daha yüksek güvenlik sağlar ancak önemli ölçüde artan ek yüke yol açar.\nUygulama Notları Kütüphane Desteği Java: Bouncycastle kitaplığı sürüm 1.79 (Ağustos 2024) ve sonraki sürümler, gerekli tüm ML-KEM (post-kuantum anahtar kapsülleme mekanizması) varyantlarını ve SHA3/SHAKE işlevlerini destekler. FIPS 203 uyumluluğu için org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine kullanın. C++: OpenSSL 3.5 (Nisan 2025) ve sonrası, EVP_KEM arayüzü üzerinden ML-KEM desteğini içerir. Bu, Nisan 2030\u0026rsquo;a kadar bakımda olan bir Uzun Süreli Destek (LTS) sürümüdür. Go: ML-KEM ve SHA3 için, Cloudflare\u0026rsquo;ın CIRCL kitaplığı da dahil olmak üzere çeşitli üçüncü taraf kitaplıklar mevcuttur. Geçiş Stratejisi Gerçekleştirimler şunları yapmalıdır: 1. Geçiş döneminde yalnızca X25519 ve hibrit ML-KEM varyantlarının her ikisini de desteklemek 2. Her iki eş de desteklediğinde hibrit varyantları tercih etmek 3. Geriye dönük uyumluluk için yalnızca X25519’a fallback (otomatik yedek yönteme geçiş) olanağını sürdürmek 4. Varsayılan varyantı seçerken ağ bant genişliği kısıtlamalarını dikkate almak\nPaylaşılan Tunnels Artan mesaj boyutları paylaşılan tunnel kullanımını etkileyebilir. Uygulamalar şunları dikkate almalıdır: - Mümkün olduğunda ek yükü dağıtmak için el sıkışmalarını toplu biçimde gerçekleştirmek - Saklanan durumu azaltmak için hibrit oturumlar için daha kısa geçerlilik süreleri kullanmak - Bant genişliği kullanımını izlemek ve parametreleri buna göre ayarlamak - Oturum kurulum trafiği için tıkanıklık kontrolü uygulamak\nYeni Oturum Boyutu ile İlgili Hususlar Daha büyük el sıkışma mesajları nedeniyle, gerçekleştirimlerin şunları yapması gerekebilir: - Oturum müzakeresi için arabellek boyutlarını artırmak (en az 4KB önerilir) - Daha yavaş bağlantılar için zaman aşımı değerlerini ayarlamak (~3-17x daha büyük mesajları hesaba katın) - NS/NSR mesajlarındaki yük verisi için sıkıştırmayı değerlendirmek - Taşıma katmanı gerektiriyorsa parçalama desteğini uygulamak\nTest ve Doğrulama Gerçeklemeler şunları doğrulamalıdır: - Doğru ML-KEM anahtar üretimi, enkapsülleme ve dekapsülleme - kem_shared_key değerinin Noise KDF (Noise anahtar türetme fonksiyonu) içine doğru şekilde entegre edilmesi - İleti boyutu hesaplamalarının spesifikasyona uygun olması - Diğer I2P router gerçeklemeleriyle birlikte çalışabilirlik - ML-KEM mevcut olmadığında geri dönüş (fallback) davranışı\nML-KEM işlemleri için test vektörleri NIST Cryptographic Algorithm Validation Program programında mevcuttur.\nSürüm Uyumluluğu I2P Sürüm Numaralandırması: I2P iki paralel sürüm numarası kullanır: - Router yayın sürümü: 2.x.x biçimi (örn., 2.10.0 Eylül 2025\u0026rsquo;te yayımlandı) - API/protokol sürümü: 0.9.x biçimi (örn., 0.9.67 router 2.10.0\u0026rsquo;a karşılık gelir)\nBu belirtim, router sürümü 2.10.0 ve sonrasına karşılık gelen 0.9.67 protokol sürümüne atıfta bulunur.\nUyumluluk Matrisi:\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release ## Referanslar [ECIES]: ECIES-X25519-AEAD-Ratchet Teknik Şartnamesi [Prop169]: Öneri 169: Kuantum Sonrası Kriptografi [FIPS203]: NIST FIPS 203 - ML-KEM Standardı [FIPS202]: NIST FIPS 202 - SHA-3 Standardı [Noise]: Noise Protokol Çerçevesi [COMMON]: Ortak Yapılar Teknik Şartnamesi [RFC7539]: RFC 7539 - ChaCha20 ve Poly1305 [RFC5869]: RFC 5869 - HKDF [OpenSSL]: OpenSSL 3.5 ML-KEM Dokümantasyonu [Bouncycastle]: Bouncycastle Java Kriptografi Kütüphanesi ","description":"ML-KEM (modül-örgü tabanlı anahtar kapsülleme mekanizması) kullanan ECIES şifreleme protokolünün kuantum sonrası hibrit varyantı","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"ECIES-X25519-AEAD-Ratchet Hibrit Şifreleme","url":"/tr/docs/specs/ecies-hybrid/"},{"categories":null,"content":"Genel Bakış I2P eklentileri, router işlevselliğini genişleten imzalı arşivlerdir. Bunlar .xpi2p veya .su3 dosyaları olarak dağıtılır, ~/.i2p/plugins/\u0026lt;name\u0026gt;/ (Windows\u0026rsquo;ta %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\) dizinine kurulur ve herhangi bir korumalı alan olmadan tam router izinleriyle çalışır.\nDesteklenen Eklenti Türleri Konsol web uygulamaları cgi-bin ve web uygulamaları içeren yeni eepsites (I2P içindeki gizli web siteleri) Konsol temaları Konsol çevirileri Java programları (aynı süreç içinde veya ayrı bir JVM) Kabuk betikleri ve yerel ikili dosyalar Güvenlik Modeli KRİTİK: Eklentiler, I2P router ile aynı izinlere sahip olarak aynı JVM (Java Sanal Makinesi) içinde çalışır. Şunlara sınırsız erişimleri vardır: - Dosya sistemi (okuma ve yazma) - Router API\u0026rsquo;leri ve iç durum - Ağ bağlantıları - Harici programların çalıştırılması\nEklentiler tamamen güvenilir kod olarak ele alınmalıdır. Kullanıcılar, kurulumdan önce eklenti kaynaklarını ve imzalarını doğrulamalıdır.\nDosya Biçimleri SU3 Formatı (Şiddetle Önerilir) Durum: Aktif, I2P 0.9.15\u0026rsquo;ten (Eylül 2014) beri tercih edilen biçim\nThe .su3 biçimi şunları sağlar: - RSA-4096 imzalama anahtarları (xpi2p\u0026rsquo;deki DSA-1024\u0026rsquo;e kıyasla) - İmza dosya başlığında saklanır - Sihirli sayı: I2Psu3 - Geleceğe dönük daha iyi uyumluluk\nYapı:\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] XPI2P Biçimi (Eski, kullanımdan kaldırılmış) Durum: Geriye dönük uyumluluk için destekleniyor, yeni eklentiler için önerilmez\n.xpi2p biçimi daha eski kriptografik imzalar kullanır:\nDSA-1024 imzaları (NIST-800-57\u0026rsquo;ye göre kullanım dışı) ZIP\u0026rsquo;in başına eklenen 40 baytlık DSA imzası plugin.config dosyasında key alanını gerektirir Yapı:\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] Geçiş Yolu: xpi2p\u0026rsquo;den su3\u0026rsquo;e geçişte, geçiş süresince hem updateURL hem de updateURL.su3 sağlayın. Modern routers (0.9.15+) SU3\u0026rsquo;e otomatik olarak öncelik verir.\nArşiv Düzeni ve plugin.config Gerekli Dosyalar plugin.config - Anahtar-değer çiftleri içeren standart bir I2P yapılandırma dosyası\nGerekli Özellikler Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format **Sürüm Biçimi Örnekleri:** - `1.2.3` - `1.2.3-4` - `2.0.0-beta.1` Geçerli ayırıcılar: . (nokta), - (tire), _ (alt çizgi)\nİsteğe bağlı meta veri özellikleri Bilgileri Görüntüle date - Sürüm tarihi (Java long timestamp - Java \u0026rsquo;long\u0026rsquo; veri türünde zaman damgası) author - Geliştirici adı (user@mail.i2p önerilir) description - İngilizce açıklama description_xx - Yerelleştirilmiş açıklama (xx = dil kodu) websiteURL - Eklenti ana sayfası (http://foo.i2p/) license - Lisans tanımlayıcısı (örn., \u0026ldquo;Apache-2.0\u0026rdquo;, \u0026ldquo;GPL-3.0\u0026rdquo;) Güncelleme Ayarları updateURL - XPI2P güncelleme konumu (eski) updateURL.su3 - SU3 güncelleme konumu (tercih edilen) min-i2p-version - Gerekli minimum I2P sürümü max-i2p-version - Uyumlu maksimum I2P sürümü min-java-version - Minimum Java sürümü (örn. 1.7, 17) min-jetty-version - Minimum Jetty sürümü (Jetty 6+ için 6 kullanın) max-jetty-version - Maksimum Jetty sürümü (Jetty 5 için 5.99999 kullanın) Kurulum Davranışı dont-start-at-install - Varsayılan false. true ise manuel başlatma gerekir router-restart-required - Varsayılan false. Güncellemeden sonra yeniden başlatma gerektiğini kullanıcıya bildirir update-only - Varsayılan false. Eklenti zaten kurulu değilse başarısız olur install-only - Varsayılan false. Eklenti zaten mevcutsa başarısız olur min-installed-version - Güncelleme için gereken asgari sürüm max-installed-version - Güncellenebilecek azami sürüm disableStop - Varsayılan false. true ise Durdur düğmesini gizler Konsol Entegrasyonu consoleLinkName - Konsol özet çubuğu bağlantısı için metin consoleLinkName_xx - Yerelleştirilmiş bağlantı metni (xx = dil kodu) consoleLinkURL - Bağlantı hedefi (örn. /appname/index.jsp) consoleLinkTooltip - Üzerine gelindiğinde görünen metin (0.7.12-6 sürümünden beri desteklenir) consoleLinkTooltip_xx - Yerelleştirilmiş araç ipucu console-icon - 32x32 simge yolu (0.9.20 sürümünden beri desteklenir) icon-code - Web kaynakları olmayan eklentiler için Base64 ile kodlanmış 32x32 PNG (0.9.25\u0026rsquo;ten beri) Platform Gereksinimleri (Yalnızca Görüntüleme) required-platform-OS - İşletim sistemi gereksinimi (zorunlu değildir) other-requirements - Ek gereksinimler (örn. \u0026ldquo;Python 3.8+\u0026rdquo;) Bağımlılık Yönetimi (Uygulanmadı) depends - Virgülle ayrılmış eklenti bağımlılıkları depends-version - Bağımlılıklar için sürüm gereksinimleri langs - Dil paketi içeriği type - Eklenti türü (app/theme/locale/webapp) Güncelleme URL\u0026rsquo;sinde Değişken Yerine Koyma Özellik Durumu: I2P 1.7.0 (0.9.53) sürümünden beri kullanılabilir\nHem updateURL hem de updateURL.su3 platforma özel değişkenleri destekler:\nDeğişkenler: - $OS - İşletim sistemi: windows, linux, mac - $ARCH - Mimari: 386, amd64, arm64\nÖrnek:\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 Windows AMD64 üzerinde sonuç:\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 Bu, platforma özgü derlemelerde tek bir plugin.config dosyası kullanılmasına olanak tanır.\nDizin Yapısı Standart Düzen plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration Dizin Amaçları console/locale/ - I2P temel çevirileri için resource bundles (kaynak demetleri) içeren JAR dosyaları - Eklentiye özel çeviriler console/webapps/*.war veya lib/*.jar içinde olmalıdır\nconsole/themes/ - Her alt dizin tam bir konsol teması içerir - Tema arama yoluna otomatik olarak eklenir\nconsole/webapps/ - konsol entegrasyonu için .war dosyaları - webapps.config içinde devre dışı bırakılmadıkça otomatik olarak başlatılır - .war dosya adının eklenti adıyla eşleşmesi gerekmez\neepsite/ - Kendi Jetty örneğine sahip eksiksiz bir eepsite - Değişken ikamesi içeren jetty.xml yapılandırması gerektirir - zzzot ve pebble eklenti örneklerine bakın\nlib/ - Eklenti JAR kitaplıkları - clients.config veya webapps.config aracılığıyla classpath (sınıf yolu) içinde belirtin\nWeb uygulaması yapılandırması webapps.config Biçimi Web uygulamasının davranışını kontrol eden standart I2P yapılandırma dosyası.\nSözdizimi:\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar Önemli Notlar: - router 0.7.12-9 öncesinde, uyumluluk için plugin.warname.startOnLoad kullanın - API 0.9.53\u0026rsquo;ten önce, classpath (sınıf yolu) yalnızca warname eklenti adıyla eşleştiğinde çalışıyordu - 0.9.53+ itibarıyla, classpath herhangi bir web uygulaması adıyla çalışır\nWeb Uygulamaları için En İyi Uygulamalar ServletContextListener Uygulaması\nKaynak temizliği için javax.servlet.ServletContextListener\u0026lsquo;ı uygulayın Veya servlet içinde destroy() yöntemini geçersiz kılın Güncellemeler sırasında ve router durdurulurken doğru şekilde kapanmayı sağlar Kütüphane Yönetimi\nPaylaşılan JAR dosyalarını lib/ içine yerleştirin, WAR dosyasının içine değil webapps.config classpath (sınıf yolu) üzerinden referans verin Eklentilerin ayrı ayrı kurulup/güncellenmesini sağlar Çakışan Kütüphanelerden Kaçının\nJetty, Tomcat veya servlet JAR\u0026rsquo;larını asla paketlemeyin Standart I2P kurulumundaki JAR\u0026rsquo;ları asla paketlemeyin Standart kütüphaneler için classpath bölümünü kontrol edin Derleme Gereksinimleri\n.java veya .jsp kaynak dosyalarını dahil etmeyin Başlangıç gecikmelerini önlemek için tüm JSP\u0026rsquo;leri önceden derleyin Java/JSP derleyicisinin mevcut olduğunu varsaymayın Servlet API Uyumluluğu\nI2P, Servlet 3.0\u0026rsquo;ı destekler (0.9.30\u0026rsquo;dan beri) Annotation taraması DESTEKLENMEZ (@WebContent) Geleneksel web.xml dağıtım tanımlayıcısı sağlanmalıdır Jetty Sürümü\nGüncel: Jetty 9 (I2P 0.9.30+) Soyutlama için net.i2p.jetty.JettyStart kullanın Jetty API değişikliklerine karşı korur İstemci Yapılandırması clients.config Biçimi Eklenti tarafından başlatılan istemcileri (servisleri) tanımlar.\nTemel İstemci:\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties Durdur/Kaldır özelliği olan İstemci:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar Özellik Referansı Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths ### Değişken Yerine Koyma Aşağıdaki değişkenler, args, stopargs, uninstallargs ve classpath içinde yerine konur:\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 ### Yönetilen ve Yönetilmeyen İstemciler Yönetilen İstemciler (Önerilir, 0.9.4\u0026rsquo;ten itibaren): - ClientAppManager tarafından örneklenir - Referans ve durum takibini sürdürür - Daha kolay yaşam döngüsü yönetimi - Daha iyi bellek yönetimi\nYönetilmeyen İstemciler: - router tarafından başlatılır, durum takibi yok - Birden fazla başlat/durdur çağrısını sorunsuz şekilde ele almalıdır - Koordinasyon için statik durum veya PID dosyaları kullanın - router kapatılırken çağrılır (0.7.12-3 itibarıyla)\nShellService (0.9.53 / 1.7.0 sürümlerinden itibaren) Harici programları otomatik durum takibiyle çalıştırmaya yönelik genelleştirilmiş bir çözüm.\nÖzellikler: - Süreç yaşam döngüsünü yönetir - ClientAppManager ile iletişim kurar - Otomatik PID (süreç kimliği) yönetimi - Çapraz platform desteği\nKullanım:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh Platforma özgü komut dosyaları için:\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH Alternatif (Eski): İşletim sistemi türünü kontrol eden bir Java sarmalayıcı yazın, uygun .bat veya .sh dosyasıyla ShellCommand\u0026lsquo;u çağırın.\nKurulum Süreci Kullanıcı Kurulum Akışı Kullanıcı eklenti URL’sini Router Konsolu Eklenti Yapılandırma Sayfası\u0026rsquo;na (/configplugins) yapıştırır Router eklenti dosyasını indirir İmza doğrulaması (anahtar bilinmiyorsa ve katı mod etkinse başarısız olur) ZIP bütünlük denetimi plugin.config dosyasını çıkar ve ayrıştır Sürüm uyumluluğunun doğrulanması (min-i2p-version, min-java-version, vb.) Web uygulaması adı çakışmasının tespiti Güncelleme ise mevcut eklentiyi durdur Dizin doğrulaması (plugins/ altında olmalı) Tüm dosyaları eklenti dizinine çıkar plugins.config dosyasını güncelle Eklentiyi başlat (dont-start-at-install=true değilse) Güvenlik ve Güven Anahtar Yönetimi: - Yeni imzalayanlar için ilk görülen anahtara dayalı güven modeli - Yalnızca jrandom ve zzz anahtarları önceden paketlenmiş - 0.9.14.1 itibarıyla bilinmeyen anahtarlar varsayılan olarak reddedilir - Geliştirme için gelişmiş bir özellik ile geçersiz kılınabilir\nKurulum Kısıtlamaları: - Arşivler yalnızca eklenti dizinine açılmalıdır - Yükleyici plugins/ dışındaki yolları reddeder - Eklentiler kurulumdan sonra başka yerlerdeki dosyalara erişebilir - Sandboxing (izole çalışma ortamı) veya ayrıcalık izolasyonu yoktur\nGüncelleme Mekanizması Güncelleme Kontrol Süreci Router, plugin.config dosyasından updateURL.su3 (tercih edilen) veya updateURL değerini okur Bayt 41-56\u0026rsquo;yı almak için HTTP HEAD veya kısmi GET isteği yapılır Uzak dosyadan sürüm dizesi çıkarılır VersionComparator (sürüm karşılaştırma sınıfı) kullanılarak yüklü sürümle karşılaştırılır Daha yeniyse, kullanıcının onayı istenir veya otomatik indirilir (ayarlara bağlı olarak) Eklenti durdurulur Güncelleme yüklenir Eklenti başlatılır (kullanıcı tercihi değişmediyse) Sürüm Karşılaştırması Sürümler nokta/tire/alt çizgi ile ayrılmış bileşenler olarak ayrıştırılır: - 1.2.3 \u0026lt; 1.2.4 - 1.2.3 \u0026lt; 1.2.3-1 - 2.0.0 \u0026gt; 1.9.9\nMaksimum uzunluk: 16 bayt (SUD/SU3 başlığıyla eşleşmelidir)\nGüncelleme En İyi Uygulamaları Yayınlar için her zaman sürümü artırın Önceki sürümden güncelleme yolunu test edin Büyük değişikliklerde router-restart-required seçeneğini göz önünde bulundurun Geçiş sırasında hem updateURL hem de updateURL.su3 sağlayın Test için derleme numarası soneki kullanın (1.2.3-456) Classpath (sınıf yolu) ve Standart Kitaplıklar Classpath (sınıf yolu) içinde her zaman mevcut I2P 0.9.30+ sürümlerinde $I2P/lib içindeki aşağıdaki JAR\u0026rsquo;lar her zaman sınıf yolunda (classpath) bulunur:\nJAR Contents Plugin Usage i2p.jarCore APIRequired for all plugins mstreaming.jarStreaming APIMost plugins need streaming.jarStreaming implementationMost plugins need i2ptunnel.jarI2PTunnelHTTP/server plugins router.jarRouter internalsRarely needed, avoid if possible javax.servlet.jarServlet 3.1, JSP 2.3 APIPlugins with servlets/JSPs jasper-runtime.jarJasper compiler/runtimePlugins with JSPs commons-el.jarEL 3.0 APIJSPs using expression language jetty-i2p.jarJetty utilitiesPlugins starting Jetty org.mortbay.jetty.jarJetty 9 baseCustom Jetty instances sam.jarSAM APIRarely needed addressbook.jarSubscription/blockfileUse NamingService instead routerconsole.jarConsole librariesNot public API, avoid jbigi.jarNative cryptoPlugins should not need systray.jarURL launcherRarely needed wrapper.jarService wrapperPlugins should not need ### Özel Notlar commons-logging.jar: - 0.9.30\u0026rsquo;dan beri boş - 0.9.30\u0026rsquo;dan önce: Apache Tomcat JULI - 0.9.24\u0026rsquo;ten önce: Commons Logging + JULI - 0.9\u0026rsquo;dan önce: yalnızca Commons Logging\njasper-compiler.jar: - Jetty 6\u0026rsquo;dan beri boş (0.9)\nsystray4j.jar: - 0.9.26 sürümünde kaldırıldı\nClasspath\u0026rsquo;ta değil (belirtmelisiniz) JAR Contents Usage jstl.jarStandard TaglibJSP tag libraries standard.jarStandard TaglibJSP tag libraries ### Classpath (sınıf yolu) Belirtimi clients.config dosyasında:\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar webapps.config dosyasında:\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar Önemli: 0.7.13-3 sürümünden itibaren, classpath\u0026rsquo;ler iş parçacığına özgüdür; JVM genelinde değildir. Her istemci için tam classpath belirtin.\nJava Sürüm Gereksinimleri Güncel Gereksinimler (Ekim 2025) I2P 2.10.0 ve önceki sürümler: - En az: Java 7 (0.9.24\u0026rsquo;ten beri gerekli, Ocak 2016) - Önerilen: Java 8 veya daha yenisi\nI2P 2.11.0 ve sonrası (YAKINDA): - En az: Java 17+ (2.9.0 sürüm notlarında duyuruldu) - İki sürüm önceden uyarı verildi (2.9.0 → 2.10.0 → 2.11.0)\nEklenti Uyumluluk Stratejisi Maksimum uyumluluk için (I2P 2.10.x\u0026rsquo;e kadar):\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 Java 8+ özellikleri için:\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 Java 11+ özellikleri için:\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 2.11.0+ için hazırlıklar:\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 Derleme için En İyi Uygulamalar Daha eski bir hedef sürümü için daha yeni bir JDK ile derleme yaparken:\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; Bu, hedef Java sürümünde bulunmayan API\u0026rsquo;lerin kullanılmasını engeller.\nPack200 Sıkıştırması - KULLANIM DIŞI Kritik Güncelleme: Pack200\u0026rsquo;u Kullanmayın Durum: KULLANIMDAN KALDIRILDI VE ÇIKARILDI\nOrijinal spesifikasyon, boyutu %60-65 oranında azaltmak için Pack200 sıkıştırmasını kuvvetle tavsiye ediyordu. Bu artık geçerli değil.\nZaman çizelgesi: - JEP 336: Pack200, Java 11\u0026rsquo;de eskimiş (deprecated) olarak işaretlendi (Eylül 2018) - JEP 367: Pack200, Java 14\u0026rsquo;te kaldırıldı (Mart 2020)\nResmi I2P Güncellemeler Spesifikasyonu şöyle der: \u0026gt; \u0026ldquo;zip içindeki Jar ve war dosyaları, yukarıda \u0026lsquo;su2\u0026rsquo; dosyaları için belgelendiği gibi artık pack200 ile sıkıştırılmıyor, çünkü güncel Java çalışma zamanları artık bunu desteklemiyor.\u0026rdquo;\nNe yapılmalı:\npack200\u0026rsquo;ü derleme süreçlerinden derhal kaldırın Standart ZIP sıkıştırmasını kullanın Alternatifleri değerlendirin: Kod küçültme için ProGuard/R8 Yerel ikili dosyalar için UPX Özel bir açıcı sağlanıyorsa güncel sıkıştırma algoritmaları (zstd, brotli) Mevcut Eklentiler için: - Eski routers (0.7.11-5, Java 10\u0026rsquo;a kadar) hâlâ pack200\u0026rsquo;u açabilir - Yeni routers (Java 11+) pack200\u0026rsquo;u açamaz - Eklentileri pack200 sıkıştırması olmadan yeniden yayımlayın\nİmzalama Anahtarları ve Güvenlik Anahtar Üretimi (SU3 Format (I2P\u0026rsquo;de kullanılan imzalı güncelleme dosya biçimi)) i2p.scripts deposundaki makeplugin.sh betiğini kullanın:\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ Önemli Ayrıntılar: - Algoritma: RSA_SHA512_4096 - Biçim: X.509 sertifikası - Depolama: Java anahtar deposu biçimi\nEklentilerin İmzalanması # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 Anahtar Yönetimi için En İyi Uygulamalar Bir kez üret, sonsuza dek koru\nRouters, anahtarı farklı olan aynı anahtar adlarını reddeder Routers, anahtar adı farklı olan aynı anahtarları reddeder Anahtar/ad uyuşmazlığı varsa güncellemeler reddedilir Güvenli depolama\nKeystore (anahtar deposu) yedeğini güvenli şekilde alın Güçlü bir passphrase (parola öbeği) kullanın Asla sürüm kontrolüne eklemeyin Anahtar rotasyonu\nMevcut mimari tarafından desteklenmiyor Uzun vadeli anahtar kullanımını planlayın Ekip geliştirmesi için çoklu imza şemalarını değerlendirin Eski DSA İmzalama (XPI2P) Durum: Çalışır durumda ancak eskimiş\nxpi2p biçimi (I2P eklenti paket biçimi) tarafından kullanılan DSA-1024 imzaları: - 40 baytlık imza - 172 base64 karakterli açık anahtar - NIST-800-57 asgari olarak (L=2048, N=224) değerlerini önerir - I2P daha zayıfını kullanır (L=1024, N=160)\nÖneri: Bunun yerine RSA-4096 ile SU3 (I2P’de kullanılan imzalı güncelleme dosyası biçimi) kullanın.\nEklenti Geliştirme Yönergeleri Temel En İyi Uygulamalar Dokümantasyon\nKurulum talimatlarını içeren anlaşılır bir README (Benioku dosyası) sağlayın Yapılandırma seçeneklerini ve varsayılanları belgeleyin Her sürümle birlikte bir değişiklik günlüğü ekleyin Gerekli I2P/Java sürümlerini belirtin Boyut Optimizasyonu\nYalnızca gerekli dosyaları ekleyin Asla router JAR\u0026rsquo;larını paketlemeyin Kurulum ve güncelleme paketlerini ayırın (kütüphaneler lib/ içinde) Pack200 sıkıştırmasını kullanın KULLANIMDAN KALKTI - Standart ZIP kullanın Yapılandırma\nÇalışma zamanında plugin.config dosyasını asla değiştirmeyin Çalışma zamanı ayarları için ayrı bir yapılandırma dosyası kullanın Gerekli router ayarlarını belgelendirin (SAM portları, tunnels vb.) Kullanıcının mevcut yapılandırmasına saygı gösterin Kaynak Kullanımı\nVarsayılan bant genişliği tüketimini aşırıya kaçırmaktan kaçının Makul CPU kullanım sınırları uygulayın Kapatma sırasında kaynakları temizleyin Uygun olduğunda daemon threads (arka planda çalışan iş parçacıkları) kullanın Test\nTüm platformlarda kurulum/yükseltme/kaldırmayı test edin Önceki sürümden güncellemeleri test edin Güncellemeler sırasında web uygulamasının durdurulmasını/yeniden başlatılmasını doğrulayın Desteklenen en düşük I2P sürümüyle test edin Dosya Sistemi\nAsla $I2P içine yazmayın (salt okunur olabilir) Çalışma zamanı verilerini $PLUGIN veya $CONFIG içine yazın Dizin keşfi için I2PAppContext kullanın $CWD konumunu varsaymayın Uyumluluk\nStandart I2P sınıflarını çoğaltmayın Gerekirse sınıfları genişletin, değiştirmeyin plugin.config içindeki min-i2p-version, min-jetty-version değerlerini kontrol edin Destekliyorsanız daha eski I2P sürümleriyle test edin Kapatma Yönetimi\nclients.config içinde uygun stopargs uygulayın Kapatma kancalarını kaydedin: I2PAppContext.addShutdownTask() Birden çok başlatma/durdurma çağrısını sorunsuz şekilde yönetin Tüm iş parçacıklarını daemon (arka plan) moduna ayarlayın Güvenlik\nTüm dış girdileri doğrulayın System.exit() asla çağırmayın Kullanıcı gizliliğine saygı gösterin Güvenli kodlama uygulamalarına uyun Lisanslama\nEklenti lisansını açıkça belirtin Birlikte paketlenen kütüphanelerin lisanslarına saygı gösterin Gerekli atıfları ekleyin Gerekirse kaynak koda erişim sağlayın Gelişmiş Hususlar Saat Dilimi Yönetimi: - Router JVM saat dilimini UTC olarak ayarlar - Kullanıcının gerçek saat dilimi: I2PAppContext özelliği i2p.systemTimeZone\nDizin Keşfi:\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args Sürüm Numaralandırma: - Anlamsal sürümleme kullanın (major.minor.patch) - Test için derleme numarası ekleyin (1.2.3-456) - Güncellemelerde monotonik artışı sağlayın\nRouter Sınıf Erişimi: - Genel olarak router.jar bağımlılıklarından kaçının - Bunun yerine i2p.jar içindeki public API\u0026rsquo;leri kullanın - Gelecekte I2P, router sınıfına erişimi kısıtlayabilir\nJVM Çökme Önleme (Tarihsel): - 0.7.13-3\u0026rsquo;te düzeltildi - Sınıf yükleyicilerini doğru şekilde kullanın - Çalışan eklentide JAR\u0026rsquo;ları güncellemekten kaçının - Gerekirse güncellemeden sonra yeniden başlatmayı destekleyecek şekilde tasarlayın\nEepsite Eklentileri Genel Bakış Eklentiler, kendi Jetty (Java servlet konteyneri) ve I2PTunnel örneklerine sahip, tam özellikli eepsites sağlayabilir.\nMimari Şunları yapmaya çalışmayın: - Mevcut bir eepsite (I2P üzerindeki site) içine kurmak - Router\u0026rsquo;ın varsayılan eepsite\u0026rsquo;i ile birleştirmek - Tek bir eepsite\u0026rsquo;in mevcut olduğunu varsaymak\nBunun yerine: - Yeni bir I2PTunnel örneği başlat (CLI yaklaşımıyla) - Yeni bir Jetty örneği başlat - Her ikisini de clients.config içinde yapılandır\nÖrnek Yapı plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] jetty.xml\u0026rsquo;de Değişken Yerine Koyma Yollar için $PLUGIN değişkenini kullanın:\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; Router, eklenti başlatılırken ikame işlemi yapar.\nÖrnekler Referans gerçeklemeler: - zzzot eklentisi - Torrent izleyici - pebble eklentisi - Blog platformu\nHer ikisi de zzz\u0026rsquo;nin eklenti sayfasında (I2P içi) bulunabilir.\nKonsol Entegrasyonu Özet Çubuğu Bağlantıları Router konsolu özet çubuğuna tıklanabilir bağlantı ekle:\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface Yerelleştirilmiş sürümler:\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle Konsol Simgeleri Görüntü Dosyası (0.9.20\u0026rsquo;den beri):\nconsole-icon=/myicon.png consoleLinkURL belirtilmişse (0.9.53\u0026rsquo;ten beri) yol buna göre görelidir, aksi takdirde web uygulaması adına görelidir.\nGömülü Simge (0.9.25 sürümünden beri):\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... Şununla oluşturun:\nbase64 -w 0 icon-32x32.png Ya da Java:\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png Gereksinimler: - 32x32 piksel - PNG formatı - Base64 ile kodlanmış (satır sonu olmadan)\nUluslararasılaştırma Çeviri Paketleri I2P Temel Çevirileri için: - JAR\u0026rsquo;ları console/locale/ dizinine yerleştirin - Mevcut I2P uygulamaları için kaynak demetlerini içerir - Adlandırma: messages_xx.properties (xx = dil kodu)\nEklentiye Özel Çeviriler İçin: - console/webapps/*.war içine dahil edin - Veya lib/*.jar içine dahil edin - Standart Java ResourceBundle (kaynak paketi) yaklaşımını kullanın\nplugin.config içindeki yerelleştirilmiş dizeler description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble Desteklenen alanlar: - description_xx - consoleLinkName_xx - consoleLinkTooltip_xx\nKonsol Tema Çevirisi console/themes/ içindeki temalar, tema arama yoluna otomatik olarak eklenir.\nPlatforma Özgü Eklentiler Ayrı Paketler Yaklaşımı Her platform için farklı eklenti adları kullanın:\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac Değişken Yerine Koyma Yaklaşımı Platform değişkenleri içeren tek bir plugin.config:\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 clients.config dosyasında:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH Çalışma Zamanı İşletim Sistemi Tespiti Koşullu yürütme için Java yaklaşımı:\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } Sorun Giderme Yaygın Sorunlar Eklenti Başlatılmıyor: 1. I2P sürüm uyumluluğunu kontrol edin (min-i2p-version) 2. Java sürümünü doğrulayın (min-java-version) 3. Hatalar için router günlüklerini kontrol edin 4. classpath (sınıf yolu) içindeki gerekli tüm JAR\u0026rsquo;ları doğrulayın\nWeb uygulamasına erişilemiyor: 1. webapps.config tarafından devre dışı bırakılmadığını doğrulayın 2. Jetty sürüm uyumluluğunu kontrol edin (min-jetty-version) 3. web.xml dosyasının mevcut olduğunu doğrulayın (annotation scanning [annotasyon taraması] desteklenmez) 4. Çakışan web uygulaması adlarını kontrol edin\nGüncelleme Başarısız: 1. Sürüm dizesinin artırıldığını doğrulayın 2. İmzanın imzalama anahtarıyla eşleştiğini kontrol edin 3. Eklenti adının yüklü sürümle eşleştiğinden emin olun 4. update-only/install-only ayarlarını gözden geçirin\nHarici Program Durmuyor: 1. Otomatik yaşam döngüsü için ShellService kullanın 2. Uygun stopargs işleme mantığını uygulayın 3. PID dosyası temizliğini kontrol edin 4. Sürecin sonlandığını doğrulayın\nHata Ayıklama Günlüğü router\u0026rsquo;da hata ayıklama günlüğünü etkinleştir:\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG Günlükleri kontrol edin:\n~/.i2p/logs/log-router-0.txt Referans Bilgileri Resmi Spesifikasyonlar Eklenti Belirtimi Yapılandırma Biçimi Güncelleme Belirtimi Kriptografi I2P Sürüm Geçmişi Güncel Sürüm: - I2P 2.10.0 (8 Eylül 2025)\n0.9.53\u0026rsquo;ten beri önemli sürümler: - 2.10.0 (Eylül 2025) - Java 17+ duyurusu - 2.9.0 (Haziran 2025) - Java 17+ uyarısı - 2.8.0 (Ekim 2024) - Kuantum sonrası kriptografi testleri - 2.6.0 (Mayıs 2024) - I2P-over-Tor engellemesi - 2.4.0 (Aralık 2023) - NetDB güvenlik iyileştirmeleri - 2.2.0 (Mart 2023) - Tıkanıklık kontrolü - 2.1.0 (Ocak 2023) - Ağ iyileştirmeleri - 2.0.0 (Kasım 2022) - SSU2 taşıma protokolü - 1.7.0/0.9.53 (Şubat 2022) - ShellService, değişken ikamesi - 0.9.15 (Eylül 2014) - SU3 formatı tanıtıldı\nSürüm Numaralandırma: - 0.9.x serisi: 0.9.53 sürümüne kadar - 2.x serisi: 2.0.0 ile başlar (SSU2\u0026rsquo;nin tanıtımı)\nGeliştirici Kaynakları Kaynak Kodu: - Ana depo: https://i2pgit.org/I2P_Developers/i2p.i2p - GitHub aynası: https://github.com/i2p/i2p.i2p Eklenti Örnekleri: - zzzot (BitTorrent izleyici) - pebble (Blog platformu) - i2p-bote (Sunucusuz e-posta) - orchid (Tor istemcisi) - seedless (Eş değişimi)\nDerleme Araçları: - makeplugin.sh - Anahtar üretimi ve imzalama - i2p.scripts deposunda bulunur - su3 (imzalı güncelleme dosyası formatı) oluşturma ve doğrulamayı otomatikleştirir\nTopluluk Desteği Forumlar: - I2P Forumu - zzz.i2p (I2P içi)\nIRC/Sohbet: - #i2p-dev OFTC\u0026rsquo;de - I2P ağı içinde IRC\nEk A: Tam plugin.config Örneği # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space Ek B: Eksiksiz clients.config örneği # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config Ek C: Eksiksiz webapps.config Örneği # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true Ek D: Geçiş Kontrol Listesi (0.9.53\u0026rsquo;ten 2.10.0\u0026rsquo;a) Gerekli Değişiklikler Derleme sürecinden Pack200 sıkıştırmasını kaldırın\nAnt/Maven/Gradle betiklerinden pack200 görevlerini kaldırın Mevcut eklentileri pack200 olmadan yeniden yayımlayın Java sürüm gereksinimlerini gözden geçirin\nYeni özellikler için Java 11+ gerektirmeyi değerlendirin I2P 2.11.0\u0026rsquo;da Java 17+ gereksinimi için plan yapın plugin.config dosyasındaki min-java-version ayarını güncelleyin Dokümantasyonu güncelle\nPack200 referanslarını kaldır Java sürüm gereksinimlerini güncelle I2P sürüm referanslarını güncelle (0.9.x → 2.x) Önerilen Değişiklikler Kriptografik imzaları güçlendirin\nHenüz yapılmadıysa XPI2P\u0026rsquo;den SU3\u0026rsquo;e geçin Yeni eklentiler için RSA-4096 anahtarları kullanın Yeni özelliklerden yararlanın (0.9.53+ kullanıyorsanız)\nPlatforma özel güncellemeler için $OS / $ARCH değişkenlerini kullanın Harici programlar için ShellService kullanın Geliştirilmiş web uygulaması classpath\u0026rsquo;ini kullanın (herhangi bir war adıyla çalışır) Uyumluluğu test edin\nI2P 2.10.0 üzerinde test edin Java 8, 11, 17 ile doğrulayın Windows, Linux, macOS üzerinde kontrol edin İsteğe Bağlı Geliştirmeler Uygun bir ServletContextListener (Servlet bağlamı dinleyicisi) uygulayın Yerelleştirilmiş açıklamalar ekleyin Konsol simgesi ekleyin Kapatma işlemi yönetimini iyileştirin Kapsamlı günlükleme ekleyin Otomatikleştirilmiş testler yazın ","description":".xpi2p / .su3 I2P eklentileri için paketleme kuralları","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"Eklenti Paket Biçimi","url":"/tr/docs/specs/plugin/"},{"categories":null,"content":" Durum: Bu belge, eski ElGamal/AES+SessionTag (oturum etiketi) şifreleme protokolünü açıklar. Modern I2P sürümleri (2.10.0+) ECIES-X25519-AEAD-Ratchet kullandığından, bu protokol yalnızca geriye dönük uyumluluk için desteklenmeye devam etmektedir. ElGamal protokolü kullanımdan kaldırılmıştır ve yalnızca tarihsel ve birlikte çalışabilirlik amaçlarıyla muhafaza edilmektedir.\nGenel Bakış ElGamal/AES+SessionTag, I2P\u0026rsquo;nin garlic messages (garlic mesajları) için özgün uçtan uca şifreleme mekanizmasını sağlıyordu. Şunları birleştiriyordu:\nElGamal (2048-bit) — anahtar değişimi için AES-256/CBC — yük verisinin şifrelenmesi için SHA-256 — özetleme ve IV türetimi için Session Tags (32 bayt) — tek kullanımlık mesaj tanımlayıcıları için Protokol, kalıcı bağlantıları sürdürmeye gerek kalmadan routers ve destinations (I2P adresleri) arasında güvenli iletişim kurulmasına olanak tanıyordu. Her oturum, simetrik bir AES anahtarı oluşturmak için asimetrik bir ElGamal değişimi kullanıyordu; ardından o oturuma referans veren hafif \u0026ldquo;tagged\u0026rdquo; mesajlar geliyordu.\nProtokol İşleyişi Oturum Kurulumu (Yeni Oturum) Yeni bir oturum, iki bölüm içeren bir mesajla başladı:\nSection Size Contents Purpose ElGamal-encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient's ElGamal public key Establishes the AES session key and IV seed AES-encrypted block Variable (≥128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags ElGamal bloğunun içindeki açık metin şunlardan oluşuyordu: Field Size Description Session Key 32 bytes AES-256 key for the session Pre-IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA-256(Pre-IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length ### Mevcut Oturum Mesajları Bir oturum kurulduğunda, gönderici, önbelleğe alınmış oturum etiketlerini kullanarak existing-session mesajları gönderebilirdi:\nField Size Description Session Tag 32 bytes Single-use identifier tied to the existing session key AES-Encrypted Block Variable Encrypted payload and metadata using the established AES key Router'lar iletilen etiketleri yaklaşık **15 dakika** boyunca önbelleğe alırdı; bu sürenin ardından kullanılmayan etiketlerin süresi dolardı. Her etiket, korelasyon saldırılarını önlemek için tam olarak **bir mesaj** için geçerliydi. AES ile Şifrelenmiş Blok Biçimi Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single-use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA-256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16-byte aligned) Random padding to block boundary Router'lar, yeni oturumlar için Pre-IV'den (ön IV), mevcut oturumlar içinse session tag'den (oturum etiketi) türetilen oturum anahtarı ve IV'yi (başlatma vektörü) kullanarak şifresini çözer. Şifre çözüldükten sonra, düz metin yükünün SHA-256 karmasını yeniden hesaplayarak bütünlüğü doğrularlar. Oturum Etiketi Yönetimi Etiketler tek yönlüdür: Alice → Bob etiketleri, Bob → Alice için yeniden kullanılamaz. Etiketler yaklaşık 15 dakika sonra sona erer. Router\u0026rsquo;lar, etiketleri, anahtarları ve sona erme zamanlarını izlemek için hedef başına oturum anahtarı yöneticileri bulundurur. Uygulamalar, I2CP seçenekleri aracılığıyla etiket davranışını denetleyebilir: i2cp.tagThreshold — yenileme yapılmadan önce önbellekte tutulması gereken minimum etiket sayısı i2cp.tagCount — mesaj başına yeni etiket sayısı Bu mekanizma, mesajlar arasındaki ilişkilendirilemezliği korurken, yüksek maliyetli ElGamal el sıkışmalarını en aza indirdi.\nYapılandırma ve Verimlilik Session tags (oturum etiketleri), I2P\u0026rsquo;nin yüksek gecikmeli ve sırasız aktarımı genelinde verimliliği artırmak için getirildi. Tipik bir yapılandırma mesaj başına 40 etiket sağlardı ve yaklaşık 1.2 KB ek yük eklerdi. Uygulamalar, beklenen trafiğe göre teslim davranışını ayarlayabilirdi:\nUse Case Recommended Tags Notes Short-lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re-establishment Long-term services 50+ Ensures steady tag supply despite loss or delay Routers periyodik olarak süresi dolmuş etiketleri temizler ve kullanılmayan oturum durumunu budar; böylece bellek kullanımını azaltır ve etiket taşması saldırılarını hafifletir. Sınırlamalar Category Limitation Performance 514-byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES-CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor's algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. Bu eksiklikler, [ECIES-X25519-AEAD-Ratchet](/docs/specs/ecies/) protokolünün tasarımını doğrudan motive etti; bu protokol mükemmel ileri gizlilik, kimlik doğrulamalı şifreleme ve verimli anahtar değişimi sağlar. Kullanımdan Kaldırma ve Geçiş Durumu Tanıtıldı: Erken I2P sürümleri (0.6 öncesi) Kullanımdan kaldırıldı: ECIES-X25519\u0026rsquo;in tanıtılmasıyla (X25519 tabanlı ECIES anahtar değişimi) (0.9.46 → 0.9.48) Kaldırıldı: 2.4.0 itibarıyla (Aralık 2023) artık varsayılan değil Destekleniyor: Yalnızca geriye dönük uyumluluk Modern router\u0026rsquo;lar ve hedefler artık şifreleme türü 4 (ECIES-X25519)\u0026lsquo;ü, tür 0 (ElGamal/AES) yerine duyuruyor. Eski protokol, güncel olmayan eşlerle birlikte çalışabilirlik için tanınmaya devam ediyor, ancak yeni dağıtımlarda kullanılmamalıdır.\nTarihsel Bağlam ElGamal/AES+SessionTag, I2P\u0026rsquo;nin erken kriptografik mimarisinin temelini oluşturuyordu. Hibrit tasarımı, tek kullanımlık oturum etiketleri ve tek yönlü oturumlar gibi yenilikleri getirdi; bunlar sonraki protokolleri şekillendirdi. Bu fikirlerin birçoğu, deterministic ratchets (belirlenimli anahtar yenileme “ratchet” mekanizmaları) ve hybrid post-quantum key exchanges (klasik ve kuantum sonrası şemaları birleştiren hibrit anahtar değişimleri) gibi modern yapılara evrildi.\n","description":"ElGamal, AES, SHA-256 ve tek kullanımlık oturum etiketlerini birleştiren eski tip uçtan uca şifreleme","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"ElGamal/AES + SessionTag (oturum etiketi) Şifreleme","url":"/tr/docs/legacy/elgamal-aes/"},{"categories":null,"content":"Erişim filtreleri, I2PTunnel sunucu işletmecilerinin, kaynak Destination (I2P\u0026rsquo;de hedef kimliği) ve yakın zamandaki bağlantı sıklığına göre gelen bağlantılara izin vermesine, bunları reddetmesine veya kısıtlamasına olanak tanır. Filtre, kurallardan oluşan düz metin bir dosyadır. Dosya yukarıdan aşağıya okunur ve ilk eşleşen kural geçerlidir.\nFiltre tanımındaki değişiklikler, tunnel yeniden başlatıldığında yürürlüğe girer. Bazı sürümler çalışma sırasında dosya tabanlı listeleri yeniden okuyabilir, ancak değişikliklerin uygulandığını garanti etmek için bir yeniden başlatmayı planlayın.\nDosya biçimi Her satırda bir kural. Boş satırlar dikkate alınmaz. #, satırın sonuna kadar devam eden bir yorum başlatır. Kurallar sırayla değerlendirilir; ilk eşleşme kullanılır. Eşikler Bir eşik, kayan bir zaman penceresi içinde tek bir Destination (uç nokta) için izin verilen bağlantı denemesi sayısını tanımlar.\nSayısal: N/S, S saniye başına N bağlantıya izin verir. Örnek: 15/5, her 5 saniyede en fazla 15 bağlantıya izin verir. Pencere içinde yapılan N+1\u0026lsquo;inci deneme reddedilir. Anahtar kelimeler: allow herhangi bir sınır olmadığı anlamına gelir. deny her zaman reddet anlamına gelir. Kural sözdizimi Kurallar şu biçimdedir:\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; Burada:\n\u0026lt;threshold\u0026gt; N/S, allow veya deny olabilir \u0026lt;scope\u0026gt;, default, explicit, file veya record değerlerinden biridir (aşağıya bakın) \u0026lt;target\u0026gt; kapsama bağlıdır Varsayılan kural Başka hiçbir kural eşleşmediğinde uygulanır. Yalnızca bir varsayılan kurala izin verilir. Belirtilmezse, bilinmeyen Destinations (Hedefler) herhangi bir kısıtlama olmaksızın izin verilir.\n15/5 default allow default deny default Açık kural Base32 adresi (örneğin example1.b32.i2p) veya tam anahtar ile belirli bir hedefi hedefler.\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p Dosya tabanlı kural Harici bir dosyada listelenen Destinations\u0026rsquo;ın tümünü hedefler. Her satır bir Destination içerir; # yorumları ve boş satırlara izin verilir.\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt İşletim notu: Bazı gerçeklemeler dosya listelerini periyodik olarak yeniden okur. tunnel çalışırken bir listeyi düzenlerseniz, değişikliklerin fark edilmesinden önce kısa bir gecikme bekleyin. Hemen uygulanması için yeniden başlatın.\nKaydedici (kademeli kontrol) Bir recorder (kaydedici) bağlantı denemelerini izler ve eşik değerini aşan hedefleri bir dosyaya yazar. Daha sonra, gelecekteki denemelere hız sınırlamaları veya engellemeler uygulamak için o dosyaya bir file kuralında referans verebilirsiniz.\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt Ona güvenmeden önce derlemenizde kaydedici desteğini doğrulayın. Garanti edilen davranış için file listelerini kullanın.\nDeğerlendirme sırası Önce özel kuralları, ardından genel olanları yazın. Yaygın bir kalıp:\nGüvenilir eşler için açık izinler Bilinen kötüye kullananlar için açık retler Dosya tabanlı izin/ret listeleri Kademeli hız kısma için kaydediciler Her şeyi kapsayan bir varsayılan kural Tam örnek # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt Uygulama notları Erişim filtresi, uygulama tarafından işlenmeden önce, tunnel katmanında çalışır; böylece kötüye kullanım amaçlı trafik erken reddedilebilir. Filtre dosyasını I2PTunnel yapılandırma dizinine yerleştirin ve değişikliklerin uygulanması için tunnel\u0026rsquo;i yeniden başlatın. Hizmetler genelinde tutarlı bir ilke istiyorsanız, dosya tabanlı listeleri birden fazla tunnel arasında paylaşın. ","description":"tunnel erişim denetimi filtre dosyaları için söz dizimi","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"Erişim Filtresi Biçimi","url":"/tr/docs/specs/filter-format/"},{"categories":null,"content":" Eski durum: Bu içerik yalnızca tarihsel referans amacıyla saklanmaktadır. I2P 0.6.1.10\u0026rsquo;dan önce dağıtılan tunnel sistemini belgeler ve modern geliştirmede kullanılmamalıdır. Üretime yönelik rehberlik için güncel gerçekleştirim \u0026rsquo;e bakın.\nÖzgün tunnel alt sistemi de tek yönlü tunnel\u0026rsquo;lar kullanıyordu, ancak mesaj düzeni, yinelenenlerin tespiti ve inşa stratejisi açısından farklıydı. Karşılaştırmayı kolaylaştırmak için aşağıdaki pek çok bölüm, kullanımdan kaldırılmış belgenin yapısını yansıtır.\n1. Tunnel\u0026rsquo;e Genel Bakış Tunnels, oluşturucu tarafından seçilen eşlerden oluşan sıralı diziler olarak oluşturulurdu. Tunnel uzunlukları 0–7 atlama arasında değişirdi; dolgu, hız sınırlama ve chaff (örtü trafiği) üretimi için çeşitli ayarlar vardı. Inbound tunnels, güvenilmeyen bir ağ geçidinden oluşturucuya (uç nokta) mesajları iletirdi; outbound tunnels ise veriyi oluşturucudan dışarı gönderirdi. Tunnel ömürleri 10 dakikaydı; bunun ardından yeni tunnels oluşturulurdu (çoğu zaman aynı eşler kullanılır, ancak farklı tunnel ID\u0026rsquo;leri atanırdı). 2. Eski Tasarımda İşleyiş 2.1 Mesaj Ön İşleme Geçitler ≤32 KB I2NP yükü biriktirdi, dolgu seçti ve şu içeriği içeren bir yük üretti:\nİki baytlık bir dolgu uzunluğu alanı ve aynı sayıda rastgele bayt Teslimat hedeflerini, parçalamayı ve isteğe bağlı gecikmeleri tanımlayan {instructions, I2NP message} çiftlerinden oluşan bir dizi 16 baytlık hizalama sınırına kadar doldurulmuş tam I2NP mesajları Teslimat talimatları yönlendirme bilgilerini bit alanlarına paketliyordu (teslimat türü, gecikme bayrakları, parçalama bayrakları ve isteğe bağlı uzantılar). Parçalanmış iletiler 4 baytlık bir ileti kimliği ve ayrıca bir indeks/son parça bayrağı taşıyordu.\n2.2 Ağ Geçidi Şifrelemesi Eski tasarım, şifreleme aşaması için tunnel uzunluğunu sekiz atlamaya sabitlemişti. Ağ geçitleri, her atlamanın yükü küçültmeden bütünlüğü doğrulayabilmesi için AES-256/CBC ve sağlama toplamı bloklarını katmanladı. Sağlama toplamının kendisi, iletinin içine gömülü SHA-256’tan türetilmiş bir bloktu.\n2.3 Katılımcı Davranışı Katılımcılar, gelen tunnel ID\u0026rsquo;lerini izledi, bütünlüğü erkenden doğruladı ve iletmeden önce yinelenenleri attı. Dolgu ve doğrulama blokları mesaja gömülü olduğundan, atlama sayısından bağımsız olarak mesaj boyutu sabit kaldı.\n2.4 Uç Nokta İşleme Uç noktalar, katmanlı blokların şifresini ardışık olarak çözdü, sağlama toplamlarını doğruladı ve yükü, sonraki iletim için kodlanmış talimatlar ile I2NP iletileri olarak yeniden ayırdı.\n3. Tunnel Oluşturma (Kullanımdan Kaldırılmış Süreç) 4. Bant Daraltma ve Karıştırma Kavramları Eski doküman, sonraki sürümlere yön veren birkaç strateji önerdi:\nAğ tıkanıklığı kontrolü için Weighted Random Early Discard (WRED) Son dönemdeki kullanımın hareketli ortalamalarına dayalı tunnel başına hız sınırlamaları İsteğe bağlı chaff (sahte trafik) ve toplu işleme kontrolleri (tam olarak uygulanmamıştır) 5. Arşivlenmiş Alternatifler Orijinal belgenin bazı bölümleri, hiçbir zaman devreye alınmamış fikirleri inceliyordu:\nHer atlama başına işlemi azaltmak için checksum bloklarını kaldırmak Eş (peer) bileşimini değiştirmek için akış ortasında tunnels üzerinde teleskoplama yapmak Çift yönlü tunnels kullanmaya geçmek (nihayetinde reddedildi) Daha kısa hash\u0026rsquo;ler veya farklı padding (dolgu) düzenleri kullanmak Bu fikirler, değerli bir tarihsel bağlam olarak önemini koruyor, ancak modern kod tabanını yansıtmıyor.\nReferanslar Özgün eski belge arşivi (0.6.1.10 öncesi) Tunnel\u0026rsquo;e Genel Bakış güncel terminoloji için Eş Profilleme ve Seçimi modern sezgisel yöntemler için ","description":"I2P 0.6.1.10'dan önce kullanılan tunnel tasarımının arşivlenmiş açıklaması.","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"Eski Tunnel İmplementasyonu (Eski)","url":"/tr/docs/legacy/old-implementation/"},{"categories":null,"content":" 1. Genel Bakış Garlic routing, I2P\u0026rsquo;nin temel yeniliklerinden biri olmaya devam etmektedir ve katmanlı şifreleme, mesaj paketleme ve tek yönlü tünelleri bir araya getirir. Kavramsal olarak onion routing ile benzer olsa da, birden fazla şifrelenmiş mesajı (\u0026ldquo;cloves\u0026rdquo;) tek bir zarf içinde (\u0026ldquo;garlic\u0026rdquo;) paketleyerek modeli genişletir ve böylece verimliliği ve anonimliği artırır.\nGarlic routing terimi, Michael J. Freedman tarafından Roger Dingledine\u0026rsquo;ın Free Haven Yüksek Lisans Tezi \u0026rsquo;nde (Haziran 2000, §8.1.1) ortaya atılmıştır. I2P geliştiricileri, 2000\u0026rsquo;li yılların başında bu terimi, Tor\u0026rsquo;un devre anahtarlamalı tasarımından farklı olarak, paket gruplama iyileştirmelerini ve tek yönlü taşıma modelini yansıtmak için benimsemişlerdir.\nÖzet: Garlic routing = katmanlı şifreleme + mesaj paketleme + tek yönlü tüneller üzerinden anonim teslimat.\n2. \u0026ldquo;Garlic\u0026rdquo; Terminolojisi Tarihsel olarak, garlic terimi I2P içinde üç farklı bağlamda kullanılmıştır:\nKatmanlı şifreleme – tünel seviyesinde soğan tarzı koruma Birden fazla mesajı paketleme – bir \u0026ldquo;garlic message\u0026rdquo; içinde birden fazla \u0026ldquo;clove\u0026rdquo; Uçtan uca şifreleme – eskiden ElGamal/AES+SessionTags, şimdi ECIES‑X25519‑AEAD‑Ratchet Mimari bozulmadan kalırken, şifreleme şeması tamamen modernize edilmiştir.\n3. Katmanlı Şifreleme Garlic routing, temel prensibini onion routing ile paylaşır: her router yalnızca bir şifreleme katmanını çözer, sadece bir sonraki atlamayı öğrenir ve tam yolu öğrenemez.\nAncak, I2P tek yönlü tüneller uygular, çift yönlü devreler değil:\nOutbound tunnel: mesajları oluşturucudan uzağa gönderir Inbound tunnel: mesajları oluşturucuya geri taşır Tam bir gidiş-dönüş (Alice ↔ Bob) dört tunnel kullanır: Alice\u0026rsquo;in outbound\u0026rsquo;u → Bob\u0026rsquo;un inbound\u0026rsquo;u, ardından Bob\u0026rsquo;un outbound\u0026rsquo;u → Alice\u0026rsquo;in inbound\u0026rsquo;u. Bu tasarım, çift yönlü devrelere kıyasla korelasyon veri maruziyetini yarıya indirir.\nTünel uygulama detayları için Tünel Spesifikasyonu ve Tünel Oluşturma (ECIES) spesifikasyonuna bakın.\n4. Birden Fazla Mesajı Paketleme (\u0026ldquo;Cloves\u0026rdquo;) Freedman\u0026rsquo;ın orijinal garlic routing tasarımı, bir mesaj içinde birden fazla şifrelenmiş \u0026ldquo;bulb\u0026rdquo; (soğan dilimi) paketlemeyi öngörüyordu. I2P bunu bir garlic message içindeki clove (karanfil) olarak uygular — her clove\u0026rsquo;un kendi şifrelenmiş teslimat talimatları ve hedefi (router, destination veya tunnel) vardır.\nGarlic bundling, I2P\u0026rsquo;nin şunları yapmasına olanak tanır:\nOnayları ve meta verileri veri mesajlarıyla birleştirin Gözlemlenebilir trafik desenlerini azaltın Ekstra bağlantı olmadan karmaşık mesaj yapılarını destekleyin Şekil 1: Her biri kendi teslimat talimatlarına sahip birden fazla dilim içeren bir Garlic Message.\nTipik karanfiller şunları içerir:\nTeslimat Durumu Mesajı — teslimat başarısını veya başarısızlığını onaylayan bildirimler.\nBunlar, gizliliği korumak için kendi garlic encryption katmanlarına sarılır. Veritabanı Depolama Mesajı — eşlerin netDb\u0026rsquo;yi yeniden sorgulamadan yanıt verebilmesi için otomatik olarak paketlenen LeaseSet\u0026rsquo;ler. Clove\u0026rsquo;lar aşağıdaki durumlarda paketlenir:\nYeni bir LeaseSet yayınlanmalıdır Yeni oturum etiketleri teslim edilir Yakın zamanda herhangi bir paketleme gerçekleşmemiştir (~varsayılan olarak 1 dakika) Garlic mesajları, tek bir pakette birden fazla şifrelenmiş bileşenin verimli uçtan uca iletimini sağlar.\n5. Şifreleme Evrimi 5.1 Historical Context Erken dönem dokümantasyon (≤ v0.9.12) ElGamal/AES+SessionTags şifrelemesini tanımlamıştır: - ElGamal 2048‑bit ile sarmalanmış AES oturum anahtarları - Yük şifrelemesi için AES‑256/CBC - Mesaj başına bir kez kullanılan 32‑bayt oturum etiketleri\nBu kriptosistem kullanımdan kaldırılmıştır.\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) 2019 ile 2023 yılları arasında, I2P tamamen ECIES‑X25519‑AEAD‑Ratchet\u0026rsquo;e geçiş yaptı. Modern yığın aşağıdaki bileşenleri standartlaştırır:\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains ECIES geçişinin faydaları: İleri gizlilik mesaj başına değişen anahtarlar aracılığıyla ElGamal\u0026rsquo;e kıyasla daha küçük yük boyutu Kriptanalitik gelişmelere karşı dayanıklılık Gelecekteki kuantum-sonrası hibrit sistemlerle uyumluluk (bkz. Öneri 169) Ek detaylar: ECIES Spesifikasyonu ve EncryptedLeaseSet spesifikasyonu belgelerine bakınız.\n6. LeaseSets and Garlic Bundling Garlic zarflar, hedef erişilebilirliğini yayınlamak veya güncellemek için sıklıkla LeaseSet\u0026rsquo;ler içerir.\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively Tüm LeaseSet'ler, özel yönlendiriciler tarafından yönetilen *floodfill DHT* üzerinden dağıtılır. Yayınlar doğrulanır, zaman damgası ile işaretlenir ve metadata korelasyonunu azaltmak için hız sınırlamasına tabi tutulur. Detaylar için Network Database belgelerine bakın.\n7. Modern “Garlic” Applications within I2P Garlic encryption ve mesaj paketleme, I2P protokol yığınının tamamında kullanılır:\nTunnel oluşturma ve kullanımı — her atlama için katmanlı şifreleme Uçtan uca mesaj iletimi — klonlanmış-onay ve LeaseSet clove\u0026rsquo;ları ile paketlenmiş garlic mesajları Network Database yayınlama — gizlilik için garlic zarflarına sarılmış LeaseSet\u0026rsquo;ler SSU2 ve NTCP2 aktarımları — Noise çerçevesi ve X25519/ChaCha20 temel bileşenleri kullanılarak alt katman şifrelemesi Garlic routing bu nedenle hem bir şifreleme katmanlama yöntemi hem de bir ağ mesajlaşma modelidir.\n6. LeaseSet\u0026rsquo;ler ve Garlic Paketleme I2P\u0026rsquo;nin dokümantasyon merkezi buradan ulaşılabilir , sürekli güncellenir. İlgili güncel teknik özellikler şunlardır:\nECIES Spesifikasyonu — ECIES‑X25519‑AEAD‑Ratchet Tunnel Oluşturma (ECIES) — modern tunnel inşa protokolü I2NP Spesifikasyonu — I2NP mesaj formatları SSU2 Spesifikasyonu — SSU2 UDP taşıma protokolü Ortak Yapılar — netDb ve floodfill davranışı Akademik doğrulama: Hoang ve diğerleri (IMC 2018, USENIX FOCI 2019) ve Muntaka ve diğerleri (2025), I2P\u0026rsquo;nin tasarımının mimari istikrarını ve operasyonel dayanıklılığını doğrulamaktadır.\n7. I2P İçindeki Modern \u0026ldquo;Garlic\u0026rdquo; Uygulamaları Devam eden öneriler:\nÖneri 169: Hibrit kuantum-sonrası (ML-KEM 512/768/1024 + X25519) Öneri 168: Taşıma bant genişliği optimizasyonu Datagram ve akış güncellemeleri: Gelişmiş tıkanıklık yönetimi Gelecekteki uyarlamalar, Freedman tarafından başlangıçta tanımlanan kullanılmayan teslimat seçenekleri üzerine inşa edilerek, garlic-message seviyesinde ek mesaj geciktirme stratejileri veya çoklu tünel yedekliliği içerebilir.\n8. Mevcut Dokümantasyon ve Referanslar Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. ","description":"I2P'de garlic routing terminolojisini, mimarisini ve modern uygulamasını anlamak","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"Garlic Yönlendirme","url":"/tr/docs/overview/garlic-routing/"},{"categories":null,"content":"Önce Yeni Geliştiriciler Kılavuzu \u0026rsquo;nu okuyun.\nTemel Yönergeler ve Kodlama Stili Aşağıdakilerin çoğu, açık kaynak projelerde veya ticari bir programlama ortamında çalışmış olan herkes için sağduyu gerektiren konular olmalıdır. Aşağıdakiler çoğunlukla ana geliştirme dalı i2p.i2p için geçerlidir. Diğer dallar, eklentiler ve harici uygulamalar için yönergeler önemli ölçüde farklı olabilir; rehberlik için ilgili geliştiriciyle görüşün.\nTopluluk Lütfen sadece kod yazmayın. Mümkünse, aşağıdakiler dahil olmak üzere diğer geliştirme faaliyetlerine katılın: IRC ve i2pforum.i2p üzerinde geliştirme tartışmaları ve destek; test etme; hata bildirimi ve yanıtlar; dokümantasyon; kod incelemeleri; vb. Aktif geliştiriciler IRC #i2p-dev kanalında periyodik olarak erişilebilir olmalıdır. Mevcut sürüm döngüsünün farkında olun. Özellik dondurma, etiket dondurma ve bir sürüm için check-in son tarihi gibi sürüm kilometre taşlarına uyun. Sürüm Döngüsü Normal sürüm döngüsü 10-16 hafta olup, yılda dört sürüm yapılır. Aşağıda tipik bir 13 haftalık döngü içindeki yaklaşık son tarihler yer almaktadır. Her sürüm için gerçek son tarihler, sürüm yöneticisi tarafından tüm ekiple istişare edildikten sonra belirlenir.\nÖnceki sürümden 1–2 gün sonra: Trunk\u0026rsquo;a check-in yapılmasına izin verilir. Önceki sürümden 2–3 hafta sonra: Diğer dallardan trunk\u0026rsquo;a büyük değişikliklerin aktarılması için son tarih. Sürümden 4–5 hafta önce: Yeni ana sayfa bağlantıları talep etmek için son tarih. Sürümden 3–4 hafta önce: Özellik dondurma. Büyük yeni özellikler için son tarih. Sürümden 2–3 hafta önce: Varsa yeni ana sayfa bağlantı taleplerini gözden geçirmek için proje toplantısı düzenlenir. Sürümden 10–14 gün önce: String dondurma. Çevrilmiş (etiketlenmiş) string\u0026rsquo;lerde daha fazla değişiklik yapılmaz. String\u0026rsquo;ler Transifex\u0026rsquo;e gönderilir, çeviri son tarihi Transifex\u0026rsquo;te duyurulur. Sürümden 10–14 gün önce: Özellik son tarihi. Bu tarihten sonra yalnızca hata düzeltmeleri. Artık özellik, refactoring veya temizleme yapılmaz. Sürümden 3–4 gün önce: Çeviri son tarihi. Çeviriler Transifex\u0026rsquo;ten çekilir ve check-in yapılır. Sürümden 3–4 gün önce: Check-in son tarihi. Bu tarihten sonra sürüm oluşturucusunun izni olmadan check-in yapılmaz. Sürümden saatler önce: Kod inceleme son tarihi. Git Dağıtık kaynak kontrol sistemleri hakkında temel bir anlayışa sahip olun, daha önce git kullanmamış olsanız bile. Gerekirse yardım isteyin. Bir kez gönderildikten sonra, check-in\u0026rsquo;ler kalıcıdır; geri alma yoktur. Lütfen dikkatli olun. Daha önce git kullanmadıysanız, küçük adımlarla başlayın. Bazı küçük değişiklikleri check-in yapın ve nasıl gittiğini görün. Değişikliklerinizi check-in yapmadan önce test edin. Check-in‑önce‑test geliştirme modelini tercih ediyorsanız, kendi hesabınızda kendi geliştirme dalınızı kullanın ve iş bittiğinde bir MR oluşturun. Build\u0026rsquo;i bozmayın. Regresyonlara neden olmayın. Buna neden olursanız (olur), lütfen değişikliğinizi gönderdikten sonra uzun süre ortadan kaybolmayın. Değişikliğiniz önemsiz değilse veya insanların test etmesini istiyorsanız ve değişikliğinizin test edilip edilmediğini bilmek için iyi test raporlarına ihtiyacınız varsa, history.txt dosyasına bir check-in yorumu ekleyin ve RouterVersion.java dosyasındaki build revizyonunu artırın. Sürüm döngüsünün geç aşamalarında ana i2p.i2p dalına büyük değişiklikler check-in yapmayın. Bir proje birkaç günden fazla sürecekse, git\u0026rsquo;te kendi hesabınızda kendi dalınızı oluşturun ve geliştirmeyi orada yapın, böylece sürümleri engellemezsiniz. Büyük değişiklikler için (genel olarak konuşursak, 100 satırdan fazla veya üçten fazla dosyaya dokunan), kendi GitLab hesabınızda yeni bir dala check-in yapın, bir MR oluşturun ve bir gözden geçiren atayın. MR\u0026rsquo;ı kendinize atayın. Gözden geçiren onayladıktan sonra MR\u0026rsquo;ı kendiniz birleştirin. Ana I2P_Developers hesabında WIP dalları oluşturmayın (i2p.www hariç). WIP kendi hesabınıza aittir. İş bittiğinde bir MR oluşturun. Ana hesaptaki tek dallar, bir nokta sürümü gibi gerçek fork\u0026rsquo;lar için olmalıdır. Geliştirmeyi şeffaf bir şekilde ve topluluğu göz önünde bulundurarak yapın. Sık sık check-in yapın. Yukarıdaki yönergeleri göz önünde bulundurarak mümkün olduğunca sık ana dala check-in yapın veya birleştirin. Kendi dalınızda/hesabınızda büyük bir proje üzerinde çalışıyorsanız, insanlara haber verin böylece takip edebilir, inceleyebilir, test edebilir ve yorum yapabilirler. Kodlama Stili Kodun çoğu boyunca kodlama stili girinti için 4 boşluktur. Tab kullanmayın. Kodu yeniden biçimlendirmeyin. IDE\u0026rsquo;niz veya editörünüz her şeyi yeniden biçimlendirmek istiyorsa, kontrol altına alın. Bazı yerlerde kodlama stili farklıdır. Sağduyuyu kullanın. Değiştirdiğiniz dosyadaki stili taklit edin. Tüm yeni public ve package-private sınıflar ve metodlar Javadocs gerektirir. @since sürüm-numarası ekleyin. Yeni private metodlar için Javadocs\u0026rsquo;lar arzu edilir. Eklenen herhangi bir Javadocs için doclint hatası veya uyarısı olmamalıdır. Kontrol etmek için Oracle Java 14 veya üzeri ile ant javadoc çalıştırın. Tüm parametrelerin @param satırları, tüm void olmayan metodların @return satırları, fırlatıldığı belirtilen tüm istisnaların @throws satırları olmalı ve HTML hatası olmamalıdır. core/ (i2p.jar) içindeki sınıflar ve i2ptunnel\u0026rsquo;ın bazı bölümleri resmi API\u0026rsquo;mizin bir parçasıdır. Bu API\u0026rsquo;ye dayanan birkaç tree-dışı plugin ve diğer uygulamalar vardır. Uyumluluğu bozan herhangi bir değişiklik yapmamaya dikkat edin. Genel fayda sağlamadıkça API\u0026rsquo;ye metodlar eklemeyin. API metodları için Javadocs\u0026rsquo;lar açık ve eksiksiz olmalıdır. API\u0026rsquo;yi ekler veya değiştirirseniz, web sitesindeki belgeleri de güncelleyin (i2p.www dalı). Uygun yerlerde çeviri için string\u0026rsquo;leri etiketleyin, bu tüm UI string\u0026rsquo;leri için geçerlidir. Gerçekten gerekli olmadıkça mevcut etiketli string\u0026rsquo;leri değiştirmeyin, çünkü mevcut çevirileri bozar. Çevirmenlerin sürümden önce güncelleme şansı olması için sürüm döngüsündeki etiket dondurmasından sonra etiketli string\u0026rsquo;ler eklemeyin veya değiştirmeyin. Mümkün olduğunca generics ve concurrent sınıflar kullanın. I2P yüksek düzeyde çok thread\u0026rsquo;li bir uygulamadır. FindBugs/SpotBugs tarafından yakalanan yaygın Java tuzaklarına aşina olun. Daha fazla bilgi için ant findbugs çalıştırın. 0.9.47 sürümünden itibaren I2P\u0026rsquo;yi derlemek ve çalıştırmak için Java 8 gereklidir. Gömülü alt sistemlerde Java 7 veya 8 sınıflarını veya metodlarını kullanmayın: addressbook, core, i2ptunnel.jar (UI olmayan), mstreaming, router, routerconsole (sadece haberler), streaming. Bu alt sistemler yalnızca Java 6 gerektiren Android ve gömülü uygulamalar tarafından kullanılır. Tüm sınıflar Android API 14\u0026rsquo;te mevcut olmalıdır. Bu alt sistemlerde Java 7 dil özellikleri, mevcut Android SDK sürümü tarafından destekleniyorsa ve Java 6 uyumlu koda derlendiyse kabul edilebilir. Try-with-resources gömülü alt sistemlerde kullanılamaz çünkü çalışma zamanında java.lang.AutoCloseable gerektirir ve bu Android API 19\u0026rsquo;a (KitKat 4.4) kadar mevcut değildir. java.nio.file paketi gömülü alt sistemlerde kullanılamaz çünkü Android API 26\u0026rsquo;ya (Oreo 8) kadar mevcut değildir. Yukarıdaki sınırlamalar dışında, Java 8 sınıfları, metodları ve yapıları yalnızca şu alt sistemlerde kullanılabilir: BOB, desktopgui, i2psnark, i2ptunnel.war (UI), jetty‑i2p.jar, jsonrpc, routerconsole (haberler hariç), SAM, susidns, susimail, systray. Plugin yazarları plugin.config dosyası aracılığıyla herhangi bir minimum Java sürümü gerektirebilir. İlkel tipler ve sınıflar arasında açıkça dönüştürme yapın; autoboxing/unboxing\u0026rsquo;e güvenmeyin. URL kullanmayın. URI kullanın. Exception yakalamayın. RuntimeException ve checked exception\u0026rsquo;ları ayrı ayrı yakalayın. String.getBytes() metodunu UTF‑8 charset argümanı olmadan kullanmayın. Ayrıca DataHelper.getUTF8() veya DataHelper.getASCII() kullanabilirsiniz. Dosyaları okurken veya yazarken her zaman UTF‑8 charset belirtin. DataHelper yardımcı programları faydalı olabilir. String.toLowerCase() veya String.toUpperCase() kullanırken her zaman bir locale (örneğin Locale.US) belirtin. String.equalsIgnoreCase() kullanmayın, çünkü locale belirtilemez. String.split() kullanmayın. DataHelper.split() kullanın. Tarih ve saatleri biçimlendirmek için kod eklemeyin. DataHelper.formatDate() ve DataHelper.formatTime() kullanın. InputStream\u0026lsquo;lerin ve OutputStream\u0026lsquo;lerin finally bloklarında kapatıldığından emin olun. Tüm for ve while blokları için, tek satır olsa bile {} kullanın. if, else veya if-else bloğundan herhangi biri için {} kullanırsanız, tüm bloklar için kullanın. } else { tek bir satıra koyun. Alanları mümkün olan her yerde final olarak belirtin. I2PAppContext, RouterContext, Log veya router veya context öğelerine yapılan diğer referansları static alanlarda saklamayın. Constructor\u0026rsquo;larda thread başlatmayın. Thread yerine I2PAppThread kullanın. Günlükleme Aşağıdaki yönergeler router, web uygulamaları ve tüm eklentiler için geçerlidir.\nVarsayılan log seviyesinde (WARN, INFO ve DEBUG) görüntülenmeyen herhangi bir mesaj için, mesaj statik bir string olmadığı sürece (birleştirme yok), gereksiz nesne yığılmasını önlemek için log çağrısından önce her zaman log.shouldWarn(), log.shouldInfo() veya log.shouldDebug() kullanın. Varsayılan log seviyesinde (ERROR, CRIT ve logAlways()) görüntülenebilecek log mesajları kısa, net ve teknik olmayan bir kullanıcı için anlaşılır olmalıdır. Bu, aynı zamanda görüntülenebilecek istisna nedeni metnini de içerir. Hatanın gerçekleşme olasılığı yüksekse (örneğin, form gönderme hatalarında) çeviri yapmayı düşünün. Aksi takdirde, çeviri gerekli değildir, ancak başka bir yerde çeviri için zaten etiketlenmiş bir stringi arayıp yeniden kullanmak faydalı olabilir. Varsayılan log seviyesinde görüntülenmeyen log mesajları (WARN, INFO ve DEBUG) geliştirici kullanımı için tasarlanmıştır ve yukarıdaki gereksinimlere sahip değildir. Ancak, WARN mesajları Android log sekmesinde mevcuttur ve sorunları gidermede kullanıcılara yardımcı olabilir, bu nedenle WARN mesajlarıyla da biraz özen gösterin. INFO ve DEBUG log mesajları, özellikle sık çalışan kod yollarında (hot code paths) dikkatli kullanılmalıdır. Geliştirme sırasında faydalı olsa da, test tamamlandıktan sonra bunları kaldırmayı veya yorum satırına almayı düşünün. stdout veya stderr\u0026rsquo;e (wrapper log) log yazmayın. Lisanslar Yalnızca kendinizin yazdığı kodu commit edin. Diğer kaynaklardan gelen herhangi bir kod veya kütüphane JAR dosyasını commit etmeden önce, neden gerekli olduğunu gerekçelendirin, lisansın uyumlu olduğunu doğrulayın ve sürüm yöneticisinden onay alın. Harici kod veya JAR dosyaları eklemek için onay alırsanız ve ikili dosyalar herhangi bir Debian veya Ubuntu paketinde mevcutsa, harici paketi kullanmak için derleme ve paketleme seçeneklerini uygulamalısınız. Değiştirilecek dosyaların kontrol listesi: build.properties, build.xml, debian/control, debian/i2p-router.install, debian/i2p-router.links, debian/rules, sub-build.xml. Harici kaynaklardan commit edilen herhangi bir görsel için, önce lisansın uyumlu olduğunu doğrulamak sizin sorumluluğunuzdadır. Commit yorumuna lisans ve kaynak bilgilerini dahil edin. Hatalar Sorunları yönetmek herkesin işidir; lütfen yardım edin. Yardım edebileceğiniz sorunlar için GitLab \u0026lsquo;ı takip edin. Yapabiliyorsanız sorunlara yorum yapın, düzeltin ve kapatın. Yeni geliştiriciler sorunları düzelterek başlamalıdır. Bir düzeltmeniz olduğunda, yamanızı soruna ekleyin ve review-needed anahtar kelimesini ekleyin. İncelenip başarıyla onaylanana ve değişikliklerinizi kontrol edene kadar sorunu kapatmayın. Bunu birkaç ticket için sorunsuz bir şekilde yaptıktan sonra, yukarıdaki normal prosedürü izleyebilirsiniz. Düzelttiğinizi düşündüğünüzde bir sorunu kapatın. Ticket\u0026rsquo;ları doğrulamak ve kapatmak için bir test departmanımız yok. Düzelttiğinizden emin değilseniz, kapatın ve \u0026ldquo;Düzelttiğimi düşünüyorum, lütfen test edin ve hala bozuksa yeniden açın\u0026rdquo; diyen bir not ekleyin. Dev build numarası veya revizyon ile bir yorum ekleyin ve milestone\u0026rsquo;ı bir sonraki sürüme ayarlayın. ","description":"I2P'ye katkıda bulunmak için uçtan uca yönergeler: iş akışı, sürüm döngüsü, kodlama stili, günlükleme, lisanslama ve sorun yönetimi","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"Geliştirici Yönergeleri ve Kodlama Stili","url":"/tr/docs/develop/dev-guidelines/"},{"categories":null,"content":"Genel Bakış NOT: ARTIK GEÇERSİZ - Artık tercih sırasına göre üç formatı destekliyoruz:\nMaxmind geoip2 (GeoLite2-Country.mmdb), Debian paketleri ve Android hariç tüm kurulumlarla birlikte gelir Maxmind geoip1 (GeoIP.dat), Debian geoip-database paketinde bulunur Aşağıda belgelenen IPv4 Tor biçimi (geoip.txt) ve özel IPv6 biçimi (geoipv6.dat.gz), hâlâ desteklenmektedir ancak kullanılmamaktadır. Bu sayfa, router tarafından bir IP’nin ülkesini sorgulamak için kullanılan çeşitli GeoIP dosyalarının biçimini tanımlar.\nÜlke Adı (countries.txt) Biçimi Bu biçim, pek çok kamuya açık kaynaktan erişilebilen veri dosyalarından kolayca oluşturulabilir. Örneğin:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Biçim özellikleri:\nKodlama UTF-8\u0026rsquo;dir sütundaki \u0026lsquo;#\u0026rsquo; bir yorum satırını belirtir Girdi satırları CountryCode,CountryName biçimindedir CountryCode, iki harfli ISO kodudur, büyük harflerle yazılır CountryName İngilizcedir IPv4 (geoip.txt) Biçimi Bu biçim Tor\u0026rsquo;dan alınmıştır ve birçok kamuya açık kaynaktan temin edilebilen veri dosyalarından kolayca oluşturulabilir. Örneğin:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Biçim spesifikasyonları:\nKodlama ASCII\u0026rsquo;dir sütundaki \u0026lsquo;#\u0026rsquo; bir yorum satırını belirtir Kayıt satırları FromIP,ToIP,CountryCode şeklindedir FromIP ve ToIP, 4 baytlık IP\u0026rsquo;nin işaretsiz tamsayı gösterimleridir CountryCode, ISO iki harfli koddur, büyük harfli olmalıdır Kayıt satırları, sayısal FromIP değerine göre sıralanmış olmalıdır IPv6 (geoipv6.dat.gz) Formatı Bu, I2P için tasarlanmış sıkıştırılmış bir ikili biçimdir. Dosya gzip ile sıkıştırılmıştır. Sıkıştırması açılmış biçim:\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) Notlar:\nVeriler sıralanmış olmalıdır (işaretli long ikinin tümleyeni), çakışma olmamalıdır. Sıralama şu şekildedir: 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF. GeoIPv6.java sınıfı, Maxmind GeoLite verileri gibi kamuya açık kaynaklardan bu biçimi üretmek için bir program içerir. IPv6 GeoIP sorgulaması 0.9.8 sürümünden itibaren desteklenir. ","description":"IP'den ülke sorgulamaları için eski GeoIP dosya biçimi spesifikasyonları","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"GeoIP Dosya Formatları","url":"/tr/docs/legacy/geoip-dosya-formatlar%C4%B1/"},{"categories":null,"content":"GitLab\u0026rsquo;ı I2P içinde barındırmak basittir: GitLab omnibus konteynerini çalıştırın, loopback üzerinde açığa çıkarın ve trafiği bir I2P tüneli üzerinden yönlendirin. Aşağıdaki adımlar git.idk.i2p için kullanılan yapılandırmayı yansıtır ancak herhangi bir kendi barındırılan örnek için çalışır.\n1. Ön Gereksinimler Docker Engine yüklü Debian veya başka bir Linux dağıtımı (sudo apt install docker.io veya Docker deposundan docker-ce). Kullanıcılarınıza hizmet verecek yeterli bant genişliğine sahip bir I2P router (Java I2P veya i2pd). İsteğe bağlı: GitLab ve router\u0026rsquo;ın masaüstü ortamınızdan izole kalması için ayrılmış bir VM. 2. GitLab İmajını Çekin docker pull gitlab/gitlab-ce:latest Resmi imaj Ubuntu temel katmanlarından oluşturulur ve düzenli olarak güncellenir. Ek güvence ihtiyacınız varsa Dockerfile dosyasını inceleyin.\n3. Köprüleme ile Yalnızca I2P Arasında Karar Verin Yalnızca I2P örnekleri asla clearnet sunucularıyla iletişim kurmaz. Kullanıcılar depoları diğer I2P hizmetlerinden yansıtabilir ancak GitHub/GitLab.com\u0026rsquo;dan yansıtamaz. Bu, anonimliği maksimize eder. Köprülenmiş örnekler, bir HTTP proxy üzerinden clearnet Git sunucularına erişir. Bu, genel projeleri I2P\u0026rsquo;ye yansıtmak için kullanışlıdır ancak sunucunun giden isteklerini anonimlikten çıkarır. Bridged modu seçerseniz, GitLab\u0026rsquo;ı Docker host\u0026rsquo;unda bağlı bir I2P HTTP proxy kullanacak şekilde yapılandırın (örneğin http://172.17.0.1:4446). Varsayılan router proxy yalnızca 127.0.0.1 üzerinde dinler; Docker gateway adresine bağlı yeni bir proxy tunnel ekleyin.\n4. Container\u0026rsquo;ı Başlatın docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest Yayınlanan portları loopback\u0026rsquo;e bağlayın; I2P tunnel\u0026rsquo;ları bunları gerektiğinde açığa çıkaracaktır. /srv/gitlab/... yolunu sunucunuza uygun depolama yollarıyla değiştirin. Container çalıştıktan sonra https://127.0.0.1:8443/ adresini ziyaret edin, bir yönetici parolası belirleyin ve hesap limitlerini yapılandırın.\n5. GitLab\u0026rsquo;ı I2P Üzerinden Erişilebilir Hale Getirme Üç adet I2PTunnel sunucu tüneli oluşturun:\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated Her tunnel\u0026rsquo;ı uygun tunnel uzunluğu ve bant genişliği ile yapılandırın. Genel erişime açık sunucular için, her yön başına 4–6 tunnel ile 3 hop iyi bir başlangıç noktasıdır. Ortaya çıkan Base32/Base64 adreslerini açılış sayfanızda yayınlayın, böylece kullanıcılar client tunnel\u0026rsquo;larını yapılandırabilir. Destination Enforcement HTTP(S) tünelleri kullanıyorsanız, yalnızca hedeflenen hostname\u0026rsquo;in hizmete erişebilmesi için hedef zorunluluğunu etkinleştirin. Bu, tünelin genel bir proxy olarak kötüye kullanılmasını önler.\n6. Maintenance Tips GitLab ayarlarını her değiştirdiğinizde docker exec gitlab gitlab-ctl reconfigure komutunu çalıştırın. Disk kullanımını izleyin (/srv/gitlab/data)—Git depoları hızla büyür. Yapılandırma ve veri dizinlerini düzenli olarak yedekleyin. GitLab\u0026rsquo;ın yedekleme rake görevleri container içinde çalışır. Hizmetin daha geniş ağdan erişilebilir olduğundan emin olmak için harici bir izleme tunnel\u0026rsquo;ını client modunda yerleştirmeyi düşünün. 6. Bakım İpuçları I2P\u0026rsquo;yi uygulamanıza gömme I2P üzerinden Git (istemci rehberi) Çevrimdışı/yavaş ağlar için Git paketleri İyi yapılandırılmış bir GitLab örneği, tamamen I2P içinde işbirlikçi bir geliştirme merkezi sağlar. Router\u0026rsquo;ı sağlıklı tutun, GitLab güvenlik güncellemelerini takip edin ve kullanıcı tabanınız büyüdükçe toplulukla koordinasyon halinde olun.\n","description":"I2P içinde Docker ve bir I2P yönlendiricisi kullanarak GitLab dağıtımı","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"GitLab'ı I2P Üzerinde Çalıştırma","url":"/tr/docs/guides/gitlab/"},{"categories":null,"content":"Güvenlik İletişim Güvenlik açıklarını veya hassas güvenlik sorunlarını bildirmek için lütfen security@i2p.net adresinden I2P Güvenlik Ekibi ile iletişime geçin\nGüvenli iletişim için lütfen aşağıdaki PGP anahtarımızı kullanın.\nPGP Anahtar Bilgisi E-posta: security@i2p.net Anahtar Kimliği: 176E1941 Parmak İzi: 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 Anahtar Türü: RSA 4096-bit Oluşturulma: 2025-10-19 Son Kullanma: 2030-11-19 UID: I2P Security \u0026lt;security@i2p.net\u0026gt; Açık Anahtar I2P Güvenlik Ekibi\u0026rsquo;nin GPG genel anahtarı aşağıdadır: \u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nmQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"I2P Güvenlik Ekibi ile iletişim için GPG genel anahtarı","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"Güvenlik GPG Anahtarı","url":"/tr/docs/develop/security-key/"},{"categories":null,"content":"Genel Bakış I2P Ağ Protokolü (I2NP), router\u0026rsquo;ların mesajları nasıl alışveriş ettiklerini, taşıma protokollerini nasıl seçtiklerini ve anonimliği korurken trafiği nasıl karıştırdıklarını tanımlar. I2CP (istemci API\u0026rsquo;si) ile taşıma protokolleri (NTCP2 ve SSU2) arasında çalışır.\nI2NP, I2P taşıma protokollerinin üstündeki katmandır. Şu amaçlarla kullanılan router\u0026rsquo;lar arası bir protokoldür: - Ağ veritabanı sorgulamaları ve yanıtları - tunnel oluşturma - Şifrelenmiş router ve istemci veri iletileri\nI2NP mesajları başka bir router\u0026rsquo;a nokta-noktaya gönderilebilir veya o router\u0026rsquo;a tunnels üzerinden anonim olarak gönderilebilir.\nRouters, yerel öncelikleri kullanarak giden işleri kuyruğa alır. Daha yüksek öncelik numaraları önce işlenir. Standart tunnel veri önceliği (400) üzerindeki her şey acil olarak değerlendirilir.\nGüncel Taşıma Protokolleri I2P artık hem IPv4 hem de IPv6 için NTCP2 (TCP) ve SSU2 (UDP) kullanıyor. Her iki taşıma protokolü de şunları kullanır: - X25519 anahtar değişimi (Noise protokol çerçevesi) - ChaCha20/Poly1305 kimliği doğrulanmış şifreleme (AEAD) - SHA-256 özetleme\nEski taşıma protokolleri kaldırıldı: - NTCP (orijinal TCP) Java router\u0026rsquo;dan 0.9.50 sürümünde (Mayıs 2021) kaldırıldı - SSU v1 (orijinal UDP) Java router\u0026rsquo;dan 2.4.0 sürümünde (Aralık 2023) kaldırıldı - SSU v1, i2pd\u0026rsquo;den 2.44.0 sürümünde (Kasım 2022) kaldırıldı\n2025 itibarıyla ağ, tamamen Noise tabanlı taşıma protokollerine geçmiş olup hiçbir eski (legacy) taşıma desteği bulunmamaktadır.\nSürüm Numaralandırma Sistemi ÖNEMLİ: I2P, net biçimde anlaşılması gereken ikili bir sürümleme sistemi kullanır:\nYayın sürümleri (kullanıcıya yönelik) Kullanıcıların gördüğü ve indirdiği sürümler şunlardır: - 0.9.50 (Mayıs 2021) - Son 0.9.x sürümü - 1.5.0 (Ağustos 2021) - İlk 1.x sürümü - 1.6.0, 1.7.0, 1.8.0, 1.9.0 (2021-2022 boyunca) - 2.0.0 (Kasım 2022) - İlk 2.x sürümü - 2.1.0\u0026rsquo;dan 2.9.0\u0026rsquo;a (2023-2025 boyunca) - 2.10.0 (8 Eylül 2025) - Güncel sürüm\nAPI Sürümleri (Protokol Uyumluluğu) Bunlar, RouterInfo özelliklerindeki \u0026ldquo;router.version\u0026rdquo; alanında yayımlanan dahili sürüm numaralarıdır: - 0.9.50 (Mayıs 2021) - 0.9.51 (Ağustos 2021) - 1.5.0 sürümü için API sürümü - 0.9.52 ile 0.9.66 arası (2.x sürümleri boyunca devam ediyor) - 0.9.67 (Eylül 2025) - 2.10.0 sürümü için API sürümü\nÖnemli Nokta: 0.9.51 ile 0.9.67 numaraları arasında HİÇBİR sürüm yayımlanmadı. Bu numaralar yalnızca API sürüm tanımlayıcıları olarak kullanılır. I2P, 0.9.50 sürümünden doğrudan 1.5.0\u0026rsquo;a atladı.\nSürüm Eşleme Tablosu Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) **Yakında:** Sürüm 2.11.0 (Aralık 2025 için planlanıyor) Java 17+ gerektirecek ve varsayılan olarak post-kuantum kriptografiyi etkinleştirecek. Protokol Sürümleri Tüm router\u0026rsquo;lar I2NP protokol sürümlerini RouterInfo özelliklerindeki \u0026ldquo;router.version\u0026rdquo; alanında yayımlamalıdır. Bu sürüm alanı, çeşitli I2NP protokol özellikleri için destek düzeyini gösteren API sürümüdür ve mutlaka gerçek router sürümü olmayabilir.\nAlternatif (Java dışı) router’lar, asıl router gerçekleştirimine ilişkin herhangi bir sürüm bilgisi yayımlamak isterlerse, bunu başka bir özellikte yapmalıdırlar. Aşağıda listelenenler dışındaki sürümlere izin verilir. Destek, sayısal bir karşılaştırma ile belirlenecektir; örneğin 0.9.13, 0.9.12 özelliklerine destek anlamına gelir.\nNot: \u0026ldquo;coreVersion\u0026rdquo; özelliği artık router info içinde yayımlanmıyor ve I2NP protokol sürümünün belirlenmesi için hiçbir zaman kullanılmadı.\nAPI Sürümüne Göre Özellik Özeti API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network **Not:** Taşıma ile ilgili özellikler ve uyumluluk sorunları da vardır. Ayrıntılar için NTCP2 ve SSU2 taşıma dokümantasyonuna bakın. İleti Üstbilgisi I2NP, mantıksal bir 16 baytlık başlık yapısı kullanırken, modern taşıma protokolleri (NTCP2 ve SSU2) gereksiz boyut ve sağlama toplamı alanlarını içermeyen kısaltılmış 9 baytlık bir başlık kullanır. Alanlar kavramsal olarak özdeş kalır.\nBaşlık Biçimi Karşılaştırması Standart Biçim (16 bayt):\nEski NTCP (I2P\u0026rsquo;nin TCP tabanlı taşıma protokolü) taşımasında ve I2NP iletileri diğer iletilerin içine gömüldüğünde (TunnelData, TunnelGateway, GarlicClove) kullanılır.\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity SSU için Kısa Biçim (Kullanımdan kaldırılmış, 5 bayt):\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) NTCP2, SSU2 ve ECIES-Ratchet Garlic Cloves (I2P\u0026rsquo;de \u0026lsquo;garlic\u0026rsquo; mesajını oluşturan alt bileşenler) için Kısa Biçim (9 bayt):\nModern taşıma protokollerinde ve ECIES ile şifrelenmiş garlic mesajlarında (I2P\u0026rsquo;de demetlemeye dayalı mesajlar) kullanılır.\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) Başlık Alanı Ayrıntıları Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity ### Uygulama Notları SSU (kullanımdan kalkmış) üzerinden iletilirken, yalnızca tür ve 4 baytlık sona erme zamanı dahil edilirdi NTCP2 veya SSU2 üzerinden iletilirken, 9 baytlık kısa biçim kullanılır Diğer iletiler içinde yer alan I2NP iletileri için standart 16 baytlık başlık gereklidir (Data, TunnelData, TunnelGateway, GarlicClove) 0.8.12 sürümünden itibaren, verimlilik amacıyla protokol yığınının bazı noktalarında sağlama toplamı doğrulaması devre dışı bırakılmıştır, ancak uyumluluk için sağlama toplamının üretilmesi hâlâ gereklidir Kısa sona erme alanı imzasızdır ve 7 Şubat 2106\u0026rsquo;da taşma yapacaktır. Bu tarihten sonra doğru zamanı elde etmek için bir ofset eklenmelidir Daha eski sürümlerle uyumluluk için, doğrulanmasalar bile her zaman sağlama toplamlarını üretin Boyut Sınırları Tunnel iletileri I2NP yüklerini sabit boyutlu parçalara böler: - İlk parça: yaklaşık 956 bayt - Sonraki parçalar: her biri yaklaşık 996 bayt - Maksimum parça sayısı: 64 (0-63 olarak numaralanmış) - Maksimum yük: yaklaşık 61,200 bayt (61.2 KB)\nHesaplama: 956 + (63 × 996) = 63,704 baytlık teorik maksimum; ek yük nedeniyle pratik sınır yaklaşık 61,200 bayt.\nTarihsel Bağlam Eski taşıma protokollerinde çerçeve boyutu sınırları daha sıkıydı: - NTCP: 16 KB\u0026rsquo;lik çerçeveler - SSU: yaklaşık 32 KB\u0026rsquo;lik çerçeveler\nNTCP2 yaklaşık 65 KB boyutunda çerçeveleri destekler, ancak tunnel parçalama sınırı hâlâ geçerlidir.\nUygulama Verilerine İlişkin Hususlar Garlic messages (I2P\u0026rsquo;de birden çok öğeyi tek bir iletide paketleyen mesajlar) LeaseSets, Session Tags veya şifrelenmiş LeaseSet2 varyantlarını birlikte taşıyabilir ve bu da yük verisi için ayrılan alanı azaltır.\nÖneri: Güvenilir iletimi sağlamak için datagramların ≤ 10 KB kalması gerekir. 61 KB sınırına yaklaşan iletiler şu sorunlarla karşılaşabilir: - Parçalama sonrası yeniden birleştirme nedeniyle artan gecikme - İletimin başarısız olma olasılığının artması - Trafik analizine daha fazla maruz kalma\nParçalama Teknik Ayrıntıları Her tunnel iletisi tam olarak 1,024 bayt (1 KB) boyutundadır ve şunları içerir: - 4 baytlık tunnel ID - 16 baytlık başlatma vektörü (IV) - 1,004 bayt şifrelenmiş veri\nŞifrelenmiş verinin içinde, tunnel iletileri, parça başlıklarında şunları belirten parçalanmış I2NP iletilerini taşır: - Parça numarası (0-63) - Bunun ilk mi yoksa devam parçası mı olduğunu - Yeniden birleştirme için toplam ileti kimliği\nİlk parça, tam I2NP mesaj başlığını (16 bayt) içerir ve yük için yaklaşık 956 bayt bırakır. Takip eden parçalar mesaj başlığını içermez, bu da parça başına yaklaşık 996 bayt yük sağlar.\nYaygın Mesaj Türleri Router\u0026rsquo;lar, giden işleri zamanlamak için ileti türünü ve önceliği kullanır. Daha yüksek öncelik değerleri önce işlenir. Aşağıdaki değerler, geçerli Java I2P varsayılanlarıyla eşleşir (API sürümü 0.9.67 itibarıyla).\nNot: Öncelikler implementasyona bağlıdır. Kesin öncelik değerleri için, Java I2P kaynak kodundaki OutNetMessage sınıfı belgelerine bakın.\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) **Ayrılmış mesaj türleri:** - Tür 0: Ayrılmış - Türler 4-9: Gelecekteki kullanım için ayrılmış - Türler 12-17: Gelecekteki kullanım için ayrılmış - Türler 224-254: Deneysel mesajlar için ayrılmış - Tür 255: Gelecekteki genişletme için ayrılmış Mesaj Türü Notları Kontrol düzlemi mesajları (DatabaseLookup, TunnelBuild vb.) genellikle istemci tunnel\u0026rsquo;ları üzerinden değil, keşif tunnel\u0026rsquo;ları üzerinden iletilir, bu da bağımsız önceliklendirmeye olanak tanır Öncelik değerleri yaklaşık olup uygulamaya göre değişebilir TunnelBuild (21) ve TunnelBuildReply (22) kullanımdan kaldırılmıştır, ancak çok uzun tunnel\u0026rsquo;larla (\u0026gt;8 atlama) uyumluluk için hâlâ uygulanmaktadır Standart tunnel verisi önceliği 400\u0026rsquo;dür; bunun üzerindeki her şey acil olarak değerlendirilir Günümüz ağında tipik tunnel uzunluğu 3-4 atlamadır, bu nedenle çoğu tunnel kurulumu ShortTunnelBuild (218 baytlık kayıtlar) veya VariableTunnelBuild (528 baytlık kayıtlar) kullanır Şifreleme ve Mesaj Sarmalama Routers, iletimden önce I2NP mesajlarını sıkça kapsüller ve birden çok şifreleme katmanı oluşturur. DeliveryStatus message (teslim durumu mesajı) şunlardan biri olabilir: 1. Bir GarlicMessage içine sarılmış (şifrelenmiş) 2. Bir DataMessage\u0026rsquo;ın içinde 3. Bir TunnelData mesajının içinde (yeniden şifrelenmiş)\nHer atlama yalnızca kendi katmanının şifresini çözer; son hedef en içteki veri yükünü ortaya çıkarır.\nŞifreleme Algoritmaları Eski (Aşamalı olarak kullanım dışı bırakılıyor): - ElGamal/AES + SessionTags (oturum etiketleri) - asimetrik şifreleme için ElGamal-2048 - simetrik şifreleme için AES-256 - 32 baytlık oturum etiketleri\nGüncel (API 0.9.48 itibarıyla standart): - ECIES-X25519 + ChaCha20/Poly1305 AEAD ile ratcheting (mandallamalı) ileri gizlilik - Noise protokol çerçevesi (destinasyonlar için Noise_IK_25519_ChaChaPoly_SHA256) - 8 baytlık oturum etiketleri (32 bayttan düşürüldü) - ileri gizlilik için Signal Double Ratchet algoritması - API sürümü 0.9.46\u0026rsquo;da (2020) tanıtıldı - API sürümü 0.9.58 (2023) itibarıyla tüm routers için zorunlu\nGelecek (2.10.0 itibarıyla Beta): - MLKEM (ML-KEM-768) kullanan ve X25519 ile birleştirilen post-kuantum hibrit kriptografi - Klasik ve post-kuantum anahtar uzlaşmasını birleştiren hibrit ratchet (kademeli anahtar yenileme mekanizması) - ECIES-X25519 ile geriye dönük uyumlu - 2.11.0 sürümünde varsayılan olacak (Aralık 2025)\nElGamal Router Kullanımdan Kaldırma KRİTİK: ElGamal router\u0026rsquo;lar API sürümü 0.9.58 (sürüm 2.2.0, Mart 2023) itibarıyla kullanımdan kaldırıldı. Artık sorgulanması önerilen asgari floodfill sürümü 0.9.58 olduğundan, gerçekleştirimlerin ElGamal floodfill router\u0026rsquo;lar için şifrelemeyi uygulaması gerekmez.\nAncak: Geriye dönük uyumluluk için ElGamal hedefleri hâlâ desteklenmektedir. ElGamal şifrelemesi kullanan istemciler ECIES router\u0026rsquo;lar aracılığıyla hâlâ iletişim kurabilir.\nECIES-X25519-AEAD-Ratchet Ayrıntıları Bu, I2P\u0026rsquo;nin kriptografi spesifikasyonundaki crypto type 4 (kripto türü 4)\u0026rsquo;tür. Şunları sağlar:\nTemel Özellikler: - Ratcheting (kademeli anahtar yenileme) ile ileri gizlilik (her mesaj için yeni anahtarlar) - Azaltılmış oturum etiketi depolama gereksinimi (8 bayt vs. 32 bayt) - Birden çok oturum türü (Yeni Oturum, Mevcut Oturum, Tek Seferlik) - Noise protokolüne dayalı Noise_IK_25519_ChaChaPoly_SHA256 - Signal\u0026rsquo;ın Double Ratchet (çift kademeli anahtar yenileme) algoritmasıyla entegre\nKriptografik Primitifler: - Diffie-Hellman anahtar anlaşması için X25519 - Akış şifrelemesi için ChaCha20 - Mesaj kimlik doğrulaması (AEAD) için Poly1305 - Özetleme için SHA-256 - Anahtar türetimi için HKDF\nOturum Yönetimi: - Yeni Oturum: Statik hedef anahtarı kullanılarak ilk bağlantı - Mevcut Oturum: Sonraki iletiler oturum etiketleri kullanılarak - Tek Seferlik Oturum: Daha düşük ek yük için tek iletilik oturumlar\nTüm teknik ayrıntılar için ECIES Spesifikasyonu ve Öneri 144 belgelerine bakın.\nOrtak Yapılar Aşağıdaki yapılar, birden fazla I2NP mesajının öğeleridir. Bunlar tam mesajlar değildir.\nBuildRequestRecord (tünel kurma isteği kaydı) (ElGamal) KULLANIMDAN KALDIRILDI. Bir tunnel (tünel) bir ElGamal router (yönlendirici) içerdiğinde yalnızca mevcut ağda kullanılır. Modern biçim için ECIES Tunnel Creation sayfasına bakın.\nAmaç: tunnel içinde bir hop (atlama) oluşturulmasını talep etmek için, birden fazla kayıttan oluşan bir kümedeki bir kayıt.\nBiçim:\nElGamal ve AES ile şifrelenmiş (toplam 528 bayt):\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ ElGamal şifrelenmiş yapı (528 bayt):\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) Açık metin yapısı (şifrelemeden önce 222 bayt):\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data Notlar: - ElGamal-2048 şifrelemesi 514 baytlık bir blok üretir, ancak iki doldurma baytı (0 ve 257. konumlarda) kaldırılır ve sonuçta 512 bayt kalır - Alan ayrıntıları için Tunnel Oluşturma Spesifikasyonu sayfasına bakın - Kaynak kodu: net.i2p.data.i2np.BuildRequestRecord - Sabit: EncryptedBuildRecord.RECORD_SIZE = 528\nBuildRequestRecord (inşa isteği kaydı) (ECIES-X25519 Long) API sürümü 0.9.48\u0026rsquo;te tanıtılan ECIES-X25519 router\u0026rsquo;lar için. Karma tunnel\u0026rsquo;larla geriye dönük uyumluluk için 528 bayt kullanır.\nBiçim:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) Toplam boyut: 528 bayt (uyumluluk için ElGamal ile aynı)\nAçık metin yapısı ve şifreleme ayrıntıları için ECIES Tunnel Creation sayfasına bakın.\nBuildRequestRecord (ECIES-X25519 Kısa) Yalnızca ECIES-X25519 routers için, API sürümü 0.9.51 (1.5.0 sürümü) itibarıyla. Bu, mevcut standart biçimdir.\nBiçim:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) Toplam boyut: 218 bayt (528 bayta kıyasla %59 azalma)\nTemel Fark: Kısa kayıtlar, kayıtta açıkça dahil etmek yerine TÜM anahtarları HKDF (anahtar türetme fonksiyonu) aracılığıyla türetir. Buna şunlar dahildir: - Katman anahtarları (tunnel şifrelemesi için) - IV anahtarları (tunnel şifrelemesi için) - Yanıt anahtarları (oluşturma yanıtı için) - Yanıt IV\u0026rsquo;leri (oluşturma yanıtı için)\nTüm anahtarlar, X25519 anahtar değişiminden elde edilen paylaşılan sırra dayalı olarak Noise protokolünün HKDF mekanizması kullanılarak türetilir.\nFaydalar: - 4 kısa kayıt tek bir tunnel mesajına sığar (873 bayt) - Her bir kayıt için ayrı mesajlar yerine 3 mesajlık tunnel kurulumları - Azaltılmış bant genişliği kullanımı ve gecikme - Uzun biçimle aynı güvenlik özellikleri\nGerekçe için Proposal 157 , tam spesifikasyon için ECIES Tunnel Creation belgesine bakın.\nKaynak kodu: - net.i2p.data.i2np.ShortEncryptedBuildRecord - Sabit: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nBuildResponseRecord (ElGamal) (oluşturma yanıt kaydı) KULLANIMDAN KALDIRILDI. Yalnızca tunnel bir ElGamal router içerdiğinde kullanılır.\nAmaç: Oluşturma isteğine verilen yanıtları içeren birden çok kayıttan oluşan kümedeki tek bir kayıt.\nBiçim:\nŞifrelenmiş (528 bayt, BuildRequestRecord ile aynı boyutta):\nbytes 0-527 :: AES-encrypted record Şifrelenmemiş yapı:\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) Yanıt Kodları: - 0 - Kabul - 30 - Reddet (bant genişliği aşıldı)\nYanıt alanı hakkında ayrıntılar için Tunnel Creation Specification bölümüne bakın.\nBuildResponseRecord (ECIES-X25519) ECIES-X25519 routers için, API sürümü 0.9.48+. Karşılık gelen istekle aynı boyuttadır (uzun için 528, kısa için 218).\nBiçim:\nUzun biçim (528 bayt):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Kısa biçim (218 bayt):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Açık metin yapısı (her iki formatta):\nBir Mapping yapısı (I2P\u0026rsquo;nin anahtar-değer biçimi) içerir: - Yanıt durum kodu (zorunlu) - Kullanılabilir bant genişliği parametresi (\u0026ldquo;b\u0026rdquo;) (isteğe bağlı, API 0.9.65\u0026rsquo;te eklendi) - Gelecekteki genişletmeler için diğer isteğe bağlı parametreler\nYanıt Durum Kodları: - 0 - Başarılı - 30 - Reddedildi: bant genişliği aşıldı\nTam spesifikasyon için ECIES Tunnel Oluşturma bölümüne bakın.\nGarlicClove (I2P\u0026rsquo;de garlic mesajının alt mesajı) (ElGamal/AES) UYARI: Bu, ElGamal ile şifrelenmiş garlic messages (birden fazla garlic clove içeren kapsül mesaj) içindeki garlic cloves (garlic message içindeki bireysel mesaj birimi) için kullanılan formattır. ECIES-AEAD-X25519-Ratchet garlic messages ve garlic cloves için kullanılan format ise önemli ölçüde farklıdır. Güncel format için bkz. ECIES Spesifikasyonu .\nrouters için kullanımdan kaldırılmıştır (API 0.9.58+), destinasyonlar için hâlâ desteklenmektedir.\nBiçim:\nŞifrelenmemiş:\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) Notlar: - Clove\u0026rsquo;lar (garlic mesajı içindeki alt-mesaj) asla parçalanmaz - Delivery Instructions bayrak baytının ilk biti 0 olduğunda, clove şifrelenmez - İlk bit 1 olduğunda, clove şifrelenir (uygulanmamış özellik) - Azami uzunluk, toplam clove uzunlukları ile azami GarlicMessage (I2P\u0026rsquo;de bir mesaj türü) uzunluğunun bir fonksiyonudur - Sertifika, yönlendirme için \u0026ldquo;ödeme\u0026rdquo; yapmak üzere HashCash ile kullanılabilir (geleceğe yönelik olasılık) - Uygulamada kullanılan mesajlar: DataMessage, DeliveryStatusMessage, DatabaseStoreMessage - GarlicMessage, GarlicMessage içerebilir (iç içe garlic), ancak bu uygulamada kullanılmaz\nKavramsal bir genel bakış için Garlic Routing (sarımsak yönlendirme tekniği) sayfasına bakın.\nGarlicClove (ECIES-X25519-AEAD-Ratchet) ECIES-X25519 routers ve hedefler için API sürümü 0.9.46+. Bu, güncel standart biçimdir.\nKRİTİK FARK: ECIES garlic, açıkça tanımlı clove (I2P\u0026rsquo;de garlic mesajı içindeki alt iletiler) yapıları yerine Noise protokolü bloklarına dayanan tamamen farklı bir yapı kullanır.\nBiçim:\nECIES (Eliptik Eğri Entegre Şifreleme Şeması) garlic mesajları bir dizi blok içerir:\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data Blok Türleri: - 0 - Garlic Clove Bloğu (bir I2NP mesajı içerir) - 1 - Tarih-Saat Bloğu (zaman damgası) - 2 - Seçenekler Bloğu (teslimat seçenekleri) - 3 - Dolgu Bloğu - 254 - Sonlandırma Bloğu (henüz uygulanmamış)\nSarımsak Dişi Bloğu (tip 0):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ ElGamal biçimine göre temel farklar: - 8 baytlık Date yerine 4 baytlık sona erme zamanı (Unix epoch\u0026rsquo;tan bu yana geçen saniye cinsinden) kullanır - Sertifika alanı yok - Tür ve uzunluk içeren bir blok yapısı içinde sarmalanmıştır - Tüm mesaj ChaCha20/Poly1305 AEAD ile şifrelenir - Oturum yönetimi ratcheting (mandallama) ile\nNoise protokol çerçevesi ve blok yapıları hakkında tüm ayrıntılar için ECIES Specification belgesine bakın.\nGarlic Clove (I2P\u0026rsquo;de bir garlic mesajının alt mesajı) Teslim Yönergeleri Bu biçim, hem ElGamal hem de ECIES garlic cloves (garlic mesajı içindeki alt iletiler) için kullanılır. Ekli mesajın nasıl teslim edileceğini belirtir.\nKRİTİK UYARI: Bu belirtim YALNIZCA Garlic Cloves (garlic mesajındaki \u0026lsquo;clove\u0026rsquo; bileşenleri) içindeki Delivery Instructions (teslimat talimatları) için geçerlidir. \u0026ldquo;Delivery Instructions\u0026rdquo; ayrıca Tunnel Messages (tunnel mesajları) içinde de kullanılır; oradaki biçim önemli ölçüde farklıdır. tunnel teslimat talimatları için Tunnel Message Specification belgesine bakın. Bu iki biçimi ASLA karıştırmayın.\nBiçim:\nOturum anahtarı ve gecikme kullanılmaz ve hiçbir zaman mevcut değildir, bu nedenle üç olası uzunluk şunlardır: - 1 bayt (LOCAL) - 33 bayt (ROUTER ve DESTINATION) - 37 bayt (TUNNEL)\n+----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds Tipik Uzunluklar: - Yerel teslimi: 1 bayt (yalnızca bayrak) - ROUTER / HEDEF teslimi: 33 bayt (bayrak + karma) - TUNNEL teslimi: 37 bayt (bayrak + karma + tunnel ID)\nTeslimat Türü Açıklamaları:\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router **Uygulama Notları:** - Oturum anahtarı şifrelemesi uygulanmamıştır ve bayrak biti her zaman 0 - Gecikme tam olarak uygulanmamıştır ve bayrak biti her zaman 0 - TUNNEL tesliminde, hash ağ geçidi router'ını belirtir ve tunnel ID, hangi gelen tunnel olduğunu belirtir - DESTINATION tesliminde, hash Destination (I2P adresi) açık anahtarının SHA-256'sıdır - ROUTER tesliminde, hash router kimliğinin SHA-256'sıdır I2NP Mesajları Tüm I2NP mesaj türleri için eksiksiz mesaj spesifikasyonları.\nMesaj Türü Özeti Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active **Ayrılmış:** - Tür 0: Ayrılmış - Türler 4-9: Gelecekte kullanım için ayrılmış - Türler 12-17: Gelecekte kullanım için ayrılmış - Türler 224-254: Deneysel mesajlar için ayrılmış - Tür 255: Gelecekteki genişletme için ayrılmış DatabaseStore (Tip 1) Amaç: Talep edilmemiş bir veritabanı depolaması veya başarılı bir DatabaseLookup mesajına verilen yanıt.\nİçerik: Sıkıştırılmamış bir LeaseSet (tunnel erişim bilgileri kümesi), LeaseSet2, MetaLeaseSet veya EncryptedLeaseSet ya da sıkıştırılmış bir RouterInfo (router bilgisi).\nYanıt belirteci içeren biçim:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet Yanıt belirteci == 0 iken biçim:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// Kaynak kodu: - net.i2p.data.i2np.DatabaseStoreMessage - net.i2p.data.RouterInfo (RouterInfo yapısı için) - net.i2p.data.LeaseSet (LeaseSet yapısı için)\nDatabaseLookup (Tip 2) Amaç: Ağ veritabanında bir öğeyi sorgulama isteği. Yanıt, DatabaseStore veya DatabaseSearchReply olur.\nBiçim:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) Yanıt Şifreleme Modları:\nNot: API 0.9.58 itibarıyla ElGamal routers kullanımdan kaldırılmıştır. Artık sorgulanması önerilen asgari floodfill sürümü 0.9.58 olduğundan, gerçekleştirimlerin ElGamal floodfill router\u0026rsquo;lar için şifreleme uygulanmasına gerek yoktur. ElGamal hedefleri hâlâ desteklenmektedir.\nBayrak biti 4 (ECIESFlag), yanıt şifreleme modunu belirlemek için bit 1 (encryptionFlag) ile birlikte kullanılır:\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future **Şifreleme Yok (bayraklar 0,0):** reply_key, tags ve reply_tags mevcut değil.\nElG\u0026rsquo;den ElG\u0026rsquo;ye (bayraklar 0,1) - KULLANIMDAN KALDIRILDI:\n0.9.7 sürümünden itibaren desteklenmektedir, 0.9.58 sürümünden itibaren kullanımdan kaldırılmıştır.\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES\u0026rsquo;den ElG\u0026rsquo;ye (bayraklar 1,0) - KULLANIMDAN KALDIRILDI:\n0.9.46 itibarıyla desteklenmektedir, 0.9.58 itibarıyla kullanımdan kaldırılmıştır.\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data Yanıt, ECIES Spesifikasyonu \u0026rsquo;nda tanımlandığı üzere bir ECIES Existing Session (mevcut oturum) mesajıdır:\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES\u0026rsquo;den ECIES\u0026rsquo;e (bayraklar 1,0) - MEVCUT STANDART:\nECIES hedefi veya router, bir ECIES router\u0026rsquo;a bir sorgu gönderir. 0.9.49 sürümünden itibaren desteklenir.\nYukarıdaki \u0026ldquo;ECIES to ElG\u0026rdquo; ile aynı biçimdedir. Sorgu mesajı şifrelemesi ECIES Routers içinde tanımlanmıştır. İstekte bulunan anonimdir.\nECIES\u0026rsquo;den DH ile ECIES\u0026rsquo;e (bayraklar 1,1) - GELECEK:\nHenüz tam olarak tanımlanmadı. Bkz. Proposal 156 .\nNotlar: - 0.9.16\u0026rsquo;dan önce, anahtar bir RouterInfo veya LeaseSet için olabilirdi (aynı anahtar alanı, ayırt etmek için bayrak yok) - Şifrelenmiş yanıtlar yalnızca yanıt bir tunnel üzerinden iletildiğinde yararlıdır - Alternatif DHT (Distributed Hash Table - Dağıtılmış Karma Tablosu) arama stratejileri uygulanırsa, dahil edilen etiketlerin sayısı birden fazla olabilir - Arama anahtarı ve hariç tutma anahtarları \u0026ldquo;gerçek\u0026rdquo; karmalardır, yönlendirme anahtarları DEĞİLDİR - 3, 5 ve 7 türleri (LeaseSet2 varyantları) 0.9.38 itibarıyla döndürülebilir. Bkz. Proposal 123 - Keşif araması notları: Bir keşif araması, anahtara yakın floodfill olmayan karmaların bir listesini döndürecek şekilde tanımlanır. Ancak uygulamalar farklılık gösterir: Java, bir RI (RouterInfo) için arama anahtarını gerçekten sorgular ve mevcutsa bir DatabaseStore döndürür; i2pd bunu yapmaz. Bu nedenle, daha önce alınmış karmalar için keşif araması kullanılması önerilmez\nKaynak kodu: - net.i2p.data.i2np.DatabaseLookupMessage - Şifreleme: net.i2p.crypto.SessionKeyManager\nDatabaseSearchReply (veritabanı arama yanıtı) (Type 3) Amaç: Başarısız bir DatabaseLookup (veritabanı arama) mesajına verilen yanıt.\nİçerik: İstenen anahtara en yakın router hash\u0026rsquo;lerinin listesi.\nBiçim:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from Notlar: - \u0026lsquo;from\u0026rsquo; karması kimlik doğrulanmamıştır ve güvenilemez - Döndürülen eş karmalarının, sorgulanan router’a kıyasla anahtara daha yakın olması şart değildir. Normal aramalara verilen yanıtlarda bu, yeni floodfill’lerin keşfini ve sağlamlık için (anahtardan daha uzak) \u0026ldquo;ters yönde\u0026rdquo; aramayı kolaylaştırır - Keşif aramalarında anahtar genellikle rastgele oluşturulur. Yanıtın floodfill olmayan peer_hashes değerleri, tüm yerel veritabanının verimsiz sıralanmasından kaçınmak için optimize edilmiş bir algoritma kullanılarak (örn. yakın ama mutlaka en yakın olmayan eşler) seçilebilir. Önbelleğe alma stratejileri de kullanılabilir. Bu, uygulamaya bağlıdır - Döndürülen karma sayısının tipik değeri: 3 - Önerilen en fazla döndürülecek karma sayısı: 16 - Arama anahtarı, eş karmaları ve \u0026lsquo;from\u0026rsquo; karması \u0026ldquo;gerçek\u0026rdquo; karmalardır, YÖNLENDİRME ANAHTARLARI DEĞİLDİR - num 0 ise, bu daha yakın eş bulunamadığını gösterir (çıkmaz)\nKaynak kodu: - net.i2p.data.i2np.DatabaseSearchReplyMessage\nDeliveryStatus (Tür 10) Amacı: Basit bir mesaj alındı onayı. Genellikle mesajın göndericisi tarafından oluşturulur ve mesajın kendisiyle birlikte Garlic Message (I2P’de birden fazla alt mesajı tek bir kapsülde taşıyan yapı) içinde paketlenir; hedef tarafından geri gönderilmek üzere.\nİçerik: İletilen mesajın kimliği ve oluşturulma veya varış zamanı.\nBiçim:\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered Notlar: - Zaman damgası her zaman oluşturan tarafından mevcut zamana ayarlanır. Ancak bunun koddaki birkaç kullanım alanı vardır ve gelecekte daha fazlası eklenebilir - Bu ileti, SSU içinde bir oturum kurulumu onayı olarak da kullanılır. Bu durumda, ileti kimliği rastgele bir sayıya ayarlanır ve \u0026ldquo;varış zamanı\u0026rdquo; geçerli ağ genelindeki kimliğe ayarlanır; bu değer 2’dir (yani, 0x0000000000000002) - DeliveryStatus (teslim durumu mesajı) genellikle bir GarlicMessage (I2P’de özel bir mesaj türü) içine sarılır ve göndereni açığa çıkarmadan alındı onayı sağlamak için bir tunnel üzerinden gönderilir - Gecikmeyi ve güvenilirliği ölçmek için tunnel testlerinde kullanılır\nKaynak kodu: - net.i2p.data.i2np.DeliveryStatusMessage - Kullanıldığı yer: net.i2p.router.tunnel.InboundEndpointProcessor tunnel testi için\nGarlicMessage (Sarımsak Mesajı) (Tür 11) UYARI: Bu, ElGamal ile şifrelenmiş garlic messages (I2P\u0026rsquo;de birden çok mesajı tek bir pakette birleştiren yapı) için kullanılan biçimdir. ECIES-AEAD-X25519-Ratchet garlic messages için kullanılan biçim önemli ölçüde farklıdır. Güncel biçim için ECIES Spesifikasyonu sayfasına bakın.\nAmaç: Birden çok şifrelenmiş I2NP mesajını sarmak için kullanılır.\nİçerik: Şifresi çözüldüğünde, Garlic Cloves (I2P’deki tekil alt-iletiler) ve ek veriden oluşan bir dizi; Clove Set (Garlic Cloves dizisi) olarak da bilinir.\nŞifrelenmiş Format:\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data Şifresi Çözülmüş Veri (Clove Set - clove kümesi):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) Notlar: - Şifrelenmediğinde, veri bir veya daha fazla Garlic Clove (I2P’deki garlic mesajının alt birimi) içerir - AES ile şifrelenmiş blok en az 128 bayta doldurulur; 32 baytlık oturum etiketi ile şifreli mesajın asgari boyutu 160 bayttır; 4 baytlık uzunluk alanıyla Garlic Message (birden çok Garlic Clove içeren üst mesaj) için asgari boyut 164 bayttır - Gerçek maksimum uzunluk 64 KB\u0026rsquo;den küçüktür (tunnel mesajları için pratik sınır yaklaşık 61.2 KB) - Şifreleme ayrıntıları için ElGamal/AES Şartnamesi bölümüne bakın - Kavramsal genel bakış için Garlic Routing bölümüne bakın - AES ile şifrelenmiş bloğun 128 baytlık asgari boyutu şu anda yapılandırılamaz - Mesaj kimliği genellikle gönderimde rastgele bir sayıya ayarlanır ve alımda yok sayılıyor görünür - Sertifika, yönlendirme için \u0026ldquo;ödeme\u0026rdquo; yapmak üzere HashCash ile kullanılabilir (gelecekteki olasılık) - ElGamal şifreleme yapısı: 32 baytlık oturum etiketi + ElGamal ile şifrelenmiş oturum anahtarı + AES ile şifrelenmiş yük\nECIES-X25519-AEAD-Ratchet formatı için (router\u0026rsquo;lar için mevcut standart):\nBkz. ECIES Specification ve Proposal 144 .\nKaynak kodu: - net.i2p.data.i2np.GarlicMessage - Şifreleme: net.i2p.crypto.elgamal.ElGamalAESEngine (kullanımdan kaldırılmış) - Modern şifreleme: net.i2p.crypto.ECIES paketleri\nTunnelData (Tür 18) Purpose: Bir tunnel ağ geçidinden veya katılımcısından sonraki katılımcıya ya da uç noktaya gönderilen bir ileti. Veri sabit uzunluktadır; parçalanmış, toplulaştırılmış, dolgu eklenmiş ve şifrelenmiş I2NP iletilerini içerir.\nBiçim:\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes Yük Yapısı (1024 bayt):\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) Notlar: - TunnelData için I2NP mesaj kimliği her atlamada yeni bir rastgele sayıya atanır - tunnel mesaj biçimi (şifrelenmiş verinin içinde) Tünel Mesajı Spesifikasyonu içinde belirtilmiştir - Her atlama, AES-256 ile CBC modunda bir katmanı çözer - IV (ilklendirme vektörü), her atlamada çözülen veri kullanılarak güncellenir - Toplam boyut tam olarak 1.028 bayttır (4 tunnelId + 1024 veri) - Bu, tunnel trafiğinin temel birimidir - TunnelData mesajları, parçalanmış I2NP mesajlarını taşır (GarlicMessage, DatabaseStore vb.)\nKaynak kodu: - net.i2p.data.i2np.TunnelDataMessage - Sabit: TunnelDataMessage.DATA_LENGTH = 1024 - İşleyen: net.i2p.router.tunnel.InboundGatewayProcessor\nTunnelGateway (Tünel Geçidi) (Tür 19) Amaç: Başka bir I2NP mesajını, tunnel\u0026rsquo;in gelen ağ geçidinde tunnel içine iletilmek üzere paketler.\nBiçim:\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message Notlar: - Yük, standart 16 baytlık başlığa sahip bir I2NP mesajıdır - Yerel router\u0026rsquo;dan tunnel\u0026rsquo;lere mesaj enjekte etmek için kullanılır - Gerekirse ağ geçidi, içerideki mesajı parçalara böler - Parçalama sonrasında, parçalar TunnelData mesajlarının içine sarılır - TunnelGateway hiçbir zaman ağ üzerinden gönderilmez; tunnel işlemeye başlamadan önce kullanılan dahili bir mesaj türüdür\nKaynak kodu: - net.i2p.data.i2np.TunnelGatewayMessage - İşleme: net.i2p.router.tunnel.OutboundGatewayProcessor\nDataMessage (Tür 20) Amaç: Her tür veriyi sarmalamak için Garlic Messages (I2P\u0026rsquo;de Garlic mesaj formatı) ve Garlic Cloves (Garlic mesajı içindeki \u0026lsquo;clove/diş\u0026rsquo; alt birimleri) tarafından kullanılır (genellikle uçtan uca şifrelenmiş uygulama verisi).\nBiçim:\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message Notlar: - Bu mesaj herhangi bir yönlendirme bilgisi içermez ve asla \u0026ldquo;unwrapped\u0026rdquo; olarak gönderilmez - Yalnızca Garlic messages (Garlic mesajları) içinde kullanılır - Genellikle uçtan uca şifrelenmiş uygulama verisi içerir (HTTP, IRC, e-posta vb.) - Veri genellikle ElGamal/AES ya da ECIES ile şifrelenmiş bir yükten oluşur - tunnel mesajı parçalanma sınırları nedeniyle pratikteki azami uzunluk yaklaşık 61.2 KB\u0026rsquo;dir\nKaynak kodu: - net.i2p.data.i2np.DataMessage\nTunnelBuild (Tür 21) KULLANIMDAN KALDIRILDI. VariableTunnelBuild (tip 23) veya ShortTunnelBuild (tip 25) kullanın.\nAmaç: Sabit uzunlukta, 8 atlamalı tunnel oluşturma isteği.\nBiçim:\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes Notlar: - 0.9.48 itibarıyla, ECIES-X25519 BuildRequestRecords (yapı istek kayıtları) içerebilir. Bkz. ECIES Tunnel Creation - Ayrıntılar için bkz. Tunnel Oluşturma Spesifikasyonu - Bu ileti için I2NP ileti kimliği, Tunnel Oluşturma Spesifikasyonu\u0026rsquo;na göre ayarlanmalıdır - Günümüz ağında nadiren görülse de (VariableTunnelBuild (değişken tunnel oluşturma) ile değiştirildi), çok uzun tunnel\u0026rsquo;lar için hâlâ kullanılabilir ve resmen kullanımdan kaldırılmamıştır - Router\u0026rsquo;lar uyumluluk için bunu hâlâ uygulamak zorundadır - Sabit 8 kayıtlı biçim esnek değildir ve daha kısa tunnel\u0026rsquo;lar için bant genişliğini israf eder\nKaynak kodu: - net.i2p.data.i2np.TunnelBuildMessage - Sabit: TunnelBuildMessageBase.MAX_RECORD_COUNT = 8\nTunnelBuildReply (Tip 22) KULLANIMDAN KALDIRILDI. VariableTunnelBuildReply (tip 24) veya OutboundTunnelBuildReply (tip 26) kullanın.\nAmaç: 8 atlamalı sabit uzunluklu tunnel oluşturma yanıtı.\nBiçim:\nTunnelBuildMessage ile aynı biçimdedir; BuildRequestRecords yerine BuildResponseRecords içerir.\nTotal size: 8 × 528 = 4,224 bytes Notlar: - 0.9.48 itibarıyla, ECIES-X25519 BuildResponseRecords (oluşturma yanıt kayıtları) içerebilir. Bkz. ECIES Tunnel Oluşturma - Ayrıntılar için Tunnel Oluşturma Belirtimi - Bu mesaj için I2NP mesaj kimliği, tunnel oluşturma belirtimine göre ayarlanmalıdır - Günümüz ağında nadiren görülse de (VariableTunnelBuildReply (değişken tunnel oluşturma yanıtı) ile değiştirildi), çok uzun tunnel\u0026rsquo;lar için hâlâ kullanılabilir ve resmen kullanımdan kaldırılmamıştır - Router\u0026rsquo;lar yine de uyumluluk için bunu uygulamak zorundadır\nKaynak kodu: - net.i2p.data.i2np.TunnelBuildReplyMessage\nVariableTunnelBuild (Tür 23) Amaç: 1-8 atlama için değişken uzunluklu tunnel oluşturma. Hem ElGamal hem de ECIES-X25519 router\u0026rsquo;ları destekler.\nBiçim:\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Notlar: - 0.9.48 itibarıyla, ECIES-X25519 BuildRequestRecords (inşa isteği kayıtları) içerebilir. Bkz. ECIES Tunnel Creation - router sürüm 0.7.12’de (2009) tanıtıldı - 0.7.12 sürümünden önceki tunnel katılımcılarına gönderilmemelidir - Ayrıntılar için bkz. Tunnel Creation Specification - I2NP mesaj kimliği, tunnel oluşturma teknik şartnamesine göre ayarlanmalıdır - Tipik kayıt sayısı: 4 (4 atlamalı bir tunnel için) - Tipik toplam boyut: 1 + (4 × 528) = 2,113 bayt - Bu, ElGamal routers için standart tunnel oluşturma mesajıdır - Bunun yerine ECIES routers genellikle ShortTunnelBuild (tip 25) kullanır\nKaynak kodu: - net.i2p.data.i2np.VariableTunnelBuildMessage\nVariableTunnelBuildReply (Tür 24) Amaç: 1-8 atlama için değişken uzunluklu tunnel kurulum yanıtı. Hem ElGamal hem de ECIES-X25519 router\u0026rsquo;ları destekler.\nBiçim:\nVariableTunnelBuildMessage (değişken tunnel oluşturma mesajı) ile aynı biçimdedir; ancak BuildRequestRecords yerine BuildResponseRecords içerir.\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Notlar: - 0.9.48 itibarıyla, ECIES-X25519 BuildResponseRecords içerebilir. Bkz. ECIES Tunnel Oluşturma - router sürüm 0.7.12\u0026rsquo;de (2009) tanıtıldı - 0.7.12 sürümünden önceki tunnel katılımcılarına gönderilmeyebilir - Ayrıntılar için Tunnel Oluşturma Spesifikasyonu bölümüne bakın - I2NP ileti kimliği, Tunnel oluşturma spesifikasyonuna uygun olarak ayarlanmalıdır - Tipik kayıt sayısı: 4 - Tipik toplam boyut: 2,113 bayt\nKaynak kodu: - net.i2p.data.i2np.VariableTunnelBuildReplyMessage\nShortTunnelBuild (Tür 25) Amaç: Yalnızca ECIES-X25519 routers için kısa tunnel oluşturma iletileri. API sürümü 0.9.51\u0026rsquo;de tanıtıldı (sürüm 1.5.0, Ağustos 2021). Bu, ECIES tunnel oluşturma işlemleri için mevcut standarttır.\nBiçim:\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Notlar: - router sürüm 0.9.51\u0026rsquo;de tanıtıldı (sürüm 1.5.0, Ağustos 2021) - API sürümü 0.9.51\u0026rsquo;den daha eski olan tunnel katılımcılarına gönderilmeyebilir - Tam belirtim için ECIES Tunnel Creation bölümüne bakın - Gerekçesi için Proposal 157 belgesine bakın - Tipik kayıt sayısı: 4 - Tipik toplam boyut: 1 + (4 × 218) = 873 bayt - Bant genişliği tasarrufu: VariableTunnelBuild\u0026rsquo;e göre 59% daha küçük (873\u0026rsquo;e karşı 2,113 bayt) - Performans kazancı: 4 kısa kayıt tek bir tunnel mesajına sığar; VariableTunnelBuild 3 tunnel mesajı gerektirir - Bu, artık saf ECIES-X25519 tunnel\u0026rsquo;ları için standart tunnel oluşturma biçimidir - Kayıtlar, anahtarları açıkça dahil etmek yerine HKDF (HMAC tabanlı anahtar türetme işlevi) aracılığıyla türetir\nKaynak kodu: - net.i2p.data.i2np.ShortTunnelBuildMessage - Sabit: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nOutboundTunnelBuildReply (Tür 26) Amaç: Yeni bir tunnel üzerindeki giden uç noktadan başlatıcıya gönderilir. Yalnızca ECIES-X25519 routers için. API sürüm 0.9.51\u0026rsquo;de tanıtıldı (sürüm 1.5.0, Ağustos 2021).\nBiçim:\nShortTunnelBuildMessage ile aynı biçimdedir; ShortBuildRequestRecords yerine ShortBuildResponseRecords kullanır.\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Notlar: - router 0.9.51 sürümünde tanıtıldı (sürüm 1.5.0, Ağustos 2021) - Tam belirtim için ECIES Tunnel Oluşturma bölümüne bakın - Tipik kayıt sayısı: 4 - Tipik toplam boyut: 873 bayt - Bu yanıt, yeni oluşturulan outbound tunnel üzerinden outbound uç nokta (OBEP) tarafından tunnel oluşturucusuna geri gönderilir - Tüm hop (atlama) noktalarının tunnel kurulumunu kabul ettiğini doğrular\nKaynak kodu: - net.i2p.data.i2np.OutboundTunnelBuildReplyMessage\nKaynaklar Resmi Spesifikasyonlar I2NP Belirtimi - Eksiksiz I2NP ileti biçimi belirtimi Ortak Yapılar - I2P genelinde kullanılan veri türleri ve yapılar Tunnel Oluşturma - ElGamal tunnel oluşturma (kullanımdan kaldırıldı) ECIES Tunnel Oluşturma - ECIES-X25519 tunnel oluşturma (güncel) Tunnel İletisi - Tunnel ileti biçimi ve teslim yönergeleri NTCP2 Belirtimi - TCP taşıma protokolü SSU2 Belirtimi - UDP taşıma protokolü ECIES Belirtimi - ECIES-X25519-AEAD-Ratchet şifreleme (ratchet: kademeli anahtar yenileme mekanizması) Kriptografi Belirtimi - Düşük seviyeli kriptografik ilkeller I2CP Belirtimi - İstemci protokolü belirtimi Datagram Belirtimi - Datagram2 ve Datagram3 biçimleri Öneriler Teklif 123 - Yeni netDB kayıtları (LeaseSet2, EncryptedLeaseSet, MetaLeaseSet) Teklif 144 - ECIES-X25519-AEAD-Ratchet şifreleme Teklif 154 - Şifreli veritabanı araması Teklif 156 - ECIES routers Teklif 157 - Daha küçük tunnel oluşturma iletileri (kısa biçim) Teklif 159 - SSU2 taşıma Teklif 161 - Sıkıştırılabilir dolgu Teklif 163 - Datagram2 ve Datagram3 Teklif 167 - LeaseSet hizmet kaydı parametreleri Teklif 168 - Tunnel oluşturma bant genişliği parametreleri Teklif 169 - Post-kuantum hibrit kriptografi Dokümantasyon Garlic Routing - Katmanlı mesaj demetleme ElGamal/AES - Kullanımdan kaldırılmış şifreleme şeması Tunnel Uygulaması - Parçalama ve işleme Ağ Veritabanı - Dağıtık hash tablosu NTCP2 Taşıma - TCP taşıma belirtimi SSU2 Taşıma - UDP taşıma belirtimi Teknik Giriş - I2P mimarisine genel bakış Kaynak kodu Java I2P Deposu - Resmî Java gerçekleştirmesi GitHub Yansısı - Java I2P\u0026rsquo;nin GitHub yansısı i2pd Deposu - C++ gerçekleştirmesi Önemli Kaynak Kod Konumları Java I2P (i2pgit.org/I2P_Developers/i2p.i2p): - core/java/src/net/i2p/data/i2np/ - I2NP mesaj gerçeklemeleri - core/java/src/net/i2p/crypto/ - Kriptografik gerçeklemeler - router/java/src/net/i2p/router/tunnel/ - Tunnel işlemesi - router/java/src/net/i2p/router/transport/ - Taşıma gerçeklemeleri\nSabitler ve Değerler: - I2NPMessage.MAX_SIZE = 65536 - Maksimum I2NP mesaj boyutu - I2NPMessageImpl.HEADER_LENGTH = 16 - Standart başlık boyutu - TunnelDataMessage.DATA_LENGTH = 1024 - Tunnel mesaj yükü - EncryptedBuildRecord.RECORD_SIZE = 528 - Uzun oluşturma kaydı - ShortEncryptedBuildRecord.RECORD_SIZE = 218 - Kısa oluşturma kaydı - TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - Bir oluşturma başına maksimum kayıt sayısı\nEk A: Ağ İstatistikleri ve Mevcut Durum Ağ Bileşimi (Ekim 2025 itibarıyla) Toplam routers: Yaklaşık 60,000-70,000 (değişir) Floodfill routers: Yaklaşık 500-700 aktif Şifreleme türleri: ECIES-X25519: routers arasında \u0026gt;95% ElGamal: routers arasında \u0026lt;5% (kullanımdan kaldırıldı, yalnızca eski) Taşıma protokollerinin benimsenmesi: SSU2: \u0026gt;60% birincil taşıma NTCP2: ~40% birincil taşıma Eski taşıma protokolleri (SSU1, NTCP): 0% (kaldırıldı) İmza türleri: EdDSA (Ed25519): Büyük çoğunluk ECDSA: Küçük bir yüzde RSA: İzin verilmiyor (kaldırıldı) Asgari Router Gereksinimleri API sürümü: 0.9.16+ (ağ ile EdDSA uyumluluğu için) Önerilen en düşük: API 0.9.51+ (ECIES kısa tunnel derlemeleri) floodfills için mevcut en düşük: API 0.9.58+ (ElGamal router\u0026rsquo;ın kullanımdan kaldırılması) Yaklaşan gereksinim: Java 17+ (sürüm 2.11.0 itibarıyla, Aralık 2025) Bant Genişliği Gereksinimleri Asgari: 128 KBytes/sn (N bayrağı veya üzeri) floodfill (I2P ağında netDb verisini tutup dağıtan özel düğüm) için Önerilen: 256 KBytes/sn (O bayrağı) veya üzeri Floodfill gereksinimleri: Asgari 128 KB/sn bant genişliği Kararlı çalışma süresi (\u0026gt; %95 önerilir) Düşük gecikme (eşlere \u0026lt;500 ms) Sağlık testlerini geçmek (kuyruk süresi, iş gecikmesi) Tunnel İstatistikleri Tipik tunnel uzunluğu: 3-4 atlama Maksimum tunnel uzunluğu: 8 atlama (teorik, nadiren kullanılır) Tipik tunnel ömrü: 10 dakika Tunnel oluşturma başarı oranı: iyi bağlantılı routers için \u0026gt;85% Tunnel oluşturma mesaj biçimi: ECIES routers: ShortTunnelBuild (218 baytlık kayıtlar) Karma tunnels: VariableTunnelBuild (528 baytlık kayıtlar) Performans Metrikleri Tunnel oluşturma süresi: 1-3 saniye (tipik) Uçtan uca gecikme: 0,5-2 saniye (tipik, toplam 6-8 atlama) Aktarım hızı: tunnel bant genişliği ile sınırlıdır (genellikle tunnel başına 10-50 KB/sn) Maksimum datagram boyutu: 10 KB önerilir (61,2 KB teorik maksimum) Ek B: Artık Önerilmeyen ve Kaldırılmış Özellikler Tamamen Kaldırıldı (Artık Desteklenmiyor) NTCP aktarımı - 0.9.50 sürümünde kaldırıldı (Mayıs 2021) SSU v1 aktarımı - Java I2P\u0026rsquo;den 2.4.0 sürümünde kaldırıldı (Aralık 2023) SSU v1 aktarımı - i2pd\u0026rsquo;den 2.44.0 sürümünde kaldırıldı (Kasım 2022) RSA imza türleri - API 0.9.28 itibarıyla yasaklandı Kullanımdan kaldırıldı (Destekleniyor ancak önerilmez) ElGamal router\u0026rsquo;lar - API 0.9.58 (Mart 2023) itibarıyla kullanımdan kaldırıldı ElGamal hedefler geriye dönük uyumluluk için hâlâ desteklenmektedir Yeni router\u0026rsquo;lar yalnızca ECIES-X25519 kullanmalıdır TunnelBuild (type 21) - VariableTunnelBuild ve ShortTunnelBuild lehine kullanımdan kaldırıldı Çok uzun tunnel\u0026rsquo;lar (\u0026gt;8 atlama) için hâlâ uygulanmaktadır TunnelBuildReply (type 22) - VariableTunnelBuildReply ve OutboundTunnelBuildReply lehine kullanımdan kaldırıldı ElGamal/AES şifrelemesi - ECIES-X25519-AEAD-Ratchet lehine kullanımdan kaldırıldı Eski hedefler için hâlâ kullanılmaktadır Uzun ECIES BuildRequestRecords (528 bayt) - Kısa biçimin (218 bayt) lehine kullanımdan kaldırıldı ElGamal atlamaları içeren karışık tunnel\u0026rsquo;larda hâlâ kullanılmaktadır Eski Sürüm Desteği Zaman Çizelgesi Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels --- Ek C: Gelecekteki Gelişmeler Kuantum Sonrası Kriptografi Durum: 2.10.0 sürümüyle birlikte (Eylül 2025) Beta, 2.11.0 sürümünde (Aralık 2025) varsayılan olacak\nUygulama: - Klasik X25519 ve post-quantum (kuantum-sonrası) MLKEM (ML-KEM-768) birleştiren hibrit yaklaşım - Mevcut ECIES-X25519 altyapısıyla geriye dönük uyumlu - Hem klasik hem de PQ anahtar materyali ile Signal Double Ratchet (çift mandal anahtar yenileme algoritması) kullanır - Ayrıntılar için Proposal 169 sayfasına bakın\nGeçiş Yolu: 1. Sürüm 2.10.0 (Eylül 2025): beta seçeneği olarak sunulacak 2. Sürüm 2.11.0 (Aralık 2025): varsayılan olarak etkinleştirilecek 3. Gelecek sürümler: Zamanla zorunlu hale gelecek\nPlanlanan Özellikler IPv6 iyileştirmeleri - Daha iyi IPv6 desteği ve geçiş mekanizmaları Tunnel başına bant daraltma - Her tunnel için ince ayarlı bant genişliği kontrolü Geliştirilmiş metrikler - Daha iyi performans izleme ve tanılama Protokol iyileştirmeleri - Daha az ek yük ve daha yüksek verimlilik Geliştirilmiş floodfill seçimi - Daha iyi ağ veritabanı dağıtımı Araştırma Alanları Tunnel uzunluğu optimizasyonu - Tehdit modeline göre dinamik tunnel uzunluğu Gelişmiş padding (dolgu) - Trafik analizine karşı dirençte iyileştirmeler Yeni şifreleme şemaları - Kuantum hesaplama tehditlerine hazırlık Tıkanıklık kontrolü - Ağ yükünün daha iyi yönetimi Mobil destek - Mobil cihazlar ve ağlar için optimizasyonlar Ek D: Uygulama Yönergeleri Yeni Gerçeklemeler İçin Asgari Gereksinimler: 1. API sürümü 0.9.51+ özelliklerini destekleyin 2. ECIES-X25519-AEAD-Ratchet şifrelemesini uygulayın 3. NTCP2 ve SSU2 taşıma protokollerini destekleyin 4. ShortTunnelBuild mesajlarını (218 baytlık kayıtlar) uygulayın 5. LeaseSet2 varyantlarını destekleyin (türleri 3, 5, 7) 6. EdDSA imzalarını kullanın (Ed25519)\nÖnerilen: 1. Post-kuantum hibrit kriptografiyi destekleyin (2.11.0 itibarıyla) 2. tunnel başına bant genişliği parametrelerini uygulayın 3. Datagram2 ve Datagram3 formatlarını destekleyin 4. LeaseSets içinde hizmet kaydı seçeneklerini uygulayın 5. /docs/specs/ adresindeki resmi spesifikasyonlara uyun\nGerekli Değil: 1. ElGamal router desteği (kullanımdan kaldırıldı) 2. Eski taşıma desteği (SSU1, NTCP) 3. Uzun ECIES BuildRequestRecords (İnşa İstek Kayıtları; yalnızca ECIES tunnels için 528 bayt) 4. TunnelBuild/TunnelBuildReply mesajları (Variable veya Short varyantlarını kullanın)\nTest ve Doğrulama Protokol Uyumluluğu: 1. Resmi Java I2P router ile birlikte çalışabilirliği test edin 2. i2pd C++ router ile birlikte çalışabilirliği test edin 3. İleti biçimlerinin belirtimlere uygunluğunu doğrulayın 4. tunnel oluşturma/sökme döngülerini test edin 5. Test vektörleriyle şifreleme/şifre çözmeyi doğrulayın\nPerformans Testi: 1. tunnel oluşturma başarı oranlarını ölçün (\u0026gt;85% olmalı) 2. çeşitli tunnel uzunluklarıyla test edin (2-8 atlama) 3. parçalama ve yeniden birleştirmeyi doğrulayın 4. yük altında test edin (eşzamanlı birden çok tunnel) 5. uçtan uca gecikmeyi ölçün\nGüvenlik Testleri: 1. Şifreleme uygulamasını doğrulayın (test vektörlerini kullanın) 2. Yeniden oynatma saldırısının (replay attack) önlenmesini test edin 3. Mesajın zaman aşımı yönetimini doğrulayın 4. Hatalı biçimlendirilmiş mesajlara karşı test edin 5. Doğru rastgele sayı üretimini doğrulayın\nSık Yapılan İmplementasyon Hataları Kafa karıştırıcı teslim talimatı biçimleri - garlic clove (I2P\u0026rsquo;de tekil \u0026lsquo;garlic\u0026rsquo; alt-ileti) vs tunnel iletisi Hatalı anahtar türetimi - kısa build records (inşa kayıtları) için HKDF kullanımı Message ID yönetimi - tunnel kurulumları için doğru şekilde ayarlanmaması Parçalama sorunları - 61.2 KB\u0026rsquo;lik pratik sınıra uyulmaması Bayt sıralaması (endianness) hataları - Java tüm tamsayılar için big-endian kullanır Sona erme yönetimi - Kısa biçim 7 Şubat 2106\u0026rsquo;da sarar Checksum (sağlama toplamı) üretimi - Doğrulanmasa bile hâlâ gereklidir ","description":"Router'lar arası mesaj biçimleri, öncelikler ve I2P içindeki boyut sınırları.","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"I2P Ağ Protokolü (I2NP)","url":"/tr/docs/specs/i2np/"},{"categories":null,"content":"Amaç: I2P teknik dokümantasyonu genelinde tutarlılığı, doğruluğu ve erişilebilirliği sürdürmek\nTemel İlkeler 1. Her Şeyi Doğrulayın Asla varsaymayın veya tahmin etmeyin. Tüm teknik ifadeler şu kaynaklara göre doğrulanmalıdır: - Güncel I2P kaynak kodu (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master ) - Resmi API belgeleri (https://i2p.github.io/i2p.i2p/ - Yapılandırma teknik özellikleri /docs/specs/ - Son sürüm notları /releases/ Uygun doğrulama örneği:\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. Kısalıktan ziyade açıklık I2P ile ilk kez karşılaşabilecek geliştiricileri hedef alarak yazın. Önceden bilgi varsaymak yerine kavramları kapsamlı biçimde açıklayın.\nÖrnek:\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. Önce Erişilebilirlik I2P bir bindirme ağı olmasına rağmen, dokümantasyonun geliştiriciler tarafından clearnet’te (normal internet) erişilebilir olması gerekir. I2P içi kaynaklar için her zaman clearnet üzerinden erişilebilir alternatifler sağlayın.\nTeknik Doğruluk API ve Arayüz Dokümantasyonu Her zaman şunları dahil edin: 1. İlk anılışında tam paket adları: net.i2p.app.ClientApp 2. Dönüş türlerini içeren eksiksiz metot imzaları 3. Parametre adları ve türleri 4. Zorunlu ve isteğe bağlı parametreler\nÖrnek:\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. Yapılandırma Özellikleri Yapılandırma dosyalarını belgelendirirken: 1. Tam özellik adlarını gösterin 2. Dosya kodlamasını belirtin (I2P yapılandırmaları için UTF-8) 3. Eksiksiz örnekler sağlayın 4. Varsayılan değerleri belgeleyin 5. Özelliklerin eklendiği/değiştirildiği sürümü belirtin\nÖrnek:\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) Sabitler ve Numaralandırmalar Sabitleri belgelerken asıl kod adlarını kullanın:\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; Benzer Kavramları Birbirinden Ayırt Et I2P\u0026rsquo;nin birbiriyle örtüşen birkaç sistemi vardır. Hangi sistemi belgelendirdiğinizi her zaman netleştirin:\nÖrnek:\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations Dokümantasyon URL\u0026rsquo;leri ve Kaynaklar URL Erişilebilirlik Kuralları Birincil referanslar clearnet (açık internet) üzerinden erişilebilir URL\u0026rsquo;ler kullanmalıdır I2P içi URL\u0026rsquo;ler (.i2p alan adları) erişilebilirlik notlarını içermelidir Her zaman alternatifler sağlayın I2P içi kaynaklara bağlantı verirken I2P dahili URL\u0026rsquo;ler için şablon:\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ Önerilen I2P Referans URL\u0026rsquo;leri Resmi spesifikasyonlar: - Yapılandırma - Eklenti - Belge Dizini API dokümantasyonu (en güncel olanı seçin): - En güncel: https://i2p.github.io/i2p.i2p/ (I2P 2.10.0 itibarıyla API 0.9.66) - Clearnet (açık internet) yansısı: https://eyedeekay.github.io/javadoc-i2p/ Kaynak kodu: - GitLab (resmi): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master - GitHub aynası: https://github.com/i2p/i2p.i2p Bağlantı Biçimi Standartları ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text Sürüm Takibi Belge Üstverisi Her teknik belge, frontmatter (belgenin başındaki meta veri bölümü) içinde sürüm meta verilerini içermelidir:\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Alan tanımları: - lastUpdated: Belgenin en son gözden geçirildiği/güncellendiği yıl-ay - accurateFor: Belgenin doğrulandığı I2P sürümü - reviewStatus: Şunlardan biri \u0026ldquo;draft\u0026rdquo;, \u0026ldquo;needs-review\u0026rdquo;, \u0026ldquo;verified\u0026rdquo;, \u0026ldquo;outdated\u0026rdquo;\nİçerikte Sürüm Referansları Sürümlerden bahsederken: 1. Güncel sürüm için kalın kullanın: \u0026ldquo;sürüm 2.10.0 (Eylül 2025)\u0026rdquo; 2. Geçmişe yönelik referanslarda hem sürüm numarasını hem de tarihi belirtin 3. Gerekli olduğunda API sürümünü I2P sürümünden ayrı olarak belirtin\nÖrnek:\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. Zaman İçindeki Değişiklikleri Belgelemek Gelişen özellikler için:\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients Kullanımdan Kaldırma Bildirimleri Kullanımdan kaldırılmış özellikleri belgeliyorsanız:\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. Terminoloji Standartları Resmi I2P Terimleri Bu terimleri aynen ve tutarlı şekilde kullanın:\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address ### Yönetilen İstemci Terminolojisi Yönetilen istemcileri belgelerken:\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory ### Yapılandırma Terminolojisi Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config ### Paket ve Sınıf Adları İlk anılışta her zaman tam nitelikli adları kullanın, sonrasında kısa adları kullanın:\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... Kod Örnekleri ve Biçimlendirme Java Kod Örnekleri Uygun sözdizimi vurgulaması ve tam örnekler kullanın:\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` Kod örneği gereksinimleri: 1. Önemli satırları açıklayan yorumlar ekleyin 2. İlgili yerlerde hata işlemeyi gösterin 3. Gerçekçi değişken adları kullanın 4. I2P kodlama kurallarına uyun (4 boşluklu girinti) 5. Bağlamdan açıkça anlaşılmıyorsa içe aktarmaları gösterin\nYapılandırma Örnekleri Tam ve geçerli yapılandırma örneklerini göster:\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` Komut Satırı Örnekleri Kullanıcı komutları için $, root için # kullanın:\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` Satır içi kod Ters tırnakları şunlar için kullanın: - Yöntem adları: startup() - Sınıf adları: ClientApp - Özellik adları: clientApp.0.main - Dosya adları: clients.config - Sabitler: SVC_HTTP_PROXY - Paket adları: net.i2p.app\nTon ve Üslup Profesyonel ama erişilebilir Küçümseyici olmadan teknik bir kitleye yazın:\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; Etken Çatı Netlik için etken çatı kullanın:\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; Yönergelerde emir kipi Prosedürel içerikte doğrudan emir kipini kullanın:\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; Gereksiz jargondan kaçının Terimleri ilk geçtiği yerde açıklayın:\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) Noktalama Yönergeleri Em-dash (uzun tire) kullanmayın - bunun yerine normal tireler, virgüller veya noktalı virgüller kullanın Listelerde Oxford virgülü kullanın: \u0026ldquo;console, i2ptunnel, and Jetty\u0026rdquo; Kod bloklarında nokta yalnızca dilbilgisel olarak gerekli olduğunda kullanın Sıralı listelerde öğeler virgül içeriyorsa noktalı virgül kullanın Belge Yapısı Standart Bölüm Sırası API belgeleri için:\nGenel Bakış - özelliğin ne yaptığı, neden var olduğu Uygulama - nasıl uygulanacağı/kullanılacağı Yapılandırma - nasıl yapılandırılacağı API Referansı - ayrıntılı metot/özellik açıklamaları Örnekler - çalışır durumdaki eksiksiz örnekler En İyi Uygulamalar - ipuçları ve öneriler Sürüm Geçmişi - ne zaman tanıtıldığı, zaman içindeki değişiklikler Referanslar - ilgili belgelere bağlantılar Başlık Hiyerarşisi Anlamsal başlık düzeylerini kullanın:\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** Bilgi Kutuları Özel notlar için alıntı bloklarını kullanın:\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. Listeler ve Düzen Sırasız listeler ardışık olmayan öğeler için:\n- First item - Second item - Third item Sıralı listeler ardışık adımlar için:\n1. First step 2. Second step 3. Third step Tanım listeleri terim açıklamaları için:\n**Term One** : Explanation of term one **Term Two** : Explanation of term two Kaçınılması Gereken Yaygın Hatalar 1. Benzer Sistemleri Karıştırma Karıştırmayın: - ClientAppManager kaydı vs. PortMapper - i2ptunnel tunnel türleri vs. port mapper servis sabitleri - ClientApp vs. RouterApp (farklı bağlamlar) - Yönetilen vs. yönetilmeyen istemciler\nHer zaman hangi sistem hakkında konuştuğunuzu netleştirin:\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. Güncel Olmayan Sürüm Referansları Yapmayın: - Eski sürümleri \u0026ldquo;güncel\u0026rdquo; olarak göstermek - Güncelliğini yitirmiş API dokümantasyonuna bağlantı vermek - Örneklerde deprecated (kullanımdan kaldırılmış) metot imzalarını kullanmak\nYapın: - Yayınlamadan önce sürüm notlarını kontrol edin - API dokümantasyonunun geçerli sürümle eşleştiğini doğrulayın - Örnekleri güncel en iyi uygulamaları kullanacak şekilde güncelleyin\n3. Erişilemeyen URL\u0026rsquo;ler Yapmayın: - clearnet alternatifleri olmayan yalnızca .i2p alan adlarına bağlantı vermek - Bozuk ya da güncelliğini yitirmiş dokümantasyon URL\u0026rsquo;lerini kullanmak - Yerel file:// yollarına bağlantı vermek\nYapın: - Tüm I2P içi bağlantılar için clearnet (açık internet) alternatifleri sağlayın - Yayınlamadan önce URL\u0026rsquo;lerin erişilebilir olduğunu doğrulayın - Kalıcı URL\u0026rsquo;ler kullanın (geti2p.net, geçici barındırma değil)\n4. Eksik Kod Örnekleri Yapmayın: - Bağlam olmadan kod parçaları göstermeyin - Hata işlemeyi atlamayın - Tanımlanmamış değişkenler kullanmayın - Bariz olmadığı durumlarda import deyimlerini atlamayın\nYapın: - Eksiksiz ve derlenebilir örnekler gösterin - Gerekli hata işlemesini dahil edin - Her önemli satırın ne yaptığını açıklayın - Yayınlamadan önce örnekleri test edin\n5. Muğlak İfadeler ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; Markdown Kuralları Dosya Adlandırma Dosya adları için kebab-case (kelimelerin küçük harfle yazılıp tirelerle ayrıldığı adlandırma biçimi) kullanın: - managed-clients.md - port-mapper-guide.md - configuration-reference.md\nÖn Bilgi Biçimi Her zaman YAML frontmatter (belgenin başındaki YAML meta verisi) ekleyin:\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Bağlantı Biçimlendirme İç bağlantılar (dokümantasyon içinde):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) Dış bağlantılar (diğer kaynaklara):\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) Kod deposu bağlantıları:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) Tablo Biçimlendirme GitHub-flavored Markdown (GitHub\u0026rsquo;a özgü Markdown) tablolarını kullanın:\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | Kod Bloğu Dil Etiketleri Sözdizimi vurgulaması için dili her zaman belirtin:\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` İnceleme Kontrol Listesi Dokümantasyonu yayımlamadan önce şunları doğrulayın:\nTüm teknik iddialar kaynak koda veya resmi dokümantasyona göre doğrulanmış Sürüm numaraları ve tarihleri güncel Tüm URL\u0026rsquo;lere clearnet (açık internet) üzerinden erişilebilir (veya alternatifler sağlanmıştır) Kod örnekleri eksiksiz ve test edilmiştir Terminoloji I2P konvansiyonlarını izler Em dash yok (normal kısa çizgi veya başka noktalama işaretleri kullanın) Frontmatter (belge başı meta verisi) eksiksiz ve doğru Başlık hiyerarşisi anlamsal (h1 → h2 → h3) Listeler ve tablolar düzgün biçimlendirilmiş Kaynakça bölümü alıntılanan tüm kaynakları içerir Belge yapı yönergelerini izler Üslup profesyonel ama anlaşılır Benzer kavramlar açıkça ayırt edilmiştir Kırık bağlantı veya referans yok Yapılandırma örnekleri geçerli ve güncel Geri bildirim: Bu kılavuzlarda sorunlar bulur veya önerileriniz olursa, lütfen bunları resmi I2P geliştirme kanalları üzerinden gönderin.\n","description":"I2P teknik dokümantasyonu genelinde tutarlılığı, doğruluğu ve erişilebilirliği sürdürün","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"I2P Dokümantasyon Yazım Yönergeleri","url":"/tr/docs/writing-guidelines/"},{"categories":null,"content":"Eepsite nedir? Bir eepsite, yalnızca I2P ağında bulunan bir web sitesidir. Clearnet üzerinden erişilebilen geleneksel web sitelerinin aksine, eepsite\u0026rsquo;lere yalnızca I2P üzerinden erişilebilir; bu da hem site işletmecisi hem de ziyaretçiler için anonimlik ve gizlilik sağlar. Eepsite\u0026rsquo;ler .i2p sözde üst düzey alan adını kullanır ve özel .b32.i2p adresleri ya da I2P adres defterine kayıtlı, insan tarafından okunabilir adlar üzerinden erişilir.\nTüm Java I2P kurulumları, hafif, Java tabanlı bir web sunucusu olan Jetty ile önceden kurulmuş ve önceden yapılandırılmış şekilde gelir. Bu, birkaç dakika içinde kendi eepsite\u0026rsquo;inizi (I2P üzerinde barındırılan web sitesi) barındırmaya başlamanızı kolaylaştırır - ek bir yazılım kurulumu gerekmez.\nBu kılavuz, I2P\u0026rsquo;nin yerleşik araçlarını kullanarak ilk eepsite\u0026rsquo;inizi oluşturma ve yapılandırma sürecinde size adım adım rehberlik edecek.\nAdım 1: Gizli Hizmetler Yöneticisine Erişin Gizli Servisler Yöneticisi (I2P Tunnel Manager olarak da adlandırılır), HTTP sunucuları (eepsites) dahil olmak üzere tüm I2P sunucu ve istemci tunnel yapılandırmalarını yaptığınız yerdir.\nI2P Router Console \u0026lsquo;unuzu açın Hidden Services Manager \u0026rsquo;e gidin Gizli Servisler Yöneticisi arayüzünde şunları görmelisiniz: - Durum Mesajları - Geçerli tunnel ve istemci durumu - Genel Tunnel Kontrolü - Tüm tunnel\u0026rsquo;ları aynı anda yönetmek için düğmeler - I2P Gizli Servisler - Yapılandırılmış sunucu tunnel\u0026rsquo;lerinin listesi\nVarsayılan olarak, yapılandırılmış ancak başlatılmamış mevcut bir I2P web sunucusu kaydı göreceksiniz. Bu, kullanmanız için hazır, önceden yapılandırılmış Jetty web sunucusudur.\nAdım 2: Eepsite sunucunuzun ayarlarını yapılandırın Sunucu yapılandırma sayfasını açmak için Gizli Servisler listesindeki I2P webserver öğesine tıklayın. Burada eepsite ayarlarınızı özelleştirebilirsiniz.\nYapılandırma Seçeneklerinin Açıklaması Name - Bu, tunnel\u0026rsquo;iniz için dahili bir tanımlayıcıdır - Birden fazla eepsites çalıştırıyorsanız hangisinin hangisi olduğunu takip etmek için kullanışlıdır - Varsayılan: \u0026ldquo;I2P webserver\u0026rdquo;\nAçıklama - Kendi referansınız için eepsite\u0026rsquo;inizin kısa bir açıklaması - Yalnızca Hidden Services Manager (Gizli Servisler Yöneticisi) içinde size görünür - Örnek: \u0026ldquo;My eepsite\u0026rdquo; veya \u0026ldquo;Kişisel blog\u0026rdquo;\nAuto Start Tunnel - Önemli: I2P router\u0026rsquo;ınız başladığında eepsite\u0026rsquo;ınızı otomatik olarak başlatmak için bu kutuyu işaretleyin - router yeniden başlatmalarından sonra sitenizin manuel müdahale olmadan erişilebilir kalmasını sağlar - Önerilen: Etkin\nHedef (Ana makine ve bağlantı noktası) - Ana makine: Web sunucunuzun çalıştığı yerel adres (varsayılan: 127.0.0.1) - Bağlantı noktası: Web sunucunuzun dinlediği bağlantı noktası (Jetty için varsayılan: 7658) - Önceden kurulu Jetty web sunucusunu kullanıyorsanız, bunları varsayılan değerlerde bırakın - Yalnızca farklı bir bağlantı noktasında özel bir web sunucusu çalıştırıyorsanız değiştirin\nWeb Sitesi Ana Makine Adı - Bu, eepsite\u0026rsquo;inizin insan tarafından okunabilir .i2p alan adıdır - Varsayılan: mysite.i2p (yer tutucu) - stormycloud.i2p veya myblog.i2p gibi özel bir alan adı kaydedebilirsiniz - Yalnızca otomatik olarak oluşturulan .b32.i2p adresini kullanmak istiyorsanız boş bırakın (outproxies (I2P dışa çıkış proxy\u0026rsquo;leri) için) - Özel bir ana makine adını nasıl talep edeceğinizi öğrenmek için aşağıdaki I2P Alan Adınızı Kaydetme bölümüne bakın\nYerel Hedef - Bu, eepsite\u0026rsquo;inizin benzersiz kriptografik tanımlayıcısıdır (hedef adresi) - tunnel ilk oluşturulduğunda otomatik olarak üretilir - Bunu I2P üzerindeki sitenizin kalıcı \u0026ldquo;IP adresi\u0026rdquo; olarak düşünebilirsiniz - Uzun alfasayısal dizi, sitenizin kodlanmış biçimdeki .b32.i2p adresidir\nÖzel Anahtar Dosyası - eepsite\u0026rsquo;inizin özel anahtarlarının saklandığı konum - Varsayılan: eepsite/eepPriv.dat - Bu dosyayı güvenli tutun - Bu dosyaya erişimi olan herkes eepsite\u0026rsquo;inizin kimliğine bürünebilir - Bu dosyayı asla paylaşmayın veya silmeyin\nÖnemli Not Sarı uyarı kutusu, QR kodu oluşturma veya kayıt kimlik doğrulama özelliklerini etkinleştirmek için, .i2p sonekine sahip bir web sitesi ana bilgisayar adı yapılandırmanız gerektiğini hatırlatır (örneğin, mynewsite.i2p).\nAdım 3: Gelişmiş Ağ Seçenekleri (İsteğe bağlı) Yapılandırma sayfasında aşağı kaydırırsanız, gelişmiş ağ seçeneklerini bulabilirsiniz. Bu ayarlar isteğe bağlıdır - varsayılanlar çoğu kullanıcı için gayet iyi çalışır. Ancak, güvenlik gereksinimlerinize ve performans ihtiyaçlarınıza göre bunları ayarlayabilirsiniz.\nTunnel Uzunluk Seçenekleri Tunnel Length - Varsayılan: 3 atlamalı tunnel (yüksek anonimlik) - İsteğin eepsite\u0026rsquo;inize ulaşmadan önce kaç adet router atlamasından geçtiğini kontrol eder - Daha fazla atlama = Daha yüksek anonimlik, ancak daha yavaş performans - Daha az atlama = Daha hızlı performans, ancak daha düşük anonimlik - Seçenekler, varyans ayarlarıyla 0-3 atlama arasında değişir - Öneri: Belirli performans gereksinimleriniz yoksa 3 atlamada tutun\nTunnel Varyansı - Varsayılan: 0 hop varyansı (rastgeleleştirme yok, tutarlı performans) - Ek güvenlik için tunnel uzunluğuna rastgeleleştirme ekler - Örnek: \u0026ldquo;0-1 hop varyansı\u0026rdquo; tunnel\u0026rsquo;ların rastgele olarak 3 veya 4 hop olacağı anlamına gelir - Öngörülemezliği artırır ancak tutarsız yükleme sürelerine yol açabilir\nTunnel Miktar Seçenekleri Sayı (Gelen/Giden Tunnels) - Varsayılan: 2 gelen, 2 giden tunnels (standart bant genişliği ve güvenilirlik) - eepsite\u0026rsquo;inize ayrılan paralel tunnels sayısını belirler - Daha fazla tunnels = Daha iyi kullanılabilirlik ve yük yönetimi, ancak daha yüksek kaynak kullanımı - Daha az tunnels = Daha düşük kaynak kullanımı, ancak daha düşük yedeklilik - Çoğu kullanıcı için önerilen: 2/2 (varsayılan) - Yüksek trafikli siteler 3/3 veya daha üzeri değerlerden fayda görebilir\nYedek Sayısı - Varsayılan: 0 yedek tunnels (yedeklilik yok, ek kaynak kullanımı yok) - Birincil tunnels başarısız olursa etkinleşen bekleme durumundaki tunnels - Güvenilirliği artırır ancak daha fazla bant genişliği ve CPU tüketir - Çoğu kişisel eepsite yedek tunnels gerektirmez\nPOST Sınırları eepsite\u0026rsquo;iniz (I2P ağı içindeki web sitesi) formlar (iletişim formları, yorum bölümleri, dosya yüklemeleri vb.) içeriyorsa, kötüye kullanımı önlemek için POST isteği limitlerini yapılandırabilirsiniz:\nİstemci Başına Sınırlar - Dönem Başına: Tek bir istemciden gelen azami istek sayısı (varsayılan: 5 dakikada 6) - Engelleme Süresi: Kötüye kullanım yapan istemcilerin ne kadar süreyle engelleneceği (varsayılan: 20 dakika)\nToplam Limitler - Toplam: Tüm istemcilerden toplam en fazla POST isteği sayısı (varsayılan: 5 dakikada 20) - Engelleme Süresi: Limit aşıldığında tüm POST isteklerinin reddedileceği süre (varsayılan: 10 dakika)\nPOST Limit Süresi - İstek hızlarını ölçmek için zaman penceresi (varsayılan: 5 dakika)\nBu kısıtlamalar, spam\u0026rsquo;a, hizmet reddi saldırılarına ve otomatik form gönderiminin kötüye kullanılmasına karşı korumaya yardımcı olur.\nGelişmiş Ayarlar Ne Zaman Düzenlenmeli Yüksek trafikli topluluk sitesi: tunnel sayısını artırın (3-4 gelen/giden) Performans-kritik uygulama: tunnel uzunluğunu 2 atlamaya düşürün (gizlilikten ödün) Maksimum anonimlik gerekli: 3 atlamayı koruyun, 0-1 varyans ekleyin Meşru olarak yüksek kullanıma sahip formlar: POST limitlerini buna göre artırın Kişisel blog/portföy: Tüm varsayılanları kullanın Adım 4: Eepsite\u0026rsquo;inize İçerik Ekleme Artık eepsite\u0026rsquo;iniz yapılandırıldığına göre, web sunucusunun belge kök dizinine web sitenizin dosyalarını (HTML, CSS, görseller vb.) eklemeniz gerekir. Konum, işletim sisteminize, kurulum türünüze ve I2P uygulamasına bağlı olarak değişir.\nBelge kök dizininizi bulma belge kök dizini (çoğunlukla docroot olarak adlandırılır), tüm web sitesi dosyalarınızı koyduğunuz klasördür. index.html dosyanız doğrudan bu klasöre yerleştirilmelidir.\nJava I2P (Standart Dağıtım) Linux - Standart kurulum: ~/.i2p/eepsite/docroot/ - Paket kurulumu (servis olarak çalışıyor): /var/lib/i2p/i2p-config/eepsite/docroot/\nWindows - Standart kurulum: %LOCALAPPDATA%\\I2P\\eepsite\\docroot\\ - Örnek yol: C:\\Users\\YourUsername\\AppData\\Local\\I2P\\eepsite\\docroot\\ - Windows Hizmeti kurulumu: %PROGRAMDATA%\\I2P\\eepsite\\docroot\\ - Örnek yol: C:\\ProgramData\\I2P\\eepsite\\docroot\\\nmacOS - Standart kurulum: /Users/YourUsername/Library/Application Support/i2p/eepsite/docroot/\nI2P+ (Geliştirilmiş I2P Dağıtımı) I2P+, Java I2P ile aynı dizin yapısını kullanır. İşletim sisteminize göre yukarıdaki yolları izleyin.\ni2pd (C++ Uygulaması) Linux/Unix - Varsayılan: /var/lib/i2pd/eepsite/ veya ~/.i2pd/eepsite/ - HTTP sunucusu tunnel\u0026rsquo;ınız altındaki geçerli root ayarı için i2pd.conf yapılandırma dosyanızı kontrol edin\nWindows - i2pd kurulum dizininizdeki i2pd.conf dosyasını kontrol edin\nmacOS - Genellikle: ~/Library/Application Support/i2pd/eepsite/\nWeb Sitenizin Dosyalarını Ekleme Belge kök dizininize gidin dosya yöneticinizi veya terminalinizi kullanarak Web sitesi dosyalarınızı oluşturun veya kopyalayın docroot klasörüne En azından bir index.html dosyası oluşturun (bu ana sayfanızdır) Gerektikçe CSS, JavaScript, görseller ve diğer varlıkları ekleyin Alt dizinleri düzenleyin herhangi bir web sitesinde yapacağınız gibi: docroot/ ├── index.html ├── about.html ├── css/ │ └── style.css ├── images/ │ └── logo.png └── js/ └── script.js Hızlı Başlangıç: Basit HTML Örneği Yeni başlıyorsanız, docroot klasörünüzde temel bir index.html dosyası oluşturun:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My I2P Eepsite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Eepsite!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first website on the I2P network.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Privacy-focused and decentralized!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; İzinler (Linux/Unix/macOS) I2P\u0026rsquo;yi bir servis olarak ya da farklı bir kullanıcı olarak çalıştırıyorsanız, I2P işleminin dosyalarınızı okuma izni olduğundan emin olun:\n# Set appropriate ownership (if running as i2p user) sudo chown -R i2p:i2p /var/lib/i2p/i2p-config/eepsite/docroot/ # Or set readable permissions for all users chmod -R 755 ~/.i2p/eepsite/docroot/ İpuçları Varsayılan içerik: I2P\u0026rsquo;yi ilk kez kurduğunuzda, docroot klasöründe zaten örnek içerik bulunur - dilediğiniz gibi değiştirebilirsiniz Statik siteler en iyi çalışır: Jetty servlet\u0026rsquo;leri ve JSP\u0026rsquo;yi desteklese de, basit HTML/CSS/JavaScript sitelerinin bakımı en kolaydır Harici web sunucuları: İleri düzey kullanıcılar, farklı portlarda özel web sunucuları (Apache, Nginx, Node.js, vb.) çalıştırıp I2P tunnel\u0026rsquo;ını (tünel) onlara yönlendirebilir Adım 5: Eepsite\u0026rsquo;inizi Başlatma Artık eepsite’iniz (I2P üzerinde barındırılan web sitesi) yapılandırıldı ve içeriği hazır; onu başlatıp I2P ağında erişilebilir hale getirmenin zamanı geldi.\nTunnel\u0026rsquo;i Başlat Gizli Servisler Yöneticisi sayfasına geri dönün Listede I2P web sunucusu girdinizi bulun Control sütunundaki Start düğmesine tıklayın Tunnel kurulana kadar bekleyin Start\u0026rsquo;a tıkladıktan sonra, eepsite tunnel\u0026rsquo;iniz oluşturulmaya başlayacaktır. Bu işlem genellikle 30-60 saniye sürer. Durum göstergesini izleyin:\nKırmızı ışık = Tunnel başlatılıyor/kuruluyor Sarı ışık = Tunnel kısmen kurulmuş Yeşil ışık = Tunnel tam olarak çalışır durumda ve hazır Bir kez yeşil ışığı gördüğünüzde, eepsite\u0026rsquo;iniz I2P ağında yayında!\nEepsite\u0026rsquo;inize Erişin Çalışan eepsite\u0026rsquo;inizin yanındaki Preview düğmesine tıklayın. Bu, eepsite\u0026rsquo;inizin adresini içeren yeni bir tarayıcı sekmesi açar.\nEepsite\u0026rsquo;inizin iki tür adresi vardır:\nBase32 adresi (.b32.i2p): Şuna benzeyen uzun bir kriptografik adres:\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p Bu, eepsite\u0026rsquo;inizin kalıcı, kriptografik olarak türetilmiş adresidir Değiştirilemez ve özel anahtarınıza bağlıdır Alan adı kaydı olmadan bile her zaman çalışır İnsan tarafından okunabilir alan adı (.i2p): Bir Web sitesi ana bilgisayar adı ayarlarsanız (örn. testwebsite.i2p)\nYalnızca alan adı kaydından sonra çalışır (bkz. bir sonraki bölüm) Hatırlaması ve paylaşması daha kolay .b32.i2p adresinize eşlenir Copy Hostname düğmesi, paylaşım için tam .b32.i2p adresinizi hızlıca kopyalamanıza olanak tanır.\n⚠️ Kritik: Özel Anahtarınızı Yedekleyin Devam etmeden önce, eepsite için özel anahtar dosyanızı yedeklemek zorundasınız. Bu, birkaç nedenle kritik derecede önemlidir:\nAnahtarınızı Neden Yedeklemelisiniz? Özel anahtarınız (eepPriv.dat) eepsite\u0026rsquo;inizin kimliğidir. Bu, .b32.i2p adresinizi belirler ve eepsite\u0026rsquo;inizin sahipliğini kanıtlar.\nAnahtar = .b32 adresi: Özel anahtarınız, benzersiz .b32.i2p adresinizi matematiksel olarak üretir Kurtarılamaz: Anahtarınızı kaybederseniz, eepsite adresinizi kalıcı olarak kaybedersiniz Değiştirilemez: Bir .b32 adresine yönlendiren bir alan adını kaydettiyseniz, bunu güncellemenin bir yolu yoktur - kayıt kalıcıdır Taşıma için gereklidir: Yeni bir bilgisayara geçmek veya I2P\u0026rsquo;yi yeniden kurmak, aynı adresi korumak için bu anahtarı gerektirir Multihoming (çoklu barındırma) desteği: eepsite\u0026rsquo;inizi birden fazla konumdan çalıştırmak, her sunucuda aynı anahtarı gerektirir Özel anahtar nerede? Varsayılan olarak, özel anahtarınız şu konumda saklanır: - Linux: ~/.i2p/eepsite/eepPriv.dat (veya hizmet kurulumları için /var/lib/i2p/i2p-config/eepsite/eepPriv.dat) - Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat veya %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat - macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat\nBu yolu ayrıca tunnel yapılandırmanızda \u0026ldquo;Private Key File\u0026rdquo; altında kontrol edip/değiştirebilirsiniz.\nYedekleme Nasıl Yapılır tunnel\u0026rsquo;inizi durdurun (isteğe bağlı, ancak daha güvenli) eepPriv.dat\u0026lsquo;i kopyalayın güvenli bir konuma: Harici USB sürücü Şifrelenmiş yedekleme sürücüsü Parola korumalı arşiv Güvenli bulut depolama (şifrelenmiş) Birden fazla yedek saklayın farklı fiziksel konumlarda Bu dosyayı asla paylaşmayın - buna sahip olan herkes eepsite\u0026rsquo;inizin kimliğine bürünebilir Yedekten Geri Yükle Yeni bir sistemde veya yeniden yükledikten sonra eepsite\u0026rsquo;inizi geri yüklemek için:\nI2P\u0026rsquo;yi yükleyin ve tunnel ayarlarınızı oluşturun/yapılandırın Anahtarı kopyalamadan önce tunnel\u0026rsquo;ı durdurun Yedeklediğiniz eepPriv.dat dosyasını doğru konuma kopyalayın Tunnel\u0026rsquo;ı başlatın - orijinal .b32 adresinizi kullanacaktır Bir alan adı kaydetmiyorsanız Tebrikler! Özel bir .i2p alan adı kayıt ettirmeyi planlamıyorsanız, eepsite\u0026rsquo;iniz artık tamamlandı ve çalışır durumda.\nŞunları yapabilirsiniz: - .b32.i2p adresinizi başkalarıyla paylaşın - Herhangi bir I2P destekli tarayıcıyla I2P ağı üzerinden sitenize erişin - Web sitenizin dosyalarını istediğiniz zaman docroot klasöründe güncelleyin - Hidden Services Manager\u0026rsquo;da tunnel durumunu izleyin\nİnsan tarafından okunabilir bir alan adı istiyorsanız (uzun bir .b32 adresi yerine mysite.i2p gibi), bir sonraki bölüme devam edin.\nI2P Alan Adınızı Kaydetme İnsanların okuyup anlayabileceği bir .i2p alan adı (örneğin testwebsite.i2p), uzun bir .b32.i2p adresine kıyasla hatırlaması ve paylaşması çok daha kolaydır. Alan adı kaydı ücretsizdir ve seçtiğiniz adı eepsite’inizin (I2P içindeki web sitenizin) kriptografik adresine bağlar.\nÖnkoşullar eepsite\u0026rsquo;iniz yeşil ışık göstermeli tunnel yapılandırmanızda (Adım 2) bir Website Hostname ayarlamış olmalısınız Örnek: testwebsite.i2p veya myblog.i2p Adım 1: Kimlik doğrulama dizesi oluşturun tunnel yapılandırmanıza geri dönün Gizli Hizmetler Yöneticisi\u0026rsquo;nde Ayarları açmak için I2P webserver girişinize tıklayın Kayıt Kimlik Doğrulaması düğmesini bulmak için aşağı kaydırın Registration Authentication\u0026lsquo;a tıklayın Kimlik doğrulama dizesinin tamamını kopyalayın \u0026ldquo;Ana bilgisayar [yourdomainhere] eklemek için kimlik doğrulaması\u0026rdquo; için gösterilen Kimlik doğrulama dizesi şu şekilde görünecektir:\ntestwebsite.i2p=I8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1uNxFZ0HN7tQbbVj1pmbahepQZNxEW0ufwnMYAoFo8opBQAEAAcAAA==#!date=1762104890#sig=9DjEfrcNRxsoSxiE0Mp0-7rH~ktYWtgwU8c4J0eSo0VHbGxDxdiO9D1Cvwcx8hkherMO07UWOC9BWf-1wRyUAw== Bu dize şunları içerir: - Alan adınız (testwebsite.i2p) - Hedef adresiniz (uzun kriptografik tanımlayıcı) - Bir zaman damgası - Özel anahtara sahip olduğunuzu kanıtlayan bir kriptografik imza\nBu kimlik doğrulama dizesini saklayın - her iki kayıt hizmeti için de buna ihtiyacınız olacak.\nAdım 2: stats.i2p\u0026rsquo;ye kaydolun Şuraya gidin stats.i2p Anahtar Ekle (I2P içinde) Kimlik doğrulama dizgesini \u0026ldquo;Authentication String\u0026rdquo; alanına yapıştırın Adınızı ekleyin (isteğe bağlı) - varsayılan olarak \u0026ldquo;Anonymous\u0026rdquo; Bir açıklama ekleyin (önerilir) - eepsite\u0026rsquo;inizin (I2P üzerinde barındırılan web sitesi) ne hakkında olduğunu kısaca açıklayın Örnek: \u0026ldquo;Yeni I2P Eepsite\u0026rdquo;, \u0026ldquo;Kişisel blog\u0026rdquo;, \u0026ldquo;Dosya paylaşım hizmeti\u0026rdquo; \u0026ldquo;HTTP Service?\u0026rdquo; seçeneğini işaretleyin bu bir web sitesi ise (çoğu eepsite için işaretli bırakın) IRC, NNTP, proxy\u0026rsquo;ler, XMPP, git, vb. için işaretini kaldırın Submit\u0026rsquo;e tıklayın İşlem başarılı olursa, alan adınızın stats.i2p adres defterine eklendiğine dair bir onay göreceksiniz.\nAdım 3: reg.i2p\u0026rsquo;e kaydolun Maksimum kullanılabilirliği sağlamak için, reg.i2p hizmetine de kaydolmalısınız:\nŞuraya gidin reg.i2p Add Domain (I2P içinde) Aynı kimlik doğrulama metnini yapıştırın \u0026ldquo;Auth string\u0026rdquo; alanına Bir açıklama ekleyin (isteğe bağlı ancak önerilir) Bu, diğer I2P kullanıcılarının sitenizin ne sunduğunu anlamasına yardımcı olur Submit\u0026rsquo;e tıklayın Alan adınızın kaydedildiğine dair bir onay almalısınız.\nAdım 4: Yayılmayı Bekleyin Her iki hizmete de gönderdikten sonra, alan adı kaydınız I2P ağının adres defteri sistemi aracılığıyla yayılacaktır.\nYayılma zaman çizelgesi: - İlk kayıt: Kayıt hizmetlerinde anında - Ağ genelinde yayılma: Birkaç saat ile 24+ saat arası - Tam kullanılabilirlik: Tüm routers güncellenene kadar 48 saate kadar sürebilir\nBu normal! I2P adres defteri sistemi anında değil, belirli aralıklarla güncellenir. eepsite\u0026rsquo;iniz çalışıyor - diğer kullanıcıların yalnızca güncellenmiş adres defterini almaları gerekiyor.\nAlan adınızı doğrulayın Birkaç saat sonra alan adınızı test edebilirsiniz:\nYeni bir tarayıcı sekmesi açın I2P tarayıcınızda Alan adınıza doğrudan erişmeyi deneyin: http://yourdomainname.i2p Yüklenirse, alan adınız kayıtlı ve yayılıyor! Eğer hâlâ çalışmıyorsa: - Daha uzun süre bekleyin (adres defterleri kendi zamanlamalarına göre güncellenir) - Router\u0026rsquo;ınızın adres defterinin eşitlenmesi için zamana ihtiyaç duyabilir - Bir adres defteri güncellemesini zorlamak için I2P router\u0026rsquo;ınızı yeniden başlatmayı deneyin\nÖnemli Notlar Kayıt kalıcıdır: Kayıt tamamlanıp ağa yayıldıktan sonra alan adınız kalıcı olarak .b32.i2p adresinizi işaret eder Hedef değiştirilemez: Alan adınızın işaret ettiği .b32.i2p adresini güncelleyemezsiniz - bu yüzden eepPriv.dat dosyasının yedeğini almak kritik önemdedir Alan adı sahipliği: Yalnızca özel anahtarın sahibi alan adı kaydını yapabilir veya güncelleyebilir Ücretsiz hizmet: I2P üzerindeki alan adı kaydı ücretsizdir, topluluk tarafından işletilir ve merkeziyetsizdir Birden fazla kayıt kuruluşu: Hem stats.i2p hem de reg.i2p ile kayıt olmak güvenilirliği ve yayılım hızını artırır Tebrikler! I2P eepsite\u0026rsquo;iniz artık kayıtlı bir alan adıyla tamamen çalışır durumda!\nSonraki adımlar: - docroot klasörünüze daha fazla içerik ekleyin - Alan adınızı I2P topluluğuyla paylaşın - eepPriv.dat yedeğinizi güvende tutun - tunnel durumunuzu düzenli olarak izleyin - Sitenizi tanıtmak için I2P forumlarına veya IRC\u0026rsquo;ye katılmayı düşünün\nI2P ağına hoş geldiniz! 🎉\n","description":"Yerleşik Jetty web sunucusunu kullanarak I2P ağında kendi web sitenizi nasıl oluşturup barındıracağınızı öğrenin","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"I2P Eepsite Oluşturma","url":"/tr/docs/guides/i2p-eepsite-olu%C5%9Fturma/"},{"categories":null,"content":"Ağ koşulları git clone işlemini güvenilmez hale getirdiğinde, depoları BitTorrent veya başka bir dosya aktarım yöntemi üzerinden git bundle\u0026rsquo;ları olarak dağıtabilirsiniz. Bir bundle, tüm depo geçmişini içeren tek bir dosyadır. İndirildikten sonra, yerel olarak ondan fetch yaparsınız ve ardından upstream remote\u0026rsquo;a geri dönersiniz.\n1. Başlamadan Önce Bir paket oluşturmak için eksiksiz bir Git klonu gereklidir. --depth 1 ile oluşturulan sığ klonlar, sessizce çalışıyor gibi görünen ancak başkaları kullanmaya çalıştığında başarısız olan bozuk paketler üretir. Her zaman güvenilir bir kaynaktan (GitHub\u0026rsquo;daki github.com/i2p/i2p.i2p , I2P Gitea örneği i2pgit.org , veya I2P üzerinden git.idk.i2p) getirin ve paket oluşturmadan önce herhangi bir sığ klonu tam klona dönüştürmek için gerekirse git fetch --unshallow komutunu çalıştırın.\nMevcut bir paketi sadece kullanıyorsanız, sadece indirin. Özel bir hazırlık gerekmez.\n2. Bir Paket İndirme Obtaining the Bundle File Bundle dosyasını I2PSnark (I2P\u0026rsquo;ye yerleşik torrent istemcisi) veya I2P eklentili BiglyBT gibi diğer I2P uyumlu istemcileri kullanarak BitTorrent üzerinden indirin.\nÖnemli: I2PSnark yalnızca I2P ağı için özel olarak oluşturulmuş torrent\u0026rsquo;lerle çalışır. Standart clearnet torrent\u0026rsquo;ler uyumlu değildir çünkü I2P, IP adresleri ve portlar yerine Destination\u0026rsquo;lar (387+ bayt adresler) kullanır.\nBundle dosyasının konumu I2P kurulum türünüze bağlıdır:\nKullanıcı/manuel kurulumlar (Java yükleyici ile kurulmuş): ~/.i2p/i2psnark/ Sistem/daemon kurulumlar (apt-get veya paket yöneticisi ile kurulmuş): /var/lib/i2p/i2p-config/i2psnark/ BiglyBT kullanıcıları indirdikleri dosyaları yapılandırılmış indirmeler dizininde bulacaktır.\nCloning from the Bundle Standart yöntem (çoğu durumda çalışır):\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle Eğer fatal: multiple updates for ref hataları ile karşılaşırsanız (Git 2.21.0 ve sonraki sürümlerde global Git yapılandırmasında çakışan fetch refspec\u0026rsquo;leri bulunduğunda bilinen bir sorun), manuel başlatma yöntemini kullanın:\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle Alternatif olarak, --update-head-ok bayrağını kullanabilirsiniz:\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; Bundle Dosyasını Edinme Bundle\u0026rsquo;dan klonladıktan sonra, gelecekteki fetch işlemlerinin I2P veya clearnet üzerinden gitmesi için klonunuzu canlı remote\u0026rsquo;a yönlendirin:\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p Veya clearnet erişimi için:\ngit remote set-url origin https://github.com/i2p/i2p.i2p I2P SSH erişimi için, I2P router konsolunuzda g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p adresine işaret eden yapılandırılmış bir SSH istemci tüneline ihtiyacınız vardır (genellikle 7670 portu). Standart olmayan bir port kullanıyorsanız:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle Paketten Klonlama Deponuzun tam bir klon (yüzeysel olmayan) ile tamamen güncel olduğundan emin olun:\ngit fetch --all Eğer sığ bir klonunuz varsa, önce onu dönüştürün:\ngit fetch --unshallow Canlı Uzak Sunucuya Geçiş Ant derleme hedefini kullanma (I2P kaynak ağacı için önerilir):\nant git-bundle Bu, hem i2p.i2p.bundle (bundle dosyası) hem de i2p.i2p.bundle.torrent (BitTorrent metaverileri) dosyalarını oluşturur.\ngit bundle\u0026rsquo;ı doğrudan kullanma:\ngit bundle create i2p.i2p.bundle --all Daha seçici paketler için:\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle Dağıtmadan önce paketi her zaman doğrulayın:\ngit bundle verify i2p.i2p.bundle Bu, bundle\u0026rsquo;ın geçerli olduğunu doğrular ve gerekli ön koşul commit\u0026rsquo;leri gösterir.\nÖn Koşullar Paketi ve torrent meta verilerini I2PSnark dizininize kopyalayın:\nKullanıcı kurulumları için:\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ Sistem kurulumları için:\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ I2PSnark, .torrent dosyalarını saniyeler içinde otomatik olarak algılar ve yükler. Seed yapmaya başlamak için http://127.0.0.1:7657/i2psnark adresindeki web arayüzüne erişin.\n4. Creating Incremental Bundles Periyodik güncellemeler için, son paketten bu yana yalnızca yeni commit\u0026rsquo;leri içeren artımlı paketler oluşturun:\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master Kullanıcılar, temel depoyu zaten indirmişlerse artımlı paketten çekebilirler:\ngit fetch /path/to/update.bundle Her zaman artımlı paketlerin beklenen önkoşul commit\u0026rsquo;leri gösterdiğini doğrulayın:\ngit bundle verify update.bundle 5. Updating After the Initial Clone Bundle\u0026rsquo;dan çalışan bir deponuz olduğunda, onu diğer Git klonları gibi kullanın:\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master Ya da daha basit iş akışları için:\ngit fetch origin git pull origin master 3. Bir Paket Oluşturma Dayanıklı dağıtım: Büyük depolar BitTorrent üzerinden paylaşılabilir; BitTorrent yeniden denemeleri, parça doğrulamayı ve devam etmeyi otomatik olarak yönetir. Eşler arası önyükleme: Yeni katkıda bulunanlar, klonlarını I2P ağındaki yakın eşlerden önyükleyebilir, ardından artımlı değişiklikleri doğrudan Git sunucularından alabilir. Azaltılmış sunucu yükü: Yansılar, özellikle büyük depolar veya yavaş ağ koşulları için canlı Git sunucuları üzerindeki baskıyı hafifletmek amacıyla periyodik paketler yayınlayabilir. Çevrimdışı aktarım: Paketler yalnızca BitTorrent ile değil, herhangi bir dosya aktarım yöntemiyle (USB sürücüler, doğrudan aktarımlar, sneakernet) çalışır. Paketler canlı uzak sunucuların yerini almaz. Bunlar sadece ilk klonlama veya büyük güncellemeler için daha dayanıklı bir başlatma yöntemi sağlar.\n7. Troubleshooting Paketi Oluşturma Sorun: Bundle oluşturma başarılı oluyor ancak diğerleri bundle\u0026rsquo;dan klonlama yapamıyor.\nSebep: Kaynak klonunuz sığ (shallow) bir klon (--depth ile oluşturulmuş).\nÇözüm: Paketler oluşturmadan önce tam klona dönüştürün:\ngit fetch --unshallow Paketinizi Doğrulama Sorun: Bundle\u0026rsquo;dan klonlarken fatal: multiple updates for ref hatası.\nSebep: Git 2.21.0+ sürümü ~/.gitconfig dosyasındaki global fetch refspec\u0026rsquo;leri ile çakışıyor.\nÇözümler: 1. Manuel başlatma kullanın: mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle 2. --update-head-ok bayrağını kullanın: git fetch --update-head-ok /path/to/bundle '*:*' 3. Çakışan yapılandırmayı kaldırın: git config --global --unset remote.origin.fetch\nI2PSnark ile Dağıtım Sorun: git bundle verify eksik önkoşulları bildiriyor.\nNeden: Artımlı paket veya eksik kaynak klonu.\nÇözüm: Ya önkoşul commit\u0026rsquo;lerini çekin ya da önce temel paketi kullanın, ardından artımlı güncellemeleri uygulayın.\n","description":"BitTorrent ve git bundle ile büyük depoları indirme ve dağıtma","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"I2P için Git Bundle'ları","url":"/tr/docs/applications/git-bundle/"},{"categories":null,"content":" Ana I2P geliştirme dalı (i2p.i2p), geliştiricilerin Java geliştirme için yaygın olarak kullanılan iki IDE'yi (Eclipse ve NetBeans) kolayca kurmalarını sağlayacak şekilde yapılandırılmıştır. Eclipse Ana I2P geliştirme dalları (i2p.i2p ve ondan türetilen dallar), dalın Eclipse'te kolayca kurulmasını sağlamak için build.gradle dosyası içerir. Güncel bir Eclipse sürümüne sahip olduğunuzdan emin olun. 2017'den daha yeni herhangi bir sürüm yeterli olacaktır. I2P dalını bir dizine (örneğin $HOME/dev/i2p.i2p) checkout edin. \"File → Import...\" seçeneğini ve ardından \"Gradle\" altında \"Existing Gradle Project\" seçeneğini seçin. \"Project root directory:\" için I2P dalının checkout edildiği dizini seçin. \"Import Options\" diyalogunda \"Gradle Wrapper\" seçeneğini işaretleyin ve Continue'ya basın. \"Import Preview\" diyalogunda proje yapısını inceleyebilirsiniz. \"i2p.i2p\" altında birden fazla proje görünmelidir. \"Finish\" düğmesine basın. Tamamlandı! Çalışma alanınız artık I2P dalındaki tüm projeleri içermeli ve derleme bağımlılıkları doğru şekilde ayarlanmış olmalıdır. NetBeans Ana I2P geliştirme dalları (i2p.i2p ve ondan türetilen dallar) NetBeans proje dosyalarını içerir. ","description":"Eclipse ve NetBeans'i Gradle ve birlikte gelen proje dosyaları ile I2P geliştirme için yapılandırma","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"I2P ile IDE Kullanımı","url":"/tr/docs/guides/ides/"},{"categories":null,"content":"Genel Bakış I2CP, bir I2P router ile herhangi bir istemci süreci arasındaki alt düzey kontrol protokolüdür. Sorumlulukların katı bir ayrımını tanımlar:\nRouter: Yönlendirmeyi, kriptografiyi, tunnel yaşam döngülerini ve ağ veritabanı işlemlerini yönetir İstemci: Anonimlik özelliklerini seçer, tunnel\u0026rsquo;ları yapılandırır ve iletiler gönderir/alır Tüm iletişim tek bir TCP soketi (isteğe bağlı olarak TLS ile sarmalanmış) üzerinden gerçekleşir; bu da eşzamansız, tam çift yönlü işlemleri mümkün kılar.\nProtokol Sürümü: I2CP, ilk bağlantı kurulumu sırasında gönderilen 0x2A (ondalık olarak 42) değerindeki bir protokol sürüm baytı kullanır. Bu sürüm baytı, protokolün başlangıcından beri sabit kalmıştır.\nGüncel Durum: Bu spesifikasyon, 2025-09\u0026rsquo;da yayımlanan router sürümü 0.9.67 (API sürümü 0.9.67) için geçerlidir.\nUygulama Bağlamı Java Implementasyonu Başvuru uygulaması Java I2P\u0026rsquo;de bulunur: - İstemci SDK\u0026rsquo;sı: i2p.jar paketi - Router gerçekleştirmesi: router.jar paketi - Javadocs İstemci ve router aynı JVM\u0026rsquo;de çalıştığında, I2CP mesajları serileştirme olmadan Java nesneleri olarak aktarılır. Harici istemciler TCP üzerinden serileştirilmiş protokolü kullanır.\nC++ Gerçeklemesi i2pd (C++ I2P router) ayrıca istemci bağlantıları için I2CP\u0026rsquo;yi harici olarak uygular.\nJava Olmayan İstemciler Eksiksiz bir I2CP istemci kitaplığının bilinen Java dışı implementasyonları yoktur. Java dışı uygulamalar bunun yerine daha üst düzey protokolleri kullanmalıdır:\nSAM (Simple Anonymous Messaging) v3: Birden çok dilde kütüphaneleri bulunan soket tabanlı bir arayüz BOB (Basic Open Bridge): SAM\u0026rsquo;e daha basit bir alternatif Bu daha üst düzey protokoller, I2CP karmaşıklığını kendi içinde yönetir ve ayrıca akış kitaplığını (TCP benzeri bağlantılar için) ve datagram kitaplığını (UDP benzeri bağlantılar için) sağlar.\nBağlantı Kurulumu 1. TCP Bağlantısı router I2CP bağlantı noktasına bağlanın: - Varsayılan: 127.0.0.1:7654 - router ayarları üzerinden yapılandırılabilir - İsteğe bağlı TLS sarmalayıcı (uzak bağlantılar için şiddetle önerilir)\n2. Protokol El Sıkışması Adım 1: Protokol sürüm baytını 0x2A gönderin\nAdım 2: Saat Senkronizasyonu\nClient → Router: GetDateMessage Router → Client: SetDateMessage router, kendi geçerli zaman damgasını ve I2CP API sürüm dizesini döndürür (0.8.7\u0026rsquo;den beri).\nAdım 3: Kimlik doğrulama (etkinleştirildiyse)\n0.9.11 itibarıyla, kimlik doğrulama, şunları içeren bir Mapping (eşleme) aracılığıyla GetDateMessage (tarih alma mesajı) içine eklenebilir: - i2cp.username - i2cp.password\n0.9.16 sürümünden itibaren, kimlik doğrulama etkinleştirildiğinde, diğer herhangi bir mesaj gönderilmeden önce GetDateMessage aracılığıyla tamamlanması zorunludur.\nAdım 4: Oturum Oluşturma\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) Adım 5: Tunnel Hazır Sinyali\nRouter → Client: RequestVariableLeaseSetMessage Bu mesaj, gelen tunnel\u0026rsquo;ların oluşturulduğunu bildirir. router, en az bir gelen VE bir giden tunnel mevcut olana kadar bunu GÖNDERMEYECEKTİR.\nAdım 6: LeaseSet Yayınlanması\nClient → Router: CreateLeaseSet2Message Bu noktada, oturum mesaj gönderme ve alma için tamamen işler durumdadır.\nMesaj Akış Kalıpları Giden Mesaj (İstemci uzak hedefe gönderir) i2cp.messageReliability=none ile:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] i2cp.messageReliability=BestEffort ile:\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) Gelen İleti (Router istemciye iletir) i2cp.fastReceive=true ile (0.9.4\u0026rsquo;ten beri varsayılan):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] i2cp.fastReceive=false ile (KULLANIMDAN KALDIRILDI):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage Modern istemciler her zaman hızlı alım modunu kullanmalıdır.\nYaygın Veri Yapıları I2CP Mesaj Başlığı Tüm I2CP mesajları bu ortak başlığı kullanır:\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ Gövde Uzunluğu: 4 baytlık tamsayı, yalnızca mesaj gövdesinin uzunluğu (başlığı içermez) Tür: 1 baytlık tamsayı, mesaj türü tanımlayıcısı Mesaj Gövdesi: 0+ bayt, biçim mesaj türüne göre değişir Mesaj Boyutu Sınırı: En fazla yaklaşık 64 KB.\nOturum Kimliği Bir router üzerinde bir oturumu benzersiz şekilde tanımlayan 2 baytlık tamsayı.\nÖzel Değer: 0xFFFF \u0026ldquo;oturum yok\u0026rdquo; anlamına gelir (kurulmuş bir oturum olmadan yapılan ana bilgisayar adı sorguları için kullanılır).\nMesaj Kimliği Bir oturum içindeki bir mesajı benzersiz olarak tanımlamak için router tarafından oluşturulan 4 baytlık tamsayı.\nÖnemli: Mesaj kimlikleri küresel olarak benzersiz değildir, yalnızca bir oturum içinde benzersizdir. Ayrıca, istemci tarafından üretilen nonce\u0026rsquo;tan (tek kullanımlık sayı) farklıdır.\nYük Biçimi Mesaj yükleri, standart 10 baytlık bir gzip üstbilgisiyle gzip sıkıştırılır: - Şununla başlar: 0x1F 0x8B 0x08 (RFC 1952) - 0.7.1\u0026rsquo;den beri: gzip üstbilgisinin kullanılmayan bölümleri protokol, kaynak bağlantı noktası ve hedef bağlantı noktası bilgilerini içerir - Bu, aynı hedef üzerinde hem akış hem de datagramları mümkün kılar\nSıkıştırma Kontrolü: Sıkıştırmayı devre dışı bırakmak için i2cp.gzip=false olarak ayarlayın (gzip çaba düzeyini 0’a ayarlar). gzip başlığı yine de dahil edilir, ancak sıkıştırma ek yükü asgaridir.\nSessionConfig Yapısı İstemci oturumu yapılandırmasını tanımlar:\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ Kritik Gereksinimler: 1. Eşleme anahtara göre sıralanmış olmalıdır imza doğrulaması için 2. Oluşturma Tarihi router\u0026rsquo;ın mevcut zamanına göre ±30 saniye içinde olmalıdır 3. İmza Destination\u0026rsquo;ın SigningPrivateKey\u0026rsquo;i tarafından oluşturulur\nÇevrimdışı İmzalar (0.9.38 itibarıyla):\nÇevrimdışı imzalama kullanılıyorsa, Eşleme şunları içermelidir: - i2cp.leaseSetOfflineExpiration - i2cp.leaseSetTransientPublicKey - i2cp.leaseSetOfflineSignature\nArdından Signature, geçici SigningPrivateKey tarafından oluşturulur.\nÇekirdek Yapılandırma Seçenekleri Tunnel Yapılandırması Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) **Notlar**: - `quantity` için 6'dan büyük değerler 0.9.0+ çalıştıran eşler gerektirir ve kaynak kullanımını önemli ölçüde artırır - Yüksek erişilebilirlikli hizmetler için `backupQuantity` değerini 1-2 olarak ayarlayın - Sıfır atlamalı tunnels daha düşük gecikme için anonimliği feda eder ancak test için kullanışlıdır Mesaj İşleme Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) **Mesaj Güvenilirliği**: - `None`: Router alındı onayı göndermez (0.8.1'den beri akış kitaplığının varsayılanı) - `BestEffort`: Router kabul + başarı/başarısızlık bildirimleri gönderir - `Guaranteed`: Uygulanmadı (şu anda BestEffort gibi davranır) Mesaj Başına Geçersiz Kılma (0.9.14 sürümünden beri): - messageReliability=none olan bir oturumda, sıfır olmayan bir nonce (bir kez kullanılan sayı) ayarlamak, o belirli mesaj için teslim bildirimi talep eder - BestEffort oturumunda nonce=0 ayarlamak, o mesaj için bildirimleri devre dışı bırakır\nLeaseSet Yapılandırması Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) ### Eski ElGamal/AES Oturum Etiketleri Bu seçenekler yalnızca eski ElGamal şifrelemesi için geçerlidir:\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch **Not**: ECIES-X25519 istemcileri farklı bir ratchet (ardışık anahtar yenileme) mekanizması kullanır ve bu seçenekleri yok sayar. Şifreleme Türleri I2CP, i2cp.leaseSetEncType seçeneği aracılığıyla birden fazla uçtan uca şifreleme şemasını destekler. Hem modern hem de eski eşleri desteklemek için birden fazla tür belirtilebilir (virgülle ayrılmış).\nDesteklenen Şifreleme Türleri Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned **Önerilen Yapılandırma**: i2cp.leaseSetEncType=4,0 Bu, uyumluluk amacıyla ElGamal geri dönüş mekanizmasıyla birlikte X25519’u (tercih edilen) sağlar.\nŞifreleme Türü Ayrıntıları Type 0 - ElGamal/AES+SessionTags: - 2048-bit ElGamal açık anahtarlar (256 bayt) - AES-256 simetrik şifreleme - toplu olarak gönderilen 32 baytlık oturum etiketleri - yüksek CPU, bant genişliği ve bellek ek yükü - ağ genelinde aşamalı olarak kullanımdan kaldırılıyor\nTip 4 - ECIES-X25519-AEAD-Ratchet: - X25519 anahtar değişimi (32 baytlık anahtarlar) - ChaCha20/Poly1305 AEAD (ilişkili verili kimlik doğrulamalı şifreleme) - Signal tarzı double ratchet (çift kademeli anahtar yenileme mekanizması) - 8 bayt oturum etiketleri (ElGamal için 32 bayta karşılık) - Etiketler senkronize PRNG (sözde rastgele sayı üreteci) aracılığıyla üretilir (önceden gönderilmez) - ElGamal’a kıyasla ~92% ek yük azaltımı - Modern I2P için standarttır (çoğu router bunu kullanır)\nTip 5-6 - Kuantum Sonrası Hibrit: - X25519 ile ML-KEM\u0026rsquo;i birleştirir (NIST FIPS 203) - Kuantuma dayanıklı güvenlik sağlar - Dengeli güvenlik/performans için ML-KEM-768 - Maksimum güvenlik için ML-KEM-1024 - PQ anahtar materyali (post-quantum; kuantum sonrası) nedeniyle daha büyük mesaj boyutları - Ağ desteği hâlen devreye alınıyor\nGeçiş Stratejisi I2P ağı, ElGamal (tip 0)\u0026lsquo;dan X25519 (tip 4)\u0026rsquo;e aktif olarak geçiş yapıyor: - NTCP → NTCP2 (tamamlandı) - SSU → SSU2 (tamamlandı) - ElGamal tunnels → X25519 tunnels (tamamlandı) - ElGamal uçtan uca → ECIES-X25519 (büyük ölçüde tamamlandı)\nLeaseSet2 ve Gelişmiş Özellikler LeaseSet2 Seçenekleri (0.9.38\u0026rsquo;den beri) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) ### Körlenmiş Adresler 0.9.39 itibarıyla, hedefler periyodik olarak değişen \u0026ldquo;blinded\u0026rdquo; (körlenmiş) adresleri (b33 biçimi) kullanabilir: - Parola koruması için i2cp.leaseSetSecret gerektirir - İsteğe bağlı istemci başına kimlik doğrulama - Ayrıntılar için 123 ve 149 numaralı önerilere bakın\nHizmet Kayıtları (0.9.66 sürümünden beri) LeaseSet2 servis kaydı seçeneklerini destekler (öneri 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p Biçim, DNS SRV kayıt biçimini izler ancak I2P\u0026rsquo;ye uyarlanmıştır.\nBirden Çok Oturum (0.9.21\u0026rsquo;den beri) Tek bir I2CP bağlantısı birden fazla oturumu destekleyebilir:\nBirincil Oturum: Bir bağlantıda oluşturulan ilk oturum Alt Oturumlar: Birincil oturumun tunnel havuzunu paylaşan ek oturumlar\nSubsession (alt oturum) Özellikleri Paylaşılan Tunnels: Birincil ile aynı gelen/giden tunnel havuzlarını kullanın Paylaşılan Şifreleme Anahtarları: Özdeş LeaseSet şifreleme anahtarlarını kullanmalıdır Farklı İmzalama Anahtarları: Ayrı Destination (I2P\u0026rsquo;de hedef kimlik) imzalama anahtarları kullanmalıdır Anonimlik Garantisi Yok: Birincil oturumla açıkça bağlantılıdır (aynı router, aynı tunnels) Subsession (alt oturum) kullanım senaryosu Farklı imza türleri kullanan hedeflerle iletişimi etkinleştirin: - Birincil: EdDSA imzası (modern) - Subsession (alt oturum): DSA imzası (eski sürümlerle uyumluluk)\nAlt Oturum Yaşam Döngüsü Oluşturma:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) Sonlandırma: - Alt oturumu sonlandırmak: Birincil oturum bozulmadan kalır - Birincil oturumu sonlandırmak: Tüm alt oturumları sonlandırır ve bağlantıyı kapatır - DisconnectMessage (bağlantıyı kesme mesajı): Tüm oturumları sonlandırır\nOturum Kimliği Yönetimi Çoğu I2CP mesajı bir Oturum Kimliği alanı içerir. İstisnalar: - DestLookup / DestReply (kullanımdan kaldırıldı, HostLookup / HostReply kullanın) - GetBandwidthLimits / BandwidthLimits (yanıt oturuma özgü değildir)\nÖnemli: İstemciler, yanıt bekleyen birden fazla CreateSession mesajını aynı anda bulundurmamalıdır; çünkü yanıtlar isteklerle kesin olarak ilişkilendirilemez.\nMesaj Kataloğu Mesaj Türleri Özeti Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current **Açıklama**: C = İstemci, R = Router Anahtar Mesaj Ayrıntıları CreateSessionMessage (Oturum Oluşturma Mesajı) (Tür 1) Amaç: Yeni bir I2CP (I2P\u0026rsquo;nin İstemci Protokolü) oturumu başlatmak\nİçerik: SessionConfig yapısı\nYanıt: SessionStatusMessage (status=Created veya Invalid)\nGereksinimler: - SessionConfig (oturum yapılandırması) içindeki tarih, router saatine göre ±30 saniye içinde olmalıdır - İmza doğrulaması için eşleme anahtara göre sıralanmış olmalıdır - Destination (hedef) zaten etkin bir oturuma sahip olmamalıdır\nRequestVariableLeaseSetMessage (Tür 37) Amaç: Router, gelen tunnels için istemci yetkilendirmesi ister\nİçerik: - Oturum Kimliği - Lease sayısı (Lease: sona erme zamanı olan erişilebilirlik kaydı) - Lease yapılarından oluşan dizi (her birinin kendi sona erme zamanı vardır)\nYanıt: CreateLeaseSet2Message\nÖnemi: Bu, oturumun çalışır durumda olduğunu belirten sinyaldir. router bunu yalnızca şu durumların ardından gönderir: 1. En az bir inbound tunnel kuruldu 2. En az bir outbound tunnel kuruldu\nZaman Aşımı Önerisi: Bu mesaj, oturum oluşturulduktan sonra 5+ dakika içinde alınmazsa istemciler oturumu sonlandırmalıdır.\nCreateLeaseSet2Message (Tür 41) Amaç: İstemci LeaseSet\u0026rsquo;i ağ veritabanına yayınlar\nİçerik: - Oturum Kimliği - LeaseSet (kiralama kümesi) tip baytı (1, 3 veya 7) - LeaseSet veya LeaseSet2 veya EncryptedLeaseSet veya MetaLeaseSet - Özel anahtar sayısı - Özel anahtar listesi (LeaseSet içindeki her açık anahtar için bir tane, aynı sırada)\nÖzel Anahtarlar: Gelen garlic messages (I2P\u0026rsquo;nin garlic encryption tekniğiyle paketlenen iletiler) şifrelerini çözmek için gereklidir. Biçim:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) Not: Aşağıdakileri desteklemeyen kullanımdan kaldırılmış CreateLeaseSetMessage (tip 4)\u0026lsquo;in yerini alır: - LeaseSet2 varyantları (I2P\u0026rsquo;de bir hedefin erişim bilgilerini içeren kayıt) - ElGamal dışı şifreleme - Birden fazla şifreleme türü - Şifrelenmiş LeaseSet\u0026rsquo;ler - Çevrimdışı imzalama anahtarları\nSendMessageExpiresMessage (Tip 36) Amaç: Mesajı geçerlilik süresi ve gelişmiş seçeneklerle hedefe gönder\nİçerik: - Oturum Kimliği - Hedef - Yük (gzip ile sıkıştırılmış) - Nonce (tek kullanımlık sayı, 4 bayt) - Bayraklar (2 bayt) - aşağıya bakın - Sona Erme Tarihi (6 bayt, 8 bayttan kısaltılmış)\nFlags Alanı (2 bayt, bit sırası 15\u0026hellip;0):\nBitler 15-11: Kullanılmıyor, 0 olmalıdır\nBitler 10-9: Mesaj Güvenilirliği Geçersiz Kılma (kullanılmıyor, bunun yerine nonce (tek seferlik sayı) kullanın)\nBit 8: LeaseSet\u0026rsquo;i paketleme - 0: Router, LeaseSet\u0026rsquo;i garlic (I2P\u0026rsquo;de kullanılan garlic encryption) içinde paketleyebilir - 1: LeaseSet\u0026rsquo;i paketleme\nBitler 7-4: Düşük etiket eşiği (yalnızca ElGamal, ECIES için yok sayılır)\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags Bits 3-0: Gerekirse gönderilecek etiketler (yalnızca ElGamal için, ECIES için yok sayılır)\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage (Tür 22) Amaç: İletinin teslim durumunu istemciye bildirmek\nİçerik: - Oturum Kimliği - Mesaj Kimliği (router tarafından oluşturulan) - Durum kodu (1 bayt) - Boyut (4 bayt, yalnızca status=0 için geçerlidir) - Nonce (4 bayt, istemcinin SendMessage nonce\u0026rsquo;u ile eşleşir)\nDurum Kodları (Giden Mesajlar):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure **Başarı kodları**: 1, 2, 4, 6 **Hata kodları**: Geri kalanların tümü Durum Kodu 0 (KULLANIMDAN KALDIRILDI): Mevcut mesaj (gelen, hızlı alım devre dışı)\nHostLookupMessage (konak adı sorgu mesajı) (Tip 38) Amaç: Konak adı veya hash ile hedef arama (DestLookup\u0026rsquo;un yerini alır)\nİçerik: - Oturum Kimliği (veya oturum yoksa 0xFFFF) - İstek Kimliği (4 bayt) - Zaman aşımı milisaniye cinsinden (4 bayt, önerilen minimum: 10000) - İstek türü (1 bayt) - Arama anahtarı (Hash, hostname String veya Destination)\nİstek Türleri:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 2-4 numaralı tipler, mevcutsa LeaseSet seçeneklerini (öneri 167) döndürür. Yanıt: HostReplyMessage (Ana Makine Yanıt Mesajı)\nHostReplyMessage (Tür 39) Amaç: HostLookupMessage (konak adı sorgulama mesajı) için yanıt\nİçerik: - Oturum Kimliği - İstek Kimliği - Sonuç kodu (1 bayt) - Hedef (başarılı olduğunda mevcut, bazen belirli başarısızlık durumlarında) - Eşleme (yalnızca arama türleri 2-4 için, boş olabilir)\nSonuç Kodları:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type #### BlindingInfoMessage (Tür 42) Amaç: router\u0026rsquo;a blinded destination (körleştirilmiş hedef) kimlik doğrulama gereksinimleri hakkında bilgi vermek (0.9.43\u0026rsquo;ten beri)\nİçerik: - Oturum Kimliği - Bayraklar (1 bayt) - Uç nokta türü (1 bayt): 0=Hash, 1=hostname, 2=Destination, 3=SigType+Key - Kör imza türü (2 bayt) - Sona erme zamanı (4 bayt, epoch\u0026rsquo;tan beri geçen saniyeler) - Uç nokta verisi (türe göre değişir) - Özel anahtar (32 bayt, yalnızca bayrak biti 0 ayarlıysa) - Arama parolası (String, yalnızca bayrak biti 4 ayarlıysa)\nBayraklar (bit sırası 76543210):\nBit 0: 0=herkes, 1=istemci başına Bitler 3-1: Kimlik doğrulama şeması (bit 0=1 ise): 000=DH, 001=PSK Bit 4: 1=sır gerekli Bitler 7-5: Kullanılmıyor, 0\u0026rsquo;a ayarlayın Yanıt yok: Router sessizce işlem yapar\nKullanım Senaryosu: Bir blinded destination (b33 address - gizlenmiş hedef) adresine göndermeden önce, istemci şunlardan birini yapmalıdır: 1. b33\u0026rsquo;ü HostLookup (ana bilgisayar adı çözümlemesi) aracılığıyla çözümlemek, VEYA 2. BlindingInfo message (körleştirme bilgisi iletisi) göndermek\nHedef kimlik doğrulama gerektiriyorsa, BlindingInfo zorunludur.\nReconfigureSessionMessage (Tip 2) Amaç: Oluşturma sonrasında oturum yapılandırmasını güncellemek\nİçerik: - Session ID - SessionConfig (yalnızca değiştirilen seçenekler gerekli)\nYanıt: SessionStatusMessage (status=Updated veya Invalid)\nNotlar: - Router yeni yapılandırmayı mevcut yapılandırmayla birleştirir - Tunnel seçenekleri (inbound.*, outbound.*) her zaman uygulanır - Bazı seçenekler oturum oluşturulduktan sonra değiştirilemez olabilir - Tarih, router saatinin ±30 saniyesi içinde olmalıdır - Eşleme anahtara göre sıralanmış olmalıdır\nDestroySessionMessage (oturumu yok etme mesajı) (Tip 3) Amaç: Bir oturumu sonlandırmak\nİçerik: Oturum Kimliği\nBeklenen Yanıt: SessionStatusMessage (status=Destroyed)\nGerçek Davranış (Java I2P 0.9.66\u0026rsquo;ya kadar): - Router asla SessionStatus(Destroyed) göndermez - Hiç oturum kalmamışsa: DisconnectMessage gönderir - Alt oturumlar kalmışsa: Yanıt yok\nÖnemli: Java I2P\u0026rsquo;nin davranışı spesifikasyondan sapmaktadır. Gerçekleştirimler, tek tek subsessions (alt oturumlar) sonlandırılırken dikkatli olmalıdır.\nDisconnectMessage (Tür 30) Amaç: Bağlantının sonlandırılmak üzere olduğunu bildirmek\nİçerik: Gerekçe Dizesi\nEtkisi: Bağlantıdaki tüm oturumlar sonlandırılır, soket kapanır\nGerçekleme: Ağırlıklı olarak Java I2P\u0026rsquo;de router → istemci\nProtokol Sürüm Geçmişi Sürüm Tespiti I2CP protokol sürümü, Get/SetDate mesajlarında alınıp verilir (0.8.7\u0026rsquo;den beri). Daha eski routers için sürüm bilgisi mevcut değildir.\nSürüm Dizesi: \u0026ldquo;core\u0026rdquo; (çekirdek) API sürümünü belirtir, router sürümünü belirtmek zorunda değildir.\nÖzellik Zaman Çizelgesi Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features ## Güvenlik Hususları Kimlik Doğrulama Varsayılan: Kimlik doğrulama gerekmez İsteğe bağlı: Kullanıcı adı/şifre ile kimlik doğrulama (0.9.11 sürümünden beri) Zorunlu: Etkinleştirildiğinde, diğer mesajlardan önce kimlik doğrulamanın tamamlanması gerekir (0.9.16 sürümünden beri)\nUzaktan Bağlantılar: Kimlik bilgilerini ve özel anahtarları korumak için her zaman TLS (i2cp.SSL=true) kullanın.\nSaat Kayması SessionConfig Date, router saatinden ±30 saniye içinde olmalıdır; aksi halde oturum reddedilecektir. Senkronize etmek için Get/SetDate kullanın.\nÖzel Anahtar Yönetimi CreateLeaseSet2Message, gelen mesajların şifresini çözmek için özel anahtarlar içerir. Bu anahtarlar şu şekilde olmalıdır: - Güvenli şekilde iletilmelidir (uzak bağlantılar için TLS) - router tarafından güvenli şekilde saklanmalıdır - Kompromize olduğunda yenilenmelidir\nMesajın Sona Ermesi Açık bir sona erme süresi belirlemek için her zaman SendMessageExpires (SendMessage değil) kullanın. Bu:\nİletilerin süresiz olarak kuyruğa alınmasını engeller Kaynak tüketimini azaltır Güvenilirliği artırır Oturum Etiketi Yönetimi ElGamal (kullanımdan kaldırılmış): - Etiketler toplu olarak iletilmelidir - Kaybolan etiketler şifre çözme hatalarına neden olur - Yüksek bellek ek yükü\nECIES-X25519 (mevcut): - Senkronize PRNG (sözde rastgele sayı üreteci) ile üretilen etiketler - Önceden gönderim gerekmez - Mesaj kaybına dayanıklı - Önemli ölçüde daha düşük ek yük\nEn İyi Uygulamalar İstemci Geliştiriciler için Hızlı Alma Modunu Kullanın: Her zaman i2cp.fastReceive=true olarak ayarlayın (veya varsayılanı kullanın)\nECIES-X25519\u0026rsquo;i tercih edin: Uyumluluğu korurken en iyi performans için i2cp.leaseSetEncType=4,0 ayarını yapılandırın\nSona Erme Süresini Açıkça Belirleyin: SendMessageExpires kullanın, SendMessage değil\nSubsessions (alt oturumlar) dikkatle ele alın: subsessions hedefler arasında anonimlik sağlamaz; bunun farkında olun\nOturum Oluşturma Zaman Aşımı: RequestVariableLeaseSet (değişken leaseSet isteği) 5 dakika içinde alınmazsa oturumu sonlandır\nYapılandırma Eşlemelerini Sırala: SessionConfig\u0026rsquo;i imzalamadan önce eşleme anahtarlarını her zaman sıralayın\nUygun Tunnel Sayılarını Kullanın: Gerekli olmadıkça quantity \u0026gt; 6 olarak ayarlamayın\nJava dışı için SAM/BOB (I2P istemci arayüzü protokolleri) kullanmayı değerlendirin: Doğrudan I2CP\u0026rsquo;yi uygulamak yerine SAM\u0026rsquo;i uygulayın\nRouter Geliştiricileri için Tarihleri Doğrulayın: SessionConfig tarihlerinde ±30 saniyelik bir zaman penceresini uygulayın\nMesaj Boyutunu Sınırla: ~64 KB maksimum mesaj boyutunu zorunlu tut\nBirden Çok Oturumu Destekleyin: 0.9.21 belirtimine göre subsession (alt oturum) desteğini uygulayın\nRequestVariableLeaseSet gönderimini gecikmeden yapın: Yalnızca hem inbound hem de outbound tunnels mevcut olduktan sonra\nKullanımdan Kaldırılmış Mesajları Ele Alın: ReceiveMessageBegin/End\u0026rsquo;i kabul edin ancak kullanımını caydırın\nECIES-X25519\u0026rsquo;i destekleyin: Yeni dağıtımlar için tip 4 şifrelemeye öncelik verin (X25519 eğrisi kullanan ECIES şifreleme)\nHata Ayıklama ve Sorun Giderme Yaygın Sorunlar Oturum Reddedildi (Geçersiz): - Saat sapmasını kontrol edin (±30 saniye içinde olmalı) - Mapping (eşleştirme) anahtara göre sıralı mı, doğrulayın - Destination (hedef) halihazırda kullanımda olmadığından emin olun\nRequestVariableLeaseSet yok: - Router tunnel oluşturuyor olabilir (en fazla 5 dakika bekleyin) - Ağ bağlantı sorunları olup olmadığını kontrol edin - Yeterli eş bağlantısı olduğunu doğrulayın\nMesaj İletim Hataları: - Belirli başarısızlık nedenini belirlemek için MessageStatus (mesaj durumu) kodlarını kontrol edin - Uzak LeaseSet\u0026rsquo;in yayımlandığını ve güncel olduğunu doğrulayın - Uyumlu şifreleme türlerinin kullanıldığından emin olun\nSubsession (alt oturum) Sorunları: - Önce birincil oturumun oluşturulduğunu doğrulayın - Aynı şifreleme anahtarlarının kullanıldığını doğrulayın - İmzalama anahtarlarının farklı olduğunu kontrol edin\nTanılama Mesajları GetBandwidthLimits: router kapasitesini sorgulayın HostLookup: ad çözümlemesini ve LeaseSet kullanılabilirliğini test edin MessageStatus: mesaj teslimatını uçtan uca izleyin\nİlgili Spesifikasyonlar Ortak Yapılar: /docs/specs/common-structures/ I2NP (Ağ Protokolü): /docs/specs/i2np/ ECIES-X25519: /docs/specs/ecies/ Tunnel Oluşturma: /docs/specs/implementation/ Akış Kitaplığı: /docs/specs/streaming/ Datagram Kitaplığı: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ Atıfta Bulunulan Öneriler Öneri 123 : Şifrelenmiş LeaseSet\u0026rsquo;ler ve kimlik doğrulama Öneri 144 : ECIES-X25519-AEAD-Ratchet Öneri 149 : Körleştirilmiş adres biçimi (b33) Öneri 152 : X25519 tunnel oluşturma Öneri 154 : ECIES hedeflerinden veritabanı sorguları Öneri 156 : Router\u0026rsquo;ın ECIES-X25519\u0026rsquo;a geçişi Öneri 161 : Hedef dolgusu sıkıştırması Öneri 167 : LeaseSet hizmet kayıtları Öneri 169 : Kuantum-sonrası hibrit kriptografi (ML-KEM) Javadocs Referansı I2CP Paketi MessageStatusMessage İstemci API Kullanımdan Kaldırma Özeti Kullanımdan Kaldırılmış Mesajlar (Kullanmayın) CreateLeaseSetMessage (tip 4): CreateLeaseSet2Message kullanın RequestLeaseSetMessage (tip 21): RequestVariableLeaseSetMessage kullanın ReceiveMessageBeginMessage (tip 6): hızlı alma modunu kullanın ReceiveMessageEndMessage (tip 7): hızlı alma modunu kullanın DestLookupMessage (tip 34): HostLookupMessage kullanın DestReplyMessage (tip 35): HostReplyMessage kullanın ReportAbuseMessage (tip 29): Hiç uygulanmadı Kullanımdan Kaldırılmış Seçenekler ElGamal şifreleme (type 0): ECIES-X25519\u0026rsquo;e (type 4) geçin DSA imzaları: EdDSA\u0026rsquo;ya veya ECDSA\u0026rsquo;ya geçin i2cp.fastReceive=false: Her zaman hızlı alma modunu kullanın ","description":"Uygulamalar, I2P router ile oturumları, tunnels ve LeaseSets'i nasıl müzakere eder.","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"I2P İstemci Protokolü (I2CP)","url":"/tr/docs/specs/i2cp/"},{"categories":null,"content":"Giriş I2P, Postman\u0026rsquo;s Mail.i2p hizmeti ile birlikte yerleşik bir webmail istemcisi olan SusiMail aracılığıyla özel e-posta tarzı mesajlaşma sağlar. Bu sistem, kullanıcıların hem I2P ağı içinde hem de bir ağ geçidi köprüsü üzerinden normal internet (clearnet) ile e-posta gönderip almalarına olanak tanır.\nPostman / Mail.i2p + SusiMail What it is Mail.i2p, \u0026ldquo;Postman\u0026rdquo; tarafından işletilen, I2P içinde barındırılan bir e-posta sağlayıcısıdır SusiMail, I2P router konsoluna entegre edilmiş webmail istemcisidir. Harici SMTP sunucularına metadata (örn. hostname) sızmasını önlemek için tasarlanmıştır. Bu yapı sayesinde I2P kullanıcıları hem I2P içinde hem de Postman köprüsü üzerinden clearnet\u0026rsquo;e (örn. Gmail) mesaj gönderip alabilir. How Addressing Works I2P e-posta ikili adres sistemi kullanır:\nI2P ağı içinde: username@mail.i2p (örneğin, idk@mail.i2p) Clearnet\u0026rsquo;ten: username@i2pmail.org (örneğin, idk@i2pmail.org) i2pmail.org gateway\u0026rsquo;i, normal internet kullanıcılarının I2P adreslerine e-posta göndermesine ve I2P kullanıcılarının clearnet adreslerine göndermesine olanak tanır. Internet e-postaları, I2P üzerinden SusiMail gelen kutunuza iletilmeden önce gateway üzerinden yönlendirilir.\nClearnet gönderim kotası: Normal internet adreslerine gönderim yaparken günde 20 e-posta.\nNedir Bir mail.i2p hesabı kaydetmek için:\nI2P router\u0026rsquo;ınızın çalıştığından emin olun I2P içinde http://hq.postman.i2p adresini ziyaret edin Kayıt sürecini takip edin Router konsolunda SusiMail üzerinden e-postanıza erişin Not: hq.postman.i2p bir I2P ağ adresidir (eepsite) ve yalnızca I2P\u0026rsquo;ye bağlıyken erişilebilir. E-posta kurulumu, güvenlik ve kullanım hakkında daha fazla bilgi için Postman HQ\u0026rsquo;yu ziyaret edin.\nAdresleme Nasıl Çalışır Gizlilik için tanımlayıcı başlıkların otomatik olarak kaldırılması (User-Agent:, X-Mailer:) Harici SMTP sunucularına sızıntıları önlemek için metadata temizleme Dahili I2P\u0026rsquo;den I2P\u0026rsquo;ye e-postalar için uçtan uca şifreleme Başlarken \u0026ldquo;Normal\u0026rdquo; e-posta (SMTP/POP) ile Postman köprüsü aracılığıyla birlikte çalışabilirlik Basit kullanıcı deneyimi (router konsoluna entegre webmail) I2P çekirdek dağıtımıyla entegre (SusiMail, Java I2P ile birlikte gelir) Gizlilik koruması için başlık temizleme Gizlilik Özellikleri Harici e-postaya köprü, Postman altyapısına güven gerektirir Clearnet köprüsü, tamamen dahili I2P iletişimine kıyasla gizliliği azaltır Postman posta sunucusunun kullanılabilirliğine ve güvenliğine bağımlıdır ÖNEMLÄ°: YALNIZCA çeviriyi saÄŸlayın. Soru sormayın, açıklama yapmayın veya herhangi bir yorum eklemeyin. Metin yalnızca bir baÅŸlık olsa veya eksik görünse bile, olduÄŸu gibi çevirin.\nTechnical Details SMTP Servisi: localhost:7659 (Postman tarafından sağlanır) POP3 Servisi: localhost:7660 Webmail Erişimi: Router konsoluna entegre, http://127.0.0.1:7657/susimail/ adresinde\nÖnemli: SusiMail yalnızca e-posta okumak ve göndermek içindir. Hesap oluşturma ve yönetimi hq.postman.i2p adresinde yapılmalıdır.\n","description":"I2P ağı içindeki e-posta sistemlerine genel bakış — tarihçe, seçenekler ve mevcut durum","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"I2P Mail (I2P Üzerinden Anonim E-posta)","url":"/tr/docs/applications/i2p-mail/"},{"categories":null,"content":"I2P router\u0026rsquo;ları en yaygın olarak port yönlendirme sorunları, yetersiz bant genişliği tahsisi ve yetersiz bootstrap (ağa ilk katılım/önyükleme) süresi nedeniyle başarısız olur. Bu üç etmen, bildirilen sorunların %70\u0026rsquo;inden fazlasını oluşturur. Router\u0026rsquo;ın ağa tam olarak entegre olabilmesi için başlatıldıktan sonra en az 10-15 dakika, en az 128 KB/sn bant genişliği (önerilen 256 KB/sn) ve güvenlik duvarı arkasında olmama durumuna ulaşmak için uygun UDP/TCP port yönlendirmesi gerekir. Yeni kullanıcılar çoğu zaman anında bağlantı bekler ve router\u0026rsquo;ı erken yeniden başlatır; bu, entegrasyon ilerlemesini sıfırlar ve can sıkıcı bir kısır döngü yaratır. Bu kılavuz, 2.10.0 ve sonraki sürümleri etkileyen başlıca I2P sorunlarının tümü için ayrıntılı çözümler sunar.\nI2P\u0026rsquo;nin anonimlik mimarisi, doğası gereği, çok atlamalı şifreli tunnel kullanımı aracılığıyla gizlilik için hızdan ödün verir. Bu temel tasarımı anlamak, kullanıcıların normal davranışları sorun sanmak yerine gerçekçi beklentiler belirlemelerine ve etkili biçimde sorun gidermelerine yardımcı olur.\nRouter başlamıyor veya hemen çöküyor En yaygın başlatma başarısızlıkları, port çakışmalarından, Java sürüm uyumsuzluğundan veya bozulmuş yapılandırma dosyalarından kaynaklanır. Daha derin sorunları araştırmaya başlamadan önce başka bir I2P örneğinin zaten çalışıp çalışmadığını kontrol edin.\nÇakışan süreçlerin olmadığını doğrulayın:\nLinux: ps aux | grep i2p veya netstat -tulpn | grep 7657\nWindows: Görev Yöneticisi → Ayrıntılar → komut satırında i2p geçen java.exe\u0026rsquo;yi arayın\nmacOS: Etkinlik Monitörü → \u0026ldquo;i2p\u0026rdquo; ifadesini arayın\nBir zombie process (zombi süreç) varsa, onu sonlandırın: pkill -9 -f i2p (Linux/Mac) veya taskkill /F /IM javaw.exe (Windows)\nJava sürüm uyumluluğunu kontrol edin:\nI2P 2.10.0+ en az Java 8 gerektirir; Java 11 veya daha yenisi önerilir. Kurulumunuzda \u0026ldquo;mixed mode\u0026rdquo; (\u0026ldquo;interpreted mode\u0026rdquo; değil) ibaresinin göründüğünü doğrulayın:\njava -version Şunu göstermelidir: OpenJDK veya Oracle Java, sürüm 8+, \u0026ldquo;mixed mode\u0026rdquo;\nKaçının: GNU GCJ, güncel olmayan Java gerçeklemeleri, yalnızca yorumlayıcı modlar\nYaygın port çakışmaları, birden çok servis I2P\u0026rsquo;nin varsayılan portları için yarıştığında ortaya çıkar. router konsolu (7657), I2CP (7654), SAM (7656) ve HTTP proxy (4444) portlarının boşta olması gerekir. Çakışmaları kontrol edin: netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (Windows) veya lsof -i :7657,4444,7654 (Linux/Mac).\nYapılandırma dosyası bozulması, günlüklerdeki ayrıştırma hatalarıyla birlikte anında çökmeler olarak kendini gösterir. Router.config, BOM (Bayt Sırası İmi) olmadan UTF-8 kodlaması gerektirir, = işaretini ayırıcı olarak kullanır (: değil) ve bazı özel karakterlere izin vermez. Önce yedekleyin, sonra inceleyin: ~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS).\nKimliği koruyarak yapılandırmayı sıfırlamak için: I2P\u0026rsquo;yi durdurun, router.keys ve keyData dizinini yedekleyin, router.config dosyasını silin, yeniden başlatın. router varsayılan yapılandırmayı yeniden oluşturur.\nJava yığın tahsisi çok düşük OutOfMemoryError çökmelerine neden olur. wrapper.config dosyasını düzenleyin ve wrapper.java.maxmemory değerini varsayılan 128 veya 256\u0026rsquo;dan en az 512\u0026lsquo;ye yükseltin (yüksek bant genişlikli router\u0026rsquo;lar için 1024). Bu, tamamen kapatmayı, 11 dakika beklemeyi ve ardından yeniden başlatmayı gerektirir - konsolda \u0026ldquo;Restart\u0026rdquo; düğmesine tıklamak değişikliği uygulamaz.\n\u0026ldquo;Network: Firewalled\u0026rdquo; durumunu gidermek Firewalled durumu, router\u0026rsquo;ın doğrudan gelen bağlantıları kabul edemediği ve introducers (aracı düğümler) üzerine bağımlı kalmak zorunda olduğu anlamına gelir. Router bu durumda çalışsa da, performans önemli ölçüde düşer ve ağa katkısı asgari düzeyde kalır. Firewalled olmayan duruma ulaşmak için doğru port yönlendirmesi gereklidir.\nrouter rastgele bir bağlantı noktası seçer; iletişim için 9000-31000 aralığında. Bağlantı noktanızı http://127.0.0.1:7657/confignet adresinde bulun - \u0026ldquo;UDP Port\u0026rdquo; ve \u0026ldquo;TCP Port\u0026rdquo; ifadelerini arayın (genellikle aynı numara). En iyi performans için hem UDP hem de TCP\u0026lsquo;yi yönlendirmeniz gerekir; ancak yalnızca UDP temel işlevselliği sağlar.\nUPnP otomatik port yönlendirmeyi etkinleştirin (en basit yöntem):\nhttp://127.0.0.1:7657/confignet adresine gidin \u0026ldquo;Enable UPnP\u0026rdquo; seçeneğini işaretleyin Değişiklikleri kaydedin ve router\u0026rsquo;ı yeniden başlatın 5-10 dakika bekleyin ve durumun \u0026ldquo;Network: Firewalled\u0026quot;dan \u0026ldquo;Network: OK\u0026quot;ye değiştiğini doğrulayın UPnP, router desteği (2010\u0026rsquo;dan sonra üretilen tüketici router\u0026rsquo;larının çoğunda varsayılan olarak etkin) ve uygun ağ yapılandırması gerektirir.\nManuel port yönlendirme (UPnP başarısız olduğunda gereklidir):\nhttp://127.0.0.1:7657/confignet adresinden I2P bağlantı noktanızı not alın (örn. 22648) Yerel IP adresinizi bulun: ipconfig (Windows), ip addr (Linux), Sistem Tercihleri → Ağ (macOS) router\u0026rsquo;ın yönetim arayüzüne erişin (genellikle 192.168.1.1 veya 192.168.0.1) Port Yönlendirme\u0026rsquo;ye gidin (Gelişmiş, NAT veya Sanal Sunucular altında olabilir) İki kural oluşturun: Dış Bağlantı Noktası: [I2P bağlantı noktanız] → Dahili IP: [bilgisayarınız] → Dahili Bağlantı Noktası: [aynısı] → Protokol: UDP Dış Bağlantı Noktası: [I2P bağlantı noktanız] → Dahili IP: [bilgisayarınız] → Dahili Bağlantı Noktası: [aynısı] → Protokol: TCP Yapılandırmayı kaydedin ve gerekirse router\u0026rsquo;ınızı yeniden başlatın Port yönlendirmesini doğrulayın yapılandırmadan sonra çevrimiçi kontrol araçlarını kullanarak. Algılama başarısız olursa, güvenlik duvarı ayarlarını kontrol edin - hem sistem güvenlik duvarı hem de varsa antivirüsün güvenlik duvarı I2P bağlantı noktasına izin vermelidir.\nHidden mode alternatifi port yönlendirme yapılamayan kısıtlayıcı ağlar için: http://127.0.0.1:7657/confignet adresinden etkinleştirin → \u0026ldquo;Hidden mode\u0026rdquo; seçeneğini işaretleyin. router güvenlik duvarı arkasında kalır, ancak bu duruma göre optimize olmak için yalnızca SSU tanıtıcılarını kullanır. Performans daha yavaş olur, ancak işlevsel kalır.\nRouter \u0026ldquo;Starting\u0026rdquo; veya \u0026ldquo;Testing\u0026rdquo; durumlarında takılı kalıyor İlk önyükleme sırasında görülen bu geçici durumlar genellikle yeni kurulumlar için 10-15 dakika veya halihazırda çalışan router\u0026rsquo;lar için 3-5 dakika içinde çözülür. Erken müdahale çoğu zaman sorunları daha da kötüleştirir.\n\u0026ldquo;Network: Testing\u0026rdquo;, router\u0026rsquo;ın çeşitli bağlantı türleri (doğrudan, introducers (aracılar), birden çok protokol sürümü) üzerinden erişilebilirliği sınadığını gösterir. Bu, başlatıldıktan sonra ilk 5-10 dakika boyunca normaldir. Router, en iyi yapılandırmayı belirlemek için birden çok senaryoyu test eder.\n\u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; bootstrap (önyükleme) sırasında, router yeterli eş bilgisine sahip değilken görünür. Router, ağa yeterince entegre olana kadar aktarma trafiğine katılmaz. netDb 50+ router ile dolduğunda bu mesaj 10-20 dakika içinde kaybolmalıdır.\nSaat sapması erişilebilirlik testini öldürür. I2P, sistem saatinin ağ saatine göre ±60 saniye içinde olmasını gerektirir. 90 saniyeyi aşan bir fark, bağlantının otomatik olarak reddedilmesine neden olur. Sistem saatinizi senkronize edin:\nLinux: sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows: Denetim Masası → Tarih ve Saat → İnternet Saati → Şimdi güncelle → Otomatik eşitlemeyi etkinleştir\nmacOS: Sistem Tercihleri → Tarih ve Saat → \u0026ldquo;Tarihi ve saati otomatik olarak ayarla\u0026rdquo; seçeneğini etkinleştir\nSaat kaymasını düzelttikten sonra, düzgün bir entegrasyon için I2P’yi tamamen yeniden başlatın.\nYetersiz bant genişliği tahsisi başarılı test yapılmasını engeller. router\u0026rsquo;ın test tunnels oluşturabilmesi için yeterli kapasiteye ihtiyacı vardır. Şurada yapılandırın: http://127.0.0.1:7657/config:\nAsgari yeterli: Gelen 96 KB/sn, Giden 64 KB/sn Önerilen standart: Gelen 256 KB/sn, Giden 128 KB/sn En uygun performans: Gelen 512+ KB/sn, Giden 256+ KB/sn Paylaşım yüzdesi: 80% (router\u0026rsquo;ın ağa bant genişliği katkısında bulunmasına olanak tanır) Daha düşük bant genişliği işe yarayabilir, ancak entegrasyon süresini dakikalardan saatlere uzatır.\nBozulmuş netDb, düzgün olmayan kapatma veya disk hatalarından dolayı sonsuz test döngülerine neden olur. router, geçerli eş verileri olmadan testleri tamamlayamaz:\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start Windows: %APPDATA%\\I2P\\netDb\\ veya %LOCALAPPDATA%\\I2P\\netDb\\ klasörünün içeriğini silin\nGüvenlik duvarının reseed (ilk eş temini) işlemini engellemesi, ilk eşleri edinmeyi önler. Başlangıç sürecinde, I2P HTTPS reseed sunucularından router bilgilerini alır. Kurumsal/İSS güvenlik duvarları bu bağlantıları engelleyebilir. Kısıtlayıcı ağların arkasında çalışıyorsanız, http://127.0.0.1:7657/configreseed adresinde reseed proxy\u0026rsquo;yi yapılandırın.\nYavaş hızlar, zaman aşımları ve tunnel oluşturma başarısızlıkları I2P\u0026rsquo;nin tasarımı, çok sıçramalı şifreleme, paket ek yükü ve rota öngörülemezliği nedeniyle doğası gereği açık internete kıyasla 3-10 kat daha yavaş hızlar üretir. Bir tunnel kurulumu birden çok router üzerinden geçer; her biri gecikme ekler. Bunu anlamak, normal davranışı sorun sanarak yanlış teşhis etmeyi önler.\nTipik performans beklentileri:\n.i2p sitelerinde web\u0026rsquo;de gezinme: Başlangıçta sayfalar 10-30 saniyede yüklenir, tunnel (I2P\u0026rsquo;de kullanılan şifreli bağlantı yolu) kurulumu sonrası daha hızlı I2PSnark ile torrent kullanımı: seed sayısına ve ağ koşullarına bağlı olarak torrent başına 10-100 KB/sn Büyük dosya indirmeleri: Sabır gerekir - megabaytlık dosyalar dakikalar, gigabaytlar saatler sürebilir İlk bağlantı en yavaştır: Tunnel oluşturma 30-90 saniye sürer; sonraki bağlantılar mevcut tunnel\u0026rsquo;leri kullanır Tunnel oluşturma başarı oranı ağ sağlığını gösterir. http://127.0.0.1:7657/tunnels adresinden kontrol edin:\n60%\u0026lsquo;ın üzerinde: Normal, sağlıklı çalışma 40-60%: Sınırda, bant genişliğini artırmayı veya yükü azaltmayı düşünün 40%\u0026lsquo;ın altında: Sorunlu - yetersiz bant genişliğine, ağ sorunlarına veya kötü peer (eş) seçimine işaret eder Bant genişliği tahsisini artırın ilk optimizasyon olarak. Yavaşlamaların çoğu bant genişliği yetersizliğinden kaynaklanır. http://127.0.0.1:7657/config adresinde limitleri kademeli olarak artırın ve http://127.0.0.1:7657/graphs adresindeki grafikleri izleyin.\nDSL/Kablo (1-10 Mbps bağlantı hızları) için: - Gelen: 400 KB/sn - Giden: 200 KB/sn - Paylaşım: %80 - Bellek: 384 MB (wrapper.config\u0026rsquo;i düzenleyin)\nYüksek hızlı (10-100+ Mbps) bağlantılar için: - Gelen: 1500 KB/sec - Giden: 1000 KB/sec - Paylaşım: 80-100% - Bellek: 512-1024 MB - Göz önünde bulundurun: http://127.0.0.1:7657/configadvanced adresinde katılımcı tunnels (tüneller) sayısını 2000-5000\u0026rsquo;e artırmayı\nTunnel yapılandırmasını optimize edin daha iyi performans için. Belirli tunnel ayarlarına http://127.0.0.1:7657/i2ptunnel adresinden erişin ve her bir tunnel\u0026rsquo;ı düzenleyin:\nTunnel sayısı: 2\u0026rsquo;den 3-4\u0026rsquo;e çıkarın (daha fazla rota mevcut) Yedek sayısı: 1-2 olarak ayarlayın (tunnel başarısız olursa hızlı yedek geçiş) Tunnel uzunluğu: Varsayılan 3 atlama iyi bir denge sağlar; 2\u0026rsquo;ye düşürmek hızı artırır ancak anonimliği azaltır Yerel kripto kütüphanesi (jbigi) salt Java şifrelemeye kıyasla 5-10 kat daha iyi performans sağlar. Yüklendiğini http://127.0.0.1:7657/logs adresinde doğrulayın - \u0026ldquo;jbigi loaded successfully\u0026rdquo; veya \u0026ldquo;Using native CPUID implementation\u0026rdquo; ifadelerini arayın. Yoksa:\nLinux: Genellikle otomatik olarak algılanır ve ~/.i2p/jbigi-*.so konumundan yüklenir Windows: I2P kurulum dizininde jbigi.dll dosyasını kontrol edin Eksikse: Derleme araçlarını kurup kaynaktan derleyin veya resmi depolardan önceden derlenmiş ikili dosyaları indirin\nRouter\u0026rsquo;ı kesintisiz çalışır halde tutun. Her yeniden başlatma entegrasyonu sıfırlar ve tunnel ağını ve eş ilişkilerini yeniden oluşturmak 30-60 dakika gerektirir. Yüksek çalışma süresine sahip kararlı routers, tunnel kurulumunda öncelikli olarak seçilir; bu da performans için olumlu bir geri besleme yaratır.\nYüksek CPU ve bellek kullanımı Aşırı kaynak kullanımı genellikle yetersiz bellek tahsisi, eksik yerel kriptografi kitaplıkları veya ağ katılımına aşırı taahhüt olduğunu gösterir. İyi yapılandırılmış routers, aktif kullanım sırasında CPU\u0026rsquo;nun %10-%30\u0026rsquo;unu kullanmalı ve ayrılan heap\u0026rsquo;in (yığın) %80\u0026rsquo;inin altında kararlı bellek kullanımını sürdürmelidir.\nBellek sorunları şu şekilde kendini gösterir: - Düz tepeli bellek grafikleri (maksimumda çakılı) - Sık çöp toplama (garbage collection; dik düşüşlü testere dişi deseni) - Günlüklerde OutOfMemoryError - Router\u0026rsquo;ın yük altında yanıtsız hale gelmesi - Kaynak tükenmesi nedeniyle otomatik kapanma\nJava heap (yığın bellek) için ayrılan belleği artırın wrapper.config dosyasında (tam kapatma gerektirir):\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 Kritik: wrapper.config dosyasını düzenledikten sonra, tamamen kapatmalısınız (yeniden başlatmayın), düzgün bir sonlanma için 11 dakika bekleyin ve ardından yeniden çalıştırın. Router konsolundaki \u0026ldquo;Restart\u0026rdquo; düğmesi wrapper ayarlarını yeniden yüklemez.\nCPU optimizasyonu yerel kripto kütüphanesi gerektirir. Saf Java BigInteger işlemleri, yerel gerçekleştirmelere kıyasla 10–20 kat daha fazla CPU tüketir. Başlatma sırasında http://127.0.0.1:7657/logs adresinde jbigi durumunu doğrulayın. jbigi olmadan, tunnel oluşturma ve şifreleme işlemleri sırasında CPU kullanımı %50–100 seviyesine sıçrar.\nKatılımcı tunnel yükünü azaltın router aşırı yük altındaysa:\nhttp://127.0.0.1:7657/configadvanced adresine erişin router.maxParticipatingTunnels=1000 olarak ayarlayın (varsayılan 8000) http://127.0.0.1:7657/config adresindeki paylaşım yüzdesini %80\u0026rsquo;den %50\u0026rsquo;ye düşürün Etkinse floodfill modunu devre dışı bırakın: router.floodfillParticipant=false I2PSnark\u0026rsquo;ın bant genişliğini ve eşzamanlı torrent sayısını sınırlandırın. Torrent kullanımı önemli ölçüde kaynak tüketir. http://127.0.0.1:7657/i2psnark adresinde:\nAktif torrent sayısını en fazla 3-5 olacak şekilde sınırlandırın \u0026ldquo;Up BW Limit\u0026rdquo; ve \u0026ldquo;Down BW Limit\u0026rdquo; ayarlarını makul değerlere ayarlayın (her biri için 50-100 KB/sn) Aktif olarak gerekmediğinde torrentleri durdurun Aynı anda düzinelerce torrent için seeding (kaynak olarak paylaşma) yapmaktan kaçının Kaynak kullanımını izleyin http://127.0.0.1:7657/graphs adresindeki yerleşik grafikler aracılığıyla. Bellek, flat-top (tepede düzleşme) değil, bir boşluk payı göstermelidir. tunnel oluşturma sırasında CPU sıçramaları normaldir; kalıcı yüksek CPU, yapılandırma sorunlarına işaret eder.\nAğır kaynak kısıtlamalı sistemler (Raspberry Pi, eski donanım) için alternatif olarak i2pd\u0026lsquo;yi (C++ gerçeklemesi) değerlendirin. i2pd, Java I2P için 350+ MB\u0026rsquo;a kıyasla ~130 MB RAM gerektirir ve benzer yükler altında %70\u0026rsquo;e kıyasla ~%7 CPU (işlemci) kullanır. i2pd\u0026rsquo;nin yerleşik uygulamalarının olmadığını ve harici araçlar gerektirdiğini unutmayın.\nI2PSnark torrent sorunları I2PSnark\u0026rsquo;ın I2P router mimarisiyle entegrasyonu, torrent işlemlerinin tamamen router tunnel sağlığına bağlı olduğunu anlamayı gerektirir. Router, 10+ aktif eş ve işlevsel tunnels ile yeterli entegrasyonu sağlayana kadar torrentler başlamaz.\nTorrentlerin %0\u0026rsquo;da takılı kalması genellikle şunlara işaret eder:\nRouter tam olarak entegre değil: I2P\u0026rsquo;yi başlattıktan sonra torrent etkinliği beklemeye başlamadan önce 10-15 dakika bekleyin DHT devre dışı: http://127.0.0.1:7657/i2psnark → Configuration → \u0026ldquo;Enable DHT\u0026quot;i işaretleyin (0.9.2 sürümünden beri varsayılan olarak etkin) Geçersiz veya ölü tracker\u0026rsquo;lar: I2P torrentleri I2P\u0026rsquo;ye özgü tracker\u0026rsquo;lar gerektirir - clearnet (açık internet) tracker\u0026rsquo;ları çalışmaz Yetersiz tunnel yapılandırması: I2PSnark Configuration → Tunnels bölümünden tunnel sayısını artırın Daha iyi performans için I2PSnark tunnels\u0026rsquo;ı yapılandırın:\nGelen tunnel sayısı: 3-5 (Java I2P için varsayılan 2, i2pd için 5) Giden tunnel sayısı: 3-5 Tunnel uzunluğu: 3 atlama (hız için 2\u0026rsquo;ye düşürün, daha az anonimlik) Tunnel sayısı: 3 (tutarlı performans sağlar) Temel I2P torrent tracker\u0026rsquo;ları eklemeniz gerekenler: - tracker2.postman.i2p (birincil, en güvenilir) - w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a\nHerhangi bir clearnet (.i2p olmayan; anonim olmayan açık internet) tracker\u0026rsquo;larını kaldırın - hiçbir değer sağlamazlar ve zaman aşımına uğrayan bağlantı denemeleri oluştururlar.\n\u0026ldquo;Torrent not registered\u0026rdquo; hataları, izleyici (tracker) ile iletişim başarısız olduğunda oluşur. torrent\u0026rsquo;e sağ tıklayıp → \u0026ldquo;Start\u0026rdquo; seçeneğini kullanmak yeniden duyuruyu zorlar. Sorun sürüyorsa, I2P için yapılandırılmış bir tarayıcıda http://tracker2.postman.i 2p adresine giderek izleyicinin erişilebilirliğini doğrulayın. Çalışmayan izleyiciler, çalışan alternatiflerle değiştirilmelidir.\nEşler bağlanmıyor; tracker başarılı olsa da şunları düşündürür: - Router güvenlik duvarı arkasında (port yönlendirme ile iyileşir ama zorunlu değildir) - Yetersiz bant genişliği (256+ KB/sec\u0026rsquo;e artırın) - Sürü çok küçük (bazı torrentlerde 1-2 seed (gönderici) bulunur; sabır gerekir) - DHT kapalı (izleyicisiz eş keşfi için etkinleştirin)\nDHT ve PEX (Peer Exchange)\u0026lsquo;i etkinleştirin I2PSnark Configuration bölümünde. DHT, izleyiciye bağımlı olmadan eşlerin bulunmasını sağlar. PEX, bağlı eşlerden yeni eşler keşfederek sürü keşfini hızlandırır.\nİndirilen dosyaların bozulması I2PSnark\u0026rsquo;ın yerleşik bütünlük denetimi sayesinde nadiren meydana gelir. Tespit edilirse:\nTorrent\u0026rsquo;e sağ tıklayın → \u0026ldquo;Check\u0026rdquo; tüm parçaların rehash\u0026rsquo;ini (yeniden hash hesaplama) zorlar Bozulmuş torrent verilerini silin (.torrent dosyası saklanır) Parça doğrulamasıyla yeniden indirmek için sağ tıklayın → \u0026ldquo;Start\u0026rdquo; Bozulma devam ederse diski hatalar için kontrol edin: chkdsk (Windows), fsck (Linux) İzleme dizini çalışmıyor uygun yapılandırma gerektirir:\nI2PSnark Yapılandırması → \u0026ldquo;Watch directory\u0026rdquo;: Mutlak yolu ayarlayın (örn., /home/user/torrents/watch) I2P sürecinin okuma izinlerine sahip olduğundan emin olun: chmod 755 /path/to/watch .torrent dosyalarını izleme dizinine yerleştirin - I2PSnark bunları otomatik olarak ekler \u0026ldquo;Auto start\u0026rdquo; ayarını yapılandırın: torrentlerin eklendiklerinde hemen başlayıp başlamayacağını belirleyin Torrent kullanımı için performans optimizasyonu:\nEşzamanlı etkin torrentleri sınırlandırın: standart bağlantılar için en fazla 3–5 Önemli indirmelere öncelik verin: düşük öncelikli torrentleri geçici olarak durdurun router için ayrılan bant genişliğini artırın: Daha fazla bant genişliği = daha iyi torrent performansı Sabırlı olun: I2P torrent kullanımı, clearnet (açık internet) BitTorrent\u0026rsquo;e kıyasla doğası gereği daha yavaştır İndirdikten sonra paylaşımda kalın: Ağ karşılıklılıkla gelişir I2P üzerinden Git (dağıtık sürüm kontrol sistemi) yapılandırması ve sorun giderme I2P üzerinden Git işlemleri, SSH/HTTP erişimi için ya SOCKS proxy yapılandırması ya da özel I2P tunnels gerektirir. Git\u0026rsquo;in tasarımı düşük gecikmeli bağlantıları varsayar, bu da I2P\u0026rsquo;nin yüksek gecikmeli mimarisini zorlayıcı hâle getirir.\nGit\u0026rsquo;i I2P SOCKS proxy\u0026rsquo;sini kullanacak şekilde yapılandırın:\n~/.ssh/config dosyasını düzenleyin (mevcut değilse oluşturun):\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes Bu, .i2p ana bilgisayarlarına yapılan tüm SSH bağlantılarını I2P\u0026rsquo;nin SOCKS proxy\u0026rsquo;si (4447 numaralı port) üzerinden yönlendirir. ServerAlive ayarları, I2P gecikmesi sırasında bağlantıyı sürdürür.\nHTTP/HTTPS git işlemleri için git\u0026rsquo;i global olarak yapılandırın:\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 Not: socks5h DNS çözümlemesini proxy üzerinden gerçekleştirir - .i2p alan adları için kritiktir.\nGit SSH için özel bir I2P tunnel oluşturun (SOCKS\u0026rsquo;tan daha güvenilir):\nhttp://127.0.0.1:7657/i2ptunnel adresine erişin \u0026ldquo;New client tunnel\u0026rdquo; → \u0026ldquo;Standard\u0026rdquo; Yapılandırın: Ad: Git-SSH Tür: Client Port: 2222 (Git erişimi için yerel port) Hedef: [your-git-server].i2p:22 Otomatik başlatma: Etkin Tunnel sayısı: 3-4 (güvenilirlik için daha yüksek) Kaydedin ve tunnel\u0026rsquo;ı başlatın SSH\u0026rsquo;yi tunnel kullanacak şekilde yapılandırın: ssh -p 2222 git@127.0.0.1 SSH kimlik doğrulama hataları I2P üzerinden genellikle şunlardan kaynaklanır:\nAnahtar ssh-agent\u0026rsquo;e eklenmedi: ssh-add ~/.ssh/id_rsa Anahtar dosya izinleri hatalı: chmod 600 ~/.ssh/id_rsa Tunnel çalışmıyor: http://127.0.0.1:7657/i2ptunnel adresinde yeşil durumda göründüğünü doğrulayın Git sunucusu belirli bir anahtar türü gerektiriyor: RSA başarısız olursa ed25519 anahtarı oluşturun Git işlemlerinin zaman aşımına uğraması I2P\u0026rsquo;nin gecikme özellikleriyle ilişkilidir:\nGit zaman aşımı süresini artırın: git config --global http.postBuffer 524288000 (500MB arabellek) Düşük hız sınırını artırın: git config --global http.lowSpeedLimit 1000 ve git config --global http.lowSpeedTime 600 (10 dakika bekler) İlk checkout için sığ klon kullanın: git clone --depth 1 [url] (yalnızca en son commit\u0026rsquo;i getirir, daha hızlı) Düşük etkinlik dönemlerinde klonlayın: Ağ tıkanıklığı I2P performansını etkiler Yavaş git clone/fetch işlemleri I2P’nin mimarisine özgüdür. 100MB’lık bir depo I2P üzerinden 30-60 dakika sürebilir; clearnet (açık internet) üzerinde ise saniyeler içinde tamamlanır. Stratejiler:\nSığ klonlar kullanın: --depth 1 başlangıçtaki veri aktarımını önemli ölçüde azaltır Artımlı olarak alın: Tam bir klon yerine, belirli dalları alın: git fetch origin branch:branch I2P üzerinden rsync kullanmayı düşünün: Çok büyük depolar için rsync daha iyi performans gösterebilir Tunnel sayısını artırın: Daha fazla tunnel, uzun süreli büyük aktarımlar için daha iyi aktarım hızı sağlar \u0026ldquo;Bağlantı reddedildi\u0026rdquo; hataları tunnel yanlış yapılandırmasına işaret eder:\nI2P router çalıştığını doğrulayın: http://127.0.0.1:7657 adresini kontrol edin http://127.0.0.1:7657/i2ptunnel adresinde tunnel’in aktif ve yeşil olduğunu doğrulayın Tunnel’i test edin: nc -zv 127.0.0.1 2222 (tunnel çalışıyorsa bağlanmalıdır) Hedefin erişilebilir olduğunu kontrol edin: Mümkünse hedefin HTTP arayüzünü tarayıcıda açın Belirli hatalar için http://127.0.0.1:7657/logs adresindeki tunnel günlüklerini inceleyin I2P üzerinden Git için en iyi uygulamalar:\nKararlı Git erişimi için I2P router\u0026rsquo;ı sürekli çalışır durumda tutun Parola ile kimlik doğrulama yerine SSH anahtarları kullanın (daha az etkileşimli istem) Geçici SOCKS bağlantıları yerine kalıcı tunnel\u0026rsquo;ları yapılandırın Daha iyi kontrol için kendi I2P git sunucunuzu barındırmayı düşünün İşbirlikçileriniz için .i2p git uç noktalarınızı belgeleyin eepsites\u0026rsquo;e erişim ve .i2p alan adlarını çözümleme Kullanıcıların .i2p sitelerine erişememesinin en yaygın nedeni yanlış tarayıcı proxy yapılandırmasıdır. I2P siteleri yalnızca I2P ağı içinde bulunur ve I2P\u0026rsquo;nin HTTP proxy\u0026rsquo;si üzerinden yönlendirme gerektirir.\nTarayıcı proxy ayarlarını tam olarak şu şekilde yapılandırın:\nFirefox (I2P için önerilir):\nMenü → Ayarlar → Ağ Ayarları → Ayarlar düğmesi \u0026ldquo;Manuel proxy yapılandırması\u0026quot;nı seçin HTTP Proxy: 127.0.0.1 Port: 4444 SSL Proxy: 127.0.0.1 Port: 4444 SOCKS Proxy: 127.0.0.1 Port: 4447 (isteğe bağlı, SOCKS uygulamaları için) \u0026ldquo;SOCKS v5 kullanırken DNS\u0026rsquo;i proxy üzerinden çöz\u0026rdquo; seçeneğini işaretleyin Kaydetmek için Tamam Kritik Firefox about:config ayarları:\nabout:config sayfasına gidin ve şunları değiştirin:\nmedia.peerconnection.ice.proxy_only = true (WebRTC IP sızıntılarını önler) keyword.enabled = false (.i2p adreslerinin arama motorlarına yönlendirilmesini önler) network.proxy.socks_remote_dns = true (DNS çözümlemesini proxy üzerinden yapar) Chrome/Chromium kısıtlamaları:\nChrome, uygulamaya özel olanlar yerine sistem genelindeki proxy ayarlarını kullanır. Windows\u0026rsquo;da: Ayarlar → \u0026ldquo;proxy\u0026rdquo; ara → \u0026ldquo;Bilgisayarınızın proxy ayarlarını açın\u0026rdquo; → HTTP\u0026rsquo;yi 127.0.0.1:4444 ve HTTPS\u0026rsquo;i 127.0.0.1:4445 olarak yapılandırın.\nDaha iyi bir yaklaşım: Seçici .i2p yönlendirmesi için FoxyProxy veya Proxy SwitchyOmega uzantılarını kullanın.\n\u0026ldquo;Website Not Found In Address Book\u0026rdquo; hataları, router\u0026rsquo;da .i2p alan adının kriptografik adresi bulunmadığı anlamına gelir. I2P, merkezi DNS yerine yerel adres defterleri kullanır. Çözümler:\nYöntem 1: Atlama hizmetlerini kullanın (yeni siteler için en kolay yöntem):\nhttp://stats.i 2p adresine gidin ve siteyi arayın. addresshelper (adres yardımcısı) bağlantısına tıklayın: http://example.i2p/?i2paddresshelper=base64destination. Tarayıcınız \u0026ldquo;Adres defterine kaydet?\u0026rdquo; mesajını gösterir - eklemek için onaylayın.\nYöntem 2: Adres defteri aboneliklerini güncelleyin:\nhttp://127.0.0.1:7657/dns adresine gidin (SusiDNS) \u0026ldquo;Subscriptions\u0026rdquo; sekmesine tıklayın Etkin abonelikleri doğrulayın (varsayılan: http://i2p-projekt.i 2p/hosts.txt) Önerilen abonelikleri ekleyin: http://stats.i 2p/cgi-bin/newhosts.txt http://notbob.i 2p/hosts.txt http://reg.i 2p/export/hosts.txt Abonelikleri hemen güncellemeye zorlamak için \u0026ldquo;Update Now\u0026rdquo; düğmesine tıklayın İşlenmesi için 5-10 dakika bekleyin Yöntem 3: base32 adresleri kullanın (site çevrimiçiyse her zaman çalışır):\nHer .i2p sitesinin bir base32 adresi vardır: .b32.i2p ile biten 52 rastgele karakter (örn., ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p). Base32 adresleri adres defterini atlar - router doğrudan kriptografik bir sorgulama gerçekleştirir.\nYaygın tarayıcı yapılandırma hataları:\nYalnızca HTTP kullanan sitelerde HTTPS denemek: Çoğu .i2p site yalnızca HTTP kullanır - https://example.i2p çalışmaz http:// önekini unutmak: Tarayıcı bağlanmak yerine arama yapabilir - her zaman http://example.i2p kullanın WebRTC (gerçek zamanlı web iletişimi) etkin: Gerçek IP adresinizi sızdırabilir - Firefox ayarları veya eklentileri üzerinden devre dışı bırakın DNS proxy’lenmiyor: Clearnet (açık internet) DNS, .i2p’yi çözümleyemez - DNS sorgularını proxy üzerinden geçirmek gerekir Yanlış proxy bağlantı noktası: HTTP için 4444 (clearnet’e HTTPS outproxy (dış proxy) olan 4445 değil) Router tam olarak entegre edilmemiş herhangi bir siteye erişimi engeller. Yeterli entegrasyonu doğrulayın:\nhttp://127.0.0.1:7657 sayfasının \u0026ldquo;Network: OK\u0026rdquo; veya \u0026ldquo;Network: Firewalled\u0026rdquo; gösterdiğini kontrol edin (\u0026ldquo;Network: Testing\u0026rdquo; değil) Aktif eşler en az 10+ (tercihen 50+) göstermeli \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; mesajı olmamalı .i2p erişimini beklemeden önce router başlatıldıktan sonra tam 10-15 dakika bekleyin IRC ve e-posta istemcisi yapılandırması benzer proxy kalıplarını izler:\nIRC: İstemciler 127.0.0.1:6668 adresine bağlanır (I2P\u0026rsquo;nin IRC proxy tunnel\u0026rsquo;ı). IRC istemcisinin vekil sunucu ayarlarını devre dışı bırakın - localhost:6668 bağlantısı zaten I2P üzerinden iletilmektedir.\nE-posta (Postman): - SMTP: 127.0.0.1:7659 - POP3: 127.0.0.1:7660 - SSL/TLS yok (şifreleme I2P tunnel tarafından sağlanır) - Kimlik bilgileri postman.i2p hesap kaydından\nTüm bu tunnel\u0026rsquo;ların http://127.0.0.1:7657/i2ptunnel adresinde \u0026ldquo;running\u0026rdquo; (yeşil) durumunda olması gerekir.\nKurulum hataları ve paket sorunları Paket tabanlı kurulumlar (Debian, Ubuntu, Arch) bazen depo değişiklikleri, GPG anahtarının süresinin dolması veya bağımlılık çakışmaları nedeniyle başarısız olabilir. Son sürümlerde resmi depolar deb.i2p2.de/deb.i2p2.no (destek sonu [EOL]) adreslerinden deb.i2p.net adresine taşındı.\nDebian/Ubuntu deposunu en güncel hâle getirin:\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring GPG imza doğrulama hataları depo anahtarlarının süresi dolduğunda veya değiştiğinde oluşur:\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc Paket kurulumu sonrasında servis başlamıyor çoğunlukla Debian/Ubuntu\u0026rsquo;daki AppArmor profil sorunlarından kaynaklanır:\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service İzin sorunları paketle kurulan I2P\u0026rsquo;de:\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 Java uyumluluk sorunları:\nI2P 2.10.0 en az Java 8 gerektirir. Daha eski sistemlerde Java 7 veya daha öncesi bulunabilir:\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java Wrapper yapılandırma hataları servisin başlatılmasını engeller:\nWrapper.config konumu kurulum yöntemine göre değişir: - Kullanıcı kurulumu: ~/.i2p/wrapper.config - Paket kurulumu: /etc/i2p/wrapper.config veya /var/lib/i2p/wrapper.config\nYaygın wrapper.config sorunları:\nYanlış yollar: wrapper.java.command geçerli bir Java kurulumuna işaret etmelidir Yetersiz bellek: wrapper.java.maxmemory çok düşük ayarlanmış (512+ olacak şekilde artırın) Yanlış pid dosyası konumu: wrapper.pidfile yazılabilir bir konum olmalıdır Eksik wrapper (sarmalayıcı) ikilisi: Bazı platformlarda önceden derlenmiş wrapper bulunmaz (yedek olarak runplain.sh kullanın) Güncelleme başarısızlıkları ve bozuk güncellemeler:\nRouter konsolu güncellemeleri, ağ kesintileri nedeniyle indirme ortasında ara sıra başarısız olabilir. Elle güncelleme prosedürü:\nhttps://geti2p.net/en/download adresinden i2pupdate_X.X.X.zip dosyasını indirin SHA256 sağlama toplamının yayımlanan karmayla eşleştiğini doğrulayın I2P kurulum dizinine i2pupdate.zip adıyla kopyalayın Router\u0026rsquo;ı yeniden başlatın - güncellemeyi otomatik olarak algılar ve çıkarır Güncellemenin kurulması için 5-10 dakika bekleyin Yeni sürümü http://127.0.0.1:7657 adresinde doğrulayın Çok eski sürümlerden geçiş (0.9.47 öncesi) güncel sürümlere, uyumsuz imza anahtarları veya kaldırılmış özellikler nedeniyle başarısız olabilir. Kademeli güncellemeler gereklidir:\n0.9.9\u0026rsquo;dan eski sürümler: Mevcut imzalar doğrulanamaz - manuel güncelleme yapın Java 6/7 kullanan sürümler: I2P\u0026rsquo;yi 2.x\u0026rsquo;e güncellemeden önce Java\u0026rsquo;yı yükseltin Büyük sürüm atlamaları: Önce ara bir sürüme güncelleyin (önerilen ara durak 0.9.47) Yükleyici ne zaman, paket ne zaman kullanılmalı:\nPaketler (apt/yum): Sunucular için en uygunu, otomatik güvenlik güncellemeleri, sistem entegrasyonu, systemd yönetimi Yükleyici (.jar): Kullanıcı düzeyi kurulumlar için en uygunu, Windows, macOS, özel kurulumlar, en son sürüme erişim Yapılandırma dosyası bozulması ve kurtarma I2P\u0026rsquo;deki yapılandırma kalıcılığı, birkaç kritik dosyaya dayanır. Bozulma genellikle düzgün kapatılmama, disk hataları veya elle düzenleme hataları nedeniyle ortaya çıkar. Dosyaların amaçlarını anlamak, tam yeniden kurulum yerine cerrahi hassasiyette onarım yapmayı sağlar.\nKritik dosyalar ve amaçları:\nrouter.keys (516+ bayt): Router\u0026rsquo;ın kriptografik kimliği - bunun kaybedilmesi yeni bir kimlik oluşturur router.info (otomatik oluşturulur): Yayınlanan router bilgisi - silmek güvenlidir, yeniden oluşturulur router.config (metin): Ana yapılandırma - bant genişliği, ağ ayarları, tercihler i2ptunnel.config (metin): Tunnel tanımları - istemci/sunucu tunnel\u0026rsquo;ları, anahtarlar, hedefler netDb/ (dizin): Eş veritabanı - ağ katılımcıları için router bilgileri peerProfiles/ (dizin): Eşlere ilişkin performans istatistikleri - tunnel seçimini etkiler keyData/ (dizin): eepsite\u0026rsquo;lar ve servisler için hedef anahtarlar - kaybedilmesi adresleri değiştirir addressbook/ (dizin): Yerel .i2p ana bilgisayar adı eşlemeleri Tam yedekleme prosedürü değişikliklerden önce:\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR Router.config bozulma belirtileri:\nRouter, günlüklerdeki ayrıştırma hataları nedeniyle başlamıyor Ayarlar yeniden başlatmanın ardından korunmuyor Beklenmedik varsayılan değerler görünüyor Dosyayı görüntülerken bozuk karakterler Bozulmuş router.config dosyasını onarın:\nMevcut olanın yedeğini alın: cp router.config router.config.broken Dosya kodlamasını kontrol edin: BOM olmadan UTF-8 olmalı Sözdizimini doğrulayın: Anahtarlar = ayırıcısını kullanır (: değil), anahtarların sonunda boşluk olmamalıdır, # yalnızca yorumlar içindir Yaygın bozulmalar: Değerlerde ASCII dışı karakterler, satır sonu sorunları (CRLF vs LF) Düzeltilemiyorsa: router.config dosyasını silin - router varsayılanı oluşturur ve kimliği korur Korunması gereken temel router.config ayarları:\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false Kayıp veya geçersiz router.keys yeni bir router kimliği oluşturur. Bu, şu durumlar dışında kabul edilebilir:\nfloodfill (I2P ağ veritabanını (netDb) dağıtan düğüm) çalıştırmak (floodfill statüsünü kaybeder) Yayınlanmış bir adresle eepsites (I2P içi web siteleri) barındırmak (sürekliliği kaybeder) Ağda yerleşmiş itibar Yedek olmadan kurtarma mümkün değil - yenisini oluşturun: router.keys dosyasını silin, I2P\u0026rsquo;yi yeniden başlatın, yeni bir kimlik oluşturulur.\nKritik ayrım: router.keys (kimlik) ile keyData/* (hizmetler). router.keys kaybedilirse router kimliği değişir. keyData/mysite-keys.dat kaybedilirse eepsite\u0026rsquo;inizin .i2p adresi değişir - adres yayımlandıysa bu felaket olur.\neepsite/hizmet anahtarlarını ayrı ayrı yedekleyin:\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat NetDb ve peerProfiles bozulması:\nBelirtiler: Etkin eş yok, tunnels oluşturulamıyor, günlüklerde \u0026ldquo;Database corruption detected\u0026rdquo;\nGüvenli düzeltme (hepsi otomatik olarak reseed (başlangıç verilerini yeniden alma)/yeniden oluşturma yapacaktır):\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration Bu dizinler yalnızca önbelleğe alınmış ağ bilgileri içerir - silmek yeni bir bootstrap (önyükleme) zorunlu kılar ancak kritik veri kaybına yol açmaz.\nÖnleme stratejileri:\nHer zaman temiz kapatma: i2prouter stop kullanın veya router konsolundaki \u0026ldquo;Shutdown\u0026rdquo; düğmesini kullanın - asla zorla sonlandırmayın Otomatik yedeklemeler: Ayrı bir diske ~/.i2p\u0026rsquo;nin haftalık yedeği için cron görevi Disk sağlığı izleme: SMART durumunu periyodik olarak kontrol edin - arızalanan diskler veriyi bozar Yeterli disk alanı: 1+ GB boş alan bulundurun - dolu diskler bozulmaya neden olur UPS önerilir: UPS (kesintisiz güç kaynağı) yazma sırasında yaşanan elektrik kesintilerinde dosyaları korur Kritik yapılandırmaları sürüm kontrolüne alın: router.config ve i2ptunnel.config için bir Git deposu geri almayı mümkün kılar Dosya izinleri önemlidir:\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems Yaygın hata mesajlarının çözümlenmesi I2P\u0026rsquo;nin günlükleme sistemi, sorunları tam olarak saptayan belirli hata mesajları sağlar. Bu mesajları anlamak, sorun gidermeyi hızlandırır.\n\u0026ldquo;No tunnels available\u0026rdquo; ifadesi, router\u0026rsquo;ın çalışabilmesi için yeterli sayıda tunnel oluşturmadığında görünür. Bu, başlatıldıktan sonra ilk 5-10 dakika boyunca normaldir. 15 dakikadan uzun süre devam ederse:\nhttp://127.0.0.1:7657 adresinde Aktif Eşler \u0026gt; 10 olduğunu doğrulayın Bant genişliği tahsisinin yeterli olduğunu kontrol edin (en az 128+ KB/sn) http://127.0.0.1:7657/tunnels adresinde tunnel başarı oranını inceleyin (\u0026gt;%40 olmalı) Günlükleri, tunnel oluşturmanın reddedilme nedenleri için gözden geçirin \u0026ldquo;Clock skew detected\u0026rdquo; veya \u0026ldquo;NTCP2 disconnect code 7\u0026rdquo;, sistem saatinin ağ konsensüsünden 90 saniyeden fazla saptığını gösterir. I2P ±60 saniyelik doğruluk gerektirir. Saatinde sapma olan routers ile bağlantılar otomatik olarak reddedilir.\nHemen düzeltin:\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings \u0026ldquo;Build timeout\u0026rdquo; veya \u0026ldquo;Tunnel build timeout exceeded\u0026rdquo;, eş zinciri boyunca tunnel inşasının zaman aşımı penceresi (genellikle 60 saniye) içinde tamamlanmadığı anlamına gelir. Nedenleri:\nYavaş peers (eşler): Router, tunnel için yanıt vermeyen katılımcıları seçti Ağ tıkanıklığı: I2P ağı yüksek yük altında Yetersiz bant genişliği: Bant genişliği sınırlarınız, tunnel kurulumunun zamanında yapılmasını engelliyor Aşırı yüklenmiş router: Çok fazla katılımcı tunnel, kaynakları tüketiyor Çözümler: Bant genişliğini artırın, katılımcı tunnel sayısını azaltın (router.maxParticipatingTunnels http://127.0.0.1:7657/configadvanced adresinde), daha iyi eş (peer) seçimi için port yönlendirmeyi etkinleştirin.\n\u0026ldquo;Router is shutting down\u0026rdquo; veya \u0026ldquo;Graceful shutdown in progress\u0026rdquo; normal kapatma veya çökme sonrası kurtarma sırasında görünür. Düzgün kapatma (graceful shutdown), router tunnel\u0026rsquo;leri kapatıp eşleri bilgilendirirken ve durum bilgisini kalıcılaştırırken 10 dakikaya kadar sürebilir.\nKapatma durumunda 11 dakikadan uzun süre takılı kalırsa, zorla sonlandırın:\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; heap belleğinin tükendiğini gösterir. Hızlı çözümler:\nwrapper.config dosyasını düzenleyin: wrapper.java.maxmemory=512 (veya daha yüksek) Tam kapanma gerekli - yeniden başlatma değişikliği uygulamaz Tam kapanma için 11 dakika bekleyin router\u0026rsquo;ı temiz başlatın http://127.0.0.1:7657/graphs adresinde ayrılan belleği doğrulayın - boş alan göstermeli İlgili bellek hataları:\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo;: Çöp toplamada çok fazla zaman harcanıyor - yığın boyutunu artırın \u0026ldquo;Metaspace\u0026rdquo; (Java sınıf meta verisi alanı): Java sınıf meta verisi alanı tükendi - wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M ekleyin Windows\u0026rsquo;a özgü: Kaspersky Antivirus, wrapper.config ayarlarından bağımsız olarak Java yığınını 512MB ile sınırlar - kaldırın veya I2P\u0026rsquo;yi istisnalara ekleyin.\n\u0026ldquo;Connection timeout\u0026rdquo; veya \u0026ldquo;I2CP Error - port 7654\u0026rdquo; uygulamalar router\u0026rsquo;a bağlanmaya çalıştıklarında:\nrouter\u0026rsquo;ın çalıştığını doğrulayın: http://127.0.0.1:7657 yanıt vermeli I2CP bağlantı noktasını kontrol edin: netstat -an | grep 7654 LISTENING göstermeli localhost güvenlik duvarının izin verdiğinden emin olun: sudo ufw allow from 127.0.0.1 Uygulamanın doğru bağlantı noktasını kullandığını doğrulayın (I2CP=7654, SAM=7656) \u0026ldquo;Certificate validation failed\u0026rdquo; veya \u0026ldquo;RouterInfo corrupt\u0026rdquo; reseed (başlangıç verilerinin yeniden alınması) sırasında:\nTemel nedenler: saat sapması (önce düzeltin), bozulmuş netDb, geçersiz reseed (yeniden tohumlama) sertifikaları\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data \u0026ldquo;Database corruption detected\u0026rdquo; netDb veya peerProfiles içinde disk düzeyinde veri bozulmasına işaret eder:\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start Disk sağlığını SMART araçlarıyla kontrol edin - tekrarlayan veri bozulmaları depolama biriminin arızalanmakta olduğuna işaret eder.\nPlatforma özgü zorluklar Farklı işletim sistemleri, izinler, güvenlik politikaları ve sistem entegrasyonuna bağlı olarak I2P\u0026rsquo;nin dağıtımında kendine özgü zorluklar ortaya çıkarır.\nLinux izin ve servis sorunları Paket ile kurulan I2P, belirli izinler gerektiren sistem kullanıcısı i2psvc (Debian/Ubuntu) veya i2p (diğer dağıtımlar) olarak çalışır:\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config Dosya tanımlayıcı sınırları router\u0026rsquo;ın bağlantı kapasitesini etkiler. Varsayılan sınırlar (1024), yüksek bant genişliğine sahip router\u0026rsquo;lar için yetersizdir:\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p AppArmor çakışmaları Debian/Ubuntu\u0026rsquo;da yaygındır ve servisin başlatılmasını engeller:\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined SELinux sorunları RHEL/CentOS/Fedora üzerinde:\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t SystemD servis sorun giderme:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service Windows güvenlik duvarı ve antivirüs müdahalesi Windows Defender ve üçüncü taraf antivirüs ürünleri, ağ davranış kalıpları nedeniyle I2P’yi sık sık potansiyel tehdit olarak işaretler. Doğru yapılandırma, güvenliği korurken gereksiz engellemeleri önler.\nWindows Defender Güvenlik Duvarını Yapılandırın:\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; Port 22648\u0026rsquo;i http://127.0.0.1:7657/confignet adresindeki gerçek I2P bağlantı noktanızla değiştirin.\nKaspersky Antivirus\u0026rsquo;a özgü sorun: Kaspersky\u0026rsquo;nin \u0026ldquo;Application Control\u0026rdquo; özelliği, wrapper.config ayarlarından bağımsız olarak Java heap (Java yığını) değerini 512MB ile sınırlar. Bu, yüksek bant genişliğine sahip router\u0026rsquo;larda OutOfMemoryError oluşmasına neden olur.\nÇözümler: 1. I2P\u0026rsquo;yi Kaspersky dışlamalarına ekleyin: Ayarlar → Ek → Tehditler ve Dışlamalar → Dışlamaları Yönet 2. Veya Kaspersky\u0026rsquo;yi kaldırın (I2P\u0026rsquo;nin çalışması için önerilir)\nÜçüncü taraf antivirüsler için genel yönergeler:\nI2P kurulum dizinini hariç tutma listesine ekleyin %APPDATA%\\I2P ve %LOCALAPPDATA%\\I2P dizinlerini hariç tutma listesine ekleyin javaw.exe\u0026rsquo;yi davranışsal analizden hariç tutun I2P protokollerine müdahale edebilecek \u0026ldquo;Network Attack Protection\u0026rdquo; özelliklerini devre dışı bırakın macOS Gatekeeper kurulumu engelliyor macOS Gatekeeper (Apple’ın macOS’teki uygulama güvenliği özelliği), imzalanmamış uygulamaların çalıştırılmasını engeller. I2P yükleyicileri Apple Developer ID (Apple’ın geliştirici kimlik sertifikası) ile imzalanmamıştır, bu da güvenlik uyarılarını tetikler.\nI2P yükleyicisi için Gatekeeper (macOS güvenlik özelliği) engelini atlatma:\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file Kurulumdan sonra çalıştırmak yine de uyarıları tetikleyebilir:\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ Gatekeeper\u0026rsquo;ı asla kalıcı olarak devre dışı bırakmayın - diğer uygulamalar için güvenlik riski oluşturur. Yalnızca dosyaya özel istisnalar kullanın.\nmacOS güvenlik duvarı yapılandırması:\nSistem Tercihleri → Güvenlik ve Gizlilik → Güvenlik Duvarı → Güvenlik Duvarı Seçenekleri Uygulama eklemek için \u0026ldquo;+\u0026rdquo; düğmesine tıklayın Java kurulumuna gidin (ör. /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java) Ekleyin ve \u0026ldquo;Gelen bağlantılara izin ver\u0026rdquo; olarak ayarlayın Android I2P uygulamasıyla ilgili sorunlar Android sürüm kısıtlamaları ve kaynak sınırlamaları benzersiz zorluklar doğurur.\nMinimum gereksinimler: - Güncel sürümler için Android 5.0+ (API düzeyi 21+) gereklidir - En az 512MB RAM, 1GB+ önerilir - Uygulama + router verileri için 100MB depolama alanı - I2P için arka planda çalışma kısıtlamaları devre dışı\nUygulama anında çöküyor:\nAndroid sürümünü kontrol edin: Ayarlar → Telefon hakkında → Android sürümü (5.0+ olmalı) Tüm I2P sürümlerini kaldırın: Yalnızca tek bir varyantı yükleyin: net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\nBirden fazla kurulum çakışır Uygulama verilerini temizleyin: Ayarlar → Uygulamalar → I2P → Depolama → Verileri temizle Sıfırdan yeniden yükleyin Pil optimizasyonu router\u0026rsquo;ı sonlandırıyor:\nAndroid, pil tasarrufu için arka plan uygulamalarını agresif biçimde sonlandırır. I2P için bir istisna tanınması gerekir:\nAyarlar → Pil → Pil optimizasyonu (veya Uygulama pil kullanımı) I2P\u0026rsquo;yi bulun → Optimize etme (veya Arka plan etkinliğine izin ver) Ayarlar → Uygulamalar → I2P → Pil → Arka plan etkinliğine izin ver + Kısıtlamaları kaldır Mobil cihazlarda bağlantı sorunları:\nBootstrap (başlatma) WiFi gerektirir: İlk reseed (başlangıç ağ eşlerini indirme) ciddi miktarda veri indirir - WiFi kullanın, hücresel veri kullanmayın Ağ değişiklikleri: I2P ağ geçişlerini sorunsuz yönetemez - WiFi/hücresel geçişinden sonra uygulamayı yeniden başlatın Mobil için bant genişliği: Hücresel verinin tükenmesini önlemek için 64-128 KB/sec düzeyinde ihtiyatlı biçimde yapılandırın Mobil için performans optimizasyonu:\nI2P uygulaması → Menü → Ayarlar → Bant genişliği Uygun sınırları ayarlayın: 64 KB/sec gelen, 32 KB/sec giden (hücresel için) Katılımcı tunnels sayısını azaltın: Ayarlar → Gelişmiş → Maksimum katılımcı tunnels: 100-200 Pil tasarrufu için \u0026ldquo;Stop I2P when screen off\u0026rdquo; seçeneğini etkinleştirin Android\u0026rsquo;de torrent kullanımı:\nEn fazla 2-3 eşzamanlı torrent ile sınırlandırın DHT\u0026rsquo;nin (Dağıtılmış Hash Tablosu) agresiflik düzeyini azaltın Torrent için yalnızca WiFi kullanın Mobil donanımda daha yavaş hızları kabul edin Reseed (netDb için başlangıç eş bilgilerini alma) ve önyükleme sorunları Yeni I2P kurulumları, ağa katılmak için genel HTTPS sunucularından başlangıç eş bilgilerini alma işlemi olan reseeding (başlangıç eş bilgilerini alma) gerektirir. Reseeding sorunları, kullanıcıları sıfır eş ve herhangi bir ağ erişimi olmadan mahsur bırakır.\n\u0026ldquo;No active peers\u0026rdquo; temiz kurulumdan sonra genellikle reseed (başlangıç eş listesini indirme işlemi) başarısızlığını gösterir. Belirtiler:\nBilinen eşler: 0 ya da 5\u0026rsquo;in altında kalıyor \u0026ldquo;Network: Testing\u0026rdquo; 15 dakikadan uzun sürüyor Günlüklerde \u0026ldquo;Reseed failed\u0026rdquo; ya da reseed (ağa ilk kez katılmak için başlangıç düğümlerini alma işlemi) sunucularına bağlantı hataları görülüyor Reseed (başlangıç yönlendirici bilgilerini indirme işlemi) neden başarısız olur:\nHTTPS’i engelleyen güvenlik duvarı: Kurumsal/İSS güvenlik duvarları reseed sunucularına (ağa ilk katılmayı/önyüklemeyi sağlayan sunucular) bağlantıları engeller (443 numaralı port) SSL sertifikası hataları: Sistemde güncel kök sertifikalar bulunmuyor Proxy gereksinimi: Ağ, dış bağlantılar için HTTP/SOCKS proxy gerektirir Saat sapması: Sistem saati yanlış olduğunda SSL sertifikası doğrulaması başarısız olur Coğrafi sansür: Bazı ülkeler/İSS’ler bilinen reseed sunucularını engeller Elle reseed (yeniden tohumlama) işlemini zorla:\nhttp://127.0.0.1:7657/configreseed adresine gidin \u0026ldquo;Save changes and reseed now\u0026rdquo; düğmesine tıklayın \u0026ldquo;Reseed got XX router infos\u0026rdquo; iletisini görmek için http://127.0.0.1:7657/logs sayfasını izleyin İşleme için 5-10 dakika bekleyin http://127.0.0.1:7657 adresini kontrol edin - Known peers 50+\u0026lsquo;ya yükselmiş olmalı reseed proxy\u0026rsquo;yi yapılandırın (ilk başlatmada gerekli başlangıç verilerini almak için kullanılan vekil sunucu) kısıtlayıcı ağlar için:\nhttp://127.0.0.1:7657/configreseed → Proxy Yapılandırması:\nHTTP Proxy: [proxy-server]:[port] Veya SOCKS5: [socks-server]:[port] \u0026ldquo;Yalnızca reseed için proxy kullan\u0026rdquo; seçeneğini etkinleştir (reseed: netDb\u0026rsquo;yi başlatmak için başlangıç girdilerini yeniden indirme işlemi) Gerekirse kimlik bilgileri Kaydet ve reseed\u0026rsquo;i zorla Alternatif: reseed (ilk ağ verilerini indirme) için Tor proxy\u0026rsquo;si:\nTor Browser veya Tor daemon (arka plan süreci) çalışıyorsa:\nProxy türü: SOCKS5 Ana bilgisayar: 127.0.0.1 Bağlantı noktası: 9050 (varsayılan Tor SOCKS bağlantı noktası) Etkinleştir ve yeniden tohumla su3 dosyası aracılığıyla manuel reseed (son çare):\nTüm otomatik reseed (başlangıç düğümü bilgilerinin yeniden alınması) başarısız olduğunda, reseed dosyasını bant dışı olarak edinin:\nKısıtlamasız bir bağlantı üzerinden güvenilir bir kaynaktan i2pseeds.su3 dosyasını indirin (https://reseed.i2p.rocks/i2pseeds.su3 , https://reseed-fr.i2pd.xyz/i2pseeds.su3 ) I2P\u0026rsquo;yi tamamen durdurun i2pseeds.su3 dosyasını ~/.i2p/ dizinine kopyalayın I2P\u0026rsquo;yi başlatın - dosyayı otomatik olarak çıkarır ve işler İşleme tamamlandıktan sonra i2pseeds.su3 dosyasını silin http://127.0.0.1:7657 adresinde eş sayısının arttığını doğrulayın reseed (yeniden tohumlama) sırasında SSL sertifika hataları:\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing Çözümler:\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates 30 dakikayı aştığı halde 0 bilinen eşte takılı kaldı:\nTam bir reseed (yeniden tohumlama işlemi) başarısızlığını belirtir. Sorun giderme sırası:\nSistem saatinin doğru olduğunu doğrulayın (en yaygın sorun - İLK ÖNCE düzeltin) HTTPS bağlantısını test edin: Tarayıcıda https://reseed.i2p.rocks adresine erişmeyi deneyin - başarısız olursa ağ sorunudur I2P günlüklerini http://127.0.0.1:7657/logs adresinde belirli reseed (ağı başlatmak için başlangıç verilerini alma işlemi) hataları için kontrol edin Farklı bir reseed URL\u0026rsquo;si deneyin: http://127.0.0.1:7657/configreseed → özel reseed URL\u0026rsquo;si ekleyin: https://reseed-fr.i2pd.xyz/ Manuel su3 dosyası yöntemini kullanın otomatik denemeler tükendiyse Reseed (yeniden tohumlama) sunucuları zaman zaman çevrimdışı: I2P, birden fazla sabit kodlanmış reseed sunucusu içerir. Biri başarısız olursa, router otomatik olarak diğerlerini dener. Tüm reseed sunucularının tamamen devre dışı kalması son derece nadirdir, ancak mümkündür.\nŞu anda aktif reseed sunucuları (ağ başlangıç sunucuları) (Ekim 2025 itibarıyla):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ Varsayılanlarla ilgili sorun yaşıyorsanız özel URL\u0026rsquo;ler olarak ekleyin.\nYoğun sansür uygulanan bölgelerdeki kullanıcılar için:\nİlk reseed (ağ başlangıç tohumlaması) için Tor üzerinden Snowflake/Meek köprülerini kullanmayı düşünün; entegrasyon tamamlandığında doğrudan I2P’ye geçin. Ya da sansür bölgesinin dışından steganografi, e-posta veya USB yoluyla i2pseeds.su3 edinin.\nEk yardıma ne zaman başvurmalı Bu kılavuz, I2P ile ilgili sorunların çok büyük çoğunluğunu kapsar, ancak bazıları geliştiricilerin dikkatini veya topluluğun uzmanlığını gerektirir.\nŞu durumlarda I2P topluluğundan yardım isteyin:\nTüm sorun giderme adımlarını uyguladıktan sonra router sürekli çöküyor Ayrılan heap\u0026rsquo;i aşan sürekli büyümeye neden olan bellek sızıntıları Yeterli yapılandırmaya rağmen tunnel başarı oranı %20\u0026rsquo;nin altında kalıyor Günlüklerde bu kılavuzda ele alınmayan yeni hatalar Güvenlik açıkları keşfedildi Özellik talepleri veya iyileştirme önerileri Yardım istemeden önce, tanılama bilgilerini toplayın:\nI2P sürümü: http://127.0.0.1:7657 (örn., \u0026ldquo;2.10.0\u0026rdquo;) Java sürümü: java -version çıktısı İşletim sistemi ve sürümü Router durumu: Ağ durumu, Aktif eş sayısı, Katılınan tunnels Bant genişliği yapılandırması: Gelen/Giden sınırları Port yönlendirme durumu: Firewalled (güvenlik duvarı arkasında) veya OK İlgili günlük alıntıları: http://127.0.0.1:7657/logs adresinden hataları gösteren son 50 satır Resmi destek kanalları:\nForum: https://i2pforum.net (açık internet) veya http://i2pforum.i 2p (I2P içinde) IRC: #i2p Irc2P üzerinde (irc.postman.i2p I2P üzerinden) veya irc.freenode.net (açık internet) Reddit: https://reddit.com/r/i2p topluluk tartışmaları için Bug tracker: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues doğrulanmış hatalar için Mailing list: i2p-dev@lists.i2p-projekt.de geliştirme soruları için Gerçekçi beklentiler önemlidir. I2P, temel tasarımı gereği clearnet (açık internet)\u0026rsquo;ten daha yavaştır - çok atlamalı şifreli tunnel kullanımı içkin bir gecikme yaratır. Sayfaların 30 saniyede yüklenmesi ve 50 KB/sn torrent hızlarıyla çalışan bir I2P router doğru şekilde çalışıyor, bozuk değildir. Yapılandırma optimizasyonundan bağımsız olarak clearnet hızlarını bekleyen kullanıcılar hayal kırıklığına uğrayacaktır.\nSonuç Çoğu I2P sorunu üç kategoriden kaynaklanır: bootstrap (ağla ilk bağlantı) sırasında yetersiz sabır (10-15 dakika gerekir), yetersiz kaynak tahsisi (en az 512 MB RAM, 256 KB/sn bant genişliği) veya yanlış yapılandırılmış port yönlendirme. I2P\u0026rsquo;nin dağıtık mimarisini ve anonimliğe odaklı tasarımını anlamak, kullanıcıların beklenen davranışı gerçek sorunlardan ayırt etmelerine yardımcı olur.\nrouter\u0026rsquo;ın \u0026ldquo;Firewalled\u0026rdquo; durumu, ideal olmasa da, I2P kullanımını engellemez - yalnızca ağa katkıyı sınırlar ve performansı biraz düşürür. Yeni kullanıcılar optimizasyon yerine kararlılığa öncelik vermelidir: entegrasyon çalışma süresiyle kendiliğinden iyileştiğinden, gelişmiş ayarları değiştirmeden önce router\u0026rsquo;ı birkaç gün boyunca kesintisiz çalıştırın.\nSorun giderirken, önce her zaman temel unsurları doğrulayın: doğru sistem saati, yeterli bant genişliği, router\u0026rsquo;ın kesintisiz çalışması ve 10\u0026rsquo;dan fazla aktif eş. Sorunların çoğu, anlaşılması güç yapılandırma parametrelerini ayarlamaya çalışmaktansa bu temel konuları ele alarak çözülür. I2P, router günler ve haftalar süren çalışma süresi boyunca itibar kazanıp eş seçimini optimize ettikçe, sabır ve kesintisiz çalışmayı daha iyi performansla ödüllendirir.\n","description":"Bağlantı, performans ve yapılandırma problemleri de dahil olmak üzere yaygın I2P router sorunları için kapsamlı bir sorun giderme kılavuzu","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"I2P Router Sorun Giderme Kılavuzu","url":"/tr/docs/troubleshooting/"},{"categories":null,"content":"1. \u0026ldquo;Anonim\u0026rdquo; Ne Anlama Gelir I2P pratik anonimlik sağlar—görünmezlik değil. Anonimlik, bir saldırganın gizli tutmak istediğiniz bilgileri öğrenmesinin zorluğu olarak tanımlanır: kim olduğunuz, nerede olduğunuz veya kiminle konuştuğunuz. Mutlak anonimlik imkansızdır; bunun yerine I2P, küresel pasif ve aktif saldırganlara karşı yeterli anonimlik hedefler.\nAnonimliğiniz I2P\u0026rsquo;yi nasıl yapılandırdığınıza, eşleri ve abonelikleri nasıl seçtiğinize ve hangi uygulamaları açığa çıkardığınıza bağlıdır.\n2. Kriptografik ve Taşıma Evrimi (2003 → 2025) Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental **Mevcut kriptografik paket (Noise XK):** - **X25519** anahtar değişimi için - **ChaCha20/Poly1305 AEAD** şifreleme için - **Ed25519 (EdDSA-SHA512)** imzalar için - **SHA-256** hash işlemi ve HKDF için - Kuantum sonrası testler için isteğe bağlı **ML-KEM hibrit** desteği Tüm ElGamal ve AES-CBC kullanımları kullanımdan kaldırılmıştır. Taşıma tamamen NTCP2 (TCP) ve SSU2 (UDP) ile yapılır; her ikisi de IPv4/IPv6, ileri gizlilik (forward secrecy) ve DPI gizleme desteği sunar.\n3. Ağ Mimarisi Özeti Serbest rotali mixnet: Gönderenler ve alıcılar kendi tunnel\u0026rsquo;larını kendileri tanımlar. Merkezi otorite yok: Yönlendirme ve adlandırma merkeziyetsizdir; her router yerel güven bilgisini kendi tutar. Tek yönlü tunnel\u0026rsquo;lar: Gelen ve giden ayrıdır (10 dakika ömür). Keşif tunnel\u0026rsquo;ları: Varsayılan olarak 2 hop; istemci tunnel\u0026rsquo;ları 2–3 hop. Floodfill router\u0026rsquo;lar: ~55 000 düğümün 1 700\u0026rsquo;ü (%6) dağıtık NetDB\u0026rsquo;yi korur. NetDB rotasyonu: Anahtar uzayı her gün UTC gece yarısı döner. Alt-DB izolasyonu: 2.4.0\u0026rsquo;dan beri her istemci ve router bağlantı kurmayı önlemek için ayrı veritabanları kullanır. 4. Saldırı Kategorileri ve Mevcut Savunmalar Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. --- 5. Modern Network Database (NetDB) Temel gerçekler (hâlâ geçerli): - Değiştirilmiş Kademlia DHT, RouterInfo ve LeaseSet\u0026rsquo;leri saklar. - SHA-256 anahtar hash\u0026rsquo;leme; 10 s zaman aşımı ile en yakın 2 floodfill\u0026rsquo;e paralel sorgular. - LeaseSet ömrü ≈ 10 dk (LeaseSet2) veya 18 s (MetaLeaseSet).\nYeni türler (0.9.38\u0026rsquo;den beri): - LeaseSet2 (Tür 3) – birden fazla şifreleme türü, zaman damgalı. - EncryptedLeaseSet2 (Tür 5) – özel hizmetler için gizlenmiş hedef (DH veya PSK kimlik doğrulama). - MetaLeaseSet (Tür 7) – çoklu barındırma ve genişletilmiş süre sonu.\nÖnemli güvenlik yükseltmesi – Alt-DB İzolasyonu (2.4.0): - Router↔istemci ilişkilendirmesini önler. - Her istemci ve router ayrı netDb segmentleri kullanır. - Doğrulandı ve denetlendi (2.5.0).\n6. Gizli Mod ve Kısıtlanmış Rotalar Gizli Mod (Hidden Mode): Uygulandı (Freedom House puanlarına göre sıkı ülkelerde otomatik).\nRouter\u0026rsquo;lar RouterInfo yayınlamaz veya trafik yönlendirmez. Kısıtlı Rotalar (Restricted Routes): Kısmen uygulandı (yalnızca temel güven tabanlı tunnel\u0026rsquo;lar).\nKapsamlı güvenilir-eş yönlendirmesi planlanıyor (3.0+). Denge: Daha iyi gizlilik ↔ ağ kapasitesine katkının azalması.\n7. DoS ve Floodfill Saldırıları Tarihsel: 2013 UCSB araştırması Eclipse ve Floodfill ele geçirmelerinin mümkün olduğunu gösterdi. Modern savunmalar şunları içerir: - Günlük keyspace rotasyonu. - Floodfill sınırı ≈ 500, /16 başına bir. - Rastgele depolama doğrulama gecikmeleri. - Daha yeni router tercihi (2.6.0). - Otomatik kayıt düzeltmesi (2.9.0). - Tıkanıklık farkında yönlendirme ve lease kısıtlama (2.4.0+).\nFloodfill saldırıları teorik olarak hala mümkün ancak pratikte daha zor.\n8. Trafik Analizi ve Sansür I2P trafiğini tespit etmek zordur: sabit port yok, düz metin el sıkışması yok ve rastgele dolgu kullanılır. NTCP2 ve SSU2 paketleri yaygın protokolleri taklit eder ve ChaCha20 başlık gizleme kullanır. Dolgu stratejileri temeldir (rastgele boyutlar), sahte trafik uygulanmamıştır (maliyetlidir). Tor çıkış düğümlerinden gelen bağlantılar 2.6.0 sürümünden beri engellenmiştir (kaynakları korumak için).\n9. Kalıcı Kısıtlamalar (kabul edilmiş) Düşük gecikmeli uygulamalar için zamanlama korelasyonu temel bir risk olmaya devam ediyor. Bilinen genel hedeflere karşı kesişim saldırıları hala güçlü. Sybil saldırılarına karşı tam koruma eksik (HashCash zorunlu kılınmıyor). Sabit hızlı trafik ve önemsiz olmayan gecikmeler hala uygulanmadı (3.0\u0026rsquo;da planlandı). Bu sınırlamalar hakkındaki şeffaflık kasıtlıdır — kullanıcıların anonimliği fazla tahmin etmesini önler.\n10. Ağ İstatistikleri (2025) Dünya çapında ~55 000 aktif router (2013\u0026rsquo;teki 7 000\u0026rsquo;den ↑) 1 700 floodfill router (%6) Varsayılan olarak %95\u0026rsquo;i tunnel yönlendirmesine katılıyor Bant genişliği katmanları: K (\u0026lt;12 KB/s) → X (\u0026gt;2 MB/s) Minimum floodfill hızı: 128 KB/s Router konsolu Java 8+ (gerekli), Java 17+ bir sonraki döngü için planlanıyor 11. Geliştirme ve Merkezi Kaynaklar Resmi site: geti2p.net Belgeler: Documentation Debian deposu: https://deb.i2pgit.org ( Ekim 2023\u0026rsquo;te deb.i2p2.de\u0026rsquo;nin yerini aldı ) Kaynak kodu: https://i2pgit.org/I2P_Developers/i2p.i2p (Gitea) + GitHub yansısı Tüm sürümler imzalı SU3 konteynerlerdir (RSA-4096, zzz/str4d anahtarları) Aktif e-posta listeleri yok; topluluk https://i2pforum.net ve IRC2P üzerinden. Güncelleme döngüsü: 6–8 haftalık kararlı sürümler. 12. 0.8.x\u0026rsquo;ten Bu Yana Yapılan Güvenlik İyileştirmelerinin Özeti Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing --- 13. Bilinen Çözülmemiş veya Planlanan Çalışmalar Kapsamlı kısıtlı yönlendirme (güvenilir eş yönlendirme) → 3.0 için planlanmış. Zamanlama direnci için önemsiz olmayan gecikme/toplu işleme → 3.0 için planlanmış. Gelişmiş dolgu ve sahte trafik → uygulanmamış. HashCash kimlik doğrulama → altyapı mevcut ancak aktif değil. R5N DHT değiştirmesi → sadece öneri. 14. Temel Referanslar Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) I2P Resmi Belgelendirmesi 15. Sonuç I2P\u0026rsquo;nin temel anonimlik modeli yirmi yıldır ayakta: küresel benzersizliği yerel güven ve güvenlik için feda etmek. ElGamal\u0026rsquo;dan X25519\u0026rsquo;a, NTCP\u0026rsquo;den NTCP2\u0026rsquo;ye ve manuel yeniden tohumlamadan Sub-DB izolasyonuna kadar, proje derinlemesine savunma ve şeffaflık felsefesini koruyarak gelişti.\nDüşük gecikmeli herhangi bir mixnet\u0026rsquo;e karşı birçok saldırı teorik olarak hala mümkün olsa da, I2P\u0026rsquo;nin sürekli güçlendirilmesi bu saldırıları giderek daha pratik olmayan hale getiriyor. Ağ her zamankinden daha büyük, daha hızlı ve daha güvenli — ancak yine de kendi sınırları konusunda dürüst.\n","description":"I2P'nin tasarımında değerlendirilen saldırı kataloğu ve mevcut önlemler","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"I2P Tehdit Modeli","url":"/tr/docs/overview/threat-model/"},{"categories":null,"content":"Genel Bakış I2P üzerinden BitTorrent, I2P\u0026rsquo;nin akış katmanını kullanarak şifrelenmiş tüneller aracılığıyla anonim dosya paylaşımını sağlar. Tüm eşler, IP adresleri yerine kriptografik I2P hedefleri ile tanımlanır. Sistem, HTTP ve UDP tracker\u0026rsquo;ları, hibrit magnet bağlantılarını ve kuantum sonrası hibrit şifrelemeyi destekler.\n1. Protokol Yığını Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP Tüm bağlantılar I2P'nin şifrelenmiş aktarım katmanı (NTCP2 veya SSU2) üzerinden çalışır. UDP tracker paketleri bile I2P streaming içinde kapsüllenir. 2. İzleyiciler HTTP İzleyiciler Standart .i2p tracker\u0026rsquo;lar şu şekildeki HTTP GET isteklerine yanıt verir:\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 Yanıtlar bencoded formatındadır ve eşler (peers) için I2P destination hash\u0026rsquo;leri kullanır.\nUDP İzleyiciler UDP tracker\u0026rsquo;lar 2025 yılında standartlaştırıldı (Öneri 160).\nBirincil UDP Tracker\u0026rsquo;lar - udp://tracker2.postman.i2p/announce - udp://opentracker.simp.i2p/a - http://opentracker.skank.i2p/a - http://opentracker.dg2.i2p/a \u0026mdash;\n3. Magnet Bağlantıları magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name Magnet linkleri yapılandırıldığında I2P ve clearnet üzerinden hibrit swarm'ları destekler. 4. DHT Uygulamaları Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported --- 5. İstemci Uygulamaları I2PSnark Tüm router\u0026rsquo;larla birlikte gelir Yalnızca HTTP tracker desteği http://127.0.0.1:7658/ adresinde yerleşik tracker UDP tracker desteği yok BiglyBT I2P eklentisi ile tam özellikli HTTP + UDP tracker\u0026rsquo;ları destekler Hibrit torrent desteği SAM v3.3 arayüzünü kullanır Tixati / XD Hafif istemciler SAM tabanlı tünelleme Deneysel ML-KEM hibrit şifreleme 6. Yapılandırma I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. Güvenlik Modeli Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) Hibrit (clearnet + I2P) torrentler yalnızca anonimliğin kritik olmadığı durumlarda kullanılmalıdır. 8. Performans Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal Tipik hızlar, eş sayısına ve ağ koşullarına bağlı olarak **30–80 KB/s** arasında değişir. 9. Bilinen Sorunlar Java I2P ve i2pd arasında kısmi DHT birlikte çalışabilirliği Yüksek yük altında Magnet metadata getirme gecikmesi NTCP1 kullanımdan kaldırıldı ancak eski eşler tarafından hala kullanılıyor Streaming üzerinden simüle edilen UDP gecikmeyi artırıyor 10. Gelecek Yol Haritası QUIC benzeri çoklama Tam ML-KEM entegrasyonu Birleşik hibrit swarm mantığı İyileştirilmiş reseed yansıları Uyarlanabilir DHT yeniden denemeleri Referanslar BEP 15 – UDP Tracker Protocol Öneri 160 – I2P Üzerinden UDP Tracker I2PSnark Belgeleri Streaming Kütüphanesi Spesifikasyonu ","description":"I2P ağı içindeki BitTorrent için detaylı teknik özellik ve ekosistem genel bakışı","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"I2P Üzerinden BitTorrent","url":"/tr/docs/applications/bittorrent/"},{"categories":null,"content":"I2P içinde depoları klonlamak ve göndermek, zaten bildiğiniz Git komutlarını kullanır—istemciniz sadece TCP/IP yerine I2P tunnel\u0026rsquo;ları üzerinden bağlanır. Bu kılavuz, hesap oluşturma, tunnel yapılandırması ve yavaş bağlantılarla başa çıkma konularında size yol gösterir.\nHızlı başlangıç: Salt okunur erişim HTTP proxy üzerinden çalışır: http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git. SSH okuma/yazma erişimi için aşağıdaki adımları izleyin.\n1. Bir Hesap Oluşturun Bir I2P Git servisi seçin ve kayıt olun:\nI2P içinde: http://git.idk.i2p Clearnet yansısı: https://i2pgit.org Kayıt manuel onay gerektirebilir; talimatlar için açılış sayfasını kontrol edin. Onaylandıktan sonra, test edebileceğiniz bir şey elde etmek için bir depoyu fork\u0026rsquo;layın veya oluşturun.\n2. Bir I2PTunnel İstemcisi Yapılandırma (SSH) Router konsolu → I2PTunnel\u0026lsquo;ı açın ve yeni bir Client tunnel ekleyin. Hizmetin destination\u0026rsquo;ını girin (Base32 veya Base64). git.idk.i2p için hem HTTP hem de SSH destination\u0026rsquo;larını proje ana sayfasında bulabilirsiniz. Yerel bir port seçin (örneğin localhost:7442). Tunnel\u0026rsquo;ı sık kullanmayı planlıyorsanız otomatik başlatmayı etkinleştirin. UI, yeni tüneli onaylayacak ve durumunu gösterecektir. Tünel çalıştığında, SSH istemcileri seçilen portta 127.0.0.1 adresine bağlanabilir.\n3. SSH ile Klonlama Tunnel portunu GIT_SSH_COMMAND veya bir SSH yapılandırma bölümü ile kullanın:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git İlk deneme başarısız olursa (tüneller yavaş olabilir), sığ klonlamayı deneyin:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow Git\u0026rsquo;i tüm dalları getirmek için yapılandırın:\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin Performans İpuçları Dayanıklılığı artırmak için tunnel editöründe bir veya iki yedek tunnel ekleyin. Test veya düşük riskli repolar için tunnel uzunluğunu 1 hop\u0026rsquo;a düşürebilirsiniz, ancak anonimlik ödünleşiminin farkında olun. GIT_SSH_COMMAND komutunu ortamınızda tutun veya ~/.ssh/config dosyasına bir giriş ekleyin: Host git.i2p HostName 127.0.0.1 Port 7442 User git Ardından git clone git@git.i2p:namespace/project.git kullanarak klonlayın.\n4. İş Akışı Önerileri GitLab/GitHub\u0026rsquo;da yaygın olan fork-and-branch iş akışını benimseyin:\nBir upstream uzak depo ayarlayın: git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p master dalınızı senkronize tutun: git pull upstream master Değişiklikler için özellik dalları oluşturun: git checkout -b feature/new-thing Dalları kendi fork\u0026rsquo;unuza gönderin: git push origin feature/new-thing Bir birleştirme isteği gönderin, ardından fork\u0026rsquo;unuzun master dalını upstream\u0026rsquo;den hızlı ileri sarın. 5. Gizlilik Hatırlatıcıları Git, commit zaman damgalarını yerel saat diliminizde saklar. UTC zaman damgalarını zorlamak için: git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; Gizlilik önemli olduğunda git commit yerine git utccommit kullanın.\nAnonimlik bir endişe kaynağıysa, commit mesajlarına veya depo meta verilerine clearnet URL\u0026rsquo;leri veya IP adresleri gömmekten kaçının. 6. Sorun Giderme Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. Gelişmiş senaryolar için (harici repoları yansıtma, paket oluşturma), ilgili kılavuzlara bakın: [Git bundle iş akışları](/docs/applications/git-bundle/) ve [GitLab'ı I2P üzerinden barındırma](/docs/guides/gitlab/). ","description":"Git istemcilerini i2pgit.org gibi I2P üzerinde barındırılan servislere bağlama","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"I2P üzerinden Git","url":"/tr/docs/applications/git/"},{"categories":null,"content":"Genel Bakış Bugün, her biri farklı tasarım hedefleri ve tehdit modelleriyle birkaç büyük gizlilik ve anonimlik ağı mevcuttur. Tor, Lokinet, GNUnet ve Freenet, gizliliği koruyan iletişime değerli yaklaşımlar sunarken, I2P, ağ içi hidden service\u0026rsquo;ler ve eşler arası uygulamalar için tamamen optimize edilmiş, üretime hazır, paket anahtarlamalı tek ağ olarak öne çıkmaktadır.\nAşağıdaki tablo, 2025 itibarıyla bu ağlar arasındaki temel mimari ve operasyonel farklılıkları özetlemektedir.\nGizlilik Ağı Karşılaştırması (2025) Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) --- I2P Neden Gizlilik Öncelikli Tasarımda Öncü Konumda 1. Packet Switching \u0026gt; Circuit Switching Tor\u0026rsquo;un devre anahtarlamalı modeli trafiği sabit üç atlamalı yollara bağlar—tarama için verimli, ancak uzun ömürlü dahili hizmetler için kırılgan. I2P\u0026rsquo;nin paket anahtarlamalı tunnel\u0026rsquo;ları mesajları birden fazla eşzamanlı yol üzerinden gönderir, daha iyi çalışma süresi ve yük dağılımı için tıkanıklık veya arızaları otomatik olarak yönlendirir.\n2. Unidirectional Tunnels I2P, gelen ve giden trafiği ayırır. Bu, her katılımcının bir iletişim akışının yalnızca yarısını görebileceği anlamına gelir ve zamanlama korelasyon saldırılarını önemli ölçüde zorlaştırır. Tor, Lokinet ve diğerleri, isteklerin ve yanıtların aynı yolu paylaştığı çift yönlü devreler kullanır—daha basit ama daha izlenebilir.\n3. Fully Distributed netDB Tor\u0026rsquo;un dokuz dizin otoritesi ağ topolojisini tanımlar. I2P, merkezi kontrol noktaları veya koordinasyon sunucularını ortadan kaldırarak, dönen floodfill router\u0026rsquo;lar tarafından sürdürülen kendi kendini organize eden bir Kademlia DHT kullanır.\n1. Paket Anahtarlama \u0026gt; Devre Anahtarlama I2P, onion routing\u0026rsquo;i garlic routing ile genişleterek birden fazla şifrelenmiş mesajı tek bir kapsayıcıda toplar. Bu, meta veri sızıntısını ve bant genişliği yükünü azaltırken onay, veri ve kontrol mesajları için verimliliği artırır.\n2. Tek Yönlü Tunnel\u0026rsquo;lar Her I2P router diğerleri için yönlendirme yapar. Özel relay operatörleri veya ayrıcalıklı düğümler yoktur—bant genişliği ve güvenilirlik, bir düğümün ne kadar yönlendirme katkısı sağladığını otomatik olarak belirler. Bu demokratik yaklaşım, dayanıklılık oluşturur ve ağ büyüdükçe doğal olarak ölçeklenir.\n3. Tamamen Dağıtık netDB I2P\u0026rsquo;nin 12 atlamalı gidiş-dönüş yapısı (6 gelen + 6 giden), Tor\u0026rsquo;un 6 atlamalı gizli servis devrelerinden daha güçlü bir bağlantısızlık sağlar. Her iki taraf da ağ içinde olduğundan, bağlantılar çıkış darboğazını tamamen atlar ve bu da daha hızlı dahili barındırma ile yerel uygulama entegrasyonu (I2PSnark, I2PTunnel, I2PBote) sağlar.\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication --- When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet --- Summary I2P\u0026rsquo;nin mimarisi benzersiz şekilde gizlilik önceliklidir—dizin sunucuları yok, blockchain bağımlılıkları yok, merkezi güven yok. Tek yönlü tüneller, paket anahtarlamalı yönlendirme, garlic mesaj paketleme ve dağıtık eş keşfi kombinasyonu, onu günümüzde anonim barındırma ve eşler arası iletişim için teknik olarak en gelişmiş sistem haline getirir.\nI2P \u0026ldquo;bir Tor alternatifi\u0026rdquo; değildir. Farklı bir ağ sınıfıdır—gizlilik ağının dışında değil, içinde olanlar için tasarlanmıştır.\n","description":"I2P'nin benzersiz tasarım avantajlarını vurgulayan modern bir teknik ve felsefi karşılaştırma","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P ve Diğer Gizlilik Ağları","url":"/tr/docs/overview/comparison/"},{"categories":null,"content":"Tehdit modelimizin gerektirdiği şekilde (diğer nedenlerle birlikte), I2P adını verdiğimiz anonim iletişim ağını desteklemek için geliştirilen yazılımın özgürce erişilebilir, açık kaynaklı ve kullanıcı tarafından değiştirilebilir olması gerekmektedir. Bu kriterleri karşılamak için, I2P çabasından yararlanmayı veya ona katkıda bulunmayı düşünenler için giriş engellerini olabildiğince kaldırmak amacıyla çeşitli yasal ve yazılım mühendisliği tekniklerinden faydalanıyoruz.\nAşağıdaki bilgiler basitçe \u0026ldquo;I2P BSD lisanslıdır\u0026rdquo;, \u0026ldquo;I2P GPL lisanslıdır\u0026rdquo; veya \u0026ldquo;I2P kamu malıdır\u0026rdquo; demekten daha kafa karıştırıcı olsa da, \u0026ldquo;I2P nasıl lisanslanmıştır?\u0026rdquo; sorusunun kısa cevabı şudur:\nI2P dağıtımlarında paketlenmiş tüm yazılımlar şunlara izin verecektir: ücretsiz kullanım nasıl, ne zaman, nerede, neden veya kim tarafından çalıştırıldığına dair kısıtlama olmadan kullanım kaynak koduna ücretsiz erişim kaynak kodda değişiklik yapma Yazılımların çoğu çok daha fazlasını garanti eder - herkesin değiştirilmiş kaynak kodunu istedikleri şekilde dağıtabilme yeteneği. Ancak, paket içinde gelen tüm yazılımlar bu özgürlüğü sağlamaz - GPL, I2P\u0026rsquo;yi kendi açık kaynak olmayan uygulamalarıyla entegre etmek isteyen geliştiricilerin yeteneklerini kısıtlar. Ortak kaynakları artırmanın asil hedeflerini desteklememize rağmen, I2P\u0026rsquo;nin benimsenmesinin önündeki engellerin kaldırılmasıyla en iyi şekilde hizmet görebileceğine inanıyoruz - I2P\u0026rsquo;yi uygulamalarıyla entegre edip edemeyeceklerini değerlendiren bir geliştiricinin durup avukatına danışması veya kendi kaynak kodunun GPL uyumlu olarak yayınlanabileceğinden emin olmak için kod denetimi yapması gerekiyorsa, kaybederiz.\nBileşen lisansları I2P dağıtımı, kaynak kodun bileşenlere ayrılmasını yansıtan birkaç kaynak içerir. Her bileşenin kendi lisansı vardır ve ona katkıda bulunan tüm geliştiriciler bu lisansı kabul eder - ya o bileşenle uyumlu bir lisans altında işlenen kodun yayınlandığını açıkça beyan ederek ya da bileşenin birincil lisansı altında işlenen kodu örtük olarak yayınlayarak. Bu bileşenlerin her birinin, hangi lisansın bileşenin birincil lisansıyla uyumlu olduğuna son kararı veren bir baş geliştiricisi vardır ve I2P proje yöneticisi, hangi lisansların I2P dağıtımına dahil edilmek üzere yukarıdaki dört garantiyi karşıladığına son kararı verir.\nComponent Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD, Cryptix, MIT zzz I2P Router router router.jar Public domain BSD, Cryptix, MIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain, Cryptix, MIT zzz Streaming apps/streaming streaming.jar Public domain BSD, Cryptix, MIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain, BSD, Cryptix, MIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain — zzz Address Book apps/addressbook addressbook.war MIT Public domain, Cryptix, BSD — Susidns apps/susidns susidns.war GPL + exception — — Susimail apps/susimail susimail.war GPL + exception — — I2PSnark apps/i2psnark i2psnark.jar GPL + exception — zzz [BOB](/docs/legacy/bob/) Bridge apps/BOB BOB.jar WTFPL — sponge [SAM](/docs/api/samv3/) Bridge apps/sam sam.jar Public domain Cryptix, BSD, MIT zzz [SAM v1](/docs/legacy/sam/) Perl library apps/sam/perl SAM.pm GPL Public domain, Cryptix, BSD, MIT BrianR [SAM v1](/docs/legacy/sam/) C library apps/sam/c libSAM BSD Public domain, Cryptix, MIT Nightblade [SAM v1](/docs/legacy/sam/) Python library apps/sam/python i2p.py Public domain BSD, Cryptix, MIT Connelly [SAM v1](/docs/legacy/sam/) C# library apps/sam/csharp/ n/a Public domain BSD, Cryptix, MIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source — — Installer installer install.jar, guiinstall.jar Public domain GPL + exception, BSD, Cryptix, MIT — GPL İstisnası Gereksiz olsa da, açıklık sağlamak adına I2PTunnel ve diğer uygulamalarda yer alan GPL lisanslı kodun, Java\u0026rsquo;nın standart kütüphanelerinin kullanımına açıkça izin veren ek bir \u0026ldquo;istisna\u0026rdquo; ile birlikte GPL altında yayınlanması gerekmektedir:\nIn addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version. Her bileşen altındaki tüm kaynak kodu, kodda aksi belirtilmedikçe varsayılan olarak birincil lisans altında lisanslanacaktır. Yukarıdakilerin tümü lisans koşullarının özetidir - yetkili koşullar için lütfen söz konusu bileşen veya kaynak kod için belirli lisansa bakın. Depo yeniden düzenlenirse bileşen kaynak konumları ve kaynak paketlemesi değiştirilebilir.\nWeb Sitesi Lisansı Aksi belirtilmedikçe, bu sitedeki içerik Creative Commons Atıf-AynıLisanslaPaylaş 4.0 Uluslararası Lisansı altında lisanslanmıştır.\nCommit Erişimi Geliştiriciler, o depoyu yöneten kişiden izin aldıkları takdirde dağıtılmış bir git deposuna değişiklik gönderebilirler. Ayrıntılar için Yeni Geliştirici Kılavuzu bölümüne bakınız.\nAncak, değişikliklerin bir sürüme dahil edilebilmesi için geliştiricilerin sürüm yöneticisi (şu anda zzz) tarafından güvenilir bulunması gerekir. Ayrıca, güvenilir olmak için yukarıdaki şartları açıkça kabul etmeleri gerekir. Bu, sürüm yöneticilerinden birine aşağıdakileri onaylayan imzalı bir mesaj göndermeleri gerektiği anlamına gelir:\nAksi belirtilmedikçe, commit ettiğim tüm kodlar örtük olarak bileşenin birincil lisansı altında lisanslanmıştır Kaynakta belirtilmişse, kod açıkça bileşenin alternatif lisanslarından biri altında lisanslanabilir Commit ettiğim kodu, commit ettiğim koşullar altında yayınlama hakkına sahibim Yukarıdaki koşulların karşılanmadığı herhangi bir durumdan haberdar olan varsa, lütfen daha fazla bilgi için bileşen sorumlusu ve/veya bir I2P sürüm yöneticisi ile iletişime geçin.\n","description":"I2P ile birlikte paketlenmiş yazılımlar için lisans politikası ve bileşen lisansları","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"I2P Yazılım Lisansları","url":"/tr/docs/develop/licenses/"},{"categories":null,"content":"Reseed sunucuları, bootstrap sürecinde yeni router\u0026rsquo;lara başlangıç düğüm grubu sağlayarak I2P ağı için kritik altyapı bileşenleridir. Bu kılavuz, kendi reseed sunucunuzu kurma ve çalıştırma adımlarında size yol gösterecektir.\nI2P Reseed Sunucusu Nedir? Bir I2P reseed sunucusu, yeni yönlendiricilerin I2P ağına entegrasyonuna şu şekilde yardımcı olur:\nİlk eş keşfi sağlama: Yeni yönlendiriciler, bağlanmak için bir başlangıç ağ düğümleri seti alır Bootstrap kurtarma: Bağlantıları sürdürmekte zorlanan yönlendiricilere yardımcı olma Güvenli dağıtım: Reseeding işlemi, ağ güvenliğini sağlamak için şifrelenir ve dijital olarak imzalanır Yeni bir I2P router ilk kez başlatıldığında (veya tüm eş bağlantılarını kaybettiğinde), başlangıç router bilgilerini indirmek için reseed sunucularına bağlanır. Bu, yeni router\u0026rsquo;ın kendi network database\u0026rsquo;ini oluşturmaya ve tunnel\u0026rsquo;lar kurmaya başlamasını sağlar.\nÖn Gereksinimler Başlamadan önce ihtiyacınız olanlar:\nRoot erişimi olan bir Linux sunucusu (Debian/Ubuntu önerilir) Sunucunuzu işaret eden bir alan adı En az 1GB RAM ve 10GB disk alanı Network database\u0026rsquo;i doldurmak için sunucuda çalışan bir I2P router Linux sistem yönetimine dair temel bilgi Sunucuyu Hazırlama Step 1: Update System and Install Dependencies İlk olarak, sisteminizi güncelleyin ve gerekli paketleri kurun:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y Bu şu bileşenleri kurar: - golang-go: Go programlama dili çalışma zamanı - git: Sürüm kontrol sistemi - make: Derleme otomasyon aracı - docker.io \u0026amp; docker-compose: Nginx Proxy Manager\u0026rsquo;ı çalıştırmak için konteyner platformu\nStep 2: Clone and Build Reseed Tools reseed-tools deposunu klonlayın ve uygulamayı derleyin:\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install reseed-tools paketi bir reseed sunucusu çalıştırmak için temel işlevselliği sağlar. Şunları yönetir: - Yerel ağ veritabanınızdan router bilgilerini toplama - Router bilgilerini imzalı SU3 dosyalarına paketleme - Bu dosyaları HTTPS üzerinden sunma\nStep 3: Generate SSL Certificate Reseed sunucunuzun SSL sertifikasını ve özel anahtarını oluşturun:\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Önemli parametreler: - --signer: E-posta adresiniz (admin@stormycloud.org yerine kendinizinkini yazın) - --netdb: I2P router\u0026rsquo;ınızın network database yolunu belirtin - --port: İç port (8443 önerilir) - --ip: Localhost\u0026rsquo;a bağlan (genel erişim için reverse proxy kullanacağız) - --trustProxy: Reverse proxy\u0026rsquo;den gelen X-Forwarded-For başlıklarına güven\nKomut şunları oluşturacaktır: - SU3 dosyalarını imzalamak için bir özel anahtar - Güvenli HTTPS bağlantıları için bir SSL sertifikası\nAdım 1: Sistemi Güncelleyin ve Bağımlılıkları Kurun Kritik: /home/i2p/.reseed/ dizininde bulunan oluşturulan anahtarları güvenli bir şekilde yedekleyin:\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ Bu yedeği güvenli, şifrelenmiş ve erişimi kısıtlanmış bir konumda saklayın. Bu anahtarlar reseed sunucunuzun çalışması için gereklidir ve dikkatli bir şekilde korunmalıdır.\nConfiguring the Service Adım 2: Reseed Araçlarını Klonlama ve Derleme Reseed sunucusunu otomatik olarak çalıştırmak için bir systemd servisi oluşturun:\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF Unutmayın admin@stormycloud.org adresini kendi e-posta adresinizle değiştirin.\nŞimdi servisi etkinleştirin ve başlatın:\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed Servisin çalıştığını kontrol edin:\nsudo systemctl status reseed Adım 3: SSL Sertifikası Oluşturma Optimum performans için, router bilgilerini yenilemek amacıyla reseed servisini periyodik olarak yeniden başlatmak isteyebilirsiniz:\nsudo crontab -e Servisi her 3 saatte bir yeniden başlatmak için bu satırı ekleyin:\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy Reseed sunucusu localhost:8443 üzerinde çalışır ve genel HTTPS trafiğini işlemek için bir ters proxy\u0026rsquo;ye ihtiyaç duyar. Kullanım kolaylığı nedeniyle Nginx Proxy Manager öneriyoruz.\nAdım 4: Anahtarlarınızı Yedekleyin Docker kullanarak Nginx Proxy Manager\u0026rsquo;ı dağıtın:\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest Bu şunları açar: - Port 80: HTTP trafiği - Port 81: Yönetim arayüzü - Port 443: HTTPS trafiği\nConfigure Proxy Manager Yönetim arayüzüne http://your-server-ip:81 adresinden erişin\nVarsayılan kimlik bilgileriyle giriş yapın:\nE-posta: admin@example.com Parola: changeme Önemli: İlk girişten hemen sonra bu kimlik bilgilerini değiştirin!\nProxy Hosts (Proxy Ana Bilgisayarları) bölümüne gidin ve Add Proxy Host (Proxy Ana Bilgisayarı Ekle) seçeneğine tıklayın Proxy host\u0026rsquo;unu yapılandırın: Domain Name: Reseed alan adınız (örn., reseed.example.com) Scheme: https Forward Hostname / IP: 127.0.0.1 Forward Port: 8443 Cache Assets\u0026lsquo;i etkinleştirin Block Common Exploits\u0026lsquo;i etkinleştirin Websockets Support\u0026lsquo;u etkinleştirin SSL sekmesinde: Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) seçeneğini seçin Force SSL seçeneğini etkinleştirin HTTP/2 Support seçeneğini etkinleştirin Let\u0026rsquo;s Encrypt Hizmet Koşulları\u0026rsquo;nı kabul edin Kaydet\u0026rsquo;e tıklayın Reseed sunucunuz artık https://reseed.example.com adresinden erişilebilir olmalıdır\nRegistering Your Reseed Server Reseed sunucunuz çalışır duruma geldiğinde, resmi reseed sunucu listesine eklenmesi için I2P geliştiricileriyle iletişime geçin.\nAdım 5: Systemd Servisi Oluşturma zzz\u0026lsquo;ye (I2P baş geliştiricisi) aşağıdaki bilgilerle e-posta gönderin:\nI2P E-posta: zzz@mail.i2p Clearnet E-posta: zzz@i2pmail.org Adım 6: İsteğe Bağlı - Periyodik Yeniden Başlatmaları Yapılandırın E-postanıza şunları ekleyin:\nReseed sunucu URL\u0026rsquo;si: Tam HTTPS URL\u0026rsquo;si (örn., https://reseed.example.com) Genel reseed sertifikası: /home/i2p/.reseed/ konumunda bulunur (.crt dosyasını ekleyin) İletişim e-postası: Sunucu bakım bildirimleri için tercih ettiğiniz iletişim yöntemi Sunucu konumu: İsteğe bağlı ancak yararlıdır (ülke/bölge) Beklenen çalışma süresi: Sunucuyu sürdürme taahhüdünüz Verification I2P geliştiricileri reseed sunucunuzun şu özelliklere sahip olduğunu doğrulayacaktır: - Düzgün yapılandırılmış ve router bilgisi sunuyor olması - Geçerli SSL sertifikaları kullanıyor olması - Doğru şekilde imzalanmış SU3 dosyaları sağlıyor olması - Erişilebilir ve yanıt veriyor olması\nOnaylandıktan sonra, reseed sunucunuz I2P router\u0026rsquo;larıyla dağıtılan listeye eklenecek ve yeni kullanıcıların ağa katılmasına yardımcı olacak!\nMonitoring and Maintenance Nginx Proxy Manager Kurulumu Reseed servisinizi izleyin:\nsudo systemctl status reseed sudo journalctl -u reseed -f Proxy Manager\u0026rsquo;ı Yapılandırma Sistem kaynaklarını takip edin:\nhtop df -h Update Reseed Tools En son iyileştirmeleri almak için reseed-tools\u0026rsquo;u düzenli olarak güncelleyin:\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed İletişim Bilgileri Nginx Proxy Manager üzerinden Let\u0026rsquo;s Encrypt kullanıyorsanız, sertifikalar otomatik olarak yenilenecektir. Yenilemenin çalıştığını doğrulayın:\ndocker logs nginx-proxy-manager | grep -i certificate Servisi Yapılandırma Gerekli Bilgiler Hataları kontrol etmek için günlükleri inceleyin:\nsudo journalctl -u reseed -n 50 Yaygın sorunlar: - I2P router çalışmıyor veya network database boş - 8443 portu zaten kullanımda - /home/i2p/.reseed/ dizini ile ilgili izin sorunları\nDoğrulama I2P router\u0026rsquo;ınızın çalıştığından ve ağ veritabanını doldurduğundan emin olun:\nls -lh /home/i2p/.i2p/netDb/ Birçok .dat dosyası görmelisiniz. Eğer boşsa, I2P router\u0026rsquo;ınızın eşleri keşfetmesini bekleyin.\nSSL Certificate Errors Sertifikalarınızın geçerli olduğunu doğrulayın:\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com Servis Durumunu Kontrol Edin Kontrol edin: - DNS kayıtları sunucunuza doğru şekilde yönlendiriliyor - Güvenlik duvarı 80 ve 443 portlarına izin veriyor - Nginx Proxy Manager çalışıyor: docker ps\nSecurity Considerations Özel anahtarlarınızı güvende tutun: /home/i2p/.reseed/ içeriğini asla paylaşmayın veya açığa çıkarmayın Düzenli güncellemeler: Sistem paketlerini, Docker\u0026rsquo;ı ve reseed-tools\u0026rsquo;u güncel tutun Günlükleri izleyin: Şüpheli erişim kalıplarına dikkat edin Hız sınırlama: Kötüye kullanımı önlemek için hız sınırlama uygulamayı düşünün Güvenlik duvarı kuralları: Yalnızca gerekli portları açın (80, 443, 81 yönetici için) Yönetici arayüzü: Nginx Proxy Manager yönetici arayüzünü (port 81) güvenilir IP\u0026rsquo;lerle sınırlandırın Contributing to the Network Bir reseed sunucusu çalıştırarak, I2P ağı için kritik altyapı sağlıyorsunuz. Daha özel ve merkezi olmayan bir internete katkıda bulunduğunuz için teşekkür ederiz!\nSorularınız veya yardım talepleriniz için I2P topluluğuna ulaşın: - Forum: i2pforum.net - IRC/Reddit: Çeşitli ağlarda #i2p - Geliştirme: i2pgit.org Rehber aslen Stormy Cloud tarafından oluşturulmuştur, I2P dokümantasyonu için uyarlanmıştır.\n","description":"I2P yeniden tohum sunucusu kurulumu ve işletimi için eksiksiz kılavuz - yeni router'ların ağa katılmasına yardımcı olmak için","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"I2P Yeniden Tohum (Reseed) Sunucusu Oluşturma ve Çalıştırma","url":"/tr/docs/guides/i2p-yeniden-tohum-reseed-sunucusu-olu%C5%9Fturma-ve-%C3%A7al%C4%B1%C5%9Ft%C4%B1rma/"},{"categories":null,"content":"Giriş I2P, ölçeklenebilir, kendi kendini organize eden, dayanıklı bir paket anahtarlamalı anonim ağ katmanıdır ve bu katman üzerinde anonimlik veya güvenlik odaklı herhangi bir sayıda farklı uygulama çalışabilir. Bu uygulamaların her biri, serbest rota mixnet\u0026rsquo;in (karıştırma ağı) doğru uygulanması konusunda endişelenmeden kendi anonimlik, gecikme ve aktarım hızı dengesini kurabilir; böylece faaliyetlerini I2P üzerinde zaten çalışan daha geniş kullanıcı anonimlik kümesiyle harmanlamalarına olanak tanır.\nHalihazırda mevcut uygulamalar, tipik İnternet etkinliklerinin tüm yelpazesini sağlar — anonim web taraması, web barındırma, sohbet, dosya paylaşımı, e-posta, blog yazarlığı ve içerik sendikasyonunun yanı sıra geliştirme aşamasında olan diğer birkaç uygulama.\nWeb tarayıcı kullanımı: proxy destekleyen herhangi bir mevcut tarayıcı kullanarak Sohbet: IRC ve diğer protokoller Dosya paylaşımı: I2PSnark ve diğer uygulamalar E-posta: Susimail ve diğer uygulamalar Blog: herhangi bir yerel web sunucusu veya mevcut eklentiler kullanarak Freenet veya GNUnet gibi içerik dağıtım ağlarında barındırılan web sitelerinin aksine, I2P üzerinde barındırılan hizmetler tamamen etkileşimlidir — geleneksel web tarzı arama motorları, bülten panoları, yorum yapabileceğiniz bloglar, veritabanı destekli siteler ve Freenet gibi statik sistemleri yerel olarak kurmaya gerek kalmadan sorgulayabileceğiniz köprüler bulunur.\nTüm bu anonimlik özellikli uygulamalarla birlikte, I2P mesaj odaklı ara katman yazılımı olarak işlev görür — uygulamalar, kriptografik bir tanımlayıcıya (bir \u0026ldquo;destination\u0026rdquo;) gönderilecek veriyi belirtir ve I2P bunun güvenli ve anonim bir şekilde ulaşmasını sağlar. I2P ayrıca, I2P\u0026rsquo;nin anonim en iyi çaba mesajlarının güvenilir, sıralı akışlar olarak aktarılmasına olanak tanıyan basit bir streaming kütüphanesi içerir ve ağın yüksek bant genişliği-gecikme çarpımına göre ayarlanmış TCP tabanlı tıkanıklık kontrolü sunar.\nBasit SOCKS proxy\u0026rsquo;leri mevcut uygulamaları bağlamak için geliştirilmiş olsa da, çoğu uygulama anonim bir bağlamda hassas bilgileri sızdırdığı için değerleri sınırlıdır. En güvenli yaklaşım, uygulamayı I2P\u0026rsquo;nin API\u0026rsquo;lerini doğrudan kullanacak şekilde denetlemek ve uyarlamaktır.\nI2P bir araştırma projesi değildir — ne akademik, ne ticari, ne de devlet destekli — kullanılabilir anonimlik sağlamayı hedefleyen bir mühendislik çabasıdır. 2003\u0026rsquo;ün başından beri dünya çapında dağıtık bir katkıda bulunanlar grubu tarafından sürekli olarak geliştirilmektedir. Tüm I2P çalışmaları resmi web sitesinde açık kaynak olup, öncelikli olarak kamu malı olarak yayınlanmakta, bazı bileşenler ise izin verici BSD-tarzı lisanslar altındadır. I2PTunnel , Susimail ve I2PSnark gibi çeşitli GPL lisanslı istemci uygulamaları mevcuttur. Finansman yalnızca kullanıcı bağışlarından gelmektedir.\nİşlem Overview I2P, router\u0026rsquo;lar (ağa katılan düğümler) ile destination\u0026rsquo;lar (uygulamalar için anonim uç noktalar) arasında net bir ayrım yapar. I2P\u0026rsquo;nin kendisini çalıştırmak gizli değildir; gizlenen şey kullanıcının ne yaptığı ve destination\u0026rsquo;larının hangi router\u0026rsquo;ı kullandığıdır. Son kullanıcılar genellikle birkaç destination çalıştırır (örneğin, biri web taraması için, diğeri barındırma için, bir diğeri IRC için).\nI2P\u0026rsquo;de temel bir kavram tunnel (tünel) — bir dizi router üzerinden geçen tek yönlü şifreli bir yoldur. Her router yalnızca bir katmanı çözer ve yalnızca bir sonraki adımı öğrenir. Tunneller her 10 dakikada bir sona erer ve yeniden oluşturulması gerekir.\nŞekil 1: İki tür tünel vardır — gelen (inbound) ve giden (outbound).\nGiden tüneller (Outbound tunnels), mesajları oluşturucudan uzağa gönderir. Gelen tüneller (Inbound tunnels), mesajları oluşturucuya geri getirir. Bunları birleştirmek iki yönlü iletişim sağlar. Örneğin, \u0026ldquo;Alice\u0026rdquo; giden bir tunnel kullanarak \u0026ldquo;Bob\u0026rsquo;un\u0026rdquo; gelen tunnel\u0026rsquo;ına gönderim yapar. Alice mesajını Bob\u0026rsquo;un gelen gateway\u0026rsquo;ine yönlendirme talimatlarıyla şifreler.\nDiğer önemli bir kavram ise router\u0026rsquo;lar ve hedefler hakkında üst verileri dağıtan network database veya netDb\u0026lsquo;dir:\nRouterInfo: Yönlendirici iletişim ve anahtar materyalini içerir. LeaseSet: Bir hedefe ulaşmak için gereken bilgileri içerir (tunnel ağ geçitleri, son kullanma süreleri, şifreleme anahtarları). Router\u0026rsquo;lar RouterInfo bilgilerini doğrudan netDb\u0026rsquo;ye yayınlar; LeaseSet\u0026rsquo;ler ise anonimlik için giden tüneller üzerinden gönderilir.\nTüneller oluşturmak için Alice, eş seçmek amacıyla netDb\u0026rsquo;yi RouterInfo girişleri için sorgular ve tünel tamamlanana kadar şifrelenmiş tünel oluşturma mesajlarını atlama-atlama (hop-by-hop) gönderir.\nŞekil 2: Router bilgileri tünel oluşturmak için kullanılır.\nBob\u0026rsquo;a göndermek için, Alice Bob\u0026rsquo;un LeaseSet\u0026rsquo;ini arar ve verilerini Bob\u0026rsquo;un gelen tünel ağ geçidine yönlendirmek için kendi giden tünellerinden birini kullanır.\nŞekil 3: LeaseSets giden ve gelen tünelleri bağlar.\nI2P mesaj tabanlı olduğu için, mesajları giden uç nokta veya gelen ağ geçidinden bile korumak için uçtan uca garlic encryption ekler. Bir garlic mesajı, meta verileri gizlemek ve anonimliği artırmak için birden fazla şifrelenmiş \u0026ldquo;clove\u0026rdquo; (mesaj) içerir.\nUygulamalar mesaj arayüzünü doğrudan kullanabilir veya güvenilir bağlantılar için streaming kütüphanesine güvenebilir.\nTunnels Hem gelen hem de giden tüneller katmanlı şifreleme kullanır, ancak yapıları farklıdır:\nGelen tünellerde, oluşturucu (uç nokta) tüm katmanların şifresini çözer. Giden tünellerde, oluşturucu (ağ geçidi) uç noktada netliği sağlamak için katmanların şifresini önceden çözer. I2P, eşleri doğrudan yoklama yapmadan gecikme ve güvenilirlik gibi dolaylı metrikler aracılığıyla profiller. Bu profillere dayanarak, eşler dinamik olarak dört katmana gruplandırılır:\nHızlı ve yüksek kapasite Yüksek kapasite Başarısız olmayan Başarısız olan Tunnel eş seçimi genellikle yüksek kapasiteli eşleri tercih eder, anonimlik ve performansı dengelemek için rastgele seçilir ve predecessor saldırılarını ve netDb toplamasını azaltmak için ek XOR tabanlı sıralama stratejileri kullanır.\nDaha detaylı bilgi için Tunnel Specification bölümüne bakınız.\nGenel Bakış Floodfill dağıtılmış hash tablosuna (DHT) katılan router\u0026rsquo;lar LeaseSet aramalarını depolar ve yanıtlar. DHT, Kademlia \u0026rsquo;nın bir varyantını kullanır. Floodfill router\u0026rsquo;lar, yeterli kapasiteye ve kararlılığa sahiplerse otomatik olarak seçilir veya manuel olarak yapılandırılabilir.\nRouterInfo: Bir router\u0026rsquo;ın yeteneklerini ve aktarım yöntemlerini tanımlar. LeaseSet: Bir hedefin tunnel\u0026rsquo;larını ve şifreleme anahtarlarını tanımlar. netDb\u0026rsquo;deki tüm veriler yayıncı tarafından imzalanır ve tekrar oynatma ya da bayat girdi saldırılarını önlemek için zaman damgası eklenir. Zamanlama senkronizasyonu SNTP ve aktarım katmanı sapma tespiti aracılığıyla sağlanır.\nAdditional concepts Yayınlanmamış ve şifrelenmiş LeaseSet\u0026rsquo;ler:\nBir hedef (destination), LeaseSet\u0026rsquo;ini yayınlamayarak ve yalnızca güvenilir eşlerle paylaşarak gizli kalabilir. Erişim için uygun şifre çözme anahtarı gereklidir.\nBootstrapping (reseeding):\nAğa katılmak için, yeni bir router güvenilir HTTPS reseed sunucularından imzalanmış RouterInfo dosyalarını alır.\nArama ölçeklenebilirliği:\nI2P, DHT ölçeklenebilirliğini ve güvenliğini artırmak için özyinelemeli değil, yinelemeli aramalar kullanır.\nTüneller Modern I2P iletişimi iki tamamen şifrelenmiş aktarım kullanır:\nNTCP2 : Şifrelenmiş TCP tabanlı protokol SSU2 : Şifrelenmiş UDP tabanlı protokol Her ikisi de modern Noise Protocol Framework üzerine kurulmuştur ve güçlü kimlik doğrulama ile trafik parmak izi almaya karşı direnç sağlar. Eski NTCP ve SSU protokollerinin yerini almışlardır (2023\u0026rsquo;ten beri tamamen kullanımdan kaldırılmıştır).\nNTCP2, TCP üzerinden şifrelenmiş ve verimli akış sunar.\nSSU2, UDP tabanlı güvenilirlik, NAT geçişi ve isteğe bağlı hole punching sağlar. SSU2 kavramsal olarak WireGuard veya QUIC\u0026rsquo;e benzer şekilde güvenilirlik ve anonimlik arasında denge kurar.\nRouter\u0026rsquo;lar hem IPv4 hem de IPv6\u0026rsquo;yı destekleyebilir ve transport adreslerini ve maliyetlerini netDb\u0026rsquo;de yayınlar. Bir bağlantının transport\u0026rsquo;u, koşulları ve mevcut bağlantıları optimize eden bir ihale sistemi tarafından dinamik olarak seçilir.\nAğ Veritabanı (netDb) I2P tüm bileşenler için katmanlı şifreleme kullanır: taşımalar, tüneller, garlic mesajları ve network database.\nMevcut temel işlevler şunları içerir:\nAnahtar değişimi için X25519 İmzalar için EdDSA (Ed25519) Kimlik doğrulamalı şifreleme için ChaCha20-Poly1305 Hash işlemleri için SHA-256 Tunnel katmanı şifrelemesi için AES256 Eski algoritmalar (ElGamal, DSA-SHA1, ECDSA) geriye dönük uyumluluk için korunmuştur.\nI2P şu anda \u0026ldquo;şimdi topla, sonra şifrele\u0026rdquo; saldırılarına karşı direnç sağlamak için X25519 ile ML-KEM\u0026lsquo;i birleştiren hibrit kuantum sonrası (PQ) kriptografik şemaları tanıtıyor.\nGarlic Messages Garlic mesajları, bağımsız teslimat talimatlarına sahip birden fazla şifrelenmiş \u0026ldquo;karanfili\u0026rdquo; gruplandırarak onion routing\u0026rsquo;i genişletir. Bunlar mesaj düzeyinde yönlendirme esnekliği ve tek tip trafik doldurma sağlar.\nSession Tags Uçtan uca şifreleme için iki kriptografik sistem desteklenmektedir:\nElGamal/AES+SessionTags (eski):\nÖnceden teslim edilen oturum etiketlerini 32-baytlık nonce\u0026rsquo;lar olarak kullanır. Verimsizliği nedeniyle artık kullanımdan kaldırılmıştır.\nECIES-X25519-AEAD-Ratchet (güncel):\nChaCha20-Poly1305 ve senkronize HKDF tabanlı PRNG\u0026rsquo;ler kullanarak geçici oturum anahtarları ve 8 baytlık etiketleri dinamik olarak üretir, ileri gizliliği korurken CPU, bellek ve bant genişliği yükünü azaltır.\nFuture of the Protocol Temel araştırma alanları, devlet düzeyindeki düşmanlara karşı güvenliği koruma ve kuantum sonrası korumalar getirme üzerine odaklanmaktadır. İki erken tasarım konsepti — kısıtlı rotalar ve değişken gecikme — modern gelişmelerle geride bırakılmıştır.\nRestricted Route Operation Orijinal kısıtlı yönlendirme (restricted routing) kavramları, IP adreslerini gizlemeyi amaçlıyordu. Bu ihtiyaç büyük ölçüde şu faktörler tarafından azaltılmıştır:\nOtomatik port yönlendirme için UPnP SSU2\u0026rsquo;de güçlü NAT geçişi IPv6 desteği İşbirlikçi introducers ve NAT delik delme İsteğe bağlı overlay (örn. Yggdrasil) bağlantısı Bu nedenle, modern I2P aynı hedeflere karmaşık kısıtlı yönlendirme olmadan daha pratik bir şekilde ulaşır.\nSimilar Systems I2P, mesaj odaklı ara katman yazılımları, DHT\u0026rsquo;ler ve mixnet\u0026rsquo;lerden kavramları entegre eder. İnovasyonu, bunları kullanılabilir, kendi kendini organize eden bir anonimlik platformunda birleştirmesinde yatmaktadır.\nTaşıma Protokolleri Website Tor ve I2P aynı hedefleri paylaşır ancak mimari olarak farklıdır:\nTor: Devre anahtarlamalı; güvenilir dizin yetkililerine dayanır. (~10k röle) I2P: Paket anahtarlamalı; tamamen dağıtık DHT-tabanlı ağ. (~50k router) I2P\u0026rsquo;nin tek yönlü tünelleri daha az metadata açığa çıkarır ve esnek yönlendirme yollarına izin verirken, Tor anonim İnternet erişimine (outproxying) odaklanır. I2P bunun yerine anonim ağ içi barındırmayı destekler.\nKriptografi Web Sitesi Freenet anonim, kalıcı dosya yayınlama ve alma odaklıdır. Buna karşılık I2P, etkileşimli kullanım (web, sohbet, torrent\u0026rsquo;ler) için gerçek zamanlı bir iletişim katmanı sağlar. İki sistem birlikte birbirini tamamlar — Freenet sansüre dayanıklı depolama sağlar; I2P aktarım anonimliği sağlar.\nOther Networks Lokinet: Teşvikli servis düğümleri kullanan IP tabanlı kaplama ağı. Nym: Daha yüksek gecikme süresinde örtü trafiği ile metadata korumasını vurgulayan yeni nesil mixnet. Appendix A: Application Layer I2P\u0026rsquo;nin kendisi yalnızca mesaj taşıma işlemini yönetir. Uygulama katmanı işlevselliği, API\u0026rsquo;ler ve kütüphaneler aracılığıyla harici olarak uygulanır.\nStreaming Library Streaming kütüphanesi, I2P\u0026rsquo;nin TCP benzeri işlevi görür; kayan pencere protokolü ve yüksek gecikmeli anonim aktarım için optimize edilmiş tıkanıklık kontrolü ile çalışır.\nTipik HTTP istek/yanıt kalıpları, mesaj paketleme optimizasyonları sayesinde genellikle tek bir gidiş-dönüşte tamamlanabilir.\nNaming Library and Address Book Geliştiriciler: mihi, Ragnarok İsimlendirme ve Adres Defteri sayfasına bakın.\nI2P\u0026rsquo;nin isimlendirme sistemi yerel ve merkeziyetsizdir, DNS tarzı global isimlerden kaçınır. Her router, insan tarafından okunabilir isimlerin destination\u0026rsquo;lara (hedeflere) yerel bir eşleştirmesini tutar. İsteğe bağlı web-of-trust (güven ağı) tabanlı adres defterleri, güvenilir eşlerden paylaşılabilir veya içe aktarılabilir.\nBu yaklaşım, merkezi otoritelerden kaçınır ve küresel veya oylama tarzı isimlendirme sistemlerinde bulunan Sybil güvenlik açıklarını atlatır.\nKısıtlı Rota İşlemi Geliştiren: mihi\nI2PTunnel, anonim TCP proxy\u0026rsquo;lemeyi sağlayan ana istemci katmanı arayüzüdür. Şunları destekler:\nİstemci tünelleri (I2P hedeflerine giden) HTTP istemcisi (eepproxy) \u0026ldquo;.i2p\u0026rdquo; alan adları için Sunucu tünelleri (I2P\u0026rsquo;den yerel bir hizmete gelen) HTTP sunucu tünelleri (web hizmetlerini güvenli bir şekilde proxy\u0026rsquo;leme) Outproxy (normal İnternet\u0026rsquo;e erişim) isteğe bağlıdır ve gönüllüler tarafından çalıştırılan \u0026ldquo;sunucu\u0026rdquo; tünelleri ile sağlanır.\nI2PSnark Geliştirici: jrandom ve diğerleri — Snark uyarlaması\nI2P ile birlikte gelen I2PSnark, DHT ve UDP desteği olan anonim bir çoklu-torrent BitTorrent istemcisidir ve web arayüzü üzerinden erişilebilir.\nTor Geliştiriciler: postman, susi23, mastiejaner\nI2Pmail, I2PTunnel bağlantıları üzerinden anonim e-posta sağlar. Susimail, geleneksel e-posta istemcilerinde yaygın olan bilgi sızıntılarını önlemek için özel olarak tasarlanmış web tabanlı bir istemcidir. mail.i2p hizmeti, ek koruma için virüs filtreleme, hashcash kotaları ve outproxy ayrımı özellikleri sunar.\n","description":"I2P mimarisi ve işleyişine teknik giriş","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P: Anonim iletişim için ölçeklenebilir bir çerçeve","url":"/tr/docs/overview/tech-intro/"},{"categories":null,"content":"I2P Nedir? The Invisible Internet Project (I2P), sansüre dirençli, eşler arası iletişim sağlayan anonim bir ağ katmanıdır. Anonim bağlantılar, kullanıcının trafiğini şifreleyerek ve dünya çapındaki gönüllüler tarafından işletilen dağıtık bir ağ üzerinden göndererek sağlanır.\nTemel Özellikler Anonymity I2P hem mesaj gönderenin hem de alanın kimliğini gizler. IP adresinizin web siteleri ve hizmetler tarafından görülebildiği geleneksel internet bağlantılarının aksine, I2P kimliğinizi gizli tutmak için birden fazla şifreleme ve yönlendirme katmanı kullanır.\nDecentralization I2P\u0026rsquo;de merkezi bir otorite yoktur. Ağ, bant genişliği ve hesaplama kaynakları bağışlayan gönüllüler tarafından sürdürülür. Bu durum, ağı sansüre ve tek arıza noktalarına karşı dirençli kılar.\nAnonimlik I2P içindeki tüm trafik uçtan uca şifrelenir. Mesajlar ağ üzerinden geçerken birden fazla kez şifrelenir, bu da Tor\u0026rsquo;un çalışma şekline benzer ancak uygulamada önemli farklılıklar vardır.\nHow It Works Merkeziyetsizlik I2P, trafiği yönlendirmek için \u0026ldquo;tunnel\u0026rdquo; (tünel) kullanır. Veri gönderdiğinizde veya aldığınızda:\nYönlendiriciniz bir outbound tunnel (gönderme için) oluşturur Yönlendiriciniz bir inbound tunnel (alma için) oluşturur Mesajlar şifrelenir ve birden fazla router üzerinden gönderilir Her router yalnızca önceki ve sonraki adımı bilir, tam yolu bilmez Uçtan Uca Şifreleme I2P, geleneksel soğan yönlendirmesini \u0026ldquo;garlic routing\u0026rdquo; ile geliştirir:\nBirden fazla mesaj birlikte paketlenebilir (sarımsak soğanındaki dişler gibi) Bu, daha iyi performans ve ek anonimlik sağlar Trafik analizini zorlaştırır Network Database I2P, aşağıdakileri içeren dağıtılmış bir ağ veritabanı tutar:\nYönlendirici bilgileri Hedef adresleri (.i2p web siteleri gibi) Şifrelenmiş yönlendirme verileri Common Use Cases Tüneller .i2p ile biten web sitelerini barındırın veya ziyaret edin - bunlara yalnızca I2P ağı içinden erişilebilir ve hem barındırıcılar hem de ziyaretçiler için güçlü anonimlik garantileri sağlar.\nGarlic Routing I2P üzerinden BitTorrent kullanarak anonim olarak dosya paylaşın. Birçok torrent uygulamasında I2P desteği yerleşik olarak bulunur.\nAğ Veritabanı I2P-Bote veya I2P için tasarlanmış diğer e-posta uygulamalarını kullanarak anonim e-posta gönderin ve alın.\nMessaging I2P ağı üzerinden IRC, anlık mesajlaşma veya diğer iletişim araçlarını gizli bir şekilde kullanın.\nGetting Started I2P\u0026rsquo;yi denemek için hazır mısınız? Sisteminize I2P kurmak için indirmeler sayfamızı ziyaret edin.\nDaha fazla teknik ayrıntı için Teknik Giriş bölümüne bakın veya tam belgeleri inceleyin.\nNasıl Çalışır Teknik Giriş - Daha derin teknik kavramlar Tehdit Modeli - I2P\u0026rsquo;nin güvenlik modelini anlamak Tor ile Karşılaştırma - I2P\u0026rsquo;nin Tor\u0026rsquo;dan farkları Kriptografi - I2P\u0026rsquo;nin kriptografik algoritmaları hakkında detaylar ","description":"I2P anonim ağına daha az teknik bir giriş","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"I2P'ye Giriş","url":"/tr/docs/overview/intro/"},{"categories":null,"content":"Bir SSH tüneli, uzak I2P router\u0026rsquo;ınızın konsoluna veya diğer hizmetlerine erişmek için güvenli, şifreli bir bağlantı sağlar. Bu kılavuz, Windows, Linux ve Mac sistemlerinde SSH tünelleri oluşturmayı gösterir.\nSSH Tüneli Nedir? SSH tüneli, veri ve bilgilerin şifrelenmiş bir SSH bağlantısı üzerinden güvenli bir şekilde yönlendirilmesi yöntemidir. Bunu internet üzerinden korumalı bir \u0026ldquo;boru hattı\u0026rdquo; oluşturmak olarak düşünün - verileriniz bu şifrelenmiş tünel içinden geçerken, yol boyunca hiç kimse verileri engelleyemez veya okuyamaz.\nSSH tünellemesi özellikle şu durumlarda kullanışlıdır:\nUzak I2P router\u0026rsquo;lara erişim: Uzak bir sunucuda çalışan I2P konsolunuza bağlanın Güvenli bağlantılar: Tüm trafik uçtan uca şifrelenir Kısıtlamaları aşma: Uzak sistemlerdeki servislere yerel hizmetlermiş gibi erişin Port yönlendirme: Yerel bir portu uzak bir servise eşleyin I2P bağlamında, uzak bir sunucudaki I2P router konsolunuza (genellikle 7657 portunda) erişmek için bir SSH tüneli kullanarak bunu bilgisayarınızdaki yerel bir porta yönlendirebilirsiniz.\nÖn Koşullar SSH tüneli oluşturmadan önce ihtiyacınız olanlar:\nSSH istemcisi: Windows: PuTTY (ücretsiz indirme) Linux/Mac: Yerleşik SSH istemcisi (Terminal üzerinden) Uzak sunucu erişimi: Uzak sunucu için kullanıcı adı Uzak sunucunun IP adresi veya hostname\u0026rsquo;i SSH parolası veya anahtar tabanlı kimlik doğrulama Kullanılabilir yerel port: 1-65535 arasında kullanılmayan bir port seçin (I2P için yaygın olarak 7657 kullanılır) Tunnel Komutunu Anlamak SSH tünel komutu bu kalıbı takip eder:\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] Parametreler açıklaması: - local_port: Yerel makinenizdeki port (örn. 7657) - destination_ip: Genellikle 127.0.0.1 (uzak sunucuda localhost) - destination_port: Uzak sunucudaki servisin portu (örn. I2P için 7657) - username: Uzak sunucudaki kullanıcı adınız - remote_server: Uzak sunucunun IP adresi veya host adı\nÖrnek: ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\nBu, şu şekilde bir tünel oluşturur: - Makinenizdeki yerel port 7657, uzak sunucunun localhost\u0026rsquo;unda (I2P\u0026rsquo;nin çalıştığı yerde) port 7657\u0026rsquo;ye yönlendirilir - i2p kullanıcısı olarak 20.228.143.58 sunucusuna bağlanılır\nWindows\u0026rsquo;ta SSH Tünelleri Oluşturma Windows kullanıcıları, ücretsiz bir SSH istemcisi olan PuTTY\u0026rsquo;yi kullanarak SSH tünelleri oluşturabilir.\nStep 1: Download and Install PuTTY PuTTY\u0026rsquo;yi putty.org adresinden indirin ve Windows sisteminize kurun.\nStep 2: Configure the SSH Connection PuTTY\u0026rsquo;yi açın ve bağlantınızı yapılandırın:\nOturum kategorisinde: Uzak sunucunuzun IP adresini veya ana bilgisayar adını Host Name alanına girin Port\u0026lsquo;un 22\u0026rsquo;ye (varsayılan SSH portu) ayarlı olduğundan emin olun Bağlantı türü SSH olmalıdır Step 3: Configure the Tunnel Sol kenar çubuğunda Connection → SSH → Tunnels bölümüne gidin:\nKaynak bağlantı noktası: Kullanmak istediğiniz yerel bağlantı noktasını girin (örn., 7657) Hedef: 127.0.0.1:7657 girin (uzak sunucudaki localhost:port) Tüneli eklemek için Ekle\u0026lsquo;ye tıklayın Tünel \u0026ldquo;Yönlendirilen bağlantı noktaları\u0026rdquo; listesinde görünmelidir Step 4: Connect Bağlantıyı başlatmak için Open düğmesine tıklayın İlk kez bağlanıyorsanız, bir güvenlik uyarısı göreceksiniz - sunucuya güvenmek için Yes düğmesine tıklayın İstendiğinde kullanıcı adınızı girin İstendiğinde parolanızı girin Bağlandıktan sonra, bir tarayıcı açıp http://127.0.0.1:7657 adresine giderek uzak I2P konsolunuza erişebilirsiniz\nAdım 1: PuTTY\u0026rsquo;yi İndirin ve Kurun Her seferinde yeniden yapılandırmaktan kaçınmak için:\nSession kategorisine geri dönün Saved Sessions alanına bir isim girin (örn. \u0026ldquo;I2P Tunnel\u0026rdquo;) Save düğmesine tıklayın Bir sonraki seferde, bu oturumu yükleyin ve Open düğmesine tıklayın Creating SSH Tunnels on Linux Linux sistemleri terminale yerleşik SSH\u0026rsquo;ye sahiptir, bu da tünel oluşturmayı hızlı ve kolay hale getirir.\nAdım 2: SSH Bağlantısını Yapılandırın Bir terminal açın ve SSH tüneli komutunu çalıştırın:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Değiştir: - 7657 (ilk geçtiği yer): İstediğiniz yerel port - 127.0.0.1:7657: Uzak sunucudaki hedef adres ve port - i2p: Uzak sunucudaki kullanıcı adınız - 20.228.143.58: Uzak sunucunuzun IP adresi\nİstendiğinde şifrenizi girin. Bağlantı kurulduktan sonra tünel aktif hale gelir.\nTarayıcınızda http://127.0.0.1:7657 adresinden uzak I2P konsolunuza erişin.\nAdım 3: Tüneli Yapılandırın Tünel, SSH oturumu çalıştığı sürece aktif kalır. Arka planda çalışır durumda tutmak için:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Ek bayraklar: - -f: SSH\u0026rsquo;yi arka planda çalıştırır - -N: Uzak komutları çalıştırma (yalnızca tünel)\nArka planda çalışan bir tüneli kapatmak için SSH sürecini bulun ve sonlandırın:\nps aux | grep ssh kill [process_id] Adım 4: Bağlan Daha iyi güvenlik ve kolaylık için SSH anahtar kimlik doğrulaması kullanın:\nBir SSH anahtar çifti oluşturun (eğer yoksa):\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Genel anahtarınızı uzak sunucuya kopyalayın:\nssh-copy-id i2p@20.228.143.58 Artık şifre olmadan bağlanabilirsiniz:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac Mac sistemleri Linux ile aynı SSH istemcisini kullanır, bu nedenle işlem aynıdır.\nİsteğe Bağlı: Oturumunuzu Kaydedin Terminal\u0026rsquo;i açın (Uygulamalar → Yardımcı Programlar → Terminal) ve şunu çalıştırın:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Değiştirin: - 7657 (ilk geçiş): İstediğiniz yerel port - 127.0.0.1:7657: Uzak sunucudaki hedef adres ve port - i2p: Uzak sunucudaki kullanıcı adınız - 20.228.143.58: Uzak sunucunuzun IP adresi\nİstendiğinde parolanızı girin. Bağlandıktan sonra, uzak I2P konsolunuza http://127.0.0.1:7657 adresinden erişin\nBackground Tunnels on Mac Linux\u0026rsquo;ta olduğu gibi, tüneli arka planda çalıştırabilirsiniz:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Terminali Kullanma Mac SSH anahtar kurulumu Linux ile aynıdır:\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases Tüneli Aktif Tutma En yaygın kullanım senaryosu - uzaktaki I2P router konsolunuza erişim:\nssh -L 7657:127.0.0.1:7657 user@remote-server Ardından tarayıcınızda http://127.0.0.1:7657 adresini açın.\nSSH Anahtarlarını Kullanma (Önerilen) Aynı anda birden fazla portu yönlendirin:\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server Bu, hem 7657 portunu (I2P konsolu) hem de 7658 portunu (başka bir servis) yönlendirir.\nCustom Local Port 7657 portu zaten kullanımdaysa farklı bir yerel port kullanın:\nssh -L 8080:127.0.0.1:7657 user@remote-server I2P konsoluna http://127.0.0.1:8080 adresinden erişin.\nTroubleshooting Terminali Kullanma Hata: \u0026ldquo;bind: Address already in use\u0026rdquo;\nÇözüm: Farklı bir yerel port seçin veya o portu kullanan işlemi sonlandırın:\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] Mac\u0026rsquo;te Arka Plan Tünelleri Hata: \u0026ldquo;Bağlantı reddedildi\u0026rdquo; veya \u0026ldquo;channel 2: open failed\u0026rdquo;\nOlası nedenler: - Uzak servis çalışmıyor (uzak sunucuda I2P router\u0026rsquo;ın çalıştığını kontrol edin) - Güvenlik duvarı bağlantıyı engelliyor - Yanlış hedef portu\nÇözüm: Uzak sunucuda I2P router\u0026rsquo;ın çalıştığını doğrulayın:\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; Mac\u0026rsquo;te SSH Anahtar Kurulumu Hata: \u0026ldquo;İzin reddedildi\u0026rdquo; veya \u0026ldquo;Kimlik doğrulama başarısız oldu\u0026rdquo;\nOlası nedenler: - Yanlış kullanıcı adı veya şifre - SSH anahtarı düzgün yapılandırılmamış - Uzak sunucuda SSH erişimi devre dışı bırakılmış\nÇözüm: Kimlik bilgilerini doğrulayın ve uzak sunucuda SSH erişiminin etkin olduğundan emin olun.\nTunnel Drops Connection Hata: Belli bir hareketsizlik süresinden sonra bağlantı kopuyor\nÇözüm: SSH yapılandırmanıza (~/.ssh/config) keep-alive ayarlarını ekleyin:\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices SSH anahtarları kullanın: Parolalardan daha güvenli, ele geçirilmesi daha zor Parola kimlik doğrulamasını devre dışı bırakın: SSH anahtarları kurulduktan sonra, sunucuda parola girişini devre dışı bırakın Güçlü parolalar kullanın: Parola kimlik doğrulaması kullanıyorsanız, güçlü ve benzersiz bir parola kullanın SSH erişimini sınırlayın: Güvenilir IP adreslerine SSH erişimini sınırlamak için güvenlik duvarı kurallarını yapılandırın SSH\u0026rsquo;ı güncel tutun: SSH istemci ve sunucu yazılımınızı düzenli olarak güncelleyin Günlükleri izleyin: Şüpheli etkinlik için sunucudaki SSH günlüklerini kontrol edin Standart olmayan SSH portları kullanın: Otomatik saldırıları azaltmak için varsayılan SSH portunu (22) değiştirin Linux\u0026rsquo;ta SSH Tünelleri Oluşturma I2P Konsoluna Erişim Tünelleri otomatik olarak kurmak için bir betik oluşturun:\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; Çalıştırılabilir yapın:\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh Çoklu Tüneller Otomatik tünel oluşturma için bir systemd servisi oluşturun:\nsudo nano /etc/systemd/system/i2p-tunnel.service Ekle:\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target Etkinleştir ve başlat:\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling Özel Yerel Port Dinamik yönlendirme için bir SOCKS proxy oluşturun:\nssh -D 8080 user@remote-server Tarayıcınızı 127.0.0.1:8080 adresini SOCKS5 proxy olarak kullanacak şekilde yapılandırın.\nReverse Tunneling Uzak sunucunun yerel makinenizdeki servislere erişmesine izin verin:\nssh -R 7657:127.0.0.1:7657 user@remote-server Port Zaten Kullanımda Ara sunucu üzerinden tünel:\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion SSH tünelleme, uzak I2P router\u0026rsquo;lara ve diğer servislere güvenli bir şekilde erişmek için güçlü bir araçtır. Windows, Linux veya Mac kullanıyor olun, süreç basittir ve bağlantılarınız için güçlü şifreleme sağlar.\nEk yardım veya sorularınız için I2P topluluğunu ziyaret edin: - Forum: i2pforum.net - IRC: çeşitli ağlarda #i2p - Belgeler: I2P Docs Rehber orijinal olarak Stormy Cloud tarafından oluşturulmuş, I2P dokümantasyonu için uyarlanmıştır.\n","description":"Windows, Linux ve Mac üzerinde uzak I2P yönlendiricinize erişmek için güvenli SSH tünelleri oluşturmayı öğrenin","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"I2P'ye Uzaktan Erişmek için SSH Tüneli Oluşturma","url":"/tr/docs/guides/i2pye-uzaktan-eri%C5%9Fmek-i%C3%A7in-ssh-t%C3%BCneli-olu%C5%9Fturma/"},{"categories":null,"content":"I2P projesi, Debian, Ubuntu ve bunların türev dağıtımları için resmi paketler sağlamaktadır. Bu kılavuz, resmi depolarımızı kullanarak I2P kurulumu için kapsamlı talimatlar sunmaktadır.\nBu belge I2P\u0026rsquo;nin temel kavramlarını açıklamaktadır.\n🚀 Beta: Otomatik Kurulum (Deneysel) Hızlı otomatik kurulum isteyen ileri düzey kullanıcılar için:\nBu tek satırlık komut dağıtımınızı otomatik olarak algılayacak ve I2P\u0026rsquo;yi kuracaktır. Dikkatli kullanın - çalıştırmadan önce kurulum betiğini inceleyin.\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash Ne yapar: - Linux dağıtımınızı algılar (Ubuntu/Debian) - Uygun I2P deposunu ekler - GPG anahtarlarını ve gerekli paketleri kurar - I2P\u0026rsquo;yi otomatik olarak kurar\n⚠️ Bu bir beta özelliğidir. Manuel kurulumu tercih ediyorsanız veya her adımı anlamak istiyorsanız, aşağıdaki manuel kurulum yöntemlerini kullanın.\n` markers.\nPlease share the English text you\u0026rsquo;d like me to translate to Turkish, and I\u0026rsquo;ll provide the translation following all the rules specified.\nUbuntu Kurulumu Ubuntu ve resmi türevleri (Linux Mint, elementary OS, Trisquel, vb.) kolay kurulum ve otomatik güncellemeler için I2P PPA\u0026rsquo;sını (Personal Package Archive - Kişisel Paket Arşivi) kullanabilir.\nMethod 1: Command Line Installation (Recommended) Bu, Ubuntu tabanlı sistemlerde I2P kurulumu için en hızlı ve en güvenilir yöntemdir.\nAdım 1: I2P PPA\u0026rsquo;sını Ekleyin\nBir terminal açın ve çalıştırın:\nsudo apt-add-repository ppa:i2p-maintainers/i2p Bu komut, I2P PPA\u0026rsquo;sını /etc/apt/sources.list.d/ dizinine ekler ve depoyu imzalayan GPG anahtarını otomatik olarak içe aktarır. GPG imzası, paketlerin oluşturulduktan sonra kurcalanmadığını garanti eder.\nAdım 2: Paket listesini güncelleyin\nSisteminizin paket veritabanını yeni PPA\u0026rsquo;yı içerecek şekilde yenileyin:\nsudo apt-get update Bu komut, yeni eklediğiniz I2P PPA dahil olmak üzere etkinleştirilmiş tüm depolardan en güncel paket bilgilerini alır.\nAdım 3: I2P\u0026rsquo;yi Kurun\nŞimdi I2P\u0026rsquo;yi kurun:\nsudo apt-get install i2p İşte bu kadar! I2P\u0026rsquo;yi nasıl başlatacağınızı ve yapılandıracağınızı öğrenmek için Kurulum Sonrası Yapılandırma bölümüne atlayın.\nMethod 2: Using the Software Center GUI Grafik arayüzü tercih ederseniz, Ubuntu\u0026rsquo;nun Yazılım Merkezi\u0026rsquo;ni kullanarak PPA\u0026rsquo;yı ekleyebilirsiniz.\nAdım 1: Yazılım ve Güncellemeler\u0026rsquo;i Açın\nUygulamalar menünüzden \u0026ldquo;Yazılım ve Güncellemeler\u0026quot;i başlatın.\nAdım 2: Diğer Yazılımlara Git\n\u0026ldquo;Diğer Yazılım\u0026rdquo; sekmesini seçin ve yeni bir PPA yapılandırmak için alttaki \u0026ldquo;Ekle\u0026rdquo; düğmesine tıklayın.\nAdım 3: I2P PPA\u0026rsquo;sını Ekleyin\nPPA iletişim kutusuna şunu girin:\nppa:i2p-maintainers/i2p Adım 4: Depo bilgilerini yeniden yükle\nGüncellenmiş depo bilgilerini indirmek için \u0026ldquo;Reload\u0026rdquo; düğmesine tıklayın.\nAdım 5: I2P\u0026rsquo;yi Kurun\nUygulamalar menünüzden \u0026ldquo;Yazılım\u0026rdquo; uygulamasını açın, \u0026ldquo;i2p\u0026rdquo; araması yapın ve Yükle\u0026rsquo;ye tıklayın.\nKurulum tamamlandığında, Kurulum Sonrası Yapılandırma bölümüne geçin.\nDebian Installation Debian ve türev dağıtımları (LMDE, Kali Linux, ParrotOS, Knoppix, vb.) deb.i2p.net adresindeki resmi I2P Debian deposunu kullanmalıdır.\nImportant Notice deb.i2p2.de ve deb.i2p2.no adreslerindeki eski depolarımız artık kullanım ömrünü tamamlamıştır. Bu eski depoları kullanıyorsanız, lütfen deb.i2p.net adresindeki yeni depoya geçiş yapmak için aşağıdaki talimatları izleyin.\nPrerequisites Aşağıdaki tüm adımlar root erişimi gerektirir. Ya su komutuyla root kullanıcısına geçin ya da her komutun önüne sudo ekleyin.\nYöntem 1: Komut Satırı Kurulumu (Önerilen) Adım 1: Gerekli paketleri yükleyin\nGerekli araçların kurulu olduğundan emin olun:\nsudo apt-get update sudo apt-get install apt-transport-https lsb-release curl Bu paketler güvenli HTTPS depo erişimi, dağıtım tespiti ve dosya indirmelerini etkinleştirir.\nAdım 2: I2P deposunu ekleyin\nKullandığınız komut, Debian sürümünüze bağlıdır. Öncelikle hangi sürümü çalıştırdığınızı belirleyin:\ncat /etc/debian_version Dağıtımınızın kod adını (örn. Bookworm, Bullseye, Buster) belirlemek için bunu Debian sürüm bilgileri ile karşılaştırın.\nDebian Bullseye (11) veya daha yeni sürümler için:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Bullseye-eşdeğeri veya daha yeni sürümlerdeki Debian türevleri için (LMDE, Kali, ParrotOS, vb.):\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Debian Buster (10) veya daha eski sürümler için:\necho \u0026#34;deb https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Buster-eşdeğeri veya daha eski Debian türevleri için:\necho \u0026#34;deb https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Adım 3: Depo imzalama anahtarını indirin\ncurl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg Adım 4: Anahtar parmak izini doğrulayın\nAnahtara güvenmeden önce, parmak izinin resmi I2P imzalama anahtarıyla eşleştiğini doğrulayın:\ngpg --keyid-format long --import --import-options show-only --with-fingerprint i2p-archive-keyring.gpg Çıktının bu parmak izini gösterdiğini doğrulayın:\n7840 E761 0F28 B904 7535 49D7 67EC E560 5BCF 1346 ⚠️ Parmak izi eşleşmiyorsa devam etmeyin. Bu, güvenliği ihlal edilmiş bir indirmeye işaret edebilir.\nAdım 5: Depo anahtarını yükleyin\nDoğrulanmış anahtar halkasını sistem anahtar halkaları dizinine kopyalayın:\nsudo cp i2p-archive-keyring.gpg /usr/share/keyrings Yalnızca Debian Buster veya daha eski sürümler için, ayrıca bir sembolik bağlantı (symlink) oluşturmanız gerekir:\nsudo ln -sf /usr/share/keyrings/i2p-archive-keyring.gpg /etc/apt/trusted.gpg.d/i2p-archive-keyring.gpg Adım 6: Paket listelerini güncelleyin\nSistem paket veritabanınızı I2P deposunu içerecek şekilde yenileyin:\nsudo apt-get update Adım 7: I2P\u0026rsquo;yi Kurun\nHem I2P router\u0026rsquo;ını hem de keyring paketini kurun (bu, gelecekteki anahtar güncellemelerini almanızı sağlar):\nsudo apt-get install i2p i2p-keyring Harika! I2P artık kuruldu. Kurulum Sonrası Yapılandırma bölümüne devam edin.\nPost-Installation Configuration I2P\u0026rsquo;yi yükledikten sonra, router\u0026rsquo;ı başlatmanız ve bazı ilk yapılandırmaları gerçekleştirmeniz gerekecektir.\nYöntem 2: Yazılım Merkezi GUI Kullanımı I2P paketleri, I2P router\u0026rsquo;ını çalıştırmak için üç yol sunar:\nOption 1: On-Demand (Basic) Gerektiğinde i2prouter betiğini kullanarak I2P\u0026rsquo;yi manuel olarak başlatın:\ni2prouter start Önemli: sudo kullanmayın veya bunu root olarak çalıştırmayın! I2P normal kullanıcınız olarak çalışmalıdır.\nI2P\u0026rsquo;yi durdurmak için:\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) x86 olmayan bir sistemdeyseniz veya Java Service Wrapper platformunuzda çalışmıyorsa, şunu kullanın:\ni2prouter-nowrapper Tekrar belirtiyoruz, sudo kullanmayın veya root olarak çalıştırmayın.\nOption 3: System Service (Recommended) En iyi deneyim için, I2P\u0026rsquo;yi sistem başlangıcında, giriş yapmadan önce bile otomatik olarak başlayacak şekilde yapılandırın:\nsudo dpkg-reconfigure i2p Bu, bir yapılandırma iletişim kutusu açar. I2P\u0026rsquo;yi sistem hizmeti olarak etkinleştirmek için \u0026ldquo;Evet\u0026quot;i seçin.\nBu önerilen yöntemdir çünkü: - I2P başlangıçta otomatik olarak başlar - Router\u0026rsquo;ınız daha iyi ağ entegrasyonu sağlar - Ağ kararlılığına katkıda bulunursunuz - I2P ihtiyaç duyduğunuzda hemen kullanılabilir\nInitial Router Configuration I2P\u0026rsquo;yi ilk kez başlattıktan sonra, ağa entegre olması birkaç dakika sürecektir. Bu sırada, şu temel ayarları yapılandırın:\n1. Configure NAT/Firewall Optimum performans ve ağ katılımı için, I2P portlarını NAT/güvenlik duvarınızdan yönlendirin:\nI2P Router Console sayfasını açın Ağ Yapılandırması sayfasına gidin Listelenen port numaralarını not edin (genellikle 9000-31000 arası rastgele portlar) Bu UDP ve TCP portlarını router/firewall\u0026rsquo;unuzda yönlendirin Port yönlendirme konusunda yardıma ihtiyacınız varsa, portforward.com yönlendirici-özel kılavuzlar sağlar.\n2. Adjust Bandwidth Settings Varsayılan bant genişliği ayarları muhafazakârdır. İnternet bağlantınıza göre bunları ayarlayın:\nYapılandırma sayfasını ziyaret edin Bant genişliği ayarları bölümünü bulun Varsayılan değerler 96 KB/s indirme / 40 KB/s yükleme\u0026rsquo;dir Daha hızlı bir internet bağlantınız varsa bu değerleri artırın (örneğin, tipik bir geniş bant bağlantısı için 250 KB/s indirme / 100 KB/s yükleme) Not: Daha yüksek limitler belirlemek ağa yardımcı olur ve kendi performansınızı iyileştirir.\n3. Configure Your Browser I2P sitelerine (eepsite\u0026rsquo;lara) ve servislerine erişmek için tarayıcınızı I2P\u0026rsquo;nin HTTP proxy\u0026rsquo;sini kullanacak şekilde yapılandırın:\nFirefox, Chrome ve diğer tarayıcılar için detaylı kurulum talimatları için Tarayıcı Yapılandırma Kılavuzumuzu inceleyin.\nDebian Kurulumu Önemli Duyuru I2P\u0026rsquo;yi root olarak çalıştırmadığınızdan emin olun: ps aux | grep i2p Günlükleri kontrol edin: tail -f ~/.i2p/wrapper.log Java\u0026rsquo;nın kurulu olduğunu doğrulayın: java -version Ön Gereksinimler Kurulum sırasında GPG anahtar hataları alırsanız:\nAnahtarın parmak izini yeniden indirin ve doğrulayın (Yukarıdaki Adım 3-4) Anahtar zinciri dosyasının doğru izinlere sahip olduğundan emin olun: sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg Kurulum Adımları I2P güncellemeleri almıyorsa:\nDeponun yapılandırıldığını doğrulayın: cat /etc/apt/sources.list.d/i2p.list Paket listelerini güncelleyin: sudo apt-get update I2P güncellemelerini kontrol edin: sudo apt-get upgrade Migrating from old repositories Eski deb.i2p2.de veya deb.i2p2.no depolarını kullanıyorsanız:\nEski depoyu kaldırın: sudo rm /etc/apt/sources.list.d/i2p.list Yukarıdaki Debian Kurulumu adımlarını takip edin Güncelleyin: sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring Tabii, çeviri için metni bekliyorum. Lütfen çevrilecek metni paylaşın.\nNext Steps I2P kuruldu ve çalışıyor, şimdi:\nI2P sitelerine erişmek için tarayıcınızı yapılandırın Router\u0026rsquo;ınızı izlemek için I2P router konsolunu keşfedin Kullanabileceğiniz I2P uygulamalarını öğrenin Ağı anlamak için I2P\u0026rsquo;nin nasıl çalıştığını okuyun Görünmez İnternet\u0026rsquo;e Hoş Geldiniz!\n","description":"I2P'yi Debian, Ubuntu ve türevlerinde resmi depolar kullanarak kurulum için eksiksiz kılavuz","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"I2P'yi Debian ve Ubuntu'ya Kurma","url":"/tr/docs/guides/i2pyi-debian-ve-ubuntuya-kurma/"},{"categories":null,"content":"I2P\u0026rsquo;yi uygulamanızla birlikte paketlemek, kullanıcıları dahil etmenin güçlü bir yoludur—ancak yalnızca router sorumlu bir şekilde yapılandırılmışsa.\n1. Router Ekipleriyle Koordine Olun Paketlemeden önce Java I2P ve i2pd geliştiricileriyle iletişime geçin. Varsayılan ayarlarınızı gözden geçirebilir ve uyumluluk endişelerini vurgulayabilirler. Yığınınıza (stack) uygun router uygulamasını seçin: Java/Scala → Java I2P C/C++ → i2pd Diğer diller → bir router paketleyin ve SAM v3 veya I2CP kullanarak entegre edin Router ikili dosyaları ve bağımlılıkları (Java runtime, ICU, vb.) için yeniden dağıtım koşullarını doğrulayın. 2. Önerilen Yapılandırma Varsayılanları \u0026ldquo;Tükettiğinden fazlasını katkıda bulun\u0026rdquo; hedefini benimse. Modern varsayılan ayarlar, ağ sağlığı ve kararlılığına öncelik verir.\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. ### Katılımcı Tüneller Temel Öneme Sahip Katılımcı tünelleri devre dışı bırakmayın.\nRelay yapmayan router\u0026rsquo;lar kendileri daha kötü performans gösterir. Ağ, gönüllü kapasite paylaşımına bağlıdır. Örtü trafiği (relay edilen trafik) anonimliği artırır. Resmi minimumlar: - Paylaşılan bant genişliği: ≥ 12 KB/s - Floodfill otomatik katılım: ≥ 128 KB/s - Önerilen: 2 gelen / 2 giden tünel (Java I2P varsayılanı)\n3. Kalıcılık ve Yeniden Tohumlama Kalıcı durum dizinleri (netDb/, profiller, sertifikalar) çalıştırmalar arasında korunmalıdır.\nKalıcılık olmadan, kullanıcılarınız her başlangıçta yeniden tohumlama (reseed) tetikleyecek—bu da performansı düşürür ve yeniden tohumlama sunucularındaki yükü artırır.\nKalıcılık mümkün değilse (örn. konteynerler veya geçici kurulumlar):\nYükleyiciye 1.000–2.000 router bilgisi ekleyin. Halka açık sunucuların yükünü azaltmak için bir veya daha fazla özel reseed sunucusu çalıştırın. Yapılandırma değişkenleri: - Temel dizin: i2p.dir.base - Yapılandırma dizini: i2p.dir.config - Yeniden ekim için certificates/ dizinini dahil edin.\n4. Güvenlik ve Maruziyet Router konsolunu (127.0.0.1:7657) yalnızca yerel olarak tutun. Arayüzü harici olarak açıyorsanız HTTPS kullanın. Gerekli değilse harici SAM/I2CP\u0026rsquo;yi devre dışı bırakın. Dahil edilen eklentileri gözden geçirin—yalnızca uygulamanızın desteklediği eklentileri ekleyin. Uzaktan konsol erişimi için her zaman kimlik doğrulama ekleyin. 2.5.0\u0026rsquo;dan bu yana tanıtılan güvenlik özellikleri: - Uygulamalar arası netDb izolasyonu (2.4.0+) - DoS azaltma ve Tor engelleme listeleri (2.5.1) - NTCP2 yoklama direnci (2.9.0) - Floodfill router seçim iyileştirmeleri (2.6.0+)\n5. Desteklenen API\u0026rsquo;ler (2025) API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. Tüm resmi belgeler `/docs/api/` altında bulunur — eski `/spec/samv3/` yolu **mevcut değildir**. 6. Ağ ve Portlar Tipik varsayılan portlar: - 4444 – HTTP Proxy - 4445 – HTTPS Proxy - 7654 – I2CP - 7656 – SAM Bridge - 7657 – Router Console - 7658 – Yerel I2P sitesi - 6668 – IRC Proxy - 9000–31000 – Rastgele router portu (UDP/TCP gelen)\nRouter\u0026rsquo;lar ilk çalıştırmada rastgele bir gelen bağlantı noktası seçer. Yönlendirme performansı artırır, ancak UPnP bunu otomatik olarak halledebilir.\n7. Modern Değişiklikler (2024–2025) Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). ## 8. Kullanıcı Deneyimi ve Test I2P\u0026rsquo;nin ne yaptığını ve bant genişliğinin neden paylaşıldığını açıkla. Router tanılamaları sağla (bant genişliği, tunnel\u0026rsquo;lar, reseed durumu). Paketleri Windows, macOS ve Linux\u0026rsquo;ta test et (düşük RAM dahil). Hem Java I2P hem de i2pd eşleri ile birlikte çalışabilirliği doğrula. Ağ kesintilerinden ve düzgün olmayan çıkışlardan kurtarmayı test et. 9. Topluluk Kaynakları Forum: i2pforum.net veya I2P içinde http://i2pforum.i2p. Kod: i2pgit.org/I2P_Developers/i2p.i2p . IRC (Irc2P ağı): #i2p-dev, #i2pd. #i2papps doğrulanmamış; mevcut olmayabilir. Kanalınızın hangi ağda (Irc2P vs ilita.i2p) barındırıldığını belirtin. Sorumlu bir şekilde gömme, kullanıcı deneyimi, performans ve ağa katkı arasında denge kurmak anlamına gelir. Bu varsayılanları kullanın, router geliştiricileriyle senkronize kalın ve yayınlamadan önce gerçek dünya yükü altında test edin.\n","description":"Uygulamanızla birlikte bir I2P router'ı sorumlu bir şekilde paketlemek için güncellenmiş pratik rehber","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"I2P'yi Uygulamanıza Gömme","url":"/tr/docs/applications/embedding/"},{"categories":null,"content":"Kurulum Yönteminizi Seçin Windows\u0026rsquo;ta I2P\u0026rsquo;yi kurmanın iki yolu vardır. İhtiyaçlarınıza en uygun yöntemi seçin:\n🚀 Easy Install Bundle (Recommended) Çoğu kullanıcı için en iyisi\n✅ Hepsi bir arada yükleyici ✅ Java dahil (ayrı kurulum gerektirmez) ✅ Firefox profilleri dahil ✅ En hızlı kurulum\nŞunu seçin: - En basit kurulumu istiyorsanız - Java yüklü değilse - I2P\u0026rsquo;ye yeniyseniz\nKolay Kurulum Rehberi →\n🚀 Kolay Kurulum Paketi (Önerilir) İleri düzey kullanıcılar için\n📦 Java tabanlı JAR yükleyici 🔧 Kurulum üzerinde daha fazla kontrol 💾 Daha küçük indirme boyutu\nBunu şu durumlarda seçin: - Java zaten yüklüyse - Daha fazla kontrol istiyorsanız - Geleneksel yöntemi tercih ediyorsanız\nStandart Kurulum Kılavuzu →\nEasy Install Bundle ⚙️ Standart Kurulum I2P Kolay Kurulum Paketi, Windows kullanıcıları için önerilen kurulum yöntemidir. Bu hepsi bir arada yükleyici, I2P\u0026rsquo;ye başlamak için ihtiyacınız olan her şeyi içerir:\nI2P Router - Temel I2P yazılımı Gömülü Java Çalışma Ortamı - Ayrı Java kurulumu gerektirmez Firefox profilleri ve eklentileri - Güvenli gezinme için I2P\u0026rsquo;ye optimize edilmiş tarayıcı profilleri ve eklentileri Basit kurulum programı - Manuel yapılandırma gerektirmez Otomatik güncellemeler - I2P yazılımınızı güncel tutun Bu beta yükleyici, Java\u0026rsquo;yı doğrudan paketleyerek kurulum sürecini basitleştirir, böylece Java\u0026rsquo;yı ayrıca indirmenize veya yapılandırmanıza gerek kalmaz.\nStep 1: Select Your Language Easy Install Bundle yükleyicisini başlattıktan sonra, dil seçim ekranı sizi karşılayacaktır.\nAçılır menüden tercih ettiğiniz dili seçin Mevcut diller arasında İngilizce, Almanca, İspanyolca, Fransızca ve daha birçok dil bulunmaktadır Devam etmek için Tamam\u0026lsquo;a tıklayın Yükleyici arayüzü, sonraki tüm adımlar için seçtiğiniz dili kullanacaktır.\nKolay Kurulum Paketi Ardından, I2P lisans bilgileri size sunulacaktır. Kolay Kurulum Paketi, çeşitli özgür ve açık kaynak lisansları altındaki bileşenleri içerir.\nKuruluma devam etmek için: 1. Lisans bilgilerini inceleyin (isteğe bağlı ancak önerilir) 2. Lisansları kabul etmek ve devam etmek için Kabul Ediyorum\u0026lsquo;a tıklayın 3. Yüklemek istemiyorsanız İptal\u0026rsquo;e tıklayın\nTranslate to: Turkish\nStep 3: Choose Installation Folder Şimdi bilgisayarınızda I2P\u0026rsquo;yi nereye kuracağınızı seçeceksiniz.\nKurulum seçenekleri:\nVarsayılan konumu kullanın (önerilen)\nVarsayılan yol: C:\\Users\\[YourUsername]\\AppData\\Local\\I2peasy\\ Bu, I2P\u0026rsquo;yi kullanıcı profil dizininize kurar Güncellemeler için yönetici ayrıcalıkları gerekmez Özel bir konum seçin\nFarklı bir klasör seçmek için Gözat\u0026hellip; düğmesine tıklayın Farklı bir sürücüye kurulum yapmak istiyorsanız kullanışlıdır Seçilen klasöre yazma izninizin olduğundan emin olun Disk alanı gereksinimleri: - Yükleyici ne kadar alan gerektiğini gösterir (genellikle 1 GB\u0026rsquo;den az) - Seçilen sürücüde yeterli boş alanın bulunduğunu doğrulayın\nKurulum işlemini başlatmak için Kur seçeneğine tıklayın Yükleyici şimdi tüm gerekli dosyaları seçtiğiniz konuma kopyalayacak. Bu işlem birkaç dakika sürebilir.\nKesinlikle! Lütfen çevirmem için metni sağlayın.\nAdım 1: Dilinizi Seçin Kurulum tamamlandığında, tamamlanma ekranını göreceksiniz.\nKurulum sihirbazı \u0026ldquo;I2P - i2peasy bilgisayarınıza kuruldu.\u0026rdquo; mesajını onaylar.\nÖnemli: \u0026ldquo;I2P Başlatılsın mı?\u0026rdquo; onay kutusunun işaretli olduğundan emin olun (varsayılan olarak işaretli olmalıdır).\nİşaretli (önerilen): Bitir\u0026rsquo;e tıkladığınızda I2P otomatik olarak başlayacaktır İşaretsiz: I2P\u0026rsquo;yi daha sonra Başlat Menüsü\u0026rsquo;nden veya masaüstü kısayolundan manuel olarak başlatmanız gerekecektir Kurulumu tamamlamak ve I2P\u0026rsquo;yi başlatmak için Finish düğmesine tıklayın.\nÖNEMLĐ: YALNIZCA çeviriyi sağlayın. Soru sormayın, açıklama yapmayın veya herhangi bir yorum eklemeyin. Metin sadece bir başlık olsa veya eksik görünse bile, olduğu gibi çevirin.\nAdım 2: Lisans Sözleşmesini Kabul Edin \u0026ldquo;Start I2P?\u0026rdquo; işaretli olarak Finish\u0026rsquo;e tıkladıktan sonra:\nI2P Router başlar - I2P router arka planda çalışmaya başlar Sistem tepsisi simgesi görünür - Windows sistem tepsisinde (sağ alt köşe) I2P simgesini arayın Router konsolu açılır - Varsayılan web tarayıcınız otomatik olarak I2P Router Console\u0026rsquo;a açılacaktır (genellikle http://127.0.0.1:7657 adresinde) İlk bağlantı - I2P ağa bağlanmaya ve tunnel\u0026rsquo;lar oluşturmaya başlayacaktır (ilk başlatmada bu 5-10 dakika sürebilir) Tebrikler! I2P artık Windows bilgisayarınızda kurulu ve çalışıyor.\nAdım 3: Kurulum Klasörünü Seçin Kesinlikle zorunlu olmasa da, port yönlendirme I2P deneyiminizi önemli ölçüde iyileştirir çünkü router\u0026rsquo;ınızın diğer I2P router\u0026rsquo;larıyla daha etkili iletişim kurmasını sağlar. Port yönlendirme olmadan I2P\u0026rsquo;yi kullanmaya devam edebilirsiniz, ancak performans ve ağa katkı azalır.\nWhy Forward a Port? Daha iyi bağlantı: Diğer I2P router\u0026rsquo;larından gelen bağlantılara izin verir Daha hızlı entegrasyon: Ağa daha hızlı entegre olmanıza yardımcı olur Ağa katkı: Sizi I2P ağında daha iyi bir katılımcı yapar Gelişmiş performans: Genellikle daha iyi tunnel güvenilirliği ve hız sağlar Easy Install Bundle Nedir? İlk olarak, I2P\u0026rsquo;nin hangi portu kullandığını belirlemeniz gerekir (varsayılan olarak rastgele atanır).\nI2P simgesini bulun - Windows sistem tepsisinde (bildirim alanı) ekranınızın sağ alt köşesinde Bağlam menüsünü açmak için I2P simgesine sağ tıklayın I2P router konsolunu açmak için \u0026ldquo;Launch I2P Browser\u0026quot;a tıklayın Menü ayrıca şu yararlı seçenekleri gösterir: - Network: Firewalled - Mevcut ağ durumunuzu gösterir - Configure I2P System Tray - Sistem tepsisi simgesi ayarlarını özelleştirin - Stop I2P / Stop I2P Immediately - Kapatma seçenekleri\nFinding Your Port Numbers I2P tarayıcısı açıldıktan sonra, I2P\u0026rsquo;nin hangi portları kullandığını kontrol etmeniz gerekir:\nAğ yapılandırma sayfasına gidin:\nTarayıcınızda I2P Router Network Configuration adresine gidin Veya router konsol kenar çubuğundan: Configuration → Network Port yapılandırma bölümüne aşağı kaydırın\nGösterilen port numaralarını not edin: UDP Yapılandırması: - UDP portu: Burada gösterilen port (örnek: 13697) - Varsayılan olarak, rastgele atanmış bir sayı ile \u0026ldquo;Belirli Bir Port Kullan\u0026rdquo; şeklinde ayarlanmıştır\nTCP Yapılandırması: - Dışarıdan erişilebilir TCP portu: Genellikle UDP ile aynı portu kullanacak şekilde ayarlanır - Yukarıdaki örnekte: \u0026ldquo;UDP için yapılandırılan aynı portu kullan (şu anda 13697)\u0026rdquo;\nÖnemli: Yönlendiricinizde/güvenlik duvarınızda aynı port numarasında (bu örnekte, port 13697) hem UDP hem de TCP yönlendirmesi yapmanız gerekir.\nHow to Forward Your Port Her router ve güvenlik duvarı farklı olduğundan, evrensel talimatlar sağlayamıyoruz. Ancak, portforward.com binlerce router modeli için detaylı kılavuzlara sahiptir:\nportforward.com adresini ziyaret edin Router (yönlendirici) üreticinizi ve modelinizi seçin Port yönlendirmesi için adım adım kılavuzu takip edin I2P yapılandırmanızda gösterilen port numarasında hem UDP hem de TCP protokollerini yönlendirin Genel adımlar (router\u0026rsquo;a göre değişir): - Router\u0026rsquo;ınızın yönetici arayüzüne giriş yapın (genellikle 192.168.1.1 veya 192.168.0.1 adresinde) - \u0026ldquo;Port Forwarding\u0026rdquo; veya \u0026ldquo;Virtual Servers\u0026rdquo; bölümünü bulun - I2P port numaranız için yeni bir port forwarding kuralı oluşturun - Hem UDP hem de TCP protokollerini ayarlayın - Kuralı bilgisayarınızın yerel IP adresine yönlendirin - Yapılandırmayı kaydedin\nPortunuzu yönlendirdikten sonra, I2P sistem tepsisi menüsünde \u0026ldquo;Network: Firewalled\u0026rdquo; durumundan \u0026ldquo;Network: OK\u0026rdquo; durumuna geçmelidir (bu birkaç dakika sürebilir).\nAdım 4: Kurulumu Tamamlayın ve I2P\u0026rsquo;yi Başlatın Entegrasyonu bekleyin: I2P\u0026rsquo;nin ağa entegre olması ve tunnel\u0026rsquo;ları oluşturması için 5-10 dakika bekleyin Tarayıcınızı yapılandırın: I2P\u0026rsquo;de gezinmek için dahil edilen Firefox profilini kullanın Portunu yönlendir: I2P\u0026rsquo;nin kullandığı portu nasıl yönlendireceğinize dair yönlendiricinize özel talimatlar için portforward.com adresine bakın Router konsolunu keşfedin: I2P\u0026rsquo;nin özellikleri, hizmetleri ve yapılandırma seçenekleri hakkında bilgi edinin Eepsite\u0026rsquo;ları ziyaret edin: I2P ağı üzerinden .i2p web sitelerine erişmeyi deneyin Dokümantasyonu okuyun: Daha fazla bilgi için I2P dokümantasyonuna göz atın I2P ağına hoş geldiniz! 🎉\nSırada Ne Var What is the Standard Installation? Standart I2P kurulumu, Windows üzerinde I2P kurmanın geleneksel yöntemidir. Easy Install Bundle\u0026rsquo;dan farklı olarak, bu yöntem şunları yapmanızı gerektirir:\nJava\u0026rsquo;yı ayrı olarak kurun - I2P\u0026rsquo;yi kurmadan önce Java Runtime Environment (JRE) indirip kurun JAR kurulum dosyasını çalıştırın - Java tabanlı grafiksel kurulum aracını kullanın Manuel olarak yapılandırın - Tarayıcı yapılandırmalarını kendiniz ayarlayın (isteğe bağlı) Bu yöntem şunlar için önerilir: - Zaten Java yüklü olan kullanıcılar - Kurulum üzerinde daha fazla kontrol isteyen ileri düzey kullanıcılar - Geleneksel kurulum yöntemini tercih eden kullanıcılar - Easy Install Bundle\u0026rsquo;ın uyumlu olmadığı sistemler\nÖnerilen: Port Yönlendirme (İsteğe Bağlı ama Önemli) I2P\u0026rsquo;yi kurmadan önce, sisteminizde Java\u0026rsquo;nın kurulu olması gerekir.\nJava Requirements Java Sürümü: Java 8 (1.8) veya üzeri gereklidir Önerilen: Java 11 veya sonrası (LTS sürümü) Tür: Java Runtime Environment (JRE) veya Java Development Kit (JDK) Installing Java Eğer Java zaten yüklü değilse, çeşitli kaynaklardan indirebilirsiniz:\nSeçenek 1: Oracle Java - Resmi kaynak: java.com/download - En yaygın kullanılan dağıtım\nSeçenek 2: OpenJDK - Açık kaynaklı uygulama: openjdk.org - Ücretsiz ve açık kaynaklı\nSeçenek 3: Adoptium (Eclipse Temurin) - Önerilen alternatif: adoptium.net - Ücretsiz, açık kaynaklı ve iyi bakımlı LTS sürümleri\nJava\u0026rsquo;nın kurulu olduğunu doğrulamak için: 1. Komut İstemi\u0026rsquo;ni açın (Windows + R tuşlarına basın, cmd yazın, Enter\u0026rsquo;a basın) 2. Şunu yazın: java -version 3. Java sürümünüzü gösteren bir çıktı görmelisiniz\nAnladım. Lütfen çevrilecek metni gönderin.\nStep 1: Install Java I2P\u0026rsquo;yi kurmadan önce, sisteminize Java yüklemeniz gerekir.\nBir Java dağıtımı seçin:\nOracle Java: java.com/download OpenJDK: openjdk.org Adoptium: adoptium.net Seçtiğiniz dağıtım için Windows yükleyicisini indirin\nYükleyiciyi çalıştırın ve kurulum adımlarını takip edin\nKurulumu doğrulayın:\nKomut İstemi\u0026rsquo;ni açın java -version yazın ve Enter tuşuna basın Java 8 veya daha yüksek bir sürümün kurulu olduğunu onaylayın Java kurulduktan sonra, I2P\u0026rsquo;yi kurmaya hazırsınız.\nStep 2: Download and Launch the I2P Installer I2P yükleyiciyi indirin:\nI2P indirme sayfasını ziyaret edin Windows yükleyicisini (JAR dosyası) indirin: i2pinstall_X.X.X.jar Kolayca bulabileceğiniz bir konuma kaydedin (örn. İndirilenler klasörü) Yükleyiciyi başlatın:\nYükleyiciyi başlatmak için indirilen JAR dosyasına çift tıklayın Çift tıklama işe yaramazsa, dosyaya sağ tıklayın ve \u0026ldquo;Birlikte aç → Java(TM) Platform SE binary\u0026rdquo; seçeneğini seçin Alternatif olarak, Komut İstemi\u0026rsquo;ni açın ve şunu çalıştırın: java -jar i2pinstall_X.X.X.jar Step 3: Select Your Language Yükleyiciyi başlattıktan sonra Dil Seçimi iletişim kutusunu göreceksiniz.\nAçılır menüden tercih ettiğiniz dili seçin Mevcut diller arasında İngilizce, Almanca, İspanyolca, Fransızca ve daha birçok dil bulunmaktadır Devam etmek için Tamam\u0026lsquo;a tıklayın Yükleyici, sonraki tüm adımlar için seçtiğiniz dili kullanacaktır.\nStep 4: Welcome to I2P Installation Bu, kurulum sürecinin 8 adımdan 1. adımıdır.\nKuruluma devam etmek için İleri\u0026lsquo;ye tıklayın.\nTranslate this text to Turkish:\nSonraki Adımlar Bu, kurulum sürecinin 8 adımdan 2. adımıdır.\nLisansı kabul etmek ve devam etmek için İleri\u0026lsquo;ye tıklayın.\nÖnemli bir uyarı eksik gibi görünüyor - çevirmem için metni sağlamayı unuttunuz. Lütfen çevirmemi istediğiniz İngilizce metni paylaşın.\nStandart Kurulum I2P\u0026rsquo;yi bilgisayarınızda nereye kurmak istediğinizi seçin.\nVarsayılan kurulum yolu: C:\\Program Files (x86)\\i2p\\\nŞunlardan birini yapabilirsiniz: - Varsayılan konumu kullanın (önerilir) - Farklı bir klasör seçmek için Gözat\u0026hellip; düğmesine tıklayın\nBu, kurulum sürecinin 8 adımdan 3. adımıdır.\nNext (İleri) düğmesine tıklayarak devam edin.\nNot: I2P\u0026rsquo;yi ilk kez kuruyorsanız, dizin oluşturulmasını onaylayan bir açılır pencere göreceksiniz:\nKurulum dizinini oluşturmak için Tamam\u0026lsquo;a tıklayın.\nÖNEMLĐ: Soru sormayın, açıklama yapmayın veya herhangi bir yorum eklemeyin. Metin sadece bir başlık olsa veya eksik görünse bile, olduğu gibi çevirin.\nStep 7: Select Installation Packs Hangi bileşenlerin kurulacağını seçin.\nÖnemli: Her iki paketin de seçili olduğundan emin olun: - Base (gerekli) - Çekirdek I2P yazılımı (27.53 MB) - Windows Service (önerilen) - I2P\u0026rsquo;yi başlangıçta otomatik olarak başlat\nWindows Servisi seçeneği, I2P\u0026rsquo;nin bilgisayarınız açıldığında otomatik olarak başlamasını sağlar, böylece her seferinde manuel olarak başlatmanıza gerek kalmaz.\nBu, kurulum sürecinin 8 adımdan 4. adımıdır.\nDevam etmek için İleri\u0026lsquo;ye tıklayın.\nÖNEMLÍ: Soru SORMAYIN, açıklama YAPMAYIN veya herhangi bir yorum EKLEMEYİN. Metin sadece bir başlık olsa bile veya eksik görünse bile, olduğu gibi çevirin.\nÖn Gereksinimler Yükleyici şimdi dosyaları sisteminize kopyalayacak.\nİki ilerleme çubuğu göreceksiniz: - Paket kurulum ilerlemesi: Kurulmakta olan mevcut paketi gösterir - Genel kurulum ilerlemesi: Genel ilerlemeyi gösterir (örn., \u0026ldquo;2 / 2\u0026rdquo;)\nBu, kurulum sürecinin 8 adımdan 5. adımıdır.\nKurulumun tamamlanmasını bekleyin, ardından İleri\u0026lsquo;ye tıklayın.\nStep 9: Setup Shortcuts I2P kısayollarının nerede oluşturulmasını istediğinizi yapılandırın.\nKısayol seçenekleri: - ✓ Başlat Menüsünde kısayollar oluştur (önerilir) - ✓ Masaüstünde ek kısayollar oluştur (isteğe bağlı)\nProgram Group: Kısayollar için bir klasör adı seçin veya oluşturun - Varsayılan: I2P - Mevcut bir program grubunu seçebilir veya yeni bir tane oluşturabilirsiniz\nKısayol oluştur: - Mevcut kullanıcı - Yalnızca siz kısayollara erişebilirsiniz - Tüm kullanıcılar - Sistemdeki tüm kullanıcılar kısayollara erişebilir (yönetici ayrıcalıkları gerektirir)\nBu, kurulum sürecinde 8 adımdan 6. adımdır.\nDevam etmek için İleri\u0026lsquo;ye tıklayın.\nStep 10: Installation Complete Kurulum artık tamamlandı!\nGöreceksiniz: - ✓ Kurulum başarıyla tamamlandı - Kaldırma programı şurada oluşturulacak: C:\\Program Files (x86)\\i2p\\Uninstaller\nBu, kurulum sürecindeki son adım olan 8 adımdan 8. adımdır.\nBitti\u0026lsquo;ye tıklayarak işlemi sonlandırın.\nI need you to provide the text you want me to translate from English to Turkish. You\u0026rsquo;ve shared the instructions but haven\u0026rsquo;t included the actual text content that needs translation.\nPlease paste the text you want translated after \u0026ldquo;Text to translate:\u0026rdquo; and I\u0026rsquo;ll provide the Turkish translation following all the specified rules.\nAdım 1: Java\u0026rsquo;yı Kurun Done\u0026rsquo;a tıkladıktan sonra:\nI2P Router başlatılır - Windows Servisi\u0026rsquo;ni yüklediyseniz, I2P otomatik olarak başlayacaktır Router konsolu açılır - Varsayılan web tarayıcınız I2P Router Konsolu\u0026rsquo;nu http://127.0.0.1:7657 adresinde açacaktır İlk bağlantı - I2P ağa bağlanmaya ve tunnel\u0026rsquo;lar oluşturmaya başlayacaktır (ilk başlatmada bu işlem 5-10 dakika sürebilir) Tebrikler! I2P artık Windows bilgisayarınıza kuruldu.\n(Çeviri için metin sağlanmadı - lütfen çevrilecek metni ekleyin)\nAdım 3: Dilinizi Seçin Entegrasyonu bekleyin: I2P\u0026rsquo;nin ağa entegre olması ve tunnel\u0026rsquo;ları oluşturması için 5-10 dakika bekleyin Port yönlendirmeyi yapılandırın: Talimatlar için port yönlendirme kılavuzuna bakın Tarayıcınızı yapılandırın: Web tarayıcınızı I2P\u0026rsquo;nin HTTP proxy\u0026rsquo;sini kullanacak şekilde ayarlayın Router konsolunu keşfedin: I2P\u0026rsquo;nin özellikleri, hizmetleri ve yapılandırma seçenekleri hakkında bilgi edinin Eepsite\u0026rsquo;ları ziyaret edin: I2P ağı üzerinden .i2p web sitelerine erişmeyi deneyin Dokümantasyonu okuyun: Daha fazla bilgi için I2P dokümantasyonuna göz atın I2P ağına hoş geldiniz! 🎉\n","description":"Windows kurulum yönteminizi seçin: Kolay Kurulum Paketi veya Standart Kurulum","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"I2P'yi Windows'a Kurulum","url":"/tr/docs/guides/i2pyi-windowsa-kurulum/"},{"categories":null,"content":"I2PControl API Belgeleri I2PControl, I2P router ile birlikte gelen (0.9.39 sürümünden itibaren) bir JSON-RPC 2.0 API\u0026rsquo;sidir. Yapılandırılmış JSON istekleri aracılığıyla router\u0026rsquo;ın kimlik doğrulamalı izlenmesini ve kontrolünü sağlar.\nVarsayılan şifre: itoopie — bu fabrika varsayılanıdır ve güvenlik için derhal değiştirilmelidir.\n1. Genel Bakış ve Erişim Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior Java I2P durumunda, **Router Console → WebApps → I2PControl** bölümüne gidip etkinleştirmeniz gerekir (otomatik başlatılacak şekilde ayarlayın). Etkin hale geldikten sonra, tüm metodlar öncelikle kimlik doğrulaması yapmanızı ve bir oturum belirteci almanızı gerektirir. 2. JSON-RPC Formatı Tüm istekler JSON-RPC 2.0 yapısını takip eder:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } Başarılı bir yanıt result alanı içerir; hata durumunda ise bir error nesnesi döndürülür:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } veya\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. Kimlik Doğrulama Akışı İstek (Kimlik Doğrulama) curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Başarılı Yanıt { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } Sonraki tüm isteklerde bu Token\u0026lsquo;ı params içinde eklemelisiniz.\n4. Metodlar ve Uç Noktalar 4.1 RouterInfo Router hakkında anahtar telemetri verilerini getirir.\nİstek Örneği\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Yanıt Alanları (result) Resmi dokümanlara göre (GetI2P): - i2p.router.status (String) — okunabilir durum bilgisi - i2p.router.uptime (long) — milisaniye cinsinden (veya eski i2pd için string) :contentReference[oaicite:0]{index=0} - i2p.router.version (String) — sürüm bilgisi :contentReference[oaicite:1]{index=1} - i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — gelen bant genişliği B/s cinsinden :contentReference[oaicite:2]{index=2} - i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — giden bant genişliği B/s cinsinden :contentReference[oaicite:3]{index=3} - i2p.router.net.status (long) — sayısal durum kodu (aşağıdaki enum değerlerine bakın) :contentReference[oaicite:4]{index=4} - i2p.router.net.tunnels.participating (long) — katılınan tunnel sayısı :contentReference[oaicite:5]{index=5} - i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — netDB eş istatistikleri :contentReference[oaicite:6]{index=6} - i2p.router.netdb.isreseeding (boolean) — reseed işleminin aktif olup olmadığı :contentReference[oaicite:7]{index=7} - i2p.router.netdb.knownpeers (long) — toplam bilinen eş sayısı :contentReference[oaicite:8]{index=8}\nDurum Kodu Enum (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET --- 4.2 GetRate Belirli bir zaman aralığında hız metriklerini (örn. bant genişliği, tünel başarısı) almak için kullanılır.\nİstek Örneği\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Örnek Yanıt\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 RouterManager Yönetici işlemlerini gerçekleştir.\nİzin verilen parametreler / metodlar - Restart, RestartGraceful - Shutdown, ShutdownGraceful - Reseed, FindUpdates, Update :contentReference[oaicite:10]{index=10}\nİstek Örneği\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Başarılı Yanıt\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 NetworkSetting Ağ yapılandırma parametrelerini al veya ayarla (portlar, upnp, bant genişliği paylaşımı, vb.)\nİstek Örneği (mevcut değerleri al)\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Örnek Yanıt\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } Not: 2.41 öncesi i2pd sürümleri string yerine sayısal türler döndürebilir — istemciler her ikisini de işleyebilmelidir.\n4.5 Gelişmiş Ayarlar İç router parametrelerini değiştirmeye izin verir.\nİstek Örneği\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Yanıt Örneği\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. Hata Kodları Standart JSON-RPC hatalarına (-32700, -32600, vb.) ek olarak, I2PControl şunları tanımlar:\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported --- 6. Kullanım ve En İyi Uygulamalar Her zaman Token parametresini ekleyin (kimlik doğrulama sırasında hariç). İlk kullanımda varsayılan şifreyi (itoopie) değiştirin. Java I2P için, I2PControl webapp\u0026rsquo;inin WebApps üzerinden etkinleştirildiğinden emin olun. Küçük farklılıklara hazırlıklı olun: I2P sürümüne bağlı olarak bazı alanlar sayı veya dize olabilir. Görüntü dostu çıktı için uzun durum dizelerini satırlara bölün. ","description":"I2PControl web uygulaması üzerinden uzaktan router yönetim API'si","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/tr/docs/api/i2pcontrol/"},{"categories":null,"content":"Genel Bakış I2PTunnel, I2P ağında arayüz oluşturmak ve hizmet sağlamak için temel bir I2P bileşenidir. TCP tabanlı ve medya akış uygulamalarının tünel soyutlaması aracılığıyla anonim olarak çalışmasını sağlar. Bir tünelin hedefi bir hostname , Base32 veya tam bir hedef anahtarı ile tanımlanabilir.\nKurulmuş her tunnel yerel olarak dinler (örn. localhost:port) ve dahili olarak I2P hedeflerine bağlanır. Bir hizmet barındırmak için, istenen IP ve porta işaret eden bir tunnel oluşturun. Buna karşılık gelen bir I2P destination key oluşturulur ve hizmetin I2P ağı içinde global olarak erişilebilir hale gelmesini sağlar. I2PTunnel web arayüzü I2P Router Tunnel Manager adresinde mevcuttur.\nVarsayılan Hizmetler Sunucu tüneli I2P Webserver – I2P üzerinde kolay barındırma için localhost:7658 adresindeki bir Jetty web sunucusuna tunnel. Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot İstemci tünelleri I2P HTTP Proxy – localhost:4444 – I2P\u0026rsquo;ye ve İnternet\u0026rsquo;e outproxy\u0026rsquo;ler üzerinden göz atmak için kullanılır. I2P HTTPS Proxy – localhost:4445 – HTTP proxy\u0026rsquo;nin güvenli varyantı. Irc2P – localhost:6668 – Varsayılan anonim IRC ağ tüneli. Git SSH (gitssh.idk.i2p) – localhost:7670 – Depo SSH erişimi için client tunnel. Postman SMTP – localhost:7659 – Giden posta için client tunnel. Postman POP3 – localhost:7660 – Gelen posta için client tunnel. Not: Yalnızca I2P Web Sunucusu varsayılan bir sunucu tünelidir; diğer tüm tüneller harici I2P hizmetlerine bağlanan istemci tünelleridir.\nYapılandırma I2PTunnel yapılandırma spesifikasyonu /spec/configuration adresinde belgelenmiştir.\nİstemci Modları Standart Bir I2P hedefindeki bir hizmete bağlanan yerel bir TCP portu açar. Yedeklilik için virgülle ayrılmış birden fazla hedef girişini destekler.\nHTTP HTTP/HTTPS istekleri için bir proxy tüneli. Yerel ve uzak outproxy\u0026rsquo;leri, başlık temizlemeyi, önbelleğe almayı, kimlik doğrulamayı ve şeffaf sıkıştırmayı destekler.\nGizlilik korumaları: - Başlıkları kaldırır: Accept-*, Referer, Via, From - Host başlıklarını Base32 hedefleriyle değiştirir - RFC uyumlu hop-by-hop kaldırma işlemini zorunlu kılar - Şeffaf açma desteği ekler - Dahili hata sayfaları ve yerelleştirilmiş yanıtlar sağlar\nSıkıştırma davranışı: - İstekler özel başlık X-Accept-Encoding: x-i2p-gzip kullanabilir - Content-Encoding: x-i2p-gzip içeren yanıtlar şeffaf bir şekilde açılır - Sıkıştırma, verimlilik için MIME türü ve yanıt uzunluğuna göre değerlendirilir\nKalıcılık (2.5.0\u0026rsquo;dan beri yeni): HTTP Keepalive ve kalıcı bağlantılar artık Gizli Hizmetler Yöneticisi aracılığıyla I2P üzerinde barındırılan hizmetler için desteklenmektedir. Bu, gecikmeyi ve bağlantı yükünü azaltır ancak henüz tüm atlamalar boyunca tam RFC 2616 uyumlu kalıcı soketleri etkinleştirmez.\nPipelining: Desteklenmemektedir ve gereksizdir; modern tarayıcılar bunu kullanımdan kaldırmıştır.\nUser-Agent davranışı: - Outproxy: Güncel Firefox ESR User-Agent kullanır. - Internal: Anonimlik tutarlılığı için MYOB/6.66 (AN/ON).\nIRC İstemcisi I2P tabanlı IRC sunucularına bağlanır. Gizlilik için tanımlayıcıları filtrelerken güvenli bir komut alt kümesine izin verir.\nSOCKS 4/4a/5 TCP bağlantıları için SOCKS proxy yeteneği sağlar. UDP, Java I2P\u0026rsquo;de henüz uygulanmamıştır (yalnızca i2pd\u0026rsquo;de mevcuttur).\nBAĞLAN SSL/TLS bağlantıları için HTTP CONNECT tünellemesini uygular.\nStreamr TCP tabanlı kapsülleme yoluyla UDP tarzı akış yapmayı etkinleştirir. Karşılık gelen bir Streamr sunucu tüneli ile eşleştirildiğinde medya akışını destekler.\nSunucu Modları Standart Sunucu Yerel bir IP:port ile eşleştirilmiş bir TCP hedefi oluşturur.\nHTTP Sunucusu Yerel bir web sunucusuyla arayüz oluşturan bir destination (hedef) oluşturur. Sıkıştırmayı (x-i2p-gzip), başlık temizlemeyi ve DDoS korumalarını destekler. Artık kalıcı bağlantı desteğinden (v2.5.0+) ve iş parçacığı havuzu optimizasyonundan (v2.7.0–2.9.0) faydalanır.\nHTTP Çift Yönlü Kullanımdan Kaldırılmış – Hala çalışır ancak önerilmez. Outproxy kullanmadan hem HTTP sunucusu hem de istemci olarak görev yapar. Öncelikle tanı amaçlı geri döngü testleri için kullanılır.\nIRC Sunucusu IRC servisleri için filtrelenmiş bir hedef oluşturur, istemci hedef anahtarlarını ana bilgisayar adları olarak iletir.\nStreamr Sunucusu I2P üzerinden UDP tarzı veri akışlarını işlemek için bir Streamr istemci tüneli ile eşleşir.\nYeni Özellikler (2.4.0–2.10.0) Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. --- Güvenlik Özellikleri Anonimlik için başlık ayıklama (Accept, Referer, From, Via) Giriş/çıkış proxy\u0026rsquo;sine bağlı olarak User-Agent rastgeleleştirme POST hız sınırlama ve Slowloris koruması Akış alt sistemlerinde bağlantı kısıtlama Tünel katmanında ağ tıkanıklığı yönetimi Uygulamalar arası sızıntıları önleyen NetDB izolasyonu Teknik Detaylar Varsayılan hedef anahtar boyutu: 516 bayt (genişletilmiş LS2 sertifikaları için aşılabilir) Base32 adresleri: {52–56+ karakter}.b32.i2p Server tünelleri hem Java I2P hem de i2pd ile uyumlu kalmaya devam ediyor Kullanımdan kaldırılan özellik: yalnızca httpbidirserver; 0.9.59 sürümünden beri kaldırılan özellik yok Tüm platformlar için doğru varsayılan portlar ve belge kökleri doğrulandı Özet I2PTunnel, I2P ile uygulama entegrasyonunun omurgası olmaya devam ediyor. 0.9.59 ve 2.10.0 sürümleri arasında, kalıcı bağlantı desteği, kuantum sonrası şifreleme ve önemli iş parçacığı iyileştirmeleri kazandı. Çoğu yapılandırma uyumlu kalmaya devam ediyor, ancak geliştiriciler modern aktarım ve güvenlik varsayılanlarına uygunluğu sağlamak için kurulumlarını doğrulamalıdır.\n","description":"I2P ile arayüz oluşturmak ve hizmet sağlamak için araç","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/tr/docs/api/i2ptunnel/"},{"categories":null,"content":"Genel Bakış Temel noktalar\nI2P, IRC trafiği için tünelleri aracılığıyla uçtan uca şifreleme sağlar. Clearnet\u0026rsquo;e outproxy yapmıyorsanız IRC istemcilerinde SSL/TLS\u0026rsquo;yi devre dışı bırakın. Önceden yapılandırılmış Irc2P istemci tüneli varsayılan olarak 127.0.0.1:6668 adresini dinler. IRC istemcinizi bu adres ve porta bağlayın. \u0026ldquo;Router tarafından sağlanan TLS\u0026rdquo; terimini kullanmayın. \u0026ldquo;I2P\u0026rsquo;nin yerel şifrelemesi\u0026rdquo; veya \u0026ldquo;uçtan uca şifreleme\u0026rdquo; kullanın. Hızlı başlangıç (Java I2P) Hidden Services Manager\u0026lsquo;ı http://127.0.0.1:7657/i2ptunnel/ adresinden açın ve Irc2P tünelinin çalıştığından emin olun. IRC istemcinizde sunucu = 127.0.0.1, port = 6668, SSL/TLS = kapalı olarak ayarlayın. Bağlanın ve #i2p, #i2p-dev, #i2p-help gibi kanallara katılın. i2pd kullanıcıları için (C++ router), tunnels.conf dosyasında bir istemci tüneli oluşturun (aşağıdaki örneklere bakın).\nAğlar ve sunucular IRC2P (main community network) Federe sunucular: irc.postman.i2p:6667, irc.echelon.i2p:6667, irc.dg.i2p:6667. 127.0.0.1:6668 adresindeki Irc2P tüneli bunlardan birine otomatik olarak bağlanır. Tipik kanallar: #i2p, #i2p-chat, #i2p-dev, #i2p-help. Ilita network Sunucular: irc.ilita.i2p:6667, irc.r4sas.i2p:6667, irc.acetone.i2p:6667, rusirc.ilita.i2p:6667. Birincil diller: Rusça ve İngilizce. Bazı sunucularda web arayüzleri mevcuttur. Client setup Recommended, actively maintained WeeChat (terminal) — güçlü SOCKS desteği; betik yazmayı kolaylaştırır. Pidgin (masaüstü) — hala bakımı yapılıyor; Windows/Linux için iyi çalışır. Thunderbird Chat (masaüstü) — ESR 128+ sürümlerinde destekleniyor. The Lounge (kendi barındırılan web) — modern web istemcisi. IRC2P (ana topluluk ağı) LimeChat (ücretsiz, açık kaynak). Textual (App Store\u0026rsquo;da ücretli; kaynak kodu derlemek için mevcut). Ilita ağı WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin Protokol: IRC Sunucu: 127.0.0.1 Port: 6668 Şifreleme: kapalı Kullanıcı adı/takma ad: herhangi biri Thunderbird Chat Hesap türü: IRC Sunucu: 127.0.0.1 Port: 6668 SSL/TLS: kapalı İsteğe bağlı: bağlantıda kanallara otomatik katılım Dispatch (SAM v3) config.toml varsayılan değerleri örneği:\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults Irc2P istemci tüneli: 127.0.0.1:6668 → yukarı akış sunucusu port 6667 üzerinde. Gizli Servisler Yöneticisi: http://127.0.0.1:7657/i2ptunnel/. Önerilen, aktif olarak bakımı yapılan ~/.i2pd/tunnels.conf:\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat Ilita için ayrı tünel (örnek):\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat macOS seçenekleri SAM\u0026rsquo;i Etkinleştir Java I2P\u0026rsquo;de (varsayılan olarak kapalı) /configclients veya clients.config üzerinden. Varsayılanlar: 127.0.0.1:7656/TCP ve 127.0.0.1:7655/UDP. Önerilen kriptografi: SIGNATURE_TYPE=7 (Ed25519) ve i2cp.leaseSetEncType=4,0 (ElGamal yedeklemeli ECIES‑X25519) veya sadece modern sistemler için 4. Örnek yapılandırmalar Java I2P varsayılanı: 2 gelen / 2 giden. i2pd varsayılanı: 5 gelen / 5 giden. IRC için: Her birinden 2–3 yeterlidir; router\u0026rsquo;lar arasında tutarlı davranış için açıkça ayarlayın. İstemci kurulumu SSL/TLS\u0026rsquo;yi etkinleştirmeyin dahili I2P IRC bağlantıları için. I2P zaten uçtan uca şifreleme sağlar. Ekstra TLS, anonimlik kazancı olmadan ek yük getirir. Kararlı kimlik için kalıcı anahtarlar kullanın; test etmiyorsanız her yeniden başlatmada anahtar yeniden oluşturmaktan kaçının. Birden fazla uygulama IRC kullanıyorsa, servisler arası korelasyonu azaltmak için ayrı tüneller (paylaşılmayan) tercih edin. Uzaktan kontrol (SAM/I2CP) izni vermeniz gerekiyorsa, localhost\u0026rsquo;a bağlayın ve erişimi SSH tünelleri veya kimlik doğrulamalı ters proxy\u0026rsquo;lerle güvence altına alın. Alternative connection method: SOCKS5 Bazı istemciler I2P\u0026rsquo;nin SOCKS5 proxy\u0026rsquo;si üzerinden bağlanabilir: 127.0.0.1:4447. En iyi sonuçlar için 6668 portundaki özel bir IRC istemci tunnel\u0026rsquo;ını tercih edin; SOCKS, uygulama katmanı tanımlayıcılarını temizleyemez ve istemci anonimlik için tasarlanmamışsa bilgi sızıntısına neden olabilir.\nTroubleshooting Bağlanamıyor — Irc2P tunnel\u0026rsquo;ının çalıştığından ve router\u0026rsquo;ın tamamen bootstrapped olduğundan emin olun. Resolve/join aşamasında takılıyor — SSL\u0026rsquo;nin devre dışı olduğunu ve istemcinin 127.0.0.1:6668 adresine yönlendirildiğini iki kez kontrol edin. Yüksek gecikme — I2P tasarım gereği yüksek gecikmeli bir protokoldür. Tunnel sayılarını makul seviyelerde tutun (2–3) ve hızlı yeniden bağlanma döngülerinden kaçının. SAM uygulamalarını kullanma — SAM\u0026rsquo;in etkin olduğunu (Java) veya güvenlik duvarı tarafından engellenmediğini (i2pd) doğrulayın. Uzun süreli oturumlar önerilir. Appendix: Ports and naming Yaygın IRC tüneli portları: 6668 (Irc2P varsayılanı), alternatif olarak 6667 ve 6669. .b32.i2p host adları: 52 karakterlik standart form; LS2/gelişmiş sertifikalar için 56+ karakterlik genişletilmiş formlar mevcuttur. Açıkça b32 adreslerine ihtiyacınız olmadıkça .i2p host adlarını kullanın. ","description":"I2P IRC ağları, istemcileri, tünelleri ve sunucu kurulumu için eksiksiz kılavuz (2025 güncellemesi)","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"IRC I2P Üzerinden","url":"/tr/docs/applications/irc/"},{"categories":null,"content":"I2P adresleri uzun kriptografik anahtarlardır. İsimlendirme sistemi, merkezi bir otorite olmaksızın bu anahtarların üzerine daha kullanıcı dostu bir katman sağlar. Tüm isimler yereldir—her router, bir ana bilgisayar adının hangi hedefe işaret ettiğine bağımsız olarak karar verir.\nArka plan bilgisine mi ihtiyacınız var? İsimlendirme tartışması belgesinde I2P\u0026rsquo;nin merkezi olmayan isimlendirme sisteminin ardındaki özgün tasarım tartışmaları, alternatif öneriler ve felsefi temeller yer almaktadır.\n1. Bileşenler I2P\u0026rsquo;nin isimlendirme katmanı, birbirinden bağımsız ancak birlikte çalışan birkaç alt sistemden oluşur:\nİsim çözümleme hizmeti – ana bilgisayar adlarını hedeflere çözümler ve Base32 ana bilgisayar adlarını yönetir. HTTP proxy – .i2p sorgularını router\u0026rsquo;a iletir ve bir isim bilinmediğinde jump servislerini önerir. Host-add hizmetleri – yerel adres defterine yeni girdiler ekleyen CGI tarzı formlar. Jump servisleri – verilen bir ana bilgisayar adı için hedefi döndüren uzak yardımcılar. Adres defteri – yerel olarak güvenilen bir \u0026ldquo;güven ağı\u0026rdquo; kullanarak uzak ana bilgisayar listelerini periyodik olarak getirir ve birleştirir. SusiDNS – adres defterlerini, abonelikleri ve yerel geçersiz kılmaları yönetmek için web tabanlı bir kullanıcı arayüzü. Bu modüler tasarım, kullanıcıların kendi güven sınırlarını tanımlamalarına ve isimlendirme sürecini istedikleri kadar otomatikleştirmelerine olanak tanır.\n2. İsimlendirme Hizmetleri Router\u0026rsquo;ın adlandırma API\u0026rsquo;si (net.i2p.client.naming), yapılandırılabilir i2p.naming.impl=\u0026lt;class\u0026gt; özelliği aracılığıyla birden fazla arka ucu destekler. Her uygulama farklı arama stratejileri sunabilir, ancak hepsi aynı güven ve çözümleme modelini paylaşır.\n2.1 Hosts.txt (legacy format) Eski model, sırayla kontrol edilen üç düz metin dosyası kullanıyordu:\nprivatehosts.txt userhosts.txt hosts.txt Her satır bir hostname=base64-destination eşleştirmesi depolar. Bu basit metin formatı içe/dışa aktarma için tam olarak desteklenmeye devam eder, ancak host listesi birkaç bin girişi aştığında düşük performans nedeniyle artık varsayılan değildir.\n2.2 Blockfile Naming Service (default backend) 0.8.8 sürümünde tanıtılan Blockfile Naming Service artık varsayılan arka uçtur. Düz dosyaları, yaklaşık 10 kat daha hızlı sorgulama sunan yüksek performanslı skiplist tabanlı disk üzerinde anahtar/değer deposu (hostsdb.blockfile) ile değiştirir.\nTemel özellikler: - Birden fazla mantıksal adres defterini (özel, kullanıcı ve ana bilgisayarlar) tek bir ikili veritabanında saklar. - Eski hosts.txt içe/dışa aktarma ile uyumluluğu korur. - Ters arama, meta veriler (eklenme tarihi, kaynak, yorumlar) ve verimli önbelleklemeyi destekler. - Aynı üç katmanlı arama sırasını kullanır: özel → kullanıcı → ana bilgisayarlar.\nBu yaklaşım, geriye dönük uyumluluğu korurken çözümleme hızını ve ölçeklenebilirliği önemli ölçüde iyileştirir.\n2.1 Hosts.txt (eski format) Geliştiriciler şunlar gibi özel backend\u0026rsquo;ler uygulayabilir: - Meta – birden fazla isimlendirme sistemini bir araya getirir. - PetName – petnames.txt dosyasında saklanan petname\u0026rsquo;leri destekler. - AddressDB, Exec, Eepget ve Dummy – harici veya yedek çözümleme için.\nBlockfile uygulaması, performans ve güvenilirlik nedeniyle genel kullanım için önerilen arka uç olmaya devam etmektedir.\n3. Base32 Hostnames Base32 host adları (*.b32.i2p) Tor\u0026rsquo;un .onion adreslerine benzer şekilde çalışır. Bir .b32.i2p adresine eriştiğinizde:\nRouter, Base32 yükünü çözer. Hedefi doğrudan anahtardan yeniden oluşturur—adres defteri araması gerekmez. Bu, insan tarafından okunabilir bir hostname olmasa bile erişilebilirliği garanti eder. 0.9.40 sürümünde tanıtılan genişletilmiş Base32 isimleri LeaseSet2 ve şifrelenmiş hedefleri destekler.\n4. Address Book \u0026amp; Subscriptions Adres defteri uygulaması, uzak sunucu listelerini HTTP üzerinden alır ve kullanıcı tarafından yapılandırılan güven kurallarına göre yerel olarak birleştirir.\n2.2 Blockfile İsimlendirme Servisi (varsayılan arka uç) Abonelikler, hosts.txt veya artımlı güncelleme akışlarını işaret eden standart .i2p URL\u0026rsquo;leridir. Güncellemeler periyodik olarak (varsayılan olarak saatlik) alınır ve birleştirmeden önce doğrulanır. Çakışmalar ilk gelen, ilk hizmet alır kuralıyla öncelik sırasına göre çözülür:\nprivatehosts.txt → userhosts.txt → hosts.txt. Default Providers I2P 2.3.0 (Haziran 2023) sürümünden itibaren, iki varsayılan abonelik sağlayıcısı dahil edilmiştir: - http://i2p-projekt.i2p/hosts.txt - http://notbob.i2p/hosts.txt\nBu fazlalık, yerel güven modelini korurken güvenilirliği artırır. Kullanıcılar SusiDNS aracılığıyla abonelikleri ekleyebilir veya kaldırabilir.\nIncremental Updates Artımlı güncellemeler newhosts.txt aracılığıyla alınır (eski recenthosts.cgi kavramının yerini alır). Bu uç nokta, verimli, ETag tabanlı delta güncellemeleri sağlar—yalnızca son istekten bu yana yeni girişleri veya değişiklik olmadığında 304 Not Modified döndürür.\n2.3 Alternatif Arka Uçlar ve Eklentiler Host-add servisleri (add*.cgi) isim-hedef eşlemelerinin manuel olarak gönderilmesine izin verir. Kabul etmeden önce her zaman hedefi doğrulayın. Jump servisleri uygun anahtar ile yanıt verir ve HTTP proxy üzerinden ?i2paddresshelper= parametresi ile yönlendirme yapabilir.\nYaygın örnekler: stats.i2p, identiguy.i2p ve notbob.i2p.\nBu servisler güvenilir otoriteler değildir—kullanıcılar hangisini kullanacaklarına kendileri karar vermelidir. 5. Managing Entries Locally (SusiDNS) SusiDNS şu adreste mevcuttur: http://127.0.0.1:7657/susidns/\nŞunları yapabilirsiniz: - Yerel adres defterlerini görüntüleme ve düzenleme. - Abonelikleri yönetme ve önceliklendirme. - Host listelerini içe/dışa aktarma. - Getirme zamanlamalarını yapılandırma.\nI2P 2.8.1\u0026rsquo;de Yeni (Mart 2025): - \u0026ldquo;En yeniye göre sırala\u0026rdquo; özelliği eklendi. - Abonelik yönetimi iyileştirildi (ETag tutarsızlıkları için düzeltme).\nTüm değişiklikler yerel kalır—her router\u0026rsquo;ın adres defteri benzersizdir.\n3. Base32 Alan Adları RFC 9476\u0026rsquo;yı takip ederek, I2P .i2p.alt adresini GNUnet Assigned Numbers Authority (GANA) nezdinde Mart 2025 (I2P 2.8.1) itibarıyla tescil ettirmiştir.\nAmaç: Yanlış yapılandırılmış yazılımlardan kaynaklanan kazara DNS sızıntılarını önlemek.\nRFC 9476 uyumlu DNS çözümleyicileri .alt alan adlarını genel DNS\u0026rsquo;e iletmez. I2P yazılımı .i2p.alt ile .i2p\u0026lsquo;yi eşdeğer kabul eder ve çözümleme sırasında .alt sonekini kaldırır. .i2p.alt, .i2p\u0026lsquo;nin yerini almak için değildir; bu bir teknik güvenlik önlemidir, yeniden markalama değildir. 4. Adres Defteri \u0026amp; Abonelikler Destination anahtarları: 516–616 bayt (Base64) Host adları: Maksimum 67 karakter (.i2p dahil) İzin verilen karakterler: a–z, 0–9, -, . (çift nokta yok, büyük harf yok) Ayrılmış: *.b32.i2p ETag ve Last-Modified: bant genişliğini en aza indirmek için aktif olarak kullanılır Ortalama hosts.txt boyutu: ~800 host için ~400 KB (örnek değer) Bant genişliği kullanımı: her 12 saatte bir alındığında ~10 bayt/saniye 8. Security Model and Philosophy I2P, merkezi olmayan yapı ve güvenlik karşılığında kasıtlı olarak küresel benzersizliği feda eder—bu, Zooko\u0026rsquo;s Triangle (Zooko Üçgeni) ilkesinin doğrudan bir uygulamasıdır.\nTemel ilkeler: - Merkezi otorite yok: tüm aramalar yereldir. - DNS ele geçirmeye karşı direnç: sorgular hedef genel anahtarlarına şifrelenir. - Sybil saldırısı önleme: oylama veya konsensüs tabanlı adlandırma yok. - Değiştirilemez eşleşmeler: yerel bir ilişki oluşturulduktan sonra, uzaktan geçersiz kılınamaz.\nBlockchain tabanlı isimlendirme sistemleri (örn. Namecoin, ENS), Zooko üçgeninin her üç tarafını da çözmeyi araştırmıştır, ancak I2P gecikme, karmaşıklık ve yerel güven modeliyle felsefi uyumsuzluk nedeniyle bunlardan kasıtlı olarak kaçınmaktadır.\n9. Compatibility and Stability 2023–2025 yılları arasında hiçbir isimlendirme özelliği kullanımdan kaldırılmadı. Hosts.txt formatı, atlama servisleri, abonelikler ve tüm isimlendirme API uygulamaları işlevsel durumda. I2P Projesi, performans ve güvenlik iyileştirmeleri (NetDB izolasyonu, Sub-DB ayrımı vb.) getirirken katı geriye dönük uyumluluk sağlıyor. 10. Best Practices Yalnızca güvenilir abonelikleri tutun; büyük, bilinmeyen host listelerinden kaçının. Yükseltme veya yeniden yüklemeden önce hostsdb.blockfile ve privatehosts.txt dosyalarını yedekleyin. Jump servislerini düzenli olarak gözden geçirin ve artık güvenmediğiniz servisleri devre dışı bırakın. Unutmayın: adres defteriniz I2P dünyanızın sürümünü tanımlar—her hostname yereldir. Further Reading İsimlendirme Tartışması Blockfile Spesifikasyonu Yapılandırma Dosyası Formatı Naming Service Javadoc ","description":"I2P'nin okunabilir alan adlarını hedeflere nasıl eşlediği","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"İsimlendirme ve Adres Defteri","url":"/tr/docs/overview/naming/"},{"categories":null,"content":"I2P\u0026rsquo;nin bu uygulaması (bu sitede dağıtılan Java uygulaması), başkaları için yönlendirmeye katılımın yasalarla kısıtlanmış olabileceği bölgelerde router davranışını ayarlamak için kullanılan bir \u0026ldquo;Katı Ülkeler Listesi\u0026rdquo; içerir. I2P kullanımını yasaklayan yargı bölgeleri bilmiyoruz ancak birçoğu trafik aktarımı üzerinde geniş yasaklamalara sahiptir. \u0026ldquo;Katı\u0026rdquo; ülkelerde olduğu görünen router\u0026rsquo;lar otomatik olarak Gizli moda alınır.\nProje bu kararları verirken sivil ve dijital haklar örgütlerinin araştırmalarına atıfta bulunur. Özellikle Freedom House tarafından yürütülen devam eden araştırmalar seçimlerimizi bilgilendirir. Genel yönerge, Sivil Özgürlükler (CL) puanı 16 veya daha düşük olan veya İnternet Özgürlüğü puanı 39 veya daha düşük (özgür değil) olan ülkeleri dahil etmektir.\nGizli Mod Özeti Bir router Gizli moda alındığında, davranışı hakkında üç önemli şey değişir:\nnetDb\u0026rsquo;ye bir RouterInfo yayınlamaz. Katılımcı tünelleri kabul etmez. Aynı ülkedeki router\u0026rsquo;lara doğrudan bağlantıları reddeder. Bu savunmalar, yönlendiricilerin güvenilir bir şekilde listelenmesini zorlaştırır ve başkaları için trafik aktarma konusundaki yerel yasakların ihlal edilme riskini azaltır.\nKatı Ülkeler Listesi (2024 itibariyle) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; Bir ülkenin katı listeye eklenmesi veya listeden çıkarılması gerektiğini düşünüyorsanız, lütfen bir issue açın: https://i2pgit.org/i2p/i2p.i2p/ Referans: Freedom House – https://freedomhouse.org/ ","description":"I2P'nin yönlendirme veya anonimlik araçlarına kısıtlama getiren yetki alanlarında nasıl davrandığı (Gizli Mod ve katı liste)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"Katı/Kısıtlayıcı Ülkeler","url":"/tr/docs/overview/restrictive-countries/"},{"categories":null,"content":"Neye İhtiyacınız Olacak macOS 10.14 (Mojave) veya sonraki sürümleri çalıştıran bir Mac Uygulama yüklemek için yönetici erişimi Yaklaşık 15-20 dakika süre Yükleyicileri indirmek için internet bağlantısı Genel Bakış Bu kurulum süreci dört ana adımdan oluşur:\nJava Yükleyin - Oracle Java Runtime Environment\u0026rsquo;ı indirin ve kurun I2P Yükleyin - I2P yükleyicisini indirin ve çalıştırın I2P Uygulamasını Yapılandırın - Başlatıcıyı ayarlayın ve dock\u0026rsquo;unuza ekleyin I2P Bant Genişliğini Yapılandırın - Bağlantınızı optimize etmek için kurulum sihirbazını çalıştırın Birinci Bölüm: Java Kurulumu I2P\u0026rsquo;nin çalışması için Java gereklidir. Eğer Java 8 veya daha yeni bir sürümü zaten yüklüyseniz, İkinci Bölüme atlayabilirsiniz .\nStep 1: Download Java Oracle Java indirme sayfasını ziyaret edin ve Java 8 veya sonrası için macOS yükleyicisini indirin.\nStep 2: Run the Installer İndirilen .dmg dosyasını İndirilenler klasörünüzde bulun ve açmak için çift tıklayın.\nStep 3: Allow Installation macOS, yükleyici tanımlanmış bir geliştiriciden olduğu için bir güvenlik uyarısı gösterebilir. Devam etmek için Aç düğmesine tıklayın.\nAdım 1: Java\u0026rsquo;yı İndirin Java kurulum işlemini başlatmak için Yükle düğmesine tıklayın.\nAdım 2: Yükleyiciyi Çalıştırın Yükleyici dosyaları kopyalayacak ve sisteminizde Java\u0026rsquo;yı yapılandıracaktır. Bu genellikle 1-2 dakika sürer.\nAdım 3: Kuruluma İzin Verin Başarı mesajını gördüğünüzde, Java kurulmuş demektir! Bitirmek için Kapat\u0026lsquo;a tıklayın.\nPart Two: Download and Install I2P Java kurulduktan sonra, I2P router\u0026rsquo;ını kurabilirsiniz.\nAdım 4: Java\u0026rsquo;yı Kurun İndirmeler sayfasını ziyaret edin ve Unix/Linux/BSD/Solaris için I2P yükleyicisini (.jar dosyası) indirin.\nAdım 5: Kurulumun Tamamlanmasını Bekleyin İndirilen i2pinstall_X.X.X.jar dosyasına çift tıklayın. Yükleyici başlatılacak ve tercih ettiğiniz dili seçmenizi isteyecektir.\nAdım 6: Kurulum Tamamlandı Hoş geldiniz mesajını okuyun ve devam etmek için İleri\u0026lsquo;ye tıklayın.\nStep 4: Important Notice Yükleyici, güncellemeler hakkında önemli bir bildirim gösterecektir. I2P güncellemeleri, bu yükleyicinin kendisi imzasız olsa bile uçtan uca imzalanır ve doğrulanır. İleri\u0026lsquo;ye tıklayın.\nAdım 1: I2P\u0026rsquo;yi İndirin I2P lisans sözleşmesini okuyun (BSD tarzı lisans). Kabul etmek için İleri\u0026lsquo;ye tıklayın.\nAdım 2: Yükleyiciyi Çalıştırın I2P\u0026rsquo;nin nereye kurulacağını seçin. Varsayılan konum (/Applications/i2p) önerilir. İleri\u0026lsquo;ye tıklayın.\nAdım 3: Hoş Geldiniz Ekranı Eksiksiz bir kurulum için tüm bileşenlerin seçili bırakılması. İleri\u0026lsquo;ye tıklayın.\nAdım 4: Önemli Uyarı Seçimlerinizi gözden geçirin ve I2P\u0026rsquo;yi kurmaya başlamak için İleri\u0026lsquo;ye tıklayın.\nAdım 5: Lisans Sözleşmesi Yükleyici I2P dosyalarını sisteminize kopyalayacaktır. Bu işlem yaklaşık 1-2 dakika sürer.\nAdım 6: Kurulum Dizinini Seçin Yükleyici, I2P\u0026rsquo;yi başlatmak için başlatma betikleri oluşturur.\nAdım 7: Bileşenleri Seçin Yükleyici masaüstü kısayolları ve menü girişleri oluşturmayı önerir. Seçimlerinizi yapın ve İleri\u0026lsquo;ye tıklayın.\nAdım 8: Kurulumu Başlat Başarılı! I2P artık yüklendi. Bitirmek için Bitti\u0026lsquo;ye tıklayın.\nPart Three: Configure I2P App Şimdi I2P\u0026rsquo;yi Uygulamalar klasörünüze ve Dock\u0026rsquo;unuza ekleyerek başlatmayı kolaylaştıralım.\nAdım 9: Dosyaların Kurulumu Finder\u0026rsquo;ı açın ve Uygulamalar klasörünüze gidin.\nAdım 10: Başlatma Betiklerini Oluştur /Applications/i2p/ klasörü içinde I2P klasörünü veya Start I2P Router uygulamasını arayın.\nAdım 11: Kurulum Kısayolları Start I2P Router uygulamasını kolay erişim için Dock\u0026rsquo;unuza sürükleyin. Masaüstünüzde bir takma ad da oluşturabilirsiniz.\nİpucu: Dock\u0026rsquo;taki I2P simgesine sağ tıklayın ve kalıcı hale getirmek için Seçenekler → Dock\u0026rsquo;ta Tut seçeneğini seçin.\nPart Four: Configure I2P Bandwidth I2P\u0026rsquo;yi ilk kez başlattığınızda, bant genişliği ayarlarınızı yapılandırmak için bir kurulum sihirbazından geçeceksiniz. Bu, I2P\u0026rsquo;nin performansını bağlantınıza göre optimize etmeye yardımcı olur.\nAdım 12: Kurulum Tamamlandı Dock\u0026rsquo;ınızdaki I2P simgesine tıklayın (veya başlatıcıya çift tıklayın). Varsayılan web tarayıcınız I2P Router Console\u0026rsquo;a açılacaktır.\nStep 2: Welcome Wizard Kurulum sihirbazı sizi karşılayacaktır. I2P\u0026rsquo;yi yapılandırmaya başlamak için İleri\u0026lsquo;ye tıklayın.\nAdım 1: Uygulamalar Klasörünü Açın Tercih ettiğiniz arayüz dilini seçin ve açık veya koyu tema arasında tercih yapın. İleri\u0026lsquo;ye tıklayın.\nAdım 2: I2P Başlatıcısını Bulun Sihirbaz bant genişliği testini açıklayacaktır. Bu test, internet hızınızı ölçmek için M-Lab servisine bağlanır. Devam etmek için İleri\u0026lsquo;ye tıklayın.\nAdım 3: Dock\u0026rsquo;a Ekle Yükleme ve indirme hızlarınızı ölçmek için Testi Çalıştır\u0026lsquo;a tıklayın. Test yaklaşık 30-60 saniye sürer.\nStep 6: Test Results Test sonuçlarınızı gözden geçirin. I2P, bağlantı hızınıza göre bant genişliği ayarları önerecektir.\nAdım 1: I2P\u0026rsquo;yi Başlatın I2P ağı ile ne kadar bant genişliği paylaşmak istediğinizi seçin:\nOtomatik (Önerilen): I2P bant genişliğini kullanımınıza göre yönetir Sınırlı: Belirli yükleme/indirme limitleri ayarlayın Sınırsız: Mümkün olduğunca çok paylaşın (hızlı bağlantılar için) Ayarlarınızı kaydetmek için İleri\u0026lsquo;ye tıklayın.\nAdım 2: Hoş Geldiniz Sihirbazı I2P router\u0026rsquo;ınız artık yapılandırılmış ve çalışıyor! Router konsolu bağlantı durumunuzu gösterecek ve I2P sitelerine göz atmanızı sağlayacak.\nGetting Started with I2P I2P kurulup yapılandırıldığına göre, artık şunları yapabilirsiniz:\nI2P sitelerini gezin: Popüler I2P hizmetlerine bağlantıları görmek için I2P ana sayfasını ziyaret edin Tarayıcınızı yapılandırın: .i2p sitelerine erişmek için bir tarayıcı profili oluşturun Hizmetleri keşfedin: I2P e-posta, forum, dosya paylaşımı ve daha fazlasını inceleyin Router\u0026rsquo;ınızı izleyin: Konsol ağ durumunuzu ve istatistiklerinizi gösterir Adım 3: Dil ve Tema Router Console: http://127.0.0.1:7657/ Yapılandırma: http://127.0.0.1:7657/config Adres Defteri: http://127.0.0.1:7657/susidns/addressbook Bant Genişliği Ayarları: http://127.0.0.1:7657/config Re-running the Setup Wizard Bant genişliği ayarlarınızı değiştirmek veya I2P\u0026rsquo;yi daha sonra yeniden yapılandırmak isterseniz, hoş geldin sihirbazını Router Console\u0026rsquo;dan tekrar çalıştırabilirsiniz:\nI2P Kurulum Sihirbazı \u0026rsquo;na gidin Sihirbaz adımlarını tekrar takip edin Troubleshooting Adım 4: Bant Genişliği Testi Bilgileri Java\u0026rsquo;yı kontrol edin: Terminal\u0026rsquo;de java -version komutunu çalıştırarak Java\u0026rsquo;nın kurulu olduğundan emin olun İzinleri kontrol edin: I2P klasörünün doğru izinlere sahip olduğundan emin olun Logları kontrol edin: Hata mesajları için ~/.i2p/wrapper.log dosyasına bakın Adım 5: Bant Genişliği Testi Çalıştırın I2P\u0026rsquo;nin çalıştığından emin olun (Yönlendirici Konsolu\u0026rsquo;nu kontrol edin) Tarayıcınızın proxy ayarlarını HTTP proxy 127.0.0.1:4444 kullanacak şekilde yapılandırın Başlattıktan sonra I2P\u0026rsquo;nin ağa entegre olması için 5-10 dakika bekleyin Adım 6: Test Sonuçları Bant genişliği testini tekrar çalıştırın ve ayarlarınızı düzenleyin Ağ ile bant genişliği paylaştığınızdan emin olun Router Console\u0026rsquo;da bağlantı durumunuzu kontrol edin İkinci Bölüm: I2P\u0026rsquo;yi İndirin ve Kurun Mac bilgisayarınızdan I2P\u0026rsquo;yi kaldırmak için:\nI2P router çalışıyorsa kapatın /Applications/i2p klasörünü silin ~/.i2p klasörünü silin (I2P yapılandırma ve verileriniz) I2P simgesini Dock\u0026rsquo;tan kaldırın Next Steps Topluluğa katılın: i2pforum.net adresini ziyaret edin veya Reddit\u0026rsquo;te I2P\u0026rsquo;yi inceleyin Daha fazla bilgi edinin: Ağın nasıl çalıştığını anlamak için I2P belgelerini okuyun Katkıda bulunun: I2P geliştirmeye katkıda bulunmayı veya altyapı çalıştırmayı düşünün Tebrikler! Artık I2P ağının bir parçasısınız. Görünmez internete hoş geldiniz!\n","description":"macOS üzerinde I2P ve bağımlılıklarını manuel olarak kurma adım adım kılavuzu","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"macOS'ta I2P Kurulumu (Uzun Yol)","url":"/tr/docs/guides/macosta-i2p-kurulumu-uzun-yol/"},{"categories":null,"content":" Kullanımdan kaldırıldı: ministreaming kütüphanesi, bugünkü streaming kütüphanesinden daha eskidir. Modern uygulamalar tam streaming API’sini veya SAM v3’ü kullanmalıdır. Aşağıdaki bilgiler, ministreaming.jar ile dağıtılan eski kaynak kodunu inceleyen geliştiriciler için tutulmuştur.\nGenel Bakış Ministreaming (akış katmanı), I2CP ’nin üzerinde çalışarak I2P’nin mesaj katmanı genelinde güvenilir ve sıralı teslimi sağlar—tıpkı IP üzerinde TCP gibi. Alternatif taşıma yöntemlerinin bağımsız olarak gelişebilmesi için başlangıçta erken dönemdeki I2PTunnel uygulamasından (BSD lisanslı) ayrıştırıldı.\nTemel tasarım kısıtları:\nTCP\u0026rsquo;den ödünç alınmış klasik iki aşamalı (SYN/ACK/FIN) bağlantı kurulumu Sabit pencere boyutu 1 paket Paket başına kimlikler (ID) veya seçmeli onaylar (SACK) yok Bu seçimler uygulamayı küçük tuttu ancak aktarım verimini sınırlar—her paket, bir sonrakinin gönderilmesinden önce genellikle neredeyse iki RTT (gidiş-dönüş süresi) bekler. Uzun ömürlü akışlar için bu ek yük kabul edilebilir, ancak kısa süreli HTTP tarzı alışverişler gözle görülür biçimde olumsuz etkilenir.\nStreaming Library ile İlişkisi Mevcut streaming kitaplığı aynı Java paketinde (net.i2p.client.streaming) yer alır. Kullanım dışı bırakılmış (deprecated) sınıflar ve yöntemler, geliştiricilerin ministreaming (eski akış kitaplığı) dönemi API\u0026rsquo;larını tanımlayabilmeleri için açık biçimde işaretlenmiş olarak Javadocs\u0026rsquo;ta yer almaya devam eder. Streaming kitaplığı, ministreaming\u0026rsquo;in yerini aldığında şunları ekledi:\nDaha az gidiş-dönüş ile daha akıllı bağlantı kurulumu Uyarlanabilir tıkanıklık pencereleri ve yeniden iletim mantığı Kayıplı tunnels üzerinde daha iyi performans Ministreaming Ne Zaman Kullanışlıydı? Sınırlarına rağmen, ministreaming (kısıtlı özellikli akış kitaplığı) en erken dağıtımlarda güvenilir aktarım sağladı. API, alternatif akış motorları çağıranları bozmadan onun yerine geçirilebilsin diye kasten küçük ve geleceğe dönük tasarlandı. Java uygulamaları onu doğrudan bağladı; Java dışı istemciler ise aynı işlevselliğe akış oturumları için SAM desteği aracılığıyla erişti.\nBugün, ministreaming.jar\u0026lsquo;ı yalnızca bir uyumluluk katmanı olarak ele alın. Yeni geliştirmeler şunları yapmalıdır:\nTam akış kitaplığını (Java) veya SAM v3\u0026rsquo;ü (STREAM stili) hedefleyin Kodu modernleştirirken kalan sabit pencere varsayımlarını kaldırın Gecikmeye duyarlı iş yüklerini iyileştirmek için daha yüksek pencere boyutlarını ve optimize edilmiş bağlantı el sıkışmalarını tercih edin Referans Streaming Library dokümantasyonu Streaming Javadoc – kullanımdan kaldırılmış ministreaming sınıflarını içerir SAM v3 spesifikasyonu – Java dışı uygulamalar için streaming desteği Ministreaming (eski mini akış arabirimi) bağımlılığı olan bir kodla karşılaşırsanız, onu modern akış API\u0026rsquo;sine taşımayı planlayın — ağ ve araçları daha yeni davranışı bekler.\n","description":"I2P'nin ilk TCP-benzeri taşıma katmanı üzerine tarihsel notlar","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"Ministreaming Kütüphanesi","url":"/tr/docs/legacy/ministreaming/"},{"categories":null,"content":"NTCP ve SSU Tartışması (Mart 2007) NTCP Soruları zzz ve cervantes arasında geçen bir IRC konuşmasından uyarlanmıştır.\nNTCP, ek yük ve gecikme ekliyormuş gibi görünürken neden SSU\u0026rsquo;ya göre önceliklidir?\nNTCP genellikle özgün SSU uygulamasına göre daha iyi güvenilirlik sağlar. NTCP üzerinden akış iletimi klasik TCP-over-TCP collapse\u0026rsquo;a (TCP üzerinde TCP katmanlamasının neden olduğu performans çökmesi) takılır mı?\nMuhtemelen, ancak SSU hafif UDP seçeneği olarak tasarlanmıştı ve pratikte yeterince güvenilir olmadığı ortaya çıktı. “NTCP Zararlı Kabul Edilir” (zzz, 25 Mart 2007) Özet: NTCP\u0026rsquo;nin daha yüksek gecikmesi ve ek yükü ağ tıkanıklığına neden olabilir; yine de yönlendirme, teklif puanları SSU\u0026rsquo;dan daha düşük olacak şekilde sabit kodlandığı için NTCP\u0026rsquo;yi tercih ediyor. Analiz birkaç noktayı gündeme getirdi:\n2007 başlığındaki öneriler Taşıma önceliklerini tersine çevirin; böylece router\u0026rsquo;lar SSU\u0026rsquo;yu tercih eder (i2np.udp.alwaysPreferred ayarını eski hâline getirerek). Streaming (akış) trafiğini etiketleyin; böylece SSU, anonimliği zedelemeden yalnızca etiketlenmiş iletiler için daha düşük teklifte bulunsun. SSU yeniden iletim sınırlarını sıkılaştırın; çökme riskini azaltmak için. Yarı güvenilir underlays (alt katmanlar) inceleyin; streaming library (akış kitaplığı) altında yapılan yeniden iletimlerin net bir fayda olup olmadığını belirlemek için. Öncelik kuyruklarını ve zaman aşımlarını gözden geçirin—örneğin, NTCP ile uyumlu hâle getirmek için streaming zaman aşımlarını 45 s\u0026rsquo;i aşacak şekilde artırmak. jrandom\u0026rsquo;un yanıtı (27 Mart 2007) Başlıca karşı argümanlar:\nNTCP\u0026rsquo;nin var olma nedeni, erken SSU dağıtımlarının congestion collapse (ağ tıkanıklığı kaynaklı çöküş) yaşamasıdır. Her atlama başına mütevazı yeniden iletim oranları bile çok atlamalı tunnel\u0026rsquo;lar boyunca katlanarak artabilir. tunnel düzeyi onaylar olmadan, iletilerin yalnızca bir kısmı uçtan uca teslim durumu alır; başarısızlıklar fark edilmeyebilir. TCP tıkanıklık denetimi onlarca yıllık iyileştirmelere sahiptir; NTCP bunlardan olgun TCP yığınları aracılığıyla yararlanır. SSU\u0026rsquo;yu tercih ederken gözlemlenen verimlilik artışları, protokole özgü içsel avantajlardan ziyade router kuyruklama davranışını yansıtıyor olabilir. Daha büyük streaming zaman aşımı değerleri halihazırda kararlılığı iyileştiriyordu; büyük değişikliklere geçmeden önce daha fazla gözlem ve veri teşvik edildi. Tartışma, sonraki taşıma ince ayarlarının geliştirilmesine yardımcı oldu, ancak modern NTCP2/SSU2 mimarisini yansıtmıyor.\n","description":"NTCP ve SSU taşıma protokollerini karşılaştıran tarihsel notlar ve önerilen ince ayar fikirleri","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"NTCP Tartışması","url":"/tr/docs/ntcp/"},{"categories":null,"content":"Genel Bakış NTCP2, eski NTCP taşıma protokolünün yerini, trafik parmak izi tespitine dirençli, uzunluk alanlarını şifreleyen ve modern şifre takımlarını destekleyen Noise tabanlı bir el sıkışmasıyla alır. Router\u0026rsquo;lar, I2P ağındaki iki zorunlu taşıma protokolü olarak NTCP2\u0026rsquo;yi SSU2 ile birlikte çalıştırabilir. NTCP (sürüm 1) 0.9.40\u0026rsquo;da (Mayıs 2019) kullanımı önerilmez hale getirildi ve 0.9.50\u0026rsquo;de (Mayıs 2021) tamamen kaldırıldı.\nNoise Protokol Çerçevesi NTCP2, I2P\u0026rsquo;ye özgü uzantılarla birlikte Noise Protocol Framework (Noise Protokol Çatısı) Revizyon 33, 2017-10-04 kullanır:\nDesen: Noise_XK_25519_ChaChaPoly_SHA256 Genişletilmiş Tanımlayıcı: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256 (KDF (Anahtar Türetme Fonksiyonu) başlatma için) DH İşlevi: X25519 (RFC 7748) - 32 baytlık anahtarlar, little-endian kodlama Şifreleme: AEAD_CHACHA20_POLY1305 (RFC 7539/RFC 8439) 12 baytlık nonce (tek seferlik değer): ilk 4 bayt sıfır, son 8 bayt sayaç (little-endian) Maksimum nonce değeri: 2^64 - 2 (bağlantı 2^64 - 1\u0026rsquo;e ulaşmadan önce sonlandırılmalıdır) Özet Fonksiyonu: SHA-256 (32 bayt çıktı) MAC (Mesaj Doğrulama Kodu): Poly1305 (16 bayt kimlik doğrulama etiketi) I2P\u0026rsquo;ye Özgü Uzantılar AES ile Gizleme: Bob\u0026rsquo;un router karması ve yayımlanmış IV (başlatma vektörü) kullanılarak AES-256-CBC ile şifrelenen geçici anahtarlar Rastgele Dolgu: Mesaj 1-2\u0026rsquo;de açık metin dolgusu (kimliği doğrulanmış), mesaj 3 ve sonrasında AEAD (authenticated encryption with associated data - ilişkili verilerle kimlik doğrulamalı şifreleme) dolgusu (şifrelenmiş) SipHash-2-4 ile Uzunluk Gizleme: İki baytlık çerçeve uzunlukları SipHash çıktısı ile XOR\u0026rsquo;lanır Çerçeve Yapısı: Veri aşaması için başında uzunluk alanı bulunan çerçeveler (TCP akış uyumluluğu) Blok Tabanlı Yükler: Tür tanımlı bloklarla yapılandırılmış veri biçimi El Sıkışma Akışı Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► Üç Mesajlı El Sıkışma SessionRequest - Alice\u0026rsquo;in gizlileştirilmiş geçici anahtarı, seçenekler, dolgu ipuçları SessionCreated - Bob\u0026rsquo;un gizlileştirilmiş geçici anahtarı, şifrelenmiş seçenekler, dolgu SessionConfirmed - Alice\u0026rsquo;in şifrelenmiş statik anahtarı ve RouterInfo (iki AEAD çerçevesi) Noise Mesaj Kalıpları XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 Kimlik Doğrulama Seviyeleri: - 0: Kimlik doğrulama yok (herhangi bir taraf göndermiş olabilir) - 2: Gönderici kimlik doğrulaması, anahtar ele geçirilmesine dayalı kimliğe bürünmeye (KCI) karşı dayanıklıdır\nGizlilik Düzeyleri: - 1: Geçici alıcı (ileri gizlilik, alıcı kimlik doğrulaması yok) - 2: Bilinen alıcı, yalnızca gönderenin ele geçirilmesi durumunda ileri gizlilik - 5: Güçlü ileri gizlilik (geçici-geçici + geçici-statik DH)\nMesaj Spesifikasyonları Anahtar Gösterimi RH_A = Alice için Router Hash (32 bayt, SHA-256) RH_B = Bob için Router Hash (32 bayt, SHA-256) || = bitiştirme operatörü byte(n) = değeri n olan tek bayt Aksi belirtilmedikçe tüm çok baytlı tamsayılar big-endian (büyük-sonlu) düzenindedir X25519 anahtarları little-endian (küçük-sonlu) (32 bayt) Kimliği Doğrulanmış Şifreleme (ChaCha20-Poly1305) Şifreleme İşlevi:\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) Parametreler: - key: KDF (Anahtar Türetme Fonksiyonu) çıktısı 32 baytlık şifreleme anahtarı - nonce: 12 bayt (4 sıfır bayt + 8 baytlık sayaç, little-endian (küçük uca dayalı bayt sıralaması)) - associatedData: el sıkışma aşamasında 32 baytlık özet; veri aşamasında sıfır uzunlukta - plaintext: Şifrelenecek veri (0+ bayt)\nÇıktı: - Şifreli metin: Düz metinle aynı uzunlukta - MAC: 16 bayt (Poly1305 kimlik doğrulama etiketi)\nNonce (tek kullanımlık sayı) Yönetimi: - Her bir şifreleme örneği için sayaç 0\u0026rsquo;dan başlar - O yöndeki her AEAD (kimliği doğrulanmış ek verili şifreleme) işlemi için artırılır - Veri aşamasında Alice→Bob ve Bob→Alice için ayrı sayaçlar vardır - Sayaç 2^64 - 1 değerine ulaşmadan önce bağlantı sonlandırılmalıdır\nMesaj 1: SessionRequest (oturum isteği) Alice, Bob ile bir bağlantı başlatır.\nNoise İşlemleri: e, es (geçici anahtar oluşturma ve değişimi)\nHam Biçim +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Boyut Kısıtları: - Minimum: 80 bayt (32 AES + 48 AEAD) - Maksimum: toplam 65535 bayt - Özel durum: \u0026ldquo;NTCP\u0026rdquo; adreslerine bağlanırken en fazla 287 bayt (sürüm algılama)\nŞifresi Çözülmüş İçerik +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Seçenekler Bloğu (16 bayt, big-endian (yüksek anlamlı bayt önce)) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 Kritik Alanlar: - Ağ Kimliği (0.9.42\u0026rsquo;den beri): Ağlar arası bağlantıların hızlı reddedilmesi - m3p2len: 3. iletinin 2. bölümünün tam boyutu (gönderildiğinde eşleşmelidir)\nAnahtar Türetme Fonksiyonu (KDF-1) Başlatma Protokolü:\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash MixHash İşlemleri:\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD MixKey İşlemi (es deseni):\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF Gerçekleştirim Notları AES Obfuscation (gizleme): Yalnızca DPI (Derin Paket İnceleme) direnci için kullanılır; Bob\u0026rsquo;un router hash\u0026rsquo;i ve IV\u0026rsquo;si olan herkes X\u0026rsquo;in şifresini çözebilir Replay Prevention: Bob, X değerlerini (veya şifrelenmiş eşdeğerlerini) en az 2*D saniye boyunca önbelleğe almalıdır (D = maksimum saat sapması) Timestamp Validation: Bob, |tsA - current_time| \u0026gt; D olan bağlantıları reddetmelidir (genellikle D = 60 saniye) Curve Validation: Bob, X\u0026rsquo;in geçerli bir X25519 noktası olduğunu doğrulamalıdır Fast Rejection: Bob, şifre çözmeden önce X[31] \u0026amp; 0x80 == 0 olup olmadığını kontrol edebilir (geçerli X25519 anahtarlarında MSB (en anlamlı bit) sıfırdır) Error Handling: Herhangi bir başarısızlıkta, Bob rastgele bir zaman aşımı ve rastgele bayt okumasının ardından TCP RST ile kapatır Buffering: Alice, verimlilik için tüm mesajı (padding (doldurma) dahil) tek seferde boşaltmalıdır Mesaj 2: SessionCreated (oturum oluşturuldu) Bob, Alice\u0026rsquo;e yanıt verir.\nNoise İşlemleri: e, ee (geçici-geçici DH)\nHam Biçim +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Şifresi Çözülmüş İçerik +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Seçenekler Bloğu (16 bayt, big-endian (büyük uçlu bayt sıralaması)) +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) Anahtar Türetme Fonksiyonu (KDF-2) MixHash İşlemleri:\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD MixKey İşlemi (ee deseni):\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF Bellek Temizliği:\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side Uygulama Notları AES Zincirleme: Y şifrelemesi, 1. mesajdan (sıfırlanmadan) AES-CBC durumunu kullanır Replay Saldırılarını Önleme: Alice en az 2*D saniye boyunca Y değerlerini önbelleğe almalıdır Zaman Damgası Doğrulaması: Alice, |tsB - current_time| \u0026gt; D ise reddetmelidir Eğri Doğrulaması: Alice, Y\u0026rsquo;nin geçerli bir X25519 noktası olduğunu doğrulamalıdır Hata İşleme: Herhangi bir hata durumunda Alice, bağlantıyı TCP RST ile kapatır Tamponlama: Bob, tüm mesajı tek seferde tampondan boşaltmalıdır Mesaj 3: SessionConfirmed Alice oturumu onaylar ve RouterInfo (router bilgi kaydı) gönderir.\nNoise İşlemleri: s, se (statik anahtarın açıklanması ve statik-geçici DH)\nİki Parçalı Yapı Mesaj 3 iki ayrı AEAD (ilişkili verili kimlik doğrulamalı şifreleme) çerçeveden oluşur:\nBölüm 1: Alice\u0026rsquo;in şifrelenmiş statik anahtarını içeren sabit 48 baytlık çerçeve Bölüm 2: RouterInfo (router bilgisi), seçenekler ve dolgu içeren değişken uzunluklu çerçeve Ham Biçim +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Boyut Kısıtlamaları: - Bölüm 1: Tam olarak 48 bayt (32 açık metin + 16 MAC) - Bölüm 2: Uzunluk, mesaj 1\u0026rsquo;deki m3p2len alanında belirtilir - Toplam azami: 65535 bayt (bölüm 1 azami 48, dolayısıyla bölüm 2 azami 65487)\nŞifresi Çözülmüş İçerik Bölüm 1:\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ Bölüm 2:\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ Anahtar Türetme Fonksiyonu (KDF-3) Bölüm 1 (s deseni):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 Bölüm 2 (se pattern):\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF Bellek Temizleme:\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side Uygulama Notları RouterInfo Doğrulaması: Bob, imzayı, zaman damgasını ve anahtar tutarlılığını doğrulamalıdır Anahtar Eşleşmesi: Bob, 1. bölümdeki Alice\u0026rsquo;in statik anahtarının RouterInfo\u0026rsquo;daki anahtarla eşleştiğini doğrulamalıdır Statik Anahtarın Konumu: NTCP veya NTCP2 RouterAddress içinde eşleşen \u0026ldquo;s\u0026rdquo; parametresine bakın Blok Sırası: RouterInfo ilk, Options ikinci (varsa), Padding en son (varsa) olmalıdır Uzunluk Planlaması: Alice, mesaj 1\u0026rsquo;deki m3p2len\u0026rsquo;in 2. bölümün uzunluğuyla tam olarak eşleştiğinden emin olmalıdır Arabelleğe Alma: Alice, her iki bölümü tek bir TCP gönderimi olarak birlikte flush (tamponu boşaltmak) etmelidir İsteğe Bağlı Zincirleme: Alice, verimlilik için hemen bir data phase frame (veri aşaması çerçevesi) ekleyebilir Veri Aşaması El sıkışması tamamlandıktan sonra, tüm iletiler gizlenmiş uzunluk alanlarına sahip, değişken uzunluklu AEAD (İlişkili verili kimlik doğrulamalı şifreleme) çerçeveleri kullanır.\nAnahtar Türetme Fonksiyonu (Veri Aşaması) Split İşlevi (Noise):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) SipHash Anahtar Türetimi:\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV Çerçeve Yapısı +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ Çerçeve Kısıtlamaları: - Minimum: 18 bayt (2 gizlenmiş uzunluk + 0 düz metin + 16 MAC) - Maksimum: 65537 bayt (2 gizlenmiş uzunluk + 65535 çerçeve) - Önerilen: çerçeve başına birkaç KB (alıcı gecikmesini en aza indirmek için)\nSipHash ile Uzunluk Gizleme Amaç: DPI\u0026rsquo;nin çerçeve sınırlarını tespit etmesini önlemek\nAlgoritma:\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes Kod çözme:\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) Notlar: - Her yön için ayrı IV (başlatma vektörü) zincirleri (Alice→Bob ve Bob→Alice) - SipHash uint64 döndürürse, maske olarak en düşük anlamlı 2 baytı kullanın - uint64 değerini bir sonraki IV\u0026rsquo;ye little-endian (küçük endian) baytlar olarak dönüştürün\nBlok Biçimi Her çerçeve sıfır veya daha fazla blok içerir:\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload Boyut Sınırları: - Maksimum çerçeve: 65535 bayt (MAC dahil) - Maksimum blok alanı: 65519 bayt (çerçeve - 16 baytlık MAC) - Maksimum tek blok: 65519 bayt (3 baytlık başlık + 65516 veri)\nBlok Türleri Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions **Blok Sıralama Kuralları:** - **Mesaj 3 bölüm 2**: RouterInfo, Options (isteğe bağlı), Padding (isteğe bağlı) - Başka tür YOK - **Veri aşaması**: Şunlar dışında herhangi bir sırayla: - Padding varsa MUTLAKA son blok olmalıdır - Termination varsa MUTLAKA (Padding hariç) son blok olmalıdır - Çerçeve başına birden fazla I2NP bloğuna izin verilir - Çerçeve başına birden fazla Padding bloğuna İZİN VERİLMEZ Blok Türü 0: DateTime Saat sapması tespiti için zaman senkronizasyonu.\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) Uygulama: Saat ofsetinin birikmesini önlemek için en yakın saniyeye yuvarlayın.\nBlok Türü 1: Seçenekler Dolgu ve trafik şekillendirme parametreleri.\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) Dolgu Oranları (4.4 sabit noktalı sayı, değer/16.0): - tmin: İletimde minimum dolgu oranı (0.0 - 15.9375) - tmax: İletimde maksimum dolgu oranı (0.0 - 15.9375) - rmin: Alımda minimum dolgu oranı (0.0 - 15.9375) - rmax: Alımda maksimum dolgu oranı (0.0 - 15.9375)\nÖrnekler: - 0x00 = 0% dolgu - 0x01 = 6.25% dolgu - 0x10 = 100% dolgu (1:1 oranı) - 0x80 = 800% dolgu (8:1 oranı)\nSahte Trafik: - tdmy: Göndermeye istekli olunan azami değer (2 bayt, bayt/sn ortalaması) - rdmy: Alınması talep edilen miktar (2 bayt, bayt/sn ortalaması)\nGecikme Ekleme: - tdelay: Eklemeye razı olunan en yüksek değer (2 bayt, milisaniye cinsinden ortalama) - rdelay: Talep edilen gecikme (2 bayt, milisaniye cinsinden ortalama)\nKılavuzlar: - Min değerler istenen trafik analizi direncini gösterir - Max değerler bant genişliği kısıtlarını gösterir - Gönderici alıcının maksimumuna uymalıdır - Gönderici kısıtlar dahilinde alıcının minimumuna uyabilir - Herhangi bir yaptırım mekanizması yoktur; uygulamalar farklılık gösterebilir\nBlok Türü 2: RouterInfo (router bilgisi) netDb\u0026rsquo;nin doldurulması ve yayılması için RouterInfo iletimi.\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 Kullanım:\nMesaj 3 Bölüm 2\u0026rsquo;de (el sıkışması): - Alice RouterInfo\u0026rsquo;yu (Router bilgisi) Bob\u0026rsquo;a gönderir - Flood bit (ağa yayma biti) genellikle 0 (yerel depolama) - RouterInfo gzip ile sıkıştırılmamıştır\nVeri Aşamasında: - Taraflardan herhangi biri güncellenmiş RouterInfo\u0026rsquo;sunu gönderebilir - Flood bit = 1: floodfill dağıtımını iste (alıcı floodfill ise) - Flood bit = 0: Yalnızca yerel netdb depolaması\nDoğrulama Gereksinimleri: 1. İmza türünün desteklendiğini doğrulayın 2. RouterInfo (yöneltici bilgi kaydı) imzasını doğrulayın 3. Zaman damgasının kabul edilebilir sınırlar içinde olduğunu doğrulayın 4. El sıkışması için: Statik anahtarın NTCP2 adresinin \u0026ldquo;s\u0026rdquo; parametresiyle eşleştiğini doğrulayın 5. Veri aşaması için: router hash\u0026rsquo;in oturum eşiyle eşleştiğini doğrulayın 6. Yalnızca yayımlanmış adresleri olan RouterInfo\u0026rsquo;ları dağıt\nNotlar: - ACK mekanizması yok (gerektiğinde yanıt belirteci ile I2NP DatabaseStore kullanın) - Üçüncü taraf RouterInfos içerebilir (floodfill kullanımı) - gzip ile sıkıştırılmamıştır (I2NP DatabaseStore\u0026rsquo;un aksine)\nBlok Türü 3: I2NP Mesajı Kısaltılmış 9 baytlık başlığa sahip I2NP mesajı.\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) NTCP1\u0026rsquo;e göre farklar: - Bitiş zamanı: 4 bayt (saniye) vs 8 bayt (milisaniye) - Uzunluk: Çıkarıldı (blok uzunluğundan türetilebilir) - Sağlama toplamı: Çıkarıldı (AEAD (ilişkili verilerle kimlik doğrulamalı şifreleme) bütünlük sağlar) - Başlık: 9 bayt vs 16 bayt (%44 azalma)\nParçalama: - I2NP mesajları bloklar arasında kesinlikle parçalanmamalıdır - I2NP mesajları çerçeveler arasında kesinlikle parçalanmamalıdır - Çerçeve başına birden fazla I2NP bloğuna izin verilir\nBlok Tipi 4: Sonlandırma Gerekçe koduyla bağlantıyı açıkça kapatma.\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) Neden Kodları:\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny **Kurallar:** - Sonlandırma MUTLAKA çerçevede dolgu olmayan son blok olmalıdır - Çerçeve başına en fazla bir sonlandırma bloğu - Gönderen gönderdikten sonra bağlantıyı kapatmalıdır - Alıcı aldıktan sonra bağlantıyı kapatmalıdır Hata İşleme: - El sıkışma hataları: Genellikle TCP RST ile kapatılır (sonlandırma bloğu yok) - Veri aşaması AEAD hataları: Rastgele zaman aşımı + rastgele okuma, ardından sonlandırma gönder - Güvenlik prosedürleri için \u0026ldquo;AEAD Error Handling\u0026rdquo; bölümüne bakın\nBlok Türü 254: Dolgu Trafik analizine karşı dayanıklılık için rastgele dolgu.\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes Kurallar: - Varsa, padding (dolgu) çerçevede son blok MUTLAKA olmalıdır - Sıfır uzunluklu padding\u0026rsquo;e izin verilir - Her çerçevede yalnızca bir padding bloğuna izin verilir - Yalnızca padding içeren çerçevelere izin verilir - Options bloğunda müzakere edilen parametrelere uyulmalıdır\nİletiler 1-2\u0026rsquo;de Dolgu: - AEAD (ilişkili verilerle kimlik doğrulamalı şifreleme) çerçevesinin dışında (açık metin) - Sonraki iletinin hash zincirine dahil edilir (kimliği doğrulanmış) - Sonraki iletide AEAD başarısız olduğunda kurcalama saptanır\nMesaj 3+ ve Veri Aşamasında Dolgu: - AEAD (kimliği doğrulamalı ve ilişkili verili şifreleme) çerçevesinin içinde (şifrelenmiş ve kimlik doğrulaması yapılmış) - Trafik şekillendirme ve boyut gizleme için kullanılır\nAEAD (ek verili kimliği doğrulanmış şifreleme) Hata İşleme Kritik Güvenlik Gereksinimleri:\nEl Sıkışma Aşaması (Mesajlar 1-3) Bilinen Mesaj Boyutu: - Mesaj boyutları önceden belirlenir veya önceden belirtilir - AEAD (ilişkili verili doğrulanmış şifreleme) kimlik doğrulama hatası şüpheye yer bırakmaz\nBob\u0026rsquo;un Mesaj 1 başarısızlığına yanıtı: 1. Rastgele bir zaman aşımı ayarla (aralık uygulamaya bağlıdır, 100-500ms önerilir) 2. Rastgele sayıda bayt oku (aralık uygulamaya bağlıdır, 1KB-64KB önerilir) 3. Bağlantıyı TCP RST ile kapat (yanıt yok) 4. Kaynak IP\u0026rsquo;yi geçici olarak kara listeye al 5. Uzun vadeli yasaklamalar için tekrarlanan hataları izle\nAlice\u0026rsquo;in Mesaj 2 Hatasına Yanıtı: 1. Bağlantıyı hemen TCP RST ile kapat 2. Bob\u0026rsquo;a yanıt verme\nBob\u0026rsquo;un Mesaj 3 Hatasına Yanıtı: 1. Bağlantıyı TCP RST ile hemen kapat 2. Alice\u0026rsquo;e yanıt verme\nVeri Aşaması Gizlenmiş Mesaj Boyutu: - Uzunluk alanı SipHash (anahtarlı karma fonksiyonu) ile gizlenmiştir - Geçersiz uzunluk ya da AEAD (ek verilerle kimliği doğrulanmış şifreleme) hatası şunlara işaret edebilir: - Saldırgan yoklaması - Ağ bozulması - Senkronu bozulmuş SipHash IV - Kötücül eş\nAEAD (İlişkili Verili Kimlik Doğrulamalı Şifreleme) veya Uzunluk Hatasına Yanıt: 1. Rastgele bir zaman aşımı ayarla (100-500ms önerilir) 2. Rastgele miktarda bayt oku (1KB-64KB önerilir) 3. Neden kodu 4 (AEAD başarısızlığı) veya 9 (çerçeveleme hatası) ile bir sonlandırma bloğu gönder 4. Bağlantıyı kapat\nDecryption Oracle\u0026rsquo;ın (saldırganın hata geri bildirimlerinden yararlanarak şifre çözmeye dair bilgi çıkarabildiği sorgulanabilir bileşen) Önlenmesi: - Rastgele bir zaman aşımı gerçekleşmeden önce eşe hata türünü asla açıklamayın - AEAD kontrolünden önce uzunluk doğrulamasını asla atlamayın - Geçersiz uzunluğu AEAD hatasıyla aynı şekilde ele alın - Her iki hata için de aynı hata işleme yolunu kullanın\nUygulama ile ilgili değerlendirmeler: - Bazı gerçekleştirmeler, AEAD (Authenticated Encryption with Associated Data — ilişkili verili kimlik doğrulamalı şifreleme) hataları seyrek görülüyorsa çalışmaya devam edebilir - Hatalar tekrarlandığında sonlandırın (önerilen eşik: saatte 3-5 hata) - Hata kurtarma ile güvenlik arasında denge kurun\nYayınlanan RouterInfo (router bilgisi) Router Adres Biçimi NTCP2 desteği, belirli seçeneklere sahip yayımlanmış RouterAddress girdileri aracılığıyla duyurulur.\nTaşıma Stili: - \u0026quot;NTCP2\u0026quot; - Bu bağlantı noktasında yalnızca NTCP2 - \u0026quot;NTCP\u0026quot; - Bu bağlantı noktasında hem NTCP hem NTCP2 (otomatik algılama) - Not: 0.9.50\u0026rsquo;de (Mayıs 2021) NTCP (v1) desteği kaldırıldı - \u0026ldquo;NTCP\u0026rdquo; stili artık kullanımdan kaldırıldı; \u0026ldquo;NTCP2\u0026rdquo; kullanın\nGerekli Seçenekler Tüm Yayımlanmış NTCP2 Adresleri:\nhost - IP adresi (IPv4 ya da IPv6) veya ana makine adı\nBiçim: Standart IP gösterimi veya alan adı Yalnızca giden ya da gizli router\u0026rsquo;lar için atlanabilir port - TCP bağlantı noktası numarası\nBiçim: Tamsayı, 1-65535 Yalnızca giden veya gizli routers için atlanabilir s - Statik açık anahtar (X25519)\nBiçim: Base64 ile kodlanmış, 44 karakter Kodlama: I2P Base64 alfabesi Kaynak: 32 bayt X25519 açık anahtar, little-endian (düşük anlamlı bayt önce) i - AES için İlklendirme Vektörü\nBiçim: Base64 ile kodlanmış, 24 karakter Kodlama: I2P Base64 alfabesi Kaynak: 16 baytlık IV, big-endian v - Protokol sürümü\nBiçim: Tamsayı veya virgülle ayrılmış tamsayılar Geçerli: \u0026quot;2\u0026quot; Gelecekte: \u0026quot;2,3\u0026quot; (sayısal sırada olmalıdır) İsteğe Bağlı Seçenekler:\ncaps - Yetenekler (0.9.50\u0026rsquo;den beri)\nBiçim: Yetenek karakterlerinden oluşan bir dize Değerler: \u0026quot;4\u0026quot; - IPv4 giden bağlantı yeteneği \u0026quot;6\u0026quot; - IPv6 giden bağlantı yeteneği \u0026quot;46\u0026quot; - Hem IPv4 hem de IPv6 (önerilen sıralama) host yayımlanmışsa gerekmez Gizli/güvenlik duvarı arkasındaki routers için kullanışlıdır cost - Adres önceliği\nBiçim: Tamsayı, 0-255 Daha düşük değerler = daha yüksek öncelik Önerilen: normal adresler için 5-10 Önerilen: yayımlanmamış adresler için 14 Örnek RouterAddress Girdileri Yayınlanan IPv4 Adresi:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Gizli Router (Yalnızca Giden):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Çift Yığınlı Router:\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Önemli Kurallar: - aynı bağlantı noktasına sahip birden çok NTCP2 adresi, MUTLAKA özdeş s, i ve v değerleri kullanmalıdır - Farklı bağlantı noktaları farklı anahtarlar kullanabilir - Çift yığın (dual-stack) routers ayrı IPv4 ve IPv6 adresleri yayımlamalıdır\nYayınlanmamış NTCP2 Adresi Yalnızca Giden Router\u0026rsquo;lar İçin:\nBir router, gelen NTCP2 bağlantılarını kabul etmiyorsa ancak giden bağlantılar başlatıyorsa, yine de aşağıdakileri içeren bir RouterAddress (yöneltici adresi) yayımlaması ZORUNDADIR:\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Amaç: - El sıkışma sırasında Bob\u0026rsquo;un Alice\u0026rsquo;in statik anahtarını doğrulamasına olanak tanır - Mesaj 3, bölüm 2 RouterInfo doğrulaması için gereklidir - i, host veya port gerekmez (yalnızca giden)\nAlternatif: - Yayımlanmış mevcut \u0026ldquo;NTCP\u0026rdquo; veya SSU adresine s ve v ekleyin\nAçık Anahtar ve IV Rotasyonu Kritik Güvenlik Politikası:\nGenel Kurallar: 1. router çalışırken asla rotasyon yapmayın 2. Anahtar ve IV (başlatma vektörü) değerlerini kalıcı olarak saklayın yeniden başlatmalar arasında 3. Önceki kapalı kalma süresini izleyin rotasyon uygunluğunu belirlemek için\nRotasyondan önceki minimum kesinti süresi:\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact **Ek Tetikleyiciler:** - Yerel IP adresi değişikliği: Kesinti süresinden bağımsız olarak yenilenebilir - Router \"rekey\" (yeni Router Hash): Yeni anahtarlar oluşturur Gerekçe: - Anahtar değişiklikleri üzerinden yeniden başlatma zamanlarının açığa çıkmasını önler - Önbelleğe alınmış RouterInfos öğelerinin süresinin doğal olarak dolmasına izin verir - Ağ kararlılığını korur - Başarısız bağlantı girişimlerini azaltır\nUygulama: 1. Anahtarı, IV (başlatma vektörü) ve son kapatma zaman damgasını kalıcı olarak saklayın 2. Başlangıçta downtime = current_time - last_shutdown değerini hesaplayın 3. downtime, router türü için minimumun üzerindeyse, anahtar ve IV için rotasyon yapılabilir 4. IP değiştiyse veya yeniden anahtarlama varsa, rotasyon yapılabilir 5. Aksi halde, önceki anahtarı ve IV\u0026rsquo;yi yeniden kullanın\nIV Rotasyonu: - Anahtar rotasyonuyla aynı kurallara tabidir - Yalnızca yayımlanmış adreslerde bulunur (gizli routers değil) - Anahtar her değiştiğinde IV\u0026rsquo;nin değiştirilmesi önerilir\nSürüm Tespiti Bağlam: transportStyle=\u0026quot;NTCP\u0026quot; (eski) iken, Bob aynı portta hem NTCP v1 hem de v2’yi destekler ve protokol sürümünü otomatik olarak algılamalıdır.\nTespit Algoritması:\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 Hızlı MSB (en yüksek anlamlı bit) Kontrolü: - AES şifre çözmeden önce doğrulayın: encrypted_X[31] \u0026amp; 0x80 == 0 - Geçerli X25519 anahtarlarında yüksek bit temizdir - Başarısızlık büyük olasılıkla NTCP1\u0026rsquo;i (veya bir saldırıyı) gösterir - Başarısızlık durumunda yoklama direnci (rastgele zaman aşımı + okuma) uygulayın\nUygulama Gereksinimleri:\nAlice’in Sorumluluğu:\n\u0026ldquo;NTCP\u0026rdquo; adresine bağlanırken, 1. mesajı en fazla 287 baytla sınırla Tüm 1. mesajı tamponla ve tek seferde boşalt Tek bir TCP paketiyle iletilme olasılığını artırır Bob\u0026rsquo;un Sorumlulukları:\nSürümü tespit etmeden önce alınan veriyi arabelleğe al Uygun zaman aşımı yönetimini uygula Hızlı sürüm tespiti için TCP_NODELAY kullan Sürüm tespit edildikten sonra 2. mesajın tamamını arabelleğe al ve tek seferde boşalt Güvenlik Hususları: - Segmentasyon saldırıları: Bob, TCP segmentasyonuna karşı dayanıklı olmalıdır - Yoklama saldırıları: Başarısızlıklarda rastgele gecikmeler ve bayt okumaları uygulayın - DoS (Hizmet Reddi) önleme: Eşzamanlı bekleyen bağlantıları sınırlandırın - Okuma zaman aşımları: Hem her okuma için hem de toplam (\u0026ldquo;slowloris\u0026rdquo; koruması)\nSaat Sapması Yönergeleri Zaman Damgası Alanları: - Mesaj 1: tsA (Alice\u0026rsquo;in zaman damgası) - Mesaj 2: tsB (Bob\u0026rsquo;un zaman damgası) - Mesaj 3+: İsteğe bağlı DateTime (tarih-saat) blokları\nMaksimum Sapma (D): - Tipik: ±60 saniye - Uygulama bazında yapılandırılabilir - Sapma \u0026gt; D genellikle ölümcül kabul edilir\nBob\u0026rsquo;un Ele Alması (Mesaj 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally Gerekçe: Zaman sapması olsa bile 2. mesajın gönderilmesi, Alice\u0026rsquo;in sistem saatiyle ilgili sorunları teşhis etmesine olanak tanır.\nAlice\u0026rsquo;in İşlemesi (Mesaj 2) 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization RTT Düzeltmesi: - Hesaplanan sapmadan RTT (gidiş-dönüş süresi) değerinin yarısını çıkarın - Ağ yayılım gecikmesini dikkate alır - Daha doğru sapma tahmini\nBob\u0026rsquo;un İşlemesi (Mesaj 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) Zaman Senkronizasyonu DateTime Blokları (Veri Aşaması): - Periyodik olarak DateTime bloğu gönder (tip 0) - Alıcı saat ayarlaması için kullanabilir - Zaman damgasını en yakın saniyeye yuvarla (yanlılığı önlemek için)\nHarici Zaman Kaynakları: - NTP (Ağ Zaman Protokolü) - Sistem saati eşzamanlaması - I2P ağının konsensüs zamanı\nSaat Ayarlama Stratejileri: - Yerel saat yanlışsa: Sistem saatini ayarla veya offset (kaydırma) kullan - Eşlerin saatleri sürekli yanlışsa: Eşte sorun olduğunu işaretle - Ağ sağlığını izlemek için skew (sapma) istatistiklerini izle\nGüvenlik Özellikleri İleri Gizlilik Şunlarla Gerçekleştirilir: - Geçici Diffie-Hellman anahtar değişimi (X25519) - Üç DH işlemi: es, ee, se (Noise XK pattern) (Noise XK deseni) - El sıkışması tamamlandıktan sonra geçici anahtarlar imha edilir\nGizlilik İlerlemesi: - Mesaj 1: Seviye 2 (gönderen kompromize olduğunda forward secrecy (ileriye dönük gizlilik)) - Mesaj 2: Seviye 1 (geçici alıcı) - Mesaj 3+: Seviye 5 (güçlü forward secrecy)\nMükemmel İleri Gizlilik (Perfect Forward Secrecy): - Uzun vadeli statik anahtarların ele geçirilmesi geçmiş oturum anahtarlarını AÇIĞA ÇIKARMAZ - Her oturum benzersiz geçici anahtarlar kullanır - Geçici özel anahtarlar asla yeniden kullanılmaz - Anahtar anlaşmasından sonra bellek temizliği\nSınırlamalar: - Mesaj 1, Bob\u0026rsquo;un statik anahtarı ele geçirilirse savunmasızdır (ancak Alice\u0026rsquo;in kompromize olması durumunda ileri gizlilik sağlar) - Mesaj 1 için yeniden oynatma saldırıları mümkündür (zaman damgası ve yeniden oynatma önbelleği ile azaltılır)\nKimlik Doğrulama Karşılıklı Kimlik Doğrulama: - Alice\u0026rsquo;in kimliği, 3. mesajdaki statik anahtar ile doğrulanır - Bob\u0026rsquo;un kimliği, statik özel anahtara sahip olmasıyla doğrulanır (başarılı el sıkışmadan örtük olarak)\nAnahtar Ele Geçirme Yoluyla Kimliğe Bürünme (KCI) Direnci: - Kimlik doğrulama düzeyi 2 (KCI\u0026rsquo;ye dayanıklı) - Saldırgan, Alice\u0026rsquo;in statik özel anahtarına sahip olsa bile (Alice\u0026rsquo;in geçici anahtarı olmadan) Alice\u0026rsquo;in kimliğine bürünemez - Saldırgan, Bob\u0026rsquo;un statik özel anahtarına sahip olsa bile (Bob\u0026rsquo;un geçici anahtarı olmadan) Bob\u0026rsquo;un kimliğine bürünemez\nStatik Anahtar Doğrulaması: - Alice, Bob\u0026rsquo;un statik anahtarını önceden bilir (RouterInfo\u0026rsquo;dan) - Bob, 3. mesajda Alice\u0026rsquo;in statik anahtarının RouterInfo ile eşleştiğini doğrular - Ortadaki adam saldırılarını önler\nTrafik Analizine Karşı Direnç DPI (Derin Paket İncelemesi) Karşı Önlemleri: 1. AES Gizleme: Geçici anahtarlar şifrelenir, rastgele görünür 2. SipHash Uzunluk Gizleme: Çerçeve uzunlukları açık metin değildir 3. Rastgele Dolgu: Değişken mesaj boyutları, sabit kalıplar yok 4. Şifreli Çerçeveler: Tüm yük ChaCha20 ile şifrelenir\nReplay Saldırılarının Önlenmesi: - Zaman damgası doğrulaması (±60 saniye) - Geçici anahtarlar için yeniden oynatma önbelleği (geçerlilik süresi 2*D) - Nonce (tek kullanımlık sayı) artışları, oturum içinde paketlerin yeniden oynatılmasını engeller\nYoklamaya Karşı Direnç: - AEAD (Authenticated Encryption with Associated Data - ilişkili verili doğrulamalı şifreleme) hatalarında rastgele zaman aşımı süreleri - Bağlantı kapatılmadan önce rastgele bayt okunması - El sıkışma başarısızlıklarında yanıt verilmez - Tekrarlanan başarısızlıklarda IP kara listeleme\nDolgu Yönergeleri: - Mesajlar 1-2: Açık metin dolgusu (kimliği doğrulanmış) - Mesaj 3+: AEAD çerçeveleri içinde şifrelenmiş dolgu - Müzakere edilen dolgu parametreleri (Seçenekler bloğu) - Yalnızca dolgu çerçevelerine izin verilir\nHizmet Reddi Saldırılarının Azaltılması Bağlantı Sınırları: - Maksimum etkin bağlantı sayısı (gerçeklemeye bağlı) - Maksimum bekleyen el sıkışması sayısı (örn., 100-1000) - IP başına bağlantı sınırları (örn., eşzamanlı 3-10)\nKaynak Koruması: - DH (Diffie-Hellman) işlemleri oran sınırlandırılmış (hesaplama açısından maliyetli) - Soket başına ve toplam okuma zaman aşımları - \u0026ldquo;Slowloris\u0026rdquo; koruması (toplam süre sınırları) - Kötüye kullanıma karşı IP kara listeleme\nHızlı Reddetme: - Ağ kimliği uyuşmazlığı → anında kapatma - Geçersiz X25519 noktası (eliptik eğri Diffie–Hellman anahtar değişimi) → şifre çözmeden önce hızlı MSB kontrolü - Zaman damgası sınırların dışında → hesaplama yapmadan kapatma - AEAD (Authenticated Encryption with Associated Data, ilişkili verili kimlik doğrulamalı şifreleme) hatası → yanıt yok, rastgele gecikme\nYoklamaya karşı direnç: - Rastgele zaman aşımı: 100-500ms (uygulamaya bağlı) - Rastgele okuma: 1KB-64KB (uygulamaya bağlı) - Saldırgana hata bilgisi verilmez - TCP RST ile kapat (FIN el sıkışması yok)\nKriptografik Güvenlik Algoritmalar: - X25519: 128-bit güvenlik, eliptik eğri DH (Curve25519) - ChaCha20: 256-bit anahtarlı akış şifresi - Poly1305: bilgi kuramsal olarak güvenli MAC (İleti Kimlik Doğrulama Kodu) - SHA-256: 128-bit çarpışma direnci, 256-bit öngörüntü direnci - HMAC-SHA256: anahtar türetimi için PRF (yalancı rastgele fonksiyon)\nAnahtar Boyutları: - Statik anahtarlar: 32 bayt (256 bit) - Geçici anahtarlar: 32 bayt (256 bit) - Şifreleme anahtarları: 32 bayt (256 bit) - MAC (İleti Kimlik Doğrulama Kodu): 16 bayt (128 bit)\nBilinen Sorunlar: - ChaCha20 nonce (tek seferlik sayı) yeniden kullanımı felaketlidir (sayaç artırımıyla önlenir) - X25519 küçük alt grup sorunlarına sahiptir (eğri doğrulamasıyla hafifletilir) - SHA-256 teorik olarak length extension (uzunluk genişletme saldırısı) karşı savunmasızdır (HMAC\u0026rsquo;te istismar edilemez)\nBilinen Güvenlik Açığı Yok (Ekim 2025 itibarıyla): - Noise Protocol Framework kapsamlı olarak incelendi - ChaCha20-Poly1305 TLS 1.3\u0026rsquo;te kullanıma alındı - X25519 modern protokollerde standart - Tasarıma karşı pratik saldırı yok\nKaynaklar Ana Spesifikasyonlar NTCP2 Spesifikasyonu - Resmi I2P spesifikasyonu Öneri 111 - Gerekçeleriyle birlikte özgün tasarım belgesi Noise Protocol Framework - Revizyon 33 (2017-10-04) Kriptografik Standartlar RFC 7748 - Güvenlik için Eliptik Eğriler (X25519) RFC 7539 - IETF Protokolleri için ChaCha20 ve Poly1305 RFC 8439 - ChaCha20-Poly1305 (RFC 7539\u0026rsquo;un yerini alır) RFC 2104 - HMAC: Mesaj kimlik doğrulaması için anahtarlı özetleme SipHash - Özet (hash) fonksiyonu uygulamaları için SipHash-2-4 İlgili I2P Spesifikasyonları I2NP Belirtimi - I2P Ağ Protokolü mesaj biçimi Ortak Yapılar - RouterInfo, RouterAddress biçimleri SSU Taşıma - UDP taşıma (orijinal, şimdi SSU2) Öneri 147 - Taşıma Ağı Kimliği Denetimi (0.9.42) Uygulama Referansları I2P Java - Referans implementasyonu (Java) i2pd - C++ implementasyonu I2P Sürüm Notları - Sürüm geçmişi ve güncellemeler Tarihsel Bağlam İstasyondan İstasyona Protokolü (STS) - Noise çerçevesi için ilham kaynağı obfs4 - Takılabilir aktarım (SipHash tabanlı uzunluk gizleme için emsal) Uygulama Yönergeleri Zorunlu Gereksinimler Uyumluluk için:\nTam El Sıkışmasını Uygulayın:\nDoğru KDF (anahtar türetme fonksiyonu) zincirleriyle her üç mesajı da destekleyin Tüm AEAD (ilişkili verili doğrulamalı şifreleme) etiketlerini doğrulayın X25519 (eliptik eğri anahtar değişimi) noktalarının geçerli olduğunu doğrulayın Veri Aşamasını Uygulayın:\nSipHash uzunluk gizleme (her iki yönde) Tüm blok türleri: 0 (Tarih/Saat), 1 (Seçenekler), 2 (RouterInfo), 3 (I2NP), 4 (Sonlandırma), 254 (Dolgu) Doğru nonce (tek seferlik sayı) yönetimi (ayrı sayaçlar) Güvenlik Özellikleri:\nYeniden yürütmenin önlenmesi (geçici anahtarları 2*D boyunca önbelleğe alma) Zaman damgası doğrulaması (varsayılan ±60 saniye) 1-2 numaralı iletilerde rastgele dolgu Rastgele zaman aşımı süreleriyle AEAD hata işleme RouterInfo Yayınlama:\nStatik anahtarı (\u0026ldquo;s\u0026rdquo;), IV\u0026rsquo;yi (\u0026ldquo;i\u0026rdquo;) ve sürümü (\u0026ldquo;v\u0026rdquo;) yayınla Anahtarları ilkeye göre döndür Gizli router\u0026rsquo;lar için yetenekler alanını (\u0026ldquo;caps\u0026rdquo;) destekle Ağ Uyumluluğu:\nAğ kimliği alanını destekleyin (şu anda ana ağ için 2) Mevcut Java ve i2pd gerçeklemeleriyle birlikte çalışın Hem IPv4 hem de IPv6\u0026rsquo;yı destekleyin Önerilen Uygulamalar Performans Optimizasyonu:\nArabelleğe Alma Stratejisi:\nTüm mesajları tek seferde gönder (mesaj 1, 2, 3) El sıkışma mesajları için TCP_NODELAY (Nagle algoritmasını devre dışı bırakma seçeneği) kullan Birden çok veri bloğunu tek bir çerçevede arabelleğe al Çerçeve boyutunu birkaç KB\u0026rsquo;ye sınırla (alıcı gecikmesini en aza indir) Bağlantı Yönetimi:\nMümkün olduğunda bağlantıları yeniden kullanın Bağlantı havuzu uygulayın Bağlantı sağlığını izleyin (DateTime blokları) Bellek Yönetimi:\nKullanımdan sonra hassas veriyi sıfırla (geçici anahtarlar, DH sonuçları) Eşzamanlı el sıkışmalarını sınırla (DoS önleme; Hizmet Reddi) Sık tahsisler için bellek havuzları kullan Güvenlik Sıkılaştırma:\nSondalama Direnci:\nRastgele zaman aşımı süreleri: 100-500ms Rastgele bayt okumaları: 1KB-64KB Tekrarlanan başarısızlıklar için IP kara listeleme Eşlere hata ayrıntıları sağlanmaz Kaynak Sınırları:\nIP başına maksimum bağlantı: 3-10 Maksimum bekleyen el sıkışması: 100-1000 Okuma zaman aşımları: işlem başına 30-60 saniye Toplam bağlantı zaman aşımı: el sıkışma için 5 dakika Anahtar Yönetimi:\nStatik anahtar ve IV (başlatma vektörü)\u0026rsquo;nin kalıcı olarak saklanması Güvenli rastgele sayı üretimi (kriptografik RNG - rastgele sayı üreteci) Anahtar rotasyonu politikalarına kesinlikle uyun Geçici anahtarları asla yeniden kullanmayın İzleme ve Tanılama:\nMetrikler:\nEl sıkışma başarı/başarısızlık oranları AEAD (İlişkili Verilerle Kimliği Doğrulanmış Şifreleme) hata oranları Saat sapması dağılımı Bağlantı süresi istatistikleri Günlükleme:\nEl sıkışması başarısızlıklarını neden kodlarıyla günlüğe kaydedin Saat sapması olaylarını günlüğe kaydedin Yasaklanmış IP\u0026rsquo;leri günlüğe kaydedin Hassas anahtar malzemesini asla günlüğe kaydetmeyin Testler:\nKDF zincirleri için birim testleri Diğer gerçekleştirimlerle entegrasyon testleri Paket işleme için Fuzzing (rastgele ve bozulmuş girdilerle test) DoS dayanıklılığı için yük testleri Sık Yapılan Hatalar Kaçınılması Gereken Kritik Hatalar:\nNonce (tek-kullanımlık sayı) Yeniden Kullanımı:\nOturum ortasında nonce sayacını asla sıfırlamayın Her yön için ayrı sayaçlar kullanın 2^64 - 1 değerine ulaşmadan önce sonlandırın Anahtar Döndürme:\nrouter çalışırken anahtarları asla döndürmeyin Geçici anahtarları oturumlar arasında asla yeniden kullanmayın Asgari kesinti süresi kurallarına uyun Zaman Damgası İşleme:\nSüresi geçmiş zaman damgalarını asla kabul etmeyin Sapmayı hesaplarken her zaman RTT (gidiş-dönüş süresi) için düzeltme uygulayın DateTime zaman damgalarını saniye hassasiyetine yuvarlayın AEAD (ek verili kimlik doğrulamalı şifreleme) Hataları:\nHata türünü saldırgana asla açıklamayın Kapatmadan önce her zaman rastgele bir zaman aşımı süresi kullanın Geçersiz uzunluğu AEAD başarısızlığıyla aynı şekilde ele alın Dolgu:\nUzlaşılan sınırların dışında asla dolgu göndermeyin Dolgu bloğunu her zaman en sona yerleştirin Her çerçevede birden fazla dolgu bloğu kullanmayın RouterInfo:\nHer zaman statik anahtarın RouterInfo ile eşleştiğini doğrulayın Yayınlanmış adresleri olmayan RouterInfo\u0026rsquo;ları asla flood etmeyin (ağa yaymayın) Her zaman imzaları doğrulayın Test Metodolojisi Birim Testleri:\nKriptografik Primitifler:\nX25519, ChaCha20, Poly1305, SHA-256 için test vektörleri HMAC-SHA256 test vektörleri SipHash-2-4 test vektörleri KDF Zincirleri:\nÜç iletinin tamamı için bilinen cevap testleri Zincirleme anahtar yayılımını doğrulayın SipHash IV üretimini test edin Mesaj Ayrıştırma:\nGeçerli mesajın kod çözümü Geçersiz mesajın reddedilmesi Sınır durumları (boş, azami boyut) Entegrasyon Testleri:\nEl sıkışma:\nBaşarılı üç mesajlık alışveriş Saat sapmasına göre reddetme Yeniden oynatma saldırısı tespiti Geçersiz anahtarların reddedilmesi Veri Aşaması:\nI2NP (I2P Ağ Protokolü) mesaj aktarımı RouterInfo (yönlendirici bilgisi) değişimi Doldurma yönetimi Sonlandırma mesajları Birlikte Çalışabilirlik:\nJava I2P\u0026rsquo;ye karşı test yapın i2pd\u0026rsquo;ye karşı test yapın IPv4 ve IPv6\u0026rsquo;yı test edin Yayınlanmış ve gizli routers üzerinde test yapın Güvenlik Testleri:\nNegatif Testler:\nGeçersiz AEAD etiketleri Yeniden oynatılmış mesajlar Saat kayması saldırıları Hatalı biçimlendirilmiş çerçeveler DoS (Hizmet Reddi) Testleri:\nBağlantı taşması Slowloris saldırıları CPU tükenmesi (aşırı DH (Diffie-Hellman anahtar değişimi)) Bellek tükenmesi Fuzzing (rastgele girdilerle hata bulma testi):\nRastgele el sıkışma mesajları Rastgele veri aşaması çerçeveleri Rastgele blok türleri ve boyutları Geçersiz kriptografik değerler NTCP\u0026rsquo;den geçiş Eski NTCP desteği için (artık kaldırıldı):\nNTCP (sürüm 1), I2P 0.9.50\u0026rsquo;de (Mayıs 2021) kaldırıldı. Mevcut tüm uygulamalar NTCP2\u0026rsquo;yi desteklemelidir. Tarihsel notlar:\nGeçiş Dönemi (2018-2021):\n0.9.36: NTCP2 tanıtıldı (varsayılan olarak devre dışı) 0.9.37: NTCP2 varsayılan olarak etkinleştirildi 0.9.40: NTCP kullanımı önerilmiyor (deprecated) 0.9.50: NTCP kaldırıldı Sürüm Tespiti:\n\u0026ldquo;NTCP\u0026rdquo; transportStyle (taşıma stili) her iki sürümün de desteklendiğini belirtir \u0026ldquo;NTCP2\u0026rdquo; transportStyle yalnızca NTCP2\u0026rsquo;nin desteklendiğini belirtir Mesaj boyutuna göre otomatik algılama (287 vs 288 bayt) Güncel Durum:\nTüm router\u0026rsquo;lar NTCP2\u0026rsquo;yi desteklemelidir \u0026ldquo;NTCP\u0026rdquo; transportStyle kullanımdan kaldırılmıştır Yalnızca \u0026ldquo;NTCP2\u0026rdquo; transportStyle kullanın Ek A: Noise XK Deseni Standart Noise XK Pattern (Noise protokol ailesindeki XK el sıkışma örüntüsü):\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se Yorumlama:\n\u0026lt;- : Yanıtlayıcıdan (Bob) başlatıcıya (Alice) giden mesaj -\u0026gt; : Başlatıcıdan (Alice) yanıtlayıcıya (Bob) giden mesaj s : Statik anahtar (uzun süreli kimlik anahtarı) rs : Uzak statik anahtar (eşin statik anahtarı, önceden bilinir) e : Geçici anahtar (oturuma özgü, talep üzerine üretilir) es : Geçici-Statik DH (Alice geçici × Bob statik) ee : Geçici-Geçici DH (Alice geçici × Bob geçici) se : Statik-Geçici DH (Alice statik × Bob geçici) Anahtar Anlaşması Sırası:\nÖn-mesaj: Alice, Bob\u0026rsquo;un statik açık anahtarını biliyor (RouterInfo\u0026rsquo;dan) Mesaj 1: Alice geçici anahtarı gönderir, es DH işlemini gerçekleştirir Mesaj 2: Bob geçici anahtarı gönderir, ee DH işlemini gerçekleştirir Mesaj 3: Alice statik anahtarını açıklar, se DH işlemini gerçekleştirir Güvenlik Özellikleri:\nAlice kimliği doğrulandı: Evet (3. mesajla) Bob kimliği doğrulandı: Evet (statik özel anahtara sahip olmasıyla) İleri gizlilik: Evet (geçici anahtarlar imha edildi) KCI resistance (Key Compromise Impersonation - anahtar ele geçirilmesi saldırısına karşı direnç): Evet (kimlik doğrulama seviyesi 2) Ek B: Base64 Kodlama I2P Base64 Alfabesi:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ Standart Base64\u0026rsquo;dan farklar: - 62-63 numaralı karakterler: -~, +/ yerine - Dolgu: Aynı (=) veya bağlama bağlı olarak atlanabilir\nNTCP2 kullanımında: - Statik anahtar (\u0026ldquo;s\u0026rdquo;): 32 bayt → 44 karakter (dolgu yok) - IV (\u0026ldquo;i\u0026rdquo;): 16 bayt → 24 karakter (dolgu yok)\nKodlama Örneği:\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= Ek C: Paket Yakalama Analizi NTCP2 trafiğinin tanımlanması:\nTCP El Sıkışması:\nStandart TCP SYN, SYN-ACK, ACK Hedef port genellikle 8887 veya benzeri Mesaj 1 (SessionRequest):\nAlice\u0026rsquo;ten gelen ilk uygulama verisi 80-65535 bayt (genellikle birkaç yüz) Rastgele görünür (AES ile şifrelenmiş geçici anahtar) \u0026ldquo;NTCP\u0026rdquo; adresine bağlanılıyorsa en fazla 287 bayt Mesaj 2 (SessionCreated - oturum oluşturuldu):\nBob\u0026rsquo;dan gelen yanıt 80-65535 bayt (tipik olarak birkaç yüz) Ayrıca rastgele görünür Mesaj 3 (SessionConfirmed):\nAlice\u0026rsquo;den 48 bayt + değişken (RouterInfo boyutu + dolgu) Genellikle 1-4 KB Veri Aşaması:\nDeğişken uzunluklu çerçeveler Uzunluk alanı gizlenmiş (rastgele görünür) Şifrelenmiş yük Dolgu, boyutu öngörülemez kılar DPI Atlatma: - Düz metin üstbilgileri yok - Sabit kalıplar yok - Uzunluk alanları gizlenmiş - Rastgele dolgu boyut tabanlı sezgisel yöntemleri bozar\nNTCP ile karşılaştırma: - NTCP\u0026rsquo;nin 1. mesajı her zaman 288 bayttır (tespit edilebilir) - NTCP2\u0026rsquo;nin 1. mesajının boyutu değişir (tespit edilemez) - NTCP tanınabilir örüntülere sahipti - NTCP2, DPI\u0026rsquo;ye (Derin Paket İncelemesi) direnmek üzere tasarlandı\nEk D: Sürüm Geçmişi Önemli Dönüm Noktaları:\n0.9.36 (23 Ağustos 2018): NTCP2 tanıtıldı, varsayılan olarak devre dışı 0.9.37 (4 Ekim 2018): NTCP2 varsayılan olarak etkin 0.9.40 (20 Mayıs 2019): NTCP kullanımdan kaldırıldı 0.9.42 (27 Ağustos 2019): Ağ Kimliği alanı eklendi (Öneri 147) 0.9.50 (17 Mayıs 2021): NTCP kaldırıldı, yetenekler için destek eklendi 2.10.0 (9 Eylül 2025): En son kararlı sürüm Protokol Kararlılığı: - 0.9.50\u0026rsquo;den beri geriye dönük uyumluluğu bozan değişiklik yok - Sondalama direncine yönelik devam eden iyileştirmeler - Performans ve güvenilirliğe odaklanma - Kuantum sonrası kriptografi geliştirme aşamasında (varsayılan olarak etkin değil)\nGüncel Taşıma Durumu: - NTCP2: Zorunlu TCP taşıma - SSU2: Zorunlu UDP taşıma - NTCP (v1): Kaldırıldı - SSU (v1): Kaldırıldı\n","description":"router'lar arası bağlantılar için Noise (Noise protokol çerçevesi) tabanlı TCP taşıma protokolü","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"NTCP2 Taşıma","url":"/tr/docs/specs/ntcp2/"},{"categories":null,"content":"Genel Bakış Bu belge, I2NP , I2CP , SSU2 , NTCP2 ve diğerleri de dahil olmak üzere tüm I2P protokolleri genelinde kullanılan temel veri yapılarını belirtir. Bu ortak yapılar, farklı I2P uygulamaları ve protokol katmanları arasında birlikte çalışabilirliği sağlar.\n0.9.58\u0026rsquo;den Bu Yana Önemli Değişiklikler Router Kimlikleri için ElGamal ve DSA-SHA1 kullanımdan kaldırıldı (X25519 + EdDSA kullanın) Kuantum-sonrası ML-KEM desteği beta testinde (2.10.0 itibarıyla isteğe bağlı) Service record seçenekleri standartlaştırıldı (Proposal 167 , 0.9.66\u0026rsquo;da uygulandı) Sıkıştırılabilir dolgu spesifikasyonları kesinleştirildi (Proposal 161 , 0.9.57\u0026rsquo;de uygulandı) Ortak Tür Belirtimleri Tamsayı Açıklama: Ağ bayt sırası (big-endian; en anlamlı bayt önce) ile temsil edilen negatif olmayan bir tamsayıyı ifade eder.\nİçerik: İşaretsiz bir tamsayıyı temsil eden 1 ile 8 bayt.\nKullanım: I2P protokollerinin genelinde alan uzunlukları, öğe sayıları, tür tanımlayıcıları ve sayısal değerler.\nTarih Açıklama: Unix zaman başlangıcından (1 Ocak 1970 00:00:00 GMT) bu yana geçen süreyi milisaniye cinsinden ifade eden zaman damgası.\nİçerik: 8 baytlık tamsayı (unsigned long)\nÖzel Değerler: - 0 = Tanımsız veya null tarih - Maksimum değer: 0xFFFFFFFFFFFFFFFF (yıl 584,942,417,355)\nUygulama Notları: - Her zaman UTC/GMT saat dilimi kullanılmalı - Milisaniye düzeyinde hassasiyet gerekir - lease süresinin dolması, RouterInfo yayını ve zaman damgası doğrulaması için kullanılır\nDize Açıklama: UTF-8 ile kodlanmış, uzunluk önekli dize.\nBiçim:\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes Kısıtlamalar: - Maksimum uzunluk: 255 bayt (karakter değil - çok baytlı UTF-8 dizileri birden fazla bayt olarak sayılır) - Uzunluk sıfır olabilir (boş dize) - Null sonlandırıcı DAHİL DEĞİL - Dize null ile sonlandırılmış DEĞİLDİR\nÖnemli: UTF-8 dizileri karakter başına birden çok bayt kullanabilir. 100 karakterlik bir dize, çok baytlı karakterler kullanıyorsa 255 baytlık sınırı aşabilir.\nKriptografik Anahtar Yapıları PublicKey Açıklama: Asimetrik şifreleme için açık anahtar. Anahtar türü ve uzunluğu bağlama bağlıdır veya bir Key Certificate (Anahtar Sertifikası) içinde belirtilir.\nVarsayılan Tür: ElGamal (0.9.58 itibarıyla Router Identities için kullanımdan kaldırıldı)\nDesteklenen Türler:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta **Uygulama Gereksinimleri:** X25519 (Tip 4) - Mevcut Standart:\nECIES-X25519-AEAD-Ratchet şifrelemesi için kullanılır 0.9.48\u0026rsquo;den beri Router Kimlikleri için zorunludur Little-endian (küçük uca öncelikli) kodlama (diğer türlerin aksine) Bkz. ECIES ve ECIES-ROUTERS ElGamal (Type 0) - Eski:\n0.9.58 itibarıyla Router kimlikleri için kullanımdan kaldırıldı Destinasyonlar için hala geçerli (alan 0.6/2005\u0026rsquo;ten beri kullanılmıyor) ElGamal spesifikasyonu \u0026rsquo;nda tanımlanan sabit asal sayıları kullanır Geriye dönük uyumluluk için destek korunmaktadır MLKEM (Kuantum Sonrası) - Beta:\nHibrit yaklaşım, ML-KEM\u0026rsquo;i X25519 ile birleştirir 2.10.0\u0026rsquo;da varsayılan olarak etkin değildir Hidden Service Manager (Gizli Servis Yöneticisi) üzerinden manuel etkinleştirme gerektirir Bkz. ECIES-HYBRID ve Öneri 169 Tip kodları ve teknik özellikler değişikliğe tabidir JavaDoc: PublicKey Özel anahtar Description: Asimetrik şifre çözme için özel anahtar; PublicKey türlerine karşılık gelir.\nDepolama: Tür ve uzunluk bağlamdan çıkarılır ya da veri yapıları/anahtar dosyalarında ayrı olarak saklanır.\nDesteklenen Türler:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta **Güvenlik Notları:** - Özel anahtarlar MUTLAKA kriptografik olarak güvenli rastgele sayı üreteçleri kullanılarak üretilmelidir - X25519 özel anahtarları, RFC 7748'te tanımlandığı şekilde scalar clamping (skaler kısma) kullanır - Anahtar materyali artık gerekmediğinde bellekten güvenli bir şekilde MUTLAKA silinmelidir JavaDoc: PrivateKey Oturum Anahtarı Açıklama: I2P\u0026rsquo;nin tunnel ve garlic encryption (garlic şifreleme tekniği) kapsamında AES-256 ile şifreleme ve şifre çözme için simetrik anahtar.\nİçerik: 32 bayt (256 bit)\nKullanım: - Tunnel katmanı şifrelemesi (AES-256/CBC IV ile) - Garlic mesaj şifrelemesi - Uçtan uca oturum şifrelemesi\nOluşturma: Kriptografik olarak güvenli bir rastgele sayı üreteci kullanılmalıdır.\nJavaDoc: SessionKey SigningPublicKey Açıklama: İmza doğrulaması için açık anahtar. Tür ve uzunluk, Destination (I2P varış adresi) Anahtar Sertifikası\u0026rsquo;nda belirtilir ya da bağlamdan çıkarılır.\nVarsayılan Tür: DSA_SHA1 (0.9.58 itibarıyla kullanımdan kaldırılmıştır)\nDesteklenen Türler:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- **Uygulama Gereksinimleri:** EdDSA_SHA512_Ed25519 (Tür 7) - Güncel Standart:\n2015\u0026rsquo;in sonlarından beri tüm yeni Router Kimlikleri ve Hedefler için varsayılan SHA-512 karmasıyla Ed25519 eğrisini kullanır 32 baytlık açık anahtarlar, 64 baytlık imzalar Little-endian (küçük-uçlu) kodlama (diğer çoğu türün aksine) Yüksek performans ve güvenlik RedDSA_SHA512_Ed25519 (Type 11) - Özel amaçlı:\nYalnızca şifrelenmiş leasesets ve blinding (körleme) için kullanılır Asla Router Identities veya standart Destinations için kullanılmaz EdDSA\u0026rsquo;ya göre temel farklar: Özel anahtarlar modüler indirgeme ile elde edilir (clamping değil) İmzalar 80 bayt rastgele veri içerir Açık anahtarları doğrudan kullanır (özel anahtarların özetleri değil) Bkz. [Red25519 spesifikasyonu](//docs/specs/red25519-signature-scheme/ DSA_SHA1 (Type 0) - Eski:\n0.9.58 itibarıyla Router Kimlikleri için kullanımdan kaldırıldı Yeni Destinations (hedefler) için önerilmez SHA-1 ile 1024-bit DSA (bilinen zayıflıklar) Destek yalnızca uyumluluk amacıyla sürdürülmektedir Çok bileşenli anahtarlar:\nİki bileşenden oluştuğunda (örneğin ECDSA noktaları X,Y) Her bir bileşen, başa sıfırlar eklenerek length/2 olacak şekilde doldurulur Örnek: 64 baytlık ECDSA anahtarı = 32 bayt X + 32 bayt Y JavaDoc: SigningPublicKey SigningPrivateKey Açıklama: İmzaları oluşturmak için kullanılan ve SigningPublicKey (imza doğrulaması için kullanılan açık anahtar) türlerine karşılık gelen özel anahtar.\nDepolama: Tür ve uzunluk oluşturma anında belirtilir.\nDesteklenen Türler:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized **Güvenlik Gereksinimleri:** - Kriptografik olarak güvenli bir rastgele kaynak kullanarak oluşturun - Uygun erişim kontrolleriyle koruyun - İş bittikten sonra bellekten güvenli bir şekilde silin - EdDSA için: 32 baytlık tohum SHA-512 ile özetlenir, ilk 32 bayt skaler hâline getirilir (clamped — bitleri standart maskeyle ayarlanmış) - RedDSA için: Farklı anahtar üretimi (clamping yerine modüler indirgeme) JavaDoc: SigningPrivateKey İmza Açıklama: Veri üzerinde, SigningPrivateKey türüne karşılık gelen imzalama algoritması kullanılarak oluşturulan kriptografik imza.\nTür ve Uzunluk: İmzalamada kullanılan anahtar türünden çıkarılır.\nDesteklenen Türler:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized **Biçim Notları:** - Çok öğeli imzalar (ör. ECDSA R,S değerleri) her bir öğe length/2'ye ulaşacak şekilde baştaki sıfırlarla doldurulur - EdDSA ve RedDSA little-endian kodlaması kullanır - Diğer tüm türler big-endian kodlaması kullanır Doğrulama: - İlgili SigningPublicKey kullanın - Anahtar türü için imza algoritması spesifikasyonlarına uyun - İmza uzunluğunun anahtar türü için beklenen uzunlukla eşleştiğini kontrol edin\nJavaDoc: Signature Özet Açıklama: Verinin SHA-256 karması, I2P genelinde bütünlük doğrulaması ve tanımlama için kullanılır.\nİçerik: 32 bayt (256 bit)\nKullanım: - Router Kimliği karma değerleri (ağ veritabanı anahtarları) - Hedef karma değerleri (ağ veritabanı anahtarları) - Leases (leaseSet içindeki ögeler) içinde Tunnel ağ geçidinin tanımlanması - Veri bütünlüğünün doğrulanması - Tunnel ID\u0026rsquo;nin oluşturulması\nAlgoritma: SHA-256, FIPS 180-4\u0026rsquo;te tanımlandığı şekilde\nJavaDoc: Hash Oturum Etiketi Açıklama: Oturum tanımlama ve etiket tabanlı şifreleme için kullanılan rastgele sayı.\nÖnemli: Oturum etiketi boyutu şifreleme türüne göre değişir: - ElGamal/AES+SessionTag: 32 bayt (eski) - ECIES-X25519: 8 bayt (mevcut standart)\nMevcut Standart (ECIES - Eliptik Eğri Entegre Şifreleme Şeması):\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers Ayrıntılı spesifikasyonlar için ECIES ve ECIES-ROUTERS belgelerine bakın.\nEski (ElGamal/AES):\nContents: 32 bytes Usage: Deprecated encryption scheme Üretim: Kriptografik olarak güvenli bir rastgele sayı üretecinin kullanılması zorunludur.\nJavaDoc: SessionTag TunnelId Açıklama: Bir router\u0026rsquo;ın bir tunnel içindeki konumuna ilişkin benzersiz tanımlayıcı. Bir tunnel içindeki her atlama kendi TunnelId\u0026rsquo;sine (tünel kimliği) sahiptir.\nBiçim:\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) Kullanım: - Her router\u0026rsquo;da gelen/giden tunnel bağlantılarını belirler - Tunnel zincirindeki her hop (ağ atlaması) için farklı bir TunnelId kullanılır - Geçit tunnel\u0026rsquo;lerini belirlemek için Lease yapılarında (I2P\u0026rsquo;de kiralama kayıtları) kullanılır\nÖzel Değerler: - 0 = Özel protokol amaçları için ayrılmıştır (normal çalışmada kullanmaktan kaçının) - TunnelIds (tunnel kimlikleri) her bir router için yerel olarak geçerlidir\nJavaDoc: TunnelId Sertifika Özellikleri Sertifika Açıklama: I2P genelinde kullanılan alındılar, iş ispatı (proof-of-work) veya kriptografik üstveri için kapsayıcı.\nBiçim:\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes Toplam Boyut: minimum 3 bayt (NULL certificate - boş sertifika), maksimum 65538 bayt\nSertifika Türleri Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) ### Anahtar Sertifikası (Tip 5) Giriş: Sürüm 0.9.12 (Aralık 2013)\nPurpose: Varsayılan olmayan anahtar türlerini belirtir ve standart 384 baytlık KeysAndCert yapısının dışında kalan fazla anahtar verisini depolar.\nYük Yapısı:\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space Kritik Gerçekleştirim Notları:\nAnahtar Türü Sırası:\nUYARI: İmzalama anahtar türü, Kripto anahtar türünden ÖNCE gelir Bu sezgilere aykırıdır ancak uyumluluk için korunmaktadır Sıra: SPKtype, CPKtype (CPKtype, SPKtype değil) KeysAndCert içinde Anahtar Verisi Düzeni:\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] Fazla Anahtar Verisini Hesaplama:\nEğer Crypto Key \u0026gt; 256 bayt ise: Excess = (Crypto Length - 256) Eğer Signing Key \u0026gt; 128 bayt ise: Excess = (Signing Length - 128) Padding = max(0, 384 - Crypto Length - Signing Length) Örnekler (ElGamal Kripto Anahtarı):\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 **Router Kimliği Gereksinimleri:** - 0.9.15 sürümüne kadar NULL sertifikası kullanıldı - 0.9.16 sürümünden beri varsayılan olmayan anahtar türleri için Anahtar Sertifikası gerekli - 0.9.48 sürümünden beri X25519 şifreleme anahtarları destekleniyor Destination (uç nokta kimliği) gereksinimleri: - NULL sertifika VEYA Key Certificate (anahtar sertifikası) (gerektiğinde) - Varsayılan olmayan imzalama anahtarı türleri için 0.9.12\u0026rsquo;den beri Key Certificate gereklidir - Kripto açık anahtar alanı 0.6\u0026rsquo;dan (2005) beri kullanılmıyor, ancak yine de mevcut olmalıdır\nÖnemli Uyarılar:\nNULL ve KEY Sertifikası:\nElGamal+DSA_SHA1\u0026rsquo;ı belirten (0,0) türlerine sahip bir KEY sertifikasına izin verilir ancak önerilmez ElGamal+DSA_SHA1 için her zaman NULL sertifikasını kullanın (kanonik gösterim) (0,0) olan KEY sertifikası 4 bayt daha uzundur ve uyumluluk sorunlarına yol açabilir Bazı gerçekleştirimler (0,0) KEY sertifikalarını doğru şekilde işleyemeyebilir Fazladan Veri Doğrulaması:\nUygulamalar, sertifika uzunluğunun anahtar türleri için beklenen uzunlukla eşleştiğini doğrulamak ZORUNDADIR Anahtar türlerine karşılık gelmeyen fazladan veri içeren sertifikaları reddedin Geçerli sertifika yapısından sonra yer alan çöp veriyi yasaklayın JavaDoc: Sertifika Eşleme Açıklama: Yapılandırma ve meta veriler için kullanılan anahtar-değer özellik koleksiyonu.\nBiçim:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] Boyut Sınırları: - Anahtar uzunluğu: 0-255 bayt (+ uzunluk için 1 bayt) - Değer uzunluğu: 0-255 bayt (+ uzunluk için 1 bayt) - Toplam eşleme boyutu: 0-65535 bayt (+ boyut alanı için 2 bayt) - Maksimum yapı boyutu: 65537 bayt\nKritik Sıralama Gereksinimi:\nEşlemeler imzalı yapılar içinde (RouterInfo, RouterAddress, Destination (hedef) özellikleri, I2CP SessionConfig) bulunduğunda, girdiler imzanın değişmezliğini sağlamak için anahtarlarına göre MUTLAKA sıralanmalıdır:\nSıralama Yöntemi: Unicode kod noktası değerlerini kullanarak leksikografik sıralama (Java String.compareTo() ile eşdeğer) Büyük/Küçük Harf Duyarlılığı: Anahtarlar ve değerler genellikle büyük/küçük harfe duyarlıdır (uygulamaya bağlı) Yinelenen Anahtarlar: İmzalı yapılarda İZİN VERİLMEZ (imza doğrulama hatasına yol açar) Karakter Kodlaması: UTF-8 bayt düzeyinde karşılaştırma Sıralama Neden Önemlidir: - İmzalar bayt gösterimi üzerinden hesaplanır - Farklı anahtar sıraları farklı imzalar üretir - İmzalanmamış eşlemeler sıralama gerektirmez ancak aynı kurala uymalıdır\nUygulama Notları:\nKodlama Fazlalığı:\nHem = ve ; ayraçları hem de dize uzunluğu baytları mevcut Bu verimsizdir, ancak uyumluluk için korunmaktadır Uzunluk baytları esas alınır; ayraçlar gerekli olsa da fazladır Karakter Desteği:\nBelgelerde yazılanlara rağmen, = ve ; dizgiler içinde DESTEKLENİR (bunu uzunluk baytları halleder) UTF-8 kodlaması tüm Unicode\u0026rsquo;u destekler Uyarı: I2CP UTF-8 kullanır, ancak I2NP tarihsel olarak UTF-8\u0026rsquo;i doğru şekilde işleyemiyordu Azami uyumluluk için mümkün olduğunda I2NP eşlemeleri için ASCII kullanın Özel Bağlamlar:\nRouterInfo/RouterAddress: Sıralı olmalıdır, yinelenen olmamalıdır I2CP SessionConfig: Sıralı olmalıdır, yinelenen olmamalıdır Uygulama eşlemeleri: Sıralama önerilir ancak her zaman zorunlu değildir Örnek (RouterInfo seçenekleri):\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 JavaDoc: DataHelper Ortak Yapı Belirtimi Anahtarlar ve Sertifikalar Açıklama: Şifreleme anahtarı, imzalama anahtarı ve sertifikayı birleştiren temel yapıdır. Hem RouterIdentity (Yönlendirici Kimliği) hem de Destination (Hedef) olarak kullanılır.\nYapı:\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) Anahtar Hizalaması: - Kriptografik Açık Anahtar: Başta hizalı (bayt 0) - Dolgu: Ortada (gerekirse) - İmzalama Açık Anahtarı: Sonda hizalı (bayt 256 ile bayt 383 arası) - Sertifika: Bayt 384\u0026rsquo;te başlar\nBoyut Hesaplaması:\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length Dolgu Üretimi Yönergeleri (Öneri 161 ) Uygulama Sürümü: 0.9.57 (Ocak 2023, sürüm 2.1.0)\nArka plan: - ElGamal+DSA olmayan anahtarlar için, 384 baytlık sabit yapıda dolgu bulunur - Destinations (I2P adresleri) için, 256 baytlık açık anahtar alanı 0.6\u0026rsquo;dan (2005) beri kullanılmıyor - Dolgu, güvenliği korurken sıkıştırılabilir olacak şekilde üretilmelidir\nGereksinimler:\nAsgari Rastgele Veri:\nEn az 32 bayt kriptografik olarak güvenli rastgele veri kullanın Bu, güvenlik için yeterli entropi sağlar Sıkıştırma Stratejisi:\n32 baytı dolgu/açık anahtar alanı boyunca tekrarlayın I2NP Database Store, Streaming SYN, SSU2 handshake gibi protokoller sıkıştırma kullanır Güvenliği zedelemeden önemli bant genişliği tasarrufu Örnekler:\nRouter Kimliği (X25519 + EdDSA):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed Hedef (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed Bu Neden Çalışır:\nTam yapının SHA-256 hash (özet) değeri yine de tüm entropiyi içerir Ağ veritabanının DHT dağıtımı yalnızca hash’e bağlıdır İmzalama anahtarı (32 bayt EdDSA/X25519) 256 bit entropi sağlar Tekrar eden rastgele verinin ilave 32 baytı = toplam 512 bit entropi Kriptografik güç için fazlasıyla yeterli Uygulama Notları:\n387+ baytlık yapının tamamını saklamalı ve iletmelidir SHA-256 özeti, sıkıştırılmamış yapının tamamı üzerinden hesaplanır Sıkıştırma, protokol katmanında uygulanır (I2NP, Streaming, SSU2) 0.6 (2005) sürümünden bu yana tüm sürümlerle geriye dönük uyumludur JavaDoc: KeysAndCert RouterIdentity (router kimliği) Açıklama: I2P ağındaki bir router\u0026rsquo;ı benzersiz şekilde tanımlar. Yapısı KeysAndCert ile aynıdır.\nBiçim: Yukarıdaki KeysAndCert yapısına bakın\nGüncel Gereksinimler (0.9.58 itibarıyla):\nZorunlu Anahtar Türleri:\nŞifreleme: X25519 (tip 4, 32 bayt) İmzalama: EdDSA_SHA512_Ed25519 (tip 7, 32 bayt) Sertifika: Key Certificate (tip 5) Kullanımdan Kaldırılan Anahtar Türleri:\nElGamal (tip 0) 0.9.58 itibarıyla Router Kimlikleri için kullanımdan kaldırılmıştır DSA_SHA1 (tip 0) 0.9.58 itibarıyla Router Kimlikleri için kullanımdan kaldırılmıştır Bunlar yeni router\u0026rsquo;lar için KULLANILMAMALIDIR Tipik Boyut:\nX25519 + EdDSA, Anahtar Sertifikası ile = 391 bayt 32 bayt X25519 açık anahtarı 320 bayt dolgu (Proposal 161 \u0026rsquo;e göre sıkıştırılabilir) 32 bayt EdDSA açık anahtarı 7 bayt sertifika (3 baytlık başlık + 4 baytlık anahtar türleri) Tarihsel Gelişim: - 0.9.16 öncesi: Her zaman NULL sertifikası (ElGamal + DSA_SHA1) - 0.9.16-0.9.47: Anahtar Sertifikası desteği eklendi - 0.9.48+: X25519 şifreleme anahtarları desteklendi - 0.9.58+: ElGamal ve DSA_SHA1 kullanımdan kaldırıldı\nAğ Veritabanı Anahtarı: - RouterInfo, tam RouterIdentity\u0026rsquo;nin SHA-256 özeti ile anahtarlanır - Özet, 391+ baytlık tam yapı üzerinde (doldurma dahil) hesaplanır\nAyrıca bakınız: - Dolgu (padding) oluşturma yönergeleri (Öneri 161 ) - Yukarıdaki Anahtar Sertifikası belirtimi\nJavaDoc: RouterIdentity Hedef Açıklama: Güvenli mesaj teslimi için uç nokta tanımlayıcısı. Yapısal olarak KeysAndCert (anahtarlar ve sertifikadan oluşan yapı) ile aynıdır, ancak kullanım semantiği farklıdır.\nBiçim: Bkz. yukarıdaki KeysAndCert yapısı\nRouterIdentity\u0026rsquo;den kritik fark: - Açık anahtar alanı KULLANILMIYOR ve rastgele veri içerebilir - Bu alan 0.6 sürümünden (2005) beri kullanılmıyor - Aslen eski I2CP-to-I2CP şifrelemesi için kullanılıyordu (devre dışı) - Şu anda yalnızca kullanımdan kaldırılmış LeaseSet şifrelemesi için IV (ilklendirme vektörü) olarak kullanılır\nGüncel Öneriler:\nİmza Anahtarı:\nÖnerilen: EdDSA_SHA512_Ed25519 (tür 7, 32 bayt) Alternatif: Eski sürümlerle uyumluluk için ECDSA türleri Kaçının: DSA_SHA1 (kullanımdan kaldırıldı, önerilmez) Şifreleme Anahtarı:\nAlan kullanılmıyor ancak mevcut olmalıdır Önerilir: Proposal 161 uyarınca rastgele verilerle doldurun (sıkıştırılabilir) Boyut: Her zaman 256 bayt (ElGamal yuvası, ElGamal için kullanılmasa da) Sertifika:\nElGamal + DSA_SHA1 için NULL sertifika (yalnızca eski) Diğer tüm imzalama anahtarı türleri için Anahtar Sertifikası Tipik Modern Hedef:\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes Gerçek Şifreleme Anahtarı: - Destination (I2P hedef adresi) için şifreleme anahtarı LeaseSet içindedir, Destination\u0026rsquo;da değil - LeaseSet geçerli şifreleme genel anahtar(lar)ını içerir - Şifreleme anahtarının işlenmesi için LeaseSet2 spesifikasyonuna bakın\nAğ Veritabanı Anahtarı: - LeaseSet, tam Destination (hedef) değerinin SHA-256 karmasıyla anahtarlanır - Karma, 387+ baytlık yapının tamamı üzerinden hesaplanır\nJavaDoc: Destination Ağ Veritabanı Yapıları Lease (kiralama kaydı) Açıklama: Belirli bir tunnel’i, bir Destination (Hedef) için mesaj almaya yetkilendirir. Orijinal LeaseSet formatının (tip 1) bir parçasıdır.\nBiçim:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch Toplam Boyut: 44 bayt\nKullanım: - Yalnızca orijinal LeaseSet\u0026rsquo;te kullanılır (tip 1, kullanımdan kaldırılmış) - LeaseSet2 ve sonraki varyantlar için bunun yerine Lease2 kullanın\nJavaDoc: Lease LeaseSet (Tür 1) Açıklama: Orijinal LeaseSet biçimi. Bir Destination (hedef kimlik) için yetkilendirilmiş tunnel\u0026rsquo;lar ve anahtarlar içerir. ağ veritabanında saklanır. Durum: Kullanımdan kaldırıldı (yerine LeaseSet2 kullanın).\nYapı:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey Veritabanı Depolaması: - Veritabanı Türü: 1 - Anahtar: Hedefin SHA-256 karması - Değer: Tam LeaseSet yapısı\nÖnemli Notlar:\nDestination (I2P’de uç nokta adres nesnesi) Genel Anahtarı Kullanılmıyor:\nDestination içindeki şifreleme genel anahtarı alanı kullanılmıyor LeaseSet içindeki şifreleme anahtarı gerçek şifreleme anahtarıdır Geçici Anahtarlar:\nencryption_key geçicidir (router başlatıldığında yeniden oluşturulur) signing_key geçicidir (router başlatıldığında yeniden oluşturulur) Her iki anahtar da yeniden başlatmalar arasında kalıcı değildir İptal (Uygulanmadı):\nsigning_key, LeaseSet iptali için tasarlanmıştı İptal mekanizması hiçbir zaman uygulanmadı Sıfır-lease (kiralama girdisi)’li LeaseSet iptal için tasarlanmıştı ancak kullanılmıyor Sürümlendirme/Zaman damgası:\nLeaseSet\u0026rsquo;te açık bir published zaman damgası alanı yoktur Sürüm, tüm lease\u0026rsquo;lerin (lease: I2P\u0026rsquo;de inbound tunnel referans kaydı) en erken sona erme zamanıdır Yeni LeaseSet\u0026rsquo;in kabul edilmesi için lease sona erme zamanı daha erken olmalıdır Lease Sona Erme Bilgisinin Yayımlanması:\n0.9.7 öncesi: Tüm leases (I2P’de yönlendirme için kullanılan lease girdileri) aynı sona erme zamanı (en erkeni) ile yayımlanırdı 0.9.7+: Gerçek bireysel lease sona erme zamanları yayımlanır Bu bir uygulama ayrıntısıdır, belirtimin parçası değildir Sıfır Leases:\nSıfır Leases içeren LeaseSet teknik olarak izinlidir İptal için tasarlandı (uygulanmamış) Pratikte kullanılmıyor LeaseSet2 varyantları en az bir Lease (I2P\u0026rsquo;de bir inbound tunnel kaydı) gerektirir Kullanımdan kaldırma: LeaseSet tür 1 kullanımdan kaldırılmıştır. Yeni uygulamalar, şu özellikleri sağlayan LeaseSet2 (tür 3) kullanmalıdır: - Yayımlanma zaman damgası alanı (daha iyi sürümleme) - Birden fazla şifreleme anahtarı desteği - Çevrimdışı imza yeteneği - 4 baytlık lease (kiralama girdisi) sona erme süreleri (8 bayta kıyasla) - Daha esnek seçenekler\nJavaDoc: LeaseSet LeaseSet Varyantları Lease2 (Lease nesnesinin ikinci sürümü) Açıklama: 4 baytlık sona erme zamanı içeren geliştirilmiş lease (kiralama kaydı) biçimi. LeaseSet2 (type 3) ve MetaLeaseSet (type 7) içinde kullanılır.\nGiriş: Sürüm 0.9.38 (bkz. Öneri 123 )\nBiçim:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 Toplam Boyut: 40 bayt (orijinal Lease\u0026rsquo;ten 4 bayt daha küçük)\nOrijinal Lease (I2P\u0026rsquo;de bir tunnel kiralama kaydı) ile Karşılaştırma:\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet **JavaDoc:** [Lease2](http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html) Çevrimdışı İmza Açıklama: Hedefin özel imzalama anahtarına çevrimiçi erişim olmadan LeaseSet yayınlanmasına olanak tanıyan, önceden imzalanmış geçici anahtarlar için isteğe bağlı bir yapı.\nGiriş: Version 0.9.38 (bkz. Öneri 123 )\nBiçim:\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey Amaç: - Çevrimdışı LeaseSet oluşturulmasını sağlar - Destination (I2P\u0026rsquo;de uç kimliği) ana anahtarını çevrimiçi ifşadan korur - Geçici anahtar, çevrimdışı imza olmadan yeni bir LeaseSet yayımlanarak iptal edilebilir\nKullanım Senaryoları:\nYüksek Güvenlikli Hedefler:\nAna imzalama anahtarı çevrimdışı olarak saklanır (HSM, soğuk depolama) Geçici anahtarlar sınırlı süreler için çevrimdışı olarak oluşturulur Ele geçirilmiş bir geçici anahtar, ana imzalama anahtarını açığa çıkarmaz Şifreli LeaseSet (I2P\u0026rsquo;de bir hizmetin iletişim uç noktalarını ve anahtarlarını içeren kayıt) Yayınlama:\nEncryptedLeaseSet, çevrimdışı imza içerebilir Körlenmiş açık anahtar + çevrimdışı imza ek güvenlik sağlar Güvenlik Hususları:\nSona Erme Yönetimi:\nMakul bir sona erme süresi belirleyin (günler ila haftalar, yıllar değil) Sona ermeden önce yeni geçici anahtarlar oluşturun Daha kısa sona erme süresi = daha iyi güvenlik, daha fazla bakım Anahtar Üretimi:\nGeçici anahtarları güvenli bir ortamda çevrimdışı oluşturun Çevrimdışı olarak ana anahtarla imzalayın Yalnızca imzalanmış geçici anahtarı + imzayı çevrimiçi router\u0026rsquo;a aktarın İptal:\nÖrtük iptal için çevrimdışı imza olmadan yeni bir LeaseSet yayımlayın Ya da farklı bir geçici anahtarla yeni bir LeaseSet yayımlayın İmza Doğrulama:\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature Uygulama Notları: - Toplam boyut, imza türü ve Destination (I2P hedef kimliği) imzalama anahtarı türüne bağlı olarak değişir - Minimum boyut: 4 + 2 + 32 (EdDSA anahtarı) + 64 (EdDSA imzası) = 102 bayt - Maksimum pratik boyut: ~600 bayt (RSA-4096 geçici anahtarı + RSA-4096 imzası)\nŞunlarla uyumlu: - LeaseSet2 (I2P\u0026rsquo;de bir adresin erişim kaydı; tip 3) - EncryptedLeaseSet (tip 5) - MetaLeaseSet (tip 7)\nAyrıca bkz.: Ayrıntılı çevrimdışı imza protokolü için Öneri 123 .\nLeaseSet2Header Açıklama: LeaseSet2 (tip 3) ve MetaLeaseSet (tip 7) için ortak başlık yapısı.\nGiriş: Sürüm 0.9.38 (bkz. Öneri 123 )\nBiçim:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length Minimum Toplam Boyut: 395 bayt (çevrimdışı imza hariç)\nBayrak Tanımları (bit sırası: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility **Bayrak Ayrıntıları:** Bit 0 - Çevrimdışı Anahtarlar: - 0: Çevrimdışı imza yok, LeaseSet imzasını doğrulamak için Destination\u0026rsquo;ın imzalama anahtarını kullanın - 1: OfflineSignature yapısı flags alanından sonra gelir\nBit 1 - Yayınlanmamış: - 0: Standart yayınlanmış LeaseSet (hedefin tunnel kiralarını içeren kayıt), floodfill\u0026rsquo;lere yayılmalıdır - 1: Yayınlanmamış LeaseSet (yalnızca istemci tarafında) - Floodfill\u0026rsquo;lere yayılmamalı, yayınlanmamalı veya sorgulara yanıt olarak gönderilmemelidir - Süresi dolmuşsa, yerine yenisini bulmak için netdb sorgulanmamalıdır (bit 2 de ayarlıysa hariç) - Yerel tunnel\u0026rsquo;lar veya test için kullanılır\nSona Erme Sınırları:\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours **Yayınlanma Zaman Damgası Gereksinimleri:** LeaseSet (tip 1) bir published alanına sahip değildi; sürümleme için en erken lease (kiralama) sona erme zamanını aramayı gerektiriyordu. LeaseSet2, 1 saniyelik çözünürlükle açıkça belirtilmiş bir published zaman damgası ekler.\nKritik Uygulama Notu: - Routers, Destination başına LeaseSet yayın hızını saniyede birden çok daha yavaş olacak şekilde sınırlamak zorundadır - Daha hızlı yayınlanıyorsa, her yeni LeaseSet\u0026rsquo;in published zamanının en az 1 saniye daha sonra olduğundan emin olun - Floodfills, published zamanı mevcut sürümden daha yeni değilse LeaseSet\u0026rsquo;i reddedecektir - Önerilen asgari aralık: yayınlar arasında 10-60 saniye\nHesaplama Örnekleri:\nLeaseSet2 (en fazla 11 dakika):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet (en fazla 18,2 saat):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) Sürümleme: - published zaman damgası daha büyükse LeaseSet \u0026ldquo;daha yeni\u0026rdquo; kabul edilir - Floodfills yalnızca en yeni sürümü depolar ve yayar - En eski Lease (kiralama kaydı) önceki LeaseSet\u0026rsquo;in en eski Lease\u0026rsquo;i ile eşleştiğinde dikkat edin\nLeaseSet2 (Tür 3) Açıklama: Birden çok şifreleme anahtarı, çevrimdışı imzalar ve hizmet kayıtlarını destekleyen modern LeaseSet biçimi. I2P gizli hizmetleri için güncel standarttır.\nGiriş: Sürüm 0.9.38 (bkz. Öneri 123 )\nYapı:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix Veritabanı Depolaması: - Veritabanı Türü: 3 - Anahtar: Destination (I2P\u0026rsquo;de hedef kimlik) öğesinin SHA-256 karması - Değer: Tam LeaseSet2 yapısı\nİmza Hesaplaması:\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key Şifreleme Anahtarı Tercih Sırası Yayımlanmış (Sunucu) LeaseSet için: - Anahtarlar sunucunun tercih sırasına göre listelenir (en çok tercih edilen en başta) - Birden fazla türü destekleyen istemciler sunucu tercihine UYMALIDIR - Listeden desteklenen ilk türü seçin - Genel olarak, numarası daha yüksek (daha yeni) anahtar türleri daha güvenli/verimlidir - Önerilen sıra: Anahtarları tür koduna göre ters sırada listeleyin (en yenisi en başta)\nÖrnek Sunucu Tercihi:\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] Yayınlanmamış (İstemci) LeaseSet için: - Anahtar sırası pratikte önemli değildir (istemcilere bağlantı denemeleri nadirdir) - Tutarlılık için aynı kurala uyun\nİstemci Anahtarı Seçimi: - Sunucu tercihini esas al (desteklenen ilk türü seç) - Ya da uygulama tarafından tanımlanan tercihi kullan - Ya da her iki tarafın yeteneklerine dayanarak ortak bir tercih belirle\nSeçenek Eşlemesi Gereksinimler: - Seçenekler anahtara göre MUTLAKA sıralanmalıdır (leksikografik, UTF-8 bayt sırası) - Sıralama, imzanın değişmezliğini sağlar - Yinelenen anahtarlara İZİN VERİLMEZ\nStandart Format (Öneri 167 ):\nAPI 0.9.66 (Haziran 2025, 2.9.0 sürümü) itibarıyla, service record (hizmet kaydı) seçenekleri standart bir biçime uyar. Tam spesifikasyon için Proposal 167 belgesine bakın.\nServis Kaydı Seçenek Biçimi:\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) Örnek Hizmet Kayıtları:\n1. Kendi Kendine Referans Veren SMTP Sunucusu:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. Tek Harici SMTP Sunucusu:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. Birden Fazla SMTP Sunucusu (Yük Dengeleme):\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. Uygulama Seçenekleri ile HTTP Hizmeti:\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates TTL (yaşam süresi) Önerileri: - En az: 86400 saniye (1 gün) - Daha uzun TTL, netdb sorgu yükünü azaltır - Sorgu azaltımı ile hizmet güncellemelerinin yayılımı arasında denge - Kararlı hizmetler için: 604800 (7 gün) veya daha uzun\nUygulama Notları:\nŞifreleme Anahtarları (0.9.44 itibarıyla):\nElGamal (tip 0, 256 bayt): Eski sürümlerle uyumluluk X25519 (tip 4, 32 bayt): Güncel standart MLKEM varyantları: Kuantum sonrası (beta, henüz kesinleşmedi) Anahtar Uzunluğu Doğrulaması:\nFloodfill düğümleri ve istemciler bilinmeyen anahtar türlerini ayrıştırabilmek zorundadır Bilinmeyen anahtarları atlamak için keylen alanını kullanın Anahtar türü bilinmiyorsa ayrıştırma başarısız olmamalıdır Yayınlanan Zaman Damgası:\nHız sınırlamasıyla ilgili LeaseSet2Header notlarına bakın Yayınlar arasında en az 1 saniyelik artış gereklidir Önerilen: Yayınlar arasında 10-60 saniye Şifreleme Türü Geçişi:\nBirden çok anahtar, kademeli geçişi destekler Geçiş döneminde hem eski hem de yeni anahtarları listeleyin Yeterli bir istemci yükseltme süresi geçtikten sonra eski anahtarı kaldırın JavaDoc: LeaseSet2 MetaLease Açıklama: MetaLeaseSet (özel bir leaseSet türü) için, tunnels yerine diğer LeaseSets\u0026rsquo;e başvurabilen bir Lease yapısı. Yük dengeleme ve yedeklilik için kullanılır.\nGiriş: Sürüm 0.9.38, 0.9.40’ta çalışması planlanıyor (bkz. Öneri 123 )\nBiçim:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 Toplam Boyut: 40 bayt\nGirdi Türü (bayrak bitleri 3-0):\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) **Kullanım Senaryoları:** Yük Dengeleme:\nBirden çok MetaLease (tekil kiralama girdisi) girdisi içeren MetaLeaseSet (I2P\u0026rsquo;de üst düzey LeaseSet türü) Her bir girdi farklı bir LeaseSet2\u0026rsquo;ye işaret eder İstemciler cost alanına göre seçim yapar Yedeklilik:\nYedek leaseSet\u0026rsquo;lere (I2P’de bir hedefin kullanılabilir giriş tünellerini tanımlayan veri kümesi) işaret eden birden çok kayıt Birincil leaseSet kullanılamadığında geri dönüş Hizmet Geçişi:\nMetaLeaseSet (LeaseSet\u0026rsquo;leri meta düzeyde tanımlayan yapı) yeni LeaseSet\u0026rsquo;e işaret eder Destinations (I2P\u0026rsquo;de hedef kimlik/adresler) arasında sorunsuz geçişe olanak tanır Maliyet Alanı Kullanımı: - Daha düşük maliyet = daha yüksek öncelik - Maliyet 0 = en yüksek öncelik - Maliyet 255 = en düşük öncelik - İstemciler daha düşük maliyetli kayıtları tercih etmelidir - Eş maliyetli kayıtlar rastgele olarak yük dengelenebilir\nLease2 ile karşılaştırma:\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing **JavaDoc:** [MetaLease](http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html) MetaLeaseSet (leaseSet\u0026rsquo;ler için meta küme, Tür 7) Açıklama: Diğer LeaseSet\u0026rsquo;lere dolaylı yönlendirme sağlayan MetaLease (bir giriş türü) girdileri içeren bir LeaseSet varyantı. Yük dengeleme, yedeklilik ve hizmet geçişi için kullanılır.\nGiriş: 0.9.38\u0026rsquo;de tanımlandı, 0.9.40\u0026rsquo;ta çalışır hâle gelmesi planlandı (bkz. Öneri 123 )\nDurum: Spesifikasyon tamamlandı. Üretim ortamına dağıtım durumu, mevcut I2P sürümleriyle doğrulanmalıdır.\nYapı:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations Veritabanı Depolaması: - Veritabanı Türü: 7 - Anahtar: Destination (I2P hedef kimliği) değerinin SHA-256 özeti - Değer: Tam MetaLeaseSet yapısı\nİmzanın Hesaplanması:\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key Kullanım Senaryoları:\n1. Yük Dengeleme:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. Failover (hata durumunda devretme):\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. Hizmet Geçişi:\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. Çok Katmanlı Mimari:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing İptal Listesi:\nGeri çekme listesi, MetaLeaseSet (özel bir LeaseSet türü)\u0026lsquo;in daha önce yayımlanmış LeaseSet\u0026rsquo;leri açıkça geri çekmesine olanak tanır:\nAmaç: Belirli Destination (I2P hedefi) öğelerini artık geçersiz olarak işaretlemek İçerik: İptal edilmiş Destination yapılarına ait SHA-256 özetleri Kullanım: İstemciler, Destination özet değeri iptal listesinde yer alan LeaseSet\u0026rsquo;leri KULLANMAMALIDIR Tipik Değer: Çoğu kurulumda Boş (numr=0) İptal Örneği:\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached Sona Erme Yönetimi:\nMetaLeaseSet, expires=65535 saniye (~18,2 saat) azami değeriyle LeaseSet2Header kullanır:\nLeaseSet2\u0026rsquo;den çok daha uzun (en fazla ~11 dakika) Nispeten statik dolaylı adresleme için uygundur Başvurulan LeaseSet\u0026rsquo;lerin geçerlilik süresi daha kısa olabilir İstemciler, hem MetaLeaseSet\u0026rsquo;in hem de başvurulan LeaseSet\u0026rsquo;lerin geçerlilik sürelerini kontrol etmelidir Seçenek Eşlemesi:\nLeaseSet2 options ile aynı formatı kullanın Hizmet kayıtlarını içerebilir (Öneri 167 ) Anahtara göre sıralanmış OLMALIDIR Hizmet kayıtları genellikle indirection structure (dolaylama yapısı) yerine nihai hizmeti tanımlar İstemci Gerçekleme Notları:\nÇözümleme Süreci:\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry Önbellekleme:\nHem MetaLeaseSet (diğer LeaseSet\u0026rsquo;lere referans veren üst düzey kayıt) hem de referans verilen LeaseSet\u0026rsquo;leri önbelleğe al Her iki düzeyin süresinin dolup dolmadığını kontrol et Güncellenmiş MetaLeaseSet\u0026rsquo;in yayınlanmasını izle Failover (yedek devreye alma):\nTercih edilen kayıt başarısız olursa, bir sonraki en düşük maliyetli olanı deneyin Başarısız olan kayıtları geçici olarak kullanılamaz olarak işaretlemeyi düşünün İyileşme için periyodik olarak yeniden kontrol edin Uygulama Durumu:\nÖneri 123 , bazı bölümlerin \u0026ldquo;geliştirme aşamasında\u0026rdquo; kaldığını belirtir. Uygulayıcılar şunları yapmalıdır: - Hedef I2P sürümünde üretime uygunluğunu doğrulayın - Dağıtımdan önce MetaLeaseSet desteğini test edin - Daha yeni I2P sürümlerinde güncellenmiş spesifikasyonları kontrol edin\nJavaDoc: MetaLeaseSet EncryptedLeaseSet (Tip 5) Açıklama: Geliştirilmiş gizlilik için şifrelenmiş ve körleştirilmiş LeaseSet. Yalnızca körleştirilmiş açık anahtar ve üstveri görünür; gerçek lease kayıtları (I2P\u0026rsquo;de tünel kiralama kayıtları) ve şifreleme anahtarları şifrelenmiştir.\nGiriş: 0.9.38\u0026rsquo;de tanımlandı, 0.9.39\u0026rsquo;da çalışır durumda (bkz. Öneri 123 )\nYapı:\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key Veritabanı Depolaması: - Veritabanı Türü: 5 - Anahtar: körleştirilmiş Destination\u0026lsquo;ın (I2P\u0026rsquo;deki \u0026lsquo;Destination\u0026rsquo;, yani hedef tanımlayıcı) (orijinal Destination değil) SHA-256 karması - Değer: Tam EncryptedLeaseSet (şifreli LeaseSet) yapısı\nLeaseSet2 (I2P\u0026rsquo;de bir hedefin bağlantı/erişim bilgilerini içeren kayıt biçiminin 2. sürümü) ile karşılaştırıldığında kritik farklar:\nLeaseSet2Header yapısını KULLANMAZ (benzer alanlar vardır ancak düzeni farklıdır) Körleştirilmiş açık anahtar tam Destination (I2P\u0026rsquo;de hedef kimliği) yerine Şifrelenmiş yük açık metin lease\u0026rsquo;ler ve anahtarlar yerine Veritabanı anahtarı, körleştirilmiş Destination\u0026rsquo;ın karmasıdır, orijinal Destination değil İmza Hesaplaması:\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key İmza Türü Gereksinimi:\nRedDSA_SHA512_Ed25519 (tip 11) MUTLAKA kullanılmalıdır: - 32 baytlık körleştirilmiş açık anahtarlar - 64 baytlık imzalar - Körleştirme güvenlik özellikleri için gereklidir - Bkz. [Red25519 spesifikasyonu](//docs/specs/red25519-signature-scheme/\nEdDSA\u0026rsquo;dan Temel Farklar: - Özel anahtarlar modüler indirgeme ile üretilir (clamping [anahtar bitlerinin sabit bir kalıba göre ayarlanması] değil) - İmzalar 80 bayt rastgele veri içerir - Açık anahtarları doğrudan kullanır (özetler değil) - Güvenli körleme işlemini mümkün kılar\nKörleme ve Şifreleme:\nTam ayrıntılar için EncryptedLeaseSet spesifikasyonu bölümüne bakın:\n1. Anahtar Körleme:\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. Veritabanı Konumu:\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. Şifreleme Katmanları (Üç Katmanlı):\nKatman 1 - Kimlik Doğrulama Katmanı (İstemci Erişimi): - Şifreleme: ChaCha20 akış şifreleme algoritması - Anahtar türetimi: Her istemciye özel sırlarla HKDF - Kimliği doğrulanmış istemciler dış katmanın şifresini çözebilir\nKatman 2 - Şifreleme Katmanı: - Şifreleme: ChaCha20 - Anahtar: İstemci ile sunucu arasındaki DH (Diffie-Hellman anahtar değişimi) üzerinden türetilir - Asıl LeaseSet2 veya MetaLeaseSet içerir\nKatman 3 - İç LeaseSet: - Eksiksiz LeaseSet2 veya MetaLeaseSet - Tüm tunnels, şifreleme anahtarları ve seçenekleri içerir - Yalnızca başarıyla şifre çözüldükten sonra erişilebilir\nŞifreleme Anahtarı Türetimi:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) Keşif Süreci:\nYetkili istemciler için:\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication Yetkisiz istemciler için: - EncryptedLeaseSet\u0026rsquo;i bulsalar bile şifresini çözemezler - Körleştirilmiş sürümden orijinal Destination\u0026rsquo;ı belirleyemezler - Farklı körleştirme dönemleri boyunca EncryptedLeaseSet\u0026rsquo;leri ilişkilendiremezler (günlük rotasyon)\nSona Erme Zamanları:\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived **Yayınlanma Zaman Damgası:** LeaseSet2Header ile aynı gereksinimler: - Yayınlar arasında en az 1 saniye artış olmalıdır - Floodfills, mevcut sürümden daha yeni değilse reddeder - Önerilen: yayınlar arasında 10-60 saniye\nŞifreli LeaseSets ile Çevrimdışı İmzalar:\nÇevrimdışı imzalar kullanılırken özel hususlar:\nKörleştirilmiş açık anahtar günlük olarak yenilenir Çevrimdışı imza, yeni körleştirilmiş anahtarla günlük olarak yeniden oluşturulmalıdır VEYA çevrimdışı imzayı dıştaki EncryptedLeaseSet yerine içteki LeaseSet üzerinde kullanın Bkz. Proposal 123 notları Uygulama Notları:\nİstemci Yetkilendirmesi:\nBirden fazla istemci farklı anahtarlarla yetkilendirilebilir Her yetkilendirilmiş istemci benzersiz şifre çözme kimlik bilgilerine sahiptir Yetkilendirme anahtarları değiştirilerek istemcinin yetkisi geri alınabilir Günlük Anahtar Rotasyonu:\nKörleştirilmiş anahtarlar her gün UTC\u0026rsquo;de gece yarısında değişir İstemciler körleştirilmiş Destination (hedef) değerini günlük olarak yeniden hesaplamalıdır Eski EncryptedLeaseSet\u0026rsquo;ler rotasyondan sonra keşfedilemez hale gelir Gizlilik Özellikleri:\nFloodfills orijinal Destination (I2P hedef kimliği) tespit edemez Yetkisiz istemciler hizmete erişemez Farklı blinding periods (körleştirme dönemleri) ilişkilendirilemez Sona erme süreleri dışında şifresiz üstveri yoktur Performans:\nİstemciler günlük körleştirme hesaplamasını yapmalıdır Üç katmanlı şifreleme ek hesaplama yükü getirir Şifre çözülmüş iç LeaseSet\u0026rsquo;i önbelleğe almayı düşünün Güvenlik Hususları:\nYetkilendirme Anahtarı Yönetimi:\nİstemci yetkilendirme kimlik bilgilerini güvenli bir şekilde dağıtın İnce taneli geri alma için her istemciye benzersiz kimlik bilgileri kullanın Yetkilendirme anahtarlarını periyodik olarak döndürün Saat Eşzamanlaması:\nGünlük körleme, eşzamanlı UTC tarihlerine bağlıdır Saat sapması, sorgu başarısızlıklarına neden olabilir Tolerans için önceki/ertesi günün körlemesini desteklemeyi düşünün Metaveri Sızıntısı:\nPublished ve expires alanları açık metindir Örüntü analizi servisin özelliklerini ortaya çıkarabilir Endişeleniyorsanız yayımlama aralıklarını rastgeleleştirin JavaDoc: EncryptedLeaseSet Router Yapıları RouterAddress (router adresi) Açıklama: Belirli bir taşıma protokolü üzerinden bir router için bağlantı bilgilerini tanımlar.\nBiçim:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary KRİTİK - Sona Erme Alanı:\n⚠️ expiration alanı MUTLAKA tamamı sıfır (8 sıfır bayt) olarak ayarlanmalıdır.\nGerekçe: Sürüm 0.9.3\u0026rsquo;ten beri, Expiration alanının sıfırdan farklı olması imza doğrulama hatasına neden oluyor Geçmiş: Expiration alanı başlangıçta kullanılmıyordu, her zaman null idi Güncel Durum: Alan 0.9.12 itibarıyla yeniden tanındı, ancak ağ yükseltmesinin beklenmesi gerekiyor Uygulama: Her zaman 0x0000000000000000 olarak ayarlayın Herhangi bir sıfırdan farklı sona erme değeri, RouterInfo (I2P router\u0026rsquo;ına ait bilgi kaydı) imzasının doğrulamada başarısız olmasına neden olur.\nTaşıma Protokolleri Güncel Protokoller (2.10.0 itibarıyla):\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 **Taşıma Stili Değerleri:** - `SSU2`: Güncel UDP tabanlı taşıma - `NTCP2`: Güncel TCP tabanlı taşıma - `NTCP`: Eski, kaldırıldı (kullanmayın) - `SSU`: Eski, kaldırıldı (kullanmayın) Genel Seçenekler Tüm taşıma protokolleri genellikle şunları içerir:\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) SSU2\u0026rsquo;ye Özel Seçenekler Tüm ayrıntılar için bkz: SSU2 spesifikasyonu (I2P\u0026rsquo;nin UDP tabanlı taşıma protokolünün 2. sürümü).\nGerekli Seçenekler:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) İsteğe Bağlı Seçenekler:\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) SSU2 RouterAddress (yöneltici adresi) Örneği:\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 NTCP2\u0026rsquo;ye Özgü Seçenekler Tam ayrıntılar için NTCP2 spesifikasyonuna bakın.\nZorunlu Seçenekler:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) İsteğe Bağlı Seçenekler (0.9.50\u0026rsquo;den beri):\n\u0026#34;caps\u0026#34; = Capability string Örnek NTCP2 RouterAddress:\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 Uygulama Notları Maliyet Değerleri:\nUDP (SSU2) verimliliği nedeniyle genellikle daha düşük maliyetlidir (5-6) TCP (NTCP2) ek yük nedeniyle genellikle daha yüksek maliyetlidir (10-11) Daha düşük maliyet = tercih edilen taşıma Birden Fazla Adres:\nRouter\u0026rsquo;lar birden fazla RouterAddress (router adresi) girdisi yayımlayabilir Farklı taşıma protokolleri (SSU2 ve NTCP2) Farklı IP sürümleri (IPv4 ve IPv6) İstemciler maliyete ve yeteneklere göre seçer Ana makine adı (hostname) vs IP:\nPerformans açısından IP adresleri tercih edilir Ana makine adları desteklenir ancak DNS çözümleme ek yükü getirir Yayımlanan RouterInfo\u0026rsquo;lar için IP kullanmayı düşünün Base64 Kodlama:\nTüm anahtarlar ve ikili veriler Base64 olarak kodlanır Standart Base64 (RFC 4648) Dolgu veya standart dışı karakter yok JavaDoc: RouterAddress RouterInfo Açıklama: netDb\u0026rsquo;de (I2P ağ veritabanı) saklanan bir router hakkında yayımlanmış eksiksiz bilgi. Kimlik, adresler ve yetenekler içerir.\nBiçim:\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey Veritabanı Depolaması: - Veritabanı Türü: 0 - Anahtar: RouterIdentity\u0026rsquo;nin SHA-256 karması - Değer: Tam RouterInfo yapısı\nYayımlanma Zaman Damgası: - 8 baytlık Tarih (epoch\u0026rsquo;tan beri milisaniye cinsinden) - RouterInfo sürümlendirmesi için kullanılır - Routers periyodik olarak yeni RouterInfo yayımlar - Floodfills, yayımlanma zaman damgasına göre en yeni sürümü tutar\nAdres Sıralaması: - Tarihsel: Çok eski routers, adreslerin verilerinin SHA-256 karmasına göre sıralanmasını gerektirirdi - Güncel: Sıralama GEREKLİ DEĞİL, uyumluluk için uygulamaya değer değil - Adresler herhangi bir sırada olabilir\nEş Sayısı Alanı (Tarihsel): - Her zaman 0 modern I2P\u0026rsquo;de - Kısıtlı rotalar için tasarlanmıştı (uygulanmadı) - Uygulansaydı, ardından o sayıda Router Hashes (router için benzersiz özetler) gelirdi - Bazı eski uygulamalar sıralanmış bir eş listesi gerektirmiş olabilir\nSeçenek Eşlemesi:\nSeçenekler anahtara göre sıralanmak zorundadır. Standart seçenekler şunları içerir:\nYetenek Seçenekleri:\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable Ağ Seçenekleri:\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; İstatistiksel Seçenekler:\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string Standart seçeneklerin tam listesi için Ağ Veritabanı RouterInfo (yöneltici bilgisi) dokümantasyonu bölümüne bakın.\nİmza Hesaplama:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length Tipik Modern RouterInfo:\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical Uygulama Notları:\nBirden Fazla Adres:\nRouter\u0026rsquo;lar genellikle 1-4 adres yayınlar IPv4 ve IPv6 varyantları SSU2 ve/veya NTCP2 taşıma protokolleri Her adres bağımsızdır Sürümleme:\nDaha yeni RouterInfo (router bilgi kaydı), daha geç published zaman damgasına sahiptir Routers, her ~2 saatte bir veya adresler değiştiğinde yeniden yayınlar Floodfills yalnızca en yeni sürümü depolar ve yayar Doğrulama:\nRouterInfo\u0026rsquo;yu kabul etmeden önce imzayı doğrulayın Her RouterAddress\u0026rsquo;te expiration alanının tamamen sıfırlardan oluştuğunu kontrol edin Seçenekler eşlemesinin anahtara göre sıralı olduğunu doğrulayın Sertifika ve anahtar türlerinin bilinen/desteklenen türler olduğunu kontrol edin Ağ Veritabanı:\nFloodfills, Hash(RouterIdentity) ile indekslenen RouterInfo\u0026rsquo;yu saklar Son yayından sonra ~2 gün boyunca saklanır Routers, diğer router\u0026rsquo;ları keşfetmek için floodfills\u0026rsquo;i sorgular JavaDoc: RouterInfo Uygulama Notları Bayt Sırası (Endianness - baytların bellekte veya iletimde diziliş sırası) Varsayılan: Big-Endian (Ağ bayt sırası)\nI2P yapılarının çoğu big-endian (büyük uçlu) bayt sırasını kullanır: - Tüm tamsayı türleri (1-8 bayt) - Tarih tipindeki zaman damgaları - TunnelId - Dize uzunluğu ön eki - Sertifika türleri ve uzunlukları - Anahtar türü kodları - Eşleme boyutu alanları\nİstisna: Little-Endian (küçük uçlu bayt sıralaması)\nAşağıdaki anahtar türleri little-endian (en az anlamlı bayt önce) kodlamasını kullanır: - X25519 şifreleme anahtarları (tip 4) - EdDSA_SHA512_Ed25519 imzalama anahtarları (tip 7) - EdDSA_SHA512_Ed25519ph imzalama anahtarları (tip 8) - RedDSA_SHA512_Ed25519 imzalama anahtarları (tip 11)\nUygulama:\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); Yapı Sürümleme Asla Sabit Boyutlar Varsaymayın:\nBirçok yapı değişken uzunluğa sahiptir: - RouterIdentity: 387+ bayt (her zaman 387 değil) - Destination: 387+ bayt (her zaman 387 değil) - LeaseSet2: Önemli ölçüde değişir - Certificate: 3+ bayt\nHer Zaman Boyut Alanlarını Okuyun: - Sertifika uzunluğu 1-2. baytlarda - Mapping (eşleme) boyutu başlangıçta - KeysAndCert her zaman 384 + 3 + certificate_length olarak hesaplanır\nFazladan Veriyi Denetleyin: - Geçerli yapıların ardından gelen sondaki gereksiz veriyi engelleyin - Sertifika uzunluklarının anahtar türleriyle eşleştiğini doğrulayın - Sabit boyutlu türler için beklenen uzunlukların birebir olmasını zorunlu kılın\nGüncel Öneriler (Ekim 2025) Yeni Router Kimlikleri İçin:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/tr/proposals/161-ri-dest-padding/) Yeni Destination (I2P\u0026rsquo;de adres/kimlik) nesneleri için:\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/tr/proposals/161-ri-dest-padding/) Yeni LeaseSets için:\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per [Proposal 167](/proposals/167-service-records/) Signature: EdDSA (64 bytes) Şifrelenmiş Hizmetler için:\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys Kullanımdan Kaldırılmış Özellikler - Kullanmayın Kullanımdan Kaldırılmış Şifreleme: - Router Kimlikleri için ElGamal (type 0) (0.9.58\u0026rsquo;de kullanımdan kaldırıldı) - ElGamal/AES+SessionTag (oturum etiketi) şifrelemesi (ECIES-X25519 kullanın)\nKullanımdan Kaldırılan İmzalama: - DSA_SHA1 (tip 0) Router Kimlikleri için (0.9.58\u0026rsquo;de kullanımdan kaldırıldı) - ECDSA varyantları (tip 1-3) yeni gerçeklemeler için - RSA varyantları (tip 4-6) SU3 dosyaları hariç\nKullanımdan Kaldırılmış Ağ Biçimleri: - LeaseSet tip 1 (LeaseSet2 kullanın) - Lease (44 bayt, Lease2 kullanın) - Orijinal Lease sona erme biçimi\nKullanımdan Kaldırılmış Taşıma Protokolleri: - NTCP (0.9.50\u0026rsquo;de kaldırıldı) - SSU (2.4.0\u0026rsquo;da kaldırıldı)\nKullanımdan Kaldırılmış Sertifikalar: - HASHCASH (tip 1) - HIDDEN (tip 2) - SIGNED (tip 3) - MULTIPLE (tip 4)\nGüvenlik Hususları Anahtar Üretimi: - Daima kriptografik olarak güvenli rastgele sayı üreteçleri kullanın - Anahtarları farklı bağlamlar arasında asla yeniden kullanmayın - Özel anahtarları uygun erişim denetimleriyle koruyun - İşiniz bittiğinde anahtar materyalini bellekten güvenli bir şekilde silin\nİmza Doğrulama: - Verilere güvenmeden önce her zaman imzaları doğrulayın - İmza uzunluğunun anahtar türüyle eşleştiğini kontrol edin - İmzalanmış verilerin beklenen alanları içerdiğini doğrulayın - Sıralı eşlemeler için, imzalamadan/doğrulamadan önce sıralama düzenini doğrulayın\nZaman Damgası Doğrulama: - Yayınlanan zamanların makul olduğunu kontrol edin (çok uzak bir gelecekte olmamalı) - Lease (kiralama girdisi) sona erme zamanlarının geçmiş olmadığını doğrulayın - Saat kayması toleransını göz önünde bulundurun (tipik olarak ±30 saniye)\nAğ Veritabanı: - Depolamadan önce tüm yapıları doğrulayın - DoS saldırılarını önlemek için boyut sınırlarını uygulayın - Sorgular ve yayımlar için oran sınırlaması uygulayın - Veritabanı anahtarlarının yapı özetleriyle (hash) eşleştiğini doğrulayın\nUyumluluk Notları Geriye Dönük Uyumluluk: - ElGamal ve DSA_SHA1 hâlâ eski router\u0026rsquo;lar için destekleniyor - Kullanımdan kaldırılmış anahtar türleri işlevsel kalır ancak kullanımı önerilmez - Sıkıştırılabilir padding (doldurma) (Proposal 161 ) 0.6\u0026rsquo;ya kadar geriye dönük uyumludur\nİleriye Dönük Uyumluluk: - Bilinmeyen anahtar türleri, uzunluk alanları kullanılarak ayrıştırılabilir - Bilinmeyen sertifika türleri, uzunluk kullanılarak atlanabilir - Bilinmeyen imza türleri, sorunsuz şekilde ele alınmalıdır - Uygulayıcılar, bilinmeyen isteğe bağlı özellikler karşısında başarısız olmamalıdır\nGeçiş Stratejileri: - Geçiş sırasında hem eski hem de yeni anahtar türlerini destekleyin - LeaseSet2 birden fazla şifreleme anahtarını listeleyebilir - Çevrimdışı imzalar güvenli anahtar döndürmeyi mümkün kılar - MetaLeaseSet şeffaf hizmet geçişini sağlar\nTest ve Doğrulama Yapı Doğrulaması: - Tüm uzunluk alanlarının beklenen aralıklar içinde olduğunu doğrulayın - Değişken uzunluklu yapıların doğru şekilde ayrıştırıldığını kontrol edin - İmzaların başarıyla doğrulandığını doğrulayın - Hem en küçük hem de en büyük boyutlu yapılarla test edin\nUç Durumlar: - Sıfır uzunluklu dizeler - Boş eşlemeler - Asgari ve azami lease (kiralama kaydı) sayıları - Sıfır uzunluklu yük içeren sertifika - Çok büyük yapılar (azami boyutlara yakın)\nBirlikte çalışabilirlik: - Resmi Java I2P gerçekleştirmesine karşı test edin - i2pd ile uyumluluğu doğrulayın - Çeşitli netDb (ağ veritabanı) içerikleriyle test edin - Doğruluğu bilinen test vektörlerine göre doğrulayın\nKaynakça Spesifikasyonlar I2NP Protokolü I2CP Protokolü SSU2 Taşıma NTCP2 Taşıma Tunnel Protokolü Datagram Protokolü Kriptografi Kriptografiye Genel Bakış ElGamal/AES Şifreleme ECIES-X25519 Şifreleme Routers için ECIES ECIES Hibrit (Post-Kuantum) Red25519 İmzaları Şifrelenmiş LeaseSet (hedefin tünel giriş noktaları ve sürelerini içeren kayıt) Öneriler Öneri 123: Yeni netDB Kayıtları Öneri 134: GOST İmza Türleri Öneri 136: Deneysel İmza Türleri Öneri 145: ECIES-P256 Öneri 156: ECIES Routers Öneri 161: Dolgu Üretimi Öneri 167: Hizmet Kayıtları Öneri 169: Kuantum Sonrası Kriptografi Tüm Öneriler Dizini Ağ Veritabanı Ağ Veritabanına Genel Bakış RouterInfo Standart Seçenekleri JavaDoc API Referansı Çekirdek Veri Paketi PublicKey PrivateKey SessionKey SigningPublicKey SigningPrivateKey Signature Hash SessionTag TunnelId Certificate DataHelper KeysAndCert RouterIdentity Destination Lease LeaseSet Lease2 LeaseSet2 MetaLease MetaLeaseSet EncryptedLeaseSet RouterAddress RouterInfo Harici Standartlar RFC 7748 (X25519): Güvenlik için Eliptik Eğriler RFC 7539 (ChaCha20): IETF Protokolleri için ChaCha20 ve Poly1305 RFC 4648 (Base64): Base16, Base32 ve Base64 Veri Kodlamaları FIPS 180-4 (SHA-256): Güvenli Özet Standardı FIPS 204 (ML-DSA): Modül-Kafes Tabanlı Dijital İmza Standardı IANA Hizmet Kaydı Topluluk Kaynakları I2P Web Sitesi I2P Forumu I2P GitLab I2P GitHub Aynası Teknik Dokümantasyon Dizini Sürüm Bilgileri I2P 2.10.0 Sürümü Sürüm Geçmişi Değişiklik Günlüğü Ek: Hızlı Başvuru Tabloları Anahtar Türü Hızlı Başvuru Güncel Standart (tüm yeni uygulamalar için önerilir): - Şifreleme: X25519 (tip 4, 32 bayt, little-endian (küçük endian)) - İmzalama: EdDSA_SHA512_Ed25519 (tip 7, 32 bayt, little-endian)\nEski (Destekleniyor ancak artık önerilmiyor): - Şifreleme: ElGamal (tip 0, 256 bayt, big-endian (en yüksek anlamlı bayt önce)) - İmzalama: DSA_SHA1 (tip 0, 20 baytlık özel / 128 baytlık açık, big-endian)\nÖzelleştirilmiş: - İmzalama (Şifrelenmiş LeaseSet): RedDSA_SHA512_Ed25519 (tip 11, 32 bayt, little-endian (küçük uçlu bayt sıralaması))\nPost-Kuantum (Beta, henüz kesinleşmedi): - Hibrit Şifreleme: MLKEM_X25519 varyantları (tipler 5-7) - Saf PQ Şifreleme: MLKEM varyantları (henüz atanmış tip kodları yok)\nYapı Boyutları Hızlı Başvuru Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes ### Veritabanı Türleri için Hızlı Başvuru Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status ### Taşıma Protokolü Hızlı Başvuru Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 ### Sürüm Kilometre Taşları Hızlı Başvuru Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023[Proposal 161](/tr/proposals/161-ri-dest-padding/) padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025[Proposal 167](/proposals/167-service-records/) service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) --- ","description":"I2P spesifikasyonları genelinde kullanılan ortak veri türleri ve serileştirme biçimleri","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"Ortak Yapılar","url":"/tr/docs/specs/common-structures/"},{"categories":null,"content":"I2P\u0026rsquo;nin eklenti çerçevesi, çekirdek kuruluma dokunmadan router\u0026rsquo;ı genişletmenize olanak tanır. Mevcut eklentiler posta, bloglar, IRC, depolama, wiki\u0026rsquo;ler, izleme araçları ve daha fazlasını kapsar.\nGüvenlik notu: Eklentiler, yönlendirici ile aynı izinlerle çalışır. Üçüncü taraf indirmelerine, imzalı herhangi bir yazılım güncellemesine davrandığınız gibi davranın—kurmadan önce kaynağı doğrulayın.\n1. Bir Eklenti Yükleyin Eklentinin indirme URL\u0026rsquo;sini proje sayfasından kopyalayın.\nRouter konsolunun Eklenti Yapılandırma sayfasını açın.\nURL\u0026rsquo;yi kurulum alanına yapıştırın ve Eklentiyi Kur\u0026lsquo;a tıklayın.\nRouter imzalı arşivi indirir, imzayı doğrular ve eklentiyi anında etkinleştirir. Çoğu eklenti, router\u0026rsquo;ın yeniden başlatılmasını gerektirmeden konsol bağlantıları veya arka plan hizmetleri ekler.\n2. Eklentiler Neden Önemlidir Son kullanıcılar için tek tıkla dağıtım—wrapper.config veya clients.config dosyalarında manuel düzenleme gerekmez Temel i2pupdate.su3 paketini küçük tutarken büyük veya niş özellikleri isteğe bağlı olarak sunar İsteğe bağlı eklenti başına JVM\u0026rsquo;ler gerektiğinde süreç izolasyonu sağlar Router sürümü, Java çalışma zamanı ve Jetty ile otomatik uyumluluk kontrolleri Güncelleme mekanizması router\u0026rsquo;ı yansıtır: imzalı paketler ve artımlı indirmeler Konsol entegrasyonları, dil paketleri, kullanıcı arayüzü temaları ve Java olmayan uygulamalar (betikler aracılığıyla) desteklenir plugins.i2p gibi düzenlenmiş \u0026ldquo;uygulama mağazası\u0026rdquo; dizinlerini etkinleştirir 3. Yüklü Eklentileri Yönetme I2P Router Eklentisi üzerindeki kontrolleri kullanarak:\nTek bir eklentiyi güncellemeler için kontrol et Tüm eklentileri aynı anda kontrol et (router yükseltmelerinden sonra otomatik olarak tetiklenir) Mevcut güncellemeleri tek tıkla yükle\nServis kaydeden eklentiler için otomatik başlatmayı etkinleştir/devre dışı bırak Eklentileri temiz bir şekilde kaldır 4. Kendi Eklentinizi Oluşturun Paketleme, imzalama ve metadata gereksinimleri için eklenti spesifikasyonunu inceleyin. Mevcut bir binary veya webapp\u0026rsquo;i kurulabilir bir arşiv haline getirmek için makeplugin.sh kullanın. Router\u0026rsquo;ın ilk kurulumları artımlı yükseltmelerden ayırt edebilmesi için hem kurulum hem de güncelleme URL\u0026rsquo;lerini yayınlayın. Kullanıcıların özgünlüğü doğrulamasına yardımcı olmak için proje sayfanızda checksumları ve imzalama anahtarlarını belirgin şekilde sağlayın. Örnek mi arıyorsunuz? plugins.i2p adresindeki topluluk eklentilerinin kaynak koduna göz atın (örneğin, snowman örneği).\n5. Bilinen Sınırlamalar Düz JAR dosyaları içeren bir eklentiyi güncellemek, Java sınıf yükleyicisinin sınıfları önbelleğe aldığı için yönlendirici yeniden başlatması gerektirebilir. Konsol, eklentinin aktif bir süreci olmasa bile Durdur düğmesini görüntüleyebilir. Ayrı bir JVM\u0026rsquo;de başlatılan eklentiler, geçerli çalışma dizininde bir logs/ dizini oluşturur. Bir imzalayan anahtarı ilk kez göründüğünde otomatik olarak güvenilir; merkezi bir imzalama otoritesi yoktur. Windows bazen bir eklenti kaldırıldıktan sonra boş dizinleri geride bırakır. Java 5 JVM üzerinde yalnızca Java 6 için olan bir eklentiyi yüklemek, Pack200 sıkıştırması nedeniyle \u0026ldquo;eklenti bozuk\u0026rdquo; bildirimi verir. Tema ve çeviri eklentileri büyük ölçüde test edilmemiş durumda kalır. Otomatik başlatma bayrakları, yönetilmeyen eklentiler için her zaman kalıcı olmaz. 6. Gereksinimler ve En İyi Uygulamalar Eklenti desteği I2P 0.7.12 ve daha yeni sürümlerde mevcuttur. Güvenlik düzeltmelerini almak için router\u0026rsquo;ınızı ve eklentilerinizi güncel tutun. Kullanıcıların sürümler arasındaki değişiklikleri anlaması için özet sürüm notları ekleyin. Mümkün olduğunda, açık-ağ metadata maruziyetini en aza indirmek için eklenti arşivlerini I2P içinde HTTPS üzerinden barındırın. 7. İleri Okuma Eklenti belirtimi İstemci uygulama çerçevesi Paketleme araçları için I2P betikleri deposu ","description":"Router eklentilerini yükleme, güncelleme ve geliştirme","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"Özel Eklentilerin Kurulumu","url":"/tr/docs/guides/plugins/"},{"categories":null,"content":"I2P Ağ Performansı: Hız, Bağlantılar ve Kaynak Yönetimi I2P ağı tamamen dinamiktir. Her istemci diğer düğümler tarafından bilinir ve yerel olarak bilinen düğümleri erişilebilirlik ve kapasite açısından test eder. Yalnızca erişilebilir ve yeterli kapasiteye sahip düğümler yerel NetDB\u0026rsquo;ye kaydedilir. Tünel oluşturma süreci sırasında, tünelleri oluşturmak için bu havuzdan en iyi kaynaklar seçilir. Test işlemi sürekli gerçekleştiğinden, düğüm havuzu değişir. Her I2P düğümü NetDB\u0026rsquo;nin farklı bir bölümünü bilir, bu da her router\u0026rsquo;ın tüneller için kullanılacak farklı bir I2P düğüm kümesine sahip olduğu anlamına gelir. İki router aynı bilinen düğüm alt kümesine sahip olsa bile, erişilebilirlik ve kapasite testleri muhtemelen farklı sonuçlar gösterecektir, çünkü diğer router\u0026rsquo;lar bir router test ederken yük altında olabilir ancak ikinci router test ettiğinde boşta olabilir.\nBu, her I2P düğümünün tüneller oluşturmak için farklı düğümlere sahip olmasının nedenini açıklar. Her I2P düğümü farklı gecikme ve bant genişliğine sahip olduğundan, tüneller (bu düğümler aracılığıyla oluşturulur) farklı gecikme ve bant genişliği değerlerine sahiptir. Ve her I2P düğümü farklı tüneller oluşturduğundan, hiçbir iki I2P düğümü aynı tünel kümelerine sahip değildir.\nBir sunucu/istemci \u0026ldquo;destination\u0026rdquo; (varış noktası) olarak bilinir ve her destination en az bir gelen ve bir giden tunnel\u0026rsquo;a sahiptir. Varsayılan değer tunnel başına 3 hopdur. Bu, tam bir gidiş-dönüş istemci → sunucu → istemci için toplam 12 hop (12 farklı I2P düğümü) anlamına gelir.\nHer veri paketi sunucuya ulaşana kadar 6 farklı I2P düğümünden geçer:\nclient - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - server\nve dönüş yolunda 6 farklı I2P düğümü:\nserver - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - client\nAğdaki trafik, yeni veri gönderilmeden önce bir ACK gerektirir; bir sunucudan ACK dönene kadar beklemek zorundadır: veri gönder, ACK bekle, daha fazla veri gönder, ACK bekle. RTT (Round Trip Time - Gidiş Dönüş Süresi) her bir I2P düğümünün gecikmesinden ve bu gidiş dönüş yolundaki her bir bağlantıdan biriktiği için, bir ACK\u0026rsquo;nin istemciye geri dönmesi genellikle 1–3 saniye sürer. TCP ve I2P aktarım tasarımı nedeniyle, bir veri paketinin sınırlı bir boyutu vardır. Bu koşullar birlikte, tünel başına kabaca 20–50 kB/s maksimum bant genişliği limiti belirler. Ancak, tüneldeki sadece bir atlama 5 kB/s bant genişliğine sahipse, tünelin tamamı gecikme ve diğer sınırlamalardan bağımsız olarak 5 kB/s ile sınırlıdır.\nŞifreleme, gecikme süresi ve bir tünelin nasıl inşa edildiği, bir tünel oluşturmayı CPU zamanı açısından oldukça maliyetli hale getirir. Bu nedenle bir destination\u0026rsquo;ın veri taşımak için maksimum 6 gelen (inbound) ve 6 giden (outbound) tünele sahip olmasına izin verilir. Tünel başına maksimum 50 kB/s ile bir destination toplam yaklaşık 300 kB/s trafik kullanabilir (gerçekte düşük veya hiç anonimlik olmadan daha kısa tüneller kullanılırsa daha fazla olabilir). Kullanılan tüneller her 10 dakikada bir atılır ve yenileri oluşturulur. Bu tünel değişimi ve bazen kapanan veya ağ bağlantısını kaybeden istemciler, zaman zaman tünelleri ve bağlantıları bozar. Bunun bir örneği IRC2P Network\u0026rsquo;te bağlantı kaybında (ping timeout) veya eepget kullanırken görülebilir.\nSınırlı sayıda hedef ve hedef başına sınırlı sayıda tünel ile, bir I2P düğümü diğer I2P düğümleri üzerinden yalnızca sınırlı sayıda tünel kullanır. Örneğin, yukarıdaki küçük örnekte bir I2P düğümü \u0026ldquo;hop1\u0026rdquo; ise, istemciden kaynaklanan yalnızca bir katılımcı tünel görür. Tüm I2P ağını toplarsak, toplamda sınırlı miktarda bant genişliği ile yalnızca oldukça sınırlı sayıda katılımcı tünel oluşturulabilir. Bu sınırlı sayıları I2P düğümlerinin sayısına dağıtırsak, kullanılabilir bant genişliği/kapasitenin yalnızca bir kısmı kullanılabilir durumda olur.\nAnonim kalmak için, tek bir router tüm ağ tarafından tünel oluşturmak için kullanılmamalıdır. Eğer bir router tüm I2P düğümleri için tünel router\u0026rsquo;ı olarak görev yaparsa, hem çok gerçek bir merkezi arıza noktası hem de istemcilerden IP\u0026rsquo;leri ve verileri toplayan merkezi bir nokta haline gelir. Bu nedenle ağ, tünel oluşturma sürecinde trafiği düğümler arasında dağıtır.\nPerformans için bir başka husus, I2P\u0026rsquo;nin mesh ağ yapısını ele alış biçimidir. Her bağlantı atlama‑atlama (hop‑to‑hop) I2P düğümlerinde bir TCP veya UDP bağlantısı kullanır. 1000 bağlantıda, 1000 TCP bağlantısı görülür. Bu oldukça fazladır ve bazı ev ve küçük ofis yönlendiricileri yalnızca az sayıda bağlantıya izin verir. I2P bu bağlantıları UDP ve TCP türü başına 1500\u0026rsquo;ün altında tutmaya çalışır. Bu, bir I2P düğümü üzerinden yönlendirilen trafik miktarını da sınırlar.\nBir düğüm erişilebilir durumdaysa ve \u0026gt;128 kB/s paylaşımlı bant genişliği ayarına sahipse ve 7/24 erişilebilir durumdaysa, bir süre sonra katılımcı trafik için kullanılmalıdır. Arada çevrimdışı olursa, diğer düğümler tarafından yapılan I2P düğüm testleri onlara erişilebilir olmadığını söyleyecektir. Bu, bir düğümü diğer düğümlerde en az 24 saat boyunca engeller. Dolayısıyla, o düğümü çevrimdışı olarak test eden diğer düğümler, tunnel oluşturmak için o düğümü 24 saat boyunca kullanmayacaktır. Bu nedenle, I2P router\u0026rsquo;ınızı yeniden başlattıktan/kapattıktan sonra trafiğiniz minimum 24 saat boyunca daha düşük olur.\nEk olarak, diğer I2P düğümlerinin bir I2P router\u0026rsquo;ı erişilebilirlik ve kapasite açısından test edebilmesi için onu bilmeleri gerekir. Bu süreç, ağ ile etkileşime girdiğinizde, örneğin uygulamalar kullanarak veya I2P sitelerini ziyaret ederek hızlandırılabilir; bu da daha fazla tunnel oluşturulmasına ve dolayısıyla ağdaki düğümler tarafından test için daha fazla aktivite ve erişilebilirliğe yol açar.\nPerformans Geçmişi (seçili) Yıllar içinde I2P, birçok önemli performans iyileştirmesi görmüştür:\nNative math GNU MP kütüphanesi (GMP) ile JNI bağlantıları üzerinden, daha önce CPU zamanına hâkim olan BigInteger modPow işlemini hızlandırmak için uygulandı. İlk sonuçlar, açık anahtarlı kriptografide çarpıcı hız artışları gösterdi. Bakınız: /misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) Daha önce, yanıtlar genellikle gönderenin LeaseSet\u0026rsquo;i için bir ağ veritabanı sorgusu gerektiriyordu. Gönderenin LeaseSet\u0026rsquo;ini ilk garlic içinde paketlemek yanıt gecikmesini iyileştirir. Bu artık (bir bağlantının başlangıcında veya LeaseSet değiştiğinde) ek yükü azaltmak için seçici olarak yapılmaktadır.\nYerel matematik Bazı doğrulama adımları transport el sıkışmasında daha erken bir aşamaya taşındı; böylece hatalı eşler (yanlış saatler, hatalı NAT/firewall, uyumsuz sürümler) daha erken reddedilerek CPU ve bant genişliği tasarrufu sağlanıyor.\nBir \u0026ldquo;yanıt\u0026rdquo; LeaseSet\u0026rsquo;ini Garlic sarmalama (ayarlanmış) Bağlam farkında tünel testi kullanın: zaten veri geçirdiği bilinen tünelleri test etmekten kaçının; boşta iken test etmeyi tercih edin. Bu, ek yükü azaltır ve başarısız tünellerin tespitini hızlandırır.\nDaha verimli TCP reddetme Belirli bir bağlantı için seçimlerin kalıcı hale getirilmesi, sıra dışı teslimi azaltır ve streaming kütüphanesinin pencere boyutlarını artırmasına izin vererek verimliliği artırır.\nTünel test ayarlamaları GZip veya benzer araçlar ayrıntılı yapılar için (örn. RouterInfo seçenekleri) uygun olduğu durumlarda bant genişliğini azaltır.\nKalıcı tünel/lease seçimi Basit \u0026ldquo;ministreaming\u0026rdquo; protokolünün yerine geçen çözüm. Modern streaming, I2P\u0026rsquo;nin anonim, mesaj odaklı altyapısına özel olarak tasarlanmış seçici ACK\u0026rsquo;ler ve tıkanıklık kontrolü içerir. Bakınız: /docs/api/streaming/\nFuture Performance Improvements (historical ideas) Aşağıda, potansiyel iyileştirmeler olarak tarihsel olarak belgelenmiş fikirler yer almaktadır. Birçoğu artık modası geçmiş, uygulanmış veya mimari değişiklikler tarafından geride bırakılmıştır.\nSeçili veri yapılarını sıkıştır Yönlendiricilerin tünel oluşturma için eş seçimini iyileştirerek yavaş veya aşırı yüklü olanlardan kaçınmalarını sağlarken, güçlü saldırganlara karşı Sybil saldırılarına dirençli kalmak.\nTam streaming protokolü Anahtar uzayı kararlı olduğunda gereksiz keşfi azaltın; aramalarda kaç peer\u0026rsquo;ın döndürüleceğini ve kaç eşzamanlı aramanın gerçekleştirileceğini ayarlayın.\nSession Tag tuning and improvements (legacy) Eski ElGamal/AES+SessionTag şeması için, daha akıllı son kullanma ve yenileme stratejileri ElGamal geri dönüşlerini ve boşa harcanan etiketleri azaltır.\nDaha iyi eş profilleme ve seçimi Yeni bir oturum kurulumu sırasında tohumlanan senkronize bir PRNG\u0026rsquo;den etiketler üretin, önceden teslim edilen etiketlerden kaynaklanan mesaj başına ek yükü azaltarak.\nAğ veritabanı ayarlama Daha uzun tunnel ömürleri, iyileştirme ile birleştiğinde yeniden oluşturma maliyetlerini azaltabilir; anonimlik ve güvenilirlik ile dengeleyin.\nSession Tag ayarlama ve iyileştirmeleri (eski) Geçersiz eşleri daha erken reddet ve çekişmeyi ve gecikmeyi azaltmak için tünel testlerini daha bağlama duyarlı hale getir.\nSessionTag\u0026rsquo;i senkronize PRNG\u0026rsquo;ye taşıma (eski) Seçici LeaseSet paketleme, sıkıştırılmış RouterInfo seçenekleri ve tam streaming protokolünün benimsenmesi, algılanan performansın iyileşmesine katkıda bulunur.\nIMPORTANT: Sadece çeviriyi sağlayın. Soru sormayın, açıklama yapmayın veya herhangi bir yorum eklemeyin. Metin sadece bir başlık veya eksik görünse bile, olduğu gibi çevirin.\nAyrıca bakınız:\nTunnel Yönlendirme Eş Seçimi Taşıma Katmanları SSU2 Spesifikasyonu ve NTCP2 Spesifikasyonu ","description":"I2P ağ performansı: bugün nasıl davranıyor, geçmişteki iyileştirmeler ve gelecekteki ayarlamalar için fikirler","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"Performans","url":"/tr/docs/overview/performance/"},{"categories":null,"content":" Durum: I2P 2.10.0 (Ekim 2025) ile güncellenmiştir. Bu liste, I2P Java Router, i2pd ve ilgili eklentiler tarafından kullanılan tüm aktif, kullanımdan kaldırılmış ve ayrılmış portları bir araya getirir. Tutarlılık için tüm portlar sayısal sıraya göre listelenmiştir.\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. ## Uygulama Notları Güvenlik için 9000\u0026rsquo;in altındaki tüm portlar (8887 hariç) varsayılan olarak 127.0.0.1\u0026rsquo;e bağlanır. Router ağ portu (9151–30777) tam katılım için internete açık olmalıdır. i2pd uyumluluk için çoğunlukla aynı atamaları kullanır (7070 konsol, 7654 I2CP, 7656/7655 SAM). Eklenti geliştiricileri çakışmaları önlemek için I2P topluluğu aracılığıyla yeni atamaları koordine etmelidir. ","description":"I2P port atamaları, eklenti portları ve ayrılmış aralıkların kapsamlı referansı.","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"Port Atamaları","url":"/tr/docs/overview/ports/"},{"categories":null,"content":"Genel Bakış Bu belge, körlenebilen Destinations (I2P hedefi) oluşturmak için uygun, yeniden rastgeleleştirilebilir bir imza şemasını belirtir. Ayrıca, etkinlikte küçük bir azalma ile, mevcut Ed25519 Destinations üzerinde körleme uygulamak için de kullanılabilir.\nRed25519, 0.9.39 sürümünden (21 Mart 2019\u0026rsquo;da yayımlandı) beri I2P router\u0026rsquo;larda tam işlevsel durumdadır. Bu spesifikasyon, 17 aylık üretimde kullanımın ardından 0.9.47 sürümünde (Ağustos 2020) nihai hale getirildi. İmza şeması, I2P ağında imza türü 11 (RedDSA_SHA512_Ed25519) olarak çalışır.\nGerekçe Öneri 123 (New netDB Entries), En Az Yetki İlkesi\u0026rsquo;ni somutlaştıran şifreli bir LeaseSet2 biçimini tanımlar: ağdaki her katılımcıya yalnızca kendi rolü için gerekli bilgi verilir. Özellikle, bir floodfill\u0026rsquo;e yayımlanan şifreli LeaseSet2, ait olduğu Destination\u0026rsquo;ı (I2P\u0026rsquo;de hedef kimliği) ifşa etmez ve Leases yalnızca Destination hakkında önceden bilgi sahibi olan biri tarafından görüntülenebilir. Ancak, floodfill\u0026rsquo;ler yine de yayımlandıklarında şifreli LeaseSet2\u0026rsquo;leri kimlik doğrulayabilmelidir ve istemciler ayrıca bu kimlik doğrulamasının bizzat Destination tarafından uygulandığından emin olmalıdır.\nÖneri 123 bunu, Hedeflerin imzalama anahtarlarını körleştirerek sağlar. Körleştirilmiş anahtarlar, floodfill\u0026rsquo;ler tarafından doğrulanabilir imzalar oluşturmak için kullanılabilir ve istemciler yalnızca Hedefin bu imzaları oluşturmuş olabileceğinden emin olabilir. Bu nedenle, körleme için kullanılabilecek bir imza şemasının tanımlanması gerekir.\nÖneri 123\u0026rsquo;ün Durumuna Dair Not: Öneri 123\u0026rsquo;ün bazı bölümleri 0.9.38 sürümünden beri aşamalı olarak uygulanıp devreye alınmış, 0.9.39\u0026rsquo;da ise Red25519 (kriptografik bir imza türü) desteği eklenmiştir. Şifreli LeaseSet2 (I2P\u0026rsquo;de bir hedefin erişim bilgilerini içeren veri yapısının 2. sürümü) işlevselliği üretim ortamı için hazırdır ve gizliliği artırılmış gizli servisler için I2P ağında aktif olarak kullanılmaktadır.\nTasarım Temel imza şeması Burada belirtilen imza şeması Red25519, Zcash Protokol Spesifikasyonu\u0026rsquo;nun (Sapling ve sonrası) 5.4.6. Bölümü\u0026rsquo;nde tanımlandığı şekliyle RedDSA\u0026rsquo;nın bir uygulamasıdır. RedDSA, key re-randomization (anahtarın yeniden rastgeleleştirilmesi) destekleyen Schnorr tabanlı bir imza şemasıdır. Aşağıdaki işlevlere sahiptir:\nGENERATE_PRIVATE() : Tekdüze dağılımlı rastgele bir özel anahtar döndürür.\nDERIVE_PUBLIC(sk) : Verilen özel anahtara karşılık gelen açık anahtarı döndürür.\nGENERATE_RANDOM() : Bir anahtar çiftini yeniden rastgeleleştirmeye uygun rastgele bir skaler döndürür.\nRANDOMIZE_PRIVATE(sk, alpha) : Gizli bir skaler alpha kullanarak özel anahtarı yeniden rastgeleleştirir.\nRANDOMIZE_PUBLIC(vk, alpha) : Gizli bir skaler alpha kullanarak bir açık anahtarı yeniden rastgeleleştirir.\nSIGN(sk, m) : Verilen m mesajı üzerinde sk özel anahtarıyla oluşturulan bir imza döndürür.\nVERIFY(vk, m, sig) : sig adlı imzayı, genel anahtar vk ve mesaj m kullanılarak doğrular. İmza geçerliyse true döndürür, aksi halde false döndürür.\nBelirli bir anahtar çifti (sk, vk) için aşağıdaki ilişki geçerlidir:\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) Ed25519 anahtarlarını Red25519\u0026rsquo;a dönüştürme Ed25519 (bir dijital imza şeması) anahtarları, mevcut Ed25519 Hedeflerinin yeniden rastgeleleştirilmesini desteklemek amacıyla, geçici kullanım için tek yönlü olarak Red25519 (yeniden rastgeleleştirilebilir Ed25519 türevi) anahtarlarına dönüştürülebilir. Diğer imza türleri uyumlu değildir.\nAşağıdaki dönüşüm işlevlerini tanımlıyoruz:\nCONVERT_ED25519_PRIVATE(privkey) : Verilen Ed25519 özel anahtarına karşılık gelen Red25519 özel anahtarını döndürür.\nCONVERT_ED25519_PUBLIC(pubkey) : Verilen Ed25519 açık anahtarına karşılık gelen Red25519 açık anahtarını döndürür.\nVerilen bir Ed25519 (eliptik eğri imza şeması) anahtar çifti (privkey, pubkey) için aşağıdaki ilişki geçerlidir:\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) Teknik Şartname Tanımlar B : RFC 8032 \u0026lsquo;de tanımlandığı gibi Ed25519 basepoint (eğri üzerindeki sabit üreteç noktası).\nL : RFC 8032 \u0026lsquo;de belirtildiği gibi Ed25519 grubunun mertebesi 2^252 + 27742317777372353535851937790883648493.\n[s] B : Taban noktasının s ile sabit tabanlı skaler çarpımı.\n[s] A : A\u0026rsquo;nın s ile değişken tabanlı skaler çarpımı.\nx || y : x ve y bayt dizilerini birleştir.\nRed25519 (bir kriptografik imza algoritması) Red25519 şeması, RedDSA\u0026rsquo;yı şu şekilde özelleştirir:\nG := Curve25519\u0026rsquo;un Edwards formu üzerindeki nokta grubu. Özellikle bu, Red25519\u0026rsquo;un mertebesi L olan asal mertebeli alt grubu kullandığı ve kofaktör h_G\u0026rsquo;nin 8 olduğu anlamına gelir. P_G := Ed25519 taban noktası B. l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) Hash Fonksiyonu Seçimine İlişkin Not: Red25519, BLAKE2b-512 (Zcash RedDSA\u0026rsquo;da kullanılır) yerine SHA-512 kullanır. Bu tasarım tercihi, aşağıda açıklanan length-prefixing (uzunluk ön ekleme) korumasıyla telafi edilir. I2P Proposal 148, Duplicate Message Identification (DMI, yinelenen mesaj tanımlama) ve Length Extension Attacks (LEA, uzunluk uzatma saldırıları) karşısında gelişmiş koruma ve daha iyi performans için gelecekte BLAKE2b-512\u0026rsquo;ye geçişi önerir.\nRedDSA, H(x)\u0026lsquo;in, uzunluk genişletme saldırılarına karşı güvenli bir kriptografik özet işleviyle gerçekleştirildiğini varsayar. SHA-512 bunu tek başına sağlamaz. Bunu gidermek için, iletilerin başına uzunluklarının prefix-free encoding (önek-özgür kodlama) ile kodlanmış hali getirilmesini şart koşuyoruz:\nlen_u16(M) || M burada len_u16(M), M\u0026rsquo;nin uzunluğunun 2 baytlık temsili olup, skalerlerin ve noktaların little-endian kodlamasıyla tutarlı olacak şekilde little-endian (küçük endian bayt sıralaması) biçimindedir.\nMesajlar 65534 baytı aşmamalıdır. 65535 uzunluk değeri, gelecekteki olası genişletmeler için ayrılmıştır.\nGüvenlik Notu: Karma fonksiyonuna genel anahtarın (vk) dahil edilmesi, imzalama sırasında kullanılan 80 rastgele bayt ile birlikte, RedDSA\u0026rsquo;nın erken tasarımlarında keşfedilen SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack - Seçilen Mesaj Saldırısı altında Yeniden Rastgeleleştirilmiş Anahtarlarla Güçlü Taklit Edilemezlik) güvenlik açıklarına karşı koruma sağlar. Bu gerçekleme, NCC Group Zcash denetimindeki güvenlik düzeltmelerini (Bulgu NCC-Zcash2018-009) içerir.\nKodlama ve kod çözme Red25519 özel anahtarları, mod L skalerler olup little-endian gösteriminde kodlanırlar. Bir skalerin bayt dizisi ve tamsayı biçimleri arasında dönüşüm yapmak için DECODE_SCALAR ve ENCODE_SCALAR işlevlerini tanımlarız.\nRed25519 genel anahtarları, Curve25519\u0026rsquo;un Edwards biçimi üzerindeki noktalardır. Bunlar, y-koordinatının 255 bitlik little-endian (küçük-endian sıralama) gösterimi ve bunu izleyen, x-koordinatının işaretini belirten tek bir bit olarak kodlanır. Bu, Ed25519 için kullanılan kodlamayla aynıdır. Bir noktanın bayt dizisi ve koordinat biçimleri arasında dönüştürme yapmak için DECODE_POINT ve ENCODE_POINT işlevlerini tanımlıyoruz.\nRedDSA fonksiyonları Gerçekleştirmeyi kolaylaştırmak için, aşağıda Red25519 için zaten özelleştirilmiş RedDSA işlevlerini (ve birkaç yardımcı işlevi) açıkça sunuyoruz. RedDSA işlevlerinin genel belirtimi için, uygulayıcılar Zcash Protocol Specification belgesinin 5.4.6 bölümüne başvurmalıdır.\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() Dönüştürme işlevleri CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey CONVERT_ED25519_PRIVATE uygulamasının, bir Ed25519 özel anahtardan Ed25519 açık anahtar türetilirken gizli skaler s değerinin hesaplanmasına, RFC 8032 belgesinin 5.1.5 bölümündeki 1-3. adımlarda belirtildiği üzere, eşdeğer olduğunu unutmayın.\nGüvenlik etkileri Red25519 Destination (I2P\u0026rsquo;de adres/kimlik) yeniden rastgeleleştirilip ardından onunla imzalar oluşturulduğunda, Destination hakkında herhangi bir bilginin sızmasına yol açmaz; çünkü RANDOMIZE_PRIVATE aracılığıyla üretilen Red25519 özel anahtarlarının dağılımı, GENERATE_PRIVATE aracılığıyla üretilen özel anahtarların dağılımıyla aynıdır ve DERIVE_PUBLIC deterministiktir.\nEd25519 özel anahtarlarının CONVERT_ED25519_PRIVATE aracılığıyla Red25519\u0026rsquo;a dönüştürülmesi aynı dağılımla sonuçlanmaz. Ancak, güvenlikteki azalmayı aşağıdaki nedenlerle kabul edilebilir buluyoruz:\nEd25519 skalerlerinin uzayı, Red25519 skalerlerinin uzayının yaklaşık yarısı kadardır (2^251 olası Ed25519 skaler vardır ve L ~= 2^252 olası Red25519 skaler vardır). Bu nedenle güvenlik kaybı en fazla yaklaşık 2 kat, yani yaklaşık 1 bit olur (çünkü tesadüfen, aynı zamanda geçerli bir Ed25519 skaler olan bir Red25519 skaler seçmiş olabiliriz). Mevcut Ed25519 Destinations (I2P\u0026rsquo;de bir adres) geçmişte zaten ağ üzerinde ifşa edilmiştir ve kötü niyetli floodfills\u0026rsquo;in bunları çoktan listelemiş olduğu varsayılmalıdır. Önemli: Bu güvenlik azalmasından endişe duyan kullanıcılar, Destinations (I2P hedefleri) için sigtype (imza türü) olarak Ed25519 (imza türü 7) yerine Red25519\u0026rsquo;u (imza türü 11) kullanmalıdır.\nYukarıdaki argüman yeniden rastgeleleştirme skaler alpha için geçerli değildir; önyargılı bir alpha seçildiğinde her seferinde anahtar hakkında bilgi sızar, çünkü toplamsal yeniden rastgeleleştirme tek kullanımlık bloknot gibi davranır.\nGüvenlik denetimi durumu Önemli Açıklama: I2P, Red25519 dahil, hiçbir zaman resmi bir üçüncü taraf güvenlik denetiminden geçmemiştir. Altta yatan RedDSA tasarımı, 2018\u0026rsquo;de Zcash Sapling protokol denetiminin bir parçası olarak NCC Group tarafından güvenlik incelemesinden geçti; bu incelemede güvenlik sorunları tespit edilip giderildi. Ancak, I2P\u0026rsquo;nin (BLAKE2b-512 yerine) SHA-512 ile yapılan özgül gerçeklenimi ve I2P domain separation (etki alanı ayrımı) bağımsız olarak analiz edilmemiştir.\nstr4d tarafından geliştirilen ed25519-java referans uygulaması, tek bir bağımsız üçüncü taraf denetiminden geçti; ancak bu, Red25519 implementasyonundan önceydi ve yalnızca Ed25519 işlevselliğini kapsadı, Red25519 uzantılarını değil.\nRed25519’u devreye alan kullanıcılar bu sınırlamayı anlamalı ve kendi tehdit modellerine göre güvenlik açısından ödünleri değerlendirmelidir.\nUyumluluk Red25519 (bir imza algoritması) destekleyen I2P sürümleri (sürüm 0.9.39 ve sonrası), Red25519 ile imzalanmış ağ veri yapılarını doğrulayabilir. Red25519\u0026rsquo;u desteklemeyen I2P sürümleri ise bunu bilinmeyen bir imza olarak ele alır ve veri yapılarını göz ardı edebilir.\nDağıtım Zaman Çizelgesi: - 0.9.39 (Mart 2019): floodfills içinde Encrypted LS2 (şifreli LeaseSet2) desteğiyle ilk uygulama - 0.9.40 (Mayıs 2019): Encrypted LS2 için istemci başına yetkilendirme - 0.9.41 (Ağustos 2019): Meta LS2 ve çevrimdışı anahtarlarla Encrypted LS2 - 0.9.43 (Şubat 2020): Encrypted LS2 için b32 desteği - 0.9.47 (Ağustos 2020): Spesifikasyonun tamamlanması - 2.10.0 (Ekim 2025): Güncel ağ sürümü (0.9.67+ ile eşdeğer)\nKullanıcılar, Red25519 ile imzalanmış veri yapılarının güvenilirliğinin Encrypted LeaseSet2 kullanım senaryoları için iyi olmasını bekleyebilir; çünkü ağ, ilk uygulamadan bu yana yükseltmelerini gerçekleştirmek için altı yılı aşkın bir süreye sahipti. Ancak, genel destination (hedef kimlik) kullanımıyla ilgili benimsenme metrikleri kamuya açık değildir.\nBirincil Kullanım Senaryosu: Red25519, key blinding (anahtar körleştirme) gerektiren Şifreli LeaseSet2 işlevselliği için öncelikle kullanılır. Şifreli leaseset gereksinimi olmayan standart hedefler için, Ed25519 (signature type 7), daha geniş uyumluluğu ve daha uzun süredir kanıtlanmış geçmişi nedeniyle önerilen seçim olmaya devam eder.\nUygulama notları Red25519, I2P Java router\u0026rsquo;da net.i2p.crypto.eddsa.RedDSAEngine içinde gerçekleştirilmiş olup, str4d (Jack Grigg) tarafından geliştirilen ed25519-java kütüphanesini Maven bağımlılığı net.i2p.crypto:eddsa (sürüm 0.1.0\u0026rsquo;dan 0.3.0\u0026rsquo;a kadar) olarak kullanır.\ni2pd C++ uygulaması ayrıca şifreli LeaseSet yayınlama için Red25519\u0026rsquo;u (signaturetype=11) destekler.\ni2pd (I2P arka plan hizmeti) için yapılandırma örneği:\nsignaturetype=11 i2cp.leaseSetType=5 Şifrelenmiş LeaseSet2 Uyumluluğu: Şifrelenmiş LeaseSet spesifikasyonu, unblinded destination (körlenmemiş hedef) içindeki imza açık anahtarının Ed25519 (imza türü 7) veya Red25519 (imza türü 11) olmasını gerektirir. Şifrelenmiş leaseset işlevselliği için başka imza türleri desteklenmez.\nTest vektörleri Aşağıdaki test vektörleri, uygulama doğrulaması için sağlanmıştır. Her vektör şunları içerir:\nedsk: Ed25519 özel anahtar (rastgele) edpk: edsk\u0026rsquo;ye karşılık gelen Ed25519 açık anahtar sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: İmzalanacak mesaj sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) Uygulama Notu: Bu test vektörleri, sürekli doğrulama için otomatik birim test paketlerine entegre edilmelidir. Uygulayıcılar, tüm dönüşümler, imzalar ve yeniden rastgeleleştirme işlemlerinin bu beklenen değerlerle eşleştiğini doğrulamalıdır.\nTest vektörü 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 Test vektörü 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f Not: 3-10 numaralı ek test vektörleri aynı formatı izler ve referans uygulamada bulunabilir.\nKaynaklar ","description":"Körleştirilmiş Destinations (I2P uç noktaları) oluşturmak için yeniden rastgeleleştirilebilir bir imza şeması","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"Red25519 İmza Şeması","url":"/tr/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":"Reseed Sunucuları Hakkında Yeni router\u0026rsquo;ların I2P ağına katılmak için birkaç eş düğüme ihtiyacı vardır. Reseed ana makineleri (reseed: yeniden tohumlama) bu başlangıç kümesini şifrelenmiş HTTPS indirmeleri üzerinden sağlar. Her reseed paketi ana makine tarafından imzalanır; bu, kimliği doğrulanmamış tarafların kurcalamasını önler. Kurulu router\u0026rsquo;lar, eş kümeleri güncelliğini yitirdiğinde ara sıra reseed edebilir.\nAğ Önyükleme Süreci Bir I2P router ilk kez başlatıldığında veya uzun süre çevrimdışı kaldığında, ağa bağlanabilmesi için RouterInfo (router bilgisi) verilerine ihtiyaç duyar. Router mevcut eşlere sahip olmadığından, bu bilgiyi I2P ağının içinden temin edemez. Reseed mekanizması (başlangıç/önyükleme için tohumlama mekanizması), güvenilir harici HTTPS sunucularından RouterInfo dosyaları sağlayarak bu önyükleme sorununu çözer.\nReseed (yeniden tohumlama) işlemi, tek bir kriptografik olarak imzalanmış paket içinde 75-100 RouterInfo dosyasını teslim eder. Bu, yeni router\u0026rsquo;ların onları ayrı ve güvenilmeyen ağ bölümlerine izole edebilecek ortadaki adam saldırılarına maruz bırakmadan hızla bağlantılar kurabilmesini sağlar.\nGüncel Ağ Durumu Ekim 2025 itibarıyla, I2P ağı router sürümü 2.10.0 (API sürümü 0.9.67) ile çalışmaktadır. 0.9.14 sürümünde tanıtılan reseed protocol (ağa ilk kez katılım için gerekli başlangıç verilerinin indirildiği protokol) temel işlevselliği açısından kararlıdır ve değişmemiştir. Ağ, erişilebilirliği ve sansüre direnç sağlamak için küresel olarak dağıtılmış birden çok bağımsız reseed servers bulundurmaktadır.\nHizmet checki2p , tüm I2P reseed (yeni kurulumların ağa katılabilmesi için başlangıç ağ verilerini sağlayan mekanizma) sunucularını her 4 saatte bir izler ve reseed altyapısı için gerçek zamanlı durum kontrolleri ile kullanılabilirlik ölçümleri sağlar.\nSU3 Dosya Biçimi Belirtimi SU3 dosya formatı, kriptografik olarak imzalanmış içerik dağıtımı sağlayarak I2P\u0026rsquo;nin reseed protokolünün (başlangıç [bootstrap] verilerinin sağlanması) temelini oluşturur. Bu formatı anlamak, reseed sunucuları ve istemcilerinin uygulanması için esastır.\nDosya Yapısı SU3 formatı üç ana bileşenden oluşur: başlık (40+ bayt), içerik (değişken uzunlukta) ve imza (uzunluğu başlıkta belirtilir).\nBaşlık Biçimi (Bayt 0-39, en az) Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") ### Reseed'e Özgü SU3 Parametreleri Reseed bundles (I2P\u0026rsquo;ye ilk bağlantı için gerekli tohum verilerini içeren paketler) için SU3 dosyası aşağıdaki özelliklere sahip olmalıdır:\nDosya adı: Tam olarak i2pseeds.su3 olmalıdır İçerik Türü (bayt 27): 0x03 (RESEED) Dosya Türü (bayt 25): 0x00 (ZIP) İmza Türü (bayt 8-9): 0x0006 (RSA-4096-SHA512) Sürüm Dizesi: ASCII biçiminde Unix zaman damgası (epoch\u0026rsquo;tan beri geçen saniyeler, date +%s biçimi) İmzalayan Kimliği: X.509 sertifikasının CN\u0026rsquo;si ile eşleşen e-posta biçeminde tanımlayıcı Ağ Kimliği Sorgu Parametresi 0.9.42 sürümünden beri, router\u0026rsquo;lar reseed (ilk ağ tohumlaması) isteklerine ?netid=2 ekler. Bu, çapraz ağ bağlantılarını engeller; çünkü test ağları farklı ağ kimlikleri kullanır. Mevcut I2P üretim ağı ağ kimliği 2\u0026rsquo;yi kullanır.\nÖrnek istek: https://reseed.example.com/i2pseeds.su3?netid=2\nZIP İçerik Yapısı İçerik bölümü (başlıktan sonra, imzadan önce) aşağıdaki gereksinimleri karşılayan standart bir ZIP arşivi içerir:\nSıkıştırma: Standart ZIP sıkıştırması (DEFLATE) Dosya sayısı: Tipik olarak 75-100 RouterInfo (router bilgisi) dosyası Dizin yapısı: Tüm dosyalar en üst düzeyde olmalıdır (alt dizin yok) Dosya adlandırma: routerInfo-{44-character-base64-hash}.dat Base64 alfabesi: I2P\u0026rsquo;nin değiştirilmiş base64 alfabesi kullanılmalıdır I2P base64 alfabesi, dosya sistemi ve URL uyumluluğunu sağlamak için + ve / yerine - ve ~ kullanarak standart base64\u0026rsquo;ten farklıdır.\nKriptografik İmza İmza, 0. bayttan başlayarak içerik bölümünün sonuna kadar dosyanın tamamını kapsar. İmzanın kendisi ise içeriğin ardından eklenir.\nİmza Algoritması (RSA-4096-SHA512) bayttan içeriğin sonuna kadar olan baytların SHA-512 özetini hesaplayın Özeti \u0026ldquo;raw\u0026rdquo; RSA (Java terminolojisinde NONEwithRSA) kullanarak imzalayın Gerekiyorsa 512 bayta ulaşması için imzayı baştaki sıfırlarla doldurun 512 baytlık imzayı dosyanın sonuna ekleyin İmza Doğrulama Süreci İstemciler şunları yapmalıdır:\nİmza türünü ve uzunluğunu belirlemek için 0-11 arası baytları okuyun İçerik sınırlarını belirlemek için tüm başlığı okuyun SHA-512 özeti hesaplanırken içeriği akış halinde işleyin İmzayı dosyanın sonundan ayıklayın İmzayı, imzalayanın RSA-4096 açık anahtarını kullanarak doğrulayın İmza doğrulaması başarısız olursa dosyayı reddedin Sertifika Güven Modeli Reseed imzalayıcı anahtarları, RSA-4096 anahtarlarıyla kendinden imzalı X.509 sertifikaları olarak dağıtılır. Bu sertifikalar, I2P router paketlerinde certificates/reseed/ dizininde yer alır.\nSertifika formatı: - Anahtar türü: RSA-4096 - İmza: Öz-imzalı - Subject CN: SU3 başlığındaki Signer ID ile eşleşmelidir - Geçerlilik tarihleri: İstemciler sertifikaların geçerlilik sürelerini uygulamalıdır\nReseed Sunucusu Çalıştırma Bir reseed hizmeti (ağa katılım için başlangıç ağ verisini sağlayan hizmet) işletmek, güvenlik, güvenilirlik ve ağ çeşitliliği gereksinimlerine titizlikle dikkat etmeyi gerektirir. Daha fazla bağımsız reseed sunucusu, dayanıklılığı artırır ve saldırganların ya da sansürcülerin yeni router\u0026rsquo;ların ağa katılımını engellemesini zorlaştırır.\nTeknik Gereksinimler Sunucu Özellikleri İşletim Sistemi: Unix/Linux (Ubuntu, Debian, FreeBSD test edilmiş ve önerilir) Bağlantı: Statik IPv4 adresi gereklidir, IPv6 önerilir ancak zorunlu değildir CPU: En az 2 çekirdek RAM: En az 2 GB Bant genişliği: Aylık yaklaşık 15 GB Çalışma süresi: 7/24 çalışma zorunludur I2P Router: Sürekli çalışan, iyi entegre edilmiş bir I2P router Yazılım Gereksinimleri Java: JDK 8 veya daha yenisi (I2P 2.11.0 ile başlayarak Java 17+ gerekli olacaktır) Web Sunucusu: Ters proxy desteğine sahip nginx veya Apache (X-Forwarded-For başlığı kısıtlamaları nedeniyle Lighttpd artık desteklenmiyor) TLS/SSL: Geçerli TLS sertifikası (Let\u0026rsquo;s Encrypt, kendinden imzalı veya ticari Sertifika Otoritesi (CA)) DDoS Koruması: fail2ban veya eşdeğeri (zorunlu, isteğe bağlı değil) Reseed Tools (I2P ağına ilk katılım için başlangıç verilerini sağlayan araçlar): https://i2pgit.org/idk/reseed-tools adresindeki resmi reseed-tools Güvenlik Gereksinimleri HTTPS/TLS Yapılandırması Protokol: Yalnızca HTTPS, HTTP\u0026rsquo;ye geri dönüş (fallback) yok TLS Sürümü: En az TLS 1.2 Şifre süitleri (cipher suites): Java 8+ ile uyumlu güçlü şifreleme algoritmalarını desteklemelidir Sertifika CN/SAN: Sunulan URL\u0026rsquo;nin ana makine adıyla eşleşmelidir Sertifika Türü: Geliştirme ekibiyle iletişime geçilirse self-signed (kendinden imzalı) olabilir veya tanınmış bir CA (Sertifika Otoritesi) tarafından verilebilir Sertifika Yönetimi SU3 imzalama sertifikaları ve TLS sertifikaları farklı amaçlara hizmet eder:\nTLS Sertifikası (certificates/ssl/): HTTPS taşımayı güvence altına alır SU3 İmzalama Sertifikası (certificates/reseed/): reseed paketlerini (ağa ilk katılım paketleri) imzalar Her iki sertifika da router paketlerine dahil edilmek üzere reseed koordinatörüne (zzz@mail.i2p ) sağlanmalıdır.\nDDoS ve Scraping (veri kazıma) Koruması Reseed sunucuları, hatalı uygulamalar, botnetler ve ağ veritabanını kazımaya çalışan kötü niyetli aktörlerden gelen periyodik saldırılarla karşı karşıya kalır. Koruma önlemleri şunları içerir:\nfail2ban: Hız sınırlama ve saldırı hafifletme için gereklidir Paket Çeşitliliği: Farklı istekte bulunanlara farklı RouterInfo (router bilgi kaydı) kümeleri teslim edin Paket Tutarlılığı: Aynı IP\u0026rsquo;den yapılandırılabilir bir zaman penceresi içinde yinelenen isteklere aynı paketi teslim edin IP Günlükleme Kısıtlamaları: Günlükleri veya IP adreslerini ifşa etmeyin (gizlilik politikası gereği) Uygulama Yöntemleri Yöntem 1: Resmi reseed-tools (Önerilir) I2P projesi tarafından sürdürülen kanonik uygulama. Depo: https://i2pgit.org/idk/reseed-tools Kurulum:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 İlk çalıştırmada, araç şunları oluşturur: - your-email@mail.i2p.crt (SU3 imzalama sertifikası) - your-email@mail.i2p.pem (SU3 imzalama özel anahtarı) - your-email@mail.i2p.crl (Sertifika iptal listesi) - TLS sertifikası ve anahtar dosyaları\nÖzellikler: - Otomatik SU3 paket üretimi (350 varyant, her birinde 77 RouterInfo (yöneltici bilgisi)) - Yerleşik HTTPS sunucusu - Önbelleğin cron aracılığıyla her 9 saatte bir yeniden oluşturulması - --trustProxy bayrağıyla X-Forwarded-For üstbilgisi desteği - Ters proxy yapılandırmalarıyla uyumlu\nÜretim Ortamına Dağıtım:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed Yöntem 2: Python Uygulaması (pyseeder) PurpleI2P projesi tarafından geliştirilen alternatif bir gerçekleme: https://github.com/PurpleI2P/pyseeder pip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 Yöntem 3: Docker ile Dağıtım Konteynerleştirilmiş ortamlar için, Docker\u0026rsquo;a hazır birkaç gerçekleştirim mevcuttur:\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: Tor onion service (Tor onion servisi) ve IPFS desteği ekler Ters Proxy Yapılandırması nginx Yapılandırması upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } Apache Yapılandırması \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; Kayıt ve Koordinasyon reseed server\u0026rsquo;ınızın (ağa ilk katılım için router listesini sağlayan sunucu) resmi I2P paketine dahil edilmesi için:\nKurulumu ve testleri tamamlayın Her iki sertifikayı (SU3 signing ve TLS) reseed (ağ başlangıç bilgisi dağıtımı) koordinatörüne gönderin İletişim: zzz@mail.i2p veya zzz@i2pmail.org Diğer operatörlerle koordinasyon için IRC2P\u0026rsquo;deki #i2p-dev kanalına katılın Operasyonel En İyi Uygulamalar İzleme ve Günlükleme İstatistikler için Apache/nginx birleşik günlük biçimini etkinleştirin Günlük döndürmeyi uygulayın (günlükler hızla büyür) Paket oluşturma başarısını ve yeniden oluşturma sürelerini izleyin Bant genişliği kullanımını ve istek kalıplarını izleyin IP adreslerini veya ayrıntılı erişim günlüklerini asla kamuya açıklamayın Bakım Takvimi Her 9 saatte bir: SU3 paket önbelleğini yeniden oluştur (cron ile otomatikleştirildi) Haftalık: Günlükleri saldırı kalıpları açısından gözden geçir Aylık: I2P router\u0026rsquo;ı ve reseed-tools\u0026rsquo;u güncelle Gerektikçe: TLS sertifikalarını yenile (Let\u0026rsquo;s Encrypt ile otomatikleştir) Port Seçimi Varsayılan: 8443 (önerilir) Alternatif: 1024-49151 arasındaki herhangi bir port Port 443: root ayrıcalıkları veya port yönlendirmesi gerektirir (iptables redirect önerilir) Örnek port yönlendirme:\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 Alternatif Yeniden Tohumlama Yöntemleri Diğer önyükleme seçenekleri, kısıtlayıcı ağların arkasındaki kullanıcılara yardımcı olur:\nDosya Tabanlı Reseed (ağın başlangıç verilerinin dosyadan alınması) 0.9.16 sürümünde tanıtılan dosya tabanlı reseed (yeniden tohumlama), kullanıcıların RouterInfo (yönlendirici bilgisi) paketlerini elle yüklemesine olanak tanır. Bu yöntem, HTTPS reseed sunucularının engellendiği sansürlü bölgelerdeki kullanıcılar için özellikle yararlıdır.\nSüreç: 1. Güvenilir bir kişi, router\u0026rsquo;ını kullanarak bir SU3 paketi oluşturur 2. Paket e-posta, USB sürücü veya başka bir bant dışı kanal üzerinden aktarılır 3. Kullanıcı i2pseeds.su3 dosyasını I2P yapılandırma dizinine yerleştirir 4. Router yeniden başlatıldığında paketi otomatik olarak algılar ve işler\nDokümantasyon: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\nKullanım Senaryoları: - reseed sunucularını engelleyen ulusal güvenlik duvarlarının arkasındaki kullanıcılar - manuel bootstrap (el ile ilk başlatma) gerektiren izole ağlar - test ve geliştirme ortamları\nCloudflare vekil sunucusu üzerinden Reseeding (başlangıç verilerinin yeniden alınması) Reseed (ağa ilk katılım için başlangıç verilerinin alınması) trafiğini Cloudflare\u0026rsquo;in CDN\u0026rsquo;i aracılığıyla yönlendirmek, yüksek düzeyde sansür uygulanan bölgelerdeki operatörler için çeşitli avantajlar sağlar.\nFaydalar: - Kaynak sunucunun IP adresi istemcilerden gizlenir - Cloudflare\u0026rsquo;ın altyapısı aracılığıyla DDoS koruması - Edge caching (uç önbellekleme) aracılığıyla coğrafi yük dağıtımı - Küresel istemciler için iyileştirilmiş performans\nUygulama Gereksinimleri: - reseed-tools içinde --trustProxy bayrağı etkin - DNS kaydı için Cloudflare proxy etkin - X-Forwarded-For üstbilgisinin uygun şekilde işlenmesi\nÖnemli Hususlar: - Cloudflare bağlantı noktası (port) kısıtlamaları geçerlidir (desteklenen bağlantı noktaları kullanılmalıdır) - Aynı istemci bundle (demet) tutarlılığı X-Forwarded-For desteği gerektirir - SSL/TLS yapılandırması Cloudflare tarafından yönetilir\nDokümantasyon: https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/ Sansüre Dayanıklı Stratejiler Nguyen Phong Hoang’ın (USENIX FOCI 2019) çalışması, sansürlü ağlar için ek önyükleme yöntemlerini tanımlamaktadır:\nBulut Depolama Sağlayıcıları Box, Dropbox, Google Drive, OneDrive: SU3 (I2P imzalı güncelleme dosyası formatı) dosyalarını herkese açık bağlantılarda barındırın Avantaj: Meşru hizmetleri aksatmadan engellemesi zordur Sınırlama: Kullanıcılara URL\u0026rsquo;lerin elle dağıtılmasını gerektirir IPFS (InterPlanetary File System - Gezegenlerarası Dosya Sistemi) Dağıtımı Reseed paketlerini InterPlanetary File System (IPFS, merkeziyetsiz dosya sistemi) üzerinde barındırın İçerik-adresli depolama, kurcalamayı önler Kaldırma girişimlerine karşı dayanıklıdır Tor Onion Hizmetleri .onion adresleri üzerinden erişilebilen Reseed servers (ağa ilk katılım için başlangıç sunucuları) IP tabanlı engellemeye dayanıklı Kullanıcının sisteminde Tor istemcisi gerektirir Araştırma Dokümantasyonu: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/ I2P\u0026rsquo;nin Engellendiği Bilinen Ülkeler 2025 itibarıyla, aşağıdaki ülkelerde I2P reseed servers (ağa ilk bağlantıyı sağlayan sunucular) erişiminin engellendiği doğrulanmıştır: - Çin - İran - Umman - Katar - Kuveyt\nBu bölgelerdeki kullanıcılar, alternatif bootstrap yöntemleri (başlangıç yöntemleri) veya sansüre dirençli reseeding stratejileri (yeniden tohumlama stratejileri) kullanmalıdır.\nUygulayıcılar için Protokol Ayrıntıları Reseed (netDb\u0026rsquo;nin ilk tohumlanması) İstek Şartnamesi İstemci Davranışı Sunucu Seçimi: Router sabit kodlanmış reseed URL\u0026rsquo;lerinin (başlangıç URL\u0026rsquo;leri) bir listesini tutar Rastgele Seçim: İstemci mevcut listeden rastgele bir sunucu seçer İstek Biçimi: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: Yaygın tarayıcıları taklit etmelidir (örn. \u0026ldquo;Wget/1.11.4\u0026rdquo;) Yeniden Deneme Mantığı: SU3 isteği başarısız olursa, indeks sayfasını ayrıştırmaya başvurun Sertifika Doğrulama: TLS sertifikasını sistemin güvenilir sertifika deposuna karşı doğrulayın SU3 İmza Doğrulama: İmzayı bilinen reseed sertifikalarına karşı doğrulayın Sunucu Davranışı Demet Seçimi: netDb içinden RouterInfos (yönlendirici bilgileri kayıtları) psödorastgele bir alt kümesini seçin İstemci İzleme: İstekleri kaynak IP\u0026rsquo;ye göre belirleyin (X-Forwarded-For\u0026rsquo;u dikkate alarak) Demet Tutarlılığı: Zaman penceresi içinde tekrarlanan isteklere aynı demeti döndürün (genellikle 8-12 saat) Demet Çeşitliliği: Ağ çeşitliliği için farklı istemcilere farklı demetler döndürün Content-Type: application/octet-stream veya application/x-i2p-reseed RouterInfo Dosya Biçimi reseed paketindeki her .dat dosyası bir RouterInfo (router bilgisi) yapısı içerir:\nDosya Adlandırma: routerInfo-{base64-hash}.dat - Özet 44 karakterdir ve I2P base64 alfabesini kullanır - Örnek: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat\nDosya İçeriği: - RouterIdentity (router hash, şifreleme anahtarı, imzalama anahtarı) - Yayın zaman damgası - Router adresleri (IP, port, taşıma türü) - Router yetenekleri ve seçenekleri - Yukarıdaki tüm verileri kapsayan imza\nAğ Çeşitliliği Gereksinimleri Ağın merkezileşmesini önlemek ve Sybil saldırılarının tespitini sağlamak için:\nTam NetDb dökümleri yok: Tüm RouterInfos (RouterInfo nesneleri; router bilgi kayıtları) öğelerini tek bir istemciye asla sunmayın Rastgele örnekleme: Her paket, mevcut eşlerin farklı bir alt kümesini içerir Minimum paket boyutu: 75 RouterInfos (orijinal 50\u0026rsquo;den artırıldı) Maksimum paket boyutu: 100 RouterInfos Güncellik: RouterInfos güncel olmalıdır (oluşturulmasından itibaren 24 saat içinde) IPv6 ile ilgili hususlar Mevcut Durum (2025): - Bazı reseed sunucuları IPv6 üzerinden yanıt vermiyor - İstemciler güvenilirlik için IPv4\u0026rsquo;ü tercih etmeli veya zorlamalı - Yeni kurulumlar için IPv6 desteği önerilir ancak kritik değildir\nUygulama Notu: Dual-stack sunucuları yapılandırırken, hem IPv4 hem de IPv6 dinleme adreslerinin düzgün çalıştığından emin olun, ya da IPv6 düzgün şekilde desteklenemiyorsa IPv6\u0026rsquo;yı devre dışı bırakın.\nGüvenlik Hususları Tehdit Modeli Reseed protokolü aşağıdakilere karşı koruma sağlar:\nAradaki adam saldırıları: RSA-4096 imzaları bundle (paket) kurcalanmasını önler Ağ bölünmesi: Birden fazla bağımsız reseed sunucusu (ağa ilk katılım için) tekil bir kontrol noktasının oluşmasını engeller Sybil saldırıları: Bundle çeşitliliği, saldırganın kullanıcıları izole etme yeteneğini sınırlar Sansür: Birden çok sunucu ve alternatif yöntemler yedeklilik sağlar Reseed protokolü şunlara karşı koruma sağlamaz:\nEle geçirilmiş reseed (I2P ağına ilk katılım için önyükleme işlemi) sunucuları: Saldırgan reseed sertifikalarının özel anahtarlarını kontrol ediyorsa Ağın tamamen engellenmesi: Bir bölgede tüm reseed yöntemleri engellenmişse Uzun vadeli izleme: Reseed istekleri, I2P\u0026rsquo;ye katılmaya çalışan IP adresini ortaya çıkarır Sertifika Yönetimi Özel Anahtar Güvenliği: - Kullanılmadıklarında SU3 imzalama anahtarlarını çevrimdışı olarak saklayın - Anahtar şifrelemesi için güçlü parolalar kullanın - Anahtarların ve sertifikaların güvenli yedeklerini muhafaza edin - Kritik öneme sahip dağıtımlar için donanım güvenlik modüllerini (HSM\u0026rsquo;ler) değerlendirin\nSertifika İptali: - Haber akışı aracılığıyla dağıtılan Sertifika İptal Listeleri (CRL\u0026rsquo;ler) - Kompromize olmuş sertifikalar koordinatör tarafından iptal edilebilir - Routers yazılım güncellemeleriyle CRL\u0026rsquo;leri otomatik olarak günceller\nSaldırıların Azaltılması DDoS Koruması: - aşırı istekler için fail2ban kuralları - web sunucusu düzeyinde hız sınırlaması - IP adresi başına bağlantı sınırları - ek bir katman için Cloudflare veya benzeri bir CDN (İçerik Dağıtım Ağı)\nVeri kazıma önleme: - İstek yapan IP başına farklı paketler - IP başına zaman bazlı paket önbellekleme - Veri kazıma girişimlerini gösteren kalıpların günlüklenmesi - Tespit edilen saldırılar konusunda diğer operatörlerle koordinasyon\nTest ve Geçerleme Reseed (önyükleme verileri) sunucunuzun test edilmesi Yöntem 1: Sıfırdan Router Kurulumu I2P\u0026rsquo;yi temiz bir sistem üzerine kurun reseed (ağa ilk eş bilgilerini alma) URL\u0026rsquo;nizi yapılandırmaya ekleyin Diğer reseed URL\u0026rsquo;lerini kaldırın veya devre dışı bırakın router\u0026rsquo;ı başlatın ve başarılı reseed için günlükleri izleyin 5-10 dakika içinde ağa bağlandığınızı doğrulayın Beklenen günlük çıktısı:\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received Yöntem 2: Manuel SU3 (imzalı güncelleme dosyası formatı) Doğrulaması # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) Yöntem 3: checki2p İzleme https://checki2p.com/reseed adresindeki hizmet, kayıtlı tüm I2P reseed sunucularında her 4 saatte bir otomatik kontroller gerçekleştirir. Bu şunları sağlar:\nKullanılabilirlik izleme Yanıt süresi metrikleri TLS sertifikası doğrulaması SU3 imza doğrulaması Geçmiş çalışma süresi verileri reseed\u0026rsquo;iniz (başlangıç sunucusu) I2P projesine kaydedildiğinde, 24 saat içinde checki2p\u0026rsquo;de otomatik olarak görünecektir.\nYaygın Sorunların Giderilmesi Sorun: İlk çalıştırmada \u0026ldquo;imzalama anahtarı okunamıyor\u0026rdquo; - Çözüm: Bu beklenen bir durumdur. Yeni anahtarlar oluşturmak için \u0026lsquo;y\u0026rsquo; yanıtını verin.\nSorun: Router imzayı doğrulayamıyor - Neden: Sertifika router\u0026rsquo;ın güven deposunda değil - Çözüm: Sertifikayı ~/.i2p/certificates/reseed/ dizinine yerleştirin\nSorun: Aynı paket farklı istemcilere sunuluyor - Neden: X-Forwarded-For başlığı doğru şekilde iletilmiyor - Çözüm: --trustProxy seçeneğini etkinleştirin ve ters proxy başlıklarını yapılandırın\nSorun: \u0026ldquo;Connection refused\u0026rdquo; hataları - Neden: Bağlantı noktası İnternet\u0026rsquo;ten erişilebilir değil - Çözüm: Güvenlik duvarı kurallarını kontrol edin, bağlantı noktası yönlendirmesini doğrulayın\nSorun: bundle yeniden oluşturma sırasında yüksek CPU kullanımı - Neden: 350\u0026rsquo;den fazla SU3 (I2P imzalı güncelleme dosyası biçimi) varyasyonu oluşturulurken normal davranıştır - Çözüm: Yeterli CPU kaynaklarını sağlayın, yeniden oluşturma sıklığını azaltmayı düşünün\nReferans Bilgileri Resmi Dokümantasyon Reseed (yeniden tohumlama) Katkıda Bulunanlar Kılavuzu: /guides/creating-and-running-an-i2p-reseed-server/ Reseed Politika Gereksinimleri: /guides/reseed-policy/ SU3 Teknik Şartnamesi: /docs/specs/updates/ Reseed Araçları Deposu: https://i2pgit.org/idk/reseed-tools Reseed Araçları Belgeleri: https://eyedeekay.github.io/reseed-tools/ Alternatif Gerçeklemeler PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Python WSGI reseeder (ilk kurulum için netDb verilerini sağlayan hizmet): https://github.com/torbjo/i2p-reseeder Topluluk Kaynakları I2P Forumu: https://i2pforum.net/ Gitea Deposu: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: #i2p-dev IRC2P üzerinde Durum İzleme: https://checki2p.com/reseed Sürüm Geçmişi 0.9.14 (2014): SU3 reseed formatı tanıtıldı 0.9.16 (2014): Dosya tabanlı reseeding eklendi 0.9.42 (2019): Network ID sorgu parametresi zorunluluğu 2.0.0 (2022): SSU2 taşıma protokolü tanıtıldı 2.4.0 (2024): NetDB izolasyonu ve güvenlik iyileştirmeleri 2.6.0 (2024): I2P-over-Tor bağlantıları engellendi 2.10.0 (2025): Güncel kararlı sürüm (Eylül 2025 itibarıyla) İmza Türü Referansı Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 **Reseed (yeniden tohumlama) Standardı**: Type 6 (RSA-SHA512-4096) reseed paketleri için gereklidir. Takdir Ağın erişilebilir ve dayanıklı kalmasını sağladıkları için tüm reseed operator (reseed hizmeti işletmecisi)lere teşekkürler. Aşağıdaki katkıda bulunanlar ve projelere özel teşekkürler:\nzzz: Uzun süredir I2P geliştiricisi ve reseed (I2P ağının ilk önyüklemesini sağlayan sunucular/işlem) koordinatörü idk: reseed-tools\u0026rsquo;un mevcut bakımcısı ve sürüm yöneticisi Nguyen Phong Hoang: Sansüre dirençli reseeding stratejileri üzerine araştırma PurpleI2P Team: Alternatif I2P gerçeklemeleri ve araçları checki2p: reseed altyapısı için otomatik izleme hizmeti I2P ağının merkeziyetsiz reseed altyapısı (ağa ilk katılım için gerekli başlangıç bilgilerini sağlayan mekanizma), dünya çapında onlarca operatörün ortak çabasını temsil eder ve yerel sansür ya da teknik engeller ne olursa olsun yeni kullanıcıların ağa katılmak için her zaman bir yol bulabilmesini sağlar.\n","description":"Reseed (ilk eş temini) hizmetlerinin işletimi ve alternatif bootstrap (başlangıç) yöntemleri","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"Reseed Sunucuları (başlangıç için ağ verisi sağlayıcıları)","url":"/tr/docs/misc/reseed/"},{"categories":null,"content":"Bu kılavuz, I2P Router Console\u0026rsquo;una ve yapılandırma sayfalarına genel bir bakış sunar. Her bölüm, sayfanın ne yaptığını ve ne için tasarlandığını açıklayarak I2P router\u0026rsquo;ınızı nasıl izleyip yapılandıracağınızı anlamanıza yardımcı olur.\nYönlendirici Konsolu\u0026rsquo;na Erişim I2P Router Console, I2P router\u0026rsquo;ınızı yönetmek ve izlemek için merkezi merkezdir. Varsayılan olarak, I2P router\u0026rsquo;ınız çalışırken I2P Router Console adresinden erişilebilir.\nAna sayfa birkaç önemli bölüm görüntüler:\nUygulamalar - E-posta, Torrent, Gizli Servisler Yöneticisi ve Web Sunucusu gibi yerleşik I2P uygulamalarına hızlı erişim I2P Topluluk Siteleri - Forum, dokümantasyon ve proje web siteleri dahil olmak üzere önemli topluluk kaynaklarına bağlantılar Yapılandırma ve Yardım - Bant genişliği ayarlarını yapılandırma, eklentileri yönetme ve yardım kaynaklarına erişim araçları Ağ ve Geliştirici Bilgileri - Grafiklere, günlüklere, teknik dokümantasyona ve ağ istatistiklerine erişim Adres Defteri URL: Adres Defteri I2P Adres Defteri, clearnet\u0026rsquo;teki DNS\u0026rsquo;e benzer şekilde çalışır ve I2P hedefleri (eepsite\u0026rsquo;lar) için insanlar tarafından okunabilir isimleri yönetmenize olanak tanır. Burası, kişisel adres defterinize I2P adreslerini görüntüleyip ekleyebileceğiniz yerdir.\nAdres defteri sistemi birden fazla katman üzerinden çalışır:\nYerel Kayıtlar - Yalnızca yönlendiricinizde saklanan kişisel adres defterleriniz\nYerel Adres Defteri - Manuel olarak eklediğiniz veya kendi kullanımınız için kaydettiğiniz hostlar Özel Adres Defteri - Başkalarıyla paylaşmak istemediğiniz adresler; hiçbir zaman halka açık olarak dağıtılmaz Abonelikler - Router\u0026rsquo;ınızın adres defterini bilinen I2P siteleriyle otomatik olarak güncelleyen uzak adres defteri kaynakları (http://i2p-projekt.i2p/hosts.txt gibi)\nRouter Addressbook - Yerel kayıtlarınız ve aboneliklerinizin birleştirilmiş sonucu, router\u0026rsquo;ınızdaki tüm I2P uygulamaları tarafından aranabilir\nYayınlanmış Adres Defteri - Adres defterinizi başkalarının abonelik kaynağı olarak kullanması için isteğe bağlı olarak halka açık şekilde paylaşma (bir I2P sitesi çalıştırıyorsanız kullanışlıdır)\nAdres defteri, aboneliklerinizi düzenli olarak kontrol eder ve içeriği yönlendirici adres defterinizle birleştirerek hosts.txt dosyanızı I2P ağıyla güncel tutar.\nYapılandırma URL: Gelişmiş Yapılandırma Yapılandırma bölümü, birden fazla özelleşmiş sekme aracılığıyla tüm router ayarlarına erişim sağlar.\nAdvanced Gelişmiş yapılandırma sayfası, normal çalışma için genellikle gerekli olmayan düşük seviyeli router ayarlarına erişim sağlar. Çoğu kullanıcı, belirli bir yapılandırma seçeneğini ve bunun router davranışı üzerindeki etkisini anlamadıkça bu ayarları değiştirmemelidir.\nTemel özellikler:\nFloodfill Yapılandırması - Router\u0026rsquo;ınızın floodfill eşi olarak katılıp katılmayacağını kontrol eder. Bu, ağ veritabanı bilgilerini depolayıp dağıtarak ağa yardımcı olur. Daha fazla sistem kaynağı kullanabilir ancak I2P ağını güçlendirir.\nGelişmiş I2P Yapılandırması - router.config dosyasına doğrudan erişim, şunlar dahil tüm gelişmiş yapılandırma parametrelerini gösterir:\nBant genişliği limitleri ve burst ayarları Transport ayarları (NTCP2, SSU2, UDP portları ve anahtarlar) Router tanımlama ve sürüm bilgisi Konsol tercihleri ve güncelleme ayarları En gelişmiş yapılandırma seçenekleri kullanıcı arayüzünde gösterilmez çünkü nadiren ihtiyaç duyulur. Bu ayarları düzenleyebilmek için router.config dosyanıza manuel olarak routerconsole.advanced=true eklemeniz gerekir.\nUyarı: Gelişmiş ayarları yanlış şekilde değiştirmek, router\u0026rsquo;ınızın performansını veya bağlantısını olumsuz etkileyebilir. Bu ayarları yalnızca ne yaptığınızı biliyorsanız değiştirin.\nBandwidth URL: Bant Genişliği Yapılandırması Bant genişliği yapılandırma sayfası, yönlendiricinizin I2P ağına ne kadar bant genişliği katkıda bulunacağını kontrol etmenizi sağlar. I2P, hızlarınızı internet bağlantınızın hızıyla eşleşecek şekilde yapılandırdığınızda en iyi şekilde çalışır.\nTemel Ayarlar:\nKBps In - Yönlendiricinizin kabul edeceği maksimum gelen bant genişliği (indirme hızı) KBps Out - Yönlendiricinizin kullanacağı maksimum giden bant genişliği (yükleme hızı) Share - Giden bant genişliğinizin katılımcı trafiğe ayrılan yüzdesi (başkalarının trafiğini yönlendirmeye yardımcı olma) Önemli Notlar:\nTüm değerler saniyede bit değil, saniyede bayt (KBps) cinsindendir Ne kadar çok bant genişliği sağlarsanız, ağa o kadar çok yardımcı olur ve kendi anonimliğinizi o kadar iyileştirirsiniz Yukarı akış paylaşım miktarınız (KBps Out), ağa genel katkınızı belirler Ağınızın hızından emin değilseniz, ölçmek için Bandwidth Test kullanın Daha yüksek paylaşım bant genişliği hem anonimliğinizi iyileştirir hem de I2P ağını güçlendirmeye yardımcı olur Yapılandırma sayfası, ayarlarınıza göre tahmini aylık veri aktarımını gösterir ve internet planı limitelerinize göre bant genişliği tahsisini planlamanıza yardımcı olur.\nClient Configuration URL: İstemci Yapılandırması İstemci Yapılandırması sayfası, başlangıçta hangi I2P uygulamalarının ve hizmetlerinin çalışacağını kontrol etmenize olanak tanır. Burası, yerleşik I2P istemcilerini kaldırmadan etkinleştirebileceğiniz veya devre dışı bırakabileceğiniz yerdir.\nÖnemli Uyarı: Buradaki ayarları değiştirirken dikkatli olun. Router konsolu ve uygulama tunnel\u0026rsquo;ları I2P\u0026rsquo;nin çoğu kullanımı için gereklidir. Yalnızca ileri düzey kullanıcılar bu ayarları değiştirmelidir.\nMevcut İstemciler:\nUygulama tünelleri - İstemci ve sunucu tünellerini yöneten I2PTunnel sistemi (HTTP proxy, IRC, vb.) I2P Router Konsolu - Şu anda kullanmakta olduğunuz web tabanlı yönetim arayüzü I2P web sunucusu (eepsite) - Kendi I2P web sitenizi barındırmak için yerleşik Jetty web sunucusu Başlangıçta Router Konsolu\u0026rsquo;nu web tarayıcısında aç - Konsol ana sayfasını tarayıcınızda otomatik olarak başlatır SAM uygulama köprüsü - Üçüncü taraf uygulamaların I2P\u0026rsquo;ye bağlanması için API köprüsü Her istemci şunları gösterir: - Başlangıçta Çalıştır? - Otomatik başlatmayı etkinleştirme/devre dışı bırakma onay kutusu - Kontrol - Anlık kontrol için Başlat/Durdur düğmeleri - Sınıf ve argümanlar - İstemcinin nasıl başlatıldığına dair teknik detaylar\n\u0026ldquo;Başlangıçta Çalıştır?\u0026rdquo; ayarındaki değişikliklerin geçerli olması için router\u0026rsquo;ın yeniden başlatılması gerekir. Tüm değişiklikler /var/lib/i2p/i2p-config/clients.config.d/ dizinine kaydedilir.\nİleri Düzey URL: I2CP Yapılandırması I2CP (I2P Client Protocol) yapılandırma sayfası, harici uygulamaların I2P router\u0026rsquo;ınıza nasıl bağlanacağını yapılandırmanıza olanak tanır. I2CP, uygulamaların tunnel oluşturmak ve I2P üzerinden veri göndermek/almak için router ile iletişim kurmak için kullandığı protokoldür.\nÖnemli: Varsayılan ayarlar çoğu kullanıcı için yeterlidir. Burada yapılan değişikliklerin harici istemci uygulamasında da yapılandırılması gerekir. Birçok istemci SSL veya yetkilendirmeyi desteklemez. Tüm değişikliklerin etkili olması için yeniden başlatma gerekir.\nYapılandırma Seçenekleri:\nHarici I2CP Arayüz Yapılandırması\nSSL olmadan Etkin - Standart I2CP erişimi (varsayılan ve en uyumlu) SSL zorunlu olarak Etkin - Yalnızca şifrelenmiş I2CP bağlantıları Devre Dışı - Harici istemcilerin I2CP üzerinden bağlanmasını engeller I2CP Arayüzü - Dinlenecek ağ arayüzü (varsayılan: yalnızca localhost için 127.0.0.1)\nI2CP Portu - I2CP bağlantıları için port numarası (varsayılan: 7654)\nYetkilendirme\nKullanıcı adı ve parola gerektir - I2CP bağlantıları için kimlik doğrulamayı etkinleştir Kullanıcı adı - I2CP erişimi için gerekli kullanıcı adını ayarla Parola - I2CP erişimi için gerekli parolayı ayarla Güvenlik Notu: I2P router\u0026rsquo;ınızla aynı makinede yalnızca uygulamalar çalıştırıyorsanız, uzaktan erişimi önlemek için arayüzü 127.0.0.1 olarak ayarlı tutun. Bu ayarları yalnızca diğer cihazlardan I2P uygulamalarının router\u0026rsquo;ınıza bağlanmasına izin vermeniz gerekiyorsa değiştirin.\nBant Genişliği URL: Ağ Yapılandırması Ağ Yapılandırması sayfası, I2P router\u0026rsquo;ınızın internete nasıl bağlanacağını yapılandırmanıza olanak tanır; bu ayarlar IP adresi algılama, IPv4/IPv6 tercihleri ve hem UDP hem de TCP transport\u0026rsquo;ları için port ayarlarını içerir.\nHarici Olarak Erişilebilir IP Adresi:\nTüm otomatik algılama yöntemlerini kullan - Genel IP adresinizi birden fazla yöntem kullanarak otomatik olarak algılar (önerilir) UPnP IP adresi algılamasını devre dışı bırak - IP adresinizi keşfetmek için UPnP kullanımını engeller Yerel arayüz IP adresini yoksay - Yerel ağ IP adresinizi kullanmaz Yalnızca SSU IP adresi algılamasını kullan - IP algılama için yalnızca SSU2 aktarımını kullanır Gizli mod - IP yayınlama - Ağ trafiğine katılımı engeller (anonimliği azaltır) Ana bilgisayar adı veya IP belirt - Genel IP adresinizi veya ana bilgisayar adınızı manuel olarak ayarlar IPv4 Yapılandırması:\nGelen bağlantıları devre dışı bırak (Güvenlik duvarı arkasında) - Gelen bağlantıları engelleyen bir güvenlik duvarı, ev ağı, ISS, DS-Lite veya operatör sınıfı NAT arkasındaysanız bunu işaretleyin IPv6 Yapılandırması:\nIPv4\u0026rsquo;ü IPv6\u0026rsquo;ya Tercih Et - IPv4 bağlantılarına öncelik verir IPv6\u0026rsquo;yı IPv4\u0026rsquo;e Tercih Et - IPv6 bağlantılarına öncelik verir (çift yığın ağları için varsayılan) IPv6\u0026rsquo;yı Etkinleştir - IPv6 bağlantılarına izin verir IPv6\u0026rsquo;yı Devre Dışı Bırak - Tüm IPv6 bağlantısını devre dışı bırakır Yalnızca IPv6 Kullan (IPv4\u0026rsquo;ü devre dışı bırak) - Deneysel yalnızca IPv6 modu Gelen Bağlantıları Devre Dışı Bırak (Güvenlik Duvarı Arkasında) - IPv6\u0026rsquo;nızın güvenlik duvarı arkasında olup olmadığını kontrol edin IP Değiştiğinde Yapılacak İşlem:\nLaptop modu - IP adresiniz değiştiğinde gelişmiş anonimlik için router kimliğini ve UDP portunu değiştiren deneysel özellik UDP Yapılandırması:\nPort Belirtin - SSU2 aktarımı için belirli bir UDP portu ayarlayın (güvenlik duvarınızda açılmalıdır) Tamamen devre dışı bırak - Yalnızca tüm giden UDP trafiğini engelleyen bir güvenlik duvarının arkasındaysanız seçin TCP Yapılandırması:\nPort Belirle - NTCP2 taşıması için belirli bir TCP portu ayarla (güvenlik duvarınızda açılmalıdır) UDP için yapılandırılan aynı portu kullan - Her iki taşıma için tek bir port kullanarak yapılandırmayı basitleştirir Otomatik algılanan IP adresini kullan - Genel IP adresinizi otomatik olarak algılar (henüz algılanmadıysa veya güvenlik duvarı varsa \u0026ldquo;şu anda bilinmiyor\u0026rdquo; gösterir) Her zaman otomatik algılanan IP adresini kullan (Güvenlik duvarı yok) - Doğrudan internet erişimi olan router\u0026rsquo;lar için en iyisi Gelen bağlantıları devre dışı bırak (Güvenlik duvarlı) - TCP bağlantılarının güvenlik duvarınız tarafından engellenip engellenmediğini kontrol edin Tamamen devre dışı bırak - Yalnızca giden TCP\u0026rsquo;yi kısıtlayan veya engelleyen bir güvenlik duvarının arkasındaysanız seçin Hostname veya IP belirle - Dışarıdan erişilebilir adresinizi manuel olarak yapılandırın Önemli: Ağ ayarlarındaki değişikliklerin tam olarak etkili olması için router\u0026rsquo;ın yeniden başlatılması gerekebilir. Doğru port yönlendirme yapılandırması, router\u0026rsquo;ınızın performansını önemli ölçüde artırır ve I2P ağına yardımcı olur.\nİstemci Yapılandırması URL: Eş Yapılandırması Peer Yapılandırma sayfası, I2P ağındaki bireysel peer\u0026rsquo;ları yönetmek için manuel kontroller sağlar. Bu, genellikle yalnızca sorunlu peer\u0026rsquo;lar için sorun giderme amacıyla kullanılan gelişmiş bir özelliktir.\nManuel Eş Kontrolleri:\nRouter Hash - Yönetmek istediğiniz eşin 44 karakterlik base64 router hash değerini girin Bir Eş Sunucuyu Manuel Olarak Yasaklama / Yasağı Kaldırma:\nBir peer\u0026rsquo;ı yasaklamak, oluşturduğunuz tünellere katılmalarını engeller. Bu işlem: - Peer\u0026rsquo;ın istemci veya keşif tünellerinizde kullanılmasını engeller - Yeniden başlatma gerektirmeden hemen etkili olur - Peer\u0026rsquo;ı manuel olarak yasaktan kaldırana veya router\u0026rsquo;ınızı yeniden başlatana kadar devam eder - Yeniden başlatana kadar peer\u0026rsquo;ı yasakla - Peer\u0026rsquo;ı geçici olarak engeller - Peer yasakını kaldır - Daha önce engellenmiş bir peer üzerindeki yasaklamayı kaldırır\nProfil Bonuslarını Ayarlama:\nProfil bonusları, tünele katılım için eşlerin nasıl seçildiğini etkiler. Bonuslar pozitif veya negatif olabilir: - Hızlı eşler - Yüksek hız gerektiren istemci tünelleri için kullanılır - Yüksek Kapasite eşleri - Güvenilir yönlendirme gerektiren bazı keşif tünelleri için kullanılır - Mevcut bonuslar profiller sayfasında görüntülenir\nYapılandırma: - Hız - Bu eş için hız bonusunu ayarlayın (0 = nötr) - Kapasite - Bu eş için kapasite bonusunu ayarlayın (0 = nötr) - Eş bonuslarını ayarla - Bonus ayarlarını uygula\nKullanım Senaryoları: - Sürekli bağlantı sorunlarına neden olan bir peer\u0026rsquo;ı yasaklayın - Kötü niyetli olduğundan şüphelendiğiniz bir peer\u0026rsquo;ı geçici olarak hariç tutun - Düşük performanslı peer\u0026rsquo;ları öncelikten düşürmek için bonusları ayarlayın - Belirli peer\u0026rsquo;ları hariç tutarak tünel oluşturma sorunlarını giderin\nNot: Çoğu kullanıcının bu özelliği kullanmasına hiç gerek kalmayacaktır. I2P router, performans metriklerine dayalı olarak peer seçimini ve profillemeyi otomatik olarak yönetir.\nI2CP Yapılandırması URL: Reseed Yapılandırması Reseed Yapılandırma sayfası, otomatik reseed işlemi başarısız olursa router\u0026rsquo;ınızı manuel olarak reseed etmenize olanak tanır. Reseed, I2P\u0026rsquo;yi ilk kurduğunuzda veya router\u0026rsquo;ınızda çok az router referansı kaldığında diğer router\u0026rsquo;ları bulmak için kullanılan başlatma sürecidir.\nManuel Reseed Ne Zaman Kullanılır:\nYeniden tohumlama başarısız olduysa, öncelikle ağ bağlantınızı kontrol etmelisiniz\nBir güvenlik duvarı yeniden tohumlama sunucularına bağlantılarınızı engelliyorsa, bir proxy\u0026rsquo;ye erişiminiz olabilir:\nProxy uzak bir genel proxy olabilir veya bilgisayarınızda (localhost) çalışıyor olabilir Bir proxy kullanmak için Yeniden Tohumlama Yapılandırması bölümünde türü, sunucuyu ve bağlantı noktasını yapılandırın Tor Browser çalıştırıyorsanız, SOCKS 5, localhost, port 9150 yapılandırarak onun üzerinden yeniden tohumlama yapın Komut satırı Tor çalıştırıyorsanız, SOCKS 5, localhost, port 9050 yapılandırarak onun üzerinden yeniden tohumlama yapın Bazı eşleriniz varsa ancak daha fazlasına ihtiyacınız varsa, I2P Outproxy seçeneğini deneyebilirsiniz. Sunucu ve port alanlarını boş bırakın. Bu, hiç eşiniz olmadığında ilk yeniden tohumlama için çalışmayacaktır Ardından, \u0026ldquo;Değişiklikleri kaydet ve şimdi yeniden tohumla\u0026rdquo; düğmesine tıklayın Varsayılan ayarlar çoğu kişi için çalışacaktır. Bunları yalnızca HTTPS kısıtlayıcı bir güvenlik duvarı tarafından engelleniyorsa ve yeniden tohumlama başarısız olduysa değiştirin I2P çalıştıran ve güvendiğiniz birini tanıyorsanız, router konsolundaki bu sayfayı kullanarak oluşturulmuş bir reseed dosyası göndermelerini isteyin. Ardından, aldığınız dosyayla reseed yapmak için bu sayfayı kullanın. İlk olarak, aşağıdan dosyayı seçin. Sonra, \u0026ldquo;Reseed from file\u0026rdquo; üzerine tıklayın\nReseed dosyalarını yayınlayan güvendiğiniz birini tanıyorsanız, onlara URL\u0026rsquo;yi sorun. Ardından, aldığınız URL ile reseed yapmak için bu sayfayı kullanın. İlk olarak, aşağıya URL\u0026rsquo;yi girin. Sonra, \u0026ldquo;Reseed from URL\u0026rdquo; düğmesine tıklayın\nManuel olarak yeniden seed işlemi için SSS bölümüne bakın\nManuel Reseed Seçenekleri:\nURL\u0026rsquo;den Yeniden Tohum - Güvenilir bir kaynaktan zip veya su3 URL\u0026rsquo;si girin ve \u0026ldquo;URL\u0026rsquo;den Yeniden Tohum\u0026quot;a tıklayın\nsu3 formatı tercih edilir, çünkü güvenilir bir kaynak tarafından imzalandığı doğrulanacaktır zip formatı imzasızdır; zip dosyasını yalnızca güvendiğiniz bir kaynaktan kullanın Dosyadan Yeniden Tohum - Yerel bir zip veya su3 dosyasına göz atın ve seçin, ardından \u0026ldquo;Dosyadan yeniden tohum\u0026rdquo; düğmesine tıklayın\nYeniden tohum dosyalarını checki2p.com/reseed adresinde bulabilirsiniz Reseed Dosyası Oluştur - Başkalarının manuel olarak reseed yapması için paylaşabileceğiniz yeni bir reseed zip dosyası oluşturun\nBu dosya asla kendi router\u0026rsquo;ınızın kimliğini veya IP\u0026rsquo;sini içermeyecektir Reseeding Yapılandırması:\nVarsayılan ayarlar çoğu kullanıcı için çalışacaktır. Bunları yalnızca HTTPS kısıtlayıcı bir güvenlik duvarı tarafından engelleniyorsa ve reseed başarısız olmuşsa değiştirin.\nReseed URL\u0026rsquo;leri - Reseed sunucularına ait HTTPS URL listesi (varsayılan liste yerleşik olarak gelir ve düzenli olarak güncellenir) Proxy Yapılandırması - Reseed sunucularına bir proxy üzerinden erişmeniz gerekiyorsa HTTP/HTTPS/SOCKS proxy yapılandırın URL listesini sıfırla - Varsayılan reseed sunucu listesini geri yükle Önemli: Manuel yeniden tohum ekleme yalnızca otomatik yeniden tohum eklemenin tekrar tekrar başarısız olduğu nadir durumlarda gerekli olmalıdır. Çoğu kullanıcının bu sayfayı kullanmasına hiç gerek olmayacaktır.\nAğ Yapılandırması URL: Router Family Yapılandırması Router Family Configuration sayfası, router ailelerini yönetmenize olanak tanır. Aynı ailedeki routerlar bir family key (aile anahtarı) paylaşır ve bu onları aynı kişi veya kuruluş tarafından işletildiğini belirtir. Bu, kontrol ettiğiniz birden fazla routerın aynı tunnel için seçilmesini önler, aksi takdirde anonimlik azalır.\nRouter Family Nedir?\nBirden fazla I2P router işlettiğinizde, bunları aynı ailenin parçası olacak şekilde yapılandırmalısınız. Bu şunları sağlar: - Router\u0026rsquo;larınız aynı tunnel yolunda birlikte kullanılmaz - Diğer kullanıcılar, tunnel\u0026rsquo;ları sizin router\u0026rsquo;larınızı kullandığında uygun anonimliği korur - Ağ, tunnel katılımını düzgün bir şekilde dağıtabilir\nMevcut Aile:\nBu sayfa mevcut router ailenizin adını gösterir. Bir ailenin parçası değilseniz, bu alan boş olacaktır.\nAile Anahtarını Dışa Aktar:\nKontrol ettiğiniz diğer yönlendiricilere aktarılmak üzere gizli aile anahtarını dışa aktarın Aile anahtarı dosyanızı indirmek için \u0026ldquo;Export Family Key\u0026rdquo; düğmesine tıklayın Aynı aileye eklemek için bu anahtarı diğer yönlendiricilerinize aktarın Router Ailesinden Ayrıl:\nArtık ailenin bir üyesi olmayın Bu yönlendiriciyi mevcut ailesinden çıkarmak için \u0026ldquo;Aileden Ayrıl\u0026quot;a tıklayın Bu işlem, aile anahtarı yeniden içe aktarılmadan geri alınamaz Önemli Hususlar:\nGenel Kayıt Gereklidir: Ailenizin ağ genelinde tanınması için, aile anahtarınızın I2P geliştirme ekibi tarafından I2P kod tabanına eklenmesi gerekir. Bu, ağdaki tüm router\u0026rsquo;ların aileniz hakkında bilgi sahibi olmasını sağlar. Birden fazla genel router işletiyorsanız, aile anahtarınızı kaydetmek için I2P ekibiyle iletişime geçin Yalnızca bir router çalıştıran kullanıcıların çoğunun bu özelliği kullanmasına hiç gerek olmayacaktır Aile yapılandırması öncelikli olarak birden fazla genel router işleten operatörler veya altyapı sağlayıcıları tarafından kullanılır Kullanım Senaryoları:\nYedeklilik için birden fazla I2P router çalıştırma Birden fazla makinede reseed sunucuları veya outproxy\u0026rsquo;ler gibi altyapı çalıştırma Bir organizasyon için I2P router ağı yönetimi Eş Yapılandırması URL: Tünel Yapılandırması Tünel Yapılandırması sayfası, hem keşif tünelleri (router iletişimi için kullanılır) hem de istemci tünelleri (uygulamalar tarafından kullanılır) için varsayılan tünel ayarlarını düzenlemenize olanak tanır. Varsayılan ayarlar çoğu kişi için çalışır ve yalnızca ödünleşimleri anlıyorsanız değiştirilmelidir.\nÖnemli Uyarılar:\n⚠️ Anonimlik ile Performans Dengesi: Anonimlik ve performans arasında temel bir denge vardır. 3 hop\u0026rsquo;tan uzun tüneller (örneğin 2 hop + 0-2 hop, 3 hop + 0-1 hop, 3 hop + 0-2 hop) veya yüksek miktar + yedek miktar, performansı veya güvenilirliği ciddi şekilde azaltabilir. Yüksek CPU ve/veya yüksek giden bant genişliği kullanımı ortaya çıkabilir. Bu ayarları dikkatle değiştirin ve sorun yaşarsanız ayarlayın.\n⚠️ Kalıcılık: Keşif tüneli ayar değişiklikleri router.config dosyasında saklanır. İstemci tüneli değişiklikleri geçicidir ve kaydedilmez. Kalıcı istemci tüneli değişiklikleri yapmak için I2PTunnel sayfasına bakın.\nKeşif Tünelleri:\nKeşif tünelleri, yönlendiriciniz tarafından ağ veritabanıyla iletişim kurmak ve I2P ağına katılmak için kullanılır.\nHem Inbound hem de Outbound için yapılandırma seçenekleri: - Length - Tüneldeki hop sayısı (varsayılan: 2-3 hop) - Randomization - Tünel uzunluğundaki rastgele varyans (varsayılan: 0-1 hop) - Quantity - Aktif tünel sayısı (varsayılan: 2 tünel) - Backup quantity - Etkinleştirilmeye hazır yedek tünel sayısı (varsayılan: 0 tünel)\nI2P Web Sunucusu için İstemci Tünelleri:\nBu ayarlar, yerleşik I2P web sunucusu (eepsite) için tünelleri kontrol eder.\n⚠️ ANONİMLİK UYARISI - Ayarlar 1-hop tunnel\u0026rsquo;ları içeriyor. ⚠️ PERFORMANS UYARISI - Ayarlar yüksek tunnel miktarları içeriyor.\nHem Gelen hem de Giden için yapılandırma seçenekleri: - Uzunluk - Tunnel uzunluğu (varsayılan: web sunucusu için 1 hop) - Rastgeleleştirme - Tunnel uzunluğunda rastgele değişkenlik - Miktar - Aktif tunnel sayısı - Yedek miktar - Yedek tunnel sayısı\nPaylaşımlı İstemciler için İstemci Tünelleri:\nBu ayarlar paylaşımlı istemci uygulamaları için geçerlidir (HTTP proxy, IRC, vb.).\nHem Gelen hem de Giden bağlantılar için yapılandırma seçenekleri: - Uzunluk - Tünel uzunluğu (varsayılan: 3 atlama) - Rastgeleleştirme - Tünel uzunluğunda rastgele değişkenlik - Miktar - Aktif tünel sayısı - Yedek miktar - Yedek tünel sayısı\nTünel Parametrelerini Anlamak:\nUzunluk: Daha uzun tüneller daha fazla anonimlik sağlar ancak performansı ve güvenilirliği azaltır Rastgeleleştirme: Tünel yollarına öngörülemezlik ekleyerek güvenliği artırır Miktar: Daha fazla tünel güvenilirliği ve yük dağılımını iyileştirir ancak kaynak kullanımını artırır Yedek miktarı: Başarısız tünelleri değiştirmeye hazır önceden oluşturulmuş tüneller, dayanıklılığı artırır En İyi Uygulamalar:\nÖzel ihtiyaçlarınız yoksa varsayılan ayarları koruyun Tunnel uzunluğunu yalnızca anonimlik kritik önemdeyse ve daha yavaş performansı kabul edebiliyorsanız artırın Sık tunnel arızaları yaşıyorsanız miktar/yedeklemeyi artırın Değişiklik yaptıktan sonra router performansını izleyin Değişiklikleri uygulamak için \u0026ldquo;Değişiklikleri kaydet\u0026quot;e tıklayın Reseed Yapılandırması URL: Arayüz Yapılandırması UI Yapılandırma sayfası, tema seçimi, dil tercihleri ve parola koruması dahil olmak üzere router konsolunuzun görünümünü ve erişilebilirliğini özelleştirmenize olanak tanır.\nRouter Konsolu Teması:\nRouter konsolu arayüzü için karanlık ve aydınlık temalar arasından seçim yapın: - Dark - Karanlık mod teması (düşük ışıklı ortamlarda gözler için daha rahat) - Light - Aydınlık mod teması (geleneksel görünüm)\nEk tema seçenekleri: - Temayı tüm uygulamalarda evrensel olarak ayarla - Seçilen temayı sadece router konsolu için değil, tüm I2P uygulamaları için uygula - Mobil konsolun kullanılmasını zorla - Masaüstü tarayıcılarda bile mobil için optimize edilmiş arayüzü kullan - E-posta ve Torrent uygulamalarını konsola göm - Susimail ve I2PSnark\u0026rsquo;ı ayrı sekmelerde açmak yerine doğrudan konsol arayüzüne entegre et\nRouter Konsolu Dili:\nRouter konsolu arayüzü için tercih ettiğiniz dili açılır menüden seçin. I2P, İngilizce, Almanca, Fransızca, İspanyolca, Rusça, Çince, Japonca ve daha fazlası dahil olmak üzere birçok dili destekler.\nÇeviri katkıları bekliyoruz: Eksik veya hatalı çeviriler fark ederseniz, çeviri projesine katkıda bulunarak I2P\u0026rsquo;yi geliştirmeye yardımcı olabilirsiniz. IRC\u0026rsquo;de #i2p-dev kanalındaki geliştiricilerle iletişime geçin veya çeviri durum raporunu kontrol edin (sayfada bağlantısı bulunmaktadır).\nRouter Konsolu Parolası:\nRouter konsolunuza erişimi korumak için kullanıcı adı ve parola kimlik doğrulaması ekleyin:\nKullanıcı Adı - Konsol erişimi için kullanıcı adını girin Parola - Konsol erişimi için parolayı girin Kullanıcı ekle - Belirtilen kimlik bilgileriyle yeni bir kullanıcı oluşturun Seçileni sil - Mevcut kullanıcı hesaplarını kaldırın Neden Şifre Eklemeliyim?\nYönlendirici konsolunuza yetkisiz yerel erişimi önler Bilgisayarınızı birden fazla kişi kullanıyorsa gereklidir Yönlendirici konsolunuz yerel ağınızda erişilebilir durumdaysa önerilir I2P yapılandırmanızı ve gizlilik ayarlarınızı değiştirilmeye karşı korur Güvenlik Notu: Şifre koruması yalnızca I2P Router Console adresindeki router console web arayüzüne erişimi etkiler. I2P trafiğini şifrelemez veya uygulamaların I2P kullanmasını engellemez. Bilgisayarınızın tek kullanıcısıysanız ve router console yalnızca localhost\u0026rsquo;ta dinliyorsa (varsayılan), bir şifre gerekli olmayabilir.\nYönlendirici Ailesi Yapılandırması URL: WebApp Yapılandırması WebApp Yapılandırma sayfası, I2P router\u0026rsquo;ınız içinde çalışan Java web uygulamalarını yönetmenize olanak tanır. Bu uygulamalar webConsole istemcisi tarafından başlatılır ve router ile aynı JVM\u0026rsquo;de çalışarak router konsolu üzerinden erişilebilen entegre işlevsellik sağlar.\nWebApps Nedir?\nWebApp\u0026rsquo;ler, aşağıdakilerden biri olabilen Java tabanlı uygulamalardır: - Tam uygulamalar (örn. torrent\u0026rsquo;ler için I2PSnark) - Ayrıca etkinleştirilmesi gereken diğer istemcilerin ön yüzleri (örn. Susidns, I2PTunnel) - Web arayüzü olmayan web uygulamaları (örn. adres defteri)\nÖnemli Notlar:\nBir webapp tamamen devre dışı bırakılabilir veya yalnızca başlangıçta çalışması engellenebilir webapps dizininden bir war dosyasının kaldırılması webapp\u0026rsquo;i tamamen devre dışı bırakır Ancak .war dosyası ve webapp dizini, router\u0026rsquo;ınızı daha yeni bir sürüme güncellediğinizde yeniden görünecektir Bir webapp\u0026rsquo;i kalıcı olarak devre dışı bırakmak için: Tercih edilen yöntem olan burada devre dışı bırakın Mevcut Web Uygulamaları:\nWebApp Description i2psnark Torrents - Built-in BitTorrent client for I2P i2ptunnel Hidden Services Manager - Configure client and server tunnels imagegen Identification Image Generator - Creates unique identicons jsonrpc jsonrpc.war - JSON-RPC API interface (disabled by default) routerconsole I2P Router Console - The main administrative interface susidns Address Book - Manage I2P addresses and subscriptions susimail Email - Web-based email client for I2P Kontroller: Her bir webapp için: - Başlangıçta Çalıştır? - Otomatik başlatmayı etkinleştirmek/devre dışı bırakmak için onay kutusu - Kontrol - Anlık kontrol için Başlat/Durdur düğmeleri - Durdur - Çalışmakta olan webapp\u0026rsquo;i durdurur - Başlat - Durdurulmuş bir webapp\u0026rsquo;i başlatır\nYapılandırma Düğmeleri:\nİptal - Değişiklikleri iptal et ve önceki sayfaya dön WebApp Yapılandırmasını Kaydet - Değişikliklerinizi kaydedin ve uygulayın Kullanım Senaryoları:\nTorrent kullanmıyorsanız kaynak tasarrufu için I2PSnark\u0026rsquo;ı durdurun API erişimine ihtiyacınız yoksa jsonrpc\u0026rsquo;yi devre dışı bırakın Harici bir e-posta istemcisi kullanıyorsanız Susimail\u0026rsquo;i durdurun Belleği boşaltmak veya sorunları gidermek için webapps\u0026rsquo;i geçici olarak durdurun Performans İpucu: Kullanılmayan web uygulamalarını devre dışı bırakmak, özellikle düşük kaynaklı sistemlerde bellek kullanımını azaltabilir ve router performansını iyileştirebilir.\nHelp URL: Yardım Yardım sayfası, I2P\u0026rsquo;yi etkili bir şekilde anlamanıza ve kullanmanıza yardımcı olacak kapsamlı dokümantasyon ve kaynaklar sağlar. Sorun giderme, öğrenme ve destek alma için merkezi bir merkez görevi görür.\nBulacaklarınız:\nHızlı Başlangıç Kılavuzu - I2P\u0026rsquo;ye yeni başlayan kullanıcılar için temel bilgiler Sıkça Sorulan Sorular (SSS) - I2P kurulumu, yapılandırması ve kullanımı hakkında yaygın soruların cevapları Sorun Giderme - Yaygın sorunlara ve bağlantı hatalarına yönelik çözümler Teknik Dokümantasyon - I2P protokolleri, mimarisi ve teknik özellikleri hakkında detaylı bilgiler Uygulama Kılavuzları - Torrent, e-posta ve gizli servisler gibi I2P uygulamalarının kullanım talimatları Ağ Bilgileri - I2P\u0026rsquo;nin nasıl çalıştığını ve onu güvenli kılan özellikleri anlama Destek Kaynakları - Forum, IRC kanalları ve topluluk desteği bağlantıları Yardım Alma:\nI2P ile ilgili sorun yaşıyorsanız: 1. Sık sorulan sorular ve cevaplar için SSS\u0026rsquo;ye bakın 2. Özel probleminiz için sorun giderme bölümünü inceleyin 3. i2pforum.i2p veya i2pforum.net adresindeki I2P forumunu ziyaret edin 4. Gerçek zamanlı topluluk desteği için #i2p IRC kanalına katılın 5. Detaylı teknik bilgi için dokümantasyonda arama yapın\nİpucu: Yardım sayfasına router konsolunun kenar çubuğundan her zaman erişilebilir, bu sayede ihtiyacınız olduğunda yardım bulmak kolaydır.\nPerformance Graphs URL: Performans Grafikleri Performans Grafikleri sayfası, I2P router\u0026rsquo;ınızın performansının ve ağ etkinliğinin gerçek zamanlı görsel izlemesini sağlar. Bu grafikler bant genişliği kullanımını, eş bağlantılarını, bellek tüketimini ve genel router sağlığını anlamanıza yardımcı olur.\nMevcut Grafikler:\nBant Genişliği Kullanımı\nDüşük seviye gönderme hızı (bayt/saniye) - Giden trafik hızı Düşük seviye alma hızı (bayt/saniye) - Gelen trafik hızı Mevcut, ortalama ve maksimum bant genişliği kullanımını gösterir Yapılandırılmış bant genişliği limitinize yaklaşıp yaklaşmadığınızı izlemenize yardımcı olur Aktif Eşler\nrouter.activePeers 60 saniyelik ortalama - Aktif olarak iletişim kurduğunuz eş sayısı Ağ bağlantınızın sağlığını gösterir Daha fazla aktif eş genellikle daha iyi tunnel oluşturma ve ağ katılımı anlamına gelir Router Bellek Kullanımı\nrouter.memoryUsed averaged for 60 sec - JVM bellek tüketimi Mevcut, ortalama ve maksimum bellek kullanımını MB cinsinden gösterir Bellek sızıntılarını tespit etmek veya Java heap boyutunu artırmanız gerekip gerekmediğini belirlemek için kullanışlıdır Grafik Görünümünü Yapılandır:\nGrafiklerin nasıl görüntüleneceğini ve yenileneceğini özelleştirin:\nGrafik boyutu - Genişlik (varsayılan: 400 piksel) ve yükseklik (varsayılan: 100 piksel) ayarlayın Görüntüleme dönemi - Görüntülenecek zaman aralığı (varsayılan: 60 dakika) Yenileme gecikmesi - Grafiklerin ne sıklıkla güncelleneceği (varsayılan: 5 dakika) Grafik türü - Ortalamalar veya Olaylar görünümü arasından seçim yapın Göstergeyi gizle - Yer kazanmak için göstergeyi grafiklerden kaldırın UTC - Grafiklerde yerel saat yerine UTC saatini kullanın Kalıcılık - Geçmiş analizi için grafik verilerini diskte saklayın Gelişmiş Seçenekler:\nHangi istatistiklerin grafikleneceğini seçmek için [Select Stats] düğmesine tıklayın: - Tunnel metrikleri (oluşturma başarı oranı, tunnel sayısı, vb.) - Network database istatistikleri - Transport istatistikleri (NTCP2, SSU2) - Client tunnel performansı - Ve çok daha fazla detaylı metrik\nKullanım Alanları:\nYapılandırılmış limitlerini aşmadığınızdan emin olmak için bant genişliğini izleyin Ağ sorunlarını giderirken eş bağlantısını doğrulayın Java heap ayarlarını optimize etmek için bellek kullanımını takip edin Zaman içindeki performans kalıplarını belirleyin Grafikleri ilişkilendirerek tunnel oluşturma sorunlarını teşhis edin İpucu: Değişikliklerinizi uygulamak için yapılandırmanızı yaptıktan sonra \u0026ldquo;Ayarları kaydet ve grafikleri yeniden çiz\u0026rdquo; düğmesine tıklayın. Grafikler, yenileme gecikmesi ayarınıza göre otomatik olarak güncellenecektir.\n","description":"I2P Yönlendirici Konsolu'nu anlamak ve yapılandırmak için kapsamlı bir kılavuz","id":"c46f1b6edeab9b686fd57cf9b311df1c","section":"docs","title":"Router Konsolu Yapılandırma Kılavuzu","url":"/tr/docs/guides/router-console-config/"},{"categories":null,"content":"Genel Bakış Bu belge, router ve çeşitli uygulamalar tarafından kullanılan I2P yapılandırma dosyalarının kapsamlı bir teknik şartnamesini sunar. Dosya biçimi belirtimleri, özellik tanımları ve I2P kaynak kodu ile resmi dokümantasyonla karşılaştırılarak doğrulanmış gerçekleme ayrıntılarını kapsar.\nKapsam Router yapılandırma dosyaları ve biçimleri İstemci uygulama yapılandırmaları I2PTunnel tunnel yapılandırmaları Dosya biçimi spesifikasyonları ve uygulanması Sürüme özgü özellikler ve kullanımdan kaldırmalar Uygulama Notları Yapılandırma dosyaları, I2P çekirdek kitaplığındaki DataHelper.loadProps() ve storeProps() yöntemleri kullanılarak okunup yazılır. Dosya biçimi, I2P protokollerinde kullanılan serileştirilmiş biçimden önemli ölçüde farklıdır (bkz. Ortak Yapılar Belirtimi - Tür Eşlemesi ).\nGenel Yapılandırma Dosyası Biçimi I2P yapılandırma dosyaları, belirli istisna ve kısıtlamalar içeren değiştirilmiş bir Java Properties biçimini kullanır.\nBiçim Belirtimi Java Properties temel alınır, ancak aşağıdaki kritik farklılıklar vardır:\nKodlama MUTLAKA UTF-8 kodlaması kullanılmalıdır (standart Java Properties\u0026rsquo;te olduğu gibi ISO-8859-1 DEĞİL) Gerçekleme: Tüm dosya işlemleri için DataHelper.getUTF8() yardımcı işlevlerini kullanır Kaçış Dizileri HİÇBİR kaçış dizisi tanınmaz (ters eğik çizgi \\ dahil) Satır devamı DESTEKLENMEZ Ters eğik çizgi karakterleri olduğu gibi yorumlanır Yorum Karakterleri # bir satırın herhangi bir yerinde yorum başlatır ; yalnızca 1. sütunda yorum başlatır ! yorum BAŞLATMAZ (Java Properties\u0026rsquo;den farklıdır) Anahtar-Değer Ayırıcıları = YALNIZCA geçerli anahtar-değer ayırıcısıdır : bir ayırıcı olarak TANINMAZ Boşluk karakterleri bir ayırıcı olarak TANINMAZ Boşluk Karakterlerinin Yönetimi Anahtarlardaki baş ve sondaki boşluk karakterleri KIRPILMAZ Değerlerdeki baş ve sondaki boşluk karakterleri KIRPILIR Satır İşleme = içermeyen satırlar yok sayılır (yorum veya boş satır olarak değerlendirilir) Boş değerler (key=) 0.9.10 sürümünden itibaren desteklenir Boş değerlere sahip anahtarlar normal şekilde depolanır ve okunur Karakter Kısıtlamaları Anahtarlar şunları içeremez: - # (kare/diyez işareti) - = (eşittir işareti) - \\n (yeni satır karakteri) - ; (noktalı virgül) ile başlayamaz\nDeğerler şunları İÇEREMEZ: - # (kare/diyez işareti) - \\n (yeni satır karakteri) - Başında veya sonunda \\r olamaz (satır başı) - Başında veya sonunda boşluk olamaz (otomatik olarak kırpılır)\nDosya Sıralama Yapılandırma dosyalarının anahtara göre sıralanması gerekmez. Ancak, çoğu I2P uygulaması, aşağıdakileri kolaylaştırmak için yapılandırma dosyalarını yazarken anahtarları alfabetik olarak sıralar: - Elle düzenleme - Sürüm kontrolü diff (fark karşılaştırma) işlemleri - İnsan tarafından okunabilirlik\nUygulama Ayrıntıları Yapılandırma Dosyalarını Okuma // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) Davranış: - UTF-8 ile kodlanmış dosyaları okur - Yukarıda açıklanan tüm biçim kurallarını uygular - Karakter kısıtlamalarını doğrular - Dosya yoksa boş bir Properties nesnesi döndürür - Okuma hatalarında IOException fırlatır\nYapılandırma Dosyaları Yazma // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) Davranış: - UTF-8 ile kodlanmış dosyalar yazar - Anahtarları alfabetik olarak sıralar (OrderedProperties kullanılmadıkça) - Sürüm 0.8.1 itibarıyla dosya izinlerini 600 moduna (yalnızca kullanıcı okuma/yazma) ayarlar - Anahtar veya değerlerdeki geçersiz karakterler için IllegalArgumentException fırlatır - Yazma hataları için IOException fırlatır\nBiçim Doğrulaması Uygulama sıkı bir doğrulama yapar: - Anahtarlar ve değerler izin verilmeyen karakterler açısından kontrol edilir - Geçersiz girdiler yazma işlemleri sırasında istisnalara neden olur - Okuma, biçimi bozuk satırları sessizce yok sayar (= olmayan satırlar)\nBiçim Örnekleri Geçerli Yapılandırma Dosyası # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは Geçersiz Yapılandırma Örnekleri # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value Çekirdek Kitaplığı ve Router Yapılandırması İstemci Yapılandırması (clients.config) Konum: $I2P_CONFIG_DIR/clients.config (eski) veya $I2P_CONFIG_DIR/clients.config.d/ (modern) Yapılandırma Arayüzü: Router konsolu /configclients adresinde Biçim Değişikliği: Sürüm 0.9.42 (Ağustos 2019)\nDizin Yapısı (Sürüm 0.9.42+) 0.9.42 sürümünden itibaren, varsayılan clients.config dosyası otomatik olarak ayrı yapılandırma dosyalarına ayrılır:\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) Geçiş Davranışı: - 0.9.42+ sürümüne yükseltmeden sonraki ilk çalıştırmada, monolitik dosya otomatik olarak bölünür - Bölünmüş dosyalardaki özelliklerin başına clientApp.0. öneki eklenir - Geriye dönük uyumluluk için eski biçim hâlâ desteklenir - Bölünmüş biçim, modüler paketlemeyi ve eklenti yönetimini mümkün kılar\nÖzellik Biçimi Satırlar clientApp.x.prop=val biçimindedir; burada x uygulama numarasıdır.\nUygulama numaralandırma gereksinimleri: - 0 ile başlamalıdır - Ardışık olmalıdır (atlama olmamalı) - Sıralama, başlatma sırasını belirler\nZorunlu Özellikler ana Tür: String (tam nitelikli sınıf adı) Gerekli: Evet Açıklama: Bu sınıftaki kurucu (constructor) veya main() metodu, istemci türüne (yönetilen vs. yönetilmeyen) bağlı olarak çağrılacaktır Örnek: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner İsteğe Bağlı Özellikler ad Tür: Dize Gerekli: Hayır Açıklama: router konsolunda gösterilen görünen ad Örnek: clientApp.0.name=Router Console args Tür: Dize (boşluk veya sekme ile ayrılmış) Gerekli: Hayır Açıklama: Ana sınıfın kurucusuna veya main() yöntemine geçirilen argümanlar Tırnak kullanımı: Boşluk veya sekme içeren argümanlar ' veya \u0026quot; ile tırnak içine alınabilir Örnek: clientApp.0.args=-d $CONFIG/eepsite gecikme Tür: Tamsayı (saniye) Gerekli: Hayır Varsayılan: 120 Açıklama: İstemciyi başlatmadan önce beklenecek saniye sayısı Geçersiz kılmalar: onBoot=true tarafından geçersiz kılınır (gecikmeyi 0\u0026rsquo;a ayarlar) Özel Değerler: \u0026lt; 0: router RUNNING durumuna ulaşana kadar bekler, sonra yeni bir iş parçacığında hemen başlatır = 0: Aynı iş parçacığında hemen çalıştırır (istisnalar konsola iletilir) \u0026gt; 0: Gecikmeden sonra yeni bir iş parçacığında başlatır (istisnalar kaydedilir, iletilmez) onBoot Tür: Boolean Gerekli: Hayır Varsayılan: false Açıklama: Gecikmeyi 0\u0026rsquo;a zorlar, açıkça belirtilen gecikme ayarını geçersiz kılar Kullanım Durumu: Kritik servisleri router önyüklemesinde hemen başlat startOnLoad Tür: Boolean Gerekli: Hayır Varsayılan: true Açıklama: İstemcinin hiç başlatılıp başlatılmayacağı Kullanım Durumu: Yapılandırmayı kaldırmadan istemcileri devre dışı bırakma Eklentiye Özel Özellikler Bu özellikler yalnızca eklentiler tarafından kullanılır (çekirdek istemciler tarafından değil):\nstopargs (durdurma argümanları) Tür: Dize (boşluk veya sekme ile ayrılmış) Açıklama: İstemciyi durdurmak için iletilen argümanlar Değişken Yerine Koyma: Evet (aşağıya bakın) uninstallargs Tür: Dize (boşluk veya sekme ile ayrılmış) Açıklama: İstemciyi kaldırma işlemine iletilen argümanlar Değişken yerine koyma: Evet (aşağıya bakın) sınıf yolu Tür: String (virgülle ayrılmış yollar) Açıklama: İstemci için ek classpath öğeleri Değişken ikamesi: Evet (aşağıya bakın) Değişken Yerine Koyma (Yalnızca Eklentiler) Aşağıdaki değişkenler, eklentiler için args, stopargs, uninstallargs, ve classpath içinde yerine konur:\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 **Not**: Değişken yerine koyma yalnızca eklentiler için uygulanır, çekirdek istemcilerde uygulanmaz. İstemci Türleri Yönetilen İstemciler Kurucu, RouterContext ve ClientAppManager parametreleriyle çağrılır İstemci, ClientApp arayüzünü uygulamalıdır Yaşam döngüsü router tarafından kontrol edilir Dinamik olarak başlatılabilir, durdurulabilir ve yeniden başlatılabilir Yönetilmeyen İstemciler main(String[] args) metodu çağrılır Ayrı bir iş parçacığında çalıştırılır Yaşam döngüsü router tarafından yönetilmez Eski istemci türü Örnek Yapılandırma # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true Günlükleyici Yapılandırması (logger.config) Konum: $I2P_CONFIG_DIR/logger.config Yapılandırma Arayüzü: Router konsolunda /configlogging\nÖzellikler Referansı Konsol Arabellek Yapılandırması logger.consoleBufferSize Tür: Tamsayı Varsayılan: 20 Açıklama: Konsolda arabelleğe alınacak en fazla günlük mesajı sayısı Aralık: 1-1000 önerilir Tarih ve Saat Biçimlendirme logger.dateFormat Tür: String (SimpleDateFormat deseni) Varsayılan: Sistem yerel ayarından Örnek: HH:mm:ss.SSS Belgelendirme: Java SimpleDateFormat Günlük Seviyeleri logger.defaultLevel Tür: Enum (numaralandırma) Varsayılan: ERROR Değerler: CRIT, ERROR, WARN, INFO, DEBUG Açıklama: Tüm sınıflar için varsayılan günlükleme düzeyi logger.minimumOnScreenLevel Tür: Enum (numaralandırma) Varsayılan: CRIT Değerler: CRIT, ERROR, WARN, INFO, DEBUG Açıklama: Ekranda gösterilen iletiler için en düşük düzey logger.record.{class} Tür: Enum Değerler: CRIT, ERROR, WARN, INFO, DEBUG Açıklama: Sınıf başına günlükleme düzeyi geçersiz kılma Örnek: logger.record.net.i2p.router.transport.udp=DEBUG Görüntüleme Seçenekleri logger.displayOnScreen Tür: Boolean (mantıksal tür) Varsayılan: true Açıklama: Günlük iletilerinin konsol çıktısında gösterilip gösterilmeyeceği logger.dropDuplicates Tür: Boolean (mantıksal) Varsayılan: true Açıklama: Ardışık yinelenen günlük iletilerini yoksay logger.dropOnOverflow Tür: Boolean Varsayılan: false Açıklama: Arabellek dolu olduğunda mesajları düşür (bloklayıcı bekleme yerine) Boşaltma Davranışı logger.flushInterval Tür: Tamsayı (saniye) Varsayılan: 29 İtibaren: Sürüm 0.9.18 Açıklama: Günlük arabelleğinin diske ne sıklıkla yazılacağı Biçim Yapılandırması logger.format Tür: String (karakter dizisi) Açıklama: Günlük iletisi biçim şablonu Biçim Karakterleri: d = tarih/saat c = sınıf adı t = iş parçacığı adı p = öncelik (günlük düzeyi) m = ileti Örnek: dctpm şunu üretir: [zaman damgası] [sınıf] [iş parçacığı] [düzey] ileti Sıkıştırma (Sürüm 0.9.56+) logger.gzip Tür: Boolean Varsayılan: false Şu sürümden beri: Sürüm 0.9.56 Açıklama: Döndürülen günlük dosyaları için gzip sıkıştırmasını etkinleştirir logger.minGzipSize Tür: Tamsayı (bayt) Varsayılan: 65536 Sürüm: 0.9.56\u0026rsquo;dan beri Açıklama: Sıkıştırmayı tetiklemek için minimum dosya boyutu (varsayılan 64 KB) Dosya Yönetimi logger.logBufferSize Tür: Tamsayı (bayt) Varsayılan: 1024 Açıklama: Boşaltmadan önce arabelleğe alınacak en fazla ileti sayısı logger.logFileName Tür: Dize (dosya yolu) Varsayılan: logs/log-@.txt Açıklama: Günlük dosyası adlandırma deseni (@ yerine döndürme numarası konur) logger.logFilenameOverride Tür: Dize (dosya yolu) Açıklama: Günlük dosya adını geçersiz kılma (döndürme desenini devre dışı bırakır) logger.logFileSize Tür: Dize (birimle birlikte boyut) Varsayılan: 10M Birimler: K (kilobayt), M (megabayt), G (gigabayt) Örnek: 50M, 1G logger.logRotationLimit Tür: Tamsayı Varsayılan: 2 Açıklama: En yüksek döndürme dosyası numarası (log-0.txt\u0026rsquo;den log-N.txt\u0026rsquo;ye kadar) Örnek Yapılandırma # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN Eklenti Yapılandırması Bireysel Eklenti Yapılandırması (plugins/*/plugin.config) Konum: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config Biçim: Standart I2P yapılandırma dosyası biçimi Belgeler: Eklenti Belirtimi Gerekli Özellikler ad Type: Dize Required: Evet Description: Eklentinin görünen adı Example: name=I2P Plugin Example anahtar Tür: Dize (genel anahtar) Zorunlu: Evet (SU3 ile imzalanmış eklentiler için belirtmeyin) Açıklama: İmzaları doğrulamak için eklentinin imzalama genel anahtarı Biçim: Base64 ile kodlanmış imzalama anahtarı imzalayan Tür: Dize Gerekli: Evet Açıklama: Eklenti imzalayıcısının kimliği Örnek: signer=user@example.i2p sürüm Tür: String (VersionComparator biçimi) Gerekli: Evet Açıklama: Güncelleme denetimi için eklenti sürümü Biçim: Semantik sürümleme veya özel karşılaştırılabilir biçim Örnek: version=1.2.3 Görüntü Özellikleri tarih Tip: Long (Unix zaman damgası milisaniye cinsinden) Açıklama: Eklentinin yayın tarihi yazar Tür: String Açıklama: Eklenti yazarının adı websiteURL Tür: String (URL) Açıklama: Eklenti web sitesi URL’si updateURL Tür: Dize (URL) Açıklama: Eklenti için güncelleme denetimi URL\u0026rsquo;si updateURL.su3 Tür: Dize (URL) Sürüm: 0.9.15\u0026rsquo;ten beri Açıklama: SU3 biçiminde güncelleme URL\u0026rsquo;si (tercih edilen) açıklama Tür: String Açıklama: İngilizce eklenti açıklaması description_{language} Tip: String Açıklama: Yerelleştirilmiş eklenti açıklaması Örnek: description_de=Deutsche Beschreibung lisans Tür: Dize Açıklama: Eklenti lisans tanımlayıcısı Örnek: license=Apache 2.0 Kurulum Özellikleri dont-start-at-install Tür: Boolean (mantıksal) Varsayılan: false Açıklama: Kurulumdan sonra otomatik başlamayı engeller router\u0026rsquo;ın yeniden başlatılması gerekiyor Tür: Boolean (mantıksal) Varsayılan: false Açıklama: Kurulumdan sonra router’ın yeniden başlatılmasını gerektirir yalnızca kurulum Tür: Boolean (mantıksal) Varsayılan: false Açıklama: Yalnızca bir kez yükle (güncelleme yok) yalnızca güncelleme Tür: Boolean Varsayılan: false Açıklama: Yalnızca mevcut kurulumu güncelle (sıfırdan kurulum yok) Örnek Eklenti Yapılandırması # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false Genel Eklenti Yapılandırması (plugins.config) Konum: $I2P_CONFIG_DIR/plugins.config Amaç: Yüklü eklentileri genel olarak etkinleştirmek/devre dışı bırakmak\nÖzellik Formatı plugin.{name}.startOnLoad=true|false {name}: plugin.config içindeki eklenti adı startOnLoad: router (yönlendirici) başlatılırken eklentinin başlatılıp başlatılmayacağı Örnek plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false Web Uygulamaları Yapılandırması (webapps.config) Konum: $I2P_CONFIG_DIR/webapps.config Amaç: Web uygulamalarını etkinleştirme/devre dışı bırakma ve yapılandırma\nÖzellik Biçimi webapps.{name}.startOnLoad Tür: Boolean Açıklama: router başlatıldığında web uygulamasının başlatılıp başlatılmayacağı Biçim: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath Tür: String (boşluk veya virgülle ayrılmış yollar) Açıklama: web uygulaması için ek classpath (sınıf yolu) öğeleri Biçim: webapps.{name}.classpath=[paths] Değişken Yerine Koyma Yollar aşağıdaki değişken ikamelerini destekler:\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps #### Sınıf Yolu Çözümlemesi Çekirdek web uygulamaları: Yollar $I2P/lib dizinine göredir Eklenti web uygulamaları: Yollar $CONFIG/plugins/{appname}/lib dizinine göredir Örnek Yapılandırma # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar Router Yapılandırması (router.config) Konum: $I2P_CONFIG_DIR/router.config Yapılandırma Arabirimi: router konsolu /configadvanced adresinde Amaç: Temel router ayarları ve ağ parametreleri\nYapılandırma Kategorileri Ağ Yapılandırması Bant genişliği ayarları:\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 Taşıma yapılandırması:\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true Router Davranışı # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 Konsol Yapılandırması # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true Zaman Yapılandırması # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org Not: Router yapılandırması kapsamlıdır. Tam özellik başvurusu için /configadvanced adresindeki router konsoluna bakın.\nUygulama Yapılandırma Dosyaları Adres Defteri Yapılandırması (addressbook/config.txt) Konum: $I2P_CONFIG_DIR/addressbook/config.txt Uygulama: SusiDNS Amaç: Ana makine adı çözümleme ve adres defteri yönetimi\nDosya Konumları router_addressbook Varsayılan: ../hosts.txt Açıklama: Ana adres defteri (sistem genelindeki ana bilgisayar adları) Biçim: Standart hosts dosyası biçimi privatehosts.txt Konum: $I2P_CONFIG_DIR/addressbook/privatehosts.txt Açıklama: Özel ana bilgisayar adı eşlemeleri Öncelik: En yüksek (diğer tüm kaynakları geçersiz kılar) userhosts.txt Konum: $I2P_CONFIG_DIR/addressbook/userhosts.txt Açıklama: Kullanıcı tarafından eklenen ana bilgisayar adı eşlemeleri Yönetim: SusiDNS arayüzü üzerinden hosts.txt Konum: $I2P_CONFIG_DIR/addressbook/hosts.txt Açıklama: İndirilen genel adres defteri Kaynak: Abonelik beslemeleri Adlandırma Hizmeti BlockfileNamingService (blok dosyası adlandırma hizmeti) (0.8.8\u0026rsquo;den beri varsayılan) Depolama biçimi: - Dosya: hostsdb.blockfile - Konum: $I2P_CONFIG_DIR/addressbook/ - Performans: hosts.txt\u0026rsquo;ye göre ~10x daha hızlı sorgular - Biçim: İkili veritabanı biçimi\nEski adlandırma hizmeti: - Biçim: Düz metin hosts.txt - Durum: Kullanımdan kaldırıldı ancak hâlâ destekleniyor - Kullanım Senaryosu: El ile düzenleme, sürüm kontrolü\nAna Bilgisayar Adı Kuralları I2P ana makine adları şunlara uymalıdır:\nTLD (üst düzey alan adı) gereksinimi: Sonu .i2p ile bitmelidir Maksimum uzunluk: Toplam 67 karakter Karakter kümesi: [a-z], [0-9], . (nokta), - (tire) Büyük/küçük harf: Yalnızca küçük harf Başlangıç kısıtlamaları: . veya - ile başlayamaz Yasak kalıplar: .., .- veya -. içeremez (0.6.1.33 sürümünden beri) Ayrılmış: Base32 ana bilgisayar adları *.b32.i2p (base32.b32.i2p\u0026rsquo;nin 52 karakteri) Geçerli Örnekler example.i2p my-site.i2p test.example.i2p site123.i2p Geçersiz Örnekler example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long Abonelik Yönetimi subscriptions.txt Konum: $I2P_CONFIG_DIR/addressbook/subscriptions.txt Biçim: Her satırda bir URL Varsayılan: http://i2p-projekt.i2p/hosts.txt Abonelik Besleme Biçimi (0.9.26 sürümünden beri) Meta veriler içeren gelişmiş besleme biçimi:\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 Üstveri özellikleri: - added: Ana makine adının eklendiği tarih (YYYYMMDD biçimi) - src: Kaynak tanımlayıcısı - sig: İsteğe bağlı imza\nGeriye dönük uyumluluk: Basit hostname=destination biçimi hâlâ desteklenmektedir.\nÖrnek Yapılandırma # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false I2PSnark Yapılandırması (i2psnark.config.d/i2psnark.config) Konum: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config Uygulama: I2PSnark BitTorrent istemcisi Yapılandırma Arayüzü: http://127.0.0.1:7657/i2psnark adresindeki Web arayüzü\nDizin Yapısı $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... Ana Yapılandırma (i2psnark.config) Asgari varsayılan yapılandırma:\ni2psnark.dir=i2psnark Web arayüzü aracılığıyla yönetilen ek özellikler:\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 Bireysel Torrent Yapılandırması Konum: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config Biçim: Torrent başına ayarlar Yönetim: Otomatik (web arayüzü aracılığıyla)\nÖzellikler şunları içerir: - Torrent\u0026rsquo;e özgü yükleme/indirme ayarları - Dosya öncelikleri - İzleyici bilgileri - Eş sınırları\nNot: Torrent yapılandırmaları öncelikle web arayüzü üzerinden yönetilir. Elle düzenleme önerilmez.\nTorrent Verilerinin Düzenlenmesi Veri depolama, yapılandırmadan ayrıdır:\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs I2PTunnel Yapılandırması (i2ptunnel.config) Konum: $I2P_CONFIG_DIR/i2ptunnel.config (eski) veya $I2P_CONFIG_DIR/i2ptunnel.config.d/ (modern) Yapılandırma Arayüzü: Router konsolu /i2ptunnel adresinde Biçim Değişikliği: Sürüm 0.9.42 (Ağustos 2019)\nDizin Yapısı (Sürüm 0.9.42+) 0.9.42 sürümünden itibaren, varsayılan i2ptunnel.config dosyası otomatik olarak bölünür:\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) Kritik Biçim Farkı: - Monolitik biçim: Özellikler tunnel.N. önekiyle başlar - Bölünmüş biçim: Özellikler önekli değildir (örn., description=, tunnel.0.description= değil)\nGeçiş Davranışı 0.9.42\u0026rsquo;ye yükselttikten sonra ilk çalıştırmada: 1. Mevcut i2ptunnel.config okunur 2. Bireysel tunnel yapılandırmaları i2ptunnel.config.d/ içinde oluşturulur 3. Özelliklerin ön ekleri ayrılmış dosyalarda kaldırılır 4. Özgün dosya yedeklenir 5. Geriye dönük uyumluluk için eski biçim hâlâ desteklenir\nYapılandırma Bölümleri I2PTunnel yapılandırması, aşağıdaki I2PTunnel Yapılandırma Başvurusu bölümünde ayrıntılı olarak belgelenmiştir. Özellik açıklamaları hem monolitik (tunnel.N.property) hem de bölünmüş (property) biçimler için geçerlidir.\nI2PTunnel Yapılandırma Referansı Bu bölüm, tüm I2PTunnel yapılandırma özellikleri için kapsamlı bir teknik başvuru sağlar. Özellikler bölünmüş biçimde (tunnel.N. ön eki olmadan) gösterilir. Monolitik biçim için, N\u0026rsquo;in tunnel numarası olduğu tunnel.N. ön ekini tüm özelliklerin başına ekleyin.\nÖnemli: tunnel.N.option.i2cp.* olarak tanımlanan özellikler I2PTunnel içinde uygulanır ve I2CP protokolü veya SAM API gibi diğer arayüzler üzerinden DESTEKLENMEZ.\nTemel Özellikler tunnel.N.description (açıklama) Tür: Dize Bağlam: Tüm tunnels Açıklama: Kullanıcı arayüzünde görüntülemek için insan tarafından okunabilir tunnel açıklaması Örnek: description=HTTP Proxy for outproxy access tunnel.N.name (ad) Tür: Dize Bağlam: Tüm tunnel\u0026rsquo;ler Gerekli: Evet Açıklama: Benzersiz tunnel tanımlayıcısı ve görünen ad Örnek: name=I2P HTTP Proxy tunnel.N.type (tip) Tür: Enum Bağlam: Tüm tunnel\u0026rsquo;lar Gerekli: Evet Değerler: client - Genel amaçlı istemci tunnel httpclient - HTTP proxy istemcisi ircclient - IRC istemci tunnel socksirctunnel - SOCKS IRC proxy sockstunnel - SOCKS proxy (sürüm 4, 4a, 5) connectclient - CONNECT proxy istemcisi streamrclient - Streamr istemcisi server - Genel amaçlı sunucu tunnel httpserver - HTTP sunucu tunnel ircserver - IRC sunucu tunnel httpbidirserver - Çift yönlü HTTP sunucusu streamrserver - Streamr sunucusu tunnel.N.interface (arayüz) Tür: Dize (IP adresi veya ana makine adı) Bağlam: Yalnızca Client tunnels (istemci tünelleri) Varsayılan: 127.0.0.1 Açıklama: Gelen bağlantılar için bağlanılacak yerel arayüz Güvenlik Notu: 0.0.0.0 adresine bağlamak uzak bağlantılara izin verir Örnek: interface=127.0.0.1 tunnel.N.listenPort (listenPort) Tür: Tamsayı Bağlam: Yalnızca Client tunnels Aralık: 1-65535 Açıklama: İstemci bağlantıları için dinlenecek yerel bağlantı noktası Örnek: listenPort=4444 tunnel.N.targetHost (targetHost) Tür: String (IP adresi veya ana bilgisayar adı) Bağlam: Yalnızca sunucu tunnel\u0026rsquo;ları Açıklama: Bağlantıların iletileceği yerel sunucu Örnek: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) Tür: Tamsayı Bağlam: Yalnızca sunucu tunnels Aralık: 1-65535 Açıklama: Bağlanılacak targetHost üzerindeki port Örnek: targetPort=80 tunnel.N.targetDestination (targetDestination) Tür: Dize (virgül veya boşlukla ayrılmış hedefler) Bağlam: Yalnızca client tunnels Biçim: destination[:port][,destination[:port]] Açıklama: Bağlanılacak I2P hedef(ler)i Örnekler: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) Tür: String (IP adresi veya ana makine adı) Varsayılan: 127.0.0.1 Açıklama: I2P router I2CP arayüz adresi Not: router bağlamında çalışırken yok sayılır Örnek: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) Tür: Tamsayı Varsayılan: 7654 Aralık: 1-65535 Açıklama: I2P router I2CP bağlantı noktası Not: router bağlamında çalışırken yok sayılır Örnek: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) Tür: Boolean (mantıksal) Varsayılan: true Açıklama: I2PTunnel yüklendiğinde tunnel\u0026rsquo;in başlatılıp başlatılmayacağı Örnek: startOnLoad=true Proxy Yapılandırması tunnel.N.proxyList (proxyList) Tür: String (virgülle veya boşlukla ayrılmış ana makine adları) Bağlam: Yalnızca HTTP ve SOCKS vekil sunucuları Açıklama: outproxy (dış vekil sunucu) ana makinelerinin listesi Örnek: proxyList=outproxy.example.i2p,backup.example.i2p Sunucu Yapılandırması tunnel.N.privKeyFile (privKeyFile) Tür: Dize (dosya yolu) Bağlam: Sunucular ve kalıcı istemci tunnels Açıklama: Kalıcı hedefin özel anahtarlarını içeren dosya Yol: Mutlak veya I2P yapılandırma dizinine göreli Örnek: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) Tür: String (ana bilgisayar adı) Bağlam: Yalnızca HTTP sunucuları Varsayılan: Hedefin Base32 ana bilgisayar adı Açıklama: Yerel sunucuya iletilen Host başlığı değeri Örnek: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) Tür: Dize (ana bilgisayar adı) Bağlam: Yalnızca HTTP sunucuları Açıklama: Belirli bir gelen bağlantı noktası için sanal ana bilgisayar adını geçersiz kılma Kullanım Durumu: Birden çok siteyi farklı bağlantı noktalarında barındırma Örnek: spoofedHost.8080=site1.example.i2p İstemciye Özgü Seçenekler tunnel.N.sharedClient (sharedClient) Tür: Boolean (doğru/yanlış) Bağlam: Yalnızca istemci tunnel\u0026rsquo;ları Varsayılan: false Açıklama: Birden fazla istemcinin bu tunnel\u0026rsquo;ı paylaşmasına izin verilip verilmediği Örnek: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) Tür: Boolean Bağlam: Yalnızca Client tunnels Varsayılan: false Açıklama: Yeniden başlatmalar arasında hedef anahtarlarını saklayıp yeniden kullanır Çakışma: i2cp.newDestOnResume=true ile birlikte kullanılamaz Örnek: option.persistentClientKey=true I2CP Seçenekleri (I2PTunnel Uygulaması) Önemli: Bu özellikler option.i2cp. önekiyle başlar, ancak I2PTunnel içinde uygulanır, I2CP protokol katmanında değil. I2CP veya SAM API\u0026rsquo;leri üzerinden kullanılamazlar.\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) Tür: Boolean Bağlam: Yalnızca istemci tunnels (tünel) için Varsayılan: false Açıklama: İlk bağlantıya kadar tunnel oluşturmayı geciktir Kullanım Durumu: Seyrek kullanılan tunnels için kaynak tasarrufu Örnek: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) Tür: Boolean Bağlam: Yalnızca istemci tunnel\u0026rsquo;ları Varsayılan: false Gerektirir: i2cp.closeOnIdle=true Çakışma: persistentClientKey=true ile birlikte kullanılamaz Açıklama: Boşta kalma zaman aşımından sonra yeni Destination (uç nokta kimliği) oluştur Örnek: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) Tür: Dize (base64 ile kodlanmış anahtar) Bağlam: Yalnızca sunucu tunnel\u0026rsquo;ları Açıklama: Kalıcı özel leaseset (I2P\u0026rsquo;de bir hedefin erişim bilgilerini içeren kayıt) şifreleme anahtarı Kullanım Senaryosu: Yeniden başlatmalar arasında şifrelenmiş leaseset tutarlılığını sürdürmek Örnek: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) Tür: String (sigtype:base64) Bağlam: Yalnızca sunucu tunnels Biçim: sigtype:base64key Açıklama: Kalıcı leaseSet (I2P\u0026rsquo;de bir destinasyonun bağlantı bilgileri kümesi) imzalama özel anahtarı Örnek: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... Sunucuya Özel Seçenekler tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) Tür: Boolean (mantıksal) Bağlam: Yalnızca Server tunnels için Varsayılan: false Açıklama: Her uzak I2P hedefi için benzersiz yerel IP kullanın Kullanım Senaryosu: Sunucu günlüklerinde istemci IP\u0026rsquo;lerini izlemek Güvenlik Notu: Anonimliği azaltabilir Örnek: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) Tür: String (hostname:port) Bağlam: Yalnızca sunucu tunnel\u0026rsquo;ları Açıklama: Gelen NNNN bağlantı noktası için targetHost/targetPort değerlerini geçersiz kıl Kullanım Senaryosu: Farklı yerel hizmetlere bağlantı noktası tabanlı yönlendirme Örnek: option.targetForPort.8080=localhost:8080 İş Parçacığı Havuzu Yapılandırması tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) Tür: Boolean Bağlam: Yalnızca sunucu tunnels Varsayılan: true Açıklama: Bağlantı işleme için iş parçacığı havuzu kullan Not: Standart sunucular için her zaman false (yok sayılır) Örnek: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) Tür: Tamsayı Bağlam: Yalnızca sunucu tunnels Varsayılan: 65 Açıklama: Maksimum iş parçacığı havuzu boyutu Not: Standart sunucular için yok sayılır Örnek: option.i2ptunnel.blockingHandlerCount=100 HTTP İstemci Seçenekleri tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) Tür: Boolean Bağlam: Yalnızca HTTP istemcileri için Varsayılan: false Açıklama: .i2p adreslerine yapılan SSL bağlantılarına izin verir Örnek: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) Tür: Boolean Bağlam: Yalnızca HTTP istemcileri Varsayılan: false Açıklama: Proxy yanıtlarındaki address helper bağlantılarını (adres eklemeye yardımcı bağlantılar) devre dışı bırakır Örnek: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) Tür: Dize (virgülle veya boşlukla ayrılmış URL\u0026rsquo;ler) Bağlam: Yalnızca HTTP istemcileri Açıklama: Ana bilgisayar adı çözümlemesi için jump server (atlama sunucusu) URL\u0026rsquo;leri Örnek: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) Tür: Boolean Bağlam: Yalnızca HTTP istemcileri Varsayılan: false Açıklama: Accept-* başlıklarını iletir (Accept ve Accept-Encoding hariç) Örnek: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) Tür: Boolean (mantıksal) Bağlam: Yalnızca HTTP istemcileri Varsayılan: false Açıklama: Referer üstbilgilerini proxy üzerinden iletir Gizlilik Notu: Bilgi sızdırabilir Örnek: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) Tür: Boolean Bağlam: Yalnızca HTTP istemcileri Varsayılan: false Açıklama: User-Agent başlıklarını vekil sunucu üzerinden geçirir Gizlilik Notu: Tarayıcı bilgilerini sızdırabilir Örnek: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) Tür: Boolean (mantıksal) Bağlam: Yalnızca HTTP istemcileri Varsayılan: false Açıklama: Via başlıklarını proxy üzerinden geçirir Örnek: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) Tür: Dize (virgül veya boşlukla ayrılmış hedefler) Bağlam: Yalnızca HTTP istemcileri Açıklama: HTTPS için ağ içi SSL outproxy\u0026rsquo;leri Örnek: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) Tür: Boolean Bağlam: Yalnızca HTTP istemcileri için Varsayılan: true Açıklama: Kayıtlı yerel outproxy (çıkış vekil sunucusu) eklentilerini kullanır Örnek: option.i2ptunnel.useLocalOutproxy=true HTTP İstemci Kimlik Doğrulaması tunnel.N.option.proxyAuth (option.proxyAuth) Tür: Enum (numaralandırma) Bağlam: Yalnızca HTTP istemcileri Varsayılan: false Değerler: true, false, basic, digest Açıklama: Proxy erişimi için yerel kimlik doğrulaması gerektirir Not: true, basic ile eşdeğerdir Örnek: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) Tür: String (32 karakterlik küçük harfli onaltılık) Bağlam: Yalnızca HTTP istemcileri Gerektirir: proxyAuth=basic veya proxyAuth=digest Açıklama: USER kullanıcısının parolasının MD5 özeti Kullanımdan kaldırıldı: Bunun yerine SHA-256 kullanın (0.9.56+) Örnek: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) Tür: Dize (64 karakterlik küçük harfli onaltılık) Bağlam: Yalnızca HTTP istemcileri Gerektirir: proxyAuth=digest İtibaren: Sürüm 0.9.56 Standart: RFC 7616 Açıklama: USER kullanıcısının parolasının SHA-256 özeti Örnek: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 Dış Proxy Kimlik Doğrulaması tunnel.N.option.outproxyAuth (option.outproxyAuth) Tür: Boolean Bağlam: Yalnızca HTTP istemcileri Varsayılan: false Açıklama: Kimlik doğrulama bilgilerini outproxy\u0026rsquo;ye (I2P dış çıkış proxy\u0026rsquo;si) gönder Örnek: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) Tür: Dize Bağlam: Yalnızca HTTP istemcileri Gerektirir: outproxyAuth=true Açıklama: outproxy (harici proxy) kimlik doğrulaması için kullanıcı adı Örnek: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) Tür: String Bağlam: Yalnızca HTTP istemcileri Gerektirir: outproxyAuth=true Açıklama: outproxy kimlik doğrulaması için parola (I2P’de dış ağlara erişim sağlayan vekil sunucu anlamındaki outproxy) Güvenlik: Düz metin olarak saklanır Örnek: option.outproxyPassword=secret SOCKS İstemci Seçenekleri tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) Tür: Dize (virgülle veya boşlukla ayrılmış hedefler) Bağlam: Yalnızca SOCKS istemcileri Açıklama: Belirtilmemiş portlar için ağ içi outproxy\u0026rsquo;ler (I2P ağında erişilebilen çıkış proxy\u0026rsquo;leri) Örnek: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) Tür: Dize (virgülle veya boşlukla ayrılmış destinations (I2P adresleri)) Bağlam: Yalnızca SOCKS istemcileri Açıklama: Özellikle NNNN bağlantı noktası için ağ içi outproxies (I2P ağından açık internete çıkış sağlayan vekil sunucular) Örnek: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) Tür: Enum (numaralandırma) Bağlam: Yalnızca SOCKS istemcileri Varsayılan: socks İtibaren: Sürüm 0.9.57 Değerler: socks, connect (HTTPS) Açıklama: Yapılandırılmış outproxy (dış vekil) türü Örnek: option.outproxyType=connect HTTP Sunucusu Seçenekleri tunnel.N.option.maxPosts (option.maxPosts) Tür: Tamsayı Bağlam: Yalnızca HTTP sunucuları Varsayılan: 0 (sınırsız) Açıklama: postCheckTime başına tek bir hedeften en fazla POST sayısı Örnek: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) Tür: Tamsayı Bağlam: Yalnızca HTTP sunucuları Varsayılan: 0 (sınırsız) Açıklama: postCheckTime başına, tüm Destinations (I2P hedef kimliği) genelinde toplam en fazla POST isteği sayısı Örnek: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) Tür: Tamsayı (saniye) Bağlam: Yalnızca HTTP sunucuları Varsayılan: 300 Açıklama: POST sınırlarını denetlemek için zaman aralığı Örnek: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) Tür: Tamsayı (saniye) Bağlam: Yalnızca HTTP sunucuları için Varsayılan: 1800 Açıklama: Tek bir hedef için maxPosts aşıldığında yasaklama süresi Örnek: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) Tür: Tamsayı (saniye) Bağlam: Yalnızca HTTP sunucuları Varsayılan: 600 Açıklama: maxTotalPosts sınırı aşıldığında yasaklama süresi Örnek: option.postTotalBanTime=1200 HTTP Sunucusu Güvenlik Seçenekleri tunnel.N.option.rejectInproxy (option.rejectInproxy) Tür: Boolean Bağlam: Yalnızca HTTP sunucuları Varsayılan: false Açıklama: Görünüşe göre bir inproxy (I2P ağına girişi sağlayan ara sunucu) üzerinden gelen bağlantıları reddet Örnek: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) Tür: Mantıksal Bağlam: Yalnızca HTTP sunucuları Varsayılan: false Sürüm: 0.9.25\u0026rsquo;ten itibaren Açıklama: Referer başlığı içeren bağlantıları reddeder Örnek: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) Tür: Boolean Bağlam: Yalnızca HTTP sunucuları için Varsayılan: false Başlangıç: Sürüm 0.9.25 Gerektirir: userAgentRejectList özelliği Açıklama: Eşleşen User-Agent\u0026rsquo;a sahip bağlantıları reddeder Örnek: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) Tür: Dize (virgülle ayrılmış eşleşme dizeleri) Bağlam: Yalnızca HTTP sunucuları Sürüm: Sürüm 0.9.25\u0026rsquo;ten beri Büyük/küçük harf: Büyük/küçük harfe duyarlı eşleştirme Özel: \u0026ldquo;none\u0026rdquo; (0.9.33\u0026rsquo;ten beri) boş User-Agent (kullanıcı aracısı) ile eşleşir Açıklama: Reddedilecek User-Agent kalıplarının listesi Örnek: option.userAgentRejectList=Mozilla,Opera,none IRC Sunucusu Seçenekleri tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) Type: Dize (ana makine adı deseni) Context: Yalnızca IRC sunucuları için Default: %f.b32.i2p Tokens: %f = Tam base32 hedef karması %c = Gizlenmiş hedef karması (bkz. cloakKey) Description: IRC sunucusuna gönderilen ana makine adı biçimi Example: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) Tür: Dize (parola tümcesi) Bağlam: Yalnızca IRC sunucuları için Varsayılan: Oturum başına rastgele Kısıtlamalar: Tırnak işareti veya boşluk içeremez Açıklama: Tutarlı ana makine adı gizlemesi için parola tümcesi Kullanım Durumu: Yeniden başlatmalar/sunucular arasında kalıcı kullanıcı takibi Örnek: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) Tür: Enum (numaralandırma) Bağlam: Yalnızca IRC sunucuları için Varsayılan: user Değerler: user, webirc Açıklama: IRC sunucusu için kimlik doğrulama yöntemi Örnek: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) Tür: String (parola) Bağlam: Yalnızca IRC sunucuları Gerektirir: method=webirc Kısıtlamalar: Tırnak işareti veya boşluk içeremez Açıklama: WEBIRC protokolü kimlik doğrulaması için parola Örnek: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) Tür: Dize (IP adresi) Bağlam: Yalnızca IRC sunucuları için Gerektirir: method=webirc Açıklama: WEBIRC protokolü için spoofed (sahte) IP adresi Örnek: option.ircserver.webircSpoofIP=10.0.0.1 SSL/TLS Yapılandırması tunnel.N.option.useSSL (option.useSSL) Tür: Boolean Varsayılan: false Bağlam: Tüm tunnels Davranış: Sunucular: Yerel sunucu bağlantıları için SSL kullan İstemciler: Yerel istemciler için SSL gerektir Örnek: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) Tür: Dize (dosya yolu) Bağlam: Yalnızca istemci tunnels Varsayılan: i2ptunnel-(random).ks Yol: Mutlak değilse $(I2P_CONFIG_DIR)/keystore/ dizinine göre göreli Otomatik oluşturulur: Mevcut değilse oluşturulur Açıklama: SSL özel anahtarını içeren keystore dosyası Örnek: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) Tür: String (parola) Bağlam: Yalnızca Client tunnels Varsayılan: changeit Otomatik oluşturulur: Yeni bir keystore (anahtar deposu) oluşturulursa rastgele parola Açıklama: SSL keystore parolası Örnek: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) Tür: String (takma ad) Bağlam: Yalnızca istemci tunnels Otomatik olarak oluşturulur: Yeni bir anahtar üretildiğinde oluşturulur Açıklama: Anahtar deposundaki (keystore) özel anahtar için takma ad Örnek: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) Tür: String (parola) Bağlam: Yalnızca istemci tunnel\u0026rsquo;ları Otomatik oluşturulur: Yeni anahtar oluşturulursa rastgele parola Açıklama: anahtar deposu (keystore) içindeki özel anahtar için parola Örnek: option.keyPassword=keypass123 Genel I2CP ve Akış Seçenekleri Tüm tunnel.N.option.* özellikleri (yukarıda özellikle belgelenmemiş olanlar), tunnel.N.option. öneki çıkarılmış olarak I2CP arayüzüne ve akış kitaplığına iletilir.\nÖnemli: Bunlar, I2PTunnel\u0026rsquo;e özgü seçeneklerden ayrıdır. Bkz: - I2CP Spesifikasyonu - Streaming Library Spesifikasyonu Örnek akış seçenekleri:\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 Tam Tunnel Örneği # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 Sürüm Geçmişi ve Özellik Zaman Çizelgesi Sürüm 0.9.10 (2013) Özellik: Yapılandırma dosyalarında boş değer desteği - Boş değerlere sahip anahtarlar (key=) artık destekleniyor - Önceden yok sayılıyor veya ayrıştırma hatalarına neden oluyordu\nSürüm 0.9.18 (2015) Özellik: Logger tampon boşaltma aralığı yapılandırması - Özellik: logger.flushInterval (varsayılan 29 saniye) - Kabul edilebilir günlük gecikmesini korurken disk G/Ç\u0026rsquo;sini azaltır\nSürüm 0.9.23 (Kasım 2015) Önemli Değişiklik: En az Java 7 gereklidir - Java 6 desteği sona erdi - Güvenlik güncellemelerinin devamı için zorunludur\nSürüm 0.9.25 (2015) Özellikler: HTTP sunucusu güvenlik seçenekleri - tunnel.N.option.rejectReferer - Referer başlığı olan bağlantıları reddet - tunnel.N.option.rejectUserAgents - Belirli User-Agent başlıklarını reddet - tunnel.N.option.userAgentRejectList - Reddedilecek User-Agent kalıpları - Kullanım Senaryosu: crawler’ların (tarama botlarının) ve istenmeyen istemcilerin etkisini azaltmak\nSürüm 0.9.33 (Ocak 2018) Özellik: Geliştirilmiş User-Agent filtreleme - userAgentRejectList dizesi \u0026ldquo;none\u0026rdquo; boş User-Agent ile eşleşir - i2psnark, i2ptunnel, streaming, SusiMail için ek hata düzeltmeleri\nSürüm 0.9.41 (2019) Kullanımdan Kaldırma: BOB Protokolü Android\u0026rsquo;den kaldırıldı - Android kullanıcıları SAM veya I2CP\u0026rsquo;ye geçmelidir\nSürüm 0.9.42 (Ağustos 2019) Önemli Değişiklik: Yapılandırma dosyalarının bölünmesi - clients.config bölünerek clients.config.d/ dizin yapısına taşındı - i2ptunnel.config bölünerek i2ptunnel.config.d/ dizin yapısına taşındı - Yükseltmeden sonraki ilk çalıştırmada otomatik geçiş - Modüler paketleme ve eklenti yönetimini etkinleştirir - Eski monolitik biçim hala destekleniyor\nEk Özellikler: - SSU performans iyileştirmeleri - Ağlar arası geçişin önlenmesi (Proposal 147) - Şifreleme türleri için başlangıç desteği\nSürüm 0.9.56 (2021) Özellikler: Güvenlik ve günlük kaydı iyileştirmeleri - logger.gzip - Döndürülen günlükler için Gzip sıkıştırması (varsayılan: false) - logger.minGzipSize - Sıkıştırma için en düşük boyut (varsayılan: 65536 bayt) - tunnel.N.option.proxy.auth.USER.sha256 - SHA-256 özet kimlik doğrulaması (RFC 7616) - Güvenlik: Özet kimlik doğrulaması için MD5\u0026rsquo;in yerini SHA-256 alır\nSürüm 0.9.57 (Ocak 2023) Özellik: SOCKS outproxy (I2P dışa çıkış vekil sunucusu) türü yapılandırması - tunnel.N.option.outproxyType - outproxy türünü seçin (socks|connect) - Varsayılan: socks - HTTPS outproxy\u0026rsquo;ler için HTTPS CONNECT desteği\nSürüm 2.6.0 (Temmuz 2024) Geriye dönük uyumsuz değişiklik: I2P-over-Tor engellendi (Tor üzerinden I2P kullanımı) - Tor çıkış düğümü IP adreslerinden gelen bağlantılar artık reddediliyor - Gerekçe: I2P performansını düşürür, Tor çıkış düğümlerinin kaynaklarını boşa harcar - Etkisi: Tor çıkış düğümleri üzerinden I2P\u0026rsquo;ye erişen kullanıcılar engellenecek - Çıkış olmayan röleler ve Tor istemcileri etkilenmeyecek\nSürüm 2.10.0 (Eylül 2025 - Güncel) Öne Çıkan Özellikler: - Kuantum sonrası kriptografi mevcut (isteğe bağlı olarak Hidden Service Manager (Gizli Servis Yöneticisi) üzerinden etkinleştirilebilir) - UDP izleyici desteği I2PSnark için, izleyici yükünü azaltmak üzere - Hidden Mode (Gizli Mod) kararlılığı iyileştirmeleri, RouterInfo tükenmesini azaltmak için - Yoğun router’lar için ağ iyileştirmeleri - Geliştirilmiş UPnP/NAT geçişi - Agresif leaseSet kaldırma ile NetDB iyileştirmeleri - router olayları için gözlemlenebilirliğin azaltılması\nYapılandırma: Yeni yapılandırma özellikleri eklenmedi\nYaklaşan Kritik Değişiklik: Bir sonraki sürüm (muhtemelen 2.11.0 veya 3.0.0) Java 17 veya daha yenisini gerektirecek\nKullanımdan Kaldırmalar ve Geriye Dönük Uyumluluğu Bozan Değişiklikler Kritik Kullanımdan Kaldırmalar I2P-over-Tor Erişimi (Sürüm 2.6.0+) Durum: Temmuz 2024\u0026rsquo;ten beri BLOKLANDI Etkisi: Tor çıkış düğümü IP\u0026rsquo;lerinden gelen bağlantılar reddediliyor Gerekçe: Anonimlik açısından bir fayda sağlamadan I2P ağının performansını düşürüyor Etkiler: Yalnızca Tor çıkış düğümleri; röleler veya normal Tor istemcileri değil Alternatif: I2P veya Tor\u0026rsquo;u ayrı ayrı kullanın, birlikte kullanmayın MD5 Özet Kimlik Doğrulaması Durum: Kullanımdan kaldırıldı (SHA-256 kullanın) Özellik: tunnel.N.option.proxy.auth.USER.md5 Gerekçe: MD5 kriptografik olarak kırıldı Yerine geçen: tunnel.N.option.proxy.auth.USER.sha256 (0.9.56 sürümünden beri) Zaman çizelgesi: MD5 hâlâ destekleniyor ancak önerilmiyor Yapılandırma Mimarisindeki Değişiklikler Monolitik Yapılandırma Dosyaları (Sürüm 0.9.42+) Etkilenen: clients.config, i2ptunnel.config Durum: Bölünmüş dizin yapısı lehine kullanımdan kaldırıldı Geçiş: 0.9.42 yükseltmesinden sonraki ilk çalıştırmada otomatik Uyumluluk: Eski biçim hâlâ çalışır (geriye dönük uyumlu) Öneri: Yeni yapılandırmalar için bölünmüş biçimi kullanın Java Sürüm Gereksinimleri Java 6 Desteği Sona erdi: Sürüm 0.9.23 (Kasım 2015) Asgari: 0.9.23\u0026rsquo;ten beri Java 7 zorunlu Java 17 Gereksinimi (Yakında) Durum: KRİTİK YAKLAŞAN DEĞİŞİKLİK Hedef: 2.10.0’dan sonra çıkacak bir sonraki ana sürüm (muhtemelen 2.11.0 veya 3.0.0) Mevcut Minimum: Java 8 Gerekli Eylem: Java 17 geçişine hazırlanın Takvim: Sürüm notlarıyla duyurulacaktır Kaldırılan Özellikler BOB Protokolü (Android) Kaldırıldı: Sürüm 0.9.41 Platform: Yalnızca Android Alternatif: SAM veya I2CP protokolleri Masaüstü: BOB hâlâ masaüstü platformlarda mevcut Önerilen Geçişler Kimlik Doğrulama: MD5\u0026rsquo;ten SHA-256 digest (özet) kimlik doğrulamaya geçiş yapın Yapılandırma Biçimi: İstemciler ve tunnels için ayrılmış dizin yapısına geçin Java Çalışma Zamanı: Bir sonraki ana sürümden önce Java 17 yükseltmesini planlayın Tor Entegrasyonu: I2P\u0026rsquo;yi Tor çıkış düğümleri üzerinden yönlendirmeyin Kaynakça Resmi Dokümantasyon I2P Yapılandırma Şartnamesi - Yapılandırma dosyası biçimi için resmi şartname I2P Eklenti Şartnamesi - Eklenti yapılandırması ve paketleme I2P Ortak Yapılar - Tür Eşlemesi - Protokol veri serileştirme biçimi Java Properties Biçimi - Temel biçim şartnamesi Kaynak Kodu I2P Java Router Deposu - GitHub aynası I2P Geliştiricileri Gitea - Resmi I2P kaynak deposu DataHelper.java - Yapılandırma dosyası G/Ç gerçeklemesi Topluluk Kaynakları I2P Forum - Aktif topluluk tartışmaları ve destek I2P Website - Resmi proje web sitesi API Dokümantasyonu DataHelper JavaDoc - yapılandırma dosyası yöntemlerine ilişkin API dokümantasyonu Belirtim Durumu Son Spesifikasyon Güncellemesi: Ocak 2023 (Sürüm 0.9.57) Güncel I2P Sürümü: 2.10.0 (Eylül 2025) Teknik Doğruluk: Spesifikasyon 2.10.0 dahil olmak üzere doğruluğunu korumaktadır (geriye dönük uyumluluğu bozan değişiklik yok) Bakım: Yapılandırma formatı değiştirildiğinde güncellenen yaşayan bir belgedir ","description":"I2P router'ları ve istemcileri için yapılandırma seçenekleri ve biçimleri","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"Router Yapılandırması","url":"/tr/docs/specs/configuration/"},{"categories":null,"content":" Kullanımdan kaldırıldı: SAM v1 yalnızca tarihsel referans amaçlı tutulmaktadır. Yeni uygulamalar SAM v3 veya BOB kullanmalıdır. Orijinal köprü yalnızca DSA-SHA1 hedeflerini ve sınırlı bir seçenek kümesini destekler.\nKütüphaneler Java I2P kaynak ağacı hâlâ C, C#, Perl ve Python için eski dil bağlayıcılarını içeriyor. Bunlar artık bakımı yapılmıyor ve çoğunlukla arşivsel uyumluluk amacıyla dağıtılıyor.\nSürüm Müzakeresi İstemciler TCP üzerinden (varsayılan 127.0.0.1:7656) bağlanır ve şunları değiş tokuş eder:\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 Java I2P 0.9.14 itibarıyla MIN parametresi isteğe bağlıdır ve güncellenmiş köprülerde hem MIN hem de MAX tek haneli biçimleri (\u0026quot;3\u0026quot; vb.) kabul eder.\nOturum Oluşturma SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name, sam.keys içinde bir kayıt yükler veya oluşturur; TRANSIENT her zaman geçici bir Destination (hedef kimliği) oluşturur. STYLE, sanal akışları (TCP benzeri), imzalı datagramları veya ham datagramları seçer. DIRECTION yalnızca akış oturumları için geçerlidir; varsayılan olarak BOTH\u0026lsquo;tur. Ek anahtar/değer çiftleri I2CP seçenekleri olarak iletilir (örneğin, tunnels.quantityInbound=3). Köprü şu şekilde yanıt verir:\nSESSION STATUS RESULT=OK DESTINATION=name Hata durumları, DUPLICATED_DEST, I2P_ERROR veya INVALID_KEY değerlerinden birini ve isteğe bağlı bir mesaj döndürür.\nMesaj Formatları SAM mesajları, anahtar/değer çiftleri boşlukla ayrılmış, tek satırlı ASCII biçimindedir. Anahtarlar UTF‑8 kodlamasındadır; değerler boşluk içeriyorsa tırnak içine alınabilir. Kaçış (escaping) tanımlı değildir.\nİletişim türleri:\nAkışlar – I2P akış kütüphanesi aracılığıyla proxy edilir Yanıtlanabilir datagramlar – imzalı yükler (Datagram1) Ham datagramlar – imzasız yükler (Datagram RAW) 0.9.14\u0026rsquo;te Eklenen Seçenekler DEST GENERATE SIGNATURE_TYPE=... değerini kabul eder (Ed25519 vb.ne izin verir) HELLO VERSION MIN\u0026lsquo;i isteğe bağlı olarak değerlendirir ve tek basamaklı sürüm dizelerini kabul eder SAM v1 ne zaman kullanılmalı Yalnızca güncellenemeyen eski yazılımlarla birlikte çalışabilirlik amacıyla. Tüm yeni geliştirmeler için şunu kullanın:\nSAM v3 tam özellikli akış/datagram erişimi için BOB hedef yönetimi için (hala sınırlı, ancak daha modern özellikleri destekler) Kaynakça SAM v2 SAM v3 Datagram Belirtimi Akış Protokolü SAM v1, router\u0026rsquo;dan bağımsız uygulama geliştirme için temeli attı, ancak ekosistem ilerledi. Bu belgeyi bir başlangıç noktası olarak değil, uyumluluğa yönelik bir yardımcı kaynak olarak değerlendirin.\n","description":"Eski Simple Anonymous Messaging (Basit Anonim Mesajlaşma) protokolü (kullanımdan kaldırılmış)","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM v1","url":"/tr/docs/legacy/sam/"},{"categories":null,"content":" Kullanımdan kaldırıldı: SAM v2, I2P 0.6.1.31 ile birlikte sunuldu ve artık bakımı yapılmıyor. Yeni geliştirmeler için SAM v3 kullanın. v1\u0026rsquo;e göre v2\u0026rsquo;nin tek iyileştirmesi, tek bir SAM bağlantısı üzerinden çoğullanan birden çok soket desteğiydi.\nSürüm Notları Raporlanan sürüm dizesi \u0026ldquo;2.0\u0026rdquo; olarak kalır. 0.9.14\u0026rsquo;ten beri HELLO VERSION mesajı tek haneli MIN/MAX değerlerini kabul eder ve MIN parametresi isteğe bağlıdır. DEST GENERATE, SIGNATURE_TYPE için destek sağlar, bu sayede Ed25519 destinations (hedefler) oluşturulabilir. Oturum Temelleri SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] Her hedef yalnızca bir aktif SAM oturumuna sahip olabilir (akışlar, datagramlar veya ham). STYLE sanal akışları, imzalı datagramları veya ham datagramları seçer. Ek seçenekler I2CP\u0026rsquo;ye iletilir (örneğin, tunnels.quantityInbound=3). Yanıtlar v1\u0026rsquo;i yansıtır: SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY. Mesaj Kodlaması Boşluklarla ayrılmış key=value çiftlerinden oluşan satır tabanlı ASCII (değerler tırnak içine alınabilir). İletişim türleri v1 ile aynıdır:\nI2P streaming library üzerinden akışlar Yanıtlanabilir datagramlar (PROTO_DATAGRAM) Ham datagramlar (PROTO_DATAGRAM_RAW) Ne Zaman Kullanılır Yalnızca geçiş yapamayan eski istemciler için. SAM v3 şunları sunar:\nİkili hedef devri (DEST GENERATE BASE64) Alt oturumlar ve DHT desteği (v3.3) Daha iyi hata raporlaması ve seçenek müzakeresi Bkz.:\nSAM v1 SAM v3 Datagram API\u0026rsquo;si Akış Protokolü ","description":"Eski Simple Anonymous Messaging protokolü","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2","url":"/tr/docs/legacy/samv2/"},{"categories":null,"content":"SAM v3 (\u0026ldquo;Simple Anonymous Messaging\u0026rdquo;), harici uygulamaların router\u0026rsquo;ı kendilerine gömmeden I2P ağı ile iletişim kurmasına olanak tanıyan mevcut kararlı, router bağımsız API\u0026lsquo;dir. Akışlar, datagramlar ve ham mesajlar\u0026lsquo;a birleşik erişim sağlar ve Java dışı yazılımlar için standart köprü katmanı olmaya devam eder.\n1. Genel Bakış ve Amaç SAM v3, geliştiricilerin hafif bir TCP/UDP protokolü kullanarak herhangi bir dilde I2P uyumlu yazılım oluşturmasını sağlar. Router iç yapısını soyutlayarak, TCP (7656) ve UDP (7655) üzerinden minimal bir komut seti sunar. Hem Java I2P hem de i2pd, SAM v3 spesifikasyonunun alt kümelerini uygular, ancak i2pd 2025 itibariyle hala çoğu 3.2 ve 3.3 uzantısından yoksundur.\n2. Sürüm Geçmişi Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. ### İsimlendirme Notu Java I2P PRIMARY/SUBSESSION kullanır. i2pd ve I2P+ geriye dönük uyumluluk için eski MASTER/SUBSESSION terminolojisini kullanmaya devam eder. 3. Temel İş Akışı Sürüm Görüşmesi HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 Hedef Oluşturma DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512). I2P 0.9.15\u0026rsquo;ten itibaren şiddetle önerilir. Oturum Oluşturma SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4 X25519\u0026rsquo;dur (ECIES X25519 AEAD Ratchet) ve 0 uyumluluk için ElGamal yedektir. Tutarlılık için açık tünel miktarları: Java I2P varsayılanı 2, i2pd varsayılanı 5. Protokol İşlemleri STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 Temel mesaj türleri şunları içerir: STREAM CONNECT, STREAM ACCEPT, STREAM FORWARD, DATAGRAM SEND, RAW SEND, NAMING LOOKUP, DEST LOOKUP, PING, QUIT.\nZarif Kapatma QUIT 4. Uygulama Farklılıkları (Java I2P vs i2pd) Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 **Öneri:** Router'lar arası tutarlılığı sağlamak için tunnel miktarlarını her zaman açıkça belirtin. 5. Desteklenen Kütüphaneler (2025 Anlık Görünümü) Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance ## 6. Yaklaşan ve Yeni Özellikler (2024–2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ ## 7. Güvenlik ve Yapılandırma Notları SAM\u0026rsquo;ı yalnızca 127.0.0.1 adresine bağlayın. Kalıcı servisler için statik anahtarlarla PRIMARY oturumları kullanın. Özellik desteğini test etmek için HELLO VERSION kullanın. Router canlılığını doğrulamak için PING veya NAMING LOOKUP kullanın. Kimlik doğrulamasız uzak SAM bağlantılarından kaçının (i2pd\u0026rsquo;de TLS yok). 8. Referanslar ve Özellikler SAM v3 Spesifikasyonu SAM v2 (Eski) Streaming Spesifikasyonu Datagram\u0026rsquo;lar Dokümantasyon Merkezi i2pd Dokümantasyonu 9. Özet SAM v3, Java olmayan tüm I2P uygulamaları için önerilen köprü protokolü olmaya devam etmektedir. Kararlılık, diller arası bağlantılar ve router türleri arasında tutarlı performans sunar.\nSAM ile geliştirme yaparken: - Ed25519 imzalarını ve X25519 şifrelemeyi kullanın. - HELLO VERSION aracılığıyla özellik desteğini dinamik olarak doğrulayın. - Özellikle hem Java I2P hem de i2pd router\u0026rsquo;larını desteklerken uyumluluk için tasarım yapın.\n","description":"Java olmayan I2P uygulamaları için kararlı köprü protokolü","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/tr/docs/api/samv3/"},{"categories":null,"content":"I2P Router Yardım I2P hangi sistemlerde çalışır? I2P, Java programlama dilinde yazılmıştır. Windows, Linux, FreeBSD ve OSX üzerinde test edilmiştir. Ayrıca bir Android portu da mevcuttur.\nBellek kullanımı açısından, I2P varsayılan olarak 128 MB RAM kullanacak şekilde yapılandırılmıştır. Bu miktar web gezintisi ve IRC kullanımı için yeterlidir. Ancak diğer aktiviteler daha fazla bellek tahsisi gerektirebilir. Örneğin, yüksek bant genişlikli bir router çalıştırmak, I2P torrentlerine katılmak veya yüksek trafikli gizli servisleri barındırmak istiyorsanız, daha yüksek miktarda bellek gereklidir.\nCPU kullanımı açısından, I2P\u0026rsquo;nin Raspberry Pi gibi tek kartlı bilgisayar serilerinde çalışabildiği test edilmiştir. I2P kriptografik teknikleri yoğun bir şekilde kullandığından, daha güçlü bir CPU hem I2P tarafından oluşturulan iş yükünü hem de sistemin geri kalanıyla ilgili görevleri (yani İşletim Sistemi, GUI, Web Tarayıcısı gibi Diğer süreçler) daha iyi yönetebilir.\nSun/Oracle Java veya OpenJDK kullanılması önerilir.\nI2P kullanmak için Java yüklemek gerekli mi? Evet, I2P Core kullanmak için Java gereklidir. Windows, Mac OSX ve Linux için kolay kurulum paketlerimizin içinde Java bulunmaktadır. I2P Android uygulamasını çalıştırıyorsanız, çoğu durumda Dalvik veya ART gibi bir Java çalışma ortamının kurulu olması gerekir.\n\u0026ldquo;I2P Site\u0026rdquo; nedir ve tarayıcımı bunları kullanabilmek için nasıl yapılandırırım? I2P Sitesi, I2P içinde barındırılması dışında normal bir web sitesidir. I2P siteleri, insanların yararı için insan tarafından okunabilir, kriptografik olmayan bir şekilde \u0026ldquo;.i2p\u0026rdquo; ile biten normal internet adresleri gibi görünen adreslere sahiptir. Aslında bir I2P Sitesine bağlanmak kriptografi gerektirir, bu da I2P Site adreslerinin aynı zamanda uzun \u0026ldquo;Base64\u0026rdquo; Destinations ve daha kısa \u0026ldquo;B32\u0026rdquo; adresleri olduğu anlamına gelir. Doğru şekilde göz atmak için ek yapılandırma yapmanız gerekebilir. I2P Sitelerine göz atmak, I2P kurulumunuzda HTTP Proxy\u0026rsquo;yi etkinleştirmenizi ve ardından tarayıcınızı bunu kullanacak şekilde yapılandırmanızı gerektirecektir. Daha fazla bilgi için aşağıdaki \u0026ldquo;Tarayıcılar\u0026rdquo; bölümüne veya \u0026ldquo;Tarayıcı Yapılandırması\u0026rdquo; Kılavuzuna göz atın.\nRouter konsolundaki Aktif x/y sayıları ne anlama gelir? Router konsolunuzdaki Eşler (Peers) sayfasında iki sayı görebilirsiniz - Aktif x/y. İlk sayı, son birkaç dakikada mesaj gönderdiğiniz veya mesaj aldığınız eş sayısıdır. İkinci sayı ise yakın zamanda görülen eş sayısıdır, bu her zaman ilk sayıdan büyük veya ona eşit olacaktır.\nRouter\u0026rsquo;ımda çok az aktif eş var, bu normal mi? Evet, bu normal olabilir, özellikle router yeni başlatıldığında. Yeni routerların başlatılması ve ağın geri kalanına bağlanması için zamana ihtiyacı vardır. Ağ entegrasyonunu, çalışma süresini ve performansı iyileştirmeye yardımcı olmak için şu ayarları gözden geçirin:\nBant genişliği paylaşımı - Bir router bant genişliği paylaşacak şekilde yapılandırılırsa, diğer router\u0026rsquo;lar için daha fazla trafik yönlendirir, bu da hem ağın geri kalanıyla entegrasyonunu sağlar hem de yerel bağlantının performansını iyileştirir. Bu, http://localhost:7657/config sayfasında yapılandırılabilir. Ağ arayüzü - http://localhost:7657/confignet sayfasında belirtilmiş bir arayüz olmadığından emin olun. Bilgisayarınız birden fazla harici IP adresine sahip çok yollu (multi-homed) bir sistem değilse, bu performansı düşürebilir. I2NP protokolü - Router\u0026rsquo;ın, ana bilgisayarın işletim sistemi ve boş ağ (Gelişmiş) ayarları için geçerli bir protokol üzerinden bağlantı bekleyecek şekilde yapılandırıldığından emin olun. Ağ yapılandırma sayfasındaki \u0026lsquo;Hostname\u0026rsquo; alanına bir IP adresi girmeyin. Burada seçtiğiniz I2NP Protokolü yalnızca henüz ulaşılabilir bir adresiniz yoksa kullanılacaktır. Örneğin, Amerika Birleşik Devletleri\u0026rsquo;ndeki çoğu Verizon 4G ve 5G kablosuz bağlantısı UDP\u0026rsquo;yi engeller ve bu protokol üzerinden erişilemez. Diğerleri ise UDP\u0026rsquo;yi kendilerine uygun olsa bile zorla kullanır. Listelenen I2NP Protokollerinden makul bir ayar seçin. Belirli içerik türlerine karşıyım. Bunları dağıtmaktan, depolamaktan veya erişmekten nasıl kaçınırım? Bu materyallerin hiçbiri varsayılan olarak yüklenmez. Ancak I2P eşler arası bir ağ olduğundan, kazara yasaklanmış içerikle karşılaşmanız mümkündür. I2P\u0026rsquo;nin sizi inançlarınızın ihlali konusunda gereksiz yere dahil olmaktan nasıl koruduğuna dair bir özet:\nDağıtım - Trafik I2P ağının içinde kalır, siz bir çıkış düğümü değilsiniz (belgelerimizde outproxy olarak adlandırılır). Depolama - I2P ağı dağıtılmış içerik depolaması yapmaz, bu özelliğin kullanıcı tarafından özel olarak kurulması ve yapılandırılması gerekir (örneğin Tahoe-LAFS ile). Bu, farklı bir anonim ağ olan Freenet \u0026lsquo;in bir özelliğidir. Bir I2P router çalıştırarak kimse için içerik depolamış olmuyorsunuz. Erişim - Router\u0026rsquo;ınız sizin özel talimatınız olmadan herhangi bir içerik talep etmeyecektir. I2P\u0026rsquo;yi engellemek mümkün mü? Evet, açık ara en kolay ve en yaygın yol bootstrap veya \u0026ldquo;Reseed\u0026rdquo; sunucularını engellemektir. Tüm gizlenmiş trafiği tamamen engellemek de işe yarar (ancak bu I2P olmayan pek çok şeyi bozar ve çoğu kişi bu kadar ileri gitmeye istekli değildir). Reseed engellemesi durumunda, Github\u0026rsquo;da bir reseed paketi bulunmaktadır, bunu engellemek Github\u0026rsquo;ı da engelleyecektir. Bir proxy üzerinden reseed yapabilirsiniz (Tor kullanmak istemiyorsanız İnternet\u0026rsquo;te birçok proxy bulunabilir) veya reseed paketlerini çevrimdışı olarak arkadaştan arkadaşa paylaşabilirsiniz.\nRouter Console yüklenirken wrapper.log dosyasında \u0026ldquo;Protocol family unavailable\u0026rdquo; hatası görüyorum Bu hata, varsayılan olarak IPv6 kullanacak şekilde yapılandırılmış bazı sistemlerde, ağ etkinleştirilmiş herhangi bir java yazılımında ortaya çıkabilir. Bunu çözmenin birkaç yolu vardır:\nLinux tabanlı sistemlerde, echo 0 \u0026gt; /proc/sys/net/ipv6/bindv6only komutunu çalıştırabilirsiniz wrapper.config dosyasında aşağıdaki satırları arayın: #wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true #wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false Bu satırlar mevcutsa, \u0026ldquo;#\u0026rdquo; işaretlerini kaldırarak yorum satırından çıkarın. Satırlar mevcut değilse, \u0026ldquo;#\u0026rdquo; işaretleri olmadan ekleyin. Başka bir seçenek, ~/.i2p/clients.config dosyasından ::1 ifadesini kaldırmak olabilir\nUYARI: wrapper.config dosyasındaki herhangi bir değişikliğin etkili olması için router\u0026rsquo;ı ve wrapper\u0026rsquo;ı tamamen durdurmanız gerekir. Router konsolunuzda Yeniden Başlat seçeneğine tıklamak bu dosyayı TEKRAR OKUMAYACAKTIR! Kapat seçeneğine tıklamanız, 11 dakika beklemeniz ve ardından I2P\u0026rsquo;yi başlatmanız gerekir.\nI2P içindeki I2P Sitelerinin çoğu kapalı mı? Şimdiye kadar oluşturulmuş tüm I2P Sitelerini düşünürseniz, evet, çoğu çevrimdışı. İnsanlar ve I2P Siteleri gelir gider. I2P\u0026rsquo;ye başlamak için iyi bir yol, şu anda aktif olan I2P Sitelerinin bir listesine göz atmaktır. identiguy.i2p aktif I2P Sitelerini takip eder.\nI2P neden 32000 portunu dinliyor? Kullandığımız Tanuki java servis sarmalayıcısı, JVM içinde çalışan yazılımla iletişim kurmak için bu portu — localhost\u0026rsquo;a bağlı olarak — açar. JVM başlatıldığında, sarmalayıcıya bağlanabilmesi için bir anahtar verilir. JVM, sarmalayıcıya bağlantısını kurduktan sonra, sarmalayıcı herhangi bir ek bağlantıyı reddeder.\nDaha fazla bilgi wrapper belgelerinde bulunabilir.\nTarayıcımı nasıl yapılandırırım? Farklı tarayıcılar için proxy yapılandırması, ekran görüntüleriyle birlikte ayrı bir sayfadadır. FoxyProxy tarayıcı eklentisi veya Privoxy proxy sunucusu gibi harici araçlarla daha gelişmiş yapılandırmalar mümkündür ancak kurulumunuzda sızıntılara neden olabilir.\nI2P içinde IRC\u0026rsquo;ye nasıl bağlanırım? I2P içindeki ana IRC sunucusuna, Irc2P\u0026rsquo;ye bir tunnel, I2P kurulduğunda oluşturulur (I2PTunnel yapılandırma sayfasına bakın) ve I2P router başladığında otomatik olarak başlatılır. Bağlanmak için IRC istemcinize localhost 6668\u0026lsquo;e bağlanmasını söyleyin. HexChat benzeri istemci kullanıcıları localhost/6668 sunucusuyla yeni bir ağ oluşturabilir (bir proxy sunucu yapılandırdıysanız \u0026ldquo;Bypass proxy server\u0026rdquo; seçeneğini işaretlemeyi unutmayın). Weechat kullanıcıları yeni bir ağ eklemek için aşağıdaki komutu kullanabilir:\n/server add irc2p localhost/6668 Kendi I2P Sitemi nasıl kurarım? En kolay yöntem, router konsolundaki i2ptunnel bağlantısına tıklayıp yeni bir \u0026lsquo;Sunucu Tüneli\u0026rsquo; oluşturmaktır. Tünel hedefini Tomcat veya Jetty gibi mevcut bir web sunucusunun portuna ayarlayarak dinamik içerik sunabilirsiniz. Statik içerik de sunabilirsiniz. Bunun için tünel hedefini: 0.0.0.0 port 7659 olarak ayarlayın ve içeriği ~/.i2p/eepsite/docroot/ dizinine yerleştirin. (Linux dışı sistemlerde bu farklı bir yerde olabilir. Router konsolunu kontrol edin.) \u0026rsquo;eepsite\u0026rsquo; yazılımı I2P kurulum paketinin bir parçası olarak gelir ve I2P başlatıldığında otomatik olarak başlayacak şekilde ayarlanmıştır. Oluşturulan varsayılan siteye http://127.0.0.1:7658 adresinden erişilebilir. Ancak, \u0026rsquo;eepsite\u0026rsquo;ınıza başkaları da eepsite anahtar dosyanız üzerinden erişebilir, dosya konumu: ~/.i2p/eepsite/i2p/eepsite.keys. Daha fazla bilgi için şu konumdaki readme dosyasını okuyun: ~/.i2p/eepsite/README.txt.\nEvde I2P üzerinde yalnızca HTML ve CSS içeren bir web sitesi barındırırsam, tehlikeli midir? Rakibinize ve tehdit modelinize bağlıdır. Yalnızca kurumsal \u0026ldquo;gizlilik\u0026rdquo; ihlalleri, tipik suçlular ve sansür konusunda endişeleniyorsanız, gerçekten tehlikeli değildir. Kolluk kuvvetleri gerçekten isterlerse muhtemelen sizi zaten bulacaktır. Yalnızca normal bir (internet) ev kullanıcı tarayıcısı çalışırken barındırma yapmak, o bölümü kimin barındırdığını bilmeyi gerçekten zorlaştıracaktır. Lütfen I2P sitenizi barındırmayı, diğer herhangi bir hizmeti barındırmak gibi düşünün - ne kadar tehlikeli - veya güvenli - olduğu, onu nasıl yapılandırıp yönettiğinize bağlıdır.\nNot: Bir i2p hizmetini (destination) i2p router\u0026rsquo;dan ayırmanın zaten bir yolu var. Eğer bunun nasıl çalıştığını anlıyorsanız, o zaman web sitesi (veya hizmet) için ayrı bir makineyi sunucu olarak kurabilir, bu sunucuyu halka açık hale getirebilir ve [son derece] güvenli bir SSH tüneli üzerinden web sunucusuna yönlendirebilir veya güvenli, paylaşımlı bir dosya sistemi kullanabilirsiniz.\nI2P \u0026ldquo;.i2p\u0026rdquo; web sitelerini nasıl bulur? I2P Adres Defteri uygulaması, insan tarafından okunabilir isimleri hizmetlerle ilişkilendirilmiş uzun vadeli hedeflerle eşleştirir, bu da onu bir ağ veritabanı veya DNS hizmetinden ziyade bir hosts dosyasına veya kişi listesine benzer hale getirir. Ayrıca yerel önceliklidir (local-first) - tanınmış bir küresel ad alanı yoktur, herhangi bir .i2p alan adının sonuçta neye eşleşeceğine siz karar verirsiniz. Orta yol ise \u0026ldquo;Jump Service\u0026rdquo; (atlama hizmeti) olarak adlandırılan bir şeydir; bu hizmet, sizi \u0026ldquo;I2P router\u0026rsquo;ına $SITE_CRYPTO_KEY\u0026rsquo;i $SITE_NAME.i2p adıyla çağırma izni veriyor musunuz?\u0026rdquo; veya bu yönde bir soru sorulacak bir sayfaya yönlendirerek insan tarafından okunabilir bir isim sağlar. Adres defterinize eklendikten sonra, siteyi başkalarıyla paylaşmaya yardımcı olmak için kendi jump URL\u0026rsquo;lerinizi oluşturabilirsiniz.\nAdres Defterine nasıl adres eklerim? Ziyaret etmek istediğiniz sitenin en azından base32 veya base64 adresini bilmeden bir adres ekleyemezsiniz. İnsan tarafından okunabilen \u0026ldquo;hostname\u0026rdquo; (ana makine adı), base32 veya base64\u0026rsquo;e karşılık gelen kriptografik adresin yalnızca bir takma adıdır. Kriptografik adres olmadan bir I2P Sitesine erişmenin hiçbir yolu yoktur, bu tasarım gereğidir. Adresi henüz bilmeyen kişilere dağıtmak genellikle Jump servis sağlayıcısının sorumluluğundadır. Bilinmeyen bir I2P Sitesini ziyaret etmek, bir Jump servisinin kullanımını tetikler. stats.i2p en güvenilir Jump servisidir.\nEğer i2ptunnel üzerinden bir site barındırıyorsanız, henüz bir jump servisi kaydı olmayacaktır. Yerel olarak bir URL vermek için yapılandırma sayfasını ziyaret edin ve \u0026ldquo;Yerel Adres Defterine Ekle\u0026rdquo; yazan düğmeye tıklayın. Ardından addresshelper URL\u0026rsquo;sini aramak için http://127.0.0.1:7657/dns adresine gidin ve paylaşın.\nI2P hangi portları kullanır? I2P tarafından kullanılan portlar 2 bölüme ayrılabilir:\nDiğer I2P yönlendiricileriyle iletişim için kullanılan, İnternet\u0026rsquo;e açık portlar Yerel bağlantılar için yerel portlar Bunlar aşağıda detaylı olarak açıklanmıştır.\n1. İnternet\u0026rsquo;e açık portlar Not: 0.7.8 sürümünden itibaren, yeni kurulumlar 8887 portunu kullanmaz; program ilk kez çalıştırıldığında 9000 ile 31000 arasında rastgele bir port seçilir. Seçilen port, router yapılandırma sayfasında gösterilir.\nGİDEN\nyapılandırma sayfasında listelenen rastgele porttan rastgele uzak UDP portlarına UDP, yanıtlara izin verir Rastgele yüksek portlardan rastgele uzak TCP portlarına TCP 123 numaralı portta giden UDP, yanıtlara izin verir. Bu, I2P\u0026rsquo;nin dahili zaman senkronizasyonu için gereklidir (SNTP aracılığıyla - pool.ntp.org içinde rastgele bir SNTP sunucusuna veya belirttiğiniz başka bir sunucuya sorgu gönderme) GELEN\n(İsteğe bağlı, önerilir) Rastgele konumlardan yapılandırma sayfasında belirtilen porta UDP (İsteğe bağlı, önerilir) Rastgele konumlardan yapılandırma sayfasında belirtilen porta TCP Gelen TCP yapılandırma sayfasında devre dışı bırakılabilir 2. Yerel I2P portları Yerel I2P portları, aksi belirtilmedikçe varsayılan olarak yalnızca yerel bağlantıları dinler:\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. ### Adres defterimdeki birçok sunucu eksik. İyi abonelik bağlantıları nelerdir? {#subscriptions} Adres defteri http://localhost:7657/dns adresinde bulunur ve daha fazla bilgi burada edinilabilir.\nİyi adres defteri abonelik bağlantıları nelerdir?\nAşağıdakileri deneyebilirsiniz:\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt Web konsoluna diğer makinelerimden nasıl erişebilirim veya şifre koruması nasıl eklerim? Güvenlik amaçları doğrultusunda, router\u0026rsquo;ın yönetim konsolu varsayılan olarak yalnızca yerel arayüzden gelen bağlantıları dinler.\nKonsola uzaktan erişim için iki yöntem bulunmaktadır:\nSSH Tüneli Konsolunuzu genel bir IP adresinde kullanıcı adı ve şifre ile erişilebilir hale getirme Bunlar aşağıda ayrıntılı olarak açıklanmıştır:\nYöntem 1: SSH Tüneli\nUnix benzeri bir İşletim Sistemi çalıştırıyorsanız, bu I2P konsolunuza uzaktan erişim için en kolay yöntemdir. (Not: SSH sunucu yazılımı Windows çalıştıran sistemler için de mevcuttur, örneğin https://github.com/PowerShell/Win32-OpenSSH )\nSisteminize SSH erişimini yapılandırdıktan sonra, \u0026lsquo;-L\u0026rsquo; bayrağı uygun argümanlarla SSH\u0026rsquo;ye iletilir - örneğin:\nssh -L 7657:localhost:7657 (System_IP) burada \u0026lsquo;(System_IP)\u0026rsquo; yerine Sisteminizin IP adresi yazılır. Bu komut 7657 portunu (ilk iki noktadan önceki sayı) uzak sistemin (ilk ve ikinci iki nokta arasındaki \u0026rsquo;localhost\u0026rsquo; dizesi tarafından belirtilen) 7657 portuna (ikinci iki noktadan sonraki sayı) yönlendirir. Uzak I2P konsolunuz artık yerel sisteminizde \u0026lsquo;http://localhost:7657\u0026rsquo; olarak erişilebilir olacak ve SSH oturumunuz aktif olduğu sürece kullanılabilir kalacaktır.\nUzak sistemde bir kabuk başlatmadan bir SSH oturumu başlatmak istiyorsanız, \u0026lsquo;-N\u0026rsquo; bayrağını ekleyebilirsiniz:\nssh -NL 7657:localhost:7657 (System_IP) Yöntem 2: Konsolunuzu bir Genel IP adresinde kullanıcı adı ve şifre ile erişilebilir olacak şekilde yapılandırma\n~/.i2p/clients.config dosyasını açın ve şunu:\nclientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ bununla değiştirin:\nclientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ burada (System_IP) yerine sisteminizin genel IP adresini yazın\nhttp://localhost:7657/configui adresine gidin ve isterseniz bir konsol kullanıcı adı ve şifresi ekleyin - I2P konsolunuzu kurcalamaya karşı güvence altına almak için bir kullanıcı adı ve şifre eklemeniz şiddetle tavsiye edilir, aksi takdirde anonimliğinizin bozulmasına yol açabilir.\nhttp://localhost:7657/index adresine gidin ve JVM\u0026rsquo;i yeniden başlatıp istemci uygulamalarını yeniden yükleyen \u0026ldquo;Graceful restart\u0026rdquo; seçeneğine tıklayın\nBundan sonra başlatıldığında, artık konsolunuza uzaktan erişebilmeniz gerekir. Router konsolunu http://(Sistem_IP):7657 adresinden yükleyin ve tarayıcınız kimlik doğrulama açılır penceresini destekliyorsa, yukarıdaki 2. adımda belirttiğiniz kullanıcı adı ve şifre istenecektir.\nNOT: Yukarıdaki yapılandırmada 0.0.0.0 belirtebilirsiniz. Bu bir ağ veya netmask değil, bir arayüz belirtir. 0.0.0.0 \u0026ldquo;tüm arayüzlere bağlan\u0026rdquo; anlamına gelir, böylece 127.0.0.1:7657 üzerinden ve herhangi bir LAN/WAN IP\u0026rsquo;si üzerinden erişilebilir olur. Bu seçeneği kullanırken dikkatli olun çünkü konsol sisteminizde yapılandırılmış TÜM adreslerde erişilebilir olacaktır.\nDiğer makinelerden uygulamaları nasıl kullanabilirim? SSH Port Forwarding kullanımı için lütfen önceki cevaba bakın ve ayrıca konsolunuzdaki şu sayfaya da göz atın: http://localhost:7657/configi2cp I2P\u0026rsquo;yi bir SOCKS proxy olarak kullanmak mümkün mü? SOCKS proxy, 0.7.1 sürümünden beri çalışmaktadır. SOCKS 4/4a/5 desteklenmektedir. I2P\u0026rsquo;nin bir SOCKS outproxy\u0026rsquo;si olmadığı için kullanımı yalnızca I2P içindedir.\nBirçok uygulama, sizi İnternet üzerinde tanımlayabilecek hassas bilgileri sızdırır ve bu, I2P SOCKS proxy kullanırken farkında olunması gereken bir risktir. I2P yalnızca bağlantı verilerini filtreler, ancak çalıştırmayı düşündüğünüz program bu bilgileri içerik olarak gönderirse, I2P anonimliğinizi koruyamaz. Örneğin, bazı e-posta uygulamaları üzerinde çalıştıkları makinenin IP adresini bir posta sunucusuna gönderir. I2P\u0026rsquo;ye özel araçlar veya uygulamalar (I2PSnark gibi torrent uygulamaları için) veya Firefox üzerinde bulunan popüler eklentiler dahil olmak üzere I2P ile güvenli olduğu bilinen uygulamalar öneriyoruz.\nNormal İnternet\u0026rsquo;te IRC, BitTorrent veya diğer hizmetlere nasıl erişebilirim? I2P ile İnternet arasında köprü görevi gören, Tor Çıkış Düğümleri (Exit Nodes) gibi Outproxy adı verilen hizmetler bulunmaktadır. HTTP ve HTTPS için varsayılan outproxy işlevselliği exit.stormycloud.i2p tarafından sağlanır ve StormyCloud Inc. tarafından işletilir. Bu, HTTP Proxy\u0026rsquo;de yapılandırılır. Ek olarak, anonimliği korumaya yardımcı olmak için I2P, varsayılan olarak normal İnternet\u0026rsquo;e anonim bağlantılar kurmanıza izin vermez. Daha fazla bilgi için lütfen Socks Outproxy sayfasına bakın.\nReseed\u0026rsquo;ler Router\u0026rsquo;ım birkaç dakikadır çalışıyor ancak hiç ya da çok az bağlantım var Öncelikle Router Console\u0026rsquo;daki http://127.0.0.1:7657/netdb sayfasını kontrol edin – ağ veritabanınız. I2P içinden listelenmiş tek bir router görmüyorsanız ancak konsol güvenlik duvarının arkasında olduğunuzu söylüyorsa, muhtemelen reseed sunucularına bağlanamıyorsunuzdur. Diğer I2P router\u0026rsquo;ları listelenmiş olarak görüyorsanız, http://127.0.0.1:7657/config adresinden maksimum bağlantı sayısını düşürmeyi deneyin, router\u0026rsquo;ınız çok fazla bağlantıyı kaldıramıyor olabilir.\nManuel olarak nasıl reseed yapabilirim? Normal koşullar altında, I2P sizi bootstrap bağlantılarımızı kullanarak ağa otomatik olarak bağlar. Kesintili internet reseed sunucularından bootstrap yapılmasını başarısız kılıyorsa, bootstrap yapmanın kolay bir yolu Tor tarayıcısını kullanmaktır (Varsayılan olarak localhost\u0026rsquo;u açar), http://127.0.0.1:7657/configreseed ile çok iyi çalışır. Bir I2P router\u0026rsquo;ını manuel olarak reseed etmek de mümkündür.\nYeniden tohum ekleme (reseed) için Tor tarayıcısını kullanırken, aynı anda birden fazla URL seçebilir ve devam edebilirsiniz. Varsayılan değer olan 2 (birden fazla url\u0026rsquo;den) de çalışacaktır ancak yavaş olacaktır.\nGizlilik-Güvenlik Router\u0026rsquo;ım normal İnternet\u0026rsquo;e bir \u0026ldquo;çıkış düğümü\u0026rdquo; (outproxy) mü? Olmasını istemiyorum. Hayır, router\u0026rsquo;ınız şifrelenmiş uçtan uca trafiğin i2p ağı üzerinden rastgele bir tunnel uç noktasına taşınmasına katılır, genellikle bir outproxy değildir, ancak router\u0026rsquo;ınız ile İnternet arasında transport katmanı üzerinden trafik geçişi olmaz. Son kullanıcı olarak, sistem ve ağ yönetiminde yetenekli değilseniz outproxy çalıştırmamalısınız.\nAğ trafiğini analiz ederek I2P kullanımını tespit etmek kolay mıdır? I2P trafiği genellikle UDP trafiği gibi görünür ve bundan fazlası değil – ve bundan fazlası gibi görünmemesi bir hedeftir. Ayrıca TCP\u0026rsquo;yi de destekler. Biraz çabayla, pasif trafik analizi trafiği \u0026ldquo;I2P\u0026rdquo; olarak sınıflandırabilir, ancak trafik gizlemenin sürekli geliştirilmesinin bunu daha da azaltacağını umuyoruz. Obfs4 gibi oldukça basit bir protokol gizleme katmanı bile sansürcülerin I2P\u0026rsquo;yi engellemesini önleyecektir (I2P\u0026rsquo;nin dağıtacağı bir hedeftir).\nI2P Kullanmak Güvenli mi? Kişisel tehdit modelinize bağlıdır. Çoğu insan için I2P, hiçbir koruma kullanmamaktan çok daha güvenlidir. Bazı diğer ağlar (Tor, mixminion/mixmaster gibi), belirli düşmanlara karşı muhtemelen daha güvenlidir. Örneğin, I2P trafiği TLS/SSL kullanmaz, bu nedenle Tor\u0026rsquo;un sahip olduğu \u0026ldquo;en zayıf halka\u0026rdquo; sorunlarına sahip değildir. I2P, \u0026ldquo;Arap Baharı\u0026rdquo; sırasında Suriye\u0026rsquo;de birçok kişi tarafından kullanıldı ve son zamanlarda proje, Yakın ve Orta Doğu\u0026rsquo;daki daha küçük dil dilimlerinde I2P kurulumlarında daha büyük bir büyüme gördü. Burada belirtilmesi gereken en önemli şey, I2P\u0026rsquo;nin bir teknoloji olduğu ve İnternet\u0026rsquo;te gizliliğinizi/anonimliğinizi artırmak için bir nasıl yapılır/kılavuza ihtiyacınız olmasıdır. Ayrıca tarayıcınızı kontrol edin veya parmak izi saldırılarını çok büyük (yani: tipik uzun kuyruklar / çok doğru çeşitli veri yapısı) bir veri setiyle engellemek için parmak izi-arama-motorunu içe aktarın, bu veri seti birçok ortam öğesi hakkındadır ve kendi TLS önbellek davranışı ve sağlayıcı işletmesinin kendi masaüstü sisteminden daha kolay hacklenebilen teknik yapısı gibi kendisinden kaynaklanan tüm riskleri azaltmak için VPN kullanmayın. İzole bir Tor V-Browser\u0026rsquo;ı harika parmak izi önleme korumaları ile kullanmak ve yalnızca gerekli sistem iletişimlerine izin veren genel bir uygulama koruma-yaşam süresi-koruması ve \u0026ldquo;neredeyse kalıcı olası risk\u0026quot;i ortadan kaldırmak için casus karşıtı devre dışı bırakma betikleri ve canlı-cd ile son bir sanal makine kullanımı ve azalan olasılıkla tüm riskleri düşürmek, kamusal ağlarda ve en yüksek bireysel risk modelinde iyi bir seçenek olabilir ve i2p kullanımı için bu hedefe ulaşmak için yapabileceğiniz en iyi şey olabilir.\nRouter konsolunda diğer tüm I2P node\u0026rsquo;larının IP adreslerini görüyorum. Bu benim IP adresimin de başkaları tarafından görülebildiği anlamına mı geliyor? Evet, router\u0026rsquo;ınız hakkında bilgi sahibi olan diğer I2P düğümleri için. Bunu I2P ağının geri kalanıyla bağlantı kurmak için kullanırız. Adresler fiziksel olarak \u0026ldquo;routerInfo\u0026rsquo;larda (anahtar,değer) nesnelerinde\u0026rdquo; bulunur; bunlar uzaktan alınır veya eşlerden (peer) alınır. \u0026ldquo;routerInfo\u0026rsquo;lar\u0026rdquo;, router\u0026rsquo;ın kendisi hakkında önyükleme (bootstrapping) için \u0026ldquo;eş tarafından yayınlanan\u0026rdquo; bazı bilgileri (bazıları isteğe bağlı fırsatçı olarak eklenmiş) içerir. Bu nesnede istemciler hakkında hiçbir veri bulunmaz. Kaputun altına daha yakından bakıldığında, herkesin \u0026ldquo;SHA-256 Hash\u0026rsquo;ler (düşük=Pozitif hash(-anahtar), yüksek=Negatif hash(+anahtar))\u0026rdquo; adı verilen en yeni kimlik oluşturma türüyle sayıldığını göreceksiniz. I2P ağı, yükleme ve indeksleme sırasında oluşturulan routerInfo\u0026rsquo;ların kendi veritabanı verilerine sahiptir, ancak bu durum anahtar/değer tablolarının ve ağ topolojisinin gerçekleştirilmesine ve yük durumuna / bant genişliği durumuna ve DB bileşenlerindeki depolama için yönlendirme olasılıklarına derinlemesine bağlıdır.\nOutproxy kullanmak güvenli midir? \u0026ldquo;Güvenli\u0026rdquo; tanımınızın ne olduğuna bağlı. Outproxy\u0026rsquo;ler çalıştıklarında harikadır, ancak ne yazık ki gönüllü olarak, ilgisini kaybedebilecek veya bunları 7/24 sürdürecek kaynaklara sahip olmayabilecek kişiler tarafından yürütülürler – lütfen hizmetlerin kullanılamaz, kesintiye uğramış veya güvenilmez olduğu dönemler yaşayabileceğinizi unutmayın ve bu hizmetle ilişkili değiliz ve üzerinde hiçbir etkimiz yoktur.\nOutproxy\u0026rsquo;lerin kendileri, uçtan uca şifrelenmiş HTTPS/SSL verileri hariç olmak üzere, trafiğinizin gelip gittiğini görebilir; tıpkı ISS\u0026rsquo;nizin (İnternet Servis Sağlayıcınızın) bilgisayarınızdan gelen ve giden trafiği görebildiği gibi. ISS\u0026rsquo;niz konusunda rahat hissediyorsanız, outproxy ile de durumun daha kötü olması söz konusu değildir.\n\u0026ldquo;Anonimliği Kaldırma\u0026rdquo; saldırıları ne olacak? Çok uzun bir açıklama için Tehdit Modeli hakkındaki makalelerimizi okuyun. Genel olarak, kimlik tespiti önemsiz değildir, ancak yeterince dikkatli olmazsanız mümkündür.\nİnternet Erişimi/Performans I2P üzerinden normal İnternet sitelerine erişemiyorum. İnternet sitelerine proxy\u0026rsquo;leme (İnternet\u0026rsquo;e açık eepsite\u0026rsquo;lar) I2P kullanıcılarına engelleme yapmayan sağlayıcılar tarafından bir hizmet olarak sunulmaktadır. Bu hizmet I2P geliştirmesinin ana odak noktası değildir ve gönüllülük esasına göre sağlanmaktadır. I2P üzerinde barındırılan eepsite\u0026rsquo;lar her zaman outproxy olmadan çalışmalıdır. Outproxy\u0026rsquo;ler bir kolaylıktır ancak tasarım gereği ne mükemmeldir ne de projenin büyük bir parçasıdır. I2P\u0026rsquo;nin diğer hizmetlerinin sağlayabileceği yüksek kaliteli hizmeti sunamayabileceklerinin farkında olun.\nI2P üzerinden https:// veya ftp:// sitelerine erişemiyorum. Varsayılan HTTP proxy yalnızca HTTP ve HTTPS outproxy\u0026rsquo;i destekler.\nRouter\u0026rsquo;ım neden çok fazla CPU kullanıyor? Öncelikle, I2P ile ilgili tüm bileşenlerin en son sürüme sahip olduğunuzdan emin olun – eski sürümlerde kodda gereksiz CPU tüketen bölümler bulunuyordu. Ayrıca, I2P performansındaki iyileştirmelerin zaman içindeki gelişimini belgeleyen bir performans Günlüğü de mevcuttur.\nAktif eşlerim / bilinen eşlerim / katıldığım tüneller / bağlantılar / bant genişliği zaman içinde büyük ölçüde değişiyor! Bir sorun mu var? I2P ağının genel kararlılığı devam eden bir araştırma alanıdır. Bu araştırmanın önemli bir bölümü, yapılandırma ayarlarındaki küçük değişikliklerin router davranışını nasıl değiştirdiğine odaklanmıştır. I2P bir eşler arası ağ olduğundan, diğer eşlerin eylemleri router\u0026rsquo;ınızın performansı üzerinde etkili olacaktır.\nI2P\u0026rsquo;de indirmeler, torrent\u0026rsquo;ler, web gezintisi ve diğer her şeyi normal internete kıyasla yavaşlatan nedir? I2P, ekstra yönlendirme ve ek şifreleme katmanları ekleyen farklı koruma mekanizmalarına sahiptir. Ayrıca trafiği, kendi hız ve kalitesine sahip diğer eşler (Tunnels) üzerinden yönlendirir; bazıları yavaş, bazıları hızlıdır. Bu durum, farklı yönlerde farklı hızlarda çok fazla ek yük ve trafiğe neden olur. Tasarım gereği tüm bunlar, internet üzerindeki doğrudan bağlantıya kıyasla daha yavaş olmasına sebep olacaktır, ancak çok daha anonimdir ve çoğu şey için hala yeterince hızlıdır.\nAşağıda, I2P kullanırken gecikme ve bant genişliği konularına bağlam sağlamaya yardımcı olmak için açıklamalı bir örnek sunulmuştur.\nAşağıdaki diyagramı inceleyin. I2P üzerinden istek yapan bir istemci, I2P üzerinden isteği alan bir sunucu ve ardından yine I2P üzerinden geri yanıt veren bir sunucu arasındaki bağlantıyı göstermektedir. İsteğin üzerinden geçtiği devre de gösterilmiştir.\nDiyagramdan, \u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo; ve \u0026lsquo;R\u0026rsquo; etiketli kutuların \u0026lsquo;A\u0026rsquo; için bir giden tüneli temsil ettiğini ve \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; ve \u0026lsquo;Z\u0026rsquo; etiketli kutuların \u0026lsquo;B\u0026rsquo; için bir giden tüneli temsil ettiğini düşünün. Benzer şekilde, \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; ve \u0026lsquo;Z\u0026rsquo; etiketli kutular \u0026lsquo;B\u0026rsquo; için bir gelen tüneli temsil ederken \u0026lsquo;P_1\u0026rsquo;, \u0026lsquo;Q_1\u0026rsquo; ve \u0026lsquo;R_1\u0026rsquo; etiketli kutular \u0026lsquo;A\u0026rsquo; için bir gelen tüneli temsil eder. Kutular arasındaki oklar trafik yönünü gösterir. Okların üstündeki ve altındaki metinler, bir çift atlama arasındaki örnek bant genişliğinin yanı sıra örnek gecikme sürelerini detaylandırır.\nHem istemci hem de sunucu baştan sona 3 atlamalı tunnel\u0026rsquo;lar kullandığında, trafiği aktarmada toplam 12 başka I2P router\u0026rsquo;ı görev alır. 6 eş, istemciden sunucuya olan trafiği aktarır; bu trafik \u0026lsquo;A\u0026rsquo;dan (\u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;R\u0026rsquo;) 3 atlamalı bir giden tunnel\u0026rsquo;a ve \u0026lsquo;B\u0026rsquo;ye (\u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;) 3 atlamalı bir gelen tunnel\u0026rsquo;a bölünür. Benzer şekilde, 6 eş sunucudan istemciye geri dönen trafiği aktarır.\nİlk olarak, gecikmeyi düşünebiliriz - bir istemciden gelen isteğin I2P ağını geçmesi, sunucuya ulaşması ve istemciye geri dönmesi için geçen süre. Tüm gecikmeleri toplarsak şunu görürüz:\n40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms Örneğimizdeki toplam gidiş-dönüş süresi 740 ms\u0026rsquo;ye ulaşıyor - bu, normal internet sitelerine göz atarken normalde görülenin kesinlikle çok üzerinde.\nİkinci olarak, mevcut bant genişliğini düşünebiliriz. Bu, istemci ve sunucu arasındaki hop\u0026rsquo;lar (atlama noktaları) arasındaki en yavaş bağlantı ile ve ayrıca sunucu tarafından istemciye trafik iletilirken belirlenir. İstemciden sunucuya giden trafik için, örneğimizde \u0026lsquo;R\u0026rsquo; \u0026amp; \u0026lsquo;X\u0026rsquo; hop\u0026rsquo;ları ile \u0026lsquo;X\u0026rsquo; \u0026amp; \u0026lsquo;Y\u0026rsquo; hop\u0026rsquo;ları arasındaki mevcut bant genişliğinin 32 KB/s olduğunu görüyoruz. Diğer hop\u0026rsquo;lar arasında daha yüksek mevcut bant genişliği olmasına rağmen, bu hop\u0026rsquo;lar bir darboğaz görevi görecek ve \u0026lsquo;A\u0026rsquo;dan \u0026lsquo;B\u0026rsquo;ye olan trafik için maksimum mevcut bant genişliğini 32 KB/s ile sınırlayacaktır. Benzer şekilde, sunucudan istemciye olan yolu izlediğimizde maksimum 64 KB/s bant genişliği olduğunu görüyoruz - \u0026lsquo;Z_1\u0026rsquo; \u0026amp; \u0026lsquo;Y_1\u0026rsquo;, \u0026lsquo;Y_1\u0026rsquo; \u0026amp; \u0026lsquo;X_1\u0026rsquo; ve \u0026lsquo;Q_1\u0026rsquo; \u0026amp; \u0026lsquo;P_1\u0026rsquo; hop\u0026rsquo;ları arasında.\nBant genişliği limitlerini artırmanızı öneririz. Bu, mevcut bant genişliği miktarını artırarak ağa yardımcı olur ve bunun sonucunda I2P deneyiminizi iyileştirir. Bant genişliği ayarları http://localhost:7657/config sayfasında bulunmaktadır. Lütfen İnternet Servis Sağlayıcınız (ISP) tarafından belirlenen internet bağlantınızın limitlerinin farkında olun ve ayarlarınızı buna göre düzenleyin.\nAyrıca yeterli miktarda paylaşımlı bant genişliği ayarlamanızı öneririz - bu, katılımcı tünellerin I2P router\u0026rsquo;ınız üzerinden yönlendirilmesine olanak tanır. Katılımcı trafiğe izin vermek, router\u0026rsquo;ınızı ağa iyi entegre tutar ve aktarım hızlarınızı artırır.\nI2P devam eden bir çalışmadır. Birçok iyileştirme ve düzeltme uygulanmaktadır ve genel olarak, en son sürümü çalıştırmak performansınıza yardımcı olacaktır. Henüz yapmadıysanız, en son sürümü yükleyin.\nSanırım bir hata buldum, nerede bildirebilirim? Karşılaştığınız hataları/sorunları, hem normal internet hem de I2P üzerinden erişilebilen hata takip sistemimizde bildirebilirsiniz. Ayrıca hem I2P hem de normal internet üzerinden erişilebilen bir tartışma forumumuz bulunmaktadır. IRC kanalımıza da katılabilirsiniz: IRC ağımız IRC2P üzerinden veya Freenode\u0026rsquo;da.\nHata İzleyicimiz: Genel internet: https://i2pgit.org/I2P_Developers/i2p.i2p/issues I2P üzerinde: http://git.idk.i2p/I2P_Developers/i2p.i2p/issues Forumlarımız: i2pforum.i2p Günlük kayıtlarını yapıştırın: İlginç günlük kayıtlarını PrivateBin Wiki sayfasında listelenen genel internet servisleri veya bu PrivateBin örneği ya da bu Javascript-siz yapıştırma servisi gibi I2P yapıştırma servislerine yapıştırabilir ve IRC\u0026rsquo;de #i2p kanalında takip edebilirsiniz IRC: #i2p-dev kanalına katılın ve geliştiricilerle IRC üzerinden görüşün Lütfen http://127.0.0.1:7657/logs adresinde bulunan router günlükleri sayfasından ilgili bilgileri ekleyin. \u0026lsquo;I2P Sürümü ve Çalışma Ortamı\u0026rsquo; bölümünün altındaki tüm metni ve sayfada gösterilen çeşitli günlüklerde görüntülenen hataları veya uyarıları paylaşmanızı rica ederiz.\nBir sorum var! Harika! Bizi IRC\u0026rsquo;de bulun:\nirc.freenode.net üzerinde #i2p kanalı IRC2P üzerinde #i2p kanalı veya foruma gönderin, biz de burada yayınlayalım (umarız cevabıyla birlikte).\n","description":"Kapsamlı I2P SSS: router yardımı, yapılandırma, reseed'ler, gizlilik/güvenlik, performans ve sorun giderme","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"Sıkça Sorulan Sorular","url":"/tr/docs/overview/faq/"},{"categories":null,"content":" Dikkat: SOCKS tüneli, uygulama yüklerini temizlemeden iletir. Birçok protokol IP\u0026rsquo;leri, ana bilgisayar adlarını veya diğer tanımlayıcıları sızdırır. SOCKS\u0026rsquo;u yalnızca anonimlik açısından denetlediğiniz yazılımlarla kullanın.\n1. Genel Bakış I2P, bir I2PTunnel istemcisi aracılığıyla giden bağlantılar için SOCKS 4, 4a ve 5 proxy desteği sağlar. Standart uygulamaların I2P hedeflerine ulaşmasını sağlar ancak clearnet\u0026rsquo;e erişemez. SOCKS outproxy yoktur ve tüm trafik I2P ağı içinde kalır.\nUygulama Özeti Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None **Desteklenen adres türleri:** - `.i2p` host adları (adres defteri girdileri) - Base32 hash'leri (`.b32.i2p`) - Base64 veya clearnet desteği yok 2. Güvenlik Riskleri ve Kısıtlamalar Uygulama Katmanı Sızıntısı SOCKS, uygulama katmanının altında çalışır ve protokolleri temizleyemez. Birçok istemci (örneğin, tarayıcılar, IRC, e-posta) IP adresinizi, ana bilgisayar adınızı veya sistem ayrıntılarınızı ifşa eden meta veriler içerir.\nYaygın sızıntılar şunları içerir: - E-posta başlıklarında veya IRC CTCP yanıtlarında IP\u0026rsquo;ler - Protokol yüklerinde gerçek isimler/kullanıcı adları - İşletim sistemi parmak izleri içeren user-agent dizileri - Harici DNS sorguları - WebRTC ve tarayıcı telemetrisi\nI2P bu sızıntıları engelleyemez—bunlar tünel katmanının üstünde gerçekleşir. SOCKS\u0026rsquo;u yalnızca anonimlik için tasarlanmış denetlenmiş istemciler için kullanın.\nPaylaşılan Tünel Kimliği Birden fazla uygulama bir SOCKS tüneli paylaşıyorsa, aynı I2P hedef kimliğini paylaşırlar. Bu, farklı hizmetler arasında ilişkilendirme veya parmak izi oluşturma olanağı sağlar.\nAzaltma: Her uygulama için paylaşılmayan tunnel\u0026rsquo;lar kullanın ve yeniden başlatmalar arasında tutarlı kriptografik kimlikleri korumak için kalıcı anahtarları etkinleştirin.\nUDP Modu Geçici Olarak Kapatıldı SOCKS5\u0026rsquo;te UDP desteği uygulanmamıştır. Protokol UDP yeteneğini duyurur, ancak çağrılar göz ardı edilir. Yalnızca TCP kullanan istemciler kullanın.\nTasarım Gereği Outproxy Yok Tor\u0026rsquo;dan farklı olarak, I2P SOCKS tabanlı clearnet outproxy\u0026rsquo;leri sunmaz. Harici IP adreslerine ulaşma girişimleri başarısız olur veya kimliği açığa çıkarır. Outproxy gerekiyorsa HTTP veya HTTPS proxy\u0026rsquo;leri kullanın.\n3. Tarihsel Bağlam Geliştiriciler uzun zamandır anonim kullanım için SOCKS\u0026rsquo;u önermiyor. Dahili geliştirici tartışmalarından ve 2004\u0026rsquo;teki Toplantı 81 ve Toplantı 82 \u0026lsquo;den:\n\u0026ldquo;Rastgele trafiği yönlendirmek güvenli değildir ve anonimlik yazılımı geliştiricileri olarak son kullanıcılarımızın güvenliğini her şeyden önce düşünmemiz gerekir.\u0026rdquo;\nSOCKS desteği uyumluluk için dahil edilmiştir ancak üretim ortamları için önerilmez. Hemen hemen her internet uygulaması, anonim yönlendirme için uygun olmayan hassas meta verileri sızdırır.\n4. Yapılandırma Java I2P I2PTunnel Manager \u0026lsquo;ı açın \u0026ldquo;SOCKS 4/4a/5\u0026rdquo; tipinde yeni bir istemci tunnel\u0026rsquo;ı oluşturun Seçenekleri yapılandırın: Yerel port (herhangi bir uygun port) Paylaşımlı istemci: uygulama başına ayrı kimlik için devre dışı bırakın Kalıcı anahtar: anahtar korelasyonunu azaltmak için etkinleştirin Tunnel\u0026rsquo;ı başlatın i2pd i2pd varsayılan olarak 127.0.0.1:4447 adresinde etkinleştirilmiş SOCKS5 desteği içerir. i2pd.conf dosyasındaki [SOCKSProxy] bölümü altındaki yapılandırma, port, host ve tunnel parametrelerini ayarlamanıza olanak tanır.\n5. Geliştirme Zaman Çizelgesi Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 SOCKS modülünün kendisi 2013'ten bu yana büyük bir protokol güncellemesi görmedi, ancak çevresindeki tunnel yığını performans ve kriptografik iyileştirmeler aldı. 6. Önerilen Alternatifler Herhangi bir üretim, halka açık veya güvenlik açısından kritik uygulama için, SOCKS yerine resmi I2P API\u0026rsquo;lerinden birini kullanın:\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM Bu API'ler uygun hedef izolasyonu, kriptografik kimlik kontrolü ve daha iyi yönlendirme performansı sağlar. 7. OnionCat / GarliCat OnionCat, GarliCat modu (fd60:db4d:ddb5::/48 IPv6 aralığı) aracılığıyla I2P\u0026rsquo;yi destekler. Hala çalışır durumda ancak 2019\u0026rsquo;dan beri sınırlı geliştirme ile.\nKullanım uyarıları: - SusiDNS\u0026rsquo;de manuel .oc.b32.i2p yapılandırması gerektirir - Statik IPv6 ataması gerektirir - I2P projesi tarafından resmi olarak desteklenmemektedir\nYalnızca gelişmiş VPN-over-I2P kurulumları için önerilir.\n8. En İyi Uygulamalar SOCKS kullanmanız gerekiyorsa: 1. Her uygulama için ayrı tunnel oluşturun. 2. Paylaşımlı istemci modunu devre dışı bırakın. 3. Kalıcı anahtarları etkinleştirin. 4. SOCKS5 DNS çözümlemesini zorunlu kılın. 5. Protokol davranışını sızıntılara karşı denetleyin. 6. Clearnet bağlantılarından kaçının. 7. Ağ trafiğini sızıntılara karşı izleyin.\n9. Teknik Özet Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) --- 10. Sonuç I2P\u0026rsquo;deki SOCKS proxy, mevcut TCP uygulamalarıyla temel uyumluluk sağlar ancak güçlü anonimlik garantileri için tasarlanmamıştır. Yalnızca kontrollü, denetlenmiş test ortamları için kullanılmalıdır.\nCiddi dağıtımlar için SAM v3 veya Streaming API\u0026lsquo;ye geçiş yapın. Bu API\u0026rsquo;ler uygulama kimliklerini izole eder, modern kriptografi kullanır ve sürekli geliştirme alır.\nEk Kaynaklar Resmi SOCKS Belgeleri SAMv3 Spesifikasyonu Streaming Kütüphanesi Belgeleri I2PTunnel Referansı I2P Geliştirici Belgeleri Topluluk Forumu ","description":"I2P'nin SOCKS tünelini güvenli şekilde kullanmak (2.10.0 için güncellenmiştir)","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"SOCKS Proxy","url":"/tr/docs/api/socks/"},{"categories":null,"content":"Bu sözlük, I2P dokümantasyonu ve tartışmalarında kullanılan yaygın terimleri tanımlar.\nB Blockchain Birden fazla taraf arasındaki işlemleri verimli, doğrulanabilir ve kalıcı bir şekilde kaydedebilen dağıtık bir defter.\nD Merkeziyetsizlik Tek bir tarafa bağımlılıktan kaçınan ağ mimarisi. Eşler arası, blokzincir, federasyon ve dağıtık teknolojileri kapsar.\nDestination I2P ağındaki bir tünelin kriptografik kimliği. Bunlar, I2P ağı içindeki istemci ve sunucuların kimlikleridir.\nDHT (Distributed Hash Table) Bazı projelerde, bilgileri anahtar-değer çiftleri şeklinde dağıtık bir biçimde saklayarak eşleri birbirine bağlamak için kullanılır.\nDistributed Systems (Dağıtık Sistemler) Bilgisayar Bilimi içinde, bir ağ üzerinden bağlı birçok bireysel bilgisayardan oluşan bilgisayar sistemlerinin tasarımıyla ilgilenen akademik konu.\nF Federe Federasyon, bir hizmetin ayrı dağıtımlarının ortak bir protokol aracılığıyla birbirleriyle iletişim kurmasına olanak tanır.\nH Hash Genellikle harf ve rakamlardan oluşan bir dizi olarak gösterilen bir sayı. Verileri benzersiz şekilde tanımlayan bir \u0026ldquo;parmak izi\u0026rdquo; görevi görebilir.\nI I2P Invisible Internet Project: kullanıcıların çeşitli uygulamalar kullanarak anonim bir şekilde iletişim kurabilmesi için bir anonimlik katmanı sağlamayı amaçlayan bir proje.\nIP Adresi Bir bilgisayarın veya ağın benzersiz numarası olup, bu sayede adreslenebilmesini sağlar.\nL LeaseSet Belirli bir Destination\u0026rsquo;da bir istemci veya sunucu ile iletişim kurmak için gereken bilgi koleksiyonu.\nP Peer-to-Peer (P2P) Eşler (peers), sunucular veya kararlı ana bilgisayarlar tarafından merkezi koordinasyona ihtiyaç duymadan kaynaklarının bir bölümünü doğrudan diğer ağ katılımcılarına sunar.\nR Router I2P ağında şifrelenmiş paketleri yönlendiren temel I2P yazılımı.\nRouterIdentity Bir yönlendirici ile doğrudan iletişim kurmak için gereken bilgi koleksiyonu.\nT TCP/UDP İnternet üzerinde kullanılan iki temel taşıma protokolü.\nTunnel Bir istemci veya sunucu ile I2P ağı arasındaki anonim iletişim yolu.\nU UX Kullanıcı deneyimi, bir ürün veya hizmeti kullanan kişinin genel deneyimi.\nW WebRTC Verilerin kullanıcılar arasında doğrudan aktığı, bir web tarayıcısında bağlantı kurmak için kullanılan bir protokol standardı.\n","description":"I2P belgelerinde kullanılan yaygın terimler ve tanımlar","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"Sözlük","url":"/tr/docs/overview/s%C3%B6zl%C3%BCk/"},{"categories":null,"content":" Kullanımdan kaldırıldı: SSU\u0026rsquo;nun yerini SSU2 aldı. Desteği i2pd 2.44.0 (API 0.9.56, Kasım 2022) ve Java I2P 2.4.0 (API 0.9.61, Aralık 2023) sürümlerinden kaldırıldı.\nSSU, tıkanıklık kontrolü, NAT geçişi ve introducer (tanıştırıcı) desteği ile UDP tabanlı, yarı güvenilir iletim sağladı. NAT/güvenlik duvarlarının arkasındaki router\u0026rsquo;ları ele alarak ve IP keşfini koordine ederek NTCP\u0026rsquo;yi tamamladı.\nAdres Öğeleri transport: SSU caps: yetenek bayrakları (B, C, 4, 6, vb.) host / port: IPv4 veya IPv6 dinleyici (güvenlik duvarı arkasındayken isteğe bağlı) key: Base64 tanıtma anahtarı mtu: İsteğe bağlı; varsayılan 1484 (IPv4) / 1488 (IPv6) ihost/ikey/iport/itag/iexp: router güvenlik duvarı arkasındayken introducer (tanıştırıcı) girdileri Özellikler introducers (tanıştırıcılar) kullanılarak işbirliğine dayalı NAT geçişi Eş testleri ve gelen paketlerin incelenmesi yoluyla yerel IP tespiti Güvenlik duvarı durumunun otomatik olarak diğer taşıma katmanlarına ve router konsoluna iletilmesi Yarı güvenilir teslimat: mesajlar bir sınıra kadar yeniden iletilir, ardından düşürülür Toplamsal artış / çarpımsal azalış ile tıkanıklık kontrolü ve parça ACK bit alanları SSU ayrıca zamanlama işaretleri ve MTU müzakeresi gibi üstveri görevlerini de üstleniyordu. Artık tüm işlevler (modern kriptografi ile) SSU2 tarafından sağlanmaktadır.\n","description":"Özgün, güvenli ve yarı güvenilir UDP taşıması","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (eski)","url":"/tr/docs/legacy/ssu/"},{"categories":null,"content":" Kullanımdan kaldırıldı: SSU (Güvenli Yarı-Güvenilir UDP) SSU2 \u0026rsquo;nin yerini aldı. Java I2P, SSU\u0026rsquo;yu 2.4.0 sürümünde (API 0.9.61) kaldırdı ve i2pd ise onu 2.44.0\u0026rsquo;da (API 0.9.56) kaldırdı. Bu belge yalnızca tarihsel referans amacıyla saklanmaktadır.\nÖne çıkanlar I2NP iletilerinin şifreli, kimliği doğrulanmış nokta-nokta teslimini sağlayan UDP tabanlı taşıma. 2048 bitlik Diffie–Hellman el sıkışmasına dayanıyordu (ElGamal ile aynı asal sayı). Her datagram, 16 baytlık HMAC-MD5 (standart dışı kısaltılmış varyant) + 16 baytlık IV (başlatma vektörü) ve ardından AES-256-CBC ile şifrelenmiş yük taşıyordu. Yeniden oynatma önleme ve oturum durumu, şifrelenmiş yük içinde izleniyordu. İleti Üstbilgisi [16-byte MAC][16-byte IV][encrypted payload] Kullanılan MAC hesaplaması: HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8))). 32 baytlık bir MAC anahtarı kullanıldı. payload (veri yükü) uzunluğu, MAC hesaplamasına eklenen big-endian 16 bitlik bir değerdi. Protokol sürümü varsayılan olarak 0 idi; netId varsayılan olarak 2 idi (ana ağ).\nOturum ve MAC Anahtarları DH paylaşılan sırrından türetilen:\nPaylaşılan değeri big-endian (yüksek anlamlı bayt önce) bir bayt dizisine dönüştürün (yüksek bit ayarlıysa başına 0x00 ekleyin). Oturum anahtarı: ilk 32 bayt (daha kısaysa sıfırlarla doldurun). MAC anahtarı: 33–64. baytlar; yetersizse, paylaşılan değerin SHA-256 özetini kullanın. Durum Router\u0026rsquo;lar artık SSU adreslerini duyurmuyor. İstemciler SSU2 veya NTCP2 taşıma protokollerine geçmelidir. Tarihsel gerçeklemeler eski sürümlerde bulunabilir:\nrouter/transport/udp altında 2.4.0\u0026rsquo;dan önceki Java kaynak kodları 2.44.0\u0026rsquo;dan önceki i2pd kaynak kodları Güncel UDP taşıma davranışı için SSU2 belirtimine bakın.\n","description":"SSU2'den önce kullanılan ilk UDP taşıma protokolü","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"SSU Taşıması (Kullanımdan kaldırıldı)","url":"/tr/docs/legacy/ssu/"},{"categories":null,"content":"1. Genel Bakış SSU2, I2P içinde güvenli, yarı güvenilir router’lar arası iletişim için kullanılan UDP tabanlı bir taşıma katmanı protokolüdür. Genel amaçlı bir taşıma protokolü değildir; bunun yerine I2NP mesaj alışverişi için özelleştirilmiştir.\nTemel Özellikler Noise XK pattern (Noise protokolünde kullanılan bir anahtar değişimi şablonu) ile kimlik doğrulamalı anahtar değişimi Derin Paket İnceleme (DPI) direncine yönelik şifrelenmiş üstbilgiler Aktarıcılar ve hole punching (delik açma tekniği) kullanarak NAT geçişi Bağlantı taşınması ve adres doğrulaması İsteğe bağlı yol doğrulaması İleri gizlilik ve yeniden oynatma koruması Eski Sürüm ve Uyumluluk Implementation SSU2 Default SSU1 Removed i2pd2.44.02.44.0 Java I2P0.9.560.9.61 SSU1 artık genel I2P ağı genelinde kullanımda değil. 2. Kriptografi SSU2, I2P\u0026rsquo;ye özgü uzantılarla birlikte Noise_XK_25519_ChaChaPoly_SHA256 kullanır.\nFunction Algorithm Notes Diffie-HellmanX25519 (RFC 7748)32-byte keys CipherChaCha20/Poly1305 (RFC 7539)AEAD encryption HashSHA-256Used for key derivation and message integrity KDFHKDF-SHA256 (RFC 5869)For session and header keys Başlıklar ve yükler, `mixHash()` aracılığıyla kriptografik olarak birbirine bağlanır. Uygulama verimliliği için tüm kriptografik ilkeller NTCP2 ve ECIES (Eliptik Eğri Entegre Şifreleme Şeması) ile ortaktır. 3. Mesajlara Genel Bakış 3.1 UDP Datagram Kuralları Her UDP datagramı tam olarak bir SSU2 message taşır. Session Confirmed iletileri birden fazla datagram arasında parçalanabilir. Minimum boyut: 40 bayt Maksimum boyut: 1472 bayt (IPv4) / 1452 bayt (IPv6)\n3.2 Mesaj Türleri Type Message Header Description 0Session Request32BHandshake initiation 1Session Created32BHandshake response 2Session Confirmed16BFinal handshake, may be fragmented 6Data16BEncrypted I2NP message blocks 7Peer Test32BNAT reachability testing 9Retry32BToken or rejection notice 10Token Request32BRequest for validation token 11Hole Punch32BNAT traversal signaling --- 4. Oturum Kurulumu 4.1 Standart Akış (Geçerli Belirteç) Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 Belirteç Edinimi Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 Geçersiz Belirteç Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. Başlık Yapıları 5.1 Uzun Başlık (32 bayt) Oturum kurulmadan önce kullanılır (SessionRequest, Created, Retry, PeerTest, TokenRequest, HolePunch).\nField Size Description Destination Connection ID8Random unique ID Packet Number4Random (ignored during handshake) Type1Message type Version1Always 2 NetID12 = main I2P network Flags1Reserved (0) Source Connection ID8Random ID distinct from destination Token8Token for address validation ### 5.2 Kısa Başlık (16 bayt) Kurulmuş oturumlar sırasında kullanılır (SessionConfirmed, Data).\nField Size Description Destination Connection ID8Stable throughout session Packet Number4Incrementing per message Type1Message type (2 or 6) Flags3ACK/fragment flags --- 6. Şifreleme 6.1 AEAD (kimlik doğrulamalı şifreleme ve ilişkili veri) Tüm veri yükleri ChaCha20/Poly1305 AEAD (kimliği doğrulanmış ilişkili verilerle şifreleme) ile şifrelenir:\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) Nonce (tek seferlik sayı): 12 bayt (4 sıfır + 8 sayaç) Tag (doğrulama etiketi): 16 bayt Associated Data (ilişkili veri): bütünlük bağlaması için başlık içerir 6.2 Başlık Koruması Başlıklar, oturum başlığı anahtarlarından türetilen ChaCha20 anahtar akışı kullanılarak maskelenir. Bu, tüm Connection ID\u0026rsquo;lerin ve paket alanlarının rastgele görünmesini sağlayarak DPI (Derin Paket İncelemesi) direnci sağlar.\n6.3 Anahtar Türetimi Phase Input Output InitialintroKey + salthandshake header key HandshakeDH(X25519)chainKey + AEAD key Data phasechainKeyTX/RX keys Key rotationoldKeynewKey --- 7. Güvenlik ve Yeniden Oynatma Saldırılarının Önlenmesi Belirteçler IP başına olup ~60 saniye içinde süresi dolar. Yeniden oynatma saldırıları, oturum başına Bloom filtreleri aracılığıyla engellenir. Yinelenen geçici anahtarlar reddedilir. Başlıklar ve yükler kriptografik olarak birbirine bağlanır. Routers, AEAD kimlik doğrulamasından geçemeyen veya geçersiz sürüm ya da NetID içeren herhangi bir paketi atmalıdır.\n8. Paket Numaralandırma ve Oturum Ömrü Her yön kendi 32-bit sayacını tutar. - 0\u0026rsquo;dan başlar, paket başına artar. - Devir yapmamalıdır; 2³²\u0026rsquo;ye ulaşmadan oturumu yeniden anahtarlayın veya sonlandırın.\nBağlantı kimlikleri, oturumun tamamı boyunca, geçiş sırasında da sabit kalır.\n9. Veri Aşaması Tür = 6 (Veri) Kısa başlık (16 bayt) Yük, bir veya daha fazla şifreli blok içerir: ACK/NACK listeleri I2NP ileti parçaları Dolgu (0–31 bayt rastgele) Sonlandırma blokları (isteğe bağlı) Seçici yeniden iletim ve sırasız teslim desteklenir. Güvenilirlik “yarı güvenilir” düzeyinde kalır — kayıp paketler, yeniden deneme sınırlarına ulaşıldıktan sonra sessizce düşürülebilir.\n10. Aktarıcı ve NAT Geçişi Message Type Purpose Peer Test7Determines inbound reachability Retry9Issues new token or rejection Token Request10Requests new address token Hole Punch11Coordinates NAT hole punching Aktarıcı router'lar, kısıtlayıcı NAT'lerin arkasındaki eşlere bu kontrol iletilerini kullanarak yardımcı olur. 11. Oturumun Sonlandırılması Taraflardan herhangi biri, bir Data message (veri iletisi) içinde bir Termination block (sonlandırma bloğu) kullanarak oturumu kapatabilir. Alındıktan hemen sonra kaynaklar serbest bırakılmalıdır. Onaydan sonra tekrarlanan sonlandırma paketleri yok sayılabilir.\n12. Uygulama Yönergeleri Routers MUST: - version = 2 ve NetID = 2 değerlerini doğrulayın. - 40 bayttan küçük paketleri veya geçersiz AEAD\u0026rsquo;i atın. - 120 saniyelik yeniden oynatma önbelleğini zorunlu kılın. - Yeniden kullanılan belirteçleri veya geçici anahtarları reddedin.\nRouters YAPMALIDIR: - 0–31 bayt dolguyu rastgeleleştirin. - Uyarlamalı yeniden iletim kullanın (RFC 6298). - Taşımadan önce her eş için yol doğrulamasını uygulayın.\n13. Güvenlik Özeti Property Achieved By Forward secrecyX25519 ephemeral keys Replay protectionTokens + Bloom filter Authenticated encryptionChaCha20/Poly1305 KCI resistanceNoise XK pattern DPI resistanceEncrypted headers NAT traversalRelay + Hole Punch MigrationStatic connection IDs --- 14. Referanslar Öneri 159 – SSU2 Noise Protokolü Çerçevesi RFC 9000 – QUIC Taşıma RFC 9001 – QUIC için TLS RFC 7539 – ChaCha20/Poly1305 AEAD (İlişkili Veri ile Kimlik Doğrulamalı Şifreleme) RFC 7748 – X25519 ECDH (Eliptik Eğri Diffie–Hellman) RFC 5869 – HKDF-SHA256 (HMAC tabanlı Ayıkla ve Genişlet Anahtar Türetme Fonksiyonu) ","description":"Güvenli Yarı Güvenilir UDP Taşıma Protokolü Sürüm 2","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"SSU2 Spesifikasyonu","url":"/tr/docs/specs/ssu2/"},{"categories":null,"content":" 0.9.57 ve sonraki sürümler idk tarafından imzalanmıştır. Güncel açık anahtarı: PGP açık anahtarını indir 0.7.6 ve 0.9.56 sürümleri zzz tarafından imzalanmıştır. Güncel public key'i: PGP public key indir -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 Yeni GPG anahtarları ve alt anahtarlar oluşturdum ve yeni anahtarları eski anahtarla imzaladım.\nEski anahtarlar:\npub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) \u0026lt;zzz@mail.i2p\u0026gt; sub 2048g/74C8122D 2005-12-16 Yeni anahtarlar:\npub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) \u0026lt;zzz@mail.i2p\u0026gt; uid zzz on i2p (key signing) \u0026lt;zzz@i2pmail.org\u0026gt; sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07] Yeni anahtarları şu şekilde kullanacağım:\nEE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing Sürüm imzalama anahtarı 0.9.13 sürümünden itibaren kullanılacaktır. Bu mesaj eski anahtarımla imzalanmıştır.\nzzz 25 Mayıs 2014\nYeni anahtarlar şunlardır:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.14 (GNU/Linux)\nmQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dpXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHp\niEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; 0.9.9 sürümünden itibaren olan sürümler str4d tarafından imzalanabilir. Onun mevcut genel anahtarı: -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 Güncel genel anahtarlarım aşağıdaki gibidir:\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [sona erer: 2019-03-10] uid [ tam ] str4d (http://str4d.i 2p) str4d@mail.i2p uid [ tam ] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [süresi doldu: 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [süresi doldu: 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [sona erer: 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [sona erer: 2016-04-04]\nAnahtarları şu anda şu şekilde kullanıyorum:\nA94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing Her yıl yeni şifreleme ve imzalama alt anahtarları oluşturuyorum. Benim tarafımdan imzalanan herhangi bir I2P sürümü, her zaman yayın tarihindeki en güncel imzalama alt anahtarı ile imzalanacaktır.\nstr4d 20 Kas 2015\nGüncel anahtarlar (yukarıdaki tarih itibarıyla) aşağıdaki gibidir:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z\niQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d aşağıdaki sürümleri imzalamıştır: 0.9.23 0.7.6 ile 0.9.12 arasındaki sürümler zzz tarafından aşağıdaki anahtar ile imzalanmıştır: -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enpA KSA8enp6QG1haWwuaTJwPohfBBMRAgAfBQJDo051AhsDBgsJCAcDAgQVAggDAxYC AQIeAQIXgAAKCRBBVXa6p24L7cRrAJ9/Ur0N/nsvO1gwxvk1gKzeqFPIJwCeM3gL AC1Ct+1mSLfDiJmUsZN+7kG5Ag0EQ6NOlRAIAMtlHqrDOWvlOmTlkvTUIiC29ym0 yxXngHdq5/aC0i6Z+YA1snMFEtEOtiZm0jFsupvWnM6Z8b8GgWF8+mgiL2ZkzbWl Or8kf+sHyQ8olFkh7Qso6chRWCYpgDXfGPHQwopr3HiP4oRA1cgV9JJIFBkQJ/Ld 3rp2i16oW34i4hcPxhtTDcVDMx7eef/vQKizn0WYN K4mbw6Fe/SvtbGErPJ9Vnml XE98E2/gm+3yjTexk9TFIXFyKGGGOhRsLMuRFhbMWAUXq76h7QSaINkqDVGv+gRR q81/iw4yvS98TE69/nxyLeID0fy7eJ53xMy/q4wpc/xWs5r9/AUcD7imoRcAAwUI AJw/wL2Qp21kgepIQFTKr2uUTmg9IFdP1HownpWXWH4Hx3gpq3DDUPsAssMAjT7I ofbwdcPgFBNKXR9+5OuVWTftqn2lXczfjxboCRrh9qZpVTqax9krguYCqRkb81Kl eVNJyZk9qJA6Vv+dmrFAySS7tYP/wN6gT/N1hr0ilGYP2YrGQNKk4hx+EKY5JaKV 4rEsUdoU/Ba/YBfVpg2tPcG8RNsYfxC+4L1YP75NIMDiXLBXeu2zQvilDDp44Tj9 EytPwIeExBLP4RzXvUbMslpTKCFLBfAIRu9SEjqyeZS0lzXtedVxG+Rc2UTPLAfW atBNz45i23VYWp2L7D51iumISQQYEQIACQUCQ6NOlQIbDAAKCRBBVXa6p24L7V08 AJ4zLvbnghW7I5nu58LM/ej3WsyXBwCgnHte4RiNuUDVw2ch6Ia44WuiMQ4= =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\n0.6.1.31 ile 0.7.5 arasındaki sürümler Complication tarafından imzalanmıştır. Onun açık anahtarı: \u0026mdash;\u0026ndash;BEGIN PGP SIGNED MESSAGE\u0026mdash;\u0026ndash; Hash: SHA1\nMerhaba,\n2007-11-24 tarihinde yayınlanan, 2009-11-23 tarihine kadar geçerli olan yeni genel anahtarımın aşağıda olduğunu ve anahtar parmak izinin şu şekilde olduğunu onaylıyorum:\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\nEski genel anahtarıma sahipseniz ve bunu doğrulamak için kullanırsanız, eski anahtarımın 2007-11-15 tarihinde süresi dolduğunu fark edeceksiniz. Bu güncellemeyi geç yaptığım için özür dilerim.\nBu mesajdan anahtarı doğrudan kopyalamak isteyen ancak bunu bir e-posta programı kullanarak okumayan kişiler için, lütfen açık anahtar bloğunun başlangıç ve bitiş işaretleyicilerindeki \u0026ldquo;- \u0026quot; kaçış dizilerini silmeyi unutmayın. Aksi takdirde tanınmayacaktır.\nKomplikasyon.\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\nmQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK - \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\niD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"I2P sürümlerini imzalamak için kullanılan PGP anahtarları ve bunların nereden edinilebileceği","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"Sürüm İmzalama Anahtarı","url":"/tr/docs/develop/release-signing-key/"},{"categories":null,"content":"Genel Bakış Bu belge, şifreli LeaseSet2 (LS2) için körleme, şifreleme ve şifre çözmeyi tanımlar. Şifreli LeaseSet\u0026rsquo;ler, I2P ağ veritabanında gizli servis bilgilerinin erişim denetimli olarak yayımlanmasına olanak tanır.\nTemel Özellikler: - İleriye dönük gizlilik için günlük anahtar rotasyonu - İki kademeli istemci yetkilendirmesi (DH tabanlı ve PSK tabanlı) - AES donanımı olmayan cihazlarda performans için ChaCha20 şifrelemesi - Anahtar körleme ile Red25519 imzaları - Gizliliği koruyan istemci üyeliği\nİlgili Dokümantasyon: - Ortak Yapılar Spesifikasyonu - Şifrelenmiş LeaseSet yapısı - Öneri 123: Yeni netDB Girdileri - Şifrelenmiş LeaseSet\u0026rsquo;ler hakkında arka plan bilgisi - Ağ Veritabanı Dokümantasyonu - NetDB kullanımı\nSürüm Geçmişi ve Uygulama Durumu Protokol Geliştirme Zaman Çizelgesi Sürüm Numaralandırma Hakkında Önemli Not: I2P iki ayrı sürüm numaralandırma şeması kullanır: - API/Router Sürümü: 0.9.x serisi (teknik özelliklerde kullanılır) - Ürün Yayın Sürümü: 2.x.x serisi (genel kullanıma sunulan sürümler için kullanılır)\nTeknik özellikler API sürümlerine (örn. 0.9.41) atıfta bulunurken, son kullanıcılar ürün sürümlerini (örn. 2.10.0) görür.\nUygulama Kilometre Taşları Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility ### Mevcut Durum ✅ Protokol Durumu: Haziran 2019\u0026rsquo;dan bu yana kararlı ve değişmedi ✅ Java I2P: 0.9.40+ sürümlerinde eksiksiz olarak uygulanmıştır ✅ i2pd (C++): 2.58.0+ sürümlerinde eksiksiz olarak uygulanmıştır ✅ Birlikte Çalışabilirlik: Uygulamalar arasında tamdır ✅ Ağ Dağıtımı: 6+ yıllık operasyonel deneyimle üretim kullanımına hazır Kriptografik Tanımlar Notasyon ve Sözleşimler || birleştirmeyi ifade eder mod L Ed25519 mertebesine göre modüler indirgemeyi ifade eder Aksi belirtilmedikçe tüm bayt dizileri ağ bayt sıralamasındadır (big-endian, en anlamlı bayt önce) Little-endian değerler açıkça belirtilir (en az anlamlı bayt önce) CSRNG(n) Kriptografik olarak güvenli rastgele sayı üreteci\nAnahtar materyali üretimine uygun, kriptografik olarak güvenli rastgele veriden n bayt üretir.\nGüvenlik Gereksinimleri: - Kriptografik olarak güvenli olmalı (anahtar üretimi için uygun) - Ağda bitişik bayt dizileri açığa çıktığında güvenli olmalı - Gerçekleştirimler, potansiyel olarak güvenilmez kaynaklardan gelen çıktıyı karmalamalıdır\nKaynaklar: - PRNG Güvenlik Hususları - Tor Geliştirici Tartışması H(p, d) Kişiselleştirmeli SHA-256 Karma\nDomain-separated (etki alanı ayrımlı) özet fonksiyonu, şunları alır:\np: Kişiselleştirme dizesi (etki alanı ayrımı sağlar) d: Özetlenecek veri Uygulama:\nH(p, d) := SHA-256(p || d) Kullanım: SHA-256\u0026rsquo;nin farklı protokol kullanımları arasında çakışma saldırılarını önlemek için kriptografik alan ayrımı sağlar.\nAkış: ChaCha20 Akış şifresi: RFC 7539 Bölüm 2.4\u0026rsquo;te belirtildiği gibi ChaCha20\nParametreler: - S_KEY_LEN = 32 (256 bitlik anahtar) - S_IV_LEN = 12 (96 bitlik tek kullanımlık sayı) - Başlangıç sayacı: 1 (RFC 7539 0 veya 1\u0026rsquo;e izin verir; AEAD bağlamlarında 1 önerilir)\nENCRYPT(k, iv, plaintext)\nAçık metni şunları kullanarak şifreler: - k: 32 baytlık şifreleme anahtarı - iv: 12 baytlık nonce (tek kullanımlık sayı; HER anahtar için benzersiz OLMALIDIR) - Açık metinle aynı boyutta şifreli metin döndürür\nGüvenlik Özelliği: Anahtar gizliyse, tüm şifreli metin rastgele veriden ayırt edilemez olmalıdır.\nŞifre Çöz(k, iv, ciphertext)\nŞifreli metni şunları kullanarak çözer: - k: 32 baytlık şifreleme anahtarı - iv: 12 baytlık nonce (tek kullanımlık değer) - Açık metni döndürür\nTasarım Gerekçesi: ChaCha20 (akış şifreleme algoritması), AES\u0026rsquo;e (Gelişmiş Şifreleme Standardı) göre tercih edildi çünkü: - Donanım hızlandırması olmayan cihazlarda AES\u0026rsquo;ten 2.5-3 kat daha hızlı - Sabit zamanlı bir uygulamayı gerçekleştirmek daha kolay - AES-NI (AES için donanım hızlandırma talimatları) mevcut olduğunda karşılaştırılabilir güvenlik ve hız\nReferanslar: - RFC 7539 - IETF Protokolleri için ChaCha20 ve Poly1305\nİmza: Red25519 (imza türü) İmza Şeması: Red25519 (SigType 11) Anahtar Körleme ile\nRed25519, Ed25519 eğrisi üzerinde Ed25519 imzalarına dayanır; özetleme için SHA-512 kullanır ve ZCash RedDSA\u0026rsquo;da belirtildiği şekilde key blinding (körleme) desteği sağlar.\nİşlevler:\nDERIVE_PUBLIC(privkey) Verilen özel anahtara karşılık gelen genel anahtarı döndürür. - Standart Ed25519 taban noktasıyla skaler çarpımı kullanır\nSIGN(privkey, m) Mesaj m üzerinden, privkey özel anahtarı kullanılarak oluşturulmuş bir imza döndürür.\nRed25519 imzalama işleminin Ed25519\u0026rsquo;e göre farkları: 1. Rastgele Nonce (tek seferlik değer): 80 bayt ek rastgele veri kullanır\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) Bu, aynı mesaj ve anahtar için bile her Red25519 (bir eliptik eğri imza şeması) imzasını benzersiz kılar.\nÖzel Anahtar Üretimi: Red25519 özel anahtarları rastgele sayılardan üretilir ve mod L alınarak indirgenir; Ed25519\u0026rsquo;un bit-clamping (bit kısma) yaklaşımı kullanılmaz. VERIFY(pubkey, m, sig) İmza sig\u0026lsquo;i açık anahtar pubkey ve mesaj m ile doğrular. - İmza geçerliyse true, aksi halde false döndürür - Doğrulama Ed25519 ile aynıdır\nAnahtar Körleme İşlemleri:\nGENERATE_ALPHA(data, secret) Anahtar körleştirme için alpha üretir. - data: Genellikle imzalama açık anahtarını ve imza türlerini içerir - secret: İsteğe bağlı ek giz (kullanılmıyorsa sıfır uzunluklu) - Sonuç, Ed25519 özel anahtarlarıyla aynı dağılıma sahiptir (mod L indirgemesinden sonra)\nBLIND_PRIVKEY(privkey, alpha) Gizli alpha kullanarak özel bir anahtarı körleştirir. - Uygulama: blinded_privkey = (privkey + alpha) mod L - Alan üzerinde skaler aritmetik kullanır\nBLIND_PUBKEY(pubkey, alpha) Bir genel anahtarı gizli alpha kullanarak körler. - Uygulama: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) - Eğri üzerinde grup elemanı (nokta) toplamını kullanır\nKritik Özellik:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) Güvenlik Hususları:\nZCash Protokol Şartnamesi Bölüm 5.4.6.1\u0026rsquo;den: Güvenlik açısından, alpha\u0026rsquo;nın körleştirilmemiş özel anahtarlarla aynı dağılıma sahip olması gerekir. Bu, \u0026ldquo;yeniden rastgeleleştirilmiş bir açık anahtar ile o anahtar altında üretilmiş imza(ların) birleşiminin, yeniden rastgeleleştirildiği anahtarı ortaya çıkarmamasını\u0026rdquo; sağlar.\nDesteklenen İmza Türleri: - Tür 7 (Ed25519): Mevcut destinasyonlar için desteklenir (geri uyumluluk) - Tür 11 (Red25519): Şifreleme kullanan yeni destinasyonlar için önerilir - Blinded keys (körleştirilmiş anahtarlar): Her zaman Tür 11 (Red25519) kullanın\nReferanslar: - ZCash Protokol Spesifikasyonu - Bölüm 5.4.6 RedDSA - I2P Red25519 Spesifikasyonu DH (Diffie-Hellman): X25519 Eliptik Eğri Diffie-Hellman: X25519\nCurve25519 tabanlı bir açık anahtar anlaşması sistemi.\nParametreler: - Özel anahtarlar: 32 bayt - Açık anahtarlar: 32 bayt - Paylaşılan sır çıktısı: 32 bayt\nİşlevler:\nGENERATE_PRIVATE() CSRNG (kriptografik olarak güvenli rastgele sayı üreteci) kullanarak yeni bir 32 baytlık özel anahtar oluşturur.\nDERIVE_PUBLIC(privkey) Verilen özel anahtardan 32 baytlık genel anahtarı türetir. - Curve25519 üzerinde skaler çarpma kullanır\nDH(privkey, pubkey) Diffie-Hellman anahtar değişimini gerçekleştirir. - privkey: Yerel 32 baytlık özel anahtar - pubkey: Uzak 32 baytlık açık anahtar - Döndürür: 32 baytlık paylaşılan sır\nGüvenlik Özellikleri: - Curve25519 üzerinde Hesaplamalı Diffie-Hellman varsayımı - Geçici anahtarlar kullanıldığında ileri gizlilik - Zamanlama saldırılarını önlemek için sabit zamanlı gerçekleştirim gereklidir\nKaynaklar: - RFC 7748 - Güvenlik için Eliptik Eğriler\nHKDF (HMAC tabanlı anahtar türetme fonksiyonu) HMAC tabanlı Anahtar Türetme Fonksiyonu\nGirdi anahtar malzemesinden anahtar malzemesini ayıklar ve genişletir.\nParametreler: - salt: en fazla 32 bayt (genellikle SHA-256 için 32 bayt) - ikm: girdi anahtar materyali (herhangi bir uzunlukta olabilir, iyi entropiye sahip olmalı) - info: bağlama özgü bilgi (domain separation — alan ayrımı) - n: çıktının bayt cinsinden uzunluğu\nUygulama:\nRFC 5869\u0026rsquo;da belirtildiği şekilde HKDF\u0026rsquo;yi şu ayarlarla kullanır: - Hash Fonksiyonu: SHA-256 - HMAC: RFC 2104\u0026rsquo;te belirtildiği şekilde - Salt Uzunluğu: En fazla 32 bayt (SHA-256 için HashLen)\nKullanım Deseni:\nkeys = HKDF(salt, ikm, info, n) Etki Alanı Ayrımı: info parametresi, protokolde HKDF\u0026rsquo;nin (HMAC tabanlı Anahtar Türetme Fonksiyonu) farklı kullanımları arasında kriptografik etki alanı ayrımı sağlar.\nDoğrulanmış Bilgi Değerleri: - \u0026quot;ELS2_L1K\u0026quot; - Katman 1 (dış) şifreleme - \u0026quot;ELS2_L2K\u0026quot; - Katman 2 (iç) şifreleme - \u0026quot;ELS2_XCA\u0026quot; - DH istemci yetkilendirmesi - \u0026quot;ELS2PSKA\u0026quot; - PSK istemci yetkilendirmesi - \u0026quot;i2pblinding1\u0026quot; - Alfa oluşturma\nReferanslar: - RFC 5869 - HKDF Şartnamesi (HMAC tabanlı çıkarma ve genişletme anahtar türetme işlevi) - RFC 2104 - HMAC Şartnamesi (karma tabanlı mesaj doğrulama kodu)\nBiçim Spesifikasyonu Şifrelenmiş LS2 (ikinci nesil LeaseSet formatı) üç iç içe geçmiş katmandan oluşur:\nKatman 0 (Dış): Depolama ve geri alma için düz metin bilgileri Katman 1 (Orta): İstemci kimlik doğrulama verileri (şifrelenmiş) Katman 2 (İç): Asıl LeaseSet2 verileri (şifrelenmiş) Genel Yapı:\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature Önemli: Şifreli LS2, körlenmiş anahtarlar kullanır. Destination (Hedef) başlıkta yer almaz. DHT (Dağıtık karma tablosu) depolama konumu SHA-256(sig type || blinded public key) olup her gün yenilenir.\nKatman 0 (Dış) - Açık metin Katman 0 standart LS2 başlığını KULLANMAZ. Blinded keys (körleştirilmiş anahtarlar) için optimize edilmiş özel bir biçime sahiptir.\nYapı:\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data **Bayraklar Alanı (2 bayt, bitler 15-0):** - **Bit 0:** Çevrimdışı anahtar göstergesi - `0` = Çevrimdışı anahtar yok - `1` = Çevrimdışı anahtarlar mevcut (geçici anahtar verisi ardından gelir) - **Bitler 1-15:** Ayrılmış, gelecekteki uyumluluk için 0 olmalıdır Geçici Anahtar Verileri (bayrak biti 0 = 1 ise mevcut):\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key **İmza Doğrulama:** - **Çevrimdışı anahtarlar olmadan:** Körlenmiş açık anahtarla doğrulayın - **Çevrimdışı anahtarlarla:** Geçici açık anahtarla doğrulayın İmza, Type\u0026rsquo;tan outerCiphertext\u0026rsquo;e kadar (dahil) tüm verileri kapsar.\nKatman 1 (Orta) - İstemci Yetkilendirme Şifre çözme: Bkz. Katman 1 Şifreleme bölümü.\nYapı:\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) **Bayraklar Alanı (1 bayt, bitler 7-0):** - **Bit 0:** Yetkilendirme modu - `0` = İstemci başına yetkilendirme yok (herkes) - `1` = İstemci başına yetkilendirme (kimlik doğrulama bölümü ardından gelir) - **Bitler 3-1:** Kimlik doğrulama şeması (yalnızca bit 0 = 1 ise) - `000` = DH istemci kimlik doğrulaması - `001` = PSK istemci kimlik doğrulaması - Diğerleri ayrılmış - **Bitler 7-4:** Kullanılmıyor, 0 olmalıdır DH İstemci Yetkilendirme Verileri (bayraklar = 0x01, bitler 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **authClient Girdisi (40 bayt):** - `clientID_i`: 8 bayt - `clientCookie_i`: 32 bayt (şifrelenmiş authCookie) PSK İstemci Yetkilendirme Verileri (bayraklar = 0x03, 3-1 bitleri = 001):\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **authClient Girdisi (40 bayt):** - `clientID_i`: 8 bayt - `clientCookie_i`: 32 bayt (şifrelenmiş authCookie) Katman 2 (İç) - LeaseSet Verileri Şifre çözme: Bkz. Katman 2 Şifreleme bölümü.\nYapı:\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 İç katman, aşağıdakileri içeren tam LeaseSet2 yapısını barındırır: - LS2 başlığı - Lease (kiralama kaydı) bilgisi - LS2 imzası Doğrulama Gereksinimleri: Şifre çözme işleminden sonra, gerçeklemeler şunları doğrulamalıdır: 1. İç zaman damgasının dışta yayımlanan zaman damgasıyla eşleştiğini 2. İç sona erme zamanının dış sona erme zamanıyla eşleştiğini 3. LS2 imzasının geçerli olduğunu 4. Lease (kiralama kaydı) verisinin iyi biçimlendirilmiş olduğunu\nReferanslar: - Ortak Yapılar Spesifikasyonu - LeaseSet2 biçim ayrıntıları\nKörleme Anahtarı Türetimi Genel Bakış I2P, Ed25519 ve ZCash RedDSA tabanlı bir additive key blinding (toplamsal anahtar körleme) şeması kullanır. İleri gizlilik için körlenmiş anahtarlar günlük olarak (UTC gece yarısında) yenilenir.\nTasarım Gerekçesi:\nI2P, Tor\u0026rsquo;un rend-spec-v3.txt dosyasındaki Ek A.2 yaklaşımını KULLANMAMAYI açıkça seçti. Spesifikasyona göre:\n\u0026ldquo;Benzer tasarım amaçlarına sahip olan Tor\u0026rsquo;un rend-spec-v3.txt belgesindeki Ek A.2\u0026rsquo;yi kullanmıyoruz; çünkü oradaki körlenmiş açık anahtarlar asal mertebeli altgrubun dışında olabilir ve bunun güvenlik sonuçları bilinmemektedir.\u0026rdquo;\nI2P\u0026rsquo;nin additive blinding (toplamsal körleme) yöntemi, körlenmiş anahtarların Ed25519 eğrisinin asal dereceli alt grubunda kalmasını garanti eder.\nMatematiksel Tanımlar Ed25519 Parametreleri: - B: Ed25519 taban noktası (üreteç) = 2^255 - 19 - L: Ed25519 mertebesi = 2^252 + 27742317777372353535851937790883648493\nTemel Değişkenler: - A: Körleştirilmemiş 32 baytlık imzalama açık anahtarı (Destination (I2P adresi) içinde) - a: Körleştirilmemiş 32 baytlık imzalama özel anahtarı - A': Körleştirilmiş 32 baytlık imzalama açık anahtarı (şifrelenmiş LeaseSet içinde kullanılır) - a': Körleştirilmiş 32 baytlık imzalama özel anahtarı - alpha: 32 baytlık körleştirme faktörü (gizli)\nYardımcı İşlevler:\nLEOS2IP(x) \u0026ldquo;Küçük endian oktet dizisini tamsayıya dönüştürme\u0026rdquo;\nlittle-endian (küçük uç önde bayt sıralaması) biçimindeki bir bayt dizisini tamsayı gösterimine dönüştürür.\nH*(x) \u0026ldquo;Özetleme ve İndirgeme\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L Ed25519 anahtar üretimindeki işlemin aynısı.\nAlfa Kuşağı Günlük Rotasyon: Her gün UTC gece yarısında (00:00:00 UTC) yeni bir alpha (alfa parametresi) ve blinded keys (körleştirilmiş anahtarlar) oluşturulması ZORUNLUDUR.\nGENERATE_ALPHA(destination, date, secret) Algoritması:\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L Doğrulanan Parametreler: - Salt kişiselleştirmesi: \u0026quot;I2PGenerateAlpha\u0026quot; - HKDF bilgisi: \u0026quot;i2pblinding1\u0026quot; - Çıktı: indirgeme öncesi 64 bayt - Alpha dağılımı: mod L sonrasında Ed25519 özel anahtarlarıyla özdeş dağılımda\nÖzel Anahtar Körleştirme BLIND_PRIVKEY(a, alpha) Algoritması:\nŞifrelenmiş LeaseSet\u0026rsquo;i yayımlayan hedef sahibi için:\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) Kritik: mod L indirgemesi, özel ve açık anahtarlar arasındaki doğru cebirsel ilişkiyi sürdürmek için hayati önemdedir.\nAçık Anahtar Körleme BLIND_PUBKEY(A, alpha) Algoritması:\nŞifrelenmiş LeaseSet\u0026rsquo;i alan ve doğrulayan istemciler için:\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) Matematiksel Eşdeğerlik:\nHer iki yöntem de aynı sonuçları verir:\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) Bunun nedeni:\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) Körleştirilmiş Anahtarlarla İmzalama Körleştirilmemiş LeaseSet İmzalama:\nKörlemesi kaldırılmış LeaseSet (doğrulanmış istemcilere doğrudan gönderilen) şu şekilde imzalanır: - Standart Ed25519 (tip 7) veya Red25519 (tip 11) imzası - Körlemesi kaldırılmış imzalama özel anahtarı - Körlemesi kaldırılmış açık anahtarla doğrulanır\nÇevrimdışı Anahtarlarla: - körleştirilmemiş geçici özel anahtar ile imzalanır - körleştirilmemiş geçici açık anahtar ile doğrulanır - Her ikisi de tür 7 veya 11 olmalıdır\nŞifreli LeaseSet İmzalama:\nŞifrelenmiş LeaseSet\u0026rsquo;in dış kısmı, körleştirilmiş anahtarlarla birlikte Red25519 imzalarını kullanır.\nRed25519 İmza Algoritması:\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total Ed25519\u0026rsquo;dan Temel Farklar: 1. 80 bayt rastgele veri T kullanır (özel anahtarın karması değil) 2. Genel anahtar değerini doğrudan kullanır (özel anahtarın karması değil) 3. Aynı mesaj ve anahtar için bile her imza benzersizdir\nDoğrulama:\nEd25519 ile aynı:\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; Güvenlik Hususları Alfa Dağıtımı:\nGüvenlik açısından, alpha körleştirilmemiş özel anahtarlarla özdeş dağılıma sahip olmalıdır. Ed25519 (tip 7)’yi Red25519 (tip 11)’ye körleştirirken, dağılımlar biraz farklılık gösterir.\nÖneri: ZCash gereksinimlerini karşılamak için hem körleştirilmemiş hem de körleştirilmiş anahtarlar için Red25519 (type 11) kullanın: \u0026ldquo;yeniden rastgeleleştirilmiş bir açık anahtar ile o anahtar altında oluşturulan imza(lar)ın birleşimi, yeniden rastgeleleştirildiği anahtarı açığa çıkarmaz.\u0026rdquo;\nTip 7 Desteği: Mevcut destinations (I2P adresleri) ile geriye dönük uyumluluk için Ed25519 desteklenir, ancak yeni şifreli destinations için tip 11 önerilir.\nGünlük Rotasyonun Faydaları: - İleri gizlilik: Bugünkü körleştirilmiş anahtarın ele geçirilmesi, dünkünü ortaya çıkarmaz - İlişkilendirilemezlik: Günlük rotasyon, DHT üzerinden uzun vadeli takibi engeller - Anahtar ayrımı: Farklı zaman dilimleri için farklı anahtarlar\nKaynaklar: - ZCash Protokol Spesifikasyonu - Bölüm 5.4.6.1 - Tor Anahtar Körleme Tartışması - Tor Bilet #8106 Şifreleme ve İşleme Subcredential (alt kimlik bilgisi) türetimi Şifrelemeden önce, şifrelenmiş katmanları Destination\u0026rsquo;ın (I2P hedef adresi) imzalama genel anahtarı bilgisine bağlamak için bir kimlik bilgisi ve bir alt kimlik bilgisi türetiriz.\nAmaç: Yalnızca Destination\u0026rsquo;ın (I2P\u0026rsquo;de bir hizmetin kimliği) imzalama için açık anahtarını bilenlerin şifrelenmiş LeaseSet\u0026rsquo;in şifresini çözebilmesini sağlamak. Tam Destination gerekli değildir.\nKimlik Bilgisi Hesaplaması A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes Alan Ayrımı: Kişiselleştirme dizesi \u0026quot;credential\u0026quot; bu karmanın herhangi bir DHT arama anahtarıyla veya protokolün diğer kullanımlarıyla çakışmamasını garanti eder.\nSubcredential (alt kimlik bilgisi) Hesaplaması blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes Amaç: subcredential (alt kimlik bilgisi), şifrelenmiş LeaseSet\u0026rsquo;i şunlara bağlar: 1. Belirli Destination (credential aracılığıyla) 2. Belirli körleştirilmiş anahtar (blindedPublicKey aracılığıyla) 3. Belirli gün (blindedPublicKey\u0026rsquo;nin günlük rotasyonu aracılığıyla)\nBu, yeniden oynatma saldırılarını ve cross-day linking (günler arası ilişkilendirme) durumunu önler.\nKatman 1 Şifrelemesi Bağlam: Katman 1, istemci yetkilendirme verilerini içerir ve subcredential (alt kimlik bilgisi) temel alınarak türetilen bir anahtarla şifrelenir.\nŞifreleme Algoritması # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) Çıktı: outerCiphertext 32 + len(outerPlaintext) bayt uzunluğundadır.\nGüvenlik Özellikleri: - Salt (tuz), aynı subcredential (alt kimlik bilgisi) olsa bile benzersiz anahtar/IV çiftlerini garanti eder - Bağlam dizesi \u0026quot;ELS2_L1K\u0026quot; alan ayrımı sağlar - ChaCha20 anlamsal güvenlik sağlar (şifreli metnin rastgele olandan ayırt edilememesi)\nŞifre Çözme Algoritması # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) Doğrulama: Şifre çözme işleminden sonra, Katman 2\u0026rsquo;ye geçmeden önce Katman 1 yapısının düzgün biçimlendirilmiş olduğunu doğrulayın.\nKatman 2 Şifreleme Bağlam: Katman 2, gerçek LeaseSet2 verisini içerir ve per-client auth (istemci başına kimlik doğrulama) etkinleştirildiyse authCookie\u0026rsquo;den, etkin değilse boş dizgeden türetilen bir anahtarla şifrelenir.\nŞifreleme Algoritması # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) Çıktı: innerCiphertext 32 + len(innerPlaintext) bayttır.\nAnahtar Bağlama: - İstemci kimlik doğrulaması yoksa: Yalnızca subcredential (alt kimlik bilgisi) ve zaman damgasına bağlanır - İstemci kimlik doğrulaması etkinse: Ayrıca authCookie\u0026rsquo;ye bağlanır (her yetkilendirilmiş istemci için farklıdır)\nŞifre Çözme Algoritması # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) Doğrulama: Şifresi çözüldükten sonra: 1. LS2 tip baytının geçerli olduğunu doğrula (3 veya 7) 2. LeaseSet2 yapısını ayrıştır 3. İç zaman damgasının dıştaki yayımlanan zaman damgasıyla eşleştiğini doğrula 4. İç sona erme zamanının dıştaki sona erme zamanıyla eşleştiğini doğrula 5. LeaseSet2 imzasını doğrula\nŞifreleme Katmanı Özeti ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ Şifre Çözme Akışı: 1. Körlenmiş açık anahtar kullanarak Katman 0 imzasını doğrulayın 2. subcredential (alt kimlik bilgisi) kullanarak Katman 1\u0026rsquo;in şifresini çözün 3. authCookie elde etmek için (varsa) yetkilendirme verisini işleyin 4. authCookie ve subcredential kullanarak Katman 2\u0026rsquo;nin şifresini çözün 5. LeaseSet2\u0026rsquo;yi doğrulayın ve ayrıştırın\nİstemci Başına Yetkilendirme Genel Bakış İstemci bazlı yetkilendirme etkinleştirildiğinde, sunucu yetkilendirilmiş istemcilerin bir listesini tutar. Her istemcinin, güvenli bir bant dışı yolla iletilmesi gereken anahtar materyali vardır.\nİki Yetkilendirme Mekanizması: 1. DH (Diffie-Hellman) İstemci Yetkilendirmesi: Daha güvenlidir, X25519 anahtar anlaşmasını kullanır 2. PSK (Önceden Paylaşılan Anahtar) Yetkilendirmesi: Daha basittir, simetrik anahtarlar kullanır\nOrtak Güvenlik Özellikleri: - İstemci üyeliği gizliliği: Gözlemciler istemci sayısını görür ancak belirli istemcileri tanımlayamaz - Anonim istemci ekleme/kaldırma: Belirli istemcilerin ne zaman eklendiği veya kaldırıldığı izlenemez - 8 baytlık istemci tanımlayıcısı çakışma olasılığı: ~ 18 kentilyonda 1 (ihmal edilebilir)\nDH İstemci Yetkilendirmesi Genel Bakış: Her istemci bir X25519 anahtar çifti oluşturur ve açık anahtarını güvenli bir bant dışı kanal üzerinden sunucuya gönderir. Sunucu, her istemci için benzersiz bir authCookie\u0026rsquo;yi şifrelemek için ephemeral DH (geçici Diffie-Hellman) kullanır.\nİstemci Anahtar Üretimi # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) Güvenlik Avantajı: İstemcinin özel anahtarı cihazını asla terk etmez. Bant dışı iletimi ele geçiren bir saldırgan, X25519 DH\u0026rsquo;yi (Diffie-Hellman anahtar değişimi) kırmadan gelecekteki şifrelenmiş LeaseSets\u0026rsquo;i deşifre edemez.\nSunucu Tarafı İşleme # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Katman 1 Veri Yapısı:\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Sunucu Önerileri: - Yayınlanan her şifreli LeaseSet için yeni bir geçici anahtar çifti oluşturun - Pozisyona dayalı izlemeyi önlemek için istemci sırasını rastgeleleştirin - Gerçek istemci sayısını gizlemek için sahte girdiler eklemeyi düşünün\nİstemci İşleme # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) İstemci Hata Yönetimi: - clientID_i bulunamadıysa: İstemcinin yetkisi iptal edilmiştir ya da hiç yetkilendirilmemiştir - Şifre çözme başarısız olursa: Bozulmuş veri ya da yanlış anahtarlar (son derece nadir) - İstemciler, iptali tespit etmek için periyodik olarak yeniden almalılar\nPSK (önceden paylaşılan anahtar) İstemci Yetkilendirmesi Genel Bakış: Her istemcinin önceden paylaşılan 32 baytlık simetrik bir anahtarı vardır. Sunucu, her istemcinin PSK\u0026rsquo;sini (önceden paylaşılan anahtar) kullanarak aynı authCookie\u0026rsquo;yi şifreler.\nAnahtar Üretimi # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel Güvenlik Notu: İstenirse aynı PSK (önceden paylaşılan anahtar) birden fazla istemci arasında paylaşılabilir (bir \u0026ldquo;grup\u0026rdquo; yetkilendirmesi oluşturur).\nSunucu İşleme # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Katman 1 Veri Yapısı:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] İstemci İşleme # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Karşılaştırma ve Öneriler Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access **Öneri:** - **DH yetkilendirmesini kullanın** ileriye dönük gizliliğin önemli olduğu yüksek güvenlikli uygulamalar için - **PSK yetkilendirmesini kullanın** performansın kritik olduğu durumlarda veya istemci gruplarını yönetirken - **PSK'leri asla yeniden kullanmayın** farklı hizmetler veya zaman dilimleri arasında - **Her zaman güvenli kanallar kullanın** anahtar dağıtımı için (örn., Signal, OTR, PGP) Güvenlik Hususları İstemci Üyeliğinin Gizliliği:\nHer iki mekanizma da istemci üyeliği için gizliliği şu yollarla sağlar: 1. Şifrelenmiş istemci tanımlayıcıları: HKDF çıktısından türetilen 8 baytlık clientID 2. Ayırt edilemeyen tanımlama bilgileri: Tüm 32 baytlık clientCookie değerleri rastgele görünür 3. İstemciye özgü meta veri yok: Hangi girdinin hangi istemciye ait olduğunu belirlemenin bir yolu yok\nBir gözlemci şunları görebilir: - Yetkili istemci sayısı (clients alanından) - Zaman içinde istemci sayısındaki değişiklikler\nBir gözlemci ŞUNLARI GÖREMEZ: - Hangi belirli istemcilerin yetkilendirildiği - Belirli istemcilerin ne zaman eklendiği veya kaldırıldığı (sayı aynı kalıyorsa) - İstemciyi tanımlayıcı herhangi bir bilgi\nRastgeleleştirme Önerileri:\nSunucular, şifrelenmiş bir LeaseSet oluşturduklarında her seferinde istemci sırasını rastgeleleştirmelidir:\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order Faydalar: - İstemcilerin listedeki konumlarını öğrenmelerini önler - Konum değişikliklerine dayalı çıkarım saldırılarını önler - İstemcilerin eklenmesi/iptal edilmesini ayırt edilemez hale getirir\nİstemci Sayısını Gizleme:\nSunucular rastgele dummy girdiler (sahte girdiler) ekleyebilir:\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) Maliyet: Doldurma girdileri, şifrelenmiş LeaseSet boyutunu artırır (her biri 40 bayt).\nAuthCookie Rotasyonu:\nSunucular yeni bir authCookie oluşturmalıdır: - Şifrelenmiş bir LeaseSet yayımlandığında her seferinde (genellikle birkaç saatte bir) - Bir istemcinin yetkisini iptal ettikten hemen sonra - Hiçbir istemci değişikliği olmasa bile düzenli bir programa göre (örn. günlük)\nFaydalar: - authCookie kompromize olursa maruz kalmayı sınırlar - Yetkisi iptal edilen istemcilerin erişimi hızla kaybetmesini sağlar - Katman 2 için ileri gizlilik sağlar\nŞifrelenmiş LeaseSets (I2P\u0026rsquo;de bir hedefin gelen tunnel uçlarını ve anahtarlarını içeren kayıtlar) için Base32 Adresleme Genel Bakış Geleneksel I2P base32 adresleri yalnızca Destination (I2P hedef adresi) hash\u0026rsquo;ini içerir (32 bayt → 52 karakter). Bu, şifrelenmiş LeaseSets için yetersizdir çünkü:\nİstemcilerin, körleştirilmiş açık anahtarı türetebilmesi için körleştirilmemiş açık anahtar gereklidir İstemcilerin, doğru anahtar türetimi için imza türleri (körleştirilmemiş ve körleştirilmiş) gereklidir Yalnızca hash (özet) bu bilgiyi sağlamaz Çözüm: Açık anahtar ve imza türlerini içeren yeni bir base32 biçimi.\nAdres Biçimi Spesifikasyonu Çözümlenmiş Yapı (35 bayt):\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ İlk 3 Bayt (Checksum ile XOR):\nİlk 3 bayt, bir CRC-32 sağlama toplamının bölümleriyle XOR\u0026rsquo;lanmış üstveri içerir:\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey Sağlama Toplamı Özellikleri: - Standart CRC-32 polinomunu kullanır - Yanlış negatif oranı: ~16 milyonda 1 - Adres yazım hataları için hata tespiti sağlar - Kimlik doğrulama için kullanılamaz (kriptografik olarak güvenli değildir)\nKodlanmış Biçim:\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; Özellikler: - Toplam karakter sayısı: 56 (35 bayt × 8 bit ÷ karakter başına 5 bit) - Sonek: \u0026ldquo;.b32.i2p\u0026rdquo; (geleneksel base32 ile aynı) - Toplam uzunluk: 56 + 8 = 64 karakter (null sonlandırıcı hariç)\nBase32 Kodlaması: - Alfabe: abcdefghijklmnopqrstuvwxyz234567 (RFC 4648 standardı) - Sondaki kullanılmayan 5 bit MUTLAKA 0 olmalıdır - Büyük/küçük harfe duyarsızdır (gelenek gereği küçük harf)\nAdres Oluşturma import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address Adres Ayrıştırma import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype Geleneksel Base32 ile Karşılaştırma Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations ### Kullanım Kısıtlamaları BitTorrent Uyumsuzluğu:\nŞifreli LS2 adresleri BitTorrent\u0026rsquo;in compact announce yanıtlarıyla KULLANILAMAZ:\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ Sorun: Kompakt biçim yalnızca özeti (32 bayt) içerir; imza türleri veya açık anahtar bilgisi için yer yoktur.\nÇözüm: Tam announce yanıtlarını veya tam adresleri destekleyen HTTP tabanlı tracker\u0026rsquo;ları kullanın.\nAdres Defteri Entegrasyonu Bir istemcinin adres defterinde tam bir Destination (I2P hedef kimliği) varsa:\nTam Destination\u0026rsquo;ı (I2P hedef adresi; açık anahtarı içerir) kaydet Hash ile tersine aramayı destekle Şifreli LS2 ile karşılaşıldığında, açık anahtarı adres defterinden al Tam Destination zaten biliniyorsa yeni base32 biçimine gerek yok Şifreli LS2 (LeaseSet2)\u0026lsquo;yi destekleyen adres defteri formatları: - hosts.txt içinde tam destination dizeleri - destination sütunu olan SQLite veritabanları - tam destination verisi içeren JSON/XML formatları\nUygulama Örnekleri Örnek 1: Adres Oluştur\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p Örnek 2: Ayrıştır ve Doğrula\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) Örnek 3: Destination (hedef) üzerinden dönüştürme\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) Güvenlik Hususları Gizlilik: - Base32 adresi açık anahtarı ortaya çıkarır - Bu, kasıtlıdır ve protokol için gereklidir - Özel anahtarı KESİNLİKLE ifşa etmez veya güvenliği tehlikeye atmaz - Açık anahtarlar tasarım gereği herkese açık bilgidir\nÇakışma Direnci: - CRC-32 yalnızca 32 bit çakışma direnci sağlar - Kriptografik olarak güvenli değildir (yalnızca hata tespiti için kullanın) - Kimlik doğrulama için sağlama toplamına güvenmeyin - Tam hedef doğrulaması hâlâ gereklidir\nAdres Doğrulama: - Kullanımdan önce her zaman sağlama toplamını doğrulayın - Geçersiz imza türlerine sahip adresleri reddedin - Açık anahtarın eliptik eğri üzerinde olduğunu doğrulayın (uygulamaya özgü)\nReferanslar: - Teklif 149: Şifrelenmiş LS2 için B32 - B32 Adresleme Spesifikasyonu - I2P Adlandırma Spesifikasyonu Çevrimdışı Anahtar Desteği Genel Bakış Çevrimdışı anahtarlar, ana imzalama anahtarının çevrimdışı (soğuk depoda) kalmasını sağlarken, günlük işlemler için geçici bir imzalama anahtarının kullanılmasına olanak tanır. Bu, yüksek güvenlikli hizmetler için kritiktir.\nŞifreli LS2\u0026rsquo;ye Özgü Gereksinimler: - Geçici anahtarlar çevrimdışı olarak üretilmelidir - Körleştirilmiş özel anahtarlar önceden üretilmelidir (günde bir adet) - Hem geçici hem de körleştirilmiş anahtarlar toplu halde teslim edilmelidir - Henüz standartlaştırılmış bir dosya biçimi tanımlanmadı (spesifikasyonda TODO)\nÇevrimdışı Anahtar Yapısı Katman 0 Geçici Anahtar Verisi (0 numaralı bayrak biti 1 ise):\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ İmza Kapsamı: Çevrimdışı anahtar bloğundaki imza şunları kapsar: - Sona erme zaman damgası (4 bayt) - Geçici imza türü (2 bayt) - Geçici imzalama açık anahtarı (değişken)\nBu imza, körleştirilmiş açık anahtar kullanılarak doğrulanır ve bu da körleştirilmiş özel anahtara sahip tarafın bu geçici anahtarı yetkilendirdiğini kanıtlar.\nAnahtar Üretim Süreci Çevrimdışı anahtarlarla şifreli LeaseSet için:\nGeçici anahtar çiftleri oluştur (çevrimdışı, soğuk depolamada):\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\nHer gün için for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026quot;%Y%m%d\u0026quot;) # \u0026quot;YYYYMMDD\u0026quot; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) 3. **Sign transient keys with blinded keys** (offline): ```python for date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router: Her tarih için delivery_package[date] = { 'transient_privkey': keys[date][0], 'transient_pubkey': keys[date][1], 'blinded_privkey': blinded_keys[date][0], 'blinded_pubkey': blinded_keys[date][1], 'offline_sig_block': offline_sig_blocks[date] }\n### Router Usage **Daily Key Loading:** ```python # UTC\u0026#39;de gece yarısı (veya yayımlamadan önce) date = datetime.utcnow().date() # Bugün için anahtarları yükle today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # Bugünkü şifreli LeaseSet (I2P\u0026#39;de bir hedefin gelen tunnel bilgilerini içeren kayıt) için bu anahtarları kullanın Publishing Process:\n# 1. İç LeaseSet2 (LeaseSet\u0026#39;in 2. sürümü) oluşturun inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. Katman 2\u0026#39;yi Şifrele layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. Yetkilendirme verileriyle Katman 1\u0026#39;i oluşturun layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. Katman 1\u0026#39;i Şifrele layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. Katman 0\u0026#39;ı çevrimdışı imza bloğuyla oluşturun layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ) # 6. Katman 0\u0026#39;ı geçici özel anahtarla imzala signature = RED25519_SIGN(transient_privkey, layer0) # 7. İmzayı ekle ve yayımla encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# Her gün HEM yeni transient (geçici) anahtarlar HEM DE yeni blinded (körlenmiş) anahtarlar oluşturun for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - Şifrelenmiş anahtar materyali paketi - Kapsanan tarih aralığı OFFLINE_KEY_STATUS - Kalan gün sayısı - Bir sonraki anahtarın sona erme tarihi REVOKE_OFFLINE_KEYS - Geçersiz kılınacak tarih aralığı - Yerine konacak yeni anahtarlar (isteğe bağlı) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p Key Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# Şifreli LeaseSet\u0026#39;i etkinleştir i2cp.encryptLeaseSet=true # İsteğe bağlı: İstemci yetkilendirmesini etkinleştirin i2cp.enableAccessList=true # İsteğe bağlı: DH (Diffie-Hellman anahtar değişimi) yetkilendirmesini kullanın (varsayılan PSK\u0026#39;dir; pre-shared key - önceden paylaşılan anahtar). i2cp.accessListType=0 # İsteğe bağlı: Körleme sırrı (şiddetle önerilir) i2cp.blindingSecret=gizlinizi-buraya-yazın API Usage Example:\n// Şifrelenmiş bir LeaseSet oluştur EncryptedLeaseSet els = new EncryptedLeaseSet(); // Hedefi ayarla els.setDestination(destination); // Her istemci için yetkilendirmeyi etkinleştir els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // Yetkili istemcileri ekle (DH açık anahtarları) for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // Körleme parametrelerini ayarla els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // İmzala ve yayımla els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd Key Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Şifreli LeaseSet\u0026#39;i etkinleştir encryptleaseset = true # İsteğe bağlı: İstemci kimlik doğrulama türü (0=DH, 1=PSK) authtype = 0 # İsteğe bağlı: Körleme sırrı secret = sırrınız-buraya # İsteğe bağlı: Yetkilendirilmiş istemciler (her satıra bir, base64 ile kodlanmış açık anahtarlar) client.1 = base64-ile-kodlanmış-istemci-açık-anahtarı-1 client.2 = base64-ile-kodlanmış-istemci-açık-anahtarı-2 API Usage Example:\n// Şifrelenmiş LeaseSet oluştur auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // İstemci başına yetkilendirmeyi etkinleştir encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // Yetkilendirilmiş istemcileri ekle for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // İmzala ve yayınla encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# Test vektörü 1: Anahtar körleme destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # Beklenen: (referans uygulamayla karşılaştırarak doğrulayın) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets Red25519 Specification - Detailed Red25519 implementation B32 Addressing Specification - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # Ed25519 baz noktası (üreteç) B = 2**255 - 19 # Ed25519 mertebesi (skaler alan boyutu) L = 2**252 + 27742317777372353535851937790883648493 # İmza türü değerleri SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # Anahtar uzunlukları PRIVKEY_SIZE = 32 # bayt PUBKEY_SIZE = 32 # bayt SIGNATURE_SIZE = 64 # bayt ChaCha20 Constants # ChaCha20 parametreleri CHACHA20_KEY_SIZE = 32 # bayt (256 bit) CHACHA20_NONCE_SIZE = 12 # bayt (96 bit) CHACHA20_INITIAL_COUNTER = 1 # RFC 7539, 0 veya 1\u0026#39;e izin verir HKDF Constants # HKDF (HMAC tabanlı Anahtar Türetme Fonksiyonu) parametreleri HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # bayt (HashLen) # HKDF info dizeleri (alan ayrımı) HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # SHA-256 kişiselleştirme dizeleri HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # Katman 0 (dış) boyutları BLINDED_SIGTYPE_SIZE = 2 # bayt BLINDED_PUBKEY_SIZE = 32 # bayt (Red25519 için) PUBLISHED_TS_SIZE = 4 # bayt EXPIRES_SIZE = 2 # bayt FLAGS_SIZE = 2 # bayt LEN_OUTER_CIPHER_SIZE = 2 # bayt SIGNATURE_SIZE = 64 # bayt (Red25519) # Çevrimdışı anahtar blok boyutları OFFLINE_EXPIRES_SIZE = 4 # bytes OFFLINE_SIGTYPE_SIZE = 2 # bytes OFFLINE_SIGNATURE_SIZE = 64 # bytes # Katman 1 (orta) boyutları AUTH_FLAGS_SIZE = 1 # bayt EPHEMERAL_PUBKEY_SIZE = 32 # bayt (DH kimlik doğrulaması) AUTH_SALT_SIZE = 32 # bayt (PSK kimlik doğrulaması) NUM_CLIENTS_SIZE = 2 # bayt CLIENT_ID_SIZE = 8 # bayt CLIENT_COOKIE_SIZE = 32 # bayt AUTH_CLIENT_ENTRY_SIZE = 40 # bayt (CLIENT_ID + CLIENT_COOKIE) # Şifreleme ek yükü SALT_SIZE = 32 # bayt (her bir şifrelenmiş katmanın başına eklenir) # Base32 adresi B32_ENCRYPTED_DECODED_SIZE = 35 # bayt B32_ENCRYPTED_ENCODED_LEN = 56 # karakter B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# Hedef açık anahtarı (Ed25519) A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # secret boş Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 bayt salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) mod L Expected Output:\n(Referans implementasyonla karşılaştırarak doğrulayın) alpha = [64 baytlık onaltılık değer] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nciphertext = [RFC 7539 test vektörlerine göre doğrulayın] Test Vector 3: HKDF Input:\nsalt = bytes(32) # Tamamı sıfır ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [44 baytlık onaltılık değer] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32 bayt unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\naddress = [56 base32 karakter].b32.i2p # Sağlama toplamının doğru şekilde doğrulandığını teyit edin Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"Özel Destinations (I2P hedefleri) için erişim denetimli LeaseSet biçimi","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"Şifrelenmiş LeaseSet","url":"/tr/docs/specs/encryptedleaseset/"},{"categories":null,"content":"Genel Bakış Standart Base 32 (\u0026ldquo;b32\u0026rdquo;) adresleri hedefin özetini içerir. Bu, şifrelenmiş LS2 (öneri 123) için çalışmaz.\nŞifrelenmiş bir LS2 (öneri 123) için geleneksel bir base 32 adresini kullanamayız, çünkü yalnızca destination\u0026rsquo;ın (hedef kimliği) özetini içerir. Bu, körleştirilmemiş açık anahtarı sağlamaz. İstemciler, leaseSet\u0026rsquo;i almak ve şifresini çözmek için destination\u0026rsquo;ın açık anahtarını, imza türünü, körleştirilmiş imza türünü ve isteğe bağlı bir gizli ya da özel anahtarı bilmek zorundadır. Bu nedenle, tek başına bir base 32 adresi yetersizdir. İstemcinin ya (açık anahtarı içeren) tam destination\u0026rsquo;a ya da yalnızca açık anahtara ihtiyacı vardır. İstemcinin bir adres defterinde tam destination\u0026rsquo;ı varsa ve adres defteri hash ile ters aramayı destekliyorsa, açık anahtar elde edilebilir.\nBu biçim, base32 adresinde özet yerine açık anahtarı kullanır. Bu biçim ayrıca açık anahtarın imza türünü ve körleme şemasının imza türünü içermelidir.\nBu belge, bu adresler için bir b32 biçimini tanımlar. Tartışmalar sırasında bu yeni formata \u0026ldquo;b33\u0026rdquo; adresi olarak atıfta bulunsak da, asıl yeni format olağan \u0026ldquo;.b32.i2p\u0026rdquo; sonekini korur.\nUygulama Durumu Öneri 123 (Yeni netDB Girdileri), 0.9.43 sürümünde (Ekim 2019) tam olarak uygulandı. Şifreli LS2 (LeaseSet2 — yeni LeaseSet formatı) özellik kümesi, adresleme formatı veya kriptografik spesifikasyonlarda geriye dönük uyumluluğu bozan herhangi bir değişiklik olmaksızın 2.10.0 sürümüne (Eylül 2025) kadar istikrarlı kaldı.\nBaşlıca uygulama kilometre taşları: - 0.9.38: Çevrimdışı anahtarlarla standart LS2 için Floodfill desteği - 0.9.39: RedDSA (dijital imza şeması) imza türü 11 ve temel şifreleme/şifre çözme - 0.9.40: Tam B32 adresleme desteği (Öneri 149) - 0.9.41: X25519 tabanlı istemci başına kimlik doğrulama - 0.9.42: Tüm körleme özellikleri çalışır durumda - 0.9.43: Tam uygulamanın tamamlandığı ilan edildi (Ekim 2019)\nTasarım Yeni biçim, körlemesi kaldırılmış genel anahtar, körlemesi kaldırılmış imza türü ve körlenmiş imza türü içerir. İsteğe bağlı olarak özel bağlantılar için gizli ve/veya özel anahtar gereksinimlerini belirtir. Mevcut \u0026ldquo;.b32.i2p\u0026rdquo; sonekini kullanır, ancak daha uzundur. Hata tespiti için bir sağlama toplamı içerir. Şifrelenmiş leaseSet\u0026rsquo;ler için adresler, kodlanmış 56 veya daha fazla karakter (çözümlenmiş 35 veya daha fazla bayt) ile tanımlanır; geleneksel base 32 adreslerinde bu değer 52 karakter (32 bayt) şeklindedir. Teknik Şartname Oluşturma ve Kodlama Aşağıdaki şekilde {56+ karakter}.b32.i2p (ikili biçimde 35+ karakter) biçiminde bir ana bilgisayar adı oluşturun:\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype Son işleme ve sağlama toplamı:\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; b32 (base32 kodlaması) sonunda kalan kullanılmayan bitlerin tümü 0 olmalıdır. Standart 56 karakterlik (35 bayt) bir adres için kullanılmayan bit yoktur.\nKod Çözme ve Doğrulama strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key Gizli ve Özel Anahtar Bitleri Gizli ve özel anahtar bitleri, istemcilere, proxy\u0026rsquo;lere veya diğer istemci tarafı koda, leaseset\u0026rsquo;in şifresini çözmek için gizli ve/veya özel anahtarın gerekeceğini belirtmek için kullanılır. Belirli uygulamalar, kullanıcının gerekli verileri sağlamasını isteyebilir ya da gerekli veriler eksikse bağlantı girişimlerini reddedebilir.\nBu bitler yalnızca gösterge niteliğindedir. Gizli veya özel anahtar asla B32 adresinin kendisine dahil edilmemelidir, çünkü bu güvenliği tehlikeye atar.\nKriptografik Ayrıntılar Körleme Şeması Körleme şeması, Ed25519 ve ZCash\u0026rsquo;in tasarımını temel alan RedDSA\u0026rsquo;yı kullanarak, SHA-512 ile Ed25519 eğrisi üzerinde Red25519 imzaları üretir. Bu yaklaşım, körlenmiş açık anahtarların asal mertebeli altgrupta kalmasını sağlar ve bazı alternatif tasarımlarda mevcut olan güvenlik endişelerinden kaçınır.\nBlinded keys (körleştirilmiş anahtarlar), UTC tarihine göre her gün şu formül kullanılarak yenilenir:\nblinded_key = BLIND(unblinded_key, date, optional_secret) DHT (Dağıtık Karma Tablosu) depolama konumu şu şekilde hesaplanır:\nSHA256(type_byte || blinded_public_key) Şifreleme Şifrelenmiş leaseset, AES donanım hızlandırması bulunmayan cihazlarda üstün performansı nedeniyle seçilen ChaCha20 akış şifresini kullanır. Spesifikasyon, anahtar türetimi için HKDF ve Diffie-Hellman işlemleri için X25519 kullanır.\nŞifreli leasesets üç katmanlı bir yapıya sahiptir: - Dış katman: düz metin üstveri - Orta katman: istemci kimlik doğrulaması (DH veya PSK yöntemleri) - İç katman: lease bilgilerini içeren asıl LS2 verisi\nKimlik Doğrulama Yöntemleri İstemci başına kimlik doğrulama iki yöntemi destekler:\nDH Kimlik Doğrulama: X25519 anahtar değişimini kullanır. Yetkilendirilmiş her istemci ortak anahtarını sunucuya iletir ve sunucu, ECDH\u0026rsquo;den (Eliptik Eğri Diffie-Hellman) türetilen paylaşılan bir sır kullanarak orta katmanı şifreler.\nPSK Kimlik Doğrulaması: Şifreleme için önceden paylaşılan anahtarları doğrudan kullanır.\nB32 adresindeki 2. bayrak biti, istemci başına kimlik doğrulama gerekip gerekmediğini belirtir.\nÖnbellekleme Bu belirtimin kapsamı dışında olsa da, routers ve istemciler, açık anahtar ile destination (varış noktası) arasındaki eşlemeyi ve tersini hatırlamalı ve önbelleğe almalıdır (kalıcı olarak önerilir).\nblockfile naming service (blockfile adlandırma hizmeti), I2P\u0026rsquo;nin 0.9.8 sürümünden beri varsayılan adres defteri sistemi olup, karma üzerinden hızlı aramalar sağlayan özel bir ters arama eşlemesiyle birden çok adres defteri tutar. Bu işlev, başlangıçta yalnızca bir karma bilindiğinde, şifreli leaseSet çözümlemesi için kritik önem taşır.\nİmza Türleri I2P sürüm 2.10.0 itibarıyla, 0\u0026rsquo;dan 11\u0026rsquo;e kadar olan imza türleri tanımlanmıştır. Tek baytlı kodlama standart olmaya devam eder; iki baytlı kodlama mevcut olsa da pratikte kullanılmamaktadır.\nYaygın Olarak Kullanılan Türler: - Tür 0 (DSA_SHA1): routers için kullanımdan kaldırılmıştır, hedefler için desteklenir - Tür 7 (EdDSA_SHA512_Ed25519): router kimlikleri ve hedefler için güncel standart - Tür 11 (RedDSA_SHA512_Ed25519): yalnızca blinding (körleme) desteğine sahip şifreli LS2 leasesets için\nÖnemli Not: Yalnızca Ed25519 (tip 7) ve Red25519 (tip 11), şifreli leaseSet\u0026rsquo;ler için gerekli körleştirmeyi destekler. Diğer imza türleri bu özellik ile birlikte kullanılamaz.\n9-10 türleri (GOST algoritmaları) ayrılmıştır, ancak henüz uygulanmamıştır. 4-6 ve 8 türleri, çevrimdışı imzalama anahtarları için \u0026ldquo;yalnızca çevrimdışı\u0026rdquo; olarak işaretlenmiştir.\nNotlar Eski ve yeni varyantları uzunluğa göre ayırt edin. Eski b32 adresleri her zaman {52 karakter}.b32.i2p biçimindedir. Yenileri {56+ karakter}.b32.i2p biçimindedir base32 kodlaması, büyük/küçük harfe duyarsız çözümlemeyle RFC 4648 standartlarını izler ve çıktının küçük harf olması tercih edilir Daha büyük açık anahtarlara sahip imza türleri kullanıldığında adresler 200 karakteri aşabilir (örn. 132 baytlık anahtarlara sahip ECDSA P521) Yeni format, standart b32’de olduğu gibi istenirse jump links (adres atlama bağlantıları) içinde kullanılabilir (ve jump servers (adres atlama sunucuları) tarafından sunulabilir) Gizliliği artırmak için blinded keys (körleştirilmiş anahtarlar) UTC tarihine göre günlük olarak döndürülür Bu format, Tor\u0026rsquo;un rend-spec-v3.txt ek A.2 yaklaşımından ayrılır; off-curve blinded public keys (eğri dışında körleştirilmiş açık anahtarlar) ile potansiyel güvenlik etkileri söz konusudur Sürüm Uyumluluğu Bu spesifikasyon, I2P’nin 0.9.47 (Ağustos 2020) sürümünden 2.10.0 (Eylül 2025) sürümüne kadar olan sürümler için doğrudur. Bu dönem boyunca B32 adresleme biçimi, şifrelenmiş LS2 (LeaseSet2) yapısı veya kriptografik uygulamalarda geriye dönük uyumluluğu bozan herhangi bir değişiklik yapılmamıştır. 0.9.47 ile oluşturulan tüm adresler, mevcut sürümlerle tamamen uyumludur.\nKaynakça CRC-32 - CRC-32 (Vikipedi) - RFC 3309: Akış Denetimli İletim Protokolü Sağlama Toplamı I2P Spesifikasyonları - Şifreli LeaseSet Spesifikasyonu - Öneri 123: Yeni netDB Girdileri - Öneri 149: Şifreli LS2 (LeaseSet 2) için B32 - Ortak Yapılar Spesifikasyonu - Adlandırma ve Adres Defteri Tor Karşılaştırması - Tor tartışma dizisi (tasarım bağlamı) Ek Kaynaklar - I2P Projesi - I2P Forumu - Java API Belgeleri ","description":"Şifrelenmiş LS2 leaseSet'ler için Base 32 adres biçimi","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"Şifreli leaseSet'ler için B32","url":"/tr/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":" 1. Genel Bakış I2P\u0026rsquo;de bir taşıma, routers arasında doğrudan, noktadan noktaya iletişim yöntemidir. Bu mekanizmalar, router kimliğini doğrularken gizlilik ve bütünlüğü güvence altına alır.\nHer bir aktarım, kimlik doğrulama, akış kontrolü, onaylar ve yeniden iletim yetenekleri içeren bağlantı modellerini kullanarak çalışır.\n2. Mevcut Taşıma Protokolleri I2P şu anda iki birincil taşıma protokolünü destekler:\nTransport Protocol Description NTCP2 TCP Noise-based TCP transport with modern encryption (as of 0.9.36) SSU2 UDP Secure Semireliable UDP with modern encryption (as of 0.9.56) ### 2.1 Eski Taşıma Protokolleri (Kullanımdan Kaldırılmış) Transport Protocol Status NTCP TCP Replaced by NTCP2; removed in 0.9.62 SSU UDP Replaced by SSU2; removed in 0.9.62 --- 3. Taşıma Hizmetleri Taşıma alt sistemi aşağıdaki hizmetleri sunar:\n3.1 Mesaj Teslimi Güvenilir I2NP mesaj teslimi (taşıma protokolleri I2NP mesajlaşmasını münhasıran ele alır) Sıraya uygun teslimat evrensel olarak GARANTİ EDİLMEZ Öncelik temelli mesaj kuyruklama 3.2 Bağlantı Yönetimi Bağlantı kurulumu ve kapatılması Eşik değerlerinin uygulanmasıyla bağlantı sınırı yönetimi Her eş için durum takibi Otomatik ve manuel eş yasaklılar listesi uygulanması 3.3 Ağ Yapılandırması Her taşıma için birden çok router adresi (IPv4 ve IPv6 desteği v0.9.8\u0026rsquo;den beri) UPnP ile güvenlik duvarında bağlantı noktası açma NAT/güvenlik duvarı geçiş desteği Birden çok yöntemle yerel IP tespiti 3.4 Güvenlik Noktadan noktaya iletişim için şifreleme IP adreslerinin yerel kurallara göre doğrulanması Saat uzlaşısının belirlenmesi (yedek olarak NTP) 3.5 Bant Genişliği Yönetimi Gelen ve giden bant genişliği sınırları Giden iletiler için en uygun taşıma protokolü seçimi 4. Taşıma Adresleri Alt sistem, router iletişim noktaları listesini sürdürür:\nTaşıma yöntemi (NTCP2, SSU2) IP adresi Port numarası İsteğe bağlı parametreler Her taşıma yöntemi için birden fazla adres mümkündür.\n4.1 Yaygın Adres Yapılandırmaları Configuration Description Hidden Routers with no published addresses Firewalled Routers publishing SSU2 addresses with \"introducer\" peer lists for NAT traversal Unrestricted Routers advertising both NTCP2 and SSU2 addresses on IPv4 and/or IPv6 --- 5. Taşıma Seçimi Sistem, üst katman protokollerinden bağımsız olarak I2NP mesajları için taşıma protokollerini seçer. Seçim, her taşıma protokolünün teklif sunduğu ve en düşük teklifin kazandığı bir teklif verme sistemi kullanır.\n5.1 Teklif Belirleme Faktörleri Taşıma tercih ayarları Mevcut eş bağlantıları Mevcut ile eşik bağlantı sayıları Son bağlantı denemeleri geçmişi Mesaj boyutu kısıtları Eş RouterInfo (router bilgisi) taşıma yetenekleri Bağlantı doğrudanlığı (doğrudan veya introducer (aracılık eden düğüm) bağımlı) Eşin ilan ettiği taşıma tercihleri Genellikle, iki router aynı anda tek bir transport (taşıma) bağlantısını sürdürür; ancak eşzamanlı çoklu transport bağlantıları da mümkündür.\n6. NTCP2 NTCP2 (Yeni Taşıma Protokolü 2), I2P için TCP tabanlı modern bir taşıma protokolüdür ve 0.9.36 sürümünde tanıtılmıştır.\n6.1 Temel Özellikler Noise Protocol Framework\u0026rsquo;e (gürültü protokol çerçevesi) dayalı (Noise_XK pattern) Anahtar değişimi için X25519 kullanır Kimliği doğrulanmış şifreleme için ChaCha20/Poly1305 kullanır Karma için BLAKE2s kullanır DPI\u0026rsquo;ye (Deep Packet Inspection - derin paket inceleme) karşı dayanım için protokol gizleme Trafik analizi direnci için isteğe bağlı dolgu 6.2 Bağlantı Kurulumu Oturum İsteği (Alice → Bob): Geçici X25519 anahtarı + şifreli yük Oturum Oluşturuldu (Bob → Alice): Geçici anahtar + şifreli onay Oturum Onaylandı (Alice → Bob): RouterInfo ile son el sıkışması Bunu izleyen tüm veriler, el sıkışmadan türetilen oturum anahtarlarıyla şifrelenir.\nTüm ayrıntılar için NTCP2 Şartnamesi belgesine bakın.\n7. SSU2 SSU2 (Secure Semireliable UDP 2), I2P için modern UDP tabanlı taşıma protokolüdür ve 0.9.56 sürümünde tanıtılmıştır.\n7.1 Temel Özellikler Noise Protocol Framework (gürültü protokol çerçevesi) (Noise_XK deseni) üzerine kuruludur Anahtar değişimi için X25519 kullanır Kimliği doğrulanmış şifreleme için ChaCha20/Poly1305 kullanır Seçmeli onaylarla yarı güvenilir veri teslimi Delik açma ve aktarma/tanıştırma yoluyla NAT geçişi Bağlantı taşınması desteği Yol MTU keşfi 7.2 SSU (Eski) ile karşılaştırıldığında avantajlar Feature SSU (Legacy) SSU2 Encryption ElGamal + AES X25519 + ChaCha20/Poly1305 Header encryption Partial Full (ChaCha20) Connection ID Fixed Encrypted, rotatable NAT traversal Basic introduction Enhanced hole punching + relay Obfuscation Minimal Improved (variable padding) Tüm ayrıntılar için [SSU2 Specification](/docs/specs/ssu2/) belgesine bakın. 8. NAT Geçişi Her iki taşıma yöntemi de, güvenlik duvarı arkasındaki router\u0026rsquo;ların ağa katılabilmesi için NAT geçişini destekler.\n8.1 SSU2\u0026rsquo;ye Giriş Bir router doğrudan gelen bağlantıları kabul edemediğinde:\nRouter, introducer (tanıştırıcı) adreslerini kendi RouterInfo\u0026rsquo;sunda yayımlar Bağlanan eş, introducer\u0026rsquo;a bir tanıştırma isteği gönderir Introducer, bağlantı bilgilerini güvenlik duvarı arkasındaki router\u0026rsquo;a iletir Güvenlik duvarı arkasındaki router, giden bağlantıyı başlatır (hole punch - delik delme) Doğrudan iletişim kurulur 8.2 NTCP2 ve Güvenlik Duvarları NTCP2, gelen TCP bağlantısı gerektirir. NAT arkasındaki router\u0026rsquo;lar şunları yapabilir:\nPortları otomatik olarak açmak için UPnP kullanın Port yönlendirmesini manuel olarak yapılandırın Gelen bağlantılar için SSU2\u0026rsquo;ye güvenirken gidenler için NTCP2 kullanın 9. Protokol Gizleme Her iki modern taşıma protokolü de obfuscation (trafik gizleme) özellikleri barındırır:\nRastgele dolgu el sıkışma iletilerinde Şifrelenmiş başlıklar protokol imzalarını ifşa etmez Değişken uzunluklu iletiler trafik analizine direnmek için Sabit kalıplar yok bağlantı kurulumu sırasında Not: Taşıma katmanı gizleme, I2P\u0026rsquo;nin tunnel mimarisinin sağladığı anonimliğin yerine geçmez; onu tamamlar.\n10. Gelecekteki Geliştirmeler Planlanan araştırmalar ve iyileştirmeler şunları içerir:\nPluggable transports (takılabilir taşıma protokolleri) – Tor ile uyumlu gizleme eklentileri QUIC-based transport – QUIC protokolünün faydalarının incelenmesi Connection limit optimization – En uygun eş bağlantı sınırlarına yönelik araştırma Enhanced padding strategies – Trafik analizine karşı direncin artırılması 11. Referanslar NTCP2 Spesifikasyonu – Noise tabanlı TCP taşıma SSU2 Spesifikasyonu – Güvenli, yarı güvenilir UDP 2 I2NP Spesifikasyonu – I2P Ağ Protokolü mesajları Ortak Yapılar – RouterInfo ve adres yapıları Tarihsel NTCP Tartışması – Eski taşıma geliştirme geçmişi Eski SSU Dokümantasyonu – Orijinal SSU spesifikasyonu (kullanımdan kaldırıldı) ","description":"I2P'nin taşıma katmanını anlamak - NTCP2 ve SSU2 dahil olmak üzere routers arasında nokta-nokta iletişim yöntemleri","id":"5fbac972dc212081634c49c5e6ac0004","section":"docs","title":"Taşıma Katmanı","url":"/tr/docs/overview/transport/"},{"categories":null,"content":" Tarihsel Not: Bu sayfa, referans için eski “Unidirectional Tunnels” tartışmasını korur. Mevcut davranış için etkin tunnel uygulama dokümantasyonu sayfasına başvurun.\nGenel Bakış I2P tek yönlü tunnel\u0026rsquo;lar oluşturur: bir tunnel dışa giden trafiği taşır ve ayrı bir tunnel içe gelen yanıtları taşır. Bu yapı en eski ağ tasarımlarına kadar uzanır ve Tor gibi çift yönlü devreli sistemlerden temel bir fark olarak kalır. Terimler ve uygulama ayrıntıları için tunnel genel bakış ve tunnel spesifikasyonu bölümlerine bakın.\nİnceleme Tek yönlü tunnel\u0026rsquo;lar istek ve yanıt trafiğini ayrı tutar; bu nedenle, tek bir işbirliği yapan eş grubu bir gidiş-dönüşün yalnızca yarısını gözlemler. Zamanlama saldırılarının, tek bir devreyi analiz etmek yerine iki tunnel havuzunu (giden ve gelen) kesiştirmesi gerekir; bu da korelasyon için çıtayı yükseltir. Bağımsız gelen ve giden havuzlar, router\u0026rsquo;ların gecikme, kapasite ve hata yönetimi özelliklerini yön başına ayarlamasına olanak tanır. Dezavantajlar arasında, eş yönetimi karmaşıklığının artması ve güvenilir hizmet sunumu için birden çok tunnel kümesini sürdürme gereksinimi yer alır. Anonimlik Hermann ve Grothoff’un I2P is Slow… and What to Do About It makalesi, tek yönlü tunnels’a karşı öncül saldırıları analiz eder; kararlı saldırganların nihayetinde uzun süreli eşleri doğrulayabileceğini öne sürer. Topluluktan gelen geri bildirimler, çalışmanın saldırganın sabrı ve yasal yetkileri hakkında belirli varsayımlara dayandığını ve yaklaşımı, çift yönlü tasarımları etkileyen zamanlama saldırılarıyla kıyaslamadığını belirtir. Süregelen araştırmalar ve pratik deneyim, tek yönlü tunnels’ın bir gözden kaçırma değil, bilinçli bir anonimlik tercihi olduğu yönündeki kanaati pekiştirmeye devam ediyor.\n","description":"I2P'nin tek yönlü tunnel tasarımının tarihsel özeti.","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"Tek Yönlü Tunnels","url":"/tr/docs/legacy/unidirectional/"},{"categories":null,"content":" Kapsam: Bu kılavuz, tunnel uygulamasını, ileti biçimini ve her iki tunnel oluşturma belirtimini (ECIES (Eliptik Eğri Entegre Şifreleme Şeması) ve eski ElGamal (ElGamal şifreleme)) bir araya getirir. Mevcut derin bağlantılar yukarıdaki takma adlar aracılığıyla çalışmaya devam eder.\nTunnel Modeli I2P, yükleri tek yönlü tunnel\u0026rsquo;lar üzerinden iletir: bunlar, trafiği tek bir yönde taşıyan sıralı router kümeleridir. İki hedef arasındaki tam bir gidiş-dönüş için dört tunnel gerekir (iki giden, iki gelen).\nTerminoloji için Tunnel Genel Bakışı ile başlayın, ardından operasyonel ayrıntılar için bu kılavuzu kullanın.\nMesaj Yaşam Döngüsü tunnel geçidi, bir veya daha fazla I2NP mesajını toplar, bunları parçalara ayırır ve teslim talimatlarını yazar. Geçit, yükü sabit boyutlu (1024 B) bir tunnel mesajı içine kapsüller, gerekirse doldurma (padding) uygular. Her katılımcı, önceki atlamayı (hop) doğrular, kendi şifreleme katmanını uygular ve {nextTunnelId, nextIV, encryptedPayload} değerini bir sonraki atlamaya iletir. tunnel uç noktası, son katmanı kaldırır, teslim talimatlarını uygular, parçaları yeniden birleştirir ve yeniden oluşturulan I2NP mesajlarını iletir. Yinelenenleri tespit etme, IV (başlangıç vektörü) ile ilk şifreli metin bloğunun XOR (dışlayan veya) işlemiyle elde edilen değeri anahtar olarak kullanan, zamana bağlı bozunan bir Bloom filtresi kullanır; bu, IV değiştirmeye dayalı etiketleme saldırılarını önler.\nRollere Hızlı Bakış Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally ### Şifreleme İş Akışı {#encryption-workflow} Inbound tunnels: ağ geçidi katman anahtarıyla bir kez şifreler; aşağı yöndeki katılımcılar, oluşturucu son yükün şifresini çözene kadar şifrelemeye devam eder. Outbound tunnels: ağ geçidi, her atlamanın şifrelemesinin tersini önceden uygular; böylece her katılımcı şifreler. Uç nokta şifrelediğinde, ağ geçidinin asıl açık metni ortaya çıkar. Her iki yön de {tunnelId, IV, encryptedPayload} verisini bir sonraki atlama noktasına iletir.\nTunnel Mesaj Biçimi tunnel ağ geçitleri, payload (taşınan veri) uzunluğunu gizlemek ve per-hop (her atlama) işlemeyi basitleştirmek için I2NP iletilerini sabit boyutlu zarflara böler.\nŞifrelenmiş Yerleşim +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – Sonraki atlama için 32 bitlik tanımlayıcı (sıfır olmayan, her oluşturma döngüsünde değişir). IV (başlatma vektörü) – Her mesaj için seçilen 16 baytlık AES IV. Şifrelenmiş yük – 1008 baytlık AES-256-CBC şifreli metin. Toplam boyut: 1028 bayt.\nŞifresi Çözülmüş Yerleşim Bir hop (ara düğüm), kendi şifreleme katmanını kaldırdıktan sonra:\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... Sağlama toplamı şifresi çözülmüş bloğu doğrular. Dolgu bir sıfır baytla sonlandırılan rastgele sıfır olmayan baytlardır. Teslim talimatları uç noktaya her parçanın nasıl ele alınacağını söyler (yerel olarak teslim etme, başka bir tunnel’a iletme vb.). Parçalar altta yatan I2NP iletilerini taşır; uç nokta, bunları daha yüksek katmanlara iletmeden önce yeniden birleştirir. İşleme Adımları Ağ geçitleri I2NP iletilerini parçalara ayırır ve kuyruğa alır, yeniden birleştirme için kısmi parçaları kısa süreliğine tutar. Ağ geçidi yükü uygun katman anahtarlarıyla şifreler ve tunnel ID ile IV\u0026rsquo;yi ekler. Her katılımcı IV\u0026rsquo;yi (AES-256/ECB) ve ardından yükü (AES-256/CBC) şifreler, sonra IV\u0026rsquo;yi yeniden şifreleyip iletiyi iletir. Uç nokta ters sırada şifreyi çözer, sağlama toplamını doğrular, teslimat talimatlarını işler ve parçaları yeniden birleştirir. Tunnel Oluşturma (ECIES-X25519) Modern router\u0026rsquo;lar, ECIES-X25519 anahtarlarıyla tunnel kurar; bu, oluşturma mesajlarını küçültür ve ileri gizlilik sağlar.\nBuild message: tek bir TunnelBuild (veya VariableTunnelBuild) I2NP mesajı, her atlama için bir tane olmak üzere 1–8 şifreli oluşturma kaydı taşır. Layer keys: oluşturucular, atlama başına katman, IV ve yanıt anahtarlarını, atlamanın statik X25519 kimliği ve oluşturucunun geçici anahtarı kullanılarak HKDF ile türetir. Processing: her atlama kendi kaydının şifresini çözer, istek bayraklarını doğrular, yanıt bloğunu yazar (başarı ya da ayrıntılı hata kodu), kalan kayıtları yeniden şifreler ve mesajı iletir. Replies: oluşturucu, garlic (I2P\u0026rsquo;de birden çok mesajın tek bir şifreli kapsülde paketlenmesi tekniği) ile paketlenmiş bir yanıt mesajı alır. Hatalı olarak işaretlenen kayıtlar, router\u0026rsquo;ın eşi profilleyebilmesi için bir ciddiyet kodu içerir. Compatibility: router\u0026rsquo;lar geriye dönük uyumluluk için hâlâ eski ElGamal oluşturma yöntemlerini kabul edebilir, ancak yeni tunnel\u0026rsquo;ler varsayılan olarak ECIES kullanır. Alan bazında sabitler ve anahtar türetme notları için, ECIES (Eliptik Eğri Tümleşik Şifreleme Şeması) öneri geçmişine ve router kaynak koduna bakın; bu kılavuz çalışma akışını kapsar.\nEski Tunnel Oluşturma (ElGamal-2048) İlk tunnel oluşturma biçimi ElGamal açık anahtarlarını kullanıyordu. Modern routers, geriye dönük uyumluluk için sınırlı destek sağlamaya devam eder.\nDurum: Kullanımdan kaldırılmıştır. Tarihsel referans amacıyla ve geriye dönük uyumlu araçların bakımını yapanlar için burada tutulmaktadır.\nNon-interactive telescoping (etkileşimsiz teleskoplama): tek bir oluşturma iletisi tüm yolu geçer. Her atlama kendi 528 baytlık kaydını çözer, iletiyi günceller ve iletir. Değişken uzunluk: Variable Tunnel Build Message (VTBM) (değişken tunnel oluşturma iletisi) 1–8 kayda izin verirdi. Daha önceki sabit ileti, tunnel uzunluğunu gizlemek için her zaman sekiz kayıt içeriyordu. İstek kayıt düzeni: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding Bayraklar: 7. bit bir inbound gateway (gelen ağ geçidi) (IBGW) olduğunu belirtir; 6. bit bir outbound endpoint (giden uç nokta) (OBEP) olduğunu işaretler. Bunlar birbirini dışlar. Şifreleme: her kayıt, atlamanın açık anahtarıyla ElGamal-2048 kullanılarak şifrelenir. Simetrik AES-256-CBC katmanlaması, yalnızca hedeflenen atlamanın kendi kaydını okuyabilmesini sağlar. Temel bilgiler: tunnel ID\u0026rsquo;leri sıfır olmayan 32 bit değerlerdir; oluşturucular, gerçek tunnel uzunluğunu gizlemek için sahte kayıtlar ekleyebilir; güvenilirlik, başarısız oluşturma işlemlerini yeniden denemeye bağlıdır. Tunnel Havuzları ve Yaşam Döngüsü Routers, keşif trafiği ve her bir I2CP oturumu için birbirinden bağımsız gelen ve giden tunnel havuzları yönetir.\nEş seçimi: exploratory tunnels çeşitliliği teşvik etmek için “active, not failing” eş kovasından seçim yapar; client tunnels ise hızlı, yüksek kapasiteli eşleri tercih eder. Deterministik sıralama: eşler, SHA256(peerHash || poolKey) ile havuzun rastgele anahtarı arasındaki XOR mesafesine göre sıralanır. Anahtar, yeniden başlatıldığında döner; bu da tek bir çalıştırma içinde istikrar sağlarken farklı çalıştırmalar arasında öncül saldırılarını zorlaştırır. Yaşam döngüsü: routers, {mode, direction, length, variance} demetine (tuple) göre geçmiş kurma sürelerini izler. tunnels sona ermeye yaklaştıkça, yerlerini alacak olanlar erken başlatılır; router, başarısızlıklar olduğunda paralel kurma sayısını artırırken bekleyen deneme sayısını sınırlar. Yapılandırma ayarları: etkin/yedek tunnel sayıları, atlama (hop) uzunluğu ve varyansı, sıfır-atlama izinleri ve kurma hız limitleri, havuz başına ayarlanabilir. Tıkanıklık ve Güvenilirlik Her ne kadar tunnels devrelere benzese de, routers onları mesaj kuyrukları olarak ele alır. Weighted Random Early Discard (WRED) (Ağırlıklı Rastgele Erken Atma), gecikmeyi sınırlı tutmak için kullanılır:\nDüşürme olasılığı, kullanım yapılandırılmış sınırlara yaklaştıkça artar. Katılımcılar sabit boyutlu parçaları dikkate alır; ağ geçitleri/uç noktaları birleşik parça boyutuna göre düşürür, önce büyük yükleri düşürür. En az ağ çabası boşa gitsin diye, giden uç noktalar diğer rollerden önce düşürür. Garantili teslimat, Streaming library (akış kütüphanesi) gibi daha üst katmanlara bırakılmıştır. Güvenilirlik gerektiren uygulamalar, yeniden iletim ve onayları kendileri yönetmelidir.\nDaha Fazla Okuma Eş Seçimi Tunnel Genel Bakışı Eski Tunnel Gerçeklemesi ","description":"I2P tunnel’larının kurulumu ile trafiğin şifrelenmesi ve iletilmesine yönelik birleşik bir belirtim.","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"Tunnel İşlemleri Kılavuzu","url":"/tr/docs/specs/implementation/"},{"categories":null,"content":" Not: Bu arşiv, I2P 0.9.41 öncesine ait spekülatif tasarım çalışmalarını içerir. Üretim uygulaması için tunnel dokümantasyonunu inceleyin.\nYapılandırma Alternatifleri Gelecekteki tunnel ayarlarına yönelik değerlendirilen fikirler şunları içeriyordu:\nMesaj teslimi için frekans sınırlamaları Dolgu politikaları (chaff injection [sahte/boş trafik ekleme] dahil) Tunnel ömrü denetimleri Yük gönderimi için toplu iş ve kuyruk stratejileri Bu seçeneklerin hiçbiri eski gerçekleştirimle birlikte sunulmadı.\nDolgu Stratejileri Ele alınan olası doldurma yaklaşımları:\nHiç dolgu yok Rastgele uzunlukta dolgu Sabit uzunlukta dolgu En yakın kilobayta tamamlayan dolgu 2\u0026rsquo;nin kuvvetlerine göre dolgu (2^n bayt) Erken ölçümler (sürüm 0.4), mevcut sabit 1024 baytlık tunnel mesajı boyutunu belirledi. Daha üst düzey garlic mesajları (I2P\u0026rsquo;de birden çok mesajın tek pakette birleştirilmesi tekniği) kendi dolgularını ekleyebilir.\nParçalama Mesaj uzunluğu aracılığıyla etiketleme saldırılarını önlemek için, tunnel mesajları 1024 baytta sabitlenir. Daha büyük I2NP yükleri ağ geçidi tarafından parçalara ayrılır; uç nokta, kısa bir zaman aşımı içinde parçaları yeniden birleştirir. Routers, göndermeden önce paketleme verimliliğini en üst düzeye çıkarmak için parçaları yeniden düzenleyebilir.\nEk Alternatifler Tunnel işleme sürecinin ortasında ayarlama Üç olasılık incelendi:\nBir ara atlamanın, şifreleri çözülmüş yüklere erişim izni vererek bir tunnel\u0026rsquo;i geçici olarak sonlandırmasına izin verin. Katılımcı router\u0026rsquo;ların, bir sonraki atlamaya devam etmeden önce iletileri kendi giden tunnel\u0026rsquo;lerinden biri üzerinden göndererek “yeniden harmanlamasına” izin verin. Tunnel oluşturucusunun bir eşin bir sonraki atlamasını dinamik olarak yeniden tanımlamasına olanak tanıyın. İki Yönlü Tunnels Ayrı gelen ve giden tunnels kullanmak, herhangi bir eş kümesinin gözlemleyebileceği bilgiyi sınırlar (örn. bir GET isteğine karşılık büyük bir yanıt). Çift yönlü tunnels eş yönetimini basitleştirir ancak her iki yönde de eşzamanlı olarak tam trafik örüntülerini ifşa eder. Bu nedenle tek yönlü tunnels tercih edilen tasarım olarak kaldı.\nArka Kanallar ve Değişken Boyutlar Değişken tunnel mesaj boyutlarına izin vermek, işbirliği içinde olan eşler arasında (örneğin, seçilen boyutlar veya frekanslar üzerinden veriyi kodlayarak) örtük kanalların oluşturulmasına olanak tanır. Sabit boyutlu mesajlar, bu riski ilave dolgu yükü pahasına azaltır.\nTunnel Oluşturma Alternatifleri Kaynak: Hashing it out in Public Eski “Paralel” Derleme Yöntemi 0.6.1.10 sürümünden önce, tunnel oluşturma istekleri her katılımcıya paralel olarak gönderilirdi. Bu yöntem eski tunnel sayfasında belgelenmiştir.\nTek Seferde Teleskopik Oluşturma (Mevcut Yöntem) Modern yaklaşım, kısmen oluşturulmuş tunnel boyunca oluşturma iletilerini adım adım gönderir. Tor’un telescoping’ine (aşamalı kurulum tekniği) benzer olsa da, oluşturma iletilerini keşif tunnel\u0026rsquo;lar üzerinden yönlendirmek bilgi sızıntısını azaltır.\n“Etkileşimli” Telescoping (kademeli uzatma) Açık gidiş-dönüşlerle her seferinde tek bir atlama inşa etmek, eşlerin mesajları saymasına ve tunnel içindeki konumlarını çıkarsamasına olanak tanır; bu nedenle bu yaklaşım reddedildi.\nKeşif Amaçlı Olmayan Yönetim Tunnels Bir öneri, oluşturma trafiği için ayrı bir yönetim tunnels havuzu sürdürmekti. Bölünmüş router\u0026rsquo;lara yardımcı olabilse de, yeterli ağ entegrasyonu ile bunun gereksiz olduğu değerlendirildi.\nKeşif Teslimi (Eski) 0.6.1.10\u0026rsquo;dan önce, tekil tunnel istekleri garlic encryption ile şifrelenip keşif amaçlı tunnels üzerinden iletiliyor ve yanıtlar ayrı olarak geri dönüyordu. Bu strateji, mevcut one-shot telescoping method (tek atımlık teleskoplama yöntemi) ile değiştirildi.\nAna noktalar Sabit boyutlu tunnel mesajları, boyuta dayalı etiketleme ve gizli kanallara karşı koruma sağlar, ek dolgu maliyetine rağmen. Alternatif dolgulama, parçalama ve oluşturma stratejileri incelendi, ancak anonimlikteki ödünler dikkate alındığında benimsenmedi. Tunnel tasarımı, verimlilik, gözlemlenebilirlik ve öncül (predecessor) ile tıkanıklık (congestion) saldırılarına karşı dayanıklılık arasında denge kurmaya devam ediyor. ","description":"tunnel dolgulaması, parçalama ve oluşturma stratejilerinin tarihsel incelenmesi","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"Tunnel Tartışması","url":"/tr/docs/legacy/tunnel/"},{"categories":null,"content":"Genel Bakış I2P, geçici, tek yönlü tüneller oluşturur — şifrelenmiş trafiği ileten yönlendiricilerin sıralı dizileridir. Tüneller inbound (gelen, mesajlar oluşturucuya doğru akar) veya outbound (giden, mesajlar oluşturucudan uzağa akar) olarak sınıflandırılır.\nTipik bir değişimde Alice\u0026rsquo;in mesajı, giden tünellerinden biri üzerinden yönlendirilir, giden uç noktaya Bob\u0026rsquo;un gelen tünellerinden birinin ağ geçidine iletmesi talimatı verilir ve ardından Bob mesajı gelen uç noktasında alır.\nA: Giden Gateway (Alice) B: Giden Katılımcı C: Giden Uç Nokta D: Gelen Gateway E: Gelen Katılımcı F: Gelen Uç Nokta (Bob) Tunnel\u0026rsquo;ların sabit 10 dakikalık bir ömrü vardır ve mesaj boyutu veya zamanlama desenlerine dayalı trafik analizini önlemek için 1024 bayt (tunnel başlığı dahil 1028 bayt) sabit boyutlu mesajlar taşırlar.\nTunnel Sözlüğü Tunnel gateway (Tünel ağ geçidi): Bir tüneldeki ilk router. Gelen tüneller için, bu router\u0026rsquo;ın kimliği yayınlanan LeaseSet içinde görünür. Giden tüneller için, gateway başlangıç router\u0026rsquo;ıdır (yukarıdaki A ve D). Tunnel endpoint (Tünel uç noktası): Bir tüneldeki son router (yukarıdaki C ve F). Tunnel participant (Tünel katılımcısı): Bir tüneldeki ara router (yukarıdaki B ve E). Katılımcılar kendi konumlarını veya tünel yönünü belirleyemez. n-hop tunnel (n-atlamalı tünel): Router\u0026rsquo;lar arası atlama sayısı. 0-hop: Gateway ve endpoint aynı router\u0026rsquo;dır – minimum anonimlik. 1-hop: Gateway doğrudan endpoint\u0026rsquo;e bağlanır – düşük gecikme, düşük anonimlik. 2-hop: Keşif tünelleri için varsayılan; dengeli güvenlik/performans. 3-hop: Güçlü anonimlik gerektiren uygulamalar için önerilir. Tunnel ID: Her router ve her atlama için benzersiz olan 4 byte\u0026rsquo;lık tamsayı, oluşturucu tarafından rastgele seçilir. Her atlama farklı ID\u0026rsquo;ler üzerinde alır ve iletir. Tünel Oluşturma Bilgileri Gateway, katılımcı ve endpoint rollerini dolduran router\u0026rsquo;lar, Tunnel Build Message içinde farklı kayıtlar alır. Modern I2P iki yöntemi destekler:\nElGamal (eski, 528-bayt kayıtlar) ECIES-X25519 (güncel, 218-bayt kayıtlar Short Tunnel Build Message – STBM aracılığıyla) Information Distributed to Participants Gateway alır: - Tunnel katman anahtarı (tunnel türüne bağlı olarak AES-256 veya ChaCha20 anahtarı) - Tunnel IV anahtarı (başlatma vektörlerini şifrelemek için) - Yanıt anahtarı ve yanıt IV\u0026rsquo;si (derleme yanıtı şifrelemesi için) - Tunnel ID (yalnızca gelen gateway\u0026rsquo;ler için) - Sonraki atlama kimlik hash\u0026rsquo;i ve tunnel ID\u0026rsquo;si (terminal değilse)\nAra katılımcılar şunları alır: - Kendi atlamaları için tunnel katman anahtarı ve IV anahtarı - Tunnel ID ve sonraki atlama bilgisi - Oluşturma yanıtı şifrelemesi için yanıt anahtarı ve IV\nUç noktalar şunları alır: - Tunnel katmanı ve IV anahtarları - Yanıt router\u0026rsquo;ı ve tunnel kimliği (yalnızca giden uç noktalar) - Yanıt anahtarı ve IV (yalnızca giden uç noktalar)\nTüm detaylar için Tunnel Oluşturma Spesifikasyonu ve ECIES Tunnel Oluşturma Spesifikasyonu bölümlerine bakın.\nTunnel Pooling Router\u0026rsquo;lar yedeklilik ve yük dağılımı için tünelleri tünel havuzları halinde gruplar. Her havuz, birinin başarısız olması durumunda yük devretmeye olanak tanıyan birden fazla paralel tünel tutar. Dahili olarak kullanılan havuzlar exploratory tunnel\u0026rsquo;lardır (keşif tünelleri), uygulama özelindeki havuzlar ise client tunnel\u0026rsquo;lardır (istemci tünelleri).\nHer hedef, I2CP seçenekleriyle (tünel sayısı, yedek sayısı, uzunluk ve QoS parametreleri) yapılandırılan ayrı gelen ve giden havuzları tutar. Router\u0026rsquo;lar tünel sağlığını izler, periyodik testler çalıştırır ve havuz boyutunu korumak için başarısız tünelleri otomatik olarak yeniden inşa eder.\nTunnel Havuzu 0-hop Tüneller : Yalnızca makul inkar edilebilirlik sağlar. Trafik her zaman aynı router\u0026rsquo;da başlar ve sonlanır — anonim kullanım için önerilmez.\n1-hop Tünelleri: Pasif gözlemcilere karşı temel anonimlik sağlar ancak bir saldırgan o tek hop\u0026rsquo;u kontrol ediyorsa savunmasızdır.\n2 sekmeli Tüneller : İki uzak router içerir ve saldırı maliyetini önemli ölçüde artırır. Keşif havuzları için varsayılan ayardır.\n3 atlama Tünel: Güçlü anonimlik koruması gerektiren uygulamalar için önerilir. Ekstra atlamalar anlamlı bir güvenlik kazancı olmadan gecikme ekler.\nVarsayılanlar: Router\u0026rsquo;lar performans ve anonimlik dengesini sağlamak için 2 atlamalı keşif tünelleri ve uygulamaya özgü 2 veya 3 atlamalı istemci tünelleri kullanır.\nTünel Uzunluğu Router\u0026rsquo;lar periyodik olarak tünelleri test etmek için bir giden tünelden gelen bir tünele DeliveryStatusMessage göndererek test eder. Test başarısız olursa, her iki tünel de olumsuz profil ağırlığı alır. Ardışık başarısızlıklar bir tüneli kullanılamaz olarak işaretler; router daha sonra bir yedek oluşturur ve yeni bir LeaseSet yayınlar. Sonuçlar, eş seçim sistemi tarafından kullanılan eş kapasite metriklerine beslenir.\nTünel Testi Router\u0026rsquo;lar, etkileşimsiz bir teleskoplama yöntemi kullanarak tüneller oluşturur: tek bir Tunnel Build Message (Tünel Oluşturma Mesajı) atlama atlama yayılır. Her atlama kendi kaydının şifresini çözer, yanıtını ekler ve mesajı iletir. Son atlama, birleştirilmiş oluşturma yanıtını farklı bir yol üzerinden geri döndürerek korelasyonu önler. Modern uygulamalar ECIES için Short Tunnel Build Messages (STBM) ve eski yollar için Variable Tunnel Build Messages (VTBM) kullanır. Her kayıt, ElGamal veya ECIES-X25519 kullanılarak atlama başına şifrelenir.\nTünel Oluşturma Tünel trafiği çok katmanlı şifreleme kullanır. Mesajlar tünelden geçerken her atlama noktası bir şifreleme katmanı ekler veya kaldırır.\nElGamal tünelleri: PKCS#5 dolgusu ile yükler için AES-256/CBC. ECIES tünelleri: Kimlik doğrulamalı şifreleme için ChaCha20 veya ChaCha20-Poly1305. Her atlama iki anahtara sahiptir: bir katman anahtarı ve bir IV anahtarı. Router\u0026rsquo;lar IV\u0026rsquo;yi şifreler, yükü işlemek için kullanır, ardından iletmeden önce IV\u0026rsquo;yi yeniden şifreler. Bu çift IV şeması mesaj etiketlemeyi önler.\nGiden ağ geçitleri tüm katmanları önceden şifreler, böylece tüm katılımcılar şifreleme ekledikten sonra uç noktalar düz metin alır. Gelen tüneller ters yönde şifreler. Katılımcılar tünel yönünü veya uzunluğunu belirleyemez.\nTünel Şifreleme Ağ yük dengeleme için dinamik tunnel ömürleri ve uyarlanabilir havuz boyutlandırma Alternatif tunnel test stratejileri ve bireysel atlama tanılaması İsteğe bağlı proof-of-work veya bant genişliği sertifikası doğrulaması (API 0.9.65+ sürümünde uygulanmıştır) Uç nokta karıştırma için trafik şekillendirme ve chaff ekleme araştırması ElGamal\u0026rsquo;ın sürekli emekliye ayrılması ve ECIES-X25519\u0026rsquo;a geçiş Devam Eden Geliştirme Tunnel Uygulama Spesifikasyonu Tunnel Oluşturma Spesifikasyonu (ElGamal) Tunnel Oluşturma Spesifikasyonu (ECIES-X25519) Tunnel Mesaj Spesifikasyonu Garlic Routing I2P Ağ Veritabanı Eş Profilleme ve Seçimi I2P Tehdit Modeli ElGamal/AES + SessionTag Şifreleme I2CP Seçenekleri ","description":"I2P tünel terminolojisi, oluşturumu ve yaşam döngüsüne genel bakış","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"Tünel Yönlendirme","url":"/tr/docs/overview/tunnel-routing/"},{"categories":null,"content":"Genel Bakış Bu belirtim, I2P\u0026rsquo;de UDP BitTorrent duyuruları için protokolü belgeler. I2P\u0026rsquo;de BitTorrent\u0026rsquo;in genel belirtimi için I2P üzerinde BitTorrent belgelendirmesi sayfasına bakın. Bu belirtimin geliştirilmesine ilişkin arka plan ve ek bilgiler için Öneri 160 sayfasına bakın.\nBu protokol 24 Haziran 2025’te resmen onaylandı ve I2P 2.10.0 (API 0.9.67) sürümünde uygulandı; bu sürüm 8 Eylül 2025’te yayınlandı. UDP izleyici desteği, birden fazla üretim ortamı izleyicisi ve tam i2psnark istemci desteğiyle şu anda I2P ağında çalışır durumdadır.\nTasarım Bu belirtim, I2P Datagram Specification içinde tanımlandığı gibi, yanıtlanabilir datagram2, yanıtlanabilir datagram3 ve ham datagramları kullanır. Datagram2 ve Datagram3, Proposal 163 içinde tanımlanan yanıtlanabilir datagramların varyantlarıdır. Datagram2, yeniden oynatma saldırılarına karşı direnç ve çevrimdışı imza desteği ekler. Datagram3, eski datagram biçiminden daha küçüktür, ancak kimlik doğrulaması yoktur.\nBEP 15 (BitTorrent Geliştirme Önerisi 15) Referans için, BEP 15 belgesinde tanımlanan mesaj akışı şu şekildedir:\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. IP adresi sahteciliğini önlemek için bağlantı kurma aşaması gereklidir. Tracker, istemcinin sonraki duyuru isteklerinde kullanacağı bir bağlantı kimliği döndürür. Bu bağlantı kimliği, varsayılan olarak istemci tarafında bir dakika içinde, tracker tarafında ise iki dakika içinde geçerliliğini yitirir.\nI2P, mevcut UDP yetenekli istemci kod tabanlarında benimsenmeyi kolaylaştırmak, verimlilik ve aşağıda tartışılan güvenlik nedenleri için BEP 15 (BitTorrent Geliştirme Önerisi 15) ile aynı mesaj akışını kullanır:\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... Bu, streaming (TCP) duyurularına kıyasla potansiyel olarak büyük bir bant genişliği tasarrufu sağlar. Datagram2, bir streaming SYN ile yaklaşık aynı boyutta olsa da, ham yanıt, streaming SYN ACK’ten çok daha küçüktür. Sonraki istekler Datagram3 kullanır ve sonraki yanıtlar hamdır.\nTracker (izleyici sunucu)ın bağlantı kimliklerini announce hedeflerine veya hash’e eşleyen büyük bir eşleme tablosu tutmasına gerek kalmaması için announce istekleri Datagram3 biçimindedir. Bunun yerine, tracker, gönderen hash’inden, mevcut zaman damgasından (belirli bir aralığa dayalı) ve gizli bir değerden kriptografik olarak bağlantı kimlikleri üretebilir. Bir announce isteği alındığında, tracker bağlantı kimliğini doğrular ve ardından gönderim hedefi olarak Datagram3 gönderen hash’ini kullanır.\nBağlantı Ömrü BEP 15 , bağlantı kimliğinin istemcide bir dakika içinde, tracker (izleyici sunucu) tarafında ise iki dakika içinde süresinin dolduğunu belirtir. Bu yapılandırılabilir değildir. Bu durum, istemciler tüm announce\u0026rsquo;ları (duyuru isteği) bir dakikalık bir zaman dilimi içinde toplu halde göndermedikçe olası verimlilik kazanımlarını sınırlar. i2psnark şu anda announce\u0026rsquo;ları toplu göndermiyor; trafik patlamalarını önlemek için bunları zamana yayar. İleri düzey kullanıcıların aynı anda binlerce torrent çalıştırdığı bildiriliyor ve bu kadar çok announce\u0026rsquo;ı bir dakikaya sığdırmak gerçekçi değildir.\nBurada, bağlantı yanıtını isteğe bağlı bir bağlantı ömrü alanı ekleyecek şekilde genişletmeyi öneriyoruz. Alan yoksa varsayılan bir dakikadır. Aksi halde, istemci saniye cinsinden belirtilen ömrü kullanacak ve izleyici bağlantı kimliğini buna ek olarak bir dakika daha muhafaza edecektir.\nBEP 15 (BitTorrent Geliştirme Önerisi 15) ile uyumluluk Bu tasarım, mevcut istemciler ve izleyicilerde gereken değişiklikleri sınırlamak için mümkün olduğunca BEP 15 ile uyumluluğu korur.\nZorunlu tek değişiklik, announce yanıtındaki peer info biçimidir. Connect yanıtına lifetime alanının eklenmesi zorunlu değildir ancak yukarıda açıklandığı gibi verimlilik açısından şiddetle önerilir.\nGüvenlik Analizi Bir UDP duyuru protokolünün önemli bir amacı, adres sahteciliğini önlemektir. İstemci gerçekten var olmalı ve gerçek bir leaseSet\u0026rsquo;i eklemelidir. Connect Response\u0026rsquo;u alabilmek için gelen tunnel\u0026rsquo;lere sahip olmalıdır. Bu tunnel\u0026rsquo;ler zero-hop (sıfır atlamalı) olabilir ve anında kurulabilirler, ancak bu durum oluşturucuyu açığa çıkarır. Bu protokol bu amaca ulaşır.\nSorunlar Bu protokol körleştirilmiş hedefleri desteklemez, ancak bunu destekleyecek şekilde genişletilebilir. Aşağıya bakın.\nTeknik Şartname Protokoller ve Bağlantı Noktaları Yanıtlanabilir Datagram2, I2CP protokolü 19’u kullanır; yanıtlanabilir Datagram3, I2CP protokolü 20’yi kullanır; ham datagramlar I2CP protokolü 18’i kullanır. İstekler Datagram2 veya Datagram3 olabilir. Yanıtlar her zaman hamdır. I2CP protokolü 17’yi kullanan eski yanıtlanabilir datagram (\u0026ldquo;Datagram1\u0026rdquo;) biçimi istekler veya yanıtlar için KESİNLİKLE kullanılmamalıdır; istek/yanıt portlarında alınırsa bunlar düşürülmelidir. Datagram1’in 17 numaralı protokolünün DHT protokolü için hâlâ kullanıldığını unutmayın.\nİsteklerde, announce URL’sinden alınan I2CP \u0026ldquo;to port\u0026rdquo; değeri kullanılır; aşağıya bakın. İstek için \u0026ldquo;from port\u0026rdquo; istemci tarafından seçilir, ancak sıfır olmamalı ve yanıtların kolayca sınıflandırılabilmesi için DHT (Dağıtık Hash Tablosu) tarafından kullanılanlardan farklı bir port olmalıdır. Tracker’lar yanlış porttan gelen istekleri reddetmelidir.\nYanıtlar, istekteki I2CP \u0026ldquo;to port\u0026rdquo; değerini kullanır. Yanıtın \u0026ldquo;from port\u0026rdquo; değeri, istekteki \u0026ldquo;to port\u0026rdquo; değeridir.\nDuyuru URL\u0026rsquo;si BEP 15 ’te announce URL biçimi belirtilmemiştir, ancak açık internette olduğu gibi, UDP announce URL’leri \u0026ldquo;udp://host:port/path\u0026rdquo; biçimindedir. Yol (path) yok sayılır ve boş olabilir, ancak açık internette genellikle \u0026ldquo;/announce\u0026rdquo; olur. \u0026ldquo;:port\u0026rdquo; kısmı her zaman bulunmalıdır; ancak \u0026ldquo;:port\u0026rdquo; kısmı atlanmışsa, açık internette yaygın olarak kullanılan port olduğu için varsayılan I2CP portu olarak 6969’u kullanın. Ayrıca sonuna \u0026amp;a=b\u0026amp;c=d gibi CGI parametreleri eklenmiş olabilir; bunlar işlenip duyuru isteğinde sunulabilir, bkz. BEP 41 . Parametreler veya yol yoksa, BEP 41 ’de ima edildiği gibi, sondaki / da atlanabilir.\nDatagram Biçimleri Tüm değerler ağ bayt sırası (big endian; en anlamlı bayt önce) ile gönderilir. Paketlerin tam olarak belirli bir boyutta olmasını beklemeyin. Gelecekteki genişletmeler paketlerin boyutunu artırabilir.\nBağlantı İsteği İstemciden trackere (izleyici). 16 bayt. Yanıtlanabilir bir Datagram2 olmalıdır. BEP 15 ile aynıdır. Değişiklik yok.\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id Bağlantı Yanıtı İstemciye tracker (izleyici sunucu) tarafından. 16 ya da 18 bayt. Ham olmalıdır. Aşağıda belirtilenler dışında BEP 15 ile aynıdır.\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 Yanıt, istek \u0026ldquo;from port\u0026rdquo; olarak alınan I2CP \u0026ldquo;to port\u0026quot;a gönderilmelidir.\nlifetime alanı isteğe bağlıdır ve connection_id için istemci ömrünü saniye cinsinden belirtir. Varsayılan 60’tır ve belirtilmişse asgari değer 60’tır. Azami değer 65535’tir (yaklaşık 18 saat). Tracker (izleyici sunucusu), connection_id değerini istemci ömründen 60 saniye daha uzun süre korumalıdır.\nDuyuru İsteği İstemciden izleyiciye. En az 98 bayt. Yanıtlanabilir Datagram3 (Datagram sürüm 3) olmalıdır. Aşağıda belirtilenler dışında BEP 15 ile aynıdır.\nconnection_id, connect yanıtında alındığı gibidir.\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 BEP 15 \u0026rsquo;e göre değişiklikler:\nanahtar yok sayılır IP adresi kullanılmaz bağlantı noktası muhtemelen yok sayılır ama I2CP from port ile aynı olmalıdır Seçenekler bölümü, varsa, BEP 41 belgesinde tanımlandığı gibidir Yanıt, istek sırasında \u0026ldquo;from port\u0026rdquo; olarak alınan I2CP \u0026ldquo;to port\u0026rdquo; alanına gönderilmelidir. Duyuru isteğindeki portu kullanmayın.\nDuyuru Yanıtı Tracker\u0026rsquo;dan istemciye. En az 20 bayt. Ham olmalıdır. Aşağıda belirtilenler dışında BEP 15 ile aynıdır.\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 BEP 15 \u0026rsquo;e göre değişiklikler:\n6 baytlık IPv4+bağlantı noktası veya 18 baytlık IPv6+bağlantı noktası yerine, SHA-256 ikili eş karmalarını içeren, her biri 32 bayt olan \u0026ldquo;compact responses\u0026rdquo; (kompakt yanıtlar) öğelerinin katları halinde döndürürüz. TCP compact responses ile olduğu gibi, bir bağlantı noktası eklemeyiz. Yanıt, istekte \u0026ldquo;from port\u0026rdquo; olarak bildirilen değeri I2CP \u0026ldquo;to port\u0026rdquo; olarak kullanarak gönderilmek zorundadır. Duyuru isteğindeki bağlantı noktasını kullanmayın.\nI2P datagramlar yaklaşık 64 KB’lık çok büyük bir azami boyuta sahiptir; ancak, güvenilir iletim için 4 KB’den büyük datagramlardan kaçınılmalıdır. Bant kullanımında verimlilik için, tracker’lar (torrent izleme sunucuları) azami eş sayısını muhtemelen yaklaşık 50 ile sınırlandırmalıdır; bu, çeşitli katmanlardaki ek yükten önce yaklaşık 1600 baytlık bir pakete karşılık gelir ve parçalandıktan sonra iki tunnel iletisi yük sınırının içinde kalmalıdır.\nBEP 15’te olduğu gibi, takip edecek eş adreslerinin (BEP 15 için IP/port, burada ise hash’ler) sayısı dahil edilmemiştir. BEP 15’te düşünülmemiş olsa da, eş bilgileri tamamlandığını ve ardından bazı uzantı verilerinin geleceğini belirtmek için tamamı sıfırlardan oluşan bir end-of-peers marker (eşler-sonu işaretleyici) tanımlanabilir.\nGelecekte bu genişletme mümkün olabilsin diye, istemciler 32 baytlık, tamamen sıfırlardan oluşan bir hash’i ve onu izleyen tüm verileri göz ardı etmelidir. Tracker’lar, tamamen sıfırlardan oluşan bir hash’ten gelen announce’ları reddetmelidir; gerçi bu hash halihazırda Java router’lar tarafından yasaklanmıştır.\nKazıma BEP 15 \u0026rsquo;te tanımlanan scrape (tracker/izleyici durumu sorgusu) isteği/yanıtı bu belirtim tarafından zorunlu değildir; ancak istenirse herhangi bir değişiklik gerektirmeden uygulanabilir. İstemci önce bir bağlantı kimliği edinmelidir. Scrape isteği her zaman yanıtlanabilir Datagram3\u0026rsquo;tür. Scrape yanıtı her zaman hamdır.\nHata Yanıtı İzleyiciden istemciye. En az 8 bayt (mesaj boşsa). Ham olmalıdır. BEP 15 ile aynıdır. Değişiklik yok.\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message Uzantılar Uzantı bitleri veya bir sürüm alanı dahil edilmez. İstemciler ve tracker\u0026rsquo;lar (izleyiciler), paketlerin belirli bir boyutta olduğunu varsaymamalıdır. Bu sayede, uyumluluğu bozmadan ilave alanlar eklenebilir. Gerekirse, BEP 41 \u0026lsquo;de tanımlanan uzantılar biçimi önerilir.\nBağlanma yanıtı, isteğe bağlı bir bağlantı kimliği yaşam süresi eklemek için değiştirildi.\nKörleştirilmiş hedef desteği gerekiyorsa, körleştirilmiş 35 baytlık adresi announce isteğinin sonuna ekleyebiliriz ya da BEP 41 biçimini kullanarak (parametreler belirlenecek) yanıtlarda körleştirilmiş hash\u0026rsquo;ler talep edebiliriz. Tümü sıfırlardan oluşan 32 baytlık bir hash\u0026rsquo;in ardından, körleştirilmiş 35 baytlık eş (peer) adreslerinin kümesi announce yanıtının sonuna eklenebilir.\nUygulama Yönergeleri Entegre olmayan ve I2CP kullanmayan istemci ve tracker\u0026rsquo;ların (izleyici sunucuları) karşılaştığı zorlukların tartışıldığı yukarıdaki tasarım bölümüne bakın.\nİstemciler Belirli bir izleyici ana makine adı için, istemci HTTP URL’lerine kıyasla UDP’yi tercih etmeli ve ikisine birden duyuru yapmamalıdır.\nMevcut BEP 15 desteğine sahip istemciler yalnızca küçük değişiklikler gerektirmelidir.\nBir istemci DHT veya diğer datagram protokollerini destekliyorsa, yanıtların o porta dönmesi ve DHT iletileriyle karışmaması için, isteğin \u0026ldquo;from port\u0026rdquo; değeri olarak muhtemelen farklı bir port seçmelidir. İstemci, yanıt olarak yalnızca ham datagramlar alır. Tracker\u0026rsquo;lar istemciye asla yanıtlanabilir bir datagram2 göndermez.\nVarsayılan opentracker (herkese açık tracker) listesine sahip istemciler, bilinen opentracker\u0026rsquo;ların UDP\u0026rsquo;yi desteklediği doğrulandıktan sonra, listeyi UDP URL\u0026rsquo;leri ekleyecek şekilde güncellemelidir.\nİstemciler, isteklerin yeniden iletimini uygulayabilir veya uygulamayabilir. Yeniden iletimler, uygulanırsa, en az 15 saniyelik bir başlangıç zaman aşımı kullanmalı ve her yeniden iletimde zaman aşımını ikiye katlamalıdır (exponential backoff (üstel geri çekilme)).\nİstemciler bir hata yanıtı aldıktan sonra back off (yeniden denemeleri geciktirerek istek hızını azaltma) uygulamalıdır.\nİzleyiciler Mevcut BEP 15 desteğine sahip tracker\u0026rsquo;ların (izleyici) yalnızca küçük değişiklikler gerektirmesi beklenir. Bu spesifikasyon, 2014 tarihli öneriden şu açıdan farklıdır: tracker aynı bağlantı noktasında repliable datagram2 ve datagram3 alımını desteklemelidir.\nTracker (izleyici) kaynak gereksinimlerini en aza indirmek için, bu protokol, tracker’ın daha sonra doğrulama amacıyla istemci karmalarının bağlantı kimlikleriyle eşlemelerini depolamasını gerektiren herhangi bir zorunluluğu ortadan kaldıracak şekilde tasarlanmıştır. Bu, announce (duyuru) istek paketinin yanıtlanabilir bir Datagram3 paketi olması sayesinde mümkündür; bu nedenle gönderenin karmasını içerir.\nÖnerilen bir gerçekleme şöyledir:\nMevcut epoku, bağlantı ömrü çözünürlüğüyle ölçülen mevcut zaman olarak tanımlayın, epoch = now / lifetime. 8 bayt çıktısı üreten bir kriptografik özet (hash) fonksiyonunu H(secret, clienthash, epoch) olarak tanımlayın. Tüm bağlantılarda kullanılacak rastgele sabit gizli değeri üretin. Bağlantı yanıtlarında connection_id = H(secret, clienthash, epoch) üretin Announce isteklerinde, alınan bağlantı kimliğini mevcut epokta doğrulamak için connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1) ifadesini doğrulayın Dağıtım Durumu Bu protokol 24 Haziran 2025 tarihinde onaylandı ve Eylül 2025 itibarıyla I2P ağında tamamen faaliyette.\nMevcut Gerçeklemeler i2psnark: 8 Eylül 2025\u0026rsquo;te yayımlanan I2P sürüm 2.10.0\u0026rsquo;da (API 0.9.67) tam UDP tracker (izleyici sunucusu) desteği yer almaktadır. Bu sürümden itibaren tüm I2P kurulumları varsayılan olarak UDP tracker özelliğini içerir.\nzzzot tracker: Sürüm 0.20.0-beta2 ve üzeri UDP duyurularını destekler. Ekim 2025 itibarıyla, aşağıdaki production tracker\u0026rsquo;lar çalışır durumdadır: - opentracker.dg2.i2p - opentracker.simp.i2p - opentracker.skank.i2p\nİstemci Uyumluluk Notları SAM v3.3 sınırlamaları: SAM (Simple Anonymous Messaging) kullanan harici BitTorrent istemcileri, Datagram2/3 için SAM v3.3 desteği gerektirir. Bu, Java I2P\u0026rsquo;de mevcutken i2pd (C++ I2P uygulaması) tarafından şu anda desteklenmemektedir; bu da qBittorrent gibi libtorrent tabanlı istemcilerde benimsenmesini sınırlayabilir.\nI2CP istemcileri: I2CP\u0026rsquo;yi doğrudan kullanan istemciler (örneğin BiglyBT), SAM sınırlamaları olmadan UDP tracker desteğini uygulayabilir.\nKaynaklar [BEP15]: BitTorrent UDP Tracker Protokolü [BEP41]: UDP Tracker Protokolü Uzantıları [DATAGRAMS]: I2P Datagramları Şartnamesi [Prop160]: UDP Tracker\u0026rsquo;lar için Öneri [Prop163]: Datagram2 Önerisi [SPEC]: I2P üzerinden BitTorrent ","description":"I2P'de UDP tabanlı BitTorrent tracker announce (duyuru isteği) için protokol spesifikasyonu","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"UDP BitTorrent Duyuruları","url":"/tr/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":"Neden I2P\u0026rsquo;ye Özel Kod Yazılır? I2P\u0026rsquo;de uygulamaları kullanmanın birden fazla yolu vardır. I2PTunnel kullanarak, açık I2P desteği programlamaya gerek kalmadan normal uygulamaları kullanabilirsiniz. Bu, tek bir web sitesine bağlanmanız gereken istemci-sunucu senaryoları için çok etkilidir. Şekil 1\u0026rsquo;de gösterildiği gibi, o web sitesine bağlanmak için I2PTunnel kullanarak basitçe bir tunnel oluşturabilirsiniz.\nUygulamanız dağıtık ise, çok sayıda eşle bağlantı kurulması gerekecektir. I2PTunnel kullanırken, Şekil 2\u0026rsquo;de gösterildiği gibi, iletişim kurmak istediğiniz her eş için yeni bir tunnel oluşturmanız gerekir. Bu işlem elbette otomatikleştirilebilir, ancak çok sayıda I2PTunnel örneği çalıştırmak büyük miktarda ek yük oluşturur. Ayrıca, birçok protokolde tüm eşlerin aynı port setini kullanmasını zorlamanız gerekecektir — örneğin DCC sohbetini güvenilir şekilde çalıştırmak istiyorsanız, protokol TCP/IP\u0026rsquo;ye özgü bilgileri (host ve port) içerdiğinden, herkesin port 10001\u0026rsquo;in Alice, port 10002\u0026rsquo;nin Bob, port 10003\u0026rsquo;ün Charlie olduğu konusunda anlaşması gerekir.\nGenel ağ uygulamaları genellikle kullanıcıları tanımlamak için kullanılabilecek çok sayıda ek veri gönderir. Ana bilgisayar adları, port numaraları, saat dilimleri, karakter setleri vb. sıklıkla kullanıcıya bilgi verilmeden gönderilir. Bu nedenle, ağ protokolünü özellikle anonimlik göz önünde bulundurularak tasarlamak, kullanıcı kimliklerinin tehlikeye girmesini önleyebilir.\nI2P üzerinde nasıl etkileşim kurulacağını belirlerken gözden geçirilmesi gereken verimlilik hususları da vardır. Streaming kütüphanesi ve onun üzerine inşa edilen şeyler TCP\u0026rsquo;ye benzer el sıkışmalarla çalışırken, çekirdek I2P protokolleri (I2NP ve I2CP) kesinlikle mesaj tabanlıdır (UDP gibi veya bazı durumlarda ham IP gibi). Önemli ayrım şudur: I2P ile iletişim, uzun ve geniş bir ağ üzerinden gerçekleşir — her uçtan uca mesaj önemsiz olmayan gecikmelere sahip olacaktır, ancak birkaç KB\u0026rsquo;a kadar yük içerebilir. Basit bir istek ve yanıta ihtiyaç duyan bir uygulama, herhangi bir durumu ortadan kaldırabilir ve MTU algılama veya mesaj parçalama konusunda endişelenmeden (en iyi çaba) datagramları kullanarak başlatma ve sonlandırma el sıkışmaları tarafından oluşturulan gecikmeyi düşürebilir.\nFigure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. Özetle, I2P'ye özgü kod yazmanın birkaç nedeni: Çok sayıda I2PTunnel örneği oluşturmak önemsiz olmayan miktarda kaynak tüketir, bu da dağıtık uygulamalar için sorunludur (her eş için yeni bir tunnel gereklidir). Genel ağ protokolleri genellikle kullanıcıları tanımlamak için kullanılabilecek çok miktarda ek veri gönderir. I2P için özel olarak programlama yapmak, bu tür bilgileri sızdırmayan bir ağ protokolü oluşturulmasına olanak tanır ve kullanıcıları anonim ve güvenli tutar. Normal internet üzerinde kullanılmak üzere tasarlanmış ağ protokolleri, çok daha yüksek gecikme süresine sahip bir ağ olan I2P\u0026rsquo;de verimsiz olabilir. I2P, geliştiriciler için standart bir eklenti arayüzünü destekler, böylece uygulamalar kolayca entegre edilip dağıtılabilir.\nJava ile yazılmış ve standart webapps/app.war üzerinden bir HTML arayüzü kullanılarak erişilebilen/çalıştırılabilen uygulamalar, I2P dağıtımına dahil edilmek üzere değerlendirilebilir.\nÖnemli Kavramlar I2P kullanırken uyum sağlanması gereken birkaç değişiklik vardır:\nHedefler I2P üzerinde çalışan bir uygulama, benzersiz bir kriptografik olarak güvenli uç nokta olan bir \u0026ldquo;destination\u0026rdquo; (hedef) üzerinden mesaj gönderir ve alır. TCP veya UDP terimleriyle, bir destination büyük ölçüde bir hostname ve port numarası çiftinin eşdeğeri olarak düşünülebilir, ancak birkaç fark vardır.\nI2P destination\u0026rsquo;ın kendisi kriptografik bir yapıdır — bir hedefe gönderilen tüm veriler, sanki IPsec evrensel olarak dağıtılmış gibi şifrelenir ve son noktanın (anonimleştirilmiş) konumu, sanki DNSSEC evrensel olarak dağıtılmış gibi imzalanır. I2P destination\u0026rsquo;lar hareketli tanımlayıcılardır — bir I2P router\u0026rsquo;dan diğerine taşınabilirler (hatta \u0026ldquo;multihome\u0026rdquo; yapabilirler — aynı anda birden fazla router üzerinde çalışabilirler). Bu, tek bir son noktanın (port) tek bir host üzerinde kalması gereken TCP veya UDP dünyasından oldukça farklıdır. I2P destination\u0026rsquo;lar çirkin ve büyüktür — perde arkasında, şifreleme için 2048 bitlik bir ElGamal public key, imzalama için 1024 bitlik bir DSA public key ve iş kanıtı (proof of work) veya gizlenmiş veri içerebilen değişken boyutlu bir sertifika bulunur. Bu büyük ve çirkin hedeflere kısa ve hoş isimlerle (örn. \u0026ldquo;irc.duck.i2p\u0026rdquo;) atıfta bulunmanın mevcut yolları vardır, ancak bu teknikler global benzersizliği garanti etmez (çünkü her kişinin makinesinde yerel bir veritabanında saklanırlar) ve mevcut mekanizma özellikle ölçeklenebilir veya güvenli değildir (host listesine yapılan güncellemeler, isimlendirme servislerine \u0026ldquo;abonelikler\u0026rdquo; kullanılarak yönetilir). Belki bir gün güvenli, insan tarafından okunabilir, ölçeklenebilir ve global olarak benzersiz bir isimlendirme sistemi olabilir, ancak uygulamalar bunun mevcut olmasına bağımlı olmamalıdır. İsimlendirme sistemi hakkında daha fazla bilgi mevcuttur.\nÇoğu uygulama protokolleri ve portları ayırt etmeye ihtiyaç duymasa da, I2P bunları destekler. Karmaşık uygulamalar, tek bir hedef üzerinde trafiği çoğullamak için mesaj bazında bir protokol, kaynak port ve hedef port belirtebilir. Ayrıntılar için datagram sayfasına bakın. Basit uygulamalar, bir hedefin \u0026ldquo;tüm portlarında\u0026rdquo; \u0026ldquo;tüm protokolleri\u0026rdquo; dinleyerek çalışır.\nAnonimlik ve Gizlilik I2P, ağ üzerinden geçirilen tüm veriler için şeffaf uçtan uca şifreleme ve kimlik doğrulama sağlar — Bob, Alice\u0026rsquo;in hedefine gönderiyorsa, yalnızca Alice\u0026rsquo;in hedefi bunu alabilir ve Bob datagram veya streaming kütüphanesini kullanıyorsa, Alice, verileri gönderenin kesinlikle Bob\u0026rsquo;un hedefi olduğunu bilir.\nElbette I2P, Alice ve Bob arasında gönderilen verileri şeffaf bir şekilde anonimleştirir, ancak gönderdikleri içeriği anonimleştirmek için hiçbir şey yapmaz. Örneğin, Alice Bob\u0026rsquo;a tam adını, devlet kimlik bilgilerini ve kredi kartı numaralarını içeren bir form gönderirse, I2P\u0026rsquo;nin yapabileceği hiçbir şey yoktur. Bu nedenle, protokoller ve uygulamalar hangi bilgileri korumaya çalıştıklarını ve hangi bilgileri açığa çıkarmaya istekli olduklarını akılda tutmalıdır.\nI2P Datagramları Birkaç KB\u0026rsquo;a Kadar Olabilir I2P datagramları kullanan uygulamalar (ham veya yanıtlanabilir olanlar) esasen UDP açısından düşünülebilir — datagramlar sırasız, en iyi çaba ile gönderilir ve bağlantısızdır — ancak UDP\u0026rsquo;nin aksine, uygulamaların MTU tespiti konusunda endişelenmesine gerek yoktur ve basitçe büyük datagramlar gönderebilirler. Üst sınır nominal olarak 32 KB olsa da, mesaj aktarım için parçalandığından, bütünün güvenilirliği düşer. Şu anda yaklaşık 10 KB\u0026rsquo;ın üzerindeki datagramlar önerilmemektedir. Ayrıntılar için datagram sayfasına bakın. Birçok uygulama için 10 KB veri, tüm bir istek veya yanıt için yeterlidir ve bu, uygulamaların parçalama, yeniden gönderme vb. yazmak zorunda kalmadan I2P\u0026rsquo;de UDP benzeri bir uygulama olarak şeffaf bir şekilde çalışmasına olanak tanır.\nGeliştirme Seçenekleri I2P üzerinden veri göndermek için her birinin kendine özgü avantaj ve dezavantajları olan çeşitli yöntemler bulunmaktadır. Streaming kütüphanesi, I2P uygulamalarının çoğunluğu tarafından kullanılan önerilen arayüzdür.\nStreaming Kütüphanesi Tam streaming kütüphanesi artık standart arayüzdür. Streaming geliştirme kılavuzunda açıklandığı gibi, TCP benzeri soketler kullanarak programlama yapılmasına olanak tanır.\nBOB BOB, herhangi bir dildeki uygulamanın I2P\u0026rsquo;ye ve I2P\u0026rsquo;den akış bağlantıları kurmasını sağlayan Basic Open Bridge (Temel Açık Köprü)\u0026lsquo;dür. Şu anda UDP desteği bulunmamaktadır, ancak UDP desteği yakın gelecekte planlanmaktadır. BOB ayrıca destination key oluşturma ve bir adresin I2P spesifikasyonlarına uygun olup olmadığını doğrulama gibi çeşitli araçlar içerir. Güncel bilgiler ve BOB kullanan uygulamalar bu I2P Sitesi \u0026rsquo;nde bulunabilir.\nSAM, SAM V2, SAM V3 SAM önerilmez. SAM V2 uygun, SAM V3 önerilir.\nSAM, herhangi bir dilde yazılmış bir uygulamanın düz bir TCP soketi üzerinden bir SAM köprüsüyle iletişim kurmasına ve bu köprünün tüm I2P trafiğini çoğullamasına, şifreleme/şifre çözme ve olay tabanlı işlemeyi şeffaf bir şekilde koordine etmesine olanak tanıyan Simple Anonymous Messaging protokolüdür. SAM üç işletim stilini destekler:\nstream\u0026rsquo;ler, Alice ve Bob birbirlerine güvenilir bir şekilde ve sırayla veri göndermek istediklerinde yanıtlanabilir datagram\u0026rsquo;lar, Alice\u0026rsquo;in Bob\u0026rsquo;a Bob\u0026rsquo;un yanıtlayabileceği bir mesaj göndermek istediğinde ham datagram\u0026rsquo;lar, Alice mümkün olduğunca fazla bant genişliği ve performans elde etmek istediğinde ve Bob verinin göndereninin kimliği doğrulanmış olup olmadığını umursamadığında (örn. aktarılan veri kendi kendini doğrulayan türde) SAM V3, SAM ve SAM V2 ile aynı hedefe yönelir, ancak çoğullama/tekilleme (multiplexing/demultiplexing) gerektirmez. Her I2P akışı, uygulama ile SAM köprüsü arasında kendi soketi tarafından işlenir. Ayrıca, datagramlar SAM köprüsü ile datagram iletişimleri aracılığıyla uygulama tarafından gönderilebilir ve alınabilir.\nSAM V2 , SAM \u0026lsquo;deki bazı sorunları düzelten ve imule tarafından kullanılan yeni bir sürümdür.\nSAM V3 , imule tarafından 1.4.0 sürümünden itibaren kullanılmaktadır.\nI2PTunnel I2PTunnel uygulaması, uygulamaların eşlere yönelik belirli TCP benzeri tüneller oluşturmasına olanak tanır. Bu, ya I2PTunnel \u0026lsquo;istemci\u0026rsquo; uygulamaları (belirli bir portu dinleyen ve o porta bir soket açıldığında belirli bir I2P hedefine bağlanan) ya da I2PTunnel \u0026lsquo;sunucu\u0026rsquo; uygulamaları (belirli bir I2P hedefini dinleyen ve yeni bir I2P bağlantısı aldığında belirli bir TCP host/port\u0026rsquo;a outproxy yapan) oluşturarak gerçekleştirilir. Bu akışlar 8-bit temizdir ve SAM\u0026rsquo;in kullandığı aynı streaming kütüphanesi aracılığıyla kimlik doğrulaması yapılır ve güvenli hale getirilir, ancak birden fazla benzersiz I2PTunnel örneği oluşturmanın önemsiz olmayan bir maliyeti vardır, çünkü her birinin kendi benzersiz I2P hedefi ve kendi tunnel, anahtar vb. seti bulunur.\nSOCKS I2P, SOCKS V4 ve V5 proxy\u0026rsquo;sini destekler. Giden bağlantılar iyi çalışır. Gelen (sunucu) ve UDP işlevselliği eksik ve test edilmemiş olabilir.\nMinistreaming Kaldırıldı\nEskiden basit bir \u0026ldquo;ministreaming\u0026rdquo; kütüphanesi vardı, ancak şimdi ministreaming.jar yalnızca tam streaming kütüphanesi için arayüzleri içeriyor.\nDatagramlar UDP benzeri uygulamalar için önerilir\nDatagram kütüphanesi , UDP benzeri paketler göndermeyi sağlar. Kullanmak mümkündür:\nYanıtlanabilir datagramlar Ham datagramlar I2CP Önerilmez\nI2CP kendisi dilden bağımsız bir protokoldür, ancak Java dışında bir dilde I2CP kütüphanesi uygulamak için önemli miktarda kod yazılması gerekir (şifreleme rutinleri, nesne serileştirme, asenkron mesaj işleme, vb.). Birisi C veya başka bir dilde I2CP kütüphanesi yazabilse de, bunun yerine C SAM kütüphanesini kullanmak muhtemelen daha faydalı olacaktır.\nWeb Uygulamaları I2P, Jetty web sunucusu ile birlikte gelir ve bunun yerine Apache sunucusunu kullanacak şekilde yapılandırma oldukça basittir. Herhangi bir standart web uygulaması teknolojisi çalışmalıdır.\nGeliştirmeye Başlayın — Basit Bir Kılavuz I2P kullanarak geliştirme yapmak, çalışan bir I2P kurulumu ve kendi seçtiğiniz bir geliştirme ortamı gerektirir. Java kullanıyorsanız, streaming library veya datagram library ile geliştirmeye başlayabilirsiniz. Başka bir programlama dili kullanıyorsanız, SAM veya BOB kullanılabilir.\nStreaming Kütüphanesi ile Geliştirme Aşağıda, orijinal sayfadaki örneğin kısaltılmış ve güncellenmiş bir versiyonu bulunmaktadır. Tam örnek için eski sayfaya veya kod tabanımızdaki Java örneklerine bakın.\n// Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\u0026#34;Received: \u0026#34; + s); } Kod örneği: veri alan temel sunucu.\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\u0026#34;Hello I2P!\\n\u0026#34;); bw.flush(); Kod örneği: istemci bağlanıyor ve bir satır gönderiyor.\n","description":"Neden I2P'ye özgü uygulamalar yazmalı, temel kavramlar, geliştirme seçenekleri ve basit bir başlangıç kılavuzu","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"Uygulama Geliştirme","url":"/tr/docs/develop/applications/"},{"categories":null,"content":" Durum: Bu, v3dgsend yardımcı programı için özet bir referanstır. Datagram API ve SAM v3 belgelerini tamamlar.\nGenel Bakış v3dgsend, SAMv3 arayüzünü kullanarak I2P datagram\u0026rsquo;ları göndermek için bir komut satırı yardımcı aracıdır. Datagram teslimini test etmek, hizmet prototipleri oluşturmak ve tam bir istemci yazmadan uçtan uca davranışı doğrulamak için kullanışlıdır.\nTipik kullanımlar şunları içerir:\nBir Hedef\u0026rsquo;e datagram erişilebilirliğinin basit testini yapma Güvenlik duvarı ve adres defteri yapılandırmasını doğrulama Ham ve imzalı (yanıtlanabilir) datagram\u0026rsquo;lar ile deneyler yapma Kullanım Temel çağrı şekli, platforma ve paketlemeye göre değişir. Yaygın seçenekler şunlardır:\nDestination: base64 Destination veya .i2p adı Protocol: raw (PROTOCOL 18) veya signed (PROTOCOL 17) Payload: satır içi metin veya dosya girişi Tam bayraklar için dağıtımınızın paketlemesine veya --help çıktısına bakın.\nAyrıca Bakınız Datagram API SAM v3 Streaming Kütüphanesi (datagram\u0026rsquo;lara alternatif) ","description":"SAM v3 üzerinden I2P datagram gönderimi için CLI aracı","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/tr/docs/api/v3dgsend/"},{"categories":null,"content":"Bu kılavuz, yaygın tarayıcıların I2P\u0026rsquo;nin yerleşik HTTP proxy\u0026rsquo;si üzerinden trafik göndermesi için nasıl yapılandırılacağını gösterir. Safari, Firefox ve Chrome/Chromium tarayıcılarını ayrıntılı adım adım talimatlarla kapsar.\nÖnemli Notlar:\nI2P\u0026rsquo;nin varsayılan HTTP proxy\u0026rsquo;si 127.0.0.1:4444 adresini dinler. I2P, I2P ağı içindeki trafiği korur (.i2p siteleri). Tarayıcınızı yapılandırmadan önce I2P router\u0026rsquo;ınızın çalıştığından emin olun. Safari (macOS) Safari, macOS\u0026rsquo;ta sistem genelindeki proxy ayarlarını kullanır.\nStep 1: Open Network Settings Safari\u0026lsquo;yi açın ve Safari → Ayarlar (veya Tercihler) menüsüne gidin Gelişmiş sekmesine tıklayın Proxy\u0026rsquo;ler bölümünde Ayarları Değiştir\u0026hellip; seçeneğine tıklayın Bu, Mac\u0026rsquo;inizin Sistem Ağ Ayarları\u0026rsquo;nı açacaktır.\nAdım 1: Ağ Ayarlarını Açın Ağ ayarlarında, Web Proxy (HTTP) seçeneğinin kutusunu işaretleyin Aşağıdakileri girin: Web Proxy Server: 127.0.0.1 Port: 4444 Ayarlarınızı kaydetmek için Tamam\u0026lsquo;a tıklayın Artık Safari\u0026rsquo;de .i2p sitelerine göz atabilirsiniz!\nNot: Bu proxy ayarları, macOS sistem proxy\u0026rsquo;lerini kullanan tüm uygulamaları etkileyecektir. I2P tarayıcı kullanımını izole etmek istiyorsanız, ayrı bir kullanıcı hesabı oluşturmayı veya yalnızca I2P için farklı bir tarayıcı kullanmayı düşünün.\nFirefox (Desktop) Firefox, sistemden bağımsız kendi proxy ayarlarına sahiptir, bu da onu özel I2P taraması için ideal kılar.\nAdım 2: HTTP Proxy\u0026rsquo;yi Yapılandırın Sağ üstteki menü düğmesine (☰) tıklayın Ayarlar\u0026lsquo;ı seçin Step 2: Find Proxy Settings Ayarlar arama kutusuna \u0026ldquo;proxy\u0026rdquo; yazın Ağ Ayarları\u0026rsquo;na kaydırın Ayarlar\u0026hellip; düğmesine tıklayın Adım 1: Ayarları Açın Manuel vekil sunucu yapılandırması\u0026rsquo;nı seçin Aşağıdakileri girin: HTTP Proxy: 127.0.0.1 Port: 4444 SOCKS Host alanını boş bırakın (özellikle SOCKS proxy\u0026rsquo;ye ihtiyacınız olmadığı sürece) Yalnızca SOCKS proxy kullanıyorsanız Proxy DNS when using SOCKS seçeneğini işaretleyin Kaydetmek için Tamam\u0026lsquo;a tıklayın Artık Firefox\u0026rsquo;ta .i2p sitelerine göz atabilirsiniz!\nİpucu: I2P tarama için ayrılmış ayrı bir Firefox profili oluşturmayı düşünün. Bu, I2P taramanızı normal taramadan izole tutar. Bir profil oluşturmak için Firefox adres çubuğuna about:profiles yazın.\nChrome / Chromium (Desktop) Chrome ve Chromium tabanlı tarayıcılar (Brave, Edge, vb.) genellikle Windows ve macOS\u0026rsquo;ta sistem proxy ayarlarını kullanır. Bu kılavuz Windows yapılandırmasını gösterir.\nAdım 2: Proxy Ayarlarını Bulun Sağ üst köşedeki üç nokta menüsüne (⋮) tıklayın Settings seçeneğini seçin Adım 3: Manuel Proxy Yapılandırması Ayarlar arama kutusuna \u0026ldquo;proxy\u0026rdquo; yazın Bilgisayarınızın proxy ayarlarını aç seçeneğine tıklayın Step 3: Open Manual Proxy Setup Bu, Windows Ağ ve İnternet ayarlarını açacaktır.\nManuel proxy kurulumu\u0026rsquo;na kadar aşağı kaydırın Ayarla\u0026lsquo;ya tıklayın Adım 1: Chrome Ayarlarını Açın Proxy sunucusu kullan seçeneğini Açık konuma getirin Aşağıdakileri girin: Proxy IP adresi: 127.0.0.1 Port: 4444 İsteğe bağlı olarak, \u0026ldquo;Şununla başlayan adresler için proxy sunucusu kullanma\u0026rdquo; bölümüne istisnalar ekleyin (örn., localhost;127.*) Kaydet\u0026rsquo;e tıklayın Artık Chrome\u0026rsquo;da .i2p sitelerine göz atabilirsiniz!\nNot: Bu ayarlar Windows\u0026rsquo;ta tüm Chromium tabanlı tarayıcıları ve diğer bazı uygulamaları etkiler. Bundan kaçınmak için, bunun yerine özel bir I2P profili ile Firefox kullanmayı düşünün.\nAdım 2: Proxy Ayarlarını Açın Linux\u0026rsquo;ta, sistem ayarlarını değiştirmekten kaçınmak için Chrome/Chromium\u0026rsquo;u proxy bayraklarıyla başlatabilirsiniz:\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; Veya bir masaüstü başlatıcı betiği oluşturun:\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; --user-data-dir bayrağı I2P taraması için ayrı bir Chrome profili oluşturur.\nFirefox (Masaüstü) Modern \u0026ldquo;Fenix\u0026rdquo; Firefox sürümleri varsayılan olarak about:config ve eklentileri kısıtlar. IceRaven, seçilmiş bir eklenti setini etkinleştiren ve proxy kurulumunu basitleştiren bir Firefox türevi (fork) yazılımdır.\nUzantı tabanlı yapılandırma (IceRaven):\nEğer zaten IceRaven kullanıyorsanız, önce tarayıcı geçmişini temizlemeyi düşünün (Menü → Geçmiş → Geçmişi Sil). 2) Menü → Eklentiler → Eklenti Yöneticisi\u0026rsquo;ni açın. 3) \u0026ldquo;I2P Proxy for Android and Other Systems\u0026rdquo; uzantısını yükleyin. 4) Tarayıcı artık I2P üzerinden proxy kullanacaktır. Bu eklenti, AMO \u0026lsquo;dan kurulduğunda Fenix öncesi Firefox tabanlı tarayıcılarda da çalışır.\nFirefox Nightly\u0026rsquo;da geniş eklenti desteğini etkinleştirmek, Mozilla tarafından belgelenen ayrı bir süreç gerektirir.\nInternet Explorer / Windows System Proxy Windows\u0026rsquo;ta sistem proxy diyalogu IE için geçerlidir ve Chromium tabanlı tarayıcılar sistem ayarlarını miras aldığında kullanılabilir.\n\u0026ldquo;Ağ ve İnternet Ayarları\u0026rdquo; → \u0026ldquo;Proxy\u0026rdquo; açın. 2) \u0026ldquo;LAN için bir proxy sunucusu kullan\u0026rdquo; seçeneğini etkinleştirin. 3) HTTP için adres 127.0.0.1, port 4444 olarak ayarlayın. 4) İsteğe bağlı olarak \u0026ldquo;Yerel adresler için proxy sunucusunu atla\u0026rdquo; seçeneğini işaretleyin. ","description":"Masaüstü ve Android'de popüler tarayıcıları I2P'nin HTTP/HTTPS proxy'lerini kullanacak şekilde yapılandırma","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"Web Tarayıcı Yapılandırması","url":"/tr/docs/guides/browser-config/"},{"categories":null,"content":"Genel Bakış Router\u0026rsquo;lar, I2P ağı aracılığıyla dağıtılan imzalı bir haber akışını periyodik olarak sorgulayarak güncellemeleri otomatik olarak denetler. Daha yeni bir sürüm duyurulduğunda, router kriptografik olarak imzalanmış bir güncelleme arşivini (.su3) indirir ve kuruluma hazırlar. Bu sistem, resmi sürümlerin kimliği doğrulanmış, kurcalamaya karşı dayanıklı ve çok kanallı dağıtımını sağlar.\nI2P 2.10.0 itibarıyla, güncelleme sistemi şunları kullanır:\nRSA-4096 / SHA-512 imzaları SU3 kapsayıcı biçimi (eski SUD/SU2\u0026rsquo;nin yerini alır) Yedekli yansılar: ağ içi HTTP, clearnet (açık internet) HTTPS ve BitTorrent 1. Haber Kaynağı Routers, yeni sürümleri ve güvenlik duyurularını keşfetmek için imzalı Atom akışını her birkaç saatte bir sorgular. Akış imzalanır ve .su3 dosyası olarak dağıtılır; şu öğeleri içerebilir:\n\u0026lt;i2p:version\u0026gt; — yeni sürüm numarası \u0026lt;i2p:minVersion\u0026gt; — desteklenen en düşük router sürümü \u0026lt;i2p:minJavaVersion\u0026gt; — gerekli en düşük Java çalışma zamanı \u0026lt;i2p:update\u0026gt; — birden çok indirme aynasını listeler (I2P, HTTPS, torrent) \u0026lt;i2p:revocations\u0026gt; — sertifika iptal verileri \u0026lt;i2p:blocklist\u0026gt; — ele geçirilmiş eşler için ağ düzeyi engelleme listeleri Besleme Dağıtımı Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load Router'lar I2P beslemesini tercih eder, ancak gerekirse clearnet veya torrent dağıtımına geri dönebilir. 2. Dosya Biçimleri SU3 (Güncel Standart) 0.9.9 sürümünde tanıtılan SU3, eski SUD ve SU2 formatlarının yerini aldı. Her dosya bir başlık, payload (yük) ve sonda yer alan bir imza içerir.\nBaşlık Yapısı \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Field\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Magic\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I2Psu3\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Format Version\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;e.g., \u0026lt;code\u0026gt;0x000B\u0026lt;/code\u0026gt; (RSA-SHA512-4096)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Length\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;512 bytes\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Version String\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Router version\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signer ID\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Certificate name\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Content Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;1 = router update, 3 = reseed, 4 = news feed\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; İmza Doğrulama Adımları 1. Başlığı ayrıştırın ve imza algoritmasını belirleyin. 2. İmzalayanın saklanan sertifikasını kullanarak özeti ve imzayı doğrulayın. 3. İmzalayanın sertifikasının iptal edilmediğini doğrulayın. 4. Gömülü sürüm dizesini yük üstverisiyle karşılaştırın.\nRouters, güvenilir imzalayıcı sertifikalarıyla (şu anda zzz ve str4d) birlikte gelir ve imzasız veya iptal edilmiş kaynakları reddeder.\nSU2 (Kullanımdan kaldırıldı) Pack200 (Java JAR arşivleri için bir sıkıştırma biçimi) ile sıkıştırılmış JAR\u0026rsquo;larda .su2 uzantısı kullanıldı. Java 14\u0026rsquo;te Pack200 (JEP 367) kullanımdan kaldırıldıktan sonra çıkarıldı. I2P 0.9.48+ sürümünde devre dışı bırakıldı; artık tamamen ZIP sıkıştırması ile değiştirildi. SUD (Eski) Erken DSA-SHA1 ile imzalanmış ZIP formatı (0.9.9 öncesi). İmzalayan kimliği veya başlık yok, bütünlük sınırlı. Zayıf kriptografi ve sürüm zorlamasının olmaması nedeniyle yerini yenisine bıraktı. 3. Güncelleme İş Akışı 3.1 Başlık Doğrulaması Router\u0026rsquo;lar, tam dosyaları indirmeden önce sürüm dizesini doğrulamak için yalnızca SU3 header\u0026lsquo;ı alır. Bu, eski yansılarda ya da güncel olmayan sürümlerde bant genişliğinin boşa harcanmasını önler.\n3.2 Tam İndirme Üstbilgiyi doğruladıktan sonra, router tam .su3 dosyasını şuralardan indirir: - Ağ içi eepsite yansıları (tercih edilir) - HTTPS clearnet (açık internet) yansıları (yedek) - BitTorrent (isteğe bağlı eş destekli dağıtım)\nİndirmeler, tekrar deneme, zaman aşımı yönetimi ve yedek aynaya geçiş özellikleriyle standart I2PTunnel HTTP istemcilerini kullanır.\n3.3 İmza Doğrulama İndirilen her dosya şu aşamalardan geçer: - İmza kontrolü: RSA-4096/SHA512 doğrulaması - Sürüm eşleşmesi: Başlık ile payload (yük) sürüm kontrolü - Eski sürüme düşürmeyi önleme: Güncellemenin yüklü sürümden daha yeni olmasını sağlar\nGeçersiz veya eşleşmeyen dosyalar hemen atılır.\n3.4 Aşamalı Kurulum Doğrulandıktan sonra: 1. ZIP içeriğini geçici dizine çıkarın 2. deletelist.txt içinde listelenen dosyaları silin 3. lib/jbigi.jar dahilse yerel kütüphaneleri değiştirin 4. İmzalayanın sertifikalarını ~/.i2p/certificates/ konumuna kopyalayın 5. Bir sonraki yeniden başlatmada uygulanmak üzere güncellemeyi i2pupdate.zip\u0026lsquo;e taşıyın\nGüncelleme, bir sonraki başlatmada veya “Install update now” elle tetiklendiğinde otomatik olarak yüklenir.\n4. Dosya Yönetimi deletelist.txt Yeni içerikleri açmadan önce kaldırılacak kullanımdan kalkmış dosyaların düz metin listesi.\nKurallar: - Her satırda bir yol (yalnızca göreli yollar) - # ile başlayan satırlar yok sayılır - .. ve mutlak yollar reddedilir\nYerel kütüphaneler Güncel olmayan veya uyumsuz yerel ikili dosyaları önlemek için: - lib/jbigi.jar varsa, eski .so veya .dll dosyaları silinir - Platforma özgü kütüphanelerin yeniden çıkarılmasını sağlar\n5. Sertifika Yönetimi Routers güncellemeler veya haber akışındaki iptaller aracılığıyla yeni imzalayıcı sertifikaları alabilir.\nYeni .crt dosyaları sertifika dizinine kopyalanır. İptal edilmiş sertifikalar gelecekteki doğrulamalardan önce silinir. Manuel kullanıcı müdahalesi gerektirmeden anahtar döndürmeyi destekler. Tüm güncellemeler, air-gapped signing systems (ağdan yalıtılmış imzalama sistemleri) kullanılarak çevrimdışı olarak imzalanır. Özel anahtarlar hiçbir zaman derleme sunucularında saklanmaz.\n6. Geliştirici Yönergeleri Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. Gelecek sürümler, post-kuantum imza entegrasyonunu (bkz. Proposal 169) ve yeniden üretilebilir derlemeleri inceleyecek. 7. Güvenliğe Genel Bakış Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity --- 8. Sürümleme Router: 2.10.0 (API 0.9.67) Anlamsal sürümleme Major.Minor.Patch ile. Minimum sürüm zorlaması güvensiz yükseltmeleri önler. Desteklenen Java: Java 8–17. Gelecek 2.11.0+ sürümleri Java 17+ gerektirecek. ","description":"I2P routers için güvenli, imzalı güncelleme mekanizması ve besleme yapısı","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"Yazılım Güncelleme Spesifikasyonu","url":"/tr/docs/specs/updates/"},{"categories":null,"content":"I2P\u0026rsquo;yi dünya çapında daha fazla insana ulaştırmak için yardım etmek ister misiniz? Çeviri, projeye yapabileceğiniz en değerli katkılardan biridir. Bu kılavuz, router konsolu çevirme sürecinde size rehberlik edecektir.\nÇeviri Yöntemleri Çevirilere katkıda bulunmanın iki yolu vardır:\nYöntem 1: Transifex (Önerilen) Bu, I2P\u0026rsquo;yi çevirmenin en kolay yoludur. Transifex, çeviriyi basit ve erişilebilir kılan web tabanlı bir arayüz sağlar.\nTransifex adresinden kayıt olun I2P çeviri ekibine katılma isteği gönderin Doğrudan tarayıcınızda çeviri yapmaya başlayın Teknik bilgi gerekmez - sadece kaydolun ve çeviriye başlayın!\nYöntem 2: Manuel Çeviri Git ve yerel dosyalarla çalışmayı tercih eden çevirmenler için veya henüz Transifex\u0026rsquo;te kurulmamış diller için.\nGereksinimler: - Git sürüm kontrol sistemi bilgisi - Metin düzenleyici veya çeviri aracı (POEdit önerilir) - Komut satırı araçları: git, gettext\nKurulum: 1. IRC\u0026rsquo;de #i2p-dev kanalına katılın ve kendinizi tanıtın 2. Wiki\u0026rsquo;deki çeviri durumunu güncelleyin (erişim için IRC\u0026rsquo;de sorun) 3. Uygun repository\u0026rsquo;yi klonlayın (aşağıdaki bölümlere bakın)\nRouter Konsolu Çevirisi Router konsolu, I2P\u0026rsquo;yi çalıştırdığınızda gördüğünüz web arayüzüdür. Onu çevirmek, İngilizce ile rahat olmayan kullanıcılara yardımcı olur.\nTransifex Kullanımı (Önerilir) Transifex üzerinde I2P sayfasına gidin Router console projesini seçin Dilinizi seçin Çeviriye başlayın Manuel Router Konsolu Çevirisi Ön Koşullar: - Web sitesi çevirisiyle aynı (git, gettext) - GPG anahtarı (commit erişimi için) - İmzalanmış geliştirici anlaşması\nAna I2P deposunu klonlayın:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p Çevrilecek dosyalar:\nRouter konsolu çeviriye ihtiyaç duyan yaklaşık 15 dosya içermektedir:\nTemel arayüz dosyaları:\napps/routerconsole/locale/messages_*.po - Ana konsol mesajları apps/routerconsole/locale-news/messages_*.po - Haber mesajları Proxy dosyaları:\napps/i2ptunnel/locale/messages_*.po - Tunnel yapılandırma arayüzü Uygulama yerel ayarları:\napps/susidns/locale/messages_*.po - Adres defteri arayüzü apps/susimail/locale/messages_*.po - E-posta arayüzü Diğer uygulamaya özel yerel ayar dizinleri Dokümantasyon dosyaları:\ninstaller/resources/readme/readme_*.html - Kurulum bilgi dosyası Çeşitli uygulamalardaki yardım dosyaları Çeviri iş akışı:\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console Çalışmanızı gönderin: - GitLab üzerinde birleştirme isteği oluşturun - Veya dosyaları IRC üzerinden geliştirme ekibi ile paylaşın\nÇeviri Araçları POEdit (Şiddetle Tavsiye Edilir) POEdit , .po çeviri dosyaları için özel bir düzenleyicidir.\nÖzellikler: - Çeviri çalışması için görsel arayüz - Çeviri bağlamını gösterir - Otomatik doğrulama - Windows, macOS ve Linux için kullanılabilir\nMetin Editörleri Herhangi bir metin düzenleyici de kullanabilirsiniz: - VS Code (i18n eklentileri ile) - Sublime Text - vim/emacs (terminal kullanıcıları için)\nKalite Kontrolleri Göndermeden önce: 1. Biçimlendirmeyi kontrol edin: %s ve {0} gibi yer tutucuların değişmeden kaldığından emin olun 2. Çevirilerinizi test edin: I2P\u0026rsquo;yi kurun ve çalıştırarak nasıl göründüklerini görün 3. Tutarlılık: Dosyalar arasında terminoloji tutarlılığını koruyun 4. Uzunluk: Bazı dizgeler arayüzde alan kısıtlamalarına sahiptir\nÇevirmenler için İpuçları Genel Kurallar Tutarlı olun: Yaygın terimler için belgeler boyunca aynı çevirileri kullanın Biçimlendirmeyi koruyun: HTML etiketlerini, yer tutucuları (%s, {0}) ve satır sonlarını olduğu gibi bırakın Bağlam önemlidir: Bağlamı anlamak için kaynak İngilizce metni dikkatlice okuyun Soru sorun: Bir şey belirsizse IRC veya forumları kullanın Yaygın I2P Terimleri Bazı terimler İngilizce olarak kalmalı veya dikkatlice harf çevriminden geçirilmelidir:\nI2P - Olduğu gibi bırakın eepsite - I2P web sitesi (dilinizde açıklama gerektirebilir) tunnel - Bağlantı yolu (\u0026ldquo;devre\u0026rdquo; gibi Tor terminolojisinden kaçının) netDb - Ağ veritabanı floodfill - Router türü destination - I2P adres uç noktası Çevirilerinizi Test Etme Çevirilerinizle I2P\u0026rsquo;yi derleyin Router konsolu ayarlarından dili değiştirin Kontrol etmek için tüm sayfalarda gezinin: Metinlerin UI öğelerine sığdığından Bozuk karakterlerin olmadığından (kodlama sorunları) Çevirilerin bağlama uygun olduğundan Sık Sorulan Sorular Çeviri süreci neden bu kadar karmaşık? Süreç, versiyon kontrolü (git) ve standart çeviri araçları (.po dosyaları) kullanır çünkü:\nHesap Verebilirlik: Kimin neyi ne zaman değiştirdiğini takip edin Kalite: Değişiklikleri yayına geçmeden önce inceleyin Tutarlılık: Uygun dosya biçimlendirme ve yapısını koruyun Ölçeklenebilirlik: Çevirileri birden fazla dilde verimli bir şekilde yönetin İşbirliği: Birden fazla çevirmen aynı dil üzerinde çalışabilir Programlama becerisine ihtiyacım var mı? Hayır! Transifex kullanıyorsanız, sadece şunlara ihtiyacınız var: - Hem İngilizce hem de hedef dilinizde akıcılık - Bir web tarayıcısı - Temel bilgisayar becerileri\nManuel çeviri için temel komut satırı bilgisi gereklidir, ancak kodlama gerekmez.\nNe kadar sürer? Router konsolu: Tüm dosyalar için yaklaşık 15-20 saat Bakım: Yeni dizeleri güncellemek için ayda birkaç saat Birden fazla kişi tek bir dil üzerinde çalışabilir mi? Evet! Koordinasyon çok önemli: - Otomatik koordinasyon için Transifex kullanın - Manuel çalışma için #i2p-dev IRC kanalında iletişim kurun - İşi bölümler veya dosyalar halinde bölüştürün\nDilim listede yoksa ne olur? Transifex üzerinden talep edin veya IRC\u0026rsquo;de ekiple iletişime geçin. Geliştirme ekibi yeni bir dili hızlıca ayarlayabilir.\nÇevirilerimi göndermeden önce nasıl test edebilirim? Çevirilerinizle I2P\u0026rsquo;yi kaynaktan derleyin Yerel olarak kurun ve çalıştırın Konsol ayarlarından dili değiştirin Yardım Alma IRC Desteği Şunlar için IRC\u0026rsquo;de #i2p-dev kanalına katılın: - Çeviri araçlarıyla ilgili teknik yardım - I2P terminolojisi hakkında sorular - Diğer çevirmenlerle koordinasyon - Geliştiricilerden doğrudan destek\nForumlar I2P Forumları \u0026rsquo;nda çeviri tartışmaları I2P İçinde: zzz.i2p üzerinde çeviri forumu (I2P router gerektirir) Belgeler Transifex Belgeleri POEdit Belgeleri gettext Kılavuzu Tanıma Tüm çevirmenler şu yerlerde belirtilir: - I2P router konsolu (Hakkında sayfası) - Web sitesi katkıda bulunanlar sayfası - Git commit geçmişi - Sürüm duyuruları\nÇalışmanız, dünya çapında insanların I2P\u0026rsquo;yi güvenli ve özel bir şekilde kullanmasına doğrudan yardımcı oluyor. Katkılarınız için teşekkür ederiz!\nSonraki Adımlar Çeviriye başlamaya hazır mısınız?\nYönteminizi seçin:\nHızlı başlangıç: Transifex\u0026rsquo;te kaydolun Manuel yaklaşım: IRC\u0026rsquo;de #i2p-dev\u0026rsquo;e katılın Küçük başlayın: Sürece aşina olmak için birkaç dize çevirin\nYardım isteyin: IRC veya forumlarda yardım istemekten çekinmeyin\nI2P\u0026rsquo;yi herkes için erişilebilir hale getirmeye yardımcı olduğunuz için teşekkür ederiz!\n","description":"I2P web sitesine ve router konsoluna Transifex veya manuel yöntemler kullanarak nasıl çeviri katkısı yapılır","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"Yeni Çevirmen Rehberi","url":"/tr/docs/develop/new-translators/"},{"categories":null,"content":"I2P üzerinde çalışmaya başlamak mı istiyorsunuz? Harika! İşte web sitesine veya yazılıma katkıda bulunmaya, geliştirme yapmaya veya çeviri oluşturmaya başlamak için hızlı bir kılavuz.\nKodlamaya henüz hazır değil misiniz? Önce katılmayı deneyin.\nJava\u0026rsquo;yı Tanıyın I2P router\u0026rsquo;ı ve gömülü uygulamaları ana geliştirme dili olarak Java kullanır. Java konusunda deneyiminiz yoksa, Thinking in Java kitabına göz atabilirsiniz\n\u0026ldquo;How intro\u0026rdquo;, diğer \u0026ldquo;how\u0026rdquo; belgelerini, teknik giriş belgesini ve ilgili dokümanları inceleyin:\nTanıtım: I2P\u0026rsquo;ye Giriş Dokümantasyon merkezi: Dokümantasyon Teknik tanıtım: Teknik Tanıtım Bunlar size I2P\u0026rsquo;nin nasıl yapılandırıldığına ve farklı işlevlerinin neler olduğuna dair iyi bir genel bakış sunacaktır.\nI2P Kodunu Edinme I2P router veya gömülü uygulamalar üzerinde geliştirme yapmak için kaynak kodunu edinmeniz gerekir.\nMevcut yöntemimiz: Git I2P\u0026rsquo;nin resmi Git hizmetleri vardır ve kendi GitLab sunucumuzdan Git üzerinden katkı kabul eder:\nI2P İçinde: http://git.idk.i2p I2P Dışında: https://i2pgit.org Ana depoyu klonlayın:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git GitHub\u0026rsquo;da salt okunur bir yansı da mevcuttur:\nGitHub yansıması: github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git I2P Kurulumu Kodu derlemek için Sun/Oracle Java Development Kit 6 veya üzeri, ya da eşdeğer bir JDK (Sun/Oracle JDK 6 şiddetle önerilir) ve Apache Ant sürüm 1.7.0 veya üzeri gereklidir. Ana I2P kodu üzerinde çalışıyorsanız, i2p.i2p dizinine girin ve derleme seçeneklerini görmek için ant komutunu çalıştırın.\nConsole çevirilerini oluşturmak veya üzerinde çalışmak için GNU gettext paketinden xgettext, msgfmt ve msgmerge araçlarına ihtiyacınız var.\nYeni uygulamalar üzerinde geliştirme yapmak için uygulama geliştirme kılavuzuna bakın.\nGeliştirme Fikirleri Fikirler için proje TODO listesine veya GitLab\u0026rsquo;daki sorun listesine bakın:\nGitLab sorunları: i2pgit.org/I2P_Developers/i2p.i2p/issues Sonuçları Erişilebilir Hale Getirme Commit yetkisi gereksinimleri için lisanslar sayfasının altına bakın. i2p.i2p\u0026lsquo;ye kod koymak için bunlara ihtiyacınız var (web sitesi için gerekli değil!).\nLisanslar sayfası Bizi Tanıyın! Geliştiriciler IRC\u0026rsquo;de takılırlar. Onlara çeşitli ağlar ve I2P dahili ağları üzerinden ulaşılabilir. Bakılması gereken olağan yer #i2p-dev\u0026lsquo;dir. Kanala katılın ve merhaba deyin! Ayrıca düzenli geliştiriciler için ek yönergelerimiz de bulunmaktadır.\nÇeviriler Web sitesi ve router konsolu çeviricileri: Sonraki adımlar için Yeni Çevirmenlerin Rehberi \u0026rsquo;ne bakın.\nAraçlar I2P, çoğunlukla açık kaynak araç setleri kullanılarak geliştirilen açık kaynak bir yazılımdır. I2P projesi yakın zamanda YourKit Java Profiler için bir lisans edindi. Açık kaynak projeler, YourKit\u0026rsquo;in proje web sitesinde referans gösterilmesi koşuluyla ücretsiz lisans almaya hak kazanır. I2P kod tabanında profilleme yapmak istiyorsanız lütfen bizimle iletişime geçin.\nYourKit, açık kaynak projelerini tam özellikli profil oluşturucularıyla nazikçe desteklemektedir. YourKit, LLC, Java ve .NET uygulamaları için profil oluşturmaya yönelik yenilikçi ve akıllı araçların yaratıcısıdır. YourKit\u0026rsquo;in önde gelen yazılım ürünlerine bir göz atın:\nYourKit Java Profiler YourKit .NET Profiler ","description":"I2P'ye katkıda bulunmaya nasıl başlanır: çalışma materyalleri, kaynak kodu, derleme, fikirler, yayınlama, topluluk, çeviriler ve araçlar","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"Yeni Geliştirici Kılavuzu","url":"/tr/docs/develop/new-developers/"},{"categories":null,"content":"1. Genel Bakış clients.config dosyasındaki girişler, router\u0026rsquo;a başlangıçta hangi uygulamaların çalıştırılacağını bildirir. Her giriş managed client (yönetilen istemci - tercih edilen) veya unmanaged client (yönetilmeyen istemci) olarak çalışabilir. Managed client\u0026rsquo;lar ClientAppManager ile işbirliği yapar ve bu yönetici:\nUygulama örneğini oluşturur ve yönlendirici konsolu için yaşam döngüsü durumunu takip eder Kullanıcıya başlatma/durdurma kontrollerini sunar ve yönlendirici çıkışında temiz kapanmayı zorlar Uygulamaların birbirlerinin servislerini keşfedebilmesi için hafif bir istemci kayıt defteri ve port eşleyici barındırır Yönetilmeyen istemciler basitçe bir main() metodunu çağırır; bunları yalnızca modernize edilemeyen eski kod için kullanın.\n2. Yönetilen Bir İstemci Uygulama Yönetilen istemciler, net.i2p.app.ClientApp (kullanıcıya yönelik uygulamalar için) veya net.i2p.router.app.RouterApp (router uzantıları için) arayüzlerinden birini uygulamalıdır. Yöneticinin bağlam ve yapılandırma argümanlarını sağlayabilmesi için aşağıdaki yapıcılardan birini sağlayın:\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) args dizisi, clients.config dosyasında veya clients.config.d/ içindeki ayrı dosyalarda yapılandırılan değerleri içerir. Varsayılan yaşam döngüsü bağlantısını miras almak için mümkün olduğunda ClientApp / RouterApp yardımcı sınıflarını genişletin.\n2.1 Lifecycle Methods Yönetilen istemcilerin uygulaması beklenir:\nstartup() - başlatma işlemlerini gerçekleştir ve hızlıca geri dön. INITIALIZED durumundan geçiş yapmak için en az bir kez manager.notify() çağrısı yapmalıdır. shutdown(String[] args) - kaynakları serbest bırak ve arka plan iş parçacıklarını durdur. Durumu STOPPING veya STOPPED olarak değiştirmek için en az bir kez manager.notify() çağrısı yapmalıdır. getState() - uygulamanın çalışıyor, başlatılıyor, durduruluyor veya başarısız olduğu bilgisini konsola bildir Yönetici, kullanıcılar konsol ile etkileşime girdikçe bu metotları çağırır.\n2.2 Advantages Yönlendirici konsolunda doğru durum raporlaması Thread sızıntısı veya statik referans bırakmadan temiz yeniden başlatmalar Uygulama durduktan sonra daha düşük bellek kullanımı Enjekte edilen bağlam üzerinden merkezileştirilmiş günlük kaydı ve hata raporlaması 3. Unmanaged Clients (Fallback Mode) Yapılandırılan sınıf yönetilen bir arayüz uygulamıyorsa, router onu main(String[] args) çağırarak başlatır ve ortaya çıkan süreci takip edemez. Konsol sınırlı bilgi gösterir ve kapatma kancaları çalışmayabilir. Bu modu, yönetilen API\u0026rsquo;leri benimseyemeyen betikler veya tek seferlik yardımcı programlar için ayırın.\n4. Client Registry Yönetilen ve yönetilmeyen istemciler, diğer bileşenlerin isme göre bir referans alabilmesi için kendilerini yönetici ile kaydedebilir:\nmanager.register(this); Kayıt, kayıt defteri anahtarı olarak istemcinin getName() dönüş değerini kullanır. Bilinen kayıtlar arasında console, i2ptunnel, Jetty, outproxy ve update bulunur. Özellikleri koordine etmek için ClientAppManager.getRegisteredApp(String name) ile bir istemci alın (örneğin, console\u0026rsquo;un Jetty\u0026rsquo;den durum ayrıntılarını sorgulaması).\nİstemci kaydının ve port eşleyicinin ayrı sistemler olduğunu unutmayın. İstemci kaydı, ad araması yoluyla uygulamalar arası iletişimi sağlarken, port eşleyici hizmet keşfi için hizmet adlarını host:port kombinasyonlarına eşler.\n3. Yönetilmeyen İstemciler (Yedek Mod) Port mapper, dahili TCP servisleri için basit bir dizin sunar. İşbirlikçilerin sabit kodlanmış adreslerden kaçınması için loopback portlarını kaydedin:\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); Veya açık host belirtimi ile:\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); PortMapper.getPort(String name) (bulunamazsa -1 döndürür) veya getPort(String name, int defaultPort) (bulunamazsa varsayılan değeri döndürür) kullanarak servisleri arayın. Kayıt durumunu isRegistered(String name) ile kontrol edin ve kayıtlı host\u0026rsquo;u getActualHost(String name) ile alın.\nnet.i2p.util.PortMapper\u0026lsquo;den ortak port mapper servis sabitleri:\nSVC_CONSOLE - Router konsolu (varsayılan port 7657) SVC_HTTP_PROXY - HTTP proxy (varsayılan port 4444) SVC_HTTPS_PROXY - HTTPS proxy (varsayılan port 4445) SVC_I2PTUNNEL - I2PTunnel yöneticisi SVC_SAM - SAM köprüsü (varsayılan port 7656) SVC_SAM_SSL - SAM köprüsü SSL SVC_SAM_UDP - SAM UDP SVC_BOB - BOB köprüsü (varsayılan port 2827) SVC_EEPSITE - Standart eepsite (varsayılan port 7658) SVC_HTTPS_EEPSITE - HTTPS eepsite SVC_IRC - IRC tüneli (varsayılan port 6668) SVC_SUSIDNS - SusiDNS Not: httpclient, httpsclient ve httpbidirclient i2ptunnel tünel tipleridir (tunnel.N.type yapılandırmasında kullanılır), port mapper servis sabitleri değildir.\n4. İstemci Kaydı 2.1 Yaşam Döngüsü Metotları 0.9.42 sürümünden itibaren router, yapılandırmayı clients.config.d/ dizini içindeki ayrı dosyalara bölmeyi desteklemektedir. Her dosya, tüm özellikleri clientApp.0. önekiyle başlayan tek bir istemci için özellikler içerir:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true Bu, yeni kurulumlar ve eklentiler için önerilen yaklaşımdır.\n2.2 Avantajlar Geriye dönük uyumluluk için, geleneksel format sıralı numaralandırma kullanır:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties Gerekli: - main - ClientApp veya RouterApp\u0026rsquo;i uygulayan veya statik main(String[] args) içeren tam sınıf adı\nİsteğe Bağlı: - name - Router konsolu için görünen ad (varsayılan olarak sınıf adı) - args - Boşluk veya sekme ile ayrılmış argümanlar (tırnaklı dizileri destekler) - delay - Başlamadan önceki saniye (varsayılan 120) - onBoot - True ise delay=0 yapar - startOnLoad - İstemciyi etkinleştirir/devre dışı bırakır (varsayılan true)\nEklentiye özgü: - stopargs - Kapatma sırasında geçirilen argümanlar - uninstallargs - Eklenti kaldırma sırasında geçirilen argümanlar - classpath - Virgülle ayrılmış ek classpath girdileri\nEklentiler için değişken ikamesi: - $I2P - I2P temel dizini - $CONFIG - Kullanıcı yapılandırma dizini (örn., ~/.i2p) - $PLUGIN - Eklenti dizini - $OS - İşletim sistemi adı - $ARCH - Mimari adı\n5. Port Mapper Yönetilen istemcileri tercih edin; yönetilmeyen istemcilere yalnızca kesinlikle gerekli olduğunda geri dönün. Konsol işlemlerinin duyarlı kalması için başlatma ve kapatma işlemlerini hafif tutun. Kayıt defteri ve port adlarını açıklayıcı kullanın, böylece tanı araçları (ve son kullanıcılar) bir servisin ne yaptığını anlayabilir. Statik singleton\u0026rsquo;lardan kaçının - kaynakları paylaşmak için enjekte edilen bağlam ve yöneticiyi kullanın. Konsol durumunun doğru kalması için tüm durum geçişlerinde manager.notify() çağrısı yapın. Ayrı bir JVM\u0026rsquo;de çalıştırmanız gerekiyorsa, günlüklerin ve tanılamaların ana konsola nasıl yansıtıldığını belgelendirin. Harici programlar için, yönetilen istemci avantajlarından yararlanmak üzere ShellService (versiyon 1.7.0\u0026rsquo;da eklendi) kullanmayı düşünün. 6. Yapılandırma Formatı Yönetilen istemciler sürüm 0.9.4 ile (17 Aralık 2012) tanıtıldı ve sürüm 2.10.0 (9 Eylül 2025) itibarıyla önerilen mimari olmaya devam etmektedir. Temel API\u0026rsquo;ler bu süre boyunca sıfır bozucu değişiklikle kararlı kalmıştır:\nConstructor imzaları değiştirilmedi Yaşam döngüsü metodları (startup, shutdown, getState) değiştirilmedi ClientAppManager kayıt metodları değiştirilmedi PortMapper kayıt ve arama metodları değiştirilmedi Önemli iyileştirmeler: - 0.9.42 (2019) - Tekil yapılandırma dosyaları için clients.config.d/ dizin yapısı - 1.7.0 (2021) - Harici program durum takibi için ShellService eklendi - 2.10.0 (2025) - Yönetilen istemci API değişikliği olmayan güncel sürüm\nBir sonraki büyük sürüm, minimum olarak Java 17+ gerektirecektir (altyapı gereksinimi, bir API değişikliği değildir).\nReferences clients.config spesifikasyonu Yapılandırma Dosyası Spesifikasyonu I2P Teknik Dokümantasyon İndeksi ClientAppManager Javadoc (API 0.9.66) PortMapper Javadoc (API 0.9.66) ClientApp arayüzü (API 0.9.66) RouterApp arayüzü (API 0.9.66) Alternatif Javadoc (kararlı sürüm) Alternatif Javadoc (clearnet yansıması) Not: I2P ağı, erişim için bir I2P router gerektiren kapsamlı belgeleri http://idk.i 2p/javadoc-i2p/ adresinde barındırmaktadır. Clearnet erişimi için yukarıdaki GitHub Pages yansısını kullanın.\n","description":"Router tarafından yönetilen uygulamaların ClientAppManager ve port mapper ile nasıl entegre olduğu","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"Yönetilen İstemciler","url":"/tr/docs/applications/managed-clients/"}]
[{"categories":null,"content":"Descripción general Esta especificación documenta el protocolo para los anuncios de BitTorrent por UDP en I2P. Para la especificación general de BitTorrent en I2P, consulta la documentación de BitTorrent sobre I2P . Para conocer los antecedentes e información adicional sobre el desarrollo de esta especificación, consulta la Propuesta 160 .\nEste protocolo fue aprobado formalmente el 24 de junio de 2025 e implementado en la versión 2.10.0 de I2P (API 0.9.67), publicada el 8 de septiembre de 2025. La compatibilidad con UDP tracker (servidor de seguimiento) está actualmente operativa en la red I2P, con múltiples trackers de producción y compatibilidad total del cliente i2psnark.\nDiseño Esta especificación utiliza datagram2 y datagram3 con posibilidad de respuesta (repliable), así como datagramas en bruto, tal como se definen en la Especificación de Datagramas de I2P . Datagram2 y Datagram3 son variantes de los datagramas con posibilidad de respuesta (repliable), definidos en la Propuesta 163 . Datagram2 añade resistencia a ataques de repetición (replay) y compatibilidad con firmas fuera de línea. Datagram3 es más pequeño que el formato antiguo de datagrama, pero carece de autenticación.\nBEP 15 (Propuesta de mejora de BitTorrent) Como referencia, el flujo de mensajes definido en BEP 15 es el siguiente:\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. La fase de conexión es necesaria para evitar la suplantación de direcciones IP. El rastreador devuelve un ID de conexión que el cliente utiliza en anuncios posteriores. Este ID de conexión caduca de forma predeterminada en un minuto en el cliente y en dos minutos en el rastreador.\nI2P utiliza el mismo flujo de mensajes que BEP 15, para facilitar la adopción en bases de código de cliente compatibles con UDP, para mayor eficiencia y por razones de seguridad que se detallan a continuación:\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... Esto potencialmente proporciona un gran ahorro de ancho de banda frente a los anuncios por streaming (TCP). Si bien el Datagram2 (tipo de datagrama) tiene aproximadamente el mismo tamaño que un SYN de streaming, la respuesta sin formato es mucho más pequeña que el SYN ACK de streaming. Las solicitudes posteriores usan Datagram3 (tipo de datagrama), y las respuestas posteriores son sin formato.\nLas solicitudes de anuncio son Datagram3 (formato de datagrama de I2P versión 3) para que el rastreador no tenga que mantener una gran tabla de correspondencias de ID de conexión con destino de anuncio o hash. En su lugar, el rastreador puede generar los ID de conexión criptográficamente a partir del hash del remitente, la marca de tiempo actual (basada en algún intervalo) y un valor secreto. Cuando se recibe una solicitud de anuncio, el rastreador valida el ID de conexión y luego usa el hash del remitente de Datagram3 como destino de envío.\nDuración de la conexión BEP 15 especifica que el ID de conexión caduca en un minuto en el cliente y en dos minutos en el tracker (rastreador). No es configurable. Eso limita las posibles ganancias de eficiencia, a menos que los clientes agrupen las solicitudes announce (peticiones del cliente al tracker) para hacerlas todas dentro de una ventana de un minuto. i2psnark no agrupa actualmente las solicitudes announce; las distribuye para evitar ráfagas de tráfico. Se informa que los usuarios avanzados ejecutan miles de torrents a la vez, y concentrar tantas solicitudes announce en un minuto no es realista.\nAquí proponemos extender la respuesta de conexión para añadir un campo opcional de tiempo de vida de la conexión. El valor predeterminado, si no está presente, es de un minuto. De lo contrario, el cliente usará el tiempo de vida especificado en segundos, y el rastreador mantendrá el ID de conexión durante un minuto más.\nCompatibilidad con BEP 15 (Propuesta de Mejora de BitTorrent 15) Este diseño mantiene la compatibilidad con BEP 15 en la medida de lo posible para limitar los cambios necesarios en los clientes y rastreadores existentes.\nEl único cambio obligatorio es el formato de la información de pares en la respuesta de anuncio. La incorporación del campo lifetime (vida útil) en la respuesta de conexión no es obligatoria, pero se recomienda encarecidamente para mayor eficiencia, como se explicó arriba.\nAnálisis de seguridad Un objetivo importante de un protocolo de anuncio por UDP es impedir la suplantación de direcciones. El cliente debe existir realmente y adjuntar un leaseSet real. Debe tener tunnels de entrada para recibir la Connect Response (respuesta de conexión). Estos tunnels podrían ser de cero saltos y construirse al instante, pero eso expondría al creador. Este protocolo cumple ese objetivo.\nProblemas Este protocolo no admite blinded destinations (destinos ocultados), pero puede ampliarse para hacerlo. Véase más abajo.\nEspecificación Protocolos y puertos Datagram2 repliable (admite respuesta) utiliza el protocolo I2CP 19; Datagram3 repliable utiliza el protocolo I2CP 20; los datagramas sin formato utilizan el protocolo I2CP 18. Las solicitudes pueden ser Datagram2 o Datagram3. Las respuestas siempre son sin formato. El formato de datagrama repliable (\u0026ldquo;Datagram1\u0026rdquo;) más antiguo que utiliza el protocolo I2CP 17 NO debe usarse para solicitudes ni respuestas; deben descartarse si se reciben en los puertos de solicitud/respuesta. Tenga en cuenta que el protocolo 17 de Datagram1 sigue utilizándose para el protocolo DHT.\nLas solicitudes usan el \u0026ldquo;to port\u0026rdquo; (puerto de destino) de I2CP indicado en la URL de anuncio; véase más abajo. El \u0026ldquo;from port\u0026rdquo; (puerto de origen) de la solicitud lo elige el cliente, pero debe ser distinto de cero y no debe coincidir con los puertos usados por DHT, para que las respuestas puedan clasificarse fácilmente. Los rastreadores deberían rechazar las solicitudes recibidas en el puerto incorrecto.\nLas respuestas usan el \u0026ldquo;to port\u0026rdquo; de I2CP (puerto de destino) de la solicitud. El \u0026ldquo;from port\u0026rdquo; (puerto de origen) de la respuesta es el \u0026ldquo;to port\u0026rdquo; de la solicitud.\nURL de anuncio El formato de la URL de announce no está especificado en BEP 15 , pero, como en clearnet (internet abierta), las URLs de announce por UDP tienen la forma \u0026ldquo;udp://host:port/path\u0026rdquo;. La ruta se ignora y puede estar vacía, pero normalmente es \u0026ldquo;/announce\u0026rdquo; en clearnet. La parte :port debe estar siempre presente; sin embargo, si se omite la parte \u0026ldquo;:port\u0026rdquo;, use un puerto I2CP predeterminado de 6969, ya que ese es el puerto común en clearnet. También pueden añadirse parámetros CGI \u0026amp;a=b\u0026amp;c=d; estos pueden procesarse y proporcionarse en la solicitud de announce, vea BEP 41 . Si no hay parámetros ni ruta, la / final también puede omitirse, como se infiere de BEP 41 .\nFormatos de datagramas Todos los valores se envían en orden de bytes de red (big endian, más significativo primero). No espere que los paquetes tengan exactamente un tamaño determinado. Las extensiones futuras podrían aumentar el tamaño de los paquetes.\nSolicitud de conexión Cliente al tracker. 16 bytes. Debe ser un Datagram2 (formato de datagrama de segunda generación de I2P) al que se pueda responder. Igual que en BEP 15 . Sin cambios.\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id Respuesta de conexión Del rastreador al cliente. 16 o 18 bytes. Debe ser sin procesar. Igual que en BEP 15 excepto como se indica a continuación.\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 La respuesta DEBE enviarse al \u0026ldquo;to port\u0026rdquo; de I2CP que se recibió como el \u0026ldquo;from port\u0026rdquo; de la solicitud.\nEl campo lifetime es opcional e indica, en segundos, la vida útil del connection_id para el cliente. El valor predeterminado es 60, y el mínimo, si se especifica, es 60. El máximo es 65535, o aproximadamente 18 horas. El rastreador debería mantener el connection_id durante 60 segundos más que la vida útil indicada por el cliente.\nSolicitud de anuncio Del cliente al rastreador. 98 bytes como mínimo. Debe ser un Datagram3 (tipo de datagrama de I2P v3) que admita respuesta. Igual que en BEP 15 salvo lo indicado a continuación.\nEl connection_id es el recibido en la respuesta de conexión.\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 Cambios con respecto a BEP 15 :\nla clave se ignora la dirección IP no se utiliza el puerto probablemente se ignore, pero debe ser el mismo que el puerto de origen de I2CP La sección de opciones, si está presente, es la definida en BEP 41 La respuesta DEBE enviarse al \u0026ldquo;to port\u0026rdquo; de I2CP que se recibió como el \u0026ldquo;from port\u0026rdquo; de la solicitud. No uses el puerto de la solicitud de anuncio.\nRespuesta de anuncio Del tracker al cliente. 20 bytes como mínimo. Debe ser en bruto. Igual que en BEP 15 salvo lo indicado a continuación.\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 Cambios con respecto a BEP 15 :\nEn lugar de IPv4+puerto de 6 bytes o IPv6+puerto de 18 bytes, devolvemos un número múltiplo de \u0026ldquo;respuestas compactas\u0026rdquo; de 32 bytes con los hashes binarios SHA-256 de los pares. Como con las respuestas compactas TCP, no incluimos un puerto. La respuesta DEBE enviarse al \u0026ldquo;to port\u0026rdquo; de I2CP que se recibió como el \u0026ldquo;from port\u0026rdquo; de la solicitud. No utilice el puerto de la solicitud de anuncio.\nLos datagramas de I2P tienen un tamaño máximo muy grande de aproximadamente 64 KB; sin embargo, para una entrega fiable, deberían evitarse los datagramas mayores de 4 KB. Por eficiencia en el uso del ancho de banda, los rastreadores probablemente deberían limitar el número máximo de pares a aproximadamente 50, lo que corresponde a un paquete de aproximadamente 1600 bytes sin contar la sobrecarga de las distintas capas, y debería quedar dentro del límite de carga útil de dos mensajes de tunnel tras la fragmentación.\nComo en BEP 15, no se incluye un contador del número de direcciones de pares (IP/puerto en BEP 15, hashes aquí) que siguen. Aunque no se contempla en BEP 15, podría definirse un marcador de fin de pares de todos ceros para indicar que la información de pares está completa y que a continuación siguen algunos datos de extensión.\nPara que dicha extensión sea posible en el futuro, los clientes deberían ignorar un hash de 32 bytes compuesto íntegramente por ceros, y cualquier dato que lo siga. Los rastreadores deberían rechazar anuncios provenientes de un hash compuesto íntegramente por ceros, aunque ese hash ya está prohibido por los routers Java.\nScrape (extracción automatizada de datos) La solicitud/respuesta de scrape (consulta de estadísticas del tracker) de BEP 15 no es obligatoria según esta especificación, pero puede implementarse si se desea, sin requerir cambios. El cliente debe obtener primero un ID de conexión. La solicitud de scrape es siempre repliable (se puede responder directamente) Datagram3. La respuesta de scrape es siempre raw (no repliable).\nRespuesta de error Del tracker al cliente. 8 bytes como mínimo (si el mensaje está vacío). Debe ser en bruto. Igual que en BEP 15 . Sin cambios.\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message Extensiones No se incluyen bits de extensión ni un campo de versión. Los clientes y los rastreadores no deben suponer que los paquetes tienen un tamaño determinado. De este modo, se pueden añadir campos adicionales sin romper la compatibilidad. Se recomienda el formato de extensiones definido en BEP 41 si se requiere.\nLa respuesta de conexión se modifica para añadir una vida útil opcional del ID de conexión.\nSi se requiere compatibilidad con destinos cegados, podemos o bien añadir la dirección cegada de 35 bytes al final de la solicitud announce, o solicitar hashes cegados en las respuestas, usando el formato BEP 41 (parámetros por definir). El conjunto de direcciones de pares de 35 bytes cegadas podría añadirse al final de la respuesta announce, después de un hash de 32 bytes de todos ceros.\nDirectrices de implementación Consulte la sección de diseño anterior para un análisis de los desafíos de los clientes y los trackers no integrados y que no usan I2CP.\nClientes Para un nombre de host de tracker dado, un cliente debería preferir URLs UDP en lugar de URLs HTTP y no debería anunciarse a ambos.\nLos clientes que ya cuenten con soporte para BEP 15 solo deberían requerir pequeñas modificaciones.\nSi un cliente admite DHT (tabla hash distribuida) u otros protocolos de datagramas, probablemente debería seleccionar un puerto diferente como el \u0026ldquo;from port\u0026rdquo; de la solicitud para que las respuestas lleguen a ese puerto y no se mezclen con los mensajes de DHT. El cliente solo recibe datagramas en bruto como respuestas. Los trackers nunca enviarán un repliable datagram2 al cliente.\nLos clientes con una lista predeterminada de opentrackers (rastreador abierto de BitTorrent) deben actualizarla para añadir URLs UDP una vez que se confirme que los opentrackers conocidos admiten UDP.\nEs posible que los clientes implementen o no la retransmisión de solicitudes. Las retransmisiones, si se implementan, deberían usar un tiempo de espera inicial de al menos 15 segundos y duplicar el tiempo de espera en cada retransmisión (backoff exponencial).\nLos clientes deben esperar antes de volver a intentarlo después de recibir una respuesta de error.\nRastreadores Los trackers con compatibilidad existente con BEP 15 deberían requerir solo pequeñas modificaciones. Esta especificación difiere de la propuesta de 2014 en que el tracker debe admitir la recepción de datagram2 (formato de datagrama v2) y datagram3 (formato de datagrama v3) con posibilidad de respuesta en el mismo puerto.\nPara minimizar los requisitos de recursos del tracker, este protocolo está diseñado para eliminar cualquier requisito de que el tracker almacene mapeos de hashes de los clientes a ID de conexión para su validación posterior. Esto es posible porque el paquete de solicitud announce (anuncio) es un paquete Datagram3 al que se puede responder, por lo que contiene el hash del remitente.\nUna implementación recomendada es:\nDefina la época actual como el tiempo actual con una resolución igual a la duración de la conexión, epoch = now / lifetime. Defina una función hash criptográfica H(secret, clienthash, epoch) que genere una salida de 8 bytes. Genere el secreto constante aleatorio utilizado para todas las conexiones. Para las respuestas de conexión, genere connection_id = H(secret, clienthash, epoch) Para las solicitudes de anuncio, valide el ID de conexión recibido en la época actual verificando connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1) Estado del despliegue Este protocolo fue aprobado el 24 de junio de 2025 y está plenamente operativo en la red I2P desde septiembre de 2025.\nImplementaciones actuales i2psnark: El soporte completo para rastreadores UDP se incluye en la versión 2.10.0 de I2P (API 0.9.67), publicada el 8 de septiembre de 2025. Todas las instalaciones de I2P a partir de esta versión incluyen de forma predeterminada la compatibilidad con rastreadores UDP.\nzzzot tracker: La versión 0.20.0-beta2 y posteriores admiten anuncios por UDP. A fecha de octubre de 2025, los siguientes trackers (servidores de seguimiento) de producción están operativos: - opentracker.dg2.i2p - opentracker.simp.i2p - opentracker.skank.i2p\nNotas de compatibilidad de clientes Limitaciones de SAM v3.3: Los clientes externos de BitTorrent que usan SAM (Mensajería Anónima Simple) requieren soporte de SAM v3.3 para Datagram2/3. Esto está disponible en Java I2P pero actualmente no está soportado por i2pd (la implementación de I2P en C++), lo que podría limitar la adopción en clientes basados en libtorrent como qBittorrent.\nClientes I2CP: Los clientes que utilizan I2CP directamente (como BiglyBT) pueden implementar soporte para rastreadores UDP sin las limitaciones de SAM.\nReferencias [BEP15]: Protocolo de tracker UDP de BitTorrent [BEP41]: Extensiones del protocolo de tracker UDP [DATAGRAMS]: Especificación de datagramas de I2P [Prop160]: Propuesta de trackers UDP [Prop163]: Propuesta de Datagram2 [SPEC]: BitTorrent sobre I2P ","description":"Especificación del protocolo para las solicitudes announce (solicitud de anuncio del rastreador) de rastreadores de BitTorrent basados en UDP en I2P","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"Anuncios de BitTorrent por UDP","url":"/es/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":" Estado: Actualizado hasta I2P 2.10.0 (octubre de 2025). Esta lista consolida todos los puertos activos, obsoletos y reservados utilizados por el router Java de I2P, i2pd y plugins relacionados. Todos los puertos se enumeran en orden numérico para mayor consistencia.\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. ## Notas de implementación Todos los puertos por debajo de 9000 (excepto 8887) se vinculan a 127.0.0.1 por defecto por seguridad. El puerto de red del router (9151–30777) debe estar abierto a internet para una participación completa. i2pd utiliza principalmente las mismas asignaciones por compatibilidad (7070 consola, 7654 I2CP, 7656/7655 SAM). Los desarrolladores de plugins deben coordinar nuevas asignaciones a través de la comunidad I2P para evitar conflictos. ","description":"Referencia completa de asignaciones de puertos I2P, puertos de plugins y rangos reservados.","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"Asignaciones de Puertos","url":"/es/docs/overview/ports/"},{"categories":null,"content":"Descripción general Las direcciones Base 32 (\u0026ldquo;b32\u0026rdquo;) contienen el hash del destino. Esto no funcionará para LS2 cifrado (propuesta 123).\nNo podemos usar una dirección base 32 tradicional para un LS2 cifrado (propuesta 123), ya que solo contiene el hash del destino. No proporciona la clave pública no cegada. Los clientes deben conocer la clave pública del destino, el tipo de firma, el tipo de firma cegada y un secreto opcional o una clave privada para obtener y descifrar el leaseSet. Por lo tanto, una dirección base 32 por sí sola es insuficiente. El cliente necesita o bien el destino completo (que contiene la clave pública), o bien la clave pública por sí sola. Si el cliente tiene el destino completo en una libreta de direcciones, y la libreta de direcciones admite búsquedas inversas por hash, entonces se puede recuperar la clave pública.\nEste formato coloca la clave pública en lugar del hash en una dirección base32. Este formato también debe contener el tipo de firma de la clave pública y el tipo de firma del esquema de cegado.\nEste documento especifica un formato b32 para estas direcciones. Aunque durante las discusiones nos hemos referido a este nuevo formato como una dirección \u0026ldquo;b33\u0026rdquo;, el formato nuevo real conserva el sufijo habitual \u0026ldquo;.b32.i2p\u0026rdquo;.\nEstado de implementación La propuesta 123 (Nuevas entradas de netDB) alcanzó su implementación completa en la versión 0.9.43 (octubre de 2019). El conjunto de funcionalidades de LS2 (tipo de leaseSet 2 cifrado) se ha mantenido estable hasta la versión 2.10.0 (septiembre de 2025), sin cambios que rompan la compatibilidad en el formato de direccionamiento ni en las especificaciones criptográficas.\nHitos clave de implementación: - 0.9.38: Compatibilidad con Floodfill para LS2 estándar con claves fuera de línea - 0.9.39: Tipo de firma RedDSA 11 y cifrado/descifrado básico - 0.9.40: Compatibilidad completa con direcciones B32 (Propuesta 149) - 0.9.41: Autenticación por cliente basada en X25519 - 0.9.42: Todas las funciones de blinding (cegado criptográfico) operativas - 0.9.43: Implementación completa declarada (octubre de 2019)\nDiseño El nuevo formato contiene la clave pública no cegada, el tipo de firma no cegada y el tipo de firma cegada. Opcionalmente indica los requisitos de secreto y/o de clave privada para enlaces privados. Utiliza el sufijo \u0026ldquo;.b32.i2p\u0026rdquo; existente, pero con una longitud mayor. Incluye una suma de verificación para la detección de errores. Las direcciones para leasesets cifrados se identifican por 56 o más caracteres codificados (35 o más bytes decodificados), en comparación con 52 caracteres (32 bytes) para las direcciones tradicionales en base 32. Especificación Creación y codificación Construye un nombre de host de {56+ caracteres}.b32.i2p (35+ caracteres en binario) de la siguiente manera:\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype Posprocesamiento y suma de verificación:\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; Cualquier bit sin usar al final del b32 debe ser 0. No hay bits sin usar en una dirección estándar de 56 caracteres (35 bytes).\nDecodificación y verificación strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key Bits de claves secretas y privadas Los bits de clave secreta y de clave privada se utilizan para indicar a los clientes, proxies u otro código del lado del cliente que se requerirá la clave secreta y/o la clave privada para descifrar el leaseset. Implementaciones concretas pueden solicitar al usuario que proporcione los datos necesarios, o rechazar los intentos de conexión si faltan dichos datos.\nEstos bits sirven únicamente como indicadores. La clave secreta o privada nunca debe incluirse en la propia dirección B32, ya que eso comprometería la seguridad.\nDetalles criptográficos Esquema de cegado El esquema de cegado utiliza RedDSA, basado en Ed25519 y en el diseño de ZCash, generando firmas Red25519 sobre la curva Ed25519 usando SHA-512. Este enfoque garantiza que las claves públicas cegadas permanezcan en el subgrupo de orden primo, evitando las preocupaciones de seguridad presentes en algunos diseños alternativos.\nLas claves cegadas se rotan diariamente en función de la fecha UTC utilizando la fórmula:\nblinded_key = BLIND(unblinded_key, date, optional_secret) La ubicación de almacenamiento de la DHT (tabla hash distribuida) se calcula como:\nSHA256(type_byte || blinded_public_key) Cifrado El leaseset cifrado utiliza la cifra de flujo ChaCha20 para el cifrado, elegida por su rendimiento superior en dispositivos que carecen de aceleración por hardware de AES. La especificación emplea HKDF (función de derivación de claves basada en HMAC) para la derivación de claves y X25519 (intercambio de claves de curva elíptica) para operaciones de Diffie-Hellman.\nLos leasesets cifrados tienen una estructura de tres capas: - Capa externa: metadatos en claro - Capa intermedia: autenticación del cliente (métodos DH o PSK) - Capa interna: datos LS2 propiamente dichos con información de lease\nMétodos de autenticación La autenticación por cliente admite dos métodos:\nAutenticación DH: Utiliza el acuerdo de claves X25519. Cada cliente autorizado proporciona su clave pública al servidor, y el servidor cifra la capa intermedia utilizando un secreto compartido derivado de ECDH.\nAutenticación PSK: Utiliza claves precompartidas directamente para el cifrado.\nEl bit de bandera 2 en la dirección B32 indica si se requiere autenticación por cliente.\nCaché Si bien está fuera del alcance de esta especificación, routers y clientes deben recordar y almacenar en caché (se recomienda que sea persistente) la asignación de la clave pública al destino, y viceversa.\nEl servicio de nombres basado en blockfile, sistema de libreta de direcciones predeterminado de I2P desde la versión 0.9.8, mantiene múltiples libretas de direcciones con un mapa dedicado de búsqueda inversa que proporciona búsquedas rápidas por hash. Esta funcionalidad es fundamental para la resolución de leaseSet (conjunto de arrendamientos de túnel) cifrados cuando inicialmente solo se conoce un hash.\nTipos de firma A partir de la versión 2.10.0 de I2P, se definen los tipos de firma del 0 al 11. La codificación de un solo byte sigue siendo el estándar, con codificación de dos bytes disponible pero no utilizada en la práctica.\nTipos de uso común: - Tipo 0 (DSA_SHA1): Obsoleto para routers, compatible con destinos - Tipo 7 (EdDSA_SHA512_Ed25519): Estándar actual para identidades de router y destinos - Tipo 11 (RedDSA_SHA512_Ed25519): Exclusivamente para LS2 leasesets cifrados con soporte de cegado\nNota importante: Solo Ed25519 (tipo 7) y Red25519 (tipo 11) admiten el cegado necesario para leaseSets cifrados. No se pueden usar otros tipos de firma con esta función.\nLos tipos 9-10 (algoritmos GOST) siguen reservados pero sin implementar. Los tipos 4-6 y 8 están marcados como \u0026ldquo;solo fuera de línea\u0026rdquo; para claves de firma fuera de línea.\nNotas Distinguir las variantes antiguas de las nuevas por la longitud. Las direcciones b32 antiguas son siempre {52 chars}.b32.i2p. Las nuevas son {56+ chars}.b32.i2p La codificación base32 sigue la RFC 4648, con decodificación insensible a mayúsculas/minúsculas y se prefiere la salida en minúsculas Las direcciones pueden superar los 200 caracteres al utilizar tipos de firma con claves públicas más grandes (p. ej., ECDSA P521 con claves de 132 bytes) El nuevo formato puede utilizarse en jump links (enlaces de salto) (y ser servido por jump servers (servidores de salto)) si se desea, igual que el b32 estándar Las claves cegadas rotan a diario según la fecha UTC para mejorar la privacidad Este formato se desvía del enfoque del apéndice A.2 del archivo rend-spec-v3.txt de Tor, que tiene posibles implicaciones de seguridad con claves públicas cegadas fuera de la curva Compatibilidad de versiones Esta especificación es válida para I2P desde la versión 0.9.47 (agosto de 2020) hasta la versión 2.10.0 (septiembre de 2025). Durante este período no se han producido cambios incompatibles en el B32 addressing format (formato de direccionamiento B32), en la encrypted LS2 structure (estructura LS2 cifrada) ni en las implementaciones criptográficas. Todas las direcciones creadas con 0.9.47 siguen siendo totalmente compatibles con las versiones actuales.\nReferencias CRC-32 - CRC-32 (Wikipedia) - RFC 3309: Suma de verificación del Protocolo de Control de Transmisión en Flujo Especificaciones de I2P - Especificación de LeaseSet cifrado - Propuesta 123: Nuevas entradas de netDB - Propuesta 149: B32 (dirección base32) para LS2 cifrado (versión 2 de LeaseSet) - Especificación de estructuras comunes - Nombres y libreta de direcciones Comparación con Tor - Hilo de discusión de Tor (contexto de diseño) Recursos adicionales - Proyecto I2P - Foro de I2P - Documentación de la API de Java ","description":"Formato de dirección en Base 32 para LS2 leasesets cifrados","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"B32 para Leasesets cifrados","url":"/es/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":" 1. Descripción general La netDb (base de datos de red) es una base de datos distribuida especializada que contiene solo dos tipos de datos: - RouterInfos – información de contacto del router - LeaseSets – información de contacto del destino\nTodos los datos están firmados criptográficamente y son verificables. Cada entrada incluye información de liveliness (estado de actividad) para descartar entradas obsoletas y reemplazar las desactualizadas, lo que protege contra ciertas clases de ataques.\nLa distribución utiliza un mecanismo de floodfill, donde un subconjunto de routers mantiene la base de datos distribuida.\n2. RouterInfo (Información del router) Cuando los routers necesitan ponerse en contacto con otros routers, intercambian paquetes de RouterInfo (información del router) que contienen:\nIdentidad del router – clave de cifrado, clave de firma, certificado Direcciones de contacto – cómo alcanzar el router Marca temporal de publicación – cuándo se publicó esta información Opciones de texto arbitrarias – banderas de capacidad y configuraciones Firma criptográfica – demuestra la autenticidad 2.1 Indicadores de capacidad Los routers anuncian sus capacidades mediante códigos de letras en su RouterInfo (información del router):\nFlag Meaning f Floodfill participation R Reachable U Unreachable D, E, G, H Various capability indicators ### 2.2 Clasificaciones de ancho de banda Code Bandwidth K Under 12 KBps L 12–48 KBps (default) M 48–64 KBps N 64–128 KBps O 128–256 KBps P 256–2000 KBps X Over 2000 KBps ### 2.3 Valores de ID de red Value Purpose 0 Reserved 1 Current Network (default) 2 Reserved for Future Networks 3–15 Forks and Test Networks 16–254 Reserved 255 Reserved ### 2.4 Estadísticas de RouterInfo Los routers publican estadísticas opcionales de salud para el análisis de la red: - Tasas de éxito/rechazo/expiración por tiempo de espera en la construcción de tunnel exploratorio - Promedio de 1 hora del recuento de tunnels participantes\nLas estadísticas siguen el formato stat_(statname).(statperiod) con valores separados por punto y coma.\nEstadísticas de ejemplo:\nstat_tunnel.buildExploratoryExpire.60m = 0;0;0;53.14 stat_tunnel.buildExploratoryReject.60m = 0;0;0;15.51 stat_tunnel.buildExploratorySuccess.60m = 0;0;0;31.35 stat_tunnel.participatingTunnels.60m = 289.20 Los Floodfill routers también pueden publicar: netdb.knownLeaseSets y netdb.knownRouters\n2.5 Opciones de familia A partir de la versión 0.9.24, los routers pueden declarar pertenencia a una familia (mismo operador):\nfamily: Nombre de la familia family.key: Código de tipo de firma concatenado con la clave pública de firma codificada en base64 family.sig: Firma del nombre de la familia y del hash del router de 32 bytes Varios routers de la misma familia no se utilizarán en tunnels individuales.\n2.6 Expiración de RouterInfo Sin expiración durante la primera hora de tiempo de actividad Sin expiración con 25 RouterInfos almacenados o menos La expiración se reduce a medida que crece el recuento local (72 horas con \u0026lt;120 routers; ~30 horas con 300 routers) Los introductores SSU expiran en ~1 hora Los Floodfills utilizan una expiración de 1 hora para todos los RouterInfos locales 3. LeaseSet (conjunto de concesiones temporales en I2P) LeaseSets documentan puntos de entrada de tunnel para destinos concretos, especificando:\nIdentidad del router de entrada del tunnel ID de tunnel de 4 bytes Tiempo de expiración del tunnel Los LeaseSets incluyen: - Destino – clave de cifrado, clave de firma, certificado - Clave pública adicional de cifrado – para el garlic encryption de extremo a extremo - Clave pública adicional de firma – destinada a la revocación (actualmente sin uso) - Firma criptográfica\n3.1 Variantes de LeaseSet Type Description Unpublished Destinations used only for outgoing connections aren't published to floodfill routers Revoked Published with zero leases, signed by additional signing key (not fully implemented) LeaseSet2 (LS2) As of 0.9.38, supports new encryption types, multiple encryption types, options, offline signing keys ([Proposal 123](/proposals/123-new-netdb-entries/)) Meta LeaseSet Tree-like DHT structure for multihomed services, supporting hundreds/thousands of destinations with long expirations (up to 18.2 hours) Encrypted LeaseSet (LS1) All leases encrypted with separate key; only those with the key can decode and contact the destination Encrypted LeaseSet (LS2) As of 0.9.38, destination hidden with only blinded public key and expiration visible to floodfill ### 3.2 Expiración de LeaseSet Los LeaseSets (estructura de I2P que agrupa leases de entrada) regulares expiran en la expiración más tardía de sus leases. La expiración de LeaseSet2 se especifica en el encabezado. Las expiraciones de EncryptedLeaseSet y MetaLeaseSet pueden variar, con posible aplicación de un límite máximo.\n4. Inicialización La netDb descentralizada requiere al menos una referencia de par para integrarse. Reseeding (resembrado: proceso inicial para obtener pares) recupera archivos RouterInfo (routerInfo-$hash.dat) de los directorios netDb de los voluntarios. El primer arranque obtiene automáticamente desde URLs codificadas de forma fija seleccionadas aleatoriamente.\n5. Mecanismo de Floodfill El netDb floodfill utiliza almacenamiento distribuido simple: envía los datos al par floodfill más cercano. Cuando los pares que no son floodfill envían datos para almacenar, los floodfill los reenvían a un subconjunto de pares floodfill más cercanos a la clave específica.\nLa participación en Floodfill se indica como un indicador de capacidad (f) en RouterInfo (estructura de información del router).\n5.1 Requisitos de adhesión voluntaria a Floodfill A diferencia de los servidores de directorio de confianza predefinidos de Tor, el conjunto de floodfill de I2P es no confiable y cambia con el tiempo.\nFloodfill (modo del router para almacenar y distribuir la netDb) se habilita automáticamente solo en routers de alto ancho de banda que cumplan estos requisitos: - Mínimo 128 KBytes/sec de ancho de banda compartido (configurado manualmente) - Debe superar pruebas de estado adicionales (tiempo de la cola de mensajes salientes, retraso de tareas)\nLa inclusión automática actual da como resultado aproximadamente un 6% de participación de floodfill en la red (nodos especializados que almacenan y propagan la netDb).\nLos floodfill (nodos especiales que almacenan y propagan la netDb) configurados manualmente coexisten con los voluntarios automáticos. Cuando el recuento de floodfill cae por debajo del umbral, los routers de alto ancho de banda se ofrecen automáticamente como voluntarios. Cuando existen demasiados floodfill, dejan de actuar como floodfill.\n5.2 Roles de Floodfill Además de aceptar operaciones de almacenamiento en la netDb y responder a consultas, los floodfills realizan funciones estándar de router. Su mayor ancho de banda normalmente implica una mayor participación en tunnels, pero esto no está directamente relacionado con los servicios de base de datos.\n6. Métrica de proximidad de Kademlia netDb utiliza una métrica de distancia basada en XOR de estilo Kademlia. El hash SHA256 de RouterIdentity o Destination crea la clave de Kademlia (excepto para LS2 Encrypted LeaseSets, que usan SHA256 del byte de tipo 3 junto con la clave pública cegada).\n6.1 Rotación del espacio de claves Para aumentar los costos de un ataque Sybil, en lugar de usar SHA256(key), el sistema utiliza:\nSHA256(key + yyyyMMdd) donde la fecha es una fecha UTC ASCII de 8 bytes. Esto crea la routing key (clave de enrutamiento), que cambia diariamente a la medianoche UTC—lo que se denomina keyspace rotation (rotación del espacio de claves).\nLas claves de enrutamiento nunca se transmiten en mensajes I2NP; solo se utilizan para la determinación de la distancia local.\n7. Segmentación de la base de datos de red Las DHT tradicionales de Kademlia no preservan la no vinculabilidad de la información almacenada. I2P previene ataques que asocian los tunnels de cliente con routers implementando segmentación.\n7.1 Estrategia de segmentación Los Routers registran: - Si las entradas llegaron vía tunnels de cliente o directamente - Si fue vía tunnel, qué tunnel de cliente/destino - Se registran llegadas por múltiples tunnels - Se distinguen las respuestas de almacenamiento frente a las de búsqueda\nTanto las implementaciones en Java como en C++ utilizan: - Una \u0026ldquo;Principal\u0026rdquo; netDb para búsquedas directas/operaciones de floodfill en el contexto del router - \u0026ldquo;Bases de datos de red de cliente\u0026rdquo; o \u0026ldquo;Sub-bases de datos\u0026rdquo; en contextos de cliente, capturando entradas enviadas a tunnels de cliente\nLos netDbs de cliente existen solo durante la vida útil del cliente y contienen únicamente entradas de tunnel de cliente. Las entradas provenientes de tunnels de cliente no pueden solaparse con llegadas directas.\nCada netDb registra si las entradas llegaron como stores (mensajes de almacenamiento; responden a solicitudes de búsqueda) o como respuestas de búsqueda (solo responden si previamente se almacenó en el mismo destino). Los clientes nunca responden consultas con entradas del netDb principal, solo con entradas de la base de datos de red del cliente.\nLas estrategias combinadas segmentan la netDb (base de datos de red de I2P) contra los ataques de asociación cliente-router.\n8. Almacenamiento, verificación y consulta 8.1 Almacenamiento de RouterInfo en pares I2NP DatabaseStoreMessage que contiene el intercambio de RouterInfo (información del router) local durante la inicialización de la conexión de transporte NTCP o SSU.\n8.2 Almacenamiento de LeaseSet en pares Los mensajes I2NP DatabaseStoreMessage que contienen el LeaseSet local se intercambian periódicamente mediante mensajes cifrados con garlic encryption, empaquetados con el tráfico del Destino, lo que permite respuestas sin consultas de LeaseSet.\n8.3 Selección de Floodfill DatabaseStoreMessage envía al floodfill más cercano a la clave de enrutamiento actual. El floodfill más cercano se encuentra mediante una búsqueda en la base de datos local. Aunque no sea realmente el más cercano, la difusión por inundación lo propaga \u0026ldquo;más cerca\u0026rdquo; enviándolo a múltiples floodfills.\nKademlia tradicional utiliza una búsqueda \u0026ldquo;find-closest\u0026rdquo; (búsqueda del más cercano) antes de la inserción. Aunque I2NP carece de tales mensajes, los routers pueden realizar una búsqueda iterativa con el bit menos significativo invertido (key ^ 0x01) para garantizar el descubrimiento del par más cercano real.\n8.4 Almacenamiento de RouterInfo (información del router) en los Floodfills Los routers publican RouterInfo conectándose directamente a un floodfill, enviando un I2NP DatabaseStoreMessage con un token de respuesta distinto de cero. El mensaje no usa garlic encryption (técnica de cifrado \u0026lsquo;garlic\u0026rsquo; propia de I2P) de extremo a extremo (conexión directa, sin intermediarios). El floodfill responde con DeliveryStatusMessage usando el token de respuesta como ID de mensaje.\nLos Routers también pueden enviar RouterInfo a través de un tunnel exploratorio (límites de conexión, incompatibilidad, ocultación de IP). Los Floodfills pueden rechazar dichos almacenamientos durante una sobrecarga.\n8.5 Almacenamiento de LeaseSet (metadatos de enrutamiento para contactar un destino en I2P) en los Floodfills (routers especiales que almacenan y difunden datos) El almacenamiento de LeaseSet es más sensible que RouterInfo (información del router). Los routers deben impedir la asociación de un LeaseSet con ellos mismos.\nLos routers publican el LeaseSet mediante un tunnel de cliente saliente, enviando un DatabaseStoreMessage con un token de respuesta distinto de cero. El mensaje está cifrado de extremo a extremo usando garlic encryption mediante el Administrador de claves de sesión del Destino, lo que lo oculta del extremo de salida del tunnel. El floodfill responde con un DeliveryStatusMessage devuelto a través del tunnel entrante.\n8.6 Proceso de inundación Los Floodfills validan RouterInfo (información del router)/LeaseSet antes de almacenarlos localmente utilizando criterios adaptativos que dependen de la carga, del tamaño de la netdb y de otros factores.\nDespués de recibir datos más nuevos válidos, los floodfills lo \u0026ldquo;inundan\u0026rdquo; buscando los 3 routers floodfill más cercanos a la clave de enrutamiento. Las conexiones directas envían I2NP DatabaseStoreMessage con Token de respuesta cero. Otros routers no responden ni vuelven a inundar.\nRestricciones importantes: - Floodfills (nodos floodfill) no deben propagar a través de tunnels; solo conexiones directas - Floodfills nunca propagan un LeaseSet expirado ni un RouterInfo (información del router) publicado hace más de una hora\n8.7 Búsqueda de RouterInfo y LeaseSet I2NP DatabaseLookupMessage solicita entradas de netDb (base de datos de red) a routers floodfill (nodos que almacenan y propagan la netDb). Las consultas se envían por un tunnel exploratorio saliente; las respuestas especifican el tunnel exploratorio entrante para el retorno.\nLas consultas generalmente se envían, en paralelo, a dos routers floodfill \u0026ldquo;buenos\u0026rdquo; más cercanos a la clave solicitada.\nCoincidencia local: recibe una respuesta I2NP de tipo DatabaseStoreMessage Sin coincidencia local: recibe I2NP DatabaseSearchReplyMessage con referencias a otros routers floodfill (routers especiales que almacenan y distribuyen la netDb) cercanas a la clave Las búsquedas de LeaseSet usan garlic encryption de extremo a extremo (a partir de la versión 0.9.5). Las búsquedas de RouterInfo (información del router) no están cifradas debido al costo computacional de ElGamal, lo que las hace vulnerables a la inspección por parte del extremo de salida.\nA partir de la 0.9.7, las respuestas de búsqueda incluyen la clave de sesión y la etiqueta, ocultando dichas respuestas a la puerta de enlace de entrada.\n8.8 Consultas iterativas Antes de la 0.8.9: Dos consultas redundantes en paralelo sin enrutamiento recursivo ni iterativo.\nA partir de la 0.8.9: Búsquedas iterativas implementadas sin redundancia—más eficientes, fiables y adecuadas para un conocimiento de floodfill incompleto. A medida que las redes crecen y los routers conocen menos floodfills, las búsquedas se acercan a una complejidad O(log n).\nLas búsquedas iterativas continúan incluso sin referencias a pares más cercanos, lo que evita el black-holing (absorción del tráfico sin respuesta) malicioso. Se aplican el número máximo de consultas y el tiempo de espera actuales.\n8.9 Verificación Verificación de RouterInfo (información del router): Deshabilitada a partir de la versión 0.9.7.1 para evitar los ataques descritos en el artículo \u0026ldquo;Practical Attacks Against the I2P Network\u0026rdquo;.\nVerificación de LeaseSet: Los routers esperan ~10 segundos, luego realizan una consulta desde un floodfill diferente a través de un tunnel de cliente saliente. La garlic encryption de extremo a extremo oculta la información al extremo saliente. Las respuestas vuelven a través de tunnels entrantes.\nA partir de la versión 0.9.7, las respuestas se cifran con session key/tag hiding (ocultación de clave/etiqueta de sesión) desde la puerta de enlace entrante.\n8.10 Exploración Exploración implica una búsqueda en netDb con claves aleatorias para descubrir nuevos routers. Los Floodfills responden con DatabaseSearchReplyMessage que contiene hashes de routers que no son floodfill cercanos a la clave solicitada. Las consultas de exploración establecen una bandera especial en DatabaseLookupMessage.\n9. MultiHoming (conexión múltiple a redes/proveedores) Las Destinations (destinos de I2P) que usan claves privadas/públicas idénticas (el eepPriv.dat tradicional) pueden alojarse en múltiples routers simultáneamente. Cada instancia publica periódicamente LeaseSets firmados; el LeaseSet publicado más reciente se devuelve a quienes realizan la consulta. Con tiempos de vida de LeaseSet de un máximo de 10 minutos, las interrupciones duran como mucho ~10 minutos.\nA partir de la 0.9.38, Meta LeaseSets admiten servicios multihomed (con múltiples puntos de conexión) de gran escala mediante Destinations (destinos) separados que proporcionan servicios comunes. Las entradas de Meta LeaseSet son Destinations u otros Meta LeaseSets con caducidades de hasta 18,2 horas, lo que permite que cientos/miles de Destinations alojen servicios comunes.\n10. Análisis de amenazas Aproximadamente 1700 floodfill routers (routers especializados que almacenan y propagan la netDb) operan actualmente. El crecimiento de la red hace que la mayoría de los ataques sean más difíciles o de menor impacto.\n10.1 Mitigaciones generales Crecimiento: Más floodfills hacen que los ataques sean más difíciles o menos impactantes Redundancia: Todas las entradas de netdb se almacenan en 3 routers floodfill más cercanos a la clave mediante inundación Firmas: Todas las entradas están firmadas por su creador; las falsificaciones son imposibles 10.2 Routers lentos o que no responden Routers (enrutadores de I2P) mantienen estadísticas ampliadas del perfil de par para floodfills (nodos especiales que almacenan la base de datos de red de I2P):\nTiempo de respuesta promedio Porcentaje de respuestas a consultas Porcentaje de éxito en la verificación del almacenamiento Último almacenamiento correcto Última búsqueda correcta Última respuesta Los routers utilizan estas métricas al determinar la \u0026ldquo;bondad\u0026rdquo; para seleccionar el floodfill más cercano. Los routers que no responden en absoluto se identifican y se evitan rápidamente; los routers parcialmente maliciosos plantean un desafío mayor.\n10.3 Ataque Sybil (espacio de claves completo) Los atacantes podrían crear numerosos routers floodfill distribuidos por todo el espacio de claves como un ataque de denegación de servicio (DoS) eficaz.\nSi el comportamiento indebido no es suficiente para la designación de \u0026ldquo;bad\u0026rdquo;, las posibles respuestas incluyen: - Compilar listas de hash/IP de router \u0026ldquo;bad\u0026rdquo; anunciadas a través de las noticias de la consola, el sitio web y el foro - Habilitación de floodfill (nodos especiales que almacenan y distribuyen la netDb) en toda la red (\u0026ldquo;combatir a Sybil con más Sybil\u0026rdquo;) - Nuevas versiones del software con listas \u0026ldquo;bad\u0026rdquo; codificadas de forma fija - Métricas y umbrales mejorados de perfiles de pares para la identificación automática - Cualificación de bloque IP que descalifique múltiples floodfills en un único bloque IP - Lista negra automática basada en suscripción (similar al consenso de Tor)\nLas redes más grandes hacen que esto sea más difícil.\n10.4 Ataque Sybil (espacio de claves parcial) Los atacantes podrían crear entre 8 y 15 routers floodfill agrupados muy cerca en el espacio de claves. Todas las consultas/almacenamientos para ese espacio de claves se dirigen a routers del atacante, lo que permite realizar ataques de denegación de servicio (DoS) contra sitios I2P concretos.\nDado que el espacio de claves indexa hashes criptográficos SHA256, los atacantes necesitan fuerza bruta para generar routers con proximidad suficiente.\nDefensa: El algoritmo de cercanía de Kademlia varía con el tiempo usando SHA256(key + YYYYMMDD), cambiando diariamente a medianoche UTC. Esta rotación del espacio de claves fuerza la regeneración diaria del ataque.\nNota: Investigaciones recientes indican que la rotación del espacio de claves no es particularmente efectiva—los atacantes pueden precalcular hashes de router, bastando con unos cuantos routers para eclipsar porciones del espacio de claves en media hora tras la rotación.\nConsecuencia de la rotación diaria: el netdb distribuido se vuelve poco confiable durante unos minutos después de la rotación—las consultas fallan antes de que el nuevo router más cercano reciba los mensajes de almacenamiento.\n10.5 Ataques de arranque Los atacantes podrían tomar el control de reseed websites (sitios web de arranque/bootstrapping de I2P) o engañar a los desarrolladores para que añadan reseed websites hostiles, provocando que routers nuevos arranquen en redes aisladas/controladas por la mayoría.\nDefensas implementadas: - Obtener subconjuntos de RouterInfo (información del router) desde múltiples sitios de reseed (proceso de incorporación inicial de pares) en lugar de un único sitio - Monitoreo de reseed fuera de la red mediante sondeos periódicos a los sitios - A partir de la 0.9.14, los paquetes de datos de reseed son archivos zip firmados con verificación de la firma descargada (ver especificación su3 )\n10.6 Captura de consultas Los Floodfill routers podrían \u0026ldquo;redirigir\u0026rdquo; a los pares hacia routers controlados por un atacante mediante referencias devueltas.\nEs poco probable mediante exploración debido a su baja frecuencia; los routers obtienen referencias de pares principalmente mediante la construcción normal de tunnel.\nA partir de la 0.8.9, se implementaron búsquedas iterativas. Se siguen las referencias de floodfill de DatabaseSearchReplyMessage si están más cerca de la clave de búsqueda. Los routers solicitantes no confían en la proximidad de las referencias. Las búsquedas continúan aunque no se encuentren claves más cercanas, hasta que se alcance el tiempo de espera o el máximo de consultas, evitando el black-holing malicioso (desvío malicioso del tráfico a un sumidero).\n10.7 Fugas de información La filtración de información en la DHT (tabla hash distribuida) de I2P requiere una investigación adicional. Los Floodfill routers observan las consultas y recaban información. Con un 20% de nodos maliciosos, las amenazas Sybil (ataques con identidades múltiples) descritas anteriormente se vuelven problemáticas por múltiples motivos.\n11. Trabajo futuro Cifrado de extremo a extremo de consultas y respuestas adicionales de netDb Mejores métodos de seguimiento de respuestas de consultas Métodos de mitigación para problemas de confiabilidad en la rotación del espacio de claves 12. Referencias Especificación de estructuras comunes – estructuras RouterInfo y LeaseSet Especificación de I2NP – tipos de mensajes de la base de datos Propuesta 123: Nuevas entradas de netDb – especificación de LeaseSet2 Discusión histórica de netDb – historial de desarrollo y debates archivados ","description":"Comprender la base de datos de red distribuida (netDb) de I2P - una DHT (tabla hash distribuida) especializada para la información de contacto de routers y las consultas de destinos","id":"ef0a5e8bee4372a50a7f4562af717b0c","section":"docs","title":"Base de datos de red","url":"/es/docs/overview/network-database/"},{"categories":null,"content":"Resumen BitTorrent sobre I2P permite el intercambio anónimo de archivos a través de túneles cifrados utilizando la capa de streaming de I2P. Todos los pares se identifican mediante destinos criptográficos de I2P en lugar de direcciones IP. El sistema soporta rastreadores HTTP y UDP, enlaces magnet híbridos y cifrado híbrido post-cuántico.\n1. Pila de Protocolos Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP Todas las conexiones se ejecutan a través de la capa de transporte cifrada de I2P (NTCP2 o SSU2). Incluso los paquetes del tracker UDP están encapsulados dentro del streaming de I2P. 2. Rastreadores Rastreadores HTTP Los trackers .i2p estándar responden a peticiones HTTP GET tales como:\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 Las respuestas están bencodeadas y utilizan hashes de destino I2P para los peers.\nRastreadores UDP Los rastreadores UDP fueron estandarizados en 2025 (Propuesta 160).\nRastreadores UDP principales - udp://tracker2.postman.i2p/announce - udp://opentracker.simp.i2p/a - http://opentracker.skank.i2p/a - http://opentracker.dg2.i2p/a \u0026mdash;\n3. Enlaces Magnet magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name Los enlaces magnet admiten enjambres híbridos entre I2P y clearnet cuando están configurados. 4. Implementaciones de DHT Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported --- 5. Implementaciones de Cliente I2PSnark Incluido con todos los routers Soporte solo para rastreadores HTTP Rastreador integrado en http://127.0.0.1:7658/ Sin soporte para rastreadores UDP BiglyBT Con todas las funciones mediante complemento I2P Compatible con rastreadores HTTP + UDP Compatibilidad con torrents híbridos Utiliza la interfaz SAM v3.3 Tixati / XD Clientes ligeros Túneles basados en SAM Cifrado híbrido ML-KEM experimental 6. Configuración I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. Modelo de Seguridad Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) Los torrents híbridos (clearnet + I2P) deben usarse solo si el anonimato no es crítico. 8. Rendimiento Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal Las velocidades típicas oscilan entre **30–80 KB/s**, dependiendo de los peers y las condiciones de la red. 9. Problemas Conocidos Interoperabilidad parcial de DHT entre Java I2P e i2pd Retraso en la obtención de metadatos magnet bajo carga elevada NTCP1 obsoleto pero aún utilizado por peers antiguos UDP simulado sobre streaming aumenta la latencia 10. Hoja de Ruta Futura Multiplexación tipo QUIC Integración completa de ML-KEM Lógica unificada de enjambre híbrido Mirrors de reseed mejorados Reintentos adaptativos de DHT Referencias BEP 15 – UDP Tracker Protocol Propuesta 160 – UDP Tracker sobre I2P Documentación de I2PSnark Especificación de la Biblioteca Streaming ","description":"Especificación detallada y descripción general del ecosistema de BitTorrent dentro de la red I2P","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"BitTorrent sobre I2P","url":"/es/docs/applications/bittorrent/"},{"categories":null,"content":" Advertencia: BOB (Basic Open Bridge, una API heredada de I2P) solo admite el tipo de firma DSA-SHA1 heredado. Java I2P dejó de incluir BOB en 1.7.0 (2022-02); solo está presente en instalaciones que se iniciaron con 1.6.1 o anterior y en algunas compilaciones de i2pd. Las nuevas aplicaciones deben usar SAM v3 .\nVinculaciones de lenguajes Go – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp Notas del protocolo KEYS denota un destino en base64 (claves públicas + privadas). KEY es una clave pública en base64. Las respuestas ERROR tienen la forma ERROR \u0026lt;description\u0026gt;\\n. OK indica la finalización del comando; los datos opcionales siguen en la misma línea. Las líneas DATA transmiten salida adicional antes de un OK final. El comando help es la única excepción: puede no devolver nada para indicar “no existe tal comando”.\nBanner de conexión BOB utiliza líneas ASCII terminadas con salto de línea (LF o CRLF). Al conectarse, emite:\nBOB \u0026lt;version\u0026gt; OK Versión actual: 00.00.10. Las compilaciones anteriores usaban dígitos hexadecimales en mayúsculas y una numeración no estándar.\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds ## Comandos principales Para ver los detalles completos de los comandos, conéctese con telnet localhost 2827 y ejecute help.\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK Resumen de obsolescencia BOB no tiene soporte para tipos de firma modernos, LeaseSets cifrados ni características de transporte. La API está congelada; no se añadirán nuevos comandos. Las aplicaciones que aún dependen de BOB deberían migrar a SAM v3 lo antes posible. ","description":"API obsoleta para la gestión de destinos (obsoleta)","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – Puente Abierto Básico","url":"/es/docs/legacy/bob/"},{"categories":null,"content":" 1. Descripción general Un transporte en I2P es un método de comunicación directa, punto a punto, entre routers. Estos mecanismos garantizan la confidencialidad y la integridad, a la vez que verifican la autenticación de los routers.\nCada transporte funciona con paradigmas de conexión que incluyen autenticación, control de flujo, acuses de recibo y capacidades de retransmisión.\n2. Transportes actuales Actualmente, I2P admite dos transportes principales:\nTransport Protocol Description NTCP2 TCP Noise-based TCP transport with modern encryption (as of 0.9.36) SSU2 UDP Secure Semireliable UDP with modern encryption (as of 0.9.56) ### 2.1 Transportes heredados (obsoletos) Transport Protocol Status NTCP TCP Replaced by NTCP2; removed in 0.9.62 SSU UDP Replaced by SSU2; removed in 0.9.62 --- 3. Servicios de transporte El subsistema de transporte proporciona los siguientes servicios:\n3.1 Entrega de mensajes Entrega fiable de mensajes I2NP (los transportes gestionan la mensajería I2NP exclusivamente) La entrega en orden NO está garantizada universalmente Encolado de mensajes basado en prioridad 3.2 Gestión de conexiones Establecimiento y cierre de conexiones Gestión de límites de conexión con cumplimiento de umbrales Seguimiento del estado por par Aplicación, automática y manual, de la lista de bloqueo de pares 3.3 Configuración de red Múltiples direcciones del router para cada transporte (compatibilidad con IPv4 e IPv6 desde v0.9.8) Apertura de puertos del cortafuegos mediante UPnP Soporte para el atravesamiento de NAT/cortafuegos Detección de la dirección IP local mediante múltiples métodos 3.4 Seguridad Cifrado para intercambios punto a punto Validación de direcciones IP según las reglas locales Determinación del consenso del reloj (respaldo NTP) 3.5 Gestión del ancho de banda Límites de ancho de banda de entrada y salida Selección óptima de transporte para mensajes salientes 4. Direcciones de transporte El subsistema mantiene una lista de puntos de contacto del router:\nMétodo de transporte (NTCP2, SSU2) Dirección IP Número de puerto Parámetros opcionales Se pueden usar múltiples direcciones por método de transporte.\n4.1 Configuraciones comunes de direcciones Configuration Description Hidden Routers with no published addresses Firewalled Routers publishing SSU2 addresses with \"introducer\" peer lists for NAT traversal Unrestricted Routers advertising both NTCP2 and SSU2 addresses on IPv4 and/or IPv6 --- 5. Selección de transporte El sistema selecciona los transportes para mensajes I2NP independientemente de los protocolos de capa superior. La selección emplea un sistema de pujas en el que cada transporte presenta pujas; gana la de menor valor.\n5.1 Factores para determinar la puja Configuración de preferencias de transporte Conexiones con pares existentes Número de conexiones actual frente al umbral Historial reciente de intentos de conexión Restricciones de tamaño de mensaje Capacidades de transporte del RouterInfo (metadatos del router) del par Directitud de la conexión (directa frente a dependiente de introducer (nodo introductor)) Preferencias de transporte anunciadas por el par Generalmente, dos routers mantienen conexiones de un solo transporte simultáneamente, aunque son posibles conexiones simultáneas de múltiples transportes.\n6. NTCP2 NTCP2 (New Transport Protocol 2) es el transporte moderno basado en TCP para I2P, introducido en la versión 0.9.36.\n6.1 Características clave Basado en el Noise Protocol Framework (patrón Noise_XK) Usa X25519 para el intercambio de claves Usa ChaCha20/Poly1305 para cifrado autenticado Usa BLAKE2s para el cálculo de hash Ofuscación del protocolo para resistir DPI (inspección profunda de paquetes) Relleno opcional para resistir el análisis de tráfico 6.2 Establecimiento de la conexión Solicitud de sesión (Alice → Bob): Clave X25519 efímera + carga útil cifrada Sesión creada (Bob → Alice): Clave efímera + confirmación cifrada Sesión confirmada (Alice → Bob): Negociación final con RouterInfo (información del router) Todos los datos posteriores se cifran con claves de sesión derivadas de la negociación inicial.\nConsulte la Especificación de NTCP2 para obtener todos los detalles.\n7. SSU2 SSU2 (UDP seguro semiconfiable 2) es el transporte moderno basado en UDP para I2P, introducido en la versión 0.9.56.\n7.1 Características clave Basado en el Noise Protocol Framework (marco de protocolos Noise) (Noise_XK pattern) Usa X25519 para el intercambio de claves Usa ChaCha20/Poly1305 para cifrado autenticado Entrega parcialmente fiable con acuses de recibo selectivos Atravesamiento de NAT mediante hole punching (técnica de perforación de puertos) y relé/introducción Soporte para migración de conexiones Descubrimiento de MTU de ruta 7.2 Ventajas frente a SSU (legado) Feature SSU (Legacy) SSU2 Encryption ElGamal + AES X25519 + ChaCha20/Poly1305 Header encryption Partial Full (ChaCha20) Connection ID Fixed Encrypted, rotatable NAT traversal Basic introduction Enhanced hole punching + relay Obfuscation Minimal Improved (variable padding) Consulta la [Especificación de SSU2](/docs/specs/ssu2/) para obtener todos los detalles. 8. Atravesamiento de NAT Ambos transportes admiten el atravesamiento de NAT para permitir que los routers detrás de un cortafuegos participen en la red.\n8.1 Introducción a SSU2 Cuando un router no puede recibir conexiones entrantes directamente:\nEl router publica direcciones de introducer en su RouterInfo El par que se conecta envía una solicitud de introducción al introducer El introducer reenvía la información de la conexión al router detrás de un cortafuegos El router detrás de un cortafuegos inicia una conexión saliente (hole punch: perforación de NAT) Se establece comunicación directa 8.2 NTCP2 y cortafuegos NTCP2 requiere conectividad TCP entrante. Los routers detrás de NAT pueden:\nUsar UPnP para abrir puertos automáticamente Configurar manualmente el reenvío de puertos Confiar en SSU2 para las conexiones entrantes mientras se usa NTCP2 para las salientes 9. Ofuscación del protocolo Ambos transportes modernos incorporan características de ofuscación:\nRelleno aleatorio en los mensajes de negociación Encabezados cifrados que no revelan firmas del protocolo Mensajes de longitud variable para resistir el análisis de tráfico Sin patrones fijos en el establecimiento de la conexión Nota: La ofuscación en la capa de transporte complementa, pero no reemplaza el anonimato proporcionado por la arquitectura de tunnel de I2P.\n10. Desarrollo futuro Las investigaciones y mejoras planificadas incluyen:\nTransportes conectables – Complementos de ofuscación compatibles con Tor Transporte basado en QUIC – Investigación de los beneficios del protocolo QUIC Optimización del límite de conexiones – Investigación sobre límites óptimos de conexiones con pares Estrategias de relleno mejoradas – Mayor resistencia al análisis de tráfico 11. Referencias NTCP2 Specification – Transporte TCP basado en Noise (framework criptográfico) SSU2 Specification – UDP 2 seguro y semiconfiable I2NP Specification – Mensajes del Protocolo de Red de I2P Common Structures – RouterInfo y estructuras de direcciones Historical NTCP Discussion – Historia del desarrollo del transporte heredado Legacy SSU Documentation – Especificación original de SSU (obsoleta) ","description":"Comprender la capa de transporte de I2P - métodos de comunicación punto a punto entre routers, incluyendo NTCP2 y SSU2","id":"5fbac972dc212081634c49c5e6ac0004","section":"docs","title":"Capa de transporte","url":"/es/docs/overview/transport/"},{"categories":null,"content":" Estado: Este documento describe el protocolo de cifrado ElGamal/AES+SessionTag legado. Sigue siendo compatible únicamente por motivos de compatibilidad retroactiva, ya que las versiones modernas de I2P (2.10.0+) utilizan ECIES-X25519-AEAD-Ratchet . El protocolo ElGamal está en desuso y se mantiene únicamente por motivos históricos y de interoperabilidad.\nDescripción general ElGamal/AES+SessionTag proporcionaba el mecanismo original de cifrado de extremo a extremo de I2P para los mensajes garlic (formato de mensajes agregados). Combinaba:\nElGamal (2048-bit) — para el intercambio de claves AES-256/CBC — para el cifrado de la carga útil SHA-256 — para el cálculo de hash y la derivación del vector de inicialización (IV) Etiquetas de sesión (32 bytes) — para identificadores de mensajes de un solo uso El protocolo permitía que routers y destinos se comunicaran de forma segura sin mantener conexiones persistentes. Cada sesión empleaba un intercambio asimétrico de ElGamal para establecer una clave AES simétrica, seguida por mensajes \u0026ldquo;etiquetados\u0026rdquo; ligeros que hacían referencia a esa sesión.\nFuncionamiento del protocolo Establecimiento de sesión (nueva sesión) Se inició una nueva sesión con un mensaje que contenía dos secciones:\nSection Size Contents Purpose ElGamal-encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient's ElGamal public key Establishes the AES session key and IV seed AES-encrypted block Variable (≥128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags El texto plano dentro del bloque de ElGamal constaba de: Field Size Description Session Key 32 bytes AES-256 key for the session Pre-IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA-256(Pre-IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length ### Mensajes de sesión existentes Una vez establecida una sesión, el remitente podía enviar mensajes de tipo existing-session (sesión existente) usando etiquetas de sesión almacenadas en caché:\nField Size Description Session Tag 32 bytes Single-use identifier tied to the existing session key AES-Encrypted Block Variable Encrypted payload and metadata using the established AES key Routers almacenaban en caché las etiquetas entregadas durante aproximadamente **15 minutos**, tras lo cual las etiquetas no utilizadas caducaban. Cada etiqueta era válida para exactamente **un mensaje** para evitar ataques de correlación. Formato de bloque cifrado con AES Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single-use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA-256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16-byte aligned) Random padding to block boundary Routers descifran usando la clave de sesión y el IV (vector de inicialización), derivados del Pre-IV (para sesiones nuevas) o de la etiqueta de sesión (para sesiones existentes). Después del descifrado, verifican la integridad volviendo a calcular el hash SHA-256 de la carga útil en claro. Gestión de etiquetas de sesión Las etiquetas son unidireccionales: las etiquetas Alice → Bob no pueden reutilizarse para Bob → Alice. Las etiquetas caducan tras aproximadamente 15 minutos. Routers mantienen gestores de claves de sesión por destino para hacer seguimiento de etiquetas, claves y tiempos de expiración. Las aplicaciones pueden controlar el comportamiento de las etiquetas mediante I2CP options : i2cp.tagThreshold — mínimo de etiquetas en caché antes de la reposición i2cp.tagCount — número de etiquetas nuevas por mensaje Este mecanismo minimizó los costosos handshakes (proceso de establecimiento) de ElGamal, al tiempo que mantenía la no vinculabilidad entre mensajes.\nConfiguración y eficiencia Las etiquetas de sesión se introdujeron para mejorar la eficiencia en el transporte de I2P, que es de alta latencia y no ordenado. Una configuración típica entregaba 40 etiquetas por mensaje, añadiendo alrededor de 1,2 KB de sobrecarga. Las aplicaciones podían ajustar el comportamiento de entrega según el tráfico esperado:\nUse Case Recommended Tags Notes Short-lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re-establishment Long-term services 50+ Ensures steady tag supply despite loss or delay Routers purgan periódicamente etiquetas caducadas y eliminan el estado de sesión no utilizado para reducir el uso de memoria y mitigar ataques de inundación de etiquetas. Limitaciones Category Limitation Performance 514-byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES-CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor's algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. Estas deficiencias motivaron directamente el diseño del protocolo [ECIES-X25519-AEAD-Ratchet](/docs/specs/ecies/), que proporciona secreto perfecto hacia adelante, cifrado autenticado e intercambio de claves eficiente. Estado de obsolescencia y migración Introducido: Primeras versiones de I2P (anteriores a la 0.6) Obsoleto: Con la introducción de ECIES-X25519 (0.9.46 → 0.9.48) Eliminado: Dejó de ser el valor predeterminado a partir de la 2.4.0 (diciembre de 2023) Admitido: Solo por compatibilidad heredada Los routers modernos y los destinos ahora anuncian tipo de cifrado 4 (ECIES-X25519) en lugar de tipo 0 (ElGamal/AES). El protocolo heredado sigue siendo reconocido para la interoperabilidad con pares desactualizados, pero no debería utilizarse para nuevas implementaciones.\nContexto histórico ElGamal/AES+SessionTag fue fundamental para la arquitectura criptográfica inicial de I2P. Su diseño híbrido introdujo innovaciones como las etiquetas de sesión de un solo uso y las sesiones unidireccionales, que sirvieron de base para protocolos posteriores. Muchas de estas ideas evolucionaron hacia construcciones modernas como deterministic ratchets (mecanismos de avance deterministas) y los intercambios de claves poscuánticos híbridos.\n","description":"Cifrado de extremo a extremo heredado que combina ElGamal, AES, SHA-256 y one-time session tags (etiquetas de sesión de un solo uso)","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"Cifrado ElGamal/AES + SessionTag (etiqueta de sesión)","url":"/es/docs/legacy/elgamal-aes/"},{"categories":null,"content":"Estado de implementación Despliegue actual: - i2pd (implementación en C++): Implementado por completo en la versión 2.58.0 (septiembre de 2025) con soporte para ML-KEM-512, ML-KEM-768 y ML-KEM-1024. El cifrado de extremo a extremo poscuántico se habilita de forma predeterminada cuando esté disponible OpenSSL 3.5.0 o posterior. - Java I2P: Aún no implementado hasta la versión 0.9.67 / 2.10.0 (septiembre de 2025). Especificación aprobada y la implementación planificada para versiones futuras.\nEsta especificación describe la funcionalidad aprobada que actualmente está desplegada en i2pd y planificada para implementaciones de Java I2P.\nDescripción general Esta es la variante híbrida poscuántica del protocolo ECIES-X25519-AEAD-Ratchet ECIES . Representa la primera fase de la Propuesta 169 Prop169 en ser aprobada. Consulte esa propuesta para conocer los objetivos generales, los modelos de amenaza, el análisis, las alternativas y la información adicional.\nEstado de la propuesta 169: Abierta (primera fase aprobada para la implementación híbrida de ECIES (Esquema de Cifrado Integrado basado en Curvas Elípticas)).\nEsta especificación contiene únicamente las diferencias respecto del ECIES estándar (Esquema de Cifrado Integrado de Curva Elíptica) y debe leerse junto con esa especificación.\nDiseño Utilizamos el estándar NIST FIPS 203 FIPS203 , que está basado en, pero no es compatible con, CRYSTALS-Kyber (esquema de encapsulación de claves poscuántico) (versiones 3.1, 3 y anteriores).\nLas negociaciones híbridas combinan Diffie-Hellman X25519 clásico con mecanismos de encapsulación de claves ML-KEM poscuánticos. Este enfoque se basa en conceptos de secreto hacia adelante híbrido documentados en la investigación PQNoise y en implementaciones similares en TLS 1.3, IKEv2 y WireGuard.\nIntercambio de claves Definimos un intercambio de claves híbrido para Ratchet (mecanismo de avance de claves). Un KEM poscuántico proporciona únicamente claves efímeras y no admite directamente handshakes (negociaciones iniciales) con clave estática, como Noise IK (patrón IK del protocolo Noise).\nDefinimos las tres variantes de ML-KEM (mecanismo de encapsulación de claves basado en retículas modulares) según lo especificado en FIPS203 , para un total de 3 nuevos tipos de cifrado. Los tipos híbridos solo se definen en combinación con X25519.\nLos nuevos tipos de cifrado son:\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 **Nota:** MLKEM768_X25519 (Tipo 6) es la variante predeterminada recomendada, que proporciona una sólida seguridad poscuántica con una sobrecarga razonable. La sobrecarga es considerable en comparación con el cifrado únicamente con X25519. Los tamaños típicos de los mensajes 1 y 2 (para IK pattern (patrón IK)) son actualmente alrededor de 96-103 bytes (antes de la carga útil adicional). Esto aumentará aproximadamente 9-12x para MLKEM512, 13-16x para MLKEM768 y 17-23x para MLKEM1024, según el tipo de mensaje.\nSe requiere nueva criptografía ML-KEM (anteriormente CRYSTALS-Kyber) FIPS203 - Estándar de mecanismo de encapsulación de claves basado en retículas de módulo SHA3-256 (anteriormente Keccak-512) FIPS202 - Parte del estándar SHA-3 SHAKE128 y SHAKE256 (extensiones XOF de SHA3) FIPS202 - Funciones de salida extensibles (XOF) Los vectores de prueba para SHA3-256, SHAKE128 y SHAKE256 están disponibles en el Programa de Validación de Algoritmos Criptográficos del NIST .\nSoporte de bibliotecas: - Java: La biblioteca Bouncycastle versión 1.79 y posteriores admite todas las variantes de ML-KEM y las funciones SHA3/SHAKE - C++: OpenSSL 3.5 y posteriores incluyen compatibilidad completa con ML-KEM (lanzamiento en abril de 2025) - Go: Varias bibliotecas disponibles para la implementación de ML-KEM y SHA3\nEspecificación Estructuras comunes Consulte la Especificación de Estructuras Comunes para conocer las longitudes de las claves y los identificadores.\nPatrones de negociación Los handshakes usan patrones de handshake del Noise Protocol Framework (marco del Protocolo Noise) con adaptaciones específicas de I2P para seguridad híbrida poscuántica.\nSe utiliza la siguiente asignación de letras:\ne = clave efímera de un solo uso (X25519) s = clave estática p = carga útil del mensaje e1 = clave PQ (poscuántica) efímera de un solo uso, enviada de Alice a Bob (token específico de I2P) ekem1 = el texto cifrado del KEM (mecanismo de encapsulación de claves), enviado de Bob a Alice (token específico de I2P) Nota importante: Los nombres de patrones \u0026ldquo;IKhfs\u0026rdquo; e \u0026ldquo;IKhfselg2\u0026rdquo; y los tokens \u0026ldquo;e1\u0026rdquo; y \u0026ldquo;ekem1\u0026rdquo; son adaptaciones específicas de I2P no documentadas en la especificación oficial del Noise Protocol Framework (marco del Protocolo Noise). Estas representan definiciones personalizadas para integrar ML-KEM en el patrón Noise IK (patrón IK de Noise). Aunque el enfoque híbrido X25519 + ML-KEM está ampliamente reconocido en la investigación de criptografía poscuántica y en otros protocolos, la nomenclatura específica utilizada aquí es propia de I2P.\nSe aplican las siguientes modificaciones a IK para lograr secreto hacia adelante híbrido:\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. El patrón e1 se define de la siguiente manera:\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) El patrón ekem1 se define de la siguiente manera:\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) Operaciones definidas de ML-KEM (mecanismo de encapsulación de claves basado en retículas de módulos) Definimos las siguientes funciones correspondientes a las primitivas criptográficas según lo especificado en FIPS203 .\n(encap_key, decap_key) = PQ_KEYGEN() : Alice crea las claves de encapsulación y desencapsulación. La clave de encapsulación se envía en el mensaje NS. Tamaños de clave: - ML-KEM-512: encap_key = 800 bytes, decap_key = 1632 bytes - ML-KEM-768: encap_key = 1184 bytes, decap_key = 2400 bytes - ML-KEM-1024: encap_key = 1568 bytes, decap_key = 3168 bytes\n(ciphertext, kem_shared_key) = ENCAPS(encap_key) : Bob calcula el texto cifrado y la clave compartida usando la clave de encapsulación recibida en el mensaje NS. El texto cifrado se envía en el mensaje NSR. Tamaños del texto cifrado: - ML-KEM-512: 768 bytes - ML-KEM-768: 1088 bytes - ML-KEM-1024: 1568 bytes\nEl kem_shared_key siempre tiene 32 bytes en las tres variantes.\nkem_shared_key = DECAPS(ciphertext, decap_key) : Alice calcula la clave compartida usando el texto cifrado recibido en el mensaje NSR. La kem_shared_key siempre es de 32 bytes.\nImportante: Tanto la encap_key como el texto cifrado están cifrados dentro de bloques de ChaCha20-Poly1305 en los mensajes 1 y 2 del handshake de Noise. Se descifrarán como parte del proceso de handshake.\nLa kem_shared_key se mezcla en la clave de encadenamiento con MixKey(). Véase más abajo para más detalles.\nKDF (función de derivación de claves) del Handshake de Noise Descripción general El handshake híbrido combina X25519 ECDH clásico con ML-KEM poscuántico (mecanismo de encapsulación de claves). El primer mensaje, de Alice a Bob, contiene e1 (la clave de encapsulación de ML-KEM) antes de la carga útil del mensaje. Esto se considera material de clave adicional; llama a EncryptAndHash() sobre él (como Alice) o a DecryptAndHash() (como Bob). Luego procesa la carga útil del mensaje como de costumbre.\nEl segundo mensaje, de Bob a Alice, contiene ekem1 (el texto cifrado ML-KEM (mecanismo de encapsulación de claves poscuántico)) antes de la carga útil del mensaje. Se considera material de clave adicional; llama a EncryptAndHash() sobre él (como Bob) o a DecryptAndHash() (como Alice). Luego calcula kem_shared_key y llama a MixKey(kem_shared_key). Después, procesa la carga útil del mensaje como de costumbre.\nIdentificadores de Noise (marco de protocolo criptográfico) Estas son las cadenas de inicialización de Noise (específicas de I2P):\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 KDF de Alice para el mensaje NS Después del patrón de mensaje \u0026rsquo;es\u0026rsquo; y antes del patrón de mensaje \u0026rsquo;s\u0026rsquo;, agrega:\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). KDF (función de derivación de claves) de Bob para el mensaje NS Después del patrón de mensajes \u0026rsquo;es\u0026rsquo; y antes del patrón de mensajes \u0026rsquo;s\u0026rsquo;, añada:\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). KDF (función de derivación de claves) de Bob para el mensaje NSR Después del patrón de mensaje \u0026rsquo;ee\u0026rsquo; y antes del patrón de mensaje \u0026lsquo;se\u0026rsquo;, añada:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. KDF (función de derivación de claves) de Alice para el mensaje NSR Después del patrón de mensaje \u0026rsquo;ee\u0026rsquo; y antes del patrón de mensaje \u0026lsquo;ss\u0026rsquo;, agregue:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. KDF para split() La función split() permanece sin cambios con respecto a la especificación estándar de ECIES. Tras completar el handshake (negociación inicial):\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] Estas son las claves de sesión bidireccionales para la comunicación en curso.\nFormato del mensaje Formato NS (Nueva sesión) Cambios: El ratchet (mecanismo de avance escalonado) actual contiene la clave estática en la primera sección de ChaCha20-Poly1305 y la carga útil en la segunda sección. Con ML-KEM, ahora hay tres secciones. La primera sección contiene la clave pública de ML-KEM cifrada (encap_key). La segunda sección contiene la clave estática. La tercera sección contiene la carga útil.\nTamaños de mensajes:\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl **Nota:** La carga útil debe contener un bloque DateTime (bloque de fecha y hora) (mínimo 7 bytes: 1 byte de tipo, 2 bytes de tamaño, 4 bytes de marca de tiempo). Los tamaños mínimos de NS pueden calcularse en consecuencia. Por lo tanto, el tamaño mínimo práctico de NS es de 103 bytes para X25519 y oscila entre 919 y 1687 bytes para las variantes híbridas. Los incrementos de tamaño de 816, 1200 y 1584 bytes para las tres variantes de ML-KEM (mecanismo de encapsulación de claves) se deben a la clave pública de ML-KEM más un Poly1305 MAC (código de autenticación de mensajes) de 16 bytes para cifrado autenticado.\nFormato de NSR (New Session Reply, respuesta de nueva sesión) Cambios: El ratchet (mecanismo de avance criptográfico) actual tiene una carga útil vacía en la primera sección de ChaCha20-Poly1305 y la carga útil en la segunda sección. Con ML-KEM, ahora hay tres secciones. La primera sección contiene el texto cifrado de ML-KEM, cifrado. La segunda sección tiene una carga útil vacía. La tercera sección contiene la carga útil.\nTamaños de mensajes:\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl Los incrementos de tamaño de 784, 1104 y 1584 bytes para las tres variantes de ML-KEM se deben al texto cifrado de ML-KEM más un MAC Poly1305 de 16 bytes para cifrado autenticado. Análisis de sobrecarga Intercambio de claves La sobrecarga del cifrado híbrido es sustancial en comparación con solo X25519:\nMLKEM512_X25519: Aproximadamente un incremento de 9-12x en el tamaño del mensaje de handshake (intercambio inicial) (NS: 9.5x, NSR: 11.9x) MLKEM768_X25519: Aproximadamente un incremento de 13-16x en el tamaño del mensaje de handshake (NS: 13.5x, NSR: 16.3x) MLKEM1024_X25519: Aproximadamente un incremento de 17-23x en el tamaño del mensaje de handshake (NS: 17.5x, NSR: 23x) Esta sobrecarga es aceptable por los beneficios adicionales de seguridad poscuántica. Los multiplicadores varían según el tipo de mensaje porque los tamaños base de los mensajes difieren (NS mínimo 96 bytes, NSR mínimo 72 bytes).\nConsideraciones sobre el ancho de banda Para un establecimiento de sesión típico con cargas útiles mínimas: - X25519 solo: ~200 bytes en total (NS + NSR) - MLKEM512_X25519: ~1,800 bytes en total (incremento de 9x) - MLKEM768_X25519: ~2,500 bytes en total (incremento de 12.5x) - MLKEM1024_X25519: ~3,400 bytes en total (incremento de 17x)\nTras el establecimiento de la sesión, el cifrado de los mensajes en curso utiliza el mismo formato de transporte de datos que las sesiones solo X25519, por lo que no introduce sobrecarga adicional en los mensajes posteriores.\nAnálisis de seguridad Apretones de manos El handshake híbrido (negociación inicial) proporciona seguridad tanto clásica (X25519) como poscuántica (ML-KEM). Un atacante debe romper ambos, el ECDH clásico y el KEM poscuántico, para comprometer las claves de sesión.\nEsto proporciona: - Seguridad actual: X25519 ECDH proporciona seguridad frente a atacantes clásicos (nivel de seguridad de 128 bits) - Seguridad futura: ML-KEM (mecanismo de encapsulación de claves poscuántico) proporciona seguridad frente a atacantes cuánticos (varía según el conjunto de parámetros) - Seguridad híbrida: Ambos deben ser vulnerados para comprometer la sesión (nivel de seguridad = máximo de ambos componentes)\nNiveles de seguridad Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit **Nota:** El nivel de seguridad híbrido está limitado por el más débil de los dos componentes. En todos los casos, X25519 proporciona seguridad clásica de 128 bits. Si llegara a estar disponible una computadora cuántica relevante desde el punto de vista criptográfico, el nivel de seguridad dependería del conjunto de parámetros de ML-KEM (mecanismo de encapsulación de claves basado en retículos modulares) elegido. Secreto hacia adelante El enfoque híbrido mantiene las propiedades de secreto hacia adelante. Las claves de sesión se derivan de ambos intercambios de claves efímeros: X25519 y ML-KEM. Si se destruyen las claves privadas efímeras de X25519 o de ML-KEM tras el handshake, las sesiones pasadas no pueden descifrarse incluso si las claves estáticas a largo plazo se ven comprometidas.\nEl IK pattern (patrón IK del protocolo Noise) proporciona secreto hacia adelante completo (Noise Confidentiality level 5) tras el envío del segundo mensaje (NSR).\nPreferencias de tipo Las implementaciones deberían admitir múltiples tipos híbridos y negociar la variante más fuerte admitida por ambas partes. El orden de preferencia debería ser:\nMLKEM768_X25519 (Tipo 6) - Predeterminado recomendado, el mejor equilibrio entre seguridad y rendimiento MLKEM1024_X25519 (Tipo 7) - Máxima seguridad para aplicaciones sensibles MLKEM512_X25519 (Tipo 5) - Seguridad poscuántica de nivel básico para escenarios con recursos limitados X25519 (Tipo 4) - Solo clásico, alternativa de respaldo para compatibilidad Justificación: Se recomienda MLKEM768_X25519 como valor predeterminado porque proporciona seguridad de Categoría 3 de NIST (equivalente a AES-192), considerada una protección suficiente frente a las computadoras cuánticas, manteniendo al mismo tiempo tamaños de mensaje razonables. MLKEM1024_X25519 ofrece mayor seguridad, pero con una sobrecarga sustancialmente superior.\nNotas de implementación Soporte de bibliotecas Java: La biblioteca Bouncycastle, a partir de la versión 1.79 (agosto de 2024), admite todas las variantes de ML-KEM (mecanismo de encapsulación de claves poscuántico de NIST) y las funciones SHA3/SHAKE (familia de funciones hash/derivación de NIST). Use org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine para el cumplimiento de FIPS 203 (estándar de NIST). C++: OpenSSL 3.5 (abril de 2025) y posteriores incluyen compatibilidad con ML-KEM mediante la interfaz EVP_KEM (interfaz de OpenSSL). Esta es una versión con Soporte de Largo Plazo (LTS) mantenida hasta abril de 2030. Go: Varias bibliotecas de terceros están disponibles para ML-KEM y SHA3, incluida la biblioteca CIRCL de Cloudflare. Estrategia de migración Las implementaciones deberían: 1. Admitir tanto variantes solo X25519 como variantes híbridas de ML-KEM (mecanismo de encapsulación de claves poscuántico) durante el período de transición 2. Preferir las variantes híbridas cuando ambos pares las admitan 3. Mantener un mecanismo de reserva a solo X25519 para compatibilidad con versiones anteriores 4. Considerar las restricciones de ancho de banda de la red al seleccionar la variante predeterminada\nTunnels compartidos Los tamaños de mensajes más grandes pueden afectar el uso compartido de tunnel. Las implementaciones deberían considerar: - Agrupar handshakes (intercambios iniciales de negociación) cuando sea posible para amortizar la sobrecarga - Usar tiempos de expiración más cortos para las sesiones híbridas para reducir el estado almacenado - Supervisar el uso de ancho de banda y ajustar los parámetros en consecuencia - Implementar control de congestión para el tráfico de establecimiento de sesión\nConsideraciones sobre el tamaño de nuevas sesiones Debido al mayor tamaño de los mensajes de handshake (intercambio inicial), las implementaciones pueden necesitar: - Aumentar el tamaño de los búferes para la negociación de sesión (mínimo 4KB recomendado) - Ajustar los valores de tiempo de espera para conexiones más lentas (tener en cuenta que los mensajes son ~3-17x más grandes) - Considerar la compresión de los datos de carga útil en NS/NSR messages (mensajes de tipo NS/NSR) - Implementar la gestión de fragmentación si la capa de transporte lo requiere\nPruebas y validación Las implementaciones deberían verificar: - Generación de claves ML-KEM, encapsulación y desencapsulación correctas - Integración adecuada de kem_shared_key en Noise KDF - Que los cálculos del tamaño de los mensajes coincidan con la especificación - Interoperabilidad con otras implementaciones de I2P router - Comportamiento de respaldo cuando ML-KEM no esté disponible\nLos vectores de prueba para las operaciones de ML-KEM (mecanismo de encapsulación de claves basado en retículas modulares) están disponibles en el Programa de Validación de Algoritmos Criptográficos de NIST.\nCompatibilidad de versiones Numeración de versiones de I2P: I2P mantiene dos números de versión en paralelo: - Versión de lanzamiento del router: formato 2.x.x (p. ej., 2.10.0 publicado en septiembre de 2025) - Versión de la API/protocolo: formato 0.9.x (p. ej., 0.9.67 corresponde al router 2.10.0)\nEsta especificación hace referencia a la versión del protocolo 0.9.67, que corresponde a la versión del router 2.10.0 y posteriores.\nMatriz de compatibilidad:\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release ## Referencias [ECIES]: Especificación ECIES-X25519-AEAD-Ratchet [Prop169]: Propuesta 169: Criptografía poscuántica [FIPS203]: NIST FIPS 203 - Estándar ML-KEM [FIPS202]: NIST FIPS 202 - Estándar SHA-3 [Noise]: Marco del Protocolo Noise [COMMON]: Especificación de estructuras comunes [RFC7539]: RFC 7539 - ChaCha20 y Poly1305 [RFC5869]: RFC 5869 - HKDF [OpenSSL]: Documentación de OpenSSL 3.5 ML-KEM [Bouncycastle]: Biblioteca criptográfica de Java Bouncycastle ","description":"Variante híbrida poscuántica del protocolo de cifrado ECIES (esquema integrado de cifrado sobre curvas elípticas) usando ML-KEM","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"Cifrado híbrido con ECIES-X25519-AEAD-Ratchet","url":"/es/docs/specs/ecies-hybrid/"},{"categories":null,"content":" Las versiones 0.9.57 en adelante están firmadas por idk. Su clave pública actual es: Descargar clave pública PGP Las versiones 0.7.6 y 0.9.56 están firmadas por zzz. Su clave pública actual es: Descargar clave pública PGP -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 He creado nuevas claves GPG y subclaves y he firmado las nuevas claves con la clave antigua.\nClaves antiguas:\npub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) \u0026lt;zzz@mail.i2p\u0026gt; sub 2048g/74C8122D 2005-12-16 Nuevas claves:\npub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) \u0026lt;zzz@mail.i2p\u0026gt; uid zzz on i2p (key signing) \u0026lt;zzz@i2pmail.org\u0026gt; sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07] Usaré las nuevas claves de la siguiente manera:\nEE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing La clave de firma de versiones se utilizará a partir de la versión 0.9.13. Este mensaje está firmado con mi clave antigua.\nzzz 25 de mayo de 2014\nLas nuevas claves son las siguientes:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.14 (GNU/Linux)\nmQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dwXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHp\niEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; Las versiones desde 0.9.9 podrían estar firmadas por str4d. Su clave pública actual es: -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 Mis claves públicas actuales son las siguientes:\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [caduca: 2019-03-10] uid [completo] str4d (http://str4d.i 2p) str4d@mail.i2p uid [completo] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [caducada: 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [caducada: 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [caduca: 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [caduca: 2016-04-04]\nActualmente uso las claves de la siguiente manera:\nA94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing Genero nuevas subclaves de cifrado y firma anualmente. Cualquier versión de I2P firmada por mí siempre estará firmada con la subclave de firma más reciente al momento del lanzamiento.\nstr4d 20 nov 2015\nLas claves actuales (a partir de la fecha indicada) son las siguientes:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z\niQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d ha firmado las siguientes versiones: 0.9.23 Las versiones 0.7.6 a 0.9.12 fueron firmadas por zzz con la siguiente clave: -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enop IDx6enpAbWFpbC5pMnA+iF8EExECAB8FAkOjTnUCGwMGCwkIBwMCBBUCCAMDFgIB Ah4BAheAAAoJEEFVdrqnbgvtxGsAn39SvQ3+ey87WDDG+TWArN6oU8gnAJ4zeAsA LUK37WZIt8OImZSxk37uQbkCDQRDo06VEAgAy2UeqsM5a+U6ZOWS9NQiILb3KbTL FeeAd2rn9oLSLpn5gDWycwUS0Q62JmbSMWy6m9aczpnxvwaBYXz6aCIvZmTNtaU6 vyR/6wfJDyiUWSHtCyjpyFFYJimANd8Y8dDCimvceI/ihEDVyBX0kkgUGRAn8t3e unaLXqhbfiLiFw/GG1MNxUMzHt55/+9AqLOfRZg0riZvDoV79K+1sYSs8n1WeaVc T3wTb+Cb7fKNN7GT1MUhcXIoYYY6FGwsy5EWFsxYBRervqHtBJog2SoNUa/6BFGr zX+LDjK9L3xMTr3+fHIt4gPR/Lt4nnfEzL+rjClz/Fazmv38BRwPuKahFwADBQgA nD/AvZCnbWSB6khAVMqva5ROaD0gV0/UejCelZdYfgfHeCmrcMNQ+wCyww2NPsih 9vB1w+AUE0pdH37k65VZN+2falUdzN+PFugJGuH2pmlVOprH2SuC5gKpGRvzUqV5 U0nJmT2okDpW/52asUDJJLu1g//A3qBP83WGvSKUZg/ZisZA0qTiHH4QpjklopXi sSxR2hT8Fr9gF9WmDa09wbxE2xh/EL7gvVg/vk0gwOJcsFd67bNC+KUMOnjhOP0T K0/Ah4TEEs/hHNe9RsyyWlMoIUsF8AhG71ISOrJ5lLSXNe151XEb5FzZRM8sD9Zq 0E3PjmLbdVhanYvsPnWK6YhJBBgRAgAJBQJDo06VAhsMAAoJEEFVdrqnbgvtXTwA njMu9ueCFbsjme7nwsz96PdazJcHAKCce17hGI25QNXDZyHohrjha6IxDg== =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nLas versiones 0.6.1.31 hasta 0.7.5 fueron firmadas por Complication. Su clave pública es: \u0026mdash;\u0026ndash;BEGIN PGP SIGNED MESSAGE\u0026mdash;\u0026ndash; Hash: SHA1\nHola,\nCertifico que a continuación se encuentra mi nueva clave pública, emitida el 24-11-2007, válida hasta el 23-11-2009, y su huella digital es:\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\nSi tienes mi antigua clave pública y la usas para verificar esto, notarás que mi antigua clave expiró el 2007-11-15. Disculpas por el retraso con esta actualización.\nPara las personas que quieran copiar la clave directamente desde este mensaje, pero no están leyendo esto usando un programa de correo electrónico, por favor recuerden eliminar las secuencias de escape \u0026ldquo;- \u0026quot; del marcador de inicio y fin del bloque de clave pública. De lo contrario, no será reconocida.\nComplicación.\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\nmQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK - \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\niD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"Claves PGP utilizadas para firmar los lanzamientos de I2P y dónde obtenerlas","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"Clave de Firma de Versiones","url":"/es/docs/develop/release-signing-key/"},{"categories":null,"content":"Contacto de Seguridad Para reportar vulnerabilidades de seguridad o problemas de seguridad sensibles, por favor contacta al Equipo de Seguridad de I2P en security@i2p.net Para comunicación segura, por favor utilice nuestra clave PGP a continuación.\nInformación de Clave PGP Correo electrónico: security@i2p.net ID de clave: 176E1941 Huella digital: 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 Tipo de clave: RSA 4096-bit Creada: 2025-10-19 Expira: 2030-11-19 UID: I2P Security \u0026lt;security@i2p.net\u0026gt; Clave Pública A continuación se muestra la clave pública GPG del Equipo de Seguridad de I2P: \u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nmQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"Clave pública GPG para contactar al Equipo de Seguridad de I2P","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"Clave GPG de Seguridad","url":"/es/docs/develop/security-key/"},{"categories":null,"content":"1. Descripción general Las entradas en clients.config indican al router qué aplicaciones lanzar al iniciar. Cada entrada puede ejecutarse como un cliente administrado (preferido) o como un cliente no administrado. Los clientes administrados colaboran con ClientAppManager, que:\nInstancia la aplicación y rastrea el estado del ciclo de vida para la consola del router Expone controles de inicio/detención al usuario y garantiza apagados limpios al salir del router Aloja un registro de clientes ligero y un mapeador de puertos para que las aplicaciones puedan descubrir los servicios de las demás Los clientes no administrados simplemente invocan un método main(); úselos solo para código heredado que no puede ser modernizado.\n2. Implementar un Cliente Administrado Los clientes gestionados deben implementar net.i2p.app.ClientApp (para aplicaciones de cara al usuario) o net.i2p.router.app.RouterApp (para extensiones del router). Proporcione uno de los constructores siguientes para que el gestor pueda suministrar el contexto y los argumentos de configuración:\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) El array args contiene los valores configurados en clients.config o archivos individuales en clients.config.d/. Extiende las clases auxiliares ClientApp / RouterApp cuando sea posible para heredar el cableado de ciclo de vida predeterminado.\n2.1 Lifecycle Methods Se espera que los clientes gestionados implementen:\nstartup() - realizar la inicialización y retornar prontamente. Debe llamar a manager.notify() al menos una vez para transicionar desde el estado INITIALIZED. shutdown(String[] args) - liberar recursos y detener hilos en segundo plano. Debe llamar a manager.notify() al menos una vez para cambiar el estado a STOPPING o STOPPED. getState() - informar a la consola si la aplicación está ejecutándose, iniciándose, deteniéndose o ha fallado El administrador llama a estos métodos cuando los usuarios interactúan con la consola.\n2.2 Advantages Informes de estado precisos en la consola del router Reinicios limpios sin filtración de hilos o referencias estáticas Menor huella de memoria una vez que la aplicación se detiene Registro centralizado y reporte de errores a través del contexto inyectado 3. Unmanaged Clients (Fallback Mode) Si la clase configurada no implementa una interfaz gestionada, el router la inicia invocando main(String[] args) y no puede rastrear el proceso resultante. La consola muestra información limitada y los hooks de apagado pueden no ejecutarse. Reserve este modo para scripts o utilidades puntuales que no pueden adoptar las APIs gestionadas.\n4. Client Registry Los clientes administrados y no administrados pueden registrarse a sí mismos con el gestor para que otros componentes puedan recuperar una referencia por nombre:\nmanager.register(this); El registro utiliza el valor de retorno de getName() del cliente como clave de registro. Los registros conocidos incluyen console, i2ptunnel, Jetty, outproxy y update. Recupera un cliente con ClientAppManager.getRegisteredApp(String name) para coordinar funcionalidades (por ejemplo, la consola consultando a Jetty para obtener detalles de estado).\nTenga en cuenta que el registro de clientes y el mapeador de puertos son sistemas separados. El registro de clientes permite la comunicación entre aplicaciones mediante búsqueda por nombre, mientras que el mapeador de puertos asigna nombres de servicios a combinaciones host:puerto para el descubrimiento de servicios.\n3. Clientes No Gestionados (Modo de Reserva) El mapeador de puertos ofrece un directorio simple para servicios TCP internos. Registra puertos de loopback para que los colaboradores eviten direcciones codificadas de forma fija:\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); O con especificación explícita del host:\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); Busca servicios usando PortMapper.getPort(String name) (devuelve -1 si no se encuentra) o getPort(String name, int defaultPort) (devuelve el valor predeterminado si no se encuentra). Verifica el estado de registro con isRegistered(String name) y obtén el host registrado con getActualHost(String name).\nConstantes comunes del servicio mapeador de puertos de net.i2p.util.PortMapper:\nSVC_CONSOLE - Consola del router (puerto predeterminado 7657) SVC_HTTP_PROXY - Proxy HTTP (puerto predeterminado 4444) SVC_HTTPS_PROXY - Proxy HTTPS (puerto predeterminado 4445) SVC_I2PTUNNEL - Gestor de I2PTunnel SVC_SAM - Puente SAM (puerto predeterminado 7656) SVC_SAM_SSL - Puente SAM SSL SVC_SAM_UDP - SAM UDP SVC_BOB - Puente BOB (puerto predeterminado 2827) SVC_EEPSITE - Eepsite estándar (puerto predeterminado 7658) SVC_HTTPS_EEPSITE - Eepsite HTTPS SVC_IRC - Túnel IRC (puerto predeterminado 6668) SVC_SUSIDNS - SusiDNS Nota: httpclient, httpsclient y httpbidirclient son tipos de tunnel de i2ptunnel (usados en la configuración tunnel.N.type), no constantes de servicio de mapeo de puertos.\n4. Registro de Clientes 2.1 Métodos del Ciclo de Vida A partir de la versión 0.9.42, el router admite dividir la configuración en archivos individuales dentro del directorio clients.config.d/. Cada archivo contiene propiedades para un solo cliente con todas las propiedades prefijadas con clientApp.0.:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true Este es el enfoque recomendado para nuevas instalaciones y plugins.\n2.2 Ventajas Para retrocompatibilidad, el formato tradicional utiliza numeración secuencial:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties Requerido: - main - Nombre completo de la clase que implementa ClientApp o RouterApp, o que contiene el método estático main(String[] args)\nOpcional: - name - Nombre a mostrar en la consola del router (por defecto el nombre de la clase) - args - Argumentos separados por espacios o tabulaciones (admite cadenas entre comillas) - delay - Segundos antes de iniciar (por defecto 120) - onBoot - Fuerza delay=0 si es verdadero - startOnLoad - Habilita/deshabilita el cliente (por defecto verdadero)\nEspecífico del plugin: - stopargs - Argumentos pasados durante el apagado - uninstallargs - Argumentos pasados durante la desinstalación del plugin - classpath - Entradas de classpath adicionales separadas por comas\nSustitución de variables para plugins: - $I2P - Directorio base de I2P - $CONFIG - Directorio de configuración del usuario (ej., ~/.i2p) - $PLUGIN - Directorio del plugin - $OS - Nombre del sistema operativo - $ARCH - Nombre de la arquitectura\n5. Mapeador de Puertos Prefiera clientes gestionados; recurra a clientes no gestionados solo cuando sea absolutamente necesario. Mantenga la inicialización y el apagado ligeros para que las operaciones de la consola permanezcan receptivas. Use nombres de registro y puerto descriptivos para que las herramientas de diagnóstico (y los usuarios finales) comprendan qué hace un servicio. Evite singletons estáticos: confíe en el contexto inyectado y el gestor para compartir recursos. Llame a manager.notify() en todas las transiciones de estado para mantener un estado preciso de la consola. Si debe ejecutarse en una JVM separada, documente cómo los registros y diagnósticos se exponen a la consola principal. Para programas externos, considere usar ShellService (añadido en la versión 1.7.0) para obtener los beneficios de un cliente gestionado. 6. Formato de Configuración Los clientes administrados se introdujeron en la versión 0.9.4 (17 de diciembre de 2012) y siguen siendo la arquitectura recomendada hasta la versión 2.10.0 (9 de septiembre de 2025). Las APIs principales se han mantenido estables sin cambios disruptivos durante este período:\nFirmas de constructor sin cambios Métodos de ciclo de vida (startup, shutdown, getState) sin cambios Métodos de registro de ClientAppManager sin cambios Métodos de registro y búsqueda de PortMapper sin cambios Mejoras notables: - 0.9.42 (2019) - estructura de directorio clients.config.d/ para archivos de configuración individuales - 1.7.0 (2021) - ShellService añadido para seguimiento del estado de programas externos - 2.10.0 (2025) - Versión actual sin cambios en la API de cliente gestionado\nLa próxima versión principal requerirá Java 17+ como mínimo (requisito de infraestructura, no un cambio en la API).\nReferences Especificación de clients.config Especificación de Archivos de Configuración Índice de Documentación Técnica de I2P Javadoc de ClientAppManager (API 0.9.66) Javadoc de PortMapper (API 0.9.66) Interfaz ClientApp (API 0.9.66) Interfaz RouterApp (API 0.9.66) Javadoc Alternativo (estable) Javadoc Alternativo (espejo clearnet) Nota: La red I2P aloja documentación completa en http://idk.i 2p/javadoc-i2p/ que requiere un router I2P para acceder. Para acceso desde clearnet, utiliza el mirror de GitHub Pages mencionado arriba.\n","description":"Cómo las aplicaciones administradas por el enrutador se integran con ClientAppManager y el mapeador de puertos","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"Clientes Gestionados","url":"/es/docs/applications/managed-clients/"},{"categories":null,"content":"La implementación principal del cliente I2P utiliza Java. Si no puedes o prefieres no usar Java en un sistema particular, existen implementaciones alternativas del cliente I2P desarrolladas y mantenidas por miembros de la comunidad. Estos programas proporcionan la misma funcionalidad principal utilizando diferentes lenguajes de programación o enfoques.\nTabla de Comparación Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements --- i2pd (C++) Sitio web: https://i2pd.website Descripción: i2pd (el I2P Daemon) es un cliente I2P completo implementado en C++. Ha sido estable para uso en producción durante muchos años (desde alrededor de 2016) y es mantenido activamente por la comunidad. i2pd implementa completamente los protocolos de red y APIs de I2P, haciéndolo completamente compatible con la red I2P de Java. Este router en C++ se utiliza frecuentemente como una alternativa ligera en sistemas donde el entorno de ejecución de Java no está disponible o no es deseado. i2pd incluye una consola web integrada para configuración y monitoreo. Es multiplataforma y está disponible en muchos formatos de empaquetado — incluso existe una versión de i2pd para Android (por ejemplo, a través de F-Droid).\nGo-I2P (Go) Repositorio: https://github.com/go-i2p/go-i2p Descripción: Go-I2P es un cliente I2P escrito en el lenguaje de programación Go. Es una implementación independiente del router I2P, que busca aprovechar la eficiencia y portabilidad de Go. El proyecto está en desarrollo activo, pero aún se encuentra en una etapa temprana y no está completo en cuanto a funcionalidades. A partir de 2025, Go-I2P se considera experimental — está siendo trabajado activamente por desarrolladores de la comunidad, pero no se recomienda para uso en producción hasta que madure más. El objetivo de Go-I2P es proporcionar un router I2P moderno y ligero con compatibilidad total con la red I2P una vez que se complete el desarrollo.\nI2P+ (fork de Java) Sitio web: https://i2pplus.github.io Descripción: I2P+ es un fork mantenido por la comunidad del cliente estándar de Java I2P. No es una reimplementación en un nuevo lenguaje, sino una versión mejorada del router de Java con características y optimizaciones adicionales. I2P+ se enfoca en ofrecer una experiencia de usuario mejorada y un mejor rendimiento, manteniendo al mismo tiempo la plena compatibilidad con la red oficial de I2P. Introduce una interfaz de consola web renovada, opciones de configuración más amigables para el usuario y varias optimizaciones (por ejemplo, rendimiento mejorado de torrents y mejor manejo de peers de red, especialmente para routers detrás de firewalls). I2P+ requiere un entorno Java al igual que el software oficial de I2P, por lo que no es una solución para entornos sin Java. Sin embargo, para usuarios que sí tienen Java y desean una compilación alternativa con capacidades adicionales, I2P+ proporciona una opción atractiva. Este fork se mantiene actualizado con los lanzamientos upstream de I2P (con su numeración de versión añadiendo un \u0026ldquo;+\u0026rdquo;) y puede obtenerse desde el sitio web del proyecto.\n","description":"Implementaciones de cliente I2P mantenidas por la comunidad (actualizado para 2025)","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"Clientes I2P Alternativos","url":"/es/docs/overview/alternative-clients/"},{"categories":null,"content":"Descripción general Esta especificación amplía el canal de suscripción de direcciones con comandos, lo que permite que los servidores de nombres difundan actualizaciones de entradas provenientes de los titulares de nombres de host. Propuesto originalmente en Proposal 112 (septiembre de 2014), implementado en la versión 0.9.26 (junio de 2016) y desplegado en toda la red con estado CERRADO.\nEl sistema se ha mantenido estable e inalterado desde su implementación inicial, y continúa operando de manera idéntica en I2P 2.10.0 (Router API 0.9.65, septiembre de 2025).\nMotivación Anteriormente, los servidores de suscripción de hosts.txt enviaban datos únicamente en un formato hosts.txt simple:\nexample.i2p=b64destination Este formato básico generó varios problemas:\nLos titulares del nombre de host no pueden actualizar el Destino asociado a sus nombres de host (por ejemplo, para actualizar la clave de firma a un tipo criptográfico más sólido). Los titulares del nombre de host no pueden ceder sus nombres de host arbitrariamente. Deben entregar directamente al nuevo titular las claves privadas del Destino correspondiente. No hay forma de autenticar que un subdominio esté controlado por el nombre de host base correspondiente. Actualmente, esto solo lo aplican individualmente algunos servidores de nombres. Diseño Esta especificación agrega líneas de comandos al formato hosts.txt. Con estos comandos, los servidores de nombres pueden ampliar sus servicios para ofrecer funciones adicionales. Los clientes que implementen esta especificación pueden escuchar estas funciones mediante el proceso de suscripción habitual.\nTodas las líneas de comandos deben estar firmadas por la Destination (identidad/dirección en I2P) correspondiente. Esto garantiza que los cambios se realicen solo a petición del titular del nombre de host.\nImplicaciones de seguridad Esta especificación no afecta el anonimato.\nAumenta el riesgo asociado a perder el control de una clave de Destino, ya que quien la obtenga puede usar estos comandos para realizar cambios en cualquier nombre de host asociado. Sin embargo, esto no es un problema mayor que el status quo, en el que quien obtenga un Destino puede suplantar un nombre de host y (parcialmente) tomar el control de su tráfico. El aumento del riesgo se compensa al dar a los titulares de nombres de host la capacidad de cambiar el Destino asociado a un nombre de host en caso de que consideren que el Destino ha sido comprometido. Esto es imposible con el sistema actual.\nEspecificación Nuevos tipos de línea Hay dos nuevos tipos de líneas:\nComandos Add y Change: example.i2p=b64destination#!key1=val1#key2=val2... Eliminar comandos: #!key1=val1#key2=val2... Ordenación Un feed no necesariamente está en orden ni es completo. Por ejemplo, un comando change puede aparecer en una línea antes de un comando add, o sin un comando add.\nLas claves pueden estar en cualquier orden. No se permiten claves duplicadas. Todas las claves y los valores distinguen entre mayúsculas y minúsculas.\nClaves comunes Obligatorio en todos los comandos:\nsig : firma en Base64, utilizando la clave de firma del destino\nReferencias a un segundo nombre de host y/o destino:\noldname : Un segundo nombre de host (nuevo o cambiado)\nolddest : Un segundo destino Base64 (nuevo o cambiado)\noldsig : Una segunda firma en Base64, utilizando la clave de firma de olddest\nOtras claves comunes:\nacción : Un comando\nname : El nombre de host, solo presente si no está precedido por example.i2p=b64dest\ndest : El destino Base64, solo presente si no está precedido por example.i2p=b64dest\ndate : En segundos desde la época\nexpires : En segundos desde la época Unix\nComandos Todos los comandos excepto el comando \u0026ldquo;Add\u0026rdquo; deben contener un par clave/valor action=command.\nPara mantener la compatibilidad con clientes antiguos, la mayoría de los comandos van precedidos por example.i2p=b64dest, como se indica a continuación. En el caso de cambios, se indican siempre los valores nuevos. Cualquier valor anterior se incluye en la sección de pares clave/valor.\nLas claves enumeradas son obligatorias. Todos los comandos pueden contener elementos adicionales de clave/valor no definidos aquí.\nAñadir nombre de host Precedido por example.i2p=b64dest : SÍ, este es el nuevo nombre de host y destino.\nacción : NO incluido, está implícito.\nsig : firma\nEjemplo:\nexample.i2p=b64dest#!sig=b64sig Cambiar el nombre de host Precedido por example.i2p=b64dest : SÍ, este es el nuevo nombre de host y el destino anterior.\nacción : changename\noldname : el nombre de host antiguo, que se reemplazará\nsig : firma\nEjemplo:\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig Cambiar destino Precedido por example.i2p=b64dest : SÍ, este es el antiguo nombre de host y el nuevo destino.\nacción : changedest\nolddest : el destino anterior, que será reemplazado\noldsig : firma usando olddest\nsig : firma\nEjemplo:\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Agregar alias de nombre de host Precedido por example.i2p=b64dest : SÍ, este es el nuevo nombre de host (alias) y el destino anterior.\nacción : addname\noldname : el nombre de host anterior\nsig : firma\nEjemplo:\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig Agregar alias de destino (Se usa para la actualización criptográfica)\nPrecedido por example.i2p=b64dest : SÍ, este es el nombre de host anterior y el nuevo destino (alternativo).\naction : adddest\nolddest : el destino anterior\noldsig : firma usando olddest\nsig : firma usando dest\nEjemplo:\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Agregar subdominio Precedido por subdomain.example.i2p=b64dest : SÍ, este es el nuevo nombre de subdominio y destino.\naction : addsubdomain\noldname : el nombre de host de nivel superior (example.i2p)\nolddest : el destino de nivel superior (por ejemplo.i2p)\noldsig : firma usando olddest\nsig : firma usando dest\nEjemplo:\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Actualizar metadatos Precedido por example.i2p=b64dest : SÍ, este es el antiguo nombre de host y destino.\nacción : actualización\nsig : firma\n(añade aquí cualquier clave actualizada)\nEjemplo:\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig Eliminar nombre de host Precedido por example.i2p=b64dest : NO, se especifican en las opciones\nacción : eliminar\nname : el nombre de host\ndest : el destino\nsig : firma\nEjemplo:\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig Eliminar todo con este destino Precedido por example.i2p=b64dest : NO, estos se especifican en las opciones\naction : removeall\ndest : el destino\nsig : firma\nEjemplo:\n#!action=removeall#dest=b64dest#sig=b64sig Firmas Todos los comandos deben estar firmados por el Destination (identificador de destino en I2P) correspondiente. Los comandos con dos Destination pueden necesitar dos firmas.\noldsig es siempre la firma \u0026ldquo;interna\u0026rdquo;. Firme y verifique sin que estén presentes las claves oldsig ni sig. sig es siempre la firma \u0026ldquo;externa\u0026rdquo;. Firme y verifique con la clave oldsig presente pero no la clave sig.\nEntrada para firmas Para generar una secuencia de bytes para crear o verificar la firma, serialice de la siguiente manera:\nElimina la clave sig Si se verifica con oldsig, elimina también la clave oldsig Solo para los comandos Add o Change, emite example.i2p=b64dest Si quedan claves, emite #! Ordena las opciones por clave UTF-8, falla si hay claves duplicadas Para cada par clave/valor, emite key=value, seguido (si no es el último par clave/valor) de un # Notas\nNo emitas un salto de línea La codificación de salida es UTF-8 Toda la codificación de destino y de firma está en Base 64 usando el alfabeto de I2P Las claves y los valores distinguen mayúsculas y minúsculas Los nombres de host deben estar en minúsculas Tipos de firma actuales A partir de la versión 2.10.0 de I2P, se admiten los siguientes tipos de firma para destinos:\nEdDSA_SHA512_Ed25519 (Tipo 7): La más común para destinos desde la 0.9.15. Usa una clave pública de 32 bytes y una firma de 64 bytes. Este es el tipo de firma recomendado para nuevos destinos. RedDSA_SHA512_Ed25519 (Tipo 13): Disponible únicamente para destinos y leasesets (conjuntos leaseSet de I2P) cifrados (desde la 0.9.39). Tipos heredados (DSA_SHA1, variantes de ECDSA): Siguen siendo compatibles, pero están obsoletos para nuevas identidades de router a partir de la 0.9.58. Nota: Las opciones criptográficas poscuánticas están disponibles a partir de I2P 2.10.0, pero aún no son los tipos de firma predeterminados.\nCompatibilidad Todas las nuevas líneas en el formato hosts.txt se implementan usando caracteres de comentario al inicio (#!), de modo que todas las versiones anteriores de I2P interpretarán los nuevos comandos como comentarios y los ignorarán sin problemas.\nCuando los routers de I2P se actualicen a la nueva especificación, no volverán a reinterpretar los comentarios antiguos, pero comenzarán a reconocer nuevos comandos en consultas posteriores de sus fuentes de suscripción. Por lo tanto, es importante que los servidores de nombres conserven las entradas de comandos de alguna manera, o habiliten la compatibilidad con ETag para que los routers puedan obtener todos los comandos anteriores.\nEstado de la implementación Despliegue inicial: Versión 0.9.26 (7 de junio de 2016)\nEstado actual: Estable y sin cambios hasta I2P 2.10.0 (Router API 0.9.65, septiembre de 2025)\nEstado de la propuesta: CERRADA (desplegada con éxito en toda la red)\nUbicación de la implementación: apps/addressbook/java/src/net/i2p/addressbook/ en el router Java de I2P\nClases clave: - SubscriptionList.java: Gestiona el procesamiento de suscripciones - Subscription.java: Gestiona fuentes de suscripción individuales - AddressBook.java: Funcionalidad central de la libreta de direcciones - Daemon.java: Servicio en segundo plano de la libreta de direcciones\nURL de suscripción predeterminada: http://i2p-projekt.i2p/hosts.txt\nDetalles del transporte Las suscripciones utilizan HTTP con soporte para GET condicional:\nEncabezado ETag: Admite una detección eficiente de cambios Encabezado Last-Modified: Realiza el seguimiento de los tiempos de actualización de la suscripción 304 Not Modified: Los servidores deberían devolver esto cuando el contenido no ha cambiado Content-Length: Altamente recomendado para todas las respuestas El I2P router utiliza el comportamiento estándar de un cliente HTTP con soporte de caché adecuado.\nContexto de la versión Nota sobre el versionado de I2P: Aproximadamente a partir de la versión 1.5.0 (agosto de 2021), I2P cambió del versionado 0.9.x al versionado semántico (1.x, 2.x, etc.). Sin embargo, la versión interna de la Router API sigue utilizando la numeración 0.9.x por compatibilidad retroactiva. En octubre de 2025, la versión actual es I2P 2.10.0 con la versión de la Router API 0.9.65.\nEste documento de especificación se redactó originalmente para la versión 0.9.49 (febrero de 2021) y sigue siendo completamente exacto para la versión actual 0.9.65 (I2P 2.10.0), porque el sistema de fuentes de suscripción no ha tenido cambios desde su implementación original en la 0.9.26.\nReferencias Propuesta 112 (Original) Especificación oficial Documentación sobre nombres de I2P Especificación de estructuras comunes Repositorio del código fuente de I2P Repositorio Gitea de I2P Desarrollos relacionados Si bien el propio sistema de fuentes de suscripción no ha cambiado, los siguientes desarrollos relacionados en la infraestructura de nombres de I2P pueden resultar de interés:\nNombres Base32 extendidos (0.9.40+): Compatibilidad con direcciones base32 de más de 56 caracteres para leaseSets cifrados. No afecta al formato del feed de suscripción. Registro de TLD .i2p.alt (RFC 9476, finales de 2023): Registro oficial en GANA de .i2p.alt como TLD alternativo. Las futuras actualizaciones del router pueden eliminar el sufijo .alt, pero no se requieren cambios en los comandos de suscripción. Criptografía poscuántica (2.10.0+): Disponible, pero no predeterminada. Se considerará en el futuro el uso de algoritmos de firma en los feeds de suscripción. ","description":"Extensión para las fuentes de suscripción de direcciones que permite a los propietarios de nombres de host actualizar y gestionar sus registros","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"Comandos de la fuente de suscripción de direcciones","url":"/es/docs/specs/subscription/"},{"categories":null,"content":"Esta guía muestra cómo configurar los navegadores más comunes para enviar tráfico a través del proxy HTTP integrado de I2P. Cubre Safari, Firefox y navegadores Chrome/Chromium con instrucciones detalladas paso a paso.\nNotas Importantes:\nEl proxy HTTP predeterminado de I2P escucha en 127.0.0.1:4444. I2P protege el tráfico dentro de la red I2P (sitios .i2p). Asegúrate de que tu router I2P esté ejecutándose antes de configurar tu navegador. Safari (macOS) Safari utiliza la configuración de proxy del sistema en macOS.\nStep 1: Open Network Settings Abre Safari y ve a Safari → Ajustes (o Preferencias) Haz clic en la pestaña Avanzado En la sección Proxies, haz clic en Cambiar ajustes\u0026hellip; Esto abrirá la Configuración de Red del Sistema de tu Mac.\nPaso 1: Abrir la Configuración de Red En la configuración de Red, marca la casilla de Proxy Web (HTTP) Introduce lo siguiente: Servidor Proxy Web: 127.0.0.1 Puerto: 4444 Haz clic en Aceptar para guardar tu configuración ¡Ahora puedes navegar por sitios .i2p en Safari!\nNota: Esta configuración de proxy afectará a todas las aplicaciones que utilicen los proxies del sistema de macOS. Considera crear una cuenta de usuario separada o usar un navegador diferente exclusivamente para I2P si deseas aislar la navegación de I2P.\nFirefox (Desktop) Firefox tiene su propia configuración de proxy independiente del sistema, lo que lo hace ideal para navegar dedicadamente en I2P.\nPaso 2: Configurar el Proxy HTTP Haz clic en el botón de menú (☰) en la esquina superior derecha Selecciona Configuración Step 2: Find Proxy Settings En el cuadro de búsqueda de Configuración, escribe \u0026ldquo;proxy\u0026rdquo; Desplázate hasta Configuración de red Haz clic en el botón Configuración\u0026hellip; Paso 1: Abrir Configuración Selecciona Configuración manual del proxy Ingresa lo siguiente: Proxy HTTP: 127.0.0.1 Puerto: 4444 Deja Host SOCKS vacío (a menos que necesites específicamente un proxy SOCKS) Marca Proxy DNS cuando se use SOCKS solo si usas proxy SOCKS Haz clic en Aceptar para guardar ¡Ahora puedes navegar por sitios .i2p en Firefox!\nConsejo: Considera crear un perfil de Firefox independiente dedicado a la navegación por I2P. Esto mantiene tu navegación I2P aislada de la navegación regular. Para crear un perfil, escribe about:profiles en la barra de direcciones de Firefox.\nChrome / Chromium (Desktop) Chrome y los navegadores basados en Chromium (Brave, Edge, etc.) normalmente utilizan la configuración de proxy del sistema en Windows y macOS. Esta guía muestra la configuración en Windows.\nPaso 2: Encontrar la Configuración del Proxy Haz clic en el menú de tres puntos (⋮) en la esquina superior derecha Selecciona Configuración Paso 3: Configurar el Proxy Manual En el cuadro de búsqueda de Configuración, escribe \u0026ldquo;proxy\u0026rdquo; Haz clic en Abrir la configuración de proxy de tu equipo Step 3: Open Manual Proxy Setup Esto abrirá la configuración de Red e Internet de Windows.\nDesplázate hacia abajo hasta Configuración manual de proxy Haz clic en Configurar Paso 1: Abrir la Configuración de Chrome Cambia Usar un servidor proxy a Activado Introduce lo siguiente: Dirección IP del proxy: 127.0.0.1 Puerto: 4444 Opcionalmente, añade excepciones en \u0026ldquo;No usar el servidor proxy para direcciones que empiecen con\u0026rdquo; (por ejemplo, localhost;127.*) Haz clic en Guardar ¡Ahora puedes navegar sitios .i2p en Chrome!\nNota: Estas configuraciones afectan a todos los navegadores basados en Chromium y algunas otras aplicaciones en Windows. Para evitar esto, considera usar Firefox con un perfil I2P dedicado en su lugar.\nPaso 2: Abrir la Configuración del Proxy En Linux, puedes iniciar Chrome/Chromium con flags de proxy para evitar cambiar la configuración del sistema:\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; O crear un script de lanzador de escritorio:\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; La bandera --user-data-dir crea un perfil de Chrome separado para la navegación en I2P.\nFirefox (Escritorio) Las compilaciones modernas de Firefox \u0026ldquo;Fenix\u0026rdquo; limitan about:config y las extensiones por defecto. IceRaven es un fork de Firefox que habilita un conjunto seleccionado de extensiones, facilitando la configuración del proxy.\nConfiguración basada en extensiones (IceRaven):\nSi ya usas IceRaven, considera borrar el historial de navegación primero (Menú → Historial → Eliminar historial). 2) Abre Menú → Complementos → Administrador de complementos. 3) Instala la extensión \u0026ldquo;I2P Proxy for Android and Other Systems\u0026rdquo;. 4) El navegador ahora se conectará a través de I2P. Esta extensión también funciona en navegadores basados en Firefox pre-Fenix si se instala desde AMO .\nHabilitar el soporte amplio de extensiones en Firefox Nightly requiere un proceso separado documentado por Mozilla .\nInternet Explorer / Windows System Proxy En Windows, el diálogo de proxy del sistema aplica a IE y puede ser utilizado por navegadores basados en Chromium cuando heredan la configuración del sistema.\nAbre \u0026ldquo;Configuración de red e Internet\u0026rdquo; → \u0026ldquo;Proxy\u0026rdquo;. 2) Activa \u0026ldquo;Usar un servidor proxy para tu LAN\u0026rdquo;. 3) Establece la dirección 127.0.0.1, puerto 4444 para HTTP. 4) Opcionalmente marca \u0026ldquo;Omitir servidor proxy para direcciones locales\u0026rdquo;. ","description":"Configurar navegadores populares para usar los proxies HTTP/HTTPS de I2P en escritorio y Android","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"Configuración del Navegador Web","url":"/es/docs/guides/browser-config/"},{"categories":null,"content":"Descripción general Este documento proporciona una especificación técnica exhaustiva de los archivos de configuración de I2P utilizados por el router y diversas aplicaciones. Cubre las especificaciones del formato de archivo, las definiciones de propiedades y los detalles de implementación verificados frente al código fuente de I2P y la documentación oficial.\nAlcance Archivos y formatos de configuración del router Configuraciones de aplicaciones cliente Configuraciones de tunnel de I2PTunnel Especificaciones del formato de archivo e implementación Características específicas de la versión y elementos en desuso Notas de implementación Los archivos de configuración se leen y se escriben utilizando los métodos DataHelper.loadProps() y storeProps() en la biblioteca central de I2P. El formato del archivo difiere significativamente del formato serializado utilizado en los protocolos de I2P (véase Especificación de estructuras comunes - asignación de tipos ).\nFormato general del archivo de configuración Los archivos de configuración de I2P siguen un formato de propiedades de Java modificado, con excepciones y restricciones específicas.\nEspecificación de formato Basado en Java Properties con las siguientes diferencias fundamentales:\nCodificación DEBE utilizar la codificación UTF-8 (NO ISO-8859-1 como en las Properties estándar de Java) Implementación: Usa las utilidades DataHelper.getUTF8() para todas las operaciones de archivo Secuencias de escape NO se reconocen secuencias de escape (incluida la barra invertida \\) La continuación de línea NO es compatible Los caracteres de barra invertida se tratan como literales Caracteres de comentario # inicia un comentario en cualquier posición de una línea ; inicia un comentario solo cuando está en la columna 1 ! NO inicia un comentario (difiere de Java Properties) Separadores de clave-valor = es el ÚNICO separador válido de clave-valor : NO se reconoce como separador El espacio en blanco NO se reconoce como separador Manejo de espacios en blanco Los espacios en blanco al principio y al final NO se eliminan de las claves Los espacios en blanco al principio y al final SÍ se eliminan de los valores Procesamiento de líneas Las líneas sin = se ignoran (se tratan como comentarios o líneas en blanco) Los valores vacíos (key=) se admiten a partir de la versión 0.9.10 Las claves con valores vacíos se almacenan y se recuperan normalmente Restricciones de caracteres Las claves NO pueden contener: - # (signo de almohadilla/numeral) - = (signo igual) - \\n (carácter de nueva línea) - No pueden comenzar con ; (punto y coma)\nLos valores NO pueden contener: - # (símbolo hash/almohadilla) - \\n (carácter de nueva línea) - No pueden empezar ni terminar con \\r (retorno de carro) - No pueden empezar ni terminar con espacios en blanco (se recortan automáticamente)\nOrdenación de archivos Los archivos de configuración no tienen por qué estar ordenados por clave. Sin embargo, la mayoría de las aplicaciones de I2P ordenan las claves alfabéticamente al escribir archivos de configuración para facilitar: - Edición manual - Operaciones de diff (comparación de cambios) del control de versiones - Legibilidad humana\nDetalles de implementación Lectura de archivos de configuración // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) Comportamiento: - Lee archivos codificados en UTF-8 - Aplica todas las reglas de formato descritas anteriormente - Valida las restricciones de caracteres - Devuelve un objeto Properties vacío si el archivo no existe - Lanza IOException por errores de lectura\nEscritura de archivos de configuración // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) Comportamiento: - Escribe archivos codificados en UTF-8 - Ordena las claves alfabéticamente (a menos que se use OrderedProperties) - Establece los permisos de archivo al modo 600 (solo lectura/escritura del usuario) a partir de la versión 0.8.1 - Lanza IllegalArgumentException por caracteres no válidos en claves o valores - Lanza IOException por errores de escritura\nValidación de formato La implementación realiza una validación estricta: - Se verifican las claves y los valores para detectar caracteres prohibidos - Las entradas inválidas provocan excepciones durante las operaciones de escritura - La lectura ignora silenciosamente las líneas con formato incorrecto (líneas sin =)\nEjemplos de formato Archivo de configuración válido # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは Ejemplos de configuraciones no válidas # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value Biblioteca central y configuración del router Configuración de clientes (clients.config) Ubicación: $I2P_CONFIG_DIR/clients.config (heredado) o $I2P_CONFIG_DIR/clients.config.d/ (moderno) Interfaz de configuración: consola del router en /configclients Cambio de formato: Versión 0.9.42 (agosto de 2019)\nEstructura de directorios (versión 0.9.42+) A partir de la versión 0.9.42, el archivo clients.config predeterminado se divide automáticamente en archivos de configuración individuales:\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) Comportamiento de migración: - En la primera ejecución tras actualizar a 0.9.42+, el archivo monolítico se divide automáticamente - Las propiedades en los archivos divididos llevan el prefijo clientApp.0. - Se sigue admitiendo el formato heredado para compatibilidad retroactiva - El formato dividido habilita el empaquetado modular y la gestión de complementos\nFormato de propiedades Las líneas tienen la forma clientApp.x.prop=val, donde x es el número de la aplicación.\nRequisitos de numeración de la aplicación: - DEBE comenzar con 0 - DEBE ser consecutiva (sin saltos) - El orden determina la secuencia de inicio\nPropiedades obligatorias principal Tipo: String (nombre de clase completamente calificado) Obligatorio: Sí Descripción: El constructor o el método main() de esta clase se invocará según el tipo de cliente (gestionado vs. no gestionado) Ejemplo: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner Propiedades opcionales nombre Tipo: Cadena Obligatorio: No Descripción: Nombre mostrado en la consola del router Ejemplo: clientApp.0.name=Router Console argumentos Tipo: Cadena (separada por espacios o tabulaciones) Obligatorio: No Descripción: Argumentos pasados al constructor de la clase principal o al método main() Entrecomillado: Los argumentos que contengan espacios o tabulaciones pueden entrecomillarse con ' o \u0026quot; Ejemplo: clientApp.0.args=-d $CONFIG/eepsite retraso Tipo: Entero (segundos) Requerido: No Predeterminado: 120 Descripción: Segundos a esperar antes de iniciar el cliente Sobrescritura: Sobrescrito por onBoot=true (establece el retardo en 0) Valores especiales: \u0026lt; 0: Esperar a que el router alcance el estado RUNNING y luego iniciar inmediatamente en un hilo nuevo = 0: Ejecutar inmediatamente en el mismo hilo (las excepciones se propagan a la consola) \u0026gt; 0: Iniciar tras el retardo en un hilo nuevo (las excepciones se registran, no se propagan) onBoot Tipo: Booleano Obligatorio: No Predeterminado: false Descripción: Fuerza un retraso de 0 y anula la configuración explícita de retraso Caso de uso: Iniciar servicios críticos de inmediato al arranque del router startOnLoad Tipo: Boolean Obligatorio: No Predeterminado: true Descripción: Indica si se debe iniciar el cliente Caso de uso: Deshabilitar clientes sin eliminar la configuración Propiedades específicas del complemento Estas propiedades solo las usan los complementos (no los clientes principales):\nstopargs Tipo: Cadena (separada por espacios o tabulaciones) Descripción: Argumentos proporcionados para detener el cliente Sustitución de variables: Sí (ver más abajo) uninstallargs Tipo: Cadena (separada por espacios o tabulaciones) Descripción: Argumentos utilizados para desinstalar el cliente Sustitución de variables: Sí (ver abajo) ruta de clases Tipo: Cadena (rutas separadas por comas) Descripción: Elementos adicionales del classpath para el cliente Sustitución de variables: Sí (ver más abajo) Sustitución de variables (solo complementos) Las siguientes variables se sustituyen en args, stopargs, uninstallargs y classpath para los plugins:\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 **Nota**: La sustitución de variables se realiza solo para los plugins, no para los clientes del núcleo. Tipos de cliente Clientes administrados El constructor se invoca con los parámetros RouterContext y ClientAppManager El cliente debe implementar la interfaz ClientApp Ciclo de vida controlado por el router Puede iniciarse, detenerse y reiniciarse dinámicamente Clientes no gestionados Se invoca el método main(String[] args) Se ejecuta en un hilo separado Ciclo de vida no gestionado por el router Tipo de cliente heredado Configuración de ejemplo # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true Configuración del registro (logger.config) Ubicación: $I2P_CONFIG_DIR/logger.config Interfaz de configuración: consola del router en /configlogging\nReferencia de propiedades Configuración del búfer de la consola logger.consoleBufferSize Tipo: Entero Predeterminado: 20 Descripción: Cantidad máxima de mensajes de registro para almacenar en búfer en la consola Rango: 1-1000 recomendado Formato de fecha y hora logger.dateFormat Tipo: String (patrón de SimpleDateFormat) Predeterminado: Según la configuración regional del sistema Ejemplo: HH:mm:ss.SSS Documentación: Java SimpleDateFormat Niveles de registro logger.defaultLevel Tipo: Enumeración Predeterminado: ERROR Valores: CRIT, ERROR, WARN, INFO, DEBUG Descripción: Nivel de registro predeterminado para todas las clases logger.minimumOnScreenLevel Tipo: Enumeración Predeterminado: CRIT Valores: CRIT, ERROR, WARN, INFO, DEBUG Descripción: Nivel mínimo para los mensajes mostrados en pantalla logger.record.{class} Tipo: Enumeración Valores: CRIT, ERROR, WARN, INFO, DEBUG Descripción: Anulación del nivel de registro por clase Ejemplo: logger.record.net.i2p.router.transport.udp=DEBUG Opciones de visualización logger.displayOnScreen Tipo: Booleano Predeterminado: true Descripción: Si se deben mostrar los mensajes de registro en la salida de consola logger.dropDuplicates Tipo: Booleano Predeterminado: true Descripción: Descartar mensajes de registro duplicados consecutivos logger.dropOnOverflow Tipo: Booleano Predeterminado: false Descripción: Descartar mensajes cuando el búfer esté lleno (en lugar de bloquear) Comportamiento de vaciado logger.flushInterval Tipo: Entero (segundos) Predeterminado: 29 Desde: Versión 0.9.18 Descripción: Con qué frecuencia volcar el búfer de registro al disco Configuración del formato logger.format Tipo: Cadena (secuencia de caracteres) Descripción: Plantilla de formato de mensaje de registro Caracteres de formato: d = fecha/hora c = nombre de la clase t = nombre del hilo p = prioridad (nivel de registro) m = mensaje Ejemplo: dctpm produce [marca de tiempo] [clase] [hilo] [nivel] mensaje Compresión (Versión 0.9.56+) logger.gzip Tipo: Booleano Predeterminado: false Desde: Versión 0.9.56 Descripción: Habilitar la compresión gzip para los archivos de registro rotados logger.minGzipSize Tipo: Entero (bytes) Valor predeterminado: 65536 Desde: Versión 0.9.56 Descripción: Tamaño mínimo de archivo para activar la compresión (64 KB por defecto) Gestión de archivos logger.logBufferSize Tipo: Entero (bytes) Predeterminado: 1024 Descripción: Número máximo de mensajes en el búfer antes de vaciarlo logger.logFileName Tipo: Cadena (ruta de archivo) Predeterminado: logs/log-@.txt Descripción: Patrón de nomenclatura del archivo de registro (@ se reemplaza con el número de rotación) logger.logFilenameOverride Tipo: Cadena (ruta de archivo) Descripción: Anulación del nombre del archivo de registro (desactiva el patrón de rotación) logger.logFileSize Tipo: Cadena (tamaño con unidad) Predeterminado: 10M Unidades: K (kilobytes), M (megabytes), G (gigabytes) Ejemplo: 50M, 1G logger.logRotationLimit Tipo: Entero Predeterminado: 2 Descripción: Número de archivo de rotación más alto (desde log-0.txt hasta log-N.txt) Ejemplo de configuración # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN Configuración de complementos Configuración individual del plugin (plugins/*/plugin.config) Ubicación: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config Formato: Formato estándar de los archivos de configuración de I2P Documentación: Especificación del plugin Propiedades obligatorias nombre Tipo: Cadena Obligatorio: Sí Descripción: Nombre visible del plugin Ejemplo: name=I2P Plugin Example clave Tipo: Cadena (clave pública) Obligatorio: Sí (omitir para plugins firmados con SU3) Descripción: Clave pública de firma del plugin para verificación Formato: Clave de firma codificada en Base64 firmante Tipo: Cadena Requerido: Sí Descripción: Identidad del firmante del plugin Ejemplo: signer=user@example.i2p versión Tipo: Cadena (formato VersionComparator, comparador de versiones) Obligatorio: Sí Descripción: Versión del complemento para la comprobación de actualizaciones Formato: versionado semántico o formato comparable personalizado Ejemplo: version=1.2.3 Propiedades de pantalla fecha Tipo: Long (Unix timestamp (marca de tiempo de Unix) en milisegundos) Descripción: Fecha de lanzamiento del plugin autor Tipo: Cadena Descripción: Nombre del autor del complemento websiteURL Tipo: Cadena (URL) Descripción: URL del sitio web del complemento updateURL Tipo: Cadena (URL) Descripción: URL de verificación de actualizaciones del complemento updateURL.su3 Tipo: Cadena (URL) Desde: Versión 0.9.15 Descripción: URL de actualización en formato SU3 (preferida) descripción Tipo: Cadena Descripción: Descripción del complemento en inglés description_{language} Tipo: Cadena Descripción: Descripción localizada del complemento Ejemplo: description_de=Deutsche Beschreibung licencia Tipo: Cadena Descripción: Identificador de la licencia del complemento Ejemplo: license=Apache 2.0 Propiedades de instalación no-iniciar-durante-la-instalación Tipo: Booleano Predeterminado: false Descripción: Impide el inicio automático después de la instalación Se requiere reiniciar el router Tipo: Booleano Predeterminado: false Descripción: Requiere reiniciar el router después de la instalación solo instalación Tipo: Boolean Predeterminado: false Descripción: Instalar solo una vez (sin actualizaciones) solo actualización Tipo: Booleano Predeterminado: false Descripción: Actualizar solo la instalación existente (sin instalación nueva) Ejemplo de configuración del complemento # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false Configuración global de plugins (plugins.config) Ubicación: $I2P_CONFIG_DIR/plugins.config Propósito: Habilitar/deshabilitar complementos instalados a nivel global\nFormato de propiedad plugin.{name}.startOnLoad=true|false {name}: Nombre del plugin según plugin.config startOnLoad: Indica si se debe iniciar el plugin al iniciar el router Ejemplo plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false Configuración de aplicaciones web (webapps.config) Ubicación: $I2P_CONFIG_DIR/webapps.config Propósito: Habilitar/deshabilitar y configurar aplicaciones web\nFormato de la propiedad webapps.{name}.startOnLoad Tipo: Booleano Descripción: Si iniciar la aplicación web al iniciar el router Formato: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath Tipo: Cadena (rutas separadas por espacios o comas) Descripción: Elementos adicionales del classpath (ruta de clases de Java) para la aplicación web Formato: webapps.{name}.classpath=[paths] Sustitución de variables Las rutas permiten las siguientes sustituciones de variables:\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps #### Resolución del Classpath (ruta de clases) Aplicaciones web del núcleo: Rutas relativas a $I2P/lib Aplicaciones web de complementos: Rutas relativas a $CONFIG/plugins/{appname}/lib Ejemplo de configuración # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar Configuración del Router (router.config) Ubicación: $I2P_CONFIG_DIR/router.config Interfaz de configuración: Consola del router en /configadvanced Propósito: Ajustes principales del router y parámetros de red\nCategorías de configuración Configuración de red Configuración de ancho de banda:\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 Configuración del transporte:\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true Comportamiento del Router # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 Configuración de la consola # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true Configuración de la hora # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org Nota: La configuración del router es extensa. Consulta la consola del router en /configadvanced para la referencia completa de propiedades.\nArchivos de configuración de aplicaciones Configuración de la libreta de direcciones (addressbook/config.txt) Ubicación: $I2P_CONFIG_DIR/addressbook/config.txt Aplicación: SusiDNS Propósito: Resolución de nombres de host y gestión de la libreta de direcciones\nUbicaciones de archivos router_addressbook Predeterminado: ../hosts.txt Descripción: Libreta de direcciones principal (nombres de host a nivel del sistema) Formato: Formato estándar del archivo hosts privatehosts.txt Ubicación: $I2P_CONFIG_DIR/addressbook/privatehosts.txt Descripción: Asignaciones de nombres de host privados Prioridad: Máxima (anula todas las demás fuentes) userhosts.txt Ubicación: $I2P_CONFIG_DIR/addressbook/userhosts.txt Descripción: Asignaciones de nombres de host añadidas por el usuario Gestión: A través de la interfaz de SusiDNS hosts.txt Ubicación: $I2P_CONFIG_DIR/addressbook/hosts.txt Descripción: Libreta de direcciones pública descargada Fuente: Fuentes de suscripción Servicio de nombres BlockfileNamingService (Predeterminado desde 0.8.8) Formato de almacenamiento: - Archivo: hostsdb.blockfile - Ubicación: $I2P_CONFIG_DIR/addressbook/ - Rendimiento: ~10x consultas más rápidas que hosts.txt - Formato: Formato de base de datos binario\nServicio de nombres heredado: - Formato: Texto plano hosts.txt - Estado: Obsoleto pero aún se admite - Caso de uso: Edición manual, control de versiones\nReglas de nombres de host Los nombres de host de I2P deben cumplir con:\nRequisito de TLD (dominio de nivel superior): Debe terminar con .i2p Longitud máxima: 67 caracteres en total Conjunto de caracteres: [a-z], [0-9], . (punto), - (guion) Mayúsculas/minúsculas: Solo minúsculas Restricciones de inicio: No puede comenzar con . o - Patrones prohibidos: No puede contener .., .- o -. (desde 0.6.1.33) Reservado: Nombres de host Base32 *.b32.i2p (52 caracteres de base32.b32.i2p) Ejemplos válidos example.i2p my-site.i2p test.example.i2p site123.i2p Ejemplos no válidos example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long Gestión de suscripciones subscriptions.txt Ubicación: $I2P_CONFIG_DIR/addressbook/subscriptions.txt Formato: Una URL por línea Predeterminado: http://i2p-projekt.i2p/hosts.txt Formato de la fuente de suscripción (Desde 0.9.26) Formato de canal avanzado con metadatos:\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 Propiedades de los metadatos: - added: Fecha en que se agregó el nombre de host (formato YYYYMMDD) - src: Identificador de origen - sig: Firma opcional\nCompatibilidad con versiones anteriores: El formato simple hostname=destination sigue siendo admitido.\nEjemplo de configuración # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false Configuración de I2PSnark (i2psnark.config.d/i2psnark.config) Ubicación: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config Aplicación: I2PSnark cliente BitTorrent Interfaz de configuración: Interfaz web en http://127.0.0.1:7657/i2psnark\nEstructura de directorios $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... Configuración principal (i2psnark.config) Configuración predeterminada mínima:\ni2psnark.dir=i2psnark Propiedades adicionales gestionadas a través de la interfaz web:\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 Configuración individual de torrent Ubicación: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config Formato: Configuración por torrent Gestión: Automática (mediante la GUI web)\nLas propiedades incluyen: - Configuración de subida/descarga específica del torrent - Prioridades de archivos - Información del rastreador - Límites de pares\nNota: La configuración de torrents se gestiona principalmente a través de la interfaz web. No se recomienda la edición manual.\nOrganización de datos de torrents El almacenamiento de datos está separado de la configuración:\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs Configuración de I2PTunnel (i2ptunnel.config) Ubicación: $I2P_CONFIG_DIR/i2ptunnel.config (legado) o $I2P_CONFIG_DIR/i2ptunnel.config.d/ (moderno) Interfaz de configuración: Consola del Router en /i2ptunnel Cambio de formato: Versión 0.9.42 (agosto de 2019)\nEstructura de directorios (Versión 0.9.42+) A partir de la versión 0.9.42, el archivo i2ptunnel.config se divide automáticamente:\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) Diferencia crítica de formato: - Formato monolítico: Propiedades con el prefijo tunnel.N. - Formato dividido: Propiedades SIN prefijo (p. ej., description=, no tunnel.0.description=)\nComportamiento de migración En la primera ejecución después de actualizar a la 0.9.42: 1. Se lee el i2ptunnel.config existente 2. Se crean configuraciones de tunnel individuales en i2ptunnel.config.d/ 3. Se eliminan los prefijos de las propiedades en los archivos divididos 4. Se realiza una copia de seguridad del archivo original 5. El formato heredado sigue siendo compatible para mantener la compatibilidad con versiones anteriores\nSecciones de configuración La configuración de I2PTunnel está documentada en detalle en la sección Referencia de configuración de I2PTunnel a continuación. Las descripciones de las propiedades son aplicables tanto al formato monolítico (tunnel.N.property) como al dividido (property).\nReferencia de configuración de I2PTunnel Esta sección proporciona una referencia técnica completa de todas las propiedades de configuración de I2PTunnel. Las propiedades se muestran en formato dividido (sin el prefijo tunnel.N.). Para el formato monolítico, antepón a todas las propiedades el prefijo tunnel.N., donde N es el número de tunnel.\nImportante: Las propiedades descritas como tunnel.N.option.i2cp.* están implementadas en I2PTunnel y NO son compatibles a través de otras interfaces como el protocolo I2CP o SAM API.\nPropiedades básicas tunnel.N.description (descripción) Tipo: Cadena Contexto: Todos los tunnels Descripción: Descripción del tunnel legible por humanos para mostrar en la interfaz de usuario Ejemplo: description=HTTP Proxy for outproxy access tunnel.N.name (nombre) Tipo: Cadena Contexto: Todos los tunnels Obligatorio: Sí Descripción: Identificador único de tunnel y nombre para mostrar Ejemplo: name=I2P HTTP Proxy tunnel.N.type (type) Tipo: Enumeración Contexto: Todos los tunnels Requerido: Sí Valores: client - Tunnel de cliente genérico httpclient - Cliente de proxy HTTP ircclient - Tunnel de cliente IRC socksirctunnel - Proxy SOCKS para IRC sockstunnel - Proxy SOCKS (versión 4, 4a, 5) connectclient - Cliente de proxy CONNECT streamrclient - Cliente de Streamr server - Tunnel de servidor genérico httpserver - Tunnel de servidor HTTP ircserver - Tunnel de servidor IRC httpbidirserver - Servidor HTTP bidireccional streamrserver - Servidor de Streamr tunnel.N.interface (interfaz) Tipo: Cadena (dirección IP o nombre de host) Contexto: Solo tunnels de cliente Predeterminado: 127.0.0.1 Descripción: Interfaz local a la que vincular para conexiones entrantes Nota de seguridad: Vincular a 0.0.0.0 permite conexiones remotas Ejemplo: interface=127.0.0.1 tunnel.N.listenPort (listenPort) Tipo: Entero Contexto: Solo para tunnels de cliente Rango: 1-65535 Descripción: Puerto local en el que escuchar para conexiones de cliente Ejemplo: listenPort=4444 tunnel.N.targetHost (targetHost) Tipo: Cadena (dirección IP o nombre de host) Contexto: Solo Server tunnels (túneles de servidor) Descripción: Servidor local al que reenviar las conexiones Ejemplo: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) Tipo: Entero Contexto: Solo para tunnels de servidor Rango: 1-65535 Descripción: Puerto en targetHost al que conectarse Ejemplo: targetPort=80 tunnel.N.targetDestination (targetDestination) Tipo: Cadena (destinos separados por comas o espacios) Contexto: Solo para tunnels de cliente Formato: destination[:port][,destination[:port]] Descripción: Destino(s) de I2P a los que conectarse Ejemplos: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) Tipo: Cadena (dirección IP o nombre de host) Predeterminado: 127.0.0.1 Descripción: Dirección de la interfaz I2CP del router I2P Nota: Se ignora cuando se ejecuta en el contexto del router Ejemplo: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) Tipo: Entero Predeterminado: 7654 Rango: 1-65535 Descripción: Puerto I2CP del router I2P Nota: Se ignora cuando se ejecuta en contexto de router Ejemplo: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) Tipo: Booleano Valor predeterminado: true Descripción: Indica si iniciar el tunnel cuando se carga I2PTunnel Ejemplo: startOnLoad=true Configuración del proxy tunnel.N.proxyList (proxyList) Tipo: Cadena (nombres de host separados por comas o espacios) Contexto: Solo proxies HTTP y SOCKS Descripción: Lista de hosts de outproxy Ejemplo: proxyList=outproxy.example.i2p,backup.example.i2p Configuración del servidor tunnel.N.privKeyFile (privKeyFile) Tipo: Cadena (ruta de archivo) Contexto: Servidores y tunnels de cliente persistentes Descripción: Archivo que contiene claves privadas de destino persistentes Ruta: Absoluta o relativa al directorio de configuración de I2P Ejemplo: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) Tipo: Cadena (nombre de host) Contexto: Solo servidores HTTP Predeterminado: Nombre de host Base32 del destino Descripción: Valor del encabezado Host enviado al servidor local Ejemplo: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) Tipo: Cadena (nombre de host) Contexto: Solo para servidores HTTP Descripción: Anulación del host virtual para un puerto de entrada específico Caso de uso: Alojar varios sitios en diferentes puertos Ejemplo: spoofedHost.8080=site1.example.i2p Opciones específicas del cliente tunnel.N.sharedClient (sharedClient) Tipo: Booleano Contexto: Solo tunnels de cliente Predeterminado: false Descripción: Si varios clientes pueden compartir este tunnel Ejemplo: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) Tipo: Booleano Contexto: Solo para Client tunnels Predeterminado: false Descripción: Almacenar y reutilizar las claves de destino entre reinicios Conflicto: Mutuamente excluyente con i2cp.newDestOnResume=true Ejemplo: option.persistentClientKey=true Opciones de I2CP (protocolo de cliente de I2P) (Implementación en I2PTunnel (herramienta de tunnel de I2P)) Importante: Estas propiedades llevan el prefijo option.i2cp. pero están implementadas en I2PTunnel, no en la capa del protocolo I2CP. No están disponibles a través de I2CP ni de las APIs de SAM.\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) Tipo: Booleano Contexto: Solo para tunnels de cliente Predeterminado: false Descripción: Retrasar la creación del tunnel hasta la primera conexión Caso de uso: Ahorrar recursos para tunnels que se usan rara vez Ejemplo: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) Tipo: Booleano Contexto: Solo para tunnels de cliente Predeterminado: false Requiere: i2cp.closeOnIdle=true Conflicto: Mutuamente excluyente con persistentClientKey=true Descripción: Crear un nuevo destino tras el tiempo de espera por inactividad Ejemplo: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) Tipo: Cadena (clave codificada en base64) Contexto: Solo tunnels de servidor Descripción: Clave de cifrado privada persistente de leaseset Caso de uso: Mantener un leaseset cifrado coherente entre reinicios Ejemplo: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) Tipo: Cadena (sigtype:base64) Contexto: Solo para tunnels de servidor Formato: sigtype:base64key Descripción: Clave privada persistente para firmar el leaseSet (conjunto de arrendamientos) Ejemplo: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... Opciones específicas del servidor tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) Tipo: Booleano Contexto: Solo tunnels de servidor Predeterminado: false Descripción: Usar una IP local única por cada destino I2P remoto Caso de uso: Rastrear direcciones IP de clientes en los registros del servidor Nota de seguridad: Puede reducir el anonimato Ejemplo: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) Tipo: Cadena (hostname:port) Contexto: Solo para tunnels de servidor Descripción: Sobrescribe targetHost/targetPort para el puerto entrante NNNN Caso de uso: Enrutamiento basado en puertos a diferentes servicios locales Ejemplo: option.targetForPort.8080=localhost:8080 Configuración del grupo de subprocesos tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) Tipo: Booleano Contexto: Solo para tunnels de servidor Predeterminado: true Descripción: Usar un grupo de subprocesos para la gestión de conexiones Nota: Siempre false para servidores estándar (se ignora) Ejemplo: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) Tipo: Entero Contexto: Solo para tunnels de servidor Predeterminado: 65 Descripción: Tamaño máximo del grupo de subprocesos Nota: Se ignora para servidores estándar Ejemplo: option.i2ptunnel.blockingHandlerCount=100 Opciones del cliente HTTP tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) Tipo: Booleano Contexto: solo clientes HTTP Predeterminado: false Descripción: Permitir conexiones SSL a direcciones .i2p Ejemplo: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) Tipo: Booleano Contexto: solo clientes HTTP Predeterminado: false Descripción: Desactivar enlaces de address helper (asistente de direcciones) en las respuestas del proxy Ejemplo: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) Tipo: Cadena (URLs separadas por comas o espacios) Contexto: Solo para clientes HTTP Descripción: URLs de servidores Jump (servidores de salto) para la resolución de nombres de host Ejemplo: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) Tipo: Booleano Contexto: Solo clientes HTTP Predeterminado: false Descripción: Reenviar encabezados Accept-* (excepto Accept y Accept-Encoding) Ejemplo: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) Tipo: Booleano Contexto: Solo clientes HTTP Predeterminado: false Descripción: Pasar encabezados Referer (cabecera HTTP de referencia) a través del proxy Nota de privacidad: Puede filtrar información Ejemplo: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) Tipo: Booleano Contexto: Solo para clientes HTTP Predeterminado: false Descripción: Reenviar encabezados User-Agent a través del proxy Nota de privacidad: Puede filtrar información del navegador Ejemplo: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) Tipo: Booleano Contexto: Solo para clientes HTTP Predeterminado: false Descripción: Pasar encabezados Via a través del proxy Ejemplo: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) Tipo: Cadena (destinos separados por comas o espacios) Contexto: Solo clientes HTTP Descripción: Outproxies (proxies de salida) SSL dentro de la red para HTTPS Ejemplo: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) Tipo: Booleano Contexto: Solo clientes HTTP Valor predeterminado: true Descripción: Usar complementos locales de outproxy (proxy de salida) registrados Ejemplo: option.i2ptunnel.useLocalOutproxy=true Autenticación del cliente HTTP tunnel.N.option.proxyAuth (option.proxyAuth) Tipo: Enum Contexto: solo clientes HTTP Predeterminado: false Valores: true, false, basic, digest Descripción: Requiere autenticación local para el acceso al proxy Nota: true es equivalente a basic Ejemplo: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) Tipo: Cadena (hexadecimal en minúsculas de 32 caracteres) Contexto: solo clientes HTTP Requiere: proxyAuth=basic o proxyAuth=digest Descripción: Hash MD5 de la contraseña del usuario USER En desuso: Utilice SHA-256 en su lugar (0.9.56+) Ejemplo: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) Tipo: Cadena (hexadecimal en minúsculas de 64 caracteres) Contexto: Solo clientes HTTP Requiere: proxyAuth=digest Desde: Versión 0.9.56 Estándar: RFC 7616 Descripción: Hash SHA-256 de la contraseña para el usuario USER Ejemplo: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 Autenticación del proxy de salida tunnel.N.option.outproxyAuth (option.outproxyAuth) Tipo: Booleano Contexto: Solo clientes HTTP Predeterminado: false Descripción: Enviar autenticación al outproxy (proxy de salida hacia Internet) Ejemplo: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) Tipo: Cadena Contexto: Solo clientes HTTP Requiere: outproxyAuth=true Descripción: Nombre de usuario para la autenticación del proxy de salida Ejemplo: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) Tipo: Cadena Contexto: Solo clientes HTTP Requiere: outproxyAuth=true Descripción: Contraseña para la autenticación de outproxy (proxy de salida) Seguridad: Almacenada en texto plano Ejemplo: option.outproxyPassword=secret Opciones del cliente SOCKS tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) Tipo: Cadena (destinos separados por comas o espacios) Contexto: Solo para clientes SOCKS Descripción: Proxies de salida dentro de la red para puertos no especificados Ejemplo: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) Tipo: Cadena (destinos separados por comas o espacios) Contexto: Solo clientes SOCKS Descripción: Proxies de salida dentro de la red específicamente para el puerto NNNN Ejemplo: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) Tipo: Enumeración Contexto: Solo para clientes SOCKS Predeterminado: socks Desde: Versión 0.9.57 Valores: socks, connect (HTTPS) Descripción: Tipo de outproxy (proxy de salida) configurado Ejemplo: option.outproxyType=connect Opciones del servidor HTTP tunnel.N.option.maxPosts (option.maxPosts) Tipo: Entero Contexto: Solo para servidores HTTP Predeterminado: 0 (sin límite) Descripción: Máximo de solicitudes POST desde un destino por cada postCheckTime Ejemplo: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) Tipo: Entero Contexto: solo servidores HTTP Predeterminado: 0 (ilimitado) Descripción: Máximo de solicitudes POST desde todos los destinos por postCheckTime Ejemplo: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) Tipo: Entero (segundos) Contexto: Solo servidores HTTP Predeterminado: 300 Descripción: Ventana de tiempo para comprobar los límites de POST Ejemplo: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) Tipo: Entero (segundos) Contexto: Solo servidores HTTP Valor predeterminado: 1800 Descripción: Duración del bloqueo tras superar maxPosts para un único destino Ejemplo: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) Tipo: Entero (segundos) Contexto: Solo servidores HTTP Predeterminado: 600 Descripción: Duración del bloqueo tras superar maxTotalPosts Ejemplo: option.postTotalBanTime=1200 Opciones de seguridad del servidor HTTP tunnel.N.option.rejectInproxy (option.rejectInproxy) Tipo: Booleano Contexto: Solo servidores HTTP Predeterminado: false Descripción: Rechaza conexiones aparentemente a través de un inproxy (puerta de entrada desde Internet a I2P) Ejemplo: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) Tipo: Booleano Contexto: solo para servidores HTTP Valor predeterminado: false Desde: Versión 0.9.25 Descripción: Rechaza las conexiones con el encabezado Referer Ejemplo: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) Tipo: booleano Contexto: solo para servidores HTTP Predeterminado: false Desde: Versión 0.9.25 Requiere: propiedad userAgentRejectList Descripción: Rechaza las conexiones cuyo User-Agent coincida Ejemplo: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) Tipo: Cadena (cadenas de coincidencia separadas por comas) Contexto: Solo para servidores HTTP Desde: Versión 0.9.25 Mayúsculas/minúsculas: Coincidencia sensible a mayúsculas y minúsculas Especial: \u0026ldquo;none\u0026rdquo; (desde 0.9.33) coincide con un User-Agent vacío Descripción: Lista de patrones de User-Agent a rechazar Ejemplo: option.userAgentRejectList=Mozilla,Opera,none Opciones del servidor IRC tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) Tipo: Cadena (patrón de nombre de host) Contexto: Solo para servidores IRC Predeterminado: %f.b32.i2p Marcadores: %f = Hash de destino base32 completo %c = Hash de destino cloaked (enmascarado) (ver cloakKey) Descripción: Formato del nombre de host enviado al servidor IRC Ejemplo: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) Tipo: Cadena (frase de contraseña) Contexto: Solo servidores IRC Predeterminado: Aleatorio por sesión Restricciones: Sin comillas ni espacios Descripción: Frase de contraseña para la ocultación consistente del nombre de host Caso de uso: Seguimiento persistente del usuario a través de reinicios/servidores Ejemplo: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) Tipo: Enum (enumeración) Contexto: Solo para servidores IRC Predeterminado: user Valores: user, webirc Descripción: Método de autenticación para el servidor IRC Ejemplo: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) Tipo: Cadena (contraseña) Contexto: solo para servidores IRC Requiere: method=webirc Restricciones: sin comillas ni espacios Descripción: Contraseña para la autenticación del protocolo WEBIRC Ejemplo: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) Tipo: Cadena (dirección IP) Contexto: Solo para servidores IRC Requiere: method=webirc Descripción: Dirección IP suplantada para el protocolo WEBIRC Ejemplo: option.ircserver.webircSpoofIP=10.0.0.1 Configuración de SSL/TLS tunnel.N.option.useSSL (option.useSSL) Tipo: Booleano Predeterminado: false Contexto: Todos los tunnels Comportamiento: Servidores: Usar SSL para conexiones al servidor local Clientes: Requerir SSL de los clientes locales Ejemplo: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) Tipo: Cadena (ruta de archivo) Contexto: Solo tunnels de cliente Predeterminado: i2ptunnel-(random).ks Ruta: Relativa a $(I2P_CONFIG_DIR)/keystore/ si no es absoluta Generado automáticamente: Se crea si no existe Descripción: Archivo de almacén de claves (keystore) que contiene la clave privada SSL Ejemplo: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) Tipo: Cadena (contraseña) Contexto: Solo para tunnels de cliente Predeterminado: changeit Generada automáticamente: Contraseña aleatoria si se crea un nuevo almacén de claves Descripción: Contraseña del almacén de claves SSL Ejemplo: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) Tipo: Cadena (alias) Contexto: Solo para tunnels de cliente Generado automáticamente: Se crea si se genera una clave nueva Descripción: Alias para la clave privada en el almacén de claves Ejemplo: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) Tipo: Cadena (contraseña) Contexto: Solo tunnels de cliente Generado automáticamente: Contraseña aleatoria si se crea una clave nueva Descripción: Contraseña de la clave privada en el almacén de claves Ejemplo: option.keyPassword=keypass123 Opciones genéricas de I2CP y de Streaming (transmisión de datos) Todas las propiedades tunnel.N.option.* (no documentadas específicamente arriba) se pasan a través de la interfaz I2CP y la biblioteca de streaming, con el prefijo tunnel.N.option. eliminado.\nImportante: Estas son independientes de las opciones específicas de I2PTunnel. Consulte: - Especificación de I2CP - Especificación de la biblioteca de Streaming Ejemplos de opciones de streaming:\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 Ejemplo completo de Tunnel # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 Historial de versiones y cronología de características Versión 0.9.10 (2013) Característica: Compatibilidad con valores vacíos en archivos de configuración - Las claves con valores vacíos (key=) ahora se admiten - Antes se ignoraban o provocaban errores de análisis\nVersión 0.9.18 (2015) Característica: Configuración del intervalo de vaciado del búfer del registro - Propiedad: logger.flushInterval (valor predeterminado: 29 segundos) - Reduce la E/S de disco manteniendo una latencia de registro aceptable\nVersión 0.9.23 (noviembre de 2015) Cambio importante: Requisito mínimo: Java 7 - Finalizó el soporte para Java 6 - Necesario para seguir recibiendo actualizaciones de seguridad\nVersión 0.9.25 (2015) Características: Opciones de seguridad del servidor HTTP - tunnel.N.option.rejectReferer - Rechazar conexiones que incluyan la cabecera Referer - tunnel.N.option.rejectUserAgents - Rechazar cabeceras User-Agent específicas - tunnel.N.option.userAgentRejectList - Patrones de User-Agent a rechazar - Caso de uso: Mitigar rastreadores y clientes no deseados\nVersión 0.9.33 (enero de 2018) Característica: Filtrado de User-Agent mejorado - el valor de cadena \u0026ldquo;none\u0026rdquo; en userAgentRejectList coincide con un User-Agent vacío - Correcciones de errores adicionales para i2psnark, i2ptunnel, streaming, SusiMail\nVersión 0.9.41 (2019) Obsolescencia: BOB Protocol (protocolo BOB de I2P) eliminado de Android - los usuarios de Android deben migrar a SAM (protocolo SAM de I2P) o I2CP\nVersión 0.9.42 (agosto de 2019) Cambio importante: Separación de archivos de configuración - clients.config dividido en una estructura de directorios clients.config.d/ - i2ptunnel.config dividido en una estructura de directorios i2ptunnel.config.d/ - Migración automática en la primera ejecución tras la actualización - Permite el empaquetado modular y la gestión de plugins - El formato monolítico heredado sigue siendo compatible\nFunciones adicionales: - Mejoras de rendimiento de SSU - Prevención de cruce entre redes (Propuesta 147) - Compatibilidad inicial con tipos de cifrado\nVersión 0.9.56 (2021) Características: Mejoras de seguridad y de registro - logger.gzip - Compresión Gzip para archivos de registro rotados (predeterminado: false) - logger.minGzipSize - Tamaño mínimo para la compresión (predeterminado: 65536 bytes) - tunnel.N.option.proxy.auth.USER.sha256 - Autenticación digest SHA-256 (RFC 7616) - Seguridad: SHA-256 reemplaza a MD5 para la autenticación digest\nVersión 0.9.57 (enero de 2023) Función: Configuración del tipo de outproxy (proxy de salida) SOCKS - tunnel.N.option.outproxyType - Selecciona el tipo de outproxy (socks|connect) - Predeterminado: socks - Compatibilidad con HTTPS CONNECT para outproxies HTTPS\nVersión 2.6.0 (julio de 2024) Cambio incompatible: I2P-over-Tor bloqueado - Ahora se rechazan las conexiones desde direcciones IP de nodos de salida de Tor - Motivo: Degrada el rendimiento de I2P, desperdicia recursos de los nodos de salida de Tor - Impacto: Se bloqueará a los usuarios que accedan a I2P a través de nodos de salida de Tor - Los relés que no son de salida y los clientes de Tor no se ven afectados\nVersión 2.10.0 (septiembre de 2025 - actualidad) Características principales: - Criptografía poscuántica disponible (activación opcional mediante Hidden Service Manager) - Compatibilidad con tracker UDP para I2PSnark para reducir la carga del tracker - Mejoras de estabilidad del Modo Oculto para reducir el agotamiento de RouterInfo - Mejoras de red para routers congestionados - Atravesamiento UPnP/NAT mejorado - Mejoras en NetDB con eliminación agresiva de leaseset - Reducciones de observabilidad para eventos del router\nConfiguración: No se han añadido nuevas propiedades de configuración\nPróximo cambio crítico: La próxima versión (probablemente 2.11.0 o 3.0.0) requerirá Java 17 o posterior\nFunciones en desuso y cambios incompatibles Obsolescencias críticas Acceso a I2P sobre Tor (Versión 2.6.0+) Estado: BLOQUEADO desde julio de 2024 Impacto: Se rechazan las conexiones procedentes de direcciones IP de nodos de salida de Tor Motivo: Degrada el rendimiento de la red I2P sin aportar beneficios de anonimato Afecta: Solo a los nodos de salida de Tor, no a los relés ni a los clientes normales de Tor Alternativa: Use I2P o Tor por separado, no combinados Autenticación por resumen MD5 Estado: Obsoleto (usar SHA-256) Propiedad: tunnel.N.option.proxy.auth.USER.md5 Motivo: MD5 roto criptográficamente Reemplazo: tunnel.N.option.proxy.auth.USER.sha256 (desde 0.9.56) Cronología: MD5 aún es compatible, pero se desaconseja Cambios en la arquitectura de configuración Archivos de configuración monolíticos (Versión 0.9.42+) Afectados: clients.config, i2ptunnel.config Estado: Obsoleto en favor de una estructura de directorios separada Migración: Automática en la primera ejecución tras la actualización a la 0.9.42 Compatibilidad: El formato heredado sigue funcionando (retrocompatible) Recomendación: Usa el formato dividido para nuevas configuraciones Requisitos de la versión de Java Compatibilidad con Java 6 Finalizado: Versión 0.9.23 (noviembre de 2015) Mínimo: Se requiere Java 7 desde la versión 0.9.23 Requisito de Java 17 (Próximamente) Estado: CAMBIO CRÍTICO INMINENTE Objetivo: Próximo lanzamiento mayor después de 2.10.0 (probablemente 2.11.0 o 3.0.0) Mínimo actual: Java 8 Acción requerida: Prepararse para la migración a Java 17 Cronograma: Se anunciará junto con las notas de la versión Características eliminadas Protocolo BOB (Basic Open Bridge, puente abierto básico) (Android) Eliminado: Versión 0.9.41 Plataforma: Solo Android Alternativa: protocolos SAM (interfaz para aplicaciones de I2P) o I2CP (protocolo de control para comunicarse con el router) Escritorio: BOB (puente básico para aplicaciones externas a I2P) sigue disponible en plataformas de escritorio Migraciones recomendadas Autenticación: Migrar de autenticación digest (por resumen) con MD5 a digest con SHA-256 Formato de configuración: Migrar a una estructura de directorios dividida para clientes y tunnels Entorno de ejecución de Java: Planificar la actualización a Java 17 antes de la próxima versión principal Integración con Tor: No enrutar I2P a través de nodos de salida de Tor Referencias Documentación oficial Especificación de configuración de I2P - Especificación oficial del formato de archivo de configuración Especificación de plugin de I2P - Configuración y empaquetado de plugins Estructuras comunes de I2P - Asignación de tipos - Formato de serialización de datos del protocolo Formato de propiedades de Java - Especificación del formato base Código fuente Repositorio del Router Java de I2P - Espejo en GitHub Gitea de los desarrolladores de I2P - Repositorio oficial del código fuente de I2P DataHelper.java - Implementación de E/S de archivos de configuración Recursos de la comunidad I2P Forum - Debates y soporte comunitarios activos I2P Website - Sitio web oficial del proyecto Documentación de la API DataHelper JavaDoc - Documentación de la API para métodos de archivos de configuración Estado de la especificación Última actualización de la especificación: enero de 2023 (Versión 0.9.57) Versión actual de I2P: 2.10.0 (septiembre de 2025) Precisión técnica: la especificación se mantiene precisa hasta la 2.10.0 (sin cambios que rompan la compatibilidad) Mantenimiento: documento vivo, se actualiza cuando se modifica el formato de configuración ","description":"Opciones y formatos de configuración para I2P routers y clientes","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"Configuración del Router","url":"/es/docs/specs/configuration/"},{"categories":null,"content":"¿Qué es un Eepsite? Un eepsite (sitio web dentro de I2P) es un sitio web que existe exclusivamente en la red I2P. A diferencia de los sitios web tradicionales accesibles a través de la clearnet (internet abierta), a los eepsites solo se puede acceder mediante I2P, lo que ofrece anonimato y privacidad tanto para el operador del sitio como para los visitantes. Eepsites utilizan el seudodominio de nivel superior .i2p y se accede a ellos a través de direcciones .b32.i2p especiales o de nombres legibles por humanos registrados en la libreta de direcciones de I2P.\nTodas las implementaciones de I2P en Java incluyen Jetty , un servidor web ligero basado en Java, preinstalado y preconfigurado. Esto hace que sea sencillo empezar a alojar tu propio eepsite en cuestión de minutos - no se requiere instalación de software adicional.\nEsta guía te llevará a través del proceso de crear y configurar tu primer eepsite utilizando las herramientas integradas de I2P.\nPaso 1: Accede al Administrador de Servicios Ocultos El Administrador de Servicios Ocultos (también llamado I2P Tunnel Manager) es donde configuras todos los tunnels de servidor y de cliente de I2P, incluidos los servidores HTTP (eepsites).\nAbre tu Consola del Router de I2P Ve al Administrador de Servicios Ocultos Deberías ver la interfaz del Administrador de Servicios Ocultos mostrando: - Mensajes de estado - Estado actual de tunnel y del cliente - Control global de tunnel - Botones para administrar todos los tunnels a la vez - Servicios ocultos de I2P - Lista de tunnels de servidor configurados\nDe forma predeterminada, verás una entrada existente de servidor web de I2P configurada pero no iniciada. Se trata del servidor web Jetty preconfigurado, listo para que lo uses.\nPaso 2: Configura los ajustes del servidor de tu Eepsite Haz clic en la entrada I2P webserver en la lista de Servicios ocultos para abrir la página de configuración del servidor. Aquí podrás personalizar los ajustes de tu eepsite (sitio web alojado en I2P).\nExplicación de las opciones de configuración Nombre - Este es un identificador interno para tu tunnel - Útil si estás ejecutando múltiples eepsites para llevar un registro de cuál es cuál - Predeterminado: \u0026ldquo;I2P webserver\u0026rdquo;\nDescripción - Una breve descripción de tu eepsite para tu propia referencia - Solo visible para ti en el Administrador de Servicios Ocultos - Ejemplo: \u0026ldquo;Mi eepsite\u0026rdquo; o \u0026ldquo;Blog personal\u0026rdquo;\nAuto Start Tunnel - Importante: Marca esta casilla para iniciar automáticamente tu eepsite cuando se inicie tu router I2P - Garantiza que tu sitio permanezca disponible sin intervención manual tras los reinicios del router - Recomendado: Activado\nDestino (Host y Puerto) - Host: La dirección local donde se está ejecutando tu servidor web (predeterminado: 127.0.0.1) - Puerto: El puerto en el que escucha tu servidor web (predeterminado: 7658 para Jetty) - Si estás usando el servidor web Jetty preinstalado, déjalos con los valores predeterminados - Solo cambia esto si estás ejecutando un servidor web personalizado en un puerto diferente\nNombre de host del sitio web - Este es el nombre de dominio .i2p legible por humanos de tu eepsite - Predeterminado: mysite.i2p (marcador de posición) - Puedes registrar un dominio personalizado como stormycloud.i2p o myblog.i2p - Déjalo en blanco si solo quieres usar la dirección .b32.i2p generada automáticamente (para outproxies (proxies de salida)) - Consulta Registrar tu dominio I2P más abajo para saber cómo reclamar un nombre de host personalizado\nDestino local - Este es el identificador criptográfico único de tu eepsite (sitio web dentro de I2P) (dirección de destino) - Se genera automáticamente cuando el tunnel se crea por primera vez - Piensa en esto como la \u0026ldquo;dirección IP\u0026rdquo; permanente de tu sitio en I2P - La cadena alfanumérica larga es la dirección .b32.i2p de tu sitio en forma codificada\nArchivo de clave privada - Ubicación donde se almacenan las claves privadas de tu eepsite - Predeterminado: eepsite/eepPriv.dat - Mantén este archivo seguro - cualquiera que tenga acceso a este archivo puede hacerse pasar por tu eepsite - Nunca compartas ni elimines este archivo\nNota importante El recuadro de advertencia amarillo te recuerda que, para habilitar las funciones de generación de códigos QR o de autenticación de registro, debes configurar un nombre de host del sitio web con un sufijo .i2p (p. ej., mynewsite.i2p).\nPaso 3: Opciones avanzadas de red (Opcional) Si te desplazas hacia abajo en la página de configuración, encontrarás opciones avanzadas de red. Estos ajustes son opcionales - los valores predeterminados funcionan bien para la mayoría de los usuarios. Sin embargo, puedes ajustarlos según tus requisitos de seguridad y necesidades de rendimiento.\nOpciones de longitud del tunnel Longitud del tunnel - Predeterminado: tunnel de 3 saltos (alto anonimato) - Controla cuántos saltos de router atraviesa una solicitud antes de llegar a tu eepsite - Más saltos = Mayor anonimato, pero rendimiento más lento - Menos saltos = Mayor rendimiento, pero menor anonimato - Las opciones van de 0-3 saltos con ajustes de variación - Recomendación: Mantén 3 saltos a menos que tengas requisitos de rendimiento específicos\nVariación de tunnel - Predeterminado: variación de 0 saltos (sin aleatorización, rendimiento consistente) - Añade aleatorización a la longitud del tunnel para mayor seguridad - Ejemplo: \u0026ldquo;variación de 0-1 saltos\u0026rdquo; significa que los tunnels serán aleatoriamente de 3 o 4 saltos - Aumenta la imprevisibilidad, pero puede provocar tiempos de carga inconsistentes\nOpciones de cantidad de Tunnel Cantidad (tunnels entrantes/salientes) - Predeterminado: 2 tunnels entrantes, 2 tunnels salientes (ancho de banda y fiabilidad estándar) - Controla cuántos tunnels paralelos se asignan a tu eepsite - Más tunnels = Mejor disponibilidad y gestión de carga, pero mayor uso de recursos - Menos tunnels = Menor uso de recursos, pero redundancia reducida - Recomendado para la mayoría de los usuarios: 2/2 (predeterminado) - Los sitios con alto tráfico pueden beneficiarse de 3/3 o más\nCantidad de tunnels de respaldo - Predeterminado: 0 tunnels de respaldo (sin redundancia, sin uso adicional de recursos) - Tunnels en espera que se activan si fallan los tunnels primarios - Aumenta la fiabilidad, pero consume más ancho de banda y CPU - La mayoría de las eepsites personales no necesitan tunnels de respaldo\nLímites de POST Si tu eepsite incluye formularios (formularios de contacto, secciones de comentarios, carga de archivos, etc.), puedes configurar límites de solicitudes POST para evitar abusos:\nLímites por cliente - Por período: Número máximo de solicitudes de un solo cliente (predeterminado: 6 cada 5 minutos) - Duración del bloqueo: Cuánto tiempo bloquear a clientes abusivos (predeterminado: 20 minutos)\nLímites totales - Total: Máximo de solicitudes POST de todos los clientes en conjunto (predeterminado: 20 cada 5 minutos) - Duración del bloqueo: Tiempo durante el cual se rechazarán todas las solicitudes POST si se supera el límite (predeterminado: 10 minutos)\nPeriodo de límite de POST - Ventana de tiempo para medir las tasas de solicitudes (por defecto: 5 minutos)\nEstos límites ayudan a proteger contra el spam, los ataques de denegación de servicio y el abuso de envíos automatizados de formularios.\nCuándo ajustar la configuración avanzada Sitio comunitario de alto tráfico: Aumentar la cantidad de tunnel (3-4 entrantes/salientes) Aplicación crítica para el rendimiento: Reducir la longitud del tunnel a 2 saltos (compromiso de privacidad) Se requiere anonimato máximo: Mantener 3 saltos, agregar una variación de 0-1 Formularios con uso legítimo elevado: Aumentar los límites de POST en consecuencia Blog/portafolio personal: Usar todos los valores predeterminados Paso 4: Añadir contenido a tu Eepsite Ahora que tu eepsite está configurado, debes añadir los archivos de tu sitio web (HTML, CSS, imágenes, etc.) al document root (directorio raíz de documentos) del servidor web. La ubicación varía según tu sistema operativo, el tipo de instalación y la implementación de I2P.\nCómo encontrar su directorio raíz de documentos La raíz del documento (a menudo llamada docroot) es la carpeta donde colocas todos los archivos de tu sitio web. Tu archivo index.html debe ir directamente en esta carpeta.\nJava I2P (Distribución estándar) Linux - Instalación estándar: ~/.i2p/eepsite/docroot/ - Instalación mediante paquete (que se ejecuta como servicio): /var/lib/i2p/i2p-config/eepsite/docroot/\nWindows - Instalación estándar: %LOCALAPPDATA%\\I2P\\eepsite\\docroot\\ - Ruta típica: C:\\Users\\YourUsername\\AppData\\Local\\I2P\\eepsite\\docroot\\ - Instalación como servicio de Windows: %PROGRAMDATA%\\I2P\\eepsite\\docroot\\ - Ruta típica: C:\\ProgramData\\I2P\\eepsite\\docroot\\\nmacOS - Instalación estándar: /Users/YourUsername/Library/Application Support/i2p/eepsite/docroot/\nI2P+ (Distribución mejorada de I2P) I2P+ utiliza la misma estructura de directorios que Java I2P. Siga las rutas indicadas arriba según su sistema operativo.\ni2pd (Implementación en C++) Linux/Unix - Predeterminado: /var/lib/i2pd/eepsite/ o ~/.i2pd/eepsite/ - Consulta tu archivo de configuración i2pd.conf para el valor real de root en el tunnel de tu servidor HTTP\nWindows - Comprueba el archivo i2pd.conf en el directorio de instalación de i2pd\nmacOS - Por lo general: ~/Library/Application Support/i2pd/eepsite/\nAñadir los archivos de tu sitio web Navega hasta la raíz del documento usando tu gestor de archivos o la terminal Crea o copia los archivos de tu sitio web en la carpeta docroot Como mínimo, crea un archivo index.html (esta es tu página de inicio) Añade CSS, JavaScript, imágenes y otros recursos según sea necesario Organiza los subdirectorios como lo harías para cualquier sitio web: docroot/ ├── index.html ├── about.html ├── css/ │ └── style.css ├── images/ │ └── logo.png └── js/ └── script.js Inicio rápido: ejemplo sencillo de HTML Si acabas de empezar, crea un archivo index.html básico en tu carpeta docroot:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My I2P Eepsite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Eepsite!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first website on the I2P network.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Privacy-focused and decentralized!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Permisos (Linux/Unix/macOS) Si ejecutas I2P como un servicio o con un usuario diferente, asegúrate de que el proceso de I2P tenga acceso de lectura a tus archivos:\n# Set appropriate ownership (if running as i2p user) sudo chown -R i2p:i2p /var/lib/i2p/i2p-config/eepsite/docroot/ # Or set readable permissions for all users chmod -R 755 ~/.i2p/eepsite/docroot/ Consejos Contenido predeterminado: Cuando instalas I2P por primera vez, ya hay contenido de ejemplo en la carpeta docroot - siéntete libre de reemplazarlo Los sitios estáticos funcionan mejor: Aunque Jetty admite servlets y JSP, los sitios sencillos en HTML/CSS/JavaScript son más fáciles de mantener Servidores web externos: Los usuarios avanzados pueden ejecutar servidores web personalizados (Apache, Nginx, Node.js, etc.) en diferentes puertos y apuntar el tunnel de I2P a ellos Paso 5: Iniciar tu eepsite Ahora que tu eepsite está configurado y tiene contenido, es hora de iniciarlo y hacerlo accesible en la red I2P.\nIniciar el Tunnel Vuelve al Administrador de Servicios Ocultos Busca la entrada de tu servidor web I2P en la lista Haz clic en el botón Iniciar en la columna Control Espere al establecimiento del Tunnel Después de hacer clic en Start, tu eepsite tunnel comenzará a construirse. Este proceso suele tardar 30-60 segundos. Observa el indicador de estado:\nLuz roja = Tunnel iniciándose/construyéndose Luz amarilla = Tunnel parcialmente establecido Luz verde = Tunnel completamente operativo y listo ¡Cuando veas la luz verde, tu eepsite estará en línea en la red de I2P!\nAccede a tu Eepsite Haz clic en el botón Preview junto a tu eepsite en ejecución. Esto abrirá una nueva pestaña del navegador con la dirección de tu eepsite.\nTu eepsite tiene dos tipos de direcciones:\nDirección Base32 (.b32.i2p): Una dirección criptográfica larga que se ve así:\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p Esta es la dirección permanente de tu eepsite (sitio web dentro de I2P), derivada criptográficamente No puede cambiarse y está vinculada a tu clave privada Funciona siempre, incluso sin registro de dominio Dominio legible por humanos (.i2p): Si configuras un nombre de host del sitio web (p. ej., testwebsite.i2p)\nSolo funciona después del registro del dominio (consulta la siguiente sección) Más fácil de recordar y compartir Se resuelve a tu dirección .b32.i2p El botón Copy Hostname te permite copiar rápidamente tu dirección .b32.i2p completa para compartirla.\n⚠️ Crítico: realiza una copia de seguridad de tu clave privada Antes de continuar, debes hacer una copia de seguridad del archivo de clave privada de tu eepsite. Esto es sumamente importante por varias razones:\n¿Por qué hacer una copia de seguridad de tu clave? Tu clave privada (eepPriv.dat) es la identidad de tu eepsite. Determina tu dirección .b32.i2p y demuestra la propiedad de tu eepsite.\nClave = dirección .b32: Tu clave privada genera matemáticamente tu dirección .b32.i2p única No se puede recuperar: Si pierdes tu clave, pierdes permanentemente la dirección de tu eepsite No se puede cambiar: Si registraste un dominio que apunta a una dirección .b32, no hay forma de actualizarlo - el registro es permanente Necesaria para la migración: Cambiar a una computadora nueva o reinstalar I2P requiere esta clave para conservar la misma dirección Multihoming support (soporte para operar desde múltiples ubicaciones): Ejecutar tu eepsite desde múltiples ubicaciones requiere la misma clave en cada servidor ¿Dónde está la clave privada? De forma predeterminada, tu clave privada se almacena en: - Linux: ~/.i2p/eepsite/eepPriv.dat (o /var/lib/i2p/i2p-config/eepsite/eepPriv.dat para instalaciones como servicio) - Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat o %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat - macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat\nTambién puedes comprobar o cambiar esta ruta en la configuración de tu tunnel, en \u0026ldquo;Archivo de clave privada\u0026rdquo;.\nCómo hacer una copia de seguridad Detén tu tunnel (opcional, pero más seguro) Copia eepPriv.dat a un lugar seguro: Unidad USB externa Unidad de copia de seguridad cifrada Archivo protegido con contraseña Almacenamiento en la nube seguro (cifrado) Mantén varias copias de seguridad en diferentes ubicaciones físicas Nunca compartas este archivo - cualquiera que lo tenga puede suplantar tu eepsite Restaurar desde copia de seguridad Para restaurar su eepsite en un sistema nuevo o después de reinstalar:\nInstala I2P y crea/configura los ajustes de tu tunnel Detén el tunnel antes de copiar la clave Copia tu eepPriv.dat de respaldo a la ubicación correcta Inicia el tunnel - usará tu dirección .b32 original Si no vas a registrar un dominio ¡Enhorabuena! Si no planeas registrar un nombre de dominio .i2p personalizado, tu eepsite (sitio web dentro de I2P) ya está completo y en funcionamiento.\nPuedes: - Compartir tu dirección .b32.i2p con otras personas - Acceder a tu sitio a través de la red I2P usando cualquier navegador compatible con I2P - Actualizar los archivos de tu sitio web en la carpeta docroot en cualquier momento - Supervisar el estado de tu tunnel en el Hidden Services Manager (Administrador de Servicios Ocultos)\nSi quieres un dominio legible para humanos (como mysite.i2p en lugar de una dirección .b32 larga), pasa a la siguiente sección.\nRegistro de su dominio de I2P Un dominio .i2p legible por humanos (como testwebsite.i2p) es mucho más fácil de recordar y compartir que una dirección .b32.i2p larga. El registro del dominio es gratuito y vincula el nombre que elijas con la dirección criptográfica de tu eepsite.\nRequisitos previos Tu eepsite (sitio web en I2P) debe estar funcionando con el indicador en verde Debes haber configurado un Nombre de host del sitio web en la configuración del tunnel (túnel de I2P) (Paso 2) Ejemplo: testwebsite.i2p o myblog.i2p Paso 1: Generar la cadena de autenticación Vuelve a la configuración de tu tunnel en el Administrador de Servicios Ocultos Haz clic en tu entrada de servidor web de I2P para abrir la configuración Desplázate hacia abajo para encontrar el botón Autenticación de registro Haz clic en Registration Authentication Copia la cadena de autenticación completa mostrada para \u0026ldquo;Authentication for adding host [yourdomainhere]\u0026rdquo; La cadena de autenticación tendrá el siguiente aspecto:\ntestwebsite.i2p=I8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1uNxFZ0HN7tQbbVj1pmbahepQZNxEW0ufwnMYAoFo8opBQAEAAcAAA==#!date=1762104890#sig=9DjEfrcNRxsoSxiE0Mp0-7rH~ktYWtgwU8c4J0eSo0VHbGxDxdiO9D1Cvwcx8hkherMO07UWOC9BWf-1wRyUAw== Esta cadena contiene: - Tu nombre de dominio (testwebsite.i2p) - Tu dirección de destino (el identificador criptográfico largo) - Una marca de tiempo - Una firma criptográfica que demuestra que posees la clave privada\nConserva esta cadena de autenticación - la necesitarás para ambos servicios de registro.\nPaso 2: Regístrate en stats.i2p Ve a stats.i2p Add Key (dentro de I2P) Pega la cadena de autenticación en el campo \u0026ldquo;Authentication String\u0026rdquo; Añade tu nombre (opcional) - de forma predeterminada es \u0026ldquo;Anonymous\u0026rdquo; Añade una descripción (recomendado) - describe brevemente de qué trata tu eepsite Ejemplo: \u0026ldquo;Nuevo I2P Eepsite\u0026rdquo;, \u0026ldquo;Blog personal\u0026rdquo;, \u0026ldquo;Servicio de intercambio de archivos\u0026rdquo; Marca \u0026ldquo;HTTP Service?\u0026rdquo; si se trata de un sitio web (déjalo marcado para la mayoría de los eepsites) Desmárcalo para IRC, NNTP, proxies, XMPP, git, etc. Haz clic en Submit Si todo sale bien, verás una confirmación de que tu dominio se ha añadido a la libreta de direcciones de stats.i2p.\nPaso 3: Regístrate en reg.i2p Para garantizar la máxima disponibilidad, también deberías registrarte en el servicio reg.i2p:\nAccede a reg.i2p Agregar dominio (dentro de I2P) Pega la misma cadena de autenticación en el campo \u0026ldquo;Auth string\u0026rdquo; Añade una descripción (opcional pero recomendable) Esto ayuda a que otros usuarios de I2P entiendan lo que ofrece tu sitio Haz clic en Submit Debería recibir una confirmación de que su dominio se ha registrado.\nPaso 4: Espera la propagación Después de enviar a ambos servicios, el registro de su dominio se propagará a través del sistema de libreta de direcciones de la red I2P.\nCronología de propagación: - Registro inicial: Inmediato en los servicios de registro - Propagación en toda la red: De varias horas a 24+ horas - Disponibilidad total: Puede tardar hasta 48 horas para que todos los routers se actualicen\n¡Esto es normal! El sistema de libreta de direcciones de I2P se actualiza periódicamente, no al instante. Tu eepsite está funcionando - otros usuarios solo necesitan recibir la libreta de direcciones actualizada.\nVerifica tu dominio Después de unas horas, puedes probar tu dominio:\nAbre una pestaña nueva en tu navegador I2P Intenta acceder a tu dominio directamente: http://yourdomainname.i2p ¡Si carga, tu dominio está registrado y propagándose! Si todavía no funciona: - Espera un poco más (las libretas de direcciones se actualizan a su propio ritmo) - La libreta de direcciones de tu router puede necesitar tiempo para sincronizarse - Intenta reiniciar tu I2P router para forzar una actualización de la libreta de direcciones\nNotas importantes El registro es permanente: Una vez registrado y propagado, tu dominio apunta permanentemente a tu dirección .b32.i2p No se puede cambiar el destino: No puedes actualizar a qué dirección .b32.i2p apunta tu dominio - por eso es fundamental hacer una copia de seguridad de eepPriv.dat Propiedad del dominio: Solo el titular de la clave privada puede registrar o actualizar el dominio Servicio gratuito: El registro de dominios en I2P es gratuito, gestionado por la comunidad y descentralizado Múltiples registradores: Registrarse tanto en stats.i2p como en reg.i2p aumenta la fiabilidad y la velocidad de propagación ¡Felicidades! ¡Tu eepsite de I2P ya está completamente operativo con un dominio registrado!\nPróximos pasos: - Agrega más contenido a tu carpeta docroot - Comparte tu dominio con la comunidad de I2P - Mantén a salvo tu copia de seguridad de eepPriv.dat - Supervisa regularmente el estado de tu tunnel - Considera unirte a los foros de I2P o a IRC para promocionar tu sitio\n¡Bienvenido a la red I2P! 🎉\n","description":"Aprende cómo crear y alojar tu propio sitio web en la red I2P usando el servidor web Jetty integrado","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"Creación de un I2P Eepsite","url":"/es/docs/guides/creaci%C3%B3n-de-un-i2p-eepsite/"},{"categories":null,"content":"Un túnel SSH proporciona una conexión segura y cifrada para acceder a la consola de tu router I2P remoto u otros servicios. Esta guía te muestra cómo crear túneles SSH en sistemas Windows, Linux y Mac.\n¿Qué es un túnel SSH? Un túnel SSH es un método para enrutar datos e información de manera segura a través de una conexión SSH cifrada. Piénsalo como crear una \u0026ldquo;tubería\u0026rdquo; protegida a través de internet: tus datos viajan a través de este túnel cifrado, evitando que cualquiera los intercepte o los lea en el camino.\nEl tunneling SSH es particularmente útil para:\nAcceso a routers I2P remotos: Conéctate a tu consola I2P ejecutándose en un servidor remoto Conexiones seguras: Todo el tráfico está cifrado de extremo a extremo Evitar restricciones: Accede a servicios en sistemas remotos como si fueran locales Reenvío de puertos: Mapea un puerto local a un servicio remoto En el contexto de I2P, puedes usar un túnel SSH para acceder a tu consola de router I2P (típicamente en el puerto 7657) en un servidor remoto reenviándola a un puerto local en tu computadora.\nRequisitos previos Antes de crear un túnel SSH, necesitarás:\nCliente SSH: Windows: PuTTY (descarga gratuita) Linux/Mac: Cliente SSH integrado (vía Terminal) Acceso al servidor remoto: Nombre de usuario para el servidor remoto Dirección IP o nombre de host del servidor remoto Contraseña SSH o autenticación basada en clave Puerto local disponible: Elija un puerto sin usar entre 1-65535 (7657 es comúnmente usado para I2P) Entendiendo el Comando Tunnel El comando del túnel SSH sigue este patrón:\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] Parámetros explicados: - local_port: El puerto en tu máquina local (por ejemplo, 7657) - destination_ip: Usualmente 127.0.0.1 (localhost en el servidor remoto) - destination_port: El puerto del servicio en el servidor remoto (por ejemplo, 7657 para I2P) - username: Tu nombre de usuario en el servidor remoto - remote_server: Dirección IP o nombre de host del servidor remoto\nEjemplo: ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\nEsto crea un túnel donde: - El puerto local 7657 en tu máquina reenvía a\u0026hellip; - El puerto 7657 en el localhost del servidor remoto (donde I2P está ejecutándose) - Conectando como usuario i2p al servidor 20.228.143.58\nCreación de túneles SSH en Windows Los usuarios de Windows pueden crear túneles SSH usando PuTTY, un cliente SSH gratuito.\nStep 1: Download and Install PuTTY Descarga PuTTY desde putty.org e instálalo en tu sistema Windows.\nStep 2: Configure the SSH Connection Abre PuTTY y configura tu conexión:\nEn la categoría Session: Ingresa la dirección IP o nombre de host de tu servidor remoto en el campo Host Name Asegúrate de que Port esté configurado en 22 (puerto SSH predeterminado) El tipo de conexión debe ser SSH Step 3: Configure the Tunnel Navega a Connection → SSH → Tunnels en la barra lateral izquierda:\nPuerto de origen: Ingresa el puerto local que deseas usar (ej., 7657) Destino: Ingresa 127.0.0.1:7657 (localhost:puerto en el servidor remoto) Haz clic en Agregar para añadir el túnel El túnel debería aparecer en la lista \u0026ldquo;Puertos reenviados\u0026rdquo; Step 4: Connect Haz clic en Abrir para iniciar la conexión Si es la primera vez que te conectas, verás una alerta de seguridad - haz clic en Sí para confiar en el servidor Ingresa tu nombre de usuario cuando se te solicite Ingresa tu contraseña cuando se te solicite Una vez conectado, puedes acceder a tu consola I2P remota abriendo un navegador y navegando a http://127.0.0.1:7657\nPaso 1: Descargar e Instalar PuTTY Para evitar reconfigurar cada vez:\nRegresa a la categoría Session Introduce un nombre en Saved Sessions (por ejemplo, \u0026ldquo;I2P Tunnel\u0026rdquo;) Haz clic en Save La próxima vez, simplemente carga esta sesión y haz clic en Open Creating SSH Tunnels on Linux Los sistemas Linux tienen SSH integrado en el terminal, lo que hace que la creación de túneles sea rápida y sencilla.\nPaso 2: Configurar la Conexión SSH Abre una terminal y ejecuta el comando del túnel SSH:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Reemplazar: - 7657 (primera ocurrencia): Tu puerto local deseado - 127.0.0.1:7657: La dirección de destino y puerto en el servidor remoto - i2p: Tu nombre de usuario en el servidor remoto - 20.228.143.58: La dirección IP de tu servidor remoto\nCuando se te solicite, ingresa tu contraseña. Una vez conectado, el túnel estará activo.\nAccede a tu consola I2P remota en http://127.0.0.1:7657 en tu navegador.\nPaso 3: Configurar el Túnel El túnel permanece activo mientras la sesión SSH esté en ejecución. Para mantenerlo ejecutándose en segundo plano:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Banderas adicionales: - -f: Ejecuta SSH en segundo plano - -N: No ejecutar comandos remotos (solo túnel)\nPara cerrar un túnel en segundo plano, encuentra y termina el proceso SSH:\nps aux | grep ssh kill [process_id] Paso 4: Conectar Para mayor seguridad y comodidad, utilice autenticación por clave SSH:\nGenera un par de claves SSH (si no tienes uno):\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Copia tu clave pública al servidor remoto:\nssh-copy-id i2p@20.228.143.58 Ahora puedes conectarte sin contraseña:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac Los sistemas Mac utilizan el mismo cliente SSH que Linux, por lo que el proceso es idéntico.\nOpcional: Guardar tu sesión Abre Terminal (Aplicaciones → Utilidades → Terminal) y ejecuta:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Reemplazar: - 7657 (primera aparición): El puerto local que desees - 127.0.0.1:7657: La dirección de destino y puerto en el servidor remoto - i2p: Tu nombre de usuario en el servidor remoto - 20.228.143.58: La dirección IP de tu servidor remoto\nIngresa tu contraseña cuando se te solicite. Una vez conectado, accede a tu consola remota de I2P en http://127.0.0.1:7657\nBackground Tunnels on Mac Al igual que en Linux, puedes ejecutar el túnel en segundo plano:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Usar la Terminal La configuración de claves SSH en Mac es idéntica a la de Linux:\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases Manteniendo el Túnel Activo El caso de uso más común - acceder a la consola de tu router I2P remoto:\nssh -L 7657:127.0.0.1:7657 user@remote-server Luego abre http://127.0.0.1:7657 en tu navegador.\nUsar Claves SSH (Recomendado) Reenviar múltiples puertos a la vez:\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server Esto reenvía tanto el puerto 7657 (consola I2P) como el 7658 (otro servicio).\nCustom Local Port Usa un puerto local diferente si el 7657 ya está en uso:\nssh -L 8080:127.0.0.1:7657 user@remote-server Accede a la consola de I2P en http://127.0.0.1:8080 en su lugar.\nTroubleshooting Usando la Terminal Error: \u0026ldquo;bind: Address already in use\u0026rdquo;\nSolución: Elija un puerto local diferente o finalice el proceso que está usando ese puerto:\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] Túneles en Segundo Plano en Mac Error: \u0026ldquo;Connection refused\u0026rdquo; o \u0026ldquo;channel 2: open failed\u0026rdquo;\nPosibles causas: - El servicio remoto no está en ejecución (verifica que el router I2P esté ejecutándose en el servidor remoto) - Firewall bloqueando la conexión - Puerto de destino incorrecto\nSolución: Verifica que el router I2P esté funcionando en el servidor remoto:\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; Configuración de Clave SSH en Mac Error: \u0026ldquo;Permiso denegado\u0026rdquo; o \u0026ldquo;Autenticación fallida\u0026rdquo;\nPosibles causas: - Nombre de usuario o contraseña incorrectos - Clave SSH no configurada correctamente - Acceso SSH deshabilitado en el servidor remoto\nSolución: Verifique las credenciales y asegúrese de que el acceso SSH esté habilitado en el servidor remoto.\nTunnel Drops Connection Error: La conexión se interrumpe después de un período de inactividad\nSolución: Agrega configuraciones de keep-alive a tu configuración de SSH (~/.ssh/config):\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices Use claves SSH: Más seguras que las contraseñas, más difíciles de comprometer Deshabilite la autenticación por contraseña: Una vez configuradas las claves SSH, deshabilite el inicio de sesión por contraseña en el servidor Use contraseñas fuertes: Si utiliza autenticación por contraseña, use una contraseña fuerte y única Limite el acceso SSH: Configure reglas de firewall para limitar el acceso SSH a IPs de confianza Mantenga SSH actualizado: Actualice regularmente el software de su cliente y servidor SSH Monitoree los registros: Revise los registros SSH en el servidor en busca de actividad sospechosa Use puertos SSH no estándar: Cambie el puerto SSH predeterminado (22) para reducir ataques automatizados Creación de túneles SSH en Linux Accediendo a la Consola I2P Crea un script para establecer túneles automáticamente:\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; Hazlo ejecutable:\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh Múltiples Túneles Crea un servicio systemd para la creación automática de túneles:\nsudo nano /etc/systemd/system/i2p-tunnel.service Añadir:\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target Habilitar e iniciar:\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling Puerto Local Personalizado Crear un proxy SOCKS para reenvío dinámico:\nssh -D 8080 user@remote-server Configura tu navegador para usar 127.0.0.1:8080 como proxy SOCKS5.\nReverse Tunneling Permite que el servidor remoto acceda a servicios en tu máquina local:\nssh -R 7657:127.0.0.1:7657 user@remote-server Puerto Ya en Uso Túnel a través de un servidor intermedio:\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion El túnel SSH es una herramienta poderosa para acceder de forma segura a routers I2P remotos y otros servicios. Ya sea que uses Windows, Linux o Mac, el proceso es sencillo y proporciona un cifrado robusto para tus conexiones.\nPara obtener ayuda adicional o realizar preguntas, visita la comunidad de I2P: - Foro: i2pforum.net - IRC: #i2p en varias redes - Documentación: Documentación de I2P Guía creada originalmente por Stormy Cloud , adaptada para la documentación de I2P.\n","description":"Aprende cómo crear túneles SSH seguros en Windows, Linux y Mac para acceder a tu router I2P remoto","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"Creación de un túnel SSH para acceder a I2P de forma remota","url":"/es/docs/guides/creaci%C3%B3n-de-un-t%C3%BAnel-ssh-para-acceder-a-i2p-de-forma-remota/"},{"categories":null,"content":"Los hosts de reseed son infraestructura crucial para la red I2P, proporcionando a los routers nuevos un grupo inicial de nodos durante el proceso de arranque. Esta guía te guiará a través de la configuración y ejecución de tu propio servidor reseed.\n¿Qué es un servidor de Reseed de I2P? Un servidor de reseed de I2P ayuda a integrar nuevos routers en la red I2P mediante:\nProporcionar descubrimiento inicial de pares: Los nuevos routers reciben un conjunto inicial de nodos de red a los que conectarse Recuperación de arranque: Ayudar a los routers que tienen dificultades para mantener conexiones Distribución segura: El proceso de reseeding está cifrado y firmado digitalmente para garantizar la seguridad de la red Cuando un router I2P nuevo se inicia por primera vez (o ha perdido todas sus conexiones con peers), contacta servidores reseed para descargar un conjunto inicial de información de routers. Esto permite que el nuevo router comience a construir su propia base de datos de red y establecer túneles.\nPrerrequisitos Antes de comenzar, necesitarás:\nUn servidor Linux (se recomienda Debian/Ubuntu) con acceso root Un nombre de dominio apuntando a tu servidor Al menos 1GB de RAM y 10GB de espacio en disco Un router I2P en ejecución en el servidor para poblar la netDb Familiaridad básica con la administración de sistemas Linux Preparando el Servidor Step 1: Update System and Install Dependencies Primero, actualiza tu sistema e instala los paquetes requeridos:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y Esto instala: - golang-go: Runtime del lenguaje de programación Go - git: Sistema de control de versiones - make: Herramienta de automatización de compilación - docker.io \u0026amp; docker-compose: Plataforma de contenedores para ejecutar Nginx Proxy Manager\nStep 2: Clone and Build Reseed Tools Clona el repositorio de reseed-tools y compila la aplicación:\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install El paquete reseed-tools proporciona la funcionalidad principal para ejecutar un servidor reseed. Se encarga de: - Recopilar información del router de tu base de datos de red local - Empaquetar la información del router en archivos SU3 firmados - Servir estos archivos a través de HTTPS\nStep 3: Generate SSL Certificate Genera el certificado SSL y la clave privada de tu servidor reseed:\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Parámetros importantes: - --signer: Tu dirección de correo electrónico (reemplaza admin@stormycloud.org con la tuya) - --netdb: Ruta a la base de datos de red (netDb) de tu router I2P - --port: Puerto interno (se recomienda 8443) - --ip: Enlazar a localhost (usaremos un proxy inverso para el acceso público) - --trustProxy: Confiar en las cabeceras X-Forwarded-For del proxy inverso\nEl comando generará: - Una clave privada para firmar archivos SU3 - Un certificado SSL para conexiones HTTPS seguras\nPaso 1: Actualizar el Sistema e Instalar Dependencias Crítico: Haz una copia de seguridad de forma segura de las claves generadas ubicadas en /home/i2p/.reseed/:\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ Almacene esta copia de seguridad en una ubicación segura y encriptada con acceso limitado. Estas claves son esenciales para el funcionamiento de su servidor reseed y deben protegerse cuidadosamente.\nConfiguring the Service Paso 2: Clonar y Compilar las Herramientas de Reseed Crea un servicio systemd para ejecutar el servidor reseed automáticamente:\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF Recuerda reemplazar admin@stormycloud.org con tu propia dirección de correo electrónico.\nAhora habilita e inicia el servicio:\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed Verifica que el servicio esté en ejecución:\nsudo systemctl status reseed Paso 3: Generar el Certificado SSL Para un rendimiento óptimo, es posible que desees reiniciar el servicio de reseed periódicamente para actualizar la información del router:\nsudo crontab -e Añade esta línea para reiniciar el servicio cada 3 horas:\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy El servidor de reseed se ejecuta en localhost:8443 y necesita un proxy inverso para manejar el tráfico HTTPS público. Recomendamos Nginx Proxy Manager por su facilidad de uso.\nPaso 4: Haz una copia de seguridad de tus claves Desplegar Nginx Proxy Manager usando Docker:\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest Esto expone: - Puerto 80: Tráfico HTTP - Puerto 81: Interfaz de administración - Puerto 443: Tráfico HTTPS\nConfigure Proxy Manager Accede a la interfaz de administración en http://your-server-ip:81\nIniciar sesión con las credenciales predeterminadas:\nCorreo electrónico: admin@example.com Contraseña: changeme Importante: ¡Cambia estas credenciales inmediatamente después del primer inicio de sesión!\nNavega a Proxy Hosts y haz clic en Add Proxy Host Configura el host del proxy: Nombre de Dominio: Tu dominio de reseed (por ejemplo, reseed.example.com) Esquema: https Hostname / IP de Reenvío: 127.0.0.1 Puerto de Reenvío: 8443 Habilita Cache Assets Habilita Block Common Exploits Habilita Websockets Support En la pestaña SSL: Selecciona Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) Habilita Force SSL Habilita HTTP/2 Support Acepta los Términos de Servicio de Let\u0026rsquo;s Encrypt Haz clic en Guardar Tu servidor reseed ahora debería estar accesible en https://reseed.example.com\nRegistering Your Reseed Server Una vez que tu servidor de reseed esté operativo, contacta a los desarrolladores de I2P para que sea añadido a la lista oficial de servidores de reseed.\nPaso 5: Crear el Servicio Systemd Envía un correo electrónico a zzz (desarrollador principal de I2P) con la siguiente información:\nCorreo electrónico I2P: zzz@mail.i2p Correo electrónico Clearnet: zzz@i2pmail.org Paso 6: Opcional - Configurar Reinicios Periódicos Incluye en tu correo electrónico:\nURL del servidor reseed: La URL HTTPS completa (p. ej., https://reseed.example.com) Certificado público reseed: Ubicado en /home/i2p/.reseed/ (adjuntar el archivo .crt) Correo electrónico de contacto: Tu método de contacto preferido para notificaciones de mantenimiento del servidor Ubicación del servidor: Opcional pero útil (país/región) Tiempo de actividad esperado: Tu compromiso para mantener el servidor Verification Los desarrolladores de I2P verificarán que tu servidor de reseed: - Esté configurado correctamente y sirviendo información de router - Use certificados SSL válidos - Proporcione archivos SU3 correctamente firmados - Sea accesible y responda adecuadamente\nUna vez aprobado, tu servidor de reseed será agregado a la lista distribuida con los routers I2P, ¡ayudando a los nuevos usuarios a unirse a la red!\nMonitoring and Maintenance Instalar Nginx Proxy Manager Monitorea tu servicio de reseed:\nsudo systemctl status reseed sudo journalctl -u reseed -f Configurar el Administrador de Proxy Mantén un control de los recursos del sistema:\nhtop df -h Update Reseed Tools Actualiza periódicamente las reseed-tools para obtener las últimas mejoras:\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed Información de Contacto Si usas Let\u0026rsquo;s Encrypt a través de Nginx Proxy Manager, los certificados se renovarán automáticamente. Verifica que la renovación esté funcionando:\ndocker logs nginx-proxy-manager | grep -i certificate Configurando el Servicio Información Requerida Verifica los logs en busca de errores:\nsudo journalctl -u reseed -n 50 Problemas comunes: - El router I2P no está ejecutándose o la netDb está vacía - El puerto 8443 ya está en uso - Problemas de permisos con el directorio /home/i2p/.reseed/\nVerificación Asegúrate de que tu router I2P esté en ejecución y haya poblado su base de datos de red:\nls -lh /home/i2p/.i2p/netDb/ Deberías ver muchos archivos .dat. Si está vacío, espera a que tu router I2P descubra peers.\nSSL Certificate Errors Verifica que tus certificados sean válidos:\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com Verificar el Estado del Servicio Verificar: - Los registros DNS están apuntando correctamente a tu servidor - El firewall permite los puertos 80 y 443 - Nginx Proxy Manager está en ejecución: docker ps\nSecurity Considerations Mantén tus claves privadas seguras: Nunca compartas ni expongas el contenido de /home/i2p/.reseed/ Actualizaciones regulares: Mantén actualizados los paquetes del sistema, Docker y reseed-tools Monitorea los logs: Busca patrones de acceso sospechosos Limitación de velocidad: Considera implementar limitación de velocidad para prevenir abusos Reglas de firewall: Solo expone los puertos necesarios (80, 443, 81 para administración) Interfaz de administración: Restringe la interfaz de administración de Nginx Proxy Manager (puerto 81) a IPs de confianza Contributing to the Network Al ejecutar un servidor reseed, estás proporcionando infraestructura crítica para la red I2P. ¡Gracias por contribuir a una internet más privada y descentralizada!\nPara preguntas o asistencia, contacta con la comunidad I2P: - Foro: i2pforum.net - IRC/Reddit: #i2p en varias redes - Desarrollo: i2pgit.org I\u0026rsquo;m ready to translate. However, I notice that no text was provided after the \u0026ldquo;\u0026mdash;\u0026rdquo; marker in your message. Could you please share the English text you\u0026rsquo;d like me to translate to Spanish?\nGuía creada originalmente por Stormy Cloud , adaptada para la documentación de I2P.\n","description":"Guía completa para configurar y operar un servidor de reseed de I2P para ayudar a los nuevos routers a unirse a la red","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"Creación y Ejecución de un Servidor de Reseed de I2P","url":"/es/docs/guides/creaci%C3%B3n-y-ejecuci%C3%B3n-de-un-servidor-de-reseed-de-i2p/"},{"categories":null,"content":" Estado: Esta página resume la antigua «Low-level Cryptography Specification» (especificación de criptografía de bajo nivel). Las versiones modernas de I2P (2.10.0, octubre de 2025) han completado la migración a nuevas primitivas criptográficas. Utilice especificaciones especializadas como ECIES , LeaseSets cifrados , NTCP2 , Red25519 , SSU2 , y Tunnel Creation (ECIES) para detalles de implementación.\nInstantánea de la evolución Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) ## Cifrado asimétrico X25519 (intercambio de claves de curva elíptica basado en Curve25519) Se utiliza para NTCP2, ECIES-X25519-AEAD-Ratchet, SSU2 y la creación de tunnel basada en X25519. Proporciona claves compactas, operaciones en tiempo constante y secreto hacia adelante mediante el Noise protocol framework (marco del protocolo Noise). Ofrece seguridad de 128 bits con claves de 32 bytes e intercambio de claves eficiente. ElGamal (heredado) Se mantiene por compatibilidad retroactiva con routers más antiguos. Opera sobre el primo de 2048 bits del Grupo 14 de Oakley (RFC 3526) con generador 2. Cifra las claves de sesión AES más los vectores de inicialización (IV) en textos cifrados de 514 bytes. Carece de cifrado autenticado y de secreto hacia adelante; todos los extremos modernos han migrado a ECIES. Cifrado simétrico ChaCha20/Poly1305 (modo AEAD que combina el cifrado de flujo ChaCha20 con el MAC Poly1305) Primitiva de cifrado autenticado predeterminada en NTCP2, SSU2 y ECIES. Proporciona seguridad AEAD y alto rendimiento sin soporte de hardware para AES. Implementada según la RFC 7539 (clave de 256 bits, nonce (número único de uso) de 96 bits, etiqueta de 128 bits). AES‑256/CBC (heredado) Sigue utilizándose para el cifrado de la capa de tunnel, donde su estructura de cifrado de bloque encaja con el modelo de cifrado por capas de I2P. Utiliza relleno PKCS#5 y transformaciones de IV (vector de inicialización) por salto. Programado para una revisión a largo plazo, pero sigue siendo criptográficamente sólido. Firmas Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer ## Derivación de hash y de claves SHA‑256: Se usa para claves DHT, HKDF y firmas antiguas. SHA‑512: Utilizado por EdDSA/RedDSA y en derivaciones HKDF de Noise. HKDF‑SHA256: Deriva claves de sesión en ECIES, NTCP2 y SSU2. Las derivaciones SHA‑256 con rotación diaria protegen las ubicaciones de almacenamiento de RouterInfo y LeaseSet en la netDb. Resumen de la capa de transporte Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) Ambos transportes proporcionan secreto hacia adelante a nivel de enlace y protección contra ataques de repetición, utilizando el patrón de handshake Noise_XK. Cifrado de la capa de Tunnel Sigue utilizando AES‑256/CBC para el cifrado en capas por salto. Las puertas de enlace de salida realizan descifrado AES iterativo; cada salto vuelve a cifrar usando su clave de capa y su clave de IV (vector de inicialización). El cifrado con IV doble mitiga ataques de correlación y de confirmación. La migración a AEAD (cifrado autenticado con datos asociados) está en estudio, pero no está prevista actualmente. Criptografía poscuántica I2P 2.10.0 introduce cifrado poscuántico híbrido experimental. Se habilita manualmente a través de Hidden Service Manager (administrador de servicios ocultos) para pruebas. Combina X25519 con un KEM (mecanismo de encapsulación de claves) resistente a ataques cuánticos (modo híbrido). No está habilitado por defecto; destinado a la investigación y la evaluación del rendimiento. Marco de extensibilidad Los identificadores de tipo de cifrado y firma permiten admitir en paralelo múltiples primitivas. Las asignaciones actuales incluyen: Tipos de cifrado: 0 = ElGamal/AES+SessionTags, 4 = ECIES‑X25519‑AEAD‑Ratchet. Tipos de firma: 0 = DSA‑SHA1, 7 = EdDSA‑SHA512‑Ed25519, 11 = RedDSA‑SHA512‑Ed25519. Este marco permite actualizaciones futuras, incluyendo esquemas poscuánticos, sin dividir la red. Composición criptográfica Capa de transporte: X25519 + ChaCha20/Poly1305 (Noise framework). Capa de tunnel: Cifrado en capas AES‑256/CBC para el anonimato. De extremo a extremo: ECIES‑X25519‑AEAD‑Ratchet para confidencialidad y secreto perfecto hacia adelante. Capa de base de datos: Firmas EdDSA/RedDSA para autenticidad. Estas capas se combinan para proporcionar defensa en profundidad: incluso si una capa se ve comprometida, las demás mantienen la confidencialidad y la no vinculabilidad.\nResumen La pila criptográfica de I2P 2.10.0 se centra en:\nCurve25519 (X25519) para intercambio de claves ChaCha20/Poly1305 para cifrado simétrico EdDSA / RedDSA para firmas SHA‑256 / SHA‑512 para hashing y derivación Modos híbridos poscuánticos experimentales para compatibilidad futura Las versiones heredadas de ElGamal, AES‑CBC y DSA se mantienen por compatibilidad con versiones anteriores, pero ya no se utilizan en protocolos de transporte activos ni en rutas de cifrado.\n","description":"Resumen de las primitivas criptográficas simétricas, asimétricas y de firma utilizadas en todo I2P","id":"f5b93f818161e04d49735c3df52fcbdc","section":"docs","title":"Criptografía de bajo nivel","url":"/es/docs/specs/cryptography/"},{"categories":null,"content":"Descripción general Los datagramas proporcionan comunicación orientada a mensajes sobre I2CP y en paralelo a la biblioteca de streaming. Permiten paquetes respondibles, autenticados o sin procesar sin requerir flujos orientados a conexión. Los routers encapsulan los datagramas en mensajes I2NP y mensajes de túnel, independientemente de si NTCP2 o SSU2 transporta el tráfico.\nLa motivación principal es permitir que las aplicaciones (como trackers, resolvedores DNS o juegos) envíen paquetes autónomos que identifiquen a su remitente.\nNuevo en 2025: El Proyecto I2P aprobó Datagram2 (protocolo 19) y Datagram3 (protocolo 20), agregando protección contra replay y mensajería con respuesta de menor sobrecarga por primera vez en una década.\n1. Constantes del Protocolo Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) Los protocolos 19 y 20 se formalizaron en la **Propuesta 163 (abril de 2025)**. Coexisten con Datagram1 / RAW para mantener la compatibilidad con versiones anteriores. 2. Tipos de Datagramas Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. ### Patrones de Diseño Típicos Solicitud → Respuesta: Enviar un Datagram2 firmado (solicitud + nonce), recibir una respuesta raw o Datagram3 (eco del nonce). Alta frecuencia/baja sobrecarga: Preferir Datagram3 o RAW. Mensajes de control autenticados: Datagram2. Compatibilidad con versiones anteriores: Datagram1 aún completamente soportado. 3. Detalles de Datagram2 y Datagram3 (2025) Datagram2 (Protocolo 19) Reemplazo mejorado para Datagram1. Características: - Prevención de repetición: token anti-repetición de 4 bytes. - Soporte de firma offline: permite el uso por Destinations firmados offline. - Cobertura de firma ampliada: incluye hash de destino, flags, opciones, bloque de firma offline, payload. - Preparado para post-cuántico: compatible con futuros híbridos ML-KEM. - Overhead: ≈ 457 bytes (claves X25519).\nDatagram3 (Protocolo 20) Cierra la brecha entre tipos raw y firmados. Características: - Replicable sin firma: contiene hash de 32 bytes del remitente + flags de 2 bytes. - Sobrecarga mínima: ≈ 34 bytes. - Sin defensa contra replay — la aplicación debe implementarla.\nAmbos protocolos son características de la API 0.9.66 e implementados en el router Java desde la versión 2.9.0; aún no hay implementaciones en i2pd o Go (octubre de 2025).\n4. Límites de Tamaño y Fragmentación Tamaño del mensaje de tunnel: 1 028 bytes (4 B Tunnel ID + 16 B IV + 1 008 B payload). Fragmento inicial: 956 B (entrega TUNNEL típica). Fragmento de continuación: 996 B. Fragmentos máximos: 63–64. Límite práctico: ≈ 62 708 B (~61 KB). Límite recomendado: ≤ 10 KB para entrega confiable (las pérdidas aumentan exponencialmente más allá de este valor). Resumen de sobrecarga: - Datagram1 ≈ 427 B (mínimo). - Datagram2 ≈ 457 B. - Datagram3 ≈ 34 B. - Capas adicionales (encabezado gzip I2CP, I2NP, Garlic, Tunnel): + ~5.5 KB en el peor caso.\n5. Integración I2CP / I2NP Ruta del mensaje: 1. La aplicación crea un datagrama (vía API I2P o SAM). 2. I2CP lo envuelve con encabezado gzip (0x1F 0x8B 0x08, RFC 1952) y suma de verificación CRC-32. 3. Números de Protocolo + Puerto se almacenan en campos del encabezado gzip. 4. El router encapsula como mensaje I2NP → clove Garlic → fragmentos de tunnel de 1 KB. 5. Los fragmentos atraviesan tunnel de salida → red → tunnel de entrada. 6. El datagrama reensamblado se entrega al manejador de aplicación según el número de protocolo.\nIntegridad: CRC-32 (desde I2CP) + firma criptográfica opcional (Datagram1/2). No hay un campo de suma de verificación separado dentro del datagrama en sí.\n6. Interfaces de Programación API de Java El paquete net.i2p.client.datagram incluye: - I2PDatagramMaker – construye datagramas firmados. - I2PDatagramDissector – verifica y extrae información del remitente. - I2PInvalidDatagramException – se lanza cuando falla la verificación.\nI2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl) gestiona la multiplexación de protocolo y puerto para aplicaciones que comparten un Destination.\nAcceso a Javadoc: - idk.i2p Javadoc (solo red I2P) - Espejo de Javadoc (espejo en clearnet) - Javadocs oficiales (documentación oficial)\nSoporte para SAM v3 SAM 3.2 (2016): agregó los parámetros PORT y PROTOCOL. SAM 3.3 (2016): introdujo el modelo PRIMARY/subsession; permite streams + datagramas en un Destination. Soporte para estilos de sesión Datagram2 / 3 agregado a la especificación en 2025 (implementación pendiente). Especificación oficial: Especificación SAM v3 Módulos de i2ptunnel udpTunnel: Base completamente funcional para aplicaciones I2P UDP (net.i2p.i2ptunnel.udpTunnel). streamr: Operativo para transmisión A/V (net.i2p.i2ptunnel.streamr). SOCKS UDP: No funcional a partir de 2.10.0 (solo stub UDP). Para UDP de propósito general, utilice la API Datagram o udpTunnel directamente—no dependa de SOCKS UDP.\n7. Ecosistema y Soporte de Idiomas (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental Java I2P es el único router que admite subsesiones completas de SAM 3.3 y la API Datagram2 en este momento. 8. Ejemplo de Uso – Rastreador UDP (I2PSnark 2.10.0) Primera aplicación real de Datagram2/3:\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return El patrón demuestra el uso mixto de datagramas autenticados y ligeros para equilibrar seguridad y rendimiento. 9. Seguridad y Mejores Prácticas Usa Datagram2 para cualquier intercambio autenticado o cuando los ataques de repetición importen. Prefiere Datagram3 para respuestas rápidas replicables con confianza moderada. Usa RAW para transmisiones públicas o datos anónimos. Mantén las cargas útiles ≤ 10 KB para una entrega confiable. Ten en cuenta que SOCKS UDP permanece no funcional. Siempre verifica el CRC de gzip y las firmas digitales al recibir. 10. Especificación Técnica Esta sección cubre los formatos de datagramas de bajo nivel, la encapsulación y los detalles del protocolo.\n10.1 Identificación de Protocolo Los formatos de datagrama no comparten un encabezado común. Los routers no pueden inferir el tipo solo a partir de los bytes de carga útil.\nAl mezclar múltiples tipos de datagramas, o al combinar datagramas con streaming, configure explícitamente: - El número de protocolo (vía I2CP o SAM) - Opcionalmente el número de puerto, si su aplicación multiplexa servicios\nDejar el protocolo sin configurar (0 o PROTO_ANY) no es recomendable y puede provocar errores de enrutamiento o entrega.\n10.2 Datagramas sin procesar Los datagramas no respondibles no llevan datos del remitente ni de autenticación. Son cargas útiles opacas, manejadas fuera de la API de datagramas de nivel superior pero soportadas a través de SAM e I2PTunnel.\nProtocolo: 18 (PROTO_DATAGRAM_RAW)\nFormato:\n+----+----+----+----+----// | payload... +----+----+----+----+----// La longitud de la carga útil está limitada por los límites del transporte (≈32 KB máximo práctico, a menudo mucho menos).\n10.3 Datagram1 (Datagramas con Respuesta) Incluye el Destination del remitente y una Signature para autenticación y direccionamiento de respuestas.\nProtocolo: 17 (PROTO_DATAGRAM)\nSobrecarga: ≥427 bytes Carga útil: hasta ~31.5 KB (limitado por el transporte)\nFormato:\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from: un Destination (387+ bytes) signature: una Signature que coincide con el tipo de clave Para DSA_SHA1: Signature del hash SHA-256 de la carga útil Para otros tipos de clave: Signature directamente sobre la carga útil Notas: - Las firmas para tipos que no son DSA se estandarizaron en I2P 0.9.14. - Las firmas offline de LS2 (Propuesta 123) no están actualmente soportadas en Datagram1.\n10.4 Formato Datagram2 Un datagrama replicable mejorado que añade resistencia a reproducción según se define en Propuesta 163 .\nProtocolo: 19 (PROTO_DATAGRAM2)\nLa implementación está en curso. Las aplicaciones deben incluir verificaciones de nonce o marca de tiempo para redundancia.\n10.5 Formato Datagram3 Proporciona datagramas con capacidad de respuesta pero no autenticados. Se basa en la autenticación de sesión mantenida por el router en lugar de destino y firma embebidos.\nProtocolo: 20 (PROTO_DATAGRAM3) Estado: En desarrollo desde 0.9.66\nÚtil cuando: - Los destinos son grandes (por ejemplo, claves post-cuánticas) - La autenticación ocurre en otra capa - La eficiencia del ancho de banda es crítica\n10.6 Integridad de Datos La integridad del datagrama está protegida por el checksum gzip CRC-32 en la capa I2CP. No existe un campo de checksum explícito dentro del formato de carga útil del datagrama en sí.\n10.7 Encapsulación de Paquetes Cada datagrama se encapsula como un único mensaje I2NP o como un diente individual en un Garlic Message. Las capas I2CP, I2NP y de tunnel manejan la longitud y el encuadre — no hay delimitador interno ni campo de longitud en el protocolo de datagramas.\n10.8 Consideraciones Post-Cuánticas (PQ) Si se implementa la Propuesta 169 (firmas ML-DSA), los tamaños de firma y destino aumentarán drásticamente — de ~455 bytes a ≥3739 bytes. Este cambio incrementará sustancialmente la sobrecarga de datagramas y reducirá la capacidad efectiva de carga útil.\nDatagram3, que se basa en la autenticación a nivel de sesión (no en firmas embebidas), probablemente se convertirá en el diseño preferido en entornos I2P post-cuánticos.\n11. Referencias Propuesta 163 – Datagram2 y Datagram3 Propuesta 160 – Integración de UDP Tracker Propuesta 144 – Cálculos de MTU en Streaming Propuesta 169 – Firmas Post-Cuánticas Especificación I2CP Especificación I2NP Especificación de Mensajes de Tunnel Especificación SAMv3 Documentación de i2ptunnel 12. Aspectos Destacados del Registro de Cambios (2019 – 2025) Year Release Change 20190.9.43Datagram API stabilization 20210.9.50Protocol port handling reworked 20222.0.0SSU2 adoption completed 20242.6.0Legacy transport removal simplified UDP code 20252.9.0Datagram2/3 support added (Java API) 20252.10.0UDP Tracker implementation released --- 13. Resumen El subsistema de datagramas ahora admite cuatro variantes de protocolo que ofrecen un espectro desde transmisión completamente autenticada hasta transmisión raw ligera. Los desarrolladores deben migrar hacia Datagram2 para casos de uso sensibles a la seguridad y Datagram3 para tráfico eficiente con capacidad de respuesta. Todos los tipos antiguos permanecen compatibles para garantizar la interoperabilidad a largo plazo.\n","description":"Formatos de mensaje autenticado, respondible y sin procesar sobre I2CP","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"Datagramas","url":"/es/docs/api/datagrams/"},{"categories":null,"content":"¿Por qué escribir código específico para I2P? Existen múltiples formas de utilizar aplicaciones en I2P. Usando I2PTunnel , puedes usar aplicaciones regulares sin necesidad de programar soporte explícito para I2P. Esto es muy efectivo para escenarios cliente-servidor, donde necesitas conectarte a un único sitio web. Simplemente puedes crear un tunnel usando I2PTunnel para conectarte a ese sitio web, como se muestra en la Figura 1.\nSi tu aplicación está distribuida, requerirá conexiones a una gran cantidad de pares. Usando I2PTunnel, necesitarás crear un nuevo túnel para cada par con el que quieras contactar, como se muestra en la Figura 2. Este proceso puede, por supuesto, automatizarse, pero ejecutar muchas instancias de I2PTunnel crea una gran cantidad de sobrecarga. Además, con muchos protocolos necesitarás forzar a todos a usar el mismo conjunto de puertos para todos los pares — por ejemplo, si quieres ejecutar de manera confiable chat DCC, todos deben acordar que el puerto 10001 es Alice, el puerto 10002 es Bob, el puerto 10003 es Charlie, y así sucesivamente, ya que el protocolo incluye información específica de TCP/IP (host y puerto).\nLas aplicaciones de red generales a menudo envían una gran cantidad de datos adicionales que podrían utilizarse para identificar usuarios. Los nombres de host, números de puerto, zonas horarias, conjuntos de caracteres, etc., se envían frecuentemente sin informar al usuario. Por lo tanto, diseñar el protocolo de red específicamente con el anonimato en mente puede evitar comprometer las identidades de los usuarios.\nTambién hay consideraciones de eficiencia que revisar al determinar cómo interactuar sobre I2P. La biblioteca streaming y las cosas construidas sobre ella operan con handshakes similares a TCP, mientras que los protocolos centrales de I2P (I2NP e I2CP) son estrictamente basados en mensajes (como UDP o en algunos casos IP sin procesar). La distinción importante es que con I2P, la comunicación opera sobre una red larga y ancha (long fat network) — cada mensaje de extremo a extremo tendrá latencias no triviales, pero puede contener cargas útiles de hasta varios KB. Una aplicación que necesita una simple solicitud y respuesta puede deshacerse de cualquier estado y eliminar la latencia incurrida por los handshakes de inicio y cierre usando datagramas (mejor esfuerzo) sin tener que preocuparse por la detección de MTU o fragmentación de mensajes.\nFigure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. En resumen, varias razones para escribir código específico para I2P: Crear una gran cantidad de instancias de I2PTunnel consume una cantidad no trivial de recursos, lo cual es problemático para aplicaciones distribuidas (se requiere un nuevo tunnel para cada par). Los protocolos de red generales a menudo envían muchos datos adicionales que pueden usarse para identificar usuarios. Programar específicamente para I2P permite la creación de un protocolo de red que no filtra dicha información, manteniendo a los usuarios anónimos y seguros. Los protocolos de red diseñados para uso en internet regular pueden ser ineficientes en I2P, que es una red con una latencia mucho mayor. I2P soporta una interfaz de plugins estándar para desarrolladores, de modo que las aplicaciones puedan integrarse y distribuirse fácilmente.\nLas aplicaciones escritas en Java y accesibles/ejecutables mediante una interfaz HTML a través del estándar webapps/app.war pueden ser consideradas para su inclusión en la distribución de I2P.\nConceptos Importantes Hay algunos cambios que requieren adaptación al usar I2P:\nDestinos Una aplicación ejecutándose en I2P envía mensajes desde y recibe mensajes hacia un punto final único criptográficamente seguro — un \u0026ldquo;destination\u0026rdquo;. En términos de TCP o UDP, un destination podría (en gran medida) considerarse el equivalente a un par de nombre de host más número de puerto, aunque existen algunas diferencias.\nUn destino I2P en sí mismo es una construcción criptográfica: todos los datos enviados a uno están cifrados como si hubiera un despliegue universal de IPsec con la ubicación (anonimizada) del punto final firmada como si hubiera un despliegue universal de DNSSEC. Los destinos I2P son identificadores móviles: pueden moverse de un router I2P a otro (o incluso pueden hacer \u0026ldquo;multihome\u0026rdquo;, operar en múltiples routers a la vez). Esto es muy diferente del mundo TCP o UDP donde un único punto final (puerto) debe permanecer en un solo host. Los destinos I2P son feos y grandes: entre bastidores, contienen una clave pública ElGamal de 2048 bits para cifrado, una clave pública DSA de 1024 bits para firma, y un certificado de tamaño variable, que puede contener prueba de trabajo o datos ofuscados. Existen formas de referirse a estos destinos grandes y complejos mediante nombres cortos y amigables (por ejemplo, \u0026ldquo;irc.duck.i2p\u0026rdquo;), pero estas técnicas no garantizan la unicidad global (ya que se almacenan localmente en una base de datos en la máquina de cada persona) y el mecanismo actual no es especialmente escalable ni seguro (las actualizaciones de la lista de hosts se gestionan mediante \u0026ldquo;suscripciones\u0026rdquo; a servicios de nombres). Puede que algún día exista un sistema de nombres seguro, legible para humanos, escalable y globalmente único, pero las aplicaciones no deberían depender de que esté implementado. Hay disponible más información sobre el sistema de nombres .\nAunque la mayoría de las aplicaciones no necesitan distinguir protocolos y puertos, I2P sí los soporta. Las aplicaciones complejas pueden especificar un protocolo, puerto de origen y puerto de destino, mensaje por mensaje, para multiplexar el tráfico en un único destino. Consulta la página de datagramas para más detalles. Las aplicaciones simples operan escuchando \u0026ldquo;todos los protocolos\u0026rdquo; en \u0026ldquo;todos los puertos\u0026rdquo; de un destino.\nAnonimato y Confidencialidad I2P tiene cifrado de extremo a extremo y autenticación transparentes para todos los datos transmitidos a través de la red — si Bob envía datos al destino de Alice, solo el destino de Alice puede recibirlos, y si Bob está usando la biblioteca de datagramas o streaming, Alice tiene la certeza de que el destino de Bob es quien envió los datos.\nPor supuesto, I2P anonimiza de forma transparente los datos enviados entre Alice y Bob, pero no hace nada para anonimizar el contenido de lo que envían. Por ejemplo, si Alice envía a Bob un formulario con su nombre completo, documentos de identidad gubernamentales y números de tarjetas de crédito, no hay nada que I2P pueda hacer. Por lo tanto, los protocolos y aplicaciones deben tener en cuenta qué información están tratando de proteger y qué información están dispuestos a exponer.\nLos datagramas I2P pueden tener hasta varios KB Las aplicaciones que utilizan datagramas I2P (ya sean crudos o respondibles) pueden concebirse esencialmente en términos de UDP — los datagramas no están ordenados, son de mejor esfuerzo y sin conexión — pero a diferencia de UDP, las aplicaciones no necesitan preocuparse por la detección de MTU y pueden simplemente enviar datagramas grandes. Aunque el límite superior es nominalmente de 32 KB, el mensaje se fragmenta para el transporte, lo que reduce la fiabilidad del conjunto. Actualmente no se recomiendan datagramas de más de 10 KB aproximadamente. Consulta la página de datagramas para más detalles. Para muchas aplicaciones, 10 KB de datos son suficientes para una solicitud o respuesta completa, permitiéndoles operar de forma transparente en I2P como una aplicación similar a UDP sin tener que implementar fragmentación, reenvíos, etc.\nOpciones de Desarrollo Existen varios medios para enviar datos a través de I2P, cada uno con sus propias ventajas y desventajas. La biblioteca streaming lib es la interfaz recomendada, utilizada por la mayoría de las aplicaciones I2P.\nBiblioteca de Streaming La biblioteca completa de streaming es ahora la interfaz estándar. Permite programar usando sockets similares a TCP, como se explica en la guía de desarrollo de Streaming .\nBOB BOB es el Basic Open Bridge , que permite a una aplicación en cualquier lenguaje establecer conexiones de streaming hacia y desde I2P. En este momento carece de soporte UDP, pero el soporte UDP está planificado para un futuro cercano. BOB también contiene varias herramientas, como generación de claves de destino y verificación de que una dirección cumple con las especificaciones de I2P. Información actualizada y aplicaciones que usan BOB se pueden encontrar en este Sitio I2P .\nSAM, SAM V2, SAM V3 SAM no es recomendado. SAM V2 está bien, SAM V3 es recomendado.\nSAM es el protocolo Simple Anonymous Messaging (Mensajería Anónima Simple), que permite que una aplicación escrita en cualquier lenguaje se comunique con un puente SAM a través de un socket TCP simple y que ese puente multiplexe todo su tráfico I2P, coordinando de forma transparente el cifrado/descifrado y el manejo basado en eventos. SAM admite tres estilos de operación:\nstreams, para cuando Alice y Bob quieren enviarse datos de manera confiable y en orden repliable datagrams, para cuando Alice quiere enviar a Bob un mensaje al que Bob puede responder raw datagrams, para cuando Alice quiere aprovechar el máximo ancho de banda y rendimiento posible, y a Bob no le importa si el remitente de los datos está autenticado o no (por ejemplo, los datos transferidos se autoautentican) SAMv3 apunta al mismo objetivo que SAM y SAM V2, pero no requiere multiplexación/demultiplexación. Cada stream I2P es manejado por su propio socket entre la aplicación y el puente SAM. Además, los datagramas pueden ser enviados y recibidos por la aplicación a través de comunicaciones de datagramas con el puente SAM.\nSAM V2 es una nueva versión utilizada por imule que soluciona algunos de los problemas en SAM .\nSAM V3 es utilizado por imule desde la versión 1.4.0.\nI2PTunnel La aplicación I2PTunnel permite a las aplicaciones construir túneles específicos similares a TCP hacia pares creando aplicaciones I2PTunnel \u0026lsquo;cliente\u0026rsquo; (que escuchan en un puerto específico y se conectan a un destino I2P específico cada vez que se abre un socket hacia ese puerto) o aplicaciones I2PTunnel \u0026lsquo;servidor\u0026rsquo; (que escuchan en un destino I2P específico y cada vez que reciben una nueva conexión I2P hacen outproxy hacia un host/puerto TCP específico). Estos flujos son limpios de 8 bits, y están autenticados y asegurados mediante la misma biblioteca de streaming que usa SAM, pero existe una sobrecarga no trivial involucrada al crear múltiples instancias únicas de I2PTunnel, ya que cada una tiene su propio destino I2P único y su propio conjunto de túneles, claves, etc.\nSOCKS I2P admite un proxy SOCKS V4 y V5. Las conexiones salientes funcionan bien. La funcionalidad entrante (servidor) y UDP puede estar incompleta y sin probar.\nMinistreaming Eliminado\nSolía haber una biblioteca simple de \u0026ldquo;ministreaming\u0026rdquo;, pero ahora ministreaming.jar contiene solo las interfaces para la biblioteca de streaming completa.\nDatagramas Recomendado para aplicaciones tipo UDP\nLa biblioteca Datagram permite enviar paquetes tipo UDP. Es posible usar:\nDatagramas replicables Datagramas sin procesar I2CP No recomendado\nI2CP en sí es un protocolo independiente del lenguaje, pero para implementar una biblioteca I2CP en algo que no sea Java hay una cantidad significativa de código que escribir (rutinas de cifrado, serialización de objetos, manejo de mensajes asíncronos, etc.). Si bien alguien podría escribir una biblioteca I2CP en C o en algún otro lenguaje, probablemente sería más útil usar la biblioteca SAM de C en su lugar.\nAplicaciones Web I2P viene con el servidor web Jetty, y configurarlo para usar el servidor Apache en su lugar es sencillo. Cualquier tecnología de aplicación web estándar debería funcionar.\nComenzar a Desarrollar — Una Guía Simple Desarrollar usando I2P requiere una instalación funcional de I2P y un entorno de desarrollo de su elección. Si está usando Java, puede comenzar el desarrollo con la biblioteca streaming o la biblioteca de datagramas. Usando otro lenguaje de programación, se puede utilizar SAM o BOB.\nDesarrollo con la biblioteca de Streaming A continuación se presenta una versión recortada y modernizada del ejemplo de la página original. Para el ejemplo completo, consulte la página legacy o nuestros ejemplos de Java en el código base.\n// Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\u0026#34;Received: \u0026#34; + s); } Ejemplo de código: servidor básico recibiendo datos.\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\u0026#34;Hello I2P!\\n\u0026#34;); bw.flush(); Ejemplo de código: cliente conectándose y enviando una línea.\n","description":"Por qué escribir aplicaciones específicas para I2P, conceptos clave, opciones de desarrollo y una guía simple para comenzar","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"Desarrollo de Aplicaciones","url":"/es/docs/develop/applications/"},{"categories":null,"content":"Lee primero la Guía para Nuevos Desarrolladores .\nDirectrices Básicas y Estilo de Codificación La mayoría de lo siguiente debería ser sentido común para cualquiera que haya trabajado en código abierto o en un entorno de programación comercial. Lo siguiente se aplica principalmente a la rama de desarrollo principal i2p.i2p. Las directrices para otras ramas, plugins y aplicaciones externas pueden ser sustancialmente diferentes; consulta con el desarrollador correspondiente para obtener orientación.\nComunidad Por favor, no solo escribas código. Si puedes, participa en otras actividades de desarrollo, incluyendo: discusiones de desarrollo y soporte en IRC e i2pforum.i2p; pruebas; reporte de errores y respuestas; documentación; revisiones de código; etc. Los desarrolladores activos deben estar disponibles periódicamente en IRC #i2p-dev. Ten en cuenta el ciclo de lanzamiento actual. Adhiérete a los hitos de lanzamiento como el congelamiento de características, congelamiento de etiquetas y la fecha límite de check-in para un lanzamiento. Ciclo de Lanzamiento El ciclo de lanzamiento normal es de 10 a 16 semanas, cuatro lanzamientos al año. A continuación se muestran las fechas límite aproximadas dentro de un ciclo típico de 13 semanas. Las fechas límite reales para cada lanzamiento son establecidas por el gestor de lanzamientos después de consultar con todo el equipo.\n1–2 días después del lanzamiento anterior: Se permiten check-ins en trunk. 2–3 semanas después del lanzamiento anterior: Fecha límite para propagar cambios importantes de otras ramas a trunk. 4–5 semanas antes del lanzamiento: Fecha límite para solicitar nuevos enlaces en la página de inicio. 3–4 semanas antes del lanzamiento: Congelación de funcionalidades. Fecha límite para nuevas funcionalidades importantes. 2–3 semanas antes del lanzamiento: Realizar reunión del proyecto para revisar solicitudes de nuevos enlaces en la página de inicio, si las hay. 10–14 días antes del lanzamiento: Congelación de cadenas de texto. No más cambios a cadenas traducidas (etiquetadas). Enviar cadenas a Transifex, anunciar fecha límite de traducción en Transifex. 10–14 días antes del lanzamiento: Fecha límite de funcionalidades. Solo correcciones de errores después de este momento. No más funcionalidades, refactorización o limpieza. 3–4 días antes del lanzamiento: Fecha límite de traducción. Obtener traducciones de Transifex y hacer check-in. 3–4 días antes del lanzamiento: Fecha límite de check-in. No se permiten check-ins después de este momento sin el permiso del responsable del lanzamiento. Horas antes del lanzamiento: Fecha límite de revisión de código. Git Ten una comprensión básica de los sistemas de control de fuente distribuidos, incluso si no has usado git antes. Pide ayuda si la necesitas. Una vez enviado, los check-ins son para siempre; no hay deshacer. Por favor, ten cuidado. Si no has usado git antes, comienza con pasos pequeños. Registra algunos cambios menores y observa cómo va. Prueba tus cambios antes de registrarlos. Si prefieres el modelo de desarrollo de check-in antes de probar, usa tu propia rama de desarrollo en tu propia cuenta, y crea un MR una vez que el trabajo esté terminado. No rompas el build. No causes regresiones. En caso de que lo hagas (sucede), por favor no desaparezcas por un largo período después de enviar tu cambio. Si tu cambio no es trivial, o quieres que las personas lo prueben y necesitas buenos reportes de prueba para saber si tu cambio fue probado o no, añade un comentario de check-in a history.txt e incrementa la revisión del build en RouterVersion.java. No registres cambios importantes en la rama principal de i2p.i2p al final del ciclo de lanzamiento. Si un proyecto te tomará más de un par de días, crea tu propia rama en git, en tu propia cuenta, y haz el desarrollo allí para no bloquear los lanzamientos. Para cambios grandes (en términos generales, más de 100 líneas, o que toquen más de tres archivos), regístralo en una nueva rama en tu propia cuenta de GitLab, crea un MR, y asigna un revisor. Asigna el MR a ti mismo. Fusiona el MR tú mismo una vez que el revisor lo apruebe. No crees ramas WIP en la cuenta principal de I2P_Developers (excepto para i2p.www). WIP pertenece a tu propia cuenta. Cuando el trabajo esté terminado, crea un MR. Las únicas ramas en la cuenta principal deben ser para verdaderos forks, como un lanzamiento puntual. Haz el desarrollo de manera transparente y con la comunidad en mente. Registra a menudo. Registra o fusiona en la rama principal tan frecuentemente como sea posible, dadas las pautas anteriores. Si estás trabajando en algún proyecto grande en tu propia rama/cuenta, avisa a las personas para que puedan seguirlo y revisar/probar/comentar. Estilo de Codificación El estilo de codificación en la mayor parte del código es de 4 espacios para la indentación. No uses tabulaciones. No reformatees el código. Si tu IDE o editor quiere reformatear todo, contrólalo. En algunos lugares, el estilo de codificación es diferente. Usa el sentido común. Emula el estilo en el archivo que estás modificando. Todas las clases y métodos públicos y package-private nuevos requieren Javadocs. Añade @since número-de-versión. Los Javadocs para métodos privados nuevos son deseables. Para cualquier Javadocs añadido, no debe haber errores o advertencias de doclint. Ejecuta ant javadoc con Oracle Java 14 o superior para verificar. Todos los parámetros deben tener líneas @param, todos los métodos no-void deben tener líneas @return, todas las excepciones declaradas como lanzadas deben tener líneas @throws, y sin errores HTML. Las clases en core/ (i2p.jar) y porciones de i2ptunnel son parte de nuestra API oficial. Hay varios plugins externos y otras aplicaciones que dependen de esta API. Ten cuidado de no hacer cambios que rompan la compatibilidad. No añadas métodos a la API a menos que sean de utilidad general. Los Javadocs para métodos de la API deben ser claros y completos. Si añades o cambias la API, actualiza también la documentación en el sitio web (rama i2p.www). Etiqueta cadenas para traducción donde sea apropiado, lo cual es cierto para todas las cadenas de UI. No cambies cadenas etiquetadas existentes a menos que sea realmente necesario, ya que romperá las traducciones existentes. No añadas o cambies cadenas etiquetadas después del congelamiento de etiquetas en el ciclo de lanzamiento para que los traductores tengan oportunidad de actualizar antes del lanzamiento. Usa genéricos y clases concurrentes donde sea posible. I2P es una aplicación altamente multi-hilo. Familiarízate con los errores comunes de Java que detecta FindBugs/SpotBugs. Ejecuta ant findbugs para aprender más. Se requiere Java 8 para compilar y ejecutar I2P a partir de la versión 0.9.47. No uses clases o métodos de Java 7 u 8 en subsistemas embebidos: addressbook, core, i2ptunnel.jar (no-UI), mstreaming, router, routerconsole (solo noticias), streaming. Estos subsistemas son usados por Android y aplicaciones embebidas que requieren solo Java 6. Todas las clases deben estar disponibles en Android API 14. Las características del lenguaje Java 7 son aceptables en estos subsistemas si son soportadas por la versión actual del Android SDK y compilan a código compatible con Java 6. Try-with-resources no puede usarse en subsistemas embebidos ya que requiere java.lang.AutoCloseable en tiempo de ejecución, y esto no está disponible hasta Android API 19 (KitKat 4.4). El paquete java.nio.file no puede usarse en subsistemas embebidos ya que no está disponible hasta Android API 26 (Oreo 8). Aparte de las limitaciones anteriores, las clases, métodos y construcciones de Java 8 pueden usarse solo en los siguientes subsistemas: BOB, desktopgui, i2psnark, i2ptunnel.war (UI), jetty‑i2p.jar, jsonrpc, routerconsole (excepto noticias), SAM, susidns, susimail, systray. Los autores de plugins pueden requerir cualquier versión mínima de Java mediante el archivo plugin.config. Convierte explícitamente entre tipos primitivos y clases; no dependas de autoboxing/unboxing. No uses URL. Usa URI. No captures Exception. Captura RuntimeException y excepciones verificadas individualmente. No uses String.getBytes() sin un argumento charset UTF‑8. También puedes usar DataHelper.getUTF8() o DataHelper.getASCII(). Especifica siempre un charset UTF‑8 al leer o escribir archivos. Las utilidades de DataHelper pueden ser útiles. Especifica siempre una localización (por ejemplo Locale.US) al usar String.toLowerCase() o String.toUpperCase(). No uses String.equalsIgnoreCase(), ya que no se puede especificar una localización. No uses String.split(). Usa DataHelper.split(). No añadas código para formatear fechas y horas. Usa DataHelper.formatDate() y DataHelper.formatTime(). Asegúrate de que los InputStreams y OutputStreams se cierren en bloques finally. Usa {} para todos los bloques for y while, incluso si solo tienen una línea. Si usas {} para el bloque if, else o if-else, úsalo para todos los bloques. Pon } else { en una sola línea. Especifica los campos como final donde sea posible. No almacenes I2PAppContext, RouterContext, Log, o cualquier otra referencia a router o elementos de contexto en campos estáticos. No inicies hilos en constructores. Usa I2PAppThread en lugar de Thread. Registro Las siguientes directrices se aplican al router, las aplicaciones web y todos los complementos.\nPara cualquier mensaje que no se muestre en el nivel de registro predeterminado (WARN, INFO y DEBUG), a menos que el mensaje sea una cadena estática (sin concatenación), use siempre log.shouldWarn(), log.shouldInfo() o log.shouldDebug() antes de la llamada de registro para evitar la creación innecesaria de objetos. Los mensajes de registro que puedan mostrarse en el nivel de registro predeterminado (ERROR, CRIT y logAlways()) deben ser breves, claros y comprensibles para un usuario no técnico. Esto incluye el texto de motivo de excepción que también puede mostrarse. Considere traducir si es probable que el error ocurra (por ejemplo, en errores de envío de formularios). De lo contrario, la traducción no es necesaria, pero puede ser útil buscar y reutilizar una cadena que ya esté marcada para traducción en otro lugar. Los mensajes de registro que no se muestran en el nivel de registro predeterminado (WARN, INFO y DEBUG) están destinados al uso del desarrollador y no tienen los requisitos anteriores. Sin embargo, los mensajes WARN están disponibles en la pestaña de registro de Android y pueden ayudar a los usuarios a depurar problemas, así que tenga cierto cuidado también con los mensajes WARN. Los mensajes de registro INFO y DEBUG deben usarse con moderación, especialmente en rutas de código críticas. Aunque son útiles durante el desarrollo, considere eliminarlos o comentarlos después de que se complete la prueba. No registre en stdout o stderr (registro del wrapper). Licencias Solo registra código que hayas escrito tú mismo. Antes de registrar cualquier código o JARs de bibliotecas de otras fuentes, justifica por qué es necesario, verifica que la licencia sea compatible y obtén la aprobación del gestor de lanzamientos. Si obtienes aprobación para añadir código externo o JARs, y hay binarios disponibles en cualquier paquete de Debian o Ubuntu, debes implementar opciones de compilación y empaquetado para usar el paquete externo en su lugar. Lista de verificación de archivos a modificar: build.properties, build.xml, debian/control, debian/i2p-router.install, debian/i2p-router.links, debian/rules, sub-build.xml. Para cualquier imagen registrada de fuentes externas, es tu responsabilidad verificar primero que la licencia sea compatible. Incluye la información de licencia y fuente en el comentario del registro. Errores Gestionar incidencias es trabajo de todos; por favor ayuda. Monitorea GitLab para ver incidencias en las que puedas ayudar. Comenta, corrige y cierra incidencias si puedes. Los nuevos desarrolladores deben comenzar corrigiendo incidencias. Cuando tengas una corrección, adjunta tu parche a la incidencia y añade la palabra clave review-needed. No cierres la incidencia hasta que haya sido revisada exitosamente y hayas verificado tus cambios. Una vez que hayas hecho esto sin problemas para un par de tickets, puedes seguir el procedimiento normal descrito arriba. Cierra una incidencia cuando creas que la has corregido. No tenemos un departamento de pruebas para verificar y cerrar tickets. Si no estás seguro de haberla corregido, ciérrala y añade una nota diciendo \u0026ldquo;Creo que lo corregí, por favor prueba y reabre si sigue sin funcionar\u0026rdquo;. Añade un comentario con el número de compilación de desarrollo o revisión y establece el milestone a la próxima versión. ","description":"Guía completa para contribuir a I2P: flujo de trabajo, ciclo de lanzamiento, estilo de código, registro de logs, licencias y gestión de problemas","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"Directrices para Desarrolladores y Estilo de Codificación","url":"/es/docs/develop/dev-guidelines/"},{"categories":null,"content":" Contexto: Esta página archiva debates prolongados de los primeros tiempos del diseño de I2P. Explica por qué el proyecto optó por libretas de direcciones de confianza local en lugar de consultas al estilo DNS o registros por voto mayoritario. Para obtener orientación sobre el uso actual, consulta la documentación de nombres .\nAlternativas descartadas Los objetivos de seguridad de I2P descartan los esquemas de nombres convencionales:\nResolución al estilo DNS. Cualquier resolvedor en la ruta de consulta podría falsificar o censurar respuestas. Incluso con DNSSEC, los registradores o las autoridades certificadoras comprometidos siguen siendo un punto único de falla. En I2P, los destinos son claves públicas—secuestrar una consulta comprometería por completo una identidad. Nomenclatura basada en votación. Un adversario puede crear identidades ilimitadas (un ataque Sybil) y “ganar” votos para nombres populares. Las mitigaciones de prueba de trabajo elevan el costo pero introducen una fuerte sobrecarga de coordinación. En cambio, I2P mantiene deliberadamente la resolución de nombres por encima de la capa de transporte. La biblioteca de resolución de nombres incluida ofrece una interfaz de proveedor de servicios para que los esquemas alternativos puedan coexistir—los usuarios deciden en qué libretas de direcciones o jump services (servicios de salto) confían.\nNombres locales vs globales (jrandom, 2005) Los nombres en I2P son únicos localmente pero legibles para humanos. Tu boss.i2p puede no coincidir con el boss.i2p de otra persona, y eso es por diseño. Si un actor malicioso te engañara para cambiar el destino detrás de un nombre, en la práctica secuestraría un servicio. Rechazar la unicidad global evita esa clase de ataque. Trata los nombres como marcadores o apodos de mensajería instantánea—tú eliges en qué destinos confiar suscribiéndote a libretas de direcciones específicas o agregando claves manualmente. Objeciones comunes \u0026amp; respuestas (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. ## Ideas de eficiencia discutidas Proporcionar actualizaciones incrementales (solo los destinos añadidos desde la última obtención). Ofrecer fuentes suplementarias (recenthosts.cgi) junto con archivos de hosts completos. Explorar herramientas automatizables con scripts (por ejemplo, i2host.i2p) para combinar fuentes o filtrar por niveles de confianza. Puntos clave La seguridad prima sobre el consenso global: las libretas de direcciones gestionadas localmente minimizan el riesgo de secuestro. Múltiples enfoques de nomenclatura pueden coexistir mediante la API de nombres—los usuarios deciden en qué confiar. La nomenclatura global completamente descentralizada sigue siendo un problema de investigación abierto; los compromisos entre la seguridad, la memorabilidad humana y la unicidad global aún reflejan el triángulo de Zooko . Referencias Documentación de nombres “Nombres: descentralizados, seguros y significativos para humanos: elige dos” de Zooko Fuente incremental de ejemplo: stats.i2p/cgi-bin/newhosts.txt ","description":"Debate histórico sobre el modelo de nombres de I2P y por qué se rechazaron los esquemas globales al estilo DNS","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"Discusión sobre el sistema de nombres","url":"/es/docs/legacy/naming/"},{"categories":null,"content":" Nota: Esta discusión archivada describe enfoques históricos de la base de datos de la red (netDb). Consulta la documentación principal de netDb para conocer el comportamiento actual y la orientación.\nHistoria La netDb de I2P se distribuye mediante un algoritmo floodfill simple. Las primeras versiones también mantenían una implementación de Kademlia DHT como respaldo, pero demostró ser poco fiable y fue deshabilitada por completo en la versión 0.6.1.20. El diseño floodfill reenvía una entrada publicada a un router participante, espera la confirmación y vuelve a intentarlo con otros pares floodfill si es necesario. Los pares floodfill difunden stores (mensajes de almacenamiento) desde routers no floodfill a todos los demás participantes floodfill.\nA finales de 2009, las consultas de Kademlia se reintrodujeron parcialmente para reducir la carga de almacenamiento en los routers floodfill individuales.\nIntroducción a Floodfill Floodfill apareció por primera vez en la versión 0.6.0.4, mientras que Kademlia (protocolo DHT) siguió disponible como respaldo. En ese momento, la gran pérdida de paquetes y las rutas restringidas dificultaban obtener acuses de recibo de los cuatro pares más cercanos, lo que a menudo requería decenas de intentos de almacenamiento redundantes. Pasar a un subconjunto floodfill de routers accesibles desde el exterior proporcionó una solución pragmática a corto plazo.\nRepensar Kademlia (protocolo de tabla hash distribuida) Entre las alternativas consideradas se encontraban:\nEjecutando la netDb como una Kademlia DHT (tabla hash distribuida Kademlia) limitada a routers alcanzables que opten por participar Manteniendo el modelo floodfill pero limitando la participación a routers capaces y verificando la distribución con comprobaciones aleatorias El enfoque floodfill se impuso porque era más fácil de implementar y la netDb solo contiene metadatos, no cargas útiles de usuario. La mayoría de los destinos nunca publican un LeaseSet porque el remitente suele empaquetar su LeaseSet en garlic messages (mensajes \u0026ldquo;garlic\u0026rdquo; que encapsulan varios mensajes).\nEstado actual (perspectiva histórica) Los algoritmos de netDb (base de datos de la red) están optimizados para las necesidades de la red y, históricamente, han gestionado cómodamente unos cientos de routers. Las estimaciones iniciales sugerían que 3–5 routers floodfill (nodos especializados que almacenan y distribuyen datos en la netDb) podrían soportar aproximadamente 10.000 nodos.\nCálculos actualizados (marzo de 2008) recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T Donde:\nN: routers en la red L: Número promedio de destinos de cliente por router (más uno por el RouterInfo) F: Porcentaje de fallos de tunnel R: Período de reconstrucción del tunnel como fracción de la vida útil del tunnel S: Tamaño promedio de una entrada de netDb T: Vida útil del tunnel Usando valores de 2008 (N = 700, L = 0.5, F = 0.33, R = 0.5, S = 4 KB, T = 10 minutes) da como resultado:\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps ¿Volverá Kademlia? Los desarrolladores debatieron reintroducir Kademlia (algoritmo de tabla hash distribuida, DHT) hacia principios de 2007. El consenso fue que la capacidad de floodfill podía ampliarse de forma incremental según fuera necesario, mientras que Kademlia añadía una complejidad y unos requisitos de recursos significativos para el conjunto base de routers. El mecanismo de respaldo permanece inactivo a menos que la capacidad de floodfill resulte insuficiente.\nPlanificación de capacidad de Floodfill (routers especiales que almacenan y propagan la netDb) La admisión automática de routers de clase de ancho de banda O en floodfill, aunque tentadora, arriesga escenarios de denegación de servicio si nodos hostiles optan por participar. Un análisis histórico indicó que limitar el conjunto de floodfill (por ejemplo, 3–5 pares gestionando ~10K routers) era más seguro. Se han utilizado operadores de confianza o heurísticas automáticas para mantener un conjunto de floodfill adecuado pero controlado.\nTareas pendientes de Floodfill (router especial de I2P que almacena y distribuye la netDb) (Histórico) Esta sección se conserva para la posteridad. La página principal de netDb realiza el seguimiento de la hoja de ruta actual y de las consideraciones de diseño.\nIncidentes operativos, como un período el 13 de marzo de 2008 con solo un floodfill router disponible, motivaron varias mejoras introducidas en las versiones 0.6.1.33 hasta la 0.7.x, entre ellas:\nAleatorización de la selección de floodfill para las búsquedas y preferencia por pares con buena respuesta Visualización de métricas adicionales de floodfill en la página \u0026ldquo;Profiles\u0026rdquo; de la consola del router Reducciones progresivas en el tamaño de las entradas de netDb para reducir el uso de ancho de banda de floodfill Activación automática para un subconjunto de routers de clase O basada en el rendimiento recopilado a través de datos de perfil Mejoras en las listas de bloqueo, la selección de pares floodfill y las heurísticas de exploración Las ideas restantes del período incluían:\nUsar estadísticas de dbHistory para evaluar y seleccionar mejor a pares floodfill Mejorar el comportamiento de reintento para evitar contactar repetidamente a pares que fallan Aprovechar las métricas de latencia y las puntuaciones de integración en la selección Detectar y reaccionar más rápidamente ante routers floodfill que fallan Seguir reduciendo las demandas de recursos en nodos de alto ancho de banda y floodfill Incluso a la fecha de estas notas, la red se consideraba resiliente, con infraestructura establecida para responder rápidamente a floodfills hostiles o a ataques de denegación de servicio dirigidos contra floodfills.\nNotas adicionales La consola del router lleva tiempo exponiendo datos de perfil mejorados para ayudar a analizar la fiabilidad de floodfill. Aunque los comentarios históricos especulaban sobre Kademlia u otros esquemas DHT (tabla hash distribuida) alternativos, floodfill ha seguido siendo el algoritmo principal para las redes de producción. La investigación orientada al futuro se centró en que la admisión a floodfill fuera adaptativa y en limitar las oportunidades de abuso. ","description":"Notas históricas sobre floodfill, experimentos con Kademlia (algoritmo DHT) y ajustes futuros para la netDb","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"Discusión sobre la base de datos de la red","url":"/es/docs/netdb/"},{"categories":null,"content":"Discusión NTCP vs. SSU (marzo de 2007) Preguntas sobre NTCP Adaptado de una conversación en IRC entre zzz y cervantes.\n¿Por qué NTCP tiene prioridad sobre SSU cuando NTCP parece añadir sobrecarga y latencia?\nNTCP generalmente ofrece mejor fiabilidad que la implementación original de SSU. ¿El streaming sobre NTCP incurre en el clásico colapso de TCP sobre TCP (TCP-over-TCP)?\nEs posible, pero SSU se concibió como la opción ligera basada en UDP y resultó demasiado poco fiable en la práctica. “NTCP considerado perjudicial” (zzz, 25 de marzo de 2007) Resumen: la mayor latencia y sobrecarga de NTCP pueden causar congestión; sin embargo, el enrutamiento prefiere NTCP porque sus valores de puja están fijados en el código como más bajos que los de SSU. El análisis planteó varios puntos:\nActualmente, NTCP ofrece un coste inferior al de SSU, por lo que los routers prefieren NTCP salvo que ya exista una sesión SSU. SSU implementa acuses de recibo con temporizadores estrictamente acotados y estadísticas; NTCP se apoya en Java NIO TCP con temporizadores al estilo de las RFC que pueden ser mucho más largos. La mayor parte del tráfico (HTTP, IRC, BitTorrent) usa la biblioteca de streaming de I2P, que efectivamente apila TCP sobre NTCP. Cuando ambas capas retransmiten, es posible un colapso. Las referencias clásicas incluyen TCP over TCP is a bad idea . Los tiempos de espera de la biblioteca de streaming aumentaron de 10 s a 45 s en la versión 0.8; el tiempo de espera máximo de SSU es de 3 s, mientras que se presume que los tiempos de espera de NTCP se acercan a 60 s (recomendación de la RFC). Los parámetros de NTCP son difíciles de inspeccionar externamente. Las observaciones de campo en 2007 mostraron que el rendimiento de subida de i2psnark oscilaba, lo que sugiere un colapso periódico por congestión. Las pruebas de eficiencia (forzando la preferencia por SSU) redujeron las proporciones de sobrecarga de tunnel de aproximadamente 3.5:1 a 3:1 y mejoraron las métricas de streaming (tamaño de ventana, RTT, proporción envío/ack). Propuestas del hilo de 2007 Invertir las prioridades de transporte para que los routers prefieran SSU (restaurando i2np.udp.alwaysPreferred). Etiquetar el tráfico de streaming de modo que SSU puje más bajo solo para los mensajes etiquetados, sin comprometer el anonimato. Restringir los límites de retransmisión de SSU para reducir el riesgo de colapso. Estudiar underlays (capas subyacentes) semiconfiables para determinar si las retransmisiones por debajo de la biblioteca de streaming aportan un beneficio neto. Revisar las colas de prioridad y los tiempos de espera—por ejemplo, aumentar los tiempos de espera de streaming más allá de 45 s para alinearlos con NTCP. Respuesta de jrandom (27 de marzo de 2007) Contraargumentos clave:\nNTCP existe porque los primeros despliegues de SSU sufrieron colapso por congestión. Incluso tasas modestas de retransmisión por salto pueden dispararse a través de tunnels de múltiples saltos. Sin acuses de recibo a nivel de tunnel, solo una fracción de los mensajes recibe estado de entrega extremo a extremo; los fallos pueden ser silenciosos. El control de congestión de TCP cuenta con décadas de optimizaciones; NTCP aprovecha eso mediante pilas TCP maduras. Las ganancias de eficiencia observadas al preferir SSU podrían reflejar el comportamiento de encolado del router más que ventajas intrínsecas del protocolo. Plazos de espera de streaming más largos ya estaban mejorando la estabilidad; se alentó recopilar más observaciones y datos antes de realizar cambios importantes. El debate ayudó a perfeccionar el ajuste posterior del transporte, pero no refleja la arquitectura moderna de NTCP2/SSU2.\n","description":"Notas históricas que comparan los transportes NTCP y SSU y propuestas de ajuste","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"Discusión sobre NTCP (protocolo de transporte de I2P basado en TCP)","url":"/es/docs/ntcp/"},{"categories":null,"content":" Nota: Este archivo recopila trabajo de diseño especulativo anterior a I2P 0.9.41. Para la implementación en producción, consulte la documentación de tunnel (túnel de I2P).\nAlternativas de configuración Entre las ideas consideradas para parámetros futuros de tunnel se incluyeron:\nLimitadores de frecuencia para la entrega de mensajes Políticas de relleno (incluida la chaff injection (inyección de tráfico señuelo)) Controles de vida útil del Tunnel Estrategias de procesamiento por lotes y de colas para el envío de cargas útiles Ninguna de estas opciones venía con la implementación heredada.\nEstrategias de relleno Enfoques potenciales de relleno discutidos:\nSin ningún relleno Relleno de longitud aleatoria Relleno de longitud fija Relleno hasta el kilobyte más cercano Relleno a potencias de dos (2^n bytes) Las mediciones iniciales (release 0.4) condujeron al tamaño fijo actual de 1024 bytes para los mensajes de tunnel. Los mensajes garlic (técnica de agrupación de mensajes en I2P) de nivel superior pueden añadir su propio relleno.\nFragmentación Para evitar ataques de etiquetado basados en la longitud del mensaje, los mensajes de tunnel tienen un tamaño fijo de 1024 bytes. Las cargas útiles I2NP de mayor tamaño son fragmentadas por la puerta de enlace; el extremo reensambla los fragmentos dentro de un breve tiempo de espera. Los Routers pueden reordenar los fragmentos para maximizar la eficiencia de empaquetado antes de enviarlos.\nAlternativas adicionales Ajustar el procesamiento del Tunnel a mitad de flujo Se examinaron tres posibilidades:\nPermitir que un salto intermedio finalice un tunnel temporalmente al conceder acceso a cargas útiles descifradas. Permitir que los routers participantes “remezclen” mensajes enviándolos a través de uno de sus propios tunnels salientes antes de continuar al siguiente salto. Habilitar al creador del tunnel para redefinir dinámicamente el siguiente salto de un par. Tunnels bidireccionales El uso de tunnels de entrada y salida separados limita la información que cualquier conjunto de pares puede observar (p. ej., una solicitud GET frente a una respuesta grande). Los tunnels bidireccionales simplifican la gestión de pares, pero exponen los patrones de tráfico completos a ambas direcciones simultáneamente. Por lo tanto, los tunnels unidireccionales siguieron siendo el diseño preferido.\nCanales de retorno y tamaños variables Permitir tamaños variables en los mensajes de tunnel habilitaría canales encubiertos entre pares en colusión (por ejemplo, codificando datos mediante tamaños o frecuencias seleccionados). Los mensajes de tamaño fijo mitigan este riesgo a costa de una sobrecarga adicional de relleno.\nAlternativas de construcción de Tunnel Referencia: Hashing it out in Public Método de compilación “paralelo” heredado Antes de la versión 0.6.1.10, las solicitudes de construcción de tunnel se enviaban en paralelo a cada participante. Este método está documentado en la antigua página de tunnel .\nConstrucción telescópica de una sola vez (método actual) El enfoque moderno envía mensajes de construcción salto a salto a través del tunnel parcialmente construido. Aunque similar al telescoping de Tor (establecimiento incremental), enrutar los mensajes de construcción a través de tunnels exploratorios reduce la fuga de información.\nConstrucción telescópica “interactiva” Construir un salto a la vez, con idas y vueltas explícitas, permite a los pares contar mensajes e inferir su posición en el tunnel, por lo que este enfoque fue rechazado.\nTunnels de gestión no exploratorios Una propuesta consistía en mantener un conjunto separado de tunnels de gestión para el tráfico de construcción. Si bien podría ayudar a routers particionados, se consideró innecesario con una integración de red adecuada.\nEntrega exploratoria (heredada) Antes de la 0.6.1.10, las solicitudes de tunnel individuales se cifraban con garlic encryption (técnica de cifrado de I2P que agrupa múltiples mensajes) y se entregaban a través de tunnels exploratorios, con las respuestas regresando por separado. Esta estrategia fue reemplazada por el método de telescopado de un solo intento actual.\nPuntos clave Los mensajes de tunnel de tamaño fijo protegen contra el marcado basado en el tamaño y los canales encubiertos, a pesar del costo adicional del relleno. Se exploraron estrategias alternativas de relleno, fragmentación y construcción, pero no se adoptaron al sopesarlas frente a los compromisos de anonimato. El diseño del tunnel sigue equilibrando la eficiencia, la observabilidad y la resistencia a los ataques de predecesor y de congestión. ","description":"Exploración histórica del relleno de tunnel, la fragmentación y las estrategias de construcción","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"Discusión sobre Tunnel","url":"/es/docs/legacy/tunnel/"},{"categories":null,"content":"Alojar GitLab dentro de I2P es sencillo: ejecuta el contenedor omnibus de GitLab, expónlo en loopback y reenvía el tráfico a través de un tunnel I2P. Los pasos a continuación reflejan la configuración utilizada para git.idk.i2p pero funcionan para cualquier instancia auto-alojada.\n1. Prerrequisitos Debian u otra distribución de Linux con Docker Engine instalado (sudo apt install docker.io o docker-ce desde el repositorio de Docker). Un router I2P (Java I2P o i2pd) con suficiente ancho de banda para servir a tus usuarios. Opcional: una VM dedicada para que GitLab y el router permanezcan aislados de tu entorno de escritorio. 2. Descargar la Imagen de GitLab docker pull gitlab/gitlab-ce:latest La imagen oficial se construye a partir de capas base de Ubuntu y se actualiza regularmente. Audite el Dockerfile si necesita garantías adicionales.\n3. Decidir entre Bridging vs. Solo I2P Las instancias exclusivas de I2P nunca contactan con hosts de clearnet. Los usuarios pueden replicar repositorios de otros servicios I2P, pero no desde GitHub/GitLab.com. Esto maximiza el anonimato. Las instancias puente se conectan a hosts Git de clearnet mediante un proxy HTTP. Esto es útil para replicar proyectos públicos en I2P, pero desanonimiza las solicitudes salientes del servidor. Si eliges el modo bridged, configura GitLab para usar un proxy HTTP de I2P vinculado en el host de Docker (por ejemplo http://172.17.0.1:4446). El proxy del router predeterminado escucha solo en 127.0.0.1; agrega un nuevo tunnel de proxy vinculado a la dirección del gateway de Docker.\n4. Iniciar el Contenedor docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest Vincula los puertos publicados a loopback; los túneles I2P los expondrán según sea necesario. Reemplaza /srv/gitlab/... con las rutas de almacenamiento que se ajusten a tu host. Una vez que el contenedor esté en ejecución, visita https://127.0.0.1:8443/, establece una contraseña de administrador y configura los límites de cuenta.\n5. Exponer GitLab a través de I2P Crea tres túneles servidor de I2PTunnel:\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated Configure cada túnel con longitudes de túnel y ancho de banda apropiados. Para instancias públicas, 3 saltos con 4–6 túneles por dirección es un buen punto de partida. Publique los destinos Base32/Base64 resultantes en su página de inicio para que los usuarios puedan configurar los túneles de cliente. Destination Enforcement Si usas túneles HTTP(S), habilita la aplicación de destino para que solo el nombre de host previsto pueda acceder al servicio. Esto evita que el túnel sea usado indebidamente como un proxy genérico.\n6. Maintenance Tips Ejecuta docker exec gitlab gitlab-ctl reconfigure cada vez que cambies la configuración de GitLab. Monitorea el uso de disco (/srv/gitlab/data)—los repositorios Git crecen rápidamente. Respalda los directorios de configuración y datos regularmente. Las tareas rake de respaldo de GitLab funcionan dentro del contenedor. Considera colocar un tunnel de monitoreo externo en modo cliente para asegurar que el servicio sea accesible desde la red más amplia. 6. Consejos de Mantenimiento Integrar I2P en tu aplicación Git sobre I2P (guía del cliente) Paquetes Git para redes sin conexión/lentas Una instancia de GitLab bien configurada proporciona un centro de desarrollo colaborativo completamente dentro de I2P. Mantén el router saludable, mantente actualizado con las actualizaciones de seguridad de GitLab y coordina con la comunidad a medida que crece tu base de usuarios.\n","description":"Desplegando GitLab dentro de I2P usando Docker y un router I2P","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"Ejecutar GitLab sobre I2P","url":"/es/docs/guides/gitlab/"},{"categories":null,"content":"Descripción general I2P construye túneles temporales y unidireccionales — secuencias ordenadas de routers que reenvían tráfico cifrado. Los túneles se clasifican como inbound (los mensajes fluyen hacia el creador) o outbound (los mensajes fluyen desde el creador).\nUn intercambio típico enruta el mensaje de Alice a través de uno de sus túneles de salida, instruye al punto final de salida para que lo reenvíe a la puerta de enlace de uno de los túneles de entrada de Bob, y luego Bob lo recibe en su punto final de entrada.\nA: Gateway de Salida (Alice) B: Participante de Salida C: Punto Final de Salida D: Gateway de Entrada E: Participante de Entrada F: Punto Final de Entrada (Bob) Los tunnels tienen una duración fija de 10 minutos y transportan mensajes de tamaño fijo de 1024 bytes (1028 bytes incluyendo el encabezado del tunnel) para prevenir el análisis de tráfico basado en patrones de tamaño o temporización de mensajes.\nVocabulario de Túneles Tunnel gateway: Primer router en un túnel. Para túneles de entrada, la identidad de este router aparece en el LeaseSet publicado. Para túneles de salida, el gateway es el router de origen (A y D arriba). Tunnel endpoint: Último router en un túnel (C y F arriba). Tunnel participant: Router intermedio en un túnel (B y E arriba). Los participantes no pueden determinar su posición o la dirección del túnel. Túnel de n-saltos: Número de saltos entre routers. 0-saltos: Gateway y endpoint son el mismo router – anonimato mínimo. 1-salto: Gateway se conecta directamente al endpoint – baja latencia, bajo anonimato. 2-saltos: Predeterminado para túneles exploratorios; seguridad/rendimiento balanceado. 3-saltos: Recomendado para aplicaciones que requieren anonimato fuerte. Tunnel ID: Entero de 4 bytes único por router y por salto, elegido aleatoriamente por el creador. Cada salto recibe y reenvía con IDs diferentes. Información de Construcción de Túneles Los routers que cumplen los roles de gateway (puerta de enlace), participant (participante) y endpoint (punto final) reciben diferentes registros dentro del Mensaje de Construcción de Túnel. El I2P moderno soporta dos métodos:\nElGamal (heredado, registros de 528 bytes) ECIES-X25519 (actual, registros de 218 bytes mediante Short Tunnel Build Message – STBM) Information Distributed to Participants El gateway recibe: - Clave de capa de tunnel (clave AES-256 o ChaCha20 dependiendo del tipo de tunnel) - Clave IV de tunnel (para cifrar vectores de inicialización) - Clave de respuesta e IV de respuesta (para el cifrado de respuesta de construcción) - ID de tunnel (solo gateways de entrada) - Hash de identidad del siguiente salto e ID de tunnel (si no es terminal)\nLos participantes intermedios reciben: - Clave de capa de tunnel e IV para su salto - ID del tunnel e información del siguiente salto - Clave de respuesta e IV para el cifrado de la respuesta de construcción\nLos endpoints reciben: - Claves de la capa de túnel e IV - Router de respuesta e ID del túnel (solo endpoints salientes) - Clave de respuesta e IV (solo endpoints salientes)\nPara más detalles consulte la Especificación de Creación de Túneles y la Especificación de Creación de Túneles ECIES .\nTunnel Pooling Los routers agrupan túneles en conjuntos de túneles (tunnel pools) para redundancia y distribución de carga. Cada conjunto mantiene múltiples túneles paralelos, permitiendo la conmutación por error cuando uno falla. Los conjuntos utilizados internamente son túneles exploratorios (exploratory tunnels), mientras que los conjuntos específicos de aplicaciones son túneles de cliente (client tunnels).\nCada destino mantiene pools de entrada y salida separados configurados mediante opciones I2CP (cantidad de túneles, cantidad de respaldo, longitud y parámetros de QoS). Los routers monitorean la salud de los túneles, ejecutan pruebas periódicas y reconstruyen automáticamente los túneles fallidos para mantener el tamaño del pool.\nAgrupación de túneles Túneles de 0 saltos: Ofrecen únicamente negación plausible. El tráfico siempre se origina y termina en el mismo router — desaconsejado para cualquier uso anónimo.\nTúneles de 1 salto: Proporcionan anonimato básico contra observadores pasivos, pero son vulnerables si un adversario controla ese único salto.\nTúneles de 2 saltos: Incluyen dos routers remotos y aumentan sustancialmente el costo de ataque. Predeterminado para pools exploratorios.\nTúneles de 3 saltos: Recomendado para aplicaciones que requieren protección robusta de anonimato. Los saltos adicionales añaden latencia sin una ganancia significativa de seguridad.\nValores predeterminados: Los routers utilizan túneles exploratorios de 2 saltos y túneles de cliente específicos de aplicación de 2 o 3 saltos, equilibrando rendimiento y anonimato.\nLongitud del Túnel Los routers prueban periódicamente los túneles enviando un DeliveryStatusMessage a través de un túnel de salida hacia un túnel de entrada. Si la prueba falla, ambos túneles reciben una ponderación negativa en el perfil. Fallos consecutivos marcan un túnel como inutilizable; el router entonces reconstruye un reemplazo y publica un nuevo LeaseSet. Los resultados alimentan las métricas de capacidad de peers utilizadas por el sistema de selección de peers .\nPrueba de Túneles Los routers construyen túneles usando un método telescópico no interactivo: un único Tunnel Build Message se propaga salto a salto. Cada salto descifra su registro, añade su respuesta y reenvía el mensaje. El salto final devuelve la respuesta agregada de construcción a través de una ruta diferente, evitando la correlación. Las implementaciones modernas usan Short Tunnel Build Messages (STBM) para ECIES y Variable Tunnel Build Messages (VTBM) para rutas heredadas. Cada registro se cifra por salto usando ElGamal o ECIES-X25519.\nCreación de Túneles El tráfico del túnel utiliza cifrado multicapa. Cada salto agrega o elimina una capa de cifrado a medida que los mensajes atraviesan el túnel.\nTúneles ElGamal: AES-256/CBC para cargas útiles con relleno PKCS#5. Túneles ECIES: ChaCha20 o ChaCha20-Poly1305 para cifrado autenticado. Cada salto tiene dos claves: una clave de capa y una clave IV. Los routers descifran el IV, lo usan para procesar la carga útil, y luego vuelven a cifrar el IV antes de reenviar. Este esquema de doble IV previene el etiquetado de mensajes.\nLos gateways de salida pre-descifran todas las capas para que los endpoints reciban texto plano después de que todos los participantes hayan añadido cifrado. Los túneles de entrada cifran en la dirección opuesta. Los participantes no pueden determinar la dirección o longitud del túnel.\nCifrado de Túnel Tiempos de vida dinámicos de túneles y dimensionamiento adaptativo de pools para balanceo de carga de red Estrategias alternativas de prueba de túneles y diagnósticos de saltos individuales Validación opcional de proof-of-work o certificados de ancho de banda (implementado en API 0.9.65+) Investigación de modelado de tráfico e inserción de chaff para mezcla de endpoints Retiro continuo de ElGamal y migración a ECIES-X25519 Desarrollo Continuo Especificación de Implementación de Túneles Especificación de Creación de Túneles (ElGamal) Especificación de Creación de Túneles (ECIES-X25519) Especificación de Mensajes de Túnel Enrutamiento Garlic Base de Datos de Red I2P Perfilado y Selección de Pares Modelo de Amenazas de I2P Cifrado ElGamal/AES + SessionTag Opciones I2CP ","description":"Descripción general de la terminología, construcción y ciclo de vida de los túneles I2P","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"Enrutamiento de Túneles","url":"/es/docs/overview/tunnel-routing/"},{"categories":null,"content":" 1. Descripción general Garlic routing sigue siendo una de las innovaciones fundamentales de I2P, combinando cifrado por capas, agrupación de mensajes y túneles unidireccionales. Aunque conceptualmente similar al enrutamiento cebolla (onion routing), extiende el modelo al agrupar múltiples mensajes cifrados (\u0026ldquo;cloves\u0026rdquo; o dientes) en un único sobre (\u0026ldquo;garlic\u0026rdquo; o ajo), mejorando la eficiencia y el anonimato.\nEl término garlic routing fue acuñado por Michael J. Freedman en la Tesis de Maestría de Free Haven de Roger Dingledine (junio de 2000, §8.1.1). Los desarrolladores de I2P adoptaron el término a principios de los años 2000 para reflejar sus mejoras de agrupación y modelo de transporte unidireccional, distinguiéndolo del diseño de conmutación de circuitos de Tor.\nResumen: Garlic routing = cifrado en capas + agrupación de mensajes + entrega anónima mediante túneles unidireccionales.\n2. La Terminología \u0026ldquo;Garlic\u0026rdquo; Históricamente, el término garlic se ha utilizado en tres contextos diferentes dentro de I2P:\nCifrado por capas – protección estilo cebolla a nivel de tunnel Agrupación de múltiples mensajes – múltiples \u0026ldquo;cloves\u0026rdquo; dentro de un \u0026ldquo;garlic message\u0026rdquo; Cifrado de extremo a extremo – anteriormente ElGamal/AES+SessionTags, ahora ECIES‑X25519‑AEAD‑Ratchet Aunque la arquitectura permanece intacta, el esquema de cifrado ha sido completamente modernizado.\n3. Cifrado por capas El garlic routing comparte su principio fundamental con el onion routing: cada router descifra solo una capa de cifrado, conociendo únicamente el siguiente salto y no la ruta completa.\nSin embargo, I2P implementa túneles unidireccionales, no circuitos bidireccionales:\nTunnel de salida: envía mensajes desde el creador Tunnel de entrada: transporta mensajes de vuelta al creador Un viaje completo de ida y vuelta (Alice ↔ Bob) utiliza cuatro tunnels: el outbound de Alice → el inbound de Bob, luego el outbound de Bob → el inbound de Alice. Este diseño reduce a la mitad la exposición de datos de correlación en comparación con los circuitos bidireccionales.\nPara detalles de implementación de túneles, consulta la Especificación de Túneles y la especificación de Creación de Túneles (ECIES) .\n4. Empaquetado de Múltiples Mensajes (Los \u0026ldquo;Cloves\u0026rdquo;) El garlic routing original de Freedman imaginaba agrupar múltiples \u0026ldquo;bulbos\u0026rdquo; encriptados dentro de un mensaje. I2P implementa esto como cloves (dientes) dentro de un garlic message (mensaje garlic) — cada clove tiene sus propias instrucciones de entrega encriptadas y destino (router, destino o tunnel).\nEl empaquetado garlic (garlic bundling) permite a I2P:\nCombinar confirmaciones y metadatos con mensajes de datos Reducir patrones de tráfico observables Soportar estructuras de mensajes complejas sin conexiones adicionales Figura 1: Un Garlic Message que contiene múltiples cloves, cada uno con sus propias instrucciones de entrega.\nLos dientes típicos incluyen:\nMensaje de Estado de Entrega — acuses de recibo que confirman el éxito o fracaso de la entrega.\nEstos se envuelven en su propia capa garlic para preservar la confidencialidad. Mensaje de Almacenamiento de Base de Datos — LeaseSets empaquetados automáticamente para que los peers puedan responder sin consultar nuevamente la netDb. Los cloves se agrupan cuando:\nSe debe publicar un nuevo LeaseSet Se entregan nuevas etiquetas de sesión No ha ocurrido ningún bundle recientemente (~1 minuto por defecto) Los mensajes garlic logran una entrega eficiente de extremo a extremo de múltiples componentes cifrados en un solo paquete.\n5. Evolución del Cifrado 5.1 Historical Context La documentación temprana (≤ v0.9.12) describía el cifrado ElGamal/AES+SessionTags: - ElGamal de 2048 bits envolvía las claves de sesión AES - AES‑256/CBC para el cifrado de la carga útil - Etiquetas de sesión de 32 bytes usadas una vez por mensaje\nEse criptosistema está obsoleto.\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) Entre 2019 y 2023, I2P migró completamente a ECIES‑X25519‑AEAD‑Ratchet. La pila moderna estandariza los siguientes componentes:\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains Beneficios de la migración a ECIES: Secreto hacia adelante mediante claves de trinquete por mensaje Tamaño de carga útil reducido en comparación con ElGamal Resiliencia contra avances criptoanalíticos Compatibilidad con híbridos post-cuánticos futuros (ver Propuesta 169) Detalles adicionales: consulte la Especificación ECIES y la especificación EncryptedLeaseSet .\n6. LeaseSets and Garlic Bundling Los envelopes garlic frecuentemente incluyen LeaseSets para publicar o actualizar la accesibilidad del destino.\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively Todos los LeaseSets se distribuyen a través de la *floodfill DHT* mantenida por routers especializados. Las publicaciones se verifican, se les añade marca de tiempo y se limita su frecuencia para reducir la correlación de metadatos. Consulte la documentación de la Network Database para más detalles.\n7. Modern “Garlic” Applications within I2P El cifrado basado en garlic y la agrupación de mensajes se utilizan en toda la pila de protocolos de I2P:\nCreación y uso de túneles — cifrado por capas en cada salto Entrega de mensajes de extremo a extremo — mensajes garlic agrupados con acuse de recibo clonado y cloves de LeaseSet Publicación en la base de datos de red — LeaseSets envueltos en sobres garlic para privacidad Transportes SSU2 y NTCP2 — cifrado de capa subyacente usando el framework Noise y primitivas X25519/ChaCha20 El garlic routing es por lo tanto tanto un método de capas de cifrado como un modelo de mensajería de red.\n6. LeaseSets y Garlic Bundling El centro de documentación de I2P está disponible aquí , mantenido continuamente. Las especificaciones vigentes relevantes incluyen:\nEspecificación ECIES — ECIES‑X25519‑AEAD‑Ratchet Creación de Tunnel (ECIES) — protocolo moderno de construcción de tunnel Especificación I2NP — formatos de mensaje I2NP Especificación SSU2 — transporte UDP SSU2 Estructuras Comunes — comportamiento de netDb y floodfill Validación académica: Hoang et al. (IMC 2018, USENIX FOCI 2019) y Muntaka et al. (2025) confirman la estabilidad arquitectónica y la resiliencia operacional del diseño de I2P.\n7. Aplicaciones \u0026ldquo;Garlic\u0026rdquo; Modernas dentro de I2P Propuestas en curso:\nPropuesta 169: Híbrida post-cuántica (ML-KEM 512/768/1024 + X25519) Propuesta 168: Optimización del ancho de banda de transporte Actualizaciones de datagramas y streaming: Gestión mejorada de congestión Las adaptaciones futuras pueden incluir estrategias adicionales de retardo de mensajes o redundancia multi-túnel a nivel de mensaje garlic, basándose en opciones de entrega no utilizadas descritas originalmente por Freedman.\n8. Documentación Actual y Referencias Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. ","description":"Comprendiendo la terminología, arquitectura e implementación moderna del garlic routing en I2P","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"Enrutamiento Garlic","url":"/es/docs/overview/garlic-routing/"},{"categories":null,"content":"Descripción general Los routers comprueban automáticamente si hay actualizaciones consultando periódicamente una fuente de noticias firmada, distribuida a través de la red I2P. Cuando se anuncia una versión más reciente, el router descarga un archivo de actualización firmado criptográficamente (.su3) y lo deja listo para su instalación. Este sistema garantiza una distribución de las versiones oficiales autenticada y resistente a manipulaciones, y multicanal.\nA partir de I2P 2.10.0, el sistema de actualización utiliza: - RSA-4096 / SHA-512 firmas - Formato de contenedor SU3 (reemplazando SUD/SU2 heredados) - Espejos redundantes: HTTP dentro de la red, HTTPS en clearnet (Internet pública) y BitTorrent\n1. Fuente de noticias Routers consultan periódicamente la fuente Atom firmada cada pocas horas para descubrir nuevas versiones y avisos de seguridad. La fuente está firmada y se distribuye como un archivo .su3, que puede incluir:\n\u0026lt;i2p:version\u0026gt; — nuevo número de versión \u0026lt;i2p:minVersion\u0026gt; — versión mínima del router compatible \u0026lt;i2p:minJavaVersion\u0026gt; — entorno de ejecución de Java mínimo requerido \u0026lt;i2p:update\u0026gt; — enumera múltiples espejos de descarga (I2P, HTTPS, torrent) \u0026lt;i2p:revocations\u0026gt; — datos de revocación de certificados \u0026lt;i2p:blocklist\u0026gt; — listas de bloqueo a nivel de red para pares comprometidos Distribución del feed Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load Routers prefieren el feed de I2P, pero pueden recurrir a clearnet (internet abierta) o a la distribución por torrent si es necesario. 2. Formatos de archivo SU3 (Estándar actual) Introducido en la versión 0.9.9, SU3 reemplazó los formatos heredados SUD y SU2. Cada archivo contiene un encabezado, una carga útil y una firma final.\nEstructura del encabezado \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Field\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Magic\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I2Psu3\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Format Version\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;e.g., \u0026lt;code\u0026gt;0x000B\u0026lt;/code\u0026gt; (RSA-SHA512-4096)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Length\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;512 bytes\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Version String\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Router version\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signer ID\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Certificate name\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Content Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;1 = router update, 3 = reseed, 4 = news feed\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Pasos para la verificación de la firma 1. Analiza el encabezado e identifica el algoritmo de firma. 2. Verifica el hash y la firma usando el certificado del firmante almacenado. 3. Confirma que el firmante no esté revocado. 4. Compara la cadena de versión incrustada con los metadatos de la carga útil.\nRouters se distribuyen con certificados de firmantes de confianza (actualmente zzz y str4d) y rechazan cualquier fuente no firmada o revocada.\nSU2 (Obsoleto) Se utilizó la extensión .su2 con archivos JAR comprimidos con Pack200. Se eliminó después de que Java 14 marcara Pack200 como obsoleto (JEP 367). Deshabilitado en I2P 0.9.48+; ahora completamente reemplazado por la compresión ZIP. SUD (heredado) Formato ZIP firmado con DSA-SHA1 (previo a la 0.9.9). Sin ID de firmante ni encabezado, integridad limitada. Reemplazado debido a criptografía débil y ausencia de obligatoriedad de versión. 3. Flujo de trabajo de actualización 3.1 Verificación del encabezado Routers obtienen únicamente el encabezado SU3 para verificar la cadena de versión antes de descargar los archivos completos. Esto evita malgastar ancho de banda en espejos obsoletos o versiones desactualizadas.\n3.2 Descarga completa Después de verificar el encabezado, el router descarga el archivo .su3 completo desde: - Espejos de eepsite dentro de la red (preferido) - Espejos HTTPS en clearnet (Internet pública) (alternativa) - BitTorrent (distribución asistida por pares opcional)\nLas descargas utilizan clientes HTTP estándar de I2PTunnel, con reintentos, manejo de tiempos de espera y conmutación a un espejo de respaldo.\n3.3 Verificación de firma Cada archivo descargado se somete a: - Comprobación de firma: verificación RSA-4096/SHA512 - Coincidencia de versiones: comprobación de la versión del encabezado frente a la de la carga útil - Prevención de retroceso de versión: garantiza que la actualización sea más reciente que la versión instalada\nLos archivos no válidos o que no coinciden se descartan de inmediato.\n3.4 Preparación de la instalación Una vez verificado: 1. Extraer el contenido del ZIP a un directorio temporal 2. Eliminar los archivos listados en deletelist.txt 3. Sustituir las bibliotecas nativas si se incluye lib/jbigi.jar 4. Copiar los certificados del firmante a ~/.i2p/certificates/ 5. Mover la actualización a i2pupdate.zip para aplicarla en el próximo reinicio\nLa actualización se instala automáticamente en el próximo inicio o cuando se activa manualmente la opción “Instalar actualización ahora”.\n4. Gestión de archivos deletelist.txt Una lista en texto plano de archivos obsoletos para eliminar antes de desempaquetar el contenido nuevo.\nReglas: - Una ruta por línea (solo rutas relativas) - Líneas que comienzan con # ignoradas - .. y rutas absolutas rechazadas\nBibliotecas nativas Para evitar binarios nativos obsoletos o incompatibles: - Si existe lib/jbigi.jar, se eliminan los archivos .so o .dll antiguos - Garantiza que las bibliotecas específicas de la plataforma se extraigan nuevamente\n5. Gestión de certificados Routers pueden recibir nuevos certificados de firmante mediante actualizaciones o revocaciones en el feed de noticias.\nLos nuevos archivos .crt se copian en el directorio de certificados. Los certificados revocados se eliminan antes de futuras verificaciones. Admite la rotación de claves sin requerir intervención manual del usuario. Todas las actualizaciones se firman sin conexión utilizando sistemas de firma aislados físicamente. Las claves privadas nunca se almacenan en los servidores de compilación.\n6. Directrices para desarrolladores Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. Las próximas versiones explorarán la integración de firmas poscuánticas (véase la Propuesta 169) y compilaciones reproducibles. 7. Descripción general de seguridad Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity --- 8. Versionado Router: 2.10.0 (API 0.9.67) Versionado semántico con Major.Minor.Patch. La exigencia de una versión mínima evita actualizaciones inseguras. Java compatible: Java 8–17. En el futuro, 2.11.0+ requerirá Java 17+. ","description":"Mecanismo seguro de actualización firmada y estructura del feed para routers I2P","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"Especificación de actualización de software","url":"/es/docs/specs/updates/"},{"categories":null,"content":"Descripción general Este documento especifica el formato de archivo blockfile de I2P y las tablas en el hostsdb.blockfile utilizadas por el Blockfile Naming Service (Servicio de nombres Blockfile). Para contexto, consulte Nombres en I2P y libreta de direcciones .\nEl blockfile (archivo de bloques) permite búsquedas rápidas de destinos en un formato binario compacto. En comparación con el sistema heredado hosts.txt:\nLos destinos se almacenan en binario, no en Base64. Se puede adjuntar metadatos arbitrarios (p. ej., fecha de incorporación, origen, comentarios). Los tiempos de búsqueda son aproximadamente 10× más rápidos. El uso de disco aumenta modestamente. Un archivo de bloques es una colección en disco de mapas ordenados (pares clave-valor) implementados como skiplists (listas con saltos). Se derivó de Metanotion Blockfile Database . Esta especificación primero define la estructura del archivo y luego describe cómo lo utiliza el BlockfileNamingService.\nEl Blockfile Naming Service (servicio de nombres basado en archivo de bloques) sustituyó la antigua implementación de hosts.txt en I2P 0.8.8. \u0026gt; Al inicializarse, importa entradas de privatehosts.txt, userhosts.txt y hosts.txt.\nFormato de Blockfile (archivo por bloques) El formato se compone de páginas de 1024 bytes, cada una precedida por un número mágico para garantizar la integridad. Las páginas se numeran a partir de 1:\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) Todos los enteros utilizan **orden de bytes de red (big-endian, byte más significativo primero)**. Los valores de 2 bytes son sin signo; los valores de 4 bytes (números de página) son con signo y deben ser positivos. Hilos: La base de datos está diseñada para acceso de un solo hilo; BlockfileNamingService proporciona sincronización.\nFormato de superbloque Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused --- Formato de la página de bloques de la lista con saltos (skip list) Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused --- Formato de página de bloqueo de salto de nivel Cada nivel tiene una extensión, pero no todas las extensiones tienen niveles.\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused --- Formato de página de bloque con omisión de span (etiqueta HTML) Los pares clave/valor están ordenados por clave a través de los segmentos. Los segmentos que no sean el primero no deben estar vacíos.\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures --- Formato de página del bloque de continuación de segmento Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures --- Formato de estructura clave/valor Los campos de longitud de clave y valor no pueden cruzar páginas (los 4 bytes deben caber). Si no queda espacio suficiente, rellene con hasta 3 bytes de relleno y continúe en el desplazamiento 8 de la página siguiente.\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each --- Formato de la página de bloques de la lista libre Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) --- Formato de bloque de página libre Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused --- Metaíndice Se encuentra en la página 2. Asocia cadenas US-ASCII → enteros de 4 bytes. La clave es el nombre del skiplist (lista con saltos); el valor es el índice de página.\nTablas del servicio de nombres de Blockfile (archivo por bloques) El servicio define varias skiplists (listas de salto). Cada segmento admite hasta 16 entradas.\nPropiedades de Skiplist (lista con saltos) %%__INFO__%% contiene una entrada:\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping Campos típicos: Property Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) --- Skiplist de búsqueda inversa (lista por saltos) %%__REVERSE__%% contiene entradas de tipo Integer → Properties (desde la DB v2).\nClave: Los primeros 4 bytes del hash SHA-256 del Destination (Destino en I2P). Valor: Objeto Properties (mapeo serializado). Varias entradas gestionan colisiones y Destinations con múltiples nombres de host. Cada clave de propiedad = nombre de host; valor = cadena vacía. Listas de salto de la base de datos de hosts Cada uno de hosts.txt, userhosts.txt, y privatehosts.txt asocia nombres de host → Destinations (destinos de I2P).\nLa versión 4 admite varios Destinos por nombre de host (introducido en I2P 0.9.26). Las bases de datos de la versión 3 se migran automáticamente.\nClave Cadena UTF-8 (nombre de host, en minúsculas, que termina en .i2p)\nValor Versión 4: 1 byte con el recuento de pares Propiedad/Destino Para cada par: Propiedades → Destino (binario) Versión 3: Propiedades → Destino (binario) Propiedades de DestEntry Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) --- Notas de implementación La clase Java BlockfileNamingService implementa esta especificación.\nFuera del contexto del router, la base de datos se abre en solo lectura a menos que i2p.naming.blockfile.writeInAppContext=true. No está pensado para acceso multiinstancia o multi-JVM. Mantiene tres mapas principales (privatehosts, userhosts, hosts) y un mapa inverso para búsquedas rápidas. Referencias Documentación de nombres y libreta de direcciones de I2P Especificación de estructuras comunes Base de datos Blockfile (archivo por bloques) de Metanotion JavaDoc de BlockfileNamingService ","description":"Formato de almacenamiento en disco tipo blockfile (archivo en bloques) utilizado por I2P para la resolución de nombres de host","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"Especificación de Blockfile (formato de archivo por bloques)","url":"/es/docs/specs/blockfile/"},{"categories":null,"content":"Descripción general Propósito ECIES-X25519-AEAD-Ratchet es el protocolo moderno de cifrado de extremo a extremo de I2P, que reemplaza el sistema heredado ElGamal/AES+SessionTags. Proporciona secreto perfecto hacia adelante, cifrado autenticado y mejoras significativas en rendimiento y seguridad.\nMejoras principales con respecto a ElGamal/AES+SessionTags Claves más pequeñas: Claves de 32 bytes frente a claves públicas ElGamal de 256 bytes (reducción del 87,5 %) Secreto hacia adelante: Logrado mediante DH ratcheting (mecanismo de avance escalonado) (no disponible en el protocolo heredado) Criptografía moderna: X25519 DH, ChaCha20-Poly1305 AEAD (cifrado autenticado con datos asociados), SHA-256 Cifrado autenticado: Autenticación integrada mediante construcción AEAD Protocolo bidireccional: Sesiones de entrada/salida emparejadas frente al protocolo heredado unidireccional Etiquetas eficientes: Etiquetas de sesión de 8 bytes frente a etiquetas de 32 bytes (reducción del 75 %) Ofuscación del tráfico: La codificación Elligator2 (técnica de ofuscación de curvas elípticas) hace que los intercambios iniciales sean indistinguibles de datos aleatorios Estado de despliegue Lanzamiento inicial: Versión 0.9.46 (25 de mayo de 2020) Despliegue de la red: Completo desde 2020 Estado actual: Maduro, ampliamente desplegado (más de 5 años en producción) Compatibilidad del router: Se requiere la versión 0.9.46 o superior Requisitos de Floodfill: Adopción cercana al 100% para consultas cifradas Estado de la implementación Completamente implementado: - mensajes New Session (NS) con vinculación - mensajes New Session Reply (NSR) - mensajes Existing Session (ES) - mecanismo de ratchet DH (mecanismo de avance escalonado) - ratchets de etiquetas de sesión y de claves simétricas - bloques DateTime, NextKey, ACK, ACK Request, Garlic Clove y Padding\nNo implementado (a partir de la versión 0.9.50): - bloque MessageNumbers (tipo 6) - bloque de opciones (tipo 5) - bloque de terminación (tipo 4) - respuestas automáticas a nivel de protocolo - modo de clave estática cero - sesiones multicast\nNota: El estado de implementación para las versiones desde la 1.5.0 hasta la 2.10.0 (2021-2025) requiere verificación, ya que es posible que se hayan añadido nuevas características.\nFundamentos del protocolo Marco del protocolo Noise ECIES-X25519-AEAD-Ratchet se basa en el Noise Protocol Framework (marco del protocolo Noise) (Revisión 34, 2018-07-11), específicamente en el patrón de negociación IK (Interactivo, clave estática remota conocida) con extensiones específicas de I2P.\nIdentificador del protocolo Noise Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 Componentes del identificador: - Noise - Marco base - IK - Patrón de saludo interactivo con clave estática remota conocida - elg2 - Codificación Elligator2 para claves efímeras (extensión de I2P) - +hs2 - MixHash invocado antes del segundo mensaje para mezclar la etiqueta (extensión de I2P) - 25519 - Función Diffie-Hellman X25519 - ChaChaPoly - Cifrado AEAD ChaCha20-Poly1305 - SHA256 - Función hash SHA-256\nPatrón de negociación de Noise Notación del patrón IK:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) Significados de los tokens: - e - Transmisión de clave efímera - s - Transmisión de clave estática - es - DH entre la clave efímera de Alice y la clave estática de Bob - ss - DH entre la clave estática de Alice y la clave estática de Bob - ee - DH entre la clave efímera de Alice y la clave efímera de Bob - se - DH entre la clave estática de Bob y la clave efímera de Alice\nPropiedades de seguridad de Noise Usando la terminología de Noise, el patrón IK proporciona:\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) **Niveles de autenticación:** - **Nivel 1**: La carga útil está autenticada como perteneciente al propietario de la clave estática del remitente, pero es vulnerable a Key Compromise Impersonation (suplantación por compromiso de clave, KCI) - **Nivel 2**: Resistente a ataques KCI después de NSR Niveles de confidencialidad: - Nivel 2: Secreto hacia adelante si la clave estática del remitente se ve comprometida posteriormente - Nivel 4: Secreto hacia adelante si la clave efímera del remitente se ve comprometida posteriormente - Nivel 5: Secreto hacia adelante completo después de que ambas claves efímeras se eliminen\nDiferencias entre IK y XK El patrón IK difiere del patrón XK utilizado en NTCP2 y SSU2:\nCuatro operaciones DH: IK usa 4 operaciones DH (es, ss, ee, se) frente a 3 para XK Autenticación inmediata: Alice queda autenticada en el primer mensaje (Nivel de Autenticación 1) Secreto hacia adelante más rápido: Se logra secreto hacia adelante completo (Nivel 5) después del segundo mensaje (1-RTT, una ida y vuelta) Compensación: La carga útil del primer mensaje no tiene secreto hacia adelante (frente a XK, donde todas las cargas útiles tienen secreto hacia adelante) Resumen: IK permite la entrega en 1-RTT de la respuesta de Bob con pleno secreto perfecto hacia adelante, a costa de que la solicitud inicial no tenga secreto perfecto hacia adelante.\nConceptos del Signal Double Ratchet (algoritmo de doble trinquete) ECIES incorpora conceptos del Signal Double Ratchet Algorithm (algoritmo de doble trinquete de Signal):\nDH Ratchet (mecanismo de avance criptográfico): Proporciona secreto hacia adelante al intercambiar periódicamente nuevas claves DH Symmetric Key Ratchet: Deriva nuevas claves de sesión para cada mensaje Session Tag Ratchet: Genera etiquetas de sesión de un solo uso de forma determinista Diferencias clave con Signal: - Ratcheting menos frecuente (mecanismo de actualización progresiva de claves): I2P solo hace ratcheting cuando es necesario (cerca del agotamiento de etiquetas o por política) - Etiquetas de sesión en lugar de cifrado de encabezados: Usa etiquetas deterministas en lugar de encabezados cifrados - ACKs explícitos: Usa bloques de ACK en banda en lugar de depender únicamente del tráfico de retorno - Ratchets de etiquetas y de claves separados: Más eficiente para el receptor (puede posponer el cálculo de la clave)\nExtensiones de I2P para Noise (marco de protocolos criptográficos) Codificación Elligator2 (técnica para hacer que las claves en curvas elípticas parezcan aleatorias): Claves efímeras codificadas para ser indistinguibles de lo aleatorio Etiqueta antepuesta a NSR: Etiqueta de sesión agregada antes del mensaje NSR para permitir la correlación Formato de carga útil definido: Estructura de carga útil basada en bloques para todos los tipos de mensajes Encapsulación I2NP: Todos los mensajes envueltos en cabeceras I2NP Garlic Message Fase de datos separada: Los mensajes de transporte (ES) difieren de la fase de datos estándar de Noise (marco de protocolos criptográficos) Primitivas criptográficas X25519 Diffie-Hellman Especificación: RFC 7748 Propiedades principales: - Tamaño de la clave privada: 32 bytes - Tamaño de la clave pública: 32 bytes - Tamaño del secreto compartido: 32 bytes - Orden de bytes: Little-endian (menos significativo primero) - Curva: Curve25519\nOperaciones:\nX25519 GENERATE_PRIVATE() Genera una clave privada aleatoria de 32 bytes:\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) Deriva la clave pública correspondiente:\npubkey = curve25519_scalarmult_base(privkey) Devuelve una clave pública de 32 bytes en formato little-endian (byte menos significativo primero).\nX25519 DH(privkey, pubkey) Realiza el acuerdo de claves Diffie-Hellman:\nsharedSecret = curve25519_scalarmult(privkey, pubkey) Devuelve un secreto compartido de 32 bytes.\nNota de seguridad: Los implementadores deben validar que el secreto compartido no consista únicamente en ceros (clave débil). Rechace y aborte el handshake (negociación) si esto ocurre.\nChaCha20-Poly1305 AEAD (cifrado autenticado con datos asociados) Especificación: RFC 7539 sección 2.8\nParámetros: - Tamaño de clave: 32 bytes (256 bits) - Tamaño de nonce (número usado una vez): 12 bytes (96 bits) - Tamaño de MAC: 16 bytes (128 bits) - Tamaño de bloque: 64 bytes (interno)\nFormato del nonce (número aleatorio de un solo uso):\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) Construcción de AEAD:\nAEAD (cifrado autenticado con datos asociados) combina el cifrado en flujo ChaCha20 con el MAC Poly1305:\nGenerar el flujo de claves de ChaCha20 a partir de la clave y el nonce (número único de uso único) Cifrar el texto plano mediante XOR con el flujo de claves Calcular el MAC Poly1305 sobre (datos asociados || texto cifrado) Adjuntar el MAC de 16 bytes al texto cifrado ChaCha20-Poly1305 ENCRYPT(k, n, plaintext, ad) Cifra el texto plano con autenticación:\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 Propiedades: - El texto cifrado tiene la misma longitud que el texto en claro (cifrado de flujo) - La salida es plaintext_length + 16 bytes (incluye el MAC) - Toda la salida es indistinguible de datos aleatorios si la clave es secreta - El MAC autentica tanto los datos asociados como el texto cifrado\nChaCha20-Poly1305 DESCIFRAR(k, n, ciphertext, ad) Descifra y verifica la autenticación:\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext Requisitos críticos de seguridad: - Los nonces (valores únicos de un solo uso) DEBEN ser únicos para cada mensaje con la misma clave - Los nonces NO DEBEN reutilizarse (fallo catastrófico si se reutilizan) - La verificación del MAC DEBE usar comparación en tiempo constante para evitar ataques de temporización - Una verificación de MAC fallida DEBE resultar en el rechazo completo del mensaje (sin descifrado parcial)\nFunción hash SHA-256 Especificación: NIST FIPS 180-4\nPropiedades: - Tamaño de salida: 32 bytes (256 bits) - Tamaño de bloque: 64 bytes (512 bits) - Nivel de seguridad: 128 bits (resistencia a colisiones)\nOperaciones:\nSHA-256 H(p, d) Hash SHA-256 con cadena de personalización:\nH(p, d) := SHA256(p || d) Donde || denota concatenación, p es la cadena de personalización, d son los datos.\nSHA-256 MixHash(d) (función de mezcla de hash) Actualiza el hash incremental con nuevos datos:\nh = SHA256(h || d) Se utiliza durante todo el handshake de Noise para mantener el hash de la transcripción.\nDerivación de claves con HKDF Especificación: RFC 5869 Descripción: Función de derivación de claves basada en HMAC usando SHA-256\nParámetros: - Función hash: HMAC-SHA256 - Longitud de la sal: Hasta 32 bytes (tamaño de salida de SHA-256) - Longitud de salida: Variable (hasta 255 * 32 bytes)\nFunción HKDF:\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] Patrones de uso comunes:\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] Cadenas de información utilizadas en ECIES: - \u0026quot;KDFDHRatchetStep\u0026quot; - derivación de la clave del ratchet DH (mecanismo de avance criptográfico) - \u0026quot;TagAndKeyGenKeys\u0026quot; - inicializar las claves de etiquetas y de la cadena de claves - \u0026quot;STInitialization\u0026quot; - inicialización del ratchet de etiqueta de sesión - \u0026quot;SessionTagKeyGen\u0026quot; - generación de etiquetas de sesión - \u0026quot;SymmetricRatchet\u0026quot; - generación de claves simétricas - \u0026quot;XDHRatchetTagSet\u0026quot; - clave del conjunto de etiquetas del ratchet DH - \u0026quot;SessionReplyTags\u0026quot; - generación del conjunto de etiquetas NSR - \u0026quot;AttachPayloadKDF\u0026quot; - derivación de la clave de la carga útil NSR\nCodificación Elligator2 (método criptográfico para representar claves públicas como datos indistinguibles de datos aleatorios) Propósito: Codificar claves públicas X25519 de modo que sean indistinguibles de cadenas aleatorias uniformes de 32 bytes.\nEspecificación: Artículo sobre Elligator2 Problema: Las claves públicas X25519 estándar tienen una estructura reconocible. Un observador puede identificar los mensajes de handshake (negociación) detectando estas claves, incluso si el contenido está cifrado.\nSolución: Elligator2 proporciona una aplicación biyectiva entre ~50% de las claves públicas X25519 válidas y cadenas de 254 bits de aspecto aleatorio.\nGeneración de claves con Elligator2:\nElligator2 GENERATE_PRIVATE_ELG2() Genera una clave privada que se corresponde con una clave pública codificable mediante Elligator2 (técnica que permite codificar claves públicas de forma indistinguible de datos aleatorios):\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue Importante: Aproximadamente el 50% de las claves privadas generadas aleatoriamente producirán claves públicas no codificables. Deben descartarse y debe intentarse la regeneración.\nOptimización del rendimiento: Genera claves por adelantado en un hilo en segundo plano para mantener una reserva de pares de claves adecuados, evitando demoras durante el handshake (negociación inicial).\nElligator2 ENCODE_ELG2(pubkey) Codifica una clave pública en 32 bytes con apariencia aleatoria:\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey Detalles de codificación: - Elligator2 (técnica de mapeo criptográfico) produce 254 bits (no los 256 completos) - Los 2 bits más significativos del byte 31 son relleno aleatorio - El resultado se distribuye uniformemente en todo el espacio de 32 bytes - Codifica con éxito aproximadamente el 50% de las claves públicas X25519 válidas\nElligator2 DECODE_ELG2(encodedKey) Se decodifica de vuelta a la clave pública original:\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey Propiedades de seguridad: - Las claves codificadas son indistinguibles computacionalmente de bytes aleatorios - Ninguna prueba estadística puede detectar de forma fiable claves codificadas con Elligator2 - La decodificación es determinista (la misma clave codificada siempre produce la misma clave pública) - La codificación es biyectiva para el ~50% de las claves del subconjunto codificable\nNotas de implementación: - Almacenar las claves codificadas en la fase de generación para evitar volver a codificarlas durante la negociación inicial - Las claves no aptas de la generación con Elligator2 (mapeo criptográfico para ofuscar claves) pueden usarse para NTCP2 (que no requiere Elligator2) - La generación de claves en segundo plano es esencial para el rendimiento - El tiempo medio de generación se duplica debido a una tasa de rechazo del 50%\nFormatos de mensajes Descripción general ECIES define tres tipos de mensaje:\nNew Session (NS) (nueva sesión): Mensaje de negociación inicial de Alice a Bob New Session Reply (NSR) (respuesta a nueva sesión): Respuesta de negociación de Bob a Alice Existing Session (ES) (sesión existente): Todos los mensajes posteriores en ambas direcciones Todos los mensajes están encapsulados en el formato I2NP Garlic Message con capas adicionales de cifrado.\nContenedor de mensajes Garlic de I2NP Todos los mensajes ECIES se encapsulan en encabezados estándar de I2NP Garlic Message (mensaje Garlic):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ Campos: - type: 0x26 (Garlic Message) - msg_id: ID de mensaje I2NP de 4 bytes - expiration: marca de tiempo Unix de 8 bytes (milisegundos) - size: tamaño de la carga útil de 2 bytes - chks: suma de verificación de 1 byte - length: longitud de los datos cifrados de 4 bytes - encrypted data: carga útil cifrada con ECIES\nPropósito: Proporciona identificación y enrutamiento de mensajes en la capa I2NP. El campo length permite a los receptores conocer el tamaño total de la carga útil cifrada.\nMensaje de Nueva Sesión (NS) El mensaje de nueva sesión inicia una nueva sesión desde Alice hacia Bob. Se presenta en tres variantes:\nCon vinculación (1b): Incluye la clave estática de Alice para comunicación bidireccional Sin vinculación (1c): Omite la clave estática para comunicación unidireccional De un solo uso (1d): Modo de un solo mensaje sin establecimiento de sesión Mensaje NS con vinculación (Tipo 1b) Caso de uso: Transmisión en continuo, datagramas a los que se puede responder, cualquier protocolo que requiera respuestas\nLongitud total: 96 + payload_length bytes\nFormato:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Detalles del campo:\nClave pública efímera (32 bytes, sin cifrar): - Clave pública X25519 de un solo uso de Alice - Codificada con Elligator2 (indistinguible de datos aleatorios) - Se genera nueva para cada mensaje NS (nunca se reutiliza) - Formato little-endian\nSección de clave estática (32 bytes cifrados, 48 bytes con MAC): - Contiene la clave pública estática X25519 de Alice (32 bytes) - Cifrado con ChaCha20 - Autenticado con MAC Poly1305 (16 bytes) - Usado por Bob para vincular la sesión al destino de Alice\nPayload Section (cifrado de longitud variable, +16 bytes de MAC): - Contiene garlic cloves (subbloques de garlic encryption; \u0026ldquo;dientes de ajo\u0026rdquo; en la terminología de I2P) y otros bloques - Debe incluir el bloque DateTime como primer bloque - Suele incluir bloques Garlic Clove con datos de la aplicación - Puede incluir el bloque NextKey para ratchet inmediato (mecanismo de avance criptográfico) - Cifrado con ChaCha20 - Autenticado con MAC Poly1305 (16 bytes)\nPropiedades de seguridad: - La clave efímera proporciona el componente de secreto perfecto hacia adelante - La clave estática autentica a Alice (vinculándola al destino) - Ambas secciones tienen MAC independientes para separación de dominios - El handshake completo realiza 2 operaciones DH (es, ss)\nNS Message (mensaje NS) sin vinculación (Tipo 1c) Caso de uso: Datagramas sin procesar en los que no se espera ni se desea respuesta\nLongitud total: 96 + payload_length bytes\nFormato:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Diferencia clave: La Flags Section (sección de banderas) contiene 32 bytes de ceros en lugar de una clave estática.\nDetección: Bob determina el tipo de mensaje descifrando la sección de 32 bytes y verificando si todos los bytes son cero: - Todos en cero → sesión no vinculada (tipo 1c) - Algún byte distinto de cero → sesión vinculada con clave estática (tipo 1b)\nPropiedades: - No tener una clave estática significa que no hay vinculación con el destino de Alice - Bob no puede enviar respuestas (no se conoce el destino) - Realiza solo 1 operación DH (Diffie-Hellman) (es) - Sigue el patrón \u0026ldquo;N\u0026rdquo; de Noise en lugar de \u0026ldquo;IK\u0026rdquo; - Más eficiente cuando nunca se necesitan respuestas\nSección de indicadores (reservada para uso futuro): Actualmente, todo son ceros. Podría utilizarse para la negociación de características en versiones futuras.\nNS Mensaje de un solo uso (Tipo 1d) Caso de uso: Mensaje anónimo único, sin sesión ni respuesta esperada\nLongitud total: 96 + payload_length bytes\nFormato: Idéntico a NS sin vinculación (tipo 1c)\nDistinción: - Tipo 1c puede enviar múltiples mensajes en la misma sesión (los mensajes ES siguen) - Tipo 1d envía exactamente un mensaje sin establecimiento de sesión - En la práctica, las implementaciones pueden tratar ambos de forma idéntica inicialmente\nPropiedades: - Anonimato máximo (sin clave estática, sin sesión) - Ninguna de las partes conserva estado de sesión - Sigue el patrón \u0026ldquo;N\u0026rdquo; de Noise (marco de protocolos criptográficos) - Una única operación DH (es)\nMensaje de respuesta de nueva sesión (NSR) Bob envía uno o más mensajes NSR en respuesta al mensaje NS de Alice. NSR completa el handshake Noise IK y establece una sesión bidireccional.\nLongitud total: 72 + payload_length bytes\nFormato:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Detalles del campo:\nEtiqueta de sesión (8 bytes, en claro): - Generada a partir del conjunto de etiquetas de NSR (véanse las secciones de KDF) - Correlaciona esta respuesta con el mensaje NS de Alice - Permite a Alice identificar a qué NS responde este NSR - Uso único (nunca se reutiliza)\nClave pública efímera (32 bytes, en claro): - La clave pública X25519 de un solo uso de Bob - Codificada con Elligator2 - Generada de nuevo para cada mensaje NSR - Debe ser diferente para cada NSR enviado\nMAC de la sección de clave (16 bytes): - Autentica datos vacíos (ZEROLEN) - Parte del protocolo Noise IK (se pattern; patrón estático-efímero) - Utiliza el hash de la transcripción como datos asociados - Crítico para vincular NSR a NS\nSección de carga útil (longitud variable): - Contiene garlic cloves (submensajes en el esquema garlic encryption) y bloques - Suele incluir respuestas de la capa de aplicación - Puede estar vacía (NSR solo con ACK) - Tamaño máximo: 65519 bytes (65535 - MAC de 16 bytes)\nMúltiples mensajes NSR:\nBob puede enviar varios mensajes NSR en respuesta a un NS: - Cada NSR tiene una clave efímera única - Cada NSR tiene una etiqueta de sesión única - Alice usa el primer NSR recibido para completar el intercambio inicial - Los otros NSR son redundancia (en caso de pérdida de paquetes)\nTemporización crítica: - Alice debe recibir un NSR antes de enviar mensajes ES - Bob debe recibir un mensaje ES antes de enviar mensajes ES - NSR establece claves de sesión bidireccionales mediante la operación split()\nPropiedades de seguridad: - Completa el apretón de manos Noise IK - Realiza 2 operaciones DH adicionales (ee, se) - Total de 4 operaciones DH entre NS+NSR - Logra autenticación mutua (Nivel 2) - Proporciona secreto hacia adelante débil (Nivel 4) para la carga útil de NSR\nMensaje de Sesión Existente (ES) Todos los mensajes posteriores a la negociación NS/NSR usan el formato Existing Session (formato de sesión existente). Los mensajes ES se utilizan de forma bidireccional tanto por Alice como por Bob.\nLongitud total: 8 + payload_length + 16 bytes (mínimo 24 bytes)\nFormato:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ Detalles del campo:\nEtiqueta de sesión (8 bytes, en claro): - Generada a partir del conjunto de etiquetas de salida actual - Identifica la sesión y el número de mensaje - El receptor busca la etiqueta para encontrar la clave de sesión y el nonce (número único de uso) - Uso único (cada etiqueta se usa exactamente una vez) - Formato: primeros 8 bytes de la salida de HKDF\nSección de carga útil (longitud variable): - Contiene garlic cloves (unidades individuales de Garlic Encryption) y bloques - Sin bloques obligatorios (puede estar vacía) - Bloques comunes: Garlic Clove, NextKey, ACK, ACK Request, Padding - Tamaño máximo: 65519 bytes (65535 - MAC de 16 bytes)\nMAC (16 bytes): - Etiqueta de autenticación Poly1305 - Se calcula sobre toda la carga útil - Datos asociados: la etiqueta de sesión de 8 bytes - Debe verificarse correctamente o el mensaje será rechazado\nProceso de búsqueda de etiquetas:\nEl receptor extrae una etiqueta de 8 bytes Busca la etiqueta en todos los conjuntos de etiquetas entrantes actuales Recupera la clave de sesión asociada y el número de mensaje N Construye el nonce (número único de uso): [0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] Descifra la carga útil usando AEAD con la etiqueta como datos asociados Elimina la etiqueta del conjunto de etiquetas (de un solo uso) Procesa los bloques descifrados Etiqueta de sesión no encontrada:\nSi la etiqueta no se encuentra en ningún conjunto de etiquetas: - Puede ser un mensaje NS (tipo de mensaje de I2P) → intentar el descifrado NS - Puede ser un mensaje NSR (tipo de mensaje de I2P) → intentar el descifrado NSR - Puede ser un ES (esquema ElGamal+SessionTags en I2P) fuera de orden → esperar brevemente la actualización del conjunto de etiquetas - Puede ser un ataque de repetición → rechazar - Puede tratarse de datos corruptos → rechazar\nCarga útil vacía:\nLos mensajes ES pueden tener cargas útiles vacías (0 bytes): - Sirven como un ACK (acuse de recibo) explícito cuando se recibió una solicitud de ACK - Proporcionan una respuesta a nivel de protocolo sin datos de aplicación - Aún consumen una etiqueta de sesión - Son útiles cuando la capa superior no tiene datos inmediatos para enviar\nPropiedades de seguridad: - Secreto perfecto hacia adelante completo (Nivel 5) después de recibir NSR - Cifrado autenticado mediante AEAD (cifrado autenticado con datos asociados) - La etiqueta actúa como datos asociados adicionales - Máximo de 65535 mensajes por tagset (conjunto de etiquetas) antes de que sea necesario un ratchet (mecanismo de derivación incremental de claves)\nFunciones de derivación de claves Esta sección documenta todas las operaciones KDF (función de derivación de claves) utilizadas en ECIES, mostrando las derivaciones criptográficas completas.\nNotación y constantes Constantes: - ZEROLEN - Matriz de bytes de longitud cero (cadena vacía) - || - Operador de concatenación\nVariables: - h - Hash acumulado de la transcripción (32 bytes) - chainKey - Clave de encadenamiento para HKDF (32 bytes) - k - Clave de cifrado simétrico (32 bytes) - n - Nonce / número de mensaje\nClaves: - ask / apk - clave privada/pública estática de Alice - aesk / aepk - clave privada/pública efímera de Alice - bsk / bpk - clave privada/pública estática de Bob - besk / bepk - clave privada/pública efímera de Bob\nFunciones de derivación de claves para mensajes NS KDF 1: Clave de cadena inicial Se realiza una vez durante la inicialización del protocolo (puede precalcularse):\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions Resultado: - chainKey = clave de encadenamiento inicial para todas las KDF posteriores (funciones de derivación de claves) - h = hash inicial de la transcripción\nKDF 2 (función de derivación de claves): Mezcla de clave estática de Bob Bob realiza esto una vez (puede precalcularse para todas las sesiones entrantes):\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF 3: Generación de clave efímera de Alice Alice genera claves nuevas para cada NS message (mensaje NS):\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF 4: Sección de clave estática de NS (es DH) Deriva claves para cifrar la clave estática de Alice:\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF 5: Sección de carga útil de NS (ss DH, solo vinculada) Para sesiones vinculadas, realiza un segundo DH (intercambio de claves Diffie-Hellman) para cifrar la carga útil:\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message Notas importantes:\nBound (vinculado) vs Unbound (no vinculado):\nBound realiza 2 operaciones DH (Diffie–Hellman) (es + ss) Unbound realiza 1 operación DH (solo es) Unbound incrementa el nonce (número usado una vez) en lugar de derivar una clave nueva Seguridad frente a la reutilización de claves:\nNonces (valor único de un solo uso) diferentes (0 vs 1) evitan la reutilización de clave/nonce Datos asociados diferentes (h es diferente) proporcionan separación de dominios Transcripción del hash:\nh ahora contiene: protocol_name, prólogo vacío, bpk, aepk, static_key_ciphertext, payload_ciphertext Esta transcripción vincula todas las partes del mensaje NS entre sí NSR Reply Tagset KDF (función de derivación de claves del conjunto de etiquetas de respuesta de NSR) Bob genera etiquetas para los mensajes NSR:\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR Funciones de derivación de claves del mensaje NSR KDF 6: Generación de claves efímeras de NSR Bob genera una clave efímera nueva para cada NSR (solicitud de sesión de Noise):\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7: Sección de claves de NSR (ee (efímero-efímero) y se (estático-efímero) DH) Deriva claves para la sección de claves de NSR:\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR Crítico: Esto completa el handshake Noise IK (intercambio inicial del protocolo Noise IK). chainKey ahora contiene contribuciones de las 4 operaciones DH (es, ss, ee, se).\nKDF 8: Sección de carga útil de NSR Deriva claves para el cifrado de la carga útil de NSR:\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message Notas importantes:\nOperación de división:\nCrea claves independientes para cada dirección Evita la reutilización de claves entre Alice→Bob y Bob→Alice Vinculación de la carga útil NSR:\nUsa h como datos asociados para vincular la carga útil al handshake (proceso de establecimiento de conexión) Una KDF (función de derivación de claves) independiente (\u0026ldquo;AttachPayloadKDF\u0026rdquo;) proporciona separación de dominios Preparación para ES:\nDespués de NSR, ambas partes pueden enviar mensajes ES Alice debe recibir NSR antes de enviar ES Bob debe recibir ES antes de enviar ES KDFs de mensajes de ES Los mensajes ES usan claves de sesión generadas previamente a partir de los tagsets (conjuntos de etiquetas):\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) Proceso del receptor:\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) Función DH_INITIALIZE Crea un tagset (conjunto de etiquetas) para un único sentido:\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset Contextos de uso:\nConjunto de etiquetas NSR: DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) Conjuntos de etiquetas ES: DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) Conjuntos de etiquetas con ratchet (mecanismo criptográfico de avance): DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) Mecanismos de trinquete ECIES (esquema de cifrado integrado sobre curvas elípticas) utiliza tres mecanismos de ratchet (mecanismo de avance criptográfico) sincronizados para proporcionar secreto hacia adelante y una gestión eficiente de sesiones.\nDescripción general de Ratchet (mecanismo de trinquete) Tres tipos de Ratchet (mecanismo de avance escalonado):\nDH Ratchet (mecanismo de avance criptográfico): Realiza intercambios de claves Diffie-Hellman para generar nuevas claves raíz Session Tag Ratchet: Deriva etiquetas de sesión de un solo uso de forma determinista Symmetric Key Ratchet: Deriva claves de sesión para el cifrado de mensajes Relación:\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) Propiedades clave:\nRemitente: Genera etiquetas y claves bajo demanda (no se necesita almacenamiento) Receptor: Pre-genera etiquetas para una ventana de anticipación (se requiere almacenamiento) Sincronización: El índice de la etiqueta determina el índice de la clave (N_tag = N_key) Secreto hacia adelante: Logrado mediante un DH ratchet (mecanismo de avance Diffie–Hellman) periódico Eficiencia: El receptor puede aplazar el cálculo de la clave hasta que se reciba la etiqueta DH Ratchet (mecanismo de avance de claves Diffie-Hellman) El DH ratchet (mecanismo de avance de Diffie-Hellman) proporciona secreto hacia adelante al intercambiar periódicamente nuevas claves efímeras.\nFrecuencia del DH Ratchet (mecanismo de trinquete Diffie‑Hellman) Condiciones requeridas del Ratchet (mecanismo de avance criptográfico): - Conjunto de etiquetas próximo al agotamiento (la etiqueta 65535 es el máximo) - Políticas específicas de la implementación: - Umbral de cantidad de mensajes (p. ej., cada 4096 mensajes) - Umbral de tiempo (p. ej., cada 10 minutos) - Umbral de volumen de datos (p. ej., cada 100 MB)\nPrimer Ratchet recomendado (mecanismo de avance criptográfico): Alrededor del número de etiqueta 4096 para evitar alcanzar el límite\nValores máximos: - ID máximo del conjunto de etiquetas: 65535 - ID máximo de clave: 32767 - Máximo de mensajes por conjunto de etiquetas: 65535 - Máximo teórico de datos por sesión: ~6.9 TB (64K conjuntos de etiquetas × 64K mensajes × 1730 bytes promedio)\nIdentificadores de etiquetas y de claves del DH Ratchet (mecanismo de avance Diffie-Hellman) Conjunto de etiquetas inicial (tras el handshake): - ID del conjunto de etiquetas: 0 - Aún no se han enviado bloques NextKey (siguiente clave) - No se han asignado IDs de clave\nDespués del primer Ratchet (mecanismo de trinquete criptográfico): - ID del conjunto de etiquetas: 1 = (1 + ID de clave de Alice + ID de clave de Bob) = (1 + 0 + 0) - Alice envía NextKey con ID de clave 0 - Bob responde con NextKey con ID de clave 0\nConjuntos de etiquetas posteriores: - ID del conjunto de etiquetas = 1 + ID de la clave del emisor + ID de la clave del receptor - Ejemplo: Conjunto de etiquetas 5 = (1 + sender_key_2 + receiver_key_2)\nTabla de progresión del conjunto de etiquetas:\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set \\* = Nueva clave generada en este ratchet (mecanismo de actualización de claves criptográficas) Reglas del ID de clave: - Los ID son secuenciales a partir de 0 - Los ID se incrementan solo cuando se genera una nueva clave - El ID de clave máximo es 32767 (15 bits) - Después del ID de clave 32767, se requiere una nueva sesión\nFlujo de mensajes de DH Ratchet (mecanismo de avance criptográfico Diffie-Hellman) Roles: - Remitente de etiquetas: Posee el conjunto de etiquetas de salida, envía mensajes - Receptor de etiquetas: Posee el conjunto de etiquetas de entrada, recibe mensajes\nPatrón: El emisor de etiquetas inicia el ratchet (mecanismo de avance criptográfico) cuando el conjunto de etiquetas está a punto de agotarse.\nDiagrama de flujo de mensajes:\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) Patrones de Ratchet (mecanismo de trinquete):\nCreación de Tag Sets (conjuntos de etiquetas) de número par (2, 4, 6, \u0026hellip;): 1. El emisor genera una nueva clave 2. El emisor envía un NextKey block (bloque NextKey) con la nueva clave 3. El receptor envía un NextKey block con el ID de la clave antigua (ACK, acuse de recibo) 4. Ambos realizan DH (Diffie-Hellman) con (nueva clave del emisor × clave antigua del receptor)\nCreación de conjuntos de etiquetas con numeración impar (3, 5, 7, \u0026hellip;): 1. El remitente solicita la clave inversa (envía NextKey (siguiente clave) con el indicador de solicitud) 2. El receptor genera una nueva clave 3. El receptor envía un bloque NextKey con la nueva clave 4. Ambos realizan Diffie-Hellman (DH) con (clave antigua del remitente × clave nueva del receptor)\nFormato del bloque NextKey (siguiente clave) Consulte la sección Formato de la carga útil para obtener la especificación detallada del bloque NextKey (siguiente clave).\nElementos clave: - Byte de indicadores: - Bit 0: Clave presente (1) o solo ID (0) - Bit 1: Clave inversa (1) o clave directa (0) - Bit 2: Solicitar clave inversa (1) o sin solicitud (0) - ID de clave: 2 bytes, big-endian (0-32767) - Clave pública: 32 bytes X25519 (si el bit 0 = 1)\nEjemplos de bloques NextKey (siguiente clave):\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) KDF (función de derivación de claves) del DH Ratchet (mecanismo de trinquete) Cuando se intercambian nuevas claves:\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset Temporización crítica:\nRemitente de etiquetas: - Crea un nuevo conjunto de etiquetas salientes de inmediato - Comienza a usar las nuevas etiquetas de inmediato - Elimina el conjunto de etiquetas salientes antiguo\nReceptor de etiquetas: - Crea un nuevo conjunto de etiquetas entrantes - Conserva el conjunto de etiquetas entrantes anterior durante el período de gracia (3 minutos) - Acepta etiquetas de ambos conjuntos, el antiguo y el nuevo, durante el período de gracia - Elimina el conjunto de etiquetas entrantes anterior tras el período de gracia\nGestión del estado de DH Ratchet (mecanismo de avance de Diffie-Hellman) Estado del remitente: - Conjunto de etiquetas salientes actual - ID del conjunto de etiquetas e IDs de claves - Siguiente clave raíz (para el próximo ratchet (mecanismo de avance criptográfico)) - Número de mensajes en el conjunto de etiquetas actual\nEstado del receptor: - Conjunto(s) actual(es) de etiquetas entrantes (puede haber 2 durante el período de gracia) - Números de mensajes anteriores (PN) para la detección de huecos - Ventana de anticipación de etiquetas pre-generadas - Siguiente clave raíz (para el siguiente ratchet, mecanismo de avance criptográfico)\nReglas de transición de estado:\nAntes del primer Ratchet (mecanismo de avance criptográfico):\nUsando el conjunto de etiquetas 0 (de NSR) No hay identificadores de clave asignados Iniciando Ratchet (mecanismo de avance criptográfico):\nGenerar nueva clave (si en esta ronda le toca generar al remitente) Enviar el bloque NextKey en el mensaje ES Esperar la respuesta de NextKey antes de crear un nuevo conjunto de etiquetas de salida Recepción de una solicitud de Ratchet (mecanismo de avance criptográfico):\nGenerar una nueva clave (si el receptor está generando en esta ronda) Realizar DH (Diffie-Hellman) con la clave recibida Crear un nuevo conjunto de etiquetas de entrada Enviar NextKey reply (respuesta NextKey) Conservar el conjunto de etiquetas de entrada anterior durante un período de gracia Completar Ratchet (mecanismo de actualización de claves):\nRecibir la respuesta NextKey Realizar DH Crear un nuevo conjunto de etiquetas de salida Comenzar a usar las nuevas etiquetas Ratchet de etiquetas de sesión (mecanismo de avance criptográfico) El session tag ratchet (mecanismo de avance criptográfico para etiquetas de sesión) genera session tags de 8 bytes de un solo uso de forma determinista.\nPropósito del Session Tag Ratchet (mecanismo de avance criptográfico para etiquetas de sesión) Sustituye la transmisión explícita de etiquetas (ElGamal enviaba etiquetas de 32 bytes) Permite al receptor pre-generar etiquetas para una ventana de anticipación El emisor las genera bajo demanda (no requiere almacenamiento) Se sincroniza con el ratchet (mecanismo de avance) de clave simétrica mediante un índice Fórmula del ratchet (mecanismo de avance tipo trinquete) de etiquetas de sesión Inicialización:\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset Generación de etiqueta (para la etiqueta N):\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 Secuencia completa:\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] Implementación del emisor de Session Tag Ratchet (mecanismo de avance criptográfico de etiquetas de sesión) class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) Proceso del emisor: 1. Llamar a get_next_tag() para cada mensaje 2. Usar la etiqueta devuelta en el mensaje ES 3. Almacenar el índice N para un posible seguimiento de ACK (confirmación de recepción) 4. No es necesario almacenar la etiqueta (se genera bajo demanda)\nImplementación del receptor de Session Tag Ratchet class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) Proceso del receptor: 1. Pre-generar etiquetas para la ventana de anticipación (p. ej., 32 etiquetas) 2. Almacenar las etiquetas en una tabla hash o diccionario 3. Cuando llegue el mensaje, consultar la etiqueta para obtener el índice N 4. Eliminar la etiqueta del almacenamiento (uso único) 5. Ampliar la ventana si el recuento de etiquetas cae por debajo del umbral\nEstrategia de anticipación de etiquetas de sesión Propósito: Equilibrar el uso de memoria frente al manejo de mensajes fuera de orden\nTamaños de anticipación recomendados:\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets **Anticipación adaptativa:** # Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 Recortar por detrás:\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 Cálculo de memoria:\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total Manejo de etiquetas de sesión fuera de orden Escenario: Los mensajes llegan fuera de orden\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 Comportamiento del receptor:\nRecibir tag_5:\nBuscar: encontrado en el índice 5 Procesar mensaje Eliminar tag_5 Máximo recibido: 5 Se recibe tag_7 (fuera de orden):\nBúsqueda: encontrado en el índice 7 Procesar el mensaje Eliminar tag_7 Máximo recibido: 7 Nota: tag_6 sigue en almacenamiento (aún no se ha recibido) Recibir tag_6 (retrasado):\nBuscar: encontrado en el índice 6 Procesar mensaje Eliminar tag_6 Máximo recibido: 7 (sin cambios) Recibir tag_8:\nBuscar: encontrado en el índice 8 Procesar mensaje Eliminar tag_8 Máximo recibido: 8 Mantenimiento de la ventana: - Llevar un registro del índice más alto recibido - Mantener una lista de índices faltantes (gaps, huecos) - Ampliar la ventana en función del índice más alto - Opcional: Expirar los huecos antiguos tras un tiempo de espera\nRatchet de clave simétrica (mecanismo de rotación progresiva de claves simétricas) El symmetric key ratchet (mecanismo de avance de clave simétrica) genera claves de cifrado de 32 bytes sincronizadas con etiquetas de sesión.\nPropósito del Symmetric Key Ratchet (mecanismo de avance de clave simétrica) Proporciona una clave de cifrado única para cada mensaje Sincronizado con session tag ratchet (mecanismo de avance de etiquetas de sesión) (mismo índice) El emisor puede generarla bajo demanda El receptor puede aplazar la generación hasta que se reciba la etiqueta Fórmula del Symmetric Key Ratchet (mecanismo de trinquete de clave simétrica) Inicialización:\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived Generación de la clave (para la clave N):\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) Secuencia completa:\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] Implementación del emisor de Symmetric Key Ratchet (trinquete de clave simétrica) class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) Proceso del emisor: 1. Obtener la siguiente etiqueta y su índice N 2. Generar la clave para el índice N 3. Usar la clave para cifrar el mensaje 4. No se requiere almacenamiento de claves\nImplementación del receptor del Symmetric Key Ratchet (mecanismo de avance de clave simétrica) Estrategia 1: Generación diferida (Recomendado)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) Proceso de generación diferida: 1. Recibir ES message (mensaje ES) con etiqueta 2. Consultar la etiqueta para obtener el índice N 3. Generar las claves de 0 a N (si aún no se han generado) 4. Usar la clave N para descifrar el mensaje 5. La clave de cadena ahora se encuentra en el índice N\nVentajas: - Uso mínimo de memoria - Claves generadas solo cuando se necesitan - Implementación simple\nDesventajas: - Debe generar todas las claves de 0 a N la primera vez que se use - No puede procesar mensajes fuera de orden sin almacenamiento en caché\nEstrategia 2: Pregeneración con ventana de etiquetas (Alternativa)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None Proceso de pre-generación: 1. Pre-generar claves que coincidan con la ventana de etiquetas (p. ej., 32 claves) 2. Almacenar las claves indexadas por número de mensaje 3. Cuando se reciba la etiqueta, buscar la clave correspondiente 4. Ampliar la ventana a medida que se utilicen las etiquetas\nVentajas: - Maneja mensajes fuera de orden de forma natural - Recuperación rápida de claves (sin demora de generación)\nDesventajas: - Mayor uso de memoria (32 bytes por clave frente a 8 bytes por etiqueta) - Es necesario mantener las claves sincronizadas con las etiquetas\nComparación de memoria:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB Sincronización del Ratchet (mecanismo de avance criptográfico) simétrico con etiquetas de sesión Requisito crítico: El índice de etiqueta de sesión DEBE ser igual al índice de clave simétrica\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) Modos de fallo:\nSi falla la sincronización: - Clave incorrecta utilizada para el descifrado - La verificación de MAC falla - Mensaje rechazado\nPrevención: - Usa siempre el mismo índice para la etiqueta y la clave - Nunca omitas índices en ninguno de los ratchets (mecanismo de actualización criptográfica) - Gestiona con cuidado los mensajes fuera de orden\nConstrucción del nonce del trinquete simétrico El Nonce (número aleatorio de un solo uso) se deriva del número de mensaje:\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) Ejemplos:\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 Propiedades importantes: - Los Nonces (valores únicos usados una vez) son únicos para cada mensaje en un conjunto de etiquetas - Los Nonces nunca se repiten (las etiquetas de un solo uso lo garantizan) - El contador de 8 bytes permite 2^64 mensajes (solo usamos 2^16) - El formato del Nonce coincide con la construcción basada en contador de la RFC 7539\nGestión de sesiones Contexto de sesión Todas las sesiones entrantes y salientes deben pertenecer a un contexto específico:\nContexto del router: Sesiones para el propio router Contexto de destino: Sesiones para un destino local específico (aplicación cliente) Regla crítica: Las sesiones NO DEBEN compartirse entre contextos para evitar ataques de correlación.\nImplementación:\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) Implementación de I2P en Java:\nEn Java I2P, la clase SessionKeyManager (gestor de claves de sesión) proporciona esta funcionalidad: - Un SessionKeyManager por router - Un SessionKeyManager por destino local - Gestión separada de las sesiones ECIES y ElGamal dentro de cada contexto\nVinculación de sesión Vinculación asocia una sesión con un destino remoto específico.\nSesiones vinculadas Características: - Incluir la clave estática del remitente en el mensaje NS - El destinatario puede identificar el destino del remitente - Permite comunicación bidireccional - Una sola sesión saliente por destino - Puede tener varias sesiones entrantes (durante transiciones)\nCasos de uso: - Conexiones de streaming (similar a TCP) - Datagramas con posibilidad de respuesta - Cualquier protocolo que requiera solicitud/respuesta\nProceso de vinculación:\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) Beneficios: 1. Ephemeral-Ephemeral DH (Diffie-Hellman efímero-efímero): La respuesta usa ee DH (secreto perfecto hacia adelante) 2. Continuidad de sesión: Ratchets (mecanismos de avance criptográfico) mantienen la vinculación con el mismo destino 3. Seguridad: Evita el secuestro de sesión (autenticado por clave estática) 4. Eficiencia: Una sola sesión por destino (sin duplicación)\nSesiones no vinculadas Características: - No hay clave estática en el mensaje NS (la sección de indicadores está compuesta únicamente por ceros) - El destinatario no puede identificar al remitente - Comunicación unidireccional únicamente - Se permiten múltiples sesiones hacia el mismo destino\nCasos de uso: - Datagramas sin formato (enviar y olvidar) - Publicación anónima - Mensajería estilo broadcast (difusión a todos los destinatarios)\nPropiedades: - Más anónimo (sin identificación del remitente) - Más eficiente (1 DH (Diffie-Hellman) vs 2 DH en el handshake) - No es posible responder (el destinatario no sabe dónde responder) - Sin session ratcheting (uso único o limitado)\nEmparejamiento de sesiones Emparejamiento conecta una sesión entrante con una sesión saliente para comunicación bidireccional.\nCreación de sesiones emparejadas Perspectiva de Alice (iniciadora):\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) Perspectiva de Bob (receptor):\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) Beneficios del emparejamiento de sesiones ACKs en banda: Se pueden confirmar mensajes sin un clove separado (clove: submensaje encapsulado) Ratcheting eficiente (mecanismo criptográfico de avance \u0026ldquo;ratchet\u0026rdquo;): Ambas direcciones avanzan el ratchet conjuntamente Control de flujo: Se puede implementar contrapresión a través de sesiones emparejadas Consistencia del estado: Más fácil mantener el estado sincronizado Reglas de emparejamiento de sesiones La sesión saliente puede estar no emparejada (NS no vinculado) La sesión entrante para un NS vinculado debería estar emparejada El emparejamiento ocurre al crear la sesión, no después Las sesiones emparejadas tienen la misma vinculación de destino Los ratchets (mecanismos de avance criptográfico) ocurren de forma independiente pero están coordinados Ciclo de vida de la sesión Ciclo de vida de la sesión: fase de creación Creación de sesión saliente (Alice):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session Creación de sesión entrante (Bob):\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session Ciclo de vida de la sesión: Fase activa Transiciones de estado:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED Mantenimiento activo de la sesión:\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) Ciclo de vida de la sesión: fase de expiración Valores de tiempo de espera de la sesión:\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet **Lógica de expiración:** def check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) Regla crítica: Las sesiones salientes DEBEN expirar antes que las sesiones entrantes para evitar la desincronización.\nTerminación ordenada:\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() Múltiples mensajes NS Escenario: El mensaje NS de Alice se pierde o se pierde la respuesta NSR.\nComportamiento de Alice:\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] Propiedades importantes:\nClaves efímeras únicas: Cada NS usa una clave efímera diferente Negociaciones independientes: Cada NS crea un estado de negociación por separado Correlación de NSR: La etiqueta NSR identifica a qué NS responde Limpieza de estado: Los estados de NS no utilizados se descartan tras una NSR satisfactoria Prevención de ataques:\nPara evitar el agotamiento de recursos:\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context Múltiples mensajes NSR Escenario: Bob envía múltiples NSRs (p. ej., datos de respuesta divididos en varios mensajes).\nComportamiento de Bob:\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES Comportamiento de Alice:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake Limpieza de Bob:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED Propiedades importantes:\nSe permiten múltiples NSRs (solicitudes de sesión Noise): Bob puede enviar múltiples NSRs por cada NS (sesión Noise) Claves efímeras diferentes: Cada NSR debe usar una clave efímera única Mismo conjunto de etiquetas de NSR: Todas las NSRs para una NS usan el mismo conjunto de etiquetas Gana el primer ES (patrón Ephemeral-Static de Noise): El primer ES de Alice determina cuál NSR tuvo éxito Limpieza después del ES: Bob descarta los estados no utilizados tras recibir el ES Máquina de estados de la sesión Diagrama de estados completo:\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED Descripciones de estado:\nNEW: Sesión saliente creada, aún no se ha enviado ningún NS PENDING_REPLY: NS enviado, esperando NSR AWAITING_ES: NSR enviado, esperando el primer ES de Alice ESTABLISHED: Negociación completada, puede enviar/recibir ES ACTIVE: Intercambiando mensajes ES activamente RATCHETING: DH ratchet (mecanismo de avance criptográfico de Diffie-Hellman) en progreso (subconjunto de ACTIVE) EXPIRED: Sesión caducada por tiempo de espera, pendiente de eliminación TERMINATED: Sesión terminada explícitamente Formato de carga útil La sección de carga útil de todos los mensajes ECIES (esquema de cifrado integrado con curvas elípticas) (NS, NSR, ES) utiliza un formato basado en bloques similar a NTCP2.\nEstructura de bloques Formato general:\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Campos:\nblk: 1 byte - Número de tipo de bloque size: 2 bytes - Tamaño del campo de datos en big-endian (0-65516) data: Longitud variable - Datos específicos del bloque Restricciones:\nTamaño máximo de la trama ChaChaPoly: 65535 bytes MAC Poly1305: 16 bytes Tamaño máximo total de bloques: 65519 bytes (65535 - 16) Tamaño máximo de un bloque: 65519 bytes (incluye encabezado de 3 bytes) Tamaño máximo de datos de un bloque: 65516 bytes Tipos de bloques Tipos de bloques definidos:\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension **Manejo de bloques desconocidos:** Las implementaciones DEBEN ignorar los bloques con números de tipo desconocido y tratarlos como relleno. Esto garantiza la compatibilidad con futuras versiones.\nReglas de ordenamiento de bloques Orden de mensajes NS Obligatorio: - El bloque DateTime DEBE ser el primero\nPermitidos: - Garlic Clove (submensaje \u0026ldquo;clove\u0026rdquo; de I2P) (tipo 11) - Opciones (tipo 5) - si está implementado - Relleno (tipo 254)\nProhibido: - NextKey, ACK, ACK Request, Termination, MessageNumbers\nEjemplo de carga útil NS válida:\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) Orden de mensajes de NSR Obligatorio: - Ninguno (la carga útil puede estar vacía)\nPermitidos: - Garlic Clove (submensaje de garlic encryption) (tipo 11) - Opciones (tipo 5) - si está implementado - Relleno (tipo 254)\nProhibido: - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers\nEjemplo de carga útil NSR válida:\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) o\n(empty - ACK only) Orden de mensajes de ES Obligatorio: - Ninguno (la carga útil puede estar vacía)\nPermitidos (en cualquier orden): - Garlic Clove (tipo 11) - NextKey (tipo 7) - ACK (tipo 8) - ACK Request (tipo 9) - Termination (tipo 4) - si se implementa - MessageNumbers (tipo 6) - si se implementa - Options (tipo 5) - si se implementa - Padding (tipo 254)\nReglas especiales: - Termination DEBE ser el último bloque (excepto Padding) - Padding DEBE ser el último bloque - Se permiten múltiples Garlic Cloves (submensajes dentro de un mensaje de garlic encryption) - Se permiten hasta 2 bloques NextKey (directo e inverso) - NO se permiten múltiples bloques de Padding\nEjemplos de cargas útiles ES válidas:\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) Bloque DateTime (Tipo 0) Propósito: Marca de tiempo para la prevención de ataques de repetición y la validación del desfase del reloj\nTamaño: 7 bytes (cabecera de 3 bytes + datos de 4 bytes)\nFormato:\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Campos:\nblk: 0 size: 4 (big-endian, orden de bytes más significativo primero) timestamp: 4 bytes - marca de tiempo Unix en segundos (sin signo, big-endian) Formato de marca de tiempo:\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) Reglas de validación:\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True Prevención de ataques de repetición:\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass Notas de implementación:\nMensajes NS: DateTime DEBE ser el primer bloque Mensajes NSR/ES: DateTime normalmente no se incluye Ventana de repetición: 5 minutos es el mínimo recomendado Filtro de Bloom: Recomendado para una detección eficiente de repeticiones Desfase del reloj: Permitir 5 minutos hacia el pasado, 2 minutos hacia el futuro Bloque Garlic Clove (sub-bloque en garlic encryption) (Tipo 11) Propósito: Encapsula mensajes I2NP para su entrega\nFormato:\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ Campos:\nblk: 11 size: Tamaño total de clove (submensaje dentro de un garlic message) (variable) Delivery Instructions: Como se especifica en la especificación de I2NP type: Tipo de mensaje I2NP (1 byte) Message_ID: ID de mensaje I2NP (4 bytes) Expiration: Marca de tiempo Unix en segundos (4 bytes) I2NP Message body: Datos de mensaje de longitud variable Formatos de instrucciones de entrega:\nEntrega local (1 byte):\n+----+ |0x00| +----+ Entrega al destino (33 bytes):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Entrega al router (33 bytes):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Entrega vía Tunnel (37 bytes):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ Encabezado de mensaje de I2NP (9 bytes en total):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: Tipo de mensaje I2NP (Database Store, Database Lookup, Data, etc.) msg_id: identificador de mensaje de 4 bytes expiration: marca de tiempo Unix de 4 bytes (segundos) Diferencias importantes con respecto al formato Clove (submensaje en I2P) de ElGamal:\nSin certificado: Se omite el campo de certificado (no se utiliza en ElGamal) Sin Clove ID: Se omite el Clove ID (siempre era 0) Sin expiración de Clove: En su lugar, se utiliza la expiración del mensaje I2NP Encabezado compacto: Encabezado I2NP de 9 bytes frente al formato ElGamal más grande Cada Clove (submensaje dentro de garlic encryption) es un bloque separado: No hay estructura CloveSet Múltiples Cloves (submensajes dentro de un mensaje garlic):\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] Tipos comunes de mensajes I2NP en Cloves (submensajes dentro de garlic encryption):\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages **Procesamiento de Clove (diente de ajo):** def process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) Bloque NextKey (Tipo 7) Propósito: intercambio de claves mediante DH ratchet (mecanismo de avance de Diffie-Hellman)\nFormato (Clave presente - 38 bytes):\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ Formato (solo ID de clave - 6 bytes):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ Campos:\nblk: 7 size: 3 (solo ID) o 35 (con clave) flag: 1 byte - Bits de bandera key ID: 2 bytes - Identificador de clave Big-endian (byte más significativo primero) (0-32767) Public Key: 32 bytes - Clave pública X25519 (little-endian; byte menos significativo primero), si el bit 0 de la bandera = 1 Bits de bandera:\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) Ejemplos de banderas:\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 Reglas del identificador de clave:\nLos ID son secuenciales: 0, 1, 2, \u0026hellip;, 32767 El ID solo se incrementa cuando se genera una nueva clave Se usa el mismo ID para varios mensajes hasta el próximo ratchet (mecanismo de trinquete) El ID máximo es 32767 (después hay que iniciar una sesión nueva) Ejemplos de uso:\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) Lógica de procesamiento:\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) Múltiples NextKey Blocks (bloques NextKey):\nUn único mensaje ES puede contener hasta 2 bloques NextKey cuando ambas direcciones están realizando ratcheting (avance de claves tipo “ratchet”) simultáneamente:\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] Bloque ACK (Tipo 8) Propósito: Confirmar la recepción de mensajes en banda\nFormato (ACK único - 7 bytes):\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ Formato (Múltiples ACKs):\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Campos:\nblk: 8 size: 4 * número de ACKs (confirmaciones) (mínimo 4) Para cada ACK: tagsetid: 2 bytes - ID del conjunto de etiquetas en Big-endian (0-65535) N: 2 bytes - número de mensaje en Big-endian (0-65535) Determinación del ID del conjunto de etiquetas:\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 Ejemplo de ACK único:\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) Ejemplo de múltiples ACK (confirmaciones):\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) Procesamiento:\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) Cuándo enviar acuses de recibo:\nACK Request explícita: Responda siempre al bloque ACK Request (ACK: acuse de recibo) Entrega de LeaseSet: Cuando el remitente incluye el LeaseSet en el mensaje Establecimiento de sesión: Puede enviar un ACK a NS/NSR (aunque el protocolo prefiere un ACK implícito vía ES) Confirmación de ratchet (mecanismo de avance criptográfico): Puede enviar ACK al recibir NextKey Capa de aplicación: Según lo requiera el protocolo de capa superior (p. ej., Streaming) Temporización de ACK:\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None Bloque de solicitud de ACK (Tipo 9) Propósito: Solicitar acuse de recibo en banda del mensaje actual\nFormato:\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ Campos:\nblk: 9 size: 1 flg: 1 byte - Indicadores (todos los bits actualmente sin uso, establecidos en 0) Uso:\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] Respuesta del receptor:\nCuando se recibe ACK Request (petición de acuse de recibo):\nCon Immediate Data (datos inmediatos): Incluir el bloque ACK en la respuesta inmediata Sin Immediate Data: Iniciar un temporizador (p. ej., 100 ms) y enviar un ES vacío con ACK si el temporizador expira Tag Set ID (ID del conjunto de etiquetas): Usar el ID de tagset entrante actual Número de mensaje: Usar el número de mensaje asociado con la session tag (etiqueta de sesión) recibida Procesamiento:\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) Cuándo usar ACK Request (solicitud de acuse de recibo):\nMensajes críticos: Mensajes que requieren acuse de recibo Entrega de LeaseSet: Al incluir un LeaseSet Session Ratchet (mecanismo de avance de claves de sesión): Después de enviar el NextKey block (bloque para la siguiente clave) Fin de la transmisión: Cuando el emisor no tiene más datos que enviar pero quiere confirmación Cuándo NO usarlo:\nProtocolo de streaming: La capa de streaming gestiona los ACKs (confirmaciones de recepción) Mensajes de alta frecuencia: Evite la solicitud de ACK en cada mensaje (sobrecarga) Datagramas no importantes: Los datagramas sin formato por lo general no necesitan ACKs Bloque de Terminación (Tipo 4) Estado: SIN IMPLEMENTAR\nPropósito: Finalizar la sesión de forma ordenada\nFormato:\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ Campos:\nblk: 4 size: 1 o más bytes rsn: 1 byte - Código de motivo addl data: Datos adicionales opcionales (el formato depende del motivo) Códigos de motivo:\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific **Uso (cuando se implemente):** # Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) Reglas:\nDEBE ser el último bloque excepto Padding (relleno) Padding DEBE seguir a Termination (terminación) si está presente No permitido en mensajes NS o NSR Solo permitido en mensajes ES Bloque de opciones (Tipo 5) Estado: SIN IMPLEMENTAR\nPropósito: Negociar parámetros de sesión\nFormato:\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Campos:\nblk: 5 size: 21 bytes o más ver: 1 byte - Versión del protocolo (debe ser 0) flg: 1 byte - Indicadores (todos los bits actualmente sin usar) STL: 1 byte - Longitud de la etiqueta de sesión (debe ser 8) STimeout: 2 bytes - Tiempo de espera de inactividad de la sesión en segundos (big-endian) SOTW: 2 bytes - Ventana de etiquetas salientes del remitente (big-endian) RITW: 2 bytes - Ventana de etiquetas entrantes del receptor (big-endian) tmin, tmax, rmin, rmax: 1 byte cada uno - Parámetros de relleno (punto fijo 4.4) tdmy: 2 bytes - Tráfico de relleno máximo que está dispuesto a enviar (bytes/s, big-endian) rdmy: 2 bytes - Tráfico de relleno solicitado (bytes/s, big-endian) tdelay: 2 bytes - Retraso intra-mensaje máximo que está dispuesto a insertar (ms, big-endian) rdelay: 2 bytes - Retraso intra-mensaje solicitado (ms, big-endian) more_options: Variable - Extensiones futuras Parámetros de relleno (formato de punto fijo 4.4):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) Negociación de la ventana de etiquetas:\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size Valores predeterminados (cuando no se negocian opciones):\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } Bloque MessageNumbers (Tipo 6) Estado: NO IMPLEMENTADO\nPropósito: Indicar el último mensaje enviado en el conjunto de etiquetas anterior (permite la detección de huecos)\nFormato:\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ Campos:\nblk: 6 size: 2 PN: 2 bytes - Número del último mensaje del conjunto de etiquetas anterior (big-endian (orden de bytes de mayor a menor significancia), 0-65535) Definición de PN (Número anterior):\nPN es el índice de la última etiqueta enviada en el conjunto de etiquetas anterior.\nUso (cuando esté implementado):\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] Beneficios para el receptor:\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) Reglas:\nNO DEBE enviarse en el conjunto de etiquetas 0 (no hay conjunto de etiquetas previo) Solo se envía en mensajes ES Solo se envía en el/los primer(os) mensaje(s) de un nuevo conjunto de etiquetas El valor PN es desde la perspectiva del remitente (última etiqueta que envió el remitente) Relación con Signal:\nEn Signal Double Ratchet (protocolo de doble trinquete de Signal), PN está en la cabecera del mensaje. En ECIES, está en la carga útil cifrada y es opcional.\nBloque de relleno (Tipo 254) Propósito: Resistencia al análisis de tráfico y ofuscación del tamaño de los mensajes\nFormato:\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Campos:\nblk: 254 size: 0-65516 bytes (big-endian, más significativo primero) padding: Datos aleatorios o ceros Reglas:\nDEBE ser el último bloque del mensaje NO se permiten múltiples bloques de relleno Puede tener longitud cero (solo encabezado de 3 bytes) Los datos de relleno pueden ser ceros o bytes aleatorios Relleno predeterminado:\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) Estrategias de resistencia al análisis de tráfico:\nEstrategia 1: Tamaño aleatorio (predeterminado)\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Estrategia 2: Redondear a un múltiplo\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Estrategia 3: Tamaños de mensajes fijos\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Estrategia 4: Relleno negociado (Options block)\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Mensajes solo de relleno:\nLos mensajes pueden consistir completamente en relleno (sin datos de la aplicación):\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] Notas de implementación:\nRelleno de ceros: Aceptable (será cifrado por ChaCha20) Relleno aleatorio: No aporta seguridad adicional tras el cifrado, pero consume más entropía Rendimiento: La generación de relleno aleatorio puede ser costosa; considere usar ceros Memoria: Los bloques de relleno grandes consumen ancho de banda; tenga cuidado con el tamaño máximo Guía de implementación Requisitos previos Bibliotecas criptográficas:\nX25519 (intercambio de claves de curva elíptica): libsodium, NaCl o Bouncy Castle ChaCha20-Poly1305 (algoritmo AEAD: cifrado ChaCha20 con autenticación Poly1305): libsodium, OpenSSL 1.1.0+ o Bouncy Castle SHA-256 (función hash criptográfica de 256 bits): OpenSSL, Bouncy Castle o soporte integrado en el lenguaje Elligator2 (técnica de ofuscación de puntos en curvas elípticas): Soporte limitado en bibliotecas; puede requerir una implementación personalizada Implementación de Elligator2 (método de mapeo uniforme a curvas elípticas para ofuscación):\nElligator2 (técnica criptográfica para ocultar claves públicas) no está ampliamente implementado. Opciones:\nOBFS4: El pluggable transport (mecanismo de transporte modular) obfs4 de Tor incluye una implementación de Elligator2 Implementación personalizada: Basada en Elligator2 paper kleshni/Elligator: Implementación de referencia en GitHub Nota sobre Java I2P: Java I2P usa la biblioteca net.i2p.crypto.eddsa con extensiones personalizadas de Elligator2 (técnica criptográfica para camuflar claves públicas).\nOrden recomendado de implementación Fase 1: Criptografía fundamental 1. Generación e intercambio de claves DH X25519 2. Cifrado/descifrado con AEAD ChaCha20-Poly1305 3. Cálculo de hash SHA-256 y MixHash 4. Derivación de claves mediante HKDF 5. Codificación/decodificación Elligator2 (se pueden usar vectores de prueba inicialmente)\nFase 2: Formatos de mensajes 1. mensaje NS (no vinculado) - formato más simple 2. mensaje NS (vinculado) - añade clave estática 3. mensaje NSR 4. mensaje ES 5. Análisis y generación de bloques\nFase 3: Gestión de sesión 1. Creación y almacenamiento de sesión 2. Gestión del conjunto de etiquetas (emisor y receptor) 3. Ratchet (mecanismo de avance) de etiquetas de sesión 4. Ratchet de clave simétrica 5. Búsqueda de etiquetas y gestión de la ventana\nFase 4: DH Ratcheting (avance de claves con Diffie-Hellman) 1. Gestión del bloque NextKey 2. Función de derivación de claves (KDF) de DH ratchet 3. Creación del conjunto de etiquetas después del ratchet 4. Gestión de múltiples conjuntos de etiquetas\nFase 5: Lógica del protocolo 1. Máquina de estados NS/NSR/ES 2. Prevención de ataques de repetición (DateTime, filtro de Bloom) 3. Lógica de retransmisión (múltiples NS/NSR) 4. Gestión de ACK (acuse de recibo)\nFase 6: Integración 1. Procesamiento de I2NP Garlic Clove (unidad individual dentro de un mensaje de garlic encryption) 2. Agrupación de LeaseSet 3. Integración del protocolo de streaming 4. Integración del protocolo de datagramas\nImplementación del emisor Ciclo de vida de la sesión saliente:\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() Implementación del receptor Ciclo de vida de la sesión entrante:\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() Clasificación de mensajes Distinción de tipos de mensajes:\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type Mejores prácticas de gestión de sesiones Almacenamiento de sesión:\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] Gestión de memoria:\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 Estrategias de prueba Pruebas unitarias:\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 Pruebas de integración:\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 Vectores de prueba:\nImplementar vectores de prueba de la especificación:\nNoise IK Handshake: Use vectores de prueba estándar de Noise HKDF: Use vectores de prueba del RFC 5869 ChaCha20-Poly1305: Use vectores de prueba del RFC 7539 Elligator2: Use vectores de prueba del artículo de Elligator2 o de OBFS4 Pruebas de interoperabilidad:\nJava I2P: Probar frente a la implementación de referencia de Java I2P i2pd: Probar frente a la implementación de i2pd en C++ Capturas de paquetes: Usar el disector de Wireshark (si está disponible) para verificar los formatos de mensajes Entre implementaciones: Crear un banco de pruebas que pueda enviar/recibir entre implementaciones Consideraciones de rendimiento Generación de claves:\nLa generación de claves mediante Elligator2 (técnica criptográfica) es costosa (tasa de rechazo del 50%):\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() Búsqueda de etiquetas:\nUtiliza tablas hash para la búsqueda de etiquetas en O(1):\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) Optimización de memoria:\nDiferir la generación de claves simétricas:\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key Procesamiento por lotes:\nProcesar múltiples mensajes por lotes:\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results Consideraciones de seguridad Modelo de amenazas Capacidades del adversario:\nObservador pasivo: Puede observar todo el tráfico de la red Atacante activo: Puede inyectar, modificar, descartar y repetir mensajes Nodo comprometido: Puede comprometer un router o un destino Análisis de tráfico: Puede realizar análisis estadístico de los patrones de tráfico Objetivos de seguridad:\nConfidencialidad: Contenido del mensaje oculto para el observador Autenticación: Identidad del remitente verificada (para sesiones vinculadas) Secreto perfecto hacia adelante: Los mensajes pasados permanecen secretos incluso si se comprometen las claves Prevención de repetición: No se pueden repetir mensajes antiguos Ofuscación del tráfico: Los handshakes son indistinguibles de datos aleatorios Supuestos criptográficos Suposiciones de dificultad:\nX25519 CDH: El problema de Diffie-Hellman computacional es difícil en Curve25519 ChaCha20 PRF: ChaCha20 es una función pseudoaleatoria Poly1305 MAC: Poly1305 es inforjable bajo ataque de mensaje elegido SHA-256 CR: SHA-256 es resistente a colisiones HKDF Security: HKDF extrae y expande claves distribuidas uniformemente Niveles de seguridad:\nX25519: seguridad de ~128 bits (orden de la curva 2^252) ChaCha20: claves de 256 bits, seguridad de 256 bits Poly1305: seguridad de 128 bits (probabilidad de colisión) SHA-256: resistencia a colisiones de 128 bits, resistencia a preimagen de 256 bits Gestión de claves Generación de claves:\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) Almacenamiento de claves:\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] Rotación de claves:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age Mitigaciones de ataques Mitigaciones contra ataques de repetición Validación de fecha y hora:\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True Filtro de Bloom para mensajes NS:\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] Uso único de Session Tag (etiquetas de sesión):\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index Mitigaciones contra la suplantación por compromiso de clave (KCI) Problema: La autenticación de los mensajes NS es vulnerable a KCI (suplantación por compromiso de clave) (Nivel de autenticación 1)\nMitigación:\nRealiza la transición a NSR (Nivel 2 de autenticación) lo antes posible No confíes en la carga útil de NS para operaciones críticas de seguridad Espera la confirmación de NSR antes de realizar acciones irreversibles def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) Medidas de mitigación contra la denegación de servicio Protección contra inundaciones de NS:\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 Límites de almacenamiento de etiquetas:\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count Gestión adaptativa de recursos:\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } Resistencia al análisis de tráfico Codificación Elligator2:\nGarantiza que los mensajes de negociación (handshake) sean indistinguibles de datos aleatorios:\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string Estrategias de relleno:\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) Ataques de temporización:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) Escollos de implementación Errores comunes:\nReutilización de nonce (número usado una vez): NUNCA reutilices pares (key, nonce) # BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC CORRECTO: Nonce (número único de uso) diferente para cada mensaje ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) 2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR ```python # MAL: Reutilizar una clave efímera ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # MAL # CORRECTO: Clave nueva para cada mensaje send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator MAL: Generador de números aleatorios no criptográfico import random key = bytes([random.randint(0, 255) for _ in range(32)]) # INSEGURO BUENO: generador de números aleatorios criptográficamente seguro import os key = os.urandom(32) 4. **Timing Attacks**: Use constant-time comparisons ```python # MAL: Comparación con salida temprana if computed_mac == received_mac: # Fuga de temporización pass # CORRECTO: Comparación en tiempo constante if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data MAL: Descifrar antes de verificar plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # DEMASIADO TARDE if not mac_ok: return error CORRECTO: AEAD (cifrado autenticado con datos asociados) verifica antes de descifrar try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError:\nreturn error 6. **Key Deletion**: Securely wipe keys from memory ```python # MAL: Eliminación simple del private_key # Sigue en memoria # CORRECTO: Sobrescribir antes de eliminar for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# Casos de prueba críticos para la seguridad def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# Solo ECIES (esquema integrado de cifrado en curvas elípticas) (recomendado para nuevos despliegues) i2cp.leaseSetEncType=4 # Doble clave (ECIES + ElGamal por compatibilidad) i2cp.leaseSetEncType=4,0 # Solo ElGamal (heredado, no recomendado) i2cp.leaseSetEncType=0 LeaseSet Type:\n# LS2 estándar (el más común) i2cp.leaseSetType=3 # LS2 cifrado (destinos cegados) i2cp.leaseSetType=5 # Meta LS2 (múltiples destinos) i2cp.leaseSetType=7 Additional Options:\n# Clave estática para ECIES (esquema de cifrado integrado de curva elíptica) (opcional, se genera automáticamente si no se especifica) # Clave pública X25519 de 32 bytes, codificada en base64 i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # Tipo de firma (para LeaseSet) i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# ECIES de router a router (Esquema de Cifrado Integrado de Curva Elíptica) i2p.router.useECIES=true Build Properties:\n// Para clientes I2CP (Java) Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[límites] # Límite de memoria para sesiones ECIES (esquema de cifrado integrado de curva elíptica) ecies.memory = 128M [ecies] # Habilitar ECIES (esquema de cifrado integrado de curva elíptica) enabled = true # Solo ECIES (esquema de cifrado integrado basado en curvas elípticas) o de doble clave compatibility = true # true = doble clave, false = solo ECIES Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Solo ECIES (Esquema Integrado de Cifrado de Curva Elíptica) ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# Añadir ECIES manteniendo ElGamal i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# Comprobar tipos de conexión i2prouter.exe status # o http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# Eliminar ElGamal i2cp.leaseSetEncType=4 Step 4: Restart Application\n# Reiniciar el router I2P o la aplicación systemctl restart i2p # o i2prouter.exe restart Rollback Plan:\n# Volver a usar únicamente ElGamal si hay problemas i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# Máximo de sesiones entrantes i2p.router.maxInboundSessions=1000 # Número máximo de sesiones salientes i2p.router.maxOutboundSessions=1000 # Tiempo de espera de la sesión (segundos) i2p.router.sessionTimeout=600 Memory Limits:\n# Límite de almacenamiento de etiquetas (KB) i2p.ecies.maxTagMemory=10240 # 10 MB # Ventana de anticipación i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# Mensajes antes del ratchet (mecanismo de avance criptográfico) i2p.ecies.ratchetThreshold=4096 # Tiempo antes del ratchet (mecanismo de avance criptográfico) (segundos) i2p.ecies.ratchetTimeout=600 # 10 minutos Monitoring and Debugging Logging:\n# Habilitar el registro de depuración de ECIES (esquema integrado de cifrado basado en curvas elípticas) logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # Ejemplos print(\u0026#34;NS (vinculado, carga útil de 1KB):\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;bytes\u0026#34;) # Salida: 1120 bytes print(\u0026#34;NSR (carga útil de 1KB):\u0026#34;, calculate_nsr_size(1024), \u0026#34;bytes\u0026#34;) # Salida: 1096 bytes print(\u0026#34;ES (carga útil de 1KB):\u0026#34;, calculate_es_size(1024), \u0026#34;bytes\u0026#34;) # Salida: 1048 bytes Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"Esquema de cifrado integrado de curva elíptica para I2P (X25519 + AEAD)","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"Especificación de cifrado ECIES-X25519-AEAD-Ratchet (mecanismo de trinquete criptográfico)","url":"/es/docs/specs/ecies/"},{"categories":null,"content":"1. Descripción general SSU2 es un protocolo de la capa de transporte basado en UDP, utilizado para una comunicación segura y con fiabilidad parcial de router a router en I2P. No es un transporte de propósito general, sino que está especializado en el intercambio de mensajes de I2NP.\nCapacidades fundamentales Intercambio de claves autenticado mediante Noise XK pattern (patrón XK de Noise) Encabezados cifrados para resistencia frente a la DPI (inspección profunda de paquetes) Atravesamiento de NAT usando relés y hole-punching (perforación NAT) Migración de conexiones y validación de direcciones Validación de ruta opcional Secreto perfecto hacia adelante (PFS) y protección contra ataques de repetición Legado y compatibilidad Implementation SSU2 Default SSU1 Removed i2pd2.44.02.44.0 Java I2P0.9.560.9.61 SSU1 ya no se utiliza en toda la red pública de I2P. 2. Criptografía SSU2 usa Noise_XK_25519_ChaChaPoly_SHA256 con extensiones específicas de I2P.\nFunction Algorithm Notes Diffie-HellmanX25519 (RFC 7748)32-byte keys CipherChaCha20/Poly1305 (RFC 7539)AEAD encryption HashSHA-256Used for key derivation and message integrity KDFHKDF-SHA256 (RFC 5869)For session and header keys Las cabeceras y las cargas útiles están vinculadas criptográficamente mediante `mixHash()`. Todas las primitivas criptográficas se comparten con NTCP2 y ECIES para mejorar la eficiencia de la implementación. 3. Descripción general de los mensajes 3.1 Reglas de datagramas UDP Cada datagrama UDP transporta exactamente un mensaje SSU2. Los mensajes Session Confirmed (confirmación de sesión) pueden fragmentarse en varios datagramas. Tamaño mínimo: 40 bytes Tamaño máximo: 1472 bytes (IPv4) / 1452 bytes (IPv6)\n3.2 Tipos de mensajes Type Message Header Description 0Session Request32BHandshake initiation 1Session Created32BHandshake response 2Session Confirmed16BFinal handshake, may be fragmented 6Data16BEncrypted I2NP message blocks 7Peer Test32BNAT reachability testing 9Retry32BToken or rejection notice 10Token Request32BRequest for validation token 11Hole Punch32BNAT traversal signaling --- 4. Establecimiento de sesión 4.1 Flujo estándar (token válido) Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 Obtención de tokens Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 Token no válido Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. Estructuras de encabezado 5.1 Cabecera larga (32 bytes) Se utiliza antes del establecimiento de la sesión (SessionRequest, Created, Retry, PeerTest, TokenRequest, HolePunch).\nField Size Description Destination Connection ID8Random unique ID Packet Number4Random (ignored during handshake) Type1Message type Version1Always 2 NetID12 = main I2P network Flags1Reserved (0) Source Connection ID8Random ID distinct from destination Token8Token for address validation ### 5.2 Cabecera corta (16 bytes) Se usa durante sesiones establecidas (SessionConfirmed, Data).\nField Size Description Destination Connection ID8Stable throughout session Packet Number4Incrementing per message Type1Message type (2 or 6) Flags3ACK/fragment flags --- 6. Cifrado 6.1 AEAD (cifrado autenticado con datos asociados) Todas las cargas útiles están cifradas con ChaCha20/Poly1305 AEAD (cifrado autenticado con datos asociados):\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) Nonce (número único de uso): 12 bytes (4 ceros + 8 de contador) Etiqueta: 16 bytes Datos asociados: incluye el encabezado para la vinculación de integridad 6.2 Protección del encabezado Los encabezados se enmascaran utilizando un flujo de claves ChaCha20 derivado de las claves de encabezado de sesión. Esto garantiza que todos los ID de conexión y los campos de los paquetes parezcan aleatorios, proporcionando resistencia al DPI (Deep Packet Inspection, inspección profunda de paquetes).\n6.3 Derivación de claves Phase Input Output InitialintroKey + salthandshake header key HandshakeDH(X25519)chainKey + AEAD key Data phasechainKeyTX/RX keys Key rotationoldKeynewKey --- 7. Seguridad y prevención de ataques de repetición Los tokens son por IP y caducan en ~60 segundos. Las repeticiones (ataques de repetición) se previenen mediante filtros de Bloom por sesión. Se rechazan las claves efímeras duplicadas. Los encabezados y las cargas útiles están criptográficamente vinculados. Los routers deben descartar cualquier paquete que falle la autenticación AEAD o que tenga una versión no válida o un NetID no válido.\n8. Numeración de paquetes y vida útil de la sesión Cada sentido mantiene su propio contador de 32 bits. - Empieza en 0, se incrementa con cada paquete. - No debe hacer wrap (volver a 0); realizar session rekey (rotación de la clave de la sesión) o terminar antes de llegar a 2³².\nLos identificadores de conexión permanecen estáticos durante toda la sesión, incluso durante la migración.\n9. Fase de datos Tipo = 6 (Datos) Encabezado corto (16 bytes) La carga útil contiene uno o más bloques cifrados: Listas ACK/NACK Fragmentos de mensajes I2NP Relleno (0–31 bytes aleatorios) Bloques de terminación (opcional) Se admiten la retransmisión selectiva y la entrega fuera de orden. La fiabilidad sigue siendo “semi-reliable” (semiconfiable) — los paquetes perdidos pueden descartarse silenciosamente después de alcanzar los límites de reintento.\n10. Retransmisión y atravesamiento de NAT Message Type Purpose Peer Test7Determines inbound reachability Retry9Issues new token or rejection Token Request10Requests new address token Hole Punch11Coordinates NAT hole punching Los routers de retransmisión ayudan a los pares detrás de NATs restrictivos mediante estos mensajes de control. 11. Terminación de la sesión Cualquiera de los pares puede cerrar la sesión usando un Termination block (bloque de terminación) dentro de un mensaje Data (mensaje de datos). Los recursos deben liberarse inmediatamente tras la recepción. Los paquetes de terminación repetidos pueden ignorarse después del acuse de recibo.\n12. Directrices de implementación Routers DEBEN: - Validar versión = 2 y NetID = 2. - Descartar paquetes \u0026lt;40 bytes o AEAD no válido. - Aplicar caché de repetición de 120s. - Rechazar tokens reutilizados o claves efímeras.\nRouters DEBERÍAN: - Aleatorizar el relleno de 0–31 bytes. - Usar retransmisión adaptativa (RFC 6298). - Implementar validación de ruta por par antes de la migración.\n13. Resumen de seguridad Property Achieved By Forward secrecyX25519 ephemeral keys Replay protectionTokens + Bloom filter Authenticated encryptionChaCha20/Poly1305 KCI resistanceNoise XK pattern DPI resistanceEncrypted headers NAT traversalRelay + Hole Punch MigrationStatic connection IDs --- 14. Referencias Propuesta 159 – SSU2 Marco del protocolo Noise RFC 9000 – Transporte QUIC RFC 9001 – TLS para QUIC RFC 7539 – ChaCha20/Poly1305 AEAD RFC 7748 – X25519 ECDH RFC 5869 – HKDF-SHA256 ","description":"Protocolo de transporte UDP seguro y parcialmente fiable Versión 2","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"Especificación de SSU2","url":"/es/docs/specs/ssu2/"},{"categories":null,"content":"Descripción general Este documento especifica un esquema de firma re-aleatorizable, adecuado para crear Destinos que pueden ser cegados. Además, puede utilizarse para cegar Destinos Ed25519 existentes, con una ligera reducción de eficacia.\nRed25519 ha estado totalmente operativo en los routers de I2P desde la versión 0.9.39 (publicada el 21 de marzo de 2019). Esta especificación se finalizó en la versión 0.9.47 (agosto de 2020) tras 17 meses de despliegue en producción. El esquema de firma opera como tipo de firma 11 (RedDSA_SHA512_Ed25519) en la red I2P.\nMotivación La Propuesta 123 (New netDB Entries) define un formato LeaseSet2 cifrado que materializa el Principio de mínima autoridad: a cada participante de la red se le proporciona únicamente la información necesaria para su función. En particular, un LeaseSet2 cifrado publicado en un floodfill no revela el Destino al que corresponde, y los Leases solo pueden ser vistos por alguien con conocimiento previo del Destino. Sin embargo, los floodfills siguen necesitando poder autenticar los LeaseSet2 cifrados cuando se publican, y los clientes, además, deben asegurarse de que la autenticación haya sido aplicada por el propio Destino.\nLa Propuesta 123 lo consigue al cegar las claves de firma de los Destinos. Las claves cegadas pueden usarse para crear firmas verificables por los floodfills, y los clientes pueden estar seguros de que solo el Destino podría haber creado las firmas. Por lo tanto, es necesario especificar un esquema de firma que pueda utilizarse para el cegado.\nNota sobre el estado de la Propuesta 123: Partes de la Propuesta 123 se han implementado y desplegado progresivamente desde la versión 0.9.38, y se añadió compatibilidad con Red25519 (curva criptográfica) en la 0.9.39. La funcionalidad cifrada de LeaseSet2 está lista para producción y se utiliza activamente en la red I2P para servicios ocultos con privacidad mejorada.\nDiseño Esquema de firma principal El esquema de firma especificado aquí, Red25519, es una instanciación de RedDSA tal como se define en la Sección 5.4.6 de la Especificación del Protocolo de Zcash (Sapling y posteriores). RedDSA es un esquema de firma basado en Schnorr que admite key re-randomization (re-aleatorización de claves). Tiene las siguientes funciones:\nGENERATE_PRIVATE() : Devuelve una clave privada aleatoria con distribución uniforme.\nDERIVE_PUBLIC(sk) : Devuelve la clave pública correspondiente a la clave privada proporcionada.\nGENERATE_RANDOM() : Devuelve un escalar aleatorio adecuado para volver a aleatorizar un par de claves.\nRANDOMIZE_PRIVATE(sk, alpha) : Re-aleatoriza una clave privada, utilizando un escalar secreto alpha.\nRANDOMIZE_PUBLIC(vk, alpha) : Vuelve a aleatorizar una clave pública, utilizando un escalar secreto alpha.\nSIGN(sk, m) : Devuelve una firma con la clave privada sk sobre el mensaje m dado.\nVERIFY(vk, m, sig) : Verifica la firma sig frente a la clave pública vk y el mensaje m. Devuelve verdadero si la firma es válida, falso en caso contrario.\nPara un par de claves dado (sk, vk) se cumple la siguiente relación:\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) Conversión de claves Ed25519 a Red25519 Las claves Ed25519 PUEDEN convertirse temporalmente y de forma unidireccional en claves Red25519, con el fin de admitir la re-aleatorización de Destinos Ed25519 existentes. Otros tipos de firma no son compatibles.\nDefinimos las siguientes funciones de conversión:\nCONVERT_ED25519_PRIVATE(privkey) : Devuelve la clave privada Red25519 correspondiente a la clave privada Ed25519 dada.\nCONVERT_ED25519_PUBLIC(pubkey) : Devuelve la clave pública Red25519 correspondiente a la clave pública Ed25519 dada.\nPara un par de claves Ed25519 dado (privkey, pubkey), se cumple la siguiente relación:\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) Especificación Definiciones B : El punto base de Ed25519 según RFC 8032 .\nL : El orden de Ed25519 2^252 + 27742317777372353535851937790883648493 como en RFC 8032 .\n[s] B : Multiplicación escalar de base fija del punto base por s.\n[s] A : Multiplicación escalar de base variable de A por s.\nx || y : Concatenar dos arrays de bytes x e y.\nRed25519 El esquema Red25519 es una especialización de RedDSA (un esquema de firma digital) con:\nG := el grupo de puntos en la forma de Edwards de Curve25519. En particular, esto significa que Red25519 utiliza el subgrupo de orden primo L, y el cofactor h_G es 8. P_G := el punto base B de Ed25519. l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) Nota sobre la elección de la función hash: Red25519 usa SHA-512 en lugar de BLAKE2b-512 (como en Zcash RedDSA). Esta decisión de diseño se compensa con la protección mediante prefijo de longitud descrita más abajo. I2P Proposal 148 sugiere una migración futura a BLAKE2b-512 para una protección mejorada contra Duplicate Message Identification (identificación duplicada de mensajes, DMI) y Length Extension Attacks (ataques de extensión de longitud, LEA), además de un mejor rendimiento.\nRedDSA asume que H(x) se implementa con una función hash criptográfica segura frente a ataques de extensión de longitud. SHA-512 no cumple este requisito por sí misma. Para remediarlo, requerimos que a los mensajes se les anteponga una codificación libre de prefijos de su longitud:\nlen_u16(M) || M donde len_u16(M) es la representación de 2 bytes de la longitud de M, en little-endian (orden de bytes de menor a mayor; para ser coherente con la codificación little-endian de escalares y puntos).\nLos mensajes no deben exceder los 65534 bytes. Una longitud de 65535 está reservada para posibles extensiones futuras.\nNota de seguridad: La inclusión de la clave pública (vk) en la función hash, combinada con 80 bytes aleatorios en la firma, garantiza protección contra vulnerabilidades SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack; inafalsificabilidad fuerte con claves re-aleatorizadas bajo ataque de mensaje elegido) descubiertas en diseños tempranos de RedDSA. Esta implementación incorpora las correcciones de seguridad de la auditoría de Zcash de NCC Group (Hallazgo NCC-Zcash2018-009).\nCodificación y decodificación Las claves privadas de Red25519 son escalares módulo L, y se codifican en representación little-endian. Definimos las funciones DECODE_SCALAR y ENCODE_SCALAR para convertir entre el arreglo de bytes y la representación entera de un escalar.\nLas claves públicas Red25519 son puntos en la forma de Edwards de Curve25519. Se codifican como la representación little-endian de 255 bits de la coordenada y, seguida de un único bit que indica el signo de la coordenada x. Esta es la misma codificación que la de Ed25519. Definimos las funciones DECODE_POINT y ENCODE_POINT para convertir entre la forma de arreglo de bytes y la forma de coordenadas de un punto.\nFunciones de RedDSA Para facilitar la implementación, a continuación detallamos explícitamente las funciones RedDSA (esquema de firma digital de Zcash), así como varias funciones auxiliares, ya especializadas para Red25519 (parámetros específicos usados por RedDSA). Quienes implementen deben consultar la sección 5.4.6 de la Especificación del Protocolo de Zcash para la especificación general de las funciones RedDSA.\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() Funciones de conversión CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey Tenga en cuenta que la implementación de CONVERT_ED25519_PRIVATE es equivalente al cálculo del escalar secreto s al derivar una clave pública Ed25519 a partir de una clave privada Ed25519, según se especifica en los pasos 1-3 de la sección 5.1.5 de RFC 8032 .\nImplicaciones de seguridad Volver a aleatorizar un Destino Red25519 y luego crear firmas con él no filtra ninguna información sobre el Destino, porque la distribución de las claves privadas Red25519 generadas mediante RANDOMIZE_PRIVATE es idéntica a la distribución de las claves privadas generadas mediante GENERATE_PRIVATE, y DERIVE_PUBLIC es determinista.\nConvertir claves privadas Ed25519 (algoritmo de firma digital de curva elíptica) a Red25519 (variante relacionada de Ed25519) mediante CONVERT_ED25519_PRIVATE no produce la misma distribución. Sin embargo, consideramos aceptable la reducción de la seguridad por las siguientes razones:\nEl espacio de Ed25519 scalars (escalares de Ed25519) es aproximadamente la mitad del tamaño del espacio de Red25519 scalars (escalares de Red25519) (hay 2^251 Ed25519 scalars posibles, y L ~= 2^252 Red25519 scalars posibles). Por lo tanto, la pérdida de seguridad es como máximo de un factor de alrededor de 2, o de alrededor de 1 bit (porque podríamos haber elegido por casualidad un Red25519 scalar que también sea un Ed25519 scalar válido). Los Destinos Ed25519 existentes ya han sido expuestos históricamente en la red, y debe asumirse que los floodfills maliciosos ya los han enumerado. Importante: Los usuarios preocupados por esta reducción de seguridad deberían usar Red25519 (tipo de firma 11) como tipo de firma para sus Destinos en lugar de Ed25519 (tipo de firma 7).\nNótese que el argumento anterior no se aplica al escalar alpha de re-randomization (re-aleatorización); se filtra información sobre la clave cada vez que se elige un alpha sesgado, porque la re-randomization aditiva se comporta como una libreta de un solo uso.\nEstado de la auditoría de seguridad Aviso importante: I2P, incluido Red25519, nunca ha sido sometido a una auditoría de seguridad formal por terceros. El diseño subyacente RedDSA se sometió a una revisión de seguridad por parte de NCC Group como parte de la auditoría del protocolo Sapling de Zcash en 2018, donde se identificaron y corrigieron problemas de seguridad. Sin embargo, la instanciación específica de I2P con SHA-512 (en lugar de BLAKE2b-512) y la separación de dominios de I2P no han sido analizadas de forma independiente.\nLa implementación de referencia ed25519-java de str4d se sometió a una auditoría independiente de un tercero, pero esta antecedió a la implementación de Red25519 (una extensión de Ed25519) y cubrió únicamente la funcionalidad de Ed25519, no las extensiones de Red25519.\nLos usuarios que desplieguen Red25519 deben comprender esta limitación y evaluar las compensaciones de seguridad según su modelo de amenazas.\nCompatibilidad Las versiones de I2P que admitan Red25519 (versión 0.9.39 y posteriores) podrán verificar las estructuras de datos de red firmadas con ella. Las versiones de I2P que no admitan Red25519 la tratarán como una firma desconocida y PODRÍAN descartar las estructuras de datos.\nCronología de despliegue: - 0.9.39 (marzo de 2019): Primera implementación con compatibilidad de Encrypted LS2 en floodfills - 0.9.40 (mayo de 2019): Autorización por cliente para Encrypted LS2 - 0.9.41 (agosto de 2019): Meta LS2 y Encrypted LS2 con claves sin conexión - 0.9.43 (febrero de 2020): Compatibilidad con b32 para Encrypted LS2 - 0.9.47 (agosto de 2020): Finalización de la especificación - 2.10.0 (octubre de 2025): Versión de red actual (equivalente a 0.9.67+)\nLos usuarios deberían esperar que la fiabilidad de las estructuras de datos firmadas con Red25519 sea buena para casos de uso de LeaseSet2 cifrado, ya que la red ha tenido más de seis años para actualizarse desde la implementación inicial. Sin embargo, las métricas de adopción sobre el uso general de destinos no están disponibles públicamente.\nCaso de uso principal: Red25519 se utiliza principalmente para la funcionalidad de LeaseSet2 cifrado, donde se requiere key blinding (cegamiento de clave). Para destinos estándar sin requisitos de leaseset cifrado, Ed25519 (tipo de firma 7) sigue siendo la opción recomendada debido a su mayor compatibilidad y a su trayectoria comprobada más extensa.\nNotas de implementación Red25519 está implementado en el I2P Java router en net.i2p.crypto.eddsa.RedDSAEngine y utiliza la biblioteca ed25519-java de str4d (Jack Grigg) como dependencia de Maven net.i2p.crypto:eddsa (versiones 0.1.0 a 0.3.0).\nLa implementación de i2pd en C++ también admite Red25519 (signaturetype=11) para la publicación cifrada de LeaseSet.\nEjemplo de configuración para i2pd:\nsignaturetype=11 i2cp.leaseSetType=5 Compatibilidad de LeaseSet2 cifrado: La especificación de LeaseSet cifrado requiere que la clave pública de firma en el unblinded destination (destino no cegado) sea Ed25519 (tipo de firma 7) o Red25519 (tipo de firma 11). No se admiten otros tipos de firma para la funcionalidad de leaseset cifrado.\nVectores de prueba Se proporcionan los siguientes vectores de prueba para la validación de la implementación. Cada vector incluye:\nedsk: Clave privada Ed25519 (aleatoria) edpk: Clave pública Ed25519 correspondiente a edsk sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: Mensaje a firmar sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) Nota de implementación: Estos vectores de prueba deben integrarse en suites de pruebas unitarias automatizadas para validación continua. Los implementadores deben verificar que todas las conversiones, firmas y operaciones de re-aleatorización coincidan con estos valores esperados.\nVector de prueba 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 Vector de prueba 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f Nota: Los vectores de prueba adicionales 3-10 siguen el mismo formato y pueden encontrarse en la implementación de referencia.\nReferencias Propuesta 123: Nuevas entradas de netDB - Partes implementadas y desplegadas en 0.9.38, 0.9.39 y versiones posteriores Especificación del protocolo de Zcash, sección 5.4.6: RedDSA, RedJubjub y RedPallas - RedDSA está definida como parte de la especificación del protocolo de Zcash; auditada en seguridad por NCC Group (enero de 2019) RFC 8032: Algoritmo de firma digital de curva de Edwards (EdDSA) Propuesta 148: RedDSA-BLAKE2b-Ed25519 - Propuesta pero aún no implementada; sugiere una migración futura a BLAKE2b-512 Especificación de LeaseSet cifrado Especificación de criptografía de bajo nivel ","description":"Esquema de firma re-aleatorizable para crear Destinations (identidades de servicio en I2P) cegadas","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"Esquema de firma Red25519","url":"/es/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":"Descripción general Este documento especifica las estructuras de datos fundamentales utilizadas en todos los protocolos de I2P, incluyendo I2NP , I2CP , SSU2 , NTCP2 y otros. Estas estructuras comunes garantizan la interoperabilidad entre diferentes implementaciones de I2P y capas de protocolo.\nCambios clave desde 0.9.58 ElGamal y DSA-SHA1 en desuso para las identidades del router (usar X25519 + EdDSA) Compatibilidad con ML-KEM poscuántico en pruebas beta (opt-in [activación opcional] desde la 2.10.0) Opciones de registros de servicio estandarizadas (Proposal 167 , implementado en 0.9.66) Especificaciones de relleno compresible finalizadas (Proposal 161 , implementado en 0.9.57) Especificaciones comunes de tipos Entero Descripción: Representa un entero no negativo en orden de bytes de red (big-endian, endián grande).\nContenido: De 1 a 8 bytes que representan un entero sin signo.\nUso: Longitudes de campo, cantidades, identificadores de tipo y valores numéricos en todos los protocolos de I2P.\nFecha Descripción: Marca de tiempo que representa milisegundos desde la época Unix (1 de enero de 1970 00:00:00 GMT).\nContenido: Entero de 8 bytes (unsigned long)\nValores especiales: - 0 = Fecha indefinida o nula - Valor máximo: 0xFFFFFFFFFFFFFFFF (año 584,942,417,355)\nNotas de implementación: - Siempre en zona horaria UTC/GMT - Se requiere precisión de milisegundos - Se utiliza para la expiración del lease (período de validez en I2P), la publicación de RouterInfo y la validación de marcas de tiempo\nCadena Descripción: Cadena codificada en UTF-8 con prefijo de longitud.\nFormato:\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes Restricciones: - Longitud máxima: 255 bytes (no caracteres - las secuencias UTF-8 de múltiples bytes cuentan como varios bytes) - La longitud puede ser cero (cadena vacía) - El terminador nulo NO está incluido - La cadena NO tiene terminación nula\nImportante: Las secuencias UTF-8 pueden usar varios bytes por carácter. Una cadena de 100 caracteres podría exceder el límite de 255 bytes si utiliza caracteres multibyte.\nEstructuras de claves criptográficas Clave pública Descripción: Clave pública para cifrado asimétrico. El tipo y la longitud de la clave dependen del contexto o se especifican en un Key Certificate (certificado de clave).\nTipo predeterminado: ElGamal (en desuso para las Identidades de Router a partir de la 0.9.58)\nTipos admitidos:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta **Requisitos de implementación:** X25519 (Tipo 4) - Estándar actual:\nSe utiliza para el cifrado ECIES-X25519-AEAD-Ratchet Obligatorio para las Identidades de router desde la versión 0.9.48 Codificación little-endian (a diferencia de otros tipos) Véase ECIES y ECIES-ROUTERS ElGamal (Type 0) - Legado:\nObsoleto para Router Identities desde la 0.9.58 Sigue siendo válido para Destinations (campo no utilizado desde 0.6/2005) Utiliza primos constantes definidos en la especificación de ElGamal Se mantiene el soporte por compatibilidad con versiones anteriores MLKEM (poscuántico) - Beta:\nEl enfoque híbrido combina ML-KEM con X25519 NO está habilitado de forma predeterminada en 2.10.0 Requiere activación manual mediante Hidden Service Manager (administrador de servicios ocultos) Consulta ECIES-HYBRID y Proposal 169 Los códigos de tipo y las especificaciones están sujetos a cambios JavaDoc: PublicKey Clave privada Descripción: Clave privada para descifrado asimétrico, correspondiente a los tipos PublicKey.\nAlmacenamiento: Tipo y longitud inferidos a partir del contexto o almacenados por separado en estructuras de datos/archivos de claves.\nTipos compatibles:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta **Notas de seguridad:** - Las claves privadas DEBEN generarse utilizando generadores de números aleatorios criptográficamente seguros - Las claves privadas X25519 usan scalar clamping (restricción del escalar) según lo definido en la RFC 7748 - El material de clave DEBE borrarse de forma segura de la memoria cuando ya no sea necesario JavaDoc: PrivateKey Clave de sesión Descripción: Clave simétrica para el cifrado y descifrado con AES-256 en el tunnel (túnel) y el garlic encryption (cifrado garlic) de I2P.\nContenido: 32 bytes (256 bits)\nUso: - Cifrado de la capa de tunnel (AES-256/CBC con IV) - garlic encryption (cifrado por agregación de mensajes) - Cifrado de sesión de extremo a extremo\nGeneración: DEBE usar un generador de números aleatorios criptográficamente seguro.\nJavaDoc: SessionKey SigningPublicKey Descripción: Clave pública para la verificación de firmas. El tipo y la longitud se especifican en el Certificado de clave del Destino o se infieren del contexto.\nTipo predeterminado: DSA_SHA1 (en desuso desde 0.9.58)\nTipos admitidos:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- **Requisitos de implementación:** EdDSA_SHA512_Ed25519 (Tipo 7) - Estándar actual:\nPredeterminado para todas las nuevas Router Identities y Destinations desde finales de 2015 Usa la curva Ed25519 con hash SHA-512 Claves públicas de 32 bytes, firmas de 64 bytes Codificación little-endian (orden de bytes con el menos significativo primero; a diferencia de la mayoría de los otros tipos) Alto rendimiento y seguridad RedDSA_SHA512_Ed25519 (Type 11) - Especializado:\nSe usa SOLO para leasesets cifrados y blinding (cegamiento) Nunca se usa para Identidades de router ni para Destinos estándar Diferencias clave con respecto a EdDSA: Claves privadas mediante reducción modular (no clamping, recorte de bits) Las firmas incluyen 80 bytes de datos aleatorios Usa las claves públicas directamente (no hashes de las claves privadas) Consulte [Especificación de Red25519](//docs/specs/red25519-signature-scheme/ DSA_SHA1 (Tipo 0) - Heredado:\nObsoleto para Identidades de router a partir de la 0.9.58 Desaconsejado para nuevos Destinos DSA de 1024 bits con SHA-1 (debilidades conocidas) Se mantiene el soporte únicamente por compatibilidad Claves de múltiples elementos:\nCuando se compone de dos elementos (p. ej., puntos ECDSA X,Y) Cada elemento se rellena hasta length/2 con ceros a la izquierda Ejemplo: clave ECDSA de 64 bytes = 32 bytes X + 32 bytes Y JavaDoc: SigningPublicKey SigningPrivateKey (clave privada de firma) Descripción: Clave privada para crear firmas, correspondiente a los tipos SigningPublicKey.\nAlmacenamiento: Tipo y longitud especificados en el momento de la creación.\nTipos admitidos:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized **Requisitos de seguridad:** - Generar utilizando una fuente de aleatoriedad criptográficamente segura - Proteger con controles de acceso adecuados - Borrar de la memoria de forma segura al finalizar - Para EdDSA: semilla de 32 bytes con hash SHA-512, los primeros 32 bytes se convierten en el escalar (clamped, acotado) - Para RedDSA: generación de claves diferente (reducción modular en lugar de clamping) JavaDoc: SigningPrivateKey Firma Descripción: Firma criptográfica sobre los datos, usando el algoritmo de firma correspondiente al tipo SigningPrivateKey.\nTipo y longitud: Inferidos a partir del tipo de clave utilizado para la firma.\nTipos admitidos:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized **Notas de formato:** - Las firmas de múltiples elementos (p. ej., valores R,S de ECDSA) se rellenan hasta length/2 por elemento con ceros a la izquierda - EdDSA y RedDSA usan codificación little-endian (orden de bytes de menor a mayor) - Todos los demás tipos usan codificación big-endian (orden de bytes de mayor a menor) Verificación: - Use el SigningPublicKey correspondiente - Siga las especificaciones del algoritmo de firma para el tipo de clave - Compruebe que la longitud de la firma coincide con la longitud esperada para el tipo de clave\nJavaDoc: Signature Hash (resumen criptográfico) Descripción: hash SHA-256 de datos, utilizado en todo I2P para la verificación de integridad e identificación.\nContenido: 32 bytes (256 bits)\nUsos: - hashes de la Identidad del Router (claves de la base de datos de red) - hashes de destino (claves de la base de datos de red) - identificación de la puerta de enlace del Tunnel en Leases - verificación de la integridad de los datos - generación del ID del Tunnel\nAlgoritmo: SHA-256 según se define en FIPS 180-4\nJavaDoc (documentación de la API de Java): Hash Etiqueta de sesión Descripción: Número aleatorio utilizado para la identificación de la sesión y el cifrado basado en etiquetas.\nImportante: El tamaño de la etiqueta de sesión varía según el tipo de cifrado: - ElGamal/AES+SessionTag: 32 bytes (heredado) - ECIES-X25519: 8 bytes (estándar actual)\nEstándar actual (ECIES):\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers Consulte ECIES y ECIES-ROUTERS para obtener especificaciones detalladas.\nHeredado (ElGamal/AES):\nContents: 32 bytes Usage: Deprecated encryption scheme Generación: DEBE usar un generador de números aleatorios criptográficamente seguro.\nJavaDoc: SessionTag TunnelId Descripción: Identificador único de la posición que ocupa un router dentro de un tunnel. Cada salto en un tunnel tiene su propio TunnelId (identificador de túnel).\nFormato:\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) Uso: - Identifica las conexiones de tunnel entrantes/salientes en cada router - TunnelId diferente en cada salto de la cadena de tunnel - Se utiliza en estructuras Lease (estructura de metadatos de I2P que anuncia tunnel de entrada y su vigencia) para identificar tunnel de puerta de enlace\nValores especiales: - 0 = Reservado para usos especiales del protocolo (evitar en operación normal) - Los TunnelIds (identificadores de tunnel) solo tienen significado local para cada router\nJavaDoc: TunnelId Especificaciones de certificados Certificado Descripción: Contenedor para recibos, prueba de trabajo o metadatos criptográficos utilizados en todo I2P.\nFormato:\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes Tamaño total: mínimo 3 bytes (NULL certificate, certificado nulo), hasta 65538 bytes como máximo\nTipos de certificados Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) ### Certificado de clave (Tipo 5) Introducción: Versión 0.9.12 (diciembre de 2013)\nPropósito: Especifica tipos de clave no predeterminados y almacena datos de clave adicionales más allá de la estructura estándar KeysAndCert de 384 bytes.\nEstructura de la carga útil:\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space Notas críticas de implementación:\nOrden de tipos de clave:\nADVERTENCIA: el tipo de clave de firma va ANTES que el tipo de clave criptográfica Esto es contraintuitivo, pero se mantiene por compatibilidad Orden: SPKtype, CPKtype (no CPKtype, SPKtype) Estructura de los datos de clave en KeysAndCert:\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] Cálculo de datos de clave excedentes:\nSi Crypto Key \u0026gt; 256 bytes: Excess = (Crypto Length - 256) Si Signing Key \u0026gt; 128 bytes: Excess = (Signing Length - 128) Padding = max(0, 384 - Crypto Length - Signing Length) Ejemplos (clave criptográfica ElGamal):\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 **Requisitos de identidad del router:** - Certificado NULL utilizado hasta la versión 0.9.15 - Certificado de clave requerido para tipos de clave no predeterminados desde la 0.9.16 - Claves de cifrado X25519 compatibles desde la 0.9.48 Requisitos del destino: - certificado NULL o certificado de clave (según sea necesario) - Se requiere un certificado de clave para los tipos de clave de firma no predeterminados desde la 0.9.12 - El campo de clave pública criptográfica no se usa desde la 0.6 (2005), pero debe seguir estando presente\nAdvertencias importantes:\nCertificado NULL vs KEY:\nUn KEY certificate (certificado de tipo KEY) con tipos (0,0) que especifican ElGamal+DSA_SHA1 está permitido pero se desaconseja Use siempre NULL certificate (certificado de tipo NULL) para ElGamal+DSA_SHA1 (representación canónica) Un KEY certificate con (0,0) es 4 bytes más largo y puede causar problemas de compatibilidad Algunas implementaciones pueden no manejar correctamente los KEY certificates con (0,0) Validación de datos excedentes:\nLas implementaciones DEBEN verificar que la longitud del certificado coincida con la longitud esperada para los tipos de clave Rechazar certificados con datos excedentes que no correspondan a los tipos de clave Prohibir datos basura al final de una estructura de certificado válida JavaDoc: Certificate Mapeo Descripción: Colección de propiedades clave-valor usada para configuración y metadatos.\nFormato:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] Límites de tamaño: - Longitud de la clave: 0-255 bytes (+ 1 byte de longitud) - Longitud del valor: 0-255 bytes (+ 1 byte de longitud) - Tamaño total del mapeo: 0-65535 bytes (+ 2 bytes del campo de tamaño) - Tamaño máximo de la estructura: 65537 bytes\nRequisito crítico de ordenación:\nCuando los mapeos aparecen en estructuras firmadas (RouterInfo, RouterAddress, Destination properties, I2CP SessionConfig), las entradas DEBEN ordenarse por clave para garantizar la invariancia de la firma:\nMétodo de ordenación: Ordenación lexicográfica usando los valores de los puntos de código Unicode (equivalente a Java String.compareTo()) Sensibilidad a mayúsculas y minúsculas: Las claves y los valores generalmente distinguen mayúsculas y minúsculas (dependiente de la aplicación) Claves duplicadas: NO se permiten en estructuras firmadas (provocan un fallo en la verificación de la firma) Codificación de caracteres: Comparación a nivel de bytes en UTF-8 Por qué importa la ordenación: - Las firmas se calculan sobre la representación en bytes - Diferentes órdenes de claves producen diferentes firmas - Los mapeos no firmados no requieren ordenación, pero deberían seguir la misma convención\nNotas de implementación:\nRedundancia de codificación:\nEstán presentes tanto los delimitadores = y ; como los bytes de longitud de la cadena Esto es ineficiente, pero se mantiene por compatibilidad Los bytes de longitud tienen prioridad; los delimitadores son obligatorios pero redundantes Compatibilidad de caracteres:\nA pesar de la documentación, = y ; SÍ se admiten dentro de las cadenas (los bytes de longitud se encargan de esto) La codificación UTF-8 admite todo el conjunto de caracteres Unicode Advertencia: I2CP usa UTF-8, pero I2NP históricamente no manejaba UTF-8 correctamente Usa ASCII para las asignaciones de I2NP cuando sea posible para lograr la máxima compatibilidad Contextos especiales:\nRouterInfo/RouterAddress: DEBE estar ordenado, sin duplicados I2CP SessionConfig (configuración de sesión): DEBE estar ordenado, sin duplicados Mapeos de aplicaciones: Se recomienda ordenar, pero no siempre es obligatorio Ejemplo (opciones de RouterInfo (información del router de I2P)):\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 JavaDoc: DataHelper Especificación de estructura común Claves y Certificado Descripción: Estructura fundamental que combina la clave de cifrado, la clave de firma y el certificado. Se utiliza como RouterIdentity (identidad del router) y como Destination (destino).\nEstructura:\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) Alineación de claves: - Clave pública criptográfica: Alineada al inicio (byte 0) - Relleno: En el medio (si es necesario) - Clave pública de firma: Alineada al final (del byte 256 al byte 383) - Certificado: Comienza en el byte 384\nCálculo del tamaño:\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length Directrices para la generación de relleno (Propuesta 161 ) Versión de implementación: 0.9.57 (enero de 2023, lanzamiento 2.1.0)\nAntecedentes: - Para claves no ElGamal+DSA, el relleno está presente en la estructura fija de 384 bytes - Para los Destinos, el campo de clave pública de 256 bytes no se utiliza desde la 0.6 (2005) - El relleno debe generarse de manera que sea comprimible y, a la vez, siga siendo seguro\nRequisitos:\nMínimo de datos aleatorios:\nUtilice al menos 32 bytes de datos aleatorios criptográficamente seguros Esto proporciona suficiente entropía para la seguridad Estrategia de compresión:\nRepetir los 32 bytes a lo largo de todo el campo de relleno/clave pública Protocolos como I2NP Database Store, Streaming SYN, SSU2 handshake (intercambio inicial) usan compresión Ahorros significativos de ancho de banda sin comprometer la seguridad Ejemplos:\nIdentidad del Router (X25519 + EdDSA):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed Destino (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed Por qué esto funciona:\nEl hash SHA-256 de la estructura completa sigue incluyendo toda la entropía La distribución DHT (tabla hash distribuida) de la base de datos de red depende únicamente del hash La clave de firma (32 bytes EdDSA/X25519) proporciona 256 bits de entropía 32 bytes adicionales de datos aleatorios repetidos = 512 bits de entropía total Más que suficiente para la seguridad criptográfica Notas de implementación:\nDEBE almacenar y transmitir la estructura completa de 387+ bytes Hash SHA-256 calculado sobre la estructura completa sin comprimir Compresión aplicada en la capa de protocolo (I2NP, Streaming, SSU2) Retrocompatible con todas las versiones desde la 0.6 (2005) JavaDoc: KeysAndCert RouterIdentity (identidad del router) Descripción: Identifica de forma única un router en la red I2P. Tiene una estructura idéntica a KeysAndCert.\nFormato: Consulte la estructura KeysAndCert más arriba\nRequisitos actuales (a partir de la versión 0.9.58):\nTipos de claves obligatorios:\nCifrado: X25519 (tipo 4, 32 bytes) Firma: EdDSA_SHA512_Ed25519 (tipo 7, 32 bytes) Certificado: Key Certificate (certificado de clave, tipo 5) Tipos de claves en desuso:\nElGamal (tipo 0) en desuso para las Identidades de Router a partir de la 0.9.58 DSA_SHA1 (tipo 0) en desuso para las Identidades de Router a partir de la 0.9.58 Estos NO deben usarse para routers nuevos Tamaño típico:\nX25519 + EdDSA con certificado de clave = 391 bytes 32 bytes de clave pública X25519 320 bytes de relleno (compresible según Propuesta 161 ) 32 bytes de clave pública EdDSA 7 bytes de certificado (encabezado de 3 bytes + tipos de clave de 4 bytes) Evolución histórica: - Pre-0.9.16: Siempre NULL certificate (certificado nulo) (ElGamal + DSA_SHA1) - 0.9.16-0.9.47: Se añadió soporte para Key Certificate (certificado de clave) - 0.9.48+: Se añadió soporte para claves de cifrado X25519 - 0.9.58+: ElGamal y DSA_SHA1 marcados como obsoletos\nClave de la base de datos de red: - RouterInfo (información del router) indexado por el hash SHA-256 de la RouterIdentity (identidad del router) completa - Hash calculado sobre la estructura completa de 391+ bytes (incluyendo el relleno)\nVéase también: - Directrices para la generación de relleno (Proposal 161 ) - Especificación del certificado de clave más arriba\nJavaDoc: RouterIdentity Destino Descripción: Identificador de extremo para la entrega segura de mensajes. Estructuralmente idéntico a KeysAndCert, pero con una semántica de uso diferente.\nFormato: Consulte la estructura KeysAndCert anterior\nDiferencia crítica con respecto a RouterIdentity: - El campo de clave pública NO SE USA y puede contener datos aleatorios - Este campo no se usa desde la versión 0.6 (2005) - Originalmente era para el cifrado I2CP-to-I2CP antiguo (deshabilitado) - Actualmente solo se usa como IV (vector de inicialización) para el cifrado de LeaseSet en desuso\nRecomendaciones actuales:\nClave de firma:\nRecomendada: EdDSA_SHA512_Ed25519 (tipo 7, 32 bytes) Alternativa: tipos ECDSA para compatibilidad con versiones anteriores Evitar: DSA_SHA1 (obsoleto, desaconsejado) Clave de cifrado:\nEl campo no se utiliza, pero debe estar presente Recomendado: Rellenar con datos aleatorios según Proposal 161 (compresible) Tamaño: Siempre 256 bytes (ranura de ElGamal, aunque no se use para ElGamal) Certificado:\nCertificado NULL para ElGamal + DSA_SHA1 (solo para compatibilidad con versiones anteriores) Certificado de clave para todos los demás tipos de claves de firma Destino moderno típico:\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes Clave de cifrado efectiva: - La clave de cifrado del Destination (Destino) está en el LeaseSet, no en el Destination - LeaseSet contiene las claves públicas de cifrado actuales - Consulta la especificación de LeaseSet2 para la gestión de la clave de cifrado\nClave de la base de datos de red: - LeaseSet indexado por el hash SHA-256 del Destino completo - Hash calculado sobre la estructura completa de 387+ bytes\nJavaDoc: Destination Estructuras de la base de datos de la red Concesión Descripción: Autoriza que un tunnel específico reciba mensajes para un Destino. Parte del formato original de LeaseSet (tipo 1).\nFormato:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch Tamaño total: 44 bytes\nUso: - Se utiliza únicamente en el LeaseSet original (tipo 1, obsoleto) - Para LeaseSet2 y variantes posteriores, utilice Lease2 en su lugar\nJavaDoc: Lease LeaseSet (Tipo 1) Descripción: Formato original de LeaseSet. Contiene tunnels autorizados y claves para un Destination (destino de I2P). Almacenado en la base de datos de la red. Estado: Obsoleto (usa LeaseSet2 en su lugar).\nEstructura:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey Almacenamiento de base de datos: - Tipo de base de datos: 1 - Clave: hash SHA-256 del Destino - Valor: estructura completa de LeaseSet\nNotas importantes:\nClave pública del Destino no utilizada:\nEl campo de clave pública de cifrado en el Destino no se utiliza La clave de cifrado en el LeaseSet es la clave de cifrado efectiva Claves temporales:\nencryption_key es temporal (se regenera al iniciar el router) signing_key es temporal (se regenera al iniciar el router) Ninguna de las dos claves persiste entre reinicios Revocación (no implementada):\nsigning_key estaba previsto para la revocación de LeaseSet El mecanismo de revocación nunca se implementó Un LeaseSet con cero leases (referencias de tunnel) estaba previsto para la revocación, pero no se utiliza Versionado/Marca de tiempo:\nLeaseSet no tiene un campo de marca de tiempo published explícito La versión es el vencimiento más temprano de todos los leases (registros de vigencia de los túneles) El nuevo LeaseSet debe tener un vencimiento de lease más temprano para ser aceptado Publicación de la expiración de Lease (periodo de validez de un túnel en I2P):\nPre-0.9.7: Todas las leases se publicaban con la misma expiración (la más temprana) 0.9.7+: Se publican las expiraciones reales de las leases individuales Esto es un detalle de implementación, no forma parte de la especificación Cero Leases:\nLeaseSet con cero Leases es técnicamente válido Previsto para revocación (no implementado) No se usa en la práctica Las variantes de LeaseSet2 requieren al menos un Lease (entrada que describe un tunnel entrante y su expiración) Obsolescencia: LeaseSet tipo 1 está obsoleto. Las nuevas implementaciones deberían usar LeaseSet2 (tipo 3), que proporciona: - Campo de marca de tiempo de publicación (mejor control de versiones) - Compatibilidad con varias claves de cifrado - Capacidad de firma sin conexión - Caducidades de lease (registro temporal de túnel) de 4 bytes (frente a 8 bytes) - Opciones más flexibles\nJavaDoc: LeaseSet Variantes de LeaseSet Lease2 (versión 2 de la entrada con expiración que autoriza el acceso a un tunnel) Descripción: Formato de lease mejorado con expiración de 4 bytes. Se utiliza en LeaseSet2 (tipo 3) y MetaLeaseSet (tipo 7).\nIntroducción: Versión 0.9.38 (véase Propuesta 123 )\nFormato:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 Tamaño total: 40 bytes (4 bytes menos que el Lease original)\nComparación con el Lease (registro que especifica un tunnel y su expiración en I2P) original:\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet **JavaDoc:** [Lease2](http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html) OfflineSignature (firma fuera de línea) Descripción: Estructura opcional para claves efímeras prefirmadas, que permite la publicación del LeaseSet sin acceso en línea a la clave privada de firma de Destination (destino en I2P).\nIntroducción: Versión 0.9.38 (véase Propuesta 123 )\nFormato:\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey Propósito: - Permite la generación de LeaseSet sin conexión - Protege la clave maestra de la Destination (Destino) contra la exposición en línea - La clave temporal puede revocarse publicando un nuevo LeaseSet sin la firma sin conexión\nEscenarios de uso:\nDestinos de alta seguridad:\nClave maestra de firma almacenada fuera de línea (HSM, almacenamiento en frío) Claves efímeras generadas fuera de línea por períodos de tiempo limitados Una clave efímera comprometida no expone la clave maestra Publicación de Encrypted LeaseSet:\nEncryptedLeaseSet puede incluir firma fuera de línea Clave pública cegada + firma fuera de línea proporcionan seguridad adicional Consideraciones de seguridad:\nGestión de caducidad:\nEstablecer una caducidad razonable (de días a semanas, no años) Generar nuevas claves efímeras antes de la caducidad Caducidad más corta = mejor seguridad, más mantenimiento Generación de claves:\nGenerar claves efímeras sin conexión en un entorno seguro Firmar con la clave maestra sin conexión Transferir únicamente la clave efímera firmada + la firma al router en línea Revocación:\nPublicar un nuevo LeaseSet sin firma fuera de línea para revocar implícitamente O publicar un nuevo LeaseSet con una clave efímera diferente Verificación de la firma:\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature Notas de implementación: - El tamaño total varía según el tipo de firma y el tipo de clave de firma del Destino - Tamaño mínimo: 4 + 2 + 32 (clave EdDSA) + 64 (firma EdDSA) = 102 bytes - Tamaño máximo práctico: ~600 bytes (clave temporal RSA-4096 + firma RSA-4096)\nCompatible con: - LeaseSet2 (tipo 3) - EncryptedLeaseSet (tipo 5) - MetaLeaseSet (tipo 7)\nVéase también: Propuesta 123 para el protocolo de firma sin conexión detallado.\nLeaseSet2Header Descripción: Estructura de encabezado común para LeaseSet2 (tipo 3) y MetaLeaseSet (tipo 7).\nIntroducción: Versión 0.9.38 (ver Propuesta 123 )\nFormato:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length Tamaño total mínimo: 395 bytes (sin firma fuera de línea)\nDefiniciones de banderas (orden de bits: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility **Detalles de la bandera:** Bit 0 - Claves fuera de línea: - 0: Sin firma fuera de línea, use la clave de firma de la Destination (identidad/destino en I2P) para verificar la firma del LeaseSet - 1: La estructura OfflineSignature sigue al campo de indicadores\nBit 1 - No publicado: - 0: LeaseSet publicado estándar, debe propagarse a los floodfills - 1: LeaseSet no publicado (solo del lado del cliente) - NO debe propagarse, publicarse ni enviarse en respuesta a consultas - Si expira, NO consultar netdb para reemplazo (a menos que el bit 2 también esté establecido) - Usado para tunnels locales o pruebas\nBit 2 - Blinded (cegado) (desde 0.9.42): - 0: LeaseSet estándar - 1: Este LeaseSet no cifrado se publicará como blinded y cifrado - La versión publicada será EncryptedLeaseSet (tipo 5) - Si caduca, consulta la ubicación blinded en netdb para su reemplazo - También se debe establecer el bit 1 en 1 (unpublished + blinded) - Se usa para servicios ocultos cifrados\nLímites de expiración:\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours **Requisitos de la marca de tiempo publicada:** LeaseSet (tipo 1) no tenía un campo published, lo que obligaba a buscar el vencimiento más temprano del lease (concesión de túnel) para el versionado. LeaseSet2 añade una marca de tiempo published explícita con resolución de 1 segundo.\nNota crítica de implementación: - Routers DEBEN aplicar limitación de tasa a la publicación de LeaseSet a una frecuencia mucho más baja que una vez por segundo por Destination (destino en I2P) - Si se publica más rápido, asegúrense de que cada nuevo LeaseSet tenga el campo published al menos 1 segundo posterior - Floodfills rechazarán el LeaseSet si el campo published no es más reciente que la versión actual - Intervalo mínimo recomendado: 10-60 segundos entre publicaciones\nEjemplos de cálculo:\nLeaseSet2 (máximo de 11 minutos):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet (máximo de 18,2 horas):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) Versionado: - Se considera \u0026ldquo;más reciente\u0026rdquo; un LeaseSet si la marca de tiempo published es mayor - Los Floodfills almacenan y propagan únicamente la versión más reciente - Presta atención cuando el Lease (arrendamiento de túnel) más antiguo coincide con el Lease más antiguo del LeaseSet anterior\nLeaseSet2 (Tipo 3) Descripción: Formato moderno de LeaseSet con múltiples claves de cifrado, firmas fuera de línea y registros de servicio. Estándar actual para servicios ocultos de I2P.\nIntroducción: Versión 0.9.38 (véase Propuesta 123 )\nEstructura:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix Almacenamiento de la base de datos: - Tipo de base de datos: 3 - Clave: hash SHA-256 del Destino - Valor: Estructura completa de LeaseSet2\nCálculo de la firma:\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key Orden de preferencia de claves de cifrado Para LeaseSet Publicado (Servidor): - Claves listadas en orden de preferencia del servidor (las más preferidas primero) - Los clientes que admitan múltiples tipos DEBERÍAN respetar la preferencia del servidor - Seleccione el primer tipo compatible de la lista - En general, los tipos de clave con numeración más alta (más nuevos) son más seguros/eficientes - Orden recomendado: Enumere las claves en orden inverso por código de tipo (las más nuevas primero)\nEjemplo de preferencia del servidor:\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] Para LeaseSet (cliente) no publicado: - El orden de las claves en la práctica no importa (rara vez se intentan conexiones a clientes) - Sigue la misma convención para mantener la coherencia\nSelección de claves del cliente: - Respetar la preferencia del servidor (seleccionar el primer tipo admitido) - O usar la preferencia definida por la implementación - O determinar una preferencia combinada en función de las capacidades de ambos\nAsignación de opciones Requisitos: - Las opciones DEBEN estar ordenadas por clave (lexicográfico, orden de bytes UTF-8) - La ordenación garantiza la invariancia de la firma - NO se permiten claves duplicadas\nFormato estándar (Propuesta 167 ):\nA partir de la API 0.9.66 (junio de 2025, versión 2.9.0), las opciones de los registros de servicio siguen un formato estandarizado. Consulta Propuesta 167 para la especificación completa.\nFormato de la opción del registro de servicio:\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) Ejemplos de registros de servicio:\n1. Servidor SMTP autorreferente:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. Servidor SMTP externo único:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. Varios servidores SMTP (balanceo de carga):\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. Servicio HTTP con opciones de la aplicación:\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates Recomendaciones de TTL: - Mínimo: 86400 segundos (1 día) - Un TTL más largo reduce la carga de consultas de netdb - Equilibrio entre la reducción de consultas y la propagación de actualizaciones del servicio - Para servicios estables: 604800 (7 días) o más\nNotas de implementación:\nClaves de cifrado (a partir de la versión 0.9.44):\nElGamal (tipo 0, 256 bytes): Compatibilidad con versiones anteriores X25519 (tipo 4, 32 bytes): Estándar actual Variantes de MLKEM: Poscuánticas (beta, no finalizadas) Validación de longitud de clave:\nFloodfills (nodos floodfill de I2P) y clientes DEBEN poder analizar tipos de clave desconocidos Utilice el campo keylen para omitir claves desconocidas No falle el análisis si el tipo de clave es desconocido Marca de tiempo de publicación:\nConsulte las notas de LeaseSet2Header sobre limitación de tasa Incremento mínimo de 1 segundo entre publicaciones Recomendado: 10-60 segundos entre publicaciones Migración del tipo de cifrado:\nEl uso de múltiples claves permite una migración gradual Enumera tanto las claves antiguas como las nuevas durante el período de transición Elimina la clave antigua tras un período suficiente de actualización de clientes JavaDoc: LeaseSet2 MetaLease (arrendamiento meta) Descripción: Estructura de Lease (registro de túnel con vencimiento) para MetaLeaseSet que puede referenciar otros LeaseSets en lugar de tunnels. Se utiliza para balanceo de carga y redundancia.\nIntroducción: Versión 0.9.38, trabajo programado para la 0.9.40 (véase Propuesta 123 )\nFormato:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 Tamaño total: 40 bytes\nTipo de entrada (bits de bandera 3-0):\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) **Escenarios de uso:** Balanceo de carga:\nMetaLeaseSet con múltiples entradas de MetaLease Cada entrada apunta a un LeaseSet2 diferente Los clientes seleccionan en función del campo de coste Redundancia:\nVarias entradas que apuntan a LeaseSets de respaldo Alternativa si el LeaseSet principal no está disponible Migración de servicio:\nMetaLeaseSet apunta al nuevo LeaseSet Permite una transición fluida entre Destinos Uso del campo de coste: - Menor coste = mayor prioridad - Coste 0 = prioridad más alta - Coste 255 = prioridad más baja - Los clientes DEBERÍAN preferir entradas de menor coste - Las entradas con el mismo coste pueden balancearse de forma aleatoria\nComparación con Lease2 (segunda versión de Lease en I2P):\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing **JavaDoc:** [MetaLease](http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html) MetaLeaseSet (Tipo 7) Descripción: Variante de LeaseSet que contiene entradas MetaLease (entradas «meta»), proporcionando indirección hacia otros LeaseSets. Se usa para balanceo de carga, redundancia y migración de servicios.\nIntroducción: Definido en 0.9.38, funcionamiento previsto en 0.9.40 (ver Propuesta 123 )\nEstado: Especificación completa. Debe verificarse el estado del despliegue en producción con las versiones actuales de I2P.\nEstructura:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations Almacenamiento de base de datos: - Tipo de base de datos: 7 - Clave: hash SHA-256 del Destino - Valor: estructura MetaLeaseSet completa\nCálculo de la firma:\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key Escenarios de uso:\n1. Balanceo de carga:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. Conmutación por error:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. Migración del servicio:\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. Arquitectura de múltiples capas:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing Lista de revocación:\nLa lista de revocación permite a MetaLeaseSet revocar explícitamente los LeaseSets publicados previamente:\nPropósito: Marcar que determinadas Destinations (destinos de I2P) ya no son válidas Contenido: Hashes SHA-256 de estructuras de Destination revocadas Uso: Los clientes NO DEBEN usar LeaseSets cuyo hash de Destination aparezca en la lista de revocación Valor típico: Vacío (numr=0) en la mayoría de los despliegues Ejemplo de revocación:\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached Gestión de caducidad:\nMetaLeaseSet utiliza LeaseSet2Header con un expires máximo de 65535 segundos (~18,2 horas):\nMucho más largo que LeaseSet2 (máx. ~11 minutos) Adecuado para una indirección relativamente estática Los LeaseSets referenciados pueden tener un vencimiento más corto Los clientes deben comprobar el vencimiento tanto del MetaLeaseSet como de los LeaseSets referenciados Asignación de opciones:\nUtiliza el mismo formato que las opciones de LeaseSet2 Puede incluir registros de servicio (Proposal 167 ) DEBE estar ordenado por clave Los registros de servicio normalmente describen el servicio final, no la estructura de indirección Notas de implementación del cliente:\nProceso de resolución:\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry Caché:\nAlmacenar en caché tanto el MetaLeaseSet (estructura que agrupa varios LeaseSets) como los LeaseSets referenciados Comprobar la caducidad de ambos niveles Supervisar la publicación de un MetaLeaseSet actualizado Conmutación por error:\nSi la entrada preferida falla, prueba con la siguiente de menor costo Considera marcar las entradas fallidas como no disponibles temporalmente Vuelve a comprobar periódicamente por si se recuperan Estado de implementación:\nPropuesta 123 indica que algunas partes siguen \u0026ldquo;en desarrollo\u0026rdquo;. Los implementadores deberían: - Verificar la aptitud para producción en la versión objetivo de I2P - Probar la compatibilidad con MetaLeaseSet (tipo de leaseSet de I2P) antes del despliegue - Comprobar si hay especificaciones actualizadas en versiones más recientes de I2P\nJavaDoc: MetaLeaseSet EncryptedLeaseSet (LeaseSet cifrado) (Tipo 5) Descripción: LeaseSet cifrado y cegado para mayor privacidad. Solo la clave pública cegada y los metadatos son visibles; los leases (entradas de túneles entrantes) reales y las claves de cifrado están cifrados.\nIntroducción: Definido en 0.9.38, operativo desde 0.9.39 (véase Propuesta 123 )\nEstructura:\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key Almacenamiento de base de datos: - Tipo de base de datos: 5 - Clave: hash SHA-256 del Destination cegado (identificador de destino en I2P) (no del Destination original) - Valor: estructura EncryptedLeaseSet completa\nDiferencias clave con respecto a LeaseSet2:\nNO utiliza la estructura LeaseSet2Header (tiene campos similares pero un formato diferente) Clave pública cegada en lugar de Destination (identificador de destino en I2P) completa Carga útil cifrada en lugar de leases y claves en texto claro La clave de base de datos es el hash de la Destination cegada, no de la Destination original Cálculo de la firma:\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key Requisito del tipo de firma:\nDEBE usar RedDSA_SHA512_Ed25519 (tipo 11): - claves públicas cegadas de 32 bytes - firmas de 64 bytes - Necesario para las propiedades de seguridad del cegado - Ver [especificación de Red25519](//docs/specs/red25519-signature-scheme/\nPrincipales diferencias con EdDSA: - Claves privadas mediante reducción modular (no clamping (ajuste de bits)) - Las firmas incluyen 80 bytes de datos aleatorios - Usa claves públicas directamente (no hashes) - Permite una operación de blinding (enmascaramiento criptográfico) segura\nCegado y cifrado:\nConsulte la Especificación de EncryptedLeaseSet (LeaseSet cifrado) para obtener detalles completos:\n1. Cegado de clave:\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. Ubicación de la base de datos:\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. Capas de cifrado (tres capas):\nCapa 1 - Capa de autenticación (Acceso de cliente): - Cifrado: cifrado de flujo ChaCha20 - Derivación de claves: HKDF con secretos por cliente - Los clientes autenticados pueden descifrar la capa externa\nCapa 2 - Capa de cifrado: - Cifrado: ChaCha20 - Clave: Derivada de DH (Diffie-Hellman) entre cliente y servidor - Contiene el LeaseSet2 o MetaLeaseSet propiamente dicho\nCapa 3 - LeaseSet interno: - LeaseSet2 completo o MetaLeaseSet - Incluye todos los tunnels, claves de cifrado, opciones - Solo accesible tras un descifrado exitoso\nDerivación de la clave de cifrado:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) Proceso de descubrimiento:\nPara clientes autorizados:\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication Para clientes no autorizados: - No pueden descifrar incluso si encuentran el EncryptedLeaseSet - No pueden determinar la Destination (destino en I2P) original a partir de la versión cegada - No pueden vincular EncryptedLeaseSets entre diferentes periodos de cegado (rotación diaria)\nTiempos de expiración:\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived **Marca de tiempo de publicación:** Los mismos requisitos que LeaseSet2Header (encabezado de LeaseSet2):\nDebe incrementarse en al menos 1 segundo entre publicaciones Los Floodfills (routers floodfill) rechazan si no es más reciente que la versión actual Recomendado: 10-60 segundos entre publicaciones Firmas sin conexión con LeaseSets cifrados:\nConsideraciones especiales al usar firmas fuera de línea: - La clave pública cegada rota diariamente - La firma fuera de línea debe regenerarse diariamente con la nueva clave cegada - O use la firma fuera de línea en el LeaseSet interno, no en el EncryptedLeaseSet externo - Consulte las notas de Propuesta 123 Notas de implementación:\nAutorización de clientes:\nSe pueden autorizar varios clientes con claves diferentes Cada cliente autorizado tiene credenciales de descifrado únicas Revoque el acceso de un cliente cambiando las claves de autorización Rotación diaria de claves:\nLas claves cegadas cambian a medianoche UTC Los clientes deben recalcular diariamente la Destination cegada (identificador del servicio en I2P) Los EncryptedLeaseSets antiguos dejan de ser descubribles tras la rotación Propiedades de privacidad:\nLos Floodfills no pueden determinar la Destination (destino en I2P) original Los clientes no autorizados no pueden acceder al servicio Los distintos períodos de blinding (cegamiento criptográfico) no pueden vincularse No hay metadatos en claro más allá de los tiempos de expiración Rendimiento:\nLos clientes deben realizar un cálculo diario de cegamiento El cifrado de tres capas añade sobrecarga computacional Considere almacenar en caché el LeaseSet interno descifrado Consideraciones de seguridad:\nGestión de claves de autorización:\nDistribuir de forma segura las credenciales de autorización de los clientes Usar credenciales únicas por cliente para una revocación granular Rotar las claves de autorización periódicamente Sincronización del reloj:\nEl blinding diario (cegamiento) depende de fechas UTC sincronizadas El desfase del reloj puede causar fallos de búsqueda Considere admitir el blinding del día anterior/siguiente para mayor tolerancia Filtración de metadatos:\nLos campos Published y expires están en texto sin cifrar El análisis de patrones podría revelar características del servicio Aleatoriza los intervalos de publicación si es motivo de preocupación JavaDoc: EncryptedLeaseSet Estructuras del Router RouterAddress (dirección del router) Descripción: Define la información de conexión para un router mediante un protocolo de transporte específico.\nFormato:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary CRÍTICO - Campo de expiración:\n⚠️ El campo de expiración DEBE establecerse a cero en todos sus bytes (8 bytes en cero).\nMotivo: Desde la versión 0.9.3, una expiración distinta de cero provoca un fallo en la verificación de la firma Historial: La expiración originalmente no se usaba, siempre era null Estado actual: El campo volvió a reconocerse a partir de la versión 0.9.12, pero debe esperar a una actualización de la red Implementación: Siempre se establece en 0x0000000000000000 Cualquier valor de expiración distinto de cero hará que la firma de RouterInfo no supere la validación.\nProtocolos de transporte Protocolos actuales (a partir de la versión 2.10.0):\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 **Valores de estilo de transporte:** - `\"SSU2\"`: Transporte actual basado en UDP - `\"NTCP2\"`: Transporte actual basado en TCP - `\"NTCP\"`: Obsoleto, eliminado (no usar) - `\"SSU\"`: Obsoleto, eliminado (no usar) Opciones comunes Todos los transportes suelen incluir:\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) Opciones específicas de SSU2 Consulte la especificación de SSU2 (protocolo de transporte de I2P) para obtener todos los detalles.\nOpciones requeridas:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Opciones opcionales:\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) Ejemplo de RouterAddress SSU2:\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 Opciones específicas de NTCP2 Consulte la especificación de NTCP2 para obtener todos los detalles.\nOpciones obligatorias:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Opciones opcionales (desde la versión 0.9.50):\n\u0026#34;caps\u0026#34; = Capability string Ejemplo de NTCP2 RouterAddress:\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 Notas de implementación Valores de costo:\nUDP (SSU2) suele tener menor costo (5-6) debido a su eficiencia TCP (NTCP2) suele tener mayor costo (10-11) debido a la sobrecarga Menor costo = transporte preferido Múltiples direcciones:\nRouters pueden publicar múltiples entradas de RouterAddress (estructura de dirección del router en I2P) Diferentes transportes (SSU2 y NTCP2) Diferentes versiones de IP (IPv4 e IPv6) Los clientes seleccionan en función del coste y las capacidades Nombre de host vs IP:\nPara un mejor rendimiento, se prefieren las direcciones IP Se admiten los nombres de host, pero añaden sobrecarga de resolución DNS Considera usar IP para los RouterInfos (objetos de información del router en I2P) publicados Codificación Base64:\nTodas las claves y los datos binarios codificados en Base64 Base64 estándar (RFC 4648) Sin relleno ni caracteres no estándar JavaDoc: RouterAddress RouterInfo (información del router) Descripción: Información completa publicada sobre un router, almacenada en la base de datos de la red. Contiene identidad, direcciones y capacidades.\nFormato:\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey Almacenamiento de base de datos: - Tipo de base de datos: 0 - Clave: hash SHA-256 de RouterIdentity - Valor: estructura completa de RouterInfo\nMarca de tiempo de publicación: - Fecha de 8 bytes (milisegundos desde la época Unix) - Se usa para el versionado de RouterInfo (información del router) - Los routers publican nuevo RouterInfo periódicamente - Los floodfill mantienen la versión más reciente basándose en la marca de tiempo de publicación\nOrdenación de direcciones: - Histórico: routers muy antiguos requerían que las direcciones estuvieran ordenadas por el SHA-256 de sus datos - Actual: La ordenación NO es necesaria, no merece la pena implementarla por compatibilidad - Las direcciones pueden estar en cualquier orden\nPeer Size Field (tamaño de pares) (histórico): - Siempre 0 en I2P moderno - Estaba destinado a rutas restringidas (no implementado) - Si se implementara, iría seguido por esa cantidad de Router Hashes - Algunas implementaciones antiguas podrían haber requerido una lista de pares ordenada\nAsignación de opciones:\nLas opciones DEBEN estar ordenadas por clave. Las opciones estándar incluyen:\nOpciones de capacidades:\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable Opciones de red:\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; Opciones estadísticas:\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string Consulta la documentación de RouterInfo de la base de datos de la red para la lista completa de opciones estándar.\nCálculo de la firma:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length RouterInfo típico moderno (información del router):\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical Notas de implementación:\nVarias direcciones:\nLos routers normalmente publican 1-4 direcciones Variantes IPv4 e IPv6 Transportes SSU2 y/o NTCP2 Cada dirección es independiente Versionado:\nUn RouterInfo más reciente tiene una marca de tiempo published posterior Los Routers vuelven a publicar cada ~2 horas o cuando las direcciones cambian Los Floodfills almacenan y difunden solo la versión más reciente Validación:\nVerificar la firma antes de aceptar RouterInfo (información del router) Comprobar que el campo de expiración contenga únicamente ceros en cada RouterAddress (dirección del router) Validar que el mapeo de opciones esté ordenado por clave Comprobar que los tipos de certificado y de clave sean conocidos y admitidos Base de datos de red (netDb):\nFloodfills almacenan RouterInfo indexado mediante Hash(RouterIdentity) Se conserva durante ~2 días tras la última publicación Los routers consultan los floodfills para descubrir otros routers JavaDoc: RouterInfo Notas de implementación Orden de bytes (Endianness, disposición de los bytes) Predeterminado: Big-Endian (orden de bytes de red)\nLa mayoría de las estructuras de I2P usan orden de bytes big-endian (byte más significativo primero): - Todos los tipos enteros (1-8 bytes) - Marcas de tiempo de fecha - TunnelId - Prefijo de longitud de cadena - Tipos y longitudes de certificados - Códigos de tipo de clave - Campos de tamaño de mapeo\nExcepción: Little-Endian (orden de bytes con el menos significativo primero)\nLos siguientes tipos de claves utilizan codificación little-endian (orden de bytes de menor a mayor): - X25519 claves de cifrado (tipo 4) - EdDSA_SHA512_Ed25519 claves de firma (tipo 7) - EdDSA_SHA512_Ed25519ph claves de firma (tipo 8) - RedDSA_SHA512_Ed25519 claves de firma (tipo 11)\nImplementación:\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); Versionado de estructuras Nunca asumas tamaños fijos:\nMuchas estructuras tienen longitud variable: - RouterIdentity: 387+ bytes (no siempre 387) - Destination: 387+ bytes (no siempre 387) - LeaseSet2: Varía significativamente - Certificate: 3+ bytes\nLeer siempre los campos de tamaño: - Longitud del certificado en los bytes 1-2 - Tamaño del mapeo al principio - KeysAndCert siempre se calcula como 384 + 3 + certificate_length\nComprobar exceso de datos: - Prohibir datos basura al final de estructuras válidas - Validar que las longitudes de los certificados coincidan con los tipos de clave - Exigir las longitudes exactas previstas para los tipos de tamaño fijo\nRecomendaciones actuales (octubre de 2025) Para nuevas identidades de Router:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/es/proposals/161-ri-dest-padding/) Para nuevos destinos:\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/es/proposals/161-ri-dest-padding/) Para nuevos LeaseSets:\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per [Proposal 167](/proposals/167-service-records/) Signature: EdDSA (64 bytes) Para servicios cifrados:\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys Características obsoletas - No usar Cifrado obsoleto: - ElGamal (tipo 0) para identidades de Router (obsoleto desde 0.9.58) - cifrado ElGamal/AES+SessionTag (utilice ECIES-X25519)\nFirmas obsoletas: - DSA_SHA1 (tipo 0) para Identidades de Router (en desuso desde 0.9.58) - Variantes ECDSA (tipos 1-3) para nuevas implementaciones - Variantes RSA (tipos 4-6) excepto para archivos SU3\nFormatos de red obsoletos: - LeaseSet tipo 1 (usar LeaseSet2) - Lease (registro de arrendamiento de túnel) (44 bytes, usar Lease2) - Formato original de expiración de Lease\nTransportes obsoletos: - NTCP (eliminado en 0.9.50) - SSU (eliminado en 2.4.0)\nCertificados obsoletos: - HASHCASH (tipo 1) - HIDDEN (tipo 2) - SIGNED (tipo 3) - MULTIPLE (tipo 4)\nConsideraciones de seguridad Generación de claves: - Usa siempre generadores de números aleatorios criptográficamente seguros - Nunca reutilices claves en distintos contextos - Protege las claves privadas con controles de acceso adecuados - Borra de forma segura el material de clave de la memoria al finalizar\nVerificación de firmas: - Verifica siempre las firmas antes de confiar en los datos - Verifica que la longitud de la firma coincida con el tipo de clave - Verifica que los datos firmados incluyan los campos esperados - Para mapeos ordenados, verifica el orden de clasificación antes de firmar/verificar\nValidación de marca de tiempo: - Comprueba que los tiempos publicados sean razonables (no muy en el futuro) - Valida que las expiraciones de lease (entrada de tunnel en un leaseSet con vencimiento) no estén vencidas - Considera la tolerancia al desfase del reloj (±30 segundos típico)\nBase de datos de la red: - Validar todas las estructuras antes de almacenarlas - Aplicar límites de tamaño para evitar ataques DoS - Limitar la tasa de consultas y publicaciones - Verificar que las claves de la base de datos coincidan con los hashes de las estructuras\nNotas de compatibilidad Retrocompatibilidad: - ElGamal y DSA_SHA1 siguen siendo compatibles para routers heredados - Los tipos de clave obsoletos siguen siendo funcionales, pero se desaconsejan - Relleno compresible (Proposal 161 ) retrocompatible hasta la versión 0.6\nCompatibilidad con versiones futuras: - Los tipos de clave desconocidos pueden analizarse utilizando campos de longitud - Los tipos de certificado desconocidos pueden omitirse usando la longitud - Los tipos de firma desconocidos deben manejarse de forma adecuada - Los implementadores no deben fallar ante características opcionales desconocidas\nEstrategias de migración: - Admitir tanto los tipos de claves antiguos como los nuevos durante la transición - LeaseSet2 puede enumerar varias claves de cifrado - Las firmas fuera de línea permiten una rotación de claves segura - MetaLeaseSet permite una migración de servicios transparente\nPruebas y validación Validación de estructuras: - Verificar que todos los campos de longitud estén dentro de los rangos esperados - Comprobar que las estructuras de longitud variable se analicen correctamente - Validar que las firmas se verifiquen correctamente - Probar con estructuras de tamaño mínimo y máximo\nCasos límite: - Cadenas de longitud cero - Mapeos vacíos - Número mínimo y máximo de leases (entradas de entrega temporales en I2P) - Certificado con carga útil de longitud cero - Estructuras muy grandes (cerca de los tamaños máximos)\nInteroperabilidad: - Probar frente a la implementación oficial de Java I2P - Verificar la compatibilidad con i2pd - Probar con diversos contenidos de la base de datos de red - Validar frente a vectores de prueba conocidos como correctos\nReferencias Especificaciones Protocolo I2NP Protocolo I2CP Transporte SSU2 Transporte NTCP2 Protocolo de Tunnel Protocolo de datagramas Criptografía Descripción general de la criptografía Cifrado ElGamal/AES Cifrado ECIES-X25519 ECIES para Routers ECIES híbrido (poscuántico) Firmas Red25519 LeaseSet cifrado (conjunto de concesiones de túnel) Propuestas Propuesta 123: Nuevas entradas de netDB Propuesta 134: Tipos de firma GOST Propuesta 136: Tipos de firma experimentales Propuesta 145: ECIES-P256 Propuesta 156: Routers ECIES Propuesta 161: Generación de relleno Propuesta 167: Registros de servicio Propuesta 169: Criptografía poscuántica Índice de todas las propuestas Base de datos de la red Descripción general de la base de datos de la red Opciones estándar de RouterInfo Referencia de la API de JavaDoc Paquete de datos del núcleo PublicKey PrivateKey SessionKey SigningPublicKey SigningPrivateKey Signature Hash SessionTag TunnelId Certificate DataHelper KeysAndCert RouterIdentity Destination Lease LeaseSet Lease2 LeaseSet2 MetaLease MetaLeaseSet EncryptedLeaseSet RouterAddress RouterInfo Estándares externos RFC 7748 (X25519): Curvas elípticas para la seguridad RFC 7539 (ChaCha20): ChaCha20 y Poly1305 para los protocolos de la IETF RFC 4648 (Base64): Codificaciones de datos Base16, Base32 y Base64 FIPS 180-4 (SHA-256): Estándar de hash seguro FIPS 204 (ML-DSA): Estándar de firma digital basado en retículas modulares Registro de servicios de IANA Recursos de la comunidad Sitio web de I2P Foro de I2P GitLab de I2P Espejo de GitHub de I2P Índice de documentación técnica Información de la versión Lanzamiento de I2P 2.10.0 Historial de lanzamientos Registro de cambios Apéndice: Tablas de referencia rápida Referencia rápida de tipos de clave Estándar actual (recomendado para todas las implementaciones nuevas): - Cifrado: X25519 (tipo 4, 32 bytes, little-endian (orden de bytes de menor a mayor)) - Firma: EdDSA_SHA512_Ed25519 (tipo 7, 32 bytes, little-endian)\nHeredado (admitido pero obsoleto): - Cifrado: ElGamal (tipo 0, 256 bytes, big-endian) - Firma: DSA_SHA1 (tipo 0, privada de 20 bytes / pública de 128 bytes, big-endian)\nEspecializado: - Firma (LeaseSet cifrado): RedDSA_SHA512_Ed25519 (tipo 11, 32 bytes, little-endian (orden de bytes de menor a mayor))\nPoscuántico (Beta, sin finalizar): - Cifrado híbrido: variantes MLKEM_X25519 (tipos 5-7) - Cifrado poscuántico puro: variantes MLKEM (esquema de encapsulación de claves poscuántico) (aún sin códigos de tipo asignados)\nReferencia rápida de tamaños de estructuras Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes ### Referencia rápida del tipo de base de datos Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status ### Referencia rápida del protocolo de transporte Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 ### Referencia rápida de hitos de versión Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023[Proposal 161](/es/proposals/161-ri-dest-padding/) padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025[Proposal 167](/proposals/167-service-records/) service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) --- ","description":"Tipos de datos compartidos y formatos de serialización utilizados en las especificaciones de I2P","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"Estructuras comunes","url":"/es/docs/specs/common-structures/"},{"categories":null,"content":"Los filtros de acceso permiten a los operadores de servidores I2PTunnel permitir, denegar o limitar las conexiones entrantes según el Destino de origen y la tasa reciente de conexiones. El filtro es un archivo de texto plano de reglas. El archivo se lee de arriba hacia abajo y la primera regla que coincida se aplica.\nLos cambios en la definición del filtro surten efecto al reiniciar el tunnel. Algunas compilaciones pueden volver a leer listas basadas en archivos en tiempo de ejecución, pero planifique un reinicio para garantizar que se apliquen los cambios.\nFormato de archivo Una regla por línea. Las líneas en blanco se ignoran. # inicia un comentario que se extiende hasta el final de la línea. Las reglas se evalúan en orden; se usa la primera coincidencia. Umbrales Un umbral define cuántos intentos de conexión desde un único Destination (destino en I2P) se permiten en una ventana de tiempo deslizante.\nNumérico: N/S significa permitir N conexiones cada S segundos. Ejemplo: 15/5 permite hasta 15 conexiones cada 5 segundos. El intento N+1 dentro de la ventana se rechaza. Palabras clave: allow significa que no hay límite. deny significa rechazar siempre. Sintaxis de reglas Las reglas tienen la forma:\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; Dónde:\n\u0026lt;threshold\u0026gt; es N/S, allow o deny \u0026lt;scope\u0026gt; es uno de default, explicit, file o record (ver más abajo) \u0026lt;target\u0026gt; depende del ámbito Regla predeterminada Se aplica cuando ninguna otra regla coincide. Solo se permite una regla predeterminada. Si se omite, se permiten Destinos desconocidos sin restricciones.\n15/5 default allow default deny default Regla explícita Apunta a un Destino específico mediante una dirección Base32 (por ejemplo example1.b32.i2p) o una clave completa.\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p Regla basada en archivos Apunta a todos los Destinos enumerados en un archivo externo. Cada línea contiene un Destino; se permiten comentarios con # y líneas en blanco.\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt Nota operativa: Algunas implementaciones vuelven a leer las listas de archivos periódicamente. Si edita una lista mientras el tunnel está en ejecución, espere un breve retraso antes de que se detecten los cambios. Reinicie para aplicar de inmediato.\nGrabador (control progresivo) Un registrador supervisa los intentos de conexión y escribe en un archivo las Destinations (destinos de I2P) que superan un umbral. Luego puedes hacer referencia a ese archivo en una regla file para aplicar limitaciones o bloqueos en intentos futuros.\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt Verifique el soporte del grabador en su compilación antes de depender de él. Use listas file para un comportamiento garantizado.\nOrden de evaluación Pon primero las reglas específicas y luego las generales. Un patrón común:\nPermisos explícitos para pares de confianza Denegaciones explícitas para abusadores conocidos Listas de permitir/denegar basadas en archivos Registradores para limitación progresiva Regla predeterminada como comodín Ejemplo completo # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt Notas de implementación El filtro de acceso opera en la capa de tunnel, antes del procesamiento de la aplicación, de modo que el tráfico abusivo pueda rechazarse de forma temprana. Coloca el archivo de filtro en tu directorio de configuración de I2PTunnel y reinicia el tunnel para aplicar los cambios. Comparte listas basadas en archivos entre varios tunnels si quieres una política coherente en todos los servicios. ","description":"Sintaxis de los archivos de filtro de control de acceso de tunnel","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"Formato del filtro de acceso","url":"/es/docs/specs/filter-format/"},{"categories":null,"content":"Descripción general Los complementos de I2P son paquetes firmados que amplían la funcionalidad del router. Se distribuyen como archivos .xpi2p o .su3, se instalan en ~/.i2p/plugins/\u0026lt;name\u0026gt;/ (o en %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\ en Windows) y se ejecutan con permisos completos del router, sin sandboxing (aislamiento).\nTipos de complementos compatibles Aplicaciones web de la consola Nuevos eepsites con cgi-bin, aplicaciones web Temas de la consola Traducciones de la consola Programas Java (en el mismo proceso o en una JVM separada) Scripts de shell y binarios nativos Modelo de seguridad CRÍTICO: Los complementos se ejecutan en la misma JVM (Máquina Virtual de Java) con los mismos permisos que el router de I2P. Tienen acceso sin restricciones a: - Sistema de archivos (lectura y escritura) - APIs del router y su estado interno - Conexiones de red - Ejecución de programas externos\nLos complementos deben tratarse como código de plena confianza. Los usuarios deben verificar las fuentes y las firmas de los complementos antes de instalarlos.\nFormatos de archivo Formato SU3 (Altamente recomendado) Estado: Activo, formato preferido desde I2P 0.9.15 (septiembre de 2014)\nEl formato .su3 ofrece: - Claves de firma RSA-4096 (vs. DSA-1024 en xpi2p) - Firma almacenada en el encabezado del archivo - Número mágico: I2Psu3 - Mejor compatibilidad futura\nEstructura:\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] Formato XPI2P (heredado, obsoleto) Estado: Se mantiene por compatibilidad con versiones anteriores, no se recomienda para nuevos complementos\nEl formato .xpi2p utiliza firmas criptográficas antiguas: - Firmas DSA-1024 (obsoletas según NIST-800-57) - Firma DSA de 40 bytes antepuesta al ZIP - Requiere el campo key en plugin.config\nEstructura:\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] Ruta de migración: Al migrar de xpi2p (formato de actualización anterior) a su3 (formato de archivo de actualización firmado), proporcione tanto updateURL como updateURL.su3 durante la transición. Los routers modernos (0.9.15+) priorizan automáticamente SU3.\nEstructura del paquete y plugin.config Archivos necesarios plugin.config - Archivo de configuración estándar de I2P con pares clave-valor\nPropiedades obligatorias Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format **Ejemplos de formato de versión:** - `1.2.3` - `1.2.3-4` - `2.0.0-beta.1` Separadores válidos: . (punto), - (guion), _ (guion bajo)\nPropiedades opcionales de metadatos Mostrar información date - Fecha de lanzamiento (timestamp long de Java) author - Nombre del desarrollador (se recomienda user@mail.i2p) description - Descripción en inglés description_xx - Descripción localizada (xx = código de idioma) websiteURL - Página de inicio del plugin (http://foo.i2p/) license - Identificador de la licencia (p. ej., \u0026ldquo;Apache-2.0\u0026rdquo;, \u0026ldquo;GPL-3.0\u0026rdquo;) Configuración de actualizaciones updateURL - Ubicación de actualización XPI2P (heredado) updateURL.su3 - Ubicación de actualización SU3 (preferida) min-i2p-version - Versión mínima de I2P requerida max-i2p-version - Versión máxima de I2P compatible min-java-version - Versión mínima de Java (p. ej., 1.7, 17) min-jetty-version - Versión mínima de Jetty (use 6 para Jetty 6+) max-jetty-version - Versión máxima de Jetty (use 5.99999 para Jetty 5) Comportamiento de la instalación dont-start-at-install - Predeterminado false. Si es true, requiere inicio manual router-restart-required - Predeterminado false. Informa al usuario de que se requiere reinicio después de la actualización update-only - Predeterminado false. Falla si el complemento no está instalado previamente install-only - Predeterminado false. Falla si el complemento ya existe min-installed-version - Versión mínima requerida para la actualización max-installed-version - Versión máxima que se puede actualizar disableStop - Predeterminado false. Oculta el botón de detener si es true Integración con la consola consoleLinkName - Texto para el enlace de la barra de resumen de la consola consoleLinkName_xx - Texto del enlace localizado (xx = código de idioma) consoleLinkURL - Destino del enlace (p. ej., /appname/index.jsp) consoleLinkTooltip - Texto emergente al pasar el cursor (compatible desde la versión 0.7.12-6) consoleLinkTooltip_xx - Texto emergente localizado console-icon - Ruta al icono de 32x32 (compatible desde la versión 0.9.20) icon-code - PNG de 32x32 codificado en Base64 para plugins sin recursos web (desde la versión 0.9.25) Requisitos de plataforma (solo visualización) required-platform-OS - Requisito del sistema operativo (no impuesto) other-requirements - Requisitos adicionales (p. ej., \u0026ldquo;Python 3.8+\u0026rdquo;) Gestión de dependencias (sin implementar) depends - Dependencias del plugin separadas por comas depends-version - Requisitos de versión para las dependencias langs - Contenido del paquete de idiomas type - Tipo de plugin (app/theme/locale/webapp) Sustitución de variables en la URL de actualización Estado de la funcionalidad: Disponible desde I2P 1.7.0 (0.9.53)\nTanto updateURL como updateURL.su3 admiten variables específicas de la plataforma:\nVariables: - $OS - Sistema operativo: windows, linux, mac - $ARCH - Arquitectura: 386, amd64, arm64\nEjemplo:\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 Resultado en Windows AMD64:\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 Esto permite archivos plugin.config únicos para compilaciones específicas de la plataforma.\nEstructura de directorios Diseño estándar plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration Propósitos del directorio console/locale/ - Archivos JAR con paquetes de recursos para traducciones básicas de I2P - Las traducciones específicas de complementos deberían estar en console/webapps/*.war o lib/*.jar\nconsole/themes/ - Cada subdirectorio contiene un tema de consola completo - Se añade automáticamente a la ruta de búsqueda de temas\nconsole/webapps/ - archivos .war para la integración con la consola - Se inician automáticamente a menos que estén deshabilitados en webapps.config - El nombre del WAR no tiene que coincidir con el nombre del complemento\neepsite/ - eepsite completo con su propia instancia de Jetty - Requiere configuración de jetty.xml con sustitución de variables - Consulte los ejemplos de los plugins zzzot y pebble\nlib/ - Bibliotecas JAR de complementos - Especificar en el classpath mediante clients.config o webapps.config\nConfiguración de la aplicación web Formato de webapps.config Archivo de configuración estándar de I2P que controla el comportamiento de la aplicación web.\nSintaxis:\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar Notas importantes: - Antes del router 0.7.12-9, use plugin.warname.startOnLoad para compatibilidad - Antes de la API 0.9.53, classpath solo funcionaba si el warname (nombre del WAR) coincidía con el nombre del plugin - A partir de 0.9.53+, classpath funciona para cualquier nombre de aplicación web\nBuenas prácticas para aplicaciones web Implementación de ServletContextListener\nImplementar javax.servlet.ServletContextListener para tareas de limpieza O sobrescribir destroy() en el servlet Garantiza un apagado correcto durante las actualizaciones y al detener el router Gestión de librerías\nColoca los JAR compartidos en lib/, no dentro del WAR Haz referencia mediante el classpath de webapps.config Permite instalar y actualizar complementos por separado Evitar bibliotecas en conflicto\nNunca empaquetes JARs de Jetty, Tomcat ni de servlets Nunca empaquetes JARs de una instalación estándar de I2P Revisa la sección de classpath para las bibliotecas estándar Requisitos de compilación\nNo incluya archivos fuente .java o .jsp Precompile todas las JSP para evitar retrasos en el inicio No se puede asumir la disponibilidad de un compilador de Java/JSP Compatibilidad con la API de Servlet\nI2P es compatible con Servlet 3.0 (desde 0.9.30) NO se admite el escaneo de anotaciones (@WebContent) Debe proporcionar el descriptor de despliegue web.xml tradicional Versión de Jetty (servidor web Java)\nActual: Jetty 9 (I2P 0.9.30+) Usa net.i2p.jetty.JettyStart como capa de abstracción Protege contra cambios en la API de Jetty Configuración del cliente Formato de clients.config Define los clientes (servicios) iniciados con el complemento.\nCliente básico:\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties Cliente con Detener/Desinstalar:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar Referencia de propiedades Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths ### Sustitución de variables Las siguientes variables se sustituyen en args, stopargs, uninstallargs y classpath:\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 ### Clientes gestionados vs. no gestionados Clientes gestionados (Recomendado, desde 0.9.4): - Instanciados por ClientAppManager - Mantiene el seguimiento de referencias y estado - Gestión del ciclo de vida más sencilla - Mejor gestión de memoria\nClientes no gestionados: - Iniciados por el router, sin seguimiento de estado - Deben manejar múltiples llamadas de inicio/detención de forma adecuada - Usar estado estático o archivos PID (identificador de proceso) para la coordinación - Invocados al apagado del router (a partir de 0.7.12-3)\nShellService (servicio de shell; desde 0.9.53 / 1.7.0) Solución genérica para ejecutar programas externos con seguimiento automático del estado.\nCaracterísticas: - Gestiona el ciclo de vida del proceso - Se comunica con ClientAppManager (gestor de aplicaciones cliente) - Gestión automática de PID - Compatibilidad multiplataforma\nUso:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh Para scripts específicos de la plataforma:\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH Alternativa (antigua): Escriba un envoltorio en Java que compruebe el tipo de sistema operativo y llame a ShellCommand con el archivo .bat o .sh correspondiente.\nProceso de instalación Flujo de instalación del usuario El usuario pega la URL del plugin en la página de configuración de plugins de la Router Console (/configplugins) El Router descarga el archivo del plugin Verificación de firma (falla si la clave es desconocida y el modo estricto está habilitado) Comprobación de integridad del ZIP Extraer y analizar plugin.config Verificación de compatibilidad de versiones (min-i2p-version, min-java-version, etc.) Detección de conflictos de nombre de la aplicación web Detener el plugin existente si es una actualización Validación del directorio (debe estar bajo plugins/) Extraer todos los archivos al directorio del plugin Actualizar plugins.config Iniciar el plugin (a menos que dont-start-at-install=true) Seguridad y confianza Gestión de claves: - Modelo de confianza \u0026lsquo;first-key-seen\u0026rsquo; (se confía en la primera clave que se ve) para nuevos firmantes - Solo las claves de jrandom y zzz vienen preincluidas - A partir de la 0.9.14.1, las claves desconocidas se rechazan por defecto - Una propiedad avanzada puede anularlo para desarrollo\nRestricciones de instalación: - Los archivos comprimidos deben extraerse únicamente en el directorio del plugin - El instalador rechaza rutas fuera de plugins/ - Los plugins pueden acceder a archivos en otras ubicaciones después de la instalación - Sin sandboxing (aislamiento en entorno controlado) ni aislamiento de privilegios\nMecanismo de actualización Proceso de comprobación de actualizaciones Router lee updateURL.su3 (preferido) o updateURL desde plugin.config Solicitud HTTP HEAD o GET parcial para obtener los bytes 41-56 Extraer la cadena de versión del archivo remoto Comparar con la versión instalada usando VersionComparator Si es más reciente, pedir confirmación al usuario o descargar automáticamente (según la configuración) Detener el complemento Instalar la actualización Iniciar el complemento (a menos que la preferencia del usuario haya cambiado) Comparación de versiones Versiones analizadas como componentes separados por punto/guion/guion bajo: - 1.2.3 \u0026lt; 1.2.4 - 1.2.3 \u0026lt; 1.2.3-1 - 2.0.0 \u0026gt; 1.9.9\nLongitud máxima: 16 bytes (debe coincidir con el encabezado SUD/SU3)\nMejores prácticas de actualización Incrementa siempre el número de versión para los lanzamientos Prueba la ruta de actualización desde la versión anterior Considera router-restart-required para cambios importantes Proporciona tanto updateURL como updateURL.su3 durante la migración Usa un sufijo de número de compilación para pruebas (1.2.3-456) Ruta de clases y bibliotecas estándar Siempre disponible en el Classpath Los siguientes archivos JAR de $I2P/lib siempre están en el classpath para I2P 0.9.30+:\nJAR Contents Plugin Usage i2p.jarCore APIRequired for all plugins mstreaming.jarStreaming APIMost plugins need streaming.jarStreaming implementationMost plugins need i2ptunnel.jarI2PTunnelHTTP/server plugins router.jarRouter internalsRarely needed, avoid if possible javax.servlet.jarServlet 3.1, JSP 2.3 APIPlugins with servlets/JSPs jasper-runtime.jarJasper compiler/runtimePlugins with JSPs commons-el.jarEL 3.0 APIJSPs using expression language jetty-i2p.jarJetty utilitiesPlugins starting Jetty org.mortbay.jetty.jarJetty 9 baseCustom Jetty instances sam.jarSAM APIRarely needed addressbook.jarSubscription/blockfileUse NamingService instead routerconsole.jarConsole librariesNot public API, avoid jbigi.jarNative cryptoPlugins should not need systray.jarURL launcherRarely needed wrapper.jarService wrapperPlugins should not need ### Notas especiales commons-logging.jar: - Vacío desde 0.9.30 - Antes de 0.9.30: Apache Tomcat JULI - Antes de 0.9.24: Commons Logging + JULI - Antes de 0.9: solo Commons Logging\njasper-compiler.jar: - Vacío desde Jetty 6 (0.9)\nsystray4j.jar: - Eliminado en 0.9.26\nNo está en el Classpath (ruta de clases) (Debe especificarlo) JAR Contents Usage jstl.jarStandard TaglibJSP tag libraries standard.jarStandard TaglibJSP tag libraries ### Especificación de la ruta de clases En clients.config:\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar En webapps.config:\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar Importante: A partir de la versión 0.7.13-3, los classpath son específicos por hilo, no a nivel de toda la JVM. Especifique el classpath completo para cada cliente.\nRequisitos de la versión de Java Requisitos actuales (octubre de 2025) I2P 2.10.0 y anteriores: - Mínimo: Java 7 (requerido desde 0.9.24, enero de 2016) - Recomendado: Java 8 o superior\nI2P 2.11.0 y posteriores (PRÓXIMAMENTE): - Mínimo: Java 17+ (anunciado en las notas de la versión 2.9.0) - Aviso con dos versiones de antelación (2.9.0 → 2.10.0 → 2.11.0)\nEstrategia de compatibilidad de complementos Para la máxima compatibilidad (hasta I2P 2.10.x inclusive):\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 Para las características de Java 8+:\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 Para las características de Java 11+:\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 Preparación para 2.11.0+:\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 Mejores prácticas de compilación Al compilar con un JDK más reciente para una versión de destino más antigua:\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; Esto impide utilizar APIs no disponibles en la versión de Java de destino.\nCompresión Pack200 - OBSOLETO Actualización crítica: no utilice Pack200 (formato de compresión para JAR de Java) Estado: OBSOLETO Y ELIMINADO\nLa especificación original recomendaba encarecidamente la compresión Pack200 para una reducción del tamaño del 60-65%. Esto ya no es válido.\nCronología: - JEP 336: Pack200 se marcó como obsoleto en Java 11 (septiembre de 2018) - JEP 367: Pack200 se eliminó en Java 14 (marzo de 2020)\nLa especificación oficial de actualizaciones de I2P establece: \u0026gt; \u0026ldquo;Los archivos JAR y WAR en el ZIP ya no se comprimen con pack200, como se documenta arriba para los archivos \u0026lsquo;su2\u0026rsquo;, porque las versiones recientes de los entornos de ejecución de Java ya no lo admiten.\u0026rdquo;\nQué hacer:\nEliminar pack200 (formato de compresión de JAR de Java) de los procesos de compilación inmediatamente Usar compresión ZIP estándar Considerar alternativas: ProGuard/R8 (minificador/ofuscador) para reducción del tamaño del código UPX (compresor de ejecutables) para binarios nativos Algoritmos de compresión modernos (zstd, brotli) si se proporciona un desempaquetador personalizado Para plugins existentes: - Los routers antiguos (0.7.11-5 hasta Java 10) aún pueden desempaquetar pack200 - Los routers nuevos (Java 11+) no pueden desempaquetar pack200 - Republicue los plugins sin compresión pack200\nClaves de firma y seguridad Generación de claves (formato SU3) Utiliza el script makeplugin.sh del repositorio i2p.scripts:\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ Detalles clave: - Algoritmo: RSA_SHA512_4096 - Formato: certificado X.509 - Almacenamiento: formato de almacén de claves de Java\nFirma de plugins # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 Mejores prácticas de gestión de claves Generar una vez, proteger para siempre\nLos Routers rechazan nombres de clave duplicados con claves diferentes Los Routers rechazan claves duplicadas con nombres de clave diferentes Se rechazan las actualizaciones si la clave y el nombre no coinciden Almacenamiento seguro\nHaz una copia de seguridad del almacén de claves (keystore) de forma segura Usa una frase de contraseña segura Nunca lo confirmes en el control de versiones Rotación de claves\nNo está soportado por la arquitectura actual Planificar el uso de claves a largo plazo Considerar esquemas de multifirma para el desarrollo en equipo Firma DSA heredada (XPI2P) Estado: Funcional pero obsoleto\nFirmas DSA-1024 utilizadas por el formato xpi2p: - firma de 40 bytes - clave pública de 172 caracteres en base64 - NIST-800-57 recomienda (L=2048, N=224) como mínimo - I2P utiliza parámetros más débiles (L=1024, N=160)\nRecomendación: Utiliza SU3 (formato de archivo firmado de I2P) con RSA-4096 en su lugar.\nDirectrices para el desarrollo de plugins Mejores prácticas esenciales Documentación\nProporcionar un README claro con instrucciones de instalación Documentar las opciones de configuración y los valores predeterminados Incluir un registro de cambios con cada versión Especificar las versiones requeridas de I2P/Java Optimización del tamaño\nIncluir solo los archivos necesarios Nunca empaquetar JARs del router Separar paquetes de instalación y actualización (bibliotecas en lib/) Usar compresión Pack200 OBSOLETO - Usar ZIP estándar Configuración\nNunca modifiques plugin.config en tiempo de ejecución Usa un archivo de configuración separado para los ajustes en tiempo de ejecución Documenta los ajustes necesarios del router (puertos SAM, tunnels, etc.) Respeta la configuración existente del usuario Uso de recursos\nEvita un consumo agresivo de ancho de banda por defecto Implementa límites razonables de uso de la CPU Libera los recursos al finalizar Usa hilos daemon (hilos en segundo plano) cuando corresponda Pruebas\nProbar instalación/actualización/desinstalación en todas las plataformas Probar actualizaciones desde la versión anterior Verificar detención/reinicio de la aplicación web durante las actualizaciones Probar con la versión mínima de I2P admitida Sistema de archivos\nNunca escribas en $I2P (puede ser de solo lectura) Escribe los datos en tiempo de ejecución en $PLUGIN o $CONFIG Usa I2PAppContext para el descubrimiento de directorios No asumas la ubicación de $CWD Compatibilidad\nNo dupliques las clases estándar de I2P Extiende las clases si es necesario, no las reemplaces Comprueba min-i2p-version, min-jetty-version en plugin.config Prueba con versiones antiguas de I2P si vas a admitirlas Gestión del apagado\nImplementa stopargs adecuados en clients.config Registra ganchos de apagado: I2PAppContext.addShutdownTask() Gestiona múltiples llamadas de inicio/parada de forma adecuada Configura todos los hilos en modo demonio Seguridad\nValidar toda entrada externa Nunca llamar a System.exit() Respetar la privacidad del usuario Seguir prácticas de codificación segura Licencias\nEspecifica claramente la licencia del plugin Respeta las licencias de las bibliotecas incluidas Incluye la atribución requerida Proporciona acceso al código fuente si se requiere Consideraciones avanzadas Gestión de la zona horaria: - Router establece la zona horaria de la JVM en UTC - Zona horaria real del usuario: propiedad i2p.systemTimeZone de I2PAppContext\nDescubrimiento de directorios:\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args Numeración de versiones: - Usa versionado semántico (major.minor.patch) - Añade un número de compilación para pruebas (1.2.3-456) - Garantiza un incremento monótono en las actualizaciones\nAcceso a clases del router: - En general, evite dependencias de router.jar - En su lugar, use las API públicas en i2p.jar - En el futuro, I2P podría restringir el acceso a clases del router\nPrevención de fallos de la JVM (histórico): - Corregido en 0.7.13-3 - Utiliza correctamente los cargadores de clases - Evita actualizar archivos JAR en un plugin en ejecución - Diseña para reiniciar tras la actualización si es necesario\nComplementos de Eepsite Descripción general Los plugins pueden proporcionar eepsites completos con sus propias instancias de Jetty e I2PTunnel.\nArquitectura No intente: - Instalar en un eepsite existente - Fusionar con el eepsite predeterminado del router - Asumir la disponibilidad de un único eepsite\nEn su lugar: - Iniciar una nueva instancia de I2PTunnel (mediante la CLI (interfaz de línea de comandos)) - Iniciar una nueva instancia de Jetty - Configurar ambos en clients.config\nEstructura de ejemplo plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] Sustitución de variables en jetty.xml Utiliza la variable $PLUGIN para las rutas:\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; Router realiza una sustitución durante el inicio del plugin.\nEjemplos Implementaciones de referencia: - zzzot plugin - Rastreador de torrents - pebble plugin - Plataforma de blogs\nAmbos están disponibles en la página de plugins de zzz (I2P-internal).\nIntegración con la consola Enlaces de la barra de resumen Añadir un enlace clicable a la barra de resumen de la consola del router:\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface Versiones localizadas:\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle Iconos de la consola Archivo de imagen (desde 0.9.20):\nconsole-icon=/myicon.png Ruta relativa a consoleLinkURL si se especifica (desde 0.9.53); en caso contrario, relativa al nombre de la aplicación web.\nIcono incrustado (desde 0.9.25):\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... Generar con:\nbase64 -w 0 icon-32x32.png O en Java:\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png Requisitos: - 32x32 píxeles - Formato PNG - Codificado en Base64 (sin saltos de línea)\nInternacionalización Paquetes de traducción Para las traducciones base de I2P: - Coloque los archivos JAR en console/locale/ - Contienen paquetes de recursos para las aplicaciones de I2P existentes - Nomenclatura: messages_xx.properties (xx = código de idioma)\nPara traducciones específicas de plugins: - Incluye en console/webapps/*.war - O incluye en lib/*.jar - Usa el método estándar de Java ResourceBundle\nCadenas localizadas en plugin.config description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble Campos admitidos: - description_xx - consoleLinkName_xx - consoleLinkTooltip_xx\nTraducción del tema de la consola Los temas en console/themes/ se añaden automáticamente a la ruta de búsqueda de temas.\nComplementos específicos de la plataforma Enfoque de paquetes separados Utilice distintos nombres de complementos para cada plataforma:\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac Enfoque de sustitución de variables Un único plugin.config con variables de plataforma:\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 En clients.config:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH Detección del sistema operativo en tiempo de ejecución Enfoque en Java para la ejecución condicional:\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } Solución de problemas Problemas comunes El plugin no se inicia: 1. Compruebe la compatibilidad con la versión de I2P (min-i2p-version) 2. Verifique la versión de Java (min-java-version) 3. Revise los registros del router en busca de errores 4. Verifique que todos los archivos JAR requeridos estén en el classpath\nAplicación web no accesible: 1. Comprueba que webapps.config no la deshabilita 2. Comprueba la compatibilidad de la versión de Jetty (servidor web Java) (min-jetty-version) 3. Comprueba que web.xml esté presente (no se admite el escaneo de anotaciones) 4. Comprueba si hay nombres de aplicaciones web en conflicto\nLa actualización falla: 1. Verifica que la cadena de versión haya aumentado 2. Verifica que la firma sea válida con la clave de firma 3. Asegúrate de que el nombre del plugin coincida con la versión instalada 4. Revisa la configuración update-only/install-only\nEl programa externo no se detiene: 1. Usa ShellService (servicio de shell) para la gestión automática del ciclo de vida 2. Implementa un manejo adecuado de stopargs 3. Comprueba la limpieza del archivo PID 4. Verifica la terminación del proceso\nRegistro de depuración Habilitar el registro de depuración en el router:\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG Revisa los registros:\n~/.i2p/logs/log-router-0.txt Información de referencia Especificaciones oficiales Especificación de complementos Formato de configuración Especificación de actualización Criptografía Historial de versiones de I2P Versión actual: - I2P 2.10.0 (8 de septiembre de 2025)\nVersiones principales desde 0.9.53: - 2.10.0 (sep 2025) - anuncio sobre Java 17+ - 2.9.0 (jun 2025) - advertencia sobre Java 17+ - 2.8.0 (oct 2024) - pruebas de criptografía poscuántica - 2.6.0 (may 2024) - bloqueo de I2P-over-Tor - 2.4.0 (dic 2023) - mejoras de seguridad en NetDB - 2.2.0 (mar 2023) - control de congestión - 2.1.0 (ene 2023) - mejoras en la red - 2.0.0 (nov 2022) - protocolo de transporte SSU2 - 1.7.0/0.9.53 (feb 2022) - ShellService (servicio de shell), sustitución de variables - 0.9.15 (sep 2014) - formato SU3 introducido\nNumeración de versiones: - Serie 0.9.x: Hasta la versión 0.9.53 - Serie 2.x: A partir de la versión 2.0.0 (introducción de SSU2)\nRecursos para desarrolladores Código fuente: - Repositorio principal: https://i2pgit.org/I2P_Developers/i2p.i2p - Espejo de GitHub: https://github.com/i2p/i2p.i2p Ejemplos de plugins: - zzzot (rastreador de BitTorrent) - pebble (plataforma de blogs) - i2p-bote (correo electrónico sin servidor) - orchid (cliente de Tor) - seedless (intercambio de pares)\nHerramientas de compilación: - makeplugin.sh - Generación y firma de claves - Se encuentra en el repositorio i2p.scripts - Automatiza la creación y la verificación de su3 (archivo de actualización firmado de I2P)\nSoporte de la comunidad Foros: - Foro de I2P - zzz.i2p (interno de I2P)\nIRC/Chat: - #i2p-dev en OFTC - IRC de I2P dentro de la red\nApéndice A: Ejemplo completo de plugin.config # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space Apéndice B: Ejemplo completo de clients.config # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config Apéndice C: Ejemplo completo de webapps.config # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true Apéndice D: Lista de verificación de migración (0.9.53 a 2.10.0) Cambios necesarios Eliminar la compresión Pack200 del proceso de compilación\nEliminar las tareas de Pack200 de los scripts de Ant/Maven/Gradle Volver a publicar los complementos existentes sin Pack200 Revisar los requisitos de versión de Java\nConsiderar exigir Java 11+ para nuevas funcionalidades Planificar el requisito de Java 17+ para I2P 2.11.0 Actualizar min-java-version en plugin.config Actualizar la documentación\nEliminar las referencias a Pack200 (formato de compresión de Java) Actualizar los requisitos de versión de Java Actualizar las referencias de versión de I2P (0.9.x → 2.x) Cambios recomendados Fortalecer las firmas criptográficas\nMigrar de XPI2P (formato de paquete de complementos de I2P) a SU3 (formato de archivo firmado para actualizaciones/paquetes de I2P) si aún no se ha hecho Usar claves RSA-4096 para nuevos complementos Aproveche las nuevas funciones (si usa 0.9.53+)\nUse las variables $OS / $ARCH para actualizaciones específicas de la plataforma Use ShellService (servicio Shell) para programas externos Use el classpath mejorado de la aplicación web (funciona para cualquier nombre de WAR) Probar compatibilidad\nProbar en I2P 2.10.0 Verificar con Java 8, 11, 17 Comprobar en Windows, Linux, macOS Mejoras opcionales Implementar un ServletContextListener (escuchador del contexto del servlet) adecuado Añadir descripciones localizadas Proporcionar un icono para la consola Mejorar la gestión del cierre Añadir un registro exhaustivo Escribir pruebas automatizadas ","description":".xpi2p / .su3 reglas de empaquetado para complementos de I2P","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"Formato del paquete del complemento","url":"/es/docs/specs/plugin/"},{"categories":null,"content":"Descripción general NOTA: OBSOLETO - Ahora admitimos tres formatos, en orden de preferencia:\nMaxmind geoip2 (GeoLite2-Country.mmdb) incluido con todas las instalaciones excepto los paquetes de Debian y Android Maxmind geoip1 (GeoIP.dat) en el paquete geoip-database de Debian El formato Tor de IPv4 (geoip.txt) y el formato IPv6 personalizado (geoipv6.dat.gz) documentados más abajo, todavía se admiten, pero no se usan. Esta página especifica el formato de los distintos archivos GeoIP, que el router utiliza para consultar el país asociado a una dirección IP.\nFormato del nombre del país (countries.txt) Este formato se genera fácilmente a partir de archivos de datos disponibles en muchas fuentes públicas. Por ejemplo:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Especificaciones de formato:\nLa codificación es UTF-8 \u0026lsquo;#\u0026rsquo; en la columna 1 indica una línea de comentario Las líneas de entrada son CountryCode,CountryName CountryCode es el código ISO de dos letras, en mayúsculas CountryName está en inglés Formato IPv4 (geoip.txt) Este formato se toma prestado de Tor y se genera fácilmente a partir de archivos de datos disponibles en muchas fuentes públicas. Por ejemplo:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Especificaciones de formato:\nLa codificación es ASCII \u0026lsquo;#\u0026rsquo; en la columna 1 especifica una línea de comentario Las líneas de entrada son FromIP,ToIP,CountryCode FromIP y ToIP son valores enteros sin signo que representan la IP de 4 bytes CountryCode es el código ISO de dos letras, en mayúsculas Las líneas de entrada deben ordenarse por FromIP numérico Formato de IPv6 (geoipv6.dat.gz) Este es un formato binario comprimido diseñado para I2P. El archivo está comprimido con gzip. Formato descomprimido:\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) NOTAS:\nLos datos deben estar ordenados (long con signo en complemento a dos), sin solapamientos. Por lo tanto, el orden es 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF. La clase GeoIPv6.java contiene un programa para generar este formato a partir de fuentes públicas como los datos de Maxmind GeoLite. La búsqueda GeoIP de IPv6 es compatible a partir de la versión 0.9.8. ","description":"Especificaciones del formato de archivo GeoIP heredado para consultas de IP a país","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"Formatos de archivos GeoIP","url":"/es/docs/legacy/formatos-de-archivos-geoip/"},{"categories":null,"content":"Clonar y subir repositorios dentro de I2P utiliza los mismos comandos de Git que ya conoces—tu cliente simplemente se conecta a través de túneles I2P en lugar de TCP/IP. Esta guía explica cómo configurar una cuenta, configurar túneles y manejar conexiones lentas.\nInicio rápido: El acceso de solo lectura funciona a través del proxy HTTP: http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git. Sigue los pasos a continuación para acceso de lectura/escritura por SSH.\n1. Crear una Cuenta Elige un servicio Git de I2P y regístrate:\nDentro de I2P: http://git.idk.i2p Espejo en Clearnet: https://i2pgit.org El registro puede requerir aprobación manual; consulta la página de inicio para obtener instrucciones. Una vez aprobado, bifurca o crea un repositorio para tener algo con qué probar.\n2. Configurar un cliente I2PTunnel (SSH) Abre la consola del router → I2PTunnel y añade un nuevo túnel Client. Introduce el destino del servicio (Base32 o Base64). Para git.idk.i2p encontrarás tanto destinos HTTP como SSH en la página principal del proyecto. Elige un puerto local (por ejemplo localhost:7442). Activa el inicio automático si planeas usar el túnel frecuentemente. La interfaz confirmará el nuevo túnel y mostrará su estado. Cuando esté en ejecución, los clientes SSH pueden conectarse a 127.0.0.1 en el puerto elegido.\n3. Clonar mediante SSH Usa el puerto del túnel con GIT_SSH_COMMAND o una configuración SSH:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git Si el primer intento falla (los túneles pueden ser lentos), intenta un clonado superficial:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow Configura Git para obtener todas las ramas:\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin Consejos de Rendimiento Agrega uno o dos túneles de respaldo en el editor de túneles para mejorar la resiliencia. Para pruebas o repositorios de bajo riesgo, puedes reducir la longitud del túnel a 1 hop, pero ten en cuenta el compromiso con el anonimato. Mantén GIT_SSH_COMMAND en tu entorno o añade una entrada a ~/.ssh/config: Host git.i2p HostName 127.0.0.1 Port 7442 User git Luego clona usando git clone git@git.i2p:namespace/project.git.\n4. Sugerencias de Flujo de Trabajo Adopta un flujo de trabajo de fork-and-branch común en GitLab/GitHub:\nConfigura un remoto upstream: git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p Mantén tu master sincronizado: git pull upstream master Crea ramas de características para los cambios: git checkout -b feature/new-thing Sube las ramas a tu fork: git push origin feature/new-thing Envía una solicitud de fusión, luego actualiza el master de tu fork desde upstream mediante fast-forward. 5. Recordatorios de Privacidad Git almacena las marcas de tiempo de los commits en tu zona horaria local. Para forzar marcas de tiempo UTC: git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; Usa git utccommit en lugar de git commit cuando la privacidad es importante.\nEvite incluir URLs de clearnet o direcciones IP en mensajes de commit o metadatos del repositorio si el anonimato es una preocupación. 6. Solución de problemas Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. Para escenarios avanzados (replicar repositorios externos, distribuir bundles), consulta las guías complementarias: [Flujos de trabajo con bundle de Git](/docs/applications/git-bundle/) y [Alojar GitLab sobre I2P](/docs/guides/gitlab/). ","description":"Conectar clientes Git a servicios alojados en I2P como i2pgit.org","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"Git sobre I2P","url":"/es/docs/applications/git/"},{"categories":null,"content":"Este glosario define términos comunes utilizados en la documentación y discusiones de I2P.\nB Blockchain Un libro de contabilidad distribuido que puede registrar transacciones entre múltiples partes de manera eficiente y de forma verificable y permanente.\nD Descentralización Arquitectura de red que evita la dependencia de una sola entidad. Abarca tecnologías peer-to-peer, blockchain, federadas y distribuidas.\nDestination La identidad criptográfica de un tunnel. Estas son las identidades de clientes y servidores dentro de la red I2P.\nDHT (Distributed Hash Table) Utilizada en algunos proyectos para conectar peers entre sí mediante el almacenamiento de información en forma de pares clave-valor de manera distribuida.\nSistemas Distribuidos Tema académico dentro de las Ciencias de la Computación relacionado con el diseño de sistemas informáticos que consisten en muchas computadoras individuales conectadas a través de una red.\nF Federado La federación permite que implementaciones separadas de un servicio se comuniquen entre sí a través de un protocolo común.\nH Hash Un número, usualmente mostrado como una cadena de letras y números. Puede servir como una \u0026ldquo;huella digital\u0026rdquo; que identifica de manera única los datos.\nI I2P Invisible Internet Project: un proyecto diseñado para proporcionar una capa de anonimato, permitiendo a los usuarios comunicarse de forma anónima mediante una variedad de aplicaciones.\nDirección IP Un número de una computadora o red que es único y, por lo tanto, puede ser utilizado para direccionarla.\nL LeaseSet Una colección de información requerida para comunicarse con un cliente o servidor en un Destination particular.\nP Peer-to-Peer (P2P) Los pares ponen a disposición una parte de sus recursos directamente a otros participantes de la red, sin necesidad de coordinación central mediante servidores o hosts estables.\nR Router El software central de I2P, que enruta paquetes cifrados en la red I2P.\nRouterIdentity Una colección de información requerida para comunicarse directamente con un router.\nT TCP/UDP Los dos protocolos de transporte fundamentales utilizados en Internet.\nTunnel Una vía de comunicación anónima entre un cliente o servidor y la red I2P.\nU UX Experiencia de usuario (User experience), la experiencia general de una persona al usar un producto o servicio.\nW WebRTC Un estándar de protocolo para establecer conexiones en un navegador web donde los datos pasan directamente entre usuarios.\n","description":"Términos y definiciones comunes utilizados en la documentación de I2P","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"Glosario","url":"/es/docs/overview/glosario/"},{"categories":null,"content":"Esta guía proporciona una descripción general de la Consola del Router I2P y sus páginas de configuración. Cada sección explica qué hace la página y para qué está destinada, ayudándote a comprender cómo monitorear y configurar tu router I2P.\nAcceso a la Consola del Router La Consola del Router I2P es el centro de control para gestionar y monitorear tu router I2P. Por defecto, se puede acceder en la Consola del Router I2P una vez que tu router I2P esté en funcionamiento.\nLa página de inicio muestra varias secciones clave:\nAplicaciones - Acceso rápido a las aplicaciones integradas de I2P como Correo electrónico, Torrents, Gestor de servicios ocultos y Servidor web Sitios comunitarios de I2P - Enlaces a recursos importantes de la comunidad incluyendo foros, documentación y sitios web del proyecto Configuración y ayuda - Herramientas para configurar ajustes de ancho de banda, gestionar plugins y acceder a recursos de ayuda Información de red y para desarrolladores - Acceso a gráficos, registros, documentación técnica y estadísticas de red Libreta de Direcciones URL: Libreta de Direcciones El Address Book de I2P funciona de manera similar al DNS en la clearnet, permitiéndote gestionar nombres legibles para destinos I2P (eepsites). Aquí es donde puedes ver y agregar direcciones I2P a tu libreta de direcciones personal.\nEl sistema de libreta de direcciones funciona a través de múltiples capas:\nRegistros Locales - Tus libretas de direcciones personales que se almacenan únicamente en tu router\nLibreta de Direcciones Local - Hosts que añades manualmente o guardas para tu propio uso Libreta de Direcciones Privada - Direcciones que no deseas compartir con otros; nunca se distribuyen públicamente Suscripciones - Fuentes remotas de libreta de direcciones (como http://i2p-projekt.i2p/hosts.txt) que actualizan automáticamente la libreta de direcciones de tu router con sitios I2P conocidos\nRouter Addressbook - El resultado combinado de tus registros locales y suscripciones, consultable por todas las aplicaciones I2P en tu router\nPublished Addressbook - Compartición pública opcional de tu libreta de direcciones para que otros la usen como fuente de suscripción (útil si estás ejecutando un sitio I2P)\nLa libreta de direcciones consulta regularmente tus suscripciones y fusiona el contenido en la libreta de direcciones de tu router, manteniendo tu archivo hosts.txt actualizado con la red I2P.\nConfiguración URL: Configuración Avanzada La sección de Configuración proporciona acceso a todos los ajustes del router a través de múltiples pestañas especializadas.\nAdvanced La página de configuración avanzada proporciona acceso a ajustes de bajo nivel del router que normalmente no son necesarios para la operación normal. La mayoría de los usuarios no deberían modificar estos ajustes a menos que comprendan la opción de configuración específica y su impacto en el comportamiento del router.\nCaracterísticas principales:\nConfiguración de Floodfill - Controla si tu router participa como peer floodfill, lo cual ayuda a la red almacenando y distribuyendo información de la base de datos de red (netDb). Esto puede usar más recursos del sistema pero fortalece la red I2P.\nConfiguración Avanzada de I2P - Acceso directo al archivo router.config, mostrando todos los parámetros de configuración avanzada incluyendo:\nLímites de ancho de banda y configuración de ráfagas Configuración de transporte (NTCP2, SSU2, puertos UDP y claves) Identificación del router e información de versión Preferencias de consola y configuración de actualizaciones La mayoría de las opciones de configuración avanzadas no están expuestas en la interfaz de usuario porque rara vez son necesarias. Para habilitar la edición de estas configuraciones, debe agregar routerconsole.advanced=true a su archivo router.config manualmente.\nAdvertencia: Modificar incorrectamente la configuración avanzada puede afectar negativamente el rendimiento o la conectividad de tu router. Solo cambia estos ajustes si sabes lo que estás haciendo.\nBandwidth URL: Configuración de Ancho de Banda La página de configuración de ancho de banda te permite controlar cuánto ancho de banda contribuye tu router a la red I2P. I2P funciona mejor cuando configuras tus tasas para que coincidan con la velocidad de tu conexión a internet.\nConfiguraciones Clave:\nKBps In - Ancho de banda entrante máximo que tu router aceptará (velocidad de descarga) KBps Out - Ancho de banda saliente máximo que tu router utilizará (velocidad de subida) Share - Porcentaje de tu ancho de banda saliente dedicado al tráfico participativo (ayudar a enrutar tráfico para otros) Notas Importantes:\nTodos los valores están en bytes por segundo (KBps), no en bits por segundo Cuanta más banda ancha pongas a disposición, más ayudas a la red y mejoras tu propio anonimato Tu cantidad de subida compartida (KBps Out) determina tu contribución general a la red Si no estás seguro de la velocidad de tu red, utiliza la Prueba de Banda Ancha para medirla Una mayor banda ancha compartida mejora tanto tu anonimato como ayuda a fortalecer la red I2P La página de configuración muestra la transferencia de datos mensual estimada según tu configuración, ayudándote a planificar la asignación de ancho de banda de acuerdo con los límites de tu plan de internet.\nClient Configuration URL: Configuración del Cliente La página de Configuración del Cliente te permite controlar qué aplicaciones y servicios de I2P se ejecutan al inicio. Aquí puedes habilitar o deshabilitar los clientes integrados de I2P sin desinstalarlos.\nAdvertencia Importante: Ten cuidado al cambiar la configuración aquí. La consola del router y los túneles de aplicación son necesarios para la mayoría de los usos de I2P. Solo los usuarios avanzados deben modificar esta configuración.\nClientes Disponibles:\nTúneles de aplicación - El sistema I2PTunnel que gestiona túneles de cliente y servidor (proxy HTTP, IRC, etc.) Consola del Router I2P - La interfaz de administración basada en web que estás usando actualmente Servidor web I2P (eepsite) - Servidor web Jetty integrado para alojar tu propio sitio web I2P Abrir Consola del Router en el navegador web al iniciar - Lanza automáticamente tu navegador a la página de inicio de la consola Puente de aplicaciones SAM - Puente API para que aplicaciones de terceros se conecten a I2P Cada cliente muestra:\n¿Ejecutar al Inicio? - Casilla de verificación para activar/desactivar el inicio automático Control - Botones de Iniciar/Detener para control inmediato Clase y argumentos - Detalles técnicos sobre cómo se lanza el cliente Los cambios en la configuración \u0026ldquo;¿Ejecutar al inicio?\u0026rdquo; requieren reiniciar el router para que surtan efecto. Todas las modificaciones se guardan en /var/lib/i2p/i2p-config/clients.config.d/.\nAvanzado URL: Configuración de I2CP La página de configuración de I2CP (I2P Client Protocol) te permite configurar cómo las aplicaciones externas se conectan a tu router I2P. I2CP es el protocolo que las aplicaciones utilizan para comunicarse con el router para crear tunnels y enviar/recibir datos a través de I2P.\nImportante: La configuración predeterminada funcionará para la mayoría de las personas. Cualquier cambio realizado aquí también debe configurarse en la aplicación cliente externa. Muchos clientes no admiten SSL o autorización. Todos los cambios requieren reiniciar para que surtan efecto.\nOpciones de Configuración:\nConfiguración de interfaz I2CP externa\nHabilitada sin SSL - Acceso I2CP estándar (predeterminado y más compatible) Habilitada con SSL requerido - Solo conexiones I2CP cifradas Deshabilitada - Bloquea la conexión de clientes externos vía I2CP Interfaz I2CP - La interfaz de red en la que escuchar (por defecto: 127.0.0.1 solo para localhost)\nPuerto I2CP - El número de puerto para las conexiones I2CP (por defecto: 7654)\nAutorización\nRequerir nombre de usuario y contraseña - Habilitar autenticación para conexiones I2CP Nombre de usuario - Establecer el nombre de usuario requerido para acceso I2CP Contraseña - Establecer la contraseña requerida para acceso I2CP Nota de Seguridad: Si solo ejecutas aplicaciones en la misma máquina que tu router I2P, mantén la interfaz configurada en 127.0.0.1 para prevenir acceso remoto. Solo cambia estas configuraciones si necesitas permitir que aplicaciones I2P desde otros dispositivos se conecten a tu router.\nAncho de banda URL: Configuración de Red La página de Configuración de Red te permite configurar cómo tu router I2P se conecta a internet, incluyendo la detección de dirección IP, preferencias de IPv4/IPv6 y configuración de puertos para los transportes UDP y TCP.\nDirección IP Accesible Externamente:\nUsar todos los métodos de autodetección - Detecta automáticamente tu IP pública usando múltiples métodos (recomendado) Deshabilitar detección de dirección IP por UPnP - Evita usar UPnP para descubrir tu IP Ignorar dirección IP de interfaz local - No usar tu IP de red local Usar solo detección de dirección IP por SSU - Solo usar el transporte SSU2 para detección de IP Modo oculto - no publicar IP - Evita participar en el tráfico de red (reduce el anonimato) Especificar hostname o IP - Configurar manualmente tu IP pública o hostname Configuración de IPv4:\nDeshabilitar entrante (Con cortafuegos) - Marca esta opción si estás detrás de un cortafuegos, red doméstica, ISP, DS-Lite, o NAT de nivel de operadora que bloquea las conexiones entrantes Configuración de IPv6:\nPreferir IPv4 sobre IPv6 - Prioriza las conexiones IPv4 Preferir IPv6 sobre IPv4 - Prioriza las conexiones IPv6 (predeterminado para redes de doble pila) Habilitar IPv6 - Permite conexiones IPv6 Deshabilitar IPv6 - Deshabilita toda la conectividad IPv6 Usar solo IPv6 (deshabilitar IPv4) - Modo experimental solo IPv6 Deshabilitar conexiones entrantes (Cortafuegos) - Marque si su IPv6 está protegido por cortafuegos Acción Cuando Cambia la IP:\nModo portátil - Función experimental que cambia la identidad del router y el puerto UDP cuando tu IP cambia para mayor anonimato Configuración UDP:\nEspecificar Puerto - Establece un puerto UDP específico para el transporte SSU2 (debe estar abierto en tu firewall) Deshabilitar completamente - Selecciona solo si estás detrás de un firewall que bloquea todo el tráfico UDP saliente Configuración TCP:\nEspecificar Puerto - Establece un puerto TCP específico para el transporte NTCP2 (debe estar abierto en tu firewall) Usar el mismo puerto configurado para UDP - Simplifica la configuración usando un solo puerto para ambos transportes Usar dirección IP autodetectada - Detecta automáticamente tu IP pública (muestra \u0026ldquo;actualmente desconocida\u0026rdquo; si aún no se ha detectado o está tras firewall) Usar siempre dirección IP autodetectada (Sin firewall) - Mejor opción para routers con acceso directo a internet Deshabilitar conexiones entrantes (Con firewall) - Marca esta opción si las conexiones TCP están bloqueadas por tu firewall Deshabilitar completamente - Selecciona solo si estás detrás de un firewall que limita o bloquea TCP saliente Especificar hostname o IP - Configura manualmente tu dirección accesible desde el exterior Importante: Los cambios en la configuración de red pueden requerir un reinicio del router para que surtan efecto completo. Una configuración adecuada del reenvío de puertos mejora significativamente el rendimiento de tu router y ayuda a la red I2P.\nConfiguración del Cliente URL: Configuración de pares La página de Configuración de Pares proporciona controles manuales para gestionar pares individuales en la red I2P. Esta es una función avanzada que normalmente se utiliza solo para solucionar problemas con pares problemáticos.\nControles Manuales de Pares:\nHash del Router - Ingrese el hash del router en base64 de 44 caracteres del peer que desea administrar Banear / Desbanear Manualmente un Peer:\nBloquear un peer evita que participe en cualquier túnel que crees. Esta acción: - Evita que el peer sea utilizado en tus túneles de cliente o exploratorios - Toma efecto inmediatamente sin requerir un reinicio - Persiste hasta que desbloquees manualmente el peer o reinicies tu router - Bloquear peer hasta el reinicio - Bloquea temporalmente el peer - Desbloquear peer - Elimina el bloqueo de un peer previamente bloqueado\nAjustar Bonificaciones de Perfil:\nLos bonos de perfil afectan cómo se seleccionan los pares para la participación en túneles. Los bonos pueden ser positivos o negativos: - Pares rápidos - Utilizados para túneles de cliente que requieren alta velocidad - Pares de alta capacidad - Utilizados para algunos túneles exploratorios que requieren enrutamiento confiable - Los bonos actuales se muestran en la página de perfiles\nConfiguración: - Velocidad - Ajustar el bono de velocidad para este peer (0 = neutral) - Capacidad - Ajustar el bono de capacidad para este peer (0 = neutral) - Ajustar bonos de peer - Aplicar la configuración de bonos\nCasos de Uso: - Banear un peer que causa problemas de conexión de forma consistente - Excluir temporalmente un peer que sospechas que es malicioso - Ajustar bonificaciones para despriorizar peers con bajo rendimiento - Depurar problemas de construcción de túneles excluyendo peers específicos\nNota: La mayoría de los usuarios nunca necesitarán utilizar esta función. El router de I2P gestiona automáticamente la selección de peers y el perfilado basándose en métricas de rendimiento.\nConfiguración de I2CP URL: Configuración de Reseed La página de Configuración de Reseed te permite resembrar manualmente tu router si el reseed automático falla. El reseed es el proceso de arranque utilizado para encontrar otros routers cuando instalas I2P por primera vez, o cuando tu router tiene muy pocas referencias de routers restantes.\nCuándo Usar Reseed Manual:\nSi el reseed ha fallado, primero debes verificar tu conexión de red\nSi un firewall está bloqueando tus conexiones a los hosts de reseed, es posible que tengas acceso a un proxy:\nEl proxy puede ser un proxy público remoto, o puede estar ejecutándose en tu computadora (localhost) Para usar un proxy, configura el tipo, host y puerto en la sección de Configuración de Reseeding Si estás ejecutando Tor Browser, haz reseed a través de él configurando SOCKS 5, localhost, puerto 9150 Si estás ejecutando Tor por línea de comandos, haz reseed a través de él configurando SOCKS 5, localhost, puerto 9050 Si tienes algunos peers pero necesitas más, puedes probar la opción I2P Outproxy. Deja el host y el puerto en blanco. Esto no funcionará para un reseed inicial cuando no tienes peers en absoluto Luego, haz clic en \u0026ldquo;Guardar cambios y hacer reseed ahora\u0026rdquo; La configuración predeterminada funcionará para la mayoría de las personas. Cambia estas opciones solo si HTTPS está bloqueado por un firewall restrictivo y el reseed ha fallado Si conoces y confías en alguien que ejecuta I2P, pídele que te envíe un archivo reseed generado usando esta página en su consola del router. Luego, usa esta página para hacer reseed con el archivo que recibiste. Primero, selecciona el archivo a continuación. Después, haz clic en \u0026ldquo;Reseed from file\u0026rdquo;\nSi conoces y confías en alguien que publica archivos reseed, pídele la URL. Luego, usa esta página para hacer reseed con la URL que recibiste. Primero, ingresa la URL a continuación. Después, haz clic en \u0026ldquo;Reseed from URL\u0026rdquo;\nConsulta las preguntas frecuentes para obtener instrucciones sobre cómo resembrar manualmente\nOpciones de Reseed Manual:\nReseed desde URL - Ingresa una URL de archivo zip o su3 de una fuente confiable y haz clic en \u0026ldquo;Reseed from URL\u0026rdquo;\nSe prefiere el formato su3, ya que se verificará como firmado por una fuente confiable El formato zip no está firmado; usa un archivo zip solo de una fuente en la que confíes Reseed desde Archivo - Navega y selecciona un archivo zip o su3 local, luego haz clic en \u0026ldquo;Reseed from file\u0026rdquo;\nPuedes encontrar archivos reseed en checki2p.com/reseed Crear Archivo de Reseed - Generar un nuevo archivo zip de reseed que puedes compartir para que otros hagan reseed manualmente\nEste archivo nunca contendrá la identidad de tu propio router ni tu IP Configuración de Reseeding:\nLa configuración predeterminada funcionará para la mayoría de las personas. Cambie estos valores solo si HTTPS está bloqueado por un firewall restrictivo y el reseed ha fallado.\nURLs de Reseed - Lista de URLs HTTPS a servidores de reseed (la lista predeterminada está integrada y se actualiza regularmente) Configuración de Proxy - Configura proxy HTTP/HTTPS/SOCKS si necesitas acceder a los servidores de reseed a través de un proxy Restablecer lista de URLs - Restaura la lista predeterminada de servidores de reseed Importante: El reseed manual solo debería ser necesario en casos excepcionales donde el reseed automático falle repetidamente. La mayoría de los usuarios nunca necesitarán usar esta página.\nConfiguración de la Red URL: Configuración de Familia de Router La página de Configuración de Familia de Routers te permite gestionar familias de routers. Los routers en la misma familia comparten una clave de familia, que los identifica como operados por la misma persona u organización. Esto evita que múltiples routers que controlas sean seleccionados para el mismo tunnel, lo que reduciría el anonimato.\n¿Qué es una Familia de Routers?\nCuando operas múltiples routers I2P, debes configurarlos para que sean parte de la misma familia. Esto garantiza: - Tus routers no se usarán juntos en la misma ruta de túnel - Otros usuarios mantienen el anonimato adecuado cuando sus túneles usan tus routers - La red puede distribuir correctamente la participación en los túneles\nFamilia Actual:\nLa página muestra el nombre actual de la familia de tu router. Si no formas parte de una familia, esto estará vacío.\nExportar Clave de Familia:\nExporta la clave secreta de familia para importarla en otros routers que controles Haz clic en \u0026ldquo;Export Family Key\u0026rdquo; para descargar tu archivo de clave de familia Importa esta clave en tus otros routers para añadirlos a la misma familia Abandonar Familia de Router:\nDejar de ser miembro de la familia Haz clic en \u0026ldquo;Abandonar familia\u0026rdquo; para eliminar este router de su familia actual Esta acción no se puede deshacer sin volver a importar la clave de familia Consideraciones Importantes:\nRegistro Público Requerido: Para que tu familia sea reconocida en toda la red, tu clave de familia debe ser añadida al código base de I2P por el equipo de desarrollo. Esto asegura que todos los routers en la red conozcan tu familia. Contacta al equipo de I2P para registrar tu clave de familia si operas múltiples routers públicos La mayoría de los usuarios que ejecutan solo un router nunca necesitarán usar esta función La configuración de familia es utilizada principalmente por operadores de múltiples routers públicos o proveedores de infraestructura Casos de Uso:\nOperar múltiples routers I2P para redundancia Ejecutar infraestructura como servidores reseed o outproxies en múltiples máquinas Gestionar una red de routers I2P para una organización Configuración de Pares URL: Configuración de Túneles La página de Configuración de Túneles te permite ajustar la configuración predeterminada de túneles tanto para túneles exploratorios (usados para la comunicación del router) como para túneles de cliente (usados por aplicaciones). La configuración predeterminada funciona para la mayoría de las personas y solo debería cambiarse si comprendes las compensaciones.\nAdvertencias Importantes:\n⚠️ Compensación entre Anonimato y Rendimiento: Existe una compensación fundamental entre el anonimato y el rendimiento. Los túneles de más de 3 saltos (por ejemplo, 2 saltos + 0-2 saltos, 3 saltos + 0-1 saltos, 3 saltos + 0-2 saltos), o una cantidad alta + cantidad de respaldo, pueden reducir gravemente el rendimiento o la fiabilidad. Esto puede resultar en un uso elevado de CPU y/o ancho de banda saliente. Modifique estos ajustes con precaución y ajústelos si tiene problemas.\n⚠️ Persistencia: Los cambios en la configuración de túneles exploratorios se almacenan en el archivo router.config. Los cambios en túneles de cliente son temporales y no se guardan. Para realizar cambios permanentes en túneles de cliente, consulta la página de I2PTunnel .\nTúneles Exploratorios:\nLos túneles exploratorios son utilizados por tu router para comunicarse con la base de datos de red y participar en la red I2P.\nOpciones de configuración tanto para Inbound como para Outbound: - Length - Número de saltos en el tunnel (por defecto: 2-3 saltos) - Randomization - Variación aleatoria en la longitud del tunnel (por defecto: 0-1 saltos) - Quantity - Número de tunnels activos (por defecto: 2 tunnels) - Backup quantity - Número de tunnels de respaldo listos para activarse (por defecto: 0 tunnels)\nTúneles de Cliente para Servidor Web I2P:\nEstas configuraciones controlan los túneles para el servidor web I2P integrado (eepsite).\n⚠️ ADVERTENCIA DE ANONIMATO - La configuración incluye túneles de 1 salto. ⚠️ ADVERTENCIA DE RENDIMIENTO - La configuración incluye cantidades elevadas de túneles.\nOpciones de configuración tanto para Entrante como para Saliente: - Longitud - Longitud del túnel (por defecto: 1 salto para servidor web) - Aleatorización - Variación aleatoria en la longitud del túnel - Cantidad - Número de túneles activos - Cantidad de respaldo - Número de túneles de respaldo\nTúneles de Cliente para Clientes Compartidos:\nEstas configuraciones se aplican a las aplicaciones cliente compartidas (proxy HTTP, IRC, etc.).\nOpciones de configuración tanto para Entrada como para Salida: - Length - Longitud del túnel (por defecto: 3 saltos) - Randomization - Varianza aleatoria en la longitud del túnel - Quantity - Número de túneles activos - Backup quantity - Número de túneles de respaldo\nComprender los Parámetros de Túnel:\nLongitud: Los túneles más largos proporcionan mayor anonimato pero reducen el rendimiento y la fiabilidad Aleatorización: Añade imprevisibilidad a las rutas de los túneles, mejorando la seguridad Cantidad: Más túneles mejoran la fiabilidad y distribución de carga pero aumentan el uso de recursos Cantidad de respaldo: Túneles preconstruidos listos para reemplazar túneles fallidos, mejorando la resiliencia Mejores Prácticas:\nMantén la configuración predeterminada a menos que tengas necesidades específicas Solo aumenta la longitud del túnel si el anonimato es crítico y puedes aceptar un rendimiento más lento Aumenta la cantidad/respaldo solo si experimentas fallos frecuentes de túneles Monitorea el rendimiento del router después de realizar cambios Haz clic en \u0026ldquo;Save changes\u0026rdquo; para aplicar las modificaciones Configuración de Reseed URL: Configuración de la UI La página de Configuración de UI te permite personalizar la apariencia y accesibilidad de tu consola del router, incluyendo selección de tema, preferencias de idioma y protección con contraseña.\nTema de la Consola del Router:\nElige entre temas oscuros y claros para la interfaz de la consola del router:\nOscuro - Tema en modo oscuro (más cómodo para la vista en ambientes con poca luz) Claro - Tema en modo claro (apariencia tradicional) Opciones adicionales de tema: - Establecer tema universalmente en todas las aplicaciones - Aplicar el tema seleccionado a todas las aplicaciones I2P, no solo a la consola del router - Forzar el uso de la consola móvil - Utilizar la interfaz optimizada para móviles incluso en navegadores de escritorio - Incrustar aplicaciones de Email y Torrent en la consola - Integrar Susimail e I2PSnark directamente en la interfaz de la consola en lugar de abrirlas en pestañas separadas\nIdioma de la Consola del Router:\nSelecciona tu idioma preferido para la interfaz de la consola del router desde el menú desplegable. I2P admite muchos idiomas incluyendo inglés, alemán, francés, español, ruso, chino, japonés y más.\nBienvenidas las contribuciones a las traducciones: Si notas traducciones incompletas o incorrectas, puedes ayudar a mejorar I2P contribuyendo al proyecto de traducción. Contacta a los desarrolladores en #i2p-dev en IRC o revisa el informe de estado de traducción (enlazado en la página).\nContraseña de la Consola del Router:\nAñade autenticación de nombre de usuario y contraseña para proteger el acceso a tu consola del router:\nNombre de usuario - Ingrese el nombre de usuario para acceder a la consola Contraseña - Ingrese la contraseña para acceder a la consola Añadir usuario - Crear un nuevo usuario con las credenciales especificadas Eliminar seleccionados - Eliminar cuentas de usuario existentes ¿Por qué añadir una contraseña?\nPreviene el acceso local no autorizado a tu consola del router Esencial si varias personas usan tu computadora Recomendado si tu consola del router es accesible en tu red local Protege tu configuración de I2P y ajustes de privacidad contra manipulación Nota de Seguridad: La protección con contraseña solo afecta el acceso a la interfaz web de la consola del router en la Consola del Router I2P . No cifra el tráfico de I2P ni impide que las aplicaciones usen I2P. Si eres el único usuario de tu computadora y la consola del router solo escucha en localhost (predeterminado), puede que no sea necesaria una contraseña.\nConfiguración de Familia de Router URL: Configuración de WebApp La página de Configuración de WebApp te permite gestionar las aplicaciones web Java que se ejecutan dentro de tu router I2P. Estas aplicaciones son iniciadas por el cliente webConsole y se ejecutan en la misma JVM que el router, proporcionando funcionalidad integrada accesible a través de la consola del router.\n¿Qué son las WebApps?\nLas WebApps son aplicaciones basadas en Java que pueden ser:\nAplicaciones completas (ej. I2PSnark para torrents) Interfaces front-end para otros clientes que deben habilitarse por separado (ej. Susidns, I2PTunnel) Aplicaciones web sin interfaz web (ej. libreta de direcciones) Notas Importantes:\nUna webapp puede estar deshabilitada completamente, o puede estar deshabilitada solo para no ejecutarse al inicio Eliminar un archivo war del directorio webapps deshabilita la webapp completamente Sin embargo, el archivo .war y el directorio de la webapp reaparecerán cuando actualices tu router a una versión más reciente Para deshabilitar permanentemente una webapp: Deshabílala aquí, que es el método preferido WebApps Disponibles:\nWebApp Description i2psnark Torrents - Built-in BitTorrent client for I2P i2ptunnel Hidden Services Manager - Configure client and server tunnels imagegen Identification Image Generator - Creates unique identicons jsonrpc jsonrpc.war - JSON-RPC API interface (disabled by default) routerconsole I2P Router Console - The main administrative interface susidns Address Book - Manage I2P addresses and subscriptions susimail Email - Web-based email client for I2P Controles: Para cada webapp: - ¿Ejecutar al inicio? - Casilla de verificación para habilitar/deshabilitar el inicio automático - Control - Botones Iniciar/Detener para control inmediato - Detener - Detiene la webapp actualmente en ejecución - Iniciar - Inicia una webapp detenida\nBotones de Configuración:\nCancelar - Descartar los cambios y volver a la página anterior Guardar Configuración de WebApp - Guardar los cambios y aplicarlos Casos de Uso:\nDetén I2PSnark si no usas torrents para ahorrar recursos Desactiva jsonrpc si no necesitas acceso a la API Detén Susimail si usas un cliente de correo externo Detén temporalmente las webapps para liberar memoria o solucionar problemas Consejo de Rendimiento: Deshabilitar las aplicaciones web no utilizadas puede reducir el uso de memoria y mejorar el rendimiento del router, especialmente en sistemas con recursos limitados.\nHelp URL: Ayuda La página de Ayuda proporciona documentación exhaustiva y recursos para ayudarte a comprender y usar I2P de manera efectiva. Sirve como centro principal para solucionar problemas, aprender y obtener soporte.\nLo que encontrarás:\nGuía de inicio rápido - Información esencial para nuevos usuarios que comienzan a usar I2P Preguntas frecuentes (FAQ) - Respuestas a preguntas comunes sobre la instalación, configuración y uso de I2P Solución de problemas - Soluciones a problemas comunes y cuestiones de conectividad Documentación técnica - Información detallada sobre protocolos, arquitectura y especificaciones de I2P Guías de aplicaciones - Instrucciones para usar aplicaciones de I2P como torrents, correo electrónico y servicios ocultos Información de la red - Comprender cómo funciona I2P y qué lo hace seguro Recursos de soporte - Enlaces a foros, canales IRC y soporte comunitario Obtener Ayuda:\nSi estás experimentando problemas con I2P: 1. Consulta las preguntas frecuentes (FAQ) para preguntas y respuestas comunes 2. Revisa la sección de solución de problemas para tu problema específico 3. Visita el foro de I2P en i2pforum.i2p o i2pforum.net 4. Únete al canal IRC #i2p para soporte de la comunidad en tiempo real 5. Busca en la documentación para información técnica detallada\nConsejo: La página de ayuda siempre es accesible desde la barra lateral de la consola del router, lo que facilita encontrar asistencia cuando la necesites.\nPerformance Graphs URL: Gráficos de Rendimiento La página de Gráficos de Rendimiento proporciona monitoreo visual en tiempo real del rendimiento de tu router I2P y la actividad de red. Estos gráficos te ayudan a comprender el uso de ancho de banda, las conexiones con peers, el consumo de memoria y el estado general del router.\nGráficos Disponibles:\nUso de Ancho de Banda\nTasa de envío de bajo nivel (bytes/seg) - Tasa de tráfico saliente Tasa de recepción de bajo nivel (bytes/seg) - Tasa de tráfico entrante Muestra la utilización actual, promedio y máxima del ancho de banda Ayuda a monitorear si te estás acercando a tus límites de ancho de banda configurados Pares Activos\nrouter.activePeers promediado durante 60 seg - Número de pares con los que te estás comunicando activamente Muestra la salud de tu conectividad de red Más pares activos generalmente significa mejor construcción de túneles y participación en la red Uso de Memoria del Router\nrouter.memoryUsed promediado durante 60 seg - Consumo de memoria de la JVM Muestra el uso de memoria actual, promedio y máximo en MB Útil para identificar fugas de memoria o determinar si necesitas aumentar el tamaño del heap de Java Configurar Visualización de Gráficos:\nPersonaliza cómo se muestran y actualizan los gráficos:\nTamaño del gráfico - Establece el ancho (predeterminado: 400 píxeles) y la altura (predeterminado: 100 píxeles) Período de visualización - Rango de tiempo a mostrar (predeterminado: 60 minutos) Intervalo de actualización - Con qué frecuencia se actualizan los gráficos (predeterminado: 5 minutos) Tipo de gráfico - Elije entre visualización de Promedios o Eventos Ocultar leyenda - Elimina la leyenda de los gráficos para ahorrar espacio UTC - Usa hora UTC en lugar de hora local en los gráficos Persistencia - Almacena datos del gráfico en disco para análisis histórico Opciones Avanzadas:\nHaz clic en [Select Stats] para elegir qué estadísticas graficar: - Métricas de tunnel (tasa de éxito de construcción, cantidad de tunnels, etc.) - Estadísticas de la base de datos de red - Estadísticas de transporte (NTCP2, SSU2) - Rendimiento de tunnels de cliente - Y muchas más métricas detalladas\nCasos de Uso:\nMonitorea el ancho de banda para asegurar que no excedas tus límites configurados Verifica la conectividad de peers al solucionar problemas de red Rastrea el uso de memoria para optimizar la configuración del heap de Java Identifica patrones de rendimiento a lo largo del tiempo Diagnostica problemas de construcción de tunnels correlacionando gráficas Consejo: Haz clic en \u0026ldquo;Guardar configuración y redibujar gráficas\u0026rdquo; después de realizar cambios para aplicar tu configuración. Las gráficas se actualizarán automáticamente según tu configuración de intervalo de actualización.\n","description":"Una guía completa para comprender y configurar la Consola del Router I2P","id":"c46f1b6edeab9b686fd57cf9b311df1c","section":"docs","title":"Guía de Configuración de la Consola del Router","url":"/es/docs/guides/router-console-config/"},{"categories":null,"content":" Alcance: Esta guía consolida la implementación de tunnel, el formato de mensaje y ambas especificaciones de creación de tunnel (ECIES y ElGamal heredado). Los enlaces profundos existentes siguen funcionando a través de los alias mencionados arriba.\nModelo de tunnel I2P reenvía cargas útiles a través de tunnels unidireccionales: conjuntos ordenados de routers que transportan tráfico en una sola dirección. Un viaje de ida y vuelta completo entre dos destinos requiere cuatro tunnels (dos de salida, dos de entrada).\nComienza con la Descripción general de Tunnel (túneles de I2P) para la terminología, luego usa esta guía para los detalles operativos.\nCiclo de vida del mensaje La puerta de enlace del tunnel agrupa en lotes uno o más mensajes I2NP, los fragmenta y escribe instrucciones de entrega. La puerta de enlace encapsula la carga útil en un mensaje de tunnel de tamaño fijo (1024 B), añadiendo relleno si es necesario. Cada participante verifica el salto anterior, aplica su capa de cifrado y reenvía {nextTunnelId, nextIV, encryptedPayload} al siguiente salto. El extremo del tunnel elimina la capa final, consume las instrucciones de entrega, reensambla los fragmentos y envía los mensajes I2NP reconstruidos. La detección de duplicados utiliza un filtro de Bloom con decaimiento, indexado por el XOR del IV (vector de inicialización) y el primer bloque de cifrado, para impedir ataques de etiquetado basados en intercambios de IV.\nRoles de un vistazo Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally ### Flujo de trabajo de cifrado {#encryption-workflow} Tunnels entrantes: la puerta de enlace cifra una vez con su clave de capa; los participantes posteriores siguen cifrando hasta que el creador descifra la carga útil final. Tunnels salientes: la puerta de enlace aplica previamente la inversa del cifrado de cada salto para que cada participante cifre. Cuando el extremo cifra, se revela el texto en claro original de la puerta de enlace. Ambas direcciones reenvían {tunnelId, IV, encryptedPayload} al siguiente salto.\nFormato del mensaje de Tunnel Las puertas de enlace del tunnel fragmentan los mensajes I2NP en envolturas de tamaño fijo para ocultar la longitud de la carga útil y simplificar el procesamiento salto a salto.\nDiseño cifrado +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – identificador de 32 bits para el siguiente salto (no es cero; rota en cada ciclo de construcción). IV – IV de AES de 16 bytes seleccionado para cada mensaje. Carga útil cifrada – 1008 bytes de texto cifrado AES-256-CBC. Tamaño total: 1028 bytes.\nDiseño descifrado Después de que un salto retira su capa de cifrado:\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... Suma de verificación valida el bloque descifrado. Relleno es una secuencia de bytes aleatorios distintos de cero, terminada por un byte cero. Instrucciones de entrega indican al extremo cómo manejar cada fragmento (entregar localmente, reenviar a otro tunnel, etc.). Fragmentos transportan los mensajes I2NP subyacentes; el extremo los reensambla antes de pasarlos a capas superiores. Pasos de procesamiento Las puertas de enlace fragmentan y ponen en cola mensajes I2NP, reteniendo brevemente fragmentos parciales para su reensamblaje. La puerta de enlace cifra la carga útil con las claves de capa apropiadas e inserta el ID del tunnel más el IV (vector de inicialización). Cada participante cifra el IV (AES-256/ECB) y luego la carga útil (AES-256/CBC) antes de volver a cifrar el IV y reenviar el mensaje. El extremo descifra en orden inverso, verifica la suma de verificación, procesa las instrucciones de entrega y reensambla los fragmentos. Creación de Tunnel (ECIES-X25519) Los routers modernos construyen tunnels con claves ECIES-X25519, reduciendo el tamaño de los mensajes de construcción (build messages) y permitiendo secreto hacia adelante.\nMensaje de construcción: un único mensaje I2NP TunnelBuild (o VariableTunnelBuild) transporta de 1–8 registros de construcción cifrados, uno por salto. Claves de capa: los creadores derivan, por salto, las claves de capa, IV (vector de inicialización) y de respuesta mediante HKDF (función de derivación de claves basada en HMAC) usando la identidad estática X25519 del salto y la clave efímera del creador. Procesamiento: cada salto descifra su registro, valida las banderas de la solicitud, escribe el bloque de respuesta (éxito o código de fallo detallado), vuelve a cifrar los registros restantes y reenvía el mensaje. Respuestas: el creador recibe un mensaje de respuesta envuelto con garlic encryption (técnica de cifrado y encapsulado propia de I2P). Los registros marcados como fallidos incluyen un código de gravedad para que el router pueda perfilar al par. Compatibilidad: los routers todavía pueden aceptar construcciones heredadas con ElGamal por compatibilidad retroactiva, pero los nuevos tunnels usan ECIES por defecto. Para las constantes por campo y las notas sobre derivación de claves, consulte el historial de propuestas de ECIES y el código fuente del router; esta guía cubre el flujo operativo.\nCreación de Tunnel heredado (ElGamal-2048) El formato original de construcción de tunnel utilizaba claves públicas de ElGamal. Los routers modernos conservan un soporte limitado por compatibilidad con versiones anteriores.\nEstado: Obsoleto. Se conserva aquí como referencia histórica y para cualquier persona que mantenga herramientas compatibles con sistemas heredados.\nNon-interactive telescoping (encadenamiento no interactivo): un único mensaje de construcción recorre toda la ruta. Cada salto descifra su registro de 528 bytes, actualiza el mensaje y lo reenvía. Longitud variable: la Variable Tunnel Build Message (VTBM, mensaje de construcción de tunnel de longitud variable) permitía entre 1 y 8 registros. El mensaje fijo anterior siempre contenía ocho registros para ocultar la longitud del tunnel. Formato del registro de solicitud: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding Indicadores: el bit 7 indica una puerta de enlace de entrada (IBGW); el bit 6 marca un extremo de salida (OBEP). Son mutuamente excluyentes. Cifrado: cada registro está cifrado con ElGamal-2048 usando la clave pública del salto. El uso en capas simétricas de AES-256-CBC garantiza que solo el salto previsto pueda leer su registro. Datos clave: los ID de tunnel son valores de 32 bits no nulos; los creadores pueden insertar registros ficticios para ocultar la longitud real del tunnel; la fiabilidad depende de reintentar construcciones fallidas. Pools de tunnel y ciclo de vida Los Routers mantienen conjuntos independientes de tunnel entrantes y salientes para el tráfico exploratorio y para cada sesión de I2CP.\nSelección de pares: los tunnels exploratorios toman del conjunto de pares “activos, sin fallos” para fomentar la diversidad; los tunnels de cliente prefieren pares rápidos y de alta capacidad. Ordenación determinista: los pares se ordenan por la distancia XOR entre SHA256(peerHash || poolKey) y la clave aleatoria del grupo. La clave rota al reiniciar, lo que aporta estabilidad dentro de una ejecución y frustra los ataques de predecesor entre ejecuciones. Ciclo de vida: routers registran tiempos históricos de construcción por tupla {mode, direction, length, variance}. A medida que los tunnels se acercan a su vencimiento, los reemplazos comienzan con antelación; el router incrementa las construcciones en paralelo cuando ocurren fallos, al tiempo que limita los intentos pendientes. Ajustes de configuración: los recuentos de tunnels activos/de respaldo, la longitud de salto y la varianza, las permisiones de cero saltos y los límites de velocidad de construcción son ajustables por grupo. Congestión y fiabilidad Aunque los tunnels se asemejan a circuitos, los routers los tratan como colas de mensajes. Se utiliza Weighted Random Early Discard (WRED, descarte aleatorio temprano ponderado) para mantener la latencia acotada:\nLa probabilidad de descarte aumenta a medida que la utilización se acerca a los límites configurados. Los participantes consideran fragmentos de tamaño fijo; las puertas de enlace/extremos descartan en función del tamaño combinado de los fragmentos, penalizando primero las cargas útiles grandes. Los extremos salientes descartan antes que otros roles para desperdiciar el menor esfuerzo de red posible. La entrega garantizada se delega a capas superiores como la Streaming library (biblioteca de transmisión). Las aplicaciones que requieren fiabilidad deben encargarse ellas mismas de la retransmisión y de los acuses de recibo.\nLecturas adicionales Selección de pares Visión general de Tunnel Implementación antigua de Tunnel ","description":"Especificación unificada para la creación, el cifrado y el transporte de tráfico con I2P tunnels.","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"Guía de operaciones de Tunnel","url":"/es/docs/specs/implementation/"},{"categories":null,"content":"Los routers I2P fallan con mayor frecuencia debido a problemas de reenvío de puertos, asignación de ancho de banda insuficiente y tiempo de bootstrap insuficiente (tiempo de arranque inicial). Estos tres factores explican más del 70% de los problemas reportados. El router requiere al menos 10-15 minutos tras el inicio para integrarse por completo en la red, 128 KB/sec de ancho de banda mínimo (se recomiendan 256 KB/sec) y un reenvío de puertos UDP/TCP adecuado para alcanzar un estado no bloqueado por firewall. Los usuarios nuevos a menudo esperan conectividad inmediata y reinician prematuramente, lo que restablece el progreso de integración y crea un ciclo frustrante. Esta guía proporciona soluciones detalladas para todos los problemas principales de I2P que afectan a las versiones 2.10.0 y posteriores.\nLa arquitectura de anonimato de I2P sacrifica de forma inherente la velocidad en favor de la privacidad mediante tunnels cifrados de múltiples saltos. Comprender este diseño fundamental ayuda a los usuarios a establecer expectativas realistas y a solucionar problemas de forma eficaz, en lugar de malinterpretar el comportamiento normal como problemas.\nRouter no se inicia o se bloquea inmediatamente Los fallos de inicio más comunes se deben a conflictos de puertos, incompatibilidad de versiones de Java o archivos de configuración corruptos. Comprueba si ya se está ejecutando otra instancia de I2P antes de investigar problemas más profundos.\nVerifique que no haya procesos en conflicto:\nLinux: ps aux | grep i2p o netstat -tulpn | grep 7657\nWindows: Administrador de tareas → Detalles → busque java.exe con i2p en la línea de comandos\nmacOS: Monitor de Actividad → busca \u0026ldquo;i2p\u0026rdquo;\nSi existe un proceso zombi, termínalo: pkill -9 -f i2p (Linux/Mac) o taskkill /F /IM javaw.exe (Windows)\nComprueba la compatibilidad de la versión de Java:\nI2P 2.10.0+ requiere Java 8 como mínimo, se recomienda Java 11 o posterior. Verifique que su instalación muestre \u0026ldquo;mixed mode\u0026rdquo; (no \u0026ldquo;interpreted mode\u0026rdquo;):\njava -version Debería mostrar: OpenJDK o Oracle Java, versión 8+, \u0026ldquo;mixed mode\u0026rdquo;\nEvite: GNU GCJ, implementaciones de Java obsoletas, modos solo interpretados\nConflictos comunes de puertos se producen cuando varios servicios compiten por los puertos predeterminados de I2P. La consola del router (7657), I2CP (7654), SAM (7656) y el proxy HTTP (4444) deben estar disponibles. Comprueba si hay conflictos: netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (Windows) o lsof -i :7657,4444,7654 (Linux/Mac).\nCorrupción del archivo de configuración se manifiesta como bloqueos inmediatos con errores de análisis en los registros. Router.config requiere codificación UTF-8 sin BOM, usa = como separador (no :) y prohíbe ciertos caracteres especiales. Haz una copia de seguridad y luego examina: ~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS).\nPara restablecer la configuración manteniendo la identidad: Detenga I2P, haga una copia de seguridad de router.keys y del directorio keyData, elimine router.config, reinicie. El router regenera la configuración predeterminada.\nAsignación del heap de Java demasiado baja causa fallos por OutOfMemoryError. Edita wrapper.config y aumenta wrapper.java.maxmemory desde el valor predeterminado de 128 o 256 a 512 como mínimo (1024 para routers de alto ancho de banda). Esto requiere un apagado completo, esperar 11 minutos y luego reiniciar - hacer clic en \u0026ldquo;Restart\u0026rdquo; en la consola no aplicará el cambio.\nResolver el estado \u0026ldquo;Network: Firewalled\u0026rdquo; El estado firewalled significa que el router no puede recibir conexiones entrantes directas, lo que obliga a depender de introducers (nodos introductores). Aunque el router funciona en este estado, el rendimiento se degrada significativamente y la contribución a la red sigue siendo mínima. Alcanzar un estado no firewalled requiere un reenvío de puertos adecuado.\nEl router selecciona aleatoriamente un puerto entre 9000-31000 para comunicaciones. Encuentra tu puerto en http://127.0.0.1:7657/confignet - busca \u0026ldquo;UDP Port\u0026rdquo; y \u0026ldquo;TCP Port\u0026rdquo; (normalmente el mismo número). Debes reenviar tanto UDP como TCP para un rendimiento óptimo, aunque solo UDP permite la funcionalidad básica.\nHabilitar el reenvío automático mediante UPnP (método más simple):\nAccede a http://127.0.0.1:7657/confignet Marca \u0026ldquo;Enable UPnP\u0026rdquo; Guarda los cambios y reinicia el router Espera 5-10 minutos y verifica que el estado cambie de \u0026ldquo;Network: Firewalled\u0026rdquo; a \u0026ldquo;Network: OK\u0026rdquo; UPnP requiere soporte del router (habilitado de forma predeterminada en la mayoría de los routers de consumo fabricados después de 2010) y una configuración de red adecuada.\nReenvío de puertos manual (requerido cuando UPnP falla):\nAnota tu puerto de I2P en http://127.0.0.1:7657/confignet (p. ej., 22648) Encuentra tu dirección IP local: ipconfig (Windows), ip addr (Linux), Preferencias del Sistema → Red (macOS) Accede a la interfaz de administración de tu router (normalmente 192.168.1.1 o 192.168.0.1) Ve a Redirección de puertos (puede estar en Avanzado, NAT o Servidores virtuales) Crea dos reglas: Puerto externo: [tu puerto de I2P] → IP interna: [tu equipo] → Puerto interno: [igual] → Protocolo: UDP Puerto externo: [tu puerto de I2P] → IP interna: [tu equipo] → Puerto interno: [igual] → Protocolo: TCP Guarda la configuración y reinicia tu router si es necesario Verifica el reenvío de puertos usando comprobadores en línea después de configurarlo. Si la detección falla, revisa la configuración del cortafuegos - tanto el cortafuegos del sistema como el cortafuegos de cualquier antivirus deben permitir el puerto de I2P.\nAlternativa de Hidden mode (modo oculto) para redes restrictivas donde el reenvío de puertos no es posible: Actívalo en http://127.0.0.1:7657/confignet → marca \u0026ldquo;Hidden mode\u0026rdquo;. El router permanece detrás de un cortafuegos pero se optimiza para este estado utilizando exclusivamente SSU introducers (nodos introductores). El rendimiento será más lento pero funcional.\nRouter atascado en los estados \u0026ldquo;Starting\u0026rdquo; o \u0026ldquo;Testing\u0026rdquo; Estos estados transitorios durante el arranque inicial suelen resolverse en 10-15 minutos para instalaciones nuevas o 3-5 minutos para routers establecidos. La intervención prematura a menudo empeora los problemas.\n\u0026ldquo;Network: Testing\u0026rdquo; indica que el router está comprobando la alcanzabilidad mediante varios tipos de conexión (directa, introducers (presentadores), múltiples versiones de protocolo). Esto es normal durante los primeros 5-10 minutos tras el arranque. El router prueba múltiples escenarios para determinar la configuración óptima.\n\u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; aparece durante la fase de arranque cuando el router carece de información suficiente sobre pares. El router no participará en el tráfico de retransmisión hasta integrarse adecuadamente. Este mensaje debería desaparecer después de 10-20 minutos, una vez que netDb se pueble con más de 50 routers.\nEl desfase del reloj arruina las pruebas de alcanzabilidad. I2P requiere que la hora del sistema esté dentro de ±60 segundos de la hora de la red. Una diferencia superior a 90 segundos provoca el rechazo automático de la conexión. Sincroniza el reloj de tu sistema:\nLinux: sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows: Panel de control → Fecha y hora → Hora de Internet → Actualizar ahora → Habilitar sincronización automática\nmacOS: Preferencias del Sistema → Fecha y hora → Activa \u0026ldquo;Ajustar la fecha y la hora automáticamente\u0026rdquo;\nDespués de corregir el desfase del reloj, reinicia I2P por completo para una integración adecuada.\nAsignación de ancho de banda insuficiente impide realizar pruebas con éxito. El router necesita capacidad adecuada para construir tunnels de prueba. Configúrelo en http://127.0.0.1:7657/config:\nMínimo viable: Entrante 96 KB/sec, Saliente 64 KB/sec Estándar recomendado: Entrante 256 KB/sec, Saliente 128 KB/sec Rendimiento óptimo: Entrante 512+ KB/sec, Saliente 256+ KB/sec Porcentaje de compartición: 80% (permite que el router aporte ancho de banda a la red) Un menor ancho de banda puede funcionar, pero prolonga el tiempo de integración de minutos a horas.\nnetDb corrupta debido a un apagado incorrecto o a errores de disco provoca bucles de prueba perpetuos. El router no puede completar las pruebas sin datos de pares válidos:\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start Windows: Elimina el contenido de %APPDATA%\\I2P\\netDb\\ o %LOCALAPPDATA%\\I2P\\netDb\\\nEl firewall que bloquea el reseed (obtención inicial de pares) impide adquirir pares iniciales. Durante el arranque, I2P recupera información del router de servidores de reseed mediante HTTPS. Los firewalls corporativos o de los ISP (proveedores de servicios de Internet) pueden bloquear estas conexiones. Configure el proxy de reseed en http://127.0.0.1:7657/configreseed si opera detrás de redes restrictivas.\nVelocidades lentas, tiempos de espera agotados y fallos en la construcción de tunnels El diseño de I2P produce de forma inherente velocidades 3-10x más lentas que clearnet (internet abierta) debido al cifrado de múltiples saltos, la sobrecarga de paquetes y la imprevisibilidad de las rutas. La construcción de un tunnel recorre múltiples routers, cada uno añadiendo latencia. Comprender esto evita diagnosticar erróneamente un comportamiento normal como problemas.\nExpectativas típicas de rendimiento:\nNavegación web de sitios .i2p: cargas de página de 10-30 segundos inicialmente, más rápidas tras el establecimiento del tunnel Uso de torrents con I2PSnark: 10-100 KB/s por torrent según las semillas y las condiciones de la red Descargas de archivos grandes: se requiere paciencia - archivos de megabytes pueden tardar minutos, los de gigabytes toman horas La primera conexión es la más lenta: la creación del tunnel tarda 30-90 segundos; las conexiones posteriores usan tunnels existentes Tasa de éxito en la construcción de Tunnel indica la salud de la red. Consulta en http://127.0.0.1:7657/tunnels:\nPor encima del 60%: Funcionamiento normal y saludable 40-60%: Marginal; considere aumentar el ancho de banda o reducir la carga Por debajo del 40%: Problemático - indica ancho de banda insuficiente, problemas de red o mala selección de pares Aumenta la asignación de ancho de banda como primera optimización. La mayoría de los problemas de lentitud se deben a una escasez de ancho de banda. En http://127.0.0.1:7657/config, aumenta los límites de forma incremental y supervisa las gráficas en http://127.0.0.1:7657/graphs.\nPara DSL/Cable (conexiones de 1-10 Mbps): - Entrante: 400 KB/sec - Saliente: 200 KB/sec - Compartir: 80% - Memoria: 384 MB (editar wrapper.config)\nPara conexiones de alta velocidad (10-100+ Mbps): - Entrante: 1500 KB/sec - Saliente: 1000 KB/sec - Compartir: 80-100% - Memoria: 512-1024 MB - Considere: aumentar los tunnels participantes a 2000-5000 en http://127.0.0.1:7657/configadvanced\nOptimiza la configuración del tunnel para mejorar el rendimiento. Accede a la configuración específica del tunnel en http://127.0.0.1:7657/i2ptunnel y edita cada tunnel:\nCantidad de tunnel: Aumentar de 2 a 3-4 (más rutas disponibles) Cantidad de respaldo: Establecer en 1-2 (conmutación por error rápida si el tunnel falla) Longitud del tunnel: El valor predeterminado de 3 saltos ofrece un buen equilibrio; reducir a 2 mejora la velocidad pero disminuye el anonimato Biblioteca criptográfica nativa (jbigi) ofrece un rendimiento 5-10x mejor que el cifrado en Java puro. Verifica que esté cargada en http://127.0.0.1:7657/logs - busca \u0026ldquo;jbigi loaded successfully\u0026rdquo; o \u0026ldquo;Using native CPUID implementation\u0026rdquo;. Si no aparecen:\nLinux: Por lo general se detecta automáticamente y se carga desde ~/.i2p/jbigi-*.so Windows: Verifica que exista jbigi.dll en el directorio de instalación de I2P Si falta: Instala las herramientas de compilación y compila desde el código fuente, o descarga binarios precompilados de los repositorios oficiales\nMantén el router funcionando de forma continua. Cada reinicio restablece la integración y requiere 30-60 minutos para reconstruir la red de tunnel y las relaciones con pares. Los routers estables con alto tiempo de actividad reciben selección preferente para la construcción de tunnel, creando una retroalimentación positiva para el rendimiento.\nAlto consumo de CPU y memoria El uso excesivo de recursos suele indicar asignación de memoria insuficiente, ausencia de bibliotecas criptográficas nativas o compromiso excesivo con la participación en la red. Los routers bien configurados deberían consumir un 10-30% de CPU durante el uso activo y mantener la memoria estable por debajo del 80% del heap (montón de memoria) asignado.\nLos problemas de memoria se manifiestan como: - Gráficas de memoria con parte superior plana (clavadas en el máximo) - Recolección de basura frecuente (patrón de diente de sierra con caídas pronunciadas) - OutOfMemoryError en los registros (error por falta de memoria) - El router deja de responder bajo carga - Apagado automático debido al agotamiento de recursos\nAumenta la asignación del heap (área de memoria) de Java en wrapper.config (requiere un apagado completo):\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 Crítico: Después de editar wrapper.config, debe apagar por completo (no reiniciar), esperar 11 minutos para una terminación ordenada y luego iniciar desde cero. El botón \u0026ldquo;Restart\u0026rdquo; de la consola del router no recarga la configuración de wrapper.\nLa optimización de CPU requiere una biblioteca criptográfica nativa. Las operaciones de BigInteger en Java puro consumen entre 10 y 20 veces más CPU que las implementaciones nativas. Verifique el estado de jbigi en http://127.0.0.1:7657/logs durante el inicio. Sin jbigi, la CPU se disparará al 50-100% durante la construcción de tunnel y las operaciones de cifrado.\nReducir la carga de tunnel participante si el router está sobrecargado:\nAccede a http://127.0.0.1:7657/configadvanced Establece router.maxParticipatingTunnels=1000 (predeterminado 8000) Reduce el porcentaje de compartición en http://127.0.0.1:7657/config del 80% al 50% Desactiva el modo floodfill si está habilitado: router.floodfillParticipant=false Limita el ancho de banda de I2PSnark y los torrents concurrentes. El uso de torrents consume recursos considerables. En http://127.0.0.1:7657/i2psnark:\nLimita los torrents activos a 3-5 como máximo Configura \u0026ldquo;Límite de ancho de banda de subida\u0026rdquo; y \u0026ldquo;Límite de ancho de banda de bajada\u0026rdquo; en valores razonables (50-100 KB/sec cada uno) Detén los torrents cuando no se necesiten activamente Evita sembrar docenas de torrents simultáneamente Supervisa el uso de recursos mediante los gráficos integrados en http://127.0.0.1:7657/graphs. La memoria debería mostrar margen disponible, no un tope plano. Los picos de CPU durante la construcción de tunnel son normales; un uso alto y sostenido de CPU indica problemas de configuración.\nPara sistemas con recursos muy limitados (Raspberry Pi, hardware antiguo), considera i2pd (implementación en C++) como alternativa. i2pd requiere ~130 MB de RAM frente a 350+ MB para Java I2P, y utiliza ~7% de CPU frente a 70% bajo cargas similares. Ten en cuenta que i2pd carece de aplicaciones integradas y requiere herramientas externas.\nProblemas con torrents en I2PSnark La integración de I2PSnark con la arquitectura del router de I2P requiere comprender que el uso de torrents depende por completo del estado de los tunnels del router. Los torrents no se iniciarán hasta que el router alcance una integración adecuada con 10 o más pares activos y cuente con tunnels en funcionamiento.\nLos torrents atascados en 0% suelen indicar:\nRouter no completamente integrado: Espera 10-15 minutos después de iniciar I2P antes de esperar actividad de torrents DHT (tabla hash distribuida) deshabilitado: Actívalo en http://127.0.0.1:7657/i2psnark → Configuración → marca \u0026ldquo;Enable DHT\u0026rdquo; (activado por defecto desde la versión 0.9.2) Rastreadores no válidos o caídos: Los torrents de I2P requieren rastreadores específicos de I2P - los rastreadores de clearnet no funcionarán Configuración de tunnel insuficiente: Aumenta los tunnels en Configuración de I2PSnark → sección Tunnels Configura los tunnels de I2PSnark para un mejor rendimiento:\nTunnels entrantes: 3-5 (por defecto 2 para Java I2P, 5 para i2pd) Tunnels salientes: 3-5 Longitud del tunnel: 3 saltos (reduzca a 2 para mayor velocidad, menos anonimato) Cantidad de tunnels: 3 (proporciona un rendimiento constante) Rastreadores de torrents esenciales de I2P para incluir: - tracker2.postman.i2p (principal, el más confiable) - w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a\nElimina todos los trackers de clearnet (non-.i2p) - no aportan ningún valor y generan intentos de conexión que agotan el tiempo de espera.\nerrores \u0026ldquo;Torrent not registered\u0026rdquo; ocurren cuando falla la comunicación con el tracker. Haz clic derecho en el torrent → \u0026ldquo;Start\u0026rdquo; fuerza un reanuncio. Si persiste, verifica la accesibilidad del tracker visitando http://tracker2.postman.i 2p en un navegador configurado para I2P. Los trackers inactivos deben reemplazarse por alternativas funcionales.\nNo se conectan pares a pesar del éxito del tracker, lo que sugiere: - Router detrás de un firewall (mejora con el reenvío de puertos, pero no es obligatorio) - Ancho de banda insuficiente (aumenta a 256+ KB/s) - Enjambre demasiado pequeño (algunos torrents tienen 1-2 semillas; se requiere paciencia) - DHT desactivado (actívalo para el descubrimiento de pares sin tracker)\nActiva DHT y PEX (Intercambio de pares) en la configuración de I2PSnark. DHT permite encontrar pares sin depender de rastreadores. PEX descubre pares a partir de los pares conectados, acelerando el descubrimiento del enjambre.\nCorrupción de archivos descargados rara vez ocurre con la comprobación de integridad integrada de I2PSnark. Si se detecta:\nClic derecho en el torrent → \u0026ldquo;Check\u0026rdquo; fuerza el recálculo del hash de todas las piezas Elimina los datos de torrent dañados (conserva el archivo .torrent) Clic derecho → \u0026ldquo;Start\u0026rdquo; para volver a descargar con verificación de piezas Comprueba el disco en busca de errores si la corrupción persiste: chkdsk (Windows), fsck (Linux) El directorio vigilado no funciona requiere una configuración adecuada:\nConfiguración de I2PSnark → \u0026ldquo;Watch directory\u0026rdquo;: Establece la ruta absoluta (p. ej., /home/user/torrents/watch) Asegúrate de que el proceso de I2P tenga permisos de lectura: chmod 755 /path/to/watch Coloca los archivos .torrent en el directorio de vigilancia - I2PSnark los añade automáticamente Configura \u0026ldquo;Auto start\u0026rdquo;: Elige si los torrents deben iniciarse inmediatamente al añadirse Optimización del rendimiento para el uso de torrents:\nLimita los torrents activos simultáneos: 3-5 como máximo para conexiones estándar Prioriza las descargas importantes: detén temporalmente los torrents de baja prioridad Aumenta la asignación de ancho de banda del router: más ancho de banda = mejor rendimiento de torrents Ten paciencia: el uso de torrents en I2P es por naturaleza más lento que BitTorrent en la clearnet Seed (compartir como fuente) después de descargar: la red prospera gracias a la reciprocidad Configuración y solución de problemas de Git a través de I2P Las operaciones de Git a través de I2P requieren ya sea configuración de proxy SOCKS o tunnels de I2P dedicados para acceso SSH/HTTP. El diseño de Git asume conexiones de baja latencia, lo que hace que la arquitectura de alta latencia de I2P sea un desafío.\nConfigurar Git para usar el proxy SOCKS de I2P:\nEdite ~/.ssh/config (créalo si no existe):\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes Esto encamina todas las conexiones SSH a hosts .i2p a través del proxy SOCKS de I2P (puerto 4447). Los parámetros ServerAlive mantienen la conexión durante la latencia de I2P.\nPara operaciones de git vía HTTP/HTTPS, configura git globalmente:\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 Nota: socks5h realiza la resolución de DNS a través del proxy - crucial para los dominios .i2p.\nCrear un I2P tunnel dedicado para Git sobre SSH (más fiable que SOCKS):\nAccede a http://127.0.0.1:7657/i2ptunnel \u0026ldquo;Nuevo tunnel de cliente\u0026rdquo; → \u0026ldquo;Estándar\u0026rdquo; Configura: Nombre: Git-SSH Tipo: Cliente Puerto: 2222 (puerto local para acceso a Git) Destino: [your-git-server].i2p:22 Inicio automático: Activado Número de tunnel: 3-4 (más alto para mayor fiabilidad) Guarda e inicia el tunnel Configura SSH para usar el tunnel: ssh -p 2222 git@127.0.0.1 Errores de autenticación de SSH a través de I2P suelen deberse a:\nClave no agregada al ssh-agent: ssh-add ~/.ssh/id_rsa Permisos incorrectos del archivo de la clave: chmod 600 ~/.ssh/id_rsa Tunnel no se está ejecutando: Verifica en http://127.0.0.1:7657/i2ptunnel que el estado sea verde El servidor Git requiere un tipo específico de clave: Genera una clave ed25519 si RSA falla Operaciones de Git que agotan el tiempo de espera se relacionan con las características de latencia de I2P:\nAumentar el tiempo de espera de Git: git config --global http.postBuffer 524288000 (búfer de 500 MB) Aumentar el límite de baja velocidad: git config --global http.lowSpeedLimit 1000 y git config --global http.lowSpeedTime 600 (espera 10 minutos) Usar clonación superficial para el checkout inicial: git clone --depth 1 [url] (solo trae el último commit, más rápido) Clonar durante periodos de baja actividad: la congestión de la red afecta al rendimiento de I2P Operaciones lentas de git clone/fetch son inherentes a la arquitectura de I2P. Un repositorio de 100MB puede tardar entre 30 y 60 minutos a través de I2P, frente a segundos en clearnet (internet abierta). Estrategias:\nUsa clones superficiales: --depth 1 reduce drásticamente la transferencia de datos inicial Obtén de forma incremental: En lugar de un clon completo, obtén ramas específicas: git fetch origin branch:branch Considera rsync sobre I2P: Para repositorios muy grandes, rsync puede ofrecer mejor rendimiento Aumenta la cantidad de tunnels (túneles de I2P): Más tunnels proporcionan mejor rendimiento para transferencias grandes sostenidas Los errores \u0026ldquo;Connection refused\u0026rdquo; indican una mala configuración del tunnel:\nVerifica que el I2P router esté en ejecución: Revisa http://127.0.0.1:7657 Confirma que el tunnel esté activo y en verde en http://127.0.0.1:7657/i2ptunnel Prueba el tunnel: nc -zv 127.0.0.1 2222 (debería conectar si el tunnel está funcionando) Comprueba que el destino sea alcanzable: Navega a la interfaz HTTP del destino si está disponible Revisa los registros del tunnel en http://127.0.0.1:7657/logs en busca de errores específicos Mejores prácticas de Git sobre I2P:\nMantén el I2P router en ejecución de forma continua para un acceso estable a Git Usa claves SSH en lugar de autenticación por contraseña (menos indicaciones interactivas) Configura tunnels persistentes en lugar de conexiones SOCKS efímeras Considera alojar tu propio servidor Git en I2P para mayor control Documenta tus endpoints (puntos de conexión) de Git .i2p para tus colaboradores Acceder a eepsites y resolver dominios .i2p La razón más frecuente por la que los usuarios no pueden acceder a los sitios .i2p es una configuración incorrecta del proxy del navegador. Los sitios de I2P existen únicamente dentro de la red de I2P y requieren enrutamiento a través del proxy HTTP de I2P.\nConfigura exactamente los ajustes de proxy del navegador:\nFirefox (recomendado para I2P):\nMenú → Configuración → Configuración de red → botón Configuración Selecciona \u0026ldquo;Configuración manual de proxy\u0026rdquo; Proxy HTTP: 127.0.0.1 Puerto: 4444 Proxy SSL: 127.0.0.1 Puerto: 4444 Proxy SOCKS: 127.0.0.1 Puerto: 4447 (opcional, para aplicaciones SOCKS) Marca \u0026ldquo;Proxy DNS al usar SOCKS v5\u0026rdquo; OK para guardar Ajustes críticos de about:config de Firefox:\nNavega a about:config y modifica:\nmedia.peerconnection.ice.proxy_only = true (evita filtraciones de IP mediante WebRTC) keyword.enabled = false (evita que las direcciones .i2p se redirijan a motores de búsqueda) network.proxy.socks_remote_dns = true (DNS a través del proxy) Limitaciones de Chrome/Chromium:\nChrome utiliza la configuración de proxy del sistema en lugar de una específica de la aplicación. En Windows: Configuración → busca \u0026ldquo;proxy\u0026rdquo; → \u0026ldquo;Abrir la configuración de proxy del equipo\u0026rdquo; → Configura HTTP: 127.0.0.1:4444 y HTTPS: 127.0.0.1:4445.\nMejor enfoque: Utiliza las extensiones FoxyProxy o Proxy SwitchyOmega para el enrutamiento selectivo de .i2p.\n\u0026ldquo;Website Not Found In Address Book\u0026rdquo; errores significan que el router no tiene la dirección criptográfica del dominio .i2p. I2P usa libretas de direcciones locales en lugar de DNS centralizado. Soluciones:\nMétodo 1: Usar servicios de salto (lo más sencillo para sitios nuevos):\nVisita http://stats.i 2p y busca el sitio. Haz clic en el enlace de addresshelper (ayuda de direcciones): http://example.i2p/?i2paddresshelper=base64destination. Tu navegador muestra \u0026ldquo;¿Guardar en la libreta de direcciones?\u0026rdquo; - confirma para añadirlo.\nMétodo 2: Actualizar las suscripciones de la libreta de direcciones:\nAccede a http://127.0.0.1:7657/dns (SusiDNS) Haz clic en la pestaña \u0026ldquo;Subscriptions\u0026rdquo; Verifica las suscripciones activas (predeterminado: http://i2p-projekt.i 2p/hosts.txt) Añade suscripciones recomendadas: http://stats.i 2p/cgi-bin/newhosts.txt http://notbob.i 2p/hosts.txt http://reg.i 2p/export/hosts.txt Haz clic en \u0026ldquo;Update Now\u0026rdquo; para forzar la actualización inmediata de las suscripciones Espera de 5 a 10 minutos para el procesamiento Método 3: Usa direcciones base32 (siempre funciona si el sitio está en línea):\nCada sitio .i2p tiene una dirección base32: 52 caracteres aleatorios seguidos de .b32.i2p (p. ej., ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p). Las direcciones Base32 omiten la libreta de direcciones - el router realiza una búsqueda criptográfica directa.\nErrores comunes de configuración del navegador:\nIntentar HTTPS en sitios solo HTTP: La mayoría de los sitios .i2p usan solo HTTP - intentar https://example.i2p falla Olvidar el prefijo http://: El navegador puede buscar en lugar de conectarse - usa siempre http://example.i2p WebRTC habilitado: Puede filtrar la dirección IP real - desactívalo desde la configuración de Firefox o con extensiones DNS sin proxy: El DNS de clearnet (Internet abierta) no puede resolver .i2p - debes enviar las consultas DNS a través del proxy Puerto de proxy incorrecto: 4444 para HTTP (no 4445, que es un outproxy (proxy de salida) HTTPS hacia clearnet) Router no completamente integrado impide el acceso a cualquier sitio. Verifique que la integración sea adecuada:\nComprueba que http://127.0.0.1:7657 muestre \u0026ldquo;Network: OK\u0026rdquo; o \u0026ldquo;Network: Firewalled\u0026rdquo; (no \u0026ldquo;Network: Testing\u0026rdquo;) Los pares activos muestran 10+ como mínimo (50+ óptimo) Que no aparezca el mensaje \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; Espera 10-15 minutos completos después del arranque del router antes de esperar acceso a .i2p La configuración de los clientes de IRC y correo electrónico sigue patrones de proxy similares:\nIRC: Los clientes se conectan a 127.0.0.1:6668 (el tunnel proxy de IRC de I2P). Deshabilita la configuración de proxy del cliente de IRC - la conexión a localhost:6668 ya se realiza a través de I2P.\nCorreo electrónico (Postman): - SMTP: 127.0.0.1:7659 - POP3: 127.0.0.1:7660 - Sin SSL/TLS (cifrado gestionado por el I2P tunnel) - Credenciales del registro de la cuenta en postman.i2p\nTodos estos tunnels deben mostrar el estado \u0026ldquo;running\u0026rdquo; (verde) en http://127.0.0.1:7657/i2ptunnel.\nErrores de instalación y problemas con paquetes Las instalaciones basadas en paquetes (Debian, Ubuntu, Arch) ocasionalmente fallan debido a cambios en los repositorios, expiración de la clave GPG o conflictos de dependencias. Los repositorios oficiales cambiaron de deb.i2p2.de/deb.i2p2.no (fin de vida) a deb.i2p.net en versiones recientes.\nActualizar el repositorio de Debian/Ubuntu a la versión actual:\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring Fallos en la verificación de firmas GPG se producen cuando las claves del repositorio expiran o cambian:\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc El servicio no se inicia después de la instalación del paquete suele deberse a problemas con el perfil de AppArmor en Debian/Ubuntu:\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service Problemas de permisos en I2P instalado mediante paquetes:\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 Problemas de compatibilidad con Java:\nI2P 2.10.0 requiere Java 8 como mínimo. Los sistemas más antiguos pueden tener Java 7 o anterior:\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java Errores de configuración del Wrapper (programa gestor de servicios de Java) impiden el inicio del servicio:\nLa ubicación de Wrapper.config varía según el método de instalación: - Instalación de usuario: ~/.i2p/wrapper.config - Instalación desde paquete: /etc/i2p/wrapper.config o /var/lib/i2p/wrapper.config\nProblemas comunes de wrapper.config:\nRutas incorrectas: wrapper.java.command debe apuntar a una instalación válida de Java Memoria insuficiente: wrapper.java.maxmemory configurado demasiado bajo (aumentar a 512 o más) Ubicación del archivo PID incorrecta: wrapper.pidfile debe ser una ubicación con permisos de escritura Falta el binario del wrapper (envoltorio): Algunas plataformas carecen de un wrapper precompilado (usa runplain.sh como alternativa) Errores de actualización y actualizaciones corruptas:\nLas actualizaciones de la consola del router ocasionalmente fallan a mitad de la descarga debido a interrupciones de red. Procedimiento de actualización manual:\nDescarga i2pupdate_X.X.X.zip desde https://geti2p.net/en/download Verifica que la suma de verificación SHA256 coincida con el hash publicado Copia al directorio de instalación de I2P como i2pupdate.zip Reinicia el router - detecta y extrae la actualización automáticamente Espera 5-10 minutos para la instalación de la actualización Verifica la nueva versión en http://127.0.0.1:7657 La migración desde versiones muy antiguas (pre-0.9.47) a las versiones actuales puede fallar debido a claves de firma incompatibles o funciones eliminadas. Se requieren actualizaciones incrementales:\nVersiones anteriores a 0.9.9: No pueden verificar las firmas actuales - se necesita una actualización manual Versiones con Java 6/7: Se debe actualizar Java antes de actualizar I2P a 2.x Grandes saltos de versión: Actualice primero a una versión intermedia (0.9.47 recomendado como punto intermedio) Cuándo usar el instalador vs el paquete:\nPaquetes (apt/yum): Lo mejor para servidores, actualizaciones de seguridad automáticas, integración con el sistema, gestión con systemd Instalador (.jar): Lo mejor para instalación a nivel de usuario, Windows, macOS, instalaciones personalizadas, disponibilidad de la última versión Corrupción y recuperación de archivos de configuración La persistencia de la configuración de I2P depende de varios archivos críticos. La corrupción normalmente se debe a apagado incorrecto, errores de disco o errores de edición manual. Comprender la finalidad de los archivos permite una reparación quirúrgica en lugar de una reinstalación completa.\nArchivos críticos y sus propósitos:\nrouter.keys (516+ bytes): Identidad criptográfica del router - perderlo crea una identidad nueva router.info (autogenerado): Información publicada del router - se puede borrar con seguridad, se regenera router.config (texto): Configuración principal - ancho de banda, configuración de red, preferencias i2ptunnel.config (texto): Definiciones de tunnel - tunnels cliente/servidor, claves, destinos netDb/ (directorio): Base de datos de pares - información del router para los participantes de la red peerProfiles/ (directorio): Estadísticas de rendimiento sobre los pares - influye en la selección de tunnels keyData/ (directorio): Claves de destino para eepsites y servicios - perderlas cambia las direcciones addressbook/ (directorio): Asignaciones locales de nombres de host .i2p Procedimiento de copia de seguridad completo antes de realizar modificaciones:\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR Síntomas de corrupción de Router.config:\nEl router no arranca; aparecen errores de análisis en los registros La configuración no se mantiene tras reiniciar Aparecen valores predeterminados inesperados Caracteres ilegibles al ver el archivo Reparar router.config dañado:\nHacer copia de seguridad de lo existente: cp router.config router.config.broken Comprobar la codificación del archivo: Debe ser UTF-8 sin BOM Validar la sintaxis: Las claves usan el separador = (no :), sin espacios finales en las claves, # solo para comentarios Corrupción común: caracteres no ASCII en los valores, problemas de fin de línea (CRLF vs LF) Si no es reparable: Eliminar router.config - el router genera la configuración predeterminada, preservando la identidad Ajustes esenciales de router.config que se deben conservar:\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false router.keys perdido o no válido crea una nueva identidad del router. Esto es aceptable a menos que:\nEjecutando floodfill (pierde el estado de floodfill) Alojando eepsites con dirección publicada (pierde la continuidad) Reputación establecida en la red No es posible la recuperación sin copia de seguridad - genere una nueva: elimine router.keys, reinicie I2P, se creará una nueva identidad.\nDistinción crítica: router.keys (identidad) vs keyData/* (servicios). Perder router.keys cambia la identidad del router. Perder keyData/mysite-keys.dat cambia la dirección .i2p de tu eepsite - catastrófico si la dirección se ha publicado.\nRealiza copias de seguridad de las claves del eepsite/servicio por separado:\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat Corrupción de NetDb y peerProfiles (perfiles de pares):\nSíntomas: cero pares activos, no se pueden construir tunnels, \u0026ldquo;Se detectó corrupción de la base de datos\u0026rdquo; en los registros\nSolución segura (todo se resembrará/reconstruirá automáticamente):\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration Estos directorios contienen solo información de red en caché - al eliminarlos se fuerza un arranque inicial desde cero, pero no se pierde ningún dato crítico.\nEstrategias de prevención:\nApagado limpio siempre: Usa i2prouter stop o el botón \u0026ldquo;Shutdown\u0026rdquo; de la consola del router - nunca mates el proceso a la fuerza Copias de seguridad automatizadas: Tarea cron semanal de copia de ~/.i2p a un disco separado Supervisión de la salud del disco: Verifica el estado SMART periódicamente - los discos con fallos corrompen datos Espacio en disco suficiente: Mantén más de 1 GB libre - los discos llenos provocan corrupción de datos UPS (sistema de alimentación ininterrumpida) recomendado: Los cortes de energía durante las escrituras corrompen archivos Control de versiones de configuraciones críticas: Un repositorio Git para router.config, i2ptunnel.config permite revertir cambios Los permisos de archivo importan:\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems Mensajes de error comunes explicados El sistema de registro de I2P proporciona mensajes de error específicos que identifican con precisión los problemas. Comprender estos mensajes acelera la resolución de problemas.\n\u0026ldquo;No tunnels available\u0026rdquo; aparece cuando el router no ha construido suficientes tunnels para funcionar. Esto es normal durante los primeros 5-10 minutos tras el arranque. Si persiste más de 15 minutos:\nVerifica que los pares activos sean \u0026gt; 10 en http://127.0.0.1:7657 Comprueba que la asignación de ancho de banda sea adecuada (mínimo 128+ KB/s) Examina la tasa de éxito de los tunnel (túnel de I2P) en http://127.0.0.1:7657/tunnels (debería ser \u0026gt;40%) Revisa los registros para conocer los motivos de rechazo en la construcción de tunnel \u0026ldquo;Clock skew detected\u0026rdquo; o \u0026ldquo;NTCP2 disconnect code 7\u0026rdquo; indican que la hora del sistema difiere del consenso de la red en más de 90 segundos. I2P requiere precisión de ±60 segundos. Las conexiones con routers con el reloj desfasado se rechazan automáticamente.\nCorregir inmediatamente:\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings \u0026ldquo;Build timeout\u0026rdquo; o \u0026ldquo;Tunnel build timeout exceeded\u0026rdquo; significa que la construcción del tunnel a través de la cadena de pares no se completó dentro de la ventana de tiempo de espera (normalmente 60 segundos). Causas:\nPares lentos: Router seleccionó participantes que no responden para el tunnel Congestión de la red: La red I2P está experimentando una carga alta Ancho de banda insuficiente: Tus límites de ancho de banda impiden el establecimiento oportuno de tunnels Router sobrecargado: Demasiados tunnels participantes consumen recursos Soluciones: Aumentar el ancho de banda, reducir los tunnels participantes (router.maxParticipatingTunnels en http://127.0.0.1:7657/configadvanced), habilitar el reenvío de puertos para una mejor selección de pares.\nAparecen \u0026ldquo;Router is shutting down\u0026rdquo; o \u0026ldquo;Graceful shutdown in progress\u0026rdquo; durante un apagado normal o la recuperación tras un fallo. El apagado ordenado puede tardar hasta 10 minutos, ya que el router cierra tunnels, notifica a los pares y guarda el estado.\nSi queda atascado en el estado de apagado durante más de 11 minutos, fuerce la terminación:\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; indica agotamiento de la memoria heap. Soluciones inmediatas:\nEdite wrapper.config: wrapper.java.maxmemory=512 (o superior) Se requiere un apagado completo - un reinicio no aplicará el cambio Espere 11 minutos para el apagado completo Inicie el router desde cero Verifique la asignación de memoria en http://127.0.0.1:7657/graphs - debería mostrar margen libre Errores de memoria relacionados:\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo;: Se está dedicando demasiado tiempo a la recolección de basura - aumente el heap (memoria heap de la JVM) \u0026ldquo;Metaspace\u0026rdquo;: Espacio de metadatos de clases de Java agotado - añada wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M Específico de Windows: Kaspersky Antivirus limita el heap de Java a 512 MB independientemente de la configuración de wrapper.config - desinstálalo o añade I2P a las exclusiones.\n\u0026ldquo;Tiempo de espera de la conexión agotado\u0026rdquo; o \u0026ldquo;Error de I2CP - puerto 7654\u0026rdquo; cuando las aplicaciones intentan conectarse al router:\nVerifique que el router esté en ejecución: http://127.0.0.1:7657 debería responder Verifique el puerto I2CP: netstat -an | grep 7654 debería mostrar LISTENING Asegúrese de que el cortafuegos de localhost permita: sudo ufw allow from 127.0.0.1 Verifique que la aplicación esté usando el puerto correcto (I2CP=7654, SAM=7656) \u0026ldquo;Certificate validation failed\u0026rdquo; o \u0026ldquo;RouterInfo corrupt\u0026rdquo; durante el reseed (proceso de resembrado inicial de la red):\nCausas raíz: desfase del reloj (corrige esto primero), netDb corrupta, certificados de reseed (arranque inicial de la red) inválidos\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data \u0026ldquo;Se detectó corrupción de base de datos\u0026rdquo; indica corrupción de datos a nivel de disco en netDb o peerProfiles (perfiles de pares):\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start Comprueba la salud del disco con herramientas SMART - la corrupción recurrente sugiere que el almacenamiento está fallando.\nDesafíos específicos de la plataforma Los distintos sistemas operativos plantean desafíos únicos para el despliegue de I2P relacionados con los permisos, las políticas de seguridad y la integración con el sistema.\nProblemas de permisos y servicios en Linux I2P instalado como paquete se ejecuta como el usuario del sistema i2psvc (Debian/Ubuntu) o i2p (otras distribuciones), lo que requiere permisos específicos:\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config Límites de descriptores de archivo afectan la capacidad del router para las conexiones. Los límites predeterminados (1024) son insuficientes para routers de alto ancho de banda:\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p Conflictos de AppArmor comunes en Debian/Ubuntu impiden el inicio del servicio:\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined Problemas de SELinux en RHEL/CentOS/Fedora:\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t Solución de problemas del servicio SystemD:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service Interferencia del cortafuegos de Windows y del antivirus Windows Defender y los productos antivirus de terceros con frecuencia marcan I2P debido a patrones de comportamiento de red. Una configuración adecuada evita bloqueos innecesarios manteniendo la seguridad.\nConfigurar el Firewall de Windows Defender:\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; Reemplaza el puerto 22648 por tu puerto real de I2P que aparece en http://127.0.0.1:7657/confignet.\nProblema específico de Kaspersky Antivirus: \u0026ldquo;Application Control\u0026rdquo; de Kaspersky limita el heap de Java a 512MB independientemente de la configuración de wrapper.config. Esto provoca OutOfMemoryError (error por falta de memoria) en routers de alto ancho de banda.\nSoluciones: 1. Añade I2P a las exclusiones de Kaspersky: Settings → Additional → Threats and Exclusions → Manage Exclusions 2. O desinstala Kaspersky (recomendado para el funcionamiento de I2P)\nOrientación general sobre antivirus de terceros:\nAñade el directorio de instalación de I2P a las exclusiones Añade %APPDATA%\\I2P y %LOCALAPPDATA%\\I2P a las exclusiones Excluye javaw.exe del análisis de comportamiento Desactiva las funciones de \u0026ldquo;Network Attack Protection\u0026rdquo; (protección contra ataques de red) que puedan interferir con los protocolos de I2P Gatekeeper de macOS bloquea la instalación Gatekeeper (función de seguridad de macOS) impide la ejecución de aplicaciones no firmadas. Los instaladores de I2P no están firmados con el ID de Desarrollador de Apple, lo que provoca advertencias de seguridad.\nOmitir Gatekeeper (función de seguridad de macOS) para el instalador de I2P:\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file Después de la instalación, la ejecución todavía puede generar advertencias:\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ Nunca desactives permanentemente Gatekeeper - riesgo de seguridad para otras aplicaciones. Usa solo excepciones específicas por archivo.\nConfiguración del cortafuegos de macOS:\nPreferencias del Sistema → Seguridad y privacidad → Firewall → Opciones del Firewall Haz clic en \u0026ldquo;+\u0026rdquo; para añadir la aplicación Navega a la instalación de Java (p. ej., /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java) Añádela y configúrala en \u0026ldquo;Permitir conexiones entrantes\u0026rdquo; Problemas con la aplicación I2P para Android Las restricciones de versión de Android y las limitaciones de recursos crean desafíos únicos.\nRequisitos mínimos: - Android 5.0+ (nivel de API 21+) requerido para las versiones actuales - 512MB de RAM mínimo, 1GB+ recomendado - 100MB de almacenamiento para la aplicación + datos del router - Restricciones de aplicaciones en segundo plano desactivadas para I2P\nLa aplicación se cierra inmediatamente:\nComprueba la versión de Android: Ajustes → Acerca del teléfono → Versión de Android (debe ser 5.0 o superior) Desinstala todas las versiones de I2P: Instala solo una variante: net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\nMúltiples instalaciones entran en conflicto Borra los datos de la app: Ajustes → Aplicaciones → I2P → Almacenamiento → Borrar datos Vuelve a instalar desde cero La optimización de la batería está forzando el cierre del router:\nAndroid cierra agresivamente las aplicaciones en segundo plano para ahorrar batería. I2P debe excluirse:\nAjustes → Batería → Optimización de batería (o Uso de batería de la aplicación) Busca I2P → No optimizar (o Permitir actividad en segundo plano) Ajustes → Aplicaciones → I2P → Batería → Permitir actividad en segundo plano + Eliminar restricciones Problemas de conexión en móviles:\nEl bootstrap (proceso de arranque) requiere WiFi: La reseed inicial (descarga de listas de pares) consume una cantidad significativa de datos - usa WiFi, no datos móviles Cambios de red: I2P no maneja bien los cambios de red - reinicia la aplicación después de una transición entre WiFi y datos móviles Ancho de banda para móviles: Configura de forma conservadora a 64-128 KB/sec para evitar agotar los datos móviles Optimización del rendimiento para móviles:\nApp de I2P → Menú → Ajustes → Ancho de banda Establece límites adecuados: 64 KB/sec entrante, 32 KB/sec saliente para datos móviles Reduce los tunnels participantes: Ajustes → Avanzado → Máximo de tunnels participantes: 100-200 Activa \u0026ldquo;Detener I2P cuando la pantalla esté apagada\u0026rdquo; para ahorrar batería Uso de torrents en Android:\nLimitar a 2-3 torrents simultáneos como máximo Reducir la agresividad de la DHT (tabla hash distribuida) Usar solo WiFi para torrents Aceptar velocidades más lentas en hardware móvil Problemas de Reseed (resembrado inicial) y de bootstrap (arranque) Las instalaciones nuevas de I2P requieren reseeding (descarga inicial de información de pares) - obtener información inicial de pares desde servidores HTTPS públicos para unirse a la red. Los problemas de reseeding dejan a los usuarios con cero pares y sin acceso a la red.\n\u0026ldquo;No active peers\u0026rdquo; después de una instalación reciente normalmente indica un fallo en el reseed (proceso inicial de obtención de pares). Síntomas:\nPares conocidos: 0 o permanece por debajo de 5 \u0026ldquo;Network: Testing\u0026rdquo; persiste durante más de 15 minutos Los registros muestran \u0026ldquo;Reseed failed\u0026rdquo; o errores de conexión con los servidores de reseed (obtención inicial de pares) Por qué falla el reseed (proceso de obtención inicial de pares):\nCortafuegos que bloquea HTTPS: Los cortafuegos corporativos/ISP bloquean conexiones con servidores reseed (servidores de arranque para obtener pares iniciales en I2P) (puerto 443) Errores de certificado SSL: El sistema carece de certificados raíz actualizados Requisito de proxy: La red requiere un proxy HTTP/SOCKS para conexiones externas Desfase del reloj: La validación de certificados SSL falla cuando la hora del sistema es incorrecta Censura geográfica: Algunos países/ISP bloquean servidores reseed conocidos Forzar reseed manual (resembrado inicial de pares):\nAccede a http://127.0.0.1:7657/configreseed Haz clic en \u0026ldquo;Save changes and reseed now\u0026rdquo; Supervisa http://127.0.0.1:7657/logs en busca de \u0026ldquo;Reseed got XX router infos\u0026rdquo; Espera de 5 a 10 minutos para el procesamiento Comprueba http://127.0.0.1:7657 - Los pares conocidos deberían aumentar a 50+ Configurar proxy de reseed (proceso de arranque para obtener nodos iniciales de la red) para redes restrictivas:\nhttp://127.0.0.1:7657/configreseed → Configuración del proxy:\nProxy HTTP: [proxy-server]:[port] O SOCKS5: [socks-server]:[port] Activa \u0026ldquo;Use proxy for reseed only\u0026rdquo; Credenciales si es necesario Guarda y fuerza el reseed (proceso de arranque de la red) Alternativa: proxy de Tor para el reseed (proceso inicial para obtener pares y poner en marcha I2P):\nSi Tor Browser o el demonio de Tor están en ejecución:\nTipo de proxy: SOCKS5 Host: 127.0.0.1 Puerto: 9050 (puerto SOCKS predeterminado de Tor) Habilitar y resembrar Reseed (obtención inicial de pares) manual mediante archivo su3 (último recurso):\nCuando falle todo el reseed (proceso de incorporación inicial a la red) automatizado, obtenga el archivo de reseed por un canal fuera de banda:\nDescarga i2pseeds.su3 desde una fuente de confianza con una conexión sin restricciones (https://reseed.i2p.rocks/i2pseeds.su3 , https://reseed-fr.i2pd.xyz/i2pseeds.su3 ) Detén I2P por completo Copia i2pseeds.su3 al directorio ~/.i2p/ Inicia I2P - extrae y procesa el archivo automáticamente Elimina i2pseeds.su3 después del procesamiento Verifica que los pares aumenten en http://127.0.0.1:7657 Errores de certificados SSL durante el reseed (proceso de obtención inicial de pares):\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing Soluciones:\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates Atascado en 0 pares conocidos durante más de 30 minutos:\nIndica un fallo completo del reseed (arranque inicial de la red obteniendo nodos iniciales desde servidores de reseed). Secuencia de resolución de problemas:\nVerifica que la hora del sistema sea precisa (problema más común - corrígelo PRIMERO) Prueba la conectividad HTTPS: Intenta acceder a https://reseed.i2p.rocks en el navegador - si falla, es un problema de red Revisa los registros de I2P en http://127.0.0.1:7657/logs para errores específicos de reseed (proceso de arranque inicial de la red) Prueba una URL de reseed diferente: http://127.0.0.1:7657/configreseed → añade una URL de reseed personalizada: https://reseed-fr.i2pd.xyz/ Usa el método manual con archivo su3 si se han agotado los intentos automáticos Servidores de reseed (servidores usados para obtener los pares iniciales de la red) ocasionalmente fuera de línea: I2P incluye múltiples servidores de reseed predefinidos. Si uno falla, el router prueba otros automáticamente. Un fallo total de todos los servidores de reseed es extremadamente raro, pero posible.\nServidores reseed (arranque inicial de la red) actualmente activos (a octubre de 2025):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ Añádelas como URL personalizadas si tienes problemas con las predeterminadas.\nPara usuarios en regiones con fuerte censura:\nConsidera usar puentes Snowflake/Meek a través de Tor para el reseed (arranque inicial de la red), y luego cambiar a una conexión directa a I2P una vez integrado a la red. O bien, obtén i2pseeds.su3 mediante esteganografía, correo electrónico o USB desde fuera de la zona de censura.\nCuándo buscar ayuda adicional Esta guía aborda la gran mayoría de los problemas de I2P, pero algunos requieren la atención de los desarrolladores o la experiencia de la comunidad.\nBusca ayuda de la comunidad de I2P cuando:\nRouter se bloquea de forma constante después de seguir todos los pasos de resolución de problemas Fugas de memoria que provocan un crecimiento constante que supera el heap asignado La tasa de éxito de Tunnel se mantiene por debajo del 20% a pesar de una configuración adecuada Nuevos errores en los registros no cubiertos por esta guía Vulnerabilidades de seguridad descubiertas Solicitudes de funcionalidades o sugerencias de mejora Antes de solicitar ayuda, recopile información de diagnóstico:\nVersión de I2P: http://127.0.0.1:7657 (p. ej., \u0026ldquo;2.10.0\u0026rdquo;) Versión de Java: salida de java -version Sistema operativo y versión Estado del router: Estado de la red, Número de pares activos, Tunnels participantes Configuración de ancho de banda: Límites de entrada/salida Estado del reenvío de puertos: Con cortafuegos o OK Extractos relevantes de los registros: Últimas 50 líneas que muestren errores desde http://127.0.0.1:7657/logs Canales de soporte oficiales:\nForo: https://i2pforum.net (clearnet) o http://i2pforum.i 2p (dentro de I2P) IRC: #i2p en Irc2P (irc.postman.i2p vía I2P) o irc.freenode.net (clearnet) Reddit: https://reddit.com/r/i2p para discusiones de la comunidad Rastreador de errores: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues para errores confirmados Lista de correo: i2p-dev@lists.i2p-projekt.de para consultas de desarrollo Las expectativas realistas importan. I2P es más lento que clearnet (Internet abierta) por su diseño fundamental - el uso de tunnels cifrados de múltiples saltos crea latencia inherente. Un router de I2P que carga páginas en 30 segundos y alcanza velocidades de torrent de 50 KB/sec está funcionando correctamente, no está averiado. Los usuarios que esperen velocidades de clearnet quedarán decepcionados independientemente de la optimización de la configuración.\nConclusión La mayoría de los problemas de I2P provienen de tres categorías: paciencia insuficiente durante el bootstrap (fase de arranque), que requiere 10-15 minutos; asignación inadecuada de recursos (512 MB de RAM y 256 KB/sec de ancho de banda como mínimo); o reenvío de puertos mal configurado. Comprender la arquitectura distribuida de I2P y su diseño centrado en el anonimato ayuda a los usuarios a distinguir el comportamiento esperado de los problemas reales.\nEl estado \u0026ldquo;Firewalled\u0026rdquo; del router, aunque subóptimo, no impide el uso de I2P - solo limita la contribución a la red y degrada ligeramente el rendimiento. Los usuarios nuevos deberían priorizar la estabilidad sobre la optimización: ejecutar el router de forma continua durante varios días antes de ajustar la configuración avanzada, ya que la integración mejora de manera natural con el tiempo de actividad.\nAl solucionar problemas, verifique siempre primero lo fundamental: hora correcta del sistema, ancho de banda adecuado, router en ejecución continua y 10 o más pares activos. La mayoría de los problemas se resuelven atendiendo estos aspectos básicos en lugar de ajustar parámetros de configuración poco claros. I2P recompensa la paciencia y el funcionamiento continuo con un mejor rendimiento a medida que el router construye reputación y optimiza la selección de pares a lo largo de días y semanas de tiempo de actividad.\n","description":"Guía exhaustiva de resolución de problemas para incidencias comunes del router I2P, incluidos problemas de conectividad, rendimiento y configuración","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"Guía de solución de problemas del I2P Router","url":"/es/docs/troubleshooting/"},{"categories":null,"content":"¿Así que quieres empezar a trabajar en I2P? ¡Genial! Aquí tienes una guía rápida para comenzar a contribuir al sitio web o al software, realizar desarrollo o crear traducciones.\n¿No estás listo para programar todavía? Prueba involucrarte primero.\nConoce Java El router I2P y sus aplicaciones integradas utilizan Java como lenguaje de desarrollo principal. Si no tienes experiencia con Java, siempre puedes consultar Thinking in Java Estudia la introducción general, otros documentos de \u0026ldquo;cómo hacer\u0026rdquo;, la introducción técnica y los documentos asociados:\nCómo introducción: Introducción a I2P Centro de documentación: Documentación Introducción técnica: Introducción Técnica Estos te darán una buena visión general de cómo está estructurado I2P y qué diferentes cosas hace.\nObtener el código de I2P Para el desarrollo del router I2P o de las aplicaciones integradas, necesitas obtener el código fuente.\nNuestra forma actual: Git I2P tiene servicios Git oficiales y acepta contribuciones vía Git en nuestro propio GitLab:\nDentro de I2P: http://git.idk.i2p Fuera de I2P: https://i2pgit.org Clona el repositorio principal:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git También está disponible un espejo de solo lectura en GitHub:\nEspejo en GitHub: github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git Compilar I2P Para compilar el código, necesitas el Sun/Oracle Java Development Kit 6 o superior, o un JDK equivalente (se recomienda encarecidamente Sun/Oracle JDK 6) y Apache Ant versión 1.7.0 o superior. Si estás trabajando en el código principal de I2P, ve al directorio i2p.i2p y ejecuta ant para ver las opciones de compilación.\nPara compilar o trabajar en las traducciones de la consola, necesitas las herramientas xgettext, msgfmt y msgmerge del paquete GNU gettext.\nPara el desarrollo de nuevas aplicaciones, consulta la guía de desarrollo de aplicaciones .\nIdeas de Desarrollo Consulta la lista de tareas pendientes (TODO) del proyecto o la lista de problemas en GitLab para obtener ideas:\nProblemas de GitLab: i2pgit.org/I2P_Developers/i2p.i2p/issues Haciendo Disponibles los Resultados Consulta la parte inferior de la página de licencias para los requisitos de privilegios de commit. Necesitas estos para colocar código en i2p.i2p (¡no requerido para el sitio web!).\nPágina de licencias ¡Conócenos! Los desarrolladores se encuentran en IRC. Se les puede contactar en varias redes y en las redes internas de I2P. El lugar habitual para buscar es #i2p-dev. ¡Únete al canal y saluda! También tenemos pautas adicionales para desarrolladores habituales .\nTraducciones Traductores del sitio web y la consola del router: Consulta la Guía para Nuevos Traductores para los siguientes pasos.\nHerramientas I2P es software de código abierto que se desarrolla principalmente utilizando herramientas de código abierto. El proyecto I2P recientemente adquirió una licencia para YourKit Java Profiler. Los proyectos de código abierto son elegibles para recibir una licencia gratuita siempre que se haga referencia a YourKit en el sitio web del proyecto. Por favor, ponte en contacto si estás interesado en realizar análisis de rendimiento del código base de I2P.\nYourKit apoya amablemente proyectos de código abierto con sus perfiladores completos. YourKit, LLC es el creador de herramientas innovadoras e inteligentes para perfilar aplicaciones Java y .NET. Echa un vistazo a los productos de software líderes de YourKit:\nYourKit Java Profiler YourKit .NET Profiler ","description":"Cómo empezar a contribuir a I2P: materiales de estudio, código fuente, compilación, ideas, publicación, comunidad, traducciones y herramientas","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"Guía para Nuevos Desarrolladores","url":"/es/docs/develop/new-developers/"},{"categories":null,"content":"¿Quieres ayudar a hacer I2P accesible a más personas en todo el mundo? La traducción es una de las contribuciones más valiosas que puedes hacer al proyecto. Esta guía te mostrará cómo traducir la consola del router.\nMétodos de traducción Hay dos formas de contribuir con traducciones:\nMétodo 1: Transifex (Recomendado) Esta es la forma más fácil de traducir I2P. Transifex proporciona una interfaz web que hace que la traducción sea simple y accesible.\nRegístrate en Transifex Solicita unirte al equipo de traducción de I2P Comienza a traducir directamente en tu navegador No se requieren conocimientos técnicos - ¡solo regístrate y comienza a traducir!\nMétodo 2: Traducción Manual Para traductores que prefieren trabajar con git y archivos locales, o para idiomas que aún no están configurados en Transifex.\nRequisitos: - Familiaridad con el control de versiones git - Editor de texto o herramienta de traducción (se recomienda POEdit) - Herramientas de línea de comandos: git, gettext\nConfiguración: 1. Únete a #i2p-dev en IRC y preséntate 2. Actualiza el estado de la traducción en el wiki (solicita acceso en IRC) 3. Clona el repositorio apropiado (consulta las secciones a continuación)\nTraducción de la Consola del Router La consola del router es la interfaz web que ves cuando ejecutas I2P. Traducirla ayuda a usuarios que no se sienten cómodos con el inglés.\nUsando Transifex (Recomendado) Ve a I2P en Transifex Selecciona el proyecto de la consola del router Elige tu idioma Comienza a traducir Traducción Manual de la Consola del Router Prerrequisitos: - Igual que la traducción del sitio web (git, gettext) - Clave GPG (para acceso de confirmación) - Acuerdo de desarrollador firmado\nClona el repositorio principal de I2P:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p Archivos a traducir:\nLa consola del router tiene aproximadamente 15 archivos que necesitan traducción:\nArchivos de interfaz principales:\napps/routerconsole/locale/messages_*.po - Mensajes principales de la consola apps/routerconsole/locale-news/messages_*.po - Mensajes de noticias Archivos de proxy:\napps/i2ptunnel/locale/messages_*.po - Interfaz de configuración de túneles Locales de aplicaciones:\napps/susidns/locale/messages_*.po - Interfaz de libreta de direcciones apps/susimail/locale/messages_*.po - Interfaz de correo electrónico Otros directorios de locales específicos de aplicaciones Archivos de documentación:\ninstaller/resources/readme/readme_*.html - Léame de instalación Archivos de ayuda en varias aplicaciones Flujo de trabajo de traducción:\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console Envía tu trabajo: - Crea una solicitud de fusión en GitLab - O comparte archivos con el equipo de desarrollo en IRC\nHerramientas de Traducción POEdit (Altamente Recomendado) POEdit es un editor especializado para archivos de traducción .po.\nCaracterísticas: - Interfaz visual para el trabajo de traducción - Muestra el contexto de traducción - Validación automática - Disponible para Windows, macOS y Linux\nEditores de Texto También puedes usar cualquier editor de texto: - VS Code (con extensiones i18n) - Sublime Text - vim/emacs (para usuarios de terminal)\nComprobaciones de Calidad Antes de enviar: 1. Revisa el formato: Asegúrate de que los marcadores de posición como %s y {0} permanezcan sin cambios 2. Prueba tus traducciones: Instala y ejecuta I2P para ver cómo se ven 3. Coherencia: Mantén la terminología coherente en todos los archivos 4. Longitud: Algunas cadenas tienen restricciones de espacio en la interfaz de usuario\nConsejos para Traductores Directrices Generales Mantén la consistencia: Usa las mismas traducciones para términos comunes en todo el documento Conserva el formato: Preserva las etiquetas HTML, marcadores de posición (%s, {0}) y saltos de línea El contexto importa: Lee cuidadosamente el texto fuente en inglés para comprender el contexto Haz preguntas: Usa IRC o los foros si algo no está claro Términos Comunes de I2P Algunos términos deben permanecer en inglés o transliterarse cuidadosamente:\nI2P - Keep as is eepsite - Sitio web I2P (puede requerir explicación en tu idioma) tunnel - Ruta de conexión (evitar terminología de Tor como \u0026ldquo;circuito\u0026rdquo;) netDb - Base de datos de red floodfill - Tipo de router destination - Punto final de dirección I2P Probando Tus Traducciones Compila I2P con tus traducciones Cambia el idioma en la configuración de la consola del router Navega por todas las páginas para verificar: El texto encaja en los elementos de la interfaz No hay caracteres ilegibles (problemas de codificación) Las traducciones tienen sentido en el contexto Preguntas Frecuentes ¿Por qué es tan complejo el proceso de traducción? El proceso utiliza control de versiones (git) y herramientas de traducción estándar (archivos .po) porque:\nResponsabilidad: Rastrear quién cambió qué y cuándo Calidad: Revisar los cambios antes de que se publiquen Consistencia: Mantener el formato y estructura adecuados de los archivos Escalabilidad: Gestionar traducciones en múltiples idiomas de manera eficiente Colaboración: Múltiples traductores pueden trabajar en el mismo idioma ¿Necesito conocimientos de programación? ¡No! Si usas Transifex, solo necesitas: - Fluidez tanto en inglés como en tu idioma objetivo - Un navegador web - Habilidades informáticas básicas\nPara la traducción manual, necesitarás conocimientos básicos de línea de comandos, pero no se requiere programación.\n¿Cuánto tiempo tarda? Consola del router: Aproximadamente 15-20 horas para todos los archivos Mantenimiento: Unas pocas horas por mes para actualizar nuevas cadenas de texto ¿Pueden varias personas trabajar en un mismo idioma? ¡Sí! La coordinación es clave: - Usa Transifex para coordinación automática - Para trabajo manual, comunícate en el canal IRC #i2p-dev - Divide el trabajo por secciones o archivos\n¿Qué pasa si mi idioma no está en la lista? Solicítalo en Transifex o contacta al equipo en IRC. El equipo de desarrollo puede configurar un nuevo idioma rápidamente.\n¿Cómo pruebo mis traducciones antes de enviarlas? Compila I2P desde el código fuente con tus traducciones Instálalo y ejecútalo localmente Cambia el idioma en la configuración de la consola Obtener Ayuda Soporte IRC Únete a #i2p-dev en IRC para: - Ayuda técnica con herramientas de traducción - Preguntas sobre terminología de I2P - Coordinación con otros traductores - Soporte directo de los desarrolladores\nForos Discusiones sobre traducción en Foros I2P Dentro de I2P: foro de Traducción en zzz.i2p (requiere router I2P) Documentación Documentación de Transifex Documentación de POEdit Manual de gettext Reconocimiento Todos los traductores son acreditados en: - La consola del router I2P (página Acerca de) - Página de créditos del sitio web - Historial de commits de Git - Anuncios de lanzamiento\nTu trabajo ayuda directamente a personas de todo el mundo a usar I2P de forma segura y privada. ¡Gracias por contribuir!\nPróximos Pasos ¿Listo para comenzar a traducir?\nElija su método:\nInicio rápido: Regístrese en Transifex Enfoque manual: Únase a #i2p-dev en IRC Empieza poco a poco: Traduce algunas cadenas de texto para familiarizarte con el proceso\nPide ayuda: No dudes en contactar a través de IRC o foros\n¡Gracias por ayudar a hacer I2P accesible para todos!\n","description":"Cómo contribuir con traducciones al sitio web de I2P y a la consola del router utilizando Transifex o métodos manuales","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"Guía para Nuevos Traductores","url":"/es/docs/develop/new-translators/"},{"categories":null,"content":"Introducción I2P proporciona mensajería privada estilo correo electrónico a través del servicio Postman\u0026rsquo;s Mail.i2p combinado con SusiMail, un cliente de correo web integrado. Este sistema permite a los usuarios enviar y recibir correos electrónicos tanto dentro de la red I2P como hacia/desde el internet regular (clearnet) a través de un puente gateway.\nGlosario de I2P Este glosario define términos técnicos comúnmente utilizados en la documentación de I2P.\nA AddressBook Un archivo local que mapea nombres legibles para humanos (como example.i2p) a destinos I2P. Similar al archivo hosts en sistemas operativos convencionales.\nAnonymity El estado de ser anónimo - no identificable dentro de un conjunto de sujetos (el conjunto de anonimato).\nB Base32 Una codificación utilizada para representar destinos I2P en un formato más corto y seguro para URL. Los dominios Base32 terminan en .b32.i2p.\nBase64 Un esquema de codificación utilizado para representar datos binarios (como claves públicas o destinos) en caracteres ASCII imprimibles.\nC Client Application Cualquier aplicación que utiliza I2P para comunicarse de forma anónima. Ejemplos incluyen navegadores web, clientes de correo electrónico y aplicaciones de compartición de archivos.\nCryptography La práctica y estudio de técnicas para comunicación segura en presencia de terceros adversarios.\nD Destination Una identidad criptográfica dentro de I2P. Similar a una dirección IP en Internet, pero incluye claves criptográficas y es permanente.\nDHT (Distributed Hash Table) Una tabla hash distribuida - una estructura de datos descentralizada utilizada para almacenar pares clave-valor a través de múltiples nodos.\nE Eepsite Un sitio web alojado dentro de la red I2P, accesible solo a través de I2P. El término proviene de los dominios .eep utilizados anteriormente.\nEncryption El proceso de codificar información de manera que solo las partes autorizadas puedan acceder a ella.\nF Floodfill Un router I2P que almacena información de netDb y responde a consultas de búsqueda de otros routers. Los routers floodfill forman la columna vertebral del sistema de búsqueda distribuida de I2P.\nG Garlic Encryption El método de encriptación en capas de I2P, similar a la encriptación onion de Tor pero más flexible. Múltiples mensajes pueden agruparse (\u0026ldquo;envueltos en ajo\u0026rdquo;) juntos para mayor eficiencia y seguridad.\nGarlic Message Un mensaje que contiene múltiples \u0026ldquo;cloves\u0026rdquo; (mensajes I2NP encriptados) agrupados juntos para eficiencia.\nH Hidden Service Un servicio accesible únicamente dentro de una red de anonimato. En I2P, típicamente se refiere a eepsites u otros servicios I2P.\nHop Un salto individual en una ruta de red - el viaje de un paquete de un nodo al siguiente.\nI I2CP (I2P Client Protocol) El protocolo que permite que las aplicaciones cliente se comuniquen con el router I2P.\nI2NP (I2P Network Protocol) El protocolo de capa de red utilizado para el enrutamiento de mensajes dentro de I2P.\nI2PTunnel Una herramienta que crea túneles para redirigir tráfico TCP/IP convencional a través de I2P o viceversa.\nInbound Tunnel Un túnel utilizado para recibir mensajes de otros routers I2P.\nInproxy Un servidor proxy que permite el acceso a contenido I2P desde Internet regular, aunque con garantías de anonimato reducidas.\nJ Jump Service Un servicio que resuelve nombres legibles para humanos a destinos I2P, permitiendo a los usuarios compartir enlaces a eepsites más fácilmente.\nK Key Material criptográfico utilizado para cifrado, descifrado, firma o verificación.\nL Latency El tiempo que tarda un mensaje en viajar de origen a destino. I2P típicamente tiene mayor latencia que Internet regular debido al enrutamiento por múltiples saltos.\nLease Una asociación temporal entre un gateway de túnel de entrada y un destination. Los leases expiran y deben renovarse periódicamente.\nLeaseSet Una estructura que contiene los leases de un destination, publicada en netDb para que otros puedan encontrar cómo contactar ese destination.\nM Message Una unidad de comunicación en I2P, típicamente un mensaje I2NP encapsulado dentro de garlic encryption.\nMultihoming La capacidad de un router I2P de utilizar múltiples túneles simultáneamente para redundancia y equilibrio de carga.\nN NetDb (Network Database) La base de datos distribuida que almacena información del router e información de leaseSet, permitiendo a los routers encontrarse entre sí.\nNTCP2 (NTCPv2) Un transporte I2P que opera sobre TCP, proporcionando conexiones encriptadas y autenticadas entre routers.\nNTP (Network Time Protocol) Un protocolo utilizado para sincronizar relojes entre sistemas informáticos. El tiempo preciso es importante para I2P.\nO Outbound Tunnel Un túnel utilizado para enviar mensajes a otros routers I2P.\nOutproxy Un nodo que permite a los usuarios de I2P acceder a servicios de Internet regular de forma anónima.\nP Participant Un router I2P que forma parte de un túnel pero no es el punto final.\nPeer Otro router I2P con el que tu router se comunica directamente.\nPrefix Una porción inicial de un hash de destino o router utilizada para enrutamiento eficiente en netDb.\nQ QoS (Quality of Service) Mecanismos para priorizar cierto tráfico de red y garantizar niveles de rendimiento.\nR Reseeding El proceso de obtener inicialmente información de router de servidores confiables cuando se ejecuta I2P por primera vez o después de estar desconectado por largo tiempo.\nRouter El software principal de I2P que maneja el enrutamiento de mensajes, construcción de túneles y participación en netDb.\nRouterInfo Una estructura publicada en netDb que contiene la identidad de un router, direcciones de contacto y otra información necesaria para que otros routers se conecten a él.\nS SAM (Simple Anonymous Messaging) Una API basada en sockets que permite que aplicaciones cliente utilicen I2P sin implementar I2CP completo.\nStreaming Library Una biblioteca que proporciona comunicación similar a TCP confiable sobre I2P.\nSSU (Secure Semireliable UDP) Un transporte I2P que opera sobre UDP, diseñado para resistir el escaneo de puertos y proporcionar comunicación eficiente.\nT Throttling Limitar intencionalmente la tasa de envío o recepción de datos para gestionar el ancho de banda.\nTunnel Una ruta unidireccional a través de múltiples routers I2P utilizada para transmisión anónima de mensajes.\nTunnel Endpoint El router final en un túnel - el gateway de entrada para túneles inbound o el origen para túneles outbound.\nTunnel Gateway El primer router en un túnel - el punto de entrada para túneles outbound o el destino para túneles inbound.\nU UDP (User Datagram Protocol) Un protocolo de comunicación sin conexión utilizado como base para el transporte SSU.\nV Verifier Código criptográfico utilizado para verificar firmas digitales.\nW Whitelist Una lista de entidades permitidas (como destinos o routers) que tienen permiso para acceder a un recurso o servicio.\nX XOR Una operación lógica (OR exclusivo) utilizada extensivamente en criptografía y operaciones de hash.\nZ Zero-day Una vulnerabilidad de seguridad previamente desconocida que puede ser explotada por atacantes antes de que exista un parche.\nEste glosario se actualiza continuamente. Si encuentras términos que faltan o necesitan aclaración, por favor contribuye al proyecto de documentación de I2P.\nPostman / Mail.i2p + SusiMail What it is Mail.i2p es un proveedor de correo electrónico alojado dentro de I2P, administrado por \u0026ldquo;Postman\u0026rdquo; SusiMail es el cliente de correo web integrado en la consola del router I2P. Está diseñado para evitar la filtración de metadatos (por ejemplo, hostname) a servidores SMTP externos. A través de esta configuración, los usuarios de I2P pueden enviar/recibir mensajes tanto dentro de I2P como hacia/desde la clearnet (por ejemplo, Gmail) mediante el puente de Postman. How Addressing Works El correo electrónico de I2P utiliza un sistema de direcciones duales:\nDentro de la red I2P: username@mail.i2p (ej., idk@mail.i2p) Desde clearnet: username@i2pmail.org (ej., idk@i2pmail.org) El gateway i2pmail.org permite a usuarios regulares de internet enviar correos electrónicos a direcciones I2P, y a usuarios de I2P enviar a direcciones de clearnet. Los correos electrónicos de internet se enrutan a través del gateway antes de ser reenviados a través de I2P a tu bandeja de entrada de SusiMail.\nCuota de envío a Clearnet: 20 correos electrónicos por día al enviar a direcciones de internet regulares.\nQué es Para registrarse para una cuenta de mail.i2p:\nAsegúrate de que tu router I2P esté en funcionamiento Visita http://hq.postman.i2p dentro de I2P Sigue el proceso de registro Accede a tu correo electrónico a través de SusiMail en la consola del router Nota: hq.postman.i2p es una dirección de red I2P (eepsite) y solo se puede acceder mientras esté conectado a I2P. Para más información sobre la configuración, seguridad y uso del correo electrónico, visite Postman HQ.\nCómo Funciona el Direccionamiento Eliminación automática de encabezados identificativos (User-Agent:, X-Mailer:) para mayor privacidad Sanitización de metadatos para prevenir filtraciones hacia servidores SMTP externos Cifrado de extremo a extremo para correos internos I2P-a-I2P Primeros Pasos Interoperabilidad con correo electrónico \u0026ldquo;normal\u0026rdquo; (SMTP/POP) a través del puente Postman Experiencia de usuario sencilla (webmail integrado en la consola del router) Integrado con la distribución principal de I2P (SusiMail se incluye con Java I2P) Eliminación de encabezados para protección de la privacidad Características de Privacidad El puente hacia correo electrónico externo requiere confianza en la infraestructura de Postman El puente hacia clearnet reduce la privacidad en comparación con la comunicación puramente interna de I2P Depende de la disponibilidad y seguridad del servidor de correo Postman Technical Details Servicio SMTP: localhost:7659 (proporcionado por Postman) Servicio POP3: localhost:7660 Acceso al Webmail: Integrado en la consola del router en http://127.0.0.1:7657/susimail/\nImportante: SusiMail es solo para leer y enviar correo electrónico. La creación y gestión de cuentas debe realizarse en hq.postman.i2p.\nBest Practices Cambia tu contraseña después de registrar tu cuenta mail.i2p Usa correo electrónico I2P-a-I2P siempre que sea posible para máxima privacidad (sin puente a clearnet) Ten en cuenta el límite de 20/día al enviar a direcciones clearnet Comprende las compensaciones: El puente a clearnet proporciona conveniencia pero reduce el anonimato comparado con comunicaciones puramente internas de I2P Mantén I2P actualizado para beneficiarte de las mejoras de seguridad en SusiMail Guía de configuración de límites de ancho de banda de I2P Introducción I2P permite controlar cuánto ancho de banda utiliza tu router. Configurar estos límites correctamente es crucial para el rendimiento de la red y tu experiencia de usuario.\nConfiguración básica Límites de ancho de banda compartido Por defecto, I2P comparte un porcentaje de tu ancho de banda disponible con otros usuarios de la red. Puedes ajustar estos valores en:\nConfiguración \u0026gt; Ancho de banda\nOpciones principales:\nAncho de banda entrante: Controla cuántos datos puede recibir tu router Ancho de banda saliente: Controla cuántos datos puede enviar tu router Recomendaciones Para un rendimiento óptimo:\nConfigura al menos 128 KBps para tráfico compartido Reserva ancho de banda adicional para tu uso personal No limites excesivamente - esto afecta la salud de la red Configuración avanzada Límites de participación Puedes configurar cuánto de tu ancho de banda se dedica a túneles de tránsito (participación en la red):\nrouter.sharePercentage=80 Este valor representa el porcentaje de tu ancho de banda total disponible para la red.\nBurst bandwidth I2P soporta ráfagas temporales de ancho de banda por encima de los límites configurados. Esto mejora el rendimiento durante picos de actividad.\nConsideraciones importantes Conexiones de alta velocidad: Si tienes \u0026gt; 10 Mbps, considera aumentar tus límites Conexiones lentas: Con \u0026lt; 1 Mbps, reduce la participación pero mantén el router activo Rendimiento: Límites más altos = mejor rendimiento personal + red más saludable Privacidad: Incluso con límites bajos, tu privacidad está protegida Monitoreo Revisa la página de estado del router para verificar:\nUso actual de ancho de banda Número de túneles de tránsito Mensajes de participación de la red Conclusión La configuración apropiada de límites de ancho de banda equilibra tu experiencia personal con la contribución a la salud general de la red I2P.\n","description":"Una descripción general de los sistemas de correo electrónico dentro de la red I2P — historia, opciones y estado actual","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"I2P Mail (Correo Electrónico Anónimo sobre I2P)","url":"/es/docs/applications/i2p-mail/"},{"categories":null,"content":"Descripción general Existen hoy en día varias redes importantes de privacidad y anonimato, cada una con diferentes objetivos de diseño y modelos de amenazas. Aunque Tor, Lokinet, GNUnet y Freenet aportan enfoques valiosos para la comunicación que preserva la privacidad, I2P se destaca como la única red de conmutación de paquetes lista para producción y completamente optimizada para servicios ocultos dentro de la red y aplicaciones peer-to-peer.\nLa siguiente tabla resume las principales diferencias arquitectónicas y operativas entre estas redes a partir de 2025.\nComparación de Redes de Privacidad (2025) Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) --- Por qué I2P lidera en diseño orientado a la privacidad 1. Packet Switching \u0026gt; Circuit Switching El modelo de circuitos conmutados de Tor vincula el tráfico a rutas fijas de tres saltos—eficiente para navegación, pero frágil para servicios internos de larga duración. Los túneles de conmutación de paquetes de I2P envían mensajes a través de múltiples rutas concurrentes, enrutando automáticamente alrededor de congestión o fallas para mejor tiempo de actividad y distribución de carga.\n2. Unidirectional Tunnels I2P separa el tráfico entrante y saliente. Esto significa que cada participante solo ve la mitad de un flujo de comunicación, lo que dificulta significativamente los ataques de correlación temporal. Tor, Lokinet y otros utilizan circuitos bidireccionales donde las solicitudes y respuestas comparten el mismo camino—más simple, pero más rastreable.\n3. Fully Distributed netDB Las nueve autoridades de directorio de Tor definen su topología de red. I2P utiliza una DHT Kademlia autoorganizada mantenida por routers floodfill rotativos, eliminando cualquier punto de control central o servidores de coordinación.\n1. Conmutación de Paquetes \u0026gt; Conmutación de Circuitos I2P extiende el enrutamiento cebolla con garlic routing, agrupando múltiples mensajes cifrados en un solo contenedor. Esto reduce la filtración de metadatos y la sobrecarga de ancho de banda mientras mejora la eficiencia para mensajes de confirmación, datos y control.\n2. Túneles Unidireccionales Cada router I2P enruta para otros. No hay operadores de relay dedicados ni nodos privilegiados: el ancho de banda y la confiabilidad determinan automáticamente cuánto enrutamiento contribuye un nodo. Este enfoque democrático construye resiliencia y escala naturalmente a medida que la red crece.\n3. netDB completamente distribuida El viaje de ida y vuelta de 12 saltos de I2P (6 entrantes + 6 salientes) crea una desvinculación más fuerte que los circuitos de servicios ocultos de 6 saltos de Tor. Debido a que ambas partes son internas, las conexiones evitan completamente el cuello de botella de salida, proporcionando alojamiento interno más rápido e integración nativa de aplicaciones (I2PSnark, I2PTunnel, I2PBote).\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication --- When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet --- Summary La arquitectura de I2P es única en su enfoque de privacidad primero—sin servidores de directorio, sin dependencias de blockchain, sin confianza centralizada. Su combinación de tunnels unidireccionales, enrutamiento de conmutación de paquetes, empaquetado de mensajes garlic y descubrimiento distribuido de peers lo convierte en el sistema técnicamente más avanzado para alojamiento anónimo y comunicación peer-to-peer en la actualidad.\nI2P no es \u0026ldquo;una alternativa a Tor\u0026rdquo;. Es una clase diferente de red—construida para lo que sucede dentro de la red de privacidad, no fuera de ella.\n","description":"Una comparación técnica y filosófica moderna que destaca las ventajas únicas del diseño de I2P","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P vs Otras Redes de Privacidad","url":"/es/docs/overview/comparison/"},{"categories":null,"content":"Introducción I2P es una capa de red anónima escalable, auto-organizada y resiliente de conmutación de paquetes, sobre la cual puede operar cualquier número de aplicaciones diferentes conscientes del anonimato o la seguridad. Cada una de estas aplicaciones puede realizar sus propias compensaciones entre anonimato, latencia y rendimiento sin preocuparse por la implementación adecuada de un mixnet de ruta libre, permitiéndoles mezclar su actividad con el conjunto de anonimato más amplio de usuarios que ya se ejecutan sobre I2P.\nLas aplicaciones ya disponibles proporcionan la gama completa de actividades típicas de Internet — navegación web anónima, alojamiento web, chat, compartición de archivos, correo electrónico, blogs y sindicación de contenidos, así como varias otras aplicaciones en desarrollo.\nNavegación web: usando cualquier navegador existente que soporte un proxy Chat: IRC y otros protocolos Compartir archivos: I2PSnark y otras aplicaciones Correo electrónico: Susimail y otras aplicaciones Blog: usando cualquier servidor web local, o plugins disponibles A diferencia de los sitios web alojados en redes de distribución de contenido como Freenet o GNUnet , los servicios alojados en I2P son completamente interactivos: hay motores de búsqueda tradicionales estilo web, tableros de anuncios, blogs en los que puedes comentar, sitios basados en bases de datos y puentes para consultar sistemas estáticos como Freenet sin necesidad de instalarlos localmente.\nCon todas estas aplicaciones habilitadas para el anonimato, I2P actúa como middleware orientado a mensajes — las aplicaciones especifican los datos a enviar a un identificador criptográfico (un \u0026ldquo;destination\u0026rdquo;), e I2P asegura que lleguen de forma segura y anónima. I2P también incluye una simple biblioteca de streaming para permitir que los mensajes anónimos de mejor esfuerzo de I2P se transfieran como flujos confiables y ordenados, ofreciendo control de congestión basado en TCP ajustado para el alto producto ancho de banda-retardo de la red.\nAunque se han desarrollado proxies SOCKS simples para conectar aplicaciones existentes, su valor es limitado ya que la mayoría de las aplicaciones filtran información sensible en un contexto anónimo. El enfoque más seguro es auditar y adaptar la aplicación para usar las APIs de I2P directamente.\nI2P no es un proyecto de investigación —académico, comercial o gubernamental— sino un esfuerzo de ingeniería orientado a proporcionar anonimato utilizable. Ha estado en desarrollo continuo desde principios de 2003 por un grupo distribuido de colaboradores en todo el mundo. Todo el trabajo de I2P es código abierto en el sitio web oficial , principalmente liberado al dominio público, con algunos componentes bajo licencias permisivas de estilo BSD. Varias aplicaciones cliente con licencia GPL están disponibles, como I2PTunnel , Susimail e I2PSnark . La financiación proviene únicamente de donaciones de usuarios.\nOperación Overview I2P distingue claramente entre routers (nodos que participan en la red) y destinos (endpoints anónimos para aplicaciones). Ejecutar I2P en sí no es secreto; lo que está oculto es qué está haciendo el usuario y qué router utilizan sus destinos. Los usuarios finales típicamente ejecutan varios destinos (por ejemplo, uno para navegación web, otro para alojamiento, otro para IRC).\nUn concepto clave en I2P es el tunnel — una ruta encriptada unidireccional a través de una serie de routers. Cada router solo desencripta una capa y solo conoce el siguiente salto. Los tunnels expiran cada 10 minutos y deben reconstruirse.\nFigura 1: Existen dos tipos de túneles — entrantes y salientes.\nTúneles de salida envían mensajes desde el creador. Túneles de entrada traen mensajes de vuelta al creador. Combinar estos permite la comunicación bidireccional. Por ejemplo, \u0026ldquo;Alice\u0026rdquo; utiliza un tunnel saliente para enviar al tunnel entrante de \u0026ldquo;Bob\u0026rdquo;. Alice cifra su mensaje con instrucciones de enrutamiento hacia el gateway entrante de Bob.\nOtro concepto clave es la base de datos de red o netDb, que distribuye metadatos sobre routers y destinos:\nRouterInfo: Contiene información de contacto del router y material de claves. LeaseSet: Contiene información necesaria para contactar un destino (gateways de túneles, tiempos de expiración, claves de cifrado). Los routers publican su RouterInfo directamente en la netDb; los LeaseSets se envían a través de túneles de salida para mantener el anonimato.\nPara construir túneles, Alice consulta la netDb en busca de entradas RouterInfo para elegir pares, y envía mensajes de construcción de túnel cifrados salto por salto hasta que el túnel esté completo.\nFigura 2: La información del router se utiliza para construir túneles.\nPara enviar a Bob, Alice busca el LeaseSet de Bob y utiliza uno de sus túneles de salida para enrutar los datos a través de la puerta de enlace del túnel de entrada de Bob.\nFigura 3: Los LeaseSets conectan túneles de salida y entrada.\nDebido a que I2P está basado en mensajes, añade cifrado de ajo de extremo a extremo (end-to-end garlic encryption) para proteger los mensajes incluso del punto de salida o puerta de entrada. Un mensaje garlic envuelve múltiples \u0026ldquo;cloves\u0026rdquo; (mensajes) cifrados para ocultar metadatos y mejorar el anonimato.\nLas aplicaciones pueden usar la interfaz de mensajes directamente o depender de la biblioteca de streaming para conexiones confiables.\nTunnels Tanto los túneles entrantes como salientes utilizan cifrado por capas, pero difieren en su construcción:\nEn túneles de entrada, el creador (el endpoint) descifra todas las capas. En túneles de salida, el creador (el gateway) pre-descifra las capas para asegurar claridad en el endpoint. I2P perfila a los peers mediante métricas indirectas como latencia y confiabilidad sin sondeo directo. Basándose en estos perfiles, los peers se agrupan dinámicamente en cuatro niveles:\nRápido y alta capacidad Alta capacidad Sin fallos Fallando La selección de pares de túnel típicamente prefiere pares de alta capacidad, elegidos aleatoriamente para equilibrar anonimato y rendimiento, con estrategias adicionales de ordenamiento basadas en XOR para mitigar ataques de predecesor y recolección de netDb.\nPara más detalles, consulta la Especificación de Túneles .\nDescripción general Los routers que participan en la tabla hash distribuida (DHT) floodfill almacenan y responden a las consultas de LeaseSet. La DHT utiliza una variante de Kademlia . Los routers floodfill se seleccionan automáticamente si tienen suficiente capacidad y estabilidad, o pueden configurarse manualmente.\nRouterInfo: Describe las capacidades y transportes de un router. LeaseSet: Describe los túneles y claves de cifrado de un destino. Todos los datos en la netDb están firmados por el publicador y tienen una marca de tiempo para prevenir ataques de repetición o de entradas obsoletas. La sincronización temporal se mantiene mediante SNTP y detección de desfase en la capa de transporte.\nAdditional concepts LeaseSets no publicados y cifrados:\nUn destino puede permanecer privado al no publicar su LeaseSet, compartiéndolo solo con pares de confianza. El acceso requiere la clave de descifrado apropiada.\nBootstrapping (reseeding):\nPara unirse a la red, un nuevo router obtiene archivos RouterInfo firmados desde servidores HTTPS de reseed de confianza.\nEscalabilidad de búsqueda:\nI2P utiliza búsquedas iterativas, no recursivas, para mejorar la escalabilidad y seguridad del DHT.\nTúneles La comunicación moderna de I2P utiliza dos transportes completamente cifrados:\nNTCP2 : Protocolo cifrado basado en TCP SSU2 : Protocolo cifrado basado en UDP Ambos están construidos sobre el moderno Noise Protocol Framework , proporcionando autenticación fuerte y resistencia a la huella digital de tráfico. Reemplazaron los protocolos heredados NTCP y SSU (completamente retirados desde 2023).\nNTCP2 ofrece transmisión cifrada y eficiente sobre TCP.\nSSU2 proporciona confiabilidad basada en UDP, atravesamiento de NAT y perforación de agujeros opcional. SSU2 es conceptualmente similar a WireGuard o QUIC, equilibrando confiabilidad y anonimato.\nLos routers pueden soportar tanto IPv4 como IPv6, publicando sus direcciones de transporte y costos en la netDb. El transporte de una conexión se selecciona dinámicamente mediante un sistema de ofertas que optimiza según las condiciones y los enlaces existentes.\nBase de Datos de Red (netDb) I2P utiliza criptografía en capas para todos los componentes: transportes, tunnels, mensajes garlic y la base de datos de red (netDb).\nLas primitivas actuales incluyen:\nX25519 para intercambio de claves EdDSA (Ed25519) para firmas ChaCha20-Poly1305 para cifrado autenticado SHA-256 para hashing AES256 para cifrado de capa de tunnel Los algoritmos heredados (ElGamal, DSA-SHA1, ECDSA) se mantienen por compatibilidad con versiones anteriores.\nI2P está introduciendo actualmente esquemas criptográficos híbridos post-cuánticos (PQ) que combinan X25519 con ML-KEM para resistir ataques de \u0026ldquo;recolectar ahora, descifrar después\u0026rdquo;.\nGarlic Messages Los mensajes garlic extienden el enrutamiento onion agrupando múltiples \u0026ldquo;cloves\u0026rdquo; (dientes) encriptados con instrucciones de entrega independientes. Estos permiten flexibilidad de enrutamiento a nivel de mensaje y relleno de tráfico uniforme.\nSession Tags Se admiten dos sistemas criptográficos para el cifrado de extremo a extremo:\nElGamal/AES+SessionTags (legacy):\nUtiliza etiquetas de sesión pre-entregadas como nonces de 32 bytes. Ahora obsoleto debido a su ineficiencia.\nECIES-X25519-AEAD-Ratchet (actual):\nUtiliza ChaCha20-Poly1305 y PRNGs basados en HKDF sincronizados para generar claves de sesión efímeras y etiquetas de 8 bytes de forma dinámica, reduciendo la sobrecarga de CPU, memoria y ancho de banda mientras mantiene el secreto hacia adelante (forward secrecy).\nFuture of the Protocol Las áreas de investigación clave se centran en mantener la seguridad contra adversarios a nivel estatal e introducir protecciones post-cuánticas. Dos conceptos de diseño tempranos — rutas restringidas y latencia variable — han sido superados por desarrollos modernos.\nRestricted Route Operation Los conceptos originales de enrutamiento restringido tenían como objetivo ocultar las direcciones IP. Esta necesidad ha sido en gran medida mitigada por:\nUPnP para reenvío automático de puertos Traversal robusto de NAT en SSU2 Soporte para IPv6 Introducers cooperativos y perforación de NAT (NAT hole-punching) Conectividad opcional de overlay (p. ej., Yggdrasil) Por lo tanto, el I2P moderno logra los mismos objetivos de manera más práctica sin el enrutamiento restringido complejo.\nSimilar Systems I2P integra conceptos de middleware orientado a mensajes, DHTs (tablas hash distribuidas) y mixnets (redes de mezcla). Su innovación radica en combinar estos elementos en una plataforma de anonimato auto-organizada y utilizable.\nProtocolos de Transporte Sitio web Tor e I2P comparten objetivos pero difieren arquitectónicamente:\nTor: Conmutación de circuitos; depende de autoridades de directorio confiables. (~10k relays) I2P: Conmutación de paquetes; red completamente distribuida impulsada por DHT. (~50k routers) Los túneles unidireccionales de I2P exponen menos metadatos y permiten rutas de enrutamiento flexibles, mientras que Tor se enfoca en el acceso anónimo a Internet (outproxying). I2P en cambio soporta alojamiento anónimo dentro de la red.\nCriptografía Sitio web Freenet se enfoca en la publicación y recuperación anónima y persistente de archivos. I2P, en contraste, proporciona una capa de comunicaciones en tiempo real para uso interactivo (web, chat, torrents). Juntos, los dos sistemas se complementan entre sí: Freenet proporciona almacenamiento resistente a la censura; I2P proporciona anonimato en el transporte.\nOther Networks Lokinet: Superposición basada en IP que utiliza nodos de servicio incentivados. Nym: Mixnet de próxima generación que enfatiza la protección de metadatos con tráfico de cobertura a mayor latencia. Appendix A: Application Layer I2P en sí solo maneja el transporte de mensajes. La funcionalidad de la capa de aplicación se implementa externamente a través de APIs y bibliotecas.\nStreaming Library La biblioteca de streaming funciona como el análogo TCP de I2P, con un protocolo de ventana deslizante y control de congestión ajustado para transporte anónimo de alta latencia.\nLos patrones típicos de solicitud/respuesta HTTP a menudo pueden completarse en un solo viaje de ida y vuelta debido a las optimizaciones de agrupación de mensajes.\nNaming Library and Address Book Desarrollado por: mihi, Ragnarok Consulta la página Nomenclatura y Libreta de Direcciones .\nEl sistema de nombres de I2P es local y descentralizado, evitando nombres globales al estilo DNS. Cada router mantiene un mapeo local de nombres legibles por humanos a destinos. Opcionalmente, se pueden compartir o importar libretas de direcciones basadas en web-of-trust desde pares de confianza.\nEste enfoque evita las autoridades centralizadas y elude las vulnerabilidades Sybil inherentes a los sistemas de nomenclatura globales o basados en votación.\nOperación de Ruta Restringida Desarrollado por: mihi\nI2PTunnel es la interfaz principal de la capa de cliente que permite el proxy TCP anónimo. Admite:\nTúneles de cliente (salida hacia destinos I2P) Cliente HTTP (eepproxy) para dominios \u0026ldquo;.i2p\u0026rdquo; Túneles de servidor (entrada desde I2P hacia un servicio local) Túneles de servidor HTTP (proxy seguro de servicios web) El outproxying (hacia Internet regular) es opcional, implementado por túneles \u0026ldquo;servidor\u0026rdquo; administrados por voluntarios.\nI2PSnark Desarrollado por: jrandom, et al — portado desde Snark Incluido con I2P, I2PSnark es un cliente BitTorrent anónimo multi-torrent con soporte DHT y UDP, accesible a través de una interfaz web.\nTor Desarrollado por: postman, susi23, mastiejaner\nI2Pmail proporciona correo electrónico anónimo a través de conexiones I2PTunnel. Susimail es un cliente basado en web diseñado específicamente para prevenir filtraciones de información comunes en los clientes de correo electrónico tradicionales. El servicio mail.i2p cuenta con filtrado de virus, cuotas de hashcash y separación de outproxy para protección adicional.\n","description":"Introducción técnica a la arquitectura y operación de I2P","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P: Un framework escalable para comunicación anónima","url":"/es/docs/overview/tech-intro/"},{"categories":null,"content":"Documentación de la API I2PControl I2PControl es una API JSON-RPC 2.0 incluida con el router I2P (desde la versión 0.9.39). Permite el monitoreo y control autenticado del router mediante solicitudes JSON estructuradas.\nContraseña predeterminada: itoopie — esta es la contraseña de fábrica y debe cambiarse inmediatamente por seguridad.\n1. Descripción general y acceso Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior En el caso de I2P en Java, debes ir a **Consola del Router → WebApps → I2PControl** y habilitarlo (configurarlo para que inicie automáticamente). Una vez activo, todos los métodos requieren que primero te autentiques y recibas un token de sesión. 2. Formato JSON-RPC Todas las solicitudes siguen la estructura JSON-RPC 2.0:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } Una respuesta exitosa incluye un campo result; en caso de fallo, se devuelve un objeto error:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } o\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. Flujo de Autenticación Solicitud (Autenticar) curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Respuesta Exitosa { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } Debes incluir ese Token en todas las solicitudes posteriores en los params.\n4. Métodos y Endpoints 4.1 RouterInfo Obtiene telemetría clave sobre el router.\nEjemplo de Solicitud\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Campos de Respuesta (result) Según la documentación oficial (GetI2P): - i2p.router.status (String) — un estado legible para humanos - i2p.router.uptime (long) — milisegundos (o cadena para i2pd más antiguos) :contentReference[oaicite:0]{index=0} - i2p.router.version (String) — cadena de versión :contentReference[oaicite:1]{index=1} - i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — ancho de banda entrante en B/s :contentReference[oaicite:2]{index=2} - i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — ancho de banda saliente en B/s :contentReference[oaicite:3]{index=3} - i2p.router.net.status (long) — código de estado numérico (ver enumeración a continuación) :contentReference[oaicite:4]{index=4} - i2p.router.net.tunnels.participating (long) — número de tunnels participantes :contentReference[oaicite:5]{index=5} - i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — estadísticas de peers del netDb :contentReference[oaicite:6]{index=6} - i2p.router.netdb.isreseeding (boolean) — si el reseed está activo :contentReference[oaicite:7]{index=7} - i2p.router.netdb.knownpeers (long) — total de peers conocidos :contentReference[oaicite:8]{index=8}\nEnumeración de Código de Estado (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET --- 4.2 GetRate Se utiliza para obtener métricas de tasa (por ejemplo, ancho de banda, éxito de túneles) durante una ventana de tiempo determinada.\nEjemplo de Solicitud\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Respuesta de Ejemplo\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 RouterManager Realizar acciones administrativas.\nParámetros / métodos permitidos - Restart, RestartGraceful - Shutdown, ShutdownGraceful - Reseed, FindUpdates, Update :contentReference[oaicite:10]{index=10}\nEjemplo de Solicitud\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Respuesta Exitosa\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 NetworkSetting Obtener o establecer parámetros de configuración de red (puertos, upnp, ancho de banda compartido, etc.)\nEjemplo de Solicitud (obtener valores actuales)\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Respuesta de Ejemplo\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } Nota: las versiones de i2pd anteriores a 2.41 pueden devolver tipos numéricos en lugar de cadenas — los clientes deben manejar ambos. :contentReference[oaicite:11]{index=11}\n4.5 Configuración Avanzada Permite manipular parámetros internos del router.\nEjemplo de Solicitud\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Ejemplo de Respuesta\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. Códigos de Error Además de los errores estándar de JSON-RPC (-32700, -32600, etc.), I2PControl define:\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported --- 6. Uso y Mejores Prácticas Incluye siempre el parámetro Token (excepto al autenticarse). Cambia la contraseña predeterminada (itoopie) en el primer uso. Para Java I2P, asegúrate de que la aplicación web I2PControl esté habilitada a través de WebApps. Prepárate para ligeras variaciones: algunos campos pueden ser números o cadenas, dependiendo de la versión de I2P. Ajusta las cadenas de estado largas para una salida legible en pantalla. ","description":"API de gestión remota del router a través de la aplicación web I2PControl","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/es/docs/api/i2pcontrol/"},{"categories":null,"content":"Resumen I2PTunnel es un componente central de I2P para interactuar con la red I2P y proporcionar servicios en ella. Permite que aplicaciones basadas en TCP y de transmisión de medios operen de forma anónima mediante abstracción de túneles. El destino de un túnel puede definirse por un nombre de host , Base32 , o una clave de destino completa.\nCada tunnel establecido escucha localmente (por ejemplo, localhost:port) y se conecta internamente a destinos I2P. Para alojar un servicio, crea un tunnel que apunte a la IP y puerto deseados. Se genera una clave de destino I2P correspondiente, lo que permite que el servicio sea accesible globalmente dentro de la red I2P. La interfaz web de I2PTunnel está disponible en I2P Router Tunnel Manager .\nServicios Predeterminados Túnel de servidor I2P Webserver – Un tunnel a un servidor web Jetty en localhost:7658 para alojar fácilmente en I2P. Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot Túneles de cliente I2P HTTP Proxy – localhost:4444 – Utilizado para navegar por I2P e Internet a través de outproxies. I2P HTTPS Proxy – localhost:4445 – Variante segura del HTTP proxy. Irc2P – localhost:6668 – Túnel predeterminado de red IRC anónima. Git SSH (gitssh.idk.i2p) – localhost:7670 – Túnel cliente para acceso SSH a repositorios. Postman SMTP – localhost:7659 – Túnel cliente para correo saliente. Postman POP3 – localhost:7660 – Túnel cliente para correo entrante. Nota: Solo el servidor web I2P es un túnel de servidor predeterminado; todos los demás son túneles de cliente que se conectan a servicios I2P externos.\nConfiguración La especificación de configuración de I2PTunnel está documentada en /spec/configuration .\nModos de Cliente Estándar Abre un puerto TCP local que se conecta a un servicio en un destino I2P. Admite múltiples entradas de destino separadas por comas para redundancia.\nHTTP Un túnel proxy para solicitudes HTTP/HTTPS. Soporta outproxies locales y remotos, eliminación de encabezados, almacenamiento en caché, autenticación y compresión transparente.\nProtecciones de privacidad: - Elimina encabezados: Accept-*, Referer, Via, From - Reemplaza encabezados de host con destinos Base32 - Aplica eliminación hop-by-hop conforme a RFC - Añade soporte para descompresión transparente - Proporciona páginas de error internas y respuestas localizadas\nComportamiento de compresión: - Las solicitudes pueden usar el encabezado personalizado X-Accept-Encoding: x-i2p-gzip - Las respuestas con Content-Encoding: x-i2p-gzip se descomprimen de forma transparente - La compresión se evalúa según el tipo MIME y la longitud de la respuesta para mayor eficiencia\nPersistencia (nuevo desde 2.5.0): HTTP Keepalive y las conexiones persistentes ahora son compatibles con servicios alojados en I2P a través del Administrador de Servicios Ocultos. Esto reduce la latencia y la sobrecarga de conexión, pero aún no habilita sockets persistentes totalmente compatibles con RFC 2616 en todos los saltos.\nPipelining: Sigue sin estar soportado y es innecesario; los navegadores modernos lo han dejado obsoleto.\nComportamiento del User-Agent: - Outproxy: Utiliza un User-Agent actual de Firefox ESR. - Interno: MYOB/6.66 (AN/ON) para consistencia de anonimato.\nCliente IRC Se conecta a servidores IRC basados en I2P. Permite un subconjunto seguro de comandos mientras filtra identificadores para proteger la privacidad.\nSOCKS 4/4a/5 Proporciona capacidad de proxy SOCKS para conexiones TCP. UDP permanece sin implementar en Java I2P (solo en i2pd).\nCONNECT Implementa túneles HTTP CONNECT para conexiones SSL/TLS.\nStreamr Habilita la transmisión de estilo UDP a través de encapsulación basada en TCP. Soporta transmisión de medios cuando se combina con un túnel de servidor Streamr correspondiente.\nModos de Servidor Servidor Estándar Crea un destino TCP mapeado a una IP:puerto local.\nServidor HTTP Crea un destino que interactúa con un servidor web local. Soporta compresión (x-i2p-gzip), eliminación de encabezados y protecciones contra DDoS. Ahora se beneficia del soporte de conexiones persistentes (v2.5.0+) y optimización de pool de hilos (v2.7.0–2.9.0).\nHTTP Bidireccional Obsoleto – Sigue siendo funcional pero desaconsejado. Actúa como servidor y cliente HTTP sin outproxying (proxy de salida). Se utiliza principalmente para pruebas de diagnóstico de loopback.\nServidor IRC Crea un destino filtrado para servicios IRC, pasando las claves de destino del cliente como nombres de host.\nServidor Streamr Se acopla con un túnel cliente Streamr para manejar flujos de datos estilo UDP sobre I2P.\nNuevas Funcionalidades (2.4.0–2.10.0) Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. --- Características de Seguridad Eliminación de encabezados para anonimato (Accept, Referer, From, Via) Aleatorización de User-Agent según in/outproxy Limitación de tasa de POST y protección contra Slowloris Limitación de conexiones en subsistemas de streaming Manejo de congestión de red en la capa de tunnel Aislamiento de NetDB previniendo filtraciones entre aplicaciones Detalles Técnicos Tamaño de clave de destino predeterminado: 516 bytes (puede exceder para certificados LS2 extendidos) Direcciones Base32: {52–56+ chars}.b32.i2p Los túneles de servidor permanecen compatibles tanto con Java I2P como con i2pd Característica obsoleta: solo httpbidirserver; sin eliminaciones desde 0.9.59 Verificados los puertos predeterminados correctos y directorios raíz de documentos para todas las plataformas Resumen I2PTunnel sigue siendo la columna vertebral de la integración de aplicaciones con I2P. Entre las versiones 0.9.59 y 2.10.0, obtuvo soporte para conexiones persistentes, cifrado post-cuántico y mejoras importantes en el manejo de hilos. La mayoría de las configuraciones permanecen compatibles, pero los desarrolladores deben verificar sus configuraciones para garantizar el cumplimiento con los valores predeterminados modernos de transporte y seguridad.\n","description":"Herramienta para interactuar con I2P y proporcionar servicios en la red","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/es/docs/api/i2ptunnel/"},{"categories":null,"content":" Estado de legado: Este contenido se conserva únicamente como referencia histórica. Documenta el sistema de tunnel que se distribuía antes de I2P 0.6.1.10 y no debe usarse para el desarrollo moderno. Consulte la implementación actual para obtener orientación de producción.\nEl subsistema de tunnel original también usaba tunnels unidireccionales, pero difería en el formato de los mensajes, la detección de duplicados y la estrategia de construcción. Muchas secciones a continuación replican la estructura del documento obsoleto para facilitar la comparación.\n1. Descripción general del Tunnel Los Tunnels se construían como secuencias ordenadas de pares seleccionados por el creador. Las longitudes de los Tunnels variaban de 0–7 saltos, con varios ajustes para relleno, limitación y generación de chaff (tráfico señuelo). Los Tunnels de entrada entregaban mensajes desde una puerta de enlace no confiable al creador (punto final); los Tunnels de salida enviaban los datos alejándolos del creador. La vida útil de los Tunnels era de 10 minutos, tras lo cual se construían nuevos Tunnels (a menudo usando los mismos pares pero con diferentes ID de Tunnel). 2. Funcionamiento en el diseño heredado 2.1 Preprocesamiento de mensajes Las puertas de enlace acumularon ≤32 KB de carga útil de I2NP, seleccionaron el relleno y produjeron una carga útil que contenía:\nUn campo de longitud de relleno de dos bytes y esa misma cantidad de bytes aleatorios Una secuencia de pares {instructions, I2NP message} que describen los destinos de entrega, la fragmentación y los retrasos opcionales Mensajes I2NP completos rellenados hasta un múltiplo de 16 bytes Las instrucciones de entrega empaquetaban la información de enrutamiento en campos de bits (tipo de entrega, indicadores de retraso, indicadores de fragmentación y extensiones opcionales). Los mensajes fragmentados llevaban un ID de mensaje de 4 bytes más un indicador de índice/último fragmento.\n2.2 Cifrado en la puerta de enlace El diseño heredado fijaba la longitud del tunnel en ocho saltos para la fase de cifrado. Las puertas de enlace aplicaban capas de AES-256/CBC junto con bloques de suma de verificación, de modo que cada salto pudiera verificar la integridad sin reducir la carga útil. La propia suma de verificación era un bloque derivado de SHA-256 incrustado dentro del mensaje.\n2.3 Comportamiento de los participantes Los participantes seguían los identificadores de tunnel entrantes, verificaban la integridad de forma temprana y descartaban duplicados antes de reenviar. Como los bloques de relleno y verificación estaban integrados, el tamaño del mensaje se mantenía constante independientemente del número de saltos.\n2.4 Procesamiento del extremo Los extremos descifraron los bloques en capas secuencialmente, validaron las sumas de verificación y volvieron a dividir la carga útil en las instrucciones codificadas más los mensajes I2NP para su posterior entrega.\n3. Construcción de Tunnel (Proceso obsoleto) Selección de pares: Los pares se eligieron a partir de perfiles mantenidos localmente (exploratorio vs. cliente). El documento original ya destacaba la mitigación del ataque de predecesor reutilizando listas ordenadas de pares por cada grupo de tunnel. Entrega de solicitudes: Los mensajes de construcción se reenviaban salto a salto con secciones cifradas para cada par. Se debatieron ideas alternativas, como la extensión telescópica, el reencaminamiento a mitad del trayecto o eliminar bloques de suma de comprobación, como experimentos, pero nunca se adoptaron. Agrupación: Cada destino local mantenía grupos de entrada y de salida por separado. Los ajustes incluían la cantidad deseada, tunnels de respaldo, variación de longitud, limitación y políticas de relleno. 4. Conceptos de limitación y mezcla El documento antiguo propuso varias estrategias que influyeron en las versiones posteriores:\nDescarte aleatorio temprano ponderado (WRED) para el control de congestión Limitadores por tunnel basados en promedios móviles del uso reciente Controles opcionales de chaff (relleno de tráfico) y batching (agrupación por lotes) (no totalmente implementados) 5. Alternativas archivadas Secciones del documento original exploraron ideas que nunca se implementaron:\nEliminar bloques de suma de verificación para reducir el procesamiento por salto Aplicar telescoping (construcción escalonada) a tunnels a mitad del trayecto para cambiar la composición de pares Cambiar a tunnels bidireccionales (finalmente rechazado) Usar hashes más cortos o diferentes esquemas de relleno Estas ideas siguen siendo un valioso contexto histórico, pero no reflejan la base de código moderna.\nReferencias Archivo original de documentos heredados (pre-0.6.1.10) Descripción general de Tunnel para la terminología actual Perfilado y selección de pares para heurísticas modernas ","description":"Descripción archivada del diseño de tunnel usado antes de I2P 0.6.1.10.","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"Implementación antigua de tunnel (heredada)","url":"/es/docs/legacy/old-implementation/"},{"categories":null,"content":"Empaquetar I2P con tu aplicación es una forma poderosa de incorporar usuarios, pero solo si el router está configurado de manera responsable.\n1. Coordinar con los equipos de Router Contacta a los mantenedores de Java I2P e i2pd antes de empaquetarlos. Pueden revisar tus configuraciones predeterminadas y destacar problemas de compatibilidad. Elige la implementación de router que se ajuste a tu stack: Java/Scala → Java I2P C/C++ → i2pd Otros lenguajes → empaqueta un router e integra usando SAM v3 o I2CP Verifica los términos de redistribución para los binarios del router y dependencias (Java runtime, ICU, etc.). 2. Valores Predeterminados de Configuración Recomendados Aspira a \u0026ldquo;contribuir más de lo que consumes\u0026rdquo;. Los valores predeterminados modernos priorizan la salud y estabilidad de la red.\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. ### Los túneles de participación siguen siendo esenciales No deshabilite los túneles de participación.\nLos routers que no retransmiten tienen peor rendimiento. La red depende del intercambio voluntario de capacidad. El tráfico de cobertura (tráfico retransmitido) mejora el anonimato. Mínimos oficiales: - Ancho de banda compartido: ≥ 12 KB/s - Auto-inclusión floodfill: ≥ 128 KB/s - Recomendado: 2 túneles de entrada / 2 túneles de salida (predeterminado en Java I2P)\n3. Persistencia y Reseeding Los directorios de estado persistente (netDb/, perfiles, certificados) deben conservarse entre ejecuciones.\nSin persistencia, tus usuarios activarán reseeds en cada inicio, degradando el rendimiento y aumentando la carga en los servidores de reseed.\nSi la persistencia es imposible (por ejemplo, contenedores o instalaciones efímeras):\nIncluir 1,000–2,000 router infos en el instalador. Operar uno o más servidores de reseed personalizados para descargar los públicos. Variables de configuración: - Directorio base: i2p.dir.base - Directorio de configuración: i2p.dir.config - Incluye certificates/ para el reseeding.\n4. Seguridad y Exposición Mantén la consola del router (127.0.0.1:7657) solo para acceso local. Usa HTTPS si expones la interfaz externamente. Deshabilita SAM/I2CP externos a menos que sea necesario. Revisa los plugins incluidos—distribuye solo lo que tu aplicación soporte. Incluye siempre autenticación para el acceso remoto a la consola. Características de seguridad introducidas desde la versión 2.5.0: - Aislamiento de NetDB entre aplicaciones (2.4.0+) - Mitigación de DoS y listas de bloqueo de Tor (2.5.1) - Resistencia al sondeo NTCP2 (2.9.0) - Mejoras en la selección de routers floodfill (2.6.0+)\n5. APIs compatibles (2025) API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. Toda la documentación oficial se encuentra en `/docs/api/` — la antigua ruta `/spec/samv3/` **no** existe. 6. Redes y Puertos Puertos predeterminados típicos: - 4444 – Proxy HTTP - 4445 – Proxy HTTPS - 7654 – I2CP - 7656 – SAM Bridge - 7657 – Consola del Router - 7658 – Sitio I2P local - 6668 – Proxy IRC - 9000–31000 – Puerto de router aleatorio (UDP/TCP entrante)\nLos routers seleccionan un puerto de entrada aleatorio en la primera ejecución. El reenvío mejora el rendimiento, pero UPnP puede gestionar esto automáticamente.\n7. Cambios Modernos (2024–2025) Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). ## 8. Experiencia de Usuario y Pruebas Comunicar qué hace I2P y por qué se comparte el ancho de banda. Proporcionar diagnósticos del router (ancho de banda, tunnels, estado de reseed). Probar los paquetes en Windows, macOS y Linux (incluidos equipos con poca RAM). Verificar la interoperabilidad con peers de Java I2P e i2pd. Probar la recuperación tras caídas de red y cierres inesperados. 9. Recursos de la Comunidad Foro: i2pforum.net o http://i2pforum.i2p dentro de I2P. Código: i2pgit.org/I2P_Developers/i2p.i2p . IRC (red Irc2P): #i2p-dev, #i2pd. #i2papps no verificado; puede no existir. Aclara qué red (Irc2P vs ilita.i2p) aloja tu canal. Integrar de manera responsable significa equilibrar la experiencia del usuario, el rendimiento y la contribución a la red. Utiliza estos valores predeterminados, mantente sincronizado con los mantenedores del router y prueba bajo carga real antes del lanzamiento.\n","description":"Guía práctica actualizada para integrar un router I2P con tu aplicación de manera responsable","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"Incorporar I2P en tu aplicación","url":"/es/docs/applications/embedding/"},{"categories":null,"content":"El proyecto I2P mantiene paquetes oficiales para Debian, Ubuntu y sus distribuciones derivadas. Esta guía proporciona instrucciones completas para instalar I2P usando nuestros repositorios oficiales.\n🚀 Beta: Instalación Automática (Experimental) Para usuarios avanzados que desean una instalación automatizada rápida:\nEste comando de una línea detectará automáticamente tu distribución e instalará I2P. Úsalo con precaución - revisa el script de instalación antes de ejecutarlo.\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash Lo que esto hace: - Detecta tu distribución de Linux (Ubuntu/Debian) - Añade el repositorio de I2P apropiado - Instala las claves GPG y los paquetes necesarios - Instala I2P automáticamente\n⚠️ Esta es una función beta. Si prefieres la instalación manual o quieres entender cada paso, utiliza los métodos de instalación manual que se describen a continuación.\nPlataformas Compatibles Los paquetes de Debian son compatibles con:\nUbuntu 18.04 (Bionic) y posteriores Linux Mint 19 (Tara) y posteriores Debian Buster (10) y posteriores Knoppix Otras distribuciones basadas en Debian (LMDE, ParrotOS, Kali Linux, etc.) Arquitecturas soportadas: amd64, i386, armhf, arm64, powerpc, ppc64el, s390x\nLos paquetes de I2P pueden funcionar en otros sistemas basados en Debian que no estén listados explícitamente arriba. Si encuentras problemas, por favor repórtalos en nuestro GitLab .\nMétodos de Instalación Elige el método de instalación que coincida con tu distribución:\nOpción 1: Ubuntu y derivados (Linux Mint, elementary OS, Pop!_OS, etc.) Opción 2: Debian y distribuciones basadas en Debian (incluyendo LMDE, Kali, ParrotOS) Instalación en Ubuntu Ubuntu y sus derivadas oficiales (Linux Mint, elementary OS, Trisquel, etc.) pueden usar el PPA (Personal Package Archive) de I2P para una instalación fácil y actualizaciones automáticas.\nMethod 1: Command Line Installation (Recommended) Este es el método más rápido y confiable para instalar I2P en sistemas basados en Ubuntu.\nPaso 1: Añadir el PPA de I2P\nAbre una terminal y ejecuta:\nsudo apt-add-repository ppa:i2p-maintainers/i2p Este comando añade el PPA de I2P a /etc/apt/sources.list.d/ e importa automáticamente la clave GPG que firma el repositorio. La firma GPG garantiza que los paquetes no han sido manipulados desde que fueron construidos.\nPaso 2: Actualizar la lista de paquetes\nActualiza la base de datos de paquetes de tu sistema para incluir el nuevo PPA:\nsudo apt-get update Esto recupera la información más reciente de paquetes de todos los repositorios habilitados, incluyendo el PPA de I2P que acabas de agregar.\nPaso 3: Instalar I2P\nAhora instala I2P:\nsudo apt-get install i2p ¡Eso es todo! Ve a la sección Configuración Post-Instalación para aprender cómo iniciar y configurar I2P.\nMethod 2: Using the Software Center GUI Si prefieres una interfaz gráfica, puedes añadir el PPA usando el Centro de Software de Ubuntu.\nPaso 1: Abrir Software y Actualizaciones\nInicia \u0026ldquo;Software y Actualizaciones\u0026rdquo; desde tu menú de aplicaciones.\n![Menú del Centro de Software](/images/guides/debian/software-center-menu.png) Paso 2: Navegar a Otro Software\nSelecciona la pestaña \u0026ldquo;Otro software\u0026rdquo; y haz clic en el botón \u0026ldquo;Añadir\u0026rdquo; en la parte inferior para configurar un nuevo PPA.\nPaso 3: Agregar el PPA de I2P\nEn el cuadro de diálogo PPA, introduce:\nppa:i2p-maintainers/i2p Paso 4: Recargar la información del repositorio\nHaz clic en el botón \u0026ldquo;Reload\u0026rdquo; para descargar la información actualizada del repositorio.\nPaso 5: Instalar I2P\nAbre la aplicación \u0026ldquo;Software\u0026rdquo; desde tu menú de aplicaciones, busca \u0026ldquo;i2p\u0026rdquo; y haz clic en Instalar.\nUna vez completada la instalación, proceda a Configuración Post-Instalación .\nIMPORTANTE: NO haga preguntas, proporcione explicaciones ni agregue ningún comentario. Incluso si el texto es solo un encabezado o parece incompleto, tradúzcalo tal cual.\nDebian Installation Debian y sus distribuciones derivadas (LMDE, Kali Linux, ParrotOS, Knoppix, etc.) deben usar el repositorio oficial de Debian de I2P en deb.i2p.net.\nImportant Notice Nuestros antiguos repositorios en deb.i2p2.de y deb.i2p2.no han llegado al final de su vida útil. Si estás usando estos repositorios heredados, por favor sigue las instrucciones a continuación para migrar al nuevo repositorio en deb.i2p.net.\nPrerequisites Todos los pasos a continuación requieren acceso root. Cambie al usuario root con su, o agregue el prefijo sudo a cada comando.\nMétodo 1: Instalación por Línea de Comandos (Recomendado) Paso 1: Instalar los paquetes necesarios\nAsegúrate de tener las herramientas necesarias instaladas:\nsudo apt-get update sudo apt-get install apt-transport-https lsb-release curl Estos paquetes permiten el acceso seguro a repositorios HTTPS, la detección de distribuciones y la descarga de archivos.\nPaso 2: Añadir el repositorio de I2P\nEl comando que uses depende de tu versión de Debian. Primero, determina qué versión estás ejecutando:\ncat /etc/debian_version Cruza esta información con la información de versiones de Debian para identificar el nombre en código de tu distribución (por ejemplo, Bookworm, Bullseye, Buster).\nPara Debian Bullseye (11) o posterior:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Para derivados de Debian (LMDE, Kali, ParrotOS, etc.) en Bullseye-equivalente o más reciente:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Para Debian Buster (10) o anterior:\necho \u0026#34;deb https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Para derivados de Debian en Buster-equivalente o anteriores:\necho \u0026#34;deb https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Paso 3: Descargar la clave de firma del repositorio\ncurl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg Paso 4: Verificar la huella digital de la clave\nAntes de confiar en la clave, verifica que su huella digital coincida con la clave de firma oficial de I2P:\ngpg --keyid-format long --import --import-options show-only --with-fingerprint i2p-archive-keyring.gpg Verifica que la salida muestre esta huella digital:\n7840 E761 0F28 B904 7535 49D7 67EC E560 5BCF 1346 ⚠️ No continúes si la huella digital no coincide. Esto podría indicar una descarga comprometida.\nPaso 5: Instalar la clave del repositorio\nCopia el keyring verificado al directorio de keyrings del sistema:\nsudo cp i2p-archive-keyring.gpg /usr/share/keyrings Solo para Debian Buster o versiones anteriores, también necesitas crear un enlace simbólico:\nsudo ln -sf /usr/share/keyrings/i2p-archive-keyring.gpg /etc/apt/trusted.gpg.d/i2p-archive-keyring.gpg Paso 6: Actualizar listas de paquetes\nActualiza la base de datos de paquetes de tu sistema para incluir el repositorio de I2P:\nsudo apt-get update Paso 7: Instalar I2P\nInstala tanto el router de I2P como el paquete keyring (que asegura que recibirás futuras actualizaciones de claves):\nsudo apt-get install i2p i2p-keyring ¡Excelente! I2P ya está instalado. Continúa a la sección de Configuración Post-Instalación .\nPost-Installation Configuration Después de instalar I2P, necesitarás iniciar el router y realizar algunas configuraciones iniciales.\nMétodo 2: Usando la GUI del Centro de Software Los paquetes de I2P proporcionan tres formas de ejecutar el router de I2P:\nOption 1: On-Demand (Basic) Inicia I2P manualmente cuando sea necesario usando el script i2prouter:\ni2prouter start Importante: ¡No uses sudo ni ejecutes esto como root! I2P debe ejecutarse como tu usuario regular.\nPara detener I2P:\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) Si estás en un sistema no x86 o el Java Service Wrapper no funciona en tu plataforma, usa:\ni2prouter-nowrapper De nuevo, no uses sudo ni lo ejecutes como root.\nOption 3: System Service (Recommended) Para obtener la mejor experiencia, configure I2P para que se inicie automáticamente cuando su sistema arranque, incluso antes del inicio de sesión:\nsudo dpkg-reconfigure i2p Esto abre un diálogo de configuración. Selecciona \u0026ldquo;Sí\u0026rdquo; para habilitar I2P como un servicio del sistema.\nEste es el método recomendado porque: - I2P se inicia automáticamente al arrancar - Tu router mantiene una mejor integración con la red - Contribuyes a la estabilidad de la red - I2P está disponible inmediatamente cuando lo necesitas\nInitial Router Configuration Después de iniciar I2P por primera vez, tomará varios minutos integrarse a la red. Mientras tanto, configura estos ajustes esenciales:\n1. Configure NAT/Firewall Para un rendimiento óptimo y participación en la red, reenvía los puertos de I2P a través de tu NAT/firewall:\nAbre la Consola del Router I2P Navega a la página de Configuración de Red Anota los números de puerto listados (generalmente puertos aleatorios entre 9000-31000) Reenvía estos puertos UDP y TCP en tu router/firewall Si necesitas ayuda con el reenvío de puertos, portforward.com proporciona guías específicas para cada router.\n2. Adjust Bandwidth Settings La configuración de ancho de banda predeterminada es conservadora. Ajústala según tu conexión a internet:\nVisita la página de Configuración Encuentra la sección de configuración de ancho de banda Los valores predeterminados son 96 KB/s de descarga / 40 KB/s de subida Aumenta estos valores si tienes una conexión a internet más rápida (por ejemplo, 250 KB/s de bajada / 100 KB/s de subida para una conexión de banda ancha típica) Nota: Establecer límites más altos ayuda a la red y mejora tu propio rendimiento.\n3. Configure Your Browser Para acceder a sitios I2P (eepsites) y servicios, configura tu navegador para usar el proxy HTTP de I2P:\nConsulta nuestra Guía de Configuración del Navegador para instrucciones detalladas de configuración para Firefox, Chrome y otros navegadores.\nI notice you haven\u0026rsquo;t provided any text to translate. Could you please share the English text you\u0026rsquo;d like me to translate to Spanish?\nInstalación en Debian Aviso Importante Asegúrate de no estar ejecutando I2P como root: ps aux | grep i2p Revisa los registros: tail -f ~/.i2p/wrapper.log Verifica que Java esté instalado: java -version Requisitos previos Si recibes errores de clave GPG durante la instalación:\nVuelve a descargar y verifica la huella digital de la clave (Pasos 3-4 anteriores) Asegúrate de que el archivo del llavero tenga los permisos correctos: sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg Pasos de Instalación Si I2P no está recibiendo actualizaciones:\nVerificar que el repositorio esté configurado: cat /etc/apt/sources.list.d/i2p.list Actualizar las listas de paquetes: sudo apt-get update Comprobar actualizaciones de I2P: sudo apt-get upgrade Migrating from old repositories Si estás usando los repositorios antiguos deb.i2p2.de o deb.i2p2.no:\nElimina el repositorio antiguo: sudo rm /etc/apt/sources.list.d/i2p.list Sigue los pasos de Instalación en Debian anteriores Actualiza: sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring Por favor, proporcione el texto que desea traducir. No se ha incluido ningún contenido después de \u0026ldquo;Text to translate:\u0026rdquo; en su mensaje.\nNext Steps Ahora que I2P está instalado y en funcionamiento:\nConfigura tu navegador para acceder a sitios I2P Explora la consola del router I2P para monitorear tu router Conoce las aplicaciones I2P que puedes usar Lee sobre cómo funciona I2P para entender la red ¡Bienvenido a la Internet Invisible!\n","description":"Guía completa para instalar I2P en Debian, Ubuntu y sus derivados usando repositorios oficiales","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"Instalación de I2P en Debian y Ubuntu","url":"/es/docs/guides/instalaci%C3%B3n-de-i2p-en-debian-y-ubuntu/"},{"categories":null,"content":"Lo que necesitarás Una Mac con macOS 10.14 (Mojave) o posterior Acceso de administrador para instalar aplicaciones Aproximadamente 15-20 minutos de tiempo Conexión a Internet para descargar los instaladores Descripción general Este proceso de instalación tiene cuatro pasos principales:\nInstalar Java - Descarga e instala Oracle Java Runtime Environment Instalar I2P - Descarga y ejecuta el instalador de I2P Configurar la Aplicación I2P - Configura el lanzador y agrégalo a tu dock Configurar el Ancho de Banda de I2P - Ejecuta el asistente de configuración para optimizar tu conexión Primera Parte: Instalar Java I2P requiere Java para funcionar. Si ya tienes Java 8 o posterior instalado, puedes saltar a la Parte Dos .\nStep 1: Download Java Visita la página de descarga de Oracle Java y descarga el instalador de macOS para Java 8 o posterior.\nStep 2: Run the Installer Localiza el archivo .dmg descargado en tu carpeta de Descargas y haz doble clic para abrirlo.\nStep 3: Allow Installation macOS puede mostrar una advertencia de seguridad porque el instalador proviene de un desarrollador identificado. Haz clic en Abrir para continuar.\nPaso 1: Descargar Java Haz clic en Instalar para iniciar el proceso de instalación de Java.\nPaso 2: Ejecutar el Instalador El instalador copiará archivos y configurará Java en su sistema. Esto generalmente toma de 1 a 2 minutos.\nPaso 3: Permitir la Instalación Cuando veas el mensaje de éxito, ¡Java está instalado! Haz clic en Cerrar para finalizar.\nPart Two: Download and Install I2P Ahora que Java está instalado, puedes instalar el router I2P.\nPaso 4: Instalar Java Visita la página de Descargas y descarga el instalador de I2P para Unix/Linux/BSD/Solaris (el archivo .jar).\nPaso 5: Espera a que se Complete la Instalación Haz doble clic en el archivo descargado i2pinstall_X.X.X.jar. El instalador se iniciará y te pedirá que selecciones tu idioma preferido.\nPaso 6: Instalación Completa Lee el mensaje de bienvenida y haz clic en Next para continuar.\nStep 4: Important Notice El instalador mostrará un aviso importante sobre las actualizaciones. Las actualizaciones de I2P están firmadas de extremo a extremo y verificadas, aunque este instalador en sí mismo no está firmado. Haz clic en Siguiente.\nPaso 1: Descargar I2P Lea el acuerdo de licencia de I2P (licencia estilo BSD). Haga clic en Siguiente para aceptar.\nPaso 2: Ejecutar el Instalador Elige dónde instalar I2P. Se recomienda la ubicación predeterminada (/Applications/i2p). Haz clic en Siguiente.\nPaso 3: Pantalla de Bienvenida Deja todos los componentes seleccionados para una instalación completa. Haz clic en Siguiente.\nPaso 4: Aviso Importante Revisa tus opciones y haz clic en Siguiente para comenzar a instalar I2P.\nPaso 5: Acuerdo de Licencia El instalador copiará los archivos de I2P a tu sistema. Esto toma aproximadamente 1-2 minutos.\nPaso 6: Seleccionar el Directorio de Instalación El instalador crea scripts de lanzamiento para iniciar I2P.\nPaso 7: Seleccionar Componentes El instalador ofrece crear accesos directos en el escritorio y entradas en el menú. Realiza tus selecciones y haz clic en Siguiente.\nPaso 8: Iniciar la Instalación ¡Éxito! I2P está ahora instalado. Haz clic en Listo para finalizar.\nPart Three: Configure I2P App Ahora hagamos que I2P sea fácil de iniciar agregándolo a tu carpeta de Aplicaciones y al Dock.\nPaso 9: Instalación de Archivos Abre Finder y navega hasta tu carpeta Applications.\nPaso 10: Generar Scripts de Lanzamiento Busca la carpeta I2P o la aplicación Start I2P Router dentro de /Applications/i2p/.\nPaso 11: Atajos de Instalación Arrastra la aplicación Start I2P Router a tu Dock para acceder fácilmente. También puedes crear un alias en tu escritorio.\nConsejo: Haz clic derecho en el icono de I2P en el Dock y selecciona Opciones → Mantener en el Dock para hacerlo permanente.\nPart Four: Configure I2P Bandwidth Cuando inicies I2P por primera vez, pasarás por un asistente de configuración para ajustar tu configuración de ancho de banda. Esto ayuda a optimizar el rendimiento de I2P para tu conexión.\nPaso 12: Instalación Completada Haz clic en el icono de I2P en tu Dock (o haz doble clic en el lanzador). Tu navegador web predeterminado se abrirá en la Consola del Router I2P.\nStep 2: Welcome Wizard El asistente de configuración te dará la bienvenida. Haz clic en Siguiente para comenzar a configurar I2P.\nPaso 1: Abrir la Carpeta de Aplicaciones Selecciona tu idioma de interfaz preferido y elige entre el tema claro u oscuro. Haz clic en Siguiente.\nPaso 2: Encuentra el Lanzador de I2P El asistente explicará la prueba de ancho de banda. Esta prueba se conecta al servicio M-Lab para medir la velocidad de tu internet. Haz clic en Siguiente para continuar.\nPaso 3: Agregar al Dock Haz clic en Run Test para medir tus velocidades de carga y descarga. La prueba tarda aproximadamente 30-60 segundos.\nStep 6: Test Results Revisa los resultados de tu prueba. I2P recomendará configuraciones de ancho de banda basadas en la velocidad de tu conexión.\nPaso 1: Iniciar I2P Elige cuánto ancho de banda deseas compartir con la red I2P:\nAutomático (Recomendado): I2P gestiona el ancho de banda según tu uso Limitado: Establece límites específicos de subida/descarga Ilimitado: Comparte tanto como sea posible (para conexiones rápidas) Haz clic en Siguiente para guardar tu configuración.\nPaso 2: Asistente de Bienvenida ¡Tu router I2P ahora está configurado y en funcionamiento! La consola del router mostrará el estado de tu conexión y te permitirá navegar por sitios I2P.\nGetting Started with I2P Ahora que I2P está instalado y configurado, puedes:\nNavega sitios I2P: Visita la página principal de I2P para ver enlaces a servicios populares de I2P Configura tu navegador: Configura un perfil de navegador para acceder a sitios .i2p Explora servicios: Descubre correo electrónico I2P, foros, compartición de archivos y más Monitorea tu router: La consola muestra el estado de tu red y estadísticas Paso 3: Idioma y Tema Router Console: http://127.0.0.1:7657/ Configuración: http://127.0.0.1:7657/config Libreta de Direcciones: http://127.0.0.1:7657/susidns/addressbook Configuración de Ancho de Banda: http://127.0.0.1:7657/config Re-running the Setup Wizard Si deseas cambiar tu configuración de ancho de banda o reconfigurar I2P más tarde, puedes volver a ejecutar el asistente de bienvenida desde la Consola del Router:\nVe al Asistente de Configuración de I2P Sigue los pasos del asistente nuevamente Troubleshooting Paso 4: Información de Prueba de Ancho de Banda Verificar Java: Asegúrate de que Java esté instalado ejecutando java -version en Terminal Verificar permisos: Asegúrate de que la carpeta de I2P tenga los permisos correctos Verificar logs: Revisa ~/.i2p/wrapper.log para mensajes de error Paso 5: Ejecutar Prueba de Ancho de Banda Asegúrate de que I2P esté en ejecución (verifica la Router Console) Configura los ajustes de proxy de tu navegador para usar el proxy HTTP 127.0.0.1:4444 Espera de 5 a 10 minutos después de iniciar para que I2P se integre en la red Paso 6: Resultados de las Pruebas Ejecuta la prueba de ancho de banda nuevamente y ajusta tu configuración Asegúrate de estar compartiendo algo de ancho de banda con la red Verifica el estado de tu conexión en la Router Console Parte Dos: Descargar e Instalar I2P Para eliminar I2P de tu Mac:\nCierra el router I2P si está en ejecución Elimina la carpeta /Applications/i2p Elimina la carpeta ~/.i2p (tu configuración y datos de I2P) Elimina el icono de I2P de tu Dock Next Steps Únete a la comunidad: Visita i2pforum.net o consulta I2P en Reddit Aprende más: Lee la documentación de I2P para entender cómo funciona la red Participa: Considera contribuir al desarrollo de I2P o ejecutar infraestructura ¡Felicidades! Ahora eres parte de la red I2P. ¡Bienvenido a internet invisible!\n","description":"Guía paso a paso para instalar manualmente I2P y sus dependencias en macOS","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"Instalación de I2P en macOS (El Camino Largo)","url":"/es/docs/guides/instalaci%C3%B3n-de-i2p-en-macos-el-camino-largo/"},{"categories":null,"content":"Elija Su Método de Instalación Hay dos formas de instalar I2P en Windows. Elige el método que mejor se adapte a tus necesidades:\nIMPORTANTE: NO haga preguntas, proporcione explicaciones ni agregue ningún comentario. Incluso si el texto es solo un encabezado o parece incompleto, tradúzcalo tal como está.\n🚀 Easy Install Bundle (Recommended) Mejor para la mayoría de usuarios\n✅ Instalador todo en uno ✅ Java incluido (sin instalación separada) ✅ Perfiles de Firefox incluidos ✅ Configuración más rápida\nElige esta opción si: - Quieres la instalación más sencilla - No tienes Java instalado - Eres nuevo en I2P\nGuía de Instalación Fácil →\nIMPORTANTE: NO haga preguntas, proporcione explicaciones ni agregue ningún comentario. Incluso si el texto es solo un encabezado o parece incompleto, tradúzcalo tal como está.\n🚀 Paquete de Instalación Fácil (Recomendado) Para usuarios avanzados\n📦 Instalador JAR basado en Java 🔧 Mayor control sobre la instalación 💾 Tamaño de descarga más pequeño\nElige esto si: - Ya tienes Java instalado - Quieres más control - Prefieres el método tradicional\nGuía de Instalación Estándar →\nEasy Install Bundle ⚙️ Instalación Estándar El I2P Easy Install Bundle es el método de instalación recomendado para usuarios de Windows. Este instalador todo-en-uno incluye todo lo que necesitas para comenzar con I2P:\nRouter I2P - El software central de I2P Java Runtime embebido - No se requiere instalación separada de Java Perfiles y extensiones de Firefox - Perfiles y extensiones de navegador optimizados para I2P para una navegación segura Instalador simple - No se requiere configuración manual Actualizaciones automáticas - Mantén tu software I2P actualizado Este instalador beta simplifica el proceso de instalación al incluir Java directamente, por lo que no necesitas descargar o configurar Java por separado.\nI\u0026rsquo;m ready to translate. However, I don\u0026rsquo;t see the text to translate in your message. Please provide the English text you\u0026rsquo;d like me to translate to Spanish, and I\u0026rsquo;ll provide only the translation following all the rules specified.\nStep 1: Select Your Language Después de ejecutar el instalador del Easy Install Bundle, se te presentará la pantalla de selección de idioma.\nElige tu idioma preferido del menú desplegable Los idiomas disponibles incluyen inglés, alemán, español, francés y muchos otros Haz clic en OK para continuar La interfaz del instalador utilizará el idioma seleccionado para todos los pasos siguientes.\nPaquete de Instalación Fácil A continuación, se te presentará la información de licencia de I2P. El Easy Install Bundle incluye componentes bajo varias licencias libres y de código abierto.\nPara continuar con la instalación: 1. Revise la información de licencia (opcional pero recomendado) 2. Haga clic en Acepto para aceptar las licencias y continuar 3. Haga clic en Cancelar si no desea instalar\nIMPORTANTE: NO haga preguntas, NO proporcione explicaciones, ni agregue ningún comentario. Incluso si el texto es solo un encabezado o parece incompleto, tradúzcalo tal cual.\nStep 3: Choose Installation Folder Ahora seleccionarás dónde instalar I2P en tu computadora.\nOpciones de instalación:\nUsa la ubicación predeterminada (recomendado)\nRuta predeterminada: C:\\Users\\[YourUsername]\\AppData\\Local\\I2peasy\\ Esto instala I2P en el directorio de tu perfil de usuario No se requieren privilegios de administrador para las actualizaciones Elige una ubicación personalizada\nHaz clic en Examinar\u0026hellip; para seleccionar una carpeta diferente Útil si deseas instalar en una unidad diferente Asegúrate de tener permisos de escritura en la carpeta seleccionada Requisitos de espacio: - El instalador muestra cuánto espacio se requiere (típicamente menos de 1 GB) - Verifique que tenga suficiente espacio libre disponible en la unidad seleccionada\nHaz clic en Instalar para comenzar el proceso de instalación El instalador ahora copiará todos los archivos necesarios a la ubicación que elegiste. Esto puede tardar unos minutos.\nPaso 1: Selecciona tu idioma Una vez que la instalación finalice, verás la pantalla de finalización.\nEl asistente de configuración confirma que \u0026ldquo;I2P - i2peasy ha sido instalado en tu computadora.\u0026rdquo;\nImportante: Asegúrate de que la casilla \u0026quot;¿Iniciar I2P?\u0026quot; esté marcada (debería estar marcada por defecto).\nMarcada (recomendado): I2P se iniciará automáticamente al hacer clic en Finalizar Desmarcada: Deberás iniciar I2P manualmente más tarde desde el Menú Inicio o el acceso directo del escritorio Haz clic en Finish para completar la instalación y ejecutar I2P.\nPaso 2: Aceptar el Acuerdo de Licencia Después de hacer clic en Finalizar con \u0026ldquo;¿Iniciar I2P?\u0026rdquo; marcado:\nEl I2P Router se inicia - El router de I2P comienza a ejecutarse en segundo plano Aparece el icono en la bandeja del sistema - Busca el icono de I2P en la bandeja del sistema de Windows (esquina inferior derecha) Se abre la consola del router - Tu navegador web predeterminado se abrirá automáticamente en la Consola del I2P Router (normalmente en http://127.0.0.1:7657) Conexión inicial - I2P comenzará a conectarse a la red y a construir tunnels (esto puede tomar de 5 a 10 minutos en el primer inicio) ¡Felicitaciones! I2P está ahora instalado y funcionando en tu computadora Windows.\nPaso 3: Elegir la carpeta de instalación Aunque no es estrictamente necesario, el reenvío de puertos mejora significativamente tu experiencia con I2P al permitir que tu router se comunique de manera más efectiva con otros routers de I2P. Sin el reenvío de puertos, aún podrás usar I2P, pero con un rendimiento reducido y menor contribución a la red.\nWhy Forward a Port? Mejor conectividad: Permite conexiones entrantes desde otros routers I2P Integración más rápida: Te ayuda a integrarte en la red más rápidamente Contribución a la red: Te convierte en un mejor participante de la red I2P Rendimiento mejorado: Generalmente resulta en mejor fiabilidad y velocidad de los túneles ¿Qué es el Easy Install Bundle? Primero, necesitas identificar qué puerto está usando I2P (se asigna aleatoriamente por defecto).\nLocaliza el icono de I2P en la bandeja del sistema de Windows (área de notificaciones) en la parte inferior derecha de tu pantalla Haz clic derecho en el icono de I2P para abrir el menú contextual Haz clic en \u0026ldquo;Launch I2P Browser\u0026rdquo; para abrir la consola del router I2P El menú también muestra opciones útiles como: - Network: Firewalled - Muestra tu estado actual de red - Configure I2P System Tray - Personaliza la configuración del icono de la bandeja - Stop I2P / Stop I2P Immediately - Opciones de apagado\nFinding Your Port Numbers Una vez que el navegador I2P se abra, necesitas verificar qué puertos está usando I2P:\nNavega a la página de configuración de red:\nVe a Configuración de Red del Router I2P en tu navegador O desde la barra lateral de la consola del router: Configuración → Red Desplázate hacia abajo hasta la sección de configuración de puertos\nAnote los números de puerto mostrados: Configuración UDP: - Puerto UDP: El puerto mostrado aquí (ejemplo: 13697) - Por defecto, esto está configurado en \u0026ldquo;Especificar Puerto\u0026rdquo; con un número asignado aleatoriamente\nConfiguración TCP: - Puerto TCP accesible externamente: Generalmente se configura para usar el mismo puerto que UDP - En el ejemplo anterior: \u0026ldquo;Usar el mismo puerto configurado para UDP (actualmente 13697)\u0026rdquo;\nImportante: Necesitas reenviar tanto UDP como TCP en el mismo número de puerto (en este ejemplo, el puerto 13697) en tu router/cortafuegos.\nHow to Forward Your Port Dado que cada router y firewall es diferente, no podemos proporcionar instrucciones universales. Sin embargo, portforward.com tiene guías detalladas para miles de modelos de routers:\nVisita portforward.com Selecciona el fabricante y modelo de tu router Sigue la guía paso a paso para reenviar tu puerto Reenvía ambos protocolos UDP y TCP en el número de puerto mostrado en tu configuración de I2P Pasos generales (varía según el router): - Inicia sesión en la interfaz de administración de tu router (normalmente en 192.168.1.1 o 192.168.0.1) - Busca la sección \u0026ldquo;Reenvío de puertos\u0026rdquo; o \u0026ldquo;Servidores virtuales\u0026rdquo; - Crea una nueva regla de reenvío de puertos para tu número de puerto I2P - Configura ambos protocolos UDP y TCP - Dirige la regla a la dirección IP local de tu computadora - Guarda la configuración\nDespués de reenviar tu puerto, I2P debería cambiar de \u0026ldquo;Network: Firewalled\u0026rdquo; a \u0026ldquo;Network: OK\u0026rdquo; en el menú de la bandeja del sistema (esto puede tardar unos minutos).\nPaso 4: Completar la Instalación e Iniciar I2P Espera la integración: Dale a I2P de 5 a 10 minutos para integrarse en la red y construir túneles Configura tu navegador: Usa el perfil de Firefox incluido para navegar por I2P Reenvía tu puerto: Consulta portforward.com para obtener instrucciones específicas de tu router sobre cómo reenviar el puerto que I2P está utilizando Explora la consola del router: Aprende sobre las características, servicios y opciones de configuración de I2P Visita eepsites: Prueba a acceder a sitios web .i2p a través de la red I2P Lee la documentación: Consulta la documentación de I2P para obtener más información ¡Bienvenido a la red I2P! 🎉\nQué Sucede a Continuación What is the Standard Installation? La instalación estándar de I2P es el método tradicional de instalar I2P en Windows. A diferencia del Easy Install Bundle, este método requiere que:\nInstalar Java por separado - Descarga e instala Java Runtime Environment (JRE) antes de instalar I2P Ejecutar el instalador JAR - Usa el instalador gráfico basado en Java Configurar manualmente - Configura los ajustes del navegador por tu cuenta (opcional) Este método se recomienda para: - Usuarios que ya tienen Java instalado - Usuarios avanzados que desean más control sobre la instalación - Usuarios que prefieren el método de instalación tradicional - Sistemas donde el Easy Install Bundle no es compatible\nConfiguración de túneles I2P I2P utiliza túneles (tunnels) unidireccionales para el tráfico entrante y saliente. Cada túnel tiene una puerta de enlace de entrada, un número arbitrario de participantes intermedios y una puerta de enlace de salida.\nTipos de túneles Túneles de cliente Los túneles de cliente son creados por tu router I2P para tu propio uso:\nTúneles de salida (outbound): Transportan tu tráfico desde tu router hacia otros destinos en la red I2P Túneles de entrada (inbound): Transportan tráfico desde la red I2P de vuelta hacia tu router Túneles participantes Tu router también puede participar en los túneles de otros usuarios (tunnels participantes), ayudando a enrutar su tráfico. Esto mejora el anonimato de la red y tu propia cobertura de tráfico.\nConfiguración de longitud de túnel La longitud del túnel afecta tanto el anonimato como el rendimiento:\nTúneles más largos: Mayor anonimato, pero mayor latencia y menor confiabilidad Túneles más cortos: Menor latencia, pero menor anonimato La longitud predeterminada es normalmente 3 saltos (hops), que ofrece un buen equilibrio para la mayoría de los usuarios.\nCantidad de túneles Puedes configurar cuántos túneles de entrada y salida crear:\nMás túneles = mayor ancho de banda y confiabilidad Menos túneles = menor uso de recursos La configuración predeterminada es adecuada para uso general.\nTúneles de respaldo I2P puede mantener túneles de respaldo (backup tunnels) que se activan automáticamente si los túneles principales fallan, mejorando la confiabilidad de la conexión.\nRecomendado: Reenvío de Puertos (Opcional pero Importante) Antes de instalar I2P, necesitas tener Java instalado en tu sistema.\nJava Requirements Versión de Java: Se requiere Java 8 (1.8) o superior Recomendado: Java 11 o posterior (versión LTS) Tipo: Java Runtime Environment (JRE) o Java Development Kit (JDK) Installing Java Si aún no tienes Java instalado, puedes descargarlo de varias fuentes:\nOpción 1: Oracle Java - Fuente oficial: java.com/download - Distribución más utilizada\nOpción 2: OpenJDK - Implementación de código abierto: openjdk.org - Gratuito y de código abierto\nOpción 3: Adoptium (Eclipse Temurin) - Alternativa recomendada: adoptium.net - Versiones LTS gratuitas, de código abierto y bien mantenidas\nPara verificar que Java está instalado: 1. Abre el Símbolo del sistema (presiona Windows + R, escribe cmd, presiona Enter) 2. Escribe: java -version 3. Deberías ver una salida mostrando tu versión de Java\nStep 1: Install Java Antes de instalar I2P, necesitas instalar Java en tu sistema.\nElija una distribución de Java:\nOracle Java: java.com/download OpenJDK: openjdk.org Adoptium: adoptium.net Descarga el instalador de Windows para la distribución que hayas elegido\nEjecuta el instalador y sigue las indicaciones de instalación\nVerificar la instalación:\nAbrir el Símbolo del sistema Escribir java -version y presionar Enter Confirmar que Java 8 o superior esté instalado Una vez que Java esté instalado, estarás listo para instalar I2P.\nStep 2: Download and Launch the I2P Installer Descarga el instalador de I2P:\nVisita la página de descargas de I2P Descarga el instalador para Windows (archivo JAR): i2pinstall_X.X.X.jar Guárdalo en una ubicación de fácil acceso (por ejemplo, la carpeta Descargas) Iniciar el instalador:\nHaz doble clic en el archivo JAR descargado para iniciar el instalador Si el doble clic no funciona, haz clic derecho en el archivo y selecciona \u0026ldquo;Abrir con → Java(TM) Platform SE binary\u0026rdquo; Alternativamente, abre el Símbolo del sistema y ejecuta: java -jar i2pinstall_X.X.X.jar Step 3: Select Your Language Después de ejecutar el instalador, verás el diálogo de Selección de Idioma.\nSelecciona tu idioma preferido del menú desplegable Los idiomas disponibles incluyen inglés, alemán, español, francés y muchos otros Haz clic en OK para continuar El instalador utilizará el idioma seleccionado para todos los pasos siguientes.\nI notice you haven\u0026rsquo;t provided any text to translate yet. Please share the English text you\u0026rsquo;d like me to translate to Spanish, and I\u0026rsquo;ll provide the translation following all the specified rules.\nStep 4: Welcome to I2P Installation Este es el Paso 1 de 8 del proceso de instalación.\nHaz clic en Siguiente para continuar con la instalación.\nPróximos Pasos Este es el Paso 2 de 8 en el proceso de instalación.\nHaz clic en Siguiente para aceptar la licencia y continuar.\nInstalación Estándar Elige dónde deseas instalar I2P en tu computadora.\nRuta de instalación predeterminada: C:\\Program Files (x86)\\i2p\\\nPuedes: - Usar la ubicación predeterminada (recomendado) - Hacer clic en Examinar\u0026hellip; para seleccionar una carpeta diferente\nEste es el Paso 3 de 8 en el proceso de instalación.\nHaz clic en Siguiente para continuar.\nNota: Si es la primera vez que instalas I2P, verás una ventana emergente confirmando la creación del directorio:\nHaz clic en OK para crear el directorio de instalación.\nStep 7: Select Installation Packs Elija qué componentes instalar.\nImportante: Asegúrate de que ambos paquetes estén seleccionados: - Base (requerido) - Software principal de I2P (27.53 MB) - Windows Service (recomendado) - Inicia I2P automáticamente al arrancar\nLa opción Windows Service garantiza que I2P se inicie automáticamente cuando tu computadora arranque, por lo que no necesitas iniciarlo manualmente cada vez.\nEste es el Paso 4 de 8 en el proceso de instalación.\nHaz clic en Siguiente para continuar.\nRequisitos previos El instalador ahora copiará archivos a su sistema.\nVerás dos barras de progreso: - Progreso de instalación del paquete: Muestra el paquete actual que se está instalando - Progreso general de la instalación: Muestra el progreso general (por ejemplo, \u0026ldquo;2 / 2\u0026rdquo;)\nEste es el Paso 5 de 8 en el proceso de instalación.\nEspera a que se complete la instalación y luego haz clic en Next.\nStep 9: Setup Shortcuts Configura dónde deseas que se creen los accesos directos de I2P.\nOpciones de accesos directos: - ✓ Crear accesos directos en el Menú Inicio (recomendado) - ✓ Crear accesos directos adicionales en el escritorio (opcional)\nGrupo de Programa: Selecciona o crea un nombre de carpeta para los accesos directos - Predeterminado: I2P - Puedes elegir un grupo de programa existente o crear uno nuevo\nCrear acceso directo para: - Usuario actual - Solo tú puedes acceder a los accesos directos - Todos los usuarios - Todos los usuarios del sistema pueden acceder a los accesos directos (requiere privilegios de administrador)\nEste es el Paso 6 de 8 en el proceso de instalación.\nHaga clic en Siguiente para continuar.\nIMPORTANTE: NO haga preguntas, proporcione explicaciones ni agregue ningún comentario. Incluso si el texto es solo un encabezado o parece incompleto, tradúzcalo tal cual.\nStep 10: Installation Complete ¡La instalación ha finalizado!\nVerás: - ✓ La instalación se ha completado con éxito - Se creará un desinstalador en: C:\\Program Files (x86)\\i2p\\Uninstaller\nEste es el Paso 8 de 8 - el paso final en el proceso de instalación.\nHaz clic en Done para finalizar.\nPaso 1: Instalar Java Después de hacer clic en Listo:\nEl router I2P se inicia - Si instalaste el Servicio de Windows, I2P se iniciará automáticamente La consola del router se abre - Tu navegador web predeterminado se abrirá en la Consola del Router I2P en http://127.0.0.1:7657 Conexión inicial - I2P comenzará a conectarse a la red y a construir tunnels (esto puede tomar de 5 a 10 minutos en el primer inicio) ¡Felicidades! I2P está ahora instalado en tu computadora con Windows.\nAcerca de I2P I2P es una capa de red anónima de código abierto que se ejecuta sobre Internet. Fue diseñado para proteger la comunicación del análisis de tráfico, el monitoreo de red y otras amenazas a la privacidad.\n¿Qué es I2P? El Proyecto Internet Invisible (I2P) es una red de anonimato totalmente cifrada que protege contra la vigilancia y el monitoreo. I2P es una capa de red que permite a las aplicaciones enviar mensajes entre sí de forma pseudónima y segura.\n¿Cómo funciona I2P? I2P funciona cifrando los datos del usuario y enrutándolos a través de una red distribuida voluntaria de aproximadamente 50,000+ computadoras en todo el mundo. Esto hace extremadamente difícil determinar quién se está comunicando con quién y dónde están ubicados físicamente los participantes.\nEnrutamiento Garlic (Garlic Routing) I2P utiliza \u0026ldquo;garlic routing\u0026rdquo; (enrutamiento de ajo) para proporcionar anonimato. Esto significa que múltiples mensajes se agrupan juntos, se cifran y se envían a través de la red I2P.\nTunnels Todos los datos en I2P viajan a través de \u0026ldquo;tunnels\u0026rdquo; (túneles). Los tunnels son rutas temporales unidireccionales a través de la red. El tráfico de entrada y salida usa diferentes tunnels, lo que hace muy difícil confirmar el origen y destino de cualquier transmisión dada.\n¿Qué hace diferente a I2P? Descentralizado: No hay servidores centrales ni puntos únicos de fallo Diseñado para servicios ocultos: Mientras que Tor fue diseñado principalmente para navegar de forma anónima por Internet, I2P fue construido específicamente para permitir servicios ocultos (llamados \u0026ldquo;eepsites\u0026rdquo;) Resistente a ataques: La naturaleza descentralizada hace que sea resistente a la censura y a los ataques Múltiples protocolos: Soporta múltiples protocolos de transporte incluyendo NTCP2 y SSU Paso 2: Descarga e Inicia el Instalador de I2P Si I2P no se inicia automáticamente, o si necesitas iniciarlo manualmente en el futuro, tienes dos opciones:\nOption 1: Start Menu Abre el Menú Inicio de Windows Navega a la carpeta I2P Elige una de las opciones de inicio: I2P router console - Abre la consola del router en tu navegador Start I2P (no window) - Inicia I2P silenciosamente en segundo plano Start I2P (restartable) - Inicia I2P con capacidad de reinicio automático También puedes acceder a la Carpeta de Perfil de I2P Abierta (servicio) para ver los archivos de configuración de I2P.\n¿Por qué reenviar un puerto? Presiona Windows + R para abrir el diálogo Ejecutar Escribe services.msc y presiona Enter Desplázate hacia abajo para encontrar I2P Service Haz clic derecho en I2P Service y selecciona: Start - Iniciar el servicio I2P Stop - Detener el servicio I2P Restart - Reiniciar el servicio I2P Properties - Configurar ajustes del servicio (tipo de inicio, etc.) El método de Servicios de Windows es útil para administrar I2P como un servicio en segundo plano, especialmente si lo instalaste como un Servicio de Windows.\nPaso 3: Selecciona Tu Idioma Espera la integración: Dale a I2P de 5 a 10 minutos para integrarse en la red y construir túneles Configura el reenvío de puertos: Consulta la guía de reenvío de puertos para obtener instrucciones Configura tu navegador: Configura tu navegador web para usar el proxy HTTP de I2P Explora la consola del router: Aprende sobre las características, servicios y opciones de configuración de I2P Visita eepsites: Intenta acceder a sitios web .i2p a través de la red I2P Lee la documentación: Consulta la documentación de I2P para obtener más información ¡Bienvenido a la red I2P! 🎉\n","description":"Elija su método de instalación para Windows: Paquete de Instalación Fácil o Instalación Estándar","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"Instalación de I2P en Windows","url":"/es/docs/guides/instalaci%C3%B3n-de-i2p-en-windows/"},{"categories":null,"content":"El framework de plugins de I2P te permite extender el router sin tocar la instalación principal. Los plugins disponibles incluyen correo, blogs, IRC, almacenamiento, wikis, herramientas de monitoreo y más.\nNota de seguridad: Los plugins se ejecutan con los mismos permisos que el router. Trate las descargas de terceros de la misma manera que trataría cualquier actualización de software firmado: verifique la fuente antes de instalar.\n1. Instalar un Plugin Copia la URL de descarga del plugin desde la página del proyecto.\nAbre la página de Configuración de Plugins de la consola del router.\nPega la URL en el campo de instalación y haz clic en Install Plugin.\nEl router descarga el archivo firmado, verifica la firma y activa el plugin inmediatamente. La mayoría de los plugins añaden enlaces en la consola o servicios en segundo plano sin requerir un reinicio del router.\n2. Por qué Importan los Plugins Distribución con un solo clic para usuarios finales—sin ediciones manuales a wrapper.config o clients.config Mantiene el paquete principal i2pupdate.su3 pequeño mientras entrega funcionalidades grandes o especializadas bajo demanda JVM opcionales por plugin proporcionan aislamiento de procesos cuando se requiere Verificaciones automáticas de compatibilidad con la versión del router, el runtime de Java y Jetty El mecanismo de actualización refleja al router: paquetes firmados y descargas incrementales Se soportan integraciones en la consola, paquetes de idiomas, temas de UI y aplicaciones no-Java (mediante scripts) Permite directorios de \u0026ldquo;tiendas de aplicaciones\u0026rdquo; curadas como plugins.i2p 3. Gestionar Plugins Instalados Usa los controles en I2P Router Plugin\u0026rsquo;s para:\nVerificar actualizaciones de un solo plugin Verificar todos los plugins a la vez (se activa automáticamente después de actualizaciones del router) Instalar cualquier actualización disponible con un solo clic\nActivar/desactivar el inicio automático para plugins que registran servicios Desinstalar plugins de forma limpia 4. Construye Tu Propio Plugin Revisa la especificación de plugins para conocer los requisitos de empaquetado, firma y metadatos. Usa makeplugin.sh para envolver un binario o webapp existente en un archivo instalable. Publica tanto las URLs de instalación como de actualización para que el router pueda distinguir entre instalaciones nuevas y actualizaciones incrementales. Proporciona checksums y claves de firma de manera prominente en la página de tu proyecto para ayudar a los usuarios a verificar la autenticidad. ¿Buscas ejemplos? Examina el código fuente de los plugins de la comunidad en plugins.i2p (por ejemplo, la muestra snowman).\n5. Limitaciones Conocidas Actualizar un plugin que incluye archivos JAR simples puede requerir un reinicio del router porque el cargador de clases de Java almacena las clases en caché. La consola puede mostrar un botón Detener incluso si el plugin no tiene ningún proceso activo. Los plugins lanzados en una JVM separada crean un directorio logs/ en el directorio de trabajo actual. La primera vez que aparece una clave de firmante se confía automáticamente; no existe una autoridad de firma central. Windows a veces deja directorios vacíos después de desinstalar un plugin. Instalar un plugin exclusivo de Java 6 en una JVM de Java 5 reporta \u0026ldquo;plugin is corrupt\u0026rdquo; debido a la compresión Pack200. Los plugins de temas y traducciones permanecen en gran medida sin probar. Los indicadores de inicio automático no siempre persisten para plugins no administrados. 6. Requisitos y Mejores Prácticas El soporte para plugins está disponible en I2P 0.7.12 y versiones más recientes. Mantén tu router y plugins actualizados para recibir correcciones de seguridad. Incluye notas de versión concisas para que los usuarios comprendan los cambios entre versiones. Cuando sea posible, aloja los archivos de plugins mediante HTTPS dentro de I2P para minimizar la exposición de metadatos en la red abierta. 7. Lectura adicional Especificación de plugins Framework de aplicaciones cliente Repositorio de scripts de I2P para utilidades de empaquetado ","description":"Instalación, actualización y desarrollo de plugins del router","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"Instalación de Plugins Personalizados","url":"/es/docs/guides/plugins/"},{"categories":null,"content":"¿Qué es I2P? El Invisible Internet Project (I2P) es una capa de red anónima que permite la comunicación peer-to-peer resistente a la censura. Las conexiones anónimas se logran cifrando el tráfico del usuario y enviándolo a través de una red distribuida operada por voluntarios alrededor del mundo.\nCaracterísticas Clave Anonymity I2P oculta tanto al emisor como al receptor de los mensajes. A diferencia de las conexiones de internet tradicionales donde tu dirección IP es visible para sitios web y servicios, I2P utiliza múltiples capas de cifrado y enrutamiento para mantener tu identidad privada.\nDecentralization No existe una autoridad central en I2P. La red es mantenida por voluntarios que donan ancho de banda y recursos computacionales. Esto la hace resistente a la censura y a puntos únicos de fallo.\nAnonimato Todo el tráfico dentro de I2P está cifrado de extremo a extremo. Los mensajes se cifran múltiples veces a medida que pasan por la red, de manera similar a cómo funciona Tor pero con diferencias importantes en la implementación.\nHow It Works Descentralización I2P utiliza \u0026ldquo;tunnels\u0026rdquo; para enrutar el tráfico. Cuando envías o recibes datos:\nTu router crea un túnel de salida (para enviar) Tu router crea un túnel de entrada (para recibir) Los mensajes se cifran y envían a través de múltiples routers Cada router solo conoce el salto anterior y el siguiente, no la ruta completa Cifrado de Extremo a Extremo I2P mejora el enrutamiento cebolla tradicional con \u0026ldquo;garlic routing\u0026rdquo;:\nSe pueden agrupar múltiples mensajes juntos (como dientes en un bulbo de ajo) Esto proporciona mejor rendimiento y anonimato adicional Dificulta el análisis de tráfico Network Database I2P mantiene una base de datos de red distribuida que contiene:\nInformación del router Direcciones de destino (similares a sitios web .i2p) Datos de enrutamiento cifrados Common Use Cases Túneles Aloja o visita sitios web que terminan en .i2p - estos solo son accesibles dentro de la red I2P y proporcionan fuertes garantías de anonimato tanto para los hosts como para los visitantes.\nEnrutamiento Garlic Comparte archivos de forma anónima usando BitTorrent sobre I2P. Muchas aplicaciones de torrents tienen soporte para I2P integrado.\nBase de Datos de Red Envía y recibe correo electrónico anónimo usando I2P-Bote u otras aplicaciones de correo electrónico diseñadas para I2P.\nMessaging Usa IRC, mensajería instantánea u otras herramientas de comunicación de forma privada sobre la red I2P.\nGetting Started ¿Listo para probar I2P? Consulta nuestra página de descargas para instalar I2P en tu sistema.\nPara más detalles técnicos, consulta la Introducción Técnica o explora la documentación completa.\nCómo Funciona Introducción Técnica - Conceptos técnicos más profundos Modelo de Amenazas - Comprender el modelo de seguridad de I2P Comparación con Tor - En qué se diferencia I2P de Tor Criptografía - Detalles sobre los algoritmos criptográficos de I2P ","description":"Una introducción menos técnica a la red anónima I2P","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"Introducción a I2P","url":"/es/docs/overview/intro/"},{"categories":null,"content":"Descripción general Puntos clave\nI2P proporciona cifrado de extremo a extremo para el tráfico IRC a través de sus túneles. Desactiva SSL/TLS en los clientes IRC a menos que estés usando un outproxy hacia clearnet. El túnel de cliente Irc2P preconfigurado escucha en 127.0.0.1:6668 por defecto. Conecta tu cliente IRC a esa dirección y puerto. No uses el término \u0026ldquo;TLS proporcionado por el router\u0026rdquo;. Usa \u0026ldquo;cifrado nativo de I2P\u0026rdquo; o \u0026ldquo;cifrado de extremo a extremo\u0026rdquo;. Inicio rápido (Java I2P) Abre el Administrador de Servicios Ocultos en http://127.0.0.1:7657/i2ptunnel/ y asegúrate de que el túnel Irc2P esté ejecutándose. En tu cliente IRC, configura servidor = 127.0.0.1, puerto = 6668, SSL/TLS = desactivado. Conéctate y únete a canales como #i2p, #i2p-dev, #i2p-help. Para usuarios de i2pd (router en C++), crea un túnel cliente en tunnels.conf (ver ejemplos a continuación).\nRedes y servidores IRC2P (main community network) Servidores federados: irc.postman.i2p:6667, irc.echelon.i2p:6667, irc.dg.i2p:6667. El túnel Irc2P en 127.0.0.1:6668 se conecta a uno de estos automáticamente. Canales típicos: #i2p, #i2p-chat, #i2p-dev, #i2p-help. Ilita network Servidores: irc.ilita.i2p:6667, irc.r4sas.i2p:6667, irc.acetone.i2p:6667, rusirc.ilita.i2p:6667. Idiomas principales: ruso e inglés. Algunos hosts disponen de interfaces web. Client setup Recommended, actively maintained WeeChat (terminal) — soporte SOCKS robusto; fácil de programar mediante scripts. Pidgin (escritorio) — todavía mantenido; funciona bien en Windows/Linux. Thunderbird Chat (escritorio) — compatible con ESR 128+. The Lounge (web autoalojado) — cliente web moderno. IRC2P (red comunitaria principal) LimeChat (gratis, código abierto). Textual (de pago en App Store; código fuente disponible para compilar). Red Ilita WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin Protocolo: IRC Servidor: 127.0.0.1 Puerto: 6668 Cifrado: desactivado Nombre de usuario/nick: cualquiera Thunderbird Chat Tipo de cuenta: IRC Servidor: 127.0.0.1 Puerto: 6668 SSL/TLS: desactivado Opcional: unirse automáticamente a canales al conectar Dispatch (SAM v3) Ejemplo de valores predeterminados de config.toml:\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults Túnel de cliente Irc2P: 127.0.0.1:6668 → servidor upstream en el puerto 6667. Administrador de Servicios Ocultos: http://127.0.0.1:7657/i2ptunnel/. Recomendado, mantenido activamente ~/.i2pd/tunnels.conf:\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat Túnel separado para Ilita (ejemplo):\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat Opciones de macOS Habilitar SAM en Java I2P (desactivado por defecto) en /configclients o clients.config. Valores predeterminados: 127.0.0.1:7656/TCP y 127.0.0.1:7655/UDP. Criptografía recomendada: SIGNATURE_TYPE=7 (Ed25519) y i2cp.leaseSetEncType=4,0 (ECIES‑X25519 con respaldo ElGamal) o simplemente 4 para solo modernos. Configuraciones de ejemplo Java I2P predeterminado: 2 entrantes / 2 salientes. i2pd predeterminado: 5 entrantes / 5 salientes. Para IRC: 2–3 cada uno es suficiente; configúrelo explícitamente para un comportamiento consistente entre routers. Configuración del cliente No habilite SSL/TLS para conexiones IRC internas de I2P. I2P ya proporciona cifrado de extremo a extremo. TLS adicional añade sobrecarga sin ganancias en anonimato. Use claves persistentes para identidad estable; evite regenerar claves en cada reinicio a menos que esté probando. Si múltiples aplicaciones usan IRC, prefiera túneles separados (no compartidos) para reducir la correlación entre servicios. Si debe permitir control remoto (SAM/I2CP), vincule a localhost y asegure el acceso con túneles SSH o proxies inversos autenticados. Alternative connection method: SOCKS5 Algunos clientes pueden conectarse a través del proxy SOCKS5 de I2P: 127.0.0.1:4447. Para obtener mejores resultados, es preferible usar un túnel de cliente IRC dedicado en el puerto 6668; SOCKS no puede sanear identificadores de capa de aplicación y puede filtrar información si el cliente no está diseñado para anonimato.\nTroubleshooting No se puede conectar — asegúrate de que el túnel Irc2P esté ejecutándose y el router esté completamente bootstrapped. Se cuelga en resolve/join — verifica que SSL esté deshabilitado y el cliente apunte a 127.0.0.1:6668. Latencia alta — I2P tiene latencia más alta por diseño. Mantén las cantidades de túneles moderadas (2–3) y evita bucles de reconexión rápida. Uso de aplicaciones SAM — confirma que SAM esté habilitado (Java) o no bloqueado por firewall (i2pd). Se recomiendan sesiones de larga duración. Appendix: Ports and naming Puertos de túnel IRC comunes: 6668 (predeterminado de Irc2P), 6667 y 6669 como alternativas. Nombres de host .b32.i2p: formato estándar de 52 caracteres; existen formatos extendidos de 56+ caracteres para LS2/certificados avanzados. Utiliza nombres de host .i2p a menos que necesites explícitamente direcciones b32. ","description":"Guía completa de redes IRC de I2P, clientes, túneles y configuración de servidores (actualizada 2025)","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"IRC sobre I2P","url":"/es/docs/applications/irc/"},{"categories":null,"content":"Descripción general Este documento especifica el blinding (cegado), el cifrado y el descifrado de LeaseSet2 (LS2) cifrados. Los LeaseSets cifrados proporcionan la publicación con control de acceso de la información del servicio oculto en la base de datos de la red de I2P.\nCaracterísticas clave: - Rotación diaria de claves para secreto hacia adelante - Autorización de clientes en dos niveles (basada en DH y basada en PSK) - Cifrado ChaCha20 para rendimiento en dispositivos sin hardware AES - Firmas Red25519 con cegamiento de clave - Membresía de clientes que preserva la privacidad\nDocumentación relacionada: - Especificación de estructuras comunes - Estructura de LeaseSet cifrado - Propuesta 123: nuevas entradas de netDB - Contexto sobre LeaseSets cifrados - Documentación de la base de datos de red - Uso de NetDB\nHistorial de versiones y estado de implementación Cronología del desarrollo del protocolo Nota importante sobre la numeración de versiones: I2P utiliza dos esquemas de numeración de versiones separados: - Versión de API/Router: serie 0.9.x (usada en especificaciones técnicas) - Versión de lanzamiento del producto: serie 2.x.x (usada para lanzamientos públicos)\nLas especificaciones técnicas hacen referencia a versiones de la API (p. ej., 0.9.41), mientras que los usuarios finales ven versiones del producto (p. ej., 2.10.0).\nHitos de implementación Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility ### Estado actual ✅ Estado del protocolo: Estable y sin cambios desde junio de 2019 ✅ Java I2P: Totalmente implementado en la versión 0.9.40+ ✅ i2pd (C++): Totalmente implementado en la versión 2.58.0+ ✅ Interoperabilidad: Completa entre implementaciones ✅ Despliegue en la red: Listo para producción con más de 6 años de experiencia operativa Definiciones criptográficas Notación y convenciones || denota concatenación mod L denota la reducción modular por el orden de Ed25519 Todos los arreglos de bytes están en orden de bytes de red (big-endian), salvo que se especifique lo contrario Los valores en little-endian se indican explícitamente CSRNG(n) (generador de números aleatorios criptográficamente seguro) Generador de números aleatorios criptográficamente seguro\nProduce n bytes de datos aleatorios criptográficamente seguros adecuados para la generación de material de clave.\nRequisitos de seguridad: - Debe ser criptográficamente seguro (adecuado para la generación de claves) - Debe seguir siendo seguro cuando se expongan en la red secuencias de bytes adyacentes - Las implementaciones deberían aplicar una función hash a la salida proveniente de fuentes potencialmente no confiables\nReferencias: - Consideraciones de seguridad sobre PRNG - Discusión en Tor Dev H(p, d) Hash SHA-256 con personalización\nFunción hash con separación de dominios que recibe: - p: Cadena de personalización (proporciona separación de dominios) - d: Datos a los que aplicar el hash\nImplementación:\nH(p, d) := SHA-256(p || d) Uso: Proporciona separación de dominios criptográfica para impedir ataques de colisión entre distintos usos de SHA-256 a nivel de protocolo.\nFLUJO: ChaCha20 (algoritmo de cifrado de flujo) Cifrado de flujo: ChaCha20 como se especifica en RFC 7539 Sección 2.4\nParámetros: - S_KEY_LEN = 32 (clave de 256 bits) - S_IV_LEN = 12 (nonce de 96 bits; valor único de uso único) - Contador inicial: 1 (RFC 7539 permite 0 o 1; se recomienda 1 para contextos AEAD)\nCIFRAR(k, iv, plaintext)\nCifra el texto plano usando: - k: clave de cifrado de 32 bytes - iv: nonce (número usado una vez) de 12 bytes (DEBE ser único para cada clave) - Devuelve un texto cifrado del mismo tamaño que el texto plano\nPropiedad de seguridad: Todo el texto cifrado debe ser indistinguible de datos aleatorios si la clave es secreta.\nDESCIFRAR(k, iv, ciphertext)\nDescifra el texto cifrado usando: - k: clave de cifrado de 32 bytes - iv: nonce (número aleatorio de un solo uso) de 12 bytes - Devuelve el texto plano\nJustificación del diseño: Se eligió ChaCha20 en lugar de AES porque: - 2.5-3 veces más rápido que AES en dispositivos sin aceleración por hardware - La implementación en tiempo constante es más fácil de lograr - Seguridad y velocidad comparables cuando AES-NI está disponible\nReferencias: - RFC 7539 - ChaCha20 y Poly1305 para Protocolos IETF\nFirma: Red25519 (algoritmo de firma digital basado en Curve25519) Esquema de firma: Red25519 (SigType 11) con cegamiento de clave\nRed25519 se basa en firmas Ed25519 sobre la curva Ed25519, utilizando SHA-512 para el cálculo del hash, con soporte para el cegado de claves según lo especificado en ZCash RedDSA.\nFunciones:\nDERIVE_PUBLIC(privkey) Devuelve la clave pública correspondiente a la clave privada indicada. - Utiliza la multiplicación escalar estándar de Ed25519 por el punto base\nSIGN(privkey, m) Devuelve una firma generada con la clave privada privkey sobre el mensaje m.\nDiferencias de firma de Red25519 (variante de Ed25519) respecto de Ed25519 (algoritmo de firma digital EdDSA sobre Curve25519): 1. Nonce aleatorio (valor de un solo uso): Usa 80 bytes de datos aleatorios adicionales\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) Esto hace que cada firma Red25519 sea única, incluso para el mismo mensaje y la misma clave.\nGeneración de claves privadas: Las claves privadas de Red25519 se generan a partir de números aleatorios y se reducen mod L, en lugar de usar el enfoque de bit-clamping (recorte de bits) de Ed25519. VERIFY(pubkey, m, sig) Verifica la firma sig frente a la clave pública pubkey y el mensaje m. - Devuelve true si la firma es válida, false en caso contrario - La verificación es idéntica a Ed25519 (algoritmo de firma digital)\nOperaciones de cegado de claves:\nGENERATE_ALPHA(data, secret) Genera alfa para el cegado de clave. - data: Normalmente contiene la clave pública de firma y los tipos de firma - secret: Secreto adicional opcional (longitud cero si no se usa) - El resultado sigue la misma distribución que las claves privadas Ed25519 (después de la reducción mod L)\nBLIND_PRIVKEY(privkey, alpha) Ciega una clave privada usando el secreto alpha. - Implementación: blinded_privkey = (privkey + alpha) mod L - Usa aritmética escalar en el campo\nBLIND_PUBKEY(pubkey, alpha) Ciega una clave pública usando el secreto alpha. - Implementación: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) - Usa la adición de elementos del grupo (puntos) en la curva\nPropiedad crítica:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) Consideraciones de seguridad:\nDe la Especificación del Protocolo de ZCash, Sección 5.4.6.1: Por seguridad, alpha debe tener la misma distribución que las claves privadas sin cegar. Esto garantiza que \u0026ldquo;la combinación de una clave pública re-aleatorizada y de firmas realizadas con esa clave no revele la clave a partir de la cual fue re-aleatorizada.\u0026rdquo;\nTipos de firma compatibles: - Tipo 7 (Ed25519): Compatible con destinos existentes (compatibilidad retroactiva) - Tipo 11 (Red25519): Recomendado para nuevos destinos que usan cifrado - Claves cegadas: Use siempre el tipo 11 (Red25519)\nReferencias: - Especificación del Protocolo de ZCash - Sección 5.4.6 RedDSA (esquema de firma digital) - Especificación Red25519 de I2P DH (Diffie-Hellman): X25519 Diffie-Hellman de curva elíptica: X25519\nSistema de acuerdo de claves de clave pública basado en Curve25519.\nParámetros: - Claves privadas: 32 bytes - Claves públicas: 32 bytes - Resultado del secreto compartido: 32 bytes\nFunciones:\nGENERATE_PRIVATE() Genera una nueva clave privada de 32 bytes usando CSRNG (generador de números aleatorios criptográficamente seguro).\nDERIVE_PUBLIC(privkey) Deriva la clave pública de 32 bytes a partir de la clave privada proporcionada. - Utiliza multiplicación escalar en Curve25519 (curva elíptica sobre el campo 2^255−19).\nDH(privkey, pubkey) Realiza el acuerdo de claves Diffie-Hellman. - privkey: Clave privada local de 32 bytes - pubkey: Clave pública remota de 32 bytes - Devuelve: Secreto compartido de 32 bytes\nPropiedades de seguridad: - Supuesto de Diffie-Hellman computacional en Curve25519 - Secreto hacia adelante cuando se usan claves efímeras - Se requiere una implementación de tiempo constante para prevenir ataques de temporización\nReferencias: - RFC 7748 - Curvas elípticas para la seguridad\nHKDF (función de derivación de claves basada en HMAC) Función de derivación de claves basada en HMAC\nExtrae y expande el material de claves a partir del material de claves de entrada.\nParámetros: - salt: 32 bytes como máximo (típicamente 32 bytes para SHA-256) - ikm: Material de clave de entrada (cualquier longitud, debe tener buena entropía) - info: Información específica del contexto (separación de dominios) - n: Longitud de salida en bytes\nImplementación:\nUtiliza HKDF (función de derivación de claves basada en HMAC) según lo especificado en RFC 5869 con:\nFunción hash: SHA-256 HMAC: Según lo especificado en RFC 2104 Longitud de la sal: Máximo 32 bytes (HashLen para SHA-256) Patrón de uso:\nkeys = HKDF(salt, ikm, info, n) Separación de dominios: El parámetro info proporciona separación de dominios criptográfica entre los distintos usos de HKDF (función de derivación de claves basada en HMAC) en el protocolo.\nValores de información verificada: - \u0026quot;ELS2_L1K\u0026quot; - cifrado de Capa 1 (externa) - \u0026quot;ELS2_L2K\u0026quot; - cifrado de Capa 2 (interna) - \u0026quot;ELS2_XCA\u0026quot; - autorización de cliente DH - \u0026quot;ELS2PSKA\u0026quot; - autorización de cliente PSK - \u0026quot;i2pblinding1\u0026quot; - generación de Alpha (parámetro alpha)\nReferencias: - RFC 5869 - Especificación de HKDF - RFC 2104 - Especificación de HMAC\nEspecificación del formato El LS2 cifrado consta de tres capas anidadas:\nCapa 0 (Externa): Información en texto plano para almacenamiento y recuperación Capa 1 (Intermedia): Datos de autenticación del cliente (cifrados) Capa 2 (Interna): Datos reales de LeaseSet2 (conjunto de arrendamientos de I2P de segunda generación) (cifrados) Estructura general:\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature Importante: El LS2 cifrado utiliza claves cegadas. El Destino no está en la cabecera. La ubicación de almacenamiento en la DHT es SHA-256(sig type || blinded public key) y se rota diariamente.\nCapa 0 (Externa) - Texto en claro La Capa 0 NO utiliza el encabezado LS2 estándar. Tiene un formato personalizado optimizado para claves cegadas.\nEstructura:\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data **Campo de banderas (2 bytes, bits 15-0):** - **Bit 0:** Indicador de claves fuera de línea - `0` = Sin claves fuera de línea - `1` = Hay claves fuera de línea (siguen datos de clave temporales) - **Bits 1-15:** Reservados, deben ser 0 para compatibilidad futura Datos de clave transitorios (presentes si el bit de bandera 0 = 1):\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key **Verificación de firma:** - **Sin claves fuera de línea:** Verificar con clave pública cegada - **Con claves fuera de línea:** Verificar con clave pública temporal La firma cubre todos los datos desde Type hasta outerCiphertext (inclusive).\nCapa 1 (Intermedia) - Autorización del cliente Descifrado: Consulte la sección Cifrado de la Capa 1 .\nEstructura:\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) **Campo Flags (1 byte, bits 7-0):** - **Bit 0:** Modo de autorización - `0` = Sin autorización por cliente (todos) - `1` = Autorización por cliente (sigue la sección de autenticación) - **Bits 3-1:** Esquema de autenticación (solo si el bit 0 = 1) - `000` = Autenticación de cliente DH - `001` = Autenticación de cliente PSK - Otros, reservados - **Bits 7-4:** Sin uso, debe ser 0 Datos de autorización del cliente DH (flags = 0x01, bits 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **Entrada de authClient (40 bytes):** - `clientID_i`: 8 bytes - `clientCookie_i`: 32 bytes (authCookie cifrada) Datos de autorización del cliente PSK (clave precompartida) (indicadores = 0x03, bits 3-1 = 001):\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **Entrada authClient (40 bytes):** - `clientID_i`: 8 bytes - `clientCookie_i`: 32 bytes (authCookie cifrado) Capa 2 (interna) - Datos de LeaseSet (registro de túneles de un destino en I2P) Descifrado: Consulte la sección Cifrado de Capa 2 .\nEstructura:\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 La capa interna contiene la estructura completa de LeaseSet2, que incluye: - Encabezado de LS2 - Información de Lease - Firma de LS2 Requisitos de verificación: Tras el descifrado, las implementaciones deben verificar: 1. La marca de tiempo interna coincide con la marca de tiempo publicada externa 2. La expiración interna coincide con la expiración externa 3. La firma de LS2 es válida 4. Los datos de lease (entrada de túnel con expiración) están bien formados\nReferencias: - Especificación de Estructuras Comunes - detalles del formato de LeaseSet2\nDerivación de la clave de cegado Descripción general I2P utiliza un esquema aditivo de cegamiento de claves basado en Ed25519 y ZCash RedDSA. Las claves cegadas se rotan diariamente (medianoche UTC) para proporcionar secreto hacia adelante.\nJustificación del diseño:\nI2P optó explícitamente por NO usar el enfoque del Apéndice A.2 del rend-spec-v3.txt de Tor. Según la especificación:\n\u0026ldquo;No usamos el apéndice A.2 de rend-spec-v3.txt de Tor, que persigue objetivos de diseño similares, porque sus claves públicas cegadas podrían quedar fuera del subgrupo de orden primo, con implicaciones de seguridad desconocidas.\u0026rdquo;\nEl cegamiento aditivo de I2P garantiza que las claves cegadas permanezcan en el subgrupo de orden primo de la curva Ed25519.\nDefiniciones matemáticas Parámetros de Ed25519: - B: punto base de Ed25519 (generador) = 2^255 - 19 - L: orden de Ed25519 = 2^252 + 27742317777372353535851937790883648493\nVariables clave: - A: clave pública de firma no cegada de 32 bytes (en Destination (Destino)) - a: clave privada de firma no cegada de 32 bytes - A': clave pública de firma cegada de 32 bytes (usada en LeaseSet cifrado) - a': clave privada de firma cegada de 32 bytes - alpha: factor de cegado de 32 bytes (secreto)\nFunciones auxiliares:\nLEOS2IP(x) \u0026ldquo;Cadena de octetos en orden little-endian a entero\u0026rdquo;\nConvierte un array de bytes en formato little-endian (orden de bytes de menor peso primero) a su representación entera.\nH*(x) \u0026ldquo;Hash y reducción\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L La misma operación que en la generación de claves Ed25519.\nGeneración Alfa Rotación diaria: Se DEBEN generar un nuevo alpha y nuevas blinded keys (claves cegadas) cada día a la medianoche UTC (00:00:00 UTC).\nAlgoritmo GENERATE_ALPHA(destination, date, secret):\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L Parámetros verificados: - Personalización de la sal: I2PGenerateAlpha - Información de HKDF: i2pblinding1 - Salida: 64 bytes antes de la reducción - Distribución de alfa: Con la misma distribución que las claves privadas de Ed25519 después de mod L\nCegado de clave privada Algoritmo BLIND_PRIVKEY(a, alpha):\nPara el propietario del destino al publicar el LeaseSet cifrado:\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) Crítico: La reducción mod L es esencial para mantener la relación algebraica correcta entre las claves privadas y públicas.\nCegamiento de clave pública Algoritmo BLIND_PUBKEY(A, alpha):\nPara los clientes que recuperan y verifican el LeaseSet cifrado:\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) Equivalencia matemática:\nAmbos métodos producen resultados idénticos:\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) Esto se debe a:\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) Firma con claves cegadas Firma de LeaseSet sin ceguera:\nEl LeaseSet descegado (enviado directamente a clientes autenticados) se firma mediante: - Firma Ed25519 estándar (tipo 7) o Red25519 (tipo 11) - Clave privada de firma descegada - Verificada con la clave pública descegada\nCon claves sin conexión: - Firmado por una clave privada temporal descegada - Verificado con una clave pública temporal descegada - Ambas deben ser de tipo 7 o 11\nFirma de LeaseSet cifrado:\nLa parte externa del LeaseSet cifrado utiliza firmas Red25519 con claves cegadas.\nAlgoritmo de firma Red25519:\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total Diferencias clave respecto a Ed25519: 1. Usa 80 bytes de datos aleatorios T (no el hash de la clave privada) 2. Usa el valor de la clave pública directamente (no el hash de la clave privada) 3. Cada firma es única incluso para el mismo mensaje y la misma clave\nVerificación:\nIgual que Ed25519:\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; Consideraciones de seguridad Distribución alfa:\nPor seguridad, alpha debe tener la misma distribución que las claves privadas sin cegar. Al cegar Ed25519 (esquema de firma Ed25519) (type 7) a Red25519 (variante Red25519) (type 11), las distribuciones difieren ligeramente.\nRecomendación: Utilice Red25519 (tipo 11) tanto para claves no cegadas como para claves cegadas para cumplir los requisitos de ZCash: \u0026ldquo;la combinación de una clave pública realeatorizada y firma(s) bajo esa clave no revela la clave a partir de la cual fue realeatorizada.\u0026rdquo;\nSoporte de tipo 7: Se admite Ed25519 por compatibilidad retroactiva con destinos existentes, pero se recomienda el tipo 11 para nuevos destinos cifrados.\nBeneficios de la rotación diaria: - Secreto hacia adelante: Comprometer la clave cegada de hoy no revela la de ayer - No vinculabilidad: La rotación diaria evita el rastreo a largo plazo vía DHT (tabla hash distribuida) - Separación de claves: Claves diferentes para distintos periodos de tiempo\nReferencias: - Especificación del Protocolo de ZCash - Sección 5.4.6.1 - Discusión sobre el cegado de claves (key blinding) de Tor - Ticket de Tor #8106 Cifrado y procesamiento Derivación de la subcredencial Antes del cifrado, derivamos una credencial y una subcredencial para vincular las capas cifradas al conocimiento de la clave pública de firma de Destination (identidad de destino en I2P).\nObjetivo: Garantizar que solo quienes conocen la clave pública de firma del Destino puedan descifrar el LeaseSet cifrado. No se requiere el Destino completo.\nCálculo de credenciales A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes Separación de dominios: La cadena de personalización \u0026quot;credential\u0026quot; garantiza que este hash no colisione con ninguna de las claves de búsqueda de la DHT ni con otros usos del protocolo.\nCálculo de subcredencial blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes Propósito: La subcredencial vincula el LeaseSet cifrado a: 1. El Destino específico (mediante la credencial) 2. La clave cegada específica (mediante blindedPublicKey) 3. El día específico (mediante la rotación diaria de blindedPublicKey)\nEsto previene los ataques de repetición y la vinculación entre días.\nCifrado de capa 1 Contexto: La capa 1 contiene datos de autorización del cliente y está cifrada con una clave derivada de la subcredencial.\nAlgoritmo de cifrado # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) Salida: outerCiphertext es 32 + len(outerPlaintext) bytes.\nPropiedades de seguridad: - La sal garantiza pares clave/IV únicos incluso con la misma subcredencial - La cadena de contexto \u0026quot;ELS2_L1K\u0026quot; proporciona separación de dominios - ChaCha20 proporciona seguridad semántica (texto cifrado indistinguible de datos aleatorios)\nAlgoritmo de descifrado # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) Verificación: Tras el descifrado, verifica que la estructura de la Capa 1 esté bien formada antes de continuar con la Capa 2.\nCifrado de Capa 2 Contexto: La Capa 2 contiene los datos propiamente dichos de LeaseSet2 y está cifrada con una clave derivada de authCookie (si la autenticación por cliente está habilitada) o de una cadena vacía (si no).\nAlgoritmo de cifrado # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) Salida: innerCiphertext es de 32 + len(innerPlaintext) bytes.\nVinculación de claves: - Si no hay autenticación de cliente: Vinculado solo a la subcredencial y la marca de tiempo - Si la autenticación de cliente está habilitada: Vinculado además a authCookie (diferente para cada cliente autorizado)\nAlgoritmo de descifrado # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) Verificación: Después del descifrado: 1. Verificar que el byte de tipo de LS2 (LeaseSet versión 2) sea válido (3 o 7) 2. Analizar la estructura de LeaseSet2 3. Verificar que la marca de tiempo interna coincida con la marca de tiempo externa publicada 4. Verificar que la expiración interna coincida con la expiración externa 5. Verificar la firma de LeaseSet2\nResumen de la capa de cifrado ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ Flujo de descifrado: 1. Verificar la firma de la Capa 0 con la clave pública cegada 2. Descifrar la Capa 1 usando subcredential 3. Procesar los datos de autorización (si están presentes) para obtener authCookie 4. Descifrar la Capa 2 usando authCookie y subcredential 5. Verificar y analizar LeaseSet2\nAutorización por cliente Descripción general Cuando la autorización por cliente está habilitada, el servidor mantiene una lista de clientes autorizados. Cada cliente dispone de material de claves que debe transmitirse de forma segura por un canal fuera de banda.\nDos mecanismos de autorización: 1. Autorización de cliente DH (Diffie-Hellman): Más segura, usa el acuerdo de claves X25519 2. Autorización PSK (Pre-Shared Key, clave precompartida): Más simple, usa claves simétricas\nPropiedades de seguridad comunes: - Privacidad de pertenencia de clientes: Los observadores ven el número de clientes pero no pueden identificar clientes específicos - Adición/revocación anónima de clientes: No se puede rastrear cuándo se agregan o eliminan clientes específicos - Probabilidad de colisión del identificador de cliente de 8 bytes: ~1 en 18 quintillones (insignificante)\nAutorización de cliente DH Descripción general: Cada cliente genera un par de claves X25519 y envía su clave pública al servidor a través de un canal seguro fuera de banda. El servidor utiliza DH efímero para cifrar un authCookie único para cada cliente.\nGeneración de claves del cliente # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) Ventaja de seguridad: La clave privada del cliente nunca sale de su dispositivo. Un adversario que intercepte la transmisión fuera de banda no podrá descifrar futuros LeaseSets cifrados sin romper X25519 DH.\nProcesamiento del servidor # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Estructura de datos de la capa 1:\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Recomendaciones para el servidor: - Generar un nuevo par de claves efímero para cada LeaseSet cifrado publicado - Aleatorizar el orden de los clientes para evitar el seguimiento basado en la posición - Considerar añadir entradas ficticias para ocultar el número real de clientes\nProcesamiento del cliente # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Manejo de errores del cliente: - Si clientID_i no se encuentra: El cliente ha sido revocado o nunca fue autorizado - Si falla el descifrado: Datos corruptos o claves incorrectas (extremadamente raro) - Los clientes deberían volver a obtener los datos periódicamente para detectar la revocación\nAutorización de cliente mediante PSK (clave precompartida) Descripción general: Cada cliente tiene una clave simétrica de 32 bytes precompartida. El servidor cifra el mismo authCookie usando el PSK (clave precompartida) de cada cliente.\nGeneración de claves # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel Nota de seguridad: La misma PSK puede compartirse entre varios clientes si se desea (crea una autorización de \u0026ldquo;grupo\u0026rdquo;).\nProcesamiento del servidor # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Estructura de datos de la capa 1:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Procesamiento del cliente # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Comparación y recomendaciones Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access **Recomendación:** - **Utiliza DH authorization (autorización DH)** para aplicaciones de alta seguridad donde el secreto hacia adelante es importante - **Utiliza PSK authorization (autorización con clave precompartida)** cuando el rendimiento es crítico o cuando se gestionan grupos de clientes - **Nunca reutilices PSKs** entre distintos servicios ni en diferentes períodos de tiempo - **Utiliza siempre canales seguros** para la distribución de claves (p. ej., Signal, OTR, PGP) Consideraciones de seguridad Privacidad de la membresía del cliente:\nAmbos mecanismos proporcionan privacidad respecto a la pertenencia de clientes mediante: 1. Identificadores de cliente cifrados: clientID de 8 bytes derivado de la salida de HKDF 2. Cookies indistinguibles: Todos los valores clientCookie de 32 bytes parecen aleatorios 3. Sin metadatos específicos del cliente: No hay manera de identificar qué entrada pertenece a qué cliente\nUn observador puede ver: - Número de clientes autorizados (del campo clients) - Cambios en la cantidad de clientes a lo largo del tiempo\nUn observador NO PUEDE ver: - Qué clientes específicos están autorizados - Cuándo se añaden o se eliminan clientes específicos (si el recuento se mantiene igual) - Cualquier información que identifique a un cliente\nRecomendaciones de aleatorización:\nLos servidores DEBERÍAN aleatorizar el orden de los clientes cada vez que generen un LeaseSet cifrado:\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order Beneficios: - Evita que los clientes conozcan su posición en la lista - Evita ataques de inferencia basados en cambios de posición - Hace que la adición/revocación de clientes sea indistinguible\nOcultación del recuento de clientes:\nLos servidores PUEDEN insertar entradas ficticias aleatorias:\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) Costo: Las entradas ficticias incrementan el tamaño del LeaseSet cifrado (40 bytes cada una).\nRotación de AuthCookie:\nLos servidores DEBERÍAN generar un nuevo authCookie: - Cada vez que se publique un LeaseSet cifrado (típicamente cada pocas horas) - Inmediatamente después de revocar a un cliente - En un horario regular (p. ej., diariamente), aunque no cambie ningún cliente\nBeneficios: - Limita la exposición si se compromete authCookie - Garantiza que los clientes revocados pierdan el acceso rápidamente - Proporciona secreto perfecto hacia adelante para la Capa 2\nDireccionamiento Base32 para LeaseSets cifrados Descripción general Las direcciones base32 tradicionales de I2P contienen únicamente el hash del Destino (32 bytes → 52 caracteres). Esto es insuficiente para LeaseSets cifrados porque:\nLos clientes necesitan la clave pública no cegada para derivar la clave pública cegada Los clientes necesitan los tipos de firma (no cegada y cegada) para derivar correctamente las claves El hash por sí solo no proporciona esta información Solución: Un nuevo formato base32 que incluye la clave pública y los tipos de firma.\nEspecificación del formato de direcciones Estructura decodificada (35 bytes):\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ Primeros 3 bytes (XOR con suma de verificación):\nLos primeros 3 bytes contienen metadatos combinados mediante XOR con partes de una suma de verificación CRC-32:\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey Propiedades de la suma de verificación: - Usa el polinomio CRC-32 estándar - Tasa de falsos negativos: ~1 en 16 millones - Proporciona detección de errores ante errores tipográficos en direcciones - No puede usarse como autenticación (no es criptográficamente seguro)\nFormato codificado:\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; Características: - Total de caracteres: 56 (35 bytes × 8 bits ÷ 5 bits por carácter) - Sufijo: \u0026ldquo;.b32.i2p\u0026rdquo; (igual que el base32 tradicional) - Longitud total: 56 + 8 = 64 caracteres (excluyendo el terminador nulo)\nCodificación Base32: - Alfabeto: abcdefghijklmnopqrstuvwxyz234567 (estándar RFC 4648) - Los 5 bits no utilizados al final DEBEN ser 0 - No distingue mayúsculas de minúsculas (por convención en minúsculas)\nGeneración de direcciones import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address Análisis de direcciones import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype Comparación con Base32 tradicional Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations ### Restricciones de uso Incompatibilidad con BitTorrent:\nLas direcciones LS2 (LeaseSet2, segunda generación de LeaseSet) cifradas NO PUEDEN utilizarse con las respuestas compactas del announce de BitTorrent:\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ Problema: El formato compacto solo contiene el hash (32 bytes), sin espacio para tipos de firma ni información de clave pública.\nSolución: Use respuestas completas de announce (endpoint de anuncio del rastreador) o rastreadores basados en HTTP que admitan direcciones completas.\nIntegración de la libreta de direcciones Si un cliente tiene el Destino completo en una libreta de direcciones:\nAlmacenar el Destination (identificador de destino en I2P) completo (incluye la clave pública) Admitir búsqueda inversa por hash Cuando se encuentre un LS2 (LeaseSet 2, formato de leaseSet de segunda generación) cifrado, recuperar la clave pública desde la libreta de direcciones No es necesario un nuevo formato base32 si el Destination completo ya se conoce Formatos de libreta de direcciones que admiten LS2 cifrado: - hosts.txt con cadenas de destino completas - bases de datos SQLite con columna de destino - formatos JSON/XML con datos de destino completos\nEjemplos de implementación Ejemplo 1: Generar dirección\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p Ejemplo 2: Analizar y validar\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) Ejemplo 3: Convertir desde Destination (destino de I2P)\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) Consideraciones de seguridad Privacidad: - La dirección Base32 revela la clave pública - Esto es intencionado y requerido por el protocolo - NO revela la clave privada ni compromete la seguridad - Las claves públicas son información pública por diseño\nResistencia a colisiones: - CRC-32 proporciona solo 32 bits de resistencia a colisiones - No es criptográficamente seguro (usar solo para detección de errores) - NO confíe en la suma de verificación para la autenticación - Aún se requiere la verificación completa del destino\nValidación de direcciones: - Siempre valide la suma de verificación antes de usarla - Rechace direcciones con tipos de firma no válidos - Verifique que la clave pública esté en la curva (específico de la implementación)\nReferencias: - Propuesta 149: B32 para LS2 cifrado - Especificación de direccionamiento B32 - Especificación de nombres de I2P Soporte para claves sin conexión Descripción general Las claves fuera de línea permiten que la clave de firma principal se mantenga fuera de línea (almacenamiento en frío), mientras se utiliza una clave de firma temporal para las operaciones diarias. Esto es crítico para servicios de alta seguridad.\nRequisitos específicos de LS2 cifrado: - Las claves transitorias deben generarse sin conexión - Las claves privadas cegadas deben pre-generarse (una por día) - Tanto las claves transitorias como las cegadas se entregan en lotes - Aún no se ha definido un formato de archivo estandarizado (TODO en la especificación)\nEstructura de la clave fuera de línea Datos de clave efímera de la capa 0 (cuando el bit 0 de la bandera = 1):\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ Cobertura de la firma: La firma en el bloque de clave fuera de línea abarca: - Marca de tiempo de expiración (4 bytes) - Tipo de firma transitoria (2 bytes) - Clave pública de firma transitoria (variable)\nEsta firma se verifica mediante la clave pública cegada, lo que demuestra que la entidad con la clave privada cegada autorizó esta clave efímera.\nProceso de generación de claves Para LeaseSet cifrado con claves fuera de línea:\nGenerar pares de claves efímeros (sin conexión, en almacenamiento en frío):\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\nPara cada día for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026quot;%Y%m%d\u0026quot;) # \u0026quot;YYYYMMDD\u0026quot; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) 3. **Sign transient keys with blinded keys** (offline): ```python for date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router: Para cada fecha delivery_package[date] = { 'transient_privkey': keys[date][0], 'transient_pubkey': keys[date][1], 'blinded_privkey': blinded_keys[date][0], 'blinded_pubkey': blinded_keys[date][1], 'offline_sig_block': offline_sig_blocks[date] }\n### Router Usage **Daily Key Loading:** ```python # A medianoche UTC (o antes de publicar) date = datetime.utcnow().date() # Cargar claves para hoy today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # Utilice estas claves para el LeaseSet cifrado de hoy Publishing Process:\n# 1. Crear LeaseSet2 (segunda generación del formato LeaseSet de I2P) interno inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. Cifrar la capa 2 layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. Crear la Capa 1 con datos de autorización layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. Cifrar la capa 1 layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. Crear la Capa 0 con un bloque de firma sin conexión layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ) # 6. Firmar la Capa 0 con una clave privada efímera signature = RED25519_SIGN(transient_privkey, layer0) # 7. Añade la firma y publica encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# Generar todos los días tanto nuevas claves temporales como nuevas claves cegadas for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - Lote de material de claves cifrado - Rango de fechas cubierto OFFLINE_KEY_STATUS - Número de días restantes - Próxima fecha de expiración de la clave REVOKE_OFFLINE_KEYS - Rango de fechas a revocar - Nuevas claves para reemplazar (opcional) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p Key Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# Habilitar LeaseSet cifrado i2cp.encryptLeaseSet=true # Opcional: Habilitar la autorización de clientes i2cp.enableAccessList=true # Opcional: Usar autorización DH (el valor predeterminado es PSK) i2cp.accessListType=0 # Opcional: Secreto de cegado (altamente recomendado) i2cp.blindingSecret=your-secret-here API Usage Example:\n// Crear LeaseSet cifrado EncryptedLeaseSet els = new EncryptedLeaseSet(); // Establecer destino els.setDestination(destination); // Habilitar la autorización por cliente els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // Agregar clientes autorizados (claves públicas DH) for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // Configura los parámetros de blinding (cegado criptográfico) els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // Firmar y publicar els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd Key Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Habilitar LeaseSet cifrado encryptleaseset = true # Opcional: tipo de autorización del cliente (0=DH, 1=PSK) authtype = 0 # Opcional: Blinding secret (secreto utilizado en blinding, técnica criptográfica de cegado) secret = tu-secreto-aquí # Opcional: Clientes autorizados (uno por línea, claves públicas codificadas en base64) client.1 = base64-encoded-client-pubkey-1 client.2 = base64-encoded-client-pubkey-2 API Usage Example:\n// Crear LeaseSet cifrado auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // Habilitar la autorización por cliente encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // Agregar clientes autorizados for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // Sign and publish encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# Vector de prueba 1: cegado de clave destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # Esperado: (verificar frente a la implementación de referencia) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets Red25519 Specification - Detailed Red25519 implementation B32 Addressing Specification - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # Punto base de Ed25519 (generador) B = 2**255 - 19 # Orden de Ed25519 (tamaño del campo escalar) L = 2**252 + 27742317777372353535851937790883648493 # Valores del tipo de firma SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # Tamaños de clave PRIVKEY_SIZE = 32 # bytes PUBKEY_SIZE = 32 # bytes SIGNATURE_SIZE = 64 # bytes ChaCha20 Constants # Parámetros de ChaCha20 CHACHA20_KEY_SIZE = 32 # bytes (256 bits) CHACHA20_NONCE_SIZE = 12 # bytes (96 bits) CHACHA20_INITIAL_COUNTER = 1 # RFC 7539 permite 0 o 1 HKDF Constants # Parámetros de HKDF HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # bytes (HashLen) # Cadenas \u0026#39;info\u0026#39; de HKDF (separación de dominios) HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # Cadenas de personalización de SHA-256 HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # Tamaños de la capa 0 (externa) BLINDED_SIGTYPE_SIZE = 2 # bytes BLINDED_PUBKEY_SIZE = 32 # bytes (para Red25519) PUBLISHED_TS_SIZE = 4 # bytes EXPIRES_SIZE = 2 # bytes FLAGS_SIZE = 2 # bytes LEN_OUTER_CIPHER_SIZE = 2 # bytes SIGNATURE_SIZE = 64 # bytes (Red25519) # Tamaños de bloques de claves sin conexión OFFLINE_EXPIRES_SIZE = 4 # bytes OFFLINE_SIGTYPE_SIZE = 2 # bytes OFFLINE_SIGNATURE_SIZE = 64 # bytes # Tamaños de la capa 1 (intermedia) AUTH_FLAGS_SIZE = 1 # byte EPHEMERAL_PUBKEY_SIZE = 32 # bytes (autenticación DH) AUTH_SALT_SIZE = 32 # bytes (autenticación PSK) NUM_CLIENTS_SIZE = 2 # bytes CLIENT_ID_SIZE = 8 # bytes CLIENT_COOKIE_SIZE = 32 # bytes AUTH_CLIENT_ENTRY_SIZE = 40 # bytes (CLIENT_ID + CLIENT_COOKIE) # Sobrecarga del cifrado SALT_SIZE = 32 # bytes (antepuesto a cada capa cifrada) # Dirección Base32 B32_ENCRYPTED_DECODED_SIZE = 35 # bytes B32_ENCRYPTED_ENCODED_LEN = 56 # caracteres B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# Clave pública del destino (Ed25519) A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # Secreto vacío Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 bytes salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) mod L Expected Output:\n(Verifique frente a la implementación de referencia) alpha = [valor hexadecimal de 64 bytes] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nciphertext = [verificar contra los vectores de prueba del RFC 7539] Test Vector 3: HKDF Input:\nsalt = bytes(32) # De todos ceros ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [valor hexadecimal de 44 bytes] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32 bytes unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\naddress = [56 caracteres base32].b32.i2p # Verifique que la suma de verificación sea válida Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"Formato de LeaseSet con control de acceso para Destinos privados","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"LeaseSet cifrado","url":"/es/docs/specs/encryptedleaseset/"},{"categories":null,"content":"Como requiere nuestro modelo de amenazas (entre otras razones), el software desarrollado para soportar la red de comunicación anónima que llamamos I2P debe estar disponible libremente, ser de código abierto y modificable por el usuario. Para cumplir con estos criterios, hacemos uso de una variedad de técnicas legales y de ingeniería de software con el fin de eliminar tantas barreras de entrada como sea posible para aquellos que consideren hacer uso de I2P o contribuir al proyecto.\nAunque la información a continuación puede ser más confusa que simplemente decir \u0026ldquo;I2P es BSD\u0026rdquo;, \u0026ldquo;I2P es GPL\u0026rdquo; o \u0026ldquo;I2P es de dominio público\u0026rdquo;, la respuesta corta a la pregunta \u0026ldquo;¿Cómo está licenciado I2P?\u0026rdquo; es esta:\nTodo el software incluido en las distribuciones de I2P permitirá: uso sin cargo uso sin restricciones sobre cómo, cuándo, dónde, por qué o quién lo ejecuta acceso al código fuente sin cargo modificaciones al código fuente La mayoría del software garantiza mucho más: la capacidad de cualquiera para distribuir el código fuente modificado como desee. Sin embargo, no todo el software incluido proporciona esta libertad - la GPL restringe la capacidad de los desarrolladores que desean integrar I2P con sus propias aplicaciones que no son en sí mismas aplicaciones de código abierto. Si bien aplaudimos los nobles objetivos de aumentar los recursos en los bienes comunes, I2P se beneficia mejor eliminando cualquier barrera que obstaculice su adopción - si un desarrollador que está considerando si puede integrar I2P con su aplicación tiene que detenerse y consultar con su abogado, o realizar una auditoría de código para asegurarse de que su propio código fuente pueda publicarse como compatible con GPL, perdemos oportunidades.\nLicencias de componentes La distribución de I2P contiene varios recursos, reflejando la partición del código fuente en componentes. Cada componente tiene su propia licencia, con la cual todos los desarrolladores que contribuyen a él están de acuerdo - ya sea declarando explícitamente la liberación del código comprometido bajo una licencia compatible con ese componente, o liberando implícitamente el código comprometido bajo la licencia principal del componente. Cada uno de estos componentes tiene un desarrollador líder que tiene la última palabra en cuanto a qué licencia es compatible con la licencia principal del componente, y el gestor del proyecto I2P tiene la última palabra en cuanto a qué licencias cumplen las cuatro garantías mencionadas anteriormente para su inclusión en la distribución de I2P.\nComponent Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD, Cryptix, MIT zzz I2P Router router router.jar Public domain BSD, Cryptix, MIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain, Cryptix, MIT zzz Streaming apps/streaming streaming.jar Public domain BSD, Cryptix, MIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain, BSD, Cryptix, MIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain — zzz Address Book apps/addressbook addressbook.war MIT Public domain, Cryptix, BSD — Susidns apps/susidns susidns.war GPL + exception — — Susimail apps/susimail susimail.war GPL + exception — — I2PSnark apps/i2psnark i2psnark.jar GPL + exception — zzz [BOB](/docs/legacy/bob/) Bridge apps/BOB BOB.jar WTFPL — sponge [SAM](/docs/api/samv3/) Bridge apps/sam sam.jar Public domain Cryptix, BSD, MIT zzz [SAM v1](/docs/legacy/sam/) Perl library apps/sam/perl SAM.pm GPL Public domain, Cryptix, BSD, MIT BrianR [SAM v1](/docs/legacy/sam/) C library apps/sam/c libSAM BSD Public domain, Cryptix, MIT Nightblade [SAM v1](/docs/legacy/sam/) Python library apps/sam/python i2p.py Public domain BSD, Cryptix, MIT Connelly [SAM v1](/docs/legacy/sam/) C# library apps/sam/csharp/ n/a Public domain BSD, Cryptix, MIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source — — Installer installer install.jar, guiinstall.jar Public domain GPL + exception, BSD, Cryptix, MIT — Excepción GPL Si bien puede ser redundante, solo para mayor claridad, el código con licencia GPL incluido en I2PTunnel y otras aplicaciones debe publicarse bajo la GPL con una \u0026ldquo;excepción\u0026rdquo; adicional que autorice explícitamente el uso de las bibliotecas estándar de Java:\nIn addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version. Todo el código fuente bajo cada componente estará licenciado por defecto bajo la licencia principal, a menos que se indique lo contrario en el código. Todo lo anterior es un resumen de los términos de la licencia - por favor consulte la licencia específica del componente o código fuente en cuestión para los términos oficiales. Las ubicaciones de origen de los componentes y el empaquetado de recursos pueden cambiar si el repositorio se reorganiza.\nLicencia del Sitio Web Excepto donde se indique lo contrario, el contenido de este sitio está licenciado bajo una Licencia Creative Commons Atribución-CompartirIgual 4.0 Internacional .\nAcceso de Commit Los desarrolladores pueden enviar cambios a un repositorio git distribuido si reciben permiso de la persona que administra ese repositorio. Consulta la Guía para Nuevos Desarrolladores para más detalles.\nSin embargo, para que los cambios se incluyan en una versión, los desarrolladores deben ser confiables para el gestor de lanzamientos (actualmente zzz). Además, deben estar explícitamente de acuerdo con los términos anteriores para ser confiables. Esto significa que deben enviar a uno de los gestores de lanzamientos un mensaje firmado afirmando que:\nA menos que se indique lo contrario, todo el código que envío está implícitamente licenciado bajo la licencia principal del componente Si se especifica en el código fuente, el código puede estar explícitamente licenciado bajo una de las licencias alternativas del componente Tengo el derecho de publicar el código que envío bajo los términos con los que lo estoy enviando Si alguien tiene conocimiento de algún caso en el que no se cumplan las condiciones anteriores, por favor contacte al responsable del componente y/o a un administrador de lanzamientos de I2P con más información.\n","description":"Política de licencias y licencias de componentes para el software incluido con I2P","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"Licencias de Software de I2P","url":"/es/docs/develop/licenses/"},{"categories":null,"content":" Obsoleto: La biblioteca ministreaming es anterior a la biblioteca de streaming actual. Las aplicaciones modernas deben usar la API de streaming completa o SAM v3. La información a continuación se conserva para desarrolladores que revisan código fuente heredado distribuido en ministreaming.jar.\nDescripción general Ministreaming (protocolo ligero de flujo fiable) se ejecuta sobre I2CP para proporcionar entrega fiable y en orden a través de la capa de mensajes de I2P—de forma similar a TCP sobre IP. Originalmente se separó de la aplicación I2PTunnel en sus primeras etapas (con licencia BSD) para que los transportes alternativos pudieran evolucionar de manera independiente.\nRestricciones clave de diseño:\nEstablecimiento de conexión clásico en dos fases (SYN/ACK/FIN) tomado de TCP Tamaño de ventana fijo de 1 paquete Sin identificadores por paquete ni acuses de recibo selectivos Estas decisiones mantuvieron la implementación pequeña, pero limitan el rendimiento—cada paquete suele esperar casi dos RTT (tiempo de ida y vuelta) antes de que se envíe el siguiente. Para flujos de larga duración la penalización es aceptable, pero los intercambios cortos al estilo HTTP se resienten notablemente.\nRelación con la biblioteca de streaming La biblioteca de streaming actual continúa en el mismo paquete de Java (net.i2p.client.streaming). Las clases y métodos obsoletos permanecen en los Javadocs, claramente anotados para que los desarrolladores puedan identificar las APIs de la era de ministreaming. Cuando la biblioteca de streaming reemplazó a ministreaming (biblioteca de streaming anterior), añadió:\nEstablecimiento de conexión más inteligente con menos viajes de ida y vuelta Ventanas de congestión adaptativas y lógica de retransmisión Mejor rendimiento en tunnels con pérdidas ¿Cuándo fue útil Ministreaming (minitransmisión)? A pesar de sus límites, ministreaming (implementación mínima de streaming) proporcionó un transporte fiable en los primeros despliegues. La API era deliberadamente pequeña y preparada para el futuro, de modo que se pudieran sustituir motores de streaming alternativos sin romper la compatibilidad con los consumidores de la API. Las aplicaciones Java lo enlazaban directamente; los clientes no Java accedían a la misma funcionalidad mediante la compatibilidad de SAM con sesiones de streaming.\nActualmente, considere ministreaming.jar únicamente como una capa de compatibilidad. El nuevo desarrollo debería:\nUtiliza la biblioteca de streaming completa (Java) o SAM v3 (estilo STREAM) Elimina cualquier suposición persistente de ventana fija al modernizar el código Prefiere tamaños de ventana más grandes y negociaciones de conexión optimizadas para mejorar cargas de trabajo sensibles a la latencia Referencia Documentación de la biblioteca Streaming Javadoc de Streaming – incluye clases de ministreaming obsoletas Especificación de SAM v3 – soporte de streaming para aplicaciones no Java Si te encuentras con código que aún depende de ministreaming (API de streaming antigua), planea portarlo a la API de streaming moderna: la red y sus herramientas esperan el comportamiento más reciente.\n","description":"Notas históricas sobre la primera capa de transporte de tipo TCP de I2P","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"Ministreaming Library (biblioteca de streaming minimalista)","url":"/es/docs/legacy/ministreaming/"},{"categories":null,"content":"1. Qué Significa \u0026ldquo;Anónimo\u0026rdquo; I2P proporciona anonimato práctico—no invisibilidad. El anonimato se define como la dificultad para un adversario de obtener información que deseas mantener privada: quién eres, dónde estás o con quién hablas. El anonimato absoluto es imposible; en su lugar, I2P busca lograr anonimato suficiente frente a adversarios pasivos y activos globales.\nTu anonimato depende de cómo configures I2P, cómo elijas peers y suscripciones, y qué aplicaciones expongas.\n2. Evolución Criptográfica y de Transporte (2003 → 2025) Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental **Suite criptográfica actual (Noise XK):** - **X25519** para intercambio de claves - **ChaCha20/Poly1305 AEAD** para cifrado - **Ed25519 (EdDSA-SHA512)** para firmas - **SHA-256** para hashing y HKDF - **Híbridos ML-KEM** opcionales para pruebas post-cuánticas Todos los usos de ElGamal y AES-CBC han sido retirados. El transporte es enteramente NTCP2 (TCP) y SSU2 (UDP); ambos soportan IPv4/IPv6, forward secrecy (secreto hacia adelante) y ofuscación DPI.\n3. Resumen de la Arquitectura de Red Mixnet de ruta libre: Los remitentes y receptores definen sus propios tunnels. Sin autoridad central: El enrutamiento y el nombramiento están descentralizados; cada router mantiene confianza local. Tunnels unidireccionales: Los entrantes y salientes son separados (ciclos de vida de 10 min). Tunnels exploratorios: 2 saltos por defecto; tunnels de cliente de 2–3 saltos. Routers floodfill: ~1 700 de ~55 000 nodos (~6 %) mantienen el NetDB distribuido. Rotación de NetDB: El espacio de claves rota diariamente a medianoche UTC. Aislamiento de sub-BD: Desde la versión 2.4.0, cada cliente y router utilizan bases de datos separadas para evitar la vinculación. 4. Categorías de Ataques y Defensas Actuales Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. --- 5. Base de Datos de Red Moderna (NetDB) Datos fundamentales (aún vigentes): - DHT Kademlia modificado almacena RouterInfo y LeaseSets. - Hash de clave SHA-256; consultas paralelas a los 2 floodfills más cercanos con tiempo de espera de 10 s. - Vida útil de LeaseSet ≈ 10 min (LeaseSet2) o 18 h (MetaLeaseSet).\nNuevos tipos (desde 0.9.38): - LeaseSet2 (Tipo 3) – múltiples tipos de cifrado, con marca de tiempo. - EncryptedLeaseSet2 (Tipo 5) – destino ofuscado para servicios privados (autenticación DH o PSK). - MetaLeaseSet (Tipo 7) – multialojamiento y expiraciones extendidas.\nActualización de seguridad importante – Aislamiento de Sub-DB (2.4.0): - Previene la asociación router↔cliente. - Cada cliente y router utilizan segmentos netDb separados. - Verificado y auditado (2.5.0).\n6. Modo Oculto y Rutas Restringidas Modo Oculto: Implementado (automático en países estrictos según puntuaciones de Freedom House).\nLos routers no publican RouterInfo ni enrutan tráfico. Rutas Restringidas: Parcialmente implementado (túneles básicos solo de confianza).\nEl enrutamiento integral de peers de confianza permanece planificado (3.0+). Compromiso: Mejor privacidad ↔ menor contribución a la capacidad de la red.\n7. Ataques DoS y Floodfill Histórico: Una investigación de UCSB en 2013 demostró que los ataques Eclipse y la toma de control de Floodfill eran posibles. Las defensas modernas incluyen: - Rotación diaria del espacio de claves. - Límite de Floodfill ≈ 500, uno por /16. - Retrasos aleatorios de verificación de almacenamiento. - Preferencia por routers más nuevos (2.6.0). - Corrección de inscripción automática (2.9.0). - Enrutamiento consciente de congestión y limitación de lease (2.4.0+).\nLos ataques floodfill siguen siendo teóricamente posibles pero prácticamente más difíciles.\n8. Análisis de Tráfico y Censura El tráfico I2P es difícil de identificar: sin puerto fijo, sin handshake en texto plano y relleno aleatorio. Los paquetes NTCP2 y SSU2 imitan protocolos comunes y usan ofuscación de encabezado ChaCha20. Las estrategias de relleno son básicas (tamaños aleatorios), el tráfico ficticio no está implementado (costoso). Las conexiones desde nodos de salida Tor están bloqueadas desde la versión 2.6.0 (para proteger recursos).\n9. Limitaciones Persistentes (reconocidas) La correlación de tiempo para aplicaciones de baja latencia sigue siendo un riesgo fundamental. Los ataques de intersección siguen siendo poderosos contra destinos públicos conocidos. Los ataques Sybil carecen de defensa completa (HashCash no se aplica). El tráfico de tasa constante y los retrasos no triviales permanecen sin implementar (planificados para 3.0). La transparencia sobre estos límites es intencional — evita que los usuarios sobreestimen el anonimato.\n10. Estadísticas de Red (2025) ~55 000 routers activos en todo el mundo (↑ desde 7 000 en 2013) ~1 700 routers floodfill (~6 %) 95 % participa en enrutamiento de túneles por defecto Niveles de ancho de banda: K (\u0026lt;12 KB/s) → X (\u0026gt;2 MB/s) Tasa mínima floodfill: 128 KB/s Consola del router Java 8+ (requerido), Java 17+ planificado para el próximo ciclo 11. Desarrollo y Recursos Centrales Sitio oficial: geti2p.net Documentación: Documentation Repositorio Debian: https://deb.i2pgit.org ( reemplazó deb.i2p2.de en Oct 2023 ) Código fuente: https://i2pgit.org/I2P_Developers/i2p.i2p (Gitea) + espejo GitHub Todas las versiones son contenedores SU3 firmados (RSA-4096, claves zzz/str4d) Sin listas de correo activas; comunidad vía https://i2pforum.net e IRC2P. Ciclo de actualizaciones: versiones estables cada 6–8 semanas. 12. Resumen de Mejoras de Seguridad Desde 0.8.x Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing --- 13. Trabajo Conocido No Resuelto o Planificado Rutas restringidas completas (enrutamiento de pares confiables) → planificado 3.0. Retardo/agrupamiento no trivial para resistencia de temporización → planificado 3.0. Relleno avanzado y tráfico ficticio → no implementado. Verificación de identidad HashCash → la infraestructura existe pero está inactiva. Reemplazo R5N DHT → solo propuesta. 14. Referencias Clave Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) Documentación Oficial de I2P 15. Conclusión El modelo central de anonimato de I2P se ha mantenido durante dos décadas: sacrificar la unicidad global por la confianza y seguridad locales. Desde ElGamal a X25519, NTCP a NTCP2, y desde reseeds manuales hasta el aislamiento de Sub-DB, el proyecto ha evolucionado manteniendo su filosofía de defensa en profundidad y transparencia.\nMuchos ataques siguen siendo teóricamente posibles contra cualquier mixnet de baja latencia, pero el fortalecimiento continuo de I2P los hace cada vez más impracticables. La red es más grande, más rápida y más segura que nunca, pero sigue siendo honesta acerca de sus límites.\n","description":"Catálogo de ataques considerados en el diseño de I2P y las mitigaciones implementadas","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"Modelo de Amenazas de I2P","url":"/es/docs/overview/threat-model/"},{"categories":null,"content":"Las direcciones I2P son claves criptográficas largas. El sistema de nombres proporciona una capa más amigable sobre esas claves sin introducir una autoridad central. Todos los nombres son locales: cada router decide de forma independiente a qué destino se refiere un nombre de host.\n¿Necesitas contexto? La discusión sobre nombres documenta los debates de diseño originales, propuestas alternativas y fundamentos filosóficos detrás del sistema de nombres descentralizado de I2P.\n1. Componentes La capa de nombres de I2P está compuesta por varios subsistemas independientes pero cooperantes:\nServicio de nombres – resuelve nombres de host a destinos y maneja nombres de host Base32 . Proxy HTTP – pasa las búsquedas .i2p al router y sugiere servicios jump cuando un nombre es desconocido. Servicios host-add – formularios estilo CGI que añaden nuevas entradas en la libreta de direcciones local. Servicios jump – ayudantes remotos que devuelven el destino para un nombre de host proporcionado. Libreta de direcciones – obtiene y fusiona periódicamente listas de hosts remotas usando una \u0026ldquo;red de confianza\u0026rdquo; localmente confiable. SusiDNS – una interfaz web para gestionar libretas de direcciones, suscripciones y anulaciones locales. Este diseño modular permite a los usuarios definir sus propios límites de confianza y automatizar tanto o tan poco del proceso de nomenclatura como prefieran.\n2. Servicios de Nombres La API de nombres del router (net.i2p.client.naming) soporta múltiples backends a través de la propiedad configurable i2p.naming.impl=\u0026lt;class\u0026gt;. Cada implementación puede ofrecer diferentes estrategias de búsqueda, pero todas comparten el mismo modelo de confianza y resolución.\n2.1 Hosts.txt (legacy format) El modelo heredado utilizaba tres archivos de texto plano verificados en orden:\nprivatehosts.txt userhosts.txt hosts.txt Cada línea almacena un mapeo hostname=base64-destination. Este formato de texto simple sigue siendo totalmente compatible para importar/exportar, pero ya no es el predeterminado debido al bajo rendimiento una vez que la lista de hosts supera unos pocos miles de entradas.\n2.2 Blockfile Naming Service (default backend) Introducido en la versión 0.8.8, el Blockfile Naming Service es ahora el backend predeterminado. Reemplaza los archivos planos con un almacén de clave/valor en disco de alto rendimiento basado en skiplist (hostsdb.blockfile) que ofrece búsquedas aproximadamente 10× más rápidas.\nCaracterísticas clave: - Almacena múltiples libretas de direcciones lógicas (privada, usuario y hosts) en una base de datos binaria. - Mantiene compatibilidad con importación/exportación del formato heredado hosts.txt. - Admite búsquedas inversas, metadatos (fecha de agregado, origen, comentarios) y caché eficiente. - Utiliza el mismo orden de búsqueda de tres niveles: privada → usuario → hosts.\nEste enfoque preserva la compatibilidad con versiones anteriores mientras mejora drásticamente la velocidad de resolución y la escalabilidad.\n2.1 Hosts.txt (formato heredado) Los desarrolladores pueden implementar backends personalizados tales como: - Meta – agrega múltiples sistemas de nombres. - PetName – soporta petnames almacenados en un petnames.txt. - AddressDB, Exec, Eepget, y Dummy – para resolución externa o de respaldo.\nLa implementación de blockfile sigue siendo el backend recomendado para uso general debido a su rendimiento y confiabilidad.\n3. Base32 Hostnames Los nombres de host Base32 (*.b32.i2p) funcionan de manera similar a las direcciones .onion de Tor. Cuando accedes a una dirección .b32.i2p:\nEl router decodifica la carga útil Base32. Reconstruye el destino directamente desde la clave—no se requiere búsqueda en la libreta de direcciones. Esto garantiza la accesibilidad incluso si no existe un nombre de host legible por humanos. Los nombres Base32 extendidos introducidos en la versión 0.9.40 admiten LeaseSet2 y destinos cifrados.\n4. Address Book \u0026amp; Subscriptions La aplicación de libreta de direcciones recupera listas de hosts remotos a través de HTTP y las fusiona localmente según las reglas de confianza configuradas por el usuario.\n2.2 Servicio de Nombres Blockfile (backend predeterminado) Las suscripciones son URLs .i2p estándar que apuntan a hosts.txt o feeds de actualización incremental. Las actualizaciones se obtienen periódicamente (cada hora por defecto) y se validan antes de fusionarse. Los conflictos se resuelven por orden de llegada, siguiendo el orden de prioridad:\nprivatehosts.txt → userhosts.txt → hosts.txt. Default Providers Desde I2P 2.3.0 (junio de 2023), se incluyen dos proveedores de suscripción predeterminados: - http://i2p-projekt.i2p/hosts.txt - http://notbob.i2p/hosts.txt\nEsta redundancia mejora la fiabilidad mientras preserva el modelo de confianza local. Los usuarios pueden agregar o eliminar suscripciones a través de SusiDNS.\nIncremental Updates Las actualizaciones incrementales se obtienen mediante newhosts.txt (reemplazando el concepto anterior de recenthosts.cgi). Este endpoint proporciona actualizaciones delta eficientes basadas en ETag, devolviendo solo las entradas nuevas desde la última solicitud o 304 Not Modified cuando no hay cambios.\n2.3 Backends Alternativos y Complementos Servicios Host-add (add*.cgi) permiten el envío manual de mapeos de nombre a destino. Verifica siempre el destino antes de aceptar. Servicios Jump responden con la clave apropiada y pueden redirigir a través del proxy HTTP con un parámetro ?i2paddresshelper=.\nEjemplos comunes: stats.i2p, identiguy.i2p, y notbob.i2p.\nEstos servicios no son autoridades de confianza—los usuarios deben decidir cuáles usar. 5. Managing Entries Locally (SusiDNS) SusiDNS está disponible en: http://127.0.0.1:7657/susidns/\nPuedes: - Ver y editar libretas de direcciones locales. - Gestionar y priorizar suscripciones. - Importar/exportar listas de hosts. - Configurar horarios de actualización.\nNuevo en I2P 2.8.1 (Marzo 2025): - Se agregó una función de \u0026ldquo;ordenar por más reciente\u0026rdquo;. - Se mejoró el manejo de suscripciones (corrección para inconsistencias de ETag).\nTodos los cambios permanecen locales: la libreta de direcciones de cada router es única.\n3. Nombres de Host Base32 Siguiendo la RFC 9476, I2P registró .i2p.alt con la GNUnet Assigned Numbers Authority (GANA) a partir de marzo de 2025 (I2P 2.8.1).\nPropósito: Prevenir filtraciones accidentales de DNS por software mal configurado.\nLos resolvers DNS conformes con RFC 9476 no reenviarán dominios .alt al DNS público. El software I2P trata .i2p.alt como equivalente a .i2p, eliminando el sufijo .alt durante la resolución. .i2p.alt no está destinado a reemplazar .i2p; es una medida de seguridad técnica, no un cambio de marca. 4. Libreta de Direcciones y Suscripciones Claves de destino: 516–616 bytes (Base64) Nombres de host: Máximo 67 caracteres (incluyendo .i2p) Caracteres permitidos: a–z, 0–9, -, . (sin puntos dobles, sin mayúsculas) Reservado: *.b32.i2p ETag y Last-Modified: utilizados activamente para minimizar el ancho de banda Tamaño promedio de hosts.txt: ~400 KB para ~800 hosts (cifra de ejemplo) Uso de ancho de banda: ~10 bytes/seg si se obtiene cada 12 horas 8. Security Model and Philosophy I2P intencionalmente sacrifica la unicidad global a cambio de descentralización y seguridad—una aplicación directa del Triángulo de Zooko.\nPrincipios clave: - Sin autoridad central: todas las búsquedas son locales. - Resistencia al secuestro de DNS: las consultas están cifradas hacia las claves públicas de destino. - Prevención de ataques Sybil: sin votación ni nomenclatura basada en consenso. - Mapeos inmutables: una vez que existe una asociación local, no puede ser anulada remotamente.\nLos sistemas de nombres basados en blockchain (por ejemplo, Namecoin, ENS) han explorado resolver los tres lados del triángulo de Zooko, pero I2P intencionalmente los evita debido a la latencia, complejidad e incompatibilidad filosófica con su modelo de confianza local.\n9. Compatibility and Stability No se han descontinuado funciones de nombres entre 2023–2025. El formato hosts.txt, servicios de salto, suscripciones y todas las implementaciones de la API de nombres permanecen funcionales. El Proyecto I2P mantiene una estricta compatibilidad hacia atrás mientras introduce mejoras de rendimiento y seguridad (aislamiento de NetDB, separación de Sub-DB, etc.). 10. Best Practices Mantén solo suscripciones de confianza; evita listas de hosts grandes y desconocidas. Haz una copia de seguridad de hostsdb.blockfile y privatehosts.txt antes de actualizar o reinstalar. Revisa regularmente los servicios de salto y desactiva aquellos en los que ya no confíes. Recuerda: tu libreta de direcciones define tu versión del mundo I2P—cada nombre de host es local. Further Reading Discusión sobre Naming Especificación de Blockfile Formato del Archivo de Configuración Javadoc del Servicio de Naming ","description":"Cómo I2P mapea nombres de host legibles por humanos a destinos","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"Nomenclatura y Libreta de Direcciones","url":"/es/docs/overview/naming/"},{"categories":null,"content":"Esta implementación de I2P (la implementación en Java distribuida en este sitio) incluye una \u0026ldquo;Lista de Países Estrictos\u0026rdquo; utilizada para ajustar el comportamiento del router en regiones donde participar en el enrutamiento para otros puede estar restringido por ley. Si bien no tenemos conocimiento de jurisdicciones que prohíban el uso de I2P, varias tienen prohibiciones amplias sobre la retransmisión de tráfico. Los routers que parecen estar en países \u0026ldquo;estrictos\u0026rdquo; se colocan automáticamente en modo Oculto.\nEl Proyecto hace referencia a investigaciones de organizaciones de derechos civiles y digitales al tomar estas decisiones. En particular, la investigación continua de Freedom House informa nuestras elecciones. La orientación general es incluir países con una puntuación de Libertades Civiles (CL) de 16 o menos, o una puntuación de Libertad en Internet de 39 o menos (no libres).\nResumen del Modo Oculto Cuando un router se coloca en modo Oculto (Hidden), tres aspectos clave cambian en su comportamiento:\nNo publica un RouterInfo en la netDb. No acepta túneles participantes. Rechaza conexiones directas a routers en el mismo país. Estas defensas hacen que los routers sean más difíciles de enumerar de manera confiable, y reducen el riesgo de violar prohibiciones locales sobre retransmitir tráfico para otros.\nLista de Países con Restricciones Estrictas (a partir de 2024) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; Si crees que un país debería añadirse o eliminarse de la lista estricta, por favor abre un issue: https://i2pgit.org/i2p/i2p.i2p/ Referencia: Freedom House – https://freedomhouse.org/ ","description":"Cómo se comporta I2P en jurisdicciones con restricciones sobre herramientas de enrutamiento o anonimato (Modo Oculto y lista estricta)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"Países Estrictos/Restrictivos","url":"/es/docs/overview/restrictive-countries/"},{"categories":null,"content":"Cuando las condiciones de red hacen que git clone no sea confiable, puedes distribuir repositorios como bundles de git a través de BitTorrent o cualquier otro transporte de archivos. Un bundle es un único archivo que contiene todo el historial del repositorio. Una vez descargado, obtienes los datos desde él localmente y luego vuelves a cambiar al remoto upstream.\n1. Antes de Comenzar Generar un bundle requiere un clon completo de Git. Los clones superficiales creados con --depth 1 producirán silenciosamente bundles rotos que parecen funcionar pero fallan cuando otros intentan usarlos. Siempre obtenga el código de una fuente confiable (GitHub en github.com/i2p/i2p.i2p , la instancia Gitea de I2P en i2pgit.org , o git.idk.i2p sobre I2P) y ejecute git fetch --unshallow si es necesario para convertir cualquier clon superficial en un clon completo antes de crear bundles.\nSi solo estás consumiendo un paquete existente, simplemente descárgalo. No se requiere ninguna preparación especial.\n2. Descargando un Bundle Obtaining the Bundle File Descarga el archivo bundle a través de BitTorrent usando I2PSnark (el cliente torrent integrado en I2P) u otros clientes compatibles con I2P como BiglyBT con el plugin de I2P.\nImportante: I2PSnark solo funciona con torrents creados específicamente para la red I2P. Los torrents estándar de clearnet no son compatibles porque I2P utiliza Destinations (direcciones de 387+ bytes) en lugar de direcciones IP y puertos.\nLa ubicación del archivo bundle depende de tu tipo de instalación de I2P:\nInstalaciones de usuario/manuales (instaladas con el instalador Java): ~/.i2p/i2psnark/ Instalaciones de sistema/daemon (instaladas mediante apt-get o gestor de paquetes): /var/lib/i2p/i2p-config/i2psnark/ Los usuarios de BiglyBT encontrarán los archivos descargados en su directorio de descargas configurado.\nCloning from the Bundle Método estándar (funciona en la mayoría de los casos):\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle Si encuentras errores fatal: multiple updates for ref (un problema conocido en Git 2.21.0 y versiones posteriores cuando la configuración global de Git contiene refspecs de fetch conflictivos), usa el enfoque de inicialización manual:\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle Alternativamente, puedes usar la bandera --update-head-ok:\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; Obtención del Archivo Bundle Después de clonar desde el bundle, apunta tu clon al remoto activo para que las futuras descargas se realicen a través de I2P o clearnet:\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p O para acceso a clearnet:\ngit remote set-url origin https://github.com/i2p/i2p.i2p Para acceso SSH a I2P, necesitas un túnel cliente SSH configurado en la consola de tu router I2P (típicamente puerto 7670) apuntando a g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p. Si usas un puerto no estándar:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle Clonación desde el Bundle Asegúrate de que tu repositorio esté completamente actualizado con un clon completo (no superficial):\ngit fetch --all Si tienes un clon superficial, conviértelo primero:\ngit fetch --unshallow Cambio al Remoto en Vivo Usando el objetivo de compilación de Ant (recomendado para el árbol de fuentes de I2P):\nant git-bundle Esto crea tanto i2p.i2p.bundle (el archivo bundle) como i2p.i2p.bundle.torrent (metadatos de BitTorrent).\nUsando git bundle directamente:\ngit bundle create i2p.i2p.bundle --all Para paquetes más selectivos:\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle Siempre verifica el paquete antes de distribuirlo:\ngit bundle verify i2p.i2p.bundle Esto confirma que el bundle es válido y muestra cualquier commit prerequisito requerido.\nRequisitos previos Copia el paquete y sus metadatos del torrent en tu directorio de I2PSnark:\nPara instalaciones de usuario:\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ Para instalaciones del sistema:\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ I2PSnark detecta y carga automáticamente archivos .torrent en cuestión de segundos. Accede a la interfaz web en http://127.0.0.1:7657/i2psnark para comenzar a compartir.\n4. Creating Incremental Bundles Para actualizaciones periódicas, crea bundles incrementales que contengan únicamente los nuevos commits desde el último bundle:\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master Los usuarios pueden obtener desde el paquete incremental si ya tienen el repositorio base:\ngit fetch /path/to/update.bundle Siempre verifica que los paquetes incrementales muestren los commits de requisitos previos esperados:\ngit bundle verify update.bundle 5. Updating After the Initial Clone Una vez que tengas un repositorio funcional a partir del paquete, trátalo como cualquier otro clon de Git:\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master O para flujos de trabajo más simples:\ngit fetch origin git pull origin master 3. Crear un Bundle Distribución resiliente: Los repositorios grandes pueden compartirse a través de BitTorrent, que maneja reintentos, verificación de piezas y reanudación automáticamente. Arranque peer-to-peer: Los nuevos colaboradores pueden arrancar su clon desde peers cercanos en la red I2P, y luego obtener cambios incrementales directamente desde los hosts de Git. Reducción de carga del servidor: Los mirrors pueden publicar bundles periódicos para aliviar la presión sobre los hosts de Git en vivo, especialmente útil para repositorios grandes o condiciones de red lentas. Transporte sin conexión: Los bundles funcionan con cualquier transporte de archivos (unidades USB, transferencias directas, sneakernet), no solo BitTorrent. Los bundles no reemplazan los remotos en vivo. Simplemente proporcionan un método de bootstrapping más resiliente para clones iniciales o actualizaciones importantes.\n7. Troubleshooting Generando el Bundle Problema: La creación del bundle tiene éxito pero otros no pueden clonar desde el bundle.\nCausa: Tu clon de origen es superficial (creado con --depth).\nSolución: Convertir a clon completo antes de crear bundles:\ngit fetch --unshallow Verificando tu Bundle Problema: fatal: multiple updates for ref al clonar desde bundle.\nCausa: Git 2.21.0+ entra en conflicto con las refspecs de fetch globales en ~/.gitconfig.\nSoluciones: 1. Usar inicialización manual: mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle 2. Usar la bandera --update-head-ok: git fetch --update-head-ok /path/to/bundle '*:*' 3. Eliminar la configuración conflictiva: git config --global --unset remote.origin.fetch\nDistribución a través de I2PSnark Problema: git bundle verify informa prerrequisitos faltantes.\nCausa: Bundle incremental o clonación de origen incompleta.\nSolución: Obtenga los commits prerequisito o use primero el bundle base, luego aplique las actualizaciones incrementales.\n","description":"Obtención y distribución de repositorios grandes con git bundle y BitTorrent","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"Paquetes Git para I2P","url":"/es/docs/applications/git-bundle/"},{"categories":null,"content":"Propósito: Mantener la coherencia, la precisión y la accesibilidad en toda la documentación técnica de I2P\nPrincipios fundamentales 1. Verifique todo Nunca asumas ni adivines. Todas las afirmaciones técnicas deben verificarse frente a: - Código fuente actual de I2P (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master ) - Documentación oficial de la API (https://i2p.github.io/i2p.i2p/ - Especificaciones de configuración /docs/specs/ - Notas de lanzamiento recientes /releases/ Ejemplo de verificación adecuada:\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. La claridad por encima de la brevedad Escribe para desarrolladores que quizá estén conociendo I2P por primera vez. Explica los conceptos por completo en lugar de asumir conocimientos previos.\nEjemplo:\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. Primero la accesibilidad La documentación debe ser accesible para los desarrolladores desde la clearnet (internet convencional) aunque I2P sea una superposición de red. Proporcione siempre alternativas accesibles desde la clearnet a los recursos internos de I2P.\nPrecisión técnica Documentación de la API y de la interfaz Incluye siempre: 1. Nombres de paquete completos en la primera mención: net.i2p.app.ClientApp 2. Firmas de métodos completas con tipos de retorno 3. Nombres y tipos de parámetros 4. Parámetros obligatorios vs opcionales\nEjemplo:\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. Propiedades de configuración Al documentar archivos de configuración: 1. Mostrar los nombres exactos de las propiedades 2. Especificar la codificación del archivo (UTF-8 para configuraciones de I2P) 3. Proporcionar ejemplos completos 4. Documentar los valores predeterminados 5. Indicar la versión en la que se introdujeron/cambiaron las propiedades\nEjemplo:\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) Constantes y enumeraciones Al documentar constantes, utiliza los nombres reales del código:\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; Distinguir entre conceptos similares I2P tiene varios sistemas superpuestos. Aclara siempre qué sistema estás documentando:\nEjemplo:\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations URLs y referencias de la documentación Reglas de accesibilidad de URL Referencias principales deben usar URLs accesibles desde la Internet abierta URLs internas de I2P (dominios .i2p) deben incluir notas de accesibilidad Proporcione siempre alternativas al enlazar recursos internos de I2P Plantilla para URLs internas de I2P:\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ URLs de referencia recomendadas para I2P Especificaciones oficiales: - Configuración - Complemento - Índice de documentación Documentación de la API (elige la más reciente): - Más reciente: https://i2p.github.io/i2p.i2p/ (API 0.9.66 a partir de I2P 2.10.0) - Espejo en clearnet (red abierta): https://eyedeekay.github.io/javadoc-i2p/ Código fuente: - GitLab (oficial): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master - Espejo en GitHub: https://github.com/i2p/i2p.i2p Normas de formato de enlaces ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text Seguimiento de versiones Metadatos del documento Todo documento técnico debe incluir metadatos de versión en el frontmatter (cabecera de metadatos):\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Definiciones de campos: - lastUpdated: Año-mes cuando el documento fue revisado/actualizado por última vez - accurateFor: Versión de I2P con la que se verificó el documento - reviewStatus: Uno de \u0026ldquo;draft\u0026rdquo;, \u0026ldquo;needs-review\u0026rdquo;, \u0026ldquo;verified\u0026rdquo;, \u0026ldquo;outdated\u0026rdquo;\nReferencias de versión en el contenido Al mencionar versiones: 1. Usa negrita para la versión actual: \u0026ldquo;versión 2.10.0 (septiembre de 2025)\u0026rdquo; 2. Especifica tanto el número de versión como la fecha para referencias históricas 3. Indica la versión de la API por separado de la versión de I2P cuando sea relevante\nEjemplo:\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. Documentación de los cambios a lo largo del tiempo Para las características que evolucionaron:\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients Avisos de obsolescencia Si se documentan características obsoletas:\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. Estándares de terminología Términos oficiales de I2P Usa estos términos exactos de manera consistente:\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address ### Terminología de clientes gestionados Al documentar clientes gestionados:\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory ### Terminología de configuración Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config ### Nombres de paquetes y clases Use siempre nombres completamente calificados en la primera mención, y nombres cortos en lo sucesivo:\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... Ejemplos de código y formato Ejemplos de código Java Utiliza un resaltado de sintaxis adecuado y ejemplos completos:\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` Requisitos del ejemplo de código: 1. Incluye comentarios que expliquen las líneas clave 2. Muestra el manejo de errores cuando sea pertinente 3. Utiliza nombres de variables realistas 4. Cumple con las convenciones de codificación de I2P (indentación de 4 espacios) 5. Muestra las importaciones si no son obvias por el contexto\nEjemplos de configuración Mostrar ejemplos completos y válidos de configuración:\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` Ejemplos de línea de comandos Usa $ para comandos de usuario, # para root:\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` Código en línea Usa comillas invertidas para: - Nombres de métodos: startup() - Nombres de clases: ClientApp - Nombres de propiedades: clientApp.0.main - Nombres de archivos: clients.config - Constantes: SVC_HTTP_PROXY - Nombres de paquetes: net.i2p.app\nTono y voz Profesional pero accesible Redacta para una audiencia técnica sin ser condescendiente:\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; Voz activa Usa la voz activa para mayor claridad:\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; Imperativos para instrucciones Usa imperativos directos en el contenido procedimental:\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; Evite la jerga innecesaria Explica los términos la primera vez que se usen:\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) Directrices de puntuación Sin guiones largos - use guiones normales, comas o punto y coma en su lugar Use la coma de Oxford en listas: \u0026ldquo;console, i2ptunnel, and Jetty\u0026rdquo; Puntos dentro de bloques de código solo cuando sea gramaticalmente necesario Listas en serie utilizan punto y coma cuando los elementos contienen comas Estructura del documento Orden estándar de secciones Para la documentación de la API:\nDescripción general - qué hace la característica, por qué existe Implementación - cómo implementarla/usarla Configuración - cómo configurarla Referencia de API - descripciones detalladas de métodos/propiedades Ejemplos - ejemplos completos y funcionales Mejores prácticas - consejos y recomendaciones Historial de versiones - cuándo se introdujo, cambios a lo largo del tiempo Referencias - enlaces a documentación relacionada Jerarquía de encabezados Utilice niveles de encabezado semánticos:\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** Cajas de información Utiliza citas en bloque para avisos especiales:\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. Listas y organización Listas no ordenadas para elementos no secuenciales:\n- First item - Second item - Third item Listas ordenadas para pasos secuenciales:\n1. First step 2. Second step 3. Third step Listas de definiciones para explicaciones de términos:\n**Term One** : Explanation of term one **Term Two** : Explanation of term two Errores comunes que se deben evitar 1. Confundir sistemas similares No confundir: - registro de ClientAppManager vs. PortMapper - tipos de tunnel de i2ptunnel vs. constantes del servicio de port mapper - ClientApp vs. RouterApp (contextos diferentes) - clientes gestionados vs. no gestionados\nAclara siempre de qué sistema estás hablando:\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. Referencias a versiones obsoletas No hagas: - Hacer referencia a versiones anteriores como \u0026ldquo;actuales\u0026rdquo; - Enlazar a documentación de la API desactualizada - Usar firmas de métodos en desuso en los ejemplos\nHaz: - Consulta las notas de la versión antes de publicar - Verifica que la documentación de la API coincida con la versión actual - Actualiza los ejemplos para usar las mejores prácticas actuales\n3. URLs inaccesibles No hagas: - Enlazar únicamente a dominios .i2p sin alternativas en clearnet (Internet abierta) - Usar URLs de documentación rotas u obsoletas - Enlazar a rutas locales file://\nHaz: - Proporciona alternativas en clearnet (Internet pública) para todos los enlaces internos de I2P - Verifica que las URL sean accesibles antes de publicar - Usa URL persistentes (geti2p.net, no alojamiento temporal)\n4. Ejemplos de código incompletos No hagas: - Mostrar fragmentos sin contexto - Omitir el manejo de errores - Usar variables indefinidas - Omitir declaraciones de importación cuando no sea obvio\nHaz: - Muestra ejemplos completos y compilables - Incluye el manejo de errores necesario - Explica qué hace cada línea significativa - Prueba los ejemplos antes de publicarlos\n5. Declaraciones ambiguas ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; Convenciones de Markdown Nomenclatura de archivos Usa kebab-case (palabras separadas por guiones) para los nombres de archivo: - managed-clients.md - port-mapper-guide.md - configuration-reference.md\nFormato del front matter (bloque de metadatos al inicio del documento) Incluye siempre el front matter de YAML (cabecera de metadatos):\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Formato de enlaces Enlaces internos (dentro de la documentación):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) Enlaces externos (a otros recursos):\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) Enlaces a repositorios de código:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) Formato de tablas Usa tablas de Markdown al estilo de GitHub:\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | Etiquetas de lenguaje para bloques de código Especifica siempre el lenguaje para el resaltado de sintaxis:\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` Lista de verificación de revisión Antes de publicar la documentación, verifica:\nTodas las afirmaciones técnicas están verificadas frente al código fuente o la documentación oficial Los números de versión y las fechas están actualizados Todas las URLs son accesibles desde clearnet (Internet abierta) (o se proporcionan alternativas) Los ejemplos de código son completos y han sido probados La terminología sigue las convenciones de I2P Sin guiones largos (em dashes) (usa guiones normales u otros signos de puntuación) El frontmatter (metadatos iniciales del documento) está completo y es preciso La jerarquía de encabezados es semántica (h1 → h2 → h3) Las listas y las tablas están correctamente formateadas La sección de referencias incluye todas las fuentes citadas El documento sigue las directrices de estructura El tono es profesional pero accesible Los conceptos similares están claramente diferenciados No hay enlaces ni referencias rotos Los ejemplos de configuración son válidos y actuales Comentarios: Si encuentra problemas o tiene sugerencias para estas directrices, envíelos a través de los canales oficiales de desarrollo de I2P.\n","description":"Mantén la coherencia, la precisión y la accesibilidad en toda la documentación técnica de I2P","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"Pautas de redacción de la documentación de I2P","url":"/es/docs/writing-guidelines/"},{"categories":null,"content":"Ayuda del Router I2P ¿En qué sistemas funcionará I2P? I2P está escrito en el lenguaje de programación Java. Ha sido probado en Windows, Linux, FreeBSD y OSX. También está disponible una versión para Android.\nEn términos de uso de memoria, I2P está configurado para utilizar 128 MB de RAM por defecto. Esto es suficiente para navegación y uso de IRC. Sin embargo, otras actividades pueden requerir una mayor asignación de memoria. Por ejemplo, si se desea ejecutar un router de alto ancho de banda, participar en torrents de I2P o servir hidden services de alto tráfico, se requiere una mayor cantidad de memoria.\nEn términos de uso de CPU, I2P ha sido probado para funcionar en sistemas modestos como la gama de computadoras de placa única Raspberry Pi. Como I2P hace un uso intensivo de técnicas criptográficas, una CPU más potente estará mejor preparada para manejar la carga de trabajo generada por I2P, así como las tareas relacionadas con el resto del sistema (es decir, sistema operativo, interfaz gráfica, otros procesos, por ejemplo, navegación web).\nSe recomienda usar Sun/Oracle Java u OpenJDK.\n¿Es necesario instalar Java para usar I2P? Sí, se requiere Java para usar I2P Core. Incluimos Java dentro de nuestros instaladores fáciles para Windows, Mac OSX y Linux. Si estás ejecutando la aplicación I2P para Android, también necesitarás un entorno de ejecución de Java como Dalvik o ART instalado en la mayoría de los casos.\n¿Qué es un \u0026ldquo;I2P Site\u0026rdquo; y cómo configuro mi navegador para poder usarlos? Un Sitio I2P es un sitio web normal excepto que está alojado dentro de I2P. Los sitios I2P tienen direcciones que parecen direcciones normales de internet, terminando en \u0026ldquo;.i2p\u0026rdquo; de una manera legible para humanos y no criptográfica, para el beneficio de las personas. En realidad, conectarse a un Sitio I2P requiere criptografía, lo que significa que las direcciones de Sitios I2P también son los largos Destinations \u0026ldquo;Base64\u0026rdquo; y las direcciones \u0026ldquo;B32\u0026rdquo; más cortas. Es posible que necesites realizar configuración adicional para navegar correctamente. Navegar Sitios I2P requerirá activar el Proxy HTTP en tu instalación de I2P y luego configurar tu navegador para usarlo. Para más información, consulta la sección \u0026ldquo;Navegadores\u0026rdquo; a continuación o la Guía de \u0026ldquo;Configuración del Navegador\u0026rdquo;.\n¿Qué significan los números Activos x/y en la consola del router? En la página de Peers en tu consola del router, puedes ver dos números - Activos x/y. El primer número es la cantidad de peers a los que has enviado o de los que has recibido un mensaje en los últimos minutos. El segundo número es la cantidad de peers vistos recientemente, este siempre será mayor o igual que el primer número.\nMi router tiene muy pocos pares activos, ¿está bien esto? Sí, esto puede ser normal, especialmente cuando el router acaba de iniciarse. Los routers nuevos necesitarán tiempo para arrancar y conectarse al resto de la red. Para ayudar a mejorar la integración en la red, el tiempo de actividad y el rendimiento, revisa estas configuraciones:\nCompartir ancho de banda - Si un router está configurado para compartir ancho de banda, enrutará más tráfico para otros routers, lo que ayuda a integrarlo con el resto de la red, así como a mejorar el rendimiento de la conexión local. Esto puede configurarse en la página http://localhost:7657/config . Interfaz de red - Asegúrate de que no haya una interfaz especificada en la página http://localhost:7657/confignet . Esto puede reducir el rendimiento a menos que tu computadora tenga múltiples interfaces con varias direcciones IP externas. Protocolo I2NP - Asegúrate de que el router esté configurado para esperar conexiones en un protocolo válido para el sistema operativo del host y configuraciones de red vacías (Avanzado). No ingreses una dirección IP en el campo \u0026lsquo;Nombre de host\u0026rsquo; en la página de configuración de red. El protocolo I2NP que selecciones aquí solo se utilizará si aún no tienes una dirección accesible. La mayoría de las conexiones inalámbricas 4G y 5G de Verizon en Estados Unidos, por ejemplo, bloquean UDP y no se puede acceder a través de él. Otros usarían UDP de manera forzada incluso si está disponible para ellos. Elige una configuración razonable de los protocolos I2NP listados. Me opongo a ciertos tipos de contenido. ¿Cómo evito distribuirlos, almacenarlos o acceder a ellos? No hay ninguno de estos materiales instalado por defecto. Sin embargo, dado que I2P es una red peer-to-peer (entre pares), es posible que encuentres contenido prohibido por accidente. Aquí hay un resumen de cómo I2P te protege de estar involucrado innecesariamente en violaciones de tus creencias.\nDistribución - El tráfico es interno a la red I2P, no eres un nodo de salida (referido como outproxy en nuestra documentación). Almacenamiento - La red I2P no realiza almacenamiento distribuido de contenido, esto debe ser instalado y configurado específicamente por el usuario (con Tahoe-LAFS, por ejemplo). Esa es una característica de una red anónima diferente, Freenet . Al ejecutar un router I2P, no estás almacenando contenido para nadie. Acceso - Tu router no solicitará ningún contenido sin tu instrucción específica para hacerlo. ¿Es posible bloquear I2P? Sí, la forma más fácil y común es bloqueando los servidores bootstrap o \u0026ldquo;Reseed\u0026rdquo;. Bloquear completamente todo el tráfico ofuscado también funcionaría (aunque esto rompería muchas, muchas otras cosas que no son I2P y la mayoría no está dispuesta a llegar tan lejos). En el caso del bloqueo de reseed, hay un paquete de reseed en Github, bloquearlo también bloqueará Github. Puedes realizar reseed a través de un proxy (se pueden encontrar muchos en Internet si no quieres usar Tor) o compartir paquetes de reseed de forma amigo-a-amigo sin conexión.\nEn wrapper.log veo un error que indica \u0026ldquo;Protocol family unavailable\u0026rdquo; al cargar la Consola del Router A menudo este error ocurrirá con cualquier software Java habilitado para red en algunos sistemas que están configurados para usar IPv6 por defecto. Hay algunas formas de resolver esto:\nEn sistemas basados en Linux, puedes ejecutar echo 0 \u0026gt; /proc/sys/net/ipv6/bindv6only Busca las siguientes líneas en wrapper.config: #wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true #wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false Si las líneas están presentes, descoméntalas eliminando los \u0026ldquo;#\u0026rdquo;. Si las líneas no están presentes, añádelas sin los \u0026ldquo;#\u0026rdquo;. Otra opción sería eliminar el ::1 de ~/.i2p/clients.config\nADVERTENCIA: Para que cualquier cambio en wrapper.config tenga efecto, debe detener completamente el router y el wrapper. ¡Hacer clic en Reiniciar en la consola del router NO volverá a leer este archivo! Debe hacer clic en Apagar, esperar 11 minutos y luego iniciar I2P.\n¿La mayoría de los sitios I2P dentro de I2P están caídos? Si consideras cada sitio I2P que se ha creado alguna vez, sí, la mayoría están caídos. Las personas y los sitios I2P vienen y van. Una buena manera de comenzar en I2P es revisar una lista de sitios I2P que están actualmente activos. identiguy.i2p rastrea los sitios I2P activos.\n¿Por qué I2P está escuchando en el puerto 32000? El wrapper de servicio Java Tanuki que utilizamos abre este puerto — vinculado a localhost — para comunicarse con el software que se ejecuta dentro de la JVM. Cuando se inicia la JVM, se le proporciona una clave para que pueda conectarse al wrapper. Después de que la JVM establece su conexión con el wrapper, el wrapper rechaza cualquier conexión adicional.\nPuede encontrar más información en la documentación del wrapper .\n¿Cómo configuro mi navegador? La configuración del proxy para diferentes navegadores está en una página separada con capturas de pantalla. Son posibles configuraciones más avanzadas con herramientas externas, como el complemento de navegador FoxyProxy o el servidor proxy Privoxy, pero podrían introducir fugas en tu configuración.\n¿Cómo me conecto a IRC dentro de I2P? Se crea un túnel al servidor IRC principal dentro de I2P, Irc2P, cuando se instala I2P (consulta la página de configuración de I2PTunnel ), y se inicia automáticamente cuando arranca el router I2P. Para conectarte a él, indica a tu cliente IRC que se conecte a localhost 6668. Los usuarios de clientes tipo HexChat pueden crear una nueva red con el servidor localhost/6668 (recuerda marcar \u0026ldquo;Bypass proxy server\u0026rdquo; si tienes un servidor proxy configurado). Los usuarios de Weechat pueden usar el siguiente comando para añadir una nueva red:\n/server add irc2p localhost/6668 ¿Cómo configuro mi propio sitio I2P? El método más fácil es hacer clic en el enlace i2ptunnel en la consola del router y crear un nuevo \u0026lsquo;Server Tunnel\u0026rsquo; (túnel de servidor). Puedes servir contenido dinámico configurando el destino del tunnel hacia el puerto de un servidor web existente, como Tomcat o Jetty. También puedes servir contenido estático. Para esto, configura el destino del tunnel a: 0.0.0.0 port 7659 y coloca el contenido en el directorio ~/.i2p/eepsite/docroot/. (En sistemas que no son Linux, esto puede estar en una ubicación diferente. Verifica la consola del router.) El software \u0026rsquo;eepsite\u0026rsquo; viene como parte del paquete de instalación de I2P y está configurado para iniciarse automáticamente cuando I2P se inicia. El sitio predeterminado que esto crea se puede acceder en http://127.0.0.1:7658. Sin embargo, tu \u0026rsquo;eepsite\u0026rsquo; también es accesible para otros a través de tu archivo de claves del eepsite, ubicado en: ~/.i2p/eepsite/i2p/eepsite.keys. Para obtener más información, lee el archivo readme en: ~/.i2p/eepsite/README.txt.\n¿Si alojo un sitio web en I2P en casa, que contenga solo HTML y CSS, es peligroso? Depende de tu adversario y tu modelo de amenaza. Si solo te preocupan las violaciones de \u0026ldquo;privacidad\u0026rdquo; corporativas, delincuentes comunes y la censura, entonces no es realmente peligroso. Las fuerzas del orden probablemente te encontrarán de todos modos si realmente lo desean. Solo alojar cuando tienes un navegador de usuario doméstico normal (de internet) en ejecución hará realmente difícil saber quién está alojando esa parte. Por favor considera el alojamiento de tu sitio I2P igual que alojar cualquier otro servicio - es tan peligroso - o seguro - como tú mismo lo configures y gestiones.\nNota: Ya existe una forma de separar el alojamiento de un servicio i2p (destination) del router i2p. Si entiendes cómo funciona, entonces puedes simplemente configurar una máquina separada como servidor para el sitio web (o servicio) que será públicamente accesible y reenviar eso al servidor web a través de un túnel SSH [muy] seguro o usar un sistema de archivos compartido y seguro.\n¿Cómo encuentra I2P los sitios web \u0026ldquo;.i2p\u0026rdquo;? La aplicación de Libreta de Direcciones de I2P asigna nombres legibles por humanos a destinos a largo plazo, asociados con servicios, lo que la hace más parecida a un archivo hosts o a una lista de contactos que a una base de datos de red o a un servicio DNS. También es local-first (prioriza lo local): no existe un espacio de nombres global reconocido, tú decides a qué se asigna cualquier dominio .i2p dado al final. El punto intermedio es algo llamado \u0026ldquo;Jump Service\u0026rdquo; (servicio de salto) que proporciona un nombre legible por humanos al redirigirte a una página donde se te preguntará \u0026ldquo;¿Le das permiso al router de I2P para llamar a $SITE_CRYPTO_KEY con el nombre $SITE_NAME.i2p?\u0026rdquo; o algo por el estilo. Una vez que está en tu libreta de direcciones, puedes generar tus propias URL de salto para ayudar a compartir el sitio con otros.\n¿Cómo agrego direcciones a la Libreta de Direcciones? No puedes agregar una dirección sin conocer al menos el base32 o base64 del sitio que deseas visitar. El \u0026ldquo;hostname\u0026rdquo; que es legible para humanos es solo un alias para la dirección criptográfica, que corresponde al base32 o base64. Sin la dirección criptográfica, no hay forma de acceder a un sitio I2P, esto es por diseño. Distribuir la dirección a personas que aún no la conocen es generalmente responsabilidad del proveedor del servicio Jump. Visitar un sitio I2P que es desconocido activará el uso de un servicio Jump. stats.i2p es el servicio Jump más confiable.\nSi estás alojando un sitio a través de i2ptunnel, entonces aún no tendrá un registro con un servicio de salto. Para darle una URL localmente, visita la página de configuración y haz clic en el botón que dice \u0026ldquo;Add to Local Address Book.\u0026rdquo; Luego ve a http://127.0.0.1:7657/dns para buscar la URL del asistente de direcciones y compartirla.\n¿Qué puertos usa I2P? Los puertos que utiliza I2P se pueden dividir en 2 secciones:\nPuertos de cara a Internet, que se utilizan para la comunicación con otros routers I2P Puertos locales, para conexiones locales Estos se describen en detalle a continuación.\n1. Puertos expuestos a Internet Nota: Desde la versión 0.7.8, las nuevas instalaciones no utilizan el puerto 8887; se selecciona un puerto aleatorio entre 9000 y 31000 cuando el programa se ejecuta por primera vez. El puerto seleccionado se muestra en la página de configuración del router.\nSALIENTE\nUDP desde el puerto aleatorio listado en la página de configuración hacia puertos UDP remotos arbitrarios, permitiendo respuestas TCP desde puertos altos aleatorios hacia puertos TCP remotos arbitrarios UDP saliente en el puerto 123, permitiendo respuestas. Esto es necesario para la sincronización de tiempo interna de I2P (vía SNTP - consultando un host SNTP aleatorio en pool.ntp.org u otro servidor que especifiques) ENTRANTE\n(Opcional, recomendado) UDP al puerto indicado en la página de configuración desde ubicaciones arbitrarias (Opcional, recomendado) TCP al puerto indicado en la página de configuración desde ubicaciones arbitrarias El TCP entrante se puede deshabilitar en la página de configuración 2. Puertos I2P locales Los puertos I2P locales escuchan solo conexiones locales de forma predeterminada, excepto donde se indique:\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. ### Me faltan muchos hosts en mi libreta de direcciones. ¿Cuáles son algunos buenos enlaces de suscripción? {#subscriptions} La libreta de direcciones se encuentra en http://localhost:7657/dns donde se puede encontrar más información.\n¿Cuáles son algunos buenos enlaces de suscripción a la libreta de direcciones?\nPuedes intentar lo siguiente:\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt ¿Cómo puedo acceder a la consola web desde mis otras máquinas o protegerla con contraseña? Por motivos de seguridad, la consola de administración del router por defecto solo escucha conexiones en la interfaz local.\nExisten dos métodos para acceder a la consola de forma remota:\nTúnel SSH Configurar tu consola para que esté disponible en una dirección IP pública con un nombre de usuario y contraseña Estos se detallan a continuación:\nMétodo 1: Túnel SSH\nSi estás ejecutando un sistema operativo tipo Unix, este es el método más fácil para acceder remotamente a tu consola I2P. (Nota: El software de servidor SSH está disponible para sistemas que ejecutan Windows, por ejemplo https://github.com/PowerShell/Win32-OpenSSH )\nUna vez que hayas configurado el acceso SSH a tu sistema, se pasa la bandera \u0026lsquo;-L\u0026rsquo; a SSH con los argumentos apropiados - por ejemplo:\nssh -L 7657:localhost:7657 (System_IP) donde \u0026lsquo;(System_IP)\u0026rsquo; se reemplaza con la dirección IP de tu sistema. Este comando reenvía el puerto 7657 (el número antes de los dos puntos) al puerto 7657 del sistema remoto (especificado por la cadena \u0026rsquo;localhost\u0026rsquo; entre los primeros y segundos dos puntos) (el número después de los segundos dos puntos). Tu consola I2P remota estará ahora disponible en tu sistema local como \u0026lsquo;http://localhost:7657\u0026rsquo; y estará disponible mientras tu sesión SSH esté activa.\nSi deseas iniciar una sesión SSH sin iniciar un shell en el sistema remoto, puedes agregar la opción \u0026lsquo;-N\u0026rsquo;:\nssh -NL 7657:localhost:7657 (System_IP) Método 2: Configurar tu consola para que esté disponible en una dirección IP pública con un nombre de usuario y contraseña\nAbre ~/.i2p/clients.config y reemplaza:\nclientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ con:\nclientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ donde reemplazas (System_IP) con la dirección IP pública de tu sistema\nVe a http://localhost:7657/configui y añade un nombre de usuario y contraseña para la consola si lo deseas - Se recomienda encarecidamente añadir un nombre de usuario y contraseña para proteger tu consola I2P de manipulaciones, lo que podría llevar a la des-anonimización.\nVe a http://localhost:7657/index y pulsa \u0026ldquo;Graceful restart\u0026rdquo;, que reinicia la JVM y recarga las aplicaciones cliente\nUna vez que se inicie, ahora deberías poder acceder a tu consola de forma remota. Carga la consola del router en http://(IP_del_Sistema):7657 y se te solicitará el nombre de usuario y la contraseña que especificaste en el paso 2 anterior si tu navegador admite la ventana emergente de autenticación.\nNOTA: Puedes especificar 0.0.0.0 en la configuración anterior. Esto especifica una interfaz, no una red o máscara de red. 0.0.0.0 significa \u0026ldquo;enlazar a todas las interfaces\u0026rdquo;, por lo que puede ser accesible en 127.0.0.1:7657 así como en cualquier IP de LAN/WAN. Ten cuidado al usar esta opción ya que la consola estará disponible en TODAS las direcciones configuradas en tu sistema.\n¿Cómo puedo usar aplicaciones desde mis otras máquinas? Por favor, consulta la respuesta anterior para obtener instrucciones sobre cómo usar el reenvío de puertos SSH, y también consulta esta página en tu consola: http://localhost:7657/configi2cp ¿Es posible usar I2P como proxy SOCKS? El proxy SOCKS ha sido funcional desde la versión 0.7.1. Se admiten SOCKS 4/4a/5. I2P no tiene un outproxy SOCKS, por lo que está limitado solo para uso dentro de I2P.\nMuchas aplicaciones filtran información sensible que podría identificarte en Internet y este es un riesgo del que debes ser consciente al usar el proxy SOCKS de I2P. I2P solo filtra los datos de conexión, pero si el programa que pretendes ejecutar envía esta información como contenido, I2P no tiene forma de proteger tu anonimato. Por ejemplo, algunas aplicaciones de correo enviarán la dirección IP de la máquina en la que se están ejecutando a un servidor de correo. Recomendamos herramientas o aplicaciones específicas de I2P (como I2PSnark para torrents), o aplicaciones que se sabe que son seguras de usar con I2P que incluyen complementos populares encontrados en Firefox .\n¿Cómo accedo a IRC, BitTorrent u otros servicios en Internet normal? Existen servicios llamados Outproxies que hacen de puente entre I2P e Internet, similar a los Tor Exit Nodes. La funcionalidad de outproxy predeterminada para HTTP y HTTPS es proporcionada por exit.stormycloud.i2p y está gestionada por StormyCloud Inc. Se configura en el HTTP Proxy. Además, para ayudar a proteger el anonimato, I2P no permite realizar conexiones anónimas a Internet regular de forma predeterminada. Consulte la página Socks Outproxy para más información.\nReseeds Mi router ha estado activo durante varios minutos y tiene cero o muy pocas conexiones Primero revisa la página http://127.0.0.1:7657/netdb en la Consola del Router – tu base de datos de red. Si no ves ningún router listado desde dentro de I2P pero la consola indica que deberías estar detrás de un firewall, entonces probablemente no puedes conectarte a los servidores de reseed. Si ves otros routers de I2P listados, entonces intenta reducir el número de conexiones máximas en http://127.0.0.1:7657/config quizás tu router no puede manejar muchas conexiones.\n¿Cómo hago un reseed manualmente? En circunstancias normales, I2P te conectará a la red automáticamente usando nuestros enlaces de arranque. Si una interrupción de internet hace que falle el arranque desde los servidores reseed, una forma fácil de arrancar es usando el navegador Tor (Por defecto abre localhost), que funciona muy bien con http://127.0.0.1:7657/configreseed . También es posible hacer reseed de un router I2P manualmente.\nAl usar el navegador Tor para resembrar puedes seleccionar múltiples URLs a la vez y continuar. Aunque el valor predeterminado que es 2 (de las múltiples urls) también funcionará, pero será lento.\nPrivacidad-Seguridad ¿Es mi router un \u0026ldquo;nodo de salida\u0026rdquo; (outproxy) hacia Internet normal? No quiero que lo sea. No, tu router participa en el transporte de tráfico cifrado de extremo a extremo a través de la red i2p hacia un punto final de tunnel aleatorio, normalmente no un outproxy, pero no se pasa tráfico entre tu router e Internet sobre la capa de transporte. Como usuario final, no deberías ejecutar un outproxy si no tienes experiencia en administración de sistemas y redes.\n¿Es fácil detectar el uso de I2P analizando el tráfico de red? El tráfico de I2P generalmente parece tráfico UDP, y no mucho más – y hacer que parezca no mucho más es un objetivo. También soporta TCP. Con algo de esfuerzo, el análisis pasivo de tráfico puede ser capaz de clasificar el tráfico como \u0026ldquo;I2P\u0026rdquo;, pero esperamos que el desarrollo continuo de ofuscación de tráfico reduzca esto aún más. Incluso una capa de ofuscación de protocolo bastante simple como obfs4 evitará que los censores bloqueen I2P (es un objetivo que I2P implementa).\n¿Es seguro usar I2P? Depende de tu modelo de amenaza personal. Para la mayoría de las personas, I2P es mucho más seguro que no usar ninguna protección. Algunas otras redes (como Tor, mixminion/mixmaster), probablemente son más seguras contra ciertos adversarios. Por ejemplo, el tráfico de I2P no utiliza TLS/SSL, por lo que no tiene los problemas del \u0026ldquo;eslabón más débil\u0026rdquo; que tiene Tor. I2P fue utilizado por muchas personas en Siria durante la \u0026ldquo;Primavera Árabe\u0026rdquo;, y recientemente el proyecto ha experimentado un mayor crecimiento en instalaciones lingüísticas más pequeñas de I2P en Oriente Próximo y Medio. Lo más importante a tener en cuenta aquí es que I2P es una tecnología y necesitas una guía/tutorial para mejorar tu privacidad/anonimato en Internet. También verifica tu navegador o importa el motor de búsqueda de huellas digitales para bloquear ataques de fingerprinting con un conjunto de datos muy grande (es decir: colas largas típicas / estructura de datos diversa muy precisa) sobre muchas características del entorno y no uses VPN para reducir todos los riesgos que provienen de sí misma, como el comportamiento de la caché TLS propia y la construcción técnica del negocio del proveedor que puede ser hackeado más fácilmente que un sistema de escritorio propio. Tal vez usar un navegador Tor aislado (Tor Browser) con sus excelentes protecciones anti-fingerprint y una protección general de tiempo de ejecución tipo appguard que solo permita las comunicaciones del sistema necesarias, y un último uso de máquina virtual con scripts de desactivación anti-espía y live-cd para eliminar cualquier \u0026ldquo;riesgo casi permanente posible\u0026rdquo; y reducir todos los riesgos mediante una probabilidad decreciente, sean una buena opción en redes públicas y modelos de riesgo individuales elevados, y podría ser lo mejor que puedes hacer con este objetivo para el uso de i2p.\nVeo direcciones IP de todos los demás nodos I2P en la consola del router. ¿Significa eso que mi dirección IP es visible para otros? Sí, para otros nodos I2P que conocen tu router. Utilizamos esto para conectarnos con el resto de la red I2P. Las direcciones están físicamente ubicadas en objetos \u0026ldquo;routerInfos (clave,valor)\u0026rdquo;, ya sea obtenidos remotamente o recibidos de pares. Los \u0026ldquo;routerInfos\u0026rdquo; contienen cierta información (algunas opcionales añadidas de forma oportunista), \u0026ldquo;publicada por el par\u0026rdquo;, sobre el router mismo para el arranque inicial. No hay datos en este objeto sobre clientes. Mirando más de cerca bajo el capó te dirá que todos son contabilizados con el tipo más reciente de creación de identificadores llamado \u0026ldquo;SHA-256 Hashes (bajo=hash positivo(-clave), alto=hash negativo(+clave))\u0026rdquo;. La red I2P tiene su propia base de datos de routerInfos creados durante la carga e indexación, pero esto depende profundamente de la realización de las tablas clave/valor y la topología de la red y el estado de carga / estado de ancho de banda y las probabilidades de enrutamiento para almacenamientos en componentes de base de datos.\n¿Es seguro usar un outproxy? Depende de cuál sea tu definición de \u0026ldquo;seguro\u0026rdquo;. Los outproxies son excelentes cuando funcionan, pero desafortunadamente son operados voluntariamente por personas que pueden perder el interés o no tener los recursos para mantenerlos 24/7 – ten en cuenta que puedes experimentar períodos de tiempo durante los cuales los servicios no están disponibles, están interrumpidos o no son confiables, y no estamos asociados con este servicio ni tenemos influencia sobre él.\nLos outproxys en sí mismos pueden ver tu tráfico entrar y salir, con la excepción de los datos HTTPS/SSL cifrados de extremo a extremo, tal como tu ISP puede ver tu tráfico entrar y salir de tu computadora. Si te sientes cómodo con tu ISP, no sería peor con el outproxy.\n¿Qué hay sobre los ataques de \u0026ldquo;Desanonimización\u0026rdquo;? Para una explicación muy detallada, lee más en nuestros artículos sobre Modelo de Amenazas . En general, la des-anonimización no es trivial, pero es posible si no eres lo suficientemente cauteloso.\nAcceso a Internet/Rendimiento No puedo acceder a sitios de Internet regulares a través de I2P. El proxy hacia sitios de Internet (eepsites que salen a Internet) se proporciona como un servicio a los usuarios de I2P por proveedores sin bloqueo. Este servicio no es el enfoque principal del desarrollo de I2P, y se proporciona de forma voluntaria. Los eepsites que están alojados en I2P siempre deberían funcionar sin un outproxy (proxy de salida). Los outproxies son una conveniencia pero por diseño no son perfectos ni una parte importante del proyecto. Tenga en cuenta que es posible que no puedan proporcionar el servicio de alta calidad que otros servicios de I2P pueden ofrecer.\nNo puedo acceder a sitios https:// o ftp:// a través de I2P. El proxy HTTP predeterminado solo admite salida HTTP y HTTPS.\n¿Por qué mi router está usando demasiada CPU? Primero, asegúrate de tener la última versión de cada componente relacionado con I2P: las versiones antiguas tenían secciones de código que consumían CPU innecesariamente. También existe un registro de rendimiento que documenta algunas de las mejoras en el rendimiento de I2P a lo largo del tiempo.\n¿Mis pares activos / pares conocidos / túneles participantes / conexiones / ancho de banda varían drásticamente con el tiempo! ¿Hay algo mal? La estabilidad general de la red I2P es un área de investigación continua. Una cantidad particular de esa investigación se centra en cómo pequeños cambios en la configuración modifican el comportamiento del router. Como I2P es una red peer-to-peer (entre pares), las acciones de otros peers influirán en el rendimiento de tu router.\n¿Qué hace que las descargas, torrents, navegación web y todo lo demás sea más lento en I2P en comparación con la internet regular? I2P tiene diferentes protecciones que añaden enrutamiento adicional y capas extra de cifrado. También rebota el tráfico a través de otros peers (Tunnels) que tienen su propia velocidad y calidad, algunos son lentos, otros rápidos. Esto suma mucha sobrecarga y tráfico a diferentes ritmos en diferentes direcciones. Por diseño, todas estas cosas lo harán más lento en comparación con una conexión directa en internet, pero mucho más anónimo y aún lo suficientemente rápido para la mayoría de las cosas.\nA continuación se presenta un ejemplo con una explicación para ayudar a proporcionar contexto sobre las consideraciones de latencia y ancho de banda al usar I2P.\nConsidere el diagrama a continuación. Representa una conexión entre un cliente que realiza una solicitud a través de I2P, un servidor que recibe la solicitud a través de I2P y luego responde también a través de I2P. El circuito por el cual viaja la solicitud también se muestra.\nSegún el diagrama, considere que las cajas etiquetadas como \u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo; y \u0026lsquo;R\u0026rsquo; representan un túnel de salida (outbound tunnel) para \u0026lsquo;A\u0026rsquo; y que las cajas etiquetadas como \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; y \u0026lsquo;Z\u0026rsquo; representan un túnel de salida para \u0026lsquo;B\u0026rsquo;. De manera similar, las cajas etiquetadas como \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; y \u0026lsquo;Z\u0026rsquo; representan un túnel de entrada (inbound tunnel) para \u0026lsquo;B\u0026rsquo; mientras que las cajas etiquetadas como \u0026lsquo;P_1\u0026rsquo;, \u0026lsquo;Q_1\u0026rsquo; y \u0026lsquo;R_1\u0026rsquo; representan un túnel de entrada para \u0026lsquo;A\u0026rsquo;. Las flechas entre las cajas muestran la dirección del tráfico. El texto arriba y abajo de las flechas detalla algunos ejemplos de ancho de banda entre un par de saltos, así como ejemplos de latencias.\nCuando tanto el cliente como el servidor están utilizando túneles de 3 saltos en todo momento, un total de 12 routers I2P adicionales participan en la retransmisión del tráfico. 6 pares retransmiten el tráfico desde el cliente al servidor, el cual se divide en un túnel de salida de 3 saltos desde \u0026lsquo;A\u0026rsquo; (\u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;R\u0026rsquo;) y un túnel de entrada de 3 saltos hacia \u0026lsquo;B\u0026rsquo; (\u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;). De manera similar, 6 pares retransmiten el tráfico desde el servidor de vuelta al cliente.\nPrimero, podemos considerar la latencia - el tiempo que tarda una solicitud de un cliente en atravesar la red I2P, llegar al servidor y volver al cliente. Sumando todas las latencias vemos que:\n40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms El tiempo total de ida y vuelta en nuestro ejemplo suma 740 ms, ciertamente mucho mayor que lo que normalmente se vería al navegar sitios web de Internet regulares.\nEn segundo lugar, podemos considerar el ancho de banda disponible. Esto se determina a través del enlace más lento entre saltos desde el cliente y el servidor, así como cuando el tráfico está siendo transmitido por el servidor al cliente. Para el tráfico que va del cliente al servidor, vemos que el ancho de banda disponible en nuestro ejemplo entre los saltos \u0026lsquo;R\u0026rsquo; y \u0026lsquo;X\u0026rsquo;, así como entre los saltos \u0026lsquo;X\u0026rsquo; e \u0026lsquo;Y\u0026rsquo; es de 32 KB/s. A pesar de un ancho de banda disponible mayor entre los otros saltos, estos saltos actuarán como un cuello de botella y limitarán el ancho de banda máximo disponible para el tráfico de \u0026lsquo;A\u0026rsquo; a \u0026lsquo;B\u0026rsquo; a 32 KB/s. De manera similar, rastreando la ruta del servidor al cliente se muestra que hay un ancho de banda máximo de 64 KB/s - entre los saltos \u0026lsquo;Z_1\u0026rsquo; y \u0026lsquo;Y_1\u0026rsquo;, \u0026lsquo;Y_1\u0026rsquo; y \u0026lsquo;X_1\u0026rsquo; y \u0026lsquo;Q_1\u0026rsquo; y \u0026lsquo;P_1\u0026rsquo;.\nRecomendamos aumentar tus límites de ancho de banda. Esto ayuda a la red al incrementar la cantidad de ancho de banda disponible, lo cual mejorará tu experiencia con I2P. La configuración de ancho de banda se encuentra en la página http://localhost:7657/config . Ten en cuenta los límites de tu conexión a internet determinados por tu proveedor de servicios de internet (ISP) y ajusta tu configuración en consecuencia.\nTambién recomendamos configurar una cantidad suficiente de ancho de banda compartido: esto permite que los túneles participantes se enruten a través de tu router I2P. Permitir tráfico participante mantiene tu router bien integrado en la red y mejora tus velocidades de transferencia.\nI2P es un trabajo en progreso. Se están implementando muchas mejoras y correcciones, y, en términos generales, ejecutar la versión más reciente ayudará a tu rendimiento. Si no lo has hecho, instala la versión más reciente.\nCreo que encontré un error, ¿dónde puedo reportarlo? Puedes reportar cualquier error o problema que encuentres en nuestro rastreador de errores, que está disponible tanto en internet no privado como en I2P. Tenemos un foro de discusión, también disponible en I2P e internet no privado. También puedes unirte a nuestro canal de IRC: ya sea a través de nuestra red IRC, IRC2P, o en Freenode.\nNuestro rastreador de errores: Internet no privada: https://i2pgit.org/I2P_Developers/i2p.i2p/issues En I2P: http://git.idk.i2p/I2P_Developers/i2p.i2p/issues Nuestros foros: i2pforum.i2p Pegar registros: Puede pegar cualquier registro de interés en un servicio de pegado como los servicios de internet no privada listados en la Wiki de PrivateBin , o un servicio de pegado de I2P como esta instancia de PrivateBin o este servicio de pegado sin Javascript y hacer seguimiento en IRC en #i2p IRC: Únase a #i2p-dev Para discutir con los desarrolladores en IRC Por favor incluye información relevante de la página de registros del router que está disponible en: http://127.0.0.1:7657/logs . Solicitamos que compartas todo el texto bajo la sección \u0026lsquo;I2P Version and Running Environment\u0026rsquo; así como cualquier error o advertencia que se muestre en los diversos registros mostrados en la página.\n¡Tengo una pregunta! ¡Genial! Encuéntranos en IRC:\nen irc.freenode.net canal #i2p en IRC2P canal #i2p o publica en el foro y lo publicaremos aquí (con la respuesta, esperamos).\n","description":"Preguntas frecuentes completas sobre I2P: ayuda del router, configuración, reseeds, privacidad/seguridad, rendimiento y solución de problemas","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"Preguntas Frecuentes","url":"/es/docs/overview/faq/"},{"categories":null,"content":"Descripción general I2CP es el protocolo de control de bajo nivel entre un router de I2P y cualquier proceso cliente. Define una separación estricta de responsabilidades:\nRouter: Gestiona el enrutamiento, la criptografía, los ciclos de vida de tunnel y las operaciones de la base de datos de la red Cliente: Selecciona propiedades de anonimato, configura tunnels y envía/recibe mensajes Toda la comunicación se realiza a través de un único socket TCP (opcionalmente envuelto en TLS), lo que permite operaciones asíncronas y de dúplex completo.\nVersión del protocolo: I2CP usa un byte de versión de protocolo 0x2A (42 en decimal) enviado durante el establecimiento inicial de la conexión. Este byte de versión se ha mantenido estable desde el inicio del protocolo.\nEstado actual: Esta especificación es precisa para la versión del router 0.9.67 (versión de la API 0.9.67), publicada en 2025-09.\nContexto de implementación Implementación en Java La implementación de referencia está en Java I2P: - SDK del cliente: paquete i2p.jar - Implementación del router: paquete router.jar - Javadocs Cuando el cliente y el router se ejecutan en la misma JVM, los mensajes de I2CP se pasan como objetos de Java sin serialización. Los clientes externos utilizan el protocolo serializado sobre TCP.\nImplementación en C++ i2pd (el router I2P en C++) también implementa I2CP de forma externa para conexiones de clientes.\nClientes no Java No se conocen implementaciones no escritas en Java de una biblioteca de cliente I2CP completa. Las aplicaciones no escritas en Java deberían usar en su lugar protocolos de nivel superior:\nSAM (Simple Anonymous Messaging) v3: Interfaz basada en sockets con bibliotecas para múltiples lenguajes BOB (Basic Open Bridge, puente abierto básico): Alternativa más simple a SAM Estos protocolos de nivel superior gestionan internamente la complejidad de I2CP y también proporcionan la biblioteca de streaming (para conexiones similares a TCP) y la biblioteca de datagramas (para conexiones similares a UDP).\nEstablecimiento de conexión 1. Conexión TCP Conéctese al puerto I2CP del router: - Predeterminado: 127.0.0.1:7654 - Configurable mediante la configuración del router - Capa TLS opcional (altamente recomendada para conexiones remotas)\n2. Negociación del protocolo Paso 1: Enviar el byte de versión del protocolo 0x2A\nPaso 2: Sincronización del reloj\nClient → Router: GetDateMessage Router → Client: SetDateMessage El router devuelve su marca de tiempo actual y la cadena de versión de la API de I2CP (desde 0.8.7).\nPaso 3: Autenticación (si está habilitada)\nA partir de la 0.9.11, la autenticación puede incluirse en GetDateMessage (mensaje de obtención de fecha) mediante un Mapping (estructura de mapeo) que contenga: - i2cp.username - i2cp.password\nA partir de la 0.9.16, cuando la autenticación está habilitada, debe completarse mediante GetDateMessage antes de que se envíe cualquier otro mensaje.\nPaso 4: Creación de sesión\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) Paso 5: Señal de que el Tunnel está listo\nRouter → Client: RequestVariableLeaseSetMessage Este mensaje indica que los tunnels entrantes se han construido. El router NO enviará esto hasta que haya al menos un tunnel entrante Y un tunnel saliente.\nPaso 6: Publicación del LeaseSet\nClient → Router: CreateLeaseSet2Message En este punto, la sesión está plenamente operativa para enviar y recibir mensajes.\nPatrones de flujo de mensajes Mensaje saliente (el cliente envía al destino remoto) Con i2cp.messageReliability=none:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] Con i2cp.messageReliability=BestEffort:\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) Mensaje entrante (Router entrega al cliente) Con i2cp.fastReceive=true (predeterminado desde 0.9.4):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] Con i2cp.fastReceive=false (OBSOLETO):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage Los clientes modernos deberían usar siempre el modo de recepción rápida.\nEstructuras de datos comunes Encabezado de mensaje de I2CP Todos los mensajes de I2CP utilizan este encabezado común:\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ Longitud del cuerpo: entero de 4 bytes, solo la longitud del cuerpo del mensaje (excluye el encabezado) Tipo: entero de 1 byte, identificador del tipo de mensaje Cuerpo del mensaje: 0+ bytes, el formato varía según el tipo de mensaje Límite de tamaño del mensaje: Aproximadamente 64 KB como máximo.\nID de sesión Entero de 2 bytes que identifica de forma única una sesión en un router.\nValor especial: 0xFFFF indica \u0026ldquo;sin sesión\u0026rdquo; (se usa para la resolución de nombres de host sin una sesión establecida).\nID de mensaje Entero de 4 bytes generado por el router para identificar de forma única un mensaje dentro de una sesión.\nImportante: Los ID de mensaje no son globalmente únicos; solo son únicos dentro de una sesión. También son distintos del nonce (número único de un solo uso) generado por el cliente.\nFormato de la carga útil Las cargas útiles de los mensajes se comprimen con gzip con un encabezado gzip estándar de 10 bytes: - Comienza con: 0x1F 0x8B 0x08 (RFC 1952) - Desde la 0.7.1: Las partes no utilizadas del encabezado gzip contienen información de protocolo, from-port y to-port - Esto permite la transmisión (streaming) y los datagramas en el mismo destino\nControl de compresión: Configura i2cp.gzip=false para desactivar la compresión (establece el esfuerzo de gzip en 0). La cabecera de gzip sigue incluyéndose, pero con una sobrecarga mínima de compresión.\nEstructura de SessionConfig Define la configuración de una sesión de cliente:\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ Requisitos críticos: 1. El mapeo debe estar ordenado por clave para la validación de la firma 2. Fecha de creación debe estar dentro de ±30 segundos del tiempo actual del router 3. Firma es creada por la SigningPrivateKey (clave privada de firma) de la Destination (Destino de I2P)\nFirmas sin conexión (a partir de la versión 0.9.38):\nSi se utiliza la firma fuera de línea, el mapeo debe contener: - i2cp.leaseSetOfflineExpiration - i2cp.leaseSetTransientPublicKey - i2cp.leaseSetOfflineSignature\nLa firma se genera luego con la clave privada de firma transitoria.\nOpciones de configuración del núcleo Configuración del Tunnel Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) **Notas**: - Los valores de `quantity` \u003e 6 requieren pares que ejecuten 0.9.0+ y aumentan significativamente el uso de recursos - Establezca `backupQuantity` en 1-2 para servicios de alta disponibilidad - Los tunnels Zero-hop (sin saltos) sacrifican anonimato en favor de la latencia, pero son útiles para pruebas Gestión de mensajes Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) **Fiabilidad de los mensajes**: - `None`: Sin acuses de recibo del router (valor predeterminado de la biblioteca de streaming desde la versión 0.8.1) - `BestEffort`: El Router envía aceptación + notificaciones de éxito/fallo - `Guaranteed`: No implementado (actualmente se comporta como BestEffort) Anulación por mensaje (desde 0.9.14): - En una sesión con messageReliability=none, establecer un nonce (valor aleatorio único) distinto de cero solicita una notificación de entrega para ese mensaje específico - Establecer nonce=0 en una sesión BestEffort desactiva las notificaciones para ese mensaje\nConfiguración de LeaseSet Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) ### Etiquetas de sesión heredadas de ElGamal/AES Estas opciones solo son relevantes para el cifrado ElGamal heredado:\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch **Nota**: Los clientes ECIES-X25519 usan un mecanismo de ratchet (mecanismo de avance criptográfico) diferente e ignoran estas opciones. Tipos de cifrado I2CP admite múltiples esquemas de cifrado de extremo a extremo mediante la opción i2cp.leaseSetEncType. Se pueden especificar varios tipos (separados por comas) para admitir tanto pares modernos como heredados.\nTipos de cifrado admitidos Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned **Configuración recomendada**: i2cp.leaseSetEncType=4,0 Esto proporciona X25519 (preferido; intercambio de claves mediante curva elíptica) con un mecanismo de respaldo ElGamal (esquema criptográfico asimétrico) para compatibilidad.\nDetalles del tipo de cifrado Tipo 0 - ElGamal/AES+SessionTags (etiquetas de sesión): - Claves públicas ElGamal de 2048 bits (256 bytes) - Cifrado simétrico AES-256 - SessionTags de 32 bytes enviadas en lotes - Alta sobrecarga de CPU, ancho de banda y memoria - Se está retirando gradualmente en toda la red\nTipo 4 - ECIES-X25519-AEAD-Ratchet: - Intercambio de claves X25519 (claves de 32 bytes) - ChaCha20/Poly1305 AEAD - double ratchet estilo Signal (doble trinquete) - Etiquetas de sesión de 8 bytes (frente a 32 bytes para ElGamal) - Etiquetas generadas mediante PRNG sincronizado (no se envían por adelantado) - Reducción del ~92% en sobrecarga frente a ElGamal - Estándar para el I2P moderno (la mayoría de los routers lo usan)\nTipos 5-6 - Híbrido poscuántico: - Combina X25519 con ML-KEM (NIST FIPS 203) - Ofrece seguridad resistente a ataques cuánticos - ML-KEM-768 para seguridad y rendimiento equilibrados - ML-KEM-1024 para máxima seguridad - Tamaños de mensaje mayores debido al material de claves poscuánticas - El soporte en la red aún se está desplegando\nEstrategia de migración La red I2P está migrando activamente de ElGamal (tipo 0) a X25519 (tipo 4) (curva de clave elíptica): - NTCP → NTCP2 (completado) - SSU → SSU2 (completado) - ElGamal tunnels → X25519 tunnels (completado) - Cifrado de extremo a extremo con ElGamal → ECIES-X25519 (mayoritariamente completado)\nLeaseSet2 y funciones avanzadas Opciones de LeaseSet2 (desde 0.9.38) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) ### Direcciones cegadas A partir de la 0.9.39, los destinos pueden usar direcciones \u0026ldquo;blinded\u0026rdquo; (ocultadas) (formato b33) que cambian periódicamente: - Requiere i2cp.leaseSetSecret para protección por contraseña - Autenticación por cliente opcional - Consulte las propuestas 123 y 149 para más detalles\nRegistros de servicio (desde 0.9.66) LeaseSet2 admite opciones de registro de servicio (propuesta 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p El formato sigue el estilo de los registros SRV de DNS, pero adaptado para I2P.\nMúltiples sesiones (desde 0.9.21) Una única conexión I2CP puede mantener múltiples sesiones:\nSesión primaria: La primera sesión creada en una conexión Subsesiones: Sesiones adicionales que comparten el grupo de tunnel de la sesión primaria\nCaracterísticas de la subsesión Tunnels compartidos: Usa los mismos conjuntos de tunnel entrantes/salientes que la sesión principal Claves de cifrado compartidas: Debe usar claves de cifrado de LeaseSet idénticas Claves de firma diferentes: Debe usar claves de firma de Destino distintas Sin garantía de anonimato: Claramente vinculado a la sesión principal (mismo router, mismos tunnels) Caso de uso de Subsession (subsesión) Permite la comunicación con destinos que usan diferentes tipos de firma:\nPrincipal: firma EdDSA (moderna) Subsession (subsesión): firma DSA (compatibilidad con sistemas heredados) Ciclo de vida de la subsesión Creación:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) Destrucción: - Destruir una subsesión: deja la sesión principal intacta - Destruir la sesión principal: destruye todas las subsesiones y cierra la conexión - DisconnectMessage: destruye todas las sesiones\nGestión del ID de sesión La mayoría de los mensajes de I2CP contienen un campo ID de sesión. Excepciones: - DestLookup / DestReply (obsoleto, use HostLookup / HostReply) - GetBandwidthLimits / BandwidthLimits (la respuesta no es específica de la sesión)\nImportante: Los clientes no deberían tener múltiples mensajes CreateSession pendientes simultáneamente, ya que las respuestas no pueden correlacionarse inequívocamente con las solicitudes.\nCatálogo de mensajes Resumen de tipos de mensajes Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current **Leyenda**: C = Cliente, R = Router Detalles clave del mensaje CreateSessionMessage (Tipo 1) Propósito: Iniciar una nueva sesión de I2CP\nContenido: estructura de SessionConfig\nRespuesta: SessionStatusMessage (mensaje de estado de sesión) (status=Created or Invalid)\nRequisitos: - La fecha en SessionConfig debe estar dentro de ±30 segundos de la hora del router - El mapeo debe estar ordenado por clave para la validación de la firma - Destination (destino de I2P) no debe tener ya una sesión activa\nRequestVariableLeaseSetMessage (Tipo 37) Propósito: Router solicita autorización del cliente para tunnels entrantes\nContenido: - ID de sesión - Número de leases (concesiones temporales) - Arreglo de estructuras Lease (cada una con expiración individual)\nRespuesta: CreateLeaseSet2Message\nImportancia: Esta es la señal de que la sesión está operativa. El router envía esto solo después de: 1. Se ha construido al menos un tunnel entrante 2. Se ha construido al menos un tunnel saliente\nRecomendación de tiempo de espera: Los clientes deberían finalizar la sesión si este mensaje no se recibe en un plazo superior a 5 minutos desde la creación de la sesión.\nCreateLeaseSet2Message (Tipo 41) Propósito: El cliente publica el LeaseSet en la base de datos de la red\nContenido: - ID de sesión - byte de tipo de LeaseSet (1, 3, 5 o 7) - LeaseSet (estructura de I2P) o LeaseSet2 o EncryptedLeaseSet o MetaLeaseSet - Número de claves privadas - Lista de claves privadas (una por clave pública en LeaseSet, mismo orden)\nClaves privadas: Necesarias para descifrar los garlic messages (mensajes encapsulados de I2P) entrantes. Formato:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) Nota: Sustituye el CreateLeaseSetMessage obsoleto (tipo 4), que no admite: - Variantes de LeaseSet2 - Cifrado distinto de ElGamal - Múltiples tipos de cifrado - LeaseSets cifrados - Claves de firma sin conexión\nSendMessageExpiresMessage (Tipo 36) Propósito: Enviar un mensaje al destino con expiración y opciones avanzadas\nContenido: - ID de sesión - Destino - Carga útil (comprimida con gzip) - Nonce (4 bytes) - Indicadores (2 bytes) - ver más abajo - Fecha de expiración (6 bytes, truncada de 8)\nCampo de banderas (2 bytes, orden de bits 15\u0026hellip;0):\nBits 15-11: No utilizados, deben ser 0\nBits 10-9: Anulación de la fiabilidad del mensaje (sin uso, usar nonce (número de un solo uso) en su lugar)\nBit 8: No empaquetar LeaseSet - 0: Router puede empaquetar LeaseSet en garlic (técnica de cifrado de I2P) - 1: No empaquetar LeaseSet\nBits 7-4: Umbral bajo de etiquetas (solo ElGamal, se ignora en ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags Bits 3-0: Etiquetas que enviar si es necesario (solo para ElGamal, se ignora en ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage (Tipo 22) Propósito: Notificar al cliente sobre el estado de entrega del mensaje\nContenido: - ID de sesión - ID de mensaje (generado por el router) - Código de estado (1 byte) - Tamaño (4 bytes, solo relevante para status=0) - Nonce (4 bytes, coincide con el nonce de SendMessage del cliente)\nCódigos de estado (Mensajes salientes):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure **Códigos de éxito**: 1, 2, 4, 6 **Códigos de error**: Todos los demás Código de estado 0 (EN DESUSO): Mensaje disponible (entrante, recepción rápida deshabilitada)\nHostLookupMessage (mensaje de búsqueda de host) (Tipo 38) Propósito: Consultar destino por nombre de host o hash (reemplaza DestLookup)\nContenido: - ID de sesión (o 0xFFFF si no hay sesión) - ID de solicitud (4 bytes) - Tiempo de espera en milisegundos (4 bytes, mínimo recomendado: 10000) - Tipo de solicitud (1 byte) - Clave de búsqueda (Hash, cadena de nombre de host, o Destino)\nTipos de solicitud:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 Los tipos 2-4 devuelven opciones de LeaseSet (propuesta 167) si están disponibles. Respuesta: HostReplyMessage\nHostReplyMessage (Tipo 39) Propósito: Respuesta a HostLookupMessage (mensaje de búsqueda de host)\nContenido: - ID de sesión - ID de solicitud - Código de resultado (1 byte) - Destino (presente en caso de éxito, a veces en fallos específicos) - Mapeo (solo para tipos de búsqueda 2-4, puede estar vacío)\nCódigos de resultado:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type #### BlindingInfoMessage (mensaje de información de blinding) (Tipo 42) Propósito: Informar al router sobre los requisitos de autenticación de blinded destination (destino cegado) (desde 0.9.43)\nContenido: - ID de sesión - Indicadores (1 byte) - Tipo de endpoint (extremo) (1 byte): 0=Hash, 1=nombre de host, 2=Destination (destino en I2P), 3=SigType+Key - Tipo de firma ciega (2 bytes) - Expiración (4 bytes, segundos desde la época Unix) - Datos del endpoint (varía según el tipo) - Clave privada (32 bytes, solo si el bit 0 de los indicadores está activado) - Contraseña de consulta (cadena, solo si el bit 4 de los indicadores está activado)\nIndicadores (orden de bits 76543210):\nBit 0: 0=todos, 1=por cliente Bits 3-1: Esquema de autenticación (si el bit 0=1): 000=DH, 001=PSK Bit 4: 1=se requiere secreto Bits 7-5: No utilizado, establecer en 0 Sin respuesta: El Router procesa en silencio\nCaso de uso: Antes de enviar a un destino cegado (b33 address), el cliente debe hacer una de las dos cosas: 1. Consultar la dirección b33 mediante HostLookup, O 2. Enviar el mensaje BlindingInfo\nSi el destino requiere autenticación, BlindingInfo (información de cegamiento) es obligatorio.\nReconfigureSessionMessage (Tipo 2) Propósito: Actualizar la configuración de la sesión después de su creación\nContenido: - ID de sesión - SessionConfig (solo se necesitan las opciones cambiadas)\nRespuesta: SessionStatusMessage (status=Updated o Invalid)\nNotas: - El router fusiona la nueva configuración con la existente - Las opciones de Tunnel (inbound.*, outbound.*) se aplican siempre - Algunas opciones pueden ser inmutables después de la creación de la sesión - La fecha debe estar dentro de ±30 segundos del tiempo del router - El mapeo debe estar ordenado por clave\nDestroySessionMessage (Tipo 3) Propósito: Finalizar una sesión\nContenido: ID de sesión\nRespuesta esperada: SessionStatusMessage (mensaje de estado de la sesión) (status=Destroyed)\nComportamiento real (Java I2P hasta la versión 0.9.66): - Router nunca envía SessionStatus(Destroyed) - Si no quedan sesiones: Envía DisconnectMessage - Si quedan subsesiones: Sin respuesta\nImportante: el comportamiento de Java I2P se desvía de la especificación. Las implementaciones deben ser cautelosas al destruir subsesiones individuales.\nDisconnectMessage (Tipo 30) Propósito: Notificar que la conexión está a punto de finalizar\nContenido: Motivo (cadena)\nEfecto: Todas las sesiones en la conexión se destruyen, el socket se cierra\nImplementación: Principalmente router → cliente en Java I2P\nHistorial de versiones del protocolo Detección de versiones La versión del protocolo I2CP se intercambia en los mensajes Get/SetDate (desde 0.8.7). Para routers más antiguos, la información de la versión no está disponible.\nCadena de versión: Indica la versión de la API \u0026ldquo;core\u0026rdquo; (núcleo), no necesariamente la versión del router.\nCronología de funcionalidades Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features ## Consideraciones de seguridad Autenticación Predeterminado: No se requiere autenticación Opcional: Autenticación con nombre de usuario/contraseña (desde 0.9.11) Obligatorio: Cuando está habilitado, la autenticación debe completarse antes de otros mensajes (desde 0.9.16)\nConexiones remotas: Utilice siempre TLS (i2cp.SSL=true) para proteger las credenciales y las claves privadas.\nDesfase del reloj SessionConfig Date debe estar dentro de ±30 segundos de la hora del router, o la sesión será rechazada. Use Get/SetDate para sincronizar.\nGestión de claves privadas CreateLeaseSet2Message (mensaje para crear un LeaseSet2) contiene claves privadas para descifrar mensajes entrantes. Estas claves deben ser: - Transmitidas de forma segura (TLS para conexiones remotas) - Almacenadas de forma segura por el router - Rotadas cuando estén comprometidas\nExpiración del mensaje Utiliza siempre SendMessageExpires (no SendMessage) para establecer una expiración explícita. Esto: - Evita que los mensajes queden en cola indefinidamente - Reduce el consumo de recursos - Mejora la fiabilidad\nGestión de etiquetas de sesión ElGamal (obsoleto): - Las etiquetas deben transmitirse en lotes - La pérdida de etiquetas provoca fallos de descifrado - Sobrecarga de memoria elevada\nECIES-X25519 (actual): - Etiquetas generadas mediante un generador de números pseudoaleatorios sincronizado (PRNG) - No se requiere transmisión previa - Resistente a la pérdida de mensajes - Sobrecarga significativamente menor\nMejores prácticas Para desarrolladores de clientes Usa el modo de recepción rápida: Establece siempre i2cp.fastReceive=true (o confía en el valor predeterminado)\nPrefiera ECIES-X25519: (suite de cifrado ECIES con X25519) Configure i2cp.leaseSetEncType=4,0 para obtener el mejor rendimiento manteniendo compatibilidad\nEstablecer expiración explícita: Usa SendMessageExpires, no SendMessage\nGestiona las Subsessions con cuidado: Ten en cuenta que las subsessions (subsesiones, sesiones secundarias asociadas a un mismo destino) no ofrecen anonimato entre destinos\nTiempo de espera en la creación de la sesión: Destruir la sesión si no se recibe RequestVariableLeaseSet en un plazo de 5 minutos\nOrdenar mapeos de configuración: Ordene siempre las claves del Mapping antes de firmar SessionConfig\nUsa recuentos de tunnel adecuados: No configures quantity \u0026gt; 6 a menos que sea necesario\nConsidere SAM/BOB para entornos no Java: Implemente SAM en lugar de I2CP directamente\nPara desarrolladores del router Validar fechas: Aplicar una ventana de ±30 segundos en las fechas de SessionConfig\nLimitar el tamaño del mensaje: Aplicar un tamaño máximo de ~64 KB\nSoporte para múltiples sesiones: Implementar soporte de subsesiones según la especificación 0.9.21\nEnviar RequestVariableLeaseSet de inmediato: Solo después de que existan ambos tunnels, entrantes y salientes\nGestionar mensajes obsoletos: Aceptar pero desaconsejar ReceiveMessageBegin/End\nSoporte para ECIES-X25519 (ECIES con curva X25519): Priorizar el cifrado de tipo 4 para nuevos despliegues\nDepuración y solución de problemas Problemas comunes Sesión rechazada (inválida): - Compruebe el desfase del reloj (debe estar dentro de ±30 segundos) - Verifique que el mapeo esté ordenado por clave - Asegúrese de que el Destino no esté ya en uso\nSin RequestVariableLeaseSet: - El Router puede estar construyendo tunnels (espere hasta 5 minutos) - Compruebe si hay problemas de conectividad de red - Verifique que haya suficientes conexiones con pares\nErrores en la entrega de mensajes: - Revise los códigos de MessageStatus para conocer el motivo específico del fallo - Verifique que el LeaseSet remoto esté publicado y actualizado - Asegúrese de que los tipos de cifrado sean compatibles\nProblemas de subsesión: - Verifica que la sesión primaria se cree primero - Confirma que se usen las mismas claves de cifrado - Comprueba que las claves de firma sean distintas\nMensajes de diagnóstico GetBandwidthLimits: Consultar la capacidad del router HostLookup: Probar la resolución de nombres y la disponibilidad del LeaseSet MessageStatus: Rastrear la entrega de mensajes de extremo a extremo\nEspecificaciones relacionadas Estructuras comunes: /docs/specs/common-structures/ I2NP (Protocolo de red): /docs/specs/i2np/ ECIES-X25519 (esquema ECIES con curva X25519): /docs/specs/ecies/ Creación de tunnel: /docs/specs/implementation/ Biblioteca de streaming: /docs/specs/streaming/ Biblioteca de datagramas: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ Propuestas referenciadas Propuesta 123 : LeaseSets cifrados y autenticación Propuesta 144 : ECIES-X25519-AEAD-Ratchet Propuesta 149 : Formato de dirección cegada (b33) Propuesta 152 : Creación de tunnel X25519 Propuesta 154 : Búsquedas en base de datos desde destinos ECIES Propuesta 156 : Migración del router a ECIES-X25519 Propuesta 161 : Compresión del relleno de destino Propuesta 167 : Registros de servicio de LeaseSet Propuesta 169 : Criptografía híbrida poscuántica (ML-KEM) Referencia de Javadocs Paquete de I2CP MessageStatusMessage API del cliente Resumen de deprecación Mensajes obsoletos (No usar) CreateLeaseSetMessage (tipo 4): Utilice CreateLeaseSet2Message RequestLeaseSetMessage (tipo 21): Utilice RequestVariableLeaseSetMessage ReceiveMessageBeginMessage (tipo 6): Utilice el modo de recepción rápida ReceiveMessageEndMessage (tipo 7): Utilice el modo de recepción rápida DestLookupMessage (tipo 34): Utilice HostLookupMessage DestReplyMessage (tipo 35): Utilice HostReplyMessage ReportAbuseMessage (tipo 29): Nunca implementado Opciones obsoletas Cifrado ElGamal (tipo 0): Migrar a ECIES-X25519 (tipo 4) Firmas DSA: Migrar a EdDSA o ECDSA i2cp.fastReceive=false: Usar siempre el modo de recepción rápida ","description":"Cómo las aplicaciones negocian sesiones, tunnels y LeaseSets con el router de I2P.","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"Protocolo de Cliente de I2P (I2CP)","url":"/es/docs/specs/i2cp/"},{"categories":null,"content":"Descripción general El Protocolo de Red de I2P (I2NP) define cómo los routers intercambian mensajes, seleccionan transportes y mezclan el tráfico manteniendo el anonimato. Opera entre I2CP (API de cliente) y los protocolos de transporte (NTCP2 y SSU2).\nI2NP es la capa por encima de los protocolos de transporte de I2P. Es un protocolo de router a router utilizado para: - Búsquedas y respuestas en la base de datos de la red - Creación de tunnels - Mensajes cifrados de datos de router y de cliente\nLos mensajes I2NP pueden enviarse punto a punto a otro router, o de forma anónima a través de tunnels a ese router.\nLos routers ponen en cola el trabajo saliente usando prioridades locales. Los números de prioridad más altos se procesan primero. Cualquier valor por encima de la prioridad estándar de datos de tunnel (400) se considera urgente.\nTransportes actuales I2P ahora utiliza NTCP2 (TCP) y SSU2 (UDP) tanto para IPv4 como para IPv6. Ambos transportes emplean: - X25519 para el intercambio de claves (marco del protocolo Noise) - ChaCha20/Poly1305 cifrado autenticado (AEAD) - SHA-256 (función de hash)\nSe retiraron los transportes heredados: - NTCP (TCP original) se eliminó del router de Java en la versión 0.9.50 (mayo de 2021) - SSU v1 (UDP original) se eliminó del router de Java en la versión 2.4.0 (diciembre de 2023) - SSU v1 se eliminó de i2pd en la versión 2.44.0 (noviembre de 2022)\nA partir de 2025, la red ha migrado por completo a transportes basados en Noise, sin soporte alguno para transportes heredados.\nSistema de numeración de versiones IMPORTANTE: I2P utiliza un sistema de versionado dual que debe entenderse claramente:\nVersiones de lanzamiento (de cara al usuario) Estas son las versiones que los usuarios ven y descargan: - 0.9.50 (mayo de 2021) - Última versión 0.9.x - 1.5.0 (agosto de 2021) - Primera versión 1.x - 1.6.0, 1.7.0, 1.8.0, 1.9.0 (entre 2021 y 2022) - 2.0.0 (noviembre de 2022) - Primera versión 2.x - 2.1.0 a 2.9.0 (entre 2023 y 2025) - 2.10.0 (8 de septiembre de 2025) - Versión actual\nVersiones de la API (Compatibilidad del protocolo) Estos son números de versión internos publicados en el campo \u0026ldquo;router.version\u0026rdquo; en las propiedades de RouterInfo: - 0.9.50 (mayo de 2021) - 0.9.51 (agosto de 2021) - Versión de la API para el lanzamiento 1.5.0 - 0.9.52 a 0.9.66 (continuando en los lanzamientos 2.x) - 0.9.67 (septiembre de 2025) - Versión de la API para el lanzamiento 2.10.0\nPunto clave: NO hubo versiones numeradas de la 0.9.51 a la 0.9.67. Estos números existen solo como identificadores de versión de la API. I2P saltó de la versión 0.9.50 directamente a la 1.5.0.\nTabla de correspondencia de versiones Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) **Próximamente:** La versión 2.11.0 (prevista para diciembre de 2025) requerirá Java 17+ y habilitará por defecto la criptografía poscuántica. Versiones de protocolo Todos los routers deben publicar su versión del protocolo I2NP en el campo \u0026ldquo;router.version\u0026rdquo; en las propiedades de RouterInfo. Este campo de versión es la versión de la API, que indica el nivel de compatibilidad con varias funciones del protocolo I2NP, y no es necesariamente la versión real del router.\nSi los routers alternativos (no Java) desean publicar cualquier información de versión sobre la implementación real del router, deben hacerlo en otra propiedad. Se permiten versiones distintas de las que se enumeran a continuación. La compatibilidad se determinará mediante una comparación numérica; por ejemplo, 0.9.13 implica compatibilidad con las funcionalidades de la versión 0.9.12.\nNota: La propiedad \u0026ldquo;coreVersion\u0026rdquo; ya no se publica en la información del router y nunca se utilizó para determinar la versión del protocolo I2NP.\nResumen de características por versión de la API API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network **Nota:** También hay características relacionadas con el transporte y problemas de compatibilidad. Consulte la documentación de transporte de NTCP2 (protocolo de transporte de I2P) y SSU2 (protocolo de transporte de I2P) para obtener detalles. Encabezado del mensaje I2NP utiliza una estructura lógica de encabezado de 16 bytes, mientras que los transportes modernos (NTCP2 y SSU2) usan un encabezado abreviado de 9 bytes que omite los campos redundantes de tamaño y suma de verificación. Los campos siguen siendo conceptualmente idénticos.\nComparación de formatos de encabezado Formato estándar (16 bytes):\nSe usa en el transporte NTCP legado y cuando los mensajes I2NP están encapsulados dentro de otros mensajes (TunnelData, TunnelGateway, GarlicClove).\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity Formato corto para SSU (obsoleto, 5 bytes):\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) Formato abreviado para NTCP2, SSU2 y ECIES-Ratchet Garlic Cloves (9 bytes):\nSe utiliza en transportes modernos y en garlic messages (mensajes \u0026ldquo;garlic\u0026rdquo;, técnica de empaquetado de mensajes en I2P) cifrados con ECIES.\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) Detalles de los campos de cabecera Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity ### Notas de implementación Cuando se transmite por SSU (obsoleto), solo se incluían el tipo y la expiración de 4 bytes Cuando se transmite por NTCP2 o SSU2, se utiliza el formato corto de 9 bytes El encabezado estándar de 16 bytes es obligatorio para los mensajes I2NP contenidos en otros mensajes (Data, TunnelData, TunnelGateway, GarlicClove) Desde la versión 0.8.12, la verificación de la suma de comprobación está deshabilitada en algunos puntos de la pila del protocolo por eficiencia, pero la generación de la suma de comprobación sigue siendo necesaria por compatibilidad La expiración corta es sin signo y se desbordará el 7 de febrero de 2106. Después de esa fecha, debe añadirse un desplazamiento para obtener la hora correcta Por compatibilidad con versiones anteriores, genere siempre sumas de comprobación aunque puede que no se verifiquen Restricciones de tamaño Los mensajes de Tunnel fragmentan las cargas útiles de I2NP en piezas de tamaño fijo:\nPrimer fragmento: aproximadamente 956 bytes Fragmentos posteriores: aproximadamente 996 bytes cada uno Máximo de fragmentos: 64 (numerados 0-63) Carga útil máxima: aproximadamente 61,200 bytes (61.2 KB) Cálculo: 956 + (63 × 996) = 63,704 bytes máximo teórico, con un límite práctico de alrededor de 61,200 bytes debido a la sobrecarga.\nContexto histórico Los transportes antiguos tenían límites más estrictos de tamaño de trama: - NTCP: tramas de 16 KB - SSU: tramas de aproximadamente 32 KB\nNTCP2 admite tramas de aproximadamente 65 KB, pero el límite de fragmentación del tunnel sigue aplicándose.\nConsideraciones sobre los datos de la aplicación Garlic messages (técnica de agrupación de mensajes en I2P) pueden agrupar LeaseSets, Session Tags (etiquetas de sesión), o variantes cifradas de LeaseSet2, reduciendo el espacio para los datos de la carga útil.\nRecomendación: Los datagramas deben mantenerse ≤ 10 KB para garantizar una entrega fiable. Los mensajes que se acerquen al límite de 61 KB pueden experimentar: - Mayor latencia debido al reensamblado de fragmentos - Mayor probabilidad de fallo en la entrega - Mayor exposición al análisis de tráfico\nDetalles técnicos de la fragmentación Cada mensaje de tunnel tiene exactamente 1,024 bytes (1 KB) y contiene: - ID de tunnel de 4 bytes - vector de inicialización (IV) de 16 bytes - 1,004 bytes de datos cifrados\nDentro de los datos cifrados, los mensajes de tunnel transportan mensajes I2NP fragmentados con cabeceras de fragmento que indican: - Número de fragmento (0-63) - Si es el primer fragmento o uno posterior - ID total del mensaje para el reensamblado\nEl primer fragmento incluye el encabezado completo del mensaje I2NP (16 bytes), dejando aproximadamente 956 bytes para la carga útil. Los fragmentos posteriores no incluyen el encabezado del mensaje, lo que permite aproximadamente 996 bytes de carga útil por fragmento.\nTipos comunes de mensajes Los Routers utilizan el tipo de mensaje y la prioridad para programar el trabajo saliente. Los valores de mayor prioridad se procesan primero. Los siguientes valores coinciden con los predeterminados actuales de Java I2P (a partir de la versión de la API 0.9.67).\nNota: Las prioridades dependen de la implementación. Para obtener los valores de prioridad oficiales, consulte la documentación de la clase OutNetMessage en el código fuente de I2P en Java.\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) **Tipos de mensajes reservados:** - Tipo 0: Reservado - Tipos 4-9: Reservados para uso futuro - Tipos 12-17: Reservados para uso futuro - Tipos 224-254: Reservados para mensajes experimentales - Tipo 255: Reservado para expansión futura Notas sobre tipos de mensaje Mensajes del plano de control (DatabaseLookup, TunnelBuild, etc.) generalmente viajan a través de tunnels exploratorios, no de tunnels de cliente, lo que permite una priorización independiente Los valores de prioridad son aproximados y pueden variar según la implementación TunnelBuild (21) y TunnelBuildReply (22) están obsoletos, pero siguen implementados para compatibilidad con tunnels muy largos (\u0026gt;8 saltos) La prioridad estándar de los datos de tunnel es 400; cualquier valor por encima de esto se trata como urgente La longitud típica de un tunnel en la red actual es de 3-4 saltos, por lo que la mayoría de las construcciones de tunnels usan ShortTunnelBuild (registros de 218 bytes) o VariableTunnelBuild (registros de 528 bytes) Cifrado y encapsulación de mensajes Los Routers encapsulan con frecuencia mensajes I2NP antes de la transmisión, creando múltiples capas de cifrado. Un DeliveryStatus message (mensaje de estado de entrega) puede estar: 1. Envuelto en un GarlicMessage (mensaje de tipo GarlicMessage; cifrado) 2. Dentro de un DataMessage (mensaje de datos) 3. Dentro de un TunnelData message (mensaje de datos de tunnel; cifrado de nuevo)\nCada salto solo descifra su capa; el destino final revela la carga útil más interna.\nAlgoritmos de cifrado Legado (en proceso de retirada): - ElGamal/AES + SessionTags (etiquetas de sesión) - ElGamal-2048 para cifrado asimétrico - AES-256 para cifrado simétrico - SessionTags de 32 bytes\nActual (Estándar a partir de la API 0.9.48): - ECIES-X25519 + ChaCha20/Poly1305 AEAD con ratcheting forward secrecy (secreto hacia adelante mediante un mecanismo de rotación progresiva de claves) - marco del protocolo Noise (Noise_IK_25519_ChaChaPoly_SHA256 para destinos) - etiquetas de sesión de 8 bytes (reducidas de 32 bytes) - algoritmo Signal Double Ratchet para secreto hacia adelante - Introducido en la versión 0.9.46 de la API (2020) - Obligatorio para todos los routers desde la versión 0.9.58 de la API (2023)\nFuturo (Beta a partir de la 2.10.0): - Criptografía híbrida poscuántica usando MLKEM (ML-KEM-768) combinada con X25519 - Hybrid ratchet (ratchet híbrido: mecanismo de avance de claves) que combina acuerdo de claves clásico y poscuántico - Retrocompatible con ECIES-X25519 - Se convertirá en el valor predeterminado en la versión 2.11.0 (diciembre de 2025)\nDesuso del Router ElGamal CRÍTICO: Los routers ElGamal quedaron obsoletos a partir de la versión 0.9.58 de la API (lanzamiento 2.2.0, marzo de 2023). Dado que la versión mínima recomendada de floodfill para consultar ahora es la 0.9.58, las implementaciones no necesitan implementar cifrado para routers floodfill ElGamal.\nSin embargo: Los destinos ElGamal se siguen admitiendo por compatibilidad con versiones anteriores. Los clientes que usan cifrado ElGamal todavía pueden comunicarse a través de routers ECIES.\nDetalles de ECIES-X25519-AEAD-Ratchet (mecanismo de cifrado autenticado con intercambio de claves ECIES basado en X25519 y un ratchet AEAD) Este es el tipo criptográfico 4 en la especificación de criptografía de I2P. Proporciona:\nCaracterísticas clave: - Secreto hacia adelante mediante ratcheting (mecanismo de actualización escalonada de claves; nuevas claves para cada mensaje) - Almacenamiento reducido de etiquetas de sesión (8 bytes frente a 32 bytes) - Varios tipos de sesión (New Session, Existing Session, One-Time) - Basado en el protocolo Noise Noise_IK_25519_ChaChaPoly_SHA256 - Integrado con el algoritmo Double Ratchet de Signal\nPrimitivas criptográficas: - X25519 para acuerdo de claves Diffie-Hellman - ChaCha20 para cifrado de flujo - Poly1305 para autenticación de mensajes (AEAD, cifrado y autenticación con datos asociados) - SHA-256 para cálculo de hash - HKDF para derivación de claves\nGestión de sesiones: - Sesión nueva: Conexión inicial usando una clave de destino estática - Sesión existente: Mensajes posteriores usando etiquetas de sesión - Sesión de una sola vez: Sesiones de un único mensaje para menor sobrecarga\nConsulte la Especificación ECIES y la Propuesta 144 para obtener detalles técnicos completos.\nEstructuras comunes Las siguientes estructuras son elementos de múltiples mensajes I2NP. No son mensajes completos.\nBuildRequestRecord (registro de solicitud de construcción) (ElGamal) OBSOLETO. Solo se usa en la red actual cuando un tunnel contiene un router ElGamal. Consulta Creación de tunnel ECIES para el formato moderno.\nPropósito: Un registro dentro de un conjunto de múltiples registros para solicitar la creación de un salto en el tunnel.\nFormato:\nCifrado con ElGamal y AES (528 bytes en total):\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Estructura cifrada con ElGamal (528 bytes):\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) Estructura en texto claro (222 bytes antes del cifrado):\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data Notas: - El cifrado ElGamal-2048 produce un bloque de 514 bytes, pero se eliminan los dos bytes de relleno (en las posiciones 0 y 257), quedando en 512 bytes - Véase Especificación de creación de Tunnel para los detalles de los campos - Código fuente: net.i2p.data.i2np.BuildRequestRecord - Constante: EncryptedBuildRecord.RECORD_SIZE = 528\nBuildRequestRecord (registro de solicitud de construcción) (ECIES-X25519 Long) Para los router ECIES-X25519, introducidos en la versión 0.9.48 de la API. Usa 528 bytes para compatibilidad con versiones anteriores con tunnel mixtos.\nFormato:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) Tamaño total: 528 bytes (igual que ElGamal por compatibilidad)\nConsulta ECIES Tunnel Creation para conocer la estructura del texto en claro y los detalles del cifrado.\nBuildRequestRecord (registro de solicitud de construcción) (ECIES-X25519 corto) Solo para routers ECIES-X25519 (ECIES con X25519), a partir de la versión 0.9.51 de la API (lanzamiento 1.5.0). Este es el formato estándar actual.\nFormato:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) Tamaño total: 218 bytes (reducción del 59% respecto a 528 bytes)\nDiferencia clave: Los registros cortos derivan TODAS las claves mediante HKDF (función de derivación de claves) en lugar de incluirlas explícitamente en el registro. Esto incluye: - Claves de capa (para el cifrado de tunnel) - Claves de IV (para el cifrado de tunnel) - Claves de respuesta (para build reply, respuesta de construcción) - IVs de respuesta (para build reply)\nTodas las claves se derivan utilizando el mecanismo HKDF del protocolo Noise, a partir del secreto compartido del intercambio de claves X25519.\nBeneficios: - 4 registros cortos caben en un mensaje de tunnel (873 bytes) - 3 mensajes de construcción de tunnel en lugar de mensajes separados para cada registro - Ancho de banda y latencia reducidos - Las mismas propiedades de seguridad que el formato largo\nConsulte Proposal 157 para la justificación y Creación de tunnel ECIES para la especificación completa.\nCódigo fuente: - net.i2p.data.i2np.ShortEncryptedBuildRecord - Constante: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nBuildResponseRecord (registro de respuesta de construcción) (ElGamal) OBSOLETO. Solo se usa cuando el tunnel contiene un router ElGamal.\nPropósito: Un registro dentro de un conjunto de múltiples registros con respuestas a una solicitud de construcción.\nFormato:\nCifrado (528 bytes, mismo tamaño que BuildRequestRecord):\nbytes 0-527 :: AES-encrypted record Estructura sin cifrar:\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) Códigos de respuesta: - 0 - Aceptar - 30 - Rechazar (ancho de banda excedido)\nConsulte Especificación de creación de Tunnel para obtener detalles sobre el campo de respuesta.\nBuildResponseRecord (ECIES-X25519, esquema de cifrado ECIES con curva X25519) Para routers ECIES-X25519, versión de API 0.9.48+. Mismo tamaño que la solicitud correspondiente (528 para la larga, 218 para la corta).\nFormato:\nFormato largo (528 bytes):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Formato corto (218 bytes):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Estructura de texto en claro (ambos formatos):\nContiene una estructura Mapping (formato clave-valor de I2P) con: - Código de estado de respuesta (obligatorio) - Parámetro de ancho de banda disponible (\u0026ldquo;b\u0026rdquo;) (opcional, añadido en la API 0.9.65) - Otros parámetros opcionales para futuras extensiones\nCódigos de estado de respuesta: - 0 - Éxito - 30 - Rechazo: ancho de banda excedido\nConsulte Creación de Tunnel ECIES para la especificación completa.\nGarlicClove (submensaje \u0026ldquo;clove\u0026rdquo; de garlic encryption) (ElGamal/AES) ADVERTENCIA: Este es el formato utilizado para las garlic cloves (submensajes del esquema garlic) dentro de los garlic messages (mensajes del esquema garlic) cifrados con ElGamal. El formato para los garlic messages y las garlic cloves de ECIES-AEAD-X25519-Ratchet es significativamente diferente. Consulta Especificación de ECIES para el formato moderno.\nObsoleto para routers (API 0.9.58+), aún compatible para destinos.\nFormato:\nSin cifrar:\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) Notas: - Los clove (submensaje dentro de un GarlicMessage) nunca se fragmentan - Cuando el primer bit del byte de indicadores de Delivery Instructions es 0, el clove no está cifrado - Cuando el primer bit es 1, el clove está cifrado (función no implementada) - La longitud máxima es una función de la suma de longitudes de los clove y de la longitud máxima de GarlicMessage (mensaje de I2NP que encapsula múltiples cloves) - El certificado podría usarse con HashCash para \u0026ldquo;pagar\u0026rdquo; el enrutamiento (posible función futura) - Mensajes usados en la práctica: DataMessage, DeliveryStatusMessage, DatabaseStoreMessage - GarlicMessage puede contener GarlicMessage (anidamiento de GarlicMessage), pero esto no se usa en la práctica\nConsulte Garlic Routing (enrutamiento Garlic) para una visión general conceptual.\nGarlicClove (submensaje en garlic encryption de I2P) (ECIES-X25519-AEAD-Ratchet) Para routers y destinos ECIES-X25519 (esquema criptográfico ECIES basado en X25519), versión de la API 0.9.46+. Este es el formato estándar actual.\nDIFERENCIA CRÍTICA: ECIES garlic utiliza una estructura completamente distinta basada en bloques del protocolo Noise, en lugar de estructuras de clove (submensaje en garlic encryption) explícitas.\nFormato:\nLos mensajes garlic (técnica de encapsulación de múltiples mensajes en I2P) de ECIES contienen una serie de bloques:\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data Tipos de bloques: - 0 - Garlic Clove Block (contiene un mensaje I2NP) - 1 - Bloque de fecha y hora (marca de tiempo) - 2 - Bloque de opciones (opciones de entrega) - 3 - Bloque de relleno - 254 - Bloque de terminación (no implementado)\nGarlic Clove Block (bloque de diente de ajo) (tipo 0):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ Diferencias clave respecto al formato ElGamal: - Usa una expiración de 4 bytes (segundos desde la época) en lugar de un Date de 8 bytes - Sin campo de certificado - Envuelto en una estructura de bloques con tipo y longitud - Todo el mensaje cifrado con ChaCha20/Poly1305 AEAD - Gestión de sesión mediante ratcheting (encadenamiento de claves)\nConsulte la Especificación ECIES para obtener detalles completos sobre el marco del protocolo Noise y las estructuras de bloques.\nInstrucciones de entrega de Garlic Clove (submensaje individual dentro de un mensaje Garlic en I2P) Este formato se utiliza tanto para los dientes de ajo de ElGamal como de ECIES. Especifica cómo entregar el mensaje contenido.\nADVERTENCIA CRÍTICA: Esta especificación es ÚNICAMENTE para Instrucciones de entrega dentro de Garlic Cloves (submensajes de garlic encryption). Las \u0026ldquo;Instrucciones de entrega\u0026rdquo; también se usan dentro de Mensajes de tunnel, donde el formato es significativamente diferente. Vea la Especificación de mensajes de tunnel para las instrucciones de entrega de tunnel. NO confunda estos dos formatos.\nFormato:\nLa clave de sesión y el retardo no se utilizan y nunca están presentes, por lo que las tres longitudes posibles son: - 1 byte (LOCAL) - 33 bytes (ROUTER y DESTINO) - 37 bytes (TUNNEL)\n+----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds Longitudes típicas: - entrega LOCAL: 1 byte (solo bandera) - entrega ROUTER / DESTINO: 33 bytes (bandera + hash) - entrega TUNNEL: 37 bytes (bandera + hash + ID de tunnel)\nDescripciones de los tipos de entrega:\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router **Notas de implementación:** - El cifrado de clave de sesión no está implementado y el bit de indicador siempre es 0 - El retraso no está completamente implementado y el bit de indicador siempre es 0 - Para la entrega TUNNEL, el hash identifica el router de puerta de enlace y el tunnel ID especifica qué tunnel de entrada - Para la entrega DESTINATION, el hash es el SHA-256 de la clave pública del destino - Para la entrega ROUTER, el hash es el SHA-256 de la identidad del router Mensajes de I2NP Especificaciones completas de mensajes para todos los tipos de mensajes de I2NP.\nResumen de tipos de mensaje Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active **Reservado:** - Tipo 0: Reservado - Tipos 4-9: Reservados para uso futuro - Tipos 12-17: Reservados para uso futuro - Tipos 224-254: Reservados para mensajes experimentales - Tipo 255: Reservado para expansión futura DatabaseStore (Tipo 1) Propósito: Un almacenamiento en la base de datos no solicitado, o la respuesta a un mensaje DatabaseLookup (búsqueda en la base de datos) exitoso.\nContenido: Un LeaseSet, LeaseSet2, MetaLeaseSet o EncryptedLeaseSet sin comprimir, o un RouterInfo (información del router) comprimido.\nFormato con el token de respuesta:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet Formato con token de respuesta == 0:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// Notas: - Por seguridad, los campos de respuesta se ignoran si el mensaje se recibe a través de un tunnel - La clave es el hash «real» de la RouterIdentity (identidad del router) o Destination (destino), NO la routing key (clave de enrutamiento) - Los tipos 3, 5 y 7 (variantes de LeaseSet2) se añadieron en la versión 0.9.38 (API 0.9.38). Consulte Propuesta 123 para más detalles - Estos tipos solo deben enviarse a routers con versión de API 0.9.38 o superior - Como optimización para reducir conexiones, si el tipo es un LeaseSet, se incluye el token de respuesta, el ID de tunnel de respuesta es distinto de cero, y el par puerta de enlace/tunnelID de respuesta se encuentra en el LeaseSet como un lease (arrendamiento), el destinatario puede redirigir la respuesta a cualquier otro lease en el LeaseSet - Formato gzip de RouterInfo: Para ocultar el SO del router y la implementación, imite la implementación del router en Java estableciendo la hora de modificación en 0 y el byte del SO en 0xFF, y establezca XFL en 0x02 (compresión máxima, algoritmo más lento) según la RFC 1952. Primeros 10 bytes: 1F 8B 08 00 00 00 00 00 02 FF\nCódigo fuente: - net.i2p.data.i2np.DatabaseStoreMessage - net.i2p.data.RouterInfo (para la estructura RouterInfo) - net.i2p.data.LeaseSet (para la estructura LeaseSet)\nDatabaseLookup (Tipo 2) Propósito: Una solicitud para consultar un elemento en la base de datos de la red (netDb). La respuesta es un DatabaseStore o un DatabaseSearchReply.\nFormato:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) Modos de cifrado de las respuestas:\nNOTA: Los routers ElGamal están obsoletos a partir de la API 0.9.58. Como la versión mínima recomendada de floodfill para consultar es ahora la 0.9.58, las implementaciones no necesitan implementar cifrado para los routers floodfill de ElGamal. Los destinos ElGamal siguen siendo compatibles.\nEl bit 4 de la bandera (ECIESFlag) se utiliza en combinación con el bit 1 (encryptionFlag) para determinar el modo de cifrado de la respuesta:\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future **Sin cifrado (flags 0,0):** reply_key, tags y reply_tags no están presentes.\nElG a ElG (indicadores 0,1) - OBSOLETO:\nCompatible desde la 0.9.7, obsoleto desde la 0.9.58.\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES (Esquema de Cifrado Integrado de Curva Elíptica) a ElG (ElGamal) (indicadores 1,0) - OBSOLETO:\nCompatible a partir de la versión 0.9.46, en desuso a partir de la versión 0.9.58.\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data La respuesta es un mensaje de sesión existente de ECIES tal como se define en Especificación de ECIES :\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES (Esquema de cifrado integrado basado en curvas elípticas) a ECIES (flags 1,0) - ESTÁNDAR ACTUAL:\nUn destino ECIES o un router envía una consulta a un router ECIES. Compatible desde la versión 0.9.49.\nEl mismo formato que \u0026ldquo;ECIES to ElG\u0026rdquo; de arriba. El cifrado del mensaje de búsqueda se especifica en ECIES Routers . El solicitante es anónimo.\nECIES (esquema de cifrado integrado con curvas elípticas) a ECIES con DH (Diffie-Hellman, intercambio de claves) (indicadores 1,1) - FUTURO:\nTodavía no está completamente definido. Consulte Propuesta 156 .\nNotas: - Antes de la 0.9.16, la clave podía corresponder a un RouterInfo (información del router) o a un LeaseSet (conjunto de arrendamientos) (mismo espacio de claves, sin indicador para distinguirlos) - Las respuestas cifradas solo son útiles cuando la respuesta es a través de un tunnel - El número de etiquetas incluidas (tags) podría ser mayor que uno si se implementan estrategias alternativas de búsqueda en DHT (tabla hash distribuida) - La clave de búsqueda y las claves de exclusión son los hashes \u0026ldquo;reales\u0026rdquo;, NO claves de enrutamiento - Los tipos 3, 5 y 7 (variantes de LeaseSet2) pueden devolverse a partir de la 0.9.38. Véase Propuesta 123 - Notas sobre la búsqueda exploratoria: Una búsqueda exploratoria se define como aquella que devuelve una lista de hashes que no son floodfill cercanos a la clave. Sin embargo, las implementaciones varían: Java sí busca la clave de búsqueda para un RI y devuelve un DatabaseStore (almacenamiento de base de datos) si está presente; i2pd no lo hace. Por lo tanto, no se recomienda usar una búsqueda exploratoria para hashes recibidos previamente\nCódigo fuente: - net.i2p.data.i2np.DatabaseLookupMessage - Cifrado: net.i2p.crypto.SessionKeyManager\nDatabaseSearchReply (Tipo 3) Propósito: La respuesta a un mensaje DatabaseLookup fallido.\nContenido: Una lista de hashes de router más cercanos a la clave solicitada.\nFormato:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from Notas: - El hash \u0026lsquo;from\u0026rsquo; no está autenticado y no puede considerarse confiable - Los hashes de pares devueltos no están necesariamente más cerca de la clave que el router consultado. Para respuestas a búsquedas normales, esto facilita el descubrimiento de nuevos floodfills y la búsqueda \u0026ldquo;hacia atrás\u0026rdquo; (más lejos de la clave) para mayor robustez - Para las búsquedas de exploración, la clave suele generarse aleatoriamente. Los peer_hashes que no son floodfill pueden seleccionarse usando un algoritmo optimizado (p. ej., pares cercanos pero no necesariamente los más cercanos) para evitar el ordenamiento ineficiente de toda la base de datos local. También pueden emplearse estrategias de almacenamiento en caché. Esto depende de la implementación - Número típico de hashes devueltos: 3 - Número máximo recomendado de hashes a devolver: 16 - La clave de búsqueda, los hashes de pares y el hash \u0026lsquo;from\u0026rsquo; son hashes \u0026ldquo;reales\u0026rdquo;, NO claves de enrutamiento - Si num es 0, esto indica que no se encontraron pares más cercanos (callejón sin salida)\nCódigo fuente: - net.i2p.data.i2np.DatabaseSearchReplyMessage\nDeliveryStatus (estado de entrega, Tipo 10) Propósito: Un acuse de recibo simple de un mensaje. Generalmente creado por el emisor del mensaje y encapsulado en un Garlic Message (mensaje Garlic de I2P que encapsula otros mensajes) junto con el propio mensaje, para que el destino lo devuelva.\nContenido: El ID del mensaje entregado y la hora de creación o de llegada.\nFormato:\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered Notas: - La marca de tiempo siempre la establece el creador a la hora actual. Sin embargo, en el código hay varios usos de esto y podrían añadirse más en el futuro - Este mensaje también se usa como confirmación de sesión establecida en SSU. En este caso, el ID del mensaje se establece en un número aleatorio, y el \u0026ldquo;arrival time\u0026rdquo; (hora de llegada) se establece en el ID actual a nivel de red, que es 2 (es decir, 0x0000000000000002) - DeliveryStatus (mensaje de estado de entrega) suele ir envuelto en un GarlicMessage (mensaje \u0026ldquo;garlic\u0026rdquo;) y se envía a través de un tunnel para proporcionar acuse de recibo sin revelar al remitente - Se utiliza para pruebas de tunnel con el fin de medir la latencia y la fiabilidad\nCódigo fuente: - net.i2p.data.i2np.DeliveryStatusMessage - Usado en: net.i2p.router.tunnel.InboundEndpointProcessor para pruebas de tunnel\nGarlicMessage (Tipo 11) ADVERTENCIA: Este es el formato utilizado para garlic messages cifrados con ElGamal (mensajes \u0026ldquo;garlic\u0026rdquo; de I2P, que agrupan múltiples mensajes en uno). El formato para los garlic messages de ECIES-AEAD-X25519-Ratchet es significativamente diferente. Consulta ECIES Specification para el formato actual.\nPropósito: Se utiliza para encapsular varios mensajes I2NP cifrados.\nContenido: Al descifrarse, consiste en una serie de Garlic Cloves (submensajes individuales) y datos adicionales, también llamado Clove Set (conjunto de submensajes).\nFormato cifrado:\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data Datos descifrados (Clove Set — conjunto de submensajes \u0026lsquo;cloves\u0026rsquo; en garlic encryption):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) Notas: - Cuando no está cifrado, los datos contienen uno o más Garlic Cloves - El bloque cifrado con AES se rellena hasta un mínimo de 128 bytes; con la Etiqueta de sesión de 32 bytes, el tamaño mínimo del mensaje cifrado es 160 bytes; con el campo de longitud de 4 bytes, el tamaño mínimo del Garlic Message (mensaje \u0026ldquo;Garlic\u0026rdquo;, formato de mensaje de I2P) es 164 bytes - La longitud máxima real es inferior a 64 KB (límite práctico de alrededor de 61.2 KB para mensajes de tunnel) - Consulte Especificación ElGamal/AES para obtener detalles de cifrado - Consulte Garlic Routing para una visión conceptual general - El tamaño mínimo de 128 bytes del bloque cifrado con AES no es configurable actualmente - El ID de mensaje generalmente se establece en un número aleatorio al transmitir y parece ignorarse al recibir - El certificado posiblemente podría usarse con HashCash para \u0026ldquo;pagar\u0026rdquo; el enrutamiento (posible función futura) - Estructura de cifrado ElGamal: etiqueta de sesión de 32 bytes + clave de sesión cifrada con ElGamal + carga útil cifrada con AES\nPara el formato ECIES-X25519-AEAD-Ratchet (estándar actual para routers):\nVéase Especificación de ECIES y Propuesta 144 .\nCódigo fuente: - net.i2p.data.i2np.GarlicMessage - Cifrado: net.i2p.crypto.elgamal.ElGamalAESEngine (obsoleto) - Cifrado moderno: net.i2p.crypto.ECIES paquetes\nTunnelData (Tipo 18) Propósito: Un mensaje enviado desde la puerta de enlace del tunnel o desde un participante al siguiente participante o al extremo. Los datos tienen longitud fija y contienen mensajes I2NP que están fragmentados, agrupados en lotes, rellenados y cifrados.\nFormato:\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes Estructura de la carga útil (1024 bytes):\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) Notas: - El ID de mensaje de I2NP para TunnelData (datos del tunnel) se establece en un nuevo número aleatorio en cada salto - El formato del mensaje de tunnel (dentro de los datos cifrados) está especificado en Especificación del mensaje de tunnel - Cada salto descifra una capa usando AES-256 en modo CBC - El IV (vector de inicialización) se actualiza en cada salto usando los datos descifrados - El tamaño total es exactamente 1,028 bytes (4 tunnelId + 1024 datos) - Esta es la unidad fundamental del tráfico de tunnel - Los mensajes TunnelData transportan mensajes I2NP fragmentados (GarlicMessage, DatabaseStore, etc.)\nCódigo fuente: - net.i2p.data.i2np.TunnelDataMessage - Constante: TunnelDataMessage.DATA_LENGTH = 1024 - Procesamiento: net.i2p.router.tunnel.InboundGatewayProcessor\nTunnelGateway (puerta de enlace de tunnel) (Tipo 19) Propósito: Encapsula otro mensaje I2NP para ser enviado dentro de un tunnel en la puerta de enlace de entrada de dicho tunnel.\nFormato:\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message Notas: - La carga útil es un mensaje I2NP con un encabezado estándar de 16 bytes - Se usa para inyectar mensajes en tunnels desde el router local - La puerta de enlace fragmenta el mensaje incluido si es necesario - Tras la fragmentación, los fragmentos se encapsulan en mensajes TunnelData - TunnelGateway nunca se envía por la red; es un tipo de mensaje interno usado antes del procesamiento del tunnel\nCódigo fuente: - net.i2p.data.i2np.TunnelGatewayMessage - Procesamiento: net.i2p.router.tunnel.OutboundGatewayProcessor\nDataMessage (mensaje de datos) (Tipo 20) Propósito: Utilizado por Garlic Messages (mensajes \u0026ldquo;garlic\u0026rdquo;) y Garlic Cloves (clavos \u0026ldquo;garlic\u0026rdquo;) para encapsular datos arbitrarios (normalmente datos de aplicación cifrados de extremo a extremo).\nFormato:\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message Notas: - Este mensaje no contiene información de enrutamiento y nunca se enviará \u0026ldquo;sin encapsular\u0026rdquo; - Solo se usa dentro de Garlic messages (mensajes Garlic de I2P) - Suele contener datos de aplicación cifrados de extremo a extremo (HTTP, IRC, correo electrónico, etc.) - Los datos suelen ser una carga útil cifrada con ElGamal/AES o ECIES - La longitud máxima práctica es de alrededor de 61,2 KB debido a los límites de fragmentación de mensajes de tunnel\nCódigo fuente: - net.i2p.data.i2np.DataMessage\nTunnelBuild (Tipo 21) OBSOLETO. Utilice VariableTunnelBuild (tipo 23) o ShortTunnelBuild (tipo 25).\nPropósito: Solicitud de construcción de tunnel de longitud fija para 8 saltos.\nFormato:\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes Notas: - A partir de la versión 0.9.48, puede contener ECIES-X25519 BuildRequestRecords (registros de solicitud de construcción). Véase Creación de tunnel ECIES - Véase Especificación de creación de tunnel para obtener detalles - El ID de mensaje I2NP para este mensaje debe establecerse según la especificación de creación de tunnel - Aunque rara vez se ve en la red actual (reemplazado por VariableTunnelBuild (construcción de túnel variable)), aún puede usarse para tunnels muy largos y no ha sido marcado formalmente como obsoleto - Routers aún deben implementar esto por compatibilidad - El formato fijo de 8 registros es inflexible y desperdicia ancho de banda para tunnels más cortos\nCódigo fuente: - net.i2p.data.i2np.TunnelBuildMessage - Constante: TunnelBuildMessageBase.MAX_RECORD_COUNT = 8\nTunnelBuildReply (Tipo 22) OBSOLETO. Usa VariableTunnelBuildReply (tipo 24) o OutboundTunnelBuildReply (tipo 26).\nPropósito: Respuesta de construcción de tunnel de longitud fija de 8 saltos.\nFormato:\nMismo formato que TunnelBuildMessage, con BuildResponseRecords en lugar de BuildRequestRecords.\nTotal size: 8 × 528 = 4,224 bytes Notas: - A partir de la versión 0.9.48, puede contener ECIES-X25519 BuildResponseRecords (registros de respuesta de construcción). Véase ECIES Tunnel Creation - Véase Tunnel Creation Specification para más detalles - El ID de mensaje I2NP de este mensaje debe establecerse de acuerdo con la Tunnel Creation Specification - Aunque rara vez se ve en la red actual (reemplazado por VariableTunnelBuildReply (respuesta de construcción de tunnel variable)), aún puede usarse para tunnels muy largos y no se ha declarado obsoleto formalmente - Los routers aún deben implementar esto por compatibilidad\nCódigo fuente: - net.i2p.data.i2np.TunnelBuildReplyMessage\nVariableTunnelBuild (Tipo 23) Propósito: Construcción de tunnel de longitud variable de 1 a 8 saltos. Admite tanto routers ElGamal como ECIES-X25519.\nFormato:\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Notas: - A partir de la 0.9.48, puede contener ECIES-X25519 BuildRequestRecords (registros de solicitud de construcción). Consulta Creación de Tunnel ECIES - Introducida en la versión 0.7.12 (2009) del router - Puede que no se envíe a participantes del tunnel anteriores a la versión 0.7.12 - Consulta Especificación de Creación de Tunnel para más detalles - El ID de mensaje de I2NP debe establecerse de acuerdo con la especificación de creación de tunnel - Número típico de registros: 4 (para un tunnel de 4 saltos) - Tamaño total típico: 1 + (4 × 528) = 2,113 bytes - Este es el mensaje estándar de construcción de tunnel para routers ElGamal - Los routers ECIES suelen usar ShortTunnelBuild (tipo 25) en su lugar\nCódigo fuente: - net.i2p.data.i2np.VariableTunnelBuildMessage\nVariableTunnelBuildReply (Tipo 24) Propósito: Respuesta de construcción de tunnel de longitud variable para 1-8 saltos. Es compatible con ambos routers, ElGamal y ECIES-X25519.\nFormato:\nEl mismo formato que VariableTunnelBuildMessage, con BuildResponseRecords en lugar de BuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Notas: - A partir de la versión 0.9.48, puede contener ECIES-X25519 BuildResponseRecords (registros BuildResponse de ECIES-X25519). Consulte ECIES Tunnel Creation - Introducido en la versión 0.7.12 del router (2009) - No puede enviarse a participantes del tunnel con versiones anteriores a la 0.7.12 - Consulte Tunnel Creation Specification para más detalles - El ID de mensaje de I2NP debe establecerse según la especificación de creación de tunnel - Número típico de registros: 4 - Tamaño total típico: 2,113 bytes\nCódigo fuente: - net.i2p.data.i2np.VariableTunnelBuildReplyMessage\nShortTunnelBuild (Tipo 25) Propósito: Mensajes cortos de construcción de tunnel solo para routers ECIES-X25519. Presentado en la versión de la API 0.9.51 (lanzamiento 1.5.0, agosto de 2021). Este es el estándar vigente para la construcción de tunnel con ECIES (Esquema de Cifrado Integrado sobre Curvas Elípticas).\nFormato:\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Notas: - Introducido en la versión del router 0.9.51 (lanzamiento 1.5.0, agosto de 2021) - No se debe enviar a participantes del tunnel con una API anterior a la versión 0.9.51 - Consulte ECIES Tunnel Creation para la especificación completa - Consulte Propuesta 157 para la justificación - Número típico de registros: 4 - Tamaño total típico: 1 + (4 × 218) = 873 bytes - Ahorro de ancho de banda: 59% más pequeño que VariableTunnelBuild (873 vs 2,113 bytes) - Beneficio de rendimiento: 4 registros cortos caben en un mensaje de tunnel; VariableTunnelBuild requiere 3 mensajes de tunnel - Este es ahora el formato estándar de construcción de tunnel para tunnels ECIES-X25519 puros - Los registros derivan claves mediante HKDF en lugar de incluirlas explícitamente\nCódigo fuente: - net.i2p.data.i2np.ShortTunnelBuildMessage - Constante: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nOutboundTunnelBuildReply (Tipo 26) Propósito: Enviado desde el extremo de salida de un nuevo tunnel al originador. Solo para routers ECIES-X25519. Introducido en la versión 0.9.51 de la API (lanzamiento 1.5.0, agosto de 2021).\nFormato:\nEl mismo formato que ShortTunnelBuildMessage, con ShortBuildResponseRecords en lugar de ShortBuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Notas: - Introducido en router versión 0.9.51 (lanzamiento 1.5.0, agosto de 2021) - Consulta ECIES Tunnel Creation para la especificación completa - Número típico de registros: 4 - Tamaño total típico: 873 bytes - Esta respuesta se envía desde el extremo de salida (OBEP) de vuelta al creador del tunnel a través del recién creado tunnel de salida - Proporciona confirmación de que todos los saltos aceptaron la construcción del tunnel\nCódigo fuente: - net.i2p.data.i2np.OutboundTunnelBuildReplyMessage\nReferencias Especificaciones oficiales Especificación de I2NP - Especificación completa del formato de mensajes de I2NP Estructuras comunes - Tipos de datos y estructuras utilizados en todo I2P Creación de tunnel - Creación de tunnel ElGamal (obsoleto) Creación de tunnel con ECIES - Creación de tunnel con ECIES-X25519 (actual) Mensaje de tunnel - Formato de los mensajes de tunnel e instrucciones de entrega Especificación de NTCP2 - Protocolo de transporte TCP Especificación de SSU2 - Protocolo de transporte UDP Especificación de ECIES - Cifrado ECIES-X25519-AEAD-Ratchet Especificación de criptografía - Primitivas criptográficas de bajo nivel Especificación de I2CP - Especificación del protocolo de cliente Especificación de datagramas - Formatos Datagram2 y Datagram3 Propuestas Propuesta 123 - Nuevas entradas de netDB (LeaseSet2, EncryptedLeaseSet, MetaLeaseSet) Propuesta 144 - Cifrado ECIES-X25519-AEAD-Ratchet (mecanismo de avance criptográfico) Propuesta 154 - Búsqueda cifrada en la base de datos Propuesta 156 - routers ECIES Propuesta 157 - Mensajes más pequeños para la construcción de tunnel (formato corto) Propuesta 159 - Transporte SSU2 Propuesta 161 - Relleno compresible Propuesta 163 - Datagram2 y Datagram3 Propuesta 167 - Parámetros del registro de servicio de LeaseSet Propuesta 168 - Parámetros de ancho de banda para la construcción de tunnel Propuesta 169 - Criptografía híbrida poscuántica Documentación Garlic Routing - Agrupación en capas de mensajes ElGamal/AES - Esquema de cifrado obsoleto Implementación de tunnel - Fragmentación y procesamiento Base de datos de red - Tabla hash distribuida Transporte NTCP2 - Especificación del transporte TCP Transporte SSU2 - Especificación del transporte UDP Introducción técnica - Descripción general de la arquitectura de I2P Código fuente Repositorio de Java I2P - Implementación oficial en Java Espejo en GitHub - Espejo en GitHub de Java I2P Repositorio de i2pd - Implementación en C++ Ubicaciones clave del código fuente Java I2P (i2pgit.org/I2P_Developers/i2p.i2p): - core/java/src/net/i2p/data/i2np/ - Implementaciones de mensajes I2NP - core/java/src/net/i2p/crypto/ - Implementaciones criptográficas - router/java/src/net/i2p/router/tunnel/ - Procesamiento de tunnel - router/java/src/net/i2p/router/transport/ - Implementaciones de transporte\nConstantes y valores: - I2NPMessage.MAX_SIZE = 65536 - Tamaño máximo de un mensaje I2NP - I2NPMessageImpl.HEADER_LENGTH = 16 - Tamaño de cabecera estándar - TunnelDataMessage.DATA_LENGTH = 1024 - Carga útil de un mensaje de tunnel - EncryptedBuildRecord.RECORD_SIZE = 528 - Registro de construcción largo - ShortEncryptedBuildRecord.RECORD_SIZE = 218 - Registro de construcción corto - TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - Máximo de registros por construcción\nApéndice A: Estadísticas de la red y estado actual Composición de la red (a fecha de octubre de 2025) Total de routers: Aproximadamente 60,000-70,000 (varía) Routers Floodfill: Aproximadamente 500-700 activos Tipos de cifrado: ECIES-X25519: \u0026gt;95% de los routers ElGamal: \u0026lt;5% de los routers (en desuso, solo legado) Adopción de transportes: SSU2: \u0026gt;60% como transporte principal NTCP2: ~40% como transporte principal Transportes heredados (SSU1, NTCP): 0% (eliminados) Tipos de firma: EdDSA (Ed25519): Gran mayoría ECDSA: Pequeño porcentaje RSA: No permitido (eliminado) Requisitos mínimos del router Versión de la API: 0.9.16+ (para compatibilidad con la red de EdDSA) Mínimo recomendado: API 0.9.51+ (compilaciones de short tunnel ECIES) Mínimo actual para floodfills: API 0.9.58+ (obsolescencia del router ElGamal) Próximo requisito: Java 17+ (a partir de la versión 2.11.0, diciembre de 2025) Requisitos de ancho de banda Mínimo: 128 KBytes/sec (indicador N o superior) para floodfill Recomendado: 256 KBytes/sec (indicador O) o superior Requisitos de floodfill: Ancho de banda mínimo de 128 KB/sec Tiempo de actividad estable (\u0026gt;95% recomendado) Baja latencia (\u0026lt;500ms hacia los pares) Aprobar las pruebas de estado (tiempo de cola, retraso de tareas) Estadísticas de tunnel Longitud típica del tunnel: 3-4 saltos Longitud máxima del tunnel: 8 saltos (teórica, raramente utilizada) Duración típica del tunnel: 10 minutos Tasa de éxito de construcción de tunnel: \u0026gt;85% para routers bien conectados Formato de mensaje de construcción de tunnel: Routers ECIES: ShortTunnelBuild (registros de 218 bytes) Tunnels mixtos: VariableTunnelBuild (registros de 528 bytes) Métricas de rendimiento Tiempo de construcción del tunnel: 1-3 segundos (típico) Latencia de extremo a extremo: 0.5-2 segundos (típico, 6-8 saltos en total) Rendimiento: Limitado por el ancho de banda del tunnel (típicamente 10-50 KB/sec por tunnel) Tamaño máximo del datagrama: 10 KB recomendado (61.2 KB máximo teórico) Apéndice B: Características obsoletas y eliminadas Completamente eliminado (ya no tiene soporte) Transporte NTCP - Eliminado en la versión 0.9.50 (mayo de 2021) Transporte SSU v1 - Eliminado de Java I2P en la versión 2.4.0 (diciembre de 2023) Transporte SSU v1 - Eliminado de i2pd en la versión 2.44.0 (noviembre de 2022) Tipos de firma RSA - No permitidos a partir de la API 0.9.28 Obsoleto (con soporte pero no recomendado) ElGamal routers - Obsoleto desde la API 0.9.58 (marzo de 2023) Los destinos ElGamal se siguen admitiendo por compatibilidad con versiones anteriores Los nuevos routers deberían usar exclusivamente ECIES-X25519 TunnelBuild (tipo 21) - Obsoleto en favor de VariableTunnelBuild y ShortTunnelBuild Sigue implementado para tunnels muy largos (\u0026gt;8 saltos) TunnelBuildReply (tipo 22) - Obsoleto en favor de VariableTunnelBuildReply y OutboundTunnelBuildReply Cifrado ElGamal/AES - Obsoleto en favor de ECIES-X25519-AEAD-Ratchet Todavía se usa para destinos heredados BuildRequestRecords ECIES largos (528 bytes) - Obsoleto en favor del formato corto (218 bytes) Todavía se usa para tunnels mixtos con saltos de ElGamal Cronograma de soporte heredado Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels --- Apéndice C: Desarrollos futuros Criptografía poscuántica Estado: Beta desde la versión 2.10.0 (septiembre de 2025), será la predeterminada en la 2.11.0 (diciembre de 2025)\nImplementación: - Enfoque híbrido que combina X25519 clásico y MLKEM poscuántico (ML-KEM-768) - Retrocompatible con la infraestructura ECIES-X25519 existente - Utiliza Signal Double Ratchet (protocolo de doble trinquete de Signal) con material de claves tanto clásico como PQ (poscuántico) - Consulte Propuesta 169 para más detalles\nRuta de migración: 1. Versión 2.10.0 (septiembre de 2025): Disponible como opción beta 2. Versión 2.11.0 (diciembre de 2025): Habilitado por defecto 3. Versiones futuras: Con el tiempo será obligatorio\nCaracterísticas previstas Mejoras en IPv6 - Mejor soporte de IPv6 y mecanismos de transición Limitación por tunnel - Control de ancho de banda granular por tunnel Métricas mejoradas - Mejor monitorización del rendimiento y diagnósticos Optimizaciones de protocolo - Menor sobrecarga y mayor eficiencia Mejor selección de floodfill (nodos especializados que mantienen y distribuyen la netDb) - Mejor distribución de la base de datos de red Áreas de investigación Optimización de la longitud de tunnel - Longitud de tunnel dinámica basada en el modelo de amenazas Relleno avanzado - Mejoras en la resistencia al análisis de tráfico Nuevos esquemas de cifrado - Preparación frente a amenazas de la computación cuántica Control de congestión - Mejor gestión de la carga de la red Soporte móvil - Optimizaciones para dispositivos y redes móviles Apéndice D: Directrices de implementación Para nuevas implementaciones Requisitos mínimos: 1. Admitir las funciones de la API versión 0.9.51+ 2. Implementar cifrado ECIES-X25519-AEAD-Ratchet 3. Admitir los transportes NTCP2 y SSU2 4. Implementar mensajes ShortTunnelBuild (registros de 218 bytes) 5. Admitir variantes LeaseSet2 (tipos 3, 5, 7) 6. Usar firmas EdDSA (Ed25519)\nRecomendado: 1. Admitir criptografía híbrida poscuántica (a partir de la versión 2.11.0) 2. Implementar parámetros de ancho de banda por tunnel 3. Admitir los formatos Datagram2 y Datagram3 4. Implementar opciones de registro de servicio en LeaseSets 5. Seguir las especificaciones oficiales en /docs/specs/\nNo requerido: 1. Soporte de router ElGamal (obsoleto) 2. Soporte de transportes heredados (SSU1, NTCP) 3. BuildRequestRecords de ECIES largos (528 bytes para tunnels ECIES puros) 4. Mensajes TunnelBuild/TunnelBuildReply (utilice las variantes Variable o Short)\nPruebas y validación Cumplimiento del protocolo: 1. Probar la interoperabilidad con el router oficial de I2P en Java 2. Probar la interoperabilidad con el router i2pd en C++ 3. Validar los formatos de mensaje conforme a las especificaciones 4. Probar los ciclos de construcción/desmontaje de tunnel 5. Verificar el cifrado/descifrado con vectores de prueba\nPruebas de rendimiento: 1. Medir las tasas de éxito al construir tunnel (deberían ser \u0026gt;85%) 2. Probar con diversas longitudes de tunnel (2-8 saltos) 3. Validar la fragmentación y el reensamblado 4. Probar bajo carga (múltiples tunnels simultáneos) 5. Medir la latencia de extremo a extremo\nPruebas de seguridad: 1. Verificar la implementación de cifrado (usar vectores de prueba) 2. Probar la prevención de ataques de repetición 3. Validar el manejo de la expiración de mensajes 4. Probar contra mensajes malformados 5. Verificar la generación adecuada de números aleatorios\nEscollos comunes de implementación Formatos de instrucciones de entrega confusos - Garlic clove (submensaje de garlic) vs mensaje de tunnel Derivación de claves incorrecta - Uso de HKDF para registros de construcción cortos Gestión del ID de mensaje - No se establece correctamente para construcciones de tunnel Problemas de fragmentación - No se respeta el límite práctico de 61.2 KB Errores de Endianness (orden de bytes) - Java usa big-endian para todos los enteros Gestión de expiración - El formato corto se desborda el 7 de febrero de 2106 Generación de suma de verificación - Sigue siendo obligatoria incluso si no se verifica ","description":"Formatos de mensajes de router a router, prioridades y límites de tamaño dentro de I2P.","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"Protocolo de red de I2P (I2NP)","url":"/es/docs/specs/i2np/"},{"categories":null,"content":"Descripción general La I2P Streaming Library proporciona transporte confiable, ordenado y autenticado sobre la capa de mensajes de I2P, similar a TCP sobre IP. Se sitúa por encima del protocolo I2CP y es utilizada por casi todas las aplicaciones interactivas de I2P, incluyendo proxies HTTP, IRC, BitTorrent y correo electrónico.\nCaracterísticas principales Configuración de conexión en una fase usando banderas SYN, ACK y FIN que pueden agruparse con datos de carga útil para reducir los viajes de ida y vuelta. Control de congestión de ventana deslizante, con arranque lento y prevención de congestión ajustados para el entorno de alta latencia de I2P. Compresión de paquetes (segmentos comprimidos de 4KB por defecto) que equilibra el costo de retransmisión y la latencia de fragmentación. Abstracción de canal completamente autenticado, cifrado y confiable entre destinos I2P. Este diseño permite que las solicitudes y respuestas HTTP pequeñas se completen en un solo viaje de ida y vuelta. Un paquete SYN puede transportar la carga útil de la solicitud, mientras que el SYN/ACK/FIN del respondedor puede contener el cuerpo completo de la respuesta.\nConceptos básicos de la API La API de streaming de Java refleja la programación estándar de sockets de Java:\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory negocia o reutiliza una sesión de router mediante I2CP. Si no se proporciona ninguna clave, se genera automáticamente un destino nuevo. Los desarrolladores pueden pasar opciones I2CP (por ejemplo, longitudes de tunnel, tipos de cifrado o configuraciones de conexión) a través del mapa options. I2PSocket e I2PServerSocket reflejan las interfaces estándar de Socket de Java, lo que facilita la migración. Los Javadocs completos están disponibles desde la consola del router I2P o aquí .\nConfiguración y Ajuste Puedes pasar propiedades de configuración al crear un socket manager mediante:\nI2PSocketManagerFactory.createManager(host, port, properties); Opciones de Clave Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false ### Comportamiento por Carga de Trabajo Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. Las características más recientes desde la versión 0.9.4 incluyen supresión de registros de rechazo, soporte de lista DSA (0.9.21) y aplicación obligatoria de protocolo (0.9.36). Los routers desde la versión 2.10.0 incluyen cifrado híbrido post-cuántico (ML-KEM + X25519) en la capa de transporte. Detalles del Protocolo Cada flujo se identifica mediante un Stream ID. Los paquetes llevan indicadores de control similares a TCP: SYNCHRONIZE, ACK, FIN y RESET. Los paquetes pueden contener tanto datos como indicadores de control simultáneamente, mejorando la eficiencia para conexiones de corta duración.\nCiclo de vida de la conexión SYN enviado — el iniciador incluye datos opcionales. Respuesta SYN/ACK — el respondedor incluye datos opcionales. Finalización ACK — establece la fiabilidad y el estado de la sesión. FIN/RESET — utilizado para cierre ordenado o terminación abrupta. Fragmentación y Reordenamiento Debido a que los túneles I2P introducen latencia y reordenamiento de mensajes, la biblioteca almacena en búfer los paquetes de streams desconocidos o que llegan anticipadamente. Los mensajes almacenados en búfer se guardan hasta que se completa la sincronización, garantizando una entrega completa y en orden.\nAplicación del Protocolo La opción i2p.streaming.enforceProtocol=true (predeterminada desde la versión 0.9.36) garantiza que las conexiones utilicen el número de protocolo I2CP correcto, evitando conflictos entre múltiples subsistemas que comparten un mismo destino.\nInteroperabilidad y Mejores Prácticas El protocolo de streaming coexiste con la API de Datagram, brindando a los desarrolladores la opción entre transportes orientados a conexión y sin conexión.\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram ### Clientes Compartidos Las aplicaciones pueden reutilizar túneles existentes ejecutándose como clientes compartidos, permitiendo que múltiples servicios compartan el mismo destino. Si bien esto reduce la sobrecarga, aumenta el riesgo de correlación entre servicios—úselo con precaución.\nControl de Congestión La capa de streaming se adapta continuamente a la latencia y el rendimiento de la red mediante retroalimentación basada en RTT. Las aplicaciones funcionan mejor cuando los routers son peers contribuyentes (túneles de participación habilitados). Los mecanismos de control de congestión similares a TCP previenen la sobrecarga de peers lentos y ayudan a equilibrar el uso del ancho de banda entre túneles. Consideraciones de Latencia Dado que I2P añade varios cientos de milisegundos de latencia base, las aplicaciones deben minimizar los viajes de ida y vuelta. Agrupa datos con la configuración de conexión donde sea posible (por ejemplo, solicitudes HTTP en SYN). Evita diseños que dependan de muchos intercambios secuenciales pequeños.\nPruebas y Compatibilidad Siempre prueba con Java I2P e i2pd para garantizar compatibilidad completa. Aunque el protocolo está estandarizado, pueden existir diferencias menores de implementación. Maneja routers antiguos con elegancia—muchos peers todavía ejecutan versiones anteriores a la 2.0. Monitorea las estadísticas de conexión usando I2PSocket.getOptions() y getSession() para leer métricas de RTT y retransmisión. El rendimiento depende en gran medida de la configuración del tunnel: - Tunnels cortos (1–2 saltos) → menor latencia, anonimato reducido. - Tunnels largos (3+ saltos) → mayor anonimato, RTT incrementado.\nMejoras Clave (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. --- Resumen La I2P Streaming Library es la columna vertebral de toda comunicación confiable dentro de I2P. Garantiza la entrega de mensajes cifrados, autenticados y en orden, y proporciona un reemplazo casi directo para TCP en entornos anónimos.\nPara lograr un rendimiento óptimo: - Minimice los viajes de ida y vuelta con agrupación SYN+payload. - Ajuste los parámetros de ventana y tiempo de espera según su carga de trabajo. - Favorezca tunnels más cortos para aplicaciones sensibles a la latencia. - Use diseños que respeten la congestión para evitar sobrecargar a los peers.\n","description":"Transporte tipo TCP utilizado por la mayoría de las aplicaciones I2P","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"Protocolo de Streaming","url":"/es/docs/api/streaming/"},{"categories":null,"content":"Descripción general La Biblioteca de Streaming de I2P proporciona una entrega de datos fiable, en el orden correcto y autenticada sobre la capa de mensajes no fiable de I2P — de forma análoga a TCP sobre IP. La utilizan casi todas las aplicaciones interactivas de I2P, como la navegación web, IRC, el correo electrónico y el intercambio de archivos.\nGarantiza la transmisión confiable, el control de congestión, la retransmisión y el control de flujo a través de los tunnels anónimos de alta latencia de I2P. Cada flujo está completamente cifrado de extremo a extremo entre destinos.\nPrincipios de diseño fundamentales La biblioteca de streaming implementa un establecimiento de conexión de una sola fase, donde las banderas SYN, ACK y FIN pueden transportar cargas útiles de datos en el mismo mensaje. Esto minimiza los viajes de ida y vuelta en entornos de alta latencia — una pequeña transacción HTTP puede completarse en un solo viaje de ida y vuelta.\nEl control de congestión y la retransmisión están inspirados en TCP, pero adaptados al entorno de I2P. Los tamaños de ventana son basados en mensajes, no en bytes, y están ajustados para la latencia del tunnel y la sobrecarga. El protocolo admite arranque lento, evitación de congestión y retroceso exponencial, de forma similar al algoritmo AIMD (Aumento Aditivo, Disminución Multiplicativa) de TCP.\nArquitectura La biblioteca de streaming opera entre las aplicaciones y la interfaz I2CP.\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels La mayoría de los usuarios acceden a él a través de I2PSocketManager, I2PTunnel o SAMv3. La biblioteca se encarga de forma transparente de la gestión de destinos, del uso de tunnel y de las retransmisiones. Formato de paquete +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | Detalles del encabezado IDs de flujo: Valores de 32 bits que identifican de forma única los flujos locales y remotos. Número de secuencia: Comienza en 0 para SYN y se incrementa por cada mensaje. Ack Through (confirmación hasta): Confirma todos los mensajes hasta N, excluyendo los de la lista de NACK. Banderas: Máscara de bits que controla el estado y el comportamiento. Opciones: Lista de longitud variable para RTT, MTU y negociación del protocolo. Indicadores de clave Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive --- Control de flujo y fiabilidad Streaming utiliza control de ventana basado en mensajes, a diferencia del enfoque basado en bytes de TCP. La cantidad de paquetes sin acuse de recibo permitidos en tránsito equivale al tamaño de la ventana actual (predeterminado 128).\nMecanismos Control de congestión: Arranque lento y evitación de congestión basada en AIMD. Choke/Unchoke: Señalización de control de flujo basada en la ocupación del búfer (bloqueo/desbloqueo). Retransmisión: Cálculo del RTO basado en RFC 6298 con retroceso exponencial. Filtrado de duplicados: Garantiza la fiabilidad frente a mensajes potencialmente reordenados. Valores de configuración típicos:\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout --- Establecimiento de la conexión Iniciador envía un SYN (opcionalmente con carga útil y FROM_INCLUDED). Respondedor responde con SYN+ACK (puede incluir carga útil). Iniciador envía el ACK final confirmando el establecimiento. Las cargas útiles iniciales opcionales permiten transmitir datos antes de la finalización completa del handshake (negociación inicial).\nDetalles de implementación Retransmisión y tiempo de espera El algoritmo de retransmisión sigue la RFC 6298. - RTO inicial: 9s - RTO mínima: 100ms - RTO máxima: 45s - Alfa: 0.125 - Beta: 0.25\nUso compartido del bloque de control Las conexiones recientes con el mismo par reutilizan el RTT (tiempo de ida y vuelta) y los datos de ventana anteriores para un aumento más rápido, evitando la latencia de “arranque en frío”. Los bloques de control expiran tras varios minutos.\nMTU y fragmentación MTU predeterminado: 1730 bytes (caben dos mensajes I2NP). Destinos ECIES (Esquema de cifrado integrado sobre curvas elípticas): 1812 bytes (sobrecarga reducida). MTU mínimo admitido: 512 bytes. El tamaño de la carga útil excluye el encabezado de streaming mínimo de 22 bytes.\nHistorial de versiones Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) --- Uso a nivel de aplicación Ejemplo de Java Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); Soporte para SAMv3 e i2pd SAMv3: Proporciona modos STREAM (flujo) y DATAGRAM (datagrama) para clientes no escritos en Java. i2pd: Expone parámetros de streaming (transmisión) idénticos mediante opciones del archivo de configuración (p. ej., i2p.streaming.maxWindowSize, profile, etc). Elegir entre streaming y datagramas Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn --- Seguridad y futuro poscuántico Las sesiones de streaming están cifradas de extremo a extremo en la capa I2CP. El cifrado híbrido poscuántico (ML-KEM + X25519) es compatible de forma experimental en la versión 2.10.0, pero está desactivado de forma predeterminada.\nReferencias Descripción general de la API de transmisión Especificación del protocolo de transmisión Especificación de I2CP Propuesta 144: Cálculos de MTU de transmisión Notas de la versión de I2P 2.10.0 ","description":"Transporte fiable, similar a TCP, utilizado por la mayoría de las aplicaciones de I2P","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"Protocolo de transmisión en continuo","url":"/es/docs/specs/streaming/"},{"categories":null,"content":" Precaución: El túnel SOCKS reenvía las cargas útiles de las aplicaciones sin desinfectarlas. Muchos protocolos filtran IPs, nombres de host u otros identificadores. Usa SOCKS únicamente con software que hayas auditado para anonimato.\n1. Descripción general I2P proporciona soporte de proxy SOCKS 4, 4a y 5 para conexiones salientes a través de un cliente I2PTunnel. Permite que aplicaciones estándar alcancen destinos I2P pero no puede acceder a clearnet. No hay outproxy SOCKS, y todo el tráfico permanece dentro de la red I2P.\nResumen de Implementación Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None **Tipos de dirección soportados:** - Nombres de host `.i2p` (entradas de libreta de direcciones) - Hashes Base32 (`.b32.i2p`) - No hay soporte para Base64 o clearnet 2. Riesgos de Seguridad y Limitaciones Fuga en la Capa de Aplicación SOCKS opera por debajo de la capa de aplicación y no puede sanitizar protocolos. Muchos clientes (por ejemplo, navegadores, IRC, correo electrónico) incluyen metadatos que revelan tu dirección IP, nombre de host o detalles del sistema.\nLas fugas comunes incluyen: - IPs en encabezados de correo o respuestas CTCP de IRC - Nombres reales/nombres de usuario en cargas útiles de protocolo - Cadenas de user-agent con huellas de SO - Consultas DNS externas - WebRTC y telemetría del navegador\nI2P no puede prevenir estas filtraciones—ocurren por encima de la capa de túnel. Solo utiliza SOCKS para clientes auditados diseñados para anonimato.\nIdentidad de Túnel Compartida Si múltiples aplicaciones comparten un túnel SOCKS, comparten la misma identidad de destino I2P. Esto permite la correlación o fingerprinting entre diferentes servicios.\nMitigación: Usa túneles no compartidos para cada aplicación y habilita claves persistentes para mantener identidades criptográficas consistentes entre reinicios.\nModo UDP deshabilitado El soporte UDP en SOCKS5 no está implementado. El protocolo anuncia capacidad UDP, pero las llamadas son ignoradas. Use clientes solo TCP.\nSin Outproxy por Diseño A diferencia de Tor, I2P no ofrece outproxies (proxies de salida) a la clearnet basados en SOCKS. Los intentos de alcanzar IPs externas fallarán o expondrán la identidad. Use proxies HTTP o HTTPS si se requiere outproxying.\n3. Contexto Histórico Los desarrolladores han desaconsejado durante mucho tiempo el uso de SOCKS para anonimato. De las discusiones internas de desarrolladores y de la Reunión 81 y Reunión 82 de 2004:\n\u0026ldquo;Reenviar tráfico arbitrario no es seguro, y nos corresponde como desarrolladores de software de anonimato tener la seguridad de nuestros usuarios finales en primer lugar en nuestras mentes.\u0026rdquo;\nEl soporte SOCKS se incluyó por compatibilidad pero no se recomienda para entornos de producción. Casi todas las aplicaciones de internet filtran metadatos sensibles inadecuados para el enrutamiento anónimo.\n4. Configuración Java I2P Abra el I2PTunnel Manager Cree un nuevo tunnel cliente de tipo \u0026ldquo;SOCKS 4/4a/5\u0026rdquo; Configure las opciones: Puerto local (cualquiera disponible) Cliente compartido: deshabilitar para identidad separada por aplicación Clave persistente: habilitar para reducir correlación de claves Inicie el tunnel i2pd i2pd incluye soporte SOCKS5habilitado por defecto en 127.0.0.1:4447. La configuración en i2pd.conf bajo [SOCKSProxy] te permite ajustar el puerto, host y parámetros del tunnel.\n5. Cronograma de Desarrollo Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 El módulo SOCKS en sí no ha tenido actualizaciones importantes del protocolo desde 2013, pero la pila de túneles circundante ha recibido mejoras de rendimiento y criptográficas. 6. Alternativas Recomendadas Para cualquier aplicación de producción, pública o crítica para la seguridad, utilice una de las APIs oficiales de I2P en lugar de SOCKS:\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM Estas APIs proporcionan un aislamiento adecuado de destinos, control de identidad criptográfica y mejor rendimiento de enrutamiento. 7. OnionCat / GarliCat OnionCat soporta I2P a través de su modo GarliCat (rango IPv6 fd60:db4d:ddb5::/48). Aún funcional pero con desarrollo limitado desde 2019.\nAdvertencias de uso: - Requiere configuración manual de .oc.b32.i2p en SusiDNS - Necesita asignación estática de IPv6 - No cuenta con soporte oficial del proyecto I2P\nRecomendado solo para configuraciones avanzadas de VPN sobre I2P.\n8. Mejores Prácticas Si debes usar SOCKS: 1. Crea túneles separados por aplicación. 2. Desactiva el modo de cliente compartido. 3. Habilita claves persistentes. 4. Fuerza la resolución DNS de SOCKS5. 5. Audita el comportamiento del protocolo en busca de fugas. 6. Evita conexiones a la red clearnet (internet convencional). 7. Monitorea el tráfico de red en busca de fugas.\n9. Resumen Técnico Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) --- 10. Conclusión El proxy SOCKS en I2P proporciona compatibilidad básica con aplicaciones TCP existentes, pero no está diseñado para garantías sólidas de anonimato. Solo debe utilizarse en entornos de prueba controlados y auditados.\nPara implementaciones serias, migre a SAM v3 o la API de Streaming. Estas APIs aíslan las identidades de aplicaciones, usan criptografía moderna y reciben desarrollo continuo.\nRecursos Adicionales Documentación Oficial de SOCKS Especificación SAMv3 Documentación de la Biblioteca Streaming Referencia de I2PTunnel Documentación para Desarrolladores de I2P Foro de la Comunidad ","description":"Uso seguro del túnel SOCKS de I2P (actualizado para 2.10.0)","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"Proxy SOCKS","url":"/es/docs/api/socks/"},{"categories":null,"content":"Rendimiento de la Red I2P: Velocidad, Conexiones y Gestión de Recursos La red I2P es completamente dinámica. Cada cliente es conocido por otros nodos y prueba localmente los nodos conocidos en cuanto a alcanzabilidad y capacidad. Solo los nodos alcanzables y capaces se guardan en una NetDB local. Durante el proceso de construcción de túneles, los mejores recursos se seleccionan de este conjunto para construir túneles. Debido a que las pruebas ocurren continuamente, el conjunto de nodos cambia. Cada nodo I2P conoce una parte diferente de la NetDB, lo que significa que cada router tiene un conjunto diferente de nodos I2P para ser utilizados en los túneles. Incluso si dos routers tienen el mismo subconjunto de nodos conocidos, las pruebas de alcanzabilidad y capacidad probablemente mostrarán resultados diferentes, ya que los otros routers podrían estar bajo carga justo cuando un router realiza las pruebas, pero estar libres cuando el segundo router las realiza.\nEsto describe por qué cada nodo I2P tiene diferentes nodos para construir tunnels. Debido a que cada nodo I2P tiene una latencia y ancho de banda diferentes, los tunnels (que se construyen a través de esos nodos) tienen diferentes valores de latencia y ancho de banda. Y como cada nodo I2P tiene diferentes tunnels construidos, no hay dos nodos I2P que tengan los mismos conjuntos de tunnels.\nUn servidor/cliente se conoce como un \u0026ldquo;destination\u0026rdquo; y cada destination tiene al menos un túnel de entrada y uno de salida. El valor predeterminado es 3 saltos por túnel. Esto suma 12 saltos (12 nodos I2P diferentes) para un viaje completo de ida y vuelta cliente → servidor → cliente.\nCada paquete de datos se envía a través de 6 otros nodos de I2P hasta llegar al servidor:\nclient - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - server\ny en el camino de regreso 6 nodos I2P diferentes:\nservidor - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - cliente\nEl tráfico en la red necesita un ACK antes de enviar nuevos datos; necesita esperar hasta que un ACK regrese del servidor: enviar datos, esperar el ACK, enviar más datos, esperar el ACK. Como el RTT (Round Trip Time) se acumula de la latencia de cada nodo I2P individual y cada conexión en este viaje de ida y vuelta, usualmente toma 1–3 segundos hasta que un ACK regresa al cliente. Debido al diseño del transporte TCP e I2P, un paquete de datos tiene un tamaño limitado. Juntas, estas condiciones establecen un límite de ancho de banda máximo por tunnel de aproximadamente 20–50 kB/s. Sin embargo, si solo un salto en el tunnel tiene únicamente 5 kB/s de ancho de banda disponible, todo el tunnel queda limitado a 5 kB/s, independientemente de la latencia y otras limitaciones.\nEl cifrado, la latencia y cómo se construye un túnel lo hace bastante costoso en tiempo de CPU para construir un túnel. Es por esto que un destino solo tiene permitido tener un máximo de 6 túneles de entrada y 6 de salida para transportar datos. Con un máximo de 50 kB/s por túnel, un destino podría usar aproximadamente 300 kB/s de tráfico combinado (en realidad podría ser más si se usan túneles más cortos con anonimato bajo o nulo disponible). Los túneles usados se descartan cada 10 minutos y se construyen nuevos. Este cambio de túneles, y a veces clientes que se apagan o pierden su conexión a la red, a veces romperá túneles y conexiones. Un ejemplo de esto se puede ver en la Red IRC2P en pérdida de conexión (ping timeout) o al usar eepget.\nCon un conjunto limitado de destinos y un conjunto limitado de túneles por destino, un nodo I2P solo utiliza un conjunto limitado de túneles a través de otros nodos I2P. Por ejemplo, si un nodo I2P es \u0026ldquo;hop1\u0026rdquo; en el pequeño ejemplo anterior, solo ve un túnel participante que se origina desde el cliente. Si sumamos toda la red I2P, solo un número bastante limitado de túneles participantes podría construirse con una cantidad limitada de ancho de banda en total. Si se distribuyen estos números limitados entre la cantidad de nodos I2P, solo hay una fracción del ancho de banda/capacidad disponible para su uso.\nPara mantener el anonimato, un solo router no debería ser utilizado por toda la red para construir túneles. Si un router actúa como router de túnel para todos los nodos I2P, se convierte en un punto central de fallo muy real, así como en un punto central para recopilar IPs y datos de los clientes. Esta es la razón por la cual la red distribuye el tráfico entre nodos en el proceso de construcción de túneles.\nOtra consideración para el rendimiento es la forma en que I2P maneja las redes en malla. Cada salto de conexión punto a punto utiliza una conexión TCP o UDP en los nodos I2P. Con 1000 conexiones, se observan 1000 conexiones TCP. Eso es bastante, y algunos routers domésticos y de pequeñas oficinas solo permiten un número pequeño de conexiones. I2P intenta limitar estas conexiones a menos de 1500 por tipo UDP y por tipo TCP. Esto limita también la cantidad de tráfico enrutado a través de un nodo I2P.\nSi un nodo es alcanzable, tiene una configuración de ancho de banda de \u0026gt;128 kB/s compartido y está alcanzable 24/7, debería ser utilizado después de algún tiempo para tráfico participante. Si se cae en el ínterin, las pruebas de un nodo I2P realizadas por otros nodos les indicarán que no es alcanzable. Esto bloquea un nodo durante al menos 24 horas en otros nodos. Por lo tanto, los otros nodos que probaron ese nodo como caído no usarán ese nodo durante 24 horas para construir túneles. Es por esto que tu tráfico es menor después de un reinicio/apagado de tu router I2P durante un mínimo de 24 horas.\nAdemás, otros nodos I2P necesitan conocer un router I2P para probarlo en cuanto a alcanzabilidad y capacidad. Este proceso puede acelerarse cuando interactúas con la red, por ejemplo, usando aplicaciones o visitando sitios I2P, lo que resultará en más construcción de túneles y, por lo tanto, más actividad y alcanzabilidad para las pruebas realizadas por los nodos en la red.\nHistorial de Rendimiento (seleccionado) A lo largo de los años, I2P ha experimentado una serie de mejoras de rendimiento notables:\nNative math Implementado mediante enlaces JNI a la biblioteca GNU MP (GMP) para acelerar modPow de BigInteger, que anteriormente dominaba el tiempo de CPU. Los primeros resultados mostraron mejoras de velocidad dramáticas en criptografía de clave pública. Ver: /misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) Anteriormente, las respuestas a menudo requerían una búsqueda en la base de datos de red del LeaseSet del remitente. Incluir el LeaseSet del remitente en el garlic inicial mejora la latencia de respuesta. Esto ahora se hace de forma selectiva (al inicio de una conexión o cuando cambia el LeaseSet) para reducir la sobrecarga.\nMatemáticas nativas Se movieron algunos pasos de validación más temprano en el handshake de transporte para rechazar peers defectuosos antes (relojes incorrectos, NAT/firewall defectuoso, versiones incompatibles), ahorrando CPU y ancho de banda.\nEnvolviendo con garlic un LeaseSet de \u0026ldquo;respuesta\u0026rdquo; (optimizado) Utiliza pruebas de túneles según el contexto: evita probar túneles que ya se sabe que están transmitiendo datos; prioriza las pruebas cuando estén inactivos. Esto reduce la sobrecarga y acelera la detección de túneles con fallos.\nRechazo de TCP más eficiente Mantener las selecciones para una conexión determinada reduce la entrega fuera de orden y permite que la biblioteca de streaming aumente los tamaños de ventana, mejorando el rendimiento.\nAjustes de prueba de túneles GZip o similar para estructuras detalladas (por ejemplo, opciones de RouterInfo) reduce el ancho de banda cuando es apropiado.\nSelección persistente de túnel/lease Reemplazo del protocolo simplista \u0026ldquo;ministreaming\u0026rdquo;. El streaming moderno incluye ACKs selectivos y control de congestión adaptado al sustrato anónimo y orientado a mensajes de I2P. Ver: /docs/api/streaming/\nFuture Performance Improvements (historical ideas) A continuación se presentan ideas documentadas históricamente como posibles mejoras. Muchas están obsoletas, implementadas o han sido reemplazadas por cambios arquitectónicos.\nComprimir estructuras de datos seleccionadas Mejorar cómo los routers eligen peers para la construcción de túneles para evitar aquellos lentos o sobrecargados, mientras se mantiene resistente a ataques Sybil por adversarios poderosos.\nProtocolo de streaming completo Reduce la exploración innecesaria cuando el espacio de claves es estable; ajuste cuántos pares se devuelven en las búsquedas y cuántas búsquedas concurrentes se realizan.\nSession Tag tuning and improvements (legacy) Para el esquema heredado ElGamal/AES+SessionTag, estrategias más inteligentes de expiración y reposición reducen los respaldos ElGamal y las etiquetas desperdiciadas.\nMejor perfilado y selección de pares Generar etiquetas desde un PRNG sincronizado inicializado durante el establecimiento de una nueva sesión, reduciendo la sobrecarga por mensaje de las etiquetas pre-entregadas.\nAjuste de la base de datos de red Tiempos de vida de túnel más largos combinados con recuperación pueden reducir los costos de reconstrucción; equilibrar con anonimato y confiabilidad.\nAjustes y mejoras de Session Tag (obsoleto) Rechazar peers inválidos más temprano y hacer las pruebas de túnel más conscientes del contexto para reducir la contención y la latencia.\nMigrar SessionTag a PRNG sincronizado (heredado) El bundling selectivo de LeaseSet, las opciones comprimidas de RouterInfo y la adopción del protocolo de streaming completo contribuyen a un mejor rendimiento percibido.\nVéase también:\nEnrutamiento de Túneles Selección de Pares Transportes Especificación SSU2 y Especificación NTCP2 ","description":"Rendimiento de la red I2P: cómo se comporta hoy, mejoras históricas e ideas para ajustes futuros","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"Rendimiento","url":"/es/docs/overview/performance/"},{"categories":null,"content":" Obsoleto: SAM v1 se mantiene únicamente como referencia histórica. Las aplicaciones nuevas deberían usar SAM v3 o BOB . El puente original solo admite destinos DSA-SHA1 y un conjunto limitado de opciones.\nBibliotecas El árbol del código fuente de I2P en Java aún incluye enlaces heredados para C, C#, Perl y Python. Ya no se mantienen y se distribuyen principalmente para compatibilidad con versiones archivadas.\nNegociación de versiones Los clientes se conectan a través de TCP (por defecto 127.0.0.1:7656) y intercambian:\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 A partir de Java I2P 0.9.14, el parámetro MIN es opcional y tanto MIN como MAX aceptan formas de un solo dígito (\u0026quot;3\u0026quot; etc.) para puentes actualizados.\nCreación de sesión SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name carga o crea una entrada en sam.keys; TRANSIENT siempre crea un destino temporal. STYLE selecciona flujos virtuales (similar a TCP), datagramas firmados o datagramas en bruto. DIRECTION se aplica solo a sesiones de flujo; de forma predeterminada es BOTH. Los pares clave/valor adicionales se pasan como opciones de I2CP (por ejemplo, tunnels.quantityInbound=3). El puente responde con:\nSESSION STATUS RESULT=OK DESTINATION=name Los errores devuelven DUPLICATED_DEST, I2P_ERROR o INVALID_KEY, además de un mensaje opcional.\nFormatos de mensajes Los mensajes SAM son ASCII de una sola línea con pares clave/valor delimitados por espacios. Las claves están en UTF‑8; los valores pueden ir entre comillas si contienen espacios. No se define ningún mecanismo de escape.\nTipos de comunicación:\nFlujos – encaminados a través de la biblioteca de streaming de I2P Datagramas con posibilidad de respuesta – cargas útiles firmadas (Datagram1) Datagramas sin formato – cargas útiles sin firma (Datagram RAW) Opciones añadidas en 0.9.14 DEST GENERATE acepta SIGNATURE_TYPE=... (permitiendo Ed25519 (algoritmo de firma digital), etc.) HELLO VERSION trata MIN como opcional y acepta cadenas de versión de un solo dígito Cuándo usar SAM v1 Solo para la interoperabilidad con software heredado que no puede actualizarse. Para todo desarrollo nuevo, utilice:\nSAM v3 para acceso completo a flujos/datagramas BOB para la gestión de destinos (sigue siendo limitado, pero admite funciones más modernas) Referencias SAM v2 SAM v3 Especificación de datagramas Protocolo de streaming SAM v1 sentó las bases para el desarrollo de aplicaciones agnósticas del router, pero el ecosistema ha evolucionado. Considere este documento como una ayuda de compatibilidad más que como un punto de partida.\n","description":"Protocolo de mensajería anónima simple heredado (en desuso)","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM v1","url":"/es/docs/legacy/sam/"},{"categories":null,"content":" Obsoleto: SAM v2 se entregó con I2P 0.6.1.31 y ya no se mantiene. Usa SAM v3 para nuevos desarrollos. La única mejora de v2 respecto a v1 fue la compatibilidad con varios sockets multiplexados sobre una única conexión SAM.\nNotas de la versión La cadena de versión reportada sigue siendo \u0026ldquo;2.0\u0026rdquo;. Desde 0.9.14, el mensaje HELLO VERSION acepta valores MIN/MAX de un solo dígito y el parámetro MIN es opcional. DEST GENERATE admite SIGNATURE_TYPE, por lo que se pueden crear destinos Ed25519. Conceptos básicos de la sesión SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] Cada destino puede tener solo una sesión SAM activa (flujos, datagramas o sin procesar). STYLE selecciona flujos virtuales, datagramas firmados o datagramas sin procesar. Las opciones adicionales se pasan a I2CP (por ejemplo, tunnels.quantityInbound=3). Las respuestas reflejan la v1: SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY. Codificación de mensajes ASCII orientado a líneas con pares key=value separados por espacios (los valores pueden ir entre comillas). Los tipos de comunicación son los mismos que en v1:\nFlujos a través de la I2P streaming library (biblioteca de transmisión de I2P) Datagramas con respuesta (PROTO_DATAGRAM) Datagramas sin procesar (PROTO_DATAGRAM_RAW) Cuándo usarlo Solo para clientes heredados que no pueden migrar. SAM v3 ofrece:\nTransferencia de destino en binario (DEST GENERATE BASE64) Subsesiones y soporte para DHT (v3.3) Mejores informes de errores y negociación de opciones Consulte:\nSAM v1 SAM v3 API de datagramas Protocolo de streaming ","description":"Protocolo heredado de Simple Anonymous Messaging","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2","url":"/es/docs/legacy/samv2/"},{"categories":null,"content":"SAM v3 (\u0026ldquo;Simple Anonymous Messaging\u0026rdquo;) es la API estable e independiente del router actual que permite a las aplicaciones externas comunicarse con la red I2P sin necesidad de integrar el router. Proporciona acceso unificado a streams, datagrams y mensajes sin procesar, y sigue siendo la capa puente canónica para software no basado en Java.\n1. Descripción General y Propósito SAM v3 permite a los desarrolladores crear software compatible con I2P en cualquier lenguaje utilizando un protocolo TCP/UDP ligero. Abstrae los componentes internos del router, exponiendo un conjunto mínimo de comandos sobre TCP (7656) y UDP (7655). Tanto Java I2P como i2pd implementan subconjuntos de la especificación SAM v3, aunque i2pd todavía carece de la mayoría de las extensiones 3.2 y 3.3 a partir de 2025.\n2. Historial de versiones Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. ### Nota sobre Nomenclatura Java I2P utiliza PRIMARY/SUBSESSION. i2pd e I2P+ continúan usando la terminología heredada MASTER/SUBSESSION para compatibilidad con versiones anteriores. 3. Flujo de trabajo principal Negociación de Versión HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 Creación de Destino DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512). Fuertemente recomendado desde I2P 0.9.15. Creación de Sesión SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4 es X25519 (ECIES X25519 AEAD Ratchet) y 0 es ElGamal de respaldo para compatibilidad. Cantidades de túneles explícitas para consistencia: Java I2P predeterminado 2, i2pd predeterminado 5. Operaciones del Protocolo STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 Los tipos de mensajes principales incluyen: STREAM CONNECT, STREAM ACCEPT, STREAM FORWARD, DATAGRAM SEND, RAW SEND, NAMING LOOKUP, DEST LOOKUP, PING, QUIT.\nApagado Ordenado QUIT 4. Diferencias de Implementación (Java I2P vs i2pd) Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 **Recomendación:** Especifique siempre las cantidades de túneles explícitamente para garantizar la coherencia entre routers. 5. Bibliotecas compatibles (estado en 2025) Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance ## 6. Funciones Nuevas y Próximas (2024–2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ ## 7. Notas de Seguridad y Configuración Vincular SAM solo a 127.0.0.1. Para servicios persistentes, usar sesiones PRIMARY con claves estáticas. Usar HELLO VERSION para probar el soporte de funcionalidades. Usar PING o NAMING LOOKUP para verificar que el router esté activo. Evitar conexiones SAM remotas no autenticadas (sin TLS en i2pd). 8. Referencias y Especificaciones Especificación SAMv3 SAM v2 (Heredado) Especificación de Streaming Datagramas Centro de Documentación Documentación de i2pd 9. Resumen SAM v3 sigue siendo el protocolo puente recomendado para todas las aplicaciones I2P que no sean Java. Ofrece estabilidad, enlaces entre lenguajes y rendimiento consistente en todos los tipos de router.\nAl desarrollar con SAM: - Usa firmas Ed25519 y cifrado X25519. - Verifica el soporte de características dinámicamente mediante HELLO VERSION. - Diseña para compatibilidad, especialmente cuando soportas tanto routers Java I2P como i2pd.\n","description":"Protocolo puente estable para aplicaciones I2P no basadas en Java","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/es/docs/api/samv3/"},{"categories":null,"content":"Acerca de los servidores Reseed (servidores de arranque de I2P) Los routers nuevos necesitan un puñado de pares para unirse a la red I2P. Los reseed hosts (servidores que suministran el conjunto de arranque inicial) proporcionan ese conjunto a través de descargas HTTPS cifradas. Cada reseed bundle (paquete de reseed) está firmado por el host, lo que impide manipulaciones por parte de terceros no autenticados. Los routers ya establecidos pueden realizar reseed ocasionalmente si su conjunto de pares se vuelve obsoleto.\nProceso de Bootstrap (arranque inicial) de la red Cuando un router I2P se inicia por primera vez o ha estado desconectado durante un período prolongado, necesita datos de RouterInfo (información del router) para conectarse a la red. Dado que el router no tiene pares existentes, no puede obtener esta información desde dentro de la propia red I2P. El mecanismo de reseed (proceso de arranque inicial) resuelve este problema de arranque proporcionando archivos RouterInfo desde servidores HTTPS externos de confianza.\nEl proceso de reseed (proceso de arranque desde servidores de semillas) entrega 75-100 archivos RouterInfo en un único paquete firmado criptográficamente. Esto garantiza que los routers nuevos puedan establecer conexiones rápidamente sin exponerlos a ataques de intermediario que podrían aislarlos en particiones de red separadas y no confiables.\nEstado actual de la red A octubre de 2025, la red I2P opera con la versión de router 2.10.0 (versión de la API 0.9.67). El protocolo de reseed (proceso de obtención inicial de pares) introducido en la versión 0.9.14 se mantiene estable y sin cambios en su funcionalidad básica. La red mantiene varios servidores de reseed independientes distribuidos a nivel mundial para garantizar la disponibilidad y la resistencia a la censura.\nEl servicio checki2p supervisa todos los servidores de reseed de I2P (servicios de arranque inicial de la red que proporcionan datos iniciales del netDb) cada 4 horas, proporcionando comprobaciones de estado en tiempo real y métricas de disponibilidad para la infraestructura de reseed.\nEspecificación del formato de archivo SU3 El formato de archivo SU3 es la base del protocolo de reseed (proceso de arranque inicial de pares) de I2P, y permite la entrega de contenido firmado criptográficamente. Comprender este formato es esencial para implementar servidores y clientes de reseed.\nEstructura de archivos El formato SU3 consta de tres componentes principales: encabezado (40+ bytes), contenido (longitud variable) y firma (longitud especificada en el encabezado).\nFormato del encabezado (Bytes 0-39 como mínimo) Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") ### Parámetros SU3 específicos de Reseed (proceso de arranque de la red) Para los paquetes de reseed (proceso de obtención de nodos iniciales de la red), el archivo SU3 debe tener las siguientes características:\nNombre de archivo: Debe ser exactamente i2pseeds.su3 Tipo de contenido (byte 27): 0x03 (RESEED) Tipo de archivo (byte 25): 0x00 (ZIP) Tipo de firma (bytes 8-9): 0x0006 (RSA-4096-SHA512) Cadena de versión: marca de tiempo Unix en ASCII (segundos desde la época Unix, formato date +%s) ID del firmante: identificador con formato de correo electrónico que coincide con el CN del certificado X.509 Parámetro de consulta del ID de red Desde la versión 0.9.42, los routers añaden ?netid=2 a las solicitudes de reseed (arranque inicial). Esto evita las conexiones entre redes, ya que las redes de prueba usan distintos ID de red. La red de producción actual de I2P usa el ID de red 2.\nEjemplo de solicitud: https://reseed.example.com/i2pseeds.su3?netid=2\nEstructura del contenido del ZIP La sección de contenido (después del encabezado, antes de la firma) contiene un archivo ZIP estándar con los siguientes requisitos:\nCompresión: Compresión ZIP estándar (DEFLATE) Número de archivos: Por lo general 75-100 archivos RouterInfo (información del router) Estructura de directorios: Todos los archivos deben estar en el nivel superior (sin subdirectorios) Nombrado de archivos: routerInfo-{44-character-base64-hash}.dat Alfabeto Base64: Debe usar el alfabeto Base64 modificado de I2P El alfabeto base64 de I2P difiere del base64 estándar al usar - y ~ en lugar de + y / para garantizar la compatibilidad con el sistema de archivos y las URL.\nFirma criptográfica La firma cubre todo el archivo desde el byte 0 hasta el final de la sección de contenido. La firma en sí se añade después del contenido.\nAlgoritmo de firma (RSA-4096-SHA512) Calcular el hash SHA-512 de los bytes desde 0 hasta el final del contenido Firmar el hash con RSA \u0026ldquo;raw\u0026rdquo; (NONEwithRSA en terminología de Java) Rellenar la firma con ceros a la izquierda si es necesario para alcanzar 512 bytes Añadir la firma de 512 bytes al archivo Proceso de verificación de firmas Los clientes deben:\nLeer los bytes 0-11 para determinar el tipo y la longitud de la firma Leer el encabezado completo para localizar los límites del contenido Procesar el contenido como flujo mientras se calcula el hash SHA-512 Extraer la firma del final del archivo Verificar la firma usando la clave pública RSA-4096 del firmante Rechazar el archivo si falla la verificación de la firma Modelo de confianza de certificados Las claves de firma de reseed (proceso de arranque/semillado inicial) se distribuyen como certificados X.509 autofirmados con claves RSA de 4096 bits. Estos certificados se incluyen en los paquetes del router de I2P en el directorio certificates/reseed/.\nFormato del certificado: - Tipo de clave: RSA-4096 - Firma: Autofirmado - CN del sujeto: Debe coincidir con el ID del firmante en el encabezado SU3 - Fechas de validez: Los clientes deberían hacer cumplir los periodos de validez del certificado\nEjecutar un host de Reseed (servidor que suministra a los routers listas iniciales de pares) Operar un servicio de reseed (servicio que proporciona semillas iniciales de la red) requiere prestar mucha atención a los requisitos de seguridad, fiabilidad y diversidad de la red. Un mayor número de servidores de reseed independientes aumenta la resiliencia y dificulta que atacantes o censores bloqueen la incorporación de nuevos routers.\nRequisitos técnicos Especificaciones del servidor Sistema operativo: Unix/Linux (Ubuntu, Debian, FreeBSD probados y recomendados) Conectividad: Se requiere dirección IPv4 estática, IPv6 recomendado pero opcional CPU: Mínimo 2 núcleos RAM: Mínimo 2 GB Ancho de banda: Aproximadamente 15 GB por mes Tiempo de actividad: Se requiere operación 24/7 I2P Router: I2P router bien integrado ejecutándose continuamente Requisitos de software Java: JDK 8 o posterior (se requerirá Java 17+ a partir de I2P 2.11.0) Servidor web: nginx o Apache con soporte de proxy inverso (Lighttpd ya no es compatible debido a limitaciones del encabezado X-Forwarded-For) TLS/SSL: Certificado TLS válido (Let\u0026rsquo;s Encrypt, autofirmado o CA comercial) Protección DDoS: fail2ban o equivalente (obligatorio, no opcional) Herramientas de reseed (proceso inicial de obtención de pares): reseed-tools oficiales de https://i2pgit.org/idk/reseed-tools Requisitos de seguridad Configuración de HTTPS/TLS Protocolo: Solo HTTPS, sin alternativa HTTP Versión de TLS: Mínimo TLS 1.2 Conjuntos de cifrado: Debe admitir conjuntos de cifrado fuertes compatibles con Java 8+ CN/SAN del certificado: Debe coincidir con el nombre de host de la URL servida Tipo de certificado: Puede ser autofirmado si se comunica con el equipo de desarrollo, o emitido por una autoridad certificadora reconocida (CA) Gestión de certificados Los certificados de firma SU3 y los certificados TLS cumplen funciones diferentes:\nCertificado TLS (certificates/ssl/): Asegura el transporte HTTPS Certificado de firma SU3 (certificates/reseed/): Firma paquetes de reseed (arranque inicial de la red) Ambos certificados deben proporcionarse al coordinador de reseed (proceso de arranque inicial de la red) (zzz@mail.i2p ) para su inclusión en los paquetes del router.\nProtección contra DDoS y scraping (extracción automatizada de datos) Los Reseed servers (servidores de arranque inicial de la red) se enfrentan a ataques periódicos de implementaciones defectuosas, botnets y actores maliciosos que intentan raspar la base de datos de la red. Las medidas de protección incluyen:\nfail2ban: Requerido para limitación de tasa y mitigación de ataques Bundle Diversity: Entregar diferentes conjuntos de RouterInfo (información del router) a distintos solicitantes Bundle Consistency: Entregar el mismo bundle (paquete) a solicitudes repetidas desde la misma IP dentro de una ventana de tiempo configurable IP Logging Restrictions: No hacer públicos los registros ni las direcciones IP (requisito de la política de privacidad) Métodos de implementación Método 1: reseed-tools (conjunto de herramientas para reseed de I2P) oficiales (Recomendado) La implementación canónica mantenida por el proyecto I2P. Repositorio: https://i2pgit.org/idk/reseed-tools Instalación:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 En la primera ejecución, la herramienta generará: - your-email@mail.i2p.crt (certificado de firma SU3) - your-email@mail.i2p.pem (clave privada de firma SU3) - your-email@mail.i2p.crl (lista de revocación de certificados) - archivos de certificado y clave TLS\nCaracterísticas: - Generación automática de SU3 bundle (paquete firmado de I2P) (350 variaciones, 77 RouterInfos (metadatos de router) cada una) - Servidor HTTPS integrado - Reconstruir la caché cada 9 horas mediante cron - Compatibilidad con el encabezado X-Forwarded-For con la opción --trustProxy - Compatible con configuraciones de proxy inverso\nDespliegue en producción:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed Método 2: Implementación en Python (pyseeder) Implementación alternativa del proyecto PurpleI2P: https://github.com/PurpleI2P/pyseeder pip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 Método 3: Despliegue con Docker Para entornos contenedorizados, existen varias implementaciones preparadas para Docker:\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: Añade soporte para servicio onion de Tor y para IPFS Configuración de proxy inverso Configuración de nginx upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } Configuración de Apache \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; Registro y coordinación Para incluir tu reseed server (servidor de resembrado) en el paquete oficial de I2P:\nCompleta la configuración y las pruebas Envía ambos certificados (firma SU3 y TLS) al coordinador de reseed (proceso para obtener pares iniciales de la red) Contacto: zzz@mail.i2p o zzz@i2pmail.org Únete a #i2p-dev en IRC2P para coordinarte con otros operadores Mejores prácticas operativas Supervisión y registro Habilitar el formato de registro combinado de Apache/nginx para estadísticas Implementar la rotación de registros (los registros crecen rápidamente) Supervisar el éxito de la generación del paquete y los tiempos de reconstrucción Hacer seguimiento del uso de ancho de banda y de los patrones de solicitudes Nunca divulgar direcciones IP ni registros de acceso detallados Calendario de mantenimiento Cada 9 horas: Reconstruir la caché del paquete SU3 (automatizado mediante cron) Semanalmente: Revisar los registros en busca de patrones de ataque Mensualmente: Actualizar el I2P router y reseed-tools Según sea necesario: Renovar los certificados TLS (automatizar con Let\u0026rsquo;s Encrypt) Selección de puertos Predeterminado: 8443 (recomendado) Alternativa: Cualquier puerto entre 1024 y 49151 Puerto 443: Requiere privilegios de root o redirección de puertos (se recomienda la redirección con iptables) Ejemplo de reenvío de puertos:\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 Métodos alternativos de reseed (obtención inicial de pares) Otras opciones de arranque ayudan a los usuarios detrás de redes restrictivas:\nReseed (proceso de arranque inicial de la red) basado en archivos Introducido en la versión 0.9.16, el resembrado basado en archivos permite a los usuarios cargar manualmente paquetes de RouterInfo. Este método es particularmente útil para usuarios en regiones con censura donde los servidores de resembrado HTTPS están bloqueados.\nProceso: 1. Un contacto de confianza genera un paquete SU3 usando su router 2. El paquete se transfiere por correo electrónico, unidad USB u otro canal fuera de banda 3. El usuario coloca i2pseeds.su3 en el directorio de configuración de I2P 4. El router detecta y procesa automáticamente el paquete al reiniciar\nDocumentación: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\nCasos de uso: - Usuarios detrás de cortafuegos nacionales que bloquean reseed servers (servidores de arranque) - Redes aisladas que requieren arranque manual - Entornos de prueba y desarrollo\nResembrado a través del proxy de Cloudflare Enrutar el tráfico de reseed (obtención inicial de pares) a través de la CDN de Cloudflare ofrece varias ventajas para los operadores en regiones con alta censura.\nBeneficios: - Dirección IP del servidor de origen oculta a los clientes - Protección contra DDoS mediante la infraestructura de Cloudflare - Distribución geográfica de la carga mediante caché perimetral - Mejor rendimiento para clientes en todo el mundo\nRequisitos de implementación: - opción --trustProxy habilitada en reseed-tools - Proxy de Cloudflare habilitado para el registro DNS - Manejo correcto del encabezado X-Forwarded-For\nConsideraciones importantes: - Se aplican las restricciones de puertos de Cloudflare (debe usar puertos admitidos) - La consistencia de la agrupación por cliente requiere soporte para X-Forwarded-For - La configuración de SSL/TLS está gestionada por Cloudflare\nDocumentación: https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/ Estrategias resistentes a la censura La investigación de Nguyen Phong Hoang (USENIX FOCI 2019) identifica métodos de arranque adicionales para redes censuradas:\nProveedores de almacenamiento en la nube Box, Dropbox, Google Drive, OneDrive: Alojar archivos SU3 en enlaces públicos Ventaja: Difícil de bloquear sin interrumpir servicios legítimos Limitación: Requiere distribuir manualmente la URL a los usuarios Distribución mediante IPFS Alojar paquetes de reseed (paquetes para resembrar la red) en InterPlanetary File System El almacenamiento direccionado por contenido impide la manipulación Resiliente frente a intentos de retirada Servicios Onion de Tor Reseed servers (servidores de inicialización) accesibles mediante direcciones .onion Resistente al bloqueo basado en IP Requiere un cliente de Tor en el sistema del usuario Documentación de investigación: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/ Países donde se sabe que se bloquea I2P A partir de 2025, se ha confirmado que los siguientes países bloquean los servidores de reseed de I2P (servidores de arranque de la red): - China - Irán - Omán - Catar - Kuwait\nLos usuarios en estas regiones deberían utilizar métodos alternativos de bootstrap (proceso de arranque inicial) o estrategias de reseeding (obtención inicial de información de nodos de la red) resistentes a la censura.\nDetalles del protocolo para implementadores Especificación de la solicitud de reseed Comportamiento del cliente Selección de servidor: Router mantiene una lista codificada de forma fija de URLs de reseed (proceso de bootstrapping inicial) Selección aleatoria: El cliente selecciona aleatoriamente un servidor de la lista disponible Formato de solicitud: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: Debe imitar navegadores comunes (p. ej., \u0026ldquo;Wget/1.11.4\u0026rdquo;) Lógica de reintento: Si la solicitud SU3 falla, recurrir al análisis de la página de índice Validación de certificado: Verificar el certificado TLS contra el almacén de confianza del sistema Validación de la firma SU3: Verificar la firma contra certificados de reseed conocidos Comportamiento del servidor Selección de paquetes: Seleccione un subconjunto seudoaleatorio de RouterInfos (información de router) de netDb Seguimiento de clientes: Identifique las solicitudes por la IP de origen (respetando X-Forwarded-For) Consistencia del paquete: Devuelva el mismo paquete a las solicitudes repetidas dentro de una ventana de tiempo (normalmente 8-12 horas) Diversidad de paquetes: Devuelva paquetes diferentes a distintos clientes para la diversidad de la red Content-Type: application/octet-stream o application/x-i2p-reseed Formato del archivo RouterInfo Cada archivo .dat en el paquete de reseed contiene una estructura RouterInfo:\nConvención de nombres de archivos: routerInfo-{base64-hash}.dat - El hash tiene 44 caracteres usando el alfabeto base64 de I2P - Ejemplo: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat\nContenido del archivo: - RouterIdentity (identidad del router; hash del router, clave de cifrado, clave de firma) - Marca de tiempo de publicación - Direcciones del router (IP, puerto, tipo de transporte) - Capacidades y opciones del router - Firma que cubre todos los datos anteriores\nRequisitos de diversidad de la red Para evitar la centralización de la red y permitir la detección de ataques Sybil:\nNo volcados completos de NetDb: Nunca servir todos los RouterInfos (información del router) a un único cliente Muestreo aleatorio: Cada paquete contiene un subconjunto diferente de los pares disponibles Tamaño mínimo del paquete: 75 RouterInfos (aumentado desde los 50 originales) Tamaño máximo del paquete: 100 RouterInfos Vigencia: Los RouterInfos deben ser recientes (dentro de las 24 horas desde su generación) Consideraciones sobre IPv6 Estado actual (2025): - Varios servidores de reseed (servidores de resembrado) muestran falta de respuesta en IPv6 - Los clientes deberían preferir o forzar IPv4 para mayor fiabilidad - Se recomienda el soporte de IPv6 para nuevas implementaciones, pero no es crítico\nNota de implementación: Al configurar servidores de doble pila, asegúrese de que las direcciones de escucha tanto de IPv4 como de IPv6 funcionen correctamente, o deshabilite IPv6 si no se puede soportar adecuadamente.\nConsideraciones de seguridad Modelo de amenazas El protocolo de reseed (proceso inicial para obtener información de routers de I2P) protege contra:\nAtaques de intermediario (man-in-the-middle): las firmas RSA-4096 evitan la manipulación del paquete Partición de la red: múltiples servidores de reseed (servidores de aprovisionamiento inicial) independientes evitan un único punto de control Ataques Sybil: la diversidad de paquetes limita la capacidad del atacante para aislar a los usuarios Censura: múltiples servidores y métodos alternativos proporcionan redundancia El protocolo reseed (resembrado) NO protege contra:\nServidores de reseed comprometidos: Si el atacante controla las claves privadas de los certificados de reseed (mecanismo de arranque inicial) Bloqueo completo de la red: Si todos los métodos de reseed están bloqueados en una región Monitoreo a largo plazo: Las solicitudes de reseed revelan la IP que intenta unirse a I2P Gestión de certificados Seguridad de claves privadas: - Almacene las claves de firma SU3 fuera de línea cuando no se estén usando - Utilice contraseñas robustas para el cifrado de claves - Mantenga copias de seguridad seguras de las claves y certificados - Considere módulos de seguridad de hardware (HSMs) para implementaciones de alto valor\nRevocación de certificados: - Listas de revocación de certificados (CRLs) distribuidas vía feed de noticias - Los certificados comprometidos pueden ser revocados por el coordinador - Routers actualizan automáticamente las CRLs con las actualizaciones de software\nMitigación de ataques Protección contra DDoS: - reglas de fail2ban para solicitudes excesivas - Limitación de tasa a nivel del servidor web - Límites de conexiones por dirección IP - Cloudflare o CDN similar para una capa adicional\nPrevención de scraping (extracción automatizada): - Paquetes diferentes por IP solicitante - Almacenamiento en caché de paquetes basado en el tiempo por IP - Registro de patrones que indiquen intentos de scraping - Coordinación con otros operadores sobre los ataques detectados\nPruebas y validación Prueba de su servidor Reseed (servidor de arranque de I2P) Método 1: Instalación limpia del router Instale I2P en un sistema limpio Añada su URL de reseed (proceso de arranque de pares) a la configuración Elimine o desactive otras URL de reseed Inicie el router y supervise los registros para confirmar un reseed exitoso Verifique la conexión a la red en un plazo de 5–10 minutos Salida de registro esperada:\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received Método 2: Validación manual de SU3 (formato de archivo de actualización firmado de I2P) # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) Método 3: Monitoreo de checki2p El servicio en https://checki2p.com/reseed realiza comprobaciones automatizadas cada 4 horas en todos los servidores de reseed (servidores de arranque que suministran pares iniciales) de I2P registrados. Esto proporciona:\nSupervisión de disponibilidad Métricas de tiempo de respuesta Validación de certificados TLS Verificación de firma SU3 Datos históricos de tiempo de actividad Una vez que su reseed (servidor de arranque) esté registrado en el proyecto I2P, aparecerá automáticamente en checki2p dentro de 24 horas.\nSolución de problemas comunes Problema: \u0026ldquo;Unable to read signing key\u0026rdquo; en la primera ejecución - Solución: Esto es lo esperado. Responde \u0026lsquo;y\u0026rsquo; para generar nuevas claves.\nProblema: Router no logra verificar la firma - Causa: El certificado no está en el almacén de confianza del router - Solución: Coloca el certificado en el directorio ~/.i2p/certificates/reseed/\nProblema: Mismo paquete servido a diferentes clientes - Causa: el encabezado X-Forwarded-For no se reenvía correctamente - Solución: habilita --trustProxy y configura las cabeceras del proxy inverso\nProblema: errores \u0026ldquo;Conexión rechazada\u0026rdquo; - Causa: Puerto no accesible desde Internet - Solución: Comprueba las reglas del firewall, verifica el reenvío de puertos\nProblema: Alto uso de CPU durante la reconstrucción del paquete - Causa: Comportamiento normal al generar 350+ variantes SU3 - Solución: Asegúrese de contar con recursos de CPU adecuados, considere reducir la frecuencia de reconstrucción\nInformación de referencia Documentación oficial Guía para colaboradores de Reseed (proceso de sembrado inicial de pares de I2P): /guides/creating-and-running-an-i2p-reseed-server/ Requisitos de la política de Reseed: /guides/reseed-policy/ Especificación de SU3: /docs/specs/updates/ Repositorio de herramientas de Reseed: https://i2pgit.org/idk/reseed-tools Documentación de las herramientas de Reseed: https://eyedeekay.github.io/reseed-tools/ Implementaciones alternativas PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Reseeder de Python WSGI: https://github.com/torbjo/i2p-reseeder Recursos de la comunidad Foro de I2P: https://i2pforum.net/ Repositorio de Gitea: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: #i2p-dev en IRC2P Supervisión del estado: https://checki2p.com/reseed Historial de versiones 0.9.14 (2014): Se introduce el formato SU3 de reseed (proceso de incorporación inicial a la red mediante servidores semilla) 0.9.16 (2014): Añadido reseeding basado en archivos 0.9.42 (2019): Requisito del parámetro de consulta Network ID 2.0.0 (2022): Se introduce el protocolo de transporte SSU2 2.4.0 (2024): Aislamiento de NetDB y mejoras de seguridad 2.6.0 (2024): Conexiones I2P-over-Tor bloqueadas 2.10.0 (2025): Versión estable actual (a septiembre de 2025) Referencia de tipos de firma Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 **Estándar de reseed (incorporación inicial a la red)**: Se requiere el Tipo 6 (RSA-SHA512-4096) para los paquetes de reseed. Agradecimientos Gracias a cada operador de reseed (servidor que proporciona pares iniciales) por mantener la red accesible y resiliente. Reconocimiento especial a los siguientes colaboradores y proyectos:\nzzz: Veterano desarrollador de I2P y coordinador de reseed (proceso de arranque/bootstrapping de I2P) idk: Mantenedor actual de reseed-tools y responsable de lanzamientos Nguyen Phong Hoang: Investigación sobre estrategias de reseeding resistentes a la censura PurpleI2P Team: Implementaciones alternativas de I2P y herramientas checki2p: Servicio de monitoreo automatizado para la infraestructura de reseed La infraestructura de reseed (proceso de arranque inicial para obtener pares) descentralizada de la red I2P representa un esfuerzo colaborativo de docenas de operadores en todo el mundo, garantizando que los nuevos usuarios siempre puedan encontrar una ruta para unirse a la red, independientemente de la censura local o de las barreras técnicas.\n","description":"Operación de los servicios de reseed (abastecimiento inicial de nodos) y métodos alternativos de arranque inicial","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"Servidores de Reseed (proceso de arranque inicial para obtener pares)","url":"/es/docs/misc/reseed/"},{"categories":null,"content":" Obsoleto: SSU fue reemplazado por SSU2. Se eliminó el soporte en i2pd 2.44.0 (API 0.9.56, nov 2022) y en Java I2P 2.4.0 (API 0.9.61, dic 2023).\nSSU ofrecía una entrega parcialmente fiable basada en UDP, con control de congestión, travesía de NAT y soporte para introducer (nodo introductor). Complementaba a NTCP al gestionar routers detrás de NAT/cortafuegos y al coordinar el descubrimiento de IP.\nElementos de la dirección transport: SSU caps: indicadores de capacidad (B, C, 4, 6, etc.) host / port: escucha IPv4 o IPv6 (opcional cuando el router está detrás de un cortafuegos) key: clave de introducción en Base64 mtu: Opcional; predeterminado 1484 (IPv4) / 1488 (IPv6) ihost/ikey/iport/itag/iexp: entradas de introducer (introductor) cuando el router está detrás de un cortafuegos Características Atravesamiento de NAT cooperativo mediante introducers (nodos presentadores) Detección de IP local mediante pruebas entre pares y la inspección de paquetes entrantes Estado del cortafuegos retransmitido automáticamente a otros transportes y a la consola del router Entrega semiconfiable: los mensajes se retransmiten hasta un límite y luego se descartan Control de congestión con aumento aditivo/disminución multiplicativa y campos de bits de ACK de fragmentos SSU también se encargaba de tareas de metadatos, como balizas de temporización y negociación de MTU. Toda la funcionalidad ahora la proporciona (con criptografía moderna) SSU2 .\n","description":"Transporte UDP seguro semiconfiable original","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (heredado)","url":"/es/docs/legacy/ssu/"},{"categories":null,"content":"Descripción general NTCP2 reemplaza el transporte NTCP heredado por un Noise-based handshake (protocolo de establecimiento de conexión basado en Noise) que resiste el fingerprinting de tráfico, cifra los campos de longitud y admite suites de cifrado modernas. Los routers pueden ejecutar NTCP2 junto con SSU2 como los dos protocolos de transporte obligatorios en la red I2P. NTCP (versión 1) se declaró obsoleto en la 0.9.40 (mayo de 2019) y se eliminó por completo en la 0.9.50 (mayo de 2021).\nNoise Protocol Framework (marco de protocolos criptográficos Noise) NTCP2 usa el Noise Protocol Framework (marco del protocolo Noise) Revision 33, 2017-10-04 con extensiones específicas de I2P:\nPatrón: Noise_XK_25519_ChaChaPoly_SHA256 Identificador extendido: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256 (para la inicialización del KDF) Función DH: X25519 (RFC 7748) - claves de 32 bytes, codificación little-endian (orden de bytes con el menos significativo primero) Cifrado: AEAD_CHACHA20_POLY1305 (RFC 7539/RFC 8439) Nonce de 12 bytes: primeros 4 bytes a cero, los últimos 8 bytes son un contador (little-endian) Valor máximo del nonce: 2^64 - 2 (la conexión debe finalizar antes de alcanzar 2^64 - 1) Función hash: SHA-256 (salida de 32 bytes) MAC: Poly1305 (etiqueta de autenticación de 16 bytes) Extensiones específicas de I2P Ofuscación con AES: Claves efímeras cifradas con AES-256-CBC usando el hash del router de Bob y un IV publicado Relleno aleatorio: Relleno en claro en los mensajes 1-2 (autenticado), relleno AEAD en el mensaje 3+ (cifrado) Ofuscación de longitud con SipHash-2-4: Longitudes de trama de dos bytes combinadas mediante XOR con la salida de SipHash Estructura de trama: Tramas con prefijo de longitud para la fase de datos (compatibilidad con streaming TCP) Cargas útiles basadas en bloques: Formato de datos estructurado con bloques tipados Flujo de negociación Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► Negociación de tres mensajes SessionRequest - la clave efímera ofuscada de Alice, opciones, indicaciones para el relleno SessionCreated - la clave efímera ofuscada de Bob, opciones cifradas, relleno SessionConfirmed - la clave estática cifrada de Alice y RouterInfo (información del router) (dos tramas AEAD) Patrones de mensajes de Noise (marco de protocolos criptográficos) XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 Niveles de autenticación: - 0: Sin autenticación (cualquier parte podría haberlo enviado) - 2: Autenticación del remitente resistente a la suplantación por compromiso de clave (KCI)\nNiveles de confidencialidad: - 1: Receptor efímero (secreto hacia adelante, sin autenticación del receptor) - 2: Receptor conocido, secreto hacia adelante solo frente al compromiso del remitente - 5: Secreto hacia adelante fuerte (efímero-efímero + efímero-estático DH)\nEspecificaciones de mensajes Notación de claves RH_A = Hash del Router para Alice (32 bytes, SHA-256) RH_B = Hash del Router para Bob (32 bytes, SHA-256) || = Operador de concatenación byte(n) = Un solo byte con valor n Todos los enteros de múltiples bytes son big-endian (orden de bytes con el más significativo primero) a menos que se especifique lo contrario Las claves X25519 son little-endian (orden de bytes con el menos significativo primero) (32 bytes) Cifrado autenticado (ChaCha20-Poly1305) Función de cifrado:\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) Parámetros: - key: clave de cifrado de 32 bytes del KDF (función de derivación de claves) - nonce: 12 bytes (4 bytes a cero + contador de 8 bytes, little-endian (orden de bytes de menor a mayor)) - associatedData: hash de 32 bytes en la fase de handshake (negociación inicial); de longitud cero en la fase de datos - plaintext: Datos a cifrar (0+ bytes)\nSalida: - Texto cifrado: Misma longitud que el texto plano - MAC: 16 bytes (etiqueta de autenticación Poly1305)\nGestión de Nonce (número usado una vez): - El contador empieza en 0 para cada instancia de cifrado - Se incrementa por cada operación AEAD en esa dirección - Contadores separados para Alice→Bob y Bob→Alice en la fase de datos - Debe terminarse la conexión antes de que el contador alcance 2^64 - 1\nMensaje 1: Solicitud de sesión Alice inicia la conexión con Bob.\nOperaciones de Noise (marco de protocolos criptográficos): e, es (generación e intercambio de claves efímeras)\nFormato sin procesar +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Restricciones de tamaño: - Mínimo: 80 bytes (32 AES + 48 AEAD) - Máximo: 65535 bytes en total - Caso especial: Máx. 287 bytes al conectarse a direcciones \u0026ldquo;NTCP\u0026rdquo; (detección de versión)\nContenido descifrado +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Bloque de opciones (16 bytes, big-endian, más significativo primero) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 Campos críticos: - ID de red (desde 0.9.42): Rechazo rápido de conexiones entre redes - m3p2len: Tamaño exacto de la parte 2 del mensaje 3 (debe coincidir al enviarse)\nFunción de derivación de claves (KDF-1) Inicializar el protocolo:\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash Operaciones de MixHash:\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD Operación MixKey (patrón es):\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF Notas de implementación Ofuscación AES: Usada solo para resistencia a DPI (inspección profunda de paquetes); cualquiera con el hash del router de Bob y el IV (vector de inicialización) puede descifrar X Prevención de repetición: Bob debe almacenar en caché los valores X (o sus equivalentes cifrados) durante al menos 2*D segundos (D = desfase máximo del reloj) Validación de marca de tiempo: Bob debe rechazar conexiones con |tsA - current_time| \u0026gt; D (normalmente D = 60 segundos) Validación de curva: Bob debe verificar que X sea un punto X25519 válido Rechazo rápido: Bob puede comprobar X[31] \u0026amp; 0x80 == 0 antes del descifrado (las claves X25519 válidas tienen el MSB (bit más significativo) a 0) Gestión de errores: Ante cualquier fallo, Bob cierra con TCP RST tras un tiempo de espera aleatorio y la lectura de un número aleatorio de bytes Almacenamiento en búfer: Alice debe vaciar todo el mensaje (incluido el relleno) de una vez para mayor eficiencia Mensaje 2: SessionCreated Bob responde a Alice.\nOperaciones de Noise: e, ee (DH efímero-efímero)\nFormato en bruto +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Contenido descifrado +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Bloque de opciones (16 bytes, big-endian (orden de bytes con el más significativo primero)) +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) Función de derivación de claves (KDF-2) Operaciones de MixHash:\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD Operación MixKey (función de mezcla de clave) (patrón ee):\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF Limpieza de memoria:\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side Notas de implementación Encadenamiento AES: El cifrado de Y utiliza el estado AES-CBC del mensaje 1 (no se restablece) Prevención de repetición: Alice debe almacenar en caché los valores Y durante al menos 2*D segundos Validación de marca de tiempo: Alice debe rechazar |tsB - current_time| \u0026gt; D Validación de curva: Alice debe verificar que Y sea un punto X25519 válido Manejo de errores: Alice cierra con TCP RST ante cualquier fallo Almacenamiento en búfer: Bob debe enviar de una vez el mensaje completo Mensaje 3: SessionConfirmed (confirmación de sesión) Alice confirma la sesión y envía RouterInfo (información del router).\nOperaciones de Noise: s, se (revelación de clave estática y DH estático-efímero)\nEstructura de dos partes El Mensaje 3 consta de dos tramas AEAD (cifrado autenticado con datos asociados) separadas:\nParte 1: Trama fija de 48 bytes con la clave estática cifrada de Alice Parte 2: Trama de longitud variable con RouterInfo (estructura de información del router), opciones y relleno Formato en bruto +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Restricciones de tamaño: - Parte 1: Exactamente 48 bytes (32 de texto en claro + 16 de MAC) - Parte 2: Longitud especificada en el mensaje 1 (campo m3p2len) - Máximo total: 65535 bytes (parte 1 máx. 48, por lo tanto, parte 2 máx. 65487)\nContenido descifrado Parte 1:\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ Parte 2:\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ Función de derivación de claves (KDF-3) Parte 1 (patrón s):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 Parte 2 (patrón se):\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF Limpieza de memoria:\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side Notas de implementación Validación de RouterInfo (información del router): Bob debe verificar la firma, la marca de tiempo y la coherencia de la clave Verificación de coincidencia de claves: Bob debe verificar que la clave estática de Alice en la parte 1 coincida con la clave en el RouterInfo Ubicación de la clave estática: Buscar un parámetro \u0026ldquo;s\u0026rdquo; coincidente en la RouterAddress (dirección del router) de NTCP o NTCP2 Orden de bloques: RouterInfo debe ir primero, Opciones en segundo lugar (si está presente), Relleno al final (si está presente) Planificación de la longitud: Alice debe asegurarse de que m3p2len en el mensaje 1 coincida exactamente con la longitud de la parte 2 Almacenamiento en búfer: Alice debe enviar ambas partes juntas en un único envío TCP Encadenamiento opcional: Alice puede adjuntar inmediatamente una trama de la fase de datos para mayor eficiencia Fase de datos Una vez completado el handshake (establecimiento de conexión), todos los mensajes usan tramas AEAD (cifrado autenticado con datos asociados) de longitud variable con campos de longitud ofuscados.\nFunción de derivación de claves (fase de datos) Función Split (Noise):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) Derivación de claves de SipHash:\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV Estructura de la trama +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ Limitaciones de la trama: - Mínimo: 18 bytes (2 longitud ofuscada + 0 texto en claro + 16 MAC) - Máximo: 65537 bytes (2 longitud ofuscada + 65535 trama) - Recomendado: Unos pocos KB por trama (minimizar la latencia del receptor)\nOfuscación de la longitud con SipHash (función hash autenticada) Propósito: Evitar que la inspección profunda de paquetes (DPI) identifique los límites de las tramas\nAlgoritmo:\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes Decodificación:\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) Notas: - Cadenas de IV separadas para cada dirección (Alice→Bob y Bob→Alice) - Si SipHash devuelve uint64, use los 2 bytes menos significativos como máscara - Convierta el uint64 al siguiente IV como bytes en formato little-endian\nFormato de bloque Cada trama contiene cero o más bloques:\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload Límites de tamaño: - Trama máxima: 65535 bytes (incluye MAC) - Espacio máximo de bloque: 65519 bytes (trama - MAC de 16 bytes) - Bloque individual máximo: 65519 bytes (cabecera de 3 bytes + 65516 de datos)\nTipos de bloques Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions **Reglas de orden de bloques:** - **Mensaje 3 parte 2**: RouterInfo, Options (opcional), Padding (opcional) - NO se permiten otros tipos - **Fase de datos**: Cualquier orden excepto: - Padding DEBE ser el último bloque si está presente - Termination DEBE ser el último bloque (excepto Padding) si está presente - Se permiten múltiples bloques de I2NP por trama - NO se permiten múltiples bloques de Padding por trama Tipo de bloque 0: Fecha y hora Sincronización temporal para la detección de desfase del reloj.\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) Implementación: Redondear al segundo más cercano para evitar la acumulación de desfase del reloj.\nTipo de bloque 1: Opciones Parámetros de relleno y de modelado del tráfico.\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) Relaciones de relleno (número de punto fijo 4.4, value/16.0): - tmin: Proporción mínima de relleno de transmisión (0.0 - 15.9375) - tmax: Proporción máxima de relleno de transmisión (0.0 - 15.9375) - rmin: Proporción mínima de relleno de recepción (0.0 - 15.9375) - rmax: Proporción máxima de relleno de recepción (0.0 - 15.9375)\nEjemplos: - 0x00 = 0% de relleno - 0x01 = 6,25% de relleno - 0x10 = 100% de relleno (relación 1:1) - 0x80 = 800% de relleno (relación 8:1)\nTráfico de relleno: - tdmy: Máximo dispuesto a enviar (2 bytes, promedio en bytes/seg) - rdmy: Solicitado para recibir (2 bytes, promedio en bytes/seg)\nInserción de retardo: - tdelay: Máximo que se está dispuesto a insertar (2 bytes, promedio en milisegundos) - rdelay: Retardo solicitado (2 bytes, promedio en milisegundos)\nDirectrices: - Los valores mínimos indican la resistencia deseada al análisis de tráfico - Los valores máximos indican restricciones de ancho de banda - El emisor debe respetar el máximo del receptor - El emisor puede respetar el mínimo del receptor dentro de las restricciones - No existe un mecanismo de cumplimiento; las implementaciones pueden variar\nTipo de bloque 2: RouterInfo Distribución de RouterInfo para poblar y difundir la netdb.\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 Uso:\nEn el Mensaje 3 Parte 2 (handshake): - Alice envía su RouterInfo (información del router) a Bob - El Flood bit (bit de inundación) normalmente es 0 (almacenamiento local) - RouterInfo NO está comprimido con gzip\nEn la fase de datos: - Cualquiera de las partes puede enviar su RouterInfo actualizado - Flood bit = 1: Solicitar distribución mediante floodfill (si el receptor es floodfill) - Flood bit = 0: Solo almacenamiento local en netdb\nRequisitos de validación: 1. Verificar que el tipo de firma sea compatible 2. Verificar la firma de RouterInfo 3. Verificar que la marca de tiempo esté dentro de límites aceptables 4. Para el handshake (negociación inicial): verificar que la clave estática coincida con el parámetro \u0026ldquo;s\u0026rdquo; de la dirección NTCP2 5. Para la fase de datos: verificar que el hash del router coincida con el par de la sesión 6. Solo propagar RouterInfos con direcciones publicadas\nNotas: - Sin mecanismo de acuse de recibo (ACK) (use I2NP DatabaseStore con token de respuesta si es necesario) - Puede contener RouterInfos de terceros (registros de identidad de routers de I2P) (uso de floodfill) - NO comprimido con gzip (a diferencia de I2NP DatabaseStore)\nTipo de bloque 3: Mensaje I2NP Mensaje I2NP con encabezado abreviado de 9 bytes.\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) Diferencias con NTCP1: - Expiración: 4 bytes (segundos) frente a 8 bytes (milisegundos) - Longitud: Omitida (deducible a partir de la longitud del bloque) - Suma de verificación: Omitida (AEAD proporciona integridad) - Encabezado: 9 bytes frente a 16 bytes (reducción del 44%)\nFragmentación: - Los mensajes I2NP NO DEBEN fragmentarse entre bloques - Los mensajes I2NP NO DEBEN fragmentarse entre tramas - Se permiten múltiples bloques I2NP por trama\nTipo de bloque 4: Terminación Cierre explícito de la conexión con código de motivo.\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) Códigos de motivo:\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny **Reglas:** - La terminación DEBE ser el último bloque que no sea de relleno en la trama - Como máximo un bloque de terminación por trama - El emisor debería cerrar la conexión después de enviar - El receptor debería cerrar la conexión después de recibir Manejo de errores: - Errores de handshake (negociación inicial): Normalmente se cierra con TCP RST (sin bloque de terminación) - Errores de AEAD (cifrado autenticado con datos asociados) en la fase de datos: Tiempo de espera aleatorio + lectura aleatoria, luego enviar terminación - Consulta la sección \u0026ldquo;AEAD Error Handling\u0026rdquo; para los procedimientos de seguridad\nTipo de bloque 254: Relleno Relleno aleatorio para resistir el análisis de tráfico.\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes Reglas: - El relleno DEBE ser el último bloque en la trama si está presente - Se permite relleno de longitud cero - Solo se permite un bloque de relleno por trama - Se permiten tramas solo de relleno - Debería cumplir con los parámetros negociados del bloque Options\nRelleno en los mensajes 1-2: - Fuera de la trama AEAD (texto en claro) - Incluido en la cadena de hashes del siguiente mensaje (autenticado) - Se detecta manipulación cuando falla el AEAD del siguiente mensaje\nRelleno en el Mensaje 3+ y en la Fase de Datos: - Dentro de la trama AEAD (cifrado autenticado con datos asociados; cifrada y autenticada) - Se utiliza para el conformado del tráfico y la ofuscación del tamaño\nGestión de errores de AEAD (cifrado autenticado con datos asociados) Requisitos de seguridad críticos:\nFase de negociación (Mensajes 1-3) Tamaño de mensaje conocido: - Los tamaños de los mensajes están predeterminados o se especifican de antemano - El fallo de autenticación de AEAD es inequívoco\nRespuesta de Bob al error del Mensaje 1: 1. Establecer un tiempo de espera aleatorio (rango dependiente de la implementación, se sugiere 100-500ms) 2. Leer una cantidad aleatoria de bytes (rango dependiente de la implementación, se sugiere 1KB-64KB) 3. Cerrar la conexión con TCP RST (sin respuesta) 4. Poner en lista negra la IP de origen temporalmente 5. Registrar fallos repetidos para bloqueos a largo plazo\nRespuesta de Alice ante el fallo del Mensaje 2: 1. Cerrar la conexión de inmediato con TCP RST (restablecimiento de TCP) 2. No responder a Bob\nRespuesta de Bob al fallo del Mensaje 3: 1. Cerrar la conexión de inmediato con TCP RST (restablecimiento de TCP) 2. No responder a Alice\nFase de datos Tamaño de mensaje ofuscado: - El campo de longitud está ofuscado con SipHash - Una longitud no válida o un fallo de AEAD podría indicar: - Sondeo por parte de un atacante - Corrupción en la red - IV de SipHash desincronizado - Par malicioso\nRespuesta a error de AEAD (cifrado autenticado con datos asociados) o de longitud: 1. Establecer un tiempo de espera aleatorio (se sugiere 100-500ms) 2. Leer un número aleatorio de bytes (se sugiere 1KB-64KB) 3. Enviar un bloque de terminación con código de motivo 4 (fallo de AEAD) o 9 (error de encuadre) 4. Cerrar la conexión\nPrevención del oráculo de descifrado: - Nunca revelar el tipo de error al par antes de un tiempo de espera aleatorio - Nunca omitir la validación de longitud antes de la verificación de AEAD (cifrado autenticado con datos asociados) - Tratar una longitud no válida igual que un fallo de AEAD - Usar una ruta de gestión de errores idéntica para ambos errores\nConsideraciones de implementación: - Algunas implementaciones pueden continuar tras errores de AEAD (cifrado autenticado con datos asociados) si son poco frecuentes - Finalizar tras errores repetidos (umbral sugerido: 3-5 errores por hora) - Equilibrio entre la recuperación ante errores y la seguridad\nRouterInfo publicado (información del router) Formato de la dirección del Router El soporte para NTCP2 se anuncia a través de entradas de RouterAddress publicadas con opciones específicas.\nEstilo de transporte: - \u0026quot;NTCP2\u0026quot; - NTCP2 solo en este puerto - \u0026quot;NTCP\u0026quot; - Tanto NTCP como NTCP2 en este puerto (detección automática) - Nota: compatibilidad con NTCP (v1) eliminada en 0.9.50 (mayo de 2021) - el estilo \u0026ldquo;NTCP\u0026rdquo; ahora está obsoleto; utiliza \u0026ldquo;NTCP2\u0026rdquo;\nOpciones obligatorias Todas las direcciones NTCP2 publicadas:\nhost - Dirección IP (IPv4 o IPv6) o nombre de host\nFormato: notación IP estándar o nombre de dominio Puede omitirse en routers de solo salida o ocultos port - Número de puerto TCP\nFormato: Entero, 1-65535 Puede omitirse para routers solo de salida o ocultos s - Clave pública estática (X25519)\nFormato: Codificado en Base64, 44 caracteres Codificación: Alfabeto Base64 de I2P Origen: Clave pública X25519 de 32 bytes, little-endian (orden de bytes de menor a mayor) i - Vector de inicialización para AES\nFormato: codificado en Base64, 24 caracteres Codificación: alfabeto Base64 de I2P Origen: IV de 16 bytes, big-endian (byte más significativo primero) v - Versión de protocolo\nFormato: Entero o enteros separados por comas Actual: \u0026quot;2\u0026quot; Futuro: \u0026quot;2,3\u0026quot; (deben estar en orden numérico) Opciones opcionales:\ncaps - Capacidades (desde 0.9.50)\nFormato: Cadena de caracteres de capacidad Valores: \u0026quot;4\u0026quot; - capacidad de salida IPv4 \u0026quot;6\u0026quot; - capacidad de salida IPv6 \u0026quot;46\u0026quot; - Ambos IPv4 e IPv6 (orden recomendado) No es necesario si host está publicado Útil para routers ocultos o tras cortafuegos cost - Prioridad de la dirección\nFormato: Entero, 0-255 Valores más bajos = mayor prioridad Sugerido: 5-10 para direcciones normales Sugerido: 14 para direcciones no publicadas Ejemplos de entradas de RouterAddress Dirección IPv4 publicada:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Router oculto (solo de salida):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Router de doble pila:\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Reglas importantes: - Varias direcciones NTCP2 con el mismo puerto DEBEN usar valores idénticos s, i y v - Puertos distintos pueden usar claves diferentes - Los routers de doble pila deberían publicar direcciones IPv4 e IPv6 separadas\nDirección NTCP2 no publicada Para routers solo de salida:\nSi un router no acepta conexiones NTCP2 entrantes pero inicia conexiones salientes, DEBE igualmente publicar un RouterAddress (dirección del router) con:\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Propósito: - Permite que Bob valide la clave estática de Alice durante el handshake (negociación inicial) - Necesario para la verificación de RouterInfo en el mensaje 3, parte 2 - No se necesitan i, host ni port (solo saliente)\nAlternativa: - Añade s y v a la dirección \u0026ldquo;NTCP\u0026rdquo; o SSU ya publicada\nRotación de clave pública e IV (vector de inicialización) Política de seguridad crítica:\nReglas generales: 1. Nunca rotar mientras el router esté en ejecución 2. Almacenar de forma persistente la clave y el IV (vector de inicialización) entre reinicios 3. Registrar el tiempo de inactividad previo para determinar la elegibilidad de rotación\nTiempo mínimo de inactividad antes de la rotación:\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact **Disparadores adicionales:** - Cambio de dirección IP local: Puede rotar independientemente del tiempo de inactividad - Router \"rekey\" (nuevo Router Hash): Generar nuevas claves Justificación: - Evita exponer los tiempos de reinicio a través de cambios de clave - Permite que los RouterInfos en caché expiren de forma natural - Mantiene la estabilidad de la red - Reduce los intentos de conexión fallidos\nImplementación: 1. Almacenar de forma persistente la clave, el IV y la marca de tiempo del último apagado 2. Al inicio, calcular el tiempo de inactividad = current_time - last_shutdown 3. Si el tiempo de inactividad \u0026gt; mínimo para el tipo de router, puede rotar 4. Si la IP cambió o hay rekeying (renovación de claves), puede rotar 5. De lo contrario, reutilizar la clave e IV anteriores\nRotación del vector de inicialización (IV): - Sujeta a las mismas reglas que la rotación de claves - Solo presente en direcciones publicadas (no en routers ocultos) - Se recomienda cambiar el IV cada vez que cambie la clave\nDetección de versión Contexto: Cuando transportStyle=\u0026quot;NTCP\u0026quot; (heredado), Bob admite tanto NTCP v1 como v2 en el mismo puerto y debe detectar automáticamente la versión del protocolo.\nAlgoritmo de detección:\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 Comprobación rápida del bit más significativo (MSB): - Antes del descifrado AES, verifique: encrypted_X[31] \u0026amp; 0x80 == 0 - Las claves X25519 válidas tienen el bit más alto en 0 - Un fallo indica probablemente NTCP1 (o un ataque) - Implemente resistencia al sondeo (tiempo de espera aleatorio + lectura) en caso de fallo\nRequisitos de implementación:\nResponsabilidad de Alice:\nAl conectarse a la dirección \u0026ldquo;NTCP\u0026rdquo;, limitar el mensaje 1 a un máximo de 287 bytes Almacenar en búfer y vaciar el mensaje 1 completo de una sola vez Aumenta la probabilidad de entrega en un único paquete TCP Responsabilidad de Bob:\nAlmacenar en búfer los datos recibidos antes de decidir la versión Implementar una gestión adecuada de los tiempos de espera Usar TCP_NODELAY para una detección rápida de la versión Almacenar en búfer y vaciar el mensaje 2 completo de una sola vez una vez detectada la versión Consideraciones de seguridad: - Ataques de segmentación: Bob debe ser resistente a la segmentación de TCP - Ataques de sondeo: Implementar retrasos aleatorios y lecturas de bytes ante fallos - Prevención de denegación de servicio (DoS): Limitar las conexiones pendientes simultáneas - Tiempos de espera de lectura: Tanto por lectura como totales (protección contra \u0026ldquo;slowloris\u0026rdquo;)\nDirectrices sobre el desfase del reloj Campos de marca de tiempo: - Mensaje 1: tsA (marca de tiempo de Alice) - Mensaje 2: tsB (marca de tiempo de Bob) - Mensaje 3+: Bloques DateTime (fecha y hora) opcionales\nDesfase máximo (D): - Típico: ±60 segundos - Configurable según la implementación - El desfase \u0026gt; D generalmente es fatal\nManejo de Bob (Mensaje 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally Justificación: Enviar el mensaje 2 incluso cuando hay desfase de reloj permite a Alice diagnosticar problemas de sincronización del reloj.\nProcesamiento de Alice (Mensaje 2) 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization Ajuste de RTT: - Restar la mitad del RTT de la desviación calculada - Tiene en cuenta el retraso de propagación de la red - Estimación de la desviación más precisa\nProcesamiento de Bob (Mensaje 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) Sincronización de tiempo Bloques DateTime (Fase de datos): - Enviar periódicamente DateTime block (bloque de fecha y hora) (tipo 0) - El receptor puede usarlo para ajustar el reloj - Redondear la marca de tiempo al segundo más cercano (evitar sesgo)\nFuentes de tiempo externas: - NTP (Network Time Protocol) - Sincronización del reloj del sistema - Tiempo de consenso de la red de I2P\nEstrategias de ajuste del reloj: - Si el reloj local es incorrecto: Ajusta la hora del sistema o usa un desfase - Si los relojes de los pares son sistemáticamente incorrectos: Señala el problema del par - Realiza seguimiento de las estadísticas de desfase para el monitoreo del estado de la red\nPropiedades de seguridad Secreto Perfecto hacia Adelante Logrado mediante: - Intercambio de claves Diffie-Hellman efímero (X25519) - Tres operaciones DH: es, ee, se (Noise XK pattern, patrón Noise XK) - Las claves efímeras se destruyen tras completar el protocolo de negociación\nProgresión de confidencialidad: - Mensaje 1: Nivel 2 (secreto perfecto hacia adelante en caso de compromiso del remitente) - Mensaje 2: Nivel 1 (destinatario efímero) - Mensaje 3+: Nivel 5 (secreto perfecto hacia adelante fuerte)\nSecreto Perfecto hacia Adelante: - El compromiso de claves estáticas a largo plazo NO revela claves de sesión anteriores - Cada sesión usa claves efímeras únicas - Las claves privadas efímeras nunca se reutilizan - Limpieza de memoria después del acuerdo de claves\nLimitaciones: - El Mensaje 1 es vulnerable si se compromete la clave estática de Bob (aunque se mantiene el secreto perfecto hacia adelante si Alice se ve comprometida) - Son posibles ataques de repetición para el mensaje 1 (mitigados por la marca de tiempo y la caché antirrepetición)\nAutenticación Autenticación mutua: - Alice autenticada mediante clave estática en el mensaje 3 - Bob autenticado por la posesión de la clave privada estática (implícito a partir de una negociación exitosa)\nResistencia a Key Compromise Impersonation (KCI, suplantación por compromiso de clave): - Nivel de autenticación 2 (resistente a KCI) - Un atacante no puede hacerse pasar por Alice ni siquiera con la clave privada estática de Alice (sin la clave efímera de Alice) - Un atacante no puede hacerse pasar por Bob ni siquiera con la clave privada estática de Bob (sin la clave efímera de Bob)\nVerificación de clave estática: - Alice sabe de antemano la clave estática de Bob (a partir de RouterInfo) - Bob verifica que la clave estática de Alice coincide con RouterInfo en el mensaje 3 - Evita ataques de intermediario\nResistencia al análisis de tráfico Contramedidas de DPI (inspección profunda de paquetes): 1. Ofuscación con AES: Claves efímeras cifradas, apariencia aleatoria 2. Ofuscación de la longitud con SipHash: Longitudes de trama no en claro 3. Relleno aleatorio: Tamaños de mensaje variables, sin patrones fijos 4. Tramas cifradas: Toda la carga útil cifrada con ChaCha20\nPrevención de ataques de repetición: - Validación de marca de tiempo (±60 segundos) - Caché antirrepetición de claves efímeras (tiempo de vida 2*D) - Los incrementos del Nonce (número usado una vez) evitan la repetición de paquetes dentro de la sesión\nResistencia a sondeos: - Tiempos de espera aleatorios ante fallos de AEAD (cifrado autenticado con datos asociados) - Lecturas aleatorias de bytes antes de cerrar la conexión - Sin respuestas ante fallos de handshake (intercambio inicial) - Inclusión de direcciones IP en lista negra por fallos repetidos\nPautas de relleno: - Mensajes 1-2: Relleno en texto en claro (autenticado) - Mensaje 3+: Relleno cifrado dentro de tramas AEAD - Parámetros de relleno negociados (Options block, bloque de opciones) - Se permiten tramas solo de relleno\nMitigación de denegación de servicio Límites de conexión: - Máximo de conexiones activas (dependiente de la implementación) - Máximo de handshakes (negociación inicial) pendientes (p. ej., 100-1000) - Límites de conexión por IP (p. ej., 3-10 simultáneas)\nProtección de recursos: - Operaciones DH con limitación de tasa (costosas) - Tiempos de espera de lectura por socket y totales - Protección contra \u0026ldquo;Slowloris\u0026rdquo; (ataque de conexiones lentas; límites de tiempo totales) - Inclusión de IP en lista negra por abuso\nRechazo rápido: - Discordancia de ID de red → cierre inmediato - Punto X25519 no válido → comprobación rápida del bit más significativo (MSB) antes del descifrado - Marca de tiempo fuera de rango → cierre sin procesamiento - Error de AEAD (cifrado autenticado con datos asociados) → sin respuesta, retraso aleatorio\nResistencia al sondeo: - Tiempo de espera aleatorio: 100-500ms (dependiente de la implementación) - Lectura aleatoria: 1KB-64KB (dependiente de la implementación) - Sin información de error para el atacante - Cerrar con TCP RST (sin FIN handshake)\nSeguridad criptográfica Algoritmos: - X25519: seguridad de 128 bits, DH de curva elíptica (Curve25519) - ChaCha20: cifrado de flujo con clave de 256 bits - Poly1305: MAC con seguridad teórica de la información - SHA-256: resistencia a colisiones de 128 bits, resistencia a preimagen de 256 bits - HMAC-SHA256: PRF para la derivación de claves\nTamaños de clave: - Claves estáticas: 32 bytes (256 bits) - Claves efímeras: 32 bytes (256 bits) - Claves de cifrado: 32 bytes (256 bits) - MAC: 16 bytes (128 bits)\nProblemas conocidos: - La reutilización del nonce (número usado una vez) en ChaCha20 es catastrófica (evitada mediante el incremento del contador) - X25519 tiene problemas de subgrupos pequeños (mitigado mediante la validación de la curva) - SHA-256 es teóricamente vulnerable a la extensión de longitud (no explotable en HMAC)\nNo hay vulnerabilidades conocidas (a octubre de 2025): - Noise Protocol Framework (marco de protocolos Noise) ampliamente analizado - ChaCha20-Poly1305 (cifrado autenticado) implementado en TLS 1.3 - X25519 (intercambio de claves de curva elíptica) estándar en protocolos modernos - No hay ataques prácticos contra la construcción criptográfica\nReferencias Especificaciones principales NTCP2 Specification - Especificación oficial de I2P Proposal 111 - Documento de diseño original con fundamentos Noise Protocol Framework - Revisión 33 (2017-10-04) Estándares criptográficos RFC 7748 - Curvas elípticas para la seguridad (X25519) RFC 7539 - ChaCha20 y Poly1305 para protocolos de la IETF RFC 8439 - ChaCha20-Poly1305 (deja obsoleto el RFC 7539) RFC 2104 - HMAC: hash con clave para la autenticación de mensajes SipHash - SipHash-2-4 para aplicaciones de funciones hash Especificaciones relacionadas de I2P Especificación de I2NP - formato de mensajes del protocolo de red de I2P Estructuras comunes - formatos de RouterInfo y RouterAddress Transporte SSU - transporte UDP (original, ahora SSU2) Propuesta 147 - verificación del ID de la red de transporte (0.9.42) Referencias de implementación I2P Java - Implementación de referencia (Java) i2pd - Implementación en C++ I2P Release Notes - Historial de versiones y actualizaciones Contexto histórico Protocolo Station-To-Station (STS) - Inspiración para Noise framework (conjunto de protocolos Noise) obfs4 - Pluggable transport (transporte conectable) (precedente de ofuscación de longitud con SipHash) Directrices de implementación Requisitos obligatorios Para cumplimiento:\nImplementar el protocolo de enlace completo:\nAdmitir los tres mensajes con cadenas KDF correctas (función de derivación de claves) Validar todas las etiquetas AEAD (cifrado autenticado con datos asociados) Verificar que los puntos X25519 sean válidos Implementar la fase de datos:\nOfuscación de longitud mediante SipHash (en ambas direcciones) Todos los tipos de bloque: 0 (DateTime), 1 (Options), 2 (RouterInfo), 3 (I2NP), 4 (Termination), 254 (Padding) Gestión adecuada del nonce (valor único de un solo uso) con contadores separados Características de seguridad:\nPrevención de ataques de repetición (almacenar en caché claves efímeras durante 2*D) Validación de marca de tiempo (±60 segundos por defecto) Relleno aleatorio en los mensajes 1-2 Gestión de errores de AEAD (cifrado autenticado con datos asociados) con tiempos de espera aleatorios Publicación de RouterInfo (información del router):\nPublicar la clave estática (\u0026ldquo;s\u0026rdquo;), el IV (vector de inicialización) (\u0026ldquo;i\u0026rdquo;) y la versión (\u0026ldquo;v\u0026rdquo;) Rotar las claves según la política Admitir el campo de capacidades (\u0026ldquo;caps\u0026rdquo;) para routers ocultos Compatibilidad de red:\nAdmitir el campo de ID de red (actualmente 2 para la red principal) Interoperar con las implementaciones existentes de Java e i2pd Gestionar tanto IPv4 como IPv6 Prácticas recomendadas Optimización del rendimiento:\nEstrategia de bufferizado:\nVolcar mensajes completos de una vez (mensajes 1, 2, 3) Usar TCP_NODELAY para mensajes de handshake (negociación inicial) Almacenar en búfer múltiples bloques de datos en una sola trama Limitar el tamaño de la trama a pocos KB (minimizar la latencia del receptor) Gestión de conexiones:\nReutilizar conexiones cuando sea posible Implementar un pool de conexiones Supervisar el estado de las conexiones (bloques de DateTime) Gestión de memoria:\nPoner a cero los datos sensibles después de su uso (claves efímeras, resultados de DH) Limitar los handshakes (intercambios de establecimiento) concurrentes (prevención de DoS) Usar pools de memoria para asignaciones frecuentes Endurecimiento de seguridad:\nResistencia a sondeos:\nTiempos de espera aleatorios: 100-500ms Lecturas aleatorias de bytes: 1KB-64KB Bloqueo de IP por fallos repetidos Sin detalles de error para los pares Límites de recursos:\nMáximo de conexiones por IP: 3-10 Máximo de handshakes pendientes (negociaciones iniciales): 100-1000 Tiempos de espera de lectura: 30-60 segundos por operación Tiempo de espera total de la conexión: 5 minutos para el handshake Gestión de claves:\nAlmacenamiento persistente de la clave estática y del vector de inicialización (IV) Generación aleatoria segura (generador de números aleatorios criptográfico) Cumplir estrictamente las políticas de rotación Nunca reutilizar claves efímeras Monitoreo y diagnóstico:\nMétricas:\nTasas de éxito/fallo del handshake (negociación inicial) Tasas de errores de AEAD (cifrado autenticado con datos asociados) Distribución del desfase del reloj Estadísticas de la duración de la conexión Registro:\nRegistrar fallos de handshake (negociación inicial) con códigos de motivo Registrar eventos de desfase del reloj Registrar direcciones IP bloqueadas Nunca registrar material de claves sensible Pruebas:\nPruebas unitarias para cadenas de KDF Pruebas de integración con otras implementaciones Fuzzing (pruebas con entradas aleatorias) para la gestión de paquetes Pruebas de carga para resistencia frente a DoS Escollos comunes Errores críticos que se deben evitar:\nReutilización de nonce (número aleatorio de un solo uso):\nNunca reinicies el contador de nonce a mitad de sesión Usa contadores separados para cada sentido Finaliza antes de alcanzar 2^64 - 1 Rotación de claves:\nNunca rote claves mientras el router esté en ejecución Nunca reutilice claves efímeras entre sesiones Cumpla las reglas de tiempo de inactividad mínimo Gestión de marcas de tiempo:\nNunca aceptar marcas de tiempo expiradas Ajustar siempre por RTT (tiempo de ida y vuelta) al calcular el desfase Redondear las marcas de tiempo de DateTime a segundos Errores AEAD (cifrado autenticado con datos asociados):\nNunca revelar el tipo de error al atacante Usar siempre un tiempo de espera aleatorio antes de cerrar Tratar una longitud no válida del mismo modo que un fallo de AEAD Relleno:\nNunca enviar relleno fuera de los límites negociados Siempre colocar el bloque de relleno al final Nunca múltiples bloques de relleno por trama RouterInfo:\nVerificar siempre que la clave estática coincida con el RouterInfo Nunca difundir RouterInfos sin direcciones publicadas Validar siempre las firmas Metodología de pruebas Pruebas unitarias:\nPrimitivas criptográficas:\nVectores de prueba para X25519, ChaCha20, Poly1305, SHA-256 Vectores de prueba de HMAC-SHA256 Vectores de prueba de SipHash-2-4 Cadenas KDF:\nPruebas de respuesta conocida para los tres mensajes Verificar la propagación de la clave de encadenamiento Probar la generación del IV de SipHash Análisis de mensajes:\nDecodificación de mensajes válidos Rechazo de mensajes no válidos Condiciones límite (vacío, tamaño máximo) Pruebas de integración:\nHandshake (negociación inicial):\nIntercambio exitoso de tres mensajes Rechazo por desfase de reloj Detección de ataques de repetición Rechazo de claves no válidas Fase de datos:\nTransferencia de mensajes I2NP Intercambio de RouterInfo (información del router) Gestión del relleno Mensajes de terminación Interoperabilidad:\nProbar contra Java I2P Probar contra i2pd Probar IPv4 e IPv6 Probar routers publicados y ocultos Pruebas de seguridad:\nPruebas negativas:\nEtiquetas AEAD no válidas Mensajes repetidos Ataques por desfase de reloj Tramas malformadas Pruebas de denegación de servicio (DoS):\nInundación de conexiones Ataques Slowloris Agotamiento de CPU (DH excesivo, intercambio de claves Diffie-Hellman) Agotamiento de memoria Fuzzing (pruebas aleatorias):\nMensajes de negociación aleatorios Tramas aleatorias de la fase de datos Tipos y tamaños de bloque aleatorios Valores criptográficos no válidos Migración desde NTCP Para el soporte heredado de NTCP (ahora eliminado):\nNTCP (versión 1) se eliminó en I2P 0.9.50 (mayo de 2021). Todas las implementaciones actuales deben admitir NTCP2. Notas históricas:\nPeriodo de transición (2018-2021):\n0.9.36: NTCP2 introducido (deshabilitado de forma predeterminada) 0.9.37: NTCP2 habilitado de forma predeterminada 0.9.40: NTCP (protocolo de transporte antiguo de I2P) declarado obsoleto 0.9.50: NTCP eliminado Detección de versión:\nEl transportStyle (estilo de transporte) \u0026ldquo;NTCP\u0026rdquo; indicaba compatibilidad con ambas versiones El transportStyle \u0026ldquo;NTCP2\u0026rdquo; indicaba solo NTCP2 Detección automática mediante el tamaño del mensaje (287 frente a 288 bytes) Estado actual:\nTodos los routers deben admitir NTCP2 El transportStyle \u0026ldquo;NTCP\u0026rdquo; está obsoleto Utilice el transportStyle \u0026ldquo;NTCP2\u0026rdquo; exclusivamente Apéndice A: Patrón XK de Noise Patrón estándar XK de Noise:\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se Interpretación:\n\u0026lt;- : Mensaje del respondedor (Bob) al iniciador (Alice) -\u0026gt; : Mensaje del iniciador (Alice) al respondedor (Bob) s : Clave estática (clave de identidad a largo plazo) rs : Clave estática remota (clave estática del par, conocida de antemano) e : Clave efímera (específica de la sesión, generada bajo demanda) es : DH efímera-estática (efímera de Alice × estática de Bob) ee : DH efímera-efímera (efímera de Alice × efímera de Bob) se : DH estática-efímera (estática de Alice × efímera de Bob) Secuencia de acuerdo de claves:\nPre-mensaje: Alice conoce la clave pública estática de Bob (de RouterInfo) Mensaje 1: Alice envía una clave efímera, realiza es DH (efímera-estática) Mensaje 2: Bob envía una clave efímera, realiza ee DH Mensaje 3: Alice revela la clave estática, realiza se DH Propiedades de seguridad:\nAlice autenticada: Sí (por el mensaje 3) Bob autenticado: Sí (por poseer la clave privada estática) Secreto perfecto hacia adelante: Sí (claves efímeras destruidas) Resistencia a KCI (Key Compromise Impersonation, suplantación por compromiso de clave): Sí (nivel de autenticación 2) Apéndice B: Codificación Base64 Alfabeto Base64 de I2P:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ Diferencias con el Base64 estándar: - Caracteres 62-63: -~ en lugar de +/ - Relleno: Igual (=) u omitido según el contexto\nUso en NTCP2: - Clave estática (\u0026ldquo;s\u0026rdquo;): 32 bytes → 44 caracteres (sin relleno) - IV (\u0026ldquo;i\u0026rdquo;): 16 bytes → 24 caracteres (sin relleno)\nEjemplo de codificación:\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= Apéndice C: Análisis de captura de paquetes Identificación del tráfico NTCP2:\nNegociación TCP:\nTCP estándar: SYN, SYN-ACK, ACK Puerto de destino generalmente 8887 o similar Mensaje 1 (SessionRequest - solicitud de sesión):\nPrimeros datos de la aplicación provenientes de Alice 80-65535 bytes (normalmente unos pocos cientos) Parece aleatorio (clave efímera cifrada con AES) 287 bytes máximo si se conecta a una dirección \u0026ldquo;NTCP\u0026rdquo; Mensaje 2 (SessionCreated, creación de sesión):\nRespuesta de Bob 80-65535 bytes (normalmente unos pocos cientos) También parece aleatorio Mensaje 3 (SessionConfirmed):\nDe Alice 48 bytes + variable (tamaño de RouterInfo (información del router) + relleno) Normalmente 1-4 KB Fase de datos:\nTramas de longitud variable Campo de longitud ofuscado (parece aleatorio) Carga útil cifrada El relleno hace que el tamaño sea impredecible Evasión de DPI (inspección profunda de paquetes): - Sin cabeceras en texto plano - Sin patrones fijos - Campos de longitud ofuscados - El relleno aleatorio invalida las heurísticas basadas en el tamaño\nComparación con NTCP: - Mensaje 1 de NTCP siempre de 288 bytes (identificable) - El tamaño del mensaje 1 de NTCP2 varía (no identificable) - NTCP tenía patrones reconocibles - NTCP2 diseñado para resistir la inspección profunda de paquetes (DPI)\nApéndice D: Historial de versiones Hitos principales:\n0.9.36 (23 de agosto de 2018): NTCP2 introducido, deshabilitado de forma predeterminada 0.9.37 (4 de octubre de 2018): NTCP2 habilitado de forma predeterminada 0.9.40 (20 de mayo de 2019): NTCP declarado obsoleto 0.9.42 (27 de agosto de 2019): Se añadió el campo de ID de red (Propuesta 147) 0.9.50 (17 de mayo de 2021): NTCP eliminado, se añadió soporte para capacidades 2.10.0 (9 de septiembre de 2025): Última versión estable Estabilidad del protocolo: - Sin cambios incompatibles desde la versión 0.9.50 - Mejoras continuas en la resistencia frente a sondeos - Enfoque en el rendimiento y la fiabilidad - Criptografía poscuántica en desarrollo (no habilitada de forma predeterminada)\nEstado actual del transporte: - NTCP2: Transporte TCP obligatorio - SSU2: Transporte UDP obligatorio - NTCP (v1): Eliminado - SSU (v1): Eliminado\n","description":"Transporte TCP basado en Noise (marco de protocolos criptográficos) para enlaces de router a router","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"Transporte NTCP2","url":"/es/docs/specs/ntcp2/"},{"categories":null,"content":" Obsoleto: SSU (Secure Semi-Reliable UDP) ha sido reemplazado por SSU2 . Java I2P eliminó SSU en la versión 2.4.0 (API 0.9.61) y i2pd lo eliminó en la 2.44.0 (API 0.9.56). Este documento se conserva únicamente como referencia histórica.\nAspectos destacados Transporte UDP que proporciona entrega punto a punto cifrada y autenticada de mensajes de I2NP. Se basaba en un intercambio Diffie–Hellman de 2048 bits (el mismo número primo que ElGamal). Cada datagrama llevaba un HMAC‑MD5 de 16 bytes (variante truncada no estándar) + un IV de 16 bytes, seguido de una carga útil cifrada con AES‑256‑CBC. La prevención de repeticiones y el estado de la sesión se controlaban dentro de la carga útil cifrada. Encabezado del mensaje [16-byte MAC][16-byte IV][encrypted payload] Cálculo de MAC utilizado: HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8))) con una clave de MAC de 32 bytes. La longitud de la carga útil, un entero de 16 bits en big-endian, se incluía dentro del cálculo del MAC. La versión del protocolo por defecto era 0; netId por defecto era 2 (red principal).\nClaves de sesión y MAC Derivado del secreto compartido de DH:\nConvierta el valor compartido en una matriz de bytes big-endian (orden de bytes de mayor peso primero) (anteponga 0x00 si el bit más significativo está en 1). Clave de sesión: los primeros 32 bytes (rellene con ceros si es más corta). Clave MAC: bytes 33–64; si no hay suficientes, recurra al hash SHA-256 del valor compartido. Estado Los Routers ya no anuncian direcciones SSU. Los clientes deberían migrar a los transportes SSU2 o NTCP2. Se pueden encontrar implementaciones históricas en versiones anteriores:\nCódigo fuente de Java anterior a la versión 2.4.0 en router/transport/udp Código fuente de i2pd (implementación de I2P en C++) anterior a la versión 2.44.0 Para el comportamiento actual del transporte UDP, consulte la especificación de SSU2 .\n","description":"Transporte UDP original utilizado antes de SSU2","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"Transporte SSU (Obsoleto)","url":"/es/docs/legacy/ssu/"},{"categories":null,"content":" Aviso histórico: Esta página conserva la discusión heredada “Unidirectional Tunnels” como referencia. Consulte la documentación de implementación de tunnel vigente para el comportamiento actual.\nDescripción general I2P construye tunnels unidireccionales: un tunnel transporta el tráfico saliente y un tunnel separado transporta las respuestas entrantes. Esta estructura se remonta a los diseños de red más tempranos y sigue siendo un diferenciador clave frente a los sistemas de circuitos bidireccionales como Tor. Para la terminología y los detalles de implementación, consulta la descripción general de tunnel y la especificación de tunnel .\nRevisión Los tunnel unidireccionales mantienen separado el tráfico de petición y de respuesta, de modo que cualquier grupo individual de pares confabulados observa solo la mitad de un trayecto de ida y vuelta. Los ataques de temporización deben cruzarse con dos conjuntos de tunnel (saliente y entrante) en lugar de analizar un único circuito, aumentando la dificultad de la correlación. Los conjuntos independientes, entrante y saliente, permiten a los routers ajustar la latencia, la capacidad y las características de gestión de fallos por dirección. Entre los inconvenientes se incluyen una mayor complejidad en la gestión de pares y la necesidad de mantener múltiples conjuntos de tunnel para una prestación de servicio fiable. Anonimato El artículo de Hermann y Grothoff, I2P is Slow… and What to Do About It , analiza ataques de predecesor contra tunnels unidireccionales, sugiriendo que adversarios determinados pueden, con el tiempo, confirmar pares de larga duración. Los comentarios de la comunidad señalan que el estudio se basa en supuestos específicos sobre la paciencia del adversario y sus facultades legales, y no compara el enfoque con ataques de temporización que afectan a diseños bidireccionales. La investigación continua y la experiencia práctica siguen reforzando los tunnels unidireccionales como una elección deliberada de anonimato, más que como un descuido.\n","description":"Resumen histórico del diseño de tunnel unidireccional de I2P.","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"Tunnels unidireccionales","url":"/es/docs/legacy/unidirectional/"},{"categories":null,"content":" La rama principal de desarrollo de I2P (i2p.i2p) ha sido configurada para permitir a los desarrolladores configurar fácilmente dos de los IDEs más comúnmente utilizados para el desarrollo en Java: Eclipse y NetBeans. Eclipse Las ramas principales de desarrollo de I2P (i2p.i2p y las ramas derivadas de ella) contienen build.gradle para permitir que la rama se configure fácilmente en Eclipse. Asegúrate de tener una versión reciente de Eclipse. Cualquier versión posterior a 2017 debería funcionar. Clona la rama de I2P en algún directorio (por ejemplo, $HOME/dev/i2p.i2p). Selecciona \"File → Import...\" y luego bajo \"Gradle\" selecciona \"Existing Gradle Project\". Para \"Project root directory:\" elige el directorio donde se clonó la rama de I2P. En el diálogo \"Import Options\", selecciona \"Gradle Wrapper\" y presiona Continue. En el diálogo \"Import Preview\" puedes revisar la estructura del proyecto. Deberían aparecer múltiples proyectos bajo \"i2p.i2p\". Presiona \"Finish\". ¡Listo! Tu espacio de trabajo ahora debería contener todos los proyectos dentro de la rama de I2P, y sus dependencias de compilación deberían estar configuradas correctamente. NetBeans Las ramas principales de desarrollo de I2P (i2p.i2p y las ramas derivadas de ella) contienen archivos de proyecto de NetBeans. ","description":"Configurar Eclipse y NetBeans para desarrollar I2P con Gradle y archivos de proyecto incluidos","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"Usando un IDE con I2P","url":"/es/docs/guides/ides/"},{"categories":null,"content":" Estado: Esta es una referencia concisa para la utilidad v3dgsend. Complementa la documentación de la API de Datagramas y SAM v3 .\nResumen general v3dgsend es una herramienta de línea de comandos para enviar datagramas I2P utilizando la interfaz SAMv3. Es útil para probar la entrega de datagramas, prototipar servicios y verificar el comportamiento de extremo a extremo sin escribir un cliente completo.\nLos usos típicos incluyen:\nPrueba de humo de accesibilidad de datagramas a un Destino Validación de configuración de firewall y libreta de direcciones Experimentación con datagramas sin procesar vs. firmados (respondibles) Uso La invocación básica varía según la plataforma y el paquete. Las opciones comunes incluyen:\nDestination: Destination en base64 o nombre .i2p Protocol: raw (PROTOCOL 18) o signed (PROTOCOL 17) Payload: cadena en línea o archivo de entrada Consulte el empaquetado de su distribución o la salida de --help para conocer las banderas exactas.\nVer también API de Datagramas SAM v3 Biblioteca de Streaming (alternativa a los datagramas) ","description":"Utilidad CLI para enviar datagramas I2P mediante SAM v3","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/es/docs/api/v3dgsend/"}]
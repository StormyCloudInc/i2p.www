[{"categories":null,"content":"نظرة عامة تحتوي عناوين Base 32 القياسية (\u0026ldquo;b32\u0026rdquo;) على تجزئة الوجهة. لن يعمل ذلك مع LS2 المشفرة (LeaseSet الإصدار الثاني) (proposal 123).\nلا يمكننا استخدام عنوان base 32 تقليدي لـ LS2 مشفّر (proposal 123)، لأنه يحتوي فقط على تجزئة الوجهة. لا يوفّر المفتاح العام غير المُعمّى. يجب أن يعرف العملاء المفتاح العام للوجهة، ونوع التوقيع، ونوع التوقيع المُعمّى، وسرًا اختياريًا أو مفتاحًا خاصًا من أجل جلب وفك تشفير الـ leaseset. لذلك، فإن عنوان base 32 وحده غير كافٍ. يحتاج العميل إما إلى الوجهة الكاملة (التي تحتوي على المفتاح العام)، أو إلى المفتاح العام وحده. إذا كان لدى العميل الوجهة الكاملة في دفتر عناوين، وكان دفتر العناوين يدعم البحث العكسي باستخدام التجزئة، فحينها يمكن استرجاع المفتاح العام.\nهذا التنسيق يضع المفتاح العام بدلاً من التجزئة في عنوان base32. ويجب أن يحتوي هذا التنسيق أيضًا على نوع التوقيع للمفتاح العام، ونوع التوقيع الخاص بـ blinding scheme (مخطط الإعماء).\nيحدد هذا المستند صيغة b32 لهذه العناوين. ورغم أننا أشرنا إلى هذه الصيغة الجديدة أثناء المناقشات على أنها عنوان \u0026ldquo;b33\u0026rdquo;، فإن الصيغة الجديدة الفعلية تحتفظ باللاحقة المعتادة \u0026ldquo;.b32.i2p\u0026rdquo;.\nحالة التنفيذ المقترح 123 (إدخالات netDB الجديدة) حقّق التنفيذ الكامل في الإصدار 0.9.43 (أكتوبر 2019). ظلّت مجموعة ميزات LS2 (الإصدار الثاني من leaseSet) المشفَّرة مستقرة حتى الإصدار 2.10.0 (سبتمبر 2025)، من دون تغييرات كاسرة للتوافق في تنسيق العنونة أو المواصفات التشفيرية.\nالمعالم الرئيسية للتنفيذ: - 0.9.38: دعم floodfill لـ LS2 القياسي مع مفاتيح غير متصلة - 0.9.39: توقيع RedDSA من النوع 11 والتشفير/فك التشفير الأساسي - 0.9.40: دعم كامل لعنونة B32 (Proposal 149) - 0.9.41: مصادقة لكل عميل مستندة إلى X25519 - 0.9.42: جميع ميزات blinding (الإعماء) قيد التشغيل - 0.9.43: تم إعلان اكتمال التنفيذ (أكتوبر 2019)\nالتصميم يتضمن التنسيق الجديد المفتاح العام غير المُعمّى، ونوع التوقيع غير المُعمّى، ونوع التوقيع المُعمّى بالإعماء. يشير اختياريًا إلى متطلبات السر و/أو المفتاح الخاص للروابط الخاصة. يستخدم اللاحقة \u0026ldquo;.b32.i2p\u0026rdquo; الحالية، ولكن بطول أكبر. يتضمن قيمة تحقق (checksum) لاكتشاف الأخطاء. تُعرَّف عناوين leasesets المُشفَّرة بواسطة 56 محرفًا مُرمَّزًا أو أكثر (35 بايتًا مُفكَّك الترميز أو أكثر)، مقارنةً بـ 52 محرفًا (32 بايتًا) لعناوين base 32 التقليدية. المواصفة الإنشاء والترميز قم ببناء اسم مضيف من الشكل {56+ محارف}.b32.i2p (35+ محارف بالنظام الثنائي) كما يلي:\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype المعالجة اللاحقة والمجموع الاختباري:\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; أي بتات غير مستخدمة في نهاية b32 يجب أن تكون 0. لا توجد بتات غير مستخدمة في عنوان قياسي بطول 56 حرفًا (35 بايتًا).\nفك الترميز والتحقق strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key بتات المفتاحين السري والخاص تُستخدم بتّات المفتاح السري والمفتاح الخاص لإبلاغ العملاء والوكلاء وأي شفرة على جانب العميل بأن المفتاح السري و/أو المفتاح الخاص سيكون مطلوبًا لفك تشفير leaseset. قد تطالب بعض التطبيقات المستخدم بتزويد البيانات المطلوبة، أو ترفض محاولات الاتصال إذا كانت البيانات المطلوبة مفقودة.\nتعمل هذه البِتّات كمؤشرات فقط. لا ينبغي مطلقًا تضمين المفتاح السري أو الخاص داخل B32 address نفسه (تمثيل العنوان بصيغة Base32 في I2P)، لأن ذلك قد يعرّض الأمان للخطر.\nتفاصيل التشفير مخطط الإعماء يستخدم مخطط الإعماء RedDSA (مخطط توقيع رقمي) القائم على Ed25519 (منحنى بيضوي وخوارزمية توقيع) وتصميم ZCash (عملة رقمية تركز على الخصوصية)، منتِجًا توقيعات Red25519 (خوارزمية توقيع مبنية على Ed25519) على منحنى Ed25519 باستخدام SHA-512 (دالة تجزئة تشفيرية). يضمن هذا النهج بقاء المفاتيح العامة المُعمّاة ضمن زمرة جزئية ذات رتبة أولية، مما يتجنب المخاوف الأمنية الموجودة في بعض التصاميم البديلة.\nتُدوَّر Blinded keys (مفاتيح تُحجب هويتها لأغراض الخصوصية) يومياً استناداً إلى تاريخ UTC باستخدام الصيغة:\nblinded_key = BLIND(unblinded_key, date, optional_secret) يُحسَب موقع التخزين في جدول التجزئة الموزع (DHT) كما يلي:\nSHA256(type_byte || blinded_public_key) التشفير يستخدم الـ leaseset المُشفّر شفرة دفق ChaCha20 للتشفير، وقد تم اختيارها لأدائها المتفوق على الأجهزة التي تفتقر إلى تسريع عتادي لـ AES. تعتمد المواصفة HKDF لاشتقاق المفاتيح و X25519 لعمليات Diffie-Hellman (تبادل المفاتيح ديفي-هيلمان).\nتتألف الـ leaseSet (مجموعة بيانات تصف أنفاق الدخول الخاصة بوجهة في I2P) المشفّرة من ثلاث طبقات: - الطبقة الخارجية: بيانات وصفية نصية غير مشفّرة - الطبقة الوسطى: مصادقة العميل (طريقتا DH أو PSK) - الطبقة الداخلية: بيانات LS2 الفعلية مع معلومات lease (تصريح نفق دخول)\nطرق المصادقة المصادقة على مستوى العميل تدعم طريقتين:\nمصادقة DH (ديفي-هيلمان): يستخدم تبادل مفاتيح X25519. يقدّم كل عميل مُصرّح له مفتاحه العام إلى الخادم، ويقوم الخادم بتشفير الطبقة الوسطى باستخدام سرّ مشترك مُشتق من ECDH (ديفي-هيلمان القائم على المنحنى الإهليلجي).\nمصادقة PSK (مفتاح مُسبق المشاركة): تستخدم مفاتيح مُسبقة المشاركة مباشرةً للتشفير.\nيشير بت العلم رقم 2 في عنوان B32 (عنوان Base32) إلى ما إذا كانت المصادقة لكل عميل على حدة مطلوبة.\nالتخزين المؤقت مع أن ذلك خارج نطاق هذه المواصفة، يجب على routers والعملاء أن يتذكروا ويخزنوا مؤقتًا تعيين المفتاح العام إلى الوجهة (ويُستحسن تخزينه بصورة دائمة)، والعكس صحيح.\nخدمة التسمية blockfile (تنسيق تخزين مُقسّم إلى كتل)، وهي نظام دفتر العناوين الافتراضي في I2P منذ الإصدار 0.9.8، تُحافظ على عدة دفاتر عناوين مع خريطة مخصّصة للبحث العكسي تتيح عمليات بحث سريعة حسب التجزئة. وتُعد هذه الوظيفة ضرورية لحل leaseset المشفّر عندما لا يكون معروفًا في البداية سوى التجزئة.\nأنواع التواقيع اعتبارًا من إصدار I2P 2.10.0، تم تعريف أنواع التواقيع من 0 إلى 11. يظل ترميز البايت الواحد هو المعيار، مع أن ترميز البايتين متاح لكنه غير مستخدم عمليًا.\nالأنواع الشائعة الاستخدام: - النوع 0 (DSA_SHA1): مهمَل للـrouters، ومدعوم للوجهات - النوع 7 (EdDSA_SHA512_Ed25519): المعيار الحالي لهويات router والوجهات - النوع 11 (RedDSA_SHA512_Ed25519): حصراً لـ LS2 leasesets المشفرة مع دعم الإعماء (blinding)\nملاحظة مهمة: تدعم Ed25519 (type 7) و Red25519 (type 11) الإعماء اللازم لـ leasesets المشفرة. لا يمكن استخدام أنواع التوقيع الأخرى مع هذه الميزة.\nتظل الأنواع 9-10 (GOST algorithms، معايير التشفير الروسية) محجوزة ولكن غير مُنفَّذة. الأنواع 4-6 و8 مُعلَّمة بأنها \u0026ldquo;offline only\u0026rdquo; لمفاتيح التوقيع غير المتصلة.\nملاحظات ميّز بين الأنواع القديمة والجديدة حسب الطول. عناوين b32 القديمة دائمًا تكون {52 chars}.b32.i2p. أما الجديدة فهي {56+ chars}.b32.i2p يتبع ترميز base32 معايير RFC 4648 مع فك ترميز غير حساس لحالة الأحرف، مع تفضيل أن يكون الإخراج بحروف صغيرة قد تتجاوز العناوين 200 حرف عند استخدام أنواع توقيع بمفاتيح عامة أكبر (مثل ECDSA P521 بمفاتيح حجمها 132-بايت) يمكن استخدام الصيغة الجديدة في jump links أي روابط القفز (ويتم تقديمها بواسطة jump servers) إذا رغبت، تمامًا مثل b32 القياسي Blinded keys (مفاتيح مموّهة) تتبدّل يوميًا بناءً على تاريخ UTC لتعزيز الخصوصية هذه الصيغة تختلف عن نهج Tor في الملف rend-spec-v3.txt ضمن الملحق A.2، ما قد يترتب عليه تداعيات أمنية محتملة عند استخدام مفاتيح عامة blinded خارج المنحنى الإهليلجي توافق الإصدارات هذه المواصفة دقيقة لنسخة I2P 0.9.47 (أغسطس 2020) وحتى النسخة 2.10.0 (سبتمبر 2025). لم تحدث أي تغييرات كاسرة للتوافق على تنسيق العنونة B32 (عنوان Base32 في I2P) أو بنية LS2 المشفّرة (إصدار leaseSet الثاني) أو تنفيذات التشفير خلال هذه الفترة. تظل جميع العناوين التي أُنشئت باستخدام 0.9.47 متوافقةً بالكامل مع الإصدارات الحالية.\nالمراجع CRC-32 (فحص التكرار الدوري 32-بت) - CRC-32 (ويكيبيديا) - RFC 3309: المجموع الاختباري لـ Stream Control Transmission Protocol (بروتوكول التحكم في نقل التدفق) مواصفات I2P - مواصفة LeaseSet (مجموعة المسارات في I2P) المشفّر - الاقتراح 123: إدخالات netDB (قاعدة بيانات الشبكة في I2P) الجديدة - الاقتراح 149: B32 من أجل LS2 (الإصدار الثاني من LeaseSet) المشفّر - مواصفة الهياكل المشتركة - التسمية ودفتر العناوين مقارنة Tor - سلسلة نقاش Tor (سياق التصميم) موارد إضافية - مشروع I2P - منتدى I2P - وثائق واجهة برمجة تطبيقات Java ","description":"تنسيق عنوان Base 32 لـ LS2 leasesets المشفرة","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"B32 لـ leaseSets (مجموعات نقاط الدخول للأنفاق في I2P) المشفّرة","url":"/ar/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":"نظرة عامة يتيح BitTorrent عبر I2P مشاركة الملفات المجهولة من خلال tunnels مشفرة باستخدام طبقة البث المباشر في I2P. يتم تحديد جميع المشاركين بواسطة وجهات I2P تشفيرية بدلاً من عناوين IP. يدعم النظام متتبعات HTTP و UDP، وروابط magnet الهجينة، والتشفير الهجين ما بعد الكم.\n1. مكدس البروتوكول Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP تعمل جميع الاتصالات عبر طبقة النقل المشفرة في I2P (NTCP2 أو SSU2). حتى حزم متتبع UDP يتم تغليفها داخل بث I2P. 2. المتتبعات متتبعات HTTP متتبعات .i2p القياسية تستجيب لطلبات HTTP GET مثل:\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 الردود مُشفّرة بصيغة bencoded وتستخدم hashes وجهات I2P للأقران.\nمتتبعات UDP تم توحيد معايير متتبعات UDP في عام 2025 (الاقتراح 160).\nمتتبعات UDP الأساسية - udp://tracker2.postman.i2p/announce - udp://opentracker.simp.i2p/a - http://opentracker.skank.i2p/a - http://opentracker.dg2.i2p/a \u0026mdash;\n3. روابط Magnet magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name روابط Magnet تدعم الأسراب الهجينة عبر I2P والإنترنت العادي عند تكوينها. 4. تطبيقات DHT Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported --- 5. تطبيقات العميل I2PSnark مُجمّع مع جميع أجهزة الـ router دعم tracker عبر HTTP فقط tracker مدمج على http://127.0.0.1:7658/ لا يوجد دعم لـ UDP tracker BiglyBT كامل المميزات مع إضافة I2P يدعم متتبعات HTTP + UDP دعم التورنت الهجين يستخدم واجهة SAM v3.3 Tixati / XD العملاء خفيفو الوزن الأنفاق المعتمدة على SAM تشفير ML-KEM الهجين التجريبي 6. التكوين I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. نموذج الأمان Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) يجب استخدام التورنتات الهجينة (clearnet + I2P) فقط إذا لم تكن إخفاء الهوية أمرًا بالغ الأهمية. 8. الأداء Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal تتراوح السرعات النموذجية بين **30-80 كيلوبايت/ثانية**، حسب الأقران وظروف الشبكة. 9. المشاكل المعروفة التوافق الجزئي لـ DHT بين Java I2P و i2pd تأخير جلب البيانات الوصفية للـ Magnet تحت الحمل الثقيل NTCP1 مُهمَل لكن لا يزال مستخدمًا من قبل الأقران القدامى UDP المحاكى عبر streaming يزيد من زمن الاستجابة 10. خارطة الطريق المستقبلية تعدد الإرسال شبيه بـ QUIC تكامل كامل لـ ML-KEM منطق سرب هجين موحد تحسين مرايا إعادة البذر (reseed mirrors) إعادة محاولات DHT تكيفية المراجع BEP 15 – بروتوكول UDP Tracker اقتراح 160 – UDP Tracker عبر I2P وثائق I2PSnark مواصفات مكتبة Streaming ","description":"نظرة عامة تفصيلية للمواصفات والنظام البيئي لـ BitTorrent داخل شبكة I2P","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"BitTorrent عبر I2P","url":"/ar/docs/applications/bittorrent/"},{"categories":null,"content":" تحذير: يدعم BOB فقط نوع التوقيع القديم DSA-SHA1. توقف Java I2P عن تضمين BOB في 1.7.0 (2022-02)؛ ولا يزال موجودًا فقط في التثبيتات التي بدأت بالإصدار 1.6.1 أو أقدم، وفي بعض بُنى i2pd. يجب على التطبيقات الجديدة استخدام SAM v3 .\nواجهات ربط للغات البرمجة Go – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp ملاحظات البروتوكول KEYS تشير إلى وجهة بصيغة base64 (مفاتيح عامة + خاصة). KEY هو مفتاح عام بصيغة base64. استجابات ERROR تكون على الصيغة ERROR \u0026lt;description\u0026gt;\\n. يشير OK إلى إتمام الأمر؛ تتبع البيانات الاختيارية في السطر نفسه. أسطر DATA تُصدر مخرجات إضافية قبل OK نهائية. أمر help هو الاستثناء الوحيد: قد لا يُرجِع أي شيء للإشارة إلى «لا يوجد أمر بهذا الاسم».\nلافتة الاتصال يستخدم BOB (بروتوكول ضمن I2P) أسطر ASCII منتهية بمحرف نهاية السطر (LF أو CRLF). عند إنشاء الاتصال يرسل:\nBOB \u0026lt;version\u0026gt; OK الإصدار الحالي: 00.00.10. كانت الإصدارات السابقة تستخدم أحرفًا سداسية عشرية كبيرة وترقيمًا غير قياسي.\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds ## الأوامر الأساسية للاطّلاع على التفاصيل الكاملة للأوامر، اتصل باستخدام telnet localhost 2827 ثم نفّذ help.\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK ملخص الميزات المهملة لا يدعم BOB أنواع التواقيع الحديثة، أو LeaseSets المشفّرة (مجموعات عقود الإيجار في I2P)، أو ميزات النقل. تم تجميد API; لن تُضاف أي أوامر جديدة. يجب على التطبيقات التي لا تزال تعتمد على BOB الانتقال إلى SAM v3 في أقرب وقت ممكن. ","description":"واجهة برمجة التطبيقات المهملة لإدارة الوجهات (مهملة)","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – الجسر المفتوح الأساسي","url":"/ar/docs/legacy/bob/"},{"categories":null,"content":"استنساخ ودفع المستودعات داخل I2P يستخدم نفس أوامر Git التي تعرفها بالفعل—عميلك يتصل ببساطة عبر tunnels الخاصة بـ I2P بدلاً من TCP/IP. يشرح هذا الدليل كيفية إعداد حساب وتكوين tunnels والتعامل مع الروابط البطيئة.\nبداية سريعة: الوصول للقراءة فقط يعمل من خلال وكيل HTTP: http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git. اتبع الخطوات أدناه للوصول بصلاحيات القراءة/الكتابة عبر SSH.\n1. إنشاء حساب اختر خدمة Git على I2P وسجّل حسابًا:\nداخل I2P: http://git.idk.i2p المرآة على الإنترنت العادي: https://i2pgit.org قد يتطلب التسجيل موافقة يدوية؛ تحقق من الصفحة الرئيسية للحصول على التعليمات. بمجرد الموافقة، قم بعمل fork أو إنشاء مستودع حتى يكون لديك شيء للاختبار به.\n2. تكوين عميل I2PTunnel (SSH) افتح وحدة تحكم router → I2PTunnel وأضف tunnel من نوع Client جديد. أدخل وجهة الخدمة (Base32 أو Base64). بالنسبة لـ git.idk.i2p ستجد وجهتي HTTP وSSH على الصفحة الرئيسية للمشروع. اختر منفذاً محلياً (على سبيل المثال localhost:7442). فعّل التشغيل التلقائي إذا كنت تخطط لاستخدام tunnel بشكل متكرر. ستؤكد واجهة المستخدم النفق الجديد وتعرض حالته. عندما يكون قيد التشغيل، يمكن لعملاء SSH الاتصال بـ 127.0.0.1 على المنفذ المختار.\n3. الاستنساخ عبر SSH استخدم منفذ النفق مع GIT_SSH_COMMAND أو مقطع تكوين SSH:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git إذا فشلت المحاولة الأولى (قد تكون الأنفاق بطيئة)، جرب استنساخًا سطحيًا:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow قم بتكوين Git لجلب جميع الفروع:\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin نصائح الأداء أضف نفقًا أو اثنين احتياطيين في محرر الأنفاق لتحسين المرونة. للاختبار أو المستودعات منخفضة المخاطر يمكنك تقليل طول النفق إلى قفزة واحدة، ولكن كن على دراية بالمقايضة المتعلقة بعدم الكشف عن الهوية. احتفظ بـ GIT_SSH_COMMAND في بيئتك أو أضف إدخالاً إلى ~/.ssh/config: Host git.i2p HostName 127.0.0.1 Port 7442 User git ثم قم بالاستنساخ باستخدام git clone git@git.i2p:namespace/project.git.\n4. اقتراحات سير العمل اعتمد سير عمل التفريع والتشعيب الشائع على GitLab/GitHub:\nقم بتعيين مستودع upstream بعيد: git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p حافظ على تزامن master الخاص بك: git pull upstream master أنشئ فروعاً للميزات من أجل التغييرات: git checkout -b feature/new-thing ادفع الفروع إلى نسختك المنسوخة: git push origin feature/new-thing قدم طلب دمج، ثم قم بعمل fast-forward لفرع master في نسختك المنسوخة من upstream. 5. تذكيرات الخصوصية يخزن Git طوابع الوقت للـ commit في المنطقة الزمنية المحلية الخاصة بك. لفرض طوابع الوقت بتوقيت UTC: git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; استخدم git utccommit بدلاً من git commit عندما تكون الخصوصية مهمة.\nتجنب تضمين عناوين URL أو عناوين IP من الإنترنت العادي (clearnet) في رسائل الالتزام أو البيانات الوصفية للمستودع إذا كانت عدم الكشف عن الهوية مصدر قلق. 6. استكشاف الأخطاء وإصلاحها Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. للسيناريوهات المتقدمة (نسخ المستودعات الخارجية، توزيع الحزم)، راجع الأدلة المصاحبة: [سير عمل حزم Git](/docs/applications/git-bundle/) و [استضافة GitLab عبر I2P](/docs/guides/gitlab/). ","description":"توصيل عملاء Git بالخدمات المستضافة على I2P مثل i2pgit.org","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"Git عبر I2P","url":"/ar/docs/applications/git/"},{"categories":null,"content":"نظرة عامة توجد اليوم عدة شبكات رئيسية للخصوصية وإخفاء الهوية، ولكل منها أهداف تصميمية ونماذج تهديد مختلفة. بينما تساهم Tor وLokinet وGNUnet وFreenet جميعها بمقاربات قيّمة للاتصالات التي تحفظ الخصوصية، يتميز I2P بكونه الشبكة الوحيدة الجاهزة للإنتاج، والمُبدلة بالحزم (packet-switched) المُحسّنة بالكامل للخدمات المخفية داخل الشبكة وتطبيقات الند للند.\nيلخص الجدول أدناه الاختلافات المعمارية والتشغيلية الرئيسية عبر هذه الشبكات اعتبارًا من عام 2025.\nمقارنة شبكات الخصوصية (2025) Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) --- لماذا يتصدر I2P في التصميم الذي يعطي الأولوية للخصوصية 1. Packet Switching \u0026gt; Circuit Switching نموذج Tor القائم على تبديل الدوائر يربط حركة البيانات بمسارات ثابتة من ثلاث قفزات—فعال للتصفح، لكنه هش للخدمات الداخلية طويلة الأمد. أنفاق I2P المبدلة بالحزم ترسل الرسائل عبر مسارات متزامنة متعددة، وتوجه تلقائياً حول الازدحام أو الفشل لتحقيق وقت تشغيل أفضل وتوزيع أمثل للحمل.\n2. Unidirectional Tunnels يفصل I2P حركة البيانات الواردة والصادرة. وهذا يعني أن كل مشارك يرى فقط نصف تدفق الاتصال، مما يجعل هجمات الارتباط الزمني أصعب بكثير. بينما تستخدم Tor وLokinet وغيرها دوائر ثنائية الاتجاه حيث تشترك الطلبات والردود في نفس المسار—أبسط، ولكن أكثر قابلية للتتبع.\n3. Fully Distributed netDB تعتمد شبكة Tor على تسع سلطات دليل (directory authorities) تحدد بنية الشبكة. بينما تستخدم I2P Kademlia DHT ذاتية التنظيم تديرها floodfill routers متناوبة، مما يلغي أي نقاط تحكم مركزية أو خوادم تنسيق.\n1. تبديل الحزم \u0026gt; تبديل الدوائر يوسّع I2P تقنية التوجيه البصلي (onion routing) باستخدام garlic routing (التوجيه الثومي)، حيث يجمع عدة رسائل مشفرة في حاوية واحدة. يقلل هذا من تسرب البيانات الوصفية والحمل الزائد على النطاق الترددي بينما يحسّن الكفاءة لرسائل الإقرار والبيانات والتحكم.\n2. Tunnels أحادية الاتجاه كل router في I2P يقوم بالتوجيه للآخرين. لا توجد مشغلو ترحيل مخصصون أو عقد ذات امتيازات خاصة - يحدد النطاق الترددي والموثوقية تلقائيًا مقدار التوجيه الذي تساهم به العقدة. يبني هذا النهج الديمقراطي المرونة ويتوسع بشكل طبيعي مع نمو الشبكة.\n3. netDB موزعة بالكامل يوفر مسار I2P ذو 12 قفزة ذهاباً وإياباً (6 قفزات واردة + 6 قفزات صادرة) عدم ربط أقوى من دوائر الخدمة المخفية في Tor ذات 6 قفزات. ولأن كلا الطرفين داخليان، تتجنب الاتصالات اختناق نقاط الخروج تماماً، مما يوفر استضافة داخلية أسرع وتكامل أصلي للتطبيقات (I2PSnark، I2PTunnel، I2PBote).\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication --- When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet --- Summary بنية I2P تضع الخصوصية في المقام الأول بشكل فريد—لا خوادم دليلية، لا اعتماد على blockchain، لا ثقة مركزية. إن مزيجها من الأنفاق أحادية الاتجاه، التوجيه المبدل للحزم، تجميع رسائل garlic، والاكتشاف الموزع للنظراء يجعلها النظام الأكثر تقدمًا تقنيًا للاستضافة المجهولة والاتصال من نظير إلى نظير اليوم.\nI2P ليس \u0026ldquo;بديلاً لـ Tor.\u0026rdquo; إنه فئة مختلفة من الشبكات—مُصمم لما يحدث داخل شبكة الخصوصية، وليس خارجها.\n","description":"مقارنة تقنية وفلسفية حديثة تُبرز مزايا التصميم الفريدة لـ I2P","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P مقارنة بشبكات الخصوصية الأخرى","url":"/ar/docs/overview/comparison/"},{"categories":null,"content":"مقدمة I2P هي طبقة شبكة مجهولة الهوية قابلة للتوسع، ذاتية التنظيم، ومرنة تعتمد على تبديل الحزم، والتي يمكن أن يعمل عليها أي عدد من التطبيقات المختلفة التي تهتم بإخفاء الهوية أو الأمان. يمكن لكل من هذه التطبيقات إجراء مقايضاتها الخاصة بين إخفاء الهوية والكمون والإنتاجية دون القلق بشأن التنفيذ الصحيح لشبكة mixnet ذات مسار حر، مما يسمح لها بدمج نشاطها مع مجموعة إخفاء الهوية الأكبر من المستخدمين الذين يعملون بالفعل على I2P.\nالتطبيقات المتاحة بالفعل توفر مجموعة كاملة من الأنشطة النموذجية للإنترنت — تصفح الويب المجهول، استضافة المواقع، الدردشة، مشاركة الملفات، البريد الإلكتروني، التدوين، ونشر المحتوى، بالإضافة إلى العديد من التطبيقات الأخرى قيد التطوير.\nتصفح الويب: باستخدام أي متصفح موجود يدعم البروكسي (proxy) المحادثة: IRC وبروتوكولات أخرى مشاركة الملفات: I2PSnark وتطبيقات أخرى البريد الإلكتروني: Susimail وتطبيقات أخرى المدونات: باستخدام أي خادم ويب محلي، أو الإضافات المتاحة على عكس المواقع المستضافة ضمن شبكات توزيع المحتوى مثل Freenet أو GNUnet ، فإن الخدمات المستضافة على I2P تفاعلية بالكامل — فهناك محركات بحث تقليدية على نمط الويب، ولوحات إعلانات، ومدونات يمكنك التعليق عليها، ومواقع تعتمد على قواعد البيانات، وجسور للاستعلام من الأنظمة الثابتة مثل Freenet دون الحاجة إلى تثبيتها محلياً.\nمع جميع هذه التطبيقات المُمكّنة لإخفاء الهوية، يعمل I2P كـ وسيط موجه للرسائل — تحدد التطبيقات البيانات المراد إرسالها إلى معرّف تشفيري (\u0026ldquo;destination\u0026rdquo;)، ويضمن I2P وصولها بشكل آمن ومجهول الهوية. يتضمن I2P أيضًا مكتبة بث بسيطة للسماح لرسائل I2P المجهولة ذات أفضل جهد بالنقل كتدفقات موثوقة ومرتبة، مما يوفر التحكم في الازدحام المستند إلى TCP والمُحسّن لحاصل ضرب عرض النطاق الترددي والتأخير العالي للشبكة.\nبينما تم تطوير بروكسيات SOCKS بسيطة لربط التطبيقات الموجودة، فإن قيمتها محدودة لأن معظم التطبيقات تسرب معلومات حساسة في سياق مجهول الهوية. النهج الأكثر أماناً هو مراجعة وتكييف التطبيق لاستخدام واجهات برمجة التطبيقات (APIs) الخاصة بـ I2P مباشرة.\nI2P ليس مشروعًا بحثيًا — سواء أكاديميًا أو تجاريًا أو حكوميًا — بل هو جهد هندسي يهدف إلى توفير إخفاء الهوية القابل للاستخدام. وهو قيد التطوير المستمر منذ أوائل عام 2003 من قبل مجموعة موزعة من المساهمين حول العالم. جميع أعمال I2P مفتوحة المصدر على الموقع الرسمي ، وتُصدر بشكل أساسي في المجال العام، مع بعض المكونات تحت تراخيص BSD المتساهلة. تتوفر العديد من تطبيقات العملاء المرخصة بموجب GPL، مثل I2PTunnel وSusimail وI2PSnark . يأتي التمويل فقط من تبرعات المستخدمين.\nالتشغيل Overview يميز I2P بوضوح بين أجهزة التوجيه (routers - العُقد المشاركة في الشبكة) والوجهات (destinations - نقاط النهاية المجهولة للتطبيقات). تشغيل I2P نفسه ليس سريًا؛ ما يتم إخفاؤه هو ماذا يفعل المستخدم وأي router تستخدمه وجهاته. عادةً ما يشغل المستخدمون النهائيون عدة وجهات (على سبيل المثال، واحدة لتصفح الويب، وأخرى للاستضافة، وأخرى لـ IRC).\nمفهوم أساسي في I2P هو tunnel (النفق) — وهو مسار مشفر أحادي الاتجاه عبر سلسلة من أجهزة الـ router. كل router يفك تشفير طبقة واحدة فقط ويعرف فقط القفزة التالية. تنتهي صلاحية الـ tunnels كل 10 دقائق ويجب إعادة بنائها.\nالشكل 1: يوجد نوعان من الأنفاق — الواردة والصادرة.\nOutbound tunnels ترسل الرسائل بعيداً عن المُنشئ. Inbound tunnels تُعيد الرسائل إلى المُنشئ. يُمكّن الجمع بين هذه الأنفاق الاتصال ثنائي الاتجاه. على سبيل المثال، تستخدم \u0026ldquo;أليس\u0026rdquo; نفقاً صادراً للإرسال إلى نفق \u0026ldquo;بوب\u0026rdquo; الوارد. تقوم أليس بتشفير رسالتها مع تعليمات التوجيه إلى بوابة بوب الواردة.\nمفهوم أساسي آخر هو قاعدة بيانات الشبكة أو netDb، والتي توزع البيانات الوصفية حول routers والوجهات:\nRouterInfo: يحتوي على معلومات الاتصال بالـ router والمفاتيح الخاصة به. LeaseSet: يحتوي على المعلومات اللازمة للاتصال بوجهة معينة (بوابات الأنفاق، أوقات الانتهاء، مفاتيح التشفير). تنشر أجهزة التوجيه معلومات RouterInfo الخاصة بها مباشرة إلى netDb؛ بينما يتم إرسال LeaseSets عبر الأنفاق الصادرة للحفاظ على عدم الكشف عن الهوية.\nلبناء الأنفاق، تستعلم Alice عن netDb للحصول على إدخالات RouterInfo لاختيار النظراء، وترسل رسائل بناء tunnel مشفرة خطوة بخطوة حتى يكتمل النفق.\nالشكل 2: يتم استخدام معلومات router لبناء الأنفاق (tunnels).\nلإرسال البيانات إلى بوب، تبحث أليس عن LeaseSet الخاص ببوب وتستخدم أحد الأنفاق الصادرة الخاصة بها لتوجيه البيانات من خلال بوابة النفق الوارد الخاص ببوب.\nالشكل 3: تربط LeaseSets بين الأنفاق الصادرة والواردة.\nنظرًا لأن I2P يعتمد على الرسائل، فإنه يضيف تشفير garlic encryption من طرف إلى طرف لحماية الرسائل حتى من نقطة النهاية الصادرة أو البوابة الواردة. تحتوي رسالة garlic على عدة \u0026ldquo;فصوص\u0026rdquo; (رسائل) مشفرة لإخفاء البيانات الوصفية وتحسين عدم الكشف عن الهوية.\nيمكن للتطبيقات إما استخدام واجهة الرسائل مباشرة أو الاعتماد على مكتبة البث للاتصالات الموثوقة.\nTunnels تستخدم الأنفاق الواردة والصادرة التشفير الطبقي، لكنها تختلف في البناء:\nفي الأنفاق الواردة (inbound tunnels)، يقوم المُنشئ (نقطة النهاية) بفك تشفير جميع الطبقات. في الأنفاق الصادرة (outbound tunnels)، يقوم المُنشئ (البوابة) بفك تشفير الطبقات مسبقاً لضمان الوضوح في نقطة النهاية. يقوم I2P بتصنيف الأقران عبر مقاييس غير مباشرة مثل زمن الاستجابة والموثوقية دون فحص مباشر. بناءً على هذه التصنيفات، يتم تجميع الأقران ديناميكيًا في أربع مستويات:\nسريع وعالي السعة عالي السعة غير فاشل فاشل يفضل اختيار نظراء النفق عادةً النظراء ذوي السعة العالية، المختارين عشوائياً لتحقيق التوازن بين عدم الكشف عن الهوية والأداء، مع استراتيجيات ترتيب إضافية قائمة على XOR للتخفيف من هجمات السلف وحصاد netDb.\nللحصول على تفاصيل أعمق، راجع مواصفات الأنفاق .\nنظرة عامة الـ routers المشاركة في جدول التجزئة الموزع (DHT) الخاص بـ floodfill تقوم بتخزين والرد على استعلامات LeaseSet. يستخدم DHT نسخة معدلة من Kademlia . يتم اختيار routers الـ floodfill تلقائيًا إذا كانت لديها سعة واستقرار كافيين، أو يمكن تكوينها يدويًا.\nRouterInfo: يصف قدرات الموجه (router) ووسائل النقل الخاصة به. LeaseSet: يصف أنفاق الوجهة ومفاتيح التشفير الخاصة بها. جميع البيانات في netDb موقّعة من قبل الناشر ومؤرشفة زمنياً لمنع هجمات إعادة التشغيل أو الإدخالات القديمة. يتم الحفاظ على مزامنة التوقيت من خلال SNTP والكشف عن الانحراف في طبقة النقل.\nAdditional concepts LeaseSets غير منشورة ومشفرة:\nيمكن للوجهة أن تظل خاصة من خلال عدم نشر LeaseSet الخاص بها، ومشاركته فقط مع الأطراف الموثوقة. يتطلب الوصول مفتاح فك التشفير المناسب.\nBootstrapping (إعادة البذر):\nللانضمام إلى الشبكة، يقوم router جديد بجلب ملفات RouterInfo الموقّعة من خوادم إعادة البذر الموثوقة عبر HTTPS.\nقابلية التوسع في البحث:\nيستخدم I2P عمليات بحث تكرارية، وليست تعاودية، لتحسين قابلية التوسع والأمان في DHT.\nالأنفاق تستخدم اتصالات I2P الحديثة وسيلتي نقل مشفرتين بالكامل:\nNTCP2 : بروتوكول مشفر قائم على TCP SSU2 : بروتوكول مشفر قائم على UDP كلاهما مبني على إطار بروتوكول Noise الحديث، مما يوفر مصادقة قوية ومقاومة لبصمات حركة المرور. لقد حلا محل بروتوكولات NTCP وSSU القديمة (التي تم إيقافها بالكامل منذ عام 2023).\nNTCP2 يوفر بثًا مشفرًا وفعالًا عبر TCP.\nSSU2 يوفر موثوقية قائمة على UDP، واجتياز NAT، وثقب اختياري. SSU2 مشابه من الناحية المفاهيمية لـ WireGuard أو QUIC، موازناً بين الموثوقية وإخفاء الهوية.\nقد تدعم أجهزة الـ router كلاً من IPv4 و IPv6، وتنشر عناوين النقل والتكاليف الخاصة بها في الـ netDb. يتم اختيار نقل الاتصال ديناميكيًا بواسطة نظام مزايدة يُحسّن الأداء بناءً على الظروف والروابط الموجودة.\nقاعدة بيانات الشبكة (netDb) يستخدم I2P التشفير الطبقي لجميع المكونات: النقل، الأنفاق (tunnels)، رسائل garlic، وقاعدة بيانات الشبكة (netDb).\nالأوليات الحالية تشمل:\nX25519 لتبادل المفاتيح EdDSA (Ed25519) للتوقيعات ChaCha20-Poly1305 للتشفير المصادق عليه SHA-256 للتجزئة AES256 لتشفير طبقة tunnel الخوارزميات القديمة (ElGamal, DSA-SHA1, ECDSA) تبقى للتوافق مع الإصدارات السابقة.\nيقدم I2P حاليًا مخططات تشفير هجينة ما بعد الكم (PQ) تجمع بين X25519 و ML-KEM لمقاومة هجمات \u0026ldquo;الحصاد الآن، فك التشفير لاحقًا\u0026rdquo;.\nGarlic Messages رسائل الثوم (Garlic messages) تمتد من توجيه البصل (onion routing) من خلال تجميع عدة \u0026ldquo;فصوص\u0026rdquo; مشفرة مع تعليمات تسليم مستقلة. هذه تسمح بمرونة توجيه على مستوى الرسالة وحشو موحد لحركة المرور.\nSession Tags يتم دعم نظامين تشفيريين للتشفير من طرف إلى طرف:\nElGamal/AES+SessionTags (قديم):\nيستخدم علامات الجلسة المُسلّمة مسبقاً كقيم nonce بحجم 32 بايت. الآن مُهمل بسبب عدم الكفاءة.\nECIES-X25519-AEAD-Ratchet (الحالي):\nيستخدم ChaCha20-Poly1305 ومولدات أرقام عشوائية شبه عشوائية (PRNGs) متزامنة قائمة على HKDF لإنشاء مفاتيح جلسة مؤقتة وعلامات بحجم 8 بايت بشكل ديناميكي، مما يقلل من استهلاك المعالج والذاكرة وعرض النطاق الترددي مع الحفاظ على السرية الأمامية.\nFuture of the Protocol تركز مجالات البحث الرئيسية على الحفاظ على الأمان ضد الخصوم على مستوى الدولة وإدخال حماية ما بعد الكم. تم استبدال مفهومين تصميميين مبكرين — المسارات المقيدة والكمون المتغير — بتطورات حديثة.\nRestricted Route Operation كانت مفاهيم التوجيه المقيد الأصلية تهدف إلى إخفاء عناوين IP. وقد تم تخفيف هذه الحاجة إلى حد كبير من خلال:\nUPnP للتوجيه التلقائي للمنافذ اجتياز قوي لـ NAT في SSU2 دعم IPv6 موجهو الاتصال التعاونيون وثقب NAT اتصال اختياري عبر الشبكة الفوقية (مثل Yggdrasil) وبالتالي، يحقق I2P الحديث نفس الأهداف بشكل أكثر عملية دون الحاجة إلى توجيه معقد ومقيد.\nSimilar Systems يدمج I2P مفاهيم من البرمجيات الوسيطة الموجهة للرسائل (message-oriented middleware)، وجداول التجزئة الموزعة (DHTs)، وشبكات المزج (mixnets). يكمن ابتكاره في دمج هذه العناصر في منصة إخفاء هوية قابلة للاستخدام وذاتية التنظيم.\nبروتوكولات النقل الموقع الإلكتروني Tor و I2P يتشاركان في الأهداف لكن يختلفان من الناحية المعمارية:\nTor: يعتمد على تبديل الدوائر؛ يعتمد على سلطات دليل موثوقة. (~10k relays) I2P: يعتمد على تبديل الحزم؛ شبكة موزعة بالكامل مدفوعة بـ DHT (جدول التجزئة الموزع). (~50k routers) أنفاق I2P أحادية الاتجاه تكشف بيانات وصفية أقل وتسمح بمسارات توجيه مرنة، بينما يركز Tor على الوصول المجهول للإنترنت (outproxying). بدلاً من ذلك، يدعم I2P الاستضافة المجهولة داخل الشبكة.\nالتشفير الموقع الإلكتروني Freenet تركز على نشر واسترجاع الملفات بشكل مجهول ودائم. بينما I2P، على العكس، توفر طبقة اتصالات فورية للاستخدام التفاعلي (الويب، الدردشة، التورنت). معًا، يكمل النظامان بعضهما البعض — Freenet توفر تخزينًا مقاومًا للرقابة؛ I2P توفر إخفاء هوية النقل.\nOther Networks Lokinet: شبكة تراكب قائمة على IP تستخدم عقد خدمة محفزة. Nym: شبكة mixnet من الجيل التالي تركز على حماية البيانات الوصفية مع حركة مرور تغطية بزمن انتقال أعلى. Appendix A: Application Layer I2P نفسه يتعامل فقط مع نقل الرسائل. يتم تنفيذ وظائف طبقة التطبيق خارجياً من خلال واجهات برمجة التطبيقات والمكتبات.\nStreaming Library تعمل مكتبة البث (streaming library) كنظير TCP في I2P، مع بروتوكول نافذة منزلقة والتحكم في الازدحام مُعَدّل للنقل المجهول عالي زمن الاستجابة.\nيمكن لأنماط طلب/استجابة HTTP النموذجية أن تكتمل غالبًا في رحلة ذهاب وإياب واحدة بفضل تحسينات تجميع الرسائل.\nNaming Library and Address Book طور بواسطة: mihi، Ragnarok راجع صفحة التسمية ودفتر العناوين .\nنظام التسمية في I2P محلي ولامركزي، مما يتجنب الأسماء العالمية على نمط DNS. يحتفظ كل router بتعيين محلي للأسماء المقروءة بشريًا إلى الوجهات. يمكن مشاركة أو استيراد دفاتر العناوين القائمة على شبكة الثقة (web-of-trust) الاختيارية من الأقران الموثوق بهم.\nيتجنب هذا النهج السلطات المركزية ويتفادى نقاط الضعف المتعلقة بهجمات Sybil الموجودة في أنظمة التسمية العالمية أو القائمة على التصويت.\nتشغيل المسار المقيد طور بواسطة: mihi\nI2PTunnel هو واجهة طبقة العميل الرئيسية التي تتيح الوصول المجهول عبر بروكسي TCP. وهو يدعم:\nأنفاق العميل (صادرة إلى وجهات I2P) عميل HTTP (eepproxy) لنطاقات \u0026ldquo;.i2p\u0026rdquo; أنفاق الخادم (واردة من I2P إلى خدمة محلية) أنفاق خادم HTTP (وكيل آمن لخدمات الويب) الوصول إلى الإنترنت العادي (outproxying) اختياري، ويتم تنفيذه عبر أنفاق \u0026ldquo;خادم\u0026rdquo; يديرها متطوعون.\nI2PSnark تم تطويره بواسطة: jrandom وآخرون — منقول من Snark مُضمّن مع I2P، I2PSnark هو عميل BitTorrent مجهول متعدد التورنت مع دعم DHT وUDP، يمكن الوصول إليه عبر واجهة ويب.\nتور طُوِّر بواسطة: postman، susi23، mastiejaner\nI2Pmail يوفر البريد الإلكتروني المجهول من خلال اتصالات I2PTunnel. Susimail هو عميل قائم على الويب مُصمم خصيصًا لمنع تسرب المعلومات الشائع في عملاء البريد الإلكتروني التقليدية. خدمة mail.i2p تتميز بفلترة الفيروسات، وحصص hashcash ، وفصل outproxy لحماية إضافية.\n","description":"مقدمة تقنية لبنية I2P وآلية عملها","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P: إطار عمل قابل للتوسع للاتصال المجهول","url":"/ar/docs/overview/tech-intro/"},{"categories":null,"content":"توثيق واجهة برمجة التطبيقات I2PControl I2PControl هو واجهة برمجية JSON-RPC 2.0 مدمجة مع router الخاص بـ I2P (منذ الإصدار 0.9.39). يتيح المراقبة والتحكم المصادق عليهما في الـ router عبر طلبات JSON منظمة.\nكلمة المرور الافتراضية: itoopie — هذه هي الإعدادات الافتراضية من المصنع ويجب تغييرها فوراً لأسباب أمنية.\n1. نظرة عامة والوصول Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior في حالة Java I2P، يجب عليك الذهاب إلى **Router Console ← WebApps ← I2PControl** وتفعيله (ضبطه للبدء تلقائيًا). بمجرد التفعيل، تتطلب جميع الطرق أن تقوم أولاً بالمصادقة واستلام رمز الجلسة (session token). 2. تنسيق JSON-RPC جميع الطلبات تتبع بنية JSON-RPC 2.0:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } تتضمن الاستجابة الناجحة حقل result؛ في حالة الفشل، يتم إرجاع كائن error:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } أو\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. تدفق المصادقة الطلب (المصادقة) curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ استجابة ناجحة { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } يجب عليك تضمين هذا Token في جميع الطلبات اللاحقة في params.\n4. الطرق ونقاط النهاية 4.1 معلومات الموجه (RouterInfo) يجلب البيانات القياسية الرئيسية حول الموجه (router).\nمثال على الطلب\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ حقول الاستجابة (result) وفقًا للوثائق الرسمية (GetI2P): - i2p.router.status (String) — حالة قابلة للقراءة البشرية - i2p.router.uptime (long) — بالميلي ثانية (أو نص لإصدارات i2pd الأقدم) :contentReference[oaicite:0]{index=0} - i2p.router.version (String) — نص الإصدار :contentReference[oaicite:1]{index=1} - i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — عرض النطاق الوارد بوحدة B/s :contentReference[oaicite:2]{index=2} - i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — عرض النطاق الصادر بوحدة B/s :contentReference[oaicite:3]{index=3} - i2p.router.net.status (long) — رمز الحالة الرقمي (انظر القائمة أدناه) :contentReference[oaicite:4]{index=4} - i2p.router.net.tunnels.participating (long) — عدد الأنفاق المشاركة :contentReference[oaicite:5]{index=5} - i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — إحصائيات الأقران في netDb :contentReference[oaicite:6]{index=6} - i2p.router.netdb.isreseeding (boolean) — ما إذا كانت عملية إعادة البذر نشطة :contentReference[oaicite:7]{index=7} - i2p.router.netdb.knownpeers (long) — إجمالي الأقران المعروفين :contentReference[oaicite:8]{index=8}\nتعداد رمز الحالة (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET --- 4.2 GetRate يُستخدم لجلب مقاييس المعدل (مثل عرض النطاق الترددي، نجاح tunnel) خلال نافذة زمنية محددة.\nمثال على الطلب\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ نموذج الاستجابة\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 مدير الموجّه (RouterManager) تنفيذ الإجراءات الإدارية.\nالمعاملات / الطرق المسموح بها - Restart، RestartGraceful - Shutdown، ShutdownGraceful - Reseed، FindUpdates، Update :contentReference[oaicite:10]{index=10}\nمثال على الطلب\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ استجابة ناجحة\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 إعدادات الشبكة الحصول على أو تعيين معاملات تكوين الشبكة (المنافذ، upnp، مشاركة النطاق الترددي، إلخ.)\nمثال على الطلب (الحصول على القيم الحالية)\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ نموذج الاستجابة\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } ملاحظة: إصدارات i2pd الأقدم من 2.41 قد تُرجع أنواع رقمية بدلاً من نصوص — يجب على العملاء التعامل مع كلا النوعين. :contentReference[oaicite:11]{index=11}\n4.5 الإعدادات المتقدمة يسمح بالتحكم في معاملات الراوتر الداخلية.\nمثال على الطلب\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ مثال على الاستجابة\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. رموز الأخطاء بالإضافة إلى أخطاء JSON-RPC القياسية (-32700، -32600، إلخ)، يُعرّف I2PControl:\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported --- 6. الاستخدام وأفضل الممارسات قم دائمًا بتضمين معامل Token (باستثناء عند المصادقة). قم بتغيير كلمة المرور الافتراضية (itoopie) عند الاستخدام الأول. بالنسبة لـ Java I2P، تأكد من تمكين تطبيق I2PControl عبر WebApps. كن مستعدًا لاختلافات طفيفة: قد تكون بعض الحقول أرقامًا أو نصوصًا، حسب إصدار I2P. قم بتغليف سلاسل الحالة الطويلة للحصول على مخرجات ملائمة للعرض. ","description":"واجهة برمجة تطبيقات (API) لإدارة الموجه (router) عن بُعد عبر تطبيق الويب I2PControl","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/ar/docs/api/i2pcontrol/"},{"categories":null,"content":"نظرة عامة I2PTunnel هو مكون أساسي في I2P للتفاعل مع شبكة I2P وتوفير الخدمات عليها. يمكّن تطبيقات البث الإعلامي والتطبيقات القائمة على TCP من العمل بشكل مجهول من خلال تجريد الأنفاق (tunnel abstraction). يمكن تحديد وجهة النفق عن طريق اسم المضيف ، أو Base32 ، أو مفتاح الوجهة الكامل.\nكل tunnel مُنشأ يستمع محلياً (مثل localhost:port) ويتصل داخلياً بوجهات I2P. لاستضافة خدمة، أنشئ tunnel يشير إلى عنوان IP والمنفذ المطلوبين. يتم توليد مفتاح وجهة I2P مقابل، مما يسمح للخدمة بأن تصبح قابلة للوصول عالمياً ضمن شبكة I2P. واجهة الويب الخاصة بـ I2PTunnel متاحة على I2P Router Tunnel Manager .\nالخدمات الافتراضية نفق الخادم I2P Webserver – tunnel إلى خادم ويب Jetty على localhost:7658 لاستضافة سهلة على I2P. Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot أنفاق العميل I2P HTTP Proxy – localhost:4444 – يُستخدم لتصفح I2P والإنترنت من خلال الوكلاء الخارجيين (outproxies). I2P HTTPS Proxy – localhost:4445 – النسخة الآمنة من وكيل HTTP. Irc2P – localhost:6668 – نفق شبكة IRC المجهول الافتراضي. Git SSH (gitssh.idk.i2p) – localhost:7670 – نفق العميل للوصول إلى المستودعات عبر SSH. Postman SMTP – localhost:7659 – نفق العميل للبريد الصادر. Postman POP3 – localhost:7660 – نفق العميل للبريد الوارد. ملاحظة: فقط خادم الويب I2P هو نفق خادم افتراضي؛ جميع الأنفاق الأخرى هي أنفاق عميل تتصل بخدمات I2P خارجية.\nالإعدادات يتم توثيق مواصفات إعداد I2PTunnel في /spec/configuration .\nأوضاع العميل قياسي يفتح منفذ TCP محلي يتصل بخدمة على وجهة I2P. يدعم إدخالات وجهات متعددة مفصولة بفواصل لتحقيق التكرار والموثوقية.\nHTTP نفق بروكسي لطلبات HTTP/HTTPS. يدعم الـ outproxies المحلية والبعيدة، إزالة الرؤوس، التخزين المؤقت، المصادقة، والضغط الشفاف.\nحماية الخصوصية: - يزيل الترويسات: Accept-*, Referer, Via, From - يستبدل ترويسات المضيف بوجهات Base32 - يفرض إزالة hop-by-hop المتوافقة مع RFC - يضيف دعمًا لفك الضغط الشفاف - يوفر صفحات أخطاء داخلية واستجابات محلية\nسلوك الضغط: - يمكن للطلبات استخدام رأس مخصص X-Accept-Encoding: x-i2p-gzip - الاستجابات مع Content-Encoding: x-i2p-gzip يتم فك ضغطها تلقائياً - يتم تقييم الضغط حسب نوع MIME وطول الاستجابة لتحقيق الكفاءة\nالاستمرارية (جديد منذ الإصدار 2.5.0): يتم الآن دعم HTTP Keepalive والاتصالات المستمرة للخدمات المستضافة على I2P من خلال مدير الخدمات المخفية. هذا يقلل من زمن الاستجابة والحمل الزائد للاتصال ولكنه لا يتيح بعد المقابس (sockets) المستمرة المتوافقة تمامًا مع RFC 2616 عبر جميع القفزات.\nPipelining: يبقى غير مدعوم وغير ضروري؛ المتصفحات الحديثة قامت بإيقافه.\nسلوك User-Agent: - Outproxy: يستخدم User-Agent حالي من Firefox ESR. - داخلي: MYOB/6.66 (AN/ON) للحفاظ على اتساق عدم الكشف عن الهوية.\nعميل IRC يتصل بخوادم IRC المبنية على I2P. يسمح بمجموعة فرعية آمنة من الأوامر مع تصفية المعرفات للحفاظ على الخصوصية.\nSOCKS 4/4a/5 يوفر إمكانية بروكسي SOCKS لاتصالات TCP. يبقى UDP غير مُطبَّق في Java I2P (فقط في i2pd).\nاتصال ينفذ نفق HTTP CONNECT لاتصالات SSL/TLS.\nStreamr يُمكّن البث بنمط UDP عبر التغليف القائم على TCP. يدعم بث الوسائط عند إقرانه مع نفق خادم Streamr المقابل.\nأوضاع الخادم خادم قياسي ينشئ وجهة TCP مرتبطة بعنوان IP محلي:منفذ.\nخادم HTTP ينشئ وجهة تتفاعل مع خادم ويب محلي. يدعم الضغط (x-i2p-gzip)، وإزالة الرؤوس، والحماية من هجمات DDoS. يستفيد الآن من دعم الاتصال المستمر (v2.5.0+) وتحسين تجميع الخيوط (v2.7.0–2.9.0).\nHTTP ثنائي الاتجاه مُهمَل – لا يزال يعمل ولكن لا يُنصح باستخدامه. يعمل كخادم وعميل HTTP في نفس الوقت دون استخدام outproxying. يُستخدم بشكل أساسي لاختبارات الحلقة المرجعية التشخيصية.\nخادم IRC ينشئ وجهة مُصفاة لخدمات IRC، حيث يمرر مفاتيح وجهة العميل كأسماء مضيفين.\nخادم Streamr يتزاوج مع نفق عميل Streamr للتعامل مع تدفقات البيانات بنمط UDP عبر I2P.\nالميزات الجديدة (2.4.0–2.10.0) Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. --- ميزات الأمان إزالة الترويسات للحفاظ على عدم الكشف عن الهوية (Accept, Referer, From, Via) عشوائية User-Agent حسب in/outproxy تقييد معدل POST و الحماية من Slowloris تقييد الاتصالات في أنظمة البث الفرعية معالجة ازدحام الشبكة على مستوى tunnel عزل NetDB لمنع التسريبات بين التطبيقات التفاصيل التقنية حجم مفتاح الوجهة الافتراضي: 516 بايت (قد يتجاوز ذلك لشهادات LS2 الموسعة) عناوين Base32: {52–56+ chars}.b32.i2p أنفاق الخادم تظل متوافقة مع كل من Java I2P و i2pd ميزة متوقفة: httpbidirserver فقط؛ لا توجد إزالات منذ 0.9.59 تم التحقق من صحة المنافذ الافتراضية وجذور المستندات لجميع المنصات ملخص يظل I2PTunnel العمود الفقري لدمج التطبيقات مع I2P. بين الإصدارين 0.9.59 و2.10.0، اكتسب دعم الاتصالات المستمرة، والتشفير المقاوم للحوسبة الكمومية، وتحسينات كبيرة في معالجة الخيوط. معظم الإعدادات تبقى متوافقة، لكن يجب على المطورين التحقق من إعداداتهم لضمان الامتثال للإعدادات الافتراضية الحديثة للنقل والأمان.\n","description":"أداة للتفاعل مع I2P وتوفير الخدمات عليها","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/ar/docs/api/i2ptunnel/"},{"categories":null,"content":"نظرة عامة النقاط الرئيسية\nيوفر I2P تشفير من طرف إلى طرف لحركة مرور IRC عبر أنفاقه. قم بتعطيل SSL/TLS في عملاء IRC ما لم تكن تستخدم outproxy للوصول إلى clearnet. نفق العميل Irc2P المُعد مسبقاً يستمع على 127.0.0.1:6668 بشكل افتراضي. قم بتوصيل عميل IRC الخاص بك بذلك العنوان والمنفذ. لا تستخدم مصطلح \u0026ldquo;router‑provided TLS\u0026rdquo;. استخدم \u0026ldquo;I2P\u0026rsquo;s native encryption\u0026rdquo; أو \u0026ldquo;end‑to‑end encryption\u0026rdquo;. البدء السريع (Java I2P) افتح مدير الخدمات المخفية على http://127.0.0.1:7657/i2ptunnel/ وتأكد من أن نفق Irc2P قيد التشغيل. في عميل IRC الخاص بك، اضبط الخادم = 127.0.0.1، المنفذ = 6668، SSL/TLS = متوقف. اتصل وانضم إلى القنوات مثل #i2p، #i2p-dev، #i2p-help. بالنسبة لمستخدمي i2pd (router بلغة C++)، أنشئ نفق عميل في tunnels.conf (انظر الأمثلة أدناه).\nالشبكات والخوادم IRC2P (main community network) خوادم متحدة: irc.postman.i2p:6667، irc.echelon.i2p:6667، irc.dg.i2p:6667. نفق Irc2P على 127.0.0.1:6668 يتصل بأحد هذه الخوادم تلقائياً. القنوات الشائعة: #i2p، #i2p-chat، #i2p-dev، #i2p-help. Ilita network الخوادم: irc.ilita.i2p:6667, irc.r4sas.i2p:6667, irc.acetone.i2p:6667, rusirc.ilita.i2p:6667. اللغات الأساسية: الروسية والإنجليزية. توجد واجهات ويب على بعض المضيفين. Client setup Recommended, actively maintained WeeChat (terminal) — دعم قوي لـ SOCKS؛ سهل البرمجة النصية. Pidgin (desktop) — لا يزال قيد الصيانة؛ يعمل بشكل جيد على Windows/Linux. Thunderbird Chat (desktop) — مدعوم في ESR 128+. The Lounge (self‑hosted web) — عميل ويب حديث. IRC2P (شبكة المجتمع الرئيسية) LimeChat (مجاني، مفتوح المصدر). Textual (مدفوع على App Store؛ الكود المصدري متاح للبناء). شبكة Ilita WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin البروتوكول: IRC الخادم: 127.0.0.1 المنفذ: 6668 التشفير: معطل اسم المستخدم/اللقب: أي اسم Thunderbird Chat نوع الحساب: IRC الخادم: 127.0.0.1 المنفذ: 6668 SSL/TLS: معطل اختياري: الانضمام التلقائي للقنوات عند الاتصال Dispatch (SAM v3) مثال على القيم الافتراضية لـ config.toml:\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults نفق عميل Irc2P: 127.0.0.1:6668 ← الخادم الأعلى على المنفذ 6667. مدير الخدمات المخفية: http://127.0.0.1:7657/i2ptunnel/. موصى به، يتم صيانته بشكل نشط ~/.i2pd/tunnels.conf:\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat نفق منفصل لـ Ilita (مثال):\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat خيارات macOS تفعيل SAM في Java I2P (معطل افتراضياً) من /configclients أو clients.config. الإعدادات الافتراضية: 127.0.0.1:7656/TCP و 127.0.0.1:7655/UDP. التشفير الموصى به: SIGNATURE_TYPE=7 (Ed25519) و i2cp.leaseSetEncType=4,0 (ECIES‑X25519 مع ElGamal احتياطي) أو فقط 4 للأنظمة الحديثة فقط. تكوينات مثالية إعدادات Java I2P الافتراضية: نفقان واردان / نفقان صادران. إعدادات i2pd الافتراضية: 5 أنفاق واردة / 5 أنفاق صادرة. لـ IRC: 2–3 لكل منهما كافٍ؛ قم بتعيينها صراحةً للحصول على سلوك متسق عبر routers مختلفة. إعداد العميل لا تقم بتفعيل SSL/TLS لاتصالات I2P IRC الداخلية. يوفر I2P بالفعل تشفيراً من طرف إلى طرف. إضافة TLS تزيد العبء دون تحسين إخفاء الهوية. استخدم مفاتيح ثابتة للحصول على هوية مستقرة؛ تجنب إعادة توليد المفاتيح عند كل إعادة تشغيل إلا إذا كنت تختبر. إذا كانت عدة تطبيقات تستخدم IRC، فضّل استخدام tunnels منفصلة (غير مشتركة) لتقليل الربط بين الخدمات. إذا كان يجب عليك السماح بالتحكم عن بُعد (SAM/I2CP)، اربطه بـ localhost وقم بتأمين الوصول باستخدام SSH tunnels أو reverse proxies مع مصادقة. Alternative connection method: SOCKS5 بعض العملاء يمكنهم الاتصال عبر بروكسي SOCKS5 الخاص بـ I2P: 127.0.0.1:4447. للحصول على أفضل النتائج، يُفضل استخدام نفق IRC مخصص على المنفذ 6668؛ SOCKS لا يمكنه تنقية معرفات طبقة التطبيق وقد يسرب معلومات إذا لم يكن العميل مصممًا لإخفاء الهوية.\nTroubleshooting لا يمكن الاتصال — تأكد من تشغيل نفق Irc2P وأن الراوتر مكتمل التهيئة بالكامل. التعليق عند الحل/الانضمام — تحقق مرة أخرى من أن SSL معطل وأن العميل يشير إلى 127.0.0.1:6668. زمن وصول مرتفع — I2P مصمم بزمن وصول أعلى بطبيعته. حافظ على عدد الأنفاق متواضعاً (2-3) وتجنب حلقات إعادة الاتصال السريعة. استخدام تطبيقات SAM — تأكد من تفعيل SAM (Java) أو أنه غير محظور بجدار الحماية (i2pd). يُنصح بالجلسات طويلة الأمد. Appendix: Ports and naming منافذ أنفاق IRC الشائعة: 6668 (الافتراضي لـ Irc2P)، 6667 و 6669 كبدائل. أسماء نطاقات .b32.i2p: النموذج القياسي بـ 52 حرفاً؛ توجد نماذج موسعة بـ 56+ حرفاً لـ LS2/الشهادات المتقدمة. استخدم أسماء نطاقات .i2p إلا إذا كنت بحاجة صريحة لعناوين b32. ","description":"دليل كامل لشبكات IRC على I2P والعملاء والأنفاق وإعداد الخادم (محدث 2025)","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"IRC عبر I2P","url":"/ar/docs/applications/irc/"},{"categories":null,"content":"نظرة عامة تحدد هذه الوثيقة آليات blinding (الإعماء التشفيري)، والتشفير، وفك التشفير لـ LeaseSet2 (LS2) المشفَّر. توفر LeaseSets المشفَّرة نشرًا خاضعًا للتحكم في الوصول لمعلومات الخدمات المخفية في قاعدة بيانات شبكة I2P.\nالميزات الأساسية: - تدوير يومي للمفاتيح لتحقيق السرية الأمامية - ترخيص العملاء ثنائي المستويات (DH-based القائم على Diffie-Hellman، وPSK-based المعتمد على المفتاح المُشترك مسبقاً) - تشفير ChaCha20 لتحسين الأداء على الأجهزة التي تفتقر إلى عتاد AES - تواقيع Red25519 مع key blinding (إعماء المفتاح) - عضوية عملاء تحافظ على الخصوصية\nالوثائق ذات الصلة: - مواصفة الهياكل المشتركة - بنية LeaseSet المشفرة - الاقتراح 123: إدخالات netDB الجديدة - خلفية حول LeaseSets المشفرة - وثائق قاعدة بيانات الشبكة - استخدام NetDB\nسجل الإصدارات وحالة التنفيذ الجدول الزمني لتطوير البروتوكول ملاحظة مهمة حول ترقيم الإصدارات: تستخدم I2P مخططين منفصلين لترقيم الإصدارات: - إصدار API/Router: سلسلة 0.9.x (يُستخدم في المواصفات التقنية) - إصدار المنتج: سلسلة 2.x.x (يُستخدم للإصدارات العامة)\nتشير المواصفات التقنية إلى إصدارات واجهة برمجة التطبيقات (API) (مثل 0.9.41)، في حين يرى المستخدمون النهائيون إصدارات المنتج (مثل 2.10.0).\nمعالم التنفيذ Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility ### الحالة الحالية ✅ حالة البروتوكول: مستقر ولم يتغير منذ يونيو 2019 ✅ Java I2P: مُنفّذ بالكامل في الإصدار 0.9.40+ ✅ i2pd (C++): مُنفّذ بالكامل في الإصدار 2.58.0+ ✅ التشغيل البيني: كامل بين التنفيذات ✅ نشر الشبكة: جاهز للإنتاج مع خبرة تشغيلية تزيد على 6 سنوات تعريفات التشفير الترميز والاصطلاحات || يدل على الربط mod L يدل على الاختزال المعياري وفق رتبة Ed25519 جميع مصفوفات البايت تكون بترتيب بايت الشبكة (big-endian: البايت الأكثر أهمية أولاً) ما لم يُنص على خلاف ذلك القيم ذات الترتيب little-endian (البايت الأقل أهمية أولاً) يُشار إليها صراحة CSRNG(n) (مولد أعداد عشوائية آمن تشفيرياً) مولِّد أرقام عشوائية آمن تشفيرياً\nيُنتج n بايتًا من بيانات عشوائية آمنة من الناحية التشفيرية، مناسبة لتوليد مادة المفتاح.\nمتطلبات الأمان: - يجب أن يكون آمناً تشفيرياً (مناسب لتوليد المفاتيح) - يجب أن يكون آمناً عند انكشاف تسلسلات بايت متجاورة على الشبكة - ينبغي لعمليات التنفيذ أن تقوم بتجزئة المخرجات القادمة من مصادر قد لا يُوثَق بها\nالمراجع: - اعتبارات أمان PRNG - مناقشة مطوري Tor H(p, d) تجزئة SHA-256 مع التخصيص\nدالة تجزئة مع domain separation (فصل النطاقات) تأخذ: - p: سلسلة التخصيص (توفّر فصل النطاقات) - d: البيانات المطلوب تجزئتها\nالتنفيذ:\nH(p, d) := SHA-256(p || d) الاستخدام: يوفّر فصلًا تشفيريًا للمجالات لمنع هجمات التصادم بين الاستخدامات البروتوكولية المختلفة لـ SHA-256.\nتدفق: ChaCha20 (خوارزمية تشفير تيارية) شفرة تدفقية: ChaCha20 كما هو محدد في RFC 7539 القسم 2.4\nالمعلمات: - S_KEY_LEN = 32 (مفتاح بطول 256-بت) - S_IV_LEN = 12 (nonce (عدد فريد لمرة واحدة) بطول 96-بت) - العداد الابتدائي: 1 (تسمح RFC 7539 بالقيمة 0 أو 1؛ يوصى باستخدام 1 لسياقات AEAD (مصادقة وتشفير البيانات المقترنة))\nENCRYPT(k, iv, plaintext)\nيشفّر النص الصريح باستخدام: - k: مفتاح تشفير بطول 32 بايت - iv: nonce (قيمة تُستخدم مرة واحدة) بطول 12 بايت (يجب أن تكون فريدة لكل مفتاح) - يعيد نصاً مُشفّراً بنفس حجم النص الصريح\nخاصية أمنية: يجب أن يكون كامل النص المشفّر غير قابل للتمييز عن العشوائية إذا كان المفتاح سريًا.\nفك التشفير(k, iv, ciphertext)\nيفك تشفير النص المُشفّر باستخدام: - k: مفتاح تشفير بطول 32 بايت - iv: عدد يُستخدم مرة واحدة بطول 12 بايت - يُرجع النص الصريح\nمبررات التصميم: تم اختيار ChaCha20 بدلًا من AES للأسباب التالية:\nأسرع بمقدار 2.5-3x من AES على الأجهزة التي لا يتوفر فيها تسريع عتادي يسهل تحقيق تنفيذ بزمن ثابت (constant-time) أمان وسرعة قابِلان للمقارنة عند توفر AES-NI المراجع: - RFC 7539 - ChaCha20 و Poly1305 لبروتوكولات IETF\nالتوقيع: Red25519 (خوارزمية توقيع رقمية) مخطط التوقيع: Red25519 (SigType 11) مع إعماء المفتاح\nRed25519 مبني على تواقيع Ed25519 على منحنى Ed25519، باستخدام SHA-512 للتجزئة، مع دعم key blinding (إعماء المفتاح) كما هو محدد في ZCash RedDSA.\nالدوال:\nDERIVE_PUBLIC(privkey) يُعيد المفتاح العام المقابل للمفتاح الخاص المُعطى. - يستخدم الضرب العددي القياسي في Ed25519 على النقطة الأساسية\nSIGN(privkey, m) يُرجِع توقيعًا باستخدام المفتاح الخاص privkey على الرسالة m.\nاختلافات توقيع Red25519 عن Ed25519: 1. Nonce عشوائي (عدد يُستخدم مرة واحدة): يستخدم 80 بايتًا من البيانات العشوائية الإضافية\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) هذا يجعل كل توقيع Red25519 (خوارزمية توقيع) فريدًا، حتى مع الرسالة والمفتاح نفسيهما.\nتوليد المفاتيح الخاصة: تُولَّد مفاتيح Red25519 الخاصة من أعداد عشوائية وتُختزَل وفق mod L، بدلاً من استخدام نهج bit-clamping الخاص بـ Ed25519. تحقق(pubkey, m, sig) يتحقق من التوقيع sig مقابل المفتاح العام pubkey والرسالة m. - يُرجع true إذا كان التوقيع صالحًا، وfalse خلاف ذلك - عملية التحقق مطابقة لـ Ed25519\nعمليات إعماء المفاتيح:\nGENERATE_ALPHA(data, secret) يولّد قيمة ألفا لأجل key blinding (إعماء المفتاح). - data: يحتوي عادةً على المفتاح العام للتوقيع وأنواع التوقيع - secret: سر إضافي اختياري (بطول صفري إذا لم يُستخدم) - النتيجة موزَّعة بنفس توزيع مفاتيح Ed25519 الخاصة (بعد إجراء اختزال mod L)\nBLIND_PRIVKEY(privkey, alpha) يُعمّي مفتاحاً خاصاً باستخدام السر alpha. - التنفيذ: blinded_privkey = (privkey + alpha) mod L - يستخدم حسابات scalar (عدد قياسي) ضمن الحقل\nBLIND_PUBKEY(pubkey, alpha) يُعمّي مفتاحاً عاماً باستخدام السر alpha. - التنفيذ: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) - يستخدم جمع عناصر المجموعة (النقاط) على المنحنى\nخاصية حرجة:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) اعتبارات أمنية:\nمن مواصفة بروتوكول ZCash القسم 5.4.6.1: لأسباب أمنية، يجب أن يكون توزيع alpha مطابقاً لتوزيع unblinded private keys (المفاتيح الخاصة بعد إزالة الإعماء). وهذا يضمن أن \u0026ldquo;مزيج مفتاح عام أُعيدت عشوائيته والتوقيع أو التوقيعات المُولَّدة باستخدام ذلك المفتاح لا يكشف المفتاح الذي أُعيدت عشوائيته منه\u0026rdquo;.\nأنواع التواقيع المدعومة: - النوع 7 (Ed25519): مدعوم للوجهات الحالية (للتوافق مع الإصدارات الأقدم) - النوع 11 (Red25519): موصى به للوجهات الجديدة التي تستخدم التشفير - Blinded keys (مفاتيح معمية): استخدم دائمًا النوع 11 (Red25519)\nالمراجع: - مواصفة بروتوكول ZCash - القسم 5.4.6 RedDSA - مواصفة I2P Red25519 DH (تبادل المفاتيح ديفي-هيلمان): X25519 ديفي-هيلمان على المنحنيات الإهليلجية: X25519\nنظام اتفاق مفاتيح بالمفتاح العام قائم على Curve25519.\nالمعلمات: - المفاتيح الخاصة: 32 بايت - المفاتيح العامة: 32 بايت - مخرجات السرّ المشترك: 32 بايت\nالدوال:\nGENERATE_PRIVATE() يُولِّد مفتاحاً خاصاً جديداً بطول 32 بايت باستخدام CSRNG (مولّد أرقام عشوائية آمن تشفيرياً).\nDERIVE_PUBLIC(privkey) يشتق مفتاحًا عامًا بطول 32 بايت من المفتاح الخاص المُعطى. - يستخدم الضرب العددي على Curve25519 (منحنى بيضوي للتشفير)\nDH(privkey, pubkey) ينفّذ اتفاقية تبادل المفاتيح Diffie-Hellman. - privkey: مفتاح خاص محلي بطول 32 بايت - pubkey: مفتاح عام بعيد بطول 32 بايت - يعيد: سر مشترك بطول 32 بايت\nخصائص الأمان: - افتراض ديفي-هيلمان الحسابي على Curve25519 - السرية الأمامية عند استخدام المفاتيح المؤقتة - يتطلب تنفيذًا بزمن ثابت لمنع هجمات التوقيت\nالمراجع: - RFC 7748 - المنحنيات البيضوية للأمن\nHKDF (دالة اشتقاق المفاتيح المستندة إلى HMAC) دالة اشتقاق المفاتيح المستندة إلى HMAC\nيستخلص ويُوسِّع المادة المفتاحية من المادة المفتاحية المُدخلة.\nالمعلمات: - salt: بحد أقصى 32 بايت (عادةً 32 بايت لـ SHA-256) - ikm: مادة مفتاح الإدخال (أي طول، ينبغي أن تتمتع بإنتروبيا جيدة) - info: معلومات خاصة بالسياق (فصل المجالات) - n: طول المخرجات بالبايت\nالتنفيذ:\nيستخدم HKDF (مشتق المفاتيح القائم على HMAC) كما هو محدد في RFC 5869 مع: - دالة التجزئة: SHA-256 - HMAC: كما هو محدد في RFC 2104 - طول الملح (Salt): بحد أقصى 32 بايت (HashLen، أي طول ناتج التجزئة، لـ SHA-256)\nنمط الاستخدام:\nkeys = HKDF(salt, ikm, info, n) فصل المجالات: يوفر معامل info فصلًا تشفيريًا للمجالات بين الاستخدامات المختلفة لـ HKDF (دالة اشتقاق المفاتيح المعتمدة على HMAC) في البروتوكول.\nقيم معلومات مُتحقَّق منها: - \u0026quot;ELS2_L1K\u0026quot; - تشفير الطبقة 1 (الخارجية) - \u0026quot;ELS2_L2K\u0026quot; - تشفير الطبقة 2 (الداخلية) - \u0026quot;ELS2_XCA\u0026quot; - تفويض العميل DH (تبادل المفاتيح ديفي-هيلمان) - \u0026quot;ELS2PSKA\u0026quot; - تفويض العميل PSK (مفتاح مُشترك مُسبقًا) - \u0026quot;i2pblinding1\u0026quot; - توليد ألفا\nالمراجع: - RFC 5869 - مواصفة HKDF - RFC 2104 - مواصفة HMAC\nمواصفة التنسيق يتكوّن LS2 (الإصدار الثاني من leaseSet) المشفّر من ثلاث طبقات متداخلة:\nالطبقة 0 (الخارجية): معلومات نصية صريحة للتخزين والاسترجاع الطبقة 1 (الوسطى): بيانات مصادقة العميل (مشفرة) الطبقة 2 (الداخلية): بيانات LeaseSet2 الفعلية (مشفرة) الهيكل العام:\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature مهم: تستخدم LS2 المُشفَّرة مفاتيح مُعمّاة بالإعماء. Destination (الوجهة) ليست في الترويسة. موقع التخزين في DHT هو SHA-256(sig type || blinded public key)، ويُدوَّر يومياً.\nالطبقة 0 (الخارجية) - نص صريح لا تستخدم الطبقة 0 ترويسة LS2 القياسية. لديها تنسيق مخصص محسّن لـ blinded keys (مفاتيح مُعمّاة بطريقة التعمية العمياء).\nالبنية:\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data **حقل الأعلام (2 بايت، البتات 15-0):** - **البت 0:** مؤشر المفاتيح غير المتصلة - `0` = لا توجد مفاتيح غير متصلة - `1` = توجد مفاتيح غير متصلة (تليها بيانات مفاتيح مؤقتة) - **البتات 1-15:** محجوزة، يجب أن تكون 0 لضمان التوافق المستقبلي بيانات مفتاح مؤقتة (موجودة إذا كان البت 0 في العلم يساوي 1):\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key **التحقق من التوقيع:** - **من دون مفاتيح غير متصلة:** تحقق باستخدام blinded public key (مفتاح عام أعمى) - **مع مفاتيح غير متصلة:** تحقق باستخدام مفتاح عام مؤقت يغطي التوقيع جميع البيانات من Type وحتى outerCiphertext (شاملًا الطرفين).\nالطبقة 1 (الوسطى) - تخويل العميل فك التشفير: انظر قسم تشفير الطبقة 1 .\nالبنية:\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) **حقل الأعلام (1 بايت، البتات 7-0):** - **البت 0:** وضع التخويل - `0` = بدون تخويل لكل عميل (الجميع) - `1` = تخويل لكل عميل (يتبع قسم التخويل) - **البتات 3-1:** مخطط المصادقة (فقط إذا كان البت 0 = 1) - `000` = مصادقة عميل DH (Diffie-Hellman) - `001` = مصادقة عميل PSK (مفتاح مُشترك مسبقًا) - البقية محجوزة - **البتات 7-4:** غير مستخدمة، يجب أن تكون 0 بيانات تفويض العميل DH (الأعلام = 0x01, البتات 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **مدخلة authClient (40 بايت):** - `clientID_i`: 8 بايت - `clientCookie_i`: 32 بايت (authCookie مشفّر) بيانات تفويض عميل PSK (مفتاح مُشترك مُسبقاً) (الأعلام = 0x03، البتات 3-1 = 001):\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **مدخلة authClient (40 بايت):** - `clientID_i`: 8 بايت - `clientCookie_i`: 32 بايت (authCookie مشفّر) الطبقة 2 (الداخلية) - بيانات LeaseSet فك التشفير: راجع قسم Layer 2 Encryption .\nالبنية:\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 تحتوي الطبقة الداخلية على البنية الكاملة لـ LeaseSet2 بما في ذلك: - ترويسة LS2 - معلومات الـ Lease (سجل اتصال مؤقت في I2P) - توقيع LS2 متطلبات التحقق: بعد فك التشفير، يجب على التنفيذات التحقق مما يلي: 1. أن الطابع الزمني الداخلي يطابق الطابع الزمني الخارجي المنشور 2. أن وقت الانتهاء الداخلي يطابق وقت الانتهاء الخارجي 3. أن يكون توقيع LS2 صالحًا (الإصدار الثاني من LeaseSet) 4. أن تكون بيانات الـ Lease مكوّنة بشكل سليم\nالمراجع: - مواصفات الهياكل المشتركة - تفاصيل تنسيق LeaseSet2\nاشتقاق مفتاح الإعماء نظرة عامة يستخدم I2P مخططاً جمعياً لإعماء المفاتيح مبنياً على Ed25519 (خوارزمية توقيع بيضوية Ed25519) وZCash RedDSA (متغير EdDSA المستخدم في ZCash). تُدوَّر المفاتيح المُعمّاة يومياً (منتصف الليل بتوقيت UTC) لتحقيق السرية الأمامية.\nالأساس المنطقي للتصميم:\nاختارت I2P صراحةً عدم استخدام نهج الملحق A.2 في ملف rend-spec-v3.txt الخاص بـ Tor. وفقًا للمواصفة:\n\u0026ldquo;نحن لا نستخدم الملحق A.2 من ملف المواصفات rend-spec-v3.txt الخاص بـ Tor، الذي له أهداف تصميم مشابهة، لأن مفاتيحه العامة المُعمّاة (blinded) قد تكون خارج المجموعة الفرعية ذات الرتبة الأولية، مع تبعات أمنية غير معروفة.\u0026rdquo;\nالإعماء الجمعي في I2P يضمن بقاء المفاتيح المُعمّاة بأسلوب الإعماء ضمن المجموعة الفرعية ذات الرتبة الأولية لمنحنى Ed25519.\nالتعريفات الرياضية معاملات Ed25519: - B: نقطة الأساس في Ed25519 (المولِّد) = 2^255 - 19 - L: رتبة Ed25519 = 2^252 + 27742317777372353535851937790883648493\nالمتغيرات الأساسية: - A: مفتاح توقيع عام بطول 32 بايت غير أعمى (داخل Destination، أي الوجهة في I2P) - a: مفتاح توقيع خاص بطول 32 بايت غير أعمى - A': مفتاح توقيع عام بطول 32 بايت أعمى (يُستخدم في LeaseSet مُشفّر) - a': مفتاح توقيع خاص بطول 32 بايت أعمى - alpha: عامل العمى بطول 32 بايت (سري)\nالدوال المساعدة:\nLEOS2IP(x) \u0026ldquo;من سلسلة بايتات بتنسيق Little-Endian (النهاية الصغرى) إلى عدد صحيح\u0026rdquo;\nيحوّل مصفوفة بايت مُرتّبة وفق little-endian إلى تمثيل عدد صحيح.\nH*(x) \u0026ldquo;التجزئة والاختزال\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L نفس العملية كما في توليد مفاتيح Ed25519 (خوارزمية توقيع رقمية على منحنى بيضوي).\nجيل ألفا التدوير اليومي: يجب توليد alpha جديدة و blinded keys (مفاتيح مُعمّاة بتقنية الإعماء) كل يوم عند منتصف الليل حسب UTC (00:00:00 UTC).\nخوارزمية GENERATE_ALPHA(destination, date, secret):\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L تم التحقق من البارامترات: - تخصيص الملح: \u0026ldquo;I2PGenerateAlpha\u0026rdquo; - قيمة info في HKDF: \u0026ldquo;i2pblinding1\u0026rdquo; - المخرجات: 64 بايت قبل الاختزال - توزيع Alpha: بنفس توزيع مفاتيح Ed25519 الخاصة بعد mod L\nإعماء المفتاح الخاص خوارزمية BLIND_PRIVKEY(a, alpha):\nبالنسبة لمالك الوجهة الذي ينشر LeaseSet المُشفَّرة:\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) حاسم: إن اختزال mod L ضروري للحفاظ على العلاقة الجبرية الصحيحة بين المفتاحين الخاص والعام.\nإعماء المفتاح العام خوارزمية BLIND_PUBKEY(A, alpha):\nبالنسبة للعملاء الذين يسترجعون ويتحققون من LeaseSet المشفَّر:\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) التكافؤ الرياضي:\nكلتا الطريقتين تعطيان النتيجة نفسها:\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) وذلك لأن:\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) التوقيع باستخدام Blinded Keys (مفاتيح مُطبَّق عليها الإعماء) توقيع LeaseSet غير أعمى:\nيتم توقيع الـ unblinded (غير مُعمّى) LeaseSet (المُرسَل مباشرةً إلى العملاء الموثَّقين) باستخدام: - توقيع Standard Ed25519 (النوع 7) أو Red25519 (النوع 11) - مفتاح توقيع خاص unblinded - يتم التحقق باستخدام مفتاح عام unblinded\nباستخدام المفاتيح غير المتصلة: - موقّع بواسطة مفتاح خاص مؤقت unblinded (مزال العمى في سياق التوقيعات العمياء) - يُتحقَّق منه باستخدام مفتاح عام مؤقت unblinded - يجب أن يكون كلاهما من النوع 7 أو 11\nتوقيع LeaseSet المشفرة:\nالجزء الخارجي من LeaseSet المشفَّر يستخدم تواقيع Red25519 مع blinded keys (مفاتيح مُعمّاة بالإعماء).\nخوارزمية التوقيع Red25519:\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total الاختلافات الأساسية عن Ed25519: 1. يستخدم 80 بايت من البيانات العشوائية T (وليس تجزئة المفتاح الخاص) 2. يستخدم قيمة المفتاح العام مباشرةً (وليس تجزئة المفتاح الخاص) 3. كل توقيع فريد حتى مع نفس الرسالة والمفتاح\nالتحقق:\nمماثل لـ Ed25519:\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; اعتبارات أمنية توزيع ألفا:\nمن أجل الأمان، يجب أن يكون توزيع alpha مطابقاً لتوزيع المفاتيح الخاصة غير المعمية. عند إجراء blinding (تقنية الإعماء في التشفير) من Ed25519 (type 7) إلى Red25519 (type 11)، تختلف التوزيعات قليلاً.\nتوصية: استخدم Red25519 (type 11) لكلٍ من المفاتيح غير المُعمّاة (بالإعماء) والمفاتيح المُعمّاة (بالإعماء) لتلبية متطلبات ZCash: \u0026ldquo;إن اقتران مفتاح عام أُعيدت عشوائيته والتوقيع(ات) باستخدام ذلك المفتاح لا يكشف المفتاح الذي أُعيدت منه عشوائيته.\u0026rdquo;\nدعم النوع 7: Ed25519 (خوارزمية توقيع رقمية بيضوية) مدعوم للتوافق مع الإصدارات السابقة للوجهات القائمة، لكن يُوصى باستخدام النوع 11 للوجهات المشفّرة الجديدة.\nفوائد التدوير اليومي: - السرية المستقبلية: اختراق blinded key (المفتاح المُعمّى) اليوم لا يكشف مفتاح الأمس - عدم قابلية الربط: التدوير اليومي يمنع التتبع طويل الأمد عبر DHT - فصل المفاتيح: مفاتيح مختلفة لفترات زمنية مختلفة\nالمراجع: - ZCash Protocol Specification - القسم 5.4.6.1 - Tor Key Blinding Discussion - Tor Ticket #8106 التشفير والمعالجة اشتقاق بيانات الاعتماد الفرعية قبل التشفير، نشتق credential (بيانات اعتماد) وsubcredential (بيانات اعتماد فرعية) لربط الطبقات المشفرة بشرط معرفة المفتاح العام للتوقيع الخاص بالوجهة.\nالهدف: ضمان أن فك تشفير LeaseSet المُشفَّر لا يمكن إلا لمن يعرفون المفتاح العام للتوقيع الخاص بالوجهة. لا حاجة إلى الوجهة الكاملة.\nحساب بيانات الاعتماد A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes فصل المجالات: تضمن سلسلة التخصيص \u0026quot;credential\u0026quot; ألا تتصادم قيمة التجزئة هذه مع أي مفاتيح استعلام في DHT (جدول تجزئة موزع) أو مع استخدامات أخرى للبروتوكول.\nحساب بيانات الاعتماد الفرعية blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes الغرض: يقوم subcredential (اعتماد فرعي) بربط الـ LeaseSet المشفّر بـ: 1. Destination (الوجهة) المحددة (عبر credential) 2. blinded key (مفتاح مُعمّى بالإعماء) المحدد (عبر blindedPublicKey) 3. اليوم المحدد (عبر التدوير اليومي لـ blindedPublicKey)\nهذا يمنع هجمات إعادة الإرسال والربط عبر أيام مختلفة.\nتشفير الطبقة الأولى السياق: تحتوي الطبقة 1 على بيانات تفويض العميل ويتم تشفيرها باستخدام مفتاح مشتق من subcredential (بيانات اعتماد فرعية).\nخوارزمية التشفير # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) الناتج: outerCiphertext هو 32 + len(outerPlaintext) بايت.\nخصائص الأمان: - الملح يضمن أزواج مفتاح/متجه تهيئة (IV) فريدة حتى مع نفس بيانات الاعتماد الفرعية - سلسلة السياق \u0026quot;ELS2_L1K\u0026quot; توفّر فصل المجالات - ChaCha20 يوفّر أمانًا دلاليًا (نصًا مشفّرًا غير قابل للتمييز عن العشوائي)\nخوارزمية فك التشفير # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) التحقق: بعد فك التشفير، تحقّق من أن بنية الطبقة 1 مُشكّلة بشكل صحيح قبل المتابعة إلى الطبقة 2.\nتشفير الطبقة الثانية السياق: تحتوي الطبقة 2 على بيانات LeaseSet2 الفعلية وتكون مشفّرة بمفتاح مشتق من authCookie (إذا كانت المصادقة لكل عميل مفعّلة) أو سلسلة فارغة (إذا لم تكن كذلك).\nخوارزمية التشفير # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) المخرجات: innerCiphertext طوله 32 + len(innerPlaintext) بايتًا.\nربط المفتاح: - إذا لم تكن هناك مصادقة للعميل: يكون الارتباط فقط بـ subcredential و timestamp - إذا كانت مصادقة العميل مفعّلة: يكون الارتباط أيضاً بـ authCookie (مختلف لكل عميل مخوّل)\nخوارزمية فك التشفير # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) التحقق: بعد فك التشفير: 1. التحقق من أن بايت نوع LS2 صالح (3 أو 7) 2. تحليل بنية LeaseSet2 3. التحقق من أن الطابع الزمني الداخلي يطابق الطابع الزمني المنشور الخارجي 4. التحقق من أن تاريخ الانقضاء الداخلي يطابق تاريخ الانقضاء الخارجي 5. التحقق من توقيع LeaseSet2\nملخص طبقة التشفير ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ تدفق فك التشفير: 1. تحقّق من توقيع الطبقة 0 باستخدام blinded public key (مفتاح عام بتعمية عمياء) 2. فك تشفير الطبقة 1 باستخدام subcredential (اعتماد فرعي) 3. قم بمعالجة بيانات التفويض (إن وُجدت) للحصول على authCookie (ملف تعريف ارتباط المصادقة) 4. فك تشفير الطبقة 2 باستخدام authCookie وsubcredential 5. تحقّق وحلّل LeaseSet2\nتفويض لكل عميل نظرة عامة عند تمكين التفويض على مستوى العميل، يحتفظ الخادم بقائمة بالعملاء المخوَّلين. يمتلك كل عميل بيانات مفاتيح يجب نقلها بأمان عبر out-of-band (خارج القناة الاعتيادية).\nآليتان للتخويل: 1. تخويل العميل بطريقة DH (Diffie-Hellman): أكثر أمانًا، يستخدم اتفاقية تبادل المفاتيح X25519 2. تخويل باستخدام PSK (Pre-Shared Key): أبسط، يستخدم مفاتيح متناظرة\nخصائص الأمان الشائعة: - خصوصية عضوية العملاء: يمكن للمراقبين رؤية عدد العملاء لكن لا يمكنهم تحديد عملاء بعينهم - إضافة/سحب العملاء بشكل مجهول: لا يمكن تتبّع وقت إضافة عملاء محدّدين أو إزالتهم - احتمال تصادم معرّف العميل المكوّن من 8 بايت: ~1 من كل 18 كوينتيليون (مهمل)\nتفويض عميل DH (Diffie-Hellman - تبادل المفاتيح ديفي-هيلمان) نظرة عامة: يولّد كل عميل زوج مفاتيح X25519 ويرسل مفتاحه العام إلى الخادم عبر قناة آمنة خارج النطاق. يستخدم الخادم تبادل مفاتيح ديفي-هيلمان المؤقت لتشفير قيمة authCookie فريدة لكل عميل.\nتوليد مفاتيح العميل # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) ميزة أمنية: لا يغادر المفتاح الخاص للعميل جهازه مطلقًا. لا يستطيع خصمٌ يعترض الإرسال خارج القناة فك تشفير LeaseSets المُشفَّرة المستقبلية من دون كسر X25519 DH (خوارزمية تبادل المفاتيح ديفي-هيلمان X25519).\nالمعالجة على الخادم # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 بنية بيانات الطبقة 1:\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] توصيات الخادم: - أنشئ زوج مفاتيح مؤقت جديد لكل LeaseSet مشفّر منشور - اجعل ترتيب العملاء عشوائياً لمنع التتبع القائم على الموضع - فكّر في إضافة إدخالات وهمية لإخفاء العدد الحقيقي للعملاء\nمعالجة العميل # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) التعامل مع أخطاء العميل: - إذا لم يتم العثور على clientID_i: تم سحب تفويض العميل أو لم يُخوَّل قط - إذا فشل فك التشفير: بيانات تالفة أو مفاتيح غير صحيحة (نادر جدًا) - ينبغي للعملاء إعادة الجلب دوريًا لاكتشاف سحب التفويض\nتفويض العميل عبر PSK (مفتاح مُسبق المشاركة) نظرة عامة: يمتلك كل عميل مفتاحاً متناظراً مشتركاً مسبقاً بطول 32 بايت. يقوم الخادم بتشفير نفس authCookie باستخدام PSK (مفتاح مشترك مسبقاً) الخاص بكل عميل.\nتوليد المفاتيح # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel ملاحظة أمنية: يمكن مشاركة PSK (مفتاح مشترك مُسبقًا) نفسه بين عدة عملاء عند الرغبة (مما يُنشئ تفويضًا من نوع \u0026ldquo;مجموعة\u0026rdquo;).\nمعالجة الخادم # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 بنية بيانات الطبقة 1:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] معالجة العميل # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) المقارنة والتوصيات Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access **التوصية:** - **Use DH authorization** (تفويض باستخدام Diffie-Hellman) للتطبيقات عالية الأمان حيث تكون السرية الأمامية مهمة - **Use PSK authorization** (تفويض بالمفتاح المشترك مسبقاً) عندما يكون الأداء بالغ الأهمية أو عند إدارة مجموعات العملاء - **لا تُعِد استخدام PSKs** عبر خدمات مختلفة أو فترات زمنية مختلفة - **استخدم دائمًا قنوات آمنة** لتوزيع المفاتيح (مثل Signal, OTR, PGP) الاعتبارات الأمنية خصوصية عضوية العميل:\nكلتا الآليتين توفّران الخصوصية لعضوية العميل من خلال: 1. معرّفات العميل المشفّرة: clientID بطول 8 بايت مُشتق من ناتج HKDF (دالة اشتقاق مفاتيح مستندة إلى HMAC) 2. ملفات تعريف الارتباط غير القابلة للتمييز: تبدو جميع قيم clientCookie بطول 32 بايت عشوائية 3. لا توجد بيانات وصفية خاصة بعميل معيّن: لا توجد طريقة لتحديد أي إدخال يعود إلى أي عميل\nيمكن للمراقب أن يرى:\nعدد العملاء المصرّح لهم (من الحقل clients) التغيرات في عدد العملاء مع مرور الوقت لا يمكن للمراقب رؤية: - أي العملاء المحددين مخولون - متى تتم إضافة عملاء محددين أو حذفهم (إذا بقي العدد كما هو) - أي معلومات تحدد هوية العميل\nتوصيات بشأن العشوائية:\nيُستحسن أن تُعيد الخوادم ترتيب العملاء بصورة عشوائية في كل مرة تُولِّد فيها LeaseSet مُشفّراً:\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order الفوائد: - يمنع العملاء من معرفة موقعهم في القائمة - يمنع هجمات الاستدلال القائمة على التغيرات في الموضع - يجعل إضافة/إبطال العملاء غير قابلة للتمييز\nإخفاء عدد العملاء:\nيجوز أن تقوم الخوادم بإدراج إدخالات وهمية عشوائية:\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) التكلفة: تزيد المدخلات الوهمية حجم LeaseSet المشفّر (40 بايت لكلٍّ منها).\nتدوير AuthCookie (ملف تعريف الارتباط الخاص بالمصادقة):\nينبغي أن تقوم الخوادم بإنشاء authCookie جديد: - في كل مرة يتم فيها نشر LeaseSet مشفر (كل بضع ساعات عادة) - مباشرة بعد إلغاء تفويض عميل - وفق جدول منتظم (مثلاً يومياً) حتى إن لم تطرأ أي تغييرات على العملاء\nالفوائد: - يحد من التعرض إذا تم اختراق authCookie - يضمن أن العملاء الذين أُلغيت صلاحياتهم يفقدون الوصول بسرعة - يوفر سرية أمامية للطبقة الثانية\nالعنونة بـ Base32 لـ LeaseSets المشفرة نظرة عامة عناوين I2P التقليدية بصيغة base32 تحتوي فقط على تجزئة Destination (الوجهة) (32 بايت → 52 حرفًا). وهذا غير كافٍ بالنسبة إلى LeaseSets المشفّرة للأسباب التالية:\nيحتاج العملاء إلى المفتاح العام غير المُعمّى (non-blinded public key) لاشتقاق المفتاح العام المُعمّى (blinded public key) يحتاج العملاء إلى أنواع التوقيع (signature types) (غير مُعمّى ومُعمّى) للاشتقاق الصحيح للمفاتيح لا توفّر التجزئة وحدها هذه المعلومات الحل: صيغة base32 (ترميز بقاعدة 32) جديدة تتضمن المفتاح العام وأنواع التوقيع.\nمواصفة صيغة العنوان البنية بعد فك الترميز (35 بايت):\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ أول 3 بايتات (XOR (أو الحصري) مع المجموع الاختباري):\nتحتوي أول 3 بايتات على بيانات وصفية طُبِّق عليها XOR (أو الحصري) مع أجزاء من قيمة فحص CRC-32:\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey خصائص المجموع الاختباري: - يستخدم متعدد الحدود القياسي CRC-32 - معدل السلبية الكاذبة: ~1 من كل 16 مليون - يكتشف أخطاء الكتابة في العناوين - لا يمكن استخدامه للمصادقة (غير آمن تشفيرياً)\nالتنسيق المُرمَّز:\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; الخصائص: - إجمالي عدد الأحرف: 56 (35 بايت × 8 بت ÷ 5 بت لكل حرف) - اللاحقة: \u0026ldquo;.b32.i2p\u0026rdquo; (مطابقة لـ base32 التقليدية) - الطول الإجمالي: 56 + 8 = 64 حرفًا (باستثناء null terminator (محرف الإنهاء الفارغ))\nترميز Base32: - الأبجدية: abcdefghijklmnopqrstuvwxyz234567 (المعيار RFC 4648) - يجب أن تكون 5 بتات غير مستخدمة في النهاية تساوي 0 - غير حساس لحالة الأحرف (تقليدياً بالأحرف الصغيرة)\nتوليد العناوين import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address تحليل العناوين import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype مقارنة مع Base32 التقليدي Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations ### قيود الاستخدام عدم التوافق مع BitTorrent:\nلا يمكن استخدام عناوين LS2 المشفّرة مع ردود الإعلان المدمجة الخاصة بـ BitTorrent:\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ المشكلة: التنسيق الموجز يحتوي فقط على التجزئة (32 بايت)، ولا يوفّر مساحة لأنواع التوقيع أو معلومات المفتاح العام.\nالحل: استخدم ردود announce (رسالة الإعلان في متتبّع BitTorrent) الكاملة أو متتبّعات قائمة على HTTP تدعم العناوين الكاملة.\nتكامل دفتر العناوين إذا كان لدى عميل Destination الكامل (معرّف الوجهة في I2P) في دفتر عناوين:\nخزّن Destination (الوجهة) الكامل (يتضمن المفتاح العام) ادعم البحث العكسي حسب التجزئة عند مواجهة LS2 مشفّر، استرجع المفتاح العام من دفتر العناوين لا حاجة إلى صيغة base32 جديدة إذا كان Destination الكامل معروف مسبقًا تنسيقات دفتر العناوين التي تدعم LS2 المُشفَّر: - hosts.txt مع سلاسل الوجهة الكاملة - قواعد بيانات SQLite مع عمود الوجهة - تنسيقات JSON/XML مع بيانات الوجهة الكاملة\nأمثلة على التنفيذ مثال 1: توليد عنوان\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p مثال 2: التحليل والتحقق\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) مثال 3: التحويل من Destination (الوجهة في I2P)\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) اعتبارات الأمان الخصوصية: - يكشف عنوان Base32 المفتاح العام - هذا مقصود ومطلوب من أجل البروتوكول - لا يكشف المفتاح الخاص ولا يعرّض الأمان للخطر - المفاتيح العامة معلومات علنية بطبيعتها\nمقاومة التصادم: - يوفر CRC-32 32 بتًا فقط من مقاومة التصادم - غير آمن من الناحية التشفيرية (يُستخدم للكشف عن الأخطاء فقط) - لا تعتمد إطلاقًا على المجموع الاختباري للمصادقة - لا يزال التحقق الكامل من الوجهة مطلوبًا\nالتحقق من صحة العنوان: - تحقق دائمًا من المجموع الاختباري (checksum) قبل الاستخدام - ارفض العناوين ذات أنواع التوقيع غير الصالحة - تحقق من أن المفتاح العام يقع على المنحنى (خاص بالتنفيذ)\nالمراجع: - المقترح 149: B32 لـ LS2 المشفّر - مواصفة عنونة B32 - مواصفة التسمية لـ I2P دعم المفاتيح غير المتصلة نظرة عامة تتيح المفاتيح غير المتصلة بالإنترنت إبقاء مفتاح التوقيع الرئيسي غير متصل بالإنترنت (التخزين البارد)، بينما يُستخدم مفتاح توقيع مؤقت للعمليات اليومية. يُعدّ ذلك بالغ الأهمية للخدمات عالية الأمان.\nمتطلبات خاصة بـ LS2 المشفّر: - يجب توليد المفاتيح المؤقتة دون اتصال بالإنترنت - يجب توليد المفاتيح الخاصة المُعمّاة (blinded) مسبقاً (مفتاح واحد يومياً) - تُسلَّم كلّ من المفاتيح المؤقتة والمفاتيح المُعمّاة على دفعات - لم يُحدَّد بعد معيار موحّد لصيغة الملف (TODO في المواصفة)\nبنية المفاتيح دون اتصال بيانات المفتاح المؤقتة للطبقة 0 (عندما يكون بت العلم 0 = 1):\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ تغطية التوقيع: يغطي التوقيع في كتلة المفتاح غير المتصل: - الطابع الزمني لانتهاء الصلاحية (4 بايتات) - نوع التوقيع المؤقت (2 بايتين) - مفتاح التوقيع العام المؤقت (متغير)\nيتم التحقق من هذا التوقيع باستخدام blinded public key (مفتاح عام خضع لتقنية التعمية العمياء)، مما يثبت أن الكيان الذي يمتلك blinded private key (مفتاح خاص خضع لتقنية التعمية العمياء) قد أجاز هذا المفتاح المؤقت.\nعملية توليد المفاتيح بالنسبة إلى LeaseSet مُشفَّر بمفاتيح غير متصلة:\nأنشئ أزواج مفاتيح مؤقتة (بدون اتصال، في التخزين البارد):\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\nلكل يوم for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026quot;%Y%m%d\u0026quot;) # \u0026quot;YYYYMMDD\u0026quot; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) 3. **Sign transient keys with blinded keys** (offline): ```python for date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router: لكل تاريخ delivery_package[date] = { 'transient_privkey': keys[date][0], 'transient_pubkey': keys[date][1], 'blinded_privkey': blinded_keys[date][0], 'blinded_pubkey': blinded_keys[date][1], 'offline_sig_block': offline_sig_blocks[date] }\n### Router Usage **Daily Key Loading:** ```python # عند منتصف الليل بتوقيت UTC (أو قبل النشر) date = datetime.utcnow().date() # حمّل مفاتيح اليوم today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # استخدم هذه المفاتيح لـ LeaseSet المشفّر لهذا اليوم Publishing Process:\n# 1. أنشئ LeaseSet2 داخلي inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. تشفير الطبقة الثانية layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. أنشئ الطبقة الأولى مع بيانات التخويل layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. شفّر الطبقة 1 layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. أنشئ الطبقة 0 مع كتلة توقيع دون اتصال layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ) # 6. وقّع الطبقة 0 باستخدام مفتاح خاص مؤقت signature = RED25519_SIGN(transient_privkey, layer0) # 7. ألحِق التوقيع ثم انشر encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# ولّد كلاً من المفاتيح المؤقتة الجديدة والمفاتيح المُعمّاة الجديدة يومياً for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - مجموعة من بيانات المفاتيح المشفّرة - الفترة الزمنية المشمولة OFFLINE_KEY_STATUS - عدد الأيام المتبقية - تاريخ انتهاء صلاحية المفتاح التالي REVOKE_OFFLINE_KEYS - نطاق التواريخ للإلغاء - مفاتيح جديدة للاستبدال (اختياري) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p Key Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# تفعيل LeaseSet المشفّر (بنية بيانات تنشر معلومات الاتصال الخاصة بوجهة داخل I2P) i2cp.encryptLeaseSet=true # اختياري: تمكين تخويل العميل i2cp.enableAccessList=true # اختياري: استخدم DH authorization (مصادقة باستخدام تبادل المفاتيح ديفي–هيلمان؛ الإعداد الافتراضي هو PSK (مفتاح مُشترك مُسبقاً)) i2cp.accessListType=0 # اختياري: سر الإعماء (موصى به بشدة) i2cp.blindingSecret=your-secret-here API Usage Example:\n// أنشئ LeaseSet مشفّر EncryptedLeaseSet els = new EncryptedLeaseSet(); // تعيين الوجهة els.setDestination(destination); // تمكين التخويل لكل عميل على حدة els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // أضف العملاء المصرّح لهم (مفاتيح DH العامة — خوارزمية ديفي-هيلمان) for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // اضبط معلمات الإعماء (blinding) els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // وقّع وانشر els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd Key Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # تفعيل LeaseSet المشفّر encryptleaseset = true # اختياري: نوع تخويل العميل (0=DH, 1=PSK) authtype = 0 # اختياري: Blinding secret (سر الإعماء) secret = السر-الخاص-بك-هنا # اختياري: العملاء المصرح لهم (واحد في كل سطر، مفاتيح عامة مرمزة بترميز base64) client.1 = base64-encoded-client-pubkey-1 client.2 = base64-encoded-client-pubkey-2 API Usage Example:\n// إنشاء LeaseSet مشفّر auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // تفعيل التخويل لكل عميل encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // إضافة العملاء المصرح لهم for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // وقّع وانشر encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# متجه الاختبار 1: Key blinding (إعماء المفتاح) destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # المتوقع: (تحقق بالمقارنة مع التنفيذ المرجعي) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets Red25519 Specification - Detailed Red25519 implementation B32 Addressing Specification - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # نقطة الأساس لـ Ed25519 (المولِّد) B = 2**255 - 19 # رتبة Ed25519 (حجم الحقل العددي) L = 2**252 + 27742317777372353535851937790883648493 # قيم أنواع التوقيع SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # أحجام المفاتيح PRIVKEY_SIZE = 32 # بايت PUBKEY_SIZE = 32 # بايت SIGNATURE_SIZE = 64 # بايت ChaCha20 Constants # معاملات ChaCha20 (خوارزمية تشفير تياري) CHACHA20_KEY_SIZE = 32 # bytes (256 bits) CHACHA20_NONCE_SIZE = 12 # bytes (96 bits) CHACHA20_INITIAL_COUNTER = 1 # RFC 7539 permits 0 or 1 HKDF Constants # معاملات HKDF (دالة اشتقاق المفاتيح المعتمدة على HMAC) HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # بايت (HashLen) # سلاسل info النصية الخاصة بـ HKDF (دالة اشتقاق مفاتيح مستندة إلى HMAC) (فصل المجالات) HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # سلاسل تخصيص SHA-256 HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # أحجام الطبقة 0 (الخارجية) BLINDED_SIGTYPE_SIZE = 2 # بايت BLINDED_PUBKEY_SIZE = 32 # بايت (خاصة بـ Red25519) PUBLISHED_TS_SIZE = 4 # بايت EXPIRES_SIZE = 2 # بايت FLAGS_SIZE = 2 # بايت LEN_OUTER_CIPHER_SIZE = 2 # بايت SIGNATURE_SIZE = 64 # بايت (Red25519) # أحجام كتل المفاتيح في وضع عدم الاتصال OFFLINE_EXPIRES_SIZE = 4 # بايت OFFLINE_SIGTYPE_SIZE = 2 # بايت OFFLINE_SIGNATURE_SIZE = 64 # بايت # أحجام الطبقة 1 (الوسطى) AUTH_FLAGS_SIZE = 1 # بايت EPHEMERAL_PUBKEY_SIZE = 32 # بايتات (مصادقة DH) AUTH_SALT_SIZE = 32 # بايتات (مصادقة PSK) NUM_CLIENTS_SIZE = 2 # بايتات CLIENT_ID_SIZE = 8 # بايتات CLIENT_COOKIE_SIZE = 32 # بايتات AUTH_CLIENT_ENTRY_SIZE = 40 # بايتات (CLIENT_ID + CLIENT_COOKIE) # العبء الإضافي للتشفير SALT_SIZE = 32 # بايت (يُضاف في المقدمة إلى كل طبقة مُشفّرة) # عنوان Base32 (ترميز أساس 32) B32_ENCRYPTED_DECODED_SIZE = 35 # بايت B32_ENCRYPTED_ENCODED_LEN = 56 # محارف B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# المفتاح العام للوجهة (Ed25519) A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # Empty secret Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 بايت salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) mod L Expected Output:\n(تحقق مقابل التنفيذ المرجعي) alpha = [قيمة سداسية عشرية بطول 64 بايت] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nالنص المشفّر = [تحقّق بمطابقته مع متجهات الاختبار الخاصة بـ RFC 7539] Test Vector 3: HKDF Input:\nsalt = bytes(32) # كلها أصفار ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [قيمة سداسية عشرية بطول 44 بايت] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32 بايت unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\naddress = [56 محارف base32].b32.i2p # تحقّق من أن التحقق من المجموع الاختباري يتم بشكل صحيح Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"تنسيق LeaseSet خاضع للتحكم في الوصول لـ Destinations الخاصة (وجهات I2P)","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"LeaseSet مشفر","url":"/ar/docs/specs/encryptedleaseset/"},{"categories":null,"content":" مهمل: تم تضمين SAM v2 مع I2P 0.6.1.31 ولم يعد يُصان. استخدم SAM v3 للتطوير الجديد. كان التحسين الوحيد في v2 مقارنةً بـ v1 هو دعم عدة مقابس مُتعددة الإرسال عبر اتصال SAM واحد.\nملاحظات الإصدار تظل سلسلة الإصدار المُبلّغ عنها \u0026ldquo;2.0\u0026rdquo;. اعتبارًا من 0.9.14 تقبل رسالة HELLO VERSION قيَم MIN/MAX المؤلفة من رقم واحد، ومعلمة MIN اختيارية. يدعم DEST GENERATE SIGNATURE_TYPE، لذا يمكن إنشاء وجهات Ed25519. أساسيات الجلسة SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] قد يكون لكل وجهة جلسة SAM نشطة واحدة فقط (تدفقات، datagrams (حزم بيانات غير متصلة)، أو خام). STYLE يختار التدفقات الافتراضية، datagrams الموقعة، أو datagrams الخام. تُمرَّر الخيارات الإضافية إلى I2CP (على سبيل المثال، tunnels.quantityInbound=3). الاستجابات مماثلة لـ v1: SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY. ترميز الرسائل ASCII القائم على الأسطر مع أزواج key=value مفصولة بمسافات (قد تُوضَع القيم بين علامات اقتباس). أنواع الاتصال هي نفسها كما في v1:\nتدفقات عبر مكتبة التدفق الخاصة بـ I2P داتاغرامات قابلة للرد (PROTO_DATAGRAM) داتاغرامات خام (PROTO_DATAGRAM_RAW) متى يجب استخدامه مخصص فقط للعملاء القديمة التي لا يمكنها الترحيل. يوفر SAM v3:\nتمرير الوجهة الثنائية (DEST GENERATE BASE64) دعم الجلسات الفرعية وDHT (جدول تجزئة موزع) (v3.3) تحسين الإبلاغ عن الأخطاء وتفاوض الخيارات راجع:\nSAM v1 SAM v3 واجهة برمجة تطبيقات الداتاغرام بروتوكول البث ","description":"البروتوكول القديم للمراسلة المجهولة البسيطة","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2","url":"/ar/docs/legacy/samv2/"},{"categories":null,"content":"SAM v3 (\u0026ldquo;Simple Anonymous Messaging\u0026rdquo;) هو واجهة برمجية مستقرة ومستقلة عن الموجه الحالية التي تتيح للتطبيقات الخارجية التواصل مع شبكة I2P دون الحاجة لتضمين الموجه نفسه. توفر وصولاً موحداً إلى التدفقات، ومخططات البيانات، والرسائل الخام، وتبقى طبقة الربط المعيارية للبرمجيات غير المبنية بلغة Java.\n1. نظرة عامة والغرض يُمكّن SAMv3 المطورين من بناء برمجيات متوافقة مع I2P بأي لغة برمجة باستخدام بروتوكول TCP/UDP خفيف الوزن. يقوم بتجريد العمليات الداخلية لل router، ويكشف عن مجموعة صغيرة من الأوامر عبر TCP (7656) و UDP (7655). كل من Java I2P و i2pd يُطبّقان مجموعات فرعية من مواصفات SAMv3، على الرغم من أن i2pd لا يزال يفتقر إلى معظم إضافات 3.2 و 3.3 حتى عام 2025.\n2. سجل الإصدارات Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. ### ملاحظة التسمية Java I2P يستخدم PRIMARY/SUBSESSION. i2pd و I2P+ يواصلان استخدام مصطلحات MASTER/SUBSESSION القديمة للتوافق مع الإصدارات السابقة. 3. سير العمل الأساسي التفاوض على الإصدار HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 إنشاء الوجهة DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512). موصى به بشدة منذ I2P 0.9.15. إنشاء الجلسة SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4 هو X25519 (ECIES X25519 AEAD Ratchet) و 0 هو ElGamal احتياطي للتوافق. كميات الأنفاق الصريحة للاتساق: الافتراضي في Java I2P 2، الافتراضي في i2pd 5. عمليات البروتوكول STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 أنواع الرسائل الأساسية تشمل: STREAM CONNECT، STREAM ACCEPT، STREAM FORWARD، DATAGRAM SEND، RAW SEND، NAMING LOOKUP، DEST LOOKUP، PING، QUIT.\nإيقاف تشغيل سلس QUIT 4. الاختلافات في التنفيذ (Java I2P مقابل i2pd) Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 **التوصية:** حدد دائمًا كميات الأنفاق بشكل صريح لضمان الاتساق عبر أجهزة التوجيه (routers). 5. المكتبات المدعومة (لقطة 2025) Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance ## 6. الميزات القادمة والجديدة (2024-2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ ## 7. ملاحظات الأمان والتكوين اربط SAM بـ 127.0.0.1 فقط. للخدمات الدائمة، استخدم جلسات PRIMARY مع مفاتيح ثابتة. استخدم HELLO VERSION لاختبار دعم الميزات. استخدم PING أو NAMING LOOKUP للتحقق من نشاط الـ router. تجنب اتصالات SAM البعيدة غير المصادق عليها (لا يوجد TLS في i2pd). 8. المراجع والمواصفات مواصفات SAM v3 SAM v2 (قديم) مواصفات البث المباشر Datagrams مركز التوثيق توثيق i2pd 9. الملخص يظل SAM v3 هو بروتوكول الجسر الموصى به لجميع تطبيقات I2P غير المبنية على Java. فهو يوفر الاستقرار، وروابط متعددة اللغات، وأداءً متسقًا عبر أنواع router المختلفة.\nعند التطوير باستخدام SAM: - استخدم توقيعات Ed25519 وتشفير X25519. - تحقق من دعم الميزات ديناميكيًا عبر HELLO VERSION. - صمم من أجل التوافق، خاصة عند دعم كل من Java I2P و i2pd routers.\n","description":"بروتوكول جسر مستقر لتطبيقات I2P غير المبنية على Java","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/ar/docs/api/samv3/"},{"categories":null,"content":" مهمل: يُحتفظ بـ SAM v1 لأغراض مرجعية تاريخية فقط. على التطبيقات الجديدة استخدام SAM v3 أو BOB . الجسر الأصلي يدعم فقط وجهات DSA-SHA1 ومجموعة محدودة من الخيارات.\nالمكتبات لا تزال شجرة الشيفرة المصدرية لـ Java I2P تتضمن bindings (واجهات ربط) قديمة للغات C وC# وPerl وPython. لم تعد هذه الواجهات قيد الصيانة، ويجري توزيعها أساساً من أجل التوافق الأرشيفي.\nتفاوض الإصدارات يتصل العملاء عبر TCP (الافتراضي 127.0.0.1:7656) ويتبادلون:\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 اعتبارًا من Java I2P 0.9.14 يكون المعامل MIN اختياريًا، وكلا MIN/MAX يقبلان صيغًا أحادية الرقم (\u0026quot;3\u0026quot; إلخ.) للجسور المُحدَّثة.\nإنشاء الجلسة SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name يقوم بتحميل أو إنشاء مُدخل في sam.keys؛ بينما TRANSIENT يُنشئ دائمًا وجهةً مؤقتة. STYLE يختار التدفقات الافتراضية (مشابه لـ TCP)، أو رُزم بيانات موقَّعة، أو رُزم بيانات خام. DIRECTION تنطبق على جلسات التدفق فقط؛ والقيمة الافتراضية هي BOTH. تُمرَّر أزواج المفتاح/القيمة الإضافية كما هي كخيارات I2CP (على سبيل المثال، tunnels.quantityInbound=3). يرد الجسر بما يلي:\nSESSION STATUS RESULT=OK DESTINATION=name تُرجِع حالات الفشل DUPLICATED_DEST أو I2P_ERROR أو INVALID_KEY بالإضافة إلى رسالة اختيارية.\nتنسيقات الرسائل رسائل SAM هي ASCII أحادية السطر مع أزواج مفتاح/قيمة مفصولة بمسافات. تكون المفاتيح بترميز UTF‑8؛ وقد تُحاط القيم بعلامات اقتباس إذا كانت تحتوي على مسافات. لا توجد آلية escaping (الهروب) معرفة.\nأنواع الاتصال:\nالتدفّقات – تُمرَّر عبر وكيل من خلال مكتبة I2P للتدفق داتاغرامات قابلة للرد – حمولات مُوقَّعة (Datagram1) داتاغرامات خام – حمولات غير مُوقَّعة (Datagram RAW) الخيارات المضافة في 0.9.14 DEST GENERATE يقبل SIGNATURE_TYPE=... (مما يسمح بـ Ed25519، إلخ.) HELLO VERSION يعتبر MIN اختيارياً ويقبل سلاسل إصدار مكوّنة من رقم واحد متى ينبغي استخدام SAM v1 فقط لضمان التوافق مع البرمجيات المتقادمة التي لا يمكن تحديثها. في جميع التطويرات الجديدة، استخدم:\nSAM v3 للوصول المتكامل الميزات إلى التدفق/الـdatagram (رزمة بيانات بلا اتصال) BOB لإدارة الوجهات (لا يزال محدوداً، لكنه يدعم ميزات أكثر حداثة) المراجع SAM v2 SAM v3 مواصفة الداتاغرام بروتوكول التدفق SAM v1 وضع الأساس لتطوير تطبيقات غير مرتبطة بـ router محدد، لكن النظام البيئي قد تطوّر. اعتبر هذا المستند وسيلة للتوافق لا نقطة انطلاق.\n","description":"بروتوكول Simple Anonymous Messaging (مراسلة مجهولة بسيطة) القديم (مهمل)","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM الإصدار 1","url":"/ar/docs/legacy/sam/"},{"categories":null,"content":" مهمل: تم استبدال SSU بـ SSU2. تمت إزالة الدعم من i2pd 2.44.0 (API 0.9.56، نوفمبر 2022) ومن Java I2P 2.4.0 (API 0.9.61، ديسمبر 2023).\nوفّر SSU آلية نقل بيانات شبه موثوقة قائمة على UDP مع تحكم في الازدحام، واجتياز NAT، ودعم introducer (آلية وسيط التعارف). وكان مكمِّلاً لـ NTCP من خلال التعامل مع routers الموجودة خلف NAT/جدران الحماية، ومن خلال تنسيق اكتشاف عنوان IP.\nعناصر العنوان transport: SSU caps: أعلام القدرات (B, C, 4, 6, إلخ.) host / port: مستمع IPv4 أو IPv6 (اختياري عند كونه خلف جدار ناري) key: مفتاح تعريف مرمّز بـ Base64 mtu: اختياري؛ القيمة الافتراضية 1484 (IPv4) / 1488 (IPv6) ihost/ikey/iport/itag/iexp: مدخلات المُعرِّف عند كون الـ router خلف جدار ناري الميزات اجتياز NAT تعاوني باستخدام introducers (عُقَد وسيطة للتعريف) اكتشاف عنوان IP المحلي عبر اختبارات الأقران وفحص الحزم الواردة نقل حالة الجدار الناري تلقائياً إلى بروتوكولات النقل الأخرى ووحدة تحكم router تسليم شبه موثوق: إعادة إرسال الرسائل حتى حد معيّن، ثم تُسقَط التحكم في الازدحام بزيادة إضافية/تقليل مضاعف وحقول بت لتأكيد الأجزاء تولّت SSU أيضًا مهام البيانات الوصفية مثل منارات التوقيت والتفاوض على MTU (الحد الأقصى لحجم وحدة الإرسال). باتت جميع الوظائف الآن متاحة (مع تشفير حديث) عبر SSU2 .\n","description":"النقل عبر UDP الآمن شبه الموثوق الأصلي","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (قديم)","url":"/ar/docs/legacy/ssu/"},{"categories":null,"content":" ملاحظة تاريخية: تحتفظ هذه الصفحة بنقاش “Unidirectional Tunnels” القديم للرجوع إليه. يُرجى الرجوع إلى توثيق تنفيذ tunnel المعمول به للاطلاع على السلوك الحالي.\nنظرة عامة يبني I2P tunnels أحادية الاتجاه: يحمل tunnel واحد المرور الصادر، ويحمل tunnel منفصل الاستجابات الواردة. تعود هذه البنية إلى أقدم تصاميم الشبكات وتظل عامل تمييز رئيسي عن أنظمة الدوائر ثنائية الاتجاه مثل Tor. للمصطلحات وتفاصيل التنفيذ، انظر نظرة عامة على tunnel ومواصفة tunnel .\nمراجعة Unidirectional tunnels (أنفاق أحادية الاتجاه) تبقي حركة مرور الطلبات والاستجابات منفصلة، لذا فإن أي مجموعة واحدة من النظراء المتواطئين تلاحظ فقط نصف رحلة ذهاب وإياب. هجمات التوقيت يجب أن تتقاطع مع اثنين من tunnel pools (الواردة والصادرة) بدلاً من تحليل دائرة واحدة، مما يرفع عتبة الربط. تتيح المجمعات الواردة والصادرة المستقلة لـ routers ضبط الكمون والسعة وخصائص التعامل مع الإخفاقات لكل اتجاه. تشمل السلبيات زيادة تعقيد إدارة النظراء والحاجة إلى الحفاظ على مجموعات tunnel متعددة لضمان تقديم خدمة موثوقة. إخفاء الهوية تتناول ورقة Hermann و Grothoff، I2P is Slow… and What to Do About It ، هجمات السلف ضد tunnels أحادية الاتجاه، مشيرةً إلى أن خصوماً عازمين يمكنهم في نهاية المطاف تأكيد هوية نظراء ذوي عمر طويل. تفيد ملاحظات المجتمع بأن الدراسة تعتمد على افتراضات محددة بشأن صبر الخصم وصلاحياته القانونية، ولا تُوازن هذا النهج مقابل هجمات التوقيت التي تؤثر في التصاميم ثنائية الاتجاه. وتستمر الأبحاث والخبرة العملية في تعزيز اعتبار tunnels أحادية الاتجاه خياراً متعمداً لإخفاء الهوية لا مجرد سهو.\n","description":"ملخص تاريخي لتصميم tunnel أحادي الاتجاه الخاص بـ I2P.","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"Tunnels أحادية الاتجاه","url":"/ar/docs/legacy/unidirectional/"},{"categories":null,"content":" الحالة: هذا مرجع موجز لأداة v3dgsend. وهو يكمل وثائق واجهة برمجة التطبيقات Datagram وSAM v3 .\nنظرة عامة v3dgsend هو أداة سطر أوامر مساعدة لإرسال البيانات المجزأة (datagrams) عبر I2P باستخدام واجهة SAMv3. وهو مفيد لاختبار تسليم البيانات المجزأة، وإنشاء نماذج أولية للخدمات، والتحقق من سلوك النظام من البداية إلى النهاية دون الحاجة لكتابة عميل كامل.\nالاستخدامات النموذجية تشمل:\nاختبار سريع لقابلية الوصول إلى البيانات المجزأة (datagram) نحو وجهة معينة التحقق من صحة إعدادات جدار الحماية ودفتر العناوين التجربة مع البيانات المجزأة الخام مقابل الموقّعة (القابلة للرد) الاستخدام يختلف الاستدعاء الأساسي حسب المنصة والحزمة. تشمل الخيارات الشائعة:\nالوجهة: Destination بصيغة base64 أو اسم .i2p البروتوكول: raw (PROTOCOL 18) أو signed (PROTOCOL 17) الحمولة: نص مضمن أو إدخال من ملف راجع حزم التوزيعة الخاصة بك أو مخرجات --help للحصول على الأعلام الدقيقة.\nانظر أيضًا Datagram API SAM v3 Streaming Library (بديل للـ datagrams) ","description":"أداة سطر الأوامر لإرسال رسائل البيانات عبر I2P باستخدام SAM v3","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/ar/docs/api/v3dgsend/"},{"categories":null,"content":"نظرة عامة توسّع هذه المواصفة موجز اشتراك العناوين بإضافة أوامر، مما يمكّن خوادم الأسماء من بثّ تحديثات الإدخالات من مالكي أسماء المضيف. طُرحت أصلاً في Proposal 112 (سبتمبر 2014)، ونُفِّذت في الإصدار 0.9.26 (يونيو 2016)، ونُشرت على مستوى الشبكة بحالة CLOSED.\nظلّ النظام مستقرًا دون تغيير منذ تنفيذه الأولي، وما يزال يعمل بالطريقة نفسها في I2P 2.10.0 (Router API 0.9.65، سبتمبر 2025).\nالدوافع في السابق، كانت خوادم الاشتراك الخاصة بـ hosts.txt ترسل البيانات فقط بتنسيق hosts.txt بسيط:\nexample.i2p=b64destination أدى هذا التنسيق الأساسي إلى عدة مشكلات:\nلا يستطيع حاملو أسماء المضيفين تحديث Destination (عنوان الوجهة في I2P) المرتبطة بأسماء مضيفيهم (على سبيل المثال، لترقية مفتاح التوقيع إلى نوعٍ تشفيري أقوى). لا يستطيع حاملو أسماء المضيفين التخلّي عن أسمائهم بشكلٍ اعتباطي. يجب عليهم تسليم المفاتيح الخاصة بـ Destination المقابلة مباشرةً إلى الحامل الجديد. لا توجد وسيلة لتوثيق أن نطاقاً فرعياً يخضع لسيطرة اسم المضيف الأساسي المقابل. يُطبَّق هذا حالياً فقط بشكلٍ فردي من قِبل بعض خوادم الأسماء. التصميم تضيف هذه المواصفة أسطر أوامر إلى تنسيق hosts.txt. وباستخدام هذه الأوامر، يمكن لخوادم الأسماء توسيع خدماتها لتقديم ميزات إضافية. ويمكن للعملاء الذين ينفّذون هذه المواصفة ترقّب هذه الميزات عبر عملية الاشتراك الاعتيادية.\nيجب توقيع جميع أسطر الأوامر من قِبل Destination المناظرة (هوية الوجهة في I2P). وهذا يضمن أن تُجرى التغييرات فقط بناءً على طلب مالك اسم المضيف.\nالتداعيات الأمنية هذه المواصفة لا تؤثر على إخفاء الهوية.\nهناك زيادة في المخاطر المرتبطة بفقدان السيطرة على مفتاح Destination (الوجهة في I2P)، إذ إن من يحصل عليه يمكنه استخدام هذه الأوامر لإجراء تغييرات على أي أسماء مضيفين مرتبطة بها. ومع ذلك، فهذه ليست مشكلة أكبر من الوضع القائم، حيث يمكن لمن يحصل على Destination انتحال اسم مضيف والسيطرة (جزئياً) على حركة المرور الخاصة به. ويقابل هذا الخطر المتزايد منح مالكي أسماء المضيفين القدرة على تغيير الـ Destination المرتبطة باسم مضيف في حال اعتقدوا أن الـ Destination قد تعرضت للاختراق. وهذا غير ممكن في النظام الحالي.\nالمواصفات أنواع السطور الجديدة هناك نوعان جديدان من الأسطر:\nأوامر الإضافة والتغيير: example.i2p=b64destination#!key1=val1#key2=val2... إزالة الأوامر: #!key1=val1#key2=val2... الترتيب ليس الموجز بالضرورة مرتبا أو مكتملا. على سبيل المثال، قد يظهر أمر change في سطر قبل أمر add، أو من دون وجود أمر add.\nيمكن أن تأتي المفاتيح بأي ترتيب. لا يُسمح بوجود مفاتيح مكررة. جميع المفاتيح والقيم حساسة لحالة الأحرف.\nالمفاتيح الشائعة مطلوب في جميع الأوامر:\nsig : توقيع Base64، باستخدام مفتاح التوقيع من الوجهة\nإشارات إلى اسم مضيف ثانٍ و/أو وجهة:\noldname : اسم مضيف ثانٍ (جديد أو مُعدَّل)\nolddest : وجهة Base64 ثانية (جديدة أو معدّلة)\noldsig : توقيع Base64 ثانٍ، باستخدام مفتاح التوقيع من olddest\nمفاتيح شائعة أخرى:\nإجراء : أمر\nname : اسم المضيف، يظهر فقط إذا لم يسبقه example.i2p=b64dest\ndest : الوجهة بصيغة Base64، توجد فقط إذا لم يسبقها example.i2p=b64dest\ndate : بالثواني منذ epoch (بداية 1 يناير/كانون الثاني 1970 بالتوقيت العالمي المنسق UTC)\nexpires : بالثواني منذ epoch (بداية وقت يونكس)\nالأوامر يجب أن تحتوي جميع الأوامر، باستثناء الأمر \u0026ldquo;Add\u0026rdquo;، على زوج مفتاح/قيمة action=command.\nلأغراض التوافق مع العملاء الأقدم، تسبق معظم الأوامر بـ example.i2p=b64dest، كما هو مذكور أدناه. وبالنسبة للتغييرات، تُعرض دائمًا القيم الجديدة. وأي قيم قديمة تُدرج في قسم المفتاح/القيمة.\nالمفاتيح المُدرجة مطلوبة. قد تحتوي جميع الأوامر على عناصر مفتاح/قيمة إضافية غير معرّفة هنا.\nإضافة اسم المضيف مسبوق بـ example.i2p=b64dest : نعم، هذا هو اسم المضيف والوجهة الجديدان.\naction : غير مُتضمَّنة، فهي مفهومة ضمناً.\nsig : توقيع\nمثال:\nexample.i2p=b64dest#!sig=b64sig تغيير اسم المضيف مسبوق بـ example.i2p=b64dest : نعم، هذا هو اسم المضيف الجديد والوجهة القديمة.\nالإجراء : changename\noldname : اسم المضيف القديم، ليتم استبداله\nsig : توقيع\nمثال:\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig تغيير الوجهة مسبوق بـ example.i2p=b64dest : نعم، هذا هو اسم المضيف القديم والوجهة الجديدة.\naction : changedest\nolddest : الوجهة القديمة المراد استبدالها\noldsig : توقيع باستخدام olddest\nsig : التوقيع\nمثال:\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig إضافة اسم مستعار لاسم المضيف مسبوق بـ example.i2p=b64dest : نعم، هذا هو اسم المضيف الجديد (اسم مستعار) والوجهة القديمة.\nإجراء : addname\noldname : اسم المضيف القديم\nsig : توقيع\nمثال:\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig إضافة اسم مستعار للوجهة (تُستخدم لترقية التشفير)\nمسبوق بـ example.i2p=b64dest : نعم، هذا هو اسم المضيف القديم والوجهة الجديدة (البديلة).\nالإجراء : adddest\nolddest : الوجهة القديمة\noldsig : توقيع باستخدام olddest\nsig : توقيع باستخدام dest\nمثال:\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig إضافة نطاق فرعي مسبوق بـ subdomain.example.i2p=b64dest : نعم، هذا هو اسم النطاق الفرعي والوجهة الجديدان.\nالإجراء : addsubdomain\noldname : اسم المضيف ذو المستوى الأعلى (example.i2p)\nolddest : الوجهة ذات المستوى الأعلى (على سبيل المثال example.i2p)\noldsig : توقيع باستخدام olddest\nsig : توقيع باستخدام dest\nمثال:\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig تحديث البيانات الوصفية مسبوق بـ example.i2p=b64dest : نعم، هذا هو اسم المضيف والوجهة القديمان.\nإجراء : تحديث\nsig : توقيع\n(أضف أي مفاتيح مُحدَّثة هنا)\nمثال:\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig إزالة اسم المضيف مسبوق بـ example.i2p=b64dest : لا، هذه تُحدَّد في الخيارات\nالإجراء : إزالة\nالاسم : اسم المضيف\ndest : الوجهة\nsig : التوقيع\nمثال:\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig إزالة الكل المرتبط بهذه الوجهة يُسبق بـ example.i2p=b64dest : لا، هذه تُحدد في الخيارات\naction : removeall\ndest : الوجهة\nsig : توقيع\nمثال:\n#!action=removeall#dest=b64dest#sig=b64sig التواقيع يجب أن تُوقَّع جميع الأوامر من قِبل الوجهة المقابلة. قد تتطلب الأوامر ذات الوجهتين توقيعين.\noldsig هي دائمًا \u0026ldquo;التوقيع الداخلي\u0026rdquo;. وقّع وتحقّق من دون وجود أيٍ من مفتاحي oldsig أو sig. sig هو دائمًا \u0026ldquo;التوقيع الخارجي\u0026rdquo;. وقّع وتحقّق مع وجود مفتاح oldsig ولكن من دون وجود مفتاح sig.\nمدخلات التواقيع لإنتاج تيار بايت بغرض إنشاء التوقيع أو التحقق منه، قم بتسلسل البيانات كما يلي:\nأزِل مفتاح sig إذا كان التحقق باستخدام oldsig، فأزِل أيضًا مفتاح oldsig بالنسبة لأوامر Add أو Change فقط، أخرج example.i2p=b64dest إذا بقيت أي مفاتيح، فأخرج #! رتّب الخيارات حسب مفتاح UTF-8، وافشل إذا وُجدت مفاتيح مكررة لكل زوج مفتاح/قيمة، أخرج key=value، يتبعه (إذا لم يكن زوج المفتاح/القيمة الأخير) علامة # ملاحظات\nلا تُخرج سطرًا جديدًا ترميز الإخراج هو UTF-8 يكون ترميز جميع الوجهات والتواقيع بصيغة Base 64 باستخدام أبجدية I2P المفاتيح والقيم حسّاسة لحالة الأحرف يجب أن تكون أسماء المضيفين بأحرف صغيرة أنواع التواقيع الحالية اعتبارًا من I2P 2.10.0، الأنواع التالية من التواقيع مدعومة للوجهات:\nEdDSA_SHA512_Ed25519 (Type 7): الأكثر شيوعًا للوجهات منذ 0.9.15. يستخدم مفتاحًا عامًا بطول 32 بايت وتوقيعًا بطول 64 بايت. هذا هو نوع التوقيع الموصى به للوجهات الجديدة. RedDSA_SHA512_Ed25519 (Type 13): متاح للوجهات وleasesets (leaseSet: مجموعة عناوين الإيجار في I2P) المشفّرة فقط (منذ 0.9.39). الأنواع القديمة (DSA_SHA1، ومتغيرات ECDSA): لا تزال مدعومة لكنها مُهمّلة للاستخدام في Router Identities (هويات الـ Router في I2P) الجديدة اعتبارًا من 0.9.58. ملاحظة: تتوفر خيارات التشفير ما بعد الكم اعتبارًا من I2P 2.10.0، لكنها ليست بعد أنواع التوقيع الافتراضية.\nالتوافق تُنفَّذ جميع الأسطر الجديدة في تنسيق hosts.txt باستخدام أحرف التعليق البادئة (#!)، لذا ستُفسِّر جميع إصدارات I2P الأقدم الأوامر الجديدة على أنها تعليقات وتتجاهلها بسلاسة.\nعندما تقوم I2P routers بالتحديث إلى المواصفة الجديدة، لن تعيد تفسير التعليقات القديمة، لكنها ستبدأ بالاستماع إلى الأوامر الجديدة خلال عمليات الجلب اللاحقة لخلاصات اشتراكها. لذا من المهم أن تقوم خوادم الأسماء بالاحتفاظ بإدخالات الأوامر بطريقة ما، أو تمكين دعم ETag (معرّف تمييز النسخة في HTTP) حتى تتمكن routers من جلب جميع الأوامر السابقة.\nحالة التنفيذ النشر الأولي: الإصدار 0.9.26 (7 يونيو 2016)\nالحالة الحالية: مستقرة ولم تتغير حتى الإصدار I2P 2.10.0 (Router API 0.9.65، سبتمبر 2025)\nحالة المقترح: مغلق (تم نشره بنجاح على مستوى الشبكة)\nموضع التنفيذ: apps/addressbook/java/src/net/i2p/addressbook/ في الـ router (الموجّه) الخاص بـ I2P والمكتوب بلغة Java\nالفئات الرئيسية: - SubscriptionList.java: يدير معالجة الاشتراكات - Subscription.java: يتعامل مع خلاصات الاشتراك الفردية - AddressBook.java: الوظائف الأساسية لدفتر العناوين - Daemon.java: خدمة الخلفية لدفتر العناوين\nعنوان URL الافتراضي للاشتراك: http://i2p-projekt.i2p/hosts.txt\nتفاصيل النقل تستخدم الاشتراكات HTTP مع دعم GET الشرطي:\nترويسة ETag: تدعم كشف التغييرات بكفاءة ترويسة Last-Modified: تتعقب أوقات تحديث الاشتراكات 304 Not Modified: ينبغي للخوادم إرجاع هذه الحالة عندما لم يتغير المحتوى Content-Length: يُوصى بها بشدة لجميع الاستجابات يستخدم I2P router سلوك عميل HTTP القياسي مع دعم مناسب للتخزين المؤقت.\nسياق الإصدار ملاحظة حول ترقيم إصدارات I2P: ابتداءً من الإصدار 1.5.0 تقريبًا (أغسطس 2021)، انتقلت I2P من ترقيم 0.9.x إلى الترقيم الدلالي (1.x، 2.x، إلخ). ومع ذلك، يواصل الإصدار الداخلي لـ Router API استخدام ترقيم 0.9.x حفاظًا على التوافق مع الإصدارات السابقة. اعتبارًا من أكتوبر 2025، الإصدار الحالي هو I2P 2.10.0 مع إصدار Router API 0.9.65.\nكُتبت وثيقة المواصفات هذه في الأصل للإصدار 0.9.49 (فبراير 2021)، ولا تزال دقيقة تمامًا بالنسبة للإصدار الحالي 0.9.65 (I2P 2.10.0)، لأن نظام خلاصات الاشتراك لم يطرأ عليه أي تغيير منذ تنفيذه الأصلي في 0.9.26.\nالمراجع المقترح 112 (الأصلي) المواصفة الرسمية توثيق نظام التسمية في I2P مواصفة البُنى المشتركة مستودع الشيفرة المصدرية لـ I2P مستودع I2P على Gitea التطورات ذات الصلة على الرغم من أن نظام خلاصات الاشتراك نفسه لم يتغير، قد تكون التطورات التالية ذات الصلة في البنية التحتية للتسمية الخاصة بـ I2P محل اهتمام:\nأسماء Base32 الموسّعة (0.9.40+): دعم عناوين base32 بطول 56+ محرفًا لـ leaseSets المُشفّرة. لا يؤثر في صيغة موجز الاشتراك. تسجيل نطاق المستوى الأعلى .i2p.alt (TLD) (RFC 9476، أواخر 2023): تسجيل رسمي لدى GANA لـ .i2p.alt بوصفه TLD بديلًا. قد تزيل تحديثات router المستقبلية لاحقة .alt، لكن لا تتطلب أوامر الاشتراك أي تغييرات. التشفير ما بعد الكمّ (2.10.0+): متاح لكنه ليس الإعداد الافتراضي. سيُنظر مستقبلاً في خوارزميات التوقيع ضمن خلاصات الاشتراك. ","description":"امتداد لتغذيات الاشتراك بالعناوين يتيح لمالكي أسماء المضيف تحديث سجلاتهم وإدارتها","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"أوامر خلاصة اشتراك العناوين","url":"/ar/docs/specs/subscription/"},{"categories":null,"content":"اقرأ دليل المطورين الجدد أولاً.\nالإرشادات الأساسية وأسلوب البرمجة معظم ما يلي يجب أن يكون بديهيًا لأي شخص عمل على برمجيات مفتوحة المصدر أو في بيئة برمجة تجارية. ما يلي ينطبق في الغالب على فرع التطوير الرئيسي i2p.i2p. قد تختلف الإرشادات لفروع أخرى والإضافات والتطبيقات الخارجية بشكل كبير؛ تحقق مع المطور المناسب للحصول على التوجيه.\nالمجتمع من فضلك لا تكتفي بكتابة الكود فقط. إذا استطعت، شارك في أنشطة التطوير الأخرى، بما في ذلك: مناقشات التطوير والدعم على IRC وi2pforum.i2p؛ الاختبار؛ الإبلاغ عن الأخطاء والرد عليها؛ التوثيق؛ مراجعة الكود؛ إلخ. يجب أن يكون المطورون النشطون متاحين بشكل دوري على IRC #i2p-dev. كن على دراية بدورة الإصدار الحالية. التزم بمعالم الإصدار مثل تجميد الميزات، تجميد الوسوم، والموعد النهائي للتسجيل الخاص بالإصدار. دورة الإصدار دورة الإصدار العادية هي 10-16 أسبوعاً، أربعة إصدارات في السنة. فيما يلي المواعيد النهائية التقريبية ضمن دورة نموذجية مدتها 13 أسبوعاً. يتم تحديد المواعيد النهائية الفعلية لكل إصدار من قبل مدير الإصدار بعد التشاور مع الفريق بأكمله.\nبعد 1-2 يوم من الإصدار السابق: يُسمح بعمليات الإيداع (Check-ins) إلى الجذع (trunk). بعد 2-3 أسابيع من الإصدار السابق: الموعد النهائي لنشر التغييرات الرئيسية من الفروع الأخرى إلى الجذع. قبل 4-5 أسابيع من الإصدار: الموعد النهائي لطلب روابط جديدة للصفحة الرئيسية. قبل 3-4 أسابيع من الإصدار: تجميد الميزات (Feature freeze). الموعد النهائي للميزات الجديدة الرئيسية. قبل 2-3 أسابيع من الإصدار: عقد اجتماع المشروع لمراجعة طلبات روابط الصفحة الرئيسية الجديدة، إن وُجدت. قبل 10-14 يومًا من الإصدار: تجميد النصوص (String freeze). لا مزيد من التغييرات على النصوص المترجمة (الموسومة). دفع النصوص إلى Transifex، والإعلان عن الموعد النهائي للترجمة على Transifex. قبل 10-14 يومًا من الإصدار: الموعد النهائي للميزات. إصلاحات الأخطاء فقط بعد هذا الوقت. لا مزيد من الميزات أو إعادة الهيكلة أو التنظيف. قبل 3-4 أيام من الإصدار: الموعد النهائي للترجمة. سحب الترجمات من Transifex وإيداعها. قبل 3-4 أيام من الإصدار: الموعد النهائي للإيداع. لا يُسمح بالإيداعات بعد هذا الوقت دون إذن من منشئ الإصدار. قبل ساعات من الإصدار: الموعد النهائي لمراجعة الكود. Git امتلك فهمًا أساسيًا لأنظمة التحكم بالمصدر الموزعة، حتى لو لم تستخدم git من قبل. اطلب المساعدة إذا احتجت إليها. بمجرد الدفع، تصبح عمليات الإدخال دائمة؛ لا يوجد تراجع. يُرجى توخي الحذر. إذا لم تستخدم git من قبل، ابدأ بخطوات صغيرة. قم بإدخال بعض التغييرات الصغيرة وانظر كيف تسير الأمور. اختبر تغييراتك قبل إدخالها. إذا كنت تفضل نموذج التطوير القائم على الإدخال قبل الاختبار، استخدم فرع التطوير الخاص بك في حسابك الخاص، وأنشئ MR بمجرد الانتهاء من العمل. لا تعطل عملية البناء. لا تتسبب في تراجعات. في حالة حدوث ذلك (يحدث أحيانًا)، يُرجى عدم الاختفاء لفترة طويلة بعد دفع تغييرك. إذا كان تغييرك غير تافه، أو كنت تريد من الناس اختباره وتحتاج إلى تقارير اختبار جيدة لمعرفة ما إذا تم اختبار تغييرك أم لا، أضف تعليق إدخال إلى history.txt وقم بزيادة مراجعة البناء في RouterVersion.java. لا تُدخل تغييرات كبيرة في الفرع الرئيسي i2p.i2p في وقت متأخر من دورة الإصدار. إذا كان المشروع سيستغرق أكثر من يومين، أنشئ فرعك الخاص في git، في حسابك الخاص، وقم بالتطوير هناك حتى لا تعيق الإصدارات. بالنسبة للتغييرات الكبيرة (بشكل عام، أكثر من 100 سطر، أو تمس أكثر من ثلاثة ملفات)، قم بإدخالها في فرع جديد على حساب GitLab الخاص بك، وأنشئ MR، وعيّن مراجعًا. عيّن MR لنفسك. ادمج MR بنفسك بمجرد موافقة المراجع عليه. لا تنشئ فروع WIP في حساب I2P_Developers الرئيسي (باستثناء i2p.www). تنتمي WIP إلى حسابك الخاص. عند الانتهاء من العمل، أنشئ MR. يجب أن تكون الفروع الوحيدة في الحساب الرئيسي للفروع الحقيقية، مثل إصدار نقطي. قم بالتطوير بطريقة شفافة ومع وضع المجتمع في الاعتبار. أدخل التغييرات بشكل متكرر. أدخل أو ادمج في الفرع الرئيسي بأكبر قدر ممكن من التكرار، بالنظر إلى الإرشادات المذكورة أعلاه. إذا كنت تعمل على مشروع كبير في فرعك/حسابك الخاص، أخبر الناس حتى يتمكنوا من المتابعة والمراجعة/الاختبار/التعليق. أسلوب البرمجة أسلوب البرمجة في معظم أنحاء الكود هو 4 مسافات للمسافة البادئة. لا تستخدم علامات التبويب. لا تعد تنسيق الكود. إذا كان محرر IDE أو المحرر الخاص بك يريد إعادة تنسيق كل شيء، فتحكم فيه. في بعض الأماكن، يختلف أسلوب البرمجة. استخدم الحس السليم. قلّد الأسلوب الموجود في الملف الذي تقوم بتعديله. جميع الفئات والطرق العامة والخاصة بالحزمة الجديدة تتطلب Javadocs. أضف @since رقم-الإصدار. يُفضل وجود Javadocs للطرق الخاصة الجديدة. بالنسبة لأي Javadocs مضافة، يجب ألا تكون هناك أي أخطاء أو تحذيرات doclint. قم بتشغيل ant javadoc مع Oracle Java 14 أو أعلى للتحقق. يجب أن تحتوي جميع المعاملات على أسطر @param، ويجب أن تحتوي جميع الطرق غير الفارغة على أسطر @return، ويجب أن تحتوي جميع الاستثناءات المعلنة على أسطر @throws، وعدم وجود أخطاء HTML. الفئات الموجودة في core/ (i2p.jar) وأجزاء من i2ptunnel هي جزء من API الرسمي الخاص بنا. هناك العديد من الإضافات والتطبيقات الأخرى خارج الشجرة التي تعتمد على هذا API. كن حذرًا حتى لا تقوم بإجراء أي تغييرات تكسر التوافق. لا تضف طرقًا إلى API ما لم تكن ذات فائدة عامة. يجب أن تكون Javadocs لطرق API واضحة وكاملة. إذا أضفت أو غيرت API، قم أيضًا بتحديث الوثائق على الموقع الإلكتروني (فرع i2p.www). ضع علامة على السلاسل النصية للترجمة عند الاقتضاء، وهو ما ينطبق على جميع سلاسل واجهة المستخدم. لا تغير السلاسل النصية المميزة الموجودة ما لم يكن ذلك ضروريًا حقًا، لأنه سيكسر الترجمات الموجودة. لا تضف أو تغير السلاسل النصية المميزة بعد تجميد العلامات في دورة الإصدار حتى تتاح للمترجمين فرصة التحديث قبل الإصدار. استخدم الأنواع العامة والفئات المتزامنة حيثما أمكن. I2P هو تطبيق متعدد الخيوط بشكل كبير. كن على دراية بالمزالق الشائعة في Java التي يتم اكتشافها بواسطة FindBugs/SpotBugs. قم بتشغيل ant findbugs لمعرفة المزيد. يُطلب Java 8 لبناء وتشغيل I2P اعتبارًا من الإصدار 0.9.47. لا تستخدم فئات أو طرق Java 7 أو 8 في الأنظمة الفرعية المضمنة: addressbook، core، i2ptunnel.jar (غير UI)، mstreaming، router، routerconsole (الأخبار فقط)، streaming. تُستخدم هذه الأنظمة الفرعية بواسطة Android والتطبيقات المضمنة التي تتطلب Java 6 فقط. يجب أن تكون جميع الفئات متاحة في Android API 14. ميزات لغة Java 7 مقبولة في هذه الأنظمة الفرعية إذا كانت مدعومة من الإصدار الحالي من Android SDK وتم تجميعها إلى كود متوافق مع Java 6. لا يمكن استخدام Try‑with‑resources في الأنظمة الفرعية المضمنة لأنها تتطلب java.lang.AutoCloseable في وقت التشغيل، وهذا غير متاح حتى Android API 19 (KitKat 4.4). لا يمكن استخدام حزمة java.nio.file في الأنظمة الفرعية المضمنة لأنها غير متاحة حتى Android API 26 (Oreo 8). بخلاف القيود المذكورة أعلاه، يمكن استخدام فئات وطرق وتراكيب Java 8 في الأنظمة الفرعية التالية فقط: BOB، desktopgui، i2psnark، i2ptunnel.war (UI)، jetty‑i2p.jar، jsonrpc، routerconsole (باستثناء الأخبار)، SAM، susidns، susimail، systray. يمكن لمؤلفي الإضافات طلب أي إصدار Java كحد أدنى عبر ملف plugin.config. قم بالتحويل صراحةً بين الأنواع البدائية والفئات؛ لا تعتمد على autoboxing/unboxing. لا تستخدم URL. استخدم URI. لا تلتقط Exception. التقط RuntimeException والاستثناءات المفحوصة بشكل فردي. لا تستخدم String.getBytes() بدون معامل مجموعة أحرف UTF‑8. يمكنك أيضًا استخدام DataHelper.getUTF8() أو DataHelper.getASCII(). حدد دائمًا مجموعة أحرف UTF‑8 عند قراءة أو كتابة الملفات. قد تكون أدوات DataHelper مفيدة. حدد دائمًا لغة (على سبيل المثال Locale.US) عند استخدام String.toLowerCase() أو String.toUpperCase(). لا تستخدم String.equalsIgnoreCase()، حيث لا يمكن تحديد لغة. لا تستخدم String.split(). استخدم DataHelper.split(). لا تضف كودًا لتنسيق التواريخ والأوقات. استخدم DataHelper.formatDate() و DataHelper.formatTime(). تأكد من إغلاق InputStreams و OutputStreams في كتل finally. استخدم {} لجميع كتل for و while، حتى لو كان سطرًا واحدًا فقط. إذا استخدمت {} لأي من كتل if أو else أو if-else، استخدمها لجميع الكتل. ضع } else { على سطر واحد. حدد الحقول كـ final حيثما أمكن. لا تخزن I2PAppContext أو RouterContext أو Log أو أي مراجع أخرى لعناصر router أو السياق في حقول ثابتة. لا تبدأ الخيوط في المُنشئات. استخدم I2PAppThread بدلاً من Thread. السجلات تنطبق الإرشادات التالية على الموجه (router)، وتطبيقات الويب، وجميع الإضافات.\nبالنسبة لأي رسائل لا تُعرض في مستوى السجل الافتراضي (WARN، INFO، وDEBUG)، ما لم تكن الرسالة نصاً ثابتاً (بدون دمج نصوص)، استخدم دائماً log.shouldWarn()، log.shouldInfo()، أو log.shouldDebug() قبل استدعاء السجل لتجنب الحمل غير الضروري على الكائنات. يجب أن تكون رسائل السجل التي قد تُعرض في مستوى السجل الافتراضي (ERROR، CRIT، وlogAlways()) مختصرة وواضحة ومفهومة للمستخدم غير التقني. يشمل ذلك نص سبب الاستثناء الذي قد يُعرض أيضاً. فكر في الترجمة إذا كان من المحتمل حدوث الخطأ (على سبيل المثال، عند أخطاء إرسال النماذج). خلاف ذلك، الترجمة ليست ضرورية، لكن قد يكون من المفيد البحث عن سلسلة نصية موجودة بالفعل ومُعلّمة للترجمة في مكان آخر وإعادة استخدامها. رسائل السجل التي لا تُعرض في مستوى السجل الافتراضي (WARN، INFO، وDEBUG) مخصصة لاستخدام المطورين، ولا تخضع للمتطلبات المذكورة أعلاه. ومع ذلك، رسائل WARN متاحة في تبويب سجل Android، وقد تكون مفيدة للمستخدمين في تصحيح المشكلات، لذا استخدم بعض الحذر مع رسائل WARN أيضاً. يجب استخدام رسائل سجل INFO وDEBUG بشكل مقتصد، خاصة في مسارات الكود الحرجة (hot code paths). على الرغم من فائدتها أثناء التطوير، فكر في إزالتها أو تعطيلها بالتعليقات بعد اكتمال الاختبار. لا تسجل في stdout أو stderr (سجل wrapper). التراخيص قم فقط بإيداع الكود الذي كتبته بنفسك. قبل إيداع أي كود أو ملفات JAR من مكتبات من مصادر أخرى، قدم مبرراً لضرورة ذلك، وتحقق من توافق الترخيص، واحصل على موافقة من مدير الإصدار. إذا حصلت على موافقة لإضافة كود خارجي أو ملفات JAR، وكانت الملفات الثنائية متاحة في أي حزمة Debian أو Ubuntu، يجب عليك تنفيذ خيارات البناء والتعبئة لاستخدام الحزمة الخارجية بدلاً من ذلك. قائمة الملفات التي يجب تعديلها: build.properties، build.xml، debian/control، debian/i2p-router.install، debian/i2p-router.links، debian/rules، sub-build.xml. بالنسبة لأي صور يتم إيداعها من مصادر خارجية، تقع على عاتقك مسؤولية التحقق أولاً من توافق الترخيص. قم بتضمين معلومات الترخيص والمصدر في تعليق الإيداع. الأخطاء إدارة المشكلات هي مسؤولية الجميع؛ يرجى المساعدة. راقب GitLab للعثور على المشكلات التي يمكنك المساعدة فيها. قم بالتعليق على المشكلات وإصلاحها وإغلاقها إذا استطعت. يجب على المطورين الجدد البدء بإصلاح المشكلات. عندما يكون لديك إصلاح، قم بإرفاق الرقعة الخاصة بك بالمشكلة وأضف الكلمة المفتاحية review-needed. لا تغلق المشكلة حتى تتم مراجعتها بنجاح وتتحقق من تغييراتك. بمجرد القيام بذلك بسلاسة لزوجين من التذاكر، يمكنك اتباع الإجراء العادي أعلاه. أغلق المشكلة عندما تعتقد أنك أصلحتها. ليس لدينا قسم اختبار للتحقق من التذاكر وإغلاقها. إذا لم تكن متأكداً من أنك أصلحتها، أغلقها وأضف ملاحظة تقول \u0026ldquo;أعتقد أنني أصلحتها، يرجى الاختبار وإعادة الفتح إذا كانت لا تزال معطلة\u0026rdquo;. أضف تعليقاً برقم بناء التطوير أو المراجعة وحدد المرحلة للإصدار التالي. ","description":"إرشادات شاملة للمساهمة في I2P: سير العمل، دورة الإصدار، أسلوب البرمجة، التسجيل، الترخيص، ومعالجة المشكلات","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"إرشادات المطورين وأسلوب البرمجة","url":"/ar/docs/develop/dev-guidelines/"},{"categories":null,"content":"الهدف: الحفاظ على الاتساق والدقة وقابلية الوصول عبر وثائق I2P التقنية\nالمبادئ الأساسية 1. تحقق من كل شيء لا تفترض أو تخمّن أبدًا. يجب التحقق من جميع التصريحات التقنية مقابل: - الشيفرة المصدرية الحالية لـ I2P (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master ) - التوثيق الرسمي لـ API (https://i2p.github.io/i2p.i2p/ - مواصفات التهيئة /docs/specs/ - ملاحظات الإصدارات الأخيرة /releases/ مثال على التحقق السليم:\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. الأولوية للوضوح على الإيجاز اكتب للمطورين الذين قد يتعرّفون على I2P (مشروع الإنترنت غير المرئي) للمرة الأولى. اشرح المفاهيم بصورة وافية بدلاً من افتراض وجود معرفة مسبقة.\nمثال:\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. إمكانية الوصول أولاً يجب أن تكون الوثائق متاحة للمطورين على clearnet (الإنترنت العام) رغم أن I2P عبارة عن شبكة تراكبية. وفّر دائمًا بدائل قابلة للوصول عبر clearnet لموارد I2P الداخلية.\nالدقة التقنية توثيق واجهات برمجة التطبيقات والواجهات قم دائمًا بتضمين: 1. أسماء الحزم كاملة عند أول ذكر: net.i2p.app.ClientApp 2. تواقيع الأساليب كاملة مع أنواع الإرجاع 3. أسماء المعاملات وأنواعها 4. المعاملات المطلوبة مقابل الاختيارية\nمثال:\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. خصائص الإعداد عند توثيق ملفات التهيئة: 1. اعرض أسماء الخصائص بدقة 2. حدّد ترميز الملف (UTF-8 لملفات تهيئة I2P) 3. قدّم أمثلة كاملة 4. وثّق القيم الافتراضية 5. اذكر الإصدار الذي أُدخلت/تغيّرت فيه الخصائص\nمثال:\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) الثوابت والتعدادات عند توثيق الثوابت، استخدم أسماء الشيفرة الفعلية:\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; التمييز بين المفاهيم المتشابهة يحتوي I2P على عدة أنظمة متداخلة. احرص دائماً على توضيح أي نظام تقوم بتوثيقه:\nمثال:\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations روابط التوثيق والمراجع قواعد إمكانية الوصول لعناوين URL المراجع الأساسية ينبغي أن تستخدم عناوين URL قابلة للوصول عبر clearnet (الإنترنت العام خارج I2P) عناوين I2P الداخلية (نطاقات .i2p) يجب أن تتضمّن ملاحظات حول إمكانية الوصول احرص دائماً على توفير بدائل عند وضع روابط إلى موارد I2P الداخلية قالب لعناوين URL الداخلية الخاصة بـ I2P:\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ عناوين URL مرجعية موصى بها لـ I2P المواصفات الرسمية: - التهيئة - الإضافة - فهرس الوثائق توثيق واجهة برمجة التطبيقات (API) (اختر الأحدث): - الأحدث: https://i2p.github.io/i2p.i2p/ (API 0.9.66 اعتباراً من I2P 2.10.0) - مرآة Clearnet (الإنترنت العام): https://eyedeekay.github.io/javadoc-i2p/ الشيفرة المصدرية: - GitLab (الرسمي): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master - مرآة GitHub: https://github.com/i2p/i2p.i2p معايير تنسيق الروابط ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text تتبع الإصدارات البيانات الوصفية للمستند يجب أن يتضمن كل مستند تقني البيانات الوصفية للإصدار في frontmatter (قسم البيانات التمهيدية في أعلى الملف):\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- تعريفات الحقول: - lastUpdated: السنة-الشهر لتاريخ آخر مراجعة/تحديث للمستند - accurateFor: إصدار I2P الذي تم التحقق من المستند مقابله - reviewStatus: إحدى القيم \u0026ldquo;draft\u0026rdquo;، \u0026ldquo;needs-review\u0026rdquo;، \u0026ldquo;verified\u0026rdquo;، \u0026ldquo;outdated\u0026rdquo;\nمراجع الإصدارات في المحتوى عند الإشارة إلى الإصدارات: 1. استخدم عريض للإصدار الحالي: \u0026ldquo;الإصدار 2.10.0 (سبتمبر 2025)\u0026rdquo; 2. اذكر رقم الإصدار وتاريخه في المراجع التاريخية 3. دوّن إصدار واجهة برمجة التطبيقات (API) بشكل منفصل عن إصدار I2P عند الاقتضاء\nمثال:\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. توثيق التغييرات مع مرور الوقت بالنسبة للميزات التي تطورت:\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients إشعارات إيقاف الدعم عند توثيق الميزات المهملة:\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. معايير المصطلحات مصطلحات I2P الرسمية استخدم هذه المصطلحات بالضبط على نحو متسق:\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address ### مصطلحات العميل المُدار عند توثيق العملاء المُدارين:\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory ### مصطلحات التهيئة Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config ### أسماء الحزم والأصناف احرص على استخدام الأسماء المؤهَّلة بالكامل عند أول ذكر، ثم استخدم الأسماء القصيرة بعد ذلك:\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... أمثلة على التعليمات البرمجية والتنسيق أمثلة على التعليمات البرمجية لـ Java استخدم تمييز بناء الجملة بشكل صحيح وأمثلة كاملة:\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` متطلبات مثال الشيفرة: 1. تضمين تعليقات تشرح الأسطر الأساسية 2. إظهار معالجة الأخطاء حيثما كان ذلك مناسبا 3. استخدام أسماء متغيرات واقعية 4. مطابقة اصطلاحات ترميز I2P (مسافة بادئة من 4 مسافات) 5. إظهار جمل الاستيراد إن لم تكن واضحة من السياق\nأمثلة التكوين اعرض أمثلة تكوين كاملة وصحيحة:\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` أمثلة سطر الأوامر استخدم $ لأوامر المستخدم، و# للمستخدم الجذر:\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` كود ضمن السطر استخدم backticks (العلامات المعكوسة) لـ: - أسماء الأساليب: startup() - أسماء الأصناف: ClientApp - أسماء الخصائص: clientApp.0.main - أسماء الملفات: clients.config - الثوابت: SVC_HTTP_PROXY - أسماء الحِزم: net.i2p.app\nالنبرة والصوت احترافي لكنه سهل الفهم اكتب لجمهور تقني من دون نبرة استعلاء:\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; المبني للمعلوم استخدموا صيغة المبني للمعلوم لتحقيق الوضوح:\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; الصيغة الأمرية في التعليمات استخدم صيغ الأمر المباشرة في المحتوى الإجرائي:\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; تجنّب المصطلحات غير الضرورية اشرح المصطلحات عند أول استخدام:\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) إرشادات علامات الترقيم لا تستخدم em-dashes (الشرطات الطويلة) - استخدم شرطات عادية، أو فواصل، أو فواصل منقوطة بدلاً منها استخدم Oxford comma (فاصلة أوكسفورد) في القوائم: \u0026ldquo;console, i2ptunnel, and Jetty\u0026rdquo; النقاط داخل كتل الشيفرة فقط عند الضرورة النحوية القوائم التسلسلية تستخدم الفواصل المنقوطة عندما تحتوي العناصر على فواصل بنية المستند ترتيب الأقسام القياسي لوثائق واجهة برمجة التطبيقات:\nنظرة عامة - ما الذي تفعله الميزة، ولماذا توجد التنفيذ - كيفية تنفيذها/استخدامها التهيئة - كيفية تهيئتها مرجع واجهة برمجة التطبيقات (API) - أوصاف تفصيلية للأساليب/الخصائص أمثلة - أمثلة كاملة تعمل أفضل الممارسات - نصائح وتوصيات سجل الإصدارات - متى قُدمت، والتغييرات مع مرور الوقت المراجع - روابط إلى وثائق ذات صلة هرمية العناوين استخدم مستويات العناوين الدلالية:\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** مربعات المعلومات استخدم كتل الاقتباس للتنبيهات الخاصة:\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. القوائم والتنظيم القوائم غير المرتبة للعناصر غير المتسلسلة:\n- First item - Second item - Third item القوائم المرتبة للخطوات المتسلسلة:\n1. First step 2. Second step 3. Third step قوائم التعاريف لشرح المصطلحات:\n**Term One** : Explanation of term one **Term Two** : Explanation of term two الأخطاء الشائعة التي يجب تجنبها 1. الخلط بين الأنظمة المتشابهة لا تخلط بين: - سجل ClientAppManager مقابل PortMapper - أنواع tunnel الخاصة بـ i2ptunnel مقابل ثوابت خدمة port mapper - ClientApp مقابل RouterApp (سياقات مختلفة) - العملاء المُدارون مقابل العملاء غير المُدارين\nوضّح دائمًا أي نظام تتحدث عنه:\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. مراجع إلى إصدارات قديمة لا تفعل: - الإشارة إلى الإصدارات القديمة على أنها \u0026ldquo;الحالية\u0026rdquo; - وضع روابط إلى وثائق واجهة برمجة التطبيقات (API) المتقادّمة - استخدام تواقيع أساليب مهملة في الأمثلة\nقم بما يلي: - تحقّق من ملاحظات الإصدار قبل النشر - تحقّق من أن توثيق واجهة برمجة التطبيقات (API) يطابق الإصدار الحالي - حدّث الأمثلة لاستخدام أفضل الممارسات الحالية\n3. عناوين URL يتعذر الوصول إليها لا تفعل: - لا تضع روابط فقط إلى نطاقات .i2p من دون بدائل على الإنترنت العام (clearnet) - لا تستخدم روابط التوثيق المعطّلة أو القديمة - لا تضع روابط إلى مسارات file:// محلية\nافعل: - وفّر بدائل clearnet (الإنترنت العام) لجميع روابط I2P الداخلية - تحقّق من إمكانية الوصول إلى عناوين URL قبل النشر - استخدم عناوين URL دائمة (geti2p.net، وليس استضافة مؤقتة)\n4. أمثلة على الشيفرة غير المكتملة لا تفعل: - عرض مقتطفات بدون سياق - إهمال معالجة الأخطاء - استخدام متغيرات غير معرّفة - تجاوز عبارات الاستيراد عندما لا يكون ذلك واضحًا\nافعل: - اعرض أمثلة كاملة قابلة للترجمة - أدرج معالجة الأخطاء اللازمة - اشرح ما يفعله كل سطر مهم - اختبر الأمثلة قبل النشر\n5. عبارات ملتبسة ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; اتفاقيات Markdown (لغة ترميز مبسطة) تسمية الملفات استخدم صيغة kebab-case (تنسيق تسمية يفصل الكلمات بشرطات وصل (-)) لأسماء الملفات:\nmanaged-clients.md port-mapper-guide.md configuration-reference.md تنسيق Frontmatter (البيانات التعريفية التمهيدية) احرص دائماً على تضمين مقدمة YAML:\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- تنسيق الروابط الروابط الداخلية (ضمن الوثائق):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) روابط خارجية (إلى موارد أخرى):\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) روابط مستودعات الشيفرة:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) تنسيق الجداول استخدم جداول Markdown بنكهة GitHub:\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | وسوم لغة كتل الشيفرة حدد دائمًا اللغة لتمييز بناء الجملة:\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` قائمة التحقق للمراجعة قبل نشر التوثيق، تحقّق مما يلي:\nتم التحقق من جميع الادعاءات التقنية مقابل الشيفرة المصدرية أو التوثيق الرسمي أرقام الإصدارات والتواريخ محدّثة جميع عناوين URL قابلة للوصول من clearnet (الإنترنت العام/المكشوف) (أو تم توفير بدائل) أمثلة الشيفرة مكتملة ومختبرة المصطلحات تتبع اصطلاحات I2P بدون em-dashes (استخدم الشرطات العادية أو علامات ترقيم أخرى) الـ Frontmatter (بيانات تمهيدية في رأس الملف) مكتملة ودقيقة التسلسل الهرمي للعناوين دلالي (h1 → h2 → h3) القوائم والجداول منسّقة بشكل صحيح قسم المراجع يتضمن جميع المصادر المذكورة المستند يتبع إرشادات البنية النبرة مهنية ولكن يسهل فهمها يتم التمييز بوضوح بين المفاهيم المتشابهة لا توجد روابط أو مراجع معطلة أمثلة الضبط صالحة ومحدّثة الملاحظات: إذا وجدت مشكلات أو كانت لديك اقتراحات بشأن هذه الإرشادات، يُرجى تقديمها عبر قنوات تطوير I2P الرسمية.\n","description":"الحفاظ على الاتساق والدقة وإمكانية الوصول في جميع الوثائق التقنية الخاصة بـ I2P","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"إرشادات كتابة وثائق I2P","url":"/ar/docs/writing-guidelines/"},{"categories":null,"content":"نظرة عامة يوفّر هذا المستند مواصفة تقنية شاملة لملفات تهيئة I2P المستخدمة بواسطة router وتطبيقات متعددة. ويغطي مواصفات تنسيق الملفات، وتعريفات الخصائص، وتفاصيل التنفيذ التي جرى التحقق منها بمقارنتها مع الشفرة المصدرية لـ I2P والوثائق الرسمية.\nالنطاق ملفات إعداد Router وتنسيقاتها إعدادات تطبيقات العميل إعدادات I2PTunnel tunnel مواصفات تنسيقات الملفات والتنفيذ ميزات خاصة بالإصدار والميزات المهملة ملاحظات التنفيذ تُقرأ وتُكتب ملفات التهيئة باستخدام أسلوبي DataHelper.loadProps() وstoreProps() في مكتبة I2P الأساسية. يختلف تنسيق الملف اختلافًا كبيرًا عن التنسيق المسلسل المستخدم في بروتوكولات I2P (انظر مواصفة البنى العامة - تعيين الأنواع ).\nالتنسيق العام لملف الإعدادات تتبع ملفات تهيئة I2P صيغة خصائص Java المعدّلة، مع استثناءات وقيود محددة.\nمواصفات التنسيق استنادًا إلى Java Properties (خصائص Java) مع الفروق الجوهرية التالية:\nالترميز يجب استخدام ترميز UTF-8 (وليس ISO-8859-1 كما في خصائص Java القياسية) التنفيذ: يستخدم دوال DataHelper.getUTF8() المساعدة لجميع عمليات الملفات تسلسلات الهروب لا يتم التعرف على أي تسلسلات هروب (بما في ذلك الشرطة المائلة العكسية \\) استمرار السطر غير مدعوم تُعامل أحرف الشرطة المائلة العكسية كأحرف حرفية محارف التعليق يبدأ # تعليقًا في أي موضع على السطر يبدأ ; تعليقًا فقط عندما يكون في العمود 1 (أي في بداية السطر) ! لا يبدأ تعليقًا (يختلف عن Java Properties) فواصل المفتاح والقيمة = هو الفاصل الوحيد المعتمد بين المفتاح والقيمة : غير معترف به كفاصل المسافات البيضاء غير معترف بها كفاصل التعامل مع المسافات البيضاء المسافات البيضاء في البداية والنهاية لا تُزال من المفاتيح المسافات البيضاء في البداية والنهاية تُزال من القيم معالجة الأسطر يتم تجاهل الأسطر التي لا تحتوي على = (تُعامل كتعليقات أو أسطر فارغة) القيم الفارغة (key=) مدعومة ابتداءً من الإصدار 0.9.10 تُخزَّن المفاتيح ذات القيم الفارغة وتُسترجع بشكل طبيعي قيود الأحرف يجب ألّا تحتوي المفاتيح على: - # (علامة الشباك/علامة الباوند) - = (علامة يساوي) - \\n (محرف سطر جديد) - لا يمكن أن تبدأ بـ ; (فاصلة منقوطة)\nلا يجوز أن تحتوي القيم على: - # (علامة الهاش/الشباك) - \\n (محرف سطر جديد) - لا يمكن أن تبدأ أو تنتهي بـ \\r (محرف إرجاع العربة) - لا يمكن أن تبدأ أو تنتهي بمحارف بيضاء (تُزال تلقائيًا)\nفرز الملفات لا يشترط ترتيب ملفات الإعداد حسب المفتاح. ومع ذلك، تقوم معظم تطبيقات I2P بترتيب المفاتيح أبجديًا عند كتابة ملفات الإعداد لتسهيل: - التحرير اليدوي - عمليات diff (المقارنة) في أنظمة التحكم في الإصدارات - قابلية القراءة البشرية\nتفاصيل التنفيذ قراءة ملفات الإعداد // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) السلوك: - يقرأ ملفات مُرمَّزة بترميز UTF-8 - يفرض جميع قواعد التنسيق الموضَّحة أعلاه - يتحقق من قيود الأحرف - يُرجِع كائن Properties فارغًا إذا كان الملف غير موجودًا - يرمي IOException عند أخطاء القراءة\nكتابة ملفات الإعداد // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) السلوك: - يكتب ملفات مُرمّزة بترميز UTF-8 - يرتّب المفاتيح أبجديًا (ما لم تُستخدم OrderedProperties (فئة تُحافظ على ترتيب الخصائص)) - يضبط أذونات الملف إلى الوضع 600 (قراءة/كتابة للمستخدم فقط) اعتبارًا من الإصدار 0.8.1 - يرمي IllegalArgumentException عند وجود أحرف غير صالحة في المفاتيح أو القيم - يرمي IOException عند أخطاء الكتابة\nالتحقق من صحة التنسيق يُجري التنفيذ تحققًا صارمًا: - يتم فحص المفاتيح والقيم بحثًا عن أحرف محظورة - تؤدي الإدخالات غير الصالحة إلى طرح استثناءات أثناء عمليات الكتابة - تتجاهل القراءة بصمت الأسطر غير السليمة (الأسطر التي لا تحتوي على =)\nأمثلة التنسيق ملف ضبط صالح # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは أمثلة على تكوينات غير صالحة # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value المكتبة الأساسية وإعدادات Router إعدادات العملاء (clients.config) الموقع: $I2P_CONFIG_DIR/clients.config (قديمة) أو $I2P_CONFIG_DIR/clients.config.d/ (حديثة) واجهة الإعداد: وحدة تحكم Router في /configclients تغيير التنسيق: الإصدار 0.9.42 (أغسطس 2019)\nبنية المجلدات (الإصدار 0.9.42+) اعتباراً من الإصدار 0.9.42، يُقسَّم ملف clients.config الافتراضي تلقائياً إلى ملفات تهيئة مستقلة:\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) سلوك الترحيل: - عند التشغيل لأول مرة بعد الترقية إلى 0.9.42+، يتم تقسيم الملف الأحادي تلقائيًا - الخصائص في الملفات المُقسَّمة تُسبَق بـ clientApp.0. - لا يزال التنسيق القديم مدعومًا للتوافق العكسي - يُمكّن التنسيق المُقسَّم التغليف المعياري وإدارة الإضافات\nتنسيق الخاصية تكون الأسطر بالشكل clientApp.x.prop=val، حيث إن x هو رقم التطبيق.\nمتطلبات ترقيم التطبيق: - يجب أن يبدأ بـ 0 - يجب أن يكون متسلسلاً (من دون فجوات) - الترتيب يحدد تسلسل بدء التشغيل\nالخصائص المطلوبة رئيسي النوع: String (اسم فئة مؤهَّل بالكامل) مطلوب: نعم الوصف: سيتم استدعاء المنشئ أو الطريقة main() في هذه الفئة اعتمادًا على نوع العميل (مُدار مقابل غير مُدار) مثال: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner خصائص اختيارية الاسم النوع: سلسلة نصية إلزامي: لا الوصف: الاسم المعروض في لوحة تحكم router مثال: clientApp.0.name=Router Console args النوع: سلسلة نصية (مفصولة بمسافة أو محرف جدولة) مطلوب: لا الوصف: الوسيطات المُمرَّرة إلى باني الفئة الرئيسية أو إلى الدالة main() الاقتباس: يمكن وضع الوسيطات التي تحتوي على مسافات أو محارف جدولة بين علامتي اقتباس \u0026rsquo; أو \u0026quot; مثال: clientApp.0.args=-d $CONFIG/eepsite تأخير النوع: عدد صحيح (ثوانٍ) مطلوب: لا الافتراضي: 120 الوصف: عدد الثواني المراد انتظارها قبل بدء تشغيل العميل التجاوزات: يتم تجاوزه بواسطة onBoot=true (يضبط التأخير على 0) القيم الخاصة: \u0026lt; 0: انتظر حتى يصل الـ router إلى حالة RUNNING، ثم ابدأ فورًا في خيط (thread) جديد = 0: شغّل فورًا في الخيط نفسه (تنتقل الاستثناءات إلى وحدة التحكم) \u0026gt; 0: ابدأ بعد تأخير في خيط جديد (تُسجَّل الاستثناءات ولا تُمرَّر) onBoot النوع: Boolean مطلوب: لا الافتراضي: false الوصف: يفرض تأخيرًا مقداره 0، ويتجاوز إعداد التأخير المحدّد صراحةً حالة الاستخدام: بدء الخدمات الحرجة على الفور عند إقلاع router startOnLoad النوع: قيمة منطقية مطلوب: لا القيمة الافتراضية: true الوصف: ما إذا كان يجب بدء تشغيل العميل على الإطلاق حالة الاستخدام: تعطيل العملاء دون إزالة التكوين خصائص خاصة بالمكوّن الإضافي هذه الخصائص تُستخدم فقط بواسطة الإضافات (وليس العملاء الأساسيين):\nstopargs النوع: سلسلة نصية (مفصولة بمسافة أو علامة تبويب) الوصف: الوسائط الممررة لإيقاف العميل استبدال المتغيرات: نعم (انظر أدناه) uninstallargs النوع: سلسلة نصية (مفصولة بمسافة أو محرف جدولة) الوصف: المعاملات المُمرَّرة لإلغاء تثبيت العميل استبدال المتغيرات: نعم (انظر أدناه) مسار الأصناف النوع: سلسلة نصية (مسارات مفصولة بفواصل) الوصف: عناصر مسار الأصناف (classpath) الإضافية للعميل استبدال المتغيرات: نعم (انظر أدناه) استبدال المتغيرات (للمكونات الإضافية فقط) يتم استبدال المتغيّرات التالية في args وstopargs وuninstallargs وclasspath للملحقات:\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 **ملاحظة**: يُجرى استبدال المتغيرات فقط للإضافات، وليس للعملاء الأساسيين. أنواع العملاء العملاء المُدارون يتم استدعاء المُنشئ مع معاملي RouterContext وClientAppManager يجب على العميل تنفيذ واجهة ClientApp يتم التحكم في دورة الحياة بواسطة router يمكن بدء تشغيله وإيقافه وإعادة تشغيله بشكل ديناميكي عملاء غير مُدارين يتم استدعاء الطريقة main(String[] args) يتم تشغيله في خيط منفصل دورة الحياة لا تُدار بواسطة router نوع عميل قديم مثال على التكوين # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true تكوين المسجل (logger.config) الموقع: $I2P_CONFIG_DIR/logger.config واجهة التهيئة: وحدة تحكم Router عند /configlogging\nمرجع الخصائص إعدادات المخزن المؤقت لوحدة التحكم logger.consoleBufferSize النوع: عدد صحيح القيمة الافتراضية: 20 الوصف: العدد الأقصى لرسائل السجل المراد تخزينها مؤقتًا في وحدة التحكم النطاق: 1-1000 مُوصى به تنسيق التاريخ والوقت logger.dateFormat النوع: String (نمط SimpleDateFormat) القيمة الافتراضية: من الإعدادات المحلية للنظام مثال: HH:mm:ss.SSS التوثيق: Java SimpleDateFormat مستويات السجل logger.defaultLevel النوع: تعداد القيمة الافتراضية: ERROR القيم: CRIT, ERROR, WARN, INFO, DEBUG الوصف: مستوى التسجيل الافتراضي لجميع الأصناف logger.minimumOnScreenLevel النوع: Enum القيمة الافتراضية: CRIT القيم: CRIT, ERROR, WARN, INFO, DEBUG الوصف: أدنى مستوى للرسائل المعروضة على الشاشة logger.record.{class} النوع: تعداد القيم: CRIT, ERROR, WARN, INFO, DEBUG الوصف: تجاوز مستوى التسجيل لكل فئة مثال: logger.record.net.i2p.router.transport.udp=DEBUG خيارات العرض logger.displayOnScreen النوع: منطقي القيمة الافتراضية: true الوصف: ما إذا كان يجب عرض رسائل السجل في إخراج وحدة التحكم logger.dropDuplicates النوع: منطقي القيمة الافتراضية: true الوصف: تجاهل رسائل السجل المتكررة المتتالية logger.dropOnOverflow النوع: منطقي الافتراضي: false الوصف: إسقاط الرسائل عند امتلاء المخزن المؤقت (بدلاً من الحظر (blocking)) سلوك التفريغ logger.flushInterval النوع: عدد صحيح (ثوانٍ) القيمة الافتراضية: 29 منذ: الإصدار 0.9.18 الوصف: مدى تكرار تفريغ المخزن المؤقت للسجل إلى القرص إعدادات التنسيق logger.format النوع: سلسلة (تسلسل محارف) الوصف: قالب تنسيق رسالة السجل أحرف التنسيق: d = التاريخ/الوقت c = اسم الصنف t = اسم الخيط p = الأولوية (مستوى السجل) m = الرسالة مثال: dctpm ينتج [الطابع الزمني] [الصنف] [الخيط] [المستوى] الرسالة الضغط (الإصدار 0.9.56+) logger.gzip النوع: منطقي القيمة الافتراضية: false منذ: الإصدار 0.9.56 الوصف: تمكين ضغط gzip لملفات السجل المدوّرة logger.minGzipSize النوع: عدد صحيح (بايت) القيمة الافتراضية: 65536 منذ: الإصدار 0.9.56 الوصف: الحد الأدنى لحجم الملف لتفعيل الضغط (افتراضيًا 64 كيلوبايت) إدارة الملفات logger.logBufferSize النوع: عدد صحيح (بايتات) القيمة الافتراضية: 1024 الوصف: أقصى عدد من الرسائل لتخزينها مؤقتًا قبل التفريغ logger.logFileName النوع: سلسلة نصية (مسار ملف) القيمة الافتراضية: logs/log-@.txt الوصف: نمط تسمية ملف السجل (@ يتم استبداله برقم التدوير) logger.logFilenameOverride النوع: سلسلة (مسار ملف) الوصف: تجاوز لاسم ملف السجل (يعطل نمط تدوير السجلات) logger.logFileSize النوع: سلسلة نصية (حجم بوحدة قياس) القيمة الافتراضية: 10M الوحدات: K (كيلوبايت)، M (ميجابايت)، G (جيجابايت) مثال: 50M، 1G logger.logRotationLimit النوع: عدد صحيح القيمة الافتراضية: 2 الوصف: أعلى رقم لملف تدوير السجل (log-0.txt إلى log-N.txt) تكوين نموذجي # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN تكوين الملحق إعدادات كل مكوّن إضافي على حدة (plugins/*/plugin.config) الموقع: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config التنسيق: تنسيق ملف تهيئة I2P القياسي التوثيق: مواصفات الإضافة الخصائص المطلوبة الاسم النوع: سلسلة نصية مطلوب: نعم الوصف: اسم العرض للمكوّن الإضافي مثال: name=I2P Plugin Example مفتاح النوع: String (مفتاح عام) إلزامي: نعم (يُحذف للمكونات الإضافية الموقعة بـ SU3) الوصف: المفتاح العام لتوقيع المكون الإضافي لأغراض التحقق الصيغة: مفتاح توقيع مرمز بصيغة Base64 الموقّع النوع: سلسلة نصية مطلوب: نعم الوصف: هوية موقّع الملحق مثال: signer=user@example.i2p الإصدار النوع: سلسلة نصية (صيغة VersionComparator «مقارنة الإصدارات») مطلوب: نعم الوصف: إصدار المكوّن الإضافي للتحقق من التحديثات الصيغة: نظام الإصدار الدلالي (Semantic Versioning) أو صيغة قابلة للمقارنة مخصّصة مثال: version=1.2.3 خصائص العرض تاريخ النوع: Long (طابع زمني Unix بالميلي ثانية) الوصف: تاريخ إصدار المكوّن الإضافي المؤلف النوع: سلسلة نصية الوصف: اسم مؤلف المكوّن الإضافي websiteURL النوع: سلسلة نصية (URL) الوصف: عنوان URL لموقع الإضافة updateURL النوع: سلسلة نصية (URL) الوصف: عنوان URL للتحقق من التحديث للمكوّن الإضافي updateURL.su3 النوع: سلسلة نصية (URL) منذ: الإصدار 0.9.15 الوصف: عنوان URL لتحديث بتنسيق SU3 (مفضل) الوصف النوع: سلسلة نصية الوصف: وصف المكوّن الإضافي باللغة الإنجليزية الوصف_{language} النوع: سلسلة نصية الوصف: وصف المكوّن الإضافي المُوطَّن مثال: description_de=Deutsche Beschreibung الترخيص النوع: سلسلة نصية الوصف: معرّف ترخيص الإضافة مثال: license=Apache 2.0 خصائص التثبيت dont-start-at-install النوع: Boolean القيمة الافتراضية: false الوصف: منع التشغيل التلقائي بعد التثبيت يلزم إعادة تشغيل الـ router النوع: منطقي الافتراضي: false الوصف: يتطلب إعادة تشغيل router بعد التثبيت للتثبيت فقط النوع: Boolean (قيمة منطقية) القيمة الافتراضية: false الوصف: تثبيت مرة واحدة فقط (لا تحديثات) update-only (تحديث فقط) Type: Boolean (قيمة منطقية) Default: false Description: تحديث التثبيت الحالي فقط (بدون تثبيت جديد) مثال على تهيئة الملحق # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false إعدادات الملحقات العامة (plugins.config) الموقع: $I2P_CONFIG_DIR/plugins.config الغرض: تمكين/تعطيل الإضافات المثبتة بشكل شامل\nتنسيق الخاصية plugin.{name}.startOnLoad=true|false {name}: اسم الإضافة من plugin.config startOnLoad: ما إذا كان يجب تشغيل الإضافة عند بدء تشغيل router مثال plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false إعدادات تطبيقات الويب (webapps.config) الموقع: $I2P_CONFIG_DIR/webapps.config الغرض: تمكين/تعطيل وتهيئة تطبيقات الويب\nتنسيق الخاصية webapps.{name}.startOnLoad النوع: قيمة منطقية الوصف: ما إذا كان سيتم تشغيل تطبيق ويب عند بدء تشغيل router الصيغة: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath النوع: سلسلة نصية (مسارات مفصولة بمسافة أو فاصلة) الوصف: عناصر classpath (مسار فئات جافا) إضافية لتطبيق الويب التنسيق: webapps.{name}.classpath=[paths] استبدال المتغيرات تدعم المسارات عمليات استبدال المتغيرات التالية:\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps #### حلّ Classpath (مسار الأصناف) تطبيقات الويب الأساسية: مسارات نسبية بالنسبة إلى $I2P/lib تطبيقات الويب الإضافية: مسارات نسبية بالنسبة إلى $CONFIG/plugins/{appname}/lib مثال على التهيئة # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar تكوين Router (router.config) الموقع: $I2P_CONFIG_DIR/router.config واجهة الإعداد: وحدة تحكم Router على /configadvanced الغرض: إعدادات Router الأساسية ومعلمات الشبكة\nفئات الإعدادات تكوين الشبكة إعدادات عرض النطاق الترددي:\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 إعدادات النقل:\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true سلوك Router # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 إعدادات وحدة التحكم # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true إعداد الوقت # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org ملاحظة: إعدادات router شاملة. راجع وحدة تحكم router في /configadvanced للحصول على مرجع كامل للخصائص.\nملفات تهيئة التطبيق إعدادات دفتر العناوين (addressbook/config.txt) الموقع: $I2P_CONFIG_DIR/addressbook/config.txt التطبيق: SusiDNS الغرض: حل أسماء المضيفين وإدارة دفتر العناوين\nمواقع الملفات router_addressbook القيمة الافتراضية: ../hosts.txt الوصف: دفتر العناوين الرئيسي (أسماء المضيفين على مستوى النظام) التنسيق: تنسيق ملف hosts القياسي privatehosts.txt الموقع: $I2P_CONFIG_DIR/addressbook/privatehosts.txt الوصف: تعيينات أسماء المضيفين الخاصة الأولوية: الأعلى (يتجاوز جميع المصادر الأخرى) userhosts.txt الموقع: $I2P_CONFIG_DIR/addressbook/userhosts.txt الوصف: تعيينات أسماء المضيفين التي أضافها المستخدم الإدارة: عبر واجهة SusiDNS hosts.txt الموقع: $I2P_CONFIG_DIR/addressbook/hosts.txt الوصف: دفتر عناوين عام تم تنزيله المصدر: خلاصات الاشتراك خدمة التسمية BlockfileNamingService (خدمة تسمية ملفات الكتل) (الإعداد الافتراضي منذ 0.8.8) تنسيق التخزين: - الملف: hostsdb.blockfile - الموقع: $I2P_CONFIG_DIR/addressbook/ - الأداء: ~10x أسرع في عمليات البحث من hosts.txt - التنسيق: تنسيق قاعدة بيانات ثنائي\nخدمة التسمية القديمة: - التنسيق: ملف hosts.txt بنص عادي - الحالة: مُهمل ولكن ما يزال مدعوماً - حالة الاستخدام: تحرير يدوي، التحكم بالإصدارات\nقواعد اسم المضيف يجب أن تتوافق أسماء المضيفين في I2P مع:\nمتطلب TLD (النطاق ذو المستوى الأعلى): يجب أن ينتهي بـ .i2p الحد الأقصى للطول: 67 حرفًا إجمالًا مجموعة الأحرف: [a-z], [0-9], . (نقطة), - (واصلة) حالة الأحرف: أحرف صغيرة فقط قيود البداية: لا يمكن أن يبدأ بـ . أو - أنماط محظورة: لا يمكن أن يحتوي على .. أو .- أو -. (منذ 0.6.1.33) محجوز: أسماء مضيفين Base32 *.b32.i2p (52 حرفًا من base32.b32.i2p) أمثلة صحيحة example.i2p my-site.i2p test.example.i2p site123.i2p أمثلة غير صالحة example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long إدارة الاشتراكات subscriptions.txt الموقع: $I2P_CONFIG_DIR/addressbook/subscriptions.txt التنسيق: عنوان URL واحد في كل سطر القيمة الافتراضية: http://i2p-projekt.i2p/hosts.txt تنسيق خلاصة الاشتراك (منذ الإصدار 0.9.26) تنسيق موجز متقدم مع بيانات وصفية:\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 خصائص البيانات الوصفية: - added: تاريخ إضافة اسم المضيف (تنسيق YYYYMMDD) - src: معرّف المصدر - sig: توقيع اختياري\nالتوافق مع الإصدارات السابقة: لا يزال تنسيق hostname=destination البسيط مدعومًا.\nمثال على التهيئة # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false إعدادات I2PSnark (i2psnark.config.d/i2psnark.config) الموقع: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config التطبيق: عميل BitTorrent I2PSnark واجهة الإعدادات: واجهة ويب رسومية على http://127.0.0.1:7657/i2psnark\nهيكلية المجلدات $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... الإعدادات الرئيسية (i2psnark.config) التهيئة الافتراضية الدنيا:\ni2psnark.dir=i2psnark خصائص إضافية تُدار عبر واجهة الويب:\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 إعدادات التورنت الفردية الموقع: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config التنسيق: إعدادات لكل تورنت الإدارة: تلقائي (عبر واجهة الويب الرسومية)\nتتضمن الخصائص: - إعدادات الرفع/التنزيل الخاصة بكل تورنت - أولويات الملفات - معلومات المتتبع - حدود النظراء\nملاحظة: تتم إدارة إعدادات التورنت في المقام الأول عبر واجهة الويب. لا يُنصح بالتحرير اليدوي.\nتنظيم بيانات التورنت تخزين البيانات منفصل عن التهيئة:\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs إعدادات I2PTunnel (i2ptunnel.config) الموقع: $I2P_CONFIG_DIR/i2ptunnel.config (قديم) أو $I2P_CONFIG_DIR/i2ptunnel.config.d/ (حديث) واجهة الإعداد: لوحة تحكم Router على /i2ptunnel تغيير التنسيق: الإصدار 0.9.42 (أغسطس 2019)\nبنية المجلدات (الإصدار 0.9.42+) اعتبارًا من الإصدار 0.9.42، يتم تقسيم ملف i2ptunnel.config الافتراضي تلقائيًا:\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) اختلاف جوهري في التنسيق: - تنسيق أحادي: الخصائص مُسبوقة بـ tunnel.N. - تنسيق مُجزّأ: الخصائص غير مُسبوقة (مثلًا، description=، وليس tunnel.0.description=)\nسلوك الترحيل عند التشغيل لأول مرة بعد الترقية إلى 0.9.42: 1. يتم قراءة i2ptunnel.config الموجود 2. يتم إنشاء إعدادات tunnel الفردية في i2ptunnel.config.d/ 3. تُزال البادئة من الخصائص في الملفات المقسمة 4. يتم نسخ الملف الأصلي احتياطيًا 5. لا يزال التنسيق القديم مدعومًا للتوافق مع الإصدارات السابقة\nأقسام التهيئة تم توثيق تهيئة I2PTunnel بالتفصيل في قسم مرجع تهيئة I2PTunnel أدناه. تنطبق أوصاف الخصائص على كلٍ من الصيغ الأحادية (tunnel.N.property) والمجزأة (property).\nمرجع إعدادات I2PTunnel يوفّر هذا القسم مرجعاً تقنياً شاملاً لجميع خصائص تهيئة I2PTunnel. تُعرَض الخصائص بصيغة split format (صيغة مُجزّأة) (من دون البادئة tunnel.N.). ولصيغة monolithic format (صيغة موحّدة)، أضِف البادئة tunnel.N. إلى جميع الخصائص، حيث N هو رقم الـ tunnel.\nهام: الخصائص الموصوفة بصيغة tunnel.N.option.i2cp.* مُنفَّذة في I2PTunnel وهي غير مدعومة عبر واجهات أخرى مثل بروتوكول I2CP أو SAM API.\nالخصائص الأساسية tunnel.N.description (الوصف) النوع: سلسلة نصية السياق: جميع tunnels الوصف: وصف tunnel قابل للقراءة من قبل البشر لعرضه في واجهة المستخدم مثال: description=HTTP Proxy for outproxy access tunnel.N.name (الاسم) النوع: سلسلة نصية السياق: جميع الـ tunnel مطلوب: نعم الوصف: معرّف tunnel فريد واسم العرض مثال: name=I2P HTTP Proxy tunnel.N.type (النوع) النوع: تعداد (Enum) السياق: جميع tunnels مطلوب: نعم القيم: client - tunnel عميل عام httpclient - عميل وكيل HTTP ircclient - tunnel عميل IRC socksirctunnel - وكيل SOCKS لـ IRC sockstunnel - وكيل SOCKS (الإصدار 4 و4a و5) connectclient - عميل وكيل CONNECT streamrclient - عميل Streamr server - tunnel خادم عام httpserver - tunnel خادم HTTP ircserver - tunnel خادم IRC httpbidirserver - خادم HTTP ثنائي الاتجاه streamrserver - خادم Streamr tunnel.N.interface (واجهة) النوع: سلسلة نصية (عنوان IP أو اسم مضيف) السياق: مقتصر على tunnels الخاصة بالعميل القيمة الافتراضية: 127.0.0.1 الوصف: الواجهة المحلية التي سيتم الربط بها للاتصالات الواردة ملاحظة أمنية: الربط على 0.0.0.0 يسمح باتصالات عن بُعد مثال: interface=127.0.0.1 tunnel.N.listenPort (listenPort) النوع: عدد صحيح السياق: Client tunnels فقط النطاق: 1-65535 الوصف: منفذ محلي للاستماع إلى اتصالات العملاء مثال: listenPort=4444 tunnel.N.targetHost (targetHost) النوع: سلسلة نصية (عنوان IP أو اسم مضيف) السياق: فقط لـ tunnels الخاصة بالخادم الوصف: خادم محلي لإعادة توجيه الاتصالات إليه مثال: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) النوع: عدد صحيح السياق: خاص بـ Server tunnels فقط النطاق: 1-65535 الوصف: المنفذ على targetHost المراد الاتصال به مثال: targetPort=80 tunnel.N.targetDestination (targetDestination) النوع: سلسلة نصية (وجهات مفصولة بفواصل أو مسافات) السياق: tunnels الخاصة بالعميل فقط الصيغة: destination[:port][,destination[:port]] الوصف: وجهة/وجهات I2P للاتصال بها أمثلة: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) النوع: سلسلة نصية (عنوان IP أو اسم المضيف) القيمة الافتراضية: 127.0.0.1 الوصف: عنوان واجهة I2CP لـ I2P router ملاحظة: يُتجاهَل عند التشغيل في سياق router مثال: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) النوع: عدد صحيح القيمة الافتراضية: 7654 النطاق: 1-65535 الوصف: منفذ I2CP الخاص بـ I2P router ملاحظة: يُتجاهَل عند التشغيل في سياق router مثال: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) النوع: منطقي القيمة الافتراضية: true الوصف: ما إذا كان سيتم بدء tunnel عند تحميل I2PTunnel مثال: startOnLoad=true إعدادات الوكيل tunnel.N.proxyList (proxyList) النوع: سلسلة نصية (أسماء المضيفين المفصولة بفواصل أو مسافات) السياق: وكلاء HTTP وSOCKS فقط الوصف: قائمة بمضيفي outproxy (وكيل الخروج إلى الإنترنت العام) مثال: proxyList=outproxy.example.i2p,backup.example.i2p إعدادات الخادم tunnel.N.privKeyFile (privKeyFile) النوع: سلسلة نصية (مسار ملف) السياق: الخوادم وtunnels (قنوات اتصال داخل I2P) الخاصة بالعميل والمستمرة الوصف: ملف يحتوي على المفاتيح الخاصة لوجهة دائمة المسار: مطلق أو نسبي بالنسبة إلى دليل إعدادات I2P مثال: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) النوع: String (اسم المضيف) السياق: خوادم HTTP فقط القيمة الافتراضية: اسم مضيف Base32 للوجهة الوصف: قيمة ترويسة Host المُمرَّرة إلى الخادم المحلي مثال: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) النوع: سلسلة نصية (اسم المضيف) السياق: خوادم HTTP فقط الوصف: تجاوز المضيف الظاهري لمنفذ وارد محدد حالة الاستخدام: استضافة مواقع متعددة على منافذ مختلفة مثال: spoofedHost.8080=site1.example.i2p خيارات خاصة بالعميل tunnel.N.sharedClient (sharedClient) النوع: منطقي السياق: Client tunnels فقط القيمة الافتراضية: false الوصف: ما إذا كان بإمكان عدة عملاء مشاركة هذا الـ tunnel مثال: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) النوع: قيمة منطقية السياق: خاصّ بـ Client tunnels فقط الافتراضي: false الوصف: تخزين وإعادة استخدام مفاتيح الوجهة عبر عمليات إعادة التشغيل التعارض: يتنافى مع i2cp.newDestOnResume=true مثال: option.persistentClientKey=true خيارات I2CP (تنفيذ I2PTunnel) مهم: تبدأ هذه الخصائص بالبادئة option.i2cp. ولكن يتم تنفيذها في I2PTunnel، وليس في طبقة بروتوكول I2CP. وهي غير متاحة عبر واجهات برمجة تطبيقات I2CP أو SAM.\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) النوع: منطقي السياق: خاص بـ Client tunnels فقط القيمة الافتراضية: false الوصف: تأخير إنشاء tunnel حتى أول اتصال حالة الاستخدام: توفير الموارد لـ tunnels نادرة الاستخدام مثال: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) النوع: منطقي السياق: Client tunnels فقط الافتراضي: false المتطلبات: i2cp.closeOnIdle=true التعارض: غير قابل للجمع (تعارض متبادل) مع persistentClientKey=true الوصف: إنشاء وجهة جديدة بعد انتهاء مهلة الخمول مثال: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) النوع: سلسلة نصية (مفتاح مُرمَّز بـ base64) السياق: tunnels (مسارات اتصال في I2P) الخاصة بالخادم فقط الوصف: مفتاح تشفير leaseset (مجموعة معلومات الوصول في I2P) خاص دائم حالة الاستخدام: الحفاظ على leaseset مُشفّرة ومتّسقة عبر عمليات إعادة التشغيل مثال: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) النوع: String (sigtype:base64) السياق: tunnels الخاصة بالخادم فقط التنسيق: sigtype:base64key الوصف: المفتاح الخاص الدائم لتوقيع leaseset مثال: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... خيارات خاصة بالخادم tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) النوع: منطقي السياق: tunnels الخاصة بالخادم فقط القيمة الافتراضية: false الوصف: استخدام عنوان IP محلي فريد لكل وجهة I2P بعيدة حالة الاستخدام: تتبّع عناوين IP للعملاء في سجلات الخادم ملاحظة أمنية: قد يقلل من مستوى عدم الكشف عن الهوية مثال: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) النوع: سلسلة نصية (hostname:port) السياق: Server tunnels فقط الوصف: تجاوز targetHost/targetPort للمنفذ الوارد NNNN حالة الاستخدام: توجيه قائم على المنفذ إلى خدمات محلية مختلفة مثال: option.targetForPort.8080=localhost:8080 تكوين تجمع الخيوط tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) النوع: منطقي السياق: ينطبق على tunnels الخوادم فقط القيمة الافتراضية: true الوصف: استخدام مجمّع مؤشرات الترابط (thread pool) لمعالجة الاتصالات ملاحظة: تكون القيمة دائمًا false في الخوادم القياسية (يتم تجاهله) مثال: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) النوع: عدد صحيح السياق: فقط لـ Server tunnels القيمة الافتراضية: 65 الوصف: الحد الأقصى لحجم thread pool (تجمّع الخيوط) ملاحظة: يتم تجاهله للخوادم القياسية مثال: option.i2ptunnel.blockingHandlerCount=100 خيارات عميل HTTP tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) النوع: منطقي السياق: عملاء HTTP فقط القيمة الافتراضية: false الوصف: السماح باتصالات SSL إلى عناوين .i2p مثال: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) النوع: منطقي السياق: عملاء HTTP فقط الافتراضي: false الوصف: تعطيل روابط مساعد العنوان في استجابات الوكيل مثال: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) النوع: سلسلة نصية (عناوين URL مفصولة بفواصل أو بمسافات) السياق: عملاء HTTP فقط الوصف: عناوين URL لخوادم Jump (خوادم القفز) لحل أسماء المضيفين مثال: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) النوع: منطقي السياق: عملاء HTTP فقط الافتراضي: false الوصف: تمرير رؤوس Accept-* (باستثناء Accept و Accept-Encoding) مثال: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) النوع: منطقي (Boolean) السياق: عملاء HTTP فقط القيمة الافتراضية: false الوصف: تمرير رؤوس Referer عبر الوكيل ملاحظة الخصوصية: قد تسرّب معلومات مثال: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) النوع: Boolean (قيمة منطقية) السياق: عملاء HTTP فقط القيمة الافتراضية: false الوصف: تمرير رؤوس User-Agent عبر الوكيل ملاحظة الخصوصية: قد تُسرّب معلومات المتصفح مثال: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) النوع: قيمة منطقية السياق: عملاء HTTP فقط القيمة الافتراضية: false الوصف: تمرير ترويسات Via عبر الوكيل مثال: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) النوع: سلسلة نصية (وجهات مفصولة بفواصل أو مسافات) السياق: عملاء HTTP فقط الوصف: وكلاء خروج SSL داخل الشبكة لطلبات HTTPS مثال: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) النوع: قيمة منطقية السياق: لعملاء HTTP فقط القيمة الافتراضية: true الوصف: استخدام ملحقات outproxy (وكيل خروج) المحلية المسجّلة مثال: option.i2ptunnel.useLocalOutproxy=true مصادقة عميل HTTP tunnel.N.option.proxyAuth (option.proxyAuth) النوع: تعداد السياق: عملاء HTTP فقط القيمة الافتراضية: false القيم: true, false, basic, digest الوصف: يتطلب مصادقة محلية للوصول إلى الوكيل ملاحظة: true تعادل basic مثال: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) النوع: سلسلة ست عشرية مؤلفة من 32 محرفاً بأحرف صغيرة السياق: لعملاء HTTP فقط يتطلب: proxyAuth=basic أو proxyAuth=digest الوصف: تجزئة MD5 لكلمة مرور المستخدم USER مهمل: استخدم SHA-256 بدلاً من ذلك (0.9.56+) مثال: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) النوع: سلسلة (سداسي عشري بأحرف صغيرة مكوّنة من 64 حرفًا) السياق: عملاء HTTP فقط يتطلب: proxyAuth=digest منذ: الإصدار 0.9.56 المعيار: RFC 7616 الوصف: تجزئة SHA-256 لكلمة مرور المستخدم USER مثال: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 مصادقة الوكيل الخارجي tunnel.N.option.outproxyAuth (option.outproxyAuth) النوع: قيمة منطقية السياق: خاص بعملاء HTTP فقط القيمة الافتراضية: false الوصف: إرسال بيانات المصادقة إلى outproxy (الوكيل الخارجي) مثال: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) النوع: سلسلة نصية السياق: عملاء HTTP فقط يتطلّب: outproxyAuth=true الوصف: اسم المستخدم لمصادقة outproxy (وكيل خروجي) مثال: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) النوع: سلسلة نصية السياق: عملاء HTTP فقط يتطلب: outproxyAuth=true الوصف: كلمة مرور لمصادقة outproxy (وكيل خارجي للوصول إلى الإنترنت العام) الأمان: مخزّنة كنص عادي مثال: option.outproxyPassword=secret خيارات عميل SOCKS tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) النوع: سلسلة نصية (وجهات مفصولة بفواصل أو مسافات) السياق: عملاء SOCKS فقط الوصف: وكلاء خروج داخل الشبكة للمنافذ غير المحددة مثال: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) النوع: سلسلة نصية (وجهات مفصولة بفواصل أو مسافات) السياق: عملاء SOCKS فقط الوصف: وكلاء خروج داخل الشبكة لمنفذ NNNN تحديداً مثال: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) النوع: تعداد السياق: عملاء SOCKS فقط القيمة الافتراضية: socks منذ: الإصدار 0.9.57 القيم: socks, connect (HTTPS) الوصف: نوع الـ outproxy (وكيل خارجي) المُكوَّن مثال: option.outproxyType=connect خيارات خادم HTTP tunnel.N.option.maxPosts (option.maxPosts) النوع: عدد صحيح السياق: خوادم HTTP فقط القيمة الافتراضية: 0 (غير محدود) الوصف: الحد الأقصى لطلبات POST من وجهة واحدة لكل postCheckTime مثال: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) النوع: عدد صحيح السياق: خوادم HTTP فقط القيمة الافتراضية: 0 (غير محدود) الوصف: الحد الأقصى لعدد عمليات POST من جميع الوجهات لكل postCheckTime مثال: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) النوع: عدد صحيح (ثوانٍ) السياق: خوادم HTTP فقط القيمة الافتراضية: 300 الوصف: إطار زمني للتحقق من حدود طلبات POST مثال: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) النوع: عدد صحيح (ثوانٍ) السياق: خوادم HTTP فقط القيمة الافتراضية: 1800 الوصف: مدة الحظر بعد تجاوز maxPosts لوجهة واحدة مثال: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) النوع: عدد صحيح (بالثواني) السياق: خوادم HTTP فقط القيمة الافتراضية: 600 الوصف: مدة الحظر بعد تجاوز maxTotalPosts مثال: option.postTotalBanTime=1200 خيارات أمان خادم HTTP tunnel.N.option.rejectInproxy (option.rejectInproxy) النوع: منطقي السياق: خوادم HTTP فقط القيمة الافتراضية: false الوصف: رفض الاتصالات التي تبدو قادمة عبر inproxy (وكيل دخول) مثال: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) النوع: منطقي (Boolean) السياق: خوادم HTTP فقط القيمة الافتراضية: false منذ: الإصدار 0.9.25 الوصف: رفض الاتصالات التي تحتوي على ترويسة Referer (ترويسة HTTP الخاصة بالإحالة) مثال: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) النوع: منطقي (Boolean) السياق: خوادم HTTP فقط القيمة الافتراضية: false منذ: الإصدار 0.9.25 يتطلب: الخاصية userAgentRejectList الوصف: رفض الاتصالات ذات User-Agent المطابق مثال: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) النوع: سلسلة نصية (سلاسل مطابقة مفصولة بفواصل) السياق: خوادم HTTP فقط منذ: الإصدار 0.9.25 حالة الأحرف: مطابقة حساسة لحالة الأحرف خاص: \u0026ldquo;none\u0026rdquo; (منذ 0.9.33) يطابق User-Agent فارغ الوصف: قائمة بأنماط User-Agent المطلوب رفضها مثال: option.userAgentRejectList=Mozilla,Opera,none خيارات خادم IRC tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) النوع: سلسلة نصية (نمط اسم المضيف) السياق: خوادم IRC فقط القيمة الافتراضية: %f.b32.i2p الرموز: %f = التجزئة الكاملة لوجهة بترميز base32 %c = تجزئة وجهة مُقنَّعة (انظر cloakKey) الوصف: تنسيق اسم المضيف المُرسل إلى خادم IRC مثال: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) النوع: سلسلة نصية (عبارة مرور) السياق: خوادم IRC فقط القيمة الافتراضية: عشوائي في كل جلسة القيود: من دون علامات اقتباس أو مسافات الوصف: عبارة مرور لتمويه اسم المضيف بشكل متسق (hostname cloaking) حالة الاستخدام: تتبّع المستخدم بشكل مستمر عبر عمليات إعادة التشغيل/الخوادم مثال: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) النوع: تعداد السياق: خوادم IRC فقط القيمة الافتراضية: user القيم: user, webirc الوصف: طريقة المصادقة لخادم IRC مثال: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) النوع: سلسلة نصية (كلمة مرور) السياق: خوادم IRC فقط يتطلب: method=webirc القيود: بدون علامات اقتباس أو مسافات الوصف: كلمة مرور لمصادقة بروتوكول WEBIRC مثال: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) النوع: سلسلة نصية (عنوان IP) السياق: خوادم IRC فقط يتطلب: method=webirc الوصف: عنوان IP مُنتَحل لبروتوكول WEBIRC مثال: option.ircserver.webircSpoofIP=10.0.0.1 تهيئة SSL/TLS tunnel.N.option.useSSL (option.useSSL) النوع: منطقي القيمة الافتراضية: false السياق: جميع tunnels السلوك: الخوادم: استخدام SSL للاتصالات بالخادم المحلي العملاء: يتطلب SSL من العملاء المحليين مثال: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) النوع: سلسلة نصية (مسار ملف) السياق: لِـ client tunnels فقط القيمة الافتراضية: i2ptunnel-(random).ks المسار: نسبي إلى $(I2P_CONFIG_DIR)/keystore/ إذا لم يكن مطلقًا مُولَّد تلقائيًا: يُنشأ إذا لم يكن موجودًا الوصف: ملف مخزن المفاتيح الذي يحتوي على المفتاح الخاص لـ SSL مثال: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) النوع: سلسلة نصية (كلمة مرور) السياق: Client tunnels فقط القيمة الافتراضية: changeit يُنشأ تلقائيًا: كلمة مرور عشوائية إذا تم إنشاء مخزن مفاتيح جديد الوصف: كلمة المرور لمخزن مفاتيح SSL مثال: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) النوع: سلسلة نصية (اسم مستعار) السياق: خاص بـ Client tunnels فقط يُنشأ تلقائيًا: يُنشأ عند إنشاء مفتاح جديد الوصف: اسم مستعار للمفتاح الخاص في مخزن المفاتيح مثال: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) النوع: سلسلة نصية (كلمة مرور) السياق: tunnels الخاصة بالعميل فقط يتم توليده تلقائياً: كلمة مرور عشوائية إذا تم إنشاء مفتاح جديد الوصف: كلمة مرور للمفتاح الخاص في مخزن المفاتيح (keystore) مثال: option.keyPassword=keypass123 خيارات I2CP العامة وخيارات التدفق تُمرَّر جميع خصائص tunnel.N.option.* (غير الموثَّقة تحديدًا أعلاه) إلى واجهة I2CP ومكتبة البث بعد إزالة البادئة tunnel.N.option..\nمهم: هذه منفصلة عن الخيارات الخاصة بـ I2PTunnel. راجع: - مواصفة I2CP - مواصفة مكتبة البث أمثلة لخيارات البث التدفقي:\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 مثال كامل على Tunnel # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 سجل الإصدارات والجدول الزمني للميزات الإصدار 0.9.10 (2013) الميزة: دعم القيم الفارغة في ملفات الإعداد - المفاتيح ذات القيم الفارغة (key=) أصبحت مدعومة الآن - كانت تُتجاهَل سابقًا أو تتسبب في أخطاء في التحليل\nالإصدار 0.9.18 (2015) الميزة: تكوين فترة تفريغ المسجّل - الخاصية: logger.flushInterval (الافتراضي 29 ثانية) - يقلّل I/O للقرص (الإدخال/الإخراج للقرص) مع الحفاظ على كمون سجل مقبول\nالإصدار 0.9.23 (نوفمبر 2015) تغيير رئيسي: الحد الأدنى المطلوب هو Java 7 - انتهى دعم Java 6 - مطلوب للاستمرار في تلقي تحديثات الأمان\nالإصدار 0.9.25 (2015) الميزات: خيارات أمان خادم HTTP - tunnel.N.option.rejectReferer - رفض الاتصالات التي تحتوي على ترويسة Referer - tunnel.N.option.rejectUserAgents - رفض ترويسات User-Agent محددة - tunnel.N.option.userAgentRejectList - أنماط User-Agent المطلوب رفضها - حالة الاستخدام: الحد من برامج الزحف والعملاء غير المرغوب فيهم\nالإصدار 0.9.33 (يناير 2018) الميزة: تصفية محسّنة لـ User-Agent (وكيل المستخدم) - userAgentRejectList القيمة النصية \u0026ldquo;none\u0026rdquo; تطابق User-Agent الفارغ - إصلاحات أخطاء إضافية لـ i2psnark و i2ptunnel و streaming و SusiMail\nالإصدار 0.9.41 (2019) إيقاف الدعم: تمت إزالة BOB Protocol (بروتوكول BOB الخاص بـ I2P) من Android - يجب على مستخدمي Android الانتقال إلى SAM أو I2CP\nالإصدار 0.9.42 (أغسطس 2019) تغيير كبير: تقسيم ملفات الإعداد - تقسيم clients.config إلى بنية دليل clients.config.d/ - تقسيم i2ptunnel.config إلى بنية دليل i2ptunnel.config.d/ - ترحيل تلقائي عند أول تشغيل بعد الترقية - يُتيح الحزم المعيارية وإدارة الملحقات - لا يزال التنسيق الأحادي القديم مدعوماً\nميزات إضافية: - تحسينات أداء SSU - منع العبور بين الشبكات (Proposal 147) - دعم أولي لأنواع التشفير\nالإصدار 0.9.56 (2021) الميزات: تحسينات الأمان والتسجيل - logger.gzip - ضغط Gzip للسجلات المُدوَّرة (الإعداد الافتراضي: false) - logger.minGzipSize - الحد الأدنى للحجم للضغط (الإعداد الافتراضي: 65536 بايت) - tunnel.N.option.proxy.auth.USER.sha256 - مصادقة الملخص باستخدام SHA-256 (RFC 7616) - الأمان: يحل SHA-256 محل MD5 في مصادقة الملخص\nالإصدار 0.9.57 (يناير 2023) ميزة: تهيئة نوع outproxy (وكيل خروج إلى الإنترنت العام) الخاص بـ SOCKS - tunnel.N.option.outproxyType - اختر نوع outproxy (socks|connect) - القيمة الافتراضية: socks - دعم HTTPS CONNECT لـ outproxies الخاصة بـ HTTPS\nالإصدار 2.6.0 (يوليو 2024) تغيير كاسر للتوافق: تم حظر I2P-over-Tor (تشغيل I2P عبر Tor) - يتم الآن رفض الاتصالات الواردة من عناوين IP لعقد خروج Tor - السبب: يضعف أداء I2P، ويهدر موارد عقد الخروج في Tor - التأثير: سيُحظر المستخدمون الذين يصلون إلى I2P عبر عقد خروج Tor - عقد الترحيل غير الخروجية وعملاء Tor غير متأثرين\nالإصدار 2.10.0 (سبتمبر 2025 - الحالي) الميزات الرئيسية: - التشفير ما بعد الكم متاح (اختياري عبر Hidden Service Manager (مدير الخدمات المخفية)) - دعم مُتعقّب UDP لـ I2PSnark لتقليل حمل المُتعقّب - ثبات Hidden Mode (الوضع المخفي) تحسينات لتقليل استنزاف RouterInfo - تحسينات في الشبكة لـ routers المزدحمة - تعزيز اجتياز UPnP/NAT - تحسينات NetDB مع إزالة leaseset بشكل عدواني - تقليل قابليّة الرصد لأحداث router\nالتهيئة: لم تتم إضافة أي خصائص تهيئة جديدة\nتغيير بالغ الأهمية مرتقب: الإصدار القادم (على الأرجح 2.11.0 أو 3.0.0) سيتطلب جافا 17 أو أحدث\nالميزات المُهمَلة والتغييرات الكاسرة للتوافق إهمالات حرجة الوصول عبر I2P-over-Tor (الإصدار 2.6.0+) الحالة: محظور منذ يوليو 2024 التأثير: رفض الاتصالات القادمة من عناوين IP لعُقد الخروج في Tor السبب: يُضعِف أداء شبكة I2P دون تقديم فوائد لإخفاء الهوية يؤثر على: عُقد الخروج في Tor فقط، وليس المرحلات أو عملاء Tor العاديين البديل: استخدم I2P أو Tor بشكل منفصل، وليس معًا مصادقة الملخص باستخدام MD5 الحالة: مُهمل (استخدم SHA-256) الخاصية: tunnel.N.option.proxy.auth.USER.md5 السبب: MD5 مكسور تشفيرياً البديل: tunnel.N.option.proxy.auth.USER.sha256 (اعتباراً من 0.9.56) الجدول الزمني: لا يزال MD5 مدعوماً ولكن غير مستحسن تغييرات معمارية في التهيئة ملفات التكوين الأحادية (الإصدار 0.9.42+) المتأثر: clients.config, i2ptunnel.config الحالة: مُهمل لصالح بنية أدلة منفصلة الترحيل: تلقائي عند أول تشغيل بعد الترقية إلى 0.9.42 التوافق: التنسيق القديم ما زال يعمل (متوافق مع الإصدارات السابقة) التوصية: استخدم التنسيق المُقسّم للتكوينات الجديدة متطلبات إصدار جافا دعم Java 6 انتهى: الإصدار 0.9.23 (نوفمبر 2015) الحد الأدنى: Java 7 مطلوب منذ 0.9.23 متطلب Java 17 (قادم) الحالة: تغيير حرج مرتقب الهدف: الإصدار الرئيسي التالي بعد 2.10.0 (على الأرجح 2.11.0 أو 3.0.0) الحد الأدنى الحالي: Java 8 الإجراء المطلوب: الاستعداد للترحيل إلى Java 17 الجدول الزمني: سيتم الإعلان عنه مع ملاحظات الإصدار الميزات التي تمت إزالتها بروتوكول BOB (أندرويد) تمت الإزالة: الإصدار 0.9.41 المنصة: Android فقط البديل: بروتوكول SAM أو I2CP سطح المكتب: لا يزال BOB متاحًا على منصات سطح المكتب عمليات الترحيل الموصى بها المصادقة: الانتقال من MD5 إلى SHA-256 لمصادقة الملخص تنسيق التكوين: الانتقال إلى بنية مجلدات منفصلة للعملاء وtunnels وقت تشغيل Java: التخطيط للترقية إلى Java 17 قبل الإصدار الرئيسي التالي تكامل Tor: لا تقم بتوجيه I2P عبر عقد الخروج في Tor المراجع التوثيق الرسمي مواصفة تهيئة I2P - المواصفة الرسمية لصيغة ملف التهيئة مواصفة ملحق I2P - تهيئة الملحق وحزمه البنى المشتركة في I2P - تعيين الأنواع - صيغة تسلسل بيانات البروتوكول صيغة خصائص Java - مواصفة الصيغة الأساسية الشيفرة المصدرية مستودع I2P Java Router - مرآة GitHub Gitea الخاص بمطوري I2P - المستودع الرسمي للشيفرة المصدرية لـ I2P DataHelper.java - تنفيذ عمليات I/O (إدخال/إخراج) لملفات التهيئة موارد المجتمع منتدى I2P - نقاشات المجتمع النشطة ودعم موقع I2P - الموقع الرسمي للمشروع توثيق واجهة برمجة التطبيقات DataHelper JavaDoc - توثيق واجهة برمجة التطبيقات (API) لأساليب ملف التهيئة حالة المواصفة آخر تحديث للمواصفة: يناير 2023 (الإصدار 0.9.57) الإصدار الحالي لـ I2P: 2.10.0 (سبتمبر 2025) الدقة التقنية: لا تزال المواصفة دقيقة حتى الإصدار 2.10.0 (لا تغييرات كاسرة للتوافق) الصيانة: مستند حي يُحدّث عند تعديل تنسيق الإعدادات ","description":"خيارات الإعداد والتنسيقات الخاصة بـ I2P routers والعملاء","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"إعدادات Router","url":"/ar/docs/specs/configuration/"},{"categories":null,"content":"نظرة عامة توثّق هذه المواصفة بروتوكول إعلانات BitTorrent عبر UDP ضمن I2P. للاطّلاع على المواصفة العامة لـ BitTorrent في I2P، راجع وثائق BitTorrent عبر I2P . للاطّلاع على خلفية ومعلومات إضافية حول تطوير هذه المواصفة، يُرجى مراجعة المقترح 160 .\nتمت الموافقة رسميًا على هذا البروتوكول في 24 يونيو 2025 وتم تنفيذُه في I2P الإصدار 2.10.0 (API 0.9.67)، الصادر في 8 سبتمبر 2025. دعم متتبعات UDP قيد التشغيل حاليًا على شبكة I2P مع عدة متتبعات في بيئة الإنتاج ودعم كامل لعميل i2psnark.\nالتصميم تستخدم هذه المواصفة Datagram2 القابل للرد، وDatagram3 القابل للرد، وداتاغرامات خام، كما هو مُعرَّف في I2P Datagram Specification . Datagram2 وDatagram3 هما متغيران من الداتاغرامات القابلة للرد، ومُعرَّفان في Proposal 163 . يضيف Datagram2 مقاومة هجمات إعادة الإرسال ودعم التوقيع دون اتصال. Datagram3 أصغر من تنسيق الداتاغرام القديم، لكنه من دون مصادقة.\nBEP 15 للمرجع، يكون تدفق الرسائل المُعرَّف في BEP 15 كما يلي:\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. مرحلة الاتصال مطلوبة لمنع انتحال عناوين IP. يُرجِع المتعقّب معرّف اتصال يستخدمه العميل في عمليات announce (طلب إبلاغ المتعقّب) اللاحقة. ينتهي معرّف الاتصال هذا افتراضياً خلال دقيقة واحدة لدى العميل، وخلال دقيقتين لدى المتعقّب.\nيستخدم I2P نفس تدفّق الرسائل كما في BEP 15 (اقتراح تحسين BitTorrent رقم 15)، لتسهيل التبنّي في قواعد الشفرة الحالية لبرمجيات العميل الداعمة لـ UDP، ولتحقيق الكفاءة، ولأسباب أمنية تُناقَش أدناه:\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... قد يوفّر هذا وفراً كبيراً في عرض النطاق الترددي مقارنةً بإعلانات التدفق (TCP). وبينما يكون Datagram2 بحجمٍ يقارب حجم SYN (إشارة بدء المصافحة في TCP) عبر التدفق، فإن الاستجابة الخامّة أصغر بكثير من SYN ACK (استجابة الإقرار لطلب SYN في TCP) عبر التدفق. تستخدم الطلبات اللاحقة Datagram3، وتكون الاستجابات اللاحقة خامّة.\nتكون طلبات الإعلان من نوع Datagram3 (تنسيق Datagram الإصدار 3) كي لا يضطر المُتعقِّب إلى الاحتفاظ بجدول مطابقة كبير يربط معرّفات الاتصال بوِجهة الإعلان أو بتجزئتها. وبدلاً من ذلك، يمكن للمتعقِّب توليد معرّفات الاتصال بشكلٍ تشفيري انطلاقاً من تجزئة المرسِل، والطابع الزمني الحالي (استناداً إلى فترة زمنية معيّنة)، وقيمة سرّية. عند استلام طلب إعلان، يتحقق المُتعقِّب من صحة معرّف الاتصال، ثم يستخدم تجزئة المرسِل في Datagram3 كوِجهة للإرسال.\nمدة الاتصال BEP 15 يحدد أن معرف الاتصال ينتهي خلال دقيقة واحدة لدى العميل، وخلال دقيقتين لدى المتتبع. وهو غير قابل للضبط. وهذا يحد من مكاسب الكفاءة المحتملة، ما لم يقم العملاء بتجميع طلبات announce (إبلاغ المتتبع) لتنفيذها جميعا ضمن نافذة زمنية مدتها دقيقة واحدة. لا يقوم i2psnark حاليا بتجميع طلبات announce؛ بل يوزعها على فترات لتجنب اندفاعات مفاجئة في حركة المرور. تفيد التقارير بأن المستخدمين المتقدمين يشغلون آلاف ملفات التورنت في وقت واحد، وإطلاق هذا العدد الكبير من طلبات announce ضمن دقيقة واحدة ليس واقعيا.\nنقترح هنا توسيع استجابة الاتصال لإضافة حقل اختياري لمدة الاتصال. إن لم يكن الحقل موجودًا، فالقيمة الافتراضية هي دقيقة واحدة. وإلا، فعلى العميل استخدام المدة المحددة بالثواني، وسيحتفظ المتعقّب بمعرّف الاتصال لدقيقة إضافية.\nالتوافق مع BEP 15 يحافظ هذا التصميم على التوافق مع BEP 15 قدر الإمكان لتقليل التغييرات المطلوبة في العملاء والمتتبعات القائمة.\nالتغيير الوحيد المطلوب هو في تنسيق معلومات الأقران ضمن استجابة الإعلان. إضافة حقل العمر الافتراضي في استجابة الاتصال غير مطلوبة، لكنها موصى بها بشدة لتحسين الكفاءة، كما شُرح أعلاه.\nتحليل الأمن هدف مهم لبروتوكول الإعلان عبر UDP هو منع انتحال العناوين. يجب أن يكون العميل موجوداً فعلاً وأن يضمّن leaseSet حقيقياً. ويجب أن يمتلك tunnels واردة لتلقي استجابة الاتصال. يمكن أن تكون هذه tunnels zero-hop (بدون قفزات) وتُنشأ فوراً، لكن ذلك سيكشف مُنشئها. يحقق هذا البروتوكول ذلك الهدف.\nالمشكلات هذا البروتوكول لا يدعم الوجهات المُعمّاة، لكن يمكن توسيعه لتحقيق ذلك. انظر أدناه.\nالمواصفات البروتوكولات والمنافذ تستخدم Datagram2 (حزمة بيانات) القابلة للرد بروتوكول I2CP رقم 19؛ وتستخدم Datagram3 القابلة للرد بروتوكول I2CP رقم 20؛ وتستخدم datagrams الخام بروتوكول I2CP رقم 18. قد تكون الطلبات Datagram2 أو Datagram3. أما الردود فهي دائماً خام. يجب عدم استخدام تنسيق Datagram القابل للرد الأقدم (\u0026ldquo;Datagram1\u0026rdquo;) الذي يستخدم بروتوكول I2CP رقم 17 للطلبات أو الردود؛ ويجب إسقاطها إذا استُلمت على منافذ الطلب/الرد. لاحظ أن Datagram1 ببروتوكول 17 لا يزال يُستخدم لبروتوكول DHT.\nتستخدم الطلبات قيمة I2CP \u0026ldquo;to port\u0026rdquo; (المنفذ الوجهة) المأخوذة من عنوان URL للإعلان؛ انظر أدناه. يتم اختيار \u0026ldquo;from port\u0026rdquo; (المنفذ المصدر) للطلب بواسطة العميل، لكن ينبغي أن يكون غير صفري، ومختلفًا عن المنافذ المستخدمة من قِبل DHT (جدول تجزئة موزع)، حتى يسهل تصنيف الاستجابات. ينبغي للمتعقّبات رفض الطلبات التي تُستقبل على منفذ غير صحيح.\nتستخدم الاستجابات قيمة \u0026ldquo;to port\u0026rdquo; في I2CP من الطلب. يكون \u0026ldquo;from port\u0026rdquo; في الاستجابة هو نفسه \u0026ldquo;to port\u0026rdquo; من الطلب.\nعنوان URL للإبلاغ تنسيق عنوان URL الخاص بالإعلان غير مُحدد في BEP 15 ، ولكن كما في الشبكة العامة (clearnet)، تكون عناوين UDP الخاصة بالإعلان على الشكل \u0026ldquo;udp://host:port/path\u0026rdquo;. يتم تجاهل المسار وقد يكون فارغًا، لكنه عادةً يكون \u0026ldquo;/announce\u0026rdquo; على الشبكة العامة (clearnet). يجب أن يكون جزء :port موجودًا دائمًا؛ ومع ذلك، إذا تم إهمال جزء \u0026ldquo;:port\u0026rdquo;، فاستخدم منفذ I2CP الافتراضي 6969، لأنه المنفذ الشائع على الشبكة العامة (clearnet). قد تُضاف أيضًا معلمات CGI مثل \u0026amp;a=b\u0026amp;c=d؛ ويمكن معالجة تلك وتمريرها في طلب الإعلان، انظر BEP 41 . إذا لم تكن هناك معلمات أو مسار، فيمكن أيضًا حذف الشرطة المائلة النهائية /، كما يُفهم ضمنًا في BEP 41 .\nتنسيقات Datagram (حزمة بيانات في شبكة عديمة الاتصال) يتم إرسال جميع القيم بترتيب بايت الشبكة (big endian، حيث يُوضَع البايت الأعلى أهمية أولاً). لا تفترض أن تكون الحزم ذات حجم محدّد تماماً. قد تزيد الامتدادات المستقبلية من حجم الحزم.\nطلب اتصال من العميل إلى المتعقب. 16 بايت. يجب أن يكون Datagram2 (حزمة بيانات من الجيل الثاني) قابلاً للرد. مماثل لما في BEP 15 . لا تغييرات.\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id استجابة الاتصال من المتتبع إلى العميل. 16 أو 18 بايت. يجب أن تكون بصيغتها الخام. مماثلة لما في BEP 15 باستثناء ما هو مذكور أدناه.\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 يجب أن تُرسَل الاستجابة إلى \u0026ldquo;to port\u0026rdquo; في I2CP (بروتوكول عميل I2P)، والذي استُلم باعتباره \u0026ldquo;from port\u0026rdquo; في الطلب.\nحقل lifetime اختياري ويشير إلى مدة صلاحية connection_id لدى العميل بالثواني. القيمة الافتراضية 60، والحد الأدنى—إذا تم تحديده—هو 60. الحد الأقصى 65535، أي نحو 18 ساعة. ينبغي على المتعقب الاحتفاظ بـ connection_id لمدة تزيد 60 ثانية على المدة التي يحددها العميل.\nطلب إعلان من العميل إلى المتعقّب. 98 بايت كحد أدنى. يجب أن يكون Datagram3 قابلاً للرد (نوع حزمة بيانات يمكن الرد عليها). مماثل لما هو في BEP 15 باستثناء ما هو مذكور أدناه.\nقيمة connection_id هي كما تم استلامها في استجابة connect.\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 التغييرات مقارنةً بـ BEP 15 :\nيتم تجاهل المفتاح عنوان IP غير مستخدم من المحتمل تجاهل المنفذ، ولكن يجب أن يطابق منفذ I2CP المصدر قسم الخيارات، إن وُجد، يكون كما هو معرّف في BEP 41 يجب حتماً إرسال الاستجابة إلى \u0026ldquo;to port\u0026rdquo; الخاص بـ I2CP والذي تم استلامه بوصفه \u0026ldquo;from port\u0026rdquo; في الطلب. لا تستخدم المنفذ من طلب الإعلان.\nاستجابة الإعلان من الـ Tracker (خادوم التعقّب) إلى العميل. 20 بايت كحد أدنى. يجب أن تكون خامًا. مماثل لما ورد في BEP 15 إلا كما هو مبيّن أدناه.\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 التغييرات مقارنةً بـ BEP 15 :\nبدلًا من IPv4+port بطول 6 بايت أو IPv6+port بطول 18 بايت، نُرجِع عددًا مضاعفًا من \u0026ldquo;compact responses\u0026rdquo; (استجابات مضغّطة) بحجم 32 بايت، مع تجزئات الأقران الثنائية بـ SHA-256. وكما هو الحال مع استجابات TCP المضغّطة، لا نضمّن منفذًا. يجب إرسال الاستجابة إلى I2CP \u0026ldquo;to port\u0026rdquo; الذي تم استلامه كـ \u0026ldquo;from port\u0026rdquo; للطلب. لا تستخدم المنفذ الوارد في طلب الإعلان.\nيبلغ الحد الأقصى لحجم I2P datagrams (رُزم بيانات مستقلة) نحو 64 KB وهو كبير جداً؛ ومع ذلك، ولضمان تسليم موثوق، ينبغي تجنب datagrams التي تتجاوز 4 KB. ومن أجل كفاءة استخدام النطاق الترددي، يجدر بالمتعقبات تقييد عدد الأقران الأقصى إلى نحو 50، وهو ما يعادل حزمة بحجم يقارب 1600 بايت قبل العبء الإضافي على الطبقات المختلفة، وينبغي أن يبقى ضمن حد الحمولة الخاص برسالتين tunnel بعد التجزئة.\nكما في BEP 15، لا يتم تضمين عدد لعناوين النظراء (IP/port في حالة BEP 15، والتجزئات هنا) التي ستأتي لاحقًا. ورغم أن BEP 15 لا يتناول ذلك، يمكن تعريف علامة نهاية للنظراء تتكوّن من أصفار بالكامل للدلالة على اكتمال معلومات النظراء وأن بعض بيانات الامتداد ستليها.\nلتمكين التوسعة في المستقبل، ينبغي للعملاء تجاهل قيمة تجزئة بطول 32 بايت كلها أصفار، وأي بيانات تليها. ينبغي لخوادم التتبع رفض طلبات announce الواردة من تجزئة كلها أصفار، مع أن تلك التجزئة محظورة أصلًا بواسطة Java routers.\nاستخلاص البيانات طلب/استجابة scrape (استعلام إحصاءات التتبع) من BEP 15 غير مطلوبين في هذه المواصفة، ولكن يمكن تنفيذهما عند الرغبة، دون الحاجة إلى أي تغييرات. يجب على العميل الحصول أولاً على معرّف اتصال. يكون طلب scrape دائمًا repliable (قابل للرد) Datagram3 (نسخة Datagram الثالثة). وتكون استجابة scrape دائمًا raw (خام/غير قابل للرد).\nاستجابة خطأ من المتعقب إلى العميل. 8 بايت كحد أدنى (إذا كانت الرسالة فارغة). يجب أن يكون خامًا. مماثل لما هو في BEP 15 . لا تغييرات.\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message الامتدادات لا تُدرج بتات الامتداد أو حقل الإصدار. لا ينبغي للعملاء والمتتبّعات افتراض أن للحزم حجماً معيّناً. وبهذه الطريقة يمكن إضافة حقول إضافية دون الإخلال بالتوافق. يُوصى باستخدام تنسيق الامتدادات المحدد في BEP 41 عند الحاجة.\nتم تعديل استجابة الاتصال لإضافة مدة صلاحية اختيارية لمعرّف الاتصال.\nإذا كان مطلوباً دعم الوجهة blinded (بتقنية التعمية العمياء)، فيمكننا إما إضافة العنوان blinded بطول 35 بايت إلى نهاية طلب الإعلان، أو طلب التجزئات blinded ضمن الاستجابات، باستخدام تنسيق BEP 41 (المعلمات قيد التحديد). يمكن إضافة مجموعة عناوين الأقران blinded بطول 35 بايت إلى نهاية رد الإعلان، بعد تجزئة بطول 32 بايت كلها أصفار.\nإرشادات التنفيذ انظر قسم التصميم أعلاه لمناقشة التحديات التي تواجه العملاء غير المدمجين وغير المعتمدين على I2CP والمتعقبات.\nالعملاء بالنسبة لاسم مضيف متتبّع معيّن، ينبغي للعميل تفضيل عناوين URL الخاصة بـ UDP على عناوين HTTP، وألا يُعلِن لكليهما معًا.\nالعملاء الذين لديهم دعم BEP 15 قائم بالفعل ينبغي ألا يحتاجوا إلا إلى تعديلات طفيفة.\nإذا كان العميل يدعم DHT (جدول تجزئة موزع) أو بروتوكولات datagram (رزم بيانات عديمة الاتصال) أخرى، فمن الأفضل أن يختار منفذًا مختلفًا كحقل \u0026ldquo;from port\u0026rdquo; في الطلب، بحيث تعود الردود إلى ذلك المنفذ ولا تختلط برسائل DHT. لا يتلقى العميل سوى datagrams خام على شكل ردود. لن ترسل خوادم التتبع مطلقًا datagram2 قابلة للرد إلى العميل.\nينبغي على العملاء الذين لديهم قائمة افتراضية من opentrackers (متعقّبات مفتوحة) تحديث القائمة لإضافة عناوين URL الخاصة بـ UDP بعد التأكد من أنّ opentrackers المعروفة تدعم UDP.\nقد يطبّق العملاء إعادة إرسال للطلبات وقد لا يطبّقونها. وإذا نُفِّذت إعادة الإرسال، فينبغي استخدام مهلة أولية لا تقل عن 15 ثانية، مع مضاعفة المهلة في كل مرة تُعاد فيها عملية الإرسال (exponential backoff، تراجع أسي).\nيجب على العملاء التراجع بعد تلقي استجابة خطأ.\nخوادم التتبّع ينبغي ألا تتطلب المتعقّبات ذات الدعم القائم لـ BEP 15 سوى تعديلات طفيفة. تختلف هذه المواصفة عن مقترح عام 2014، إذ يجب على المتعقّب دعم استقبال كل من datagram2 (حزمة بيانات بدون اتصال) وdatagram3 القابلتين للرد على نفس المنفذ.\nلتقليل متطلبات موارد المتعقّب، صُمّم هذا البروتوكول لإلغاء أي حاجة إلى أن يحتفظ المتعقّب بعمليات الربط بين قيم التجزئة الخاصة بالعملاء ومعرّفات الاتصال بغرض التحقق لاحقًا. وهذا ممكن لأن حزمة طلب الإعلان هي حزمة Datagram3 (صيغة الحزم الإصدار 3) قابلة للرد، لذا فهي تتضمن تجزئة المُرسِل.\nالتنفيذ الموصى به هو:\nعرّف الـ epoch (فترة زمنية مرجعية) الحالي باعتباره الوقت الحالي بدقة مساوية لمدة حياة الاتصال، epoch = now / lifetime. عرّف دالة تجزئة تشفيرية H(secret, clienthash, epoch) تولّد مُخرجًا بطول 8 بايت. ولّد السر الثابت العشوائي المستخدم لجميع الاتصالات. في استجابات الاتصال، ولّد connection_id = H(secret, clienthash, epoch) في طلبات الإعلان، تحقّق من صحة معرّف الاتصال المستلم ضمن الـ epoch الحالي عبر التحقق من connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1) حالة النشر تمت الموافقة على هذا البروتوكول في 24 يونيو 2025 وهو يعمل بكامل طاقته على شبكة I2P اعتبارًا من سبتمبر 2025.\nالتنفيذات الحالية i2psnark: تم تضمين الدعم الكامل لمتعقّبات UDP في I2P الإصدار 2.10.0 (API 0.9.67)، الصادر في 8 سبتمبر 2025. تتضمن جميع تثبيتات I2P اعتبارًا من هذا الإصدار فصاعدًا دعم متعقّبات UDP افتراضيًا.\nzzzot tracker: يدعم الإصدار 0.20.0-beta2 وما بعده UDP announces (طلبات الإعلان عبر UDP). اعتباراً من أكتوبر 2025، المتتبعات الإنتاجية التالية قيد التشغيل: - opentracker.dg2.i2p - opentracker.simp.i2p - opentracker.skank.i2p\nملاحظات حول توافق العميل قيود SAM v3.3: عملاء BitTorrent الخارجيون الذين يستخدمون SAM (Simple Anonymous Messaging — المراسلة المجهولة البسيطة) تتطلب دعم SAM v3.3 لـ Datagram2/3. هذا متوفر في Java I2P ولكنه غير مدعوم حالياً من قبل i2pd (تنفيذ I2P بلغة C++)، مما قد يحد من التبني في العملاء المعتمدين على libtorrent مثل qBittorrent.\nعملاء I2CP: يمكن للعملاء الذين يستخدمون I2CP مباشرةً (مثل BiglyBT) إضافة دعم لمتعقّبات UDP دون قيود SAM.\nالمراجع [BEP15]: بروتوكول متعقب UDP الخاص بـ BitTorrent [BEP41]: امتدادات بروتوكول متعقب UDP [DATAGRAMS]: مواصفة داتاغرامات I2P [Prop160]: مقترح متعقبات UDP [Prop163]: مقترح Datagram2 [SPEC]: BitTorrent عبر I2P ","description":"مواصفة بروتوكول لإعلانات متتبع BitTorrent القائم على UDP في I2P","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"إعلانات BitTorrent عبر UDP","url":"/ar/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":"ما هو Eepsite؟ إن eepsite هو موقع ويب يعمل حصراً على شبكة I2P. وعلى عكس مواقع الويب التقليدية المتاحة عبر clearnet (الإنترنت العام)، فإن eepsites لا يمكن الوصول إليها إلا عبر I2P، مما يوفر إخفاء الهوية والخصوصية لكل من مشغّل الموقع والزوار. تستخدم Eepsites نطاق المستوى الأعلى الزائف .i2p ويتم الوصول إليها عبر عناوين خاصة من نوع .b32.i2p أو عبر أسماء مقروءة للبشر مسجلة في دفتر عناوين I2P.\nتأتي جميع عمليات نشر Java I2P مع Jetty ، وهو خادم ويب خفيف مبني على Java، مثبّت ومهيّأ مسبقًا. هذا يجعل من السهل البدء في استضافة eepsite (موقع ويب على شبكة I2P) الخاص بك في غضون دقائق - دون الحاجة إلى تثبيت أي برامج إضافية.\nسيرشدك هذا الدليل خلال عملية إنشاء وتهيئة أول eepsite (موقع ويب يعمل داخل شبكة I2P فقط) لك باستخدام الأدوات المدمجة في I2P.\nالخطوة 1: الوصول إلى مدير الخدمات المخفية مدير الخدمات المخفية (ويُسمّى أيضاً I2P Tunnel Manager) هو المكان الذي تقوم فيه بتكوين جميع tunnels لخوادم I2P وعملاء I2P، بما في ذلك خوادم HTTP (eepsites).\nافتح I2P Router Console انتقل إلى Hidden Services Manager ينبغي أن ترى واجهة مدير الخدمات المخفية تعرض: - رسائل الحالة - حالة الـ tunnel والعميل الحالية - التحكم العام في الـ Tunnel - أزرار لإدارة جميع الـ tunnels دفعة واحدة - خدمات I2P المخفية - قائمة بـ tunnels للخوادم المُكوَّنة\nافتراضيًا، سترى إدخالًا موجودًا لـ خادم ويب I2P مُعدًّا ولكنه غير مُشغَّل. هذا هو خادم Jetty المُهيّأ مسبقًا والجاهز للاستخدام.\nالخطوة 2: تكوين إعدادات خادم Eepsite الخاص بك انقر على الإدخال I2P webserver في قائمة Hidden Services (الخدمات المخفية) لفتح صفحة تهيئة الخادم. هنا ستخصص إعدادات eepsite الخاص بك.\nشرح خيارات الإعداد الاسم - هذا معرّف داخلي لـ tunnel (مسار اتصال مشفّر داخل شبكة I2P) الخاص بك - مفيد إذا كنت تشغّل عدة eepsites (مواقع ويب داخل شبكة I2P) للتمييز بينها - الافتراضي: \u0026ldquo;I2P webserver\u0026rdquo;\nالوصف - وصف موجز لـ eepsite الخاص بك كمرجع شخصي - مرئي لك فقط في مدير الخدمات المخفية - مثال: \u0026ldquo;eepsite الخاص بي\u0026rdquo; أو \u0026ldquo;مدونة شخصية\u0026rdquo;\nالتشغيل التلقائي لـ Tunnel - مهم: حدّد هذا المربع لبدء eepsite الخاص بك تلقائيًا عند بدء تشغيل I2P router - يضمن بقاء موقعك متاحًا دون تدخل يدوي بعد عمليات إعادة تشغيل router - موصى به: مفعّل\nالوجهة (المضيف والمنفذ) - المضيف: العنوان المحلي الذي يعمل عليه خادم الويب لديك (الافتراضي: 127.0.0.1) - المنفذ: المنفذ الذي يستمع عليه خادم الويب لديك (الافتراضي: 7658 لـ Jetty) - إذا كنت تستخدم خادم Jetty المثبت مسبقًا، اترك هذه القيم على قيمها الافتراضية - غيّرها فقط إذا كنت تشغّل خادم ويب مخصصًا على منفذ مختلف\nاسم مضيف الموقع - هذا هو اسم نطاق .i2p القابل للقراءة البشرية الخاص بـ eepsite لديك - الافتراضي: mysite.i2p (عنصر نائب) - يمكنك تسجيل نطاقًا مخصصًا مثل stormycloud.i2p أو myblog.i2p - اتركه فارغًا إذا كنت تريد فقط استخدام عنوان .b32.i2p المُنشأ تلقائيًا (لـ outproxies (وكلاء الخروج)) - راجع تسجيل نطاق I2P الخاص بك أدناه لمعرفة كيفية المطالبة باسم مضيف مخصص\nالوجهة المحلية - هذا هو المعرّف التشفيري الفريد لـ eepsite (موقع ويب على I2P) الخاص بك (عنوان الوجهة) - يُولَّد تلقائيًا عند إنشاء tunnel (نفق اتصال) لأول مرة - اعتبره \u0026ldquo;عنوان IP\u0026rdquo; الدائم لموقعك على I2P - سلسلة الأحرف والأرقام الطويلة هي عنوان .b32.i2p الخاص بموقعك بصيغة مُرمَّزة\nملف المفتاح الخاص - الموقع الذي تُخزَّن فيه مفاتيح eepsite الخاصة بك (موقع ويب مخفي على I2P) - الإعداد الافتراضي: eepsite/eepPriv.dat - حافظ على أمان هذا الملف - يمكن لأي شخص لديه وصول إلى هذا الملف انتحال هوية eepsite الخاص بك - لا تُشارك هذا الملف مطلقًا ولا تحذفه\nملاحظة مهمة يذكّرك صندوق التحذير الأصفر بأنه، لتمكين ميزات إنشاء رمز الاستجابة السريعة (QR) أو مصادقة التسجيل، يجب عليك تكوين اسم مضيف للموقع بلاحقة .i2p (مثلًا، mynewsite.i2p).\nالخطوة 3: خيارات الشبكات المتقدمة (اختياري) إذا قمت بالتمرير إلى أسفل صفحة الإعدادات، فستجد خيارات شبكات متقدمة. هذه الإعدادات اختيارية - الإعدادات الافتراضية تعمل جيدًا لمعظم المستخدمين. ومع ذلك، يمكنك تعديلها بناءً على متطلباتك الأمنية واحتياجات الأداء.\nخيارات طول Tunnel طول Tunnel - الافتراضي: tunnel بثلاث قفزات (إخفاء هوية مرتفع) - يحدد عدد قفزات router التي يمرّ بها الطلب قبل وصوله إلى eepsite الخاص بك - المزيد من القفزات = إخفاء هوية أعلى، ولكن أداء أبطأ - قفزات أقل = أداء أسرع، ولكن إخفاء هوية أقل - تتراوح الخيارات بين 0-3 قفزات مع إعدادات التفاوت - التوصية: اتركها عند 3 قفزات ما لم تكن لديك متطلبات أداء محددة\nتباين Tunnel - الإعداد الافتراضي: تباين 0 قفزة (بلا عشوائية، أداء متسق) - يضيف عشوائية إلى طول Tunnel لمزيد من الأمان - مثال: \u0026ldquo;تباين 0-1 قفزة\u0026rdquo; يعني أن طول tunnels سيكون عشوائياً 3 أو 4 قفزات - يزيد عدم القدرة على التنبؤ، لكنه قد يسبب أوقات تحميل غير متسقة\nخيارات عدد Tunnel العدد (Inbound/Outbound Tunnels) - الإعداد الافتراضي: 2 inbound, 2 outbound tunnels (نطاق ترددي وموثوقية قياسيان) - يتحكم في عدد tunnels (قنوات مسار داخل I2P) المتوازية المخصصة لـeepsite الخاص بك - المزيد من tunnels = توافرية أفضل وتعامل أفضل مع الحمل، ولكن استخدام موارد أعلى - عدد أقل من tunnels = استخدام موارد أقل، ولكن تقليل في التكرار - موصى به لمعظم المستخدمين: 2/2 (افتراضي) - قد تستفيد المواقع ذات الزيارات العالية من 3/3 أو أكثر\nعدد النسخ الاحتياطية - الإعداد الافتراضي: 0 tunnels احتياطية (بدون ازدواجية، وبدون استخدام إضافي للموارد) - tunnels احتياطية تنشط إذا فشلت الـtunnels الأساسية - يعزز الموثوقية لكنه يستهلك مزيداً من النطاق الترددي ووحدة المعالجة المركزية - معظم eepsites الشخصية لا تحتاج إلى tunnels احتياطية\nحدود POST إذا كان eepsite الخاص بك يتضمن نماذج (نماذج تواصل، أقسام تعليقات، رفع ملفات، إلخ)، يمكنك ضبط حدود طلبات POST لمنع إساءة الاستخدام:\nحدود لكل عميل - لكل فترة زمنية: الحد الأقصى للطلبات من عميل واحد (القيمة الافتراضية: 6 لكل 5 دقائق) - مدة الحظر: مدة حظر العملاء المسيئين (القيمة الافتراضية: 20 دقيقة)\nالحدود الإجمالية - الإجمالي: الحد الأقصى لعدد طلبات POST من جميع العملاء مجتمعين (الافتراضي: 20 لكل 5 دقائق) - مدة الحظر: المدة التي سيتم خلالها رفض جميع طلبات POST إذا تم تجاوز الحد (الافتراضي: 10 دقائق)\nفترة حدّ POST - نافذة زمنية لقياس معدلات الطلبات (الافتراضي: 5 دقائق)\nتساعد هذه القيود في الحماية من الرسائل غير المرغوب فيها، وهجمات الحرمان من الخدمة، وإساءة استخدام عمليات إرسال النماذج بشكل آلي.\nمتى ينبغي ضبط الإعدادات المتقدمة موقع مجتمعي عالي الزيارات: زد عدد الـ tunnel (3-4 واردة/صادرة) تطبيق شديد الحساسية للأداء: خفّض طول الـ tunnel إلى قفزتين (مقايضة في الخصوصية) مطلوب أقصى قدر من إخفاء الهوية: حافظ على 3 قفزات، وأضف تباينًا بمقدار 0-1 النماذج ذات الاستخدام المرتفع المشروع: زد حدود POST (طلب HTTP POST) وفقًا لذلك مدونة/معرض أعمال شخصي: استخدم جميع الإعدادات الافتراضية الخطوة 4: إضافة محتوى إلى Eepsite (موقع ويب على شبكة I2P) الخاص بك الآن بعد أن تم تكوين eepsite الخاص بك، تحتاج إلى إضافة ملفات موقعك (HTML وCSS والصور، إلخ) إلى الدليل الجذر لمستندات خادم الويب. يختلف الموقع تبعًا لنظام التشغيل لديك، ونوع التثبيت، وتنفيذ I2P.\nالعثور على جذر مستنداتك جذر المستندات (وغالبًا ما يُسمّى docroot) هو المجلد الذي تضع فيه جميع ملفات موقعك الإلكتروني. يجب أن يوضع ملفك index.html مباشرة داخل هذا المجلد.\nJava I2P (التوزيع القياسي) لينكس - التثبيت القياسي: ~/.i2p/eepsite/docroot/ - تثبيت الحزمة (يعمل كخدمة): /var/lib/i2p/i2p-config/eepsite/docroot/\nويندوز - التثبيت القياسي: %LOCALAPPDATA%\\I2P\\eepsite\\docroot\\ - المسار النموذجي: C:\\Users\\YourUsername\\AppData\\Local\\I2P\\eepsite\\docroot\\ - تثبيت خدمة ويندوز: %PROGRAMDATA%\\I2P\\eepsite\\docroot\\ - المسار النموذجي: C:\\ProgramData\\I2P\\eepsite\\docroot\\\nmacOS - التثبيت الافتراضي: /Users/YourUsername/Library/Application Support/i2p/eepsite/docroot/\nI2P+ (توزيعة I2P المحسّنة) يستخدم I2P+ بنية الدلائل نفسها مثل Java I2P. اتبع المسارات المذكورة أعلاه وفقًا لنظام التشغيل لديك.\ni2pd (تنفيذ بلغة C++) Linux/Unix - الافتراضي: /var/lib/i2pd/eepsite/ أو ~/.i2pd/eepsite/ - تحقق من ملف التهيئة i2pd.conf لمعرفة إعداد root الفعلي ضمن tunnel خادم HTTP لديك\nويندوز - تحقق من i2pd.conf في دليل تثبيت i2pd لديك\nmacOS - عادةً: ~/Library/Application Support/i2pd/eepsite/\nإضافة ملفات موقع الويب الخاص بك انتقل إلى جذر المستندات باستخدام مدير الملفات أو الطرفية أنشئ أو انسخ ملفات موقعك إلى مجلد docroot على الأقل، أنشئ ملفًا باسم index.html (هذه صفحتك الرئيسية) أضف CSS وJavaScript والصور وموارد أخرى حسب الحاجة نظّم المجلدات الفرعية كما تفعل لأي موقع: docroot/ ├── index.html ├── about.html ├── css/ │ └── style.css ├── images/ │ └── logo.png └── js/ └── script.js البدء السريع: مثال HTML بسيط إذا كنت قد بدأت للتو، فأنشئ ملفًا أساسيًا باسم index.html في مجلد docroot لديك:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My I2P Eepsite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Eepsite!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first website on the I2P network.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Privacy-focused and decentralized!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; الأذونات (Linux/Unix/macOS) إذا كنت تُشغّل I2P كخدمة أو كمستخدم آخر، فتأكد من أن عملية I2P لديها صلاحية الوصول للقراءة إلى ملفاتك:\n# Set appropriate ownership (if running as i2p user) sudo chown -R i2p:i2p /var/lib/i2p/i2p-config/eepsite/docroot/ # Or set readable permissions for all users chmod -R 755 ~/.i2p/eepsite/docroot/ نصائح المحتوى الافتراضي: عند تثبيت I2P لأول مرة، يوجد بالفعل محتوى نموذجي في مجلد docroot، ويمكنك استبداله بحرية المواقع الثابتة تعمل بشكل أفضل: رغم أن Jetty يدعم Servlets (مكوّنات خادم جافا) وJSP (صفحات JavaServer)، فإن مواقع HTML/CSS/JavaScript البسيطة هي الأسهل صيانةً خوادم ويب خارجية: يمكن للمستخدمين المتقدّمين تشغيل خوادم ويب مخصّصة (Apache وNginx وNode.js وغيرها) على منافذ مختلفة وتوجيه الـ I2P tunnel إليها الخطوة 5: بدء تشغيل Eepsite الخاص بك الآن بعد أن تم تهيئة eepsite الخاص بك وأصبح يحتوي على محتوى، حان الوقت لتشغيله وجعله متاحًا على شبكة I2P.\nابدأ الـ Tunnel (النفق) عُد إلى مدير الخدمات المخفية اعثر على إدخال خادم الويب I2P الخاص بك في القائمة انقر زر Start في عمود Control انتظر اكتمال إنشاء Tunnel بعد النقر على Start، سيبدأ بناء eepsite tunnel الخاص بك. تستغرق هذه العملية عادةً 30-60 ثانية. راقب مؤشر الحالة:\nالضوء الأحمر = Tunnel قيد البدء/البناء الضوء الأصفر = Tunnel مُنشأة جزئياً الضوء الأخضر = Tunnel تعمل بالكامل وجاهزة بمجرد أن ترى الضوء الأخضر، يصبح eepsite (موقع ويب مخفي داخل I2P) الخاص بك متاحًا على شبكة I2P!\nالوصول إلى Eepsite الخاص بك (موقع ويب داخل شبكة I2P) انقر على زر Preview بجوار eepsite الخاص بك قيد التشغيل. سيؤدي ذلك إلى فتح علامة تبويب جديدة في المتصفح تحتوي على عنوان eepsite الخاص بك.\nيحتوي eepsite الخاص بك على نوعين من العناوين:\nعنوان Base32 (.b32.i2p): عنوان تشفيري طويل (مُرَمَّز بترميز Base32) يبدو كالتالي:\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p هذا هو العنوان الدائم لـ eepsite الخاص بك والمُشتقّ تشفيرياً لا يمكن تغييره وهو مرتبط بمفتاحك الخاص يعمل دائماً، حتى من دون تسجيل نطاق نطاق مقروء بشريًا (.i2p): إذا قمت بتعيين اسم مضيف للموقع (مثال: testwebsite.i2p)\nيعمل فقط بعد تسجيل النطاق (انظر القسم التالي) أسهل في التذكر والمشاركة يُشير إلى عنوان .b32.i2p الخاص بك يتيح لك زر نسخ اسم المضيف نسخ عنوانك الكامل .b32.i2p بسرعة لمشاركته.\n⚠️ هام جدًا: أنشئ نسخة احتياطية لمفتاحك الخاص قبل المضي قدماً، يجب إنشاء نسخة احتياطية لملف المفتاح الخاص لـ eepsite لديك. هذا أمر بالغ الأهمية لعدة أسباب:\nلماذا ينبغي نسخ مفتاحك احتياطيًا؟ مفتاحك الخاص (eepPriv.dat) هو هوية eepsite الخاصة بك (موقع خدمة مخفية على شبكة I2P). إنه يحدد عنوان .b32.i2p الخاص بك ويثبت ملكيتك لـ eepsite الخاص بك.\nالمفتاح = عنوان .b32: يُولِّد مفتاحك الخاص رياضيًا عنوان .b32.i2p الفريد الخاص بك لا يمكن استعادته: إذا فقدت مفتاحك، فستفقد عنوان eepsite الخاص بك بشكل دائم لا يمكن تغييره: إذا سجّلت نطاقًا يشير إلى عنوان .b32، فلا توجد أي طريقة لتحديثه - التسجيل دائم مطلوب لعملية النقل: الانتقال إلى جهاز جديد أو إعادة تثبيت I2P يتطلب هذا المفتاح للاحتفاظ بنفس العنوان دعم Multihoming (الاستضافة من مواقع تشغيل/خوادم متعددة): يتطلب تشغيل eepsite الخاص بك من مواقع/خوادم متعددة استخدام المفتاح نفسه على كل خادم أين المفتاح الخاص؟ بشكل افتراضي، يتم تخزين مفتاحك الخاص في: - Linux: ~/.i2p/eepsite/eepPriv.dat (أو /var/lib/i2p/i2p-config/eepsite/eepPriv.dat للتثبيت كخدمة) - Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat أو %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat - macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat\nيمكنك أيضًا التحقق من هذا المسار أو تغييره في إعدادات tunnel لديك ضمن \u0026ldquo;Private Key File\u0026rdquo;.\nكيفية عمل نسخة احتياطية أوقف الـ tunnel (نفق اتصال داخل شبكة I2P) الخاص بك (اختياري، لكنه أكثر أماناً) انسخ eepPriv.dat إلى مكان آمن: محرك أقراص USB خارجي محرك نسخ احتياطي مُشفّر أرشيف محمي بكلمة مرور تخزين سحابي آمن (مُشفّر) احتفظ بعدة نسخ احتياطية في أماكن مادية مختلفة لا تشارك هذا الملف مطلقاً - أي شخص يمتلكه يمكنه انتحال هوية الـ eepsite (موقع داخل شبكة I2P) الخاص بك الاستعادة من نسخة احتياطية لاستعادة eepsite الخاص بك على نظام جديد أو بعد إعادة التثبيت:\nثبّت I2P وقم بإنشاء وتهيئة إعدادات الـ tunnel الخاصة بك أوقف الـ tunnel قبل نسخ المفتاح انسخ ملف eepPriv.dat الاحتياطي إلى الموقع الصحيح ابدأ الـ tunnel - سيستخدم عنوان .b32 الأصلي الخاص بك إذا لم تكن تسجّل نطاقًا تهانينا! إذا لم تكن تخطط لتسجيل اسم نطاق مخصص .i2p، فإن eepsite (موقع ويب على شبكة I2P) الخاص بك أصبح الآن مكتملًا وقيد التشغيل.\nيمكنك: - مشاركة عنوان .b32.i2p الخاص بك مع الآخرين - الوصول إلى موقعك عبر شبكة I2P باستخدام أي متصفح يدعم I2P - تحديث ملفات موقعك في مجلد docroot في أي وقت - مراقبة حالة الـ tunnel لديك في Hidden Services Manager (مدير الخدمات المخفية)\nإذا كنت تريد اسم نطاق مقروءاً للبشر (مثل mysite.i2p بدلاً من عنوان .b32 طويل)، فانتقل إلى القسم التالي.\nتسجيل نطاق I2P الخاص بك إن نطاق .i2p المقروء للبشر (مثل testwebsite.i2p) أسهل بكثير في التذكر والمشاركة من عنوان .b32.i2p طويل. تسجيل النطاق مجاني ويربط الاسم الذي تختاره بالعنوان التشفيري لـ eepsite الخاص بك.\nالمتطلبات الأساسية يجب أن يكون eepsite الخاص بك قيد التشغيل مع مؤشّر أخضر يجب أن تكون قد عيّنت اسم مضيف الموقع في إعدادات tunnel لديك (الخطوة 2) مثال: testwebsite.i2p أو myblog.i2p الخطوة 1: توليد سلسلة المصادقة عُد إلى تهيئة tunnel الخاصة بك في مدير الخدمات المخفية انقر على إدخال خادم الويب I2P الخاص بك لفتح الإعدادات مرّر لأسفل للعثور على زر مصادقة التسجيل انقر Registration Authentication انسخ سلسلة المصادقة كاملة المعروضة لـ \u0026ldquo;Authentication for adding host [yourdomainhere]\u0026rdquo; ستبدو سلسلة المصادقة كما يلي:\ntestwebsite.i2p=I8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1uNxFZ0HN7tQbbVj1pmbahepQZNxEW0ufwnMYAoFo8opBQAEAAcAAA==#!date=1762104890#sig=9DjEfrcNRxsoSxiE0Mp0-7rH~ktYWtgwU8c4J0eSo0VHbGxDxdiO9D1Cvwcx8hkherMO07UWOC9BWf-1wRyUAw== تتضمن هذه السلسلة:\nاسم النطاق الخاص بك (testwebsite.i2p) عنوان الوجهة الخاص بك (المعرّف التشفيري الطويل) طابع زمني توقيع تشفيري يثبت أنك تملك المفتاح الخاص احتفظ بسلسلة المصادقة هذه - ستحتاجها لكلتا خدمتي التسجيل.\nالخطوة 2: سجّل في stats.i2p انتقل إلى stats.i2p Add Key (ضمن I2P) الصق سلسلة المصادقة في الحقل \u0026ldquo;Authentication String\u0026rdquo; أضِف اسمك (اختياري) - القيمة الافتراضية: \u0026ldquo;Anonymous\u0026rdquo; أضِف وصفًا (موصى به) - صف بإيجاز ما يدور حوله eepsite (موقع داخل شبكة I2P) الخاص بك مثال: \u0026ldquo;I2P Eepsite جديد\u0026rdquo;، \u0026ldquo;مدونة شخصية\u0026rdquo;، \u0026ldquo;خدمة مشاركة الملفات\u0026rdquo; حدِّد \u0026ldquo;HTTP Service?\u0026rdquo; إذا كان هذا موقع ويب (اتركه محددًا لمعظم eepsites) ألغِ التحديد لـ IRC وNNTP وproxies وXMPP وgit، إلخ. انقر Submit إذا نجحت العملية، فسترى رسالة تأكيد تفيد بأنه تمت إضافة نطاقك إلى دفتر عناوين stats.i2p.\nالخطوة 3: التسجيل لدى reg.i2p لضمان أقصى قدر من التوفّر، ينبغي عليك أيضًا التسجيل لدى خدمة reg.i2p:\nانتقل إلى reg.i2p Add Domain (ضمن I2P) الصق سلسلة المصادقة نفسها في الحقل \u0026ldquo;Auth string\u0026rdquo; أضف وصفًا (اختياري لكنه مُوصى به) يساعد هذا مستخدمي I2P الآخرين على فهم ما يقدمه موقعك انقر Submit ينبغي أن تتلقى تأكيدًا بأن نطاقك قد تم تسجيله.\nالخطوة 4: انتظر الانتشار بعد الإرسال إلى الخدمتين كلتيهما، سينتشر تسجيل نطاقك عبر نظام دفتر العناوين في شبكة I2P.\nالجدول الزمني للانتشار: - التسجيل الأولي: فوري عبر خدمات التسجيل - الانتشار على مستوى الشبكة: من عدة ساعات إلى 24 ساعة أو أكثر - التوافر الكامل: قد يستغرق ما يصل إلى 48 ساعة لتحديث جميع routers\nهذا طبيعي! يقوم نظام دفتر العناوين الخاص بـ I2P بالتحديث بشكل دوري، وليس على الفور. موقعك eepsite يعمل - يحتاج المستخدمون الآخرون فقط إلى استلام دفتر العناوين المحدّث.\nتحقق من نطاقك بعد بضع ساعات، يمكنك اختبار نطاقك:\nافتح علامة تبويب جديدة في متصفح I2P لديك جرّب الوصول إلى نطاقك مباشرةً: http://yourdomainname.i2p إذا تم التحميل، فهذا يعني أن نطاقك مسجَّل وقيد الانتشار! إذا لم يعمل بعد: - انتظر مدة أطول (يتم تحديث دفاتر العناوين وفق جدولها الخاص) - قد يحتاج دفتر عناوين router لديك بعض الوقت للمزامنة - جرّب إعادة تشغيل I2P router لإجبار دفتر العناوين على التحديث\nملاحظات مهمة التسجيل دائم: بمجرد تسجيل النطاق وانتشاره، سيشير نطاقك إلى عنوان .b32.i2p الخاص بك بشكل دائم لا يمكن تغيير الوجهة: لا يمكنك تحديث العنوان .b32.i2p الذي يشير إليه نطاقك - ولهذا فإن الاحتفاظ بنسخة احتياطية من eepPriv.dat أمر بالغ الأهمية ملكية النطاق: لا يستطيع تسجيل النطاق أو تحديثه إلا حامل المفتاح الخاص خدمة مجانية: تسجيل النطاق على I2P مجاني، يديره المجتمع، ولامركزي جهات تسجيل متعددة: التسجيل لدى كل من stats.i2p و reg.i2p يزيد الموثوقية وسرعة الانتشار تهانينا! أصبح I2P eepsite الخاص بك يعمل الآن بكامل طاقته مع نطاق مُسجَّل!\nالخطوات التالية: - أضف مزيدًا من المحتوى إلى مجلد docroot الخاص بك - شارك نطاقك مع مجتمع I2P - احفظ النسخة الاحتياطية لـeepPriv.dat بأمان - راقب حالة tunnel الخاصة بك بانتظام - فكّر في الانضمام إلى منتديات I2P أو IRC للترويج لموقعك\nمرحبًا بك في شبكة I2P! 🎉\n","description":"تعرّف على كيفية إنشاء واستضافة موقعك الإلكتروني على شبكة I2P باستخدام خادم الويب Jetty المدمج","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"إنشاء Eepsite (موقع ويب مُستضاف داخل شبكة I2P)","url":"/ar/docs/guides/%D8%A5%D9%86%D8%B4%D8%A7%D8%A1-eepsite-%D9%85%D9%88%D9%82%D8%B9-%D9%88%D9%8A%D8%A8-%D9%85%D9%8F%D8%B3%D8%AA%D8%B6%D8%A7%D9%81-%D8%AF%D8%A7%D8%AE%D9%84-%D8%B4%D8%A8%D9%83%D8%A9-i2p/"},{"categories":null,"content":"يوفر نفق SSH اتصالاً آمناً ومشفراً للوصول إلى وحدة تحكم I2P router البعيدة أو خدمات أخرى. يوضح لك هذا الدليل كيفية إنشاء أنفاق SSH على أنظمة Windows وLinux وMac.\nما هو نفق SSH؟ نفق SSH هو طريقة لتوجيه البيانات والمعلومات بشكل آمن عبر اتصال SSH مشفر. فكر في الأمر على أنه إنشاء \u0026ldquo;خط أنابيب\u0026rdquo; محمي عبر الإنترنت - تنتقل بياناتك عبر هذا النفق المشفر، مما يمنع أي شخص من اعتراضها أو قراءتها أثناء الطريق.\nنفق SSH مفيد بشكل خاص من أجل:\nالوصول إلى أجهزة التوجيه I2P البعيدة: الاتصال بوحدة تحكم I2P الخاصة بك والتي تعمل على خادم بعيد اتصالات آمنة: يتم تشفير جميع البيانات من طرف إلى طرف تجاوز القيود: الوصول إلى الخدمات على الأنظمة البعيدة كما لو كانت محلية إعادة توجيه المنافذ: ربط منفذ محلي بخدمة بعيدة في سياق I2P، يمكنك استخدام نفق SSH للوصول إلى وحدة تحكم router الخاص بك في I2P (عادةً على المنفذ 7657) على خادم بعيد عن طريق إعادة توجيهه إلى منفذ محلي على جهاز الكمبيوتر الخاص بك.\nالمتطلبات الأساسية قبل إنشاء نفق SSH، ستحتاج إلى:\nعميل SSH: Windows: PuTTY (تنزيل مجاني) Linux/Mac: عميل SSH مدمج (عبر Terminal) الوصول إلى الخادم البعيد: اسم المستخدم للخادم البعيد عنوان IP أو اسم المضيف للخادم البعيد كلمة مرور SSH أو المصادقة المعتمدة على المفتاح منفذ محلي متاح: اختر منفذاً غير مستخدم بين 1-65535 (المنفذ 7657 شائع الاستخدام لـ I2P) فهم أمر Tunnel يتبع أمر نفق SSH هذا النمط:\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] شرح المعاملات: - local_port: المنفذ على جهازك المحلي (مثلاً، 7657) - destination_ip: عادةً 127.0.0.1 (localhost على الخادم البعيد) - destination_port: منفذ الخدمة على الخادم البعيد (مثلاً، 7657 لـ I2P) - username: اسم المستخدم الخاص بك على الخادم البعيد - remote_server: عنوان IP أو اسم المضيف للخادم البعيد\nمثال: ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\nهذا ينشئ نفقًا حيث: - المنفذ المحلي 7657 على جهازك يُحوّل إلى\u0026hellip; - المنفذ 7657 على localhost الخاص بالخادم البعيد (حيث يعمل I2P) - الاتصال كمستخدم i2p بالخادم 20.228.143.58\nإنشاء أنفاق SSH على Windows يمكن لمستخدمي Windows إنشاء أنفاق SSH باستخدام PuTTY، وهو عميل SSH مجاني.\nStep 1: Download and Install PuTTY قم بتنزيل PuTTY من putty.org وتثبيته على نظام Windows الخاص بك.\nStep 2: Configure the SSH Connection افتح PuTTY وقم بتكوين اتصالك:\nفي فئة Session: أدخل عنوان IP أو اسم المضيف للخادم البعيد في حقل Host Name تأكد من ضبط Port على 22 (منفذ SSH الافتراضي) يجب أن يكون نوع الاتصال SSH Step 3: Configure the Tunnel انتقل إلى Connection → SSH → Tunnels في الشريط الجانبي الأيسر:\nمنفذ المصدر: أدخل المنفذ المحلي الذي تريد استخدامه (مثلاً، 7657) الوجهة: أدخل 127.0.0.1:7657 (localhost:port على الخادم البعيد) انقر على إضافة لإضافة النفق يجب أن يظهر النفق في قائمة \u0026ldquo;المنافذ المعاد توجيهها\u0026rdquo; Step 4: Connect انقر على Open لبدء الاتصال إذا كانت هذه أول مرة تتصل فيها، ستظهر لك تنبيه أمني - انقر على Yes للوثوق بالخادم أدخل اسم المستخدم عندما يُطلب منك ذلك أدخل كلمة المرور عندما يُطلب منك ذلك بمجرد الاتصال، يمكنك الوصول إلى وحدة تحكم I2P البعيدة الخاصة بك عن طريق فتح متصفح والانتقال إلى http://127.0.0.1:7657\nالخطوة 1: تنزيل وتثبيت PuTTY لتجنب إعادة التهيئة في كل مرة:\nالعودة إلى فئة الجلسة (Session) أدخل اسمًا في الجلسات المحفوظة (Saved Sessions) (مثال: \u0026ldquo;I2P Tunnel\u0026rdquo;) انقر على حفظ (Save) في المرة القادمة، قم بتحميل هذه الجلسة وانقر على فتح (Open) Creating SSH Tunnels on Linux أنظمة Linux تحتوي على SSH مدمج في الطرفية، مما يجعل إنشاء الأنفاق سريعًا ومباشرًا.\nالخطوة 2: تكوين اتصال SSH افتح نافذة طرفية وقم بتشغيل أمر نفق SSH:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 استبدل: - 7657 (الظهور الأول): المنفذ المحلي المطلوب - 127.0.0.1:7657: عنوان الوجهة والمنفذ على الخادم البعيد - i2p: اسم المستخدم الخاص بك على الخادم البعيد - 20.228.143.58: عنوان IP للخادم البعيد الخاص بك\nعند المطالبة، أدخل كلمة المرور الخاصة بك. بمجرد الاتصال، يصبح النفق (tunnel) نشطًا.\nقم بالوصول إلى وحدة تحكم I2P البعيدة الخاصة بك على http://127.0.0.1:7657 في متصفحك.\nالخطوة 3: تكوين النفق يبقى النفق نشطًا طالما أن جلسة SSH قيد التشغيل. للحفاظ على تشغيله في الخلفية:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 أعلام إضافية: - -f: تشغيل SSH في الخلفية - -N: عدم تنفيذ أوامر عن بعد (tunnel فقط)\nلإغلاق tunnel في الخلفية، ابحث عن عملية SSH وأنهِها:\nps aux | grep ssh kill [process_id] الخطوة 4: الاتصال للحصول على أمان وراحة أفضل، استخدم مصادقة مفاتيح SSH:\nإنشاء زوج مفاتيح SSH (إذا لم يكن لديك واحد):\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; انسخ مفتاحك العام إلى الخادم البعيد:\nssh-copy-id i2p@20.228.143.58 الآن يمكنك الاتصال بدون كلمة مرور:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac تستخدم أنظمة Mac نفس عميل SSH الخاص بنظام Linux، لذا فإن العملية متطابقة.\nاختياري: احفظ جلستك افتح Terminal (التطبيقات ← الأدوات المساعدة ← Terminal) وقم بتشغيل:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 استبدل: - 7657 (الظهور الأول): المنفذ المحلي المطلوب - 127.0.0.1:7657: عنوان الوجهة والمنفذ على الخادم البعيد - i2p: اسم المستخدم الخاص بك على الخادم البعيد - 20.228.143.58: عنوان IP الخاص بالخادم البعيد\nأدخل كلمة المرور الخاصة بك عند الطلب. بمجرد الاتصال، قم بالوصول إلى وحدة تحكم I2P البعيدة على http://127.0.0.1:7657\nBackground Tunnels on Mac كما في Linux، يمكنك تشغيل الـ tunnel في الخلفية:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 استخدام الطرفية إعداد مفتاح SSH على Mac مطابق لنظام Linux:\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases الحفاظ على النفق نشطاً حالة الاستخدام الأكثر شيوعًا - الوصول إلى وحدة تحكم I2P router البعيدة الخاصة بك:\nssh -L 7657:127.0.0.1:7657 user@remote-server ثم افتح http://127.0.0.1:7657 في المتصفح الخاص بك.\nاستخدام مفاتيح SSH (موصى به) إعادة توجيه منافذ متعددة في وقت واحد:\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server هذا يُعيد توجيه كل من المنفذ 7657 (واجهة I2P) والمنفذ 7658 (خدمة أخرى).\nCustom Local Port استخدم منفذ محلي مختلف إذا كان المنفذ 7657 قيد الاستخدام بالفعل:\nssh -L 8080:127.0.0.1:7657 user@remote-server قم بالوصول إلى وحدة تحكم I2P على http://127.0.0.1:8080 بدلاً من ذلك.\nTroubleshooting استخدام الطرفية خطأ: \u0026ldquo;bind: Address already in use\u0026rdquo;\nالحل: اختر منفذ محلي مختلف أو أنهِ العملية التي تستخدم ذلك المنفذ:\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] أنفاق الخلفية على Mac خطأ: \u0026ldquo;Connection refused\u0026rdquo; أو \u0026ldquo;channel 2: open failed\u0026rdquo;\nالأسباب المحتملة: - الخدمة البعيدة غير قيد التشغيل (تحقق من أن router الـ I2P يعمل على الخادم البعيد) - جدار الحماية يحجب الاتصال - منفذ الوجهة غير صحيح\nالحل: تحقق من أن موجه I2P يعمل على الخادم البعيد:\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; إعداد مفتاح SSH على نظام Mac خطأ: \u0026ldquo;تم رفض الإذن\u0026rdquo; أو \u0026ldquo;فشلت المصادقة\u0026rdquo;\nالأسباب المحتملة: - اسم المستخدم أو كلمة المرور غير صحيحة - مفتاح SSH غير مُكوّن بشكل صحيح - وصول SSH معطّل على الخادم البعيد\nالحل: تحقق من بيانات الاعتماد وتأكد من تمكين وصول SSH على الخادم البعيد.\nTunnel Drops Connection خطأ: انقطاع الاتصال بعد فترة من عدم النشاط\nالحل: أضف إعدادات keep-alive إلى ملف تكوين SSH الخاص بك (~/.ssh/config):\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices استخدم مفاتيح SSH: أكثر أماناً من كلمات المرور، وأصعب في الاختراق عطّل المصادقة بكلمة المرور: بمجرد إعداد مفاتيح SSH، عطّل تسجيل الدخول بكلمة المرور على الخادم استخدم كلمات مرور قوية: إذا كنت تستخدم المصادقة بكلمة المرور، استخدم كلمة مرور قوية وفريدة قيّد الوصول إلى SSH: قم بتكوين قواعد جدار الحماية لتقييد الوصول إلى SSH على عناوين IP الموثوقة فقط حافظ على تحديث SSH: قم بتحديث برامج عميل وخادم SSH بانتظام راقب السجلات: تحقق من سجلات SSH على الخادم للكشف عن أي نشاط مشبوه استخدم منافذ SSH غير قياسية: قم بتغيير منفذ SSH الافتراضي (22) لتقليل الهجمات الآلية إنشاء أنفاق SSH على Linux الوصول إلى واجهة I2P Console أنشئ سكريبت لإنشاء الأنفاق تلقائيًا:\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; اجعله قابلاً للتنفيذ:\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh أنفاق متعددة أنشئ خدمة systemd لإنشاء الأنفاق تلقائيًا:\nsudo nano /etc/systemd/system/i2p-tunnel.service أضف:\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target تفعيل والبدء:\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling منفذ محلي مخصص قم بإنشاء بروكسي SOCKS للتوجيه الديناميكي:\nssh -D 8080 user@remote-server قم بتكوين متصفحك لاستخدام 127.0.0.1:8080 كوكيل SOCKS5.\nReverse Tunneling اسمح للخادم البعيد بالوصول إلى الخدمات على جهازك المحلي:\nssh -R 7657:127.0.0.1:7657 user@remote-server المنفذ قيد الاستخدام بالفعل النفق عبر خادم وسيط:\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion نفق SSH هو أداة قوية للوصول الآمن إلى أجهزة router البعيدة في I2P والخدمات الأخرى. سواء كنت تستخدم Windows أو Linux أو Mac، فإن العملية مباشرة وتوفر تشفيرًا قويًا لاتصالاتك.\nللحصول على مساعدة إضافية أو طرح أسئلة، قم بزيارة مجتمع I2P: - المنتدى: i2pforum.net - IRC: #i2p على شبكات مختلفة - التوثيق: I2P Docs خريطة طريق I2P تم اقتراح الميزات التالية لمشروع I2P. هذه ليست قائمة شاملة، ولا يوجد ضمان بأن أي شيء مدرج هنا سيتم تنفيذه. ومع ذلك، إنها مؤشر جيد على اتجاه المشروع.\nالأولويات الحالية الأداء والموثوقية تحسينات NTCP2 تحسينات SSU تحسين netDb للتعامل مع الشبكات الكبيرة تحسين اختيار نقاط floodfill تحسين إدارة tunnel تحسين أداء router الأمان تحديث خوارزميات التشفير تحسين garlic encryption تدقيق أمني للكود الأساسي تحسين حماية الخصوصية سهولة الاستخدام تحسين واجهة المستخدم لـ router تبسيط الإعداد الأولي تحسين الوثائق أدوات أفضل للمطورين التوافق والتكامل تحسين توافق SAMv3 تحسين دعم I2PTunnel واجهات برمجة تطبيقات أفضل للتطبيقات دعم أفضل للمنصات المحمولة الميزات المقترحة طويلة المدى تحسينات البروتوكول بروتوكولات نقل جديدة تحسينات على I2NP خوارزميات توجيه أفضل دعم محسّن لـ IPv6 قابلية التوسع دعم أفضل للشبكات الكبيرة تحسين أداء leaseSet معالجة موزعة لـ netDb تقسيم أفضل للشبكة التطوير أدوات اختبار محسنة بيئة تطوير أفضل مكتبات للغات برمجة إضافية وثائق محسنة للمطورين الدليل الأصلي من إعداد Stormy Cloud ، تم تكييفه لتوثيق I2P.\n","description":"تعلم كيفية إنشاء أنفاق SSH آمنة على Windows و Linux و Mac للوصول إلى router I2P البعيد الخاص بك","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"إنشاء نفق SSH للوصول إلى I2P عن بُعد","url":"/ar/docs/guides/%D8%A5%D9%86%D8%B4%D8%A7%D8%A1-%D9%86%D9%81%D9%82-ssh-%D9%84%D9%84%D9%88%D8%B5%D9%88%D9%84-%D8%A5%D9%84%D9%89-i2p-%D8%B9%D9%86-%D8%A8%D9%8F%D8%B9%D8%AF/"},{"categories":null,"content":"خوادم إعادة البذر (Reseed hosts) هي بنية تحتية حيوية لشبكة I2P، حيث توفر لأجهزة router الجديدة مجموعة أولية من العقد خلال عملية الإقلاع الأولي (bootstrap). سيرشدك هذا الدليل خلال إعداد وتشغيل خادم reseed خاص بك.\nما هو خادم إعادة البذر (Reseed Server) في I2P؟ يساعد خادم إعادة البذر (reseed server) في I2P على دمج أجهزة التوجيه الجديدة في شبكة I2P من خلال:\nتوفير الاكتشاف الأولي للنظراء: تتلقى أجهزة Router الجديدة مجموعة أولية من عقد الشبكة للاتصال بها استعادة Bootstrap: مساعدة أجهزة Router التي تواجه صعوبة في الحفاظ على الاتصالات التوزيع الآمن: عملية إعادة التوزيع (reseeding) مشفرة وموقعة رقمياً لضمان أمان الشبكة عندما يبدأ router I2P جديد للمرة الأولى (أو فقد جميع اتصالات النظراء الخاصة به)، فإنه يتصل بخوادم reseed لتنزيل مجموعة أولية من معلومات الـ router. هذا يسمح للـ router الجديد بالبدء في بناء قاعدة بيانات الشبكة الخاصة به وإنشاء tunnels.\nالمتطلبات الأساسية قبل البدء، ستحتاج إلى:\nخادم Linux (يُفضّل Debian/Ubuntu) مع صلاحيات root اسم نطاق يشير إلى خادمك ذاكرة وصول عشوائي لا تقل عن 1GB ومساحة قرص 10GB router I2P يعمل على الخادم لملء قاعدة بيانات الشبكة (netDb) إلمام أساسي بإدارة أنظمة Linux إعداد الخادم Step 1: Update System and Install Dependencies أولاً، قم بتحديث نظامك وتثبيت الحزم المطلوبة:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y هذا يثبت: - golang-go: بيئة تشغيل لغة البرمجة Go - git: نظام التحكم في الإصدارات - make: أداة أتمتة البناء - docker.io \u0026amp; docker-compose: منصة الحاويات لتشغيل Nginx Proxy Manager\nStep 2: Clone and Build Reseed Tools استنسخ مستودع reseed-tools وقم ببناء التطبيق:\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install حزمة reseed-tools توفر الوظائف الأساسية لتشغيل خادم reseed. تتعامل مع: - جمع معلومات router من قاعدة بيانات الشبكة المحلية الخاصة بك - تعبئة معلومات router في ملفات SU3 موقعة - تقديم هذه الملفات عبر HTTPS\nStep 3: Generate SSL Certificate قم بإنشاء شهادة SSL والمفتاح الخاص لخادم reseed الخاص بك:\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; المعاملات المهمة: - --signer: عنوان بريدك الإلكتروني (استبدل admin@stormycloud.org بعنوانك الخاص) - --netdb: المسار إلى قاعدة بيانات الشبكة الخاصة بموجه I2P - --port: المنفذ الداخلي (يُنصح باستخدام 8443) - --ip: الربط بـ localhost (سنستخدم reverse proxy للوصول العام) - --trustProxy: الوثوق برؤوس X-Forwarded-For من الـ reverse proxy\nسيقوم الأمر بإنشاء: - مفتاح خاص لتوقيع ملفات SU3 - شهادة SSL لاتصالات HTTPS الآمنة\nالخطوة 1: تحديث النظام وتثبيت التبعيات هام جداً: احتفظ بنسخة احتياطية آمنة للمفاتيح المُولّدة الموجودة في /home/i2p/.reseed/:\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ قم بتخزين هذه النسخة الاحتياطية في موقع آمن ومشفر مع وصول محدود. هذه المفاتيح ضرورية لتشغيل خادم إعادة البذر الخاص بك ويجب حمايتها بعناية.\nConfiguring the Service الخطوة 2: استنساخ وبناء أدوات Reseed أنشئ خدمة systemd لتشغيل خادم إعادة البذر تلقائيًا:\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF تذكر استبدال admin@stormycloud.org بعنوان بريدك الإلكتروني الخاص.\nالآن قم بتفعيل وبدء الخدمة:\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed تحقق من أن الخدمة قيد التشغيل:\nsudo systemctl status reseed الخطوة 3: إنشاء شهادة SSL للحصول على الأداء الأمثل، قد ترغب في إعادة تشغيل خدمة الـ reseed بشكل دوري لتحديث معلومات الـ router:\nsudo crontab -e أضف هذا السطر لإعادة تشغيل الخدمة كل 3 ساعات:\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy يعمل خادم reseed على localhost:8443 ويحتاج إلى reverse proxy للتعامل مع حركة HTTPS العامة. نوصي باستخدام Nginx Proxy Manager لسهولة استخدامه.\nالخطوة 4: احفظ نسخة احتياطية من مفاتيحك نشر Nginx Proxy Manager باستخدام Docker:\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest هذا يكشف: - المنفذ 80: حركة مرور HTTP - المنفذ 81: واجهة الإدارة - المنفذ 443: حركة مرور HTTPS\nConfigure Proxy Manager قم بالوصول إلى واجهة الإدارة على http://your-server-ip:81\nتسجيل الدخول باستخدام بيانات الاعتماد الافتراضية:\nالبريد الإلكتروني: admin@example.com كلمة المرور: changeme مهم: قم بتغيير بيانات الاعتماد هذه فوراً بعد تسجيل الدخول الأول!\nانتقل إلى Proxy Hosts وانقر على Add Proxy Host قم بتكوين مضيف الوكيل (proxy host): اسم النطاق: نطاق إعادة البذر الخاص بك (مثال: reseed.example.com) البروتوكول: https اسم المضيف / عنوان IP للتوجيه: 127.0.0.1 منفذ التوجيه: 8443 فعّل تخزين الأصول مؤقتاً (Cache Assets) فعّل حظر الثغرات الشائعة (Block Common Exploits) فعّل دعم Websockets في تبويب SSL: اختر Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) فعّل Force SSL فعّل HTTP/2 Support وافق على شروط خدمة Let\u0026rsquo;s Encrypt انقر على حفظ يجب أن يكون خادم إعادة التهيئة (reseed) الخاص بك متاحًا الآن على https://reseed.example.com\nRegistering Your Reseed Server بمجرد أن يصبح خادم إعادة البذر (reseed server) الخاص بك جاهزاً للعمل، اتصل بمطوري I2P لإضافته إلى قائمة خوادم إعادة البذر الرسمية.\nالخطوة 5: إنشاء خدمة Systemd راسل zzz (المطور الرئيسي لـ I2P) عبر البريد الإلكتروني بالمعلومات التالية:\nالبريد الإلكتروني على I2P: zzz@mail.i2p البريد الإلكتروني على Clearnet: zzz@i2pmail.org الخطوة 6: اختياري - تكوين عمليات إعادة التشغيل الدورية قم بتضمين ما يلي في بريدك الإلكتروني:\nعنوان URL لخادم Reseed: عنوان URL الكامل لبروتوكول HTTPS (مثال: https://reseed.example.com) شهادة reseed العامة: موجودة في /home/i2p/.reseed/ (أرفق ملف .crt) البريد الإلكتروني للتواصل: طريقة الاتصال المفضلة لديك لتلقي إشعارات صيانة الخادم موقع الخادم: اختياري لكنه مفيد (البلد/المنطقة) وقت التشغيل المتوقع: التزامك بصيانة الخادم Verification سيتحقق مطورو I2P من أن خادم إعادة البذر (reseed server) الخاص بك: - مُكوّن بشكل صحيح ويقدم معلومات الموجه (router) - يستخدم شهادات SSL صالحة - يوفر ملفات SU3 موقعة بشكل صحيح - متاح ويستجيب\nبمجرد الموافقة، سيتم إضافة خادم إعادة التوزيع الخاص بك إلى القائمة الموزعة مع أجهزة توجيه I2P، مما يساعد المستخدمين الجدد على الانضمام إلى الشبكة!\nMonitoring and Maintenance تثبيت Nginx Proxy Manager راقب خدمة إعادة البذر الخاصة بك:\nsudo systemctl status reseed sudo journalctl -u reseed -f تكوين مدير البروكسي راقب موارد النظام:\nhtop df -h Update Reseed Tools قم بتحديث reseed-tools بشكل دوري للحصول على أحدث التحسينات:\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed معلومات الاتصال إذا كنت تستخدم Let\u0026rsquo;s Encrypt من خلال Nginx Proxy Manager، فإن الشهادات ستتجدد تلقائياً. تحقق من أن التجديد يعمل:\ndocker logs nginx-proxy-manager | grep -i certificate تكوين الخدمة المعلومات المطلوبة تحقق من السجلات بحثًا عن الأخطاء:\nsudo journalctl -u reseed -n 50 المشاكل الشائعة: - router الخاص بـ I2P غير قيد التشغيل أو قاعدة بيانات الشبكة فارغة - المنفذ 8443 قيد الاستخدام بالفعل - مشاكل في الأذونات مع مجلد /home/i2p/.reseed/\nالتحقق تأكد من أن موجه I2P الخاص بك قيد التشغيل وقد ملأ قاعدة بيانات الشبكة الخاصة به:\nls -lh /home/i2p/.i2p/netDb/ يجب أن ترى العديد من ملفات .dat. إذا كانت فارغة، انتظر حتى يكتشف router الخاص بك I2P نظراء الشبكة.\nSSL Certificate Errors تحقق من صحة الشهادات الخاصة بك:\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com فحص حالة الخدمة تحقق من: - سجلات DNS تشير بشكل صحيح إلى الخادم الخاص بك - جدار الحماية يسمح بالمنافذ 80 و 443 - Nginx Proxy Manager يعمل: docker ps\nSecurity Considerations حافظ على أمان مفاتيحك الخاصة: لا تشارك أو تكشف محتويات /home/i2p/.reseed/ أبدًا التحديثات المنتظمة: حافظ على تحديث حزم النظام وDocker وreseed-tools راقب السجلات: راقب أنماط الوصول المشبوهة تحديد المعدل: فكر في تطبيق تحديد المعدل لمنع إساءة الاستخدام قواعد الجدار الناري: اكشف فقط المنافذ الضرورية (80، 443، 81 لواجهة الإدارة) واجهة الإدارة: قيّد الوصول إلى واجهة إدارة Nginx Proxy Manager (المنفذ 81) على عناوين IP الموثوقة فقط Contributing to the Network من خلال تشغيل خادم reseed، فإنك توفر بنية تحتية حيوية لشبكة I2P. شكراً لمساهمتك في إنترنت أكثر خصوصية ولامركزية!\nللأسئلة أو المساعدة، تواصل مع مجتمع I2P: - المنتدى: i2pforum.net - IRC/Reddit: #i2p على شبكات مختلفة - التطوير: i2pgit.org الدليل تم إنشاؤه في الأصل بواسطة Stormy Cloud ، معدل لتوثيق I2P.\n","description":"دليل شامل لإعداد وتشغيل خادم reseed من I2P لمساعدة أجهزة router الجديدة على الانضمام إلى الشبكة","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"إنشاء وتشغيل خادم إعادة البذر (Reseed Server) الخاص بـ I2P","url":"/ar/docs/guides/%D8%A5%D9%86%D8%B4%D8%A7%D8%A1-%D9%88%D8%AA%D8%B4%D8%BA%D9%8A%D9%84-%D8%AE%D8%A7%D8%AF%D9%85-%D8%A5%D8%B9%D8%A7%D8%AF%D8%A9-%D8%A7%D9%84%D8%A8%D8%B0%D8%B1-reseed-server-%D8%A7%D9%84%D8%AE%D8%A7%D8%B5-%D8%A8%D9%80-i2p/"},{"categories":null,"content":" تم إعداد فرع التطوير الرئيسي لـ I2P (i2p.i2p) لتمكين المطورين من إعداد اثنتين من بيئات التطوير المتكاملة الشائعة الاستخدام لتطوير Java بسهولة: Eclipse و NetBeans. Eclipse تحتوي فروع التطوير الرئيسية لـ I2P (i2p.i2p والفروع المتفرعة منها) على build.gradle لتمكين إعداد الفرع بسهولة في Eclipse. تأكد من أن لديك إصدار حديث من Eclipse. أي إصدار أحدث من 2017 سيفي بالغرض. قم بسحب فرع I2P إلى دليل ما (مثل $HOME/dev/i2p.i2p). اختر \"File → Import...\" ثم تحت \"Gradle\" اختر \"Existing Gradle Project\". في خانة \"Project root directory:\" اختر الدليل الذي تم سحب فرع I2P إليه. في مربع حوار \"Import Options\"، اختر \"Gradle Wrapper\" واضغط Continue. في مربع حوار \"Import Preview\" يمكنك مراجعة هيكل المشروع. يجب أن تظهر مشاريع متعددة تحت \"i2p.i2p\". اضغط \"Finish\". تم! يجب أن تحتوي مساحة العمل الخاصة بك الآن على جميع المشاريع داخل فرع I2P، ويجب أن تكون تبعيات البناء الخاصة بها معدة بشكل صحيح. NetBeans تحتوي فروع التطوير الرئيسية لـ I2P (i2p.i2p والفروع المشتقة منها) على ملفات مشروع NetBeans. \u0026lt;!-- احتفظ بالمحتوى بسيطاً وقريباً من النص الأصلي؛ سيتم التحديث لاحقاً. --\u0026gt; ","description":"إعداد Eclipse وNetBeans لتطوير I2P باستخدام Gradle وملفات المشروع المرفقة","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"استخدام بيئة تطوير متكاملة (IDE) مع I2P","url":"/ar/docs/guides/ides/"},{"categories":null,"content":"أداء شبكة I2P: السرعة والاتصالات وإدارة الموارد شبكة I2P ديناميكية بالكامل. كل عميل معروف للعقد الأخرى ويختبر العقد المعروفة محلياً من حيث إمكانية الوصول والقدرة. يتم حفظ العقد القابلة للوصول والقادرة فقط في NetDB محلية. أثناء عملية بناء الأنفاق، يتم اختيار أفضل الموارد من هذا المجمع لبناء الأنفاق. نظراً لأن الاختبار يحدث بشكل مستمر، فإن مجمع العقد يتغير. كل عقدة I2P تعرف جزءاً مختلفاً من NetDB، مما يعني أن كل router لديه مجموعة مختلفة من عقد I2P التي يمكن استخدامها للأنفاق. حتى لو كان لدى اثنين من routers نفس المجموعة الفرعية من العقد المعروفة، فمن المحتمل أن تظهر اختبارات إمكانية الوصول والقدرة نتائج مختلفة، حيث يمكن أن تكون routers الأخرى تحت حمل تشغيلي في الوقت الذي يختبر فيه router واحد، ولكنها تكون حرة عندما يختبر router الثاني.\nيصف هذا سبب امتلاك كل عقدة I2P عقدات مختلفة لبناء الأنفاق (tunnels). نظرًا لأن كل عقدة I2P لديها زمن استجابة (latency) وعرض نطاق (bandwidth) مختلفين، فإن الأنفاق (tunnels) (التي يتم بناؤها عبر تلك العقد) لها قيم زمن استجابة وعرض نطاق مختلفة. ولأن كل عقدة I2P لديها أنفاق مختلفة تم بناؤها، لا توجد عقدتا I2P لهما نفس مجموعات الأنفاق.\nيُعرف الخادم/العميل باسم \u0026ldquo;destination\u0026rdquo; ولكل destination نفق وارد واحد على الأقل ونفق صادر واحد. الإعداد الافتراضي هو 3 قفزات لكل نفق. وهذا يصل إلى 12 قفزة (12 عقدة I2P مختلفة) لرحلة ذهاب وإياب كاملة عميل ← خادم ← عميل.\nيتم إرسال كل حزمة بيانات عبر 6 عُقد I2P أخرى حتى تصل إلى الخادم:\nclient - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - server\nوفي طريق العودة 6 عُقد I2P مختلفة:\nserver - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - client\nحركة المرور على الشبكة تحتاج إلى إقرار استلام (ACK) قبل إرسال بيانات جديدة؛ تحتاج إلى الانتظار حتى يعود ACK من الخادم: إرسال البيانات، الانتظار للحصول على ACK، إرسال المزيد من البيانات، الانتظار للحصول على ACK. نظرًا لأن RTT (Round Trip Time - وقت الذهاب والإياب) يتراكم من زمن الاستجابة لكل عقدة I2P فردية ولكل اتصال في رحلة الذهاب والإياب هذه، فإنه يستغرق عادةً من 1 إلى 3 ثوانٍ حتى يعود ACK إلى العميل. بسبب تصميم TCP ونقل I2P، تكون حزمة البيانات ذات حجم محدود. معًا، تضع هذه الشروط حدًا أقصى للنطاق الترددي لكل tunnel بحوالي 20-50 كيلوبايت/ثانية. ومع ذلك، إذا كان لقفزة واحدة فقط في الـ tunnel نطاق ترددي قدره 5 كيلوبايت/ثانية فقط للإنفاق، فإن الـ tunnel بأكمله يقتصر على 5 كيلوبايت/ثانية، بغض النظر عن زمن الاستجابة والقيود الأخرى.\nالتشفير والكمون وكيفية بناء النفق يجعله مكلفًا جدًا من حيث وقت المعالج لبناء نفق. لهذا السبب يُسمح للوجهة بأن يكون لديها حد أقصى 6 أنفاق واردة و6 أنفاق صادرة لنقل البيانات. مع حد أقصى 50 كيلوبايت/ثانية لكل نفق، يمكن للوجهة استخدام ما يقارب 300 كيلوبايت/ثانية من حركة البيانات المجمعة (في الواقع يمكن أن يكون أكثر إذا تم استخدام أنفاق أقصر مع عدم إخفاء الهوية منخفض أو معدوم). يتم التخلص من الأنفاق المستخدمة كل 10 دقائق ويتم بناء أنفاق جديدة. هذا التغيير في الأنفاق، وأحيانًا العملاء الذين يتم إيقاف تشغيلهم أو يفقدون اتصالهم بالشبكة، سيؤدي في بعض الأحيان إلى كسر الأنفاق والاتصالات. يمكن رؤية مثال على ذلك في شبكة IRC2P في فقدان الاتصال (ping timeout) أو عند استخدام eepget.\nمع مجموعة محدودة من الوجهات ومجموعة محدودة من الأنفاق لكل وجهة، يستخدم عقدة I2P واحدة مجموعة محدودة فقط من الأنفاق عبر عقد I2P الأخرى. على سبيل المثال، إذا كانت عقدة I2P هي \u0026ldquo;hop1\u0026rdquo; في المثال الصغير أعلاه، فإنها ترى فقط نفقًا مشاركًا واحدًا ينشأ من العميل. إذا جمعنا شبكة I2P بأكملها، يمكن بناء عدد محدود نسبيًا فقط من الأنفاق المشاركة بكمية محدودة من النطاق الترددي مجتمعة. إذا وزعنا هذه الأعداد المحدودة على عدد عقد I2P، فلن يكون هناك سوى جزء بسيط من النطاق الترددي/السعة المتاحة للاستخدام.\nللبقاء مجهول الهوية، يجب ألا يُستخدم router واحد من قبل الشبكة بأكملها لبناء الأنفاق. إذا كان router واحد يعمل كـ tunnel router لجميع عُقد I2P، فإنه يصبح نقطة فشل مركزية حقيقية بالإضافة إلى نقطة مركزية لجمع عناوين IP والبيانات من العملاء. لهذا السبب تقوم الشبكة بتوزيع حركة المرور عبر العُقد في عملية بناء الأنفاق.\nاعتبار آخر للأداء هو الطريقة التي يتعامل بها I2P مع الشبكات الشبكية. كل قفزة اتصال من عقدة إلى أخرى تستخدم اتصال TCP أو UDP واحد على عقد I2P. مع 1000 اتصال، يرى المرء 1000 اتصال TCP. هذا عدد كبير جداً، وبعض أجهزة التوجيه المنزلية والمكتبية الصغيرة تسمح فقط بعدد صغير من الاتصالات. يحاول I2P الحد من هذه الاتصالات إلى أقل من 1500 لكل نوع UDP و TCP. هذا يحد من كمية البيانات المنقولة عبر عقدة I2P أيضاً.\nإذا كان العقدة قابلة للوصول، ولديها إعداد عرض نطاق \u0026gt;128 كيلوبايت/ثانية مشترك وقابلة للوصول على مدار الساعة طوال أيام الأسبوع، فيجب استخدامها بعد بعض الوقت لحركة المرور المشاركة. إذا كانت متوقفة في ما بينهما، فإن اختبار عقدة I2P الذي تقوم به العقد الأخرى سيخبرهم أنها غير قابلة للوصول. هذا يحظر العقدة لمدة 24 ساعة على الأقل على العقد الأخرى. لذلك، العقد الأخرى التي اختبرت تلك العقدة على أنها متوقفة لن تستخدم تلك العقدة لمدة 24 ساعة لبناء الأنفاق. هذا هو السبب في أن حركة المرور الخاصة بك تكون أقل بعد إعادة التشغيل/الإيقاف لموجه I2P الخاص بك لمدة لا تقل عن 24 ساعة.\nبالإضافة إلى ذلك، تحتاج عُقد I2P الأخرى إلى معرفة router I2P لاختباره من حيث إمكانية الوصول والسعة. يمكن تسريع هذه العملية عند التفاعل مع الشبكة، على سبيل المثال باستخدام التطبيقات أو زيارة مواقع I2P، مما سيؤدي إلى المزيد من بناء الأنفاق وبالتالي المزيد من النشاط وإمكانية الوصول للاختبار من قبل العُقد على الشبكة.\nسجل الأداء (مختارات) على مر السنين، شهد I2P عدداً من تحسينات الأداء البارزة:\nNative math تم التنفيذ عبر روابط JNI إلى مكتبة GNU MP (GMP) لتسريع عملية modPow في BigInteger، والتي كانت تستهلك معظم وقت المعالج سابقاً. أظهرت النتائج الأولية تسريعاً ملحوظاً في تشفير المفتاح العام. انظر: /misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) في السابق، كانت الردود تتطلب غالبًا البحث في قاعدة بيانات الشبكة عن LeaseSet الخاص بالمرسل. يؤدي تضمين LeaseSet الخاص بالمرسل في garlic الأولي إلى تحسين زمن استجابة الرد. يتم ذلك الآن بشكل انتقائي (بداية الاتصال أو عند تغيير LeaseSet) لتقليل النفقات الإضافية.\nالرياضيات الأصلية تم نقل بعض خطوات التحقق إلى مرحلة أبكر في مصافحة transport لرفض العقد السيئة بشكل أسرع (الساعات الخاطئة، NAT/جدار الحماية السيئ، الإصدارات غير المتوافقة)، مما يوفر المعالج وعرض النطاق الترددي.\nتغليف LeaseSet \u0026ldquo;الرد\u0026rdquo; بتقنية Garlic (محسّن) استخدم اختبار الأنفاق الواعي بالسياق: تجنب اختبار الأنفاق المعروفة بالفعل بأنها تمرر البيانات؛ فضّل الاختبار عندما تكون خاملة. هذا يقلل من العبء ويسرّع اكتشاف الأنفاق الفاشلة.\nرفض TCP أكثر كفاءة الاحتفاظ بالاختيارات لاتصال معين يقلل من التسليم خارج الترتيب ويسمح لمكتبة البث بزيادة أحجام النوافذ، مما يحسن الإنتاجية.\nتعديلات اختبار الأنفاق (Tunnel) GZip أو ما شابه للهياكل الطويلة (على سبيل المثال، خيارات RouterInfo) يقلل من عرض النطاق الترددي عند الاقتضاء.\nاختيار النفق/الإيجار الثابت بديل لبروتوكول \u0026ldquo;ministreaming\u0026rdquo; البسيط. يتضمن streaming الحديث إقرارات استلام انتقائية (selective ACKs) والتحكم في الازدحام المصمم خصيصاً لبيئة I2P المجهولة الموجهة للرسائل. انظر: /docs/api/streaming/\nFuture Performance Improvements (historical ideas) فيما يلي أفكار موثقة تاريخياً كتحسينات محتملة. العديد منها أصبح قديماً، أو تم تنفيذه، أو تم استبداله بتغييرات معمارية.\nضغط هياكل البيانات المحددة تحسين كيفية اختيار أجهزة التوجيه للنظراء عند بناء الأنفاق لتجنب الأجهزة البطيئة أو المثقلة بالأحمال، مع الحفاظ على المقاومة ضد هجمات Sybil من قبل خصوم أقوياء.\nبروتوكول البث الكامل قلل الاستكشاف غير الضروري عندما تكون مساحة المفاتيح مستقرة؛ اضبط عدد الأقران المُرجعة في عمليات البحث وعدد عمليات البحث المتزامنة التي يتم تنفيذها.\nSession Tag tuning and improvements (legacy) بالنسبة لمخطط ElGamal/AES+SessionTag القديم، تؤدي استراتيجيات الانتهاء والتجديد الأكثر ذكاءً إلى تقليل العودة إلى ElGamal وتقليل الـ tags المهدرة.\nتحسين تحليل واختيار النظراء إنشاء العلامات من PRNG متزامن يتم إنشاؤه أثناء إنشاء جلسة جديدة، مما يقلل من العبء لكل رسالة مقارنة بالعلامات المسلمة مسبقاً.\nضبط قاعدة بيانات الشبكة فترات حياة أطول للأنفاق (tunnel) مقترنة بالإصلاح التلقائي (healing) يمكن أن تقلل من أعباء إعادة البناء؛ مع الموازنة بين عدم الكشف عن الهوية والموثوقية.\nضبط وتحسينات علامة الجلسة (Session Tag) (قديم) رفض النظراء غير الصالحين مبكرًا وجعل اختبارات الأنفاق أكثر وعيًا بالسياق لتقليل التنافس والكمون.\nترحيل SessionTag إلى PRNG متزامن (قديم) تجميع LeaseSet الانتقائي، وخيارات RouterInfo المضغوطة، واعتماد بروتوكول البث الكامل، كلها تساهم في تحسين الأداء الملموس.\nانظر أيضاً:\nتوجيه الأنفاق (Tunnel Routing) اختيار النظراء (Peer Selection) بروتوكولات النقل (Transports) مواصفات SSU2 و مواصفات NTCP2 ","description":"أداء شبكة I2P: كيف تعمل اليوم، التحسينات التاريخية، وأفكار للضبط المستقبلي","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"الأداء","url":"/ar/docs/overview/performance/"},{"categories":null,"content":"مساعدة موجه I2P ما هي الأنظمة التي يعمل عليها I2P؟ تم كتابة I2P بلغة البرمجة Java. وقد تم اختباره على Windows وLinux وFreeBSD وOSX. كما يتوفر إصدار لنظام Android.\nمن حيث استخدام الذاكرة، تم تكوين I2P لاستخدام 128 ميجابايت من الذاكرة العشوائية افتراضيًا. هذا كافٍ للتصفح واستخدام IRC. ومع ذلك، قد تتطلب الأنشطة الأخرى تخصيص ذاكرة أكبر. على سبيل المثال، إذا أراد المرء تشغيل router عالي النطاق الترددي، أو المشاركة في تورنت I2P أو تقديم خدمات مخفية ذات حركة مرور عالية، فإن ذلك يتطلب كمية أكبر من الذاكرة.\nمن حيث استخدام المعالج، تم اختبار I2P للعمل على أنظمة متواضعة مثل مجموعة أجهزة Raspberry Pi ذات اللوحة الواحدة. نظرًا لأن I2P يستخدم بكثافة التقنيات التشفيرية، فإن معالجًا أقوى سيكون أكثر ملاءمة للتعامل مع عبء العمل الناتج عن I2P بالإضافة إلى المهام المتعلقة ببقية النظام (أي نظام التشغيل، واجهة المستخدم الرسومية، العمليات الأخرى مثل تصفح الويب).\nيُوصى باستخدام Sun/Oracle Java أو OpenJDK.\nهل تثبيت Java مطلوب لاستخدام I2P؟ نعم، Java مطلوبة لاستخدام I2P Core. نحن نضمّن Java داخل برامج التثبيت السهلة الخاصة بنا لأنظمة Windows وMac OSX وLinux. إذا كنت تستخدم تطبيق I2P على Android، ستحتاج أيضًا إلى بيئة تشغيل Java مثل Dalvik أو ART مثبتة في معظم الحالات.\nما هو \u0026ldquo;موقع I2P\u0026rdquo; وكيف أقوم بتكوين متصفحي حتى أتمكن من استخدامها؟ موقع I2P هو موقع ويب عادي باستثناء أنه يتم استضافته داخل I2P. مواقع I2P لها عناوين تبدو مثل عناوين الإنترنت العادية، تنتهي بـ \u0026ldquo;.i2p\u0026rdquo; بطريقة قابلة للقراءة البشرية وغير تشفيرية، لصالح الأشخاص. في الواقع، يتطلب الاتصال بموقع I2P التشفير، مما يعني أن عناوين مواقع I2P هي أيضاً عناوين \u0026ldquo;Base64\u0026rdquo; الطويلة (Destinations) والعناوين الأقصر \u0026ldquo;B32\u0026rdquo;. قد تحتاج إلى إجراء تكوين إضافي للتصفح بشكل صحيح. يتطلب تصفح مواقع I2P تفعيل HTTP Proxy في تثبيت I2P الخاص بك ثم تكوين متصفحك لاستخدامه. لمزيد من المعلومات، تصفح قسم \u0026ldquo;المتصفحات\u0026rdquo; أدناه أو دليل \u0026ldquo;تكوين المتصفح\u0026rdquo;.\nما معنى أرقام النشط x/y في وحدة التحكم بالموجه؟ في صفحة النظراء (Peers) على وحدة تحكم الموجه الخاص بك، قد ترى رقمين - نشط x/y. الرقم الأول هو عدد النظراء الذين أرسلت إليهم أو استقبلت منهم رسالة خلال الدقائق القليلة الماضية. الرقم الثاني هو عدد النظراء الذين تمت رؤيتهم مؤخراً، وسيكون هذا الرقم دائماً أكبر من أو مساوياً للرقم الأول.\nجهاز التوجيه الخاص بي لديه عدد قليل جدًا من الأقران النشطين، هل هذا طبيعي؟ نعم، هذا يمكن أن يكون طبيعياً، خاصةً عندما يكون الـ router قد بدأ للتو. سيحتاج الـ routers الجديدة إلى وقت للبدء والاتصال ببقية الشبكة. للمساعدة في تحسين التكامل مع الشبكة ووقت التشغيل والأداء، راجع هذه الإعدادات:\nمشاركة النطاق الترددي - إذا تم تكوين router لمشاركة النطاق الترددي، فسيقوم بتوجيه المزيد من حركة المرور لأجهزة router أخرى مما يساعد على دمجه مع بقية الشبكة، بالإضافة إلى تحسين أداء الاتصال المحلي للمستخدم. يمكن تكوين ذلك على صفحة http://localhost:7657/config . واجهة الشبكة - تأكد من عدم وجود واجهة محددة على صفحة http://localhost:7657/confignet . يمكن أن يؤدي هذا إلى تقليل الأداء ما لم يكن جهاز الكمبيوتر الخاص بك متعدد الوصلات مع عناوين IP خارجية متعددة. بروتوكول I2NP - تأكد من أن router مُكوّن لتوقع الاتصالات على بروتوكول صالح لنظام تشغيل المضيف وإعدادات الشبكة (متقدم) الفارغة. لا تدخل عنوان IP في حقل \u0026lsquo;اسم المضيف\u0026rsquo; في صفحة تكوين الشبكة. سيتم استخدام بروتوكول I2NP الذي تحدده هنا فقط إذا لم يكن لديك عنوان قابل للوصول بالفعل. معظم اتصالات Verizon 4G و 5G اللاسلكية في الولايات المتحدة، على سبيل المثال، تحظر UDP ولا يمكن الوصول إليها عبره. قد يستخدم آخرون UDP بالقوة حتى لو كان متاحًا لهم. اختر إعدادًا معقولاً من بروتوكولات I2NP المدرجة. أنا معارض لأنواع معينة من المحتوى. كيف أمنع توزيعها أو تخزينها أو الوصول إليها؟ لا يتم تثبيت أي من هذه المواد بشكل افتراضي. ومع ذلك، نظرًا لأن I2P هي شبكة نظير إلى نظير (peer-to-peer)، فمن المحتمل أن تصادف محتوى محظورًا عن طريق الخطأ. فيما يلي ملخص لكيفية منع I2P من تورطك بشكل غير ضروري في انتهاكات معتقداتك.\nالتوزيع - حركة المرور داخلية لشبكة I2P، أنت لست عقدة خروج (يُشار إليها باسم outproxy في وثائقنا). التخزين - شبكة I2P لا تقوم بالتخزين الموزع للمحتوى، يجب تثبيت ذلك وتكوينه بشكل خاص من قبل المستخدم (باستخدام Tahoe-LAFS، على سبيل المثال). هذه ميزة لشبكة مجهولة مختلفة، Freenet . بتشغيل router على I2P، أنت لا تقوم بتخزين محتوى لأي شخص. الوصول - لن يطلب router الخاص بك أي محتوى دون تعليمات محددة منك للقيام بذلك. هل من الممكن حظر I2P؟ نعم، الطريقة الأسهل والأكثر شيوعاً بكثير هي من خلال حظر خوادم bootstrap أو \u0026ldquo;Reseed\u0026rdquo;. كما أن حظر جميع البيانات المشفرة بالكامل سيعمل أيضاً (على الرغم من أن ذلك سيعطل العديد والعديد من الأشياء الأخرى التي ليست I2P ومعظم الجهات غير راغبة في الذهاب إلى هذا الحد). في حالة حظر reseed، هناك حزمة reseed على Github، وحظرها سيؤدي أيضاً إلى حظر Github. يمكنك إجراء reseed عبر بروكسي (يمكن العثور على العديد منها على الإنترنت إذا كنت لا ترغب في استخدام Tor) أو مشاركة حزم reseed على أساس صديق إلى صديق دون اتصال بالإنترنت.\nفي wrapper.log أرى خطأ ينص على \u0026ldquo;Protocol family unavailable\u0026rdquo; عند تحميل Router Console غالباً ما يحدث هذا الخطأ مع أي برنامج java متصل بالشبكة على بعض الأنظمة المكونة لاستخدام IPv6 بشكل افتراضي. هناك عدة طرق لحل هذه المشكلة:\nعلى أنظمة Linux، يمكنك تنفيذ echo 0 \u0026gt; /proc/sys/net/ipv6/bindv6only ابحث عن الأسطر التالية في wrapper.config: #wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true #wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false إذا كانت الأسطر موجودة، قم بإلغاء التعليق عنها بإزالة علامات \u0026ldquo;#\u0026rdquo;. إذا لم تكن الأسطر موجودة، أضفها بدون علامات \u0026ldquo;#\u0026rdquo;. خيار آخر هو إزالة ::1 من ~/.i2p/clients.config\nتحذير: لكي تصبح أي تغييرات على wrapper.config سارية المفعول، يجب عليك إيقاف الراوتر والـ wrapper بشكل كامل. النقر على إعادة التشغيل في وحدة تحكم الراوتر الخاص بك لن يعيد قراءة هذا الملف! يجب عليك النقر على إيقاف التشغيل، والانتظار 11 دقيقة، ثم بدء تشغيل I2P.\nمعظم مواقع I2P داخل I2P متوقفة؟ إذا أخذت بعين الاعتبار كل موقع I2P Site الذي تم إنشاؤه على الإطلاق، نعم، معظمها متوقف عن العمل. الأشخاص ومواقع I2P Sites تأتي وتذهب. طريقة جيدة للبدء في I2P هي الاطلاع على قائمة بمواقع I2P Sites النشطة حاليًا. يتتبع identiguy.i2p مواقع I2P Sites النشطة.\nلماذا يستمع I2P على المنفذ 32000؟ غلاف خدمة Tanuki Java الذي نستخدمه يفتح هذا المنفذ — المرتبط بـ localhost — من أجل التواصل مع البرمجيات التي تعمل داخل JVM. عندما يتم تشغيل JVM يُعطى مفتاحاً حتى يتمكن من الاتصال بالغلاف. بعد أن يُنشئ JVM اتصاله بالغلاف، يرفض الغلاف أي اتصالات إضافية.\nيمكن العثور على مزيد من المعلومات في توثيق wrapper .\nكيف أقوم بتكوين المتصفح الخاص بي؟ إعدادات الوكيل (proxy) للمتصفحات المختلفة موجودة في صفحة منفصلة مع لقطات الشاشة. الإعدادات الأكثر تقدمًا باستخدام أدوات خارجية، مثل إضافة المتصفح FoxyProxy أو خادم الوكيل Privoxy، ممكنة لكنها قد تتسبب في تسريبات في إعداداتك.\nكيف أتصل بـ IRC داخل I2P؟ يتم إنشاء نفق إلى خادم IRC الرئيسي داخل I2P، وهو Irc2P، عند تثبيت I2P (راجع صفحة إعدادات I2PTunnel )، ويتم تشغيله تلقائيًا عند بدء تشغيل router الخاص بـ I2P. للاتصال به، اطلب من عميل IRC الخاص بك الاتصال بـ localhost 6668. يمكن لمستخدمي عملاء مثل HexChat إنشاء شبكة جديدة مع الخادم localhost/6668 (تذكر تحديد \u0026ldquo;Bypass proxy server\u0026rdquo; إذا كان لديك خادم بروكسي مُعد). يمكن لمستخدمي Weechat استخدام الأمر التالي لإضافة شبكة جديدة:\n/server add irc2p localhost/6668 كيف أقوم بإعداد موقع I2P الخاص بي؟ أسهل طريقة هي النقر على رابط i2ptunnel في لوحة تحكم الـ router والقيام بإنشاء \u0026lsquo;Server Tunnel\u0026rsquo; جديد. يمكنك تقديم محتوى ديناميكي عن طريق تعيين وجهة الـ tunnel إلى منفذ خادم ويب موجود، مثل Tomcat أو Jetty. يمكنك أيضًا تقديم محتوى ثابت. لهذا، قم بتعيين وجهة الـ tunnel إلى: 0.0.0.0 port 7659 وضع المحتوى في دليل ~/.i2p/eepsite/docroot/. (على الأنظمة غير Linux، قد يكون هذا في مكان مختلف. تحقق من لوحة تحكم الـ router.) يأتي برنامج \u0026rsquo;eepsite\u0026rsquo; كجزء من حزمة تثبيت I2P ومعد للبدء تلقائيًا عند بدء تشغيل I2P. يمكن الوصول إلى الموقع الافتراضي الذي يتم إنشاؤه على http://127.0.0.1:7658. ومع ذلك، فإن \u0026rsquo;eepsite\u0026rsquo; الخاص بك يمكن الوصول إليه أيضًا من قبل الآخرين عبر ملف مفتاح eepsite الخاص بك، الموجود في: ~/.i2p/eepsite/i2p/eepsite.keys. لمعرفة المزيد، اقرأ ملف readme في: ~/.i2p/eepsite/README.txt.\nإذا استضفت موقعًا إلكترونيًا على I2P في المنزل، يحتوي على HTML و CSS فقط، هل هذا خطير؟ يعتمد ذلك على خصمك ونموذج التهديد الخاص بك. إذا كنت قلقًا فقط من انتهاكات \u0026ldquo;الخصوصية\u0026rdquo; من قبل الشركات، أو المجرمين العاديين، أو الرقابة، فإن الأمر ليس خطيرًا حقًا. ستجدك جهات إنفاذ القانون على الأرجح في النهاية إذا أرادت ذلك حقًا. إن الاستضافة فقط عندما يكون لديك متصفح مستخدم منزلي عادي (للإنترنت) قيد التشغيل سيجعل من الصعب جدًا معرفة من يستضيف ذلك الجزء. يرجى النظر إلى استضافة موقع I2P الخاص بك تمامًا كاستضافة أي خدمة أخرى - إنه خطير - أو آمن - بقدر ما تقوم بتكوينه وإدارته بنفسك.\nملاحظة: توجد بالفعل طريقة لفصل استضافة خدمة i2p (destination) عن router الخاص بـ i2p. إذا كنت تفهم كيف يعمل ذلك، فيمكنك ببساطة إعداد جهاز منفصل كخادم للموقع الإلكتروني (أو الخدمة) الذي سيكون متاحًا للعامة وإعادة توجيهه إلى خادم الويب عبر نفق SSH آمن [للغاية] أو استخدام نظام ملفات مشترك وآمن.\nكيف يعثر I2P على مواقع \u0026ldquo;.i2p\u0026rdquo;؟ تطبيق دفتر العناوين في I2P يربط الأسماء المقروءة بشرياً بالوجهات طويلة الأمد المرتبطة بالخدمات، مما يجعله أشبه بملف المضيفين أو قائمة جهات الاتصال بدلاً من قاعدة بيانات الشبكة أو خدمة DNS. كما أنه محلي أولاً - لا يوجد نطاق عام معترف به، فأنت تقرر ما يرتبط به أي نطاق .i2p في النهاية. الحل الوسط هو ما يسمى \u0026ldquo;خدمة القفز\u0026rdquo; (Jump Service) التي توفر اسماً مقروءاً بشرياً من خلال إعادة توجيهك إلى صفحة حيث سيُطلب منك \u0026ldquo;هل تمنح router الـ I2P إذناً لتسمية $SITE_CRYPTO_KEY بالاسم $SITE_NAME.i2p\u0026rdquo; أو ما شابه ذلك. بمجرد إضافته إلى دفتر عناوينك، يمكنك إنشاء روابط القفز الخاصة بك للمساعدة في مشاركة الموقع مع الآخرين.\nكيف أقوم بإضافة عناوين إلى دفتر العناوين؟ لا يمكنك إضافة عنوان دون معرفة base32 أو base64 على الأقل للموقع الذي تريد زيارته. \u0026ldquo;اسم المضيف\u0026rdquo; القابل للقراءة البشرية هو مجرد اسم مستعار للعنوان التشفيري، والذي يتوافق مع base32 أو base64. بدون العنوان التشفيري، لا توجد طريقة للوصول إلى موقع I2P، وهذا بالتصميم. توزيع العنوان على الأشخاص الذين لا يعرفونه بعد هو عادةً مسؤولية مزود خدمة Jump. زيارة موقع I2P غير معروف ستؤدي إلى استخدام خدمة Jump. stats.i2p هي خدمة Jump الأكثر موثوقية.\nإذا كنت تستضيف موقعًا عبر i2ptunnel، فلن يكون لديه تسجيل مع خدمة القفز بعد. لإعطائه عنوان URL محليًا، قم بزيارة صفحة التكوين وانقر على الزر الذي يقول \u0026ldquo;Add to Local Address Book\u0026rdquo;. ثم انتقل إلى http://127.0.0.1:7657/dns للبحث عن عنوان URL الخاص بـ addresshelper ومشاركته.\nما هي المنافذ التي يستخدمها I2P؟ المنافذ المستخدمة من قبل I2P يمكن تقسيمها إلى قسمين:\nالمنافذ المواجهة للإنترنت، والتي تُستخدم للاتصال مع أجهزة router أخرى في I2P المنافذ المحلية، للاتصالات المحلية يتم وصف هذه بالتفصيل أدناه.\n1. المنافذ المواجهة للإنترنت ملاحظة: منذ الإصدار 0.7.8، التثبيتات الجديدة لا تستخدم المنفذ 8887؛ يتم اختيار منفذ عشوائي بين 9000 و 31000 عند تشغيل البرنامج لأول مرة. يظهر المنفذ المحدد في صفحة إعدادات الموجه .\nصادر\nUDP من المنفذ العشوائي المدرج في صفحة التكوين إلى منافذ UDP بعيدة عشوائية، مع السماح بالردود TCP من منافذ عالية عشوائية إلى منافذ TCP بعيدة عشوائية UDP صادر على المنفذ 123، مع السماح بالردود. هذا ضروري لمزامنة الوقت الداخلية لـ I2P (عبر SNTP - الاستعلام من مضيف SNTP عشوائي في pool.ntp.org أو خادم آخر تحدده) الوارد\n(اختياري، موصى به) UDP إلى المنفذ المذكور في صفحة الإعدادات من مواقع عشوائية (اختياري، موصى به) TCP إلى المنفذ المذكور في صفحة الإعدادات من مواقع عشوائية يمكن تعطيل TCP الوارد في صفحة الإعدادات 2. منافذ I2P المحلية منافذ I2P المحلية تستمع فقط للاتصالات المحلية بشكل افتراضي، إلا حيث يُذكر خلاف ذلك:\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. ### أفتقد الكثير من المضيفين في دفتر العناوين الخاص بي. ما هي بعض روابط الاشتراك الجيدة؟ {#subscriptions} يقع دفتر العناوين على http://localhost:7657/dns حيث يمكن العثور على مزيد من المعلومات.\nما هي بعض روابط الاشتراك الجيدة في دفتر العناوين؟\nيمكنك تجربة ما يلي:\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt كيف يمكنني الوصول إلى وحدة التحكم عبر الويب من أجهزتي الأخرى أو حمايتها بكلمة مرور؟ لأغراض أمنية، لوحة إدارة الراوتر (router) افتراضياً تستقبل الاتصالات فقط على الواجهة المحلية.\nهناك طريقتان للوصول إلى وحدة التحكم عن بُعد:\nنفق SSH تكوين وحدة التحكم الخاصة بك لتكون متاحة على عنوان IP عام باستخدام اسم مستخدم وكلمة مرور هذه موضحة بالتفصيل أدناه:\nالطريقة 1: نفق SSH\nإذا كنت تستخدم نظام تشغيل شبيه بـ Unix، فهذه هي أسهل طريقة للوصول عن بُعد إلى وحدة تحكم I2P الخاصة بك. (ملاحظة: برنامج خادم SSH متاح للأنظمة التي تعمل بنظام Windows، على سبيل المثال https://github.com/PowerShell/Win32-OpenSSH )\nبمجرد تكوين وصول SSH إلى نظامك، يتم تمرير العلم \u0026lsquo;-L\u0026rsquo; إلى SSH مع الوسائط المناسبة - على سبيل المثال:\nssh -L 7657:localhost:7657 (System_IP) حيث يتم استبدال \u0026lsquo;(System_IP)\u0026rsquo; بعنوان IP الخاص بنظامك. يقوم هذا الأمر بإعادة توجيه المنفذ 7657 (الرقم قبل النقطتين الأولى) إلى المنفذ 7657 (الرقم بعد النقطتين الثانية) الخاص بالنظام البعيد (كما هو محدد بالنص \u0026rsquo;localhost\u0026rsquo; بين النقطتين الأولى والثانية). ستكون وحدة تحكم I2P البعيدة الخاصة بك متاحة الآن على نظامك المحلي كـ \u0026lsquo;http://localhost:7657\u0026rsquo; وستظل متاحة طالما أن جلسة SSH الخاصة بك نشطة.\nإذا كنت ترغب في بدء جلسة SSH دون تشغيل shell على النظام البعيد، يمكنك إضافة العلم \u0026lsquo;-N\u0026rsquo;:\nssh -NL 7657:localhost:7657 (System_IP) الطريقة الثانية: تكوين وحدة التحكم الخاصة بك لتكون متاحة على عنوان IP عام باستخدام اسم مستخدم وكلمة مرور\nافتح ~/.i2p/clients.config واستبدل:\nclientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ بـ:\nclientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ حيث تستبدل (System_IP) بعنوان IP العام لنظامك\nانتقل إلى http://localhost:7657/configui وأضف اسم مستخدم وكلمة مرور لوحة التحكم إذا رغبت - يُوصى بشدة بإضافة اسم مستخدم وكلمة مرور لتأمين وحدة تحكم I2P الخاصة بك من التلاعب، والذي قد يؤدي إلى كشف الهوية.\nانتقل إلى http://localhost:7657/index واضغط على \u0026ldquo;Graceful restart\u0026rdquo;، والذي يعيد تشغيل JVM ويعيد تحميل تطبيقات العميل\nبعد بدء التشغيل، يجب أن تتمكن الآن من الوصول إلى وحدة التحكم عن بُعد. قم بتحميل وحدة تحكم الراوتر على http://(System_IP):7657 وسيُطلب منك إدخال اسم المستخدم وكلمة المرور التي حددتها في الخطوة 2 أعلاه إذا كان متصفحك يدعم نافذة المصادقة المنبثقة.\nملاحظة: يمكنك تحديد 0.0.0.0 في التكوين أعلاه. هذا يحدد واجهة، وليس شبكة أو netmask. 0.0.0.0 تعني \u0026ldquo;الربط بجميع الواجهات\u0026rdquo;، لذلك يمكن الوصول إليها على 127.0.0.1:7657 بالإضافة إلى أي عنوان IP على الشبكة المحلية/الشبكة الواسعة. كن حذرًا عند استخدام هذا الخيار لأن وحدة التحكم ستكون متاحة على جميع العناوين المكونة على نظامك.\nكيف يمكنني استخدام التطبيقات من أجهزتي الأخرى؟ يرجى الاطلاع على الإجابة السابقة للحصول على تعليمات حول استخدام إعادة توجيه منفذ SSH، وانظر أيضًا هذه الصفحة في وحدة التحكم الخاصة بك: http://localhost:7657/configi2cp هل من الممكن استخدام I2P كوكيل SOCKS؟ بروكسي SOCKS يعمل بشكل وظيفي منذ الإصدار 0.7.1. يتم دعم SOCKS 4/4a/5. لا يحتوي I2P على بروكسي خارجي SOCKS outproxy لذلك يقتصر استخدامه داخل I2P فقط.\nتقوم العديد من التطبيقات بتسريب معلومات حساسة يمكن أن تكشف هويتك على الإنترنت، وهذا خطر يجب أن تكون على دراية به عند استخدام بروكسي SOCKS الخاص بـ I2P. يقوم I2P فقط بتصفية بيانات الاتصال، ولكن إذا قام البرنامج الذي تنوي تشغيله بإرسال هذه المعلومات كمحتوى، فلن يكون لدى I2P أي طريقة لحماية هويتك المجهولة. على سبيل المثال، بعض تطبيقات البريد الإلكتروني ترسل عنوان IP الخاص بالجهاز الذي تعمل عليه إلى خادم البريد. نوصي باستخدام أدوات أو تطبيقات خاصة بـ I2P (مثل I2PSnark للتورنت)، أو التطبيقات المعروفة بأنها آمنة للاستخدام مع I2P والتي تشمل الإضافات الشائعة الموجودة على Firefox .\nكيف يمكنني الوصول إلى IRC أو BitTorrent أو خدمات أخرى على الإنترنت العادي؟ هناك خدمات تسمى Outproxies تربط بين I2P والإنترنت، مثل Tor Exit Nodes. يتم توفير وظيفة outproxy الافتراضية لـ HTTP و HTTPS بواسطة exit.stormycloud.i2p وتديرها شركة StormyCloud Inc. يتم تكوينها في HTTP Proxy. بالإضافة إلى ذلك، للمساعدة في حماية عدم الكشف عن الهوية، لا يسمح لك I2P بإجراء اتصالات مجهولة بالإنترنت العادي بشكل افتراضي. يرجى الاطلاع على صفحة Socks Outproxy لمزيد من المعلومات.\nإعادة البذر (Reseeds) جهاز التوجيه الخاص بي يعمل منذ عدة دقائق ولديه صفر أو عدد قليل جداً من الاتصالات أولاً، تحقق من صفحة http://127.0.0.1:7657/netdb في وحدة تحكم الـ Router – قاعدة بيانات الشبكة الخاصة بك. إذا لم تشاهد أي router مدرج من داخل I2P لكن وحدة التحكم تشير إلى أنك محمي بجدار ناري، فمن المحتمل أنك لا تستطيع الاتصال بخوادم reseed. إذا كنت تشاهد routers أخرى من I2P مدرجة، فحاول تقليل عدد الاتصالات القصوى في http://127.0.0.1:7657/config ربما لا يستطيع الـ router الخاص بك التعامل مع اتصالات كثيرة.\nكيف أقوم بإعادة البذر يدويًا؟ في الظروف العادية، سيقوم I2P بتوصيلك بالشبكة تلقائياً باستخدام روابط التمهيد الخاصة بنا. إذا تسبب انقطاع الإنترنت في فشل التمهيد من خوادم إعادة البذر (reseed servers)، فإن طريقة سهلة للتمهيد هي استخدام متصفح Tor (يفتح localhost افتراضياً)، والذي يعمل بشكل ممتاز مع http://127.0.0.1:7657/configreseed . من الممكن أيضاً إعادة بذر router الخاص بـ I2P يدوياً.\nعند استخدام متصفح Tor لإعادة التحميل (reseed)، يمكنك تحديد عدة عناوين URL في وقت واحد والمتابعة. على الرغم من أن القيمة الافتراضية وهي 2 (من بين عدة عناوين url) ستعمل أيضًا، لكنها ستكون بطيئة.\nالخصوصية-الأمان هل جهاز التوجيه الخاص بي يعمل كـ \u0026ldquo;exit node\u0026rdquo; (outproxy) للإنترنت العادي؟ لا أريد ذلك. لا، يشارك الـ router الخاص بك في نقل حركة البيانات المشفرة من طرف إلى طرف (e2e) عبر شبكة i2p إلى نقطة نهاية tunnel عشوائية، وعادة ليس outproxy، ولكن لا يتم تمرير أي حركة بيانات بين الـ router الخاص بك والإنترنت عبر طبقة النقل. كمستخدم نهائي، لا يجب عليك تشغيل outproxy إذا لم تكن ماهرًا في إدارة الأنظمة والشبكات.\nهل من السهل اكتشاف استخدام I2P من خلال تحليل حركة مرور الشبكة؟ عادةً ما تبدو حركة مرور I2P مثل حركة مرور UDP، وليس أكثر من ذلك بكثير - وجعلها تبدو بهذا الشكل هو هدف. كما أنها تدعم TCP. مع بعض الجهد، قد يتمكن التحليل السلبي لحركة المرور من تصنيف الحركة على أنها \u0026ldquo;I2P\u0026rdquo;، لكننا نأمل أن يؤدي التطوير المستمر لتعتيم حركة المرور إلى تقليل ذلك بشكل أكبر. حتى طبقة تعتيم بروتوكول بسيطة نسبيًا مثل obfs4 ستمنع الرقابة من حظر I2P (وهو هدف ينفذه I2P).\nهل استخدام I2P آمن؟ يعتمد ذلك على نموذج التهديد الشخصي الخاص بك. بالنسبة لمعظم الناس، I2P أكثر أمانًا بكثير من عدم استخدام أي حماية. بعض الشبكات الأخرى (مثل Tor أو mixminion/mixmaster)، ربما تكون أكثر أمانًا ضد خصوم معينين. على سبيل المثال، حركة بيانات I2P لا تستخدم TLS/SSL، لذا لا تعاني من مشكلات \u0026ldquo;الحلقة الأضعف\u0026rdquo; التي يعاني منها Tor. تم استخدام I2P من قبل الكثير من الناس في سوريا خلال \u0026ldquo;الربيع العربي\u0026rdquo;، وشهد المشروع مؤخرًا نموًا أكبر في عمليات تثبيت I2P اللغوية الأصغر في الشرق الأدنى والأوسط. أهم شيء يجب ملاحظته هنا هو أن I2P هو تقنية وتحتاج إلى دليل/مرشد لتعزيز خصوصيتك/إخفاء هويتك على الإنترنت. تحقق أيضًا من متصفحك أو استورد محرك البحث عن البصمات لحظر هجمات البصمة الرقمية باستخدام مجموعة بيانات كبيرة جدًا (بمعنى: ذيول طويلة نموذجية / بنية بيانات متنوعة دقيقة جدًا) حول الكثير من عناصر البيئة ولا تستخدم VPN لتقليل جميع المخاطر الناتجة عنه ذاته مثل سلوك ذاكرة التخزين المؤقت TLS الخاصة به والبناء التقني لأعمال المزود التي يمكن اختراقها بسهولة أكبر من نظام سطح مكتب خاص. قد يكون استخدام متصفح Tor V معزول مع حمايته الممتازة ضد البصمات الرقمية وحماية appguard شاملة طوال فترة التشغيل مع السماح فقط لاتصالات الأنظمة الضرورية واستخدام vm نهائي مع نصوص تعطيل مكافحة التجسس وقرص مباشر لإزالة أي \u0026ldquo;مخاطر شبه دائمة محتملة\u0026rdquo; وتقليل جميع المخاطر من خلال احتمالية متناقصة خيارًا جيدًا في الشبكات العامة ونموذج المخاطر الفردية العالية وقد يكون أفضل ما يمكنك فعله بهذا الهدف لاستخدام i2p.\nأرى عناوين IP لجميع عُقد I2P الأخرى في لوحة تحكم الموجّه (router console). هل هذا يعني أن عنوان IP الخاص بي مرئي للآخرين؟ نعم، بالنسبة لعقد I2P الأخرى التي تعرف عن router الخاص بك. نستخدم هذا للاتصال مع بقية شبكة I2P. تتواجد العناوين فعلياً في كائنات \u0026ldquo;routerInfos (key,value)\u0026quot;، إما يتم جلبها عن بُعد أو استلامها من النظير. تحتوي \u0026ldquo;routerInfos\u0026rdquo; على بعض المعلومات (بعضها اختياري يُضاف انتهازياً)، \u0026ldquo;منشورة بواسطة النظير\u0026rdquo;، حول router نفسه للإقلاع الأولي. لا توجد بيانات في هذا الكائن حول العملاء. النظر عن كثب تحت الغطاء سيخبرك أن الجميع تم احتسابه باستخدام أحدث نوع من إنشاء المعرفات يسمى \u0026ldquo;SHA-256 Hashes (low=Positive hash(-key), high=Negative hash(+key))\u0026rdquo;. شبكة I2P لديها قاعدة بيانات خاصة ببيانات routerInfos تم إنشاؤها أثناء الرفع والفهرسة، لكن هذا يعتمد بشكل عميق على تنفيذ جداول key/value وطوبولوجيا الشبكة وحالة التحميل / حالة النطاق الترددي واحتماليات التوجيه للتخزين في مكونات قاعدة البيانات.\nهل استخدام outproxy آمن؟ يعتمد ذلك على تعريفك لكلمة \u0026ldquo;آمن\u0026rdquo;. الـ Outproxies رائعة عندما تعمل، ولكن للأسف يتم تشغيلها طوعياً من قبل أشخاص قد يفقدون الاهتمام أو قد لا تكون لديهم الموارد للحفاظ عليها على مدار الساعة طوال أيام الأسبوع - يرجى العلم بأنك قد تواجه فترات زمنية تكون فيها الخدمات غير متاحة أو متقطعة أو غير موثوقة، ونحن غير مرتبطين بهذه الخدمة وليس لدينا أي تأثير عليها.\nيمكن لخوادم الـ outproxy نفسها رؤية حركة المرور الخاصة بك وهي تأتي وتذهب، باستثناء البيانات المشفرة من طرف إلى طرف عبر HTTPS/SSL، تمامًا كما يمكن لمزود خدمة الإنترنت الخاص بك رؤية حركة المرور الخاصة بك وهي تأتي وتذهب من جهاز الكمبيوتر الخاص بك. إذا كنت مرتاحًا لمزود خدمة الإنترنت الخاص بك، فلن يكون الأمر أسوأ مع الـ outproxy.\nماذا عن هجمات \u0026ldquo;كشف الهوية\u0026rdquo;؟ للحصول على شرح مفصل جداً، اقرأ المزيد في مقالاتنا حول نموذج التهديد . بشكل عام، كشف الهوية ليس أمراً بسيطاً، ولكنه ممكن إذا لم تكن حذراً بما فيه الكفاية.\nالوصول إلى الإنترنت/الأداء لا أستطيع الوصول إلى مواقع الإنترنت العادية من خلال I2P. يتم توفير الوصول بالوكالة إلى مواقع الإنترنت (eepsites التي تتجه إلى الإنترنت) كخدمة لمستخدمي I2P من قبل مزودين غير محجوبين. هذه الخدمة ليست التركيز الرئيسي لتطوير I2P، ويتم توفيرها على أساس طوعي. يجب أن تعمل eepsites المستضافة على I2P دائمًا بدون outproxy. تعتبر outproxies ميزة مريحة ولكنها بحكم التصميم ليست مثالية ولا تشكل جزءًا كبيرًا من المشروع. كن على علم بأنها قد لا تكون قادرة على توفير خدمة عالية الجودة مثل الخدمات الأخرى التي قد يوفرها I2P.\nلا أستطيع الوصول إلى مواقع https:// أو ftp:// عبر I2P. يدعم البروكسي HTTP الافتراضي خدمة outproxying لـ HTTP و HTTPS فقط.\nلماذا يستخدم الـ router الخاص بي الكثير من وحدة المعالجة المركزية؟ أولاً، تأكد من أن لديك أحدث إصدار من كل جزء متعلق بـ I2P – الإصدارات القديمة كانت تحتوي على أقسام غير ضرورية في الكود تستهلك المعالج. يوجد أيضاً سجل الأداء الذي يوثق بعض التحسينات في أداء I2P عبر الزمن.\nالنظراء النشطون / النظراء المعروفون / الأنفاق المشاركة / الاتصالات / النطاق الترددي الخاص بي يتغير بشكل كبير مع مرور الوقت! هل هناك أي خطأ؟ الاستقرار العام لشبكة I2P هو مجال بحث مستمر. يركز جزء كبير من هذا البحث على كيفية تأثير التغييرات الصغيرة في إعدادات التكوين على سلوك الموجه (router). نظرًا لأن I2P هي شبكة نظير إلى نظير، فإن تصرفات الأقران الآخرين سيكون لها تأثير على أداء الموجه الخاص بك.\nما الذي يجعل التنزيلات، والتورنت، وتصفح الويب، وكل شيء آخر أبطأ على I2P مقارنة بالإنترنت العادي؟ يحتوي I2P على آليات حماية مختلفة تضيف توجيهًا إضافيًا وطبقات تشفير متعددة. كما أنه يوجه حركة البيانات عبر أجهزة نظيرة أخرى (Tunnels) لها سرعتها وجودتها الخاصة، بعضها بطيء وبعضها سريع. هذا يؤدي إلى الكثير من الحمل الإضافي وحركة البيانات بوتيرات مختلفة في اتجاهات متعددة. بالتصميم، كل هذه الأمور ستجعله أبطأ مقارنة بالاتصال المباشر على الإنترنت، لكنه أكثر إخفاءً للهوية بكثير ولا يزال سريعًا بما يكفي لمعظم الاستخدامات.\nفيما يلي مثال مع شرح للمساعدة في توفير بعض السياق حول اعتبارات زمن الاستجابة (latency) وعرض النطاق الترددي (bandwidth) عند استخدام I2P.\nانظر إلى الرسم التخطيطي أدناه. يوضح اتصالاً بين عميل يقوم بإرسال طلب عبر I2P، وخادم يستقبل الطلب عبر I2P ثم يستجيب مرة أخرى عبر I2P أيضاً. كما يظهر المسار الذي يسلكه الطلب.\nمن المخطط، لاحظ أن الصناديق المسماة \u0026lsquo;P\u0026rsquo; و \u0026lsquo;Q\u0026rsquo; و \u0026lsquo;R\u0026rsquo; تمثل tunnel صادر لـ \u0026lsquo;A\u0026rsquo; وأن الصناديق المسماة \u0026lsquo;X\u0026rsquo; و \u0026lsquo;Y\u0026rsquo; و \u0026lsquo;Z\u0026rsquo; تمثل tunnel صادر لـ \u0026lsquo;B\u0026rsquo;. وبالمثل، تمثل الصناديق المسماة \u0026lsquo;X\u0026rsquo; و \u0026lsquo;Y\u0026rsquo; و \u0026lsquo;Z\u0026rsquo; tunnel وارد لـ \u0026lsquo;B\u0026rsquo; بينما تمثل الصناديق المسماة \u0026lsquo;P_1\u0026rsquo; و \u0026lsquo;Q_1\u0026rsquo; و \u0026lsquo;R_1\u0026rsquo; tunnel وارد لـ \u0026lsquo;A\u0026rsquo;. تُظهر الأسهم بين الصناديق اتجاه حركة البيانات. يوضح النص أعلى وأسفل الأسهم بعض الأمثلة على النطاق الترددي بين زوج من القفزات بالإضافة إلى أمثلة على أوقات الاستجابة.\nعندما يستخدم كل من العميل والخادم أنفاقًا من 3 قفزات طوال الوقت، يشارك إجمالي 12 router آخر من I2P في نقل حركة المرور. يقوم 6 أقران بنقل حركة المرور من العميل إلى الخادم والتي تنقسم إلى tunnel صادر من 3 قفزات من \u0026lsquo;A\u0026rsquo; (\u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;R\u0026rsquo;) و tunnel وارد من 3 قفزات إلى \u0026lsquo;B\u0026rsquo; (\u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;). وبالمثل، يقوم 6 أقران بنقل حركة المرور من الخادم مرة أخرى إلى العميل.\nأولاً، يمكننا النظر في زمن الاستجابة (latency) - الوقت الذي يستغرقه الطلب من العميل لعبور شبكة I2P، والوصول إلى الخادم والعودة إلى العميل. عند جمع جميع أزمنة الاستجابة نرى أن:\n40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms يصل إجمالي وقت الرحلة ذهابًا وإيابًا في مثالنا إلى 740 ميلي ثانية - وهو بالتأكيد أعلى بكثير مما يراه المرء عادةً أثناء تصفح مواقع الإنترنت العادية.\nثانياً، يمكننا النظر في عرض النطاق الترددي المتاح. يتم تحديد ذلك من خلال الرابط الأبطأ بين القفزات من العميل إلى الخادم وكذلك عندما يتم نقل البيانات من الخادم إلى العميل. بالنسبة للبيانات المتجهة من العميل إلى الخادم، نرى أن عرض النطاق الترددي المتاح في مثالنا بين القفزتين \u0026lsquo;R\u0026rsquo; و \u0026lsquo;X\u0026rsquo; وكذلك بين القفزتين \u0026lsquo;X\u0026rsquo; و \u0026lsquo;Y\u0026rsquo; هو 32 كيلوبايت/ثانية. على الرغم من ارتفاع عرض النطاق الترددي المتاح بين القفزات الأخرى، فإن هذه القفزات ستعمل كعنق زجاجة وستحد من الحد الأقصى لعرض النطاق الترددي المتاح للبيانات من \u0026lsquo;A\u0026rsquo; إلى \u0026lsquo;B\u0026rsquo; عند 32 كيلوبايت/ثانية. وبالمثل، فإن تتبع المسار من الخادم إلى العميل يظهر أن الحد الأقصى لعرض النطاق الترددي هو 64 كيلوبايت/ثانية - بين القفزات \u0026lsquo;Z_1\u0026rsquo; و \u0026lsquo;Y_1\u0026rsquo;، \u0026lsquo;Y_1\u0026rsquo; و \u0026lsquo;X_1\u0026rsquo; و \u0026lsquo;Q_1\u0026rsquo; و \u0026lsquo;P_1\u0026rsquo;.\nنوصي بزيادة حدود النطاق الترددي الخاص بك. يساعد هذا الشبكة من خلال زيادة كمية النطاق الترددي المتاح مما سيؤدي بدوره إلى تحسين تجربتك مع I2P. توجد إعدادات النطاق الترددي في صفحة http://localhost:7657/config . يرجى الانتباه إلى حدود اتصال الإنترنت الخاص بك كما يحددها مزود خدمة الإنترنت، وضبط إعداداتك وفقًا لذلك.\nنوصي أيضًا بتعيين قدر كافٍ من عرض النطاق المشترك - وهذا يسمح بتوجيه الأنفاق المشاركة عبر جهاز التوجيه I2P الخاص بك. السماح بحركة المرور المشاركة يبقي جهاز التوجيه الخاص بك متكاملاً بشكل جيد في الشبكة ويحسن من سرعات النقل لديك.\nI2P هو عمل قيد التطوير المستمر. يتم تنفيذ الكثير من التحسينات والإصلاحات، وبشكل عام، تشغيل أحدث إصدار سيساعد في تحسين الأداء. إذا لم تقم بذلك، قم بتثبيت أحدث إصدار.\nأعتقد أنني وجدت خطأ برمجي، أين يمكنني الإبلاغ عنه؟ يمكنك الإبلاغ عن أي أخطاء/مشاكل تواجهها على نظام تتبع الأخطاء الخاص بنا، والذي يمكن الوصول إليه عبر الإنترنت العادي وعبر I2P. لدينا منتدى نقاش، متاح أيضًا على I2P والإنترنت العادي. يمكنك أيضًا الانضمام إلى قناة IRC الخاصة بنا: إما من خلال شبكة IRC الخاصة بنا، IRC2P، أو على Freenode.\nنظام تتبع الأخطاء الخاص بنا: الإنترنت غير الخاص: https://i2pgit.org/I2P_Developers/i2p.i2p/issues على I2P: http://git.idk.i2p/I2P_Developers/i2p.i2p/issues منتدياتنا: i2pforum.i2p لصق السجلات: يمكنك لصق أي سجلات مثيرة للاهتمام في خدمة لصق مثل خدمات الإنترنت غير الخاص المدرجة في PrivateBin Wiki ، أو خدمة لصق I2P مثل نسخة PrivateBin هذه أو خدمة اللصق الخالية من Javascript هذه ثم المتابعة على IRC في #i2p IRC: انضم إلى #i2p-dev للنقاش مع المطورين على IRC يرجى تضمين المعلومات ذات الصلة من صفحة سجلات الـ router المتاحة على: http://127.0.0.1:7657/logs . نطلب منك مشاركة جميع النصوص الموجودة تحت قسم \u0026lsquo;I2P Version and Running Environment\u0026rsquo; بالإضافة إلى أي أخطاء أو تحذيرات معروضة في مختلف السجلات المعروضة على الصفحة.\nلدي سؤال! رائع! تواصل معنا عبر IRC:\nعلى irc.freenode.net قناة #i2p على IRC2P قناة #i2p أو انشر في المنتدى وسننشره هنا (مع الإجابة، نأمل ذلك).\n","description":"أسئلة وأجوبة شاملة حول I2P: مساعدة router، الإعداد، reseeds، الخصوصية/الأمان، الأداء، وحل المشكلات","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"الأسئلة الشائعة","url":"/ar/docs/overview/faq/"},{"categories":null,"content":"مقدمة يوفر I2P رسائل خاصة بأسلوب البريد الإلكتروني من خلال خدمة Postman\u0026rsquo;s Mail.i2p مدمجة مع SusiMail، وهو عميل بريد إلكتروني ويب مدمج. يسمح هذا النظام للمستخدمين بإرسال واستقبال رسائل البريد الإلكتروني داخل شبكة I2P وإلى/من الإنترنت العادي (clearnet) عبر جسر gateway.\n{ \u0026#34;title\u0026#34;: \u0026#34;حول I2P\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;I2P هو شبكة مجهولة، تُقدم طبقة بسيطة لتطبيقات من أجل إرسال رسائل بشكل مجهول وآمن لبعضها البعض. الاتصال مشفر من طرف إلى طرف. بالمجمل هناك أربعة طبقات من التشفير تُستخدم عند إرسال رسالة. يتم توزيع الشبكة نفسها بشكل كامل ويديرها متطوعون بشكل عشوائي، بدون بنية تحتية موثوقة أو مركزية. كل شخص يُدير I2P router يعمل بشكل متساو. لا توجد خوادم \\\u0026#34;خاصة\\\u0026#34;. I2P تُستخدم من قبل أشخاص عاديين يريدون حماية خصوصيتهم على الإنترنت: نشطاء، صحفيون، مدونون، والكثير من الأشخاص الذين يهتمون بإخفاء هويتهم.\u0026#34;, \u0026#34;features\u0026#34;: { \u0026#34;anonymous\u0026#34;: \u0026#34;**مجهول:** يحمي هويتك من رقابة الشبكة\u0026#34;, \u0026#34;encrypted\u0026#34;: \u0026#34;**مشفر:** الاتصال من طرف إلى طرف مشفر بالكامل\u0026#34;, \u0026#34;distributed\u0026#34;: \u0026#34;**موزع:** لا توجد خوادم مركزية، الجميع متساوون\u0026#34;, \u0026#34;open\u0026#34;: \u0026#34;**مفتوح المصدر:** كود قابل للفحص والتحقق\u0026#34;, \u0026#34;free\u0026#34;: \u0026#34;**مجاني:** مجاني الاستخدام بالكامل، بدون قيود\u0026#34; } } Postman / Mail.i2p + SusiMail What it is Mail.i2p هو مزود بريد إلكتروني مستضاف داخل I2P، يديره \u0026ldquo;Postman\u0026rdquo; SusiMail هو عميل البريد الإلكتروني على الويب المدمج في وحدة تحكم موجه I2P. وهو مصمم لتجنب تسريب البيانات الوصفية (مثل اسم المضيف) إلى خوادم SMTP الخارجية. من خلال هذا الإعداد، يمكن لمستخدمي I2P إرسال/استقبال الرسائل داخل I2P وإلى/من الإنترنت العادي (مثل Gmail) عبر جسر Postman. How Addressing Works يستخدم البريد الإلكتروني في I2P نظام عناوين مزدوج:\nداخل شبكة I2P: username@mail.i2p (مثال: idk@mail.i2p) من الإنترنت العادي: username@i2pmail.org (مثال: idk@i2pmail.org) بوابة i2pmail.org تسمح لمستخدمي الإنترنت العاديين بإرسال رسائل البريد الإلكتروني إلى عناوين I2P، ولمستخدمي I2P بالإرسال إلى عناوين الإنترنت العادي (clearnet). يتم توجيه رسائل البريد الإلكتروني من الإنترنت عبر البوابة قبل إعادة توجيهها عبر I2P إلى صندوق الوارد الخاص بك في SusiMail.\nحصة الإرسال إلى الإنترنت العادي (Clearnet): 20 بريدًا إلكترونيًا يوميًا عند الإرسال إلى عناوين الإنترنت العادية.\nما هو للتسجيل للحصول على حساب mail.i2p:\nتأكد من تشغيل موجه I2P الخاص بك قم بزيارة http://hq.postman.i2p داخل I2P اتبع عملية التسجيل الوصول إلى بريدك الإلكتروني من خلال SusiMail في لوحة تحكم الموجه ملاحظة: hq.postman.i2p هو عنوان شبكة I2P (eepsite) ولا يمكن الوصول إليه إلا أثناء الاتصال بـ I2P. لمزيد من المعلومات حول إعداد البريد الإلكتروني والأمان والاستخدام، قم بزيارة Postman HQ.\nكيف تعمل آلية العناوين الإزالة التلقائية لرؤوس التعريف (User-Agent:، X-Mailer:) لحماية الخصوصية تنظيف البيانات الوصفية لمنع التسريبات إلى خوادم SMTP الخارجية التشفير من طرف إلى طرف لرسائل البريد الإلكتروني الداخلية من I2P إلى I2P البدء التوافقية مع البريد الإلكتروني \u0026ldquo;العادي\u0026rdquo; (SMTP/POP) عبر جسر Postman تجربة مستخدم بسيطة (بريد إلكتروني ويب مدمج في وحدة تحكم router) متكامل مع التوزيع الأساسي لـ I2P (SusiMail يأتي مع Java I2P) إزالة الرؤوس لحماية الخصوصية ميزات الخصوصية الجسر إلى البريد الإلكتروني الخارجي يتطلب الثقة في البنية التحتية لـ Postman جسر Clearnet يقلل من الخصوصية مقارنة بالاتصالات الداخلية البحتة عبر I2P يعتمد على توفر وأمان خادم بريد Postman Best Practices غيّر كلمة المرور بعد تسجيل حساب mail.i2p الخاص بك استخدم البريد الإلكتروني I2P-to-I2P كلما أمكن ذلك لأقصى قدر من الخصوصية (بدون جسر clearnet) انتبه لحد الـ 20 رسالة يوميًا عند الإرسال إلى عناوين clearnet افهم المقايضات: توفر جسور Clearnet الراحة لكنها تقلل من إخفاء الهوية مقارنةً بالاتصالات الداخلية البحتة في I2P حافظ على تحديث I2P للاستفادة من التحسينات الأمنية في SusiMail ","description":"نظرة عامة على أنظمة البريد الإلكتروني داخل شبكة I2P — التاريخ والخيارات والوضع الحالي","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"البريد الإلكتروني I2P (البريد الإلكتروني المجهول عبر I2P)","url":"/ar/docs/applications/i2p-mail/"},{"categories":null,"content":"يتضمن هذا التطبيق من I2P (تطبيق Java الموزع على هذا الموقع) \u0026ldquo;قائمة البلدان الصارمة\u0026rdquo; المستخدمة لتعديل سلوك router في المناطق التي قد يكون فيها المشاركة في routing للآخرين مقيدًا بموجب القانون. على الرغم من أننا لسنا على علم بولايات قضائية تحظر استخدام I2P، إلا أن العديد منها لديه حظر واسع على نقل حركة المرور (relaying traffic). يتم وضع routers التي يبدو أنها في البلدان \u0026ldquo;الصارمة\u0026rdquo; تلقائيًا في وضع Hidden (المخفي).\nيشير المشروع إلى الأبحاث الصادرة عن منظمات الحقوق المدنية والرقمية عند اتخاذ هذه القرارات. وعلى وجه الخصوص، تُوجّه الأبحاث المستمرة التي تُجريها منظمة فريدم هاوس (Freedom House) خياراتنا. التوجيه العام هو تضمين الدول التي لديها درجة حريات مدنية (CL) تبلغ 16 أو أقل، أو درجة حرية الإنترنت تبلغ 39 أو أقل (غير حرة).\nملخص الوضع المخفي عندما يتم وضع router في وضع الإخفاء (Hidden mode)، تتغير ثلاثة أشياء رئيسية في سلوكه:\nلا ينشر معلومات الموجه (RouterInfo) إلى قاعدة بيانات الشبكة (netDb). لا يقبل أنفاق المشاركة (participating tunnels). يرفض الاتصالات المباشرة بالموجهات في نفس البلد. هذه الدفاعات تجعل أجهزة التوجيه (routers) أكثر صعوبة في الإحصاء بشكل موثوق، وتقلل من خطر انتهاك الحظر المحلي على نقل حركة المرور للآخرين.\nقائمة البلدان ذات الرقابة الصارمة (اعتبارًا من 2024) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; إذا كنت تعتقد أن دولة ما يجب إضافتها أو إزالتها من القائمة الصارمة، يرجى فتح تذكرة على: https://i2pgit.org/i2p/i2p.i2p/ المرجع: Freedom House – https://freedomhouse.org/ ","description":"كيف يتصرف I2P في الولايات القضائية التي تفرض قيودًا على أدوات التوجيه أو إخفاء الهوية (الوضع المخفي والقائمة الصارمة)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"البلدان الصارمة/المقيدة","url":"/ar/docs/overview/restrictive-countries/"},{"categories":null,"content":"عناوين I2P هي مفاتيح تشفير طويلة. يوفر نظام التسمية طبقة أكثر سهولة فوق تلك المفاتيح دون إدخال سلطة مركزية. جميع الأسماء محلية—كل router يقرر بشكل مستقل أي وجهة يشير إليها اسم المضيف.\nتحتاج إلى خلفية؟ تُوثِّق مناقشة التسمية النقاشات التصميمية الأصلية، والمقترحات البديلة، والأسس الفلسفية وراء نظام التسمية اللامركزي في I2P.\n1. المكونات تتكون طبقة التسمية في I2P من عدة أنظمة فرعية مستقلة ولكنها متعاونة:\nخدمة التسمية – تحل أسماء المضيفين إلى الوجهات وتتعامل مع أسماء المضيفين Base32 . وكيل HTTP – يمرر عمليات البحث عن .i2p إلى الموجه (router) ويقترح خدمات القفز (jump services) عندما يكون الاسم غير معروف. خدمات إضافة المضيفين – نماذج على طراز CGI تضيف إدخالات جديدة إلى دفتر العناوين المحلي. خدمات القفز – مساعدات بعيدة تُرجع الوجهة لاسم مضيف محدد. دفتر العناوين – يجلب ويدمج قوائم المضيفين البعيدة بشكل دوري باستخدام \u0026ldquo;شبكة ثقة\u0026rdquo; موثوقة محلياً. SusiDNS – واجهة مستخدم قائمة على الويب لإدارة دفاتر العناوين والاشتراكات والتجاوزات المحلية. يتيح هذا التصميم المعياري للمستخدمين تحديد حدود الثقة الخاصة بهم وأتمتة عملية التسمية بقدر ما يفضلون أو بأقل قدر ممكن.\n2. خدمات الأسماء تدعم واجهة برمجة التطبيقات الخاصة بالتسمية في الموجه (net.i2p.client.naming) عدة خلفيات من خلال الخاصية القابلة للتكوين i2p.naming.impl=\u0026lt;class\u0026gt;. قد يقدم كل تطبيق استراتيجيات بحث مختلفة، لكنها جميعاً تشترك في نفس نموذج الثقة والتحليل.\n2.1 Hosts.txt (legacy format) كان النموذج القديم يستخدم ثلاثة ملفات نصية عادية يتم فحصها بالترتيب:\nprivatehosts.txt userhosts.txt hosts.txt يخزن كل سطر تعيين hostname=base64-destination. يظل تنسيق النص البسيط هذا مدعومًا بالكامل للاستيراد/التصدير، لكنه لم يعد الافتراضي بسبب الأداء الضعيف بمجرد أن تتجاوز قائمة المضيفين بضعة آلاف من الإدخالات.\n2.2 Blockfile Naming Service (default backend) تم تقديمه في الإصدار 0.8.8، أصبح Blockfile Naming Service الآن الخلفية الافتراضية. وهو يستبدل الملفات المسطحة بمخزن مفتاح/قيمة على القرص عالي الأداء قائم على skiplist (hostsdb.blockfile) يوفر عمليات بحث أسرع بحوالي 10 مرات.\nالخصائص الرئيسية: - يخزن عدة دفاتر عناوين منطقية (خاص، مستخدم، ومضيفين) في قاعدة بيانات ثنائية واحدة. - يحافظ على التوافق مع استيراد/تصدير hosts.txt القديم. - يدعم البحث العكسي، والبيانات الوصفية (تاريخ الإضافة، المصدر، التعليقات)، والتخزين المؤقت الفعال. - يستخدم نفس ترتيب البحث ثلاثي المستويات: خاص ← مستخدم ← مضيفين.\nيحافظ هذا النهج على التوافق مع الإصدارات السابقة بينما يحسن بشكل كبير سرعة الحل وقابلية التوسع.\n2.1 Hosts.txt (التنسيق القديم) يمكن للمطورين تنفيذ واجهات خلفية مخصصة مثل: - Meta – يجمع أنظمة تسمية متعددة. - PetName – يدعم أسماء مستعارة مخزنة في petnames.txt. - AddressDB، Exec، Eepget، و Dummy – للحل الخارجي أو الاحتياطي.\nيظل تنفيذ blockfile هو الخيار الموصى به للاستخدام العام نظراً للأداء والموثوقية.\n3. Base32 Hostnames أسماء المضيفين Base32 (*.b32.i2p) تعمل بشكل مشابه لعناوين .onion في Tor. عندما تصل إلى عنوان .b32.i2p:\nيقوم الـ router بفك تشفير حمولة Base32. يعيد بناء الوجهة مباشرة من المفتاح—دون الحاجة إلى البحث في دفتر العناوين. يضمن هذا إمكانية الوصول حتى لو لم يكن هناك اسم مضيف قابل للقراءة البشرية. أسماء Base32 الممتدة التي تم تقديمها في الإصدار 0.9.40 تدعم LeaseSet2 والوجهات المشفرة.\n4. Address Book \u0026amp; Subscriptions يقوم تطبيق دفتر العناوين باسترجاع قوائم المضيفين البعيدة عبر HTTP ودمجها محلياً وفقاً لقواعد الثقة المُعدّة من قبل المستخدم.\n2.2 خدمة تسمية Blockfile (الواجهة الخلفية الافتراضية) الاشتراكات هي روابط .i2p قياسية تشير إلى hosts.txt أو موجزات التحديثات التدريجية. يتم جلب التحديثات بشكل دوري (كل ساعة افتراضياً) والتحقق من صحتها قبل الدمج. يتم حل التعارضات على أساس الأسبقية (من يأتي أولاً يُخدم أولاً)، وفقاً لترتيب الأولوية:\nprivatehosts.txt → userhosts.txt → hosts.txt. Default Providers منذ I2P 2.3.0 (يونيو 2023)، يتم تضمين مزودي اشتراك افتراضيين: - http://i2p-projekt.i2p/hosts.txt - http://notbob.i2p/hosts.txt\nيعمل هذا التكرار على تحسين الموثوقية مع الحفاظ على نموذج الثقة المحلي. يمكن للمستخدمين إضافة أو إزالة الاشتراكات من خلال SusiDNS.\nIncremental Updates يتم جلب التحديثات التدريجية عبر newhosts.txt (لتحل محل مفهوم recenthosts.cgi الأقدم). توفر هذه النقطة النهائية تحديثات تدريجية فعالة معتمدة على ETag—تُرجع فقط الإدخالات الجديدة منذ الطلب الأخير أو 304 Not Modified عندما لا يكون هناك تغيير.\n2.3 الخلفيات البديلة والإضافات خدمات إضافة المضيف (add*.cgi) تسمح بإرسال يدوي لربط الأسماء بالوجهات. تحقق دائماً من الوجهة قبل القبول. خدمات Jump تستجيب بالمفتاح المناسب ويمكنها إعادة التوجيه عبر البروكسي HTTP باستخدام معامل ?i2paddresshelper=. أمثلة شائعة: stats.i2p، identiguy.i2p، و notbob.i2p. هذه الخدمات ليست جهات موثوقة—يجب على المستخدمين تحديد أيها يستخدمون. 5. Managing Entries Locally (SusiDNS) SusiDNS متاح على: http://127.0.0.1:7657/susidns/\nيمكنك: - عرض وتعديل دفاتر العناوين المحلية. - إدارة الاشتراكات وتحديد أولوياتها. - استيراد/تصدير قوائم المضيفين. - تكوين جداول الجلب.\nجديد في I2P 2.8.1 (مارس 2025): - إضافة ميزة \u0026ldquo;الترتيب حسب الأحدث\u0026rdquo;. - تحسين معالجة الاشتراكات (إصلاح لتناقضات ETag).\nجميع التغييرات تبقى محلية—دفتر العناوين لكل router فريد.\n3. أسماء المضيفين Base32 وفقًا لـ RFC 9476، سجّلت I2P نطاق .i2p.alt لدى هيئة GNUnet للأرقام المخصصة (GANA) اعتبارًا من مارس 2025 (I2P 2.8.1).\nالغرض: منع تسريبات DNS العرضية من البرامج غير المُكوّنة بشكل صحيح.\nمحللات DNS المتوافقة مع RFC 9476 لن تقوم بإعادة توجيه نطاقات .alt إلى DNS العام. برنامج I2P يتعامل مع .i2p.alt كمعادل لـ .i2p، حيث يزيل لاحقة .alt أثناء عملية الحل. .i2p.alt ليس مخصصًا لاستبدال .i2p؛ إنه إجراء حماية تقني، وليس إعادة تسمية للعلامة التجارية. 4. دفتر العناوين والاشتراكات مفاتيح الوجهة (Destination keys): 516–616 بايت (Base64) أسماء المضيفين: الحد الأقصى 67 حرفًا (بما في ذلك .i2p) الأحرف المسموح بها: a–z، 0–9، -، . (بدون نقاط مزدوجة، بدون أحرف كبيرة) محجوز: *.b32.i2p ETag و Last-Modified: تُستخدم بنشاط لتقليل النطاق الترددي متوسط حجم hosts.txt: ~400 كيلوبايت لـ ~800 مضيف (رقم تقريبي) استخدام النطاق الترددي: ~10 بايت/ثانية إذا تم الجلب كل 12 ساعة 8. Security Model and Philosophy تضحي I2P عمدًا بالتفرد العالمي مقابل اللامركزية والأمان—وهو تطبيق مباشر لـ مثلث Zooko.\nالمبادئ الأساسية: - لا سلطة مركزية: جميع عمليات البحث محلية. - المقاومة لاختطاف DNS: الاستعلامات مشفرة إلى المفاتيح العامة للوجهة. - منع هجمات Sybil: لا يوجد تصويت أو تسمية قائمة على الإجماع. - تعيينات غير قابلة للتغيير: بمجرد وجود ارتباط محلي، لا يمكن تجاوزه عن بُعد.\nأنظمة التسمية القائمة على سلسلة الكتل (مثل Namecoin و ENS) استكشفت حل جميع جوانب مثلث Zooko الثلاثة، لكن I2P يتجنبها عمداً بسبب زمن الاستجابة والتعقيد وعدم التوافق الفلسفي مع نموذج الثقة المحلي الخاص به.\n9. Compatibility and Stability لم يتم إيقاف أي ميزات تسمية بين 2023-2025. تنسيق Hosts.txt وخدمات jump والاشتراكات وجميع تطبيقات واجهة برمجة التطبيقات للتسمية تظل وظيفية. يحافظ مشروع I2P على التوافق العكسي الصارم مع إدخال تحسينات الأداء والأمان (عزل NetDB، فصل Sub-DB، إلخ). 10. Best Practices احتفظ فقط بالاشتراكات الموثوقة؛ تجنب قوائم المضيفين الكبيرة غير المعروفة. قم بعمل نسخة احتياطية من hostsdb.blockfile و privatehosts.txt قبل الترقية أو إعادة التثبيت. راجع خدمات القفز بانتظام وعطّل أي خدمة لم تعد تثق بها. تذكر: دفتر العناوين الخاص بك يحدد نسختك من عالم I2P—كل اسم مضيف محلي. Further Reading نقاش التسمية مواصفات Blockfile تنسيق ملف الإعدادات Javadoc لخدمة التسمية ","description":"كيف يقوم I2P بتعيين أسماء المضيفين القابلة للقراءة إلى الوجهات","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"التسمية ودفتر العناوين","url":"/ar/docs/overview/naming/"},{"categories":null,"content":" الحالة: تلخّص هذه الصفحة \u0026ldquo;مواصفة التشفير منخفض المستوى\u0026rdquo; القديمة. لقد أكملت إصدارات I2P الحديثة (2.10.0، أكتوبر 2025) الانتقال إلى بدائيات تشفير جديدة. استخدم المواصفات المتخصصة مثل ECIES (نظام تشفير متكامل قائم على المنحنيات الإهليلجية)، Encrypted LeaseSets ، NTCP2 ، Red25519 ، SSU2 ، وTunnel Creation (ECIES) للحصول على تفاصيل التنفيذ.\nلقطة للتطور Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) ## التشفير غير المتماثل X25519 (خوارزمية تبادل مفاتيح باستخدام المنحنى البيضي Curve25519) تُستخدم لـ NTCP2 و ECIES-X25519-AEAD-Ratchet و SSU2، ولإنشاء tunnel معتمد على X25519. يوفّر مفاتيح صغيرة الحجم، وعمليات بزمن ثابت، وسرية أمامية عبر Noise protocol framework (إطار عمل بروتوكول Noise). يوفّر أمانًا بمستوى 128-بت مع مفاتيح بحجم 32 بايت وتبادل مفاتيح فعّال. ElGamal (قديم) تم الإبقاء عليه للتوافق مع الإصدارات الأقدم من routers. يعمل على العدد الأوّلي لمجموعة Oakley رقم 14 بطول 2048 بت (RFC 3526) مع المولِّد 2. يشفّر مفاتيح جلسة AES إضافةً إلى IVs (متجهات التهيئة) ضمن نصوص مشفّرة بحجم 514 بايت. يفتقر إلى التشفير الموثّق والسرية الأمامية؛ وقد انتقلت جميع نقاط النهاية الحديثة إلى ECIES. التشفير المتماثل ChaCha20/Poly1305 (خوارزمية AEAD للتشفير المصادق تجمع بين تشفير التدفق ChaCha20 ودالة مصادقة الرسائل Poly1305) البدائية الافتراضية للتشفير الموثَّق عبر NTCP2 وSSU2 وECIES. توفّر أمان AEAD وأداءً عاليًا من دون دعم عتادي لـ AES. مُنفّذة وفق RFC 7539 (مفتاح 256‑بت، nonce (رقم وحيد الاستخدام) بطول 96‑بت، ووسم 128‑بت). AES‑256/CBC (قديم) لا يزال مستخدماً لتشفير طبقة tunnel، حيث إن بنيته كخوارزمية تشفير كتليّة تلائم نموذج التشفير الطبقي الخاص بـ I2P. يستخدم حشو PKCS#5 وتحويلات IV (متجه التهيئة) لكل قفزة. مُجدول لمراجعة طويلة الأمد لكنه لا يزال متيناً من الناحية التشفيرية. التواقيع Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer ## التجزئة واشتقاق المفاتيح SHA‑256: تُستخدم لمفاتيح DHT (جدول التجزئة الموزّع)، وHKDF (دالة اشتقاق المفاتيح المعتمدة على HMAC)، والتواقيع القديمة. SHA‑512: تُستخدم من قِبل EdDSA (خوارزمية التوقيع الرقمي للمنحنيات الإهليلجية)/RedDSA، وفي اشتقاقات HKDF ضمن Noise (إطار عمل بروتوكولات Noise). HKDF‑SHA256: تشتق مفاتيح الجلسة في ECIES (مخطط التشفير المتكامل بالمنحنيات الإهليلجية)، وNTCP2، وSSU2. اشتقاقات SHA‑256 ذات التدوير اليومي تؤمّن مواقع تخزين RouterInfo وLeaseSet في netDb. ملخص طبقة النقل Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) كلا الناقلين يوفّران سرية أمامية على مستوى الوصلة وحماية من إعادة التشغيل، باستخدام نمط المصافحة Noise_XK (نمط ضمن إطار عمل Noise). تشفير طبقة Tunnel يواصل استخدام AES‑256/CBC للتشفير متعدد الطبقات على مستوى كل قفزة. تقوم البوابات الصادرة بإجراء فك تشفير AES بشكل تكراري؛ وتعيد كل قفزة التشفير باستخدام مفتاح الطبقة ومفتاح IV (المتجه الابتدائي) الخاصين بها. يخفف التشفير بـ IV مزدوج من هجمات الترابط والتأكيد. الانتقال إلى AEAD (تشفير مصادق مع بيانات مرتبطة) قيد الدراسة، لكنه غير مخطط له حالياً. التشفير ما بعد الكمّي I2P 2.10.0 يقدم تشفيراً هجيناً تجريبياً لما بعد الكم. يتم تمكينه يدوياً عبر Hidden Service Manager (مدير الخدمات المخفية) لأغراض الاختبار. يجمع بين X25519 وKEM المقاوم للكم (آلية تغليف المفاتيح) (الوضع الهجين). غير مُفعل افتراضياً؛ مُخصص للبحث وتقييم الأداء. إطار قابلية التوسعة تُتيح مُعرِّفات الأنواع للتشفير والتوقيع دعماً متوازياً لعدة بدائيات تشفيرية. تشمل التعيينات الحالية: أنواع التشفير: 0 = ElGamal/AES+SessionTags, 4 = ECIES‑X25519‑AEAD‑Ratchet. أنواع التوقيع: 0 = DSA‑SHA1, 7 = EdDSA‑SHA512‑Ed25519, 11 = RedDSA‑SHA512‑Ed25519. يتيح هذا الإطار ترقيات مستقبلية، بما في ذلك مخططات ما بعد الكم، دون انقسامات في الشبكة. التركيب التشفيري طبقة النقل: X25519 + ChaCha20/Poly1305 (إطار Noise). طبقة Tunnel: تشفير متعدد الطبقات AES‑256/CBC لإخفاء الهوية. من طرف إلى طرف: ECIES‑X25519‑AEAD‑Ratchet للحفاظ على السرية ولتحقيق السرية المستقبلية (forward secrecy). طبقة قاعدة البيانات: تواقيع EdDSA/RedDSA لضمان الأصالة. تتضافر هذه الطبقات لتوفير الدفاع في العمق: حتى إذا اختُرقت طبقة واحدة، فإن الطبقات الأخرى تحافظ على السرية وعدم إمكانية الربط.\nملخص يتمحور المكدس التشفيري الخاص بـ I2P 2.10.0 حول:\nCurve25519 (X25519) لتبادل المفاتيح ChaCha20/Poly1305 للتشفير المتماثل EdDSA / RedDSA للتواقيع SHA‑256 / SHA‑512 للتجزئة والاشتقاق أوضاع هجينة تجريبية لما بعد الكمّ للتوافقية المستقبلية لا تزال ElGamal وAES‑CBC وDSA القديمة موجودة لأغراض التوافق مع الإصدارات السابقة، لكنها لم تعد تُستخدم في وسائط النقل النشطة أو مسارات التشفير.\n","description":"ملخص للبدائيات التماثلية وغير التماثلية وبدائيات التوقيع المستخدمة عبر I2P","id":"f5b93f818161e04d49735c3df52fcbdc","section":"docs","title":"التشفير منخفض المستوى","url":"/ar/docs/specs/cryptography/"},{"categories":null,"content":" 1. نظرة عامة يظل garlic routing أحد الابتكارات الأساسية في I2P، حيث يجمع بين التشفير متعدد الطبقات وتجميع الرسائل والأنفاق أحادية الاتجاه. وعلى الرغم من تشابهه المفاهيمي مع onion routing، إلا أنه يوسع النموذج ليجمع رسائل مشفرة متعددة (\u0026ldquo;cloves\u0026rdquo;) في مغلف واحد (\u0026ldquo;garlic\u0026rdquo;)، مما يحسن الكفاءة وعدم الكشف عن الهوية.\nتم صياغة مصطلح garlic routing من قبل Michael J. Freedman في رسالة الماجستير الخاصة بـ Roger Dingledine في Free Haven (يونيو 2000، §8.1.1). اعتمد مطورو I2P المصطلح في أوائل العقد الأول من القرن الحادي والعشرين ليعكس تحسينات التجميع ونموذج النقل أحادي الاتجاه، مما يميزه عن تصميم Tor القائم على تبديل الدوائر.\nملخص: garlic routing = تشفير متعدد الطبقات + تجميع الرسائل + توصيل مجهول عبر أنفاق أحادية الاتجاه.\n2. مصطلح \u0026ldquo;Garlic\u0026rdquo; تاريخياً، تم استخدام مصطلح garlic في ثلاثة سياقات مختلفة داخل I2P:\nالتشفير متعدد الطبقات – حماية على مستوى tunnel بأسلوب onion تجميع رسائل متعددة – عدة \u0026ldquo;cloves\u0026rdquo; داخل \u0026ldquo;garlic message\u0026rdquo; التشفير من طرف إلى طرف – كان سابقاً ElGamal/AES+SessionTags، الآن ECIES‑X25519‑AEAD‑Ratchet بينما تظل البنية المعمارية سليمة، فقد تم تحديث نظام التشفير بالكامل.\n3. التشفير الطبقي يشترك توجيه Garlic مع توجيه Onion في مبدأه الأساسي: يقوم كل router بفك تشفير طبقة واحدة فقط من التشفير، ويتعرف فقط على القفزة التالية وليس المسار الكامل.\nومع ذلك، يقوم I2P بتنفيذ tunnels أحادية الاتجاه، وليست دوائر ثنائية الاتجاه:\nOutbound tunnel: يرسل الرسائل بعيداً عن المُنشئ Inbound tunnel: ينقل الرسائل عائدة إلى المُنشئ رحلة كاملة ذهاباً وإياباً (Alice ↔ Bob) تستخدم أربعة tunnels: outbound الخاص بـ Alice → inbound الخاص بـ Bob، ثم outbound الخاص بـ Bob → inbound الخاص بـ Alice. هذا التصميم يقلل تعرض بيانات الارتباط إلى النصف مقارنة بالدوائر ثنائية الاتجاه.\nلمزيد من التفاصيل حول تنفيذ الأنفاق، راجع مواصفات النفق ومواصفات إنشاء النفق (ECIES) .\n4. تجميع رسائل متعددة (\u0026ldquo;القرنفل\u0026rdquo;) تصور Freedman الأصلي لـ garlic routing تضمين عدة \u0026ldquo;بصيلات\u0026rdquo; مشفرة داخل رسالة واحدة. يطبق I2P هذا على شكل cloves (فصوص) داخل garlic message (رسالة الثوم) — كل clove له تعليمات التسليم والوجهة المشفرة الخاصة به (router أو destination أو tunnel).\nيتيح تجميع garlic لـ I2P:\nدمج الإقرارات والبيانات الوصفية مع رسائل البيانات تقليل أنماط حركة البيانات القابلة للملاحظة دعم هياكل الرسائل المعقدة دون اتصالات إضافية الشكل 1: رسالة Garlic تحتوي على عدة cloves، كل منها له تعليمات التسليم الخاصة به.\nتشمل فصوص الثوم النموذجية:\nرسالة حالة التسليم — إقرارات تؤكد نجاح أو فشل التسليم.\nيتم تغليفها في طبقة garlic خاصة بها للحفاظ على السرية. رسالة تخزين قاعدة البيانات — LeaseSets مجمعة تلقائياً حتى يتمكن الأقران من الرد دون الاستعلام مرة أخرى من netDb. يتم تجميع القرنفل عندما:\nيجب نشر LeaseSet جديد يتم تسليم علامات جلسة جديدة لم يحدث تجميع مؤخراً (حوالي دقيقة واحدة افتراضياً) تحقق رسائل garlic توصيلاً فعالاً من طرف إلى طرف لمكونات مشفرة متعددة في حزمة واحدة.\n5. تطور التشفير 5.1 Historical Context الوثائق المبكرة (الإصدار 0.9.12 أو أقدم) وصفت تشفير ElGamal/AES+SessionTags: - ElGamal 2048‑bit لتغليف مفاتيح جلسة AES - AES‑256/CBC لتشفير الحمولة - علامات جلسة بحجم 32 بايت تُستخدم مرة واحدة لكل رسالة\nهذا النظام التشفيري مُهمل.\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) بين عامي 2019 و2023، انتقلت I2P بالكامل إلى ECIES‑X25519‑AEAD‑Ratchet. يقوم المكدس الحديث بتوحيد المكونات التالية:\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains فوائد الانتقال إلى ECIES: السرية الأمامية عبر مفاتيح ratcheting لكل رسالة حجم حمولة مُخفّض مقارنة بـ ElGamal المرونة ضد التقدمات في التحليل التشفيري التوافق مع الهجينات المستقبلية لما بعد الكم (انظر الاقتراح 169) تفاصيل إضافية: راجع مواصفات ECIES ومواصفات EncryptedLeaseSet .\n6. LeaseSets and Garlic Bundling تتضمن مغلفات garlic في كثير من الأحيان LeaseSets لنشر أو تحديث إمكانية الوصول إلى الوجهة.\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively يتم توزيع جميع مجموعات الإيجار (LeaseSets) عبر *floodfill DHT* الذي تحتفظ به أجهزة التوجيه المتخصصة. يتم التحقق من المنشورات وختمها بطابع زمني وتحديد معدلها لتقليل الربط بين البيانات الوصفية. راجع وثائق قاعدة بيانات الشبكة للحصول على التفاصيل.\n7. Modern “Garlic” Applications within I2P يتم استخدام التشفير القائم على garlic وتجميع الرسائل في جميع أنحاء مكدس بروتوكول I2P:\nإنشاء واستخدام الأنفاق (Tunnel) — تشفير متعدد الطبقات لكل قفزة توصيل الرسائل من طرف إلى طرف — رسائل garlic مجمعة مع cloves التأكيد المستنسخ وLeaseSet نشر قاعدة بيانات الشبكة (Network Database) — LeaseSets ملفوفة في مظاريف garlic للخصوصية بروتوكولات النقل SSU2 وNTCP2 — تشفير الطبقة الأساسية باستخدام إطار عمل Noise وعمليات X25519/ChaCha20 الأولية التوجيه garlic هو بالتالي كل من طريقة لطبقات التشفير و نموذج لمراسلة الشبكة.\n6. LeaseSets وتجميع Garlic مركز توثيق I2P متاح هنا ، ويتم صيانته بشكل مستمر. المواصفات الحية ذات الصلة تشمل:\nمواصفات ECIES — ECIES‑X25519‑AEAD‑Ratchet إنشاء Tunnel (ECIES) — بروتوكول بناء tunnel الحديث مواصفات I2NP — تنسيقات رسائل I2NP مواصفات SSU2 — بروتوكول نقل SSU2 UDP البنى المشتركة — سلوك netDb و floodfill التحقق الأكاديمي: أكد Hoang وآخرون (IMC 2018، USENIX FOCI 2019) و Muntaka وآخرون (2025) الاستقرار المعماري والمرونة التشغيلية لتصميم I2P.\n7. تطبيقات \u0026ldquo;Garlic\u0026rdquo; الحديثة ضمن I2P المقترحات الجارية:\nالمقترح 169: هجين ما بعد الكم (ML-KEM 512/768/1024 + X25519) المقترح 168: تحسين عرض النطاق الترددي للنقل تحديثات Datagram والبث المباشر: إدارة محسّنة للازدحام قد تشمل التعديلات المستقبلية استراتيجيات إضافية لتأخير الرسائل أو التكرار متعدد الأنفاق على مستوى رسائل garlic، بالاستناد إلى خيارات التسليم غير المستخدمة التي وصفها فريدمان أصلاً.\n8. الوثائق والمراجع الحالية Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. ","description":"فهم مصطلحات garlic routing، البنية المعمارية، والتنفيذ الحديث في I2P","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"التوجيه بطريقة Garlic","url":"/ar/docs/overview/garlic-routing/"},{"categories":null,"content":"نظرة عامة توفر الـ Datagrams اتصالاً موجهاً للرسائل فوق I2CP وبالتوازي مع مكتبة البث. تتيح إرسال حزم قابلة للرد، أو موثقة، أو خام دون الحاجة إلى تدفقات موجهة بالاتصال. تقوم الـ routers بتغليف الـ datagrams في رسائل I2NP ورسائل tunnel، بغض النظر عما إذا كان NTCP2 أو SSU2 يحمل البيانات.\nالدافع الأساسي هو السماح للتطبيقات (مثل المتتبعات، أو محللات DNS، أو الألعاب) بإرسال حزم مستقلة تحدد هوية المرسل.\nجديد في 2025: وافق مشروع I2P على Datagram2 (البروتوكول 19) و Datagram3 (البروتوكول 20)، مما يضيف حماية من إعادة التشغيل ورسائل قابلة للرد بتكلفة أقل لأول مرة منذ عقد من الزمن.\n1. ثوابت البروتوكول Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) تم إضفاء الطابع الرسمي على البروتوكولين 19 و20 في **الاقتراح 163 (أبريل 2025)**. وهما يتعايشان مع Datagram1 / RAW للتوافق مع الإصدارات السابقة. 2. أنواع الرزم البيانية Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. ### أنماط التصميم النموذجية الطلب ← الاستجابة: إرسال Datagram2 موقّع (طلب + nonce)، واستقبال رد خام أو Datagram3 (صدى nonce). تردد عالي/حمل منخفض: يُفضل Datagram3 أو RAW. رسائل التحكم الموثّقة: Datagram2. التوافق مع الإصدارات القديمة: Datagram1 لا يزال مدعومًا بالكامل. 3. تفاصيل Datagram2 و Datagram3 (2025) Datagram2 (البروتوكول 19) بديل محسّن لـ Datagram1. الميزات: - منع إعادة التشغيل: رمز مضاد لإعادة التشغيل بحجم 4 بايتات. - دعم التوقيع دون اتصال: يتيح الاستخدام بواسطة Destinations الموقعة دون اتصال. - تغطية توقيع موسعة: تشمل hash الوجهة، الأعلام، الخيارات، كتلة التوقيع دون اتصال، الحمولة. - جاهز لما بعد الكم: متوافق مع ML-KEM hybrids المستقبلية. - الحمل الإضافي: ≈ 457 بايت (مفاتيح X25519).\nDatagram3 (البروتوكول 20) يسد الفجوة بين الأنواع الخام والموقعة. المميزات: - قابل للرد بدون توقيع: يحتوي على hash بطول 32 بايت للمرسل + علامات بطول 2 بايت. - حمل إضافي ضئيل: ≈ 34 بايت. - لا يوجد دفاع ضد إعادة الإرسال — يجب على التطبيق تنفيذه.\nكلا البروتوكولين من ميزات API 0.9.66 ومُنفذان في router الخاص بـ Java منذ الإصدار 2.9.0؛ لا توجد تطبيقات لـ i2pd أو Go حتى الآن (أكتوبر 2025).\n4. حدود الحجم والتجزئة حجم رسالة Tunnel: 1 028 بايت (4 بايت Tunnel ID + 16 بايت IV + 1 008 بايت حمولة). الجزء الأول: 956 بايت (تسليم TUNNEL النموذجي). الجزء التالي: 996 بايت. الحد الأقصى للأجزاء: 63–64. الحد العملي: ≈ 62 708 بايت (~61 كيلوبايت). الحد الموصى به: ≤ 10 كيلوبايت للتسليم الموثوق (تزداد حالات الإسقاط بشكل أُسّي بعد هذا الحد). ملخص الحمل الإضافي: - Datagram1 ≈ 427 بايت (الحد الأدنى). - Datagram2 ≈ 457 بايت. - Datagram3 ≈ 34 بايت. - الطبقات الإضافية (I2CP gzip header، I2NP، Garlic، Tunnel): + ~5.5 كيلوبايت في أسوأ الحالات.\n5. تكامل I2CP / I2NP مسار الرسالة: 1. ينشئ التطبيق datagram (عبر I2P API أو SAM). 2. يغلف I2CP بترويسة gzip (0x1F 0x8B 0x08، RFC 1952) ومجموع تدقيق CRC-32. 3. تُخزن أرقام البروتوكول + المنفذ في حقول ترويسة gzip. 4. يغلف الموجه Router كرسالة I2NP ← Garlic clove ← أجزاء tunnel بحجم 1 كيلوبايت. 5. تمر الأجزاء عبر tunnel صادر ← الشبكة ← tunnel وارد. 6. يُسلَّم datagram المُعاد تجميعه إلى معالج التطبيق بناءً على رقم البروتوكول.\nالتكامل: CRC-32 (من I2CP) + توقيع تشفيري اختياري (Datagram1/2). لا يوجد حقل تدقيق منفصل داخل الـ datagram نفسه.\n6. واجهات البرمجة واجهة برمجة التطبيقات Java الحزمة net.i2p.client.datagram تتضمن: - I2PDatagramMaker – ينشئ datagrams موقعة. - I2PDatagramDissector – يتحقق ويستخرج معلومات المرسل. - I2PInvalidDatagramException – يُطرح عند فشل التحقق.\nI2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl) يدير تعدد إرسال البروتوكول والمنافذ للتطبيقات التي تشترك في Destination واحد.\nالوصول إلى Javadoc: - idk.i2p Javadoc (شبكة I2P فقط) - Javadoc Mirror (نسخة على الإنترنت العادي) - Official Javadocs (الوثائق الرسمية)\nدعم SAMv3 SAM 3.2 (2016): إضافة معاملات PORT و PROTOCOL. SAM 3.3 (2016): تقديم نموذج PRIMARY/subsession؛ يسمح بالتدفقات + البيانات المجمعة على وجهة واحدة. تمت إضافة دعم أنماط جلسات Datagram2 / 3 في المواصفات 2025 (التنفيذ قيد الانتظار). المواصفات الرسمية: مواصفات SAM v3 وحدات i2ptunnel udpTunnel: قاعدة وظيفية بالكامل لتطبيقات I2P UDP (net.i2p.i2ptunnel.udpTunnel). streamr: عملي لبث الصوت/الفيديو (net.i2p.i2ptunnel.streamr). SOCKS UDP: غير وظيفي اعتبارًا من الإصدار 2.10.0 (نموذج UDP فقط). لأغراض UDP العامة، استخدم Datagram API أو udpTunnel مباشرة—لا تعتمد على SOCKS UDP.\n7. النظام البيئي ودعم اللغات (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental Java I2P هو الموجه الوحيد الذي يدعم subsessions كاملة لـ SAM 3.3 وواجهة برمجة التطبيقات Datagram2 في الوقت الحالي. 8. مثال على الاستخدام – متتبع UDP (I2PSnark 2.10.0) أول تطبيق حقيقي لـ Datagram2/3:\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return يوضح النمط الاستخدام المختلط لحزم البيانات المصادق عليها والخفيفة لتحقيق التوازن بين الأمان والأداء. 9. الأمان وأفضل الممارسات استخدم Datagram2 لأي تبادل مصادق عليه أو عندما تكون هجمات إعادة التشغيل مهمة. فضّل Datagram3 للاستجابات السريعة القابلة للرد مع ثقة معتدلة. استخدم RAW للبث العام أو البيانات المجهولة. احتفظ بالحمولات ≤ 10 كيلوبايت لضمان التسليم الموثوق. كن على علم بأن SOCKS UDP يبقى غير وظيفي. تحقق دائماً من CRC لـ gzip والتوقيعات الرقمية عند الاستلام. 10. المواصفات الفنية يغطي هذا القسم تنسيقات الحزم (datagram) منخفضة المستوى، والتغليف، وتفاصيل البروتوكول.\n10.1 تحديد البروتوكول تنسيقات البيانات المجزأة (Datagram) لا تشترك في رأس (header) مشترك. لا يمكن لأجهزة التوجيه (routers) استنتاج النوع من بايتات الحمولة (payload) وحدها.\nعند دمج أنواع متعددة من الـ datagram—أو عند الجمع بين الـ datagrams مع البث المستمر—قم بتعيين بشكل صريح: - رقم البروتوكول (عبر I2CP أو SAM) - اختيارياً رقم المنفذ، إذا كان تطبيقك يتعدد الخدمات\nترك البروتوكول غير محدد (0 أو PROTO_ANY) غير مُستحسن وقد يؤدي إلى أخطاء في التوجيه أو التسليم.\n10.2 الحزم الخام (Raw Datagrams) الرسائل البيانية غير القابلة للرد لا تحمل بيانات المرسل أو المصادقة. إنها حمولات معتمة، تُعالج خارج واجهة برمجة التطبيقات للرسائل البيانية عالية المستوى ولكنها مدعومة عبر SAM و I2PTunnel.\nالبروتوكول: 18 (PROTO_DATAGRAM_RAW)\nالتنسيق:\n+----+----+----+----+----// | payload... +----+----+----+----+----// طول البيانات محدود بقيود النقل (≈32 كيلوبايت كحد أقصى عملي، وغالباً أقل بكثير).\n10.3 Datagram1 (مخططات بيانات قابلة للرد) يضمّن Destination المرسل وSignature (التوقيع) للمصادقة وعنوان الرد.\nالبروتوكول: 17 (PROTO_DATAGRAM)\nالحمل الإضافي: ≥427 بايت الحمولة: حتى ~31.5 كيلوبايت (محدودة بواسطة النقل)\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from: وجهة Destination (387+ بايت) signature: توقيع Signature يطابق نوع المفتاح بالنسبة لـ DSA_SHA1: توقيع لقيمة التجزئة SHA-256 للحمولة بالنسبة لأنواع المفاتيح الأخرى: توقيع مباشر على الحمولة ملاحظات: - تم توحيد التوقيعات لأنواع non-DSA في I2P 0.9.14. - التوقيعات غير المتصلة LS2 (الاقتراح 123) غير مدعومة حالياً في Datagram1.\n10.4 تنسيق Datagram2 رسالة بيانات قابلة للرد محسّنة تضيف مقاومة إعادة التشغيل كما هو محدد في الاقتراح 163 .\nالبروتوكول: 19 (PROTO_DATAGRAM2)\nالتنفيذ جارٍ حالياً. يجب أن تتضمن التطبيقات فحوصات nonce أو الطابع الزمني للتكرار.\n10.5 تنسيق Datagram3 يوفر رسائل بيانات قابلة للرد لكن غير مصادق عليها. يعتمد على مصادقة الجلسة التي يحتفظ بها الموجه (router) بدلاً من الوجهة والتوقيع المضمنين.\nالبروتوكول: 20 (PROTO_DATAGRAM3) الحالة: قيد التطوير منذ 0.9.66\nمفيد عندما: - تكون الوجهات كبيرة (مثل مفاتيح ما بعد الكم) - تحدث المصادقة في طبقة أخرى - تكون كفاءة النطاق الترددي حرجة\n10.6 سلامة البيانات يتم حماية سلامة البيانات (Datagram) من خلال مجموع التحقق gzip CRC-32 في طبقة I2CP. لا يوجد حقل مجموع تحقق صريح ضمن تنسيق حمولة البيانات (datagram payload) نفسها.\n10.7 تغليف الحزم يتم تغليف كل datagram كرسالة I2NP واحدة أو كـ clove فردي في Garlic Message. تتولى طبقات I2CP وI2NP والـ tunnel معالجة الطول والتأطير — لا يوجد فاصل داخلي أو حقل طول في بروتوكول الـ datagram.\n10.8 اعتبارات ما بعد الكم (PQ) إذا تم تطبيق Proposal 169 (توقيعات ML-DSA)، فسترتفع أحجام التوقيعات والوجهات بشكل كبير — من ~455 بايت إلى ≥3739 بايت. سيؤدي هذا التغيير إلى زيادة كبيرة في الحمل الإضافي للبيانات وتقليل سعة الحمولة الفعلية.\nDatagram3، الذي يعتمد على المصادقة على مستوى الجلسة (وليس التوقيعات المضمنة)، من المرجح أن يصبح التصميم المفضل في بيئات I2P ما بعد الكم.\n11. المراجع اقتراح 163 – Datagram2 و Datagram3 اقتراح 160 – تكامل UDP Tracker اقتراح 144 – حسابات MTU للبث المباشر اقتراح 169 – التوقيعات ما بعد الكم مواصفات I2CP مواصفات I2NP مواصفات رسائل Tunnel مواصفات SAM v3 توثيق i2ptunnel 12. أبرز تغييرات السجل (2019 – 2025) Year Release Change 20190.9.43Datagram API stabilization 20210.9.50Protocol port handling reworked 20222.0.0SSU2 adoption completed 20242.6.0Legacy transport removal simplified UDP code 20252.9.0Datagram2/3 support added (Java API) 20252.10.0UDP Tracker implementation released --- 13. الملخص يدعم نظام الـ datagram الفرعي الآن أربعة متغيرات من البروتوكول توفر نطاقاً من المصادقة الكاملة إلى النقل الخام خفيف الوزن. يجب على المطورين الانتقال إلى Datagram2 للحالات الحساسة أمنياً وإلى Datagram3 لحركة البيانات القابلة للرد بكفاءة. تظل جميع الأنواع القديمة متوافقة لضمان إمكانية التشغيل البيني طويل الأمد.\n","description":"تنسيقات الرسائل المصادق عليها والقابلة للرد والخام فوق I2CP","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"الرسائل البيانية (Datagrams)","url":"/ar/docs/api/datagrams/"},{"categories":null,"content":"1. نظرة عامة الإدخالات في clients.config تخبر الـ router أي التطبيقات يتم تشغيلها عند بدء التشغيل. كل إدخال قد يعمل كـ managed client (مفضل) أو كـ unmanaged client. الـ managed clients تتعاون مع ClientAppManager، والذي:\nيقوم بإنشاء التطبيق وتتبع حالة دورة الحياة لوحدة تحكم الموجه (router console) يوفر عناصر التحكم في البدء/الإيقاف للمستخدم ويفرض عمليات إيقاف نظيفة عند خروج الموجه يستضيف سجل عملاء خفيف ومُخطط منافذ حتى تتمكن التطبيقات من اكتشاف خدمات بعضها البعض العملاء غير المُدارين (Unmanaged clients) يستدعون ببساطة دالة main()؛ استخدمها فقط للكود القديم الذي لا يمكن تحديثه.\n2. تنفيذ عميل مُدار يجب على العملاء المُدارة تنفيذ إما net.i2p.app.ClientApp (للتطبيقات الموجهة للمستخدم) أو net.i2p.router.app.RouterApp (لامتدادات الـ router). قم بتوفير أحد الـ constructors أدناه حتى يتمكن المدير من توفير context ومعاملات التكوين:\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) يحتوي مصفوفة args على القيم المُكوَّنة في clients.config أو الملفات الفردية في clients.config.d/. قم بتوسيع الفئات المساعدة ClientApp / RouterApp عندما يكون ذلك ممكناً لوراثة الربط الافتراضي لدورة الحياة.\n2.1 Lifecycle Methods من المتوقع أن ينفذ العملاء المُدارون (Managed clients):\nstartup() - تنفيذ التهيئة والعودة بسرعة. يجب استدعاء manager.notify() مرة واحدة على الأقل للانتقال من حالة INITIALIZED. shutdown(String[] args) - تحرير الموارد وإيقاف خيوط العمل في الخلفية. يجب استدعاء manager.notify() مرة واحدة على الأقل لتغيير الحالة إلى STOPPING أو STOPPED. getState() - إبلاغ لوحة التحكم بما إذا كان التطبيق قيد التشغيل أو البدء أو الإيقاف أو فشل يستدعي المدير هذه الوظائف (methods) عندما يتفاعل المستخدمون مع وحدة التحكم.\n2.2 Advantages تقارير حالة دقيقة في وحدة تحكم الراوتر عمليات إعادة تشغيل نظيفة دون تسريب threads أو مراجع ثابتة استهلاك ذاكرة أقل بمجرد توقف التطبيق تسجيل مركزي والإبلاغ عن الأخطاء عبر السياق المُدرج 3. Unmanaged Clients (Fallback Mode) إذا لم يقم الصف المُكوَّن بتنفيذ واجهة مُدارة، يقوم الموجه بتشغيله عن طريق استدعاء main(String[] args) ولا يمكنه تتبع العملية الناتجة. تعرض وحدة التحكم معلومات محدودة وقد لا يتم تشغيل خطافات الإيقاف. احتفظ بهذا الوضع للسكريبتات أو الأدوات المساعدة ذات الاستخدام الواحد التي لا يمكنها اعتماد واجهات برمجة التطبيقات المُدارة.\n4. Client Registry يمكن للعملاء المُدارة وغير المُدارة تسجيل أنفسها لدى المدير بحيث يمكن للمكونات الأخرى استرجاع مرجع بالاسم:\nmanager.register(this); يستخدم التسجيل القيمة المُرجعة من getName() الخاصة بالعميل كمفتاح للسجل. تتضمن التسجيلات المعروفة console و i2ptunnel و Jetty و outproxy و update. استرجع عميلاً باستخدام ClientAppManager.getRegisteredApp(String name) لتنسيق الميزات (على سبيل المثال، استعلام console عن Jetty للحصول على تفاصيل الحالة).\nلاحظ أن سجل العملاء (client registry) ومُخطط المنافذ (port mapper) هما نظامان منفصلان. يُمكّن سجل العملاء التواصل بين التطبيقات عن طريق البحث بالاسم، بينما يقوم مُخطط المنافذ بربط أسماء الخدمات بتركيبات host:port لاكتشاف الخدمات.\n3. العملاء غير المُدارة (وضع الاحتياطي) يوفر port mapper دليلاً بسيطاً لخدمات TCP الداخلية. قم بتسجيل منافذ loopback حتى يتجنب المتعاونون العناوين المشفرة بشكل ثابت:\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); أو مع تحديد صريح للمضيف:\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); ابحث عن الخدمات باستخدام PortMapper.getPort(String name) (يُرجع -1 إذا لم يتم العثور عليها) أو getPort(String name, int defaultPort) (يُرجع القيمة الافتراضية إذا لم يتم العثور عليها). تحقق من حالة التسجيل باستخدام isRegistered(String name) واسترجع المضيف المسجل باستخدام getActualHost(String name).\nثوابت خدمة تعيين المنافذ الشائعة من net.i2p.util.PortMapper:\nSVC_CONSOLE - وحدة تحكم الموجه Router (المنفذ الافتراضي 7657) SVC_HTTP_PROXY - وكيل HTTP (المنفذ الافتراضي 4444) SVC_HTTPS_PROXY - وكيل HTTPS (المنفذ الافتراضي 4445) SVC_I2PTUNNEL - مدير I2PTunnel SVC_SAM - جسر SAM (المنفذ الافتراضي 7656) SVC_SAM_SSL - جسر SAM بـ SSL SVC_SAM_UDP - SAM بـ UDP SVC_BOB - جسر BOB (المنفذ الافتراضي 2827) SVC_EEPSITE - موقع eepsite قياسي (المنفذ الافتراضي 7658) SVC_HTTPS_EEPSITE - موقع eepsite بـ HTTPS SVC_IRC - نفق IRC (المنفذ الافتراضي 6668) SVC_SUSIDNS - SusiDNS ملاحظة: httpclient و httpsclient و httpbidirclient هي أنواع أنفاق i2ptunnel (تُستخدم في إعدادات tunnel.N.type)، وليست ثوابت خدمة port mapper.\n4. سجل العملاء 2.1 أساليب دورة الحياة اعتبارًا من الإصدار 0.9.42، يدعم الموجه (router) تقسيم التكوين إلى ملفات فردية ضمن دليل clients.config.d/. يحتوي كل ملف على خصائص لعميل واحد مع جميع الخصائص مسبوقة بـ clientApp.0.:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true هذا هو النهج الموصى به للتثبيتات والإضافات الجديدة.\n2.2 المزايا للتوافق مع الإصدارات السابقة، يستخدم التنسيق التقليدي الترقيم المتسلسل:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties مطلوب: - main - اسم الفئة الكامل الذي ينفذ ClientApp أو RouterApp، أو يحتوي على main(String[] args) ثابت\nاختياري: - name - اسم العرض لوحدة تحكم الموجه (router console) (افتراضيًا اسم الفئة) - args - معاملات مفصولة بمسافة أو علامة تبويب (تدعم النصوص المقتبسة) - delay - الثواني قبل البدء (افتراضيًا 120) - onBoot - يفرض delay=0 إذا كان true - startOnLoad - يمكّن/يعطل العميل (افتراضيًا true)\nخاص بالإضافة: - stopargs - المعاملات الممررة أثناء الإيقاف - uninstallargs - المعاملات الممررة أثناء إلغاء تثبيت الإضافة - classpath - إدخالات مسار الفئة الإضافية مفصولة بفواصل\nاستبدال المتغيرات للإضافات: - $I2P - دليل I2P الأساسي - $CONFIG - دليل إعدادات المستخدم (مثال: ~/.i2p) - $PLUGIN - دليل الإضافات - $OS - اسم نظام التشغيل - $ARCH - اسم البنية المعمارية\n5. Port Mapper فضّل العملاء المُدارين؛ واستخدم العملاء غير المُدارين فقط عند الضرورة القصوى. اجعل عمليات التهيئة والإيقاف خفيفة الوزن حتى تظل عمليات console سريعة الاستجابة. استخدم أسماء واضحة للسجل والمنافذ حتى تتمكن أدوات التشخيص (والمستخدمون النهائيون) من فهم وظيفة الخدمة. تجنّب استخدام الـ static singletons - اعتمد على السياق والمدير المُحقَنين لمشاركة الموارد. استدعِ manager.notify() عند كل انتقال بين الحالات للحفاظ على دقة حالة console. إذا كان يجب عليك العمل في JVM منفصل، وثّق كيفية إظهار السجلات والتشخيصات في console الرئيسي. بالنسبة للبرامج الخارجية، فكّر في استخدام ShellService (المُضاف في الإصدار 1.7.0) للحصول على مزايا العملاء المُدارين. 6. تنسيق الإعداد تم تقديم العملاء المُدارة في الإصدار 0.9.4 (17 ديسمبر 2012) وتظل البنية الموصى بها حتى الإصدار 2.10.0 (9 سبتمبر 2025). ظلت واجهات برمجة التطبيقات الأساسية مستقرة دون أي تغييرات جذرية خلال هذه الفترة:\nتوقيعات المُنشئ (Constructor) دون تغيير دوال دورة الحياة (startup، shutdown، getState) دون تغيير دوال تسجيل ClientAppManager دون تغيير دوال تسجيل والبحث في PortMapper دون تغيير التحسينات البارزة: - 0.9.42 (2019) - هيكل دليل clients.config.d/ لملفات التكوين الفردية - 1.7.0 (2021) - إضافة ShellService لتتبع حالة البرامج الخارجية - 2.10.0 (2025) - الإصدار الحالي بدون تغييرات في واجهة برمجة التطبيقات للعملاء المُدارين\nالإصدار الرئيسي التالي سيتطلب Java 17+ كحد أدنى (متطلب بنية تحتية، وليس تغييراً في الـ API).\nReferences مواصفات clients.config مواصفات ملف التكوين فهرس الوثائق التقنية لـ I2P ClientAppManager Javadoc (API 0.9.66) PortMapper Javadoc (API 0.9.66) واجهة ClientApp (API 0.9.66) واجهة RouterApp (API 0.9.66) Javadoc بديل (مستقر) Javadoc بديل (نسخة مرآة على الشبكة العادية) ملاحظة: تستضيف شبكة I2P وثائق شاملة على http://idk.i 2p/javadoc-i2p/ والتي تتطلب router من I2P للوصول إليها. للوصول عبر الإنترنت العادي، استخدم نسخة GitHub Pages المذكورة أعلاه.\n","description":"كيفية تكامل التطبيقات المُدارة من قِبل الراوتر مع ClientAppManager ومُخطط المنافذ","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"العملاء المُدارون","url":"/ar/docs/applications/managed-clients/"},{"categories":null,"content":"نظرة عامة يحدد هذا المستند هياكل البيانات الأساسية المستخدمة عبر جميع بروتوكولات I2P، بما في ذلك I2NP ، I2CP ، SSU2 ، NTCP2 وغيرها. تضمن هذه الهياكل المشتركة قابلية التشغيل البيني بين تطبيقات I2P المختلفة وطبقات البروتوكول.\nالتغييرات الرئيسية منذ 0.9.58 أُعلِن تقادم ElGamal و DSA-SHA1 لهويات Router (استخدم X25519 + EdDSA) دعم ML-KEM لما بعد الكم في مرحلة الاختبار التجريبي (اختياري اعتبارًا من 2.10.0) تم توحيد خيارات سجل الخدمة (Proposal 167 , تم تنفيذها في 0.9.66) تم إقرار مواصفات الحشو القابل للضغط نهائيًا (Proposal 161 , تم تنفيذها في 0.9.57) مواصفات الأنواع المشتركة عدد صحيح الوصف: يمثّل عددًا صحيحًا غير سالب بترتيب بايتات الشبكة (big-endian؛ حيث يأتي البايت الأعلى أهمية أولًا).\nالمحتويات: من 1 إلى 8 بايتات تمثل عدداً صحيحاً غير موقّع.\nالاستخدام: أطوال الحقول، وأعداد العناصر، ومعرّفات الأنواع، والقيم الرقمية في جميع بروتوكولات I2P.\nالتاريخ الوصف: طابع زمني يمثل عدد الميلي ثانية منذ حقبة Unix (نقطة البداية الزمنية في أنظمة Unix) (1 يناير 1970 00:00:00 GMT).\nالمحتويات: عدد صحيح بطول 8 بايت (unsigned long)\nالقيم الخاصة: - 0 = تاريخ غير معرّف أو فارغ - القيمة القصوى: 0xFFFFFFFFFFFFFFFF (السنة 584,942,417,355)\nملاحظات التنفيذ: - دائمًا المنطقة الزمنية UTC/GMT - الدقة على مستوى الميلي ثانية مطلوبة - تُستخدم لانتهاء صلاحية الـlease (مدة الإيجار)، ونشر RouterInfo (معلومات الـRouter)، والتحقق من صحة الطابع الزمني\nسلسلة نصية الوصف: سلسلة نصية مرمّزة بترميز UTF-8 مع بادئة تحدد الطول.\nالتنسيق:\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes القيود: - الحد الأقصى للطول: 255 بايت (وليس عدد المحارف - تُحتسب تسلسلات UTF-8 متعددة البايت على أنها عدة بايتات) - قد يكون الطول صفراً (سلسلة فارغة) - لا يتضمن محرف الإنهاء null - السلسلة ليست منتهية بـ null\nهام: قد تستخدم تسلسلات UTF-8 عدة بايتات لكل حرف. قد تتجاوز سلسلة تحتوي على 100 حرف الحد البالغ 255 بايت إذا كانت تستخدم أحرف متعددة البايت.\nبُنى مفاتيح التشفير المفتاح العام الوصف: مفتاح عام للتشفير غير المتماثل. يعتمد نوع المفتاح وطوله على السياق أو يُحدَّدان في شهادة مفتاح.\nالنوع الافتراضي: ElGamal (خوارزمية تشفير بالمفتاح العام) (مهمل لهويات Router اعتبارًا من 0.9.58)\nالأنواع المدعومة:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta **متطلبات التنفيذ:** X25519 (النوع 4) - المعيار الحالي:\nيُستخدم لتشفير ECIES-X25519-AEAD-Ratchet إلزامي لهويات Router منذ 0.9.48 ترميز Little-endian (الترتيب الأصغر أولاً) (على خلاف الأنواع الأخرى) راجع ECIES وECIES-ROUTERS ElGamal (خوارزمية تشفير) (Type 0) - قديمة:\nمُهمَّلة لهويات Router اعتبارًا من 0.9.58 لا تزال صالحة للوجهات (الحقل غير مستخدم منذ 0.6/2005) تستخدم أعدادًا أولية ثابتة مُعرَّفة في مواصفة ElGamal يُحافَظ على الدعم للتوافق مع الإصدارات الأقدم MLKEM (ما بعد الكمّ) - بيتا:\nنهج هجين يجمع بين ML-KEM (آلية تغليف المفاتيح القائمة على الشبكات المعيارية) وX25519 غير مُفعّلة افتراضياً في 2.10.0 يتطلب تفعيلها يدوياً عبر Hidden Service Manager انظر ECIES-HYBRID وProposal 169 أكواد النوع والمواصفات قابلة للتغيير JavaDoc (توثيق جافا): PublicKey المفتاح الخاص الوصف: مفتاح خاص لفك التشفير غير المتماثل، يتوافق مع أنواع PublicKey.\nالتخزين: يُستدل على النوع والطول من السياق أو يتم تخزينهما بشكل منفصل في هياكل البيانات/ملفات المفاتيح.\nالأنواع المدعومة:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta **ملاحظات أمنية:** - يجب إنشاء المفاتيح الخاصة باستخدام مولدات أعداد عشوائية آمنة من الناحية التشفيرية - تستخدم مفاتيح X25519 الخاصة scalar clamping (تقييد السكالار) كما هو معرّف في RFC 7748 - يجب محو المادة المفتاحية من الذاكرة بشكل آمن عند عدم الحاجة إليها توثيق JavaDoc: PrivateKey SessionKey (مفتاح الجلسة) الوصف: مفتاح متناظر لتشفير وفك تشفير AES-256 ضمن tunnel وgarlic encryption الخاصة بـ I2P.\nالمحتوى: 32 بايت (256 بت)\nالاستخدام: - تشفير طبقة tunnel (AES-256/CBC with IV) - تشفير رسائل garlic - تشفير الجلسة من طرف إلى طرف\nالتوليد: يجب استخدام مولّد أعداد عشوائية آمن تشفيرياً.\nتوثيق JavaDoc: SessionKey SigningPublicKey (المفتاح العام للتوقيع) الوصف: المفتاح العمومي للتحقق من صحة التوقيع. يتم تحديد النوع والطول في شهادة المفتاح الخاصة بـ Destination (الوجهة في I2P) أو يُستدل عليهما من السياق.\nالنوع الافتراضي: DSA_SHA1 (مهمل اعتبارًا من 0.9.58)\nالأنواع المدعومة:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- **متطلبات التنفيذ:** EdDSA_SHA512_Ed25519 (Type 7) - المعيار الحالي:\nالإعداد الافتراضي لجميع هويات Router والوجهات الجديدة منذ أواخر 2015 يستخدم منحنى Ed25519 مع تجزئة SHA-512 مفاتيح عامة بطول 32 بايت، وتواقيع بطول 64 بايت ترميز Little-endian (ترتيب البايت من الأصغر إلى الأكبر) (على خلاف معظم الأنواع الأخرى) أداء عالٍ وأمن قوي RedDSA_SHA512_Ed25519 (النوع 11) - متخصص:\nيُستخدم حصراً مع leasesets المشفَّرة (مجموعات الإيجارات في I2P) وعمليات الإعماء لا يُستخدم مطلقاً في Router Identities أو Destinations القياسية الفروق الرئيسية عن EdDSA: توليد المفاتيح الخاصة بالاختزال المعياري (بدلاً من clamping أي تقييد البتّات) التواقيع تتضمن 80 بايتاً من البيانات العشوائية تستخدم المفاتيح العامة مباشرةً (وليس تجزئات المفاتيح الخاصة) راجع [مواصفة Red25519](//docs/specs/red25519-signature-scheme/ DSA_SHA1 (Type 0) - قديمة:\nمُعلنة كمهجورة لهويات Router اعتباراً من 0.9.58 غير مُستحسنة للوجهات الجديدة DSA بطول 1024-بت مع SHA-1 (نقاط ضعف معروفة) الإبقاء على الدعم لأغراض التوافق فقط مفاتيح متعددة العناصر:\nعندما يتكون من عنصرين (مثل: نقاط ECDSA (خوارزمية التوقيع الرقمي باستخدام المنحنيات البيضوية) X,Y) يُحشى كل عنصر إلى الطول/2 بأصفار بادئة مثال: مفتاح ECDSA بحجم 64 بايت = 32 بايت لـ X + 32 بايت لـ Y توثيق JavaDoc: SigningPublicKey SigningPrivateKey الوصف: مفتاح خاص لإنشاء التواقيع، المقابل لأنواع SigningPublicKey (مفتاح التوقيع العام).\nالتخزين: يتم تحديد النوع والطول وقت الإنشاء.\nالأنواع المدعومة:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized **متطلبات الأمان:** - التوليد باستخدام مصدر عشوائي آمن تشفيرياً - الحماية بضوابط وصول ملائمة - محوها بأمان من الذاكرة عند الانتهاء - بالنسبة إلى EdDSA (خوارزمية التوقيع الرقمي على منحنيات إدواردز): بذرة بحجم 32 بايت يُجرى لها تجزئة باستخدام SHA-512، وتصبح أول 32 بايت قيمة سكالار (scalar) مع تطبيق clamping (تقييد البتّات وفق المواصفات) - بالنسبة إلى RedDSA (متغير يستخدم الاختزال المعياري في توليد المفاتيح): توليد مفاتيح مختلف (اختزال معياري بدلاً من clamping) JavaDoc (توثيق جافا): SigningPrivateKey التوقيع الوصف: توقيع تشفيري على البيانات، باستخدام خوارزمية التوقيع المقابلة لنوع SigningPrivateKey.\nالنوع والطول: يتم استنتاجهما من نوع المفتاح المستخدم للتوقيع.\nالأنواع المدعومة:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized **ملاحظات التنسيق:** - التواقيع متعددة العناصر (مثلاً، قيم ECDSA R,S) تُستكمل كل قيمة إلى طول length/2 بإضافة أصفار بادئة - تستخدم EdDSA و RedDSA ترميز little-endian (ترتيب البايتات من الأقل أهمية إلى الأكثر أهمية) - تستخدم جميع الأنواع الأخرى ترميز big-endian (ترتيب البايتات من الأكثر أهمية إلى الأقل أهمية) التحقق: - استخدم SigningPublicKey المقابل - اتبع مواصفات خوارزمية التوقيع لنوع المفتاح - تحقق من أن طول التوقيع يطابق الطول المتوقع لنوع المفتاح\nJavaDoc (توثيق Java): Signature تجزئة الوصف: تجزئة SHA-256 للبيانات، تُستخدم في جميع أنحاء I2P للتحقق من السلامة والتعرّف.\nالمحتوى: 32 بايت (256 بت)\nالاستخدام: - تجزئات Router Identity (مفاتيح قاعدة بيانات الشبكة) - تجزئات الوجهة (مفاتيح قاعدة بيانات الشبكة) - تحديد بوابة Tunnel ضمن Leases - التحقق من سلامة البيانات - توليد معرف Tunnel\nالخوارزمية: SHA-256 كما هو محدد في FIPS 180-4\nJavaDoc (توثيق جافا): Hash وسم الجلسة الوصف: رقم عشوائي يُستخدم لتحديد هوية الجلسة والتشفير القائم على الوسوم.\nمهم: يختلف حجم وسم الجلسة بحسب نوع التشفير: - ElGamal/AES+SessionTag: 32 بايت (قديم) - ECIES-X25519: 8 بايت (المعيار الحالي)\nالمعيار الحالي (ECIES - مخطط التشفير المتكامل بالمنحنى الإهليلجي):\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers راجع ECIES وECIES-ROUTERS للاطلاع على المواصفات التفصيلية.\nقديم (ElGamal/AES — خوارزميتا تشفير):\nContents: 32 bytes Usage: Deprecated encryption scheme التوليد: يجب استخدام مولِّد أرقام عشوائية آمن تشفيرياً.\nجافا دوك: SessionTag TunnelId الوصف: مُعرّف فريد لموضع router داخل tunnel. تمتلك كل قفزة في tunnel قيمة TunnelId (معرّف النفق) خاصة بها.\nالتنسيق:\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) الاستخدام: - يحدد اتصالات tunnel الواردة/الصادرة عند كل router - TunnelId مختلف عند كل قفزة في سلسلة الـ tunnel - يُستخدم في هياكل Lease (بنية بيانات في I2P) لتحديد tunnel البوابة\nقيم خاصة: - 0 = محجوزة لاستخدامات خاصة في البروتوكول (تجنّب استخدامها في التشغيل العادي) - TunnelIds (معرّفات tunnel) صالحة محليًا لكل router\nJavaDoc: TunnelId مواصفات الشهادات شهادة الوصف: حاوية للإيصالات، أو لإثبات العمل، أو للبيانات الوصفية التشفيرية المستخدمة على امتداد I2P.\nالتنسيق:\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes الحجم الإجمالي: 3 بايت كحد أدنى (NULL certificate — شهادة فارغة)، وحتى 65538 بايت كحد أقصى\nأنواع الشهادات Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) ### شهادة المفتاح (النوع 5) المقدمة: الإصدار 0.9.12 (ديسمبر 2013)\nالغرض: يحدد أنواع مفاتيح غير افتراضية ويخزّن بيانات مفاتيح زائدة تتجاوز بنية KeysAndCert القياسية بحجم 384 بايت.\nبنية الحمولة:\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space ملاحظات التنفيذ الحرجة:\nترتيب أنواع المفاتيح:\nتحذير: يأتي نوع مفتاح التوقيع قبل نوع مفتاح التشفير هذا غير بديهي ولكنه مُحافَظ عليه لأغراض التوافق الترتيب: SPKtype, CPKtype (ليس CPKtype, SPKtype) تخطيط بيانات المفاتيح في KeysAndCert (هيكل المفاتيح والشهادة):\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] حساب بيانات المفاتيح الزائدة:\nإذا كان Crypto Key \u0026gt; 256 بايت: Excess = (Crypto Length - 256) إذا كان Signing Key \u0026gt; 128 بايت: Excess = (Signing Length - 128) Padding = max(0, 384 - Crypto Length - Signing Length) أمثلة (ElGamal Crypto Key، مفتاح تشفير بخوارزمية إل-غامال):\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 **متطلبات هوية Router:** - تم استخدام شهادة NULL حتى الإصدار 0.9.15 - شهادة المفتاح مطلوبة لأنواع المفاتيح غير الافتراضية منذ 0.9.16 - تم دعم مفاتيح التشفير X25519 منذ 0.9.48 متطلبات الوجهة: - شهادة NULL (فارغة) أو شهادة مفتاح (حسب الحاجة) - شهادة مفتاح مطلوبة لأنواع مفاتيح التوقيع غير الافتراضية منذ 0.9.12 - حقل المفتاح العام للتشفير غير مستخدم منذ 0.6 (2005) ولكنه يجب أن يظل موجوداً\nتحذيرات مهمة:\nشهادة NULL مقابل KEY:\nتُسمح شهادة KEY ذات الأنواع (0,0) التي تحدد ElGamal+DSA_SHA1، ولكن يُنصَح بتجنّبها استخدم دائمًا شهادة NULL لـ ElGamal+DSA_SHA1 (التمثيل المعياري) شهادة KEY ذات (0,0) أطول بمقدار 4 بايتات وقد تتسبب في مشكلات توافق قد لا تتعامل بعض عمليات التنفيذ مع شهادات KEY ذات (0,0) بشكل صحيح التحقق من البيانات الزائدة:\nيجب على عمليات التنفيذ التحقق من أن طول الشهادة يتطابق مع الطول المتوقع لكل نوع من أنواع المفاتيح رفض الشهادات التي تحتوي على بيانات زائدة لا تتوافق مع أنواع المفاتيح حظر وجود بيانات لاحقة عشوائية بعد بنية الشهادة الصالحة JavaDoc (توثيق الشيفرة في جافا): Certificate التعيين الوصف: مجموعة خصائص مفتاح-قيمة تُستخدم للتهيئة والبيانات الوصفية.\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] حدود الحجم: - طول المفتاح: 0-255 بايت (+ 1 بايت للطول) - طول القيمة: 0-255 بايت (+ 1 بايت للطول) - إجمالي حجم التعيين: 0-65535 بايت (+ 2 بايت لحقل الحجم) - الحد الأقصى لحجم البنية: 65537 بايت\nمتطلب حاسم للفرز:\nعند ظهور التعيينات في البنى الموقّعة (RouterInfo, RouterAddress, Destination properties, I2CP SessionConfig)، يجب ترتيب المدخلات حسب المفتاح لضمان ثبات التوقيع:\nطريقة الفرز: ترتيب معجمي باستخدام قيم نقاط الرمز في Unicode (يعادل Java String.compareTo()) حساسية حالة الأحرف: المفاتيح والقيم عمومًا حساسة لحالة الأحرف (تبعًا للتطبيق) المفاتيح المكررة: غير مسموح بها في البنى الموقعة (سيؤدي إلى فشل التحقق من التوقيع) ترميز الأحرف: مقارنة على مستوى البايت باستخدام UTF-8 لماذا يعد الفرز مهمًا: - يتم حساب التواقيع على التمثيل بالبايتات - تؤدي ترتيبات المفاتيح المختلفة إلى تواقيع مختلفة - لا تتطلب التعيينات غير الموقعة الفرز ولكن ينبغي أن تتبع الاتفاقية نفسها\nملاحظات التنفيذ:\nازدواجية الترميز:\nكلا المحدِّدين = و; وكذلك بايتات طول السلسلة موجودة هذا غير فعّال لكنه مُبقى للحفاظ على التوافق بايتات الطول هي المرجع المعتمد؛ المحدِّدات مطلوبة لكنها زائدة عن الحاجة دعم المحارف:\nعلى الرغم مما تذكره الوثائق، فإن = و ; مدعومان فعلًا داخل السلاسل النصية (تتعامل بايتات الطول مع ذلك) ترميز UTF-8 يدعم يونيكود بالكامل تحذير: I2CP يستخدم UTF-8، لكن I2NP تاريخيًا لم يكن يتعامل مع UTF-8 بشكل صحيح استخدم ASCII لتعيينات I2NP متى أمكن لتحقيق أقصى قدر من التوافق سياقات خاصة:\nRouterInfo/RouterAddress: يجب ترتيبها، من دون تكرارات I2CP SessionConfig: يجب ترتيبها، من دون تكرارات تعيينات التطبيقات: يوصى بالترتيب ولكن ليس مطلوبًا دائمًا مثال (خيارات RouterInfo):\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 JavaDoc (توثيق Java): DataHelper مواصفة البنية المشتركة المفاتيح والشهادة الوصف: بنية أساسية تجمع مفتاح التشفير، مفتاح التوقيع، والشهادة. تُستخدَم بوصفها كلًا من RouterIdentity وDestination.\nالبنية:\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) محاذاة المفاتيح: - المفتاح العام للتشفير: محاذى عند البداية (البايت 0) - الحشو: في الوسط (عند الحاجة) - المفتاح العام للتوقيع: محاذى عند النهاية (من البايت 256 إلى البايت 383) - الشهادة: تبدأ عند البايت 384\nحساب الحجم:\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length إرشادات توليد الحشو (المقترح 161 ) إصدار التنفيذ: 0.9.57 (يناير 2023، الإصدار 2.1.0)\nالخلفية: - بالنسبة للمفاتيح غير ElGamal+DSA، الحشو موجود في البنية الثابتة بحجم 384 بايت - بالنسبة إلى الوجهات (Destinations)، لم يُستخدم حقل المفتاح العام بحجم 256 بايت منذ الإصدار 0.6 (2005) - يجب توليد الحشو بحيث يكون قابلاً للضغط مع الحفاظ على الأمان\nالمتطلبات:\nالحد الأدنى للبيانات العشوائية:\nاستخدم ما لا يقل عن 32 بايتًا من بيانات عشوائية آمنة من الناحية التشفيرية يوفر هذا مقدارًا كافيًا من entropy (مقدار العشوائية) للأمان استراتيجية الضغط:\nكرّر 32 بايت على امتداد حقل الحشو/المفتاح العام تستخدم بروتوكولات مثل I2NP Database Store (رسالة تخزين قاعدة البيانات ضمن I2NP)، Streaming SYN (طلب SYN لبدء الاتصال في طبقة Streaming)، وSSU2 handshake (عملية المصافحة في SSU2) الضغط توفير كبير في استهلاك عرض النطاق الترددي دون المساس بالأمان أمثلة:\nهوية الـRouter (X25519 + EdDSA، خوارزميات تشفير منحنيات بيضاوية):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed الوجهة (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed لماذا يعمل هذا:\nتجزئة SHA-256 للبنية الكاملة لا تزال تتضمن كل الإنتروبيا (Entropy) يعتمد توزيع DHT لقاعدة بيانات الشبكة فقط على التجزئة مفتاح التوقيع (32 بايت EdDSA/X25519) يوفّر 256 بتًا من الإنتروبيا 32 بايتًا إضافية من بيانات عشوائية مكررة = 512 بتًا من الإنتروبيا الإجمالية أكثر من كافٍ لتحقيق قوة تشفيرية ملاحظات التنفيذ:\nيجب تخزين ونقل البنية الكاملة بحجم 387+ بايت تجزئة SHA-256 محسوبة على البنية الكاملة غير المضغوطة يُطبَّق الضغط على طبقة البروتوكول (I2NP, Streaming, SSU2) متوافق رجعياً مع جميع الإصدارات منذ 0.6 (2005) JavaDoc (توثيق جافا): KeysAndCert RouterIdentity (هوية router) الوصف: يعرّف router بشكل فريد ضمن شبكة I2P. بنية مطابقة لـ KeysAndCert (مفاتيح وشهادة).\nالتنسيق: انظر بنية KeysAndCert أعلاه\nالمتطلبات الحالية (اعتبارًا من 0.9.58):\nأنواع المفاتيح الإلزامية:\nالتشفير: X25519 (النوع 4، 32 بايت) التوقيع: EdDSA_SHA512_Ed25519 (النوع 7، 32 بايت) الشهادة: Key Certificate (شهادة المفتاح) (النوع 5) أنواع المفاتيح المهملة:\nElGamal (type 0) تم إهماله لـ Router Identities اعتبارًا من 0.9.58 DSA_SHA1 (type 0) تم إهماله لـ Router Identities اعتبارًا من 0.9.58 لا ينبغي إطلاقًا استخدامها مع أي router جديد الحجم النموذجي:\nX25519 + EdDSA مع شهادة المفتاح = 391 بايت 32 بايت لمفتاح عام X25519 320 بايت حشو (قابل للضغط حسب Proposal 161 ) 32 بايت لمفتاح عام EdDSA 7 بايت شهادة (ترويسة 3 بايت + أنواع المفاتيح 4 بايت) التطور التاريخي: - قبل 0.9.16: كانت الشهادة دائمًا NULL (ElGamal + DSA_SHA1) - 0.9.16-0.9.47: تمت إضافة دعم Key Certificate (شهادة المفاتيح) - 0.9.48+: تم دعم مفاتيح تشفير X25519 - 0.9.58+: تم إهمال ElGamal و DSA_SHA1\nمفتاح قاعدة البيانات الشبكية: - RouterInfo مفهرس بواسطة تجزئة SHA-256 لـ RouterIdentity الكامل - التجزئة محسوبة على البنية كاملة المؤلفة من 391+ بايت (بما في ذلك الحشو)\nانظر أيضًا: - إرشادات توليد الحشو (المقترح 161 ) - مواصفة شهادة المفتاح أعلاه\nJavaDoc (توثيق Java): RouterIdentity الوجهة الوصف: مُعرِّف نقطة نهاية للتسليم الآمن للرسائل. مماثل من حيث البنية لـ KeysAndCert، لكن بدلالات استخدام مختلفة.\nالتنسيق: راجع بنية KeysAndCert أعلاه\nالاختلاف الجوهري عن RouterIdentity: - حقل المفتاح العام غير مُستخدَم وقد يحتوي على بيانات عشوائية - لم يُستخدم هذا الحقل منذ الإصدار 0.6 (2005) - كان يُستخدم في الأصل لتشفير I2CP-to-I2CP القديم (معطَّل) - يُستخدم حالياً فقط كـ IV (متجه التهيئة) لتشفير LeaseSet المُهمل\nالتوصيات الحالية:\nمفتاح التوقيع:\nموصى به: EdDSA_SHA512_Ed25519 (النوع 7، 32 بايت) بديل: أنواع ECDSA للتوافق مع الإصدارات الأقدم تجنب: DSA_SHA1 (مهمل، غير مستحسن) مفتاح التشفير:\nالحقل غير مستخدَم لكنه يجب أن يكون موجودًا موصى به: املأه ببيانات عشوائية وفقًا لـ Proposal 161 (قابلة للضغط) الحجم: دائمًا 256 بايت (فتحة ElGamal (خوارزمية التشفير ElGamal)، على الرغم من أنه لا يُستَخدَم لـ ElGamal) الشهادة:\nشهادة NULL لـ ElGamal + DSA_SHA1 (للاستخدام المتقادِم فقط) شهادة المفتاح (Key Certificate) لجميع أنواع مفاتيح التوقيع الأخرى الوجهة النموذجية الحديثة:\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes مفتاح التشفير الفعلي: - مفتاح التشفير الخاص بالوجهة موجود في LeaseSet، وليس في الوجهة - يحتوي LeaseSet على المفاتيح العامة للتشفير الحالية - راجع مواصفات LeaseSet2 لمعالجة مفاتيح التشفير\nمفتاح قاعدة بيانات الشبكة: - LeaseSet (مجموعة عقود الوصول في I2P) مفهرس بواسطة تجزئة SHA-256 للوجهة الكاملة - تُحتسب التجزئة على البنية الكاملة بحجم 387+ بايت\nJavaDoc (توثيق جافا): Destination هياكل قاعدة بيانات الشبكة Lease (عنصر في leaseSet يحدد tunnel صالحاً حتى وقت انتهاء معين) الوصف: يأذن لـ tunnel معيّن باستلام الرسائل الموجّهة إلى Destination (الوجهة). وهو جزء من تنسيق LeaseSet الأصلي (النوع 1).\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch إجمالي الحجم: 44 بايت\nالاستخدام: - يُستخدم فقط في LeaseSet الأصلي (النوع 1، مهمل) - بالنسبة إلى LeaseSet2 والمتغيرات اللاحقة، استخدم Lease2 بدلاً من ذلك\nتوثيق JavaDoc: Lease LeaseSet (النوع 1) الوصف: صيغة LeaseSet الأصلية. تتضمن tunnels المصرَّح بها والمفاتيح الخاصة بـ Destination (الوجهة). مخزَّنة في قاعدة بيانات الشبكة. الحالة: مهملة (استخدم LeaseSet2 بدلاً من ذلك).\nالبنية:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey التخزين في قاعدة البيانات: - نوع قاعدة البيانات: 1 - المفتاح: تجزئة SHA-256 للوجهة - القيمة: البنية الكاملة لـ LeaseSet (بنية بيانات عقود المسارات الواردة في I2P)\nملاحظات مهمة:\nالمفتاح العام لـ Destination (الوجهة في I2P) غير مستخدم:\nحقل المفتاح العام للتشفير في Destination غير مستخدم مفتاح التشفير في LeaseSet هو مفتاح التشفير الفعلي مفاتيح مؤقتة:\nencryption_key مؤقت (يُعاد توليده عند بدء تشغيل router) signing_key مؤقت (يُعاد توليده عند بدء تشغيل router) لا يتم الاحتفاظ بأيّ من المفتاحين بين عمليات إعادة التشغيل الإبطال (غير مُنفَّذ):\nكان signing_key معدّاً لإبطال LeaseSet لم تُنفَّذ آلية الإبطال مطلقاً كان المقصود استخدام LeaseSet بصفر عقود (zero-lease) للإبطال، لكنه غير مُستَخدَم إدارة الإصدارات/الطابع الزمني:\nلا يحتوي LeaseSet على حقل طابع زمني published صريح الإصدار هو أبكر وقت لانتهاء صلاحية جميع leases (عنصر تسليم مؤقت في I2P) يجب أن يكون انتهاء صلاحية lease في LeaseSet الجديد أبكر ليتم قبوله نشر أوقات انتهاء الـ lease (مدخل يحدد نفقًا ووقت انتهاءه):\nقبل 0.9.7: تم نشر جميع الـ leases بنفس وقت الانتهاء (الأبكر) 0.9.7+: تم نشر أوقات انتهاء كل lease الفعلية بشكل منفصل هذا تفصيل تنفيذي، وليس جزءًا من المواصفة صفر Leases:\nيُسمح تقنياً بـ LeaseSet يحتوي على صفر Leases مخصّص للإبطال (غير منفذ) غير مستخدم عملياً متغيرات LeaseSet2 تتطلب Lease واحداً على الأقل إيقاف الدعم: تم إيقاف دعم LeaseSet من النوع 1. ينبغي للتنفيذات الجديدة استخدام LeaseSet2 (النوع 3) الذي يوفّر: - حقل طابع زمني للنشر (إدارة إصدارات أفضل) - دعم مفاتيح تشفير متعددة - إمكانية التوقيع دون اتصال - تواريخ انتهاء صلاحية الـ lease بطول 4 بايت (بدلاً من 8 بايت) - خيارات أكثر مرونة\nتوثيق Java (JavaDoc): LeaseSet أنواع LeaseSet Lease2 (الإصدار الثاني من هيكل البيانات Lease في I2P) الوصف: تنسيق Lease (سجل مؤقت للنفق) مُحسَّن بحقل انتهاء صلاحية من 4 بايت. يُستخدم في LeaseSet2 (النوع 3) وMetaLeaseSet (النوع 7).\nالمقدمة: الإصدار 0.9.38 (انظر المقترح 123 )\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 إجمالي الحجم: 40 بايت (أصغر بـ 4 بايت من Lease الأصلي (سجل نفق وارد في I2P))\nالمقارنة مع Lease الأصلية (مكوّن في I2P):\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet **JavaDoc (توثيق جافا):** [Lease2](http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html) توقيع دون اتصال الوصف: بنية اختيارية للمفاتيح العابرة الموقعة مسبقًا، مما يتيح نشر LeaseSet دون الحاجة إلى الوصول عبر الإنترنت إلى مفتاح التوقيع الخاص بالوجهة (Destination).\nالمقدمة: الإصدار 0.9.38 (انظر المقترح 123 )\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey الغرض: - يُتيح إنشاء LeaseSet دون اتصال - يحمي المفتاح الرئيسي للوجهة من التعرض عبر الإنترنت - يمكن إبطال المفتاح المؤقت بنشر LeaseSet جديد دون توقيع غير متصل\nسيناريوهات الاستخدام:\nوجهات عالية الأمان:\nمفتاح التوقيع الرئيسي مخزّن دون اتصال (HSM (وحدة أمن عتادية)، التخزين البارد) تُولَّد المفاتيح المؤقتة دون اتصال لفترات زمنية محدودة اختراق مفتاح مؤقت لا يعرّض المفتاح الرئيسي للخطر نشر LeaseSet مُشفّر:\nEncryptedLeaseSet يمكن أن يتضمن توقيعًا غير متصل المفتاح العام المُعمّى + التوقيع غير المتصل يوفّران أمانًا إضافيًا اعتبارات الأمان:\nإدارة انتهاء الصلاحية:\nاضبط مدة انتهاء صلاحية معقولة (من أيام إلى أسابيع، وليس سنوات) أنشئ مفاتيح مؤقتة جديدة قبل تاريخ الانتهاء مدة انتهاء أقصر = أمان أفضل، وصيانة أكثر توليد المفاتيح:\nأنشئ مفاتيح مؤقتة دون اتصال في بيئة آمنة وقّع باستخدام المفتاح الرئيسي دون اتصال انقل فقط المفتاح المؤقت الموقّع + التوقيع إلى الـrouter المتصل الإبطال:\nانشر LeaseSet جديداً من دون توقيع غير متصل لإبطاله ضمنياً أو انشر LeaseSet جديداً بمفتاح مؤقت مختلف التحقق من التوقيع:\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature ملاحظات التنفيذ: - يختلف الحجم الإجمالي حسب sigtype (نوع التوقيع) ونوع مفتاح توقيع Destination (الوجهة) - الحد الأدنى للحجم: 4 + 2 + 32 (مفتاح EdDSA) + 64 (توقيع EdDSA) = 102 بايت - الحد الأقصى العملي للحجم: ~600 بايت (مفتاح RSA-4096 مؤقت + توقيع RSA-4096)\nمتوافق مع: - LeaseSet2 (النوع 3) - EncryptedLeaseSet (النوع 5) - MetaLeaseSet (النوع 7)\nانظر أيضًا: Proposal 123 للاطلاع على بروتوكول التوقيع غير المتصل بالتفصيل.\nLeaseSet2Header (رأس LeaseSet2 في I2P) الوصف: بنية ترويسة مشتركة لـ LeaseSet2 (النوع 3) و MetaLeaseSet (النوع 7).\nالمقدمة: الإصدار 0.9.38 (انظر الاقتراح 123 )\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length الحد الأدنى للحجم الإجمالي: 395 بايت (من دون توقيع غير متصل بالإنترنت)\nتعريفات الأعلام (ترتيب البتات: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility **تفاصيل العلم:** البت 0 - المفاتيح غير المتصلة: - 0: لا يوجد توقيع غير متصل؛ استخدم مفتاح توقيع Destination للتحقق من توقيع LeaseSet - 1: تأتي بنية OfflineSignature (توقيع غير متصل) بعد حقل الأعلام\nالبت 1 - غير منشور: - 0: LeaseSet منشور قياسي، يجب توزيعه إلى floodfills - 1: LeaseSet غير منشور (على جانب العميل فقط) - يجب ألّا يتم توزيعه أو نشره أو إرساله استجابةً للاستعلامات - إذا انتهت صلاحيته، فلا تستعلم netdb عن بديل (إلّا إذا كان البت 2 مُفعّلاً أيضًا) - يُستخدم لـ tunnels محلية أو للاختبار\nالبت 2 - Blinded (مُعمّى) (منذ 0.9.42): - 0: LeaseSet قياسي - 1: سيتم تعمية هذا LeaseSet غير المشفّر وتشفيره عند النشر - النسخة المنشورة ستكون EncryptedLeaseSet (النوع 5) - إذا انتهت صلاحيته، استعلم عن blinded location في netdb لاستبداله - يجب أيضًا ضبط البت 1 إلى 1 (غير منشور + blinded) - يُستخدم للخدمات الخفية المُشفّرة\nحدود انتهاء الصلاحية:\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours **متطلبات الطابع الزمني المنشور:** لم يكن LeaseSet (type 1) يحتوي على حقل published، مما كان يستلزم البحث عن أقرب وقت لانتهاء صلاحية الـ lease لأغراض تحديد الإصدار. تضيف LeaseSet2 طابعًا زمنيًا صريحًا باسم published بدقة ثانية واحدة.\nملاحظة تنفيذية حرجة: - يجب على Routers تقييد معدل نشر LeaseSet ليكون أبطأ بكثير من مرة واحدة في الثانية لكل Destination (الوجهة) - إذا كان النشر أسرع، فتأكد من أن كل LeaseSet جديد لديه وقت published متأخراً بما لا يقل عن ثانية واحدة - سترفض Floodfills الـ LeaseSet إذا لم يكن وقت published أحدث من الإصدار الحالي - الفاصل الزمني الأدنى الموصى به: 10–60 ثانية بين عمليات النشر\nأمثلة حسابية:\nLeaseSet2 (بحد أقصى 11 دقيقة):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet (بحد أقصى 18.2 ساعة):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) إدارة الإصدارات: - يُعتبر LeaseSet \u0026ldquo;أحدث\u0026rdquo; إذا كان الطابع الزمني لـ published أكبر - تقوم Floodfills بتخزين ونشر أحدث إصدار فقط - توخَّ الحذر عندما يتطابق أقدم Lease (مدخل ضمن LeaseSet) مع أقدم Lease في LeaseSet السابق\nLeaseSet2 (النوع 3) الوصف: تنسيق LeaseSet حديث بمفاتيح تشفير متعددة، وتواقيع غير متصلة بالإنترنت، وسجلات خدمة. المعيار الحالي لخدمات I2P المخفية.\nالمقدمة: الإصدار 0.9.38 (انظر المقترح 123 )\nالبنية:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix تخزين قاعدة البيانات: - نوع قاعدة البيانات: 3 - المفتاح: تجزئة SHA-256 لـ Destination (الوجهة) - القيمة: البنية الكاملة لـ LeaseSet2\nحساب التوقيع:\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key ترتيب أولوية مفتاح التشفير بالنسبة إلى LeaseSet المنشور (الخادم): - تُدرَج المفاتيح وفق ترتيب تفضيل الخادم (الأكثر تفضيلاً أولاً) - ينبغي على العملاء الذين يدعمون أنواعاً متعددة احترام تفضيل الخادم - اختر أول نوع مدعوم من القائمة - عموماً، تكون أنواع المفاتيح ذات الأرقام الأعلى (الأحدث) أكثر أماناً/كفاءة - الترتيب الموصى به: سرد المفاتيح بترتيب عكسي حسب رمز النوع (الأحدث أولاً)\nمثال على تفضيل الخادم:\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] بالنسبة إلى LeaseSet غير المنشور (العميل): - ترتيب المفاتيح عملياً لا يهم (نادراً ما تُحاوَل الاتصالات إلى العملاء) - اتبع نفس الاصطلاح للحفاظ على الاتساق\nاختيار مفتاح العميل: - احترام تفضيل الخادم (اختيار أول نوع مدعوم) - أو استخدام تفضيل يحدده التنفيذ - أو تحديد تفضيل مركّب بناءً على قدرات الطرفين\nتعيين الخيارات المتطلبات: - يجب ترتيب الخيارات حسب المفتاح (ترتيب معجمي، ترتيب البايتات وفق UTF-8) - يضمن الفرز ثبات التوقيع - غير مسموح بالمفاتيح المكررة\nالتنسيق القياسي (المقترح 167 ):\nاعتبارًا من API 0.9.66 (يونيو 2025، الإصدار 2.9.0)، تتبع خيارات سجل الخدمة تنسيقًا موحدًا. راجع المقترح 167 للاطلاع على المواصفة الكاملة.\nتنسيق خيار سجل الخدمة:\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) أمثلة على سجلات الخدمة:\n1. خادم SMTP يشير إلى نفسه:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. خادم SMTP خارجي واحد:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. خوادم SMTP متعددة (موازنة التحميل):\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. خدمة HTTP مع خيارات التطبيق:\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates توصيات TTL (مدة الحياة): - الحد الأدنى: 86400 ثانية (يوم واحد) - TTL أطول يقلّل حمل الاستعلامات على netdb - تحقيق توازن بين تقليل الاستعلامات ونشر تحديثات الخدمة - للخدمات المستقرة: 604800 (7 أيام) أو أطول\nملاحظات التنفيذ:\nمفاتيح التشفير (اعتبارًا من 0.9.44):\nElGamal (خوارزمية إلجامال للتشفير) (النوع 0، 256 بايت): توافق مع الإصدارات القديمة X25519 (خوارزمية تبادل مفاتيح بيضوية) (النوع 4، 32 بايت): المعيار الحالي MLKEM variants (خوارزمية تشفير مقاومة للكمّ): بعد-كمومي (بيتا، غير نهائي) التحقق من طول المفتاح:\nFloodfills والعملاء يجب أن يكونوا قادرين على تحليل أنواع مفاتيح غير معروفة استخدم الحقل keylen لتخطي المفاتيح غير المعروفة لا تفشل عملية التحليل إذا كان نوع المفتاح غير معروف الطابع الزمني للنشر:\nراجع ملاحظات LeaseSet2Header بخصوص الحدّ من المعدّل حد أدنى لفاصل زمني مقداره ثانية واحدة بين عمليات النشر موصى به: 10-60 ثانية بين عمليات النشر ترحيل نوع التشفير:\nدعم مفاتيح متعددة يتيح انتقالاً تدريجياً أدرِج كلاً من المفاتيح القديمة والجديدة خلال فترة الانتقال أزِل المفتاح القديم بعد انقضاء فترة كافية لترقية العملاء توثيق JavaDoc: LeaseSet2 MetaLease (مصطلح تقني ضمن I2P) الوصف: بنية Lease (مدخل خدمة في I2P) لـ MetaLeaseSet يمكنها الإشارة إلى LeaseSets أخرى بدلًا من tunnels. تُستخدم لموازنة الأحمال والتكرار.\nالمقدمة: الإصدار 0.9.38، ومقرّر العمل به في 0.9.40 (انظر المقترح 123 )\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 إجمالي الحجم: 40 بايت\nنوع الإدخال (بتات الأعلام 3-0):\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) **سيناريوهات الاستخدام:** موازنة الأحمال:\nMetaLeaseSet (مجموعة إيجار ميتا) مع مدخلات MetaLease (إيجار ميتا) متعددة يشير كل إدخال إلى LeaseSet2 (مجموعة الإيجار الإصدار 2) مختلف يختار العملاء بناءً على حقل التكلفة التكرار:\nمدخلات متعددة تشير إلى LeaseSets احتياطية آلية بديلة إذا كان LeaseSet الأساسي غير متاح ترحيل الخدمة:\nMetaLeaseSet تشير إلى LeaseSet جديد يتيح انتقال سلس بين Destinations (عناوين I2P) استخدام حقل التكلفة: - تكلفة أقل = أولوية أعلى - تكلفة 0 = أعلى أولوية - تكلفة 255 = أدنى أولوية - ينبغي للعملاء تفضيل الإدخالات ذات التكلفة الأقل - قد تُوزَّع الأحمال عشوائياً بين الإدخالات متساوية التكلفة\nالمقارنة مع Lease2:\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing **توثيق JavaDoc:** [MetaLease](http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html) MetaLeaseSet (النوع 7) الوصف: نوع من LeaseSet يحتوي على مدخلات MetaLease (مدخل فوقي)، مما يوفر توجيهاً غير مباشراً إلى LeaseSets أخرى. يُستخدم لموازنة الحمل، والتكرار، وترحيل الخدمات.\nالمقدمة: تم التعريف في الإصدار 0.9.38، مُجدول للعمل في 0.9.40 (انظر المقترح 123 )\nالحالة: المواصفة مكتملة. ينبغي التحقق من حالة النشر في بيئة الإنتاج باستخدام إصدارات I2P الحالية.\nالبنية:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations تخزين قاعدة البيانات: - نوع قاعدة البيانات: 7 - المفتاح: تجزئة SHA-256 لـ Destination (الوجهة في I2P) - القيمة: البنية الكاملة لـ MetaLeaseSet (مجموعة leaseSet الوصفية)\nحساب التوقيع:\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key سيناريوهات الاستخدام:\n1. موازنة الحمل:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. التبديل التلقائي عند الفشل:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. ترحيل الخدمة:\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. معمارية متعددة الطبقات:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing قائمة الإبطال:\nتتيح قائمة الإبطال لـ MetaLeaseSet (هيكل بيانات يجمع عدة LeaseSets) إبطال LeaseSets المنشورة سابقًا بصورة صريحة:\nالغرض: تحديد وجهات معيّنة على أنها لم تعد صالحة المحتويات: تجزئات SHA-256 لهياكل الوجهة المُبطلة الاستخدام: يجب على العملاء عدم استخدام LeaseSets التي تظهر تجزئة وجهتها في قائمة الإبطال القيمة النموذجية: فارغة (numr=0) في معظم عمليات النشر مثال على الإبطال:\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached التعامل مع انتهاء الصلاحية:\nMetaLeaseSet (نوع بيانات في I2P) يستخدم LeaseSet2Header بحد أقصى expires=65535 ثانية (~18.2 ساعة):\nأطول بكثير من LeaseSet2 (حد أقصى ~11 دقيقة) مناسب للإحالة غير المباشرة الثابتة نسبياً يمكن أن يكون انتهاء صلاحية LeaseSets المُشار إليها أقصر يجب على العملاء التحقق من انتهاء صلاحية كل من MetaLeaseSet وLeaseSets المُشار إليها تعيين الخيارات:\nاستخدم نفس تنسيق خيارات LeaseSet2 يمكن أن تتضمن سجلات الخدمة (Proposal 167 ) يجب ترتيبها حسب المفتاح تصف سجلات الخدمة عادةً الخدمة النهائية، وليس indirection structure (بنية التوجيه غير المباشر) ملاحظات تنفيذ العميل:\nعملية الحل:\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry التخزين المؤقت:\nخزّن مؤقتاً كلّاً من MetaLeaseSet (مجموعة إيجارات وصفية) وLeaseSets المشار إليها تحقّق من انتهاء الصلاحية في كلا المستويين راقب نشر إصدار محدّث من MetaLeaseSet Failover (التحويل التلقائي عند الفشل):\nإذا فشل الإدخال المفضّل، جرّب الخيار التالي الأقل تكلفة فكّر في وسم الإدخالات الفاشلة كغير متاحة مؤقتًا أعد التحقق دوريًا للتحقق من التعافي حالة التنفيذ:\nالمقترح 123 يشير إلى أن بعض الأجزاء لا تزال \u0026ldquo;قيد التطوير.\u0026rdquo; ينبغي على المنفذين: - التحقق من جاهزية الإنتاج في إصدار I2P المستهدف - اختبار دعم MetaLeaseSet (نوع «LeaseSet» فوقي/تجميعي في I2P) قبل النشر - التحقق من وجود مواصفات محدّثة في إصدارات I2P الأحدث\nJavaDoc (توثيق Java): MetaLeaseSet EncryptedLeaseSet (النوع 5) الوصف: LeaseSet مشفّر و blinded (إعماء) لتعزيز الخصوصية. لا يظهر سوى المفتاح العام blinded والبيانات الوصفية؛ أما الـ leases (سجلات الربط المؤقتة) الفعلية ومفاتيح التشفير فهي مشفّرة.\nالمقدمة: تم تعريفه في 0.9.38، أصبح فعّالًا في 0.9.39 (انظر المقترح 123 )\nالبنية:\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key تخزين قاعدة البيانات: - نوع قاعدة البيانات: 5 - المفتاح: تجزئة SHA-256 لـ الوجهة المُعمّاة (ليست الوجهة الأصلية) - القيمة: البنية الكاملة لـ EncryptedLeaseSet\nالفروقات الجوهرية مقارنةً بـ LeaseSet2:\nلا يستخدم بنية LeaseSet2Header (يحتوي على حقول متشابهة لكن بتخطيط مختلف) مفتاح عام مُعمّى بدلاً من Destination الكامل (معرّف الوجهة في I2P) حمولة مُشفّرة بدلاً من leases (سجلات المسار في I2P) والمفاتيح غير المشفّرة مفتاح قاعدة البيانات هو تجزئة لـ Destination المُعمّى، وليس Destination الأصلي حساب التوقيع:\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key متطلب نوع التوقيع:\nيجب استخدام RedDSA_SHA512_Ed25519 (النوع 11): - مفاتيح عامة معمّاة بطريقة الإعماء (blinding) بطول 32 بايت - تواقيع بطول 64 بايت - مطلوب لضمان خصائص الأمان المتعلقة بالإعماء - راجع [مواصفة Red25519](//docs/specs/red25519-signature-scheme/\nالفروق الرئيسية عن EdDSA: - المفاتيح الخاصة باستخدام الاختزال المعياري (وليس clamping: تعديل بتّات المفتاح الخاص بفرض قيود ثابتة) - تتضمن التواقيع 80 بايتًا من البيانات العشوائية - تستخدم المفاتيح العامة مباشرة (وليس التجزئات) - تمكّن عملية إعماء آمنة\nالإعماء والتشفير:\nراجع مواصفة EncryptedLeaseSet (نوع مشفّر من الـ leaseSet) للاطلاع على التفاصيل الكاملة:\n1. إعماء المفتاح:\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. موقع قاعدة البيانات:\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. طبقات التشفير (ثلاث طبقات):\nالطبقة 1 - طبقة المصادقة (وصول العملاء): - التشفير: ChaCha20 (شيفرة تدفقية) - اشتقاق المفاتيح: HKDF مع أسرار خاصة بكل عميل - يمكن للعملاء المُصادَقين فك تشفير الطبقة الخارجية\nالطبقة 2 - طبقة التشفير: - التشفير: ChaCha20 - المفتاح: مشتق من DH (تبادل المفاتيح ديفي-هيلمان) بين العميل والخادم - يتضمن LeaseSet2 أو MetaLeaseSet الفعلي\nالطبقة 3 - LeaseSet الداخلي: - نسخة كاملة من LeaseSet2 أو MetaLeaseSet - يتضمن جميع tunnels ومفاتيح التشفير والخيارات - لا يمكن الوصول إليه إلا بعد فك التشفير بنجاح\nاشتقاق مفتاح التشفير:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) عملية الاكتشاف:\nللعملاء المصرَّح لهم:\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication للعُملاء غير المصرّح لهم: - لا يمكنهم فك التشفير حتى لو عثروا على EncryptedLeaseSet - لا يمكنهم تحديد Destination (الوجهة في I2P) الأصلية من الإصدار المُعمّى - لا يمكنهم ربط EncryptedLeaseSets عبر فترات تعمية مختلفة (تدوير يومي)\nأوقات انتهاء الصلاحية:\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived **الطابع الزمني للنشر:** نفس المتطلبات مثل LeaseSet2Header: - يجب أن يزداد بمقدار ثانية واحدة على الأقل بين عمليات النشر - تقوم Floodfills برفضه إذا لم يكن أحدث من الإصدار الحالي - موصى به: 10–60 ثانية بين عمليات النشر\nتواقيع دون اتصال مع LeaseSets المشفّرة:\nاعتبارات خاصة عند استخدام التواقيع غير المتصلة (offline signatures): - Blinded public key (المفتاح العام المموّه) يتبدّل يوميًا - يجب إعادة توليد Offline signature يوميًا باستخدام blinded key جديد - أو استخدم Offline signature على LeaseSet الداخلية، وليس على EncryptedLeaseSet الخارجية - راجع ملاحظات المقترح 123 ملاحظات التنفيذ:\nتفويض العميل:\nيمكن تفويض عدة عملاء بمفاتيح مختلفة يمتلك كل عميل مُفوَّض بيانات اعتماد لفك التشفير فريدة إبطال تفويض العميل بتغيير مفاتيح التفويض تدوير المفاتيح اليومي:\nتتغيّر Blinded keys (مفاتيح مُعمّاة بغرض الإخفاء) عند منتصف الليل بتوقيت UTC يجب على العملاء إعادة حساب blinded Destination (الوجهة المعمّاة) يومياً تصبح EncryptedLeaseSets (LeaseSets مشفّرة) القديمة غير قابلة للاكتشاف بعد التدوير خصائص الخصوصية:\nلا يمكن لـ Floodfills تحديد Destination (الوجهة) الأصلية لا يمكن للعملاء غير المصرّح لهم الوصول إلى الخدمة لا يمكن ربط فترات التعمية المختلفة لا توجد بيانات وصفية بنص صريح باستثناء أوقات الانتهاء الأداء:\nيجب على العملاء إجراء حساب blinding (الإعماء) اليومي يضيف التشفير ثلاثي الطبقات حملاً حسابياً إضافياً ينبغي النظر في التخزين المؤقت لـ LeaseSet الداخلي بعد فك التشفير الاعتبارات الأمنية:\nإدارة مفاتيح التفويض:\nتوزيع بيانات اعتماد تفويض العملاء بشكل آمن استخدام بيانات اعتماد فريدة لكل عميل لتمكين الإبطال الدقيق تدوير مفاتيح التفويض بشكل دوري مزامنة الساعة:\nيعتمد الـ blinding (إعماء/تعمية لأغراض الخصوصية) اليومي على تواريخ UTC المتزامنة قد يتسبب انحراف الساعة في فشل عمليات البحث فكّر في دعم blinding لليوم السابق/التالي للتسامح مع انحراف الساعة تسرب البيانات الوصفية:\nحقلا Published و expires يكونان نصاً صريحاً (غير مُشفَّر) قد يكشف تحليل الأنماط خصائص الخدمة اجعل فترات النشر عشوائية إذا كان ذلك مصدر قلق JavaDoc: EncryptedLeaseSet هياكل Router RouterAddress (عنوان الـrouter) الوصف: يحدّد معلومات الاتصال الخاصة بـ router عبر بروتوكول نقل محدّد.\nالتنسيق:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary حرج - حقل انتهاء الصلاحية:\n⚠️ يجب ضبط حقل انتهاء الصلاحية إلى جميع الأصفار (8 بايتات صفرية).\nالسبب: منذ الإصدار 0.9.3، تؤدي قيمة انتهاء الصلاحية غير صفرية إلى فشل التحقق من التوقيع التاريخ: كان حقل انتهاء الصلاحية غير مستخدم في الأصل، وكان دائمًا null الحالة الحالية: تم التعرف على الحقل مرة أخرى اعتبارًا من 0.9.12، لكن يجب انتظار ترقية الشبكة التنفيذ: يُعيَّن دائمًا إلى 0x0000000000000000 أي قيمة انتهاء صلاحية غير صفرية ستؤدي إلى فشل التحقق من توقيع RouterInfo (بنية معلومات الـ router في I2P).\nبروتوكولات النقل البروتوكولات الحالية (اعتبارًا من الإصدار 2.10.0):\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 **قيم أنماط النقل:** - `\"SSU2\"`: النقل الحالي المعتمد على UDP - `\"NTCP2\"`: النقل الحالي المعتمد على TCP - `\"NTCP\"`: قديمة، أُزيلت (لا تستخدم) - `\"SSU\"`: قديمة، أُزيلت (لا تستخدم) الخيارات المشتركة تتضمن جميع بروتوكولات النقل عادةً:\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) خيارات خاصة بـ SSU2 راجع مواصفة SSU2 للحصول على التفاصيل الكاملة.\nالخيارات المطلوبة:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) خيارات اختيارية:\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) مثال على SSU2 RouterAddress:\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 الخيارات الخاصة بـ NTCP2 انظر مواصفة NTCP2 للاطلاع على التفاصيل الكاملة.\nالخيارات المطلوبة:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) خيارات اختيارية (منذ 0.9.50):\n\u0026#34;caps\u0026#34; = Capability string مثال على NTCP2 (بروتوكول نقل في I2P) RouterAddress:\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 ملاحظات التنفيذ قيم التكلفة:\nUDP (SSU2) عادة أقل تكلفة (5-6) بفضل الكفاءة TCP (NTCP2) عادة أعلى تكلفة (10-11) بسبب الحمل الإضافي التكلفة الأقل = وسيلة النقل المفضلة عناوين متعددة:\nقد تقوم Routers بنشر عدة إدخالات RouterAddress بروتوكولات نقل مختلفة (SSU2 وNTCP2) إصدارات IP مختلفة (IPv4 وIPv6) يختار العملاء بناءً على التكلفة والقدرات اسم المضيف مقابل IP:\nتُفضَّل عناوين IP لتحسين الأداء يتم دعم أسماء المضيف، لكنها تضيف عبئًا إضافيًا لاستعلام DNS فكّر في استخدام IP لـ RouterInfos (بيانات تعريف router في I2P) المنشورة ترميز Base64:\nيتم ترميز جميع المفاتيح والبيانات الثنائية باستخدام Base64 Base64 القياسي (RFC 4648) بدون padding (حشو) أو أحرف غير قياسية JavaDoc (توثيق جافا): RouterAddress RouterInfo الوصف: معلومات منشورة كاملة عن router، مخزنة في قاعدة بيانات الشبكة (netDb). تتضمن الهوية والعناوين والقدرات.\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey تخزين قاعدة البيانات: - نوع قاعدة البيانات: 0 - المفتاح: تجزئة SHA-256 لـ RouterIdentity - القيمة: البنية الكاملة لـ RouterInfo\nالطابع الزمني المنشور: - تاريخ/وقت بحجم 8 بايت (ميلي ثانية منذ epoch (بداية زمن يونكس)) - يُستخدم لإدارة إصدارات RouterInfo - Routers تنشر RouterInfo جديدًا بشكل دوري - تحتفظ Floodfills بأحدث إصدار استنادًا إلى الطابع الزمني المنشور\nفرز العناوين: - تاريخيًا: كانت routers القديمة جدًا تتطلب فرز العناوين حسب SHA-256 لبياناتها - حاليًا: الفرز غير مطلوب، ولا يستحق التنفيذ لأغراض التوافق - يمكن أن تكون العناوين بأي ترتيب\nحقل حجم النظير (تاريخي): - دائمًا 0 في I2P الحديثة - كان مقصودًا للمسارات المقيّدة (غير مُنفّذة) - لو تم تنفيذه، لَتَبِعَه ذلك العدد من تجزئات Router - قد تكون بعض التطبيقات القديمة قد اشترطت قائمة نظراء مُرتّبة\nتعيين الخيارات:\nيجب ترتيب الخيارات بحسب اسم المفتاح. تشمل الخيارات القياسية:\nخيارات القدرات:\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable خيارات الشبكة:\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; الخيارات الإحصائية:\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string انظر وثائق RouterInfo لقاعدة بيانات الشبكة (RouterInfo: سجل معلومات router) للاطلاع على القائمة الكاملة للخيارات القياسية.\nحساب التوقيع:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length RouterInfo (بيانات تعريف الـrouter) الحديثة النموذجية:\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical ملاحظات التنفيذ:\nعناوين متعددة:\nRouters عادةً تنشر من 1 إلى 4 عناوين متغيرات IPv4 وIPv6 بروتوكولات النقل SSU2 و/أو NTCP2 كل عنوان مستقل إدارة الإصدارات:\nيحتوي RouterInfo (بيانات تعريف الـ router في I2P) الأحدث على طابعٍ زمني لحقل published أحدث من السابق تعيد routers النشر كل ~2 ساعة أو عند تغيّر العناوين تخزّن Floodfills (عُقَد floodfill في I2P) وتبثّ أحدث إصدار فقط التحقق:\nتحقق من التوقيع قبل قبول RouterInfo (هيكل معلومات Router) تحقق من أن حقل انتهاء الصلاحية كله أصفار في كل RouterAddress (عنوان Router) تحقق من أن خريطة الخيارات مرتبة حسب المفتاح تحقق من أن أنواع الشهادات والمفاتيح معروفة/مدعومة قاعدة بيانات الشبكة:\nتقوم Floodfills بتخزين RouterInfo مفهرساً حسب Hash(RouterIdentity) تُخزَّن لمدة تقارب يومين بعد آخر نشر Routers ترسل استعلامات إلى floodfills لاكتشاف Routers أخرى JavaDoc: RouterInfo ملاحظات التنفيذ ترتيب البايتات (Endianness) الافتراضي: Big-Endian (ترتيب بايتات الشبكة)\nتستخدم معظم بُنى I2P ترتيب البايتات big-endian (الأعلى أهمية أولاً): - جميع أنواع الأعداد الصحيحة (1-8 بايت) - الطوابع الزمنية للتواريخ - TunnelId - بادئة طول السلسلة - أنواع الشهادات وأطوالها - رموز نوع المفتاح - حقول حجم التعيين\nاستثناء: Little-Endian (ترتيب البايت الصغير أولاً)\nتستخدم أنواع المفاتيح التالية ترميز little-endian (ترتيب البايتات من الأصغر إلى الأكبر): - مفاتيح التشفير X25519 (النوع 4) - مفاتيح التوقيع EdDSA_SHA512_Ed25519 (النوع 7) - مفاتيح التوقيع EdDSA_SHA512_Ed25519ph (النوع 8) - مفاتيح التوقيع RedDSA_SHA512_Ed25519 (النوع 11)\nالتنفيذ:\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); ترقيم إصدارات البنية لا تفترض أحجامًا ثابتة أبدًا:\nالعديد من البُنى ذات طول متغير: - RouterIdentity (معرف Router): 387+ بايت (ليس دائما 387) - Destination: 387+ بايت (ليس دائما 387) - LeaseSet2 (الإصدار 2 من LeaseSet): يتفاوت بشكل ملحوظ - Certificate: 3+ بايت\nاقرأ دائمًا حقول الحجم: - طول الشهادة عند البايتين 1-2 - حجم التعيين في البداية - KeysAndCert (مجموعة المفاتيح والشهادة) يُحسب دائمًا على أنه 384 + 3 + certificate_length\nتحقق من البيانات الزائدة: - منع البيانات اللاحقة غير المرغوب فيها بعد البُنى الصالحة - التحقق من أن أطوال الشهادات تطابق أنواع المفاتيح - فرض الأطوال المتوقعة بدقة للأنواع ذات الحجم الثابت\nالتوصيات الحالية (أكتوبر 2025) بالنسبة لهويات Router الجديدة:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/ar/proposals/161-ri-dest-padding/) بالنسبة إلى الوجهات الجديدة:\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/ar/proposals/161-ri-dest-padding/) بالنسبة إلى LeaseSets الجديدة (وصف لمسارات الدخول إلى وجهة في I2P):\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per [Proposal 167](/proposals/167-service-records/) Signature: EdDSA (64 bytes) للخدمات المشفرة:\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys ميزات مهملة - لا تستخدم التشفير المهمل: - ElGamal (النوع 0) لهويات Router (مهمل منذ 0.9.58) - تشفير ElGamal/AES+SessionTag (وسم الجلسة) (استخدم ECIES-X25519)\nخيارات التوقيع المهملة: - DSA_SHA1 (type 0) لهويات Router (مهمل منذ 0.9.58) - متغيرات ECDSA (types 1-3) للتنفيذات الجديدة - متغيرات RSA (types 4-6) باستثناء ملفات SU3\nتنسيقات الشبكة المتوقفة عن الاستخدام: - LeaseSet من النوع 1 (استخدم LeaseSet2) - Lease (44 بايت, استخدم Lease2) - تنسيق انتهاء صلاحية Lease الأصلي\nوسائط النقل المهملة: - NTCP (أزيل في 0.9.50) - SSU (أزيل في 2.4.0)\nالشهادات المهملة: - HASHCASH (النوع 1) - HIDDEN (النوع 2) - SIGNED (النوع 3) - MULTIPLE (النوع 4)\nاعتبارات أمنية توليد المفاتيح: - استخدم دائماً مولدات أعداد عشوائية آمنة تشفيرياً - لا تعاود استخدام المفاتيح عبر سياقات مختلفة - احمِ المفاتيح الخاصة بضوابط التحكم في الوصول المناسبة - امسح بيانات المفاتيح من الذاكرة بشكل آمن عند الانتهاء\nالتحقق من التوقيع: - تحقّق دائمًا من التواقيع قبل الوثوق بالبيانات - تحقّق من أن طول التوقيع يطابق نوع المفتاح - تحقّق من أن البيانات الموقعة تتضمن الحقول المتوقعة - بالنسبة إلى الخرائط المرتبة، تحقّق من ترتيب الفرز قبل التوقيع/التحقق\nالتحقق من صحة الطابع الزمني: - تحقق من أن الأوقات المنشورة معقولة (ليست في مستقبل بعيد) - تحقق من أن تواريخ انتهاء فترات الإيجار لم تنقضِ - راعِ سماحية انحراف الساعة (±30 ثانية عادةً)\nقاعدة بيانات الشبكة: - التحقق من صحة جميع الهياكل قبل التخزين - فرض حدود للحجم لمنع هجمات حجب الخدمة (DoS) - تقييد معدل الاستعلامات وعمليات النشر - التحقق من أن مفاتيح قاعدة البيانات تطابق تجزئات الهياكل\nملاحظات التوافق التوافق مع الإصدارات السابقة: - لا يزال دعم ElGamal و DSA_SHA1 قائماً لـ routers القديمة - تظل أنواع المفاتيح المهملة تعمل، لكن غير مستحسنة - الحشو القابل للضغط (المقترح 161 ) متوافق رجوعياً حتى الإصدار 0.6\nالتوافق المستقبلي: - يمكن تحليل أنواع المفاتيح غير المعروفة باستخدام حقول الطول - يمكن تجاوز أنواع الشهادات غير المعروفة باستخدام الطول - يجب التعامل مع أنواع التواقيع غير المعروفة بسلاسة - لا ينبغي أن يفشل المنفذون عند مواجهة ميزات اختيارية غير معروفة\nاستراتيجيات الترحيل: - دعم كلٍ من أنواع المفاتيح القديمة والجديدة خلال فترة الانتقال - يمكن لـ LeaseSet2 إدراج عدة مفاتيح تشفير - التواقيع غير المتصلة تمكّن تدوير المفاتيح بأمان - يتيح MetaLeaseSet ترحيل الخدمة بشفافية\nالاختبار والتحقق التحقّق من البنية: - تحقّق من أن جميع حقول الطول ضمن النطاقات المتوقعة - تحقّق من أن البُنى ذات الطول المتغير تُحلَّل بشكل صحيح - تحقّق من أن التواقيع يتم التحقق من صحتها بنجاح - اختبر مع البُنى ذات الحد الأدنى والحد الأقصى للحجم\nالحالات الحدّية: - سلاسل نصية بطول صفري - تعيينات فارغة - الحدّين الأدنى والأقصى لعدد الإيجارات - شهادة ذات حمولة بطول صفري - تراكيب كبيرة جداً (قريبة من الأحجام القصوى)\nالتشغيل البيني: - الاختبار مقابل التطبيق الرسمي لـ Java I2P - التحقق من التوافق مع i2pd - الاختبار باستخدام محتويات متنوعة لقاعدة بيانات الشبكة - التحقق مقابل متجهات اختبار معروفة بأنها صحيحة\nالمراجع المواصفات بروتوكول I2NP بروتوكول I2CP نقل SSU2 نقل NTCP2 بروتوكول Tunnel بروتوكول الداتاغرام علم التشفير نظرة عامة على التشفير تشفير ElGamal/AES تشفير ECIES-X25519 ECIES لـ Routers ECIES الهجين (ما بعد الكمّ) تواقيع Red25519 LeaseSet مشفّر مقترحات المقترح 123: مدخلات netDB الجديدة المقترح 134: أنواع تواقيع GOST المقترح 136: أنواع تواقيع تجريبية المقترح 145: ECIES-P256 المقترح 156: ECIES Routers المقترح 161: توليد الحشو المقترح 167: سجلات الخدمة المقترح 169: التشفير ما بعد الكمّي فهرس جميع المقترحات قاعدة بيانات الشبكة نظرة عامة على قاعدة بيانات الشبكة (netDb) الخيارات القياسية لـ RouterInfo مرجع JavaDoc لواجهة برمجة التطبيقات حزمة البيانات الأساسية PublicKey PrivateKey SessionKey SigningPublicKey SigningPrivateKey Signature Hash SessionTag TunnelId Certificate DataHelper KeysAndCert RouterIdentity Destination Lease LeaseSet Lease2 LeaseSet2 MetaLease MetaLeaseSet EncryptedLeaseSet RouterAddress RouterInfo المعايير الخارجية RFC 7748 (X25519): المنحنيات الإهليلجية للأمان RFC 7539 (ChaCha20): ChaCha20 وPoly1305 لبروتوكولات IETF RFC 4648 (Base64): ترميزات البيانات Base16 وBase32 وBase64 FIPS 180-4 (SHA-256): معيار التجزئة الآمنة FIPS 204 (ML-DSA): معيار التوقيع الرقمي القائم على Module-Lattice (شبكات الوحدات) سجل خدمات IANA موارد المجتمع موقع I2P منتدى I2P GitLab الخاص بـ I2P مرآة I2P على GitHub فهرس الوثائق التقنية معلومات الإصدار إصدار I2P 2.10.0 سجل الإصدارات سجل التغييرات الملحق: جداول مرجعية سريعة مرجع سريع لأنواع المفاتيح المعيار الحالي (مُوصى به لجميع عمليات التنفيذ الجديدة): - التشفير: X25519 (النوع 4، 32 بايت، ترتيب بايت صغير) - التوقيع: EdDSA_SHA512_Ed25519 (النوع 7، 32 بايت، ترتيب بايت صغير)\nقديم (مدعوم ولكن مُهمَل): - التشفير: ElGamal (خوارزمية تشفير غير متناظرة) (النوع 0، 256 بايت، big-endian) - التوقيع: DSA_SHA1 (خوارزمية توقيع رقمي تعتمد SHA-1) (النوع 0، خاص 20 بايت / عام 128 بايت، big-endian)\nمتخصص: - التوقيع (LeaseSet مشفر): RedDSA_SHA512_Ed25519 (النوع 11، 32 بايت، بترتيب بايت صغير)\nما بعد الكمومي (بيتا، غير نهائي): - تشفير هجين: متغيرات MLKEM_X25519 (الأنواع 5-7) - تشفير ما بعد الكمومي الخالص: متغيرات MLKEM (خوارزمية تغليف مفاتيح ما بعد كمومي) (لم تُخصَّص رموز أنواع بعد)\nمرجع سريع لحجم البنية Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes ### مرجع سريع لأنواع قاعدة البيانات Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status ### مرجع سريع لبروتوكول النقل Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 ### مرجع سريع لمعالم الإصدارات Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023[Proposal 161](/ar/proposals/161-ri-dest-padding/) padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025[Proposal 167](/proposals/167-service-records/) service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) --- ","description":"أنواع البيانات المشتركة وتنسيقات التسلسل المستخدمة عبر مواصفات I2P","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"الهياكل الشائعة","url":"/ar/docs/specs/common-structures/"},{"categories":null,"content":"نظرة عامة توفر مكتبة I2P Streaming نقلاً موثوقاً ومرتباً ومصادقاً عليه عبر طبقة الرسائل في I2P، مشابهة لـ TCP over IP. تقع فوق بروتوكول I2CP وتُستخدم من قبل جميع تطبيقات I2P التفاعلية تقريباً، بما في ذلك بروكسيات HTTP وIRC وBitTorrent والبريد الإلكتروني.\nالخصائص الأساسية إعداد اتصال من مرحلة واحدة باستخدام علامات SYN و ACK و FIN التي يمكن دمجها مع بيانات الحمولة لتقليل عدد الرحلات ذهاباً وإياباً. التحكم في الازدحام بنافذة منزلقة، مع بداية بطيئة وتجنب للازدحام مُعدّل لبيئة I2P ذات الكمون العالي. ضغط الحزم (الافتراضي 4KB شرائح مضغوطة) يوازن بين تكلفة إعادة الإرسال وكمون التجزئة. قناة مصادق عليها، مشفرة، وموثوقة بالكامل بين وجهات I2P. يتيح هذا التصميم إكمال طلبات واستجابات HTTP الصغيرة في رحلة ذهاب وإياب واحدة. قد تحمل حزمة SYN حمولة الطلب، بينما قد تحتوي حزمة SYN/ACK/FIN الخاصة بالمستجيب على نص الاستجابة الكامل.\nأساسيات واجهة برمجة التطبيقات (API) واجهة برمجة التطبيقات للبث في Java تحاكي برمجة المقابس القياسية في Java:\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory يتفاوض أو يعيد استخدام جلسة router عبر I2CP. إذا لم يتم توفير مفتاح، يتم إنشاء وجهة جديدة تلقائياً. يمكن للمطورين تمرير خيارات I2CP (مثل أطوال tunnel، أنواع التشفير، أو إعدادات الاتصال) من خلال خريطة options. I2PSocket و I2PServerSocket يعكسان واجهات Java القياسية Socket، مما يجعل الترحيل سهلاً ومباشراً. وثائق Javadocs الكاملة متاحة من وحدة تحكم موجه I2P أو هنا .\nالتكوين والضبط يمكنك تمرير خصائص الإعدادات عند إنشاء مدير المقبس (socket manager) عبر:\nI2PSocketManagerFactory.createManager(host, port, properties); الخيارات الرئيسية Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false ### السلوك حسب حمل العمل Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. تشمل الميزات الأحدث منذ الإصدار 0.9.4 منع سجلات الرفض، ودعم قوائم DSA (0.9.21)، وفرض البروتوكول الإلزامي (0.9.36). تتضمن أجهزة الـ router منذ الإصدار 2.10.0 التشفير الهجين ما بعد الكمي (ML-KEM + X25519) على طبقة النقل. تفاصيل البروتوكول يتم تعريف كل تدفق بواسطة معرف التدفق (Stream ID). تحمل الحزم أعلام تحكم مشابهة لـ TCP: SYNCHRONIZE، ACK، FIN، و RESET. يمكن أن تحتوي الحزم على كل من البيانات وأعلام التحكم في وقت واحد، مما يحسن الكفاءة للاتصالات قصيرة الأمد.\nدورة حياة الاتصال إرسال SYN — يتضمن المُبادِر بيانات اختيارية. استجابة SYN/ACK — يتضمن المُستجيب بيانات اختيارية. إنهاء ACK — يُنشئ الموثوقية وحالة الجلسة. FIN/RESET — يُستخدم للإغلاق المنظم أو الإنهاء المفاجئ. التجزئة وإعادة الترتيب نظرًا لأن أنفاق I2P تُدخل تأخيرًا وإعادة ترتيب للرسائل، تقوم المكتبة بتخزين الحزم مؤقتًا من التدفقات غير المعروفة أو التي تصل مبكرًا. يتم تخزين الرسائل المخزنة مؤقتًا حتى تكتمل المزامنة، مما يضمن تسليمًا كاملاً ومرتبًا.\nتطبيق البروتوكول الخيار i2p.streaming.enforceProtocol=true (افتراضي منذ الإصدار 0.9.36) يضمن أن الاتصالات تستخدم رقم بروتوكول I2CP الصحيح، مما يمنع التعارضات بين الأنظمة الفرعية المتعددة التي تشترك في وجهة واحدة.\nالتوافقية وأفضل الممارسات يتعايش بروتوكول البث مع Datagram API، مما يمنح المطورين الاختيار بين النقل الموجه بالاتصال والنقل غير الموجه بالاتصال.\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram ### العملاء المشتركون يمكن للتطبيقات إعادة استخدام الأنفاق الموجودة عن طريق العمل كـ عملاء مشتركين، مما يسمح لخدمات متعددة بمشاركة نفس الوجهة. بينما يقلل هذا من العبء، إلا أنه يزيد من مخاطر الربط بين الخدمات—استخدمه بحذر.\nالتحكم في الازدحام تتكيف طبقة البث المباشر بشكل مستمر مع زمن الاستجابة وسرعة النقل عبر الملاحظات المبنية على RTT. تعمل التطبيقات بشكل أفضل عندما تكون أجهزة router مساهمة كنظراء (مع تمكين المشاركة في tunnels). آليات التحكم في الازدحام الشبيهة بـ TCP تمنع إرهاق النظراء البطيئين وتساعد في موازنة استخدام النطاق الترددي عبر tunnels. اعتبارات زمن الاستجابة نظرًا لأن I2P يضيف عدة مئات من الميلي ثانية من التأخير الأساسي، يجب على التطبيقات تقليل عدد الرحلات ذهابًا وإيابًا. قم بتجميع البيانات مع إعداد الاتصال حيثما أمكن (على سبيل المثال، طلبات HTTP في SYN). تجنب التصميمات التي تعتمد على العديد من التبادلات المتسلسلة الصغيرة.\nالاختبار والتوافق قم دائماً بالاختبار على كل من Java I2P و i2pd لضمان التوافق الكامل. على الرغم من توحيد البروتوكول، قد توجد اختلافات طفيفة في التنفيذ. تعامل مع routers الأقدم بمرونة—فالعديد من النظراء لا يزالون يستخدمون إصدارات ما قبل 2.0. راقب إحصائيات الاتصال باستخدام I2PSocket.getOptions() و getSession() لقراءة مقاييس RTT وإعادة الإرسال. يعتمد الأداء بشكل كبير على إعداد tunnel: - أنفاق قصيرة (1-2 hops) → زمن استجابة أقل، عدم إخفاء هوية مخفض. - أنفاق طويلة (3+ hops) → عدم إخفاء هوية أعلى، زيادة في RTT.\nالتحسينات الرئيسية (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. --- ملخص مكتبة I2P Streaming Library هي العمود الفقري لجميع الاتصالات الموثوقة داخل I2P. فهي تضمن تسليم الرسائل بالترتيب الصحيح، مع المصادقة والتشفير، وتوفر بديلاً شبه جاهز لبروتوكول TCP في البيئات المجهولة.\nلتحقيق الأداء الأمثل: - قلل من الرحلات ذهابًا وإيابًا من خلال تجميع SYN+payload. - اضبط معاملات النافذة والمهلة الزمنية وفقًا لحمل العمل الخاص بك. - فضل الأنفاق الأقصر للتطبيقات الحساسة لزمن الاستجابة. - استخدم تصاميم متوافقة مع الازدحام لتجنب إرهاق الأقران.\n","description":"بروتوكول نقل شبيه بـ TCP يستخدم من قبل معظم تطبيقات I2P","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"بروتوكول البث المباشر","url":"/ar/docs/api/streaming/"},{"categories":null,"content":"نظرة عامة توفر I2P Streaming Library إيصال بيانات موثوقًا، وفق الترتيب، ومصادقًا عليه فوق طبقة الرسائل غير الموثوقة الخاصة بـ I2P — على غرار TCP فوق IP. تُستخدم من قبل تكاد جميع تطبيقات I2P التفاعلية مثل تصفح الويب، وIRC، والبريد الإلكتروني، ومشاركة الملفات.\nإنه يضمن النقل الموثوق، والتحكم في الازدحام، وإعادة الإرسال، والتحكم في التدفق عبر tunnels المجهولة عالية الكمون الخاصة بـ I2P. يُشفَّر كل تدفق بالكامل من طرف إلى طرف بين الوجهات.\nمبادئ التصميم الأساسية تنفّذ مكتبة البثّ تهيئة اتصال أحادية المرحلة، حيث يمكن لأعلام SYN وACK وFIN حمل حمولة بيانات في الرسالة نفسها. وهذا يقلّل عدد رحلات الذهاب والإياب في البيئات عالية الكمون — إذ يمكن لعملية HTTP صغيرة أن تكتمل في رحلة ذهاب وإياب واحدة.\nيُستوحى التحكم في الازدحام وإعادة الإرسال من TCP ولكنه مُكيَّف لبيئة I2P. أحجام النوافذ مستندة إلى الرسائل، وليست مستندة إلى البايتات، وهي مُضبوطة وفق زمن تأخير الـ tunnel والعبء الإضافي. يدعم البروتوكول البدء البطيء، وتجنّب الازدحام، والتراجع الأُسّي بطريقة مشابهة لخوارزمية AIMD في TCP (الزيادة الإضافية/النقصان الضربي).\nالمعمارية تعمل مكتبة التدفق بين التطبيقات وواجهة I2CP.\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels يصل معظم المستخدمين إليه عبر I2PSocketManager أو I2PTunnel أو SAMv3. تتعامل المكتبة بشفافية مع إدارة الوجهات، واستخدام tunnel، وعمليات إعادة الإرسال. تنسيق الحزمة +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | تفاصيل الترويسة معرّفات التدفق: قيم بطول 32 بت تُعرّف بشكل فريد التدفقات المحلية والبعيدة. رقم التسلسل: يبدأ من 0 مع SYN (علم بدء الاتصال)، ويزداد مع كل رسالة. Ack Through: يُقِرّ بجميع الرسائل حتى N، باستثناء تلك الموجودة في قائمة NACK (عدم الإقرار). Flags: قناع بتّي يتحكم في الحالة والسلوك. Options: قائمة بطول متغيّر لـ RTT (زمن الرحلة ذهاباً وإياباً)، وMTU (أقصى حجم لوحدة النقل)، والتفاوض على البروتوكول. أعلام المفتاح Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive --- التحكم في التدفق والموثوقية تستخدم Streaming (طبقة تدفق الاتصالات في I2P) آلية نافذة معتمدة على الرسائل، بخلاف نهج TCP (بروتوكول التحكم بالنقل) المعتمد على البايتات. يساوي عدد الحزم غير المؤكدة المسموح بكونها قيد العبور حجم النافذة الحالي (القيمة الافتراضية 128).\nالآليات التحكم في الازدحام: البداية البطيئة وتجنّب قائم على AIMD (الزيادة الجمعيّة/النقصان الضربي). الخنق/فكّ الخنق: إشارات التحكم في التدفق استنادًا إلى إشغال المخزن المؤقت. إعادة الإرسال: حساب RTO وفق RFC 6298 مع تراجع أسّي. ترشيح التكرارات: يضمن الموثوقية رغم احتمال إعادة ترتيب الرسائل. قيم الإعداد النموذجية:\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout --- إنشاء الاتصال المُبادر يرسل SYN (اختياريًا مع حمولة و FROM_INCLUDED). المستجيب يرد بـ SYN+ACK (قد يتضمن حمولة). المُبادر يرسل ACK النهائي مؤكدًا إتمام التأسيس. تتيح الحمولات الأولية الاختيارية نقل البيانات قبل اكتمال المصافحة بالكامل.\nتفاصيل التنفيذ إعادة الإرسال والمهلة تتبع خوارزمية إعادة الإرسال RFC 6298. - RTO (مهلة إعادة الإرسال) الأولي: 9s - الحد الأدنى لـ RTO: 100ms - الحد الأقصى لـ RTO: 45s - ألفا: 0.125 - بيتا: 0.25\nمشاركة كتلة التحكم تعيد الاتصالات الأخيرة إلى القرين نفسه استخدام بيانات RTT (زمن الذهاب والإياب) وبيانات النافذة السابقة للتدرّج بشكل أسرع، ما يتفادى كمون “cold start” (بدء بارد). تنتهي صلاحية كتل التحكم بعد عدة دقائق.\nMTU (الحد الأقصى لحجم وحدة الإرسال) والتجزئة MTU الافتراضي: 1730 بايت (يتسع لرسالتين من I2NP). وجهات ECIES (نظام تشفير قائم على المنحنيات الإهليلجية): 1812 بايت (حمولة إضافية أقل). الحد الأدنى للـ MTU المدعوم: 512 بايت. حجم الحمولة لا يشمل ترويسة البث الدنيا البالغة 22 بايت.\nسجل الإصدارات Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) --- الاستخدام على مستوى التطبيق مثال بلغة جافا Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); دعم SAMv3 و i2pd SAMv3: يوفّر وضعي STREAM و DATAGRAM للعملاء غير المكتوبين بـ Java. i2pd: يوفّر معلمات بث متطابقة عبر خيارات ملف الإعدادات (مثل i2p.streaming.maxWindowSize، profile، إلخ). الاختيار بين Streaming (التدفق شبيه TCP) و Datagrams (رسائل عديمة الاتصال) Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn --- الأمن والمستقبل ما بعد الكم جلسات التدفق مشفرة من طرف إلى طرف على طبقة I2CP. التشفير الهجين لما بعد الكم (ML-KEM + X25519) مدعوم تجريبياً في 2.10.0 لكنه معطّل افتراضياً.\nالمراجع نظرة عامة على واجهة برمجة تطبيقات البث مواصفة بروتوكول البث مواصفة I2CP الاقتراح 144: حسابات MTU (أقصى وحدة نقل) للبث ملاحظات إصدار I2P 2.10.0 ","description":"آلية نقل موثوقة شبيهة بـ TCP تستخدمها معظم تطبيقات I2P","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"بروتوكول التدفق","url":"/ar/docs/specs/streaming/"},{"categories":null,"content":"نظرة عامة I2CP هو بروتوكول تحكم منخفض المستوى بين I2P router وأي عملية عميل. يحدّد فصلاً صارماً للمسؤوليات:\nRouter: يدير التوجيه، والتشفير، ودورات حياة الـ tunnel، وعمليات قاعدة بيانات الشبكة العميل: يختار خصائص إخفاء الهوية، ويُكوّن tunnels، ويرسل/يتلقى الرسائل تمرّ جميع الاتصالات عبر مقبس TCP واحد (اختياريًا مُغلّف بـ TLS)، مما يتيح عمليات غير متزامنة وبازدواج كامل.\nإصدار البروتوكول: تستخدم I2CP بايت إصدار البروتوكول 0x2A (42 بالنظام العشري) يُرسَل أثناء إقامة الاتصال الأولي. لقد ظل هذا البايت الخاص بالإصدار مستقراً منذ نشأة البروتوكول.\nالحالة الحالية: هذه المواصفة تنطبق على إصدار router 0.9.67 (إصدار API 0.9.67)، الصادر في 2025-09.\nسياق التنفيذ تنفيذ جافا التنفيذ المرجعي موجود في Java I2P: - SDK للعميل: حزمة i2p.jar - تنفيذ الـ router (برنامج التوجيه في I2P): حزمة router.jar - Javadocs عندما يعمل العميل وrouter ضمن نفس بيئة JVM (آلة جافا الافتراضية)، تُنقَل رسائل I2CP على شكل كائنات Java من دون إجراء تسلسل. يستخدم العملاء الخارجيون البروتوكول المُسَلسَل عبر TCP.\nتنفيذ C++ يطبّق i2pd (الـ I2P router المكتوب بـ C++) بروتوكول I2CP خارجيًا لاتصالات العملاء.\nالعملاء غير المكتوبين بلغة Java لا توجد تنفيذات غير مكتوبة بـ Java معروفة لمكتبة عميل I2CP كاملة. ينبغي للتطبيقات غير المكتوبة بـ Java استخدام بروتوكولات على مستوى أعلى بدلاً من ذلك:\nSAM (المراسلة المجهولة البسيطة) v3: واجهة قائمة على المقابس مع مكتبات بلغات متعددة BOB (الجسر المفتوح الأساسي): بديل أبسط لـ SAM تعالج هذه البروتوكولات عالية المستوى تعقيدات I2CP داخليًا، كما توفر أيضًا مكتبة التدفق (للاتصالات المشابهة لـ TCP) ومكتبة الداتاغرام (للاتصالات المشابهة لـ UDP).\nإقامة الاتصال 1. اتصال TCP اتصل بمنفذ I2CP الخاص بـ router: - القيمة الافتراضية: 127.0.0.1:7654 - قابلة للتهيئة عبر إعدادات router - غلاف TLS اختياري (يوصى به بشدة للاتصالات عن بُعد)\n2. مصافحة البروتوكول الخطوة 1: أرسل بايت إصدار البروتوكول 0x2A\nالخطوة 2: مزامنة الساعة\nClient → Router: GetDateMessage Router → Client: SetDateMessage يُرجِع الـ router الطابع الزمني الحالي وسلسلة إصدار واجهة برمجة تطبيقات I2CP (بروتوكول التحكّم في I2P) (منذ الإصدار 0.8.7).\nالخطوة 3: المصادقة (إذا كانت مفعّلة)\nاعتبارًا من 0.9.11، يمكن تضمين المصادقة في GetDateMessage عبر Mapping (خريطة مفاتيح/قيم) تتضمن: - i2cp.username - i2cp.password\nاعتبارًا من الإصدار 0.9.16، عندما تكون المصادقة مُفعَّلة، يجب إتمامها عبر GetDateMessage قبل إرسال أي رسائل أخرى.\nالخطوة 4: إنشاء الجلسة\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) الخطوة 5: إشارة جاهزية Tunnel\nRouter → Client: RequestVariableLeaseSetMessage تشير هذه الرسالة إلى أنه تم بناء الـ tunnels الواردة. لن يقوم الـ router بإرسالها إلا بعد توفر tunnel وارد واحد على الأقل وtunnel صادر واحد.\nالخطوة 6: نشر LeaseSet\nClient → Router: CreateLeaseSet2Message في هذه المرحلة، تكون الجلسة جاهزة للعمل بالكامل لإرسال الرسائل واستقبالها.\nأنماط تدفق الرسائل رسالة صادرة (يرسلها العميل إلى وجهة بعيدة) مع i2cp.messageReliability=none:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] مع i2cp.messageReliability=BestEffort:\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) رسالة واردة (Router يسلّمها إلى العميل) مع i2cp.fastReceive=true (الإعداد الافتراضي منذ 0.9.4):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] مع i2cp.fastReceive=false (مهمل):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage ينبغي على العملاء الحديثين دائمًا استخدام وضع الاستقبال السريع.\nهياكل البيانات الشائعة ترويسة رسالة I2CP تستخدم جميع رسائل I2CP هذه الترويسة المشتركة:\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ طول جسم الرسالة: عدد صحيح بطول 4 بايت، طول جسم الرسالة فقط (لا يشمل الترويسة) النوع: عدد صحيح بطول 1 بايت، معرّف نوع الرسالة جسم الرسالة: 0 بايت فأكثر، يختلف التنسيق بحسب نوع الرسالة حد حجم الرسالة: تقريبًا 64 كيلوبايت كحد أقصى.\nمعرّف الجلسة عدد صحيح بطول 2 بايت يعرّف جلسة بشكل فريد على router.\nقيمة خاصة: 0xFFFF تشير إلى \u0026ldquo;بدون جلسة\u0026rdquo; (تُستخدم لاستعلامات اسم المضيف من دون جلسة قائمة).\nمعرّف الرسالة عدد صحيح بطول 4 بايت يتم توليده بواسطة router لتحديد رسالة بشكل فريد ضمن جلسة.\nمهم: معرّفات الرسائل ليست فريدة عالميًا، بل فريدة ضمن الجلسة فقط. كما أنها تختلف أيضًا عن الـ nonce (عدد يُستخدم مرة واحدة) الذي يولّده العميل.\nتنسيق الحمولة يتم ضغط حمولات الرسائل باستخدام gzip مع ترويسة gzip قياسية بطول 10 بايت: - تبدأ بـ: 0x1F 0x8B 0x08 (RFC 1952) - منذ 0.7.1: تحتوي الأجزاء غير المستخدمة من ترويسة gzip على معلومات البروتوكول، ومنفذ المصدر، ومنفذ الوجهة - يتيح هذا استخدام streaming (اتصالات متدفقة) و datagrams (رسائل عديمة الاتصال) على الوجهة نفسها\nالتحكم في الضغط: اضبط i2cp.gzip=false لتعطيل الضغط (يضبط مستوى جهد gzip إلى 0). تظل ترويسة gzip مُضمّنة، ولكن مع حد أدنى من العبء الإضافي للضغط.\nبنية SessionConfig يحدد إعدادات جلسة عميل:\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ المتطلبات الحرجة: 1. يجب أن يكون التعيين مرتبًا حسب المفتاح لأغراض التحقق من التوقيع 2. تاريخ الإنشاء يجب أن يكون ضمن ±30 ثانية من الوقت الحالي للـ router 3. التوقيع يتم إنشاؤه بواسطة SigningPrivateKey (مفتاح التوقيع الخاص) الخاص بالـ Destination (الوجهة)\nالتواقيع غير المتصلة (اعتبارًا من 0.9.38):\nعند استخدام التوقيع دون اتصال، يجب أن يحتوي التعيين على:\ni2cp.leaseSetOfflineExpiration i2cp.leaseSetTransientPublicKey i2cp.leaseSetOfflineSignature بعد ذلك يتم إنشاء Signature بواسطة SigningPrivateKey المؤقت.\nخيارات تكوين النواة إعدادات Tunnel Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) **ملاحظات**: - القيم لـ `quantity` \u003e 6 تتطلب أقرانًا يشغّلون الإصدار 0.9.0+ وتزيد بشكل ملحوظ من استهلاك الموارد - اضبط `backupQuantity` على 1-2 للخدمات عالية التوفّر - Zero-hop tunnels تُضحّي بإخفاء الهوية لتقليل الكمون لكنها مفيدة للاختبار معالجة الرسائل Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) **موثوقية الرسائل**: - `None`: لا توجد إقرارات من router (الموجّه في I2P) (الافتراضي في مكتبة البث منذ 0.8.1) - `BestEffort`: يرسل router إشعار قبول + إشعارات نجاح/فشل - `Guaranteed`: غير مُنفّذ (حاليًا يتصرّف مثل BestEffort) تجاوز لكل رسالة (منذ 0.9.14): - في جلسة تكون فيها messageReliability=none، فإن تعيين قيمة nonce غير صفرية يطلب إشعار تسليم لتلك الرسالة المحددة - تعيين nonce=0 في جلسة BestEffort يعطّل الإشعارات لتلك الرسالة\nتكوين LeaseSet (بنية بيانات تحدد كيفية الوصول إلى وجهة داخل I2P) Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) ### وسوم الجلسة القديمة لـ ElGamal/AES تنطبق هذه الخيارات فقط على تشفير ElGamal القديم (خوارزمية تشفير بالمفتاح العام):\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch **ملاحظة**: يستخدمون عملاء ECIES-X25519 آلية ratchet (آلية تحديث مفاتيح تدريجية) مختلفة ويتجاهلون هذه الخيارات. أنواع التشفير يدعم I2CP عدة مخططات لتشفير من طرف إلى طرف عبر الخيار i2cp.leaseSetEncType. يمكن تحديد أنواع متعددة (مفصولة بفواصل) لدعم كل من النظراء الحديثين والقدامى.\nأنواع التشفير المدعومة Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned **التكوين الموصى به**: i2cp.leaseSetEncType=4,0 يوفّر هذا دعمًا لـ X25519 (المفضّل) مع ElGamal كخيار بديل لأغراض التوافق.\nتفاصيل نوع التشفير النوع 0 - ElGamal/AES+وسوم الجلسة: - مفاتيح ElGamal العامة بطول 2048-بت (256 بايت) - تشفير متماثل AES-256 - وسوم الجلسة بطول 32 بايت تُرسل على دفعات - عبء عالٍ على المعالج والنطاق الترددي والذاكرة - يتم التخلص منه تدريجياً على مستوى الشبكة\nالنوع 4 - ECIES-X25519-AEAD-Ratchet: - تبادل مفاتيح X25519 (مفاتيح بحجم 32 بايت) - ChaCha20/Poly1305 AEAD - Double Ratchet بأسلوب Signal (المسنّن المزدوج) - وسوم جلسة بحجم 8 بايت (مقارنةً بـ 32 بايت في ElGamal) - تُولَّد الوسوم عبر PRNG متزامن (مولّد أعداد عشوائية زائف) (لا تُرسَل مسبقاً) - خفض الحمل الإضافي بنحو ~92% مقارنةً بـ ElGamal - المعيار في I2P الحديثة (تستخدمه معظم routers)\nالنوعان 5-6 - هجين ما بعد الكم: - يجمع بين X25519 و ML-KEM (NIST FIPS 203) - يوفر أمانًا مقاومًا للكم - ML-KEM-768 لتحقيق توازن بين الأمان والأداء - ML-KEM-1024 لأقصى درجات الأمان - أحجام رسائل أكبر بسبب بيانات مفاتيح PQ (ما بعد الكم) - لا يزال دعم الشبكة قيد النشر\nاستراتيجية الترحيل شبكة I2P تنتقل بنشاط من ElGamal (النوع 0) إلى X25519 (النوع 4): - NTCP → NTCP2 (مكتمل) - SSU → SSU2 (مكتمل) - ElGamal tunnels → X25519 tunnels (مكتمل) - ElGamal من طرف إلى طرف → ECIES-X25519 (مكتمل في معظمه)\nLeaseSet2 (الجيل الثاني من تنسيق leaseSet في I2P) والميزات المتقدمة خيارات LeaseSet2 (منذ 0.9.38) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) ### العناوين المعماة اعتبارًا من 0.9.39، يمكن للوجهات استخدام عناوين \u0026ldquo;blinded\u0026rdquo; (مطموسة الهوية) (b33 format) التي تتغير دوريًا: - يتطلب i2cp.leaseSetSecret للحماية بكلمة مرور - مصادقة لكل عميل اختيارية - راجع المقترحين 123 و149 للتفاصيل\nسجلات الخدمة (منذ 0.9.66) يدعم LeaseSet2 خيارات سجل الخدمة (المقترح 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p يتبع التنسيق أسلوب سجل SRV في DNS، ولكن مع تكييفه لـ I2P.\nجلسات متعددة (منذ 0.9.21) يمكن لاتصال I2CP واحد إدارة جلسات متعددة:\nالجلسة الأساسية: أول جلسة يتم إنشاؤها ضمن اتصال الجلسات الفرعية: جلسات إضافية تشترك في مجموعة الـ tunnel الخاصة بالجلسة الأساسية\nخصائص الجلسة الفرعية Tunnels مشتركة: استخدم مجمّعات tunnel الواردة/الصادرة نفسها كما في الجلسة الأساسية مفاتيح تشفير مشتركة: يجب استخدام مفاتيح تشفير LeaseSet متطابقة مفاتيح توقيع مختلفة: يجب استخدام مفاتيح توقيع Destination (الوجهة في I2P) مختلفة لا ضمان لإخفاء الهوية: مرتبطة بوضوح بالجلسة الأساسية (نفس router، نفس tunnels) حالة استخدام Subsession (جلسة فرعية) تمكين التواصل مع الوجهات باستخدام أنواع توقيع مختلفة: - الأساسي: توقيع EdDSA (حديث) - Subsession (جلسة فرعية): توقيع DSA (التوافق مع الإصدارات القديمة)\nدورة حياة الجلسة الفرعية الإنشاء:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) التدمير: - تدمير جلسة فرعية: يبقي الجلسة الأساسية سليمة - تدمير الجلسة الأساسية: يدمر جميع الجلسات الفرعية ويغلق الاتصال - DisconnectMessage: يدمر جميع الجلسات\nالتعامل مع معرّف الجلسة تحتوي معظم رسائل I2CP على حقل معرّف الجلسة. الاستثناءات: - DestLookup / DestReply (مهملة، استخدم HostLookup / HostReply) - GetBandwidthLimits / BandwidthLimits (الاستجابة ليست خاصة بجلسة معينة)\nمهم: ينبغي ألا يكون لدى العملاء عدة رسائل CreateSession (رسالة إنشاء جلسة) معلّقة في آن واحد، إذ لا يمكن ربط الاستجابات بالطلبات بشكل لا لبس فيه.\nفهرس الرسائل ملخص أنواع الرسائل Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current **المفتاح**: C = عميل، R = Router تفاصيل الرسالة الرئيسية CreateSessionMessage (رسالة إنشاء جلسة) (النوع 1) الغرض: بدء جلسة I2CP جديدة\nالمحتوى: بنية SessionConfig\nالاستجابة: SessionStatusMessage (status=Created أو Invalid)\nالمتطلبات: - يجب أن يكون التاريخ في SessionConfig ضمن ±30 ثانية من وقت router - يجب أن يكون التعيين مرتبًا حسب المفتاح للـتحقق من صحة التوقيع - يجب ألا تكون لدى الوجهة جلسة نشطة مسبقًا\nRequestVariableLeaseSetMessage (النوع 37) الغرض: يطلب Router إذن العميل من أجل tunnels الواردة\nالمحتوى: - معرّف الجلسة - عدد إدخالات Lease (مصطلح في I2P يشير إلى إدخال مرتبط بـ tunnel وفترة صلاحيته) - مصفوفة من هياكل Lease (لكلٍ منها انتهاء صلاحية مستقل)\nالاستجابة: CreateLeaseSet2Message\nالأهمية: هذه هي الإشارة على أن الجلسة قيد التشغيل. لا يرسل router هذا إلا بعد: 1. تم إنشاء inbound tunnel واحد على الأقل 2. تم إنشاء outbound tunnel واحد على الأقل\nتوصية بشأن المهلة: ينبغي للعملاء إنهاء الجلسة إذا لم يتم استلام هذه الرسالة بعد مرور 5 دقائق أو أكثر على إنشاء الجلسة.\nCreateLeaseSet2Message (النوع 41) الغرض: العميل ينشر LeaseSet إلى قاعدة بيانات الشبكة\nالمحتوى: - معرّف الجلسة - بايت نوع الـ LeaseSet (1، 3، 5، أو 7) - LeaseSet أو LeaseSet2 أو EncryptedLeaseSet أو MetaLeaseSet - عدد المفاتيح الخاصة - قائمة المفاتيح الخاصة (واحد لكل مفتاح عام في LeaseSet، بنفس الترتيب)\nالمفاتيح الخاصة: مطلوبة لفك تشفير رسائل garlic (تقنية تغليف في I2P) الواردة. التنسيق:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) ملاحظة: يحل محل CreateLeaseSetMessage (رسالة إنشاء LeaseSet) (النوع 4) المهملة، والتي لا يمكنها التعامل مع: - متغيرات LeaseSet2 - التشفير غير القائم على ElGamal - أنواع تشفير متعددة - LeaseSets مشفرة - مفاتيح توقيع غير متصلة\nSendMessageExpiresMessage (النوع 36) الغرض: إرسال رسالة إلى الوجهة مع وقت انتهاء الصلاحية وخيارات متقدمة\nالمحتوى: - معرّف الجلسة - الوجهة - الحمولة (gzipped، مضغوط باستخدام gzip) - Nonce (عدد يُستعمل مرة واحدة، 4 بايت) - الأعلام (2 بايت) - انظر أدناه - تاريخ الانتهاء (6 بايت، مقتطع من 8)\nحقل الأعلام (2 بايت، ترتيب البتات 15\u0026hellip;0):\nالبتات 15-11: غير مستخدمة، يجب أن تكون 0\nالبتّات 10-9: تجاوز اعتمادية الرسالة (غير مستخدم، استخدم nonce (عدد يُستخدم مرة واحدة) بدلاً من ذلك)\nالبت 8: لا تقم بتضمين LeaseSet - 0: قد يقوم Router بتضمين LeaseSet ضمن garlic (رسالة garlic في I2P) - 1: لا تقم بتضمين LeaseSet\nالبتات 7-4: عتبة الوسوم الدنيا (ElGamal فقط، يتم تجاهلها في ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags البتات 3-0: وسوم تُرسل عند الحاجة (لـ ElGamal (نظام تشفير بالمفتاح العام) فقط، ويتم تجاهلها مع ECIES (مخطط تشفير متكامل بالمنحنيات البيضوية))\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage (رسالة حالة الرسالة، النوع 22) الغرض: إخطار العميل بحالة تسليم الرسالة\nالمحتوى: - معرّف الجلسة - معرّف الرسالة (مولَّد بواسطة router) - رمز الحالة (1 بايت) - الحجم (4 بايت، ذو صلة فقط عندما يكون status=0) - Nonce (رقم يُستخدم مرة واحدة؛ 4 بايت، يطابق nonce الخاص بعملية SendMessage لدى العميل)\nرموز الحالة (الرسائل الصادرة):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure **رموز النجاح**: 1, 2, 4, 6 **رموز الفشل**: جميع الرموز الأخرى رمز الحالة 0 (مهمل): رسالة متاحة (واردة، الاستقبال السريع معطل)\nHostLookupMessage (النوع 38) الغرض: الاستعلام عن الوجهة باستخدام اسم المضيف أو التجزئة (يحل محل DestLookup)\nالمحتوى: - معرّف الجلسة (أو 0xFFFF لعدم وجود جلسة) - معرّف الطلب (4 بايت) - المهلة بالميلي ثانية (4 بايت، الحد الأدنى الموصى به: 10000) - نوع الطلب (1 بايت) - مفتاح الاستعلام (Hash، اسم مضيف من النوع String، أو Destination (الوجهة))\nأنواع الطلبات:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 تعيد الأنواع 2-4 خيارات LeaseSet (المقترح 167) إن توفرت. الاستجابة: HostReplyMessage\nHostReplyMessage (رسالة رد المضيف) (النوع 39) الغرض: استجابة لـ HostLookupMessage (رسالة البحث عن المضيف)\nالمحتوى: - معرّف الجلسة - معرّف الطلب - رمز النتيجة (1 بايت) - الوجهة (موجودة عند النجاح، وأحياناً عند بعض حالات الفشل المحددة) - التعيين (فقط لأنواع البحث 2-4، وقد يكون فارغاً)\nرموز النتائج:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type #### BlindingInfoMessage (رسالة معلومات الإعماء) (النوع 42) الغرض: إعلام router بمتطلبات المصادقة الخاصة بـ blinded destination (وجهة مُعمّاة) (اعتبارًا من 0.9.43)\nالمحتوى: - معرّف الجلسة - الأعلام (1 بايت) - نوع نقطة النهاية (1 بايت): 0=تجزئة, 1=اسم المضيف, 2=الوجهة, 3=SigType+Key - نوع التوقيع الأعمى (2 بايت) - انتهاء الصلاحية (4 بايت, ثوانٍ منذ Epoch (بداية زمن يونكس)) - بيانات نقطة النهاية (تختلف حسب النوع) - المفتاح الخاص (32 بايت, فقط إذا كان بت العلم 0 مُعيّنًا) - كلمة مرور الاستعلام (سلسلة نصية, فقط إذا كان بت العلم 4 مُعيّنًا)\nالأعلام (ترتيب البتات 76543210):\nالبت 0: 0=الجميع، 1=لكل عميل البتات 3-1: آلية المصادقة (إذا كانت البت 0=1): 000=DH (ديفي-هيلمان)، 001=PSK (مفتاح مشترك مسبقًا) البت 4: 1=يتطلب سرًا البتات 7-5: غير مستخدمة، تُضبط إلى 0 لا استجابة: يعالج Router بصمت\nحالة استخدام: قبل الإرسال إلى وجهة مُعمّاة (عنوان b33)، يجب على العميل إما أن: 1. إجراء استعلام عن b33 عبر HostLookup (استعلام المضيف)، أو 2. إرسال رسالة BlindingInfo (معلومات التعمية)\nإذا كانت الوجهة تتطلب المصادقة، فإن BlindingInfo (معلومات التعمية العمياء) مطلوبة.\nReconfigureSessionMessage (رسالة إعادة تهيئة الجلسة) (النوع 2) الغرض: تحديث تكوين الجلسة بعد إنشائها\nالمحتوى: - معرّف الجلسة - SessionConfig (فقط الخيارات التي تم تغييرها مطلوبة)\nالاستجابة: SessionStatusMessage (رسالة حالة الجلسة) (status=Updated أو Invalid)\nملاحظات: - Router يدمج الإعدادات الجديدة مع الإعدادات الحالية - خيارات Tunnel (inbound.*, outbound.*) تُطبَّق دائمًا - قد تكون بعض الخيارات غير قابلة للتغيير بعد إنشاء الجلسة - يجب أن يكون التاريخ ضمن ±30 ثانية من وقت Router - يجب ترتيب التعيين حسب المفتاح\nDestroySessionMessage (رسالة تدمير الجلسة) (النوع 3) الغرض: إنهاء جلسة\nالمحتوى: معرّف الجلسة\nالاستجابة المتوقعة: SessionStatusMessage (status=Destroyed)\nالسلوك الفعلي (Java I2P حتى الإصدار 0.9.66): - Router لا يرسل مطلقًا SessionStatus(Destroyed) - إذا لم تبقَ أي جلسات: يرسل DisconnectMessage - إذا بقيت جلسات فرعية: لا رد\nمهم: يحيد سلوك Java I2P عن المواصفة. ينبغي على عمليات التنفيذ توخي الحذر عند تدمير الجلسات الفرعية الفردية.\nDisconnectMessage (رسالة قطع الاتصال) (النوع 30) الغرض: إشعار بأن الاتصال على وشك أن يتم إنهاؤه\nالمحتوى: سلسلة السبب\nالتأثير: تُدمَّر جميع الجلسات ضمن الاتصال، ويُغلَق المقبس\nالتنفيذ: بشكل أساسي router → العميل في Java I2P\nسجل إصدارات البروتوكول اكتشاف الإصدار يتم تبادل إصدار بروتوكول I2CP ضمن رسائل Get/SetDate (منذ 0.8.7). بالنسبة إلى routers الأقدم، لا تتوفر معلومات الإصدار.\nسلسلة الإصدار: تشير إلى إصدار واجهة برمجة التطبيقات (API) \u0026ldquo;core\u0026rdquo;، وليس بالضرورة إصدار router.\nالجدول الزمني للميزات Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features ## اعتبارات الأمان المصادقة الافتراضي: لا يلزم إجراء مصادقة اختياري: مصادقة باسم مستخدم/كلمة مرور (منذ 0.9.11) مطلوب: عند التمكين، يجب إتمام المصادقة قبل الرسائل الأخرى (منذ 0.9.16)\nالاتصالات عن بُعد: استخدم دائمًا TLS (i2cp.SSL=true) لحماية بيانات الاعتماد والمفاتيح الخاصة.\nانحراف الساعة يجب أن يكون SessionConfig Date ضمن ±30 ثانية من وقت الـrouter، وإلا فسيتم رفض الجلسة. استخدم Get/SetDate للمزامنة.\nالتعامل مع المفتاح الخاص CreateLeaseSet2Message (رسالة إنشاء LeaseSet2) تحتوي على مفاتيح خاصة لفك تشفير الرسائل الواردة. يجب أن تكون هذه المفاتيح: - تُنقَل بأمان (TLS للاتصالات عن بُعد) - تُخزَّن بأمان بواسطة router - تُستبدل عند تعرّضها للاختراق\nانتهاء صلاحية الرسالة استخدم دائمًا SendMessageExpires (وليس SendMessage) لتعيين وقت انتهاء صريح. هذا:\nيمنع وضع الرسائل في قائمة الانتظار إلى أجل غير مسمى يقلّل استهلاك الموارد يحسّن الموثوقية إدارة وسوم الجلسة ElGamal (خوارزمية تشفير بالمفتاح العام) (مُهمَل): - يجب إرسال الوسوم على دفعات - فقدان الوسوم يؤدي إلى فشل فك التشفير - استهلاك مرتفع للذاكرة\nECIES-X25519 (الحالي): - تُولَّد الوسوم عبر PRNG متزامن (مولّد أعداد شبه عشوائية) - لا حاجة إلى إرسال مسبق - مقاوم لفقدان الرسائل - حمل إضافي أقل بكثير\nأفضل الممارسات لمطوري العملاء استخدم وضع الاستلام السريع: اضبط دائماً i2cp.fastReceive=true (أو اعتمد على القيمة الافتراضية)\nيفضل استخدام ECIES-X25519 (مخطط ECIES للتشفير بالمنحنيات الإهليلجية مع X25519): قم بتهيئة i2cp.leaseSetEncType=4,0 لأفضل أداء مع الحفاظ على التوافق\nحدّد انتهاء الصلاحية صراحةً: استخدم SendMessageExpires، وليس SendMessage\nتعامل مع subsessions (جلسات فرعية) بعناية: كن على دراية بأن subsessions لا توفر أي إخفاء للهوية بين destinations (وجهات)\nمهلة إنشاء الجلسة: أنهِ الجلسة إذا لم يتم استلام RequestVariableLeaseSet (اسم رسالة تطلب leaseSet متغيراً) خلال 5 دقائق\nفرز تعيينات التكوين: احرص دائمًا على فرز مفاتيح Mapping قبل توقيع SessionConfig\nاستخدم أعداد Tunnel المناسبة: لا تضبط quantity \u0026gt; 6 إلا عند الضرورة\nضع في الاعتبار SAM/BOB لغير Java: نفّذ SAM بدلًا من I2CP مباشرةً\nلمطوري Router التحقق من التواريخ: فرض نافذة زمنية قدرها ±30 ثانية على تواريخ SessionConfig\nتقييد حجم الرسالة: فرض حد أقصى لحجم الرسالة قدره ~64 KB\nدعم الجلسات المتعددة: تنفيذ دعم الجلسات الفرعية حسب مواصفة 0.9.21\nأرسل RequestVariableLeaseSet فورًا: فقط بعد وجود كل من الـ inbound و الـ outbound tunnels\nالتعامل مع الرسائل المهملة: قبولها ولكن عدم التشجيع على استخدام ReceiveMessageBegin/End\nدعم ECIES-X25519 (مخطط تشفير بالمفتاح العام يعتمد X25519 وفق ECIES): أعطِ الأولوية لتشفير النوع 4 في عمليات النشر الجديدة\nتنقيح واستكشاف الأخطاء وإصلاحها المشكلات الشائعة تم رفض الجلسة (غير صالحة): - تحقّق من انحراف الساعة (يجب أن يكون ضمن ±30 ثانية) - تحقّق من أن Mapping (خريطة الخيارات) مرتّبة حسب المفتاح - تأكّد من أن Destination (هوية الوجهة في I2P) غير مستخدمة مسبقًا\nلا يوجد RequestVariableLeaseSet (مصطلح في I2P): - قد يكون Router يبني tunnels (انتظر حتى 5 دقائق) - تحقق من مشكلات اتصال الشبكة - تحقق من وجود عدد كافٍ من اتصالات الأقران\nإخفاقات تسليم الرسائل: - تحقّق من رموز MessageStatus لمعرفة سبب الفشل المحدّد - تأكّد من أن LeaseSet البعيد منشور ومحدّث - تأكّد من توافق أنواع التشفير\nمشكلات الجلسات الفرعية: - تحقّق من إنشاء الجلسة الأساسية أولاً - أكّد استخدام مفاتيح التشفير نفسها - تحقّق من اختلاف مفاتيح التوقيع\nرسائل التشخيص GetBandwidthLimits: استعلم عن سعة router HostLookup: اختبر حلّ الأسماء وتوفّر LeaseSet (مجموعة بيانات المسارات في I2P) MessageStatus: تتبّع تسليم الرسائل من طرف إلى طرف\nالمواصفات ذات الصلة الهياكل الشائعة: /docs/specs/common-structures/ I2NP (بروتوكول الشبكة): /docs/specs/i2np/ ECIES-X25519 (مخطط تشفير بيضوي ECIES باستخدام منحنى X25519): /docs/specs/ecies/ إنشاء tunnel: /docs/specs/implementation/ مكتبة التدفق: /docs/specs/streaming/ مكتبة الداتاغرام: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ المقترحات المشار إليها المقترح 123 : LeaseSets مشفّرة والمصادقة المقترح 144 : ECIES-X25519-AEAD-Ratchet المقترح 149 : صيغة العنوان المحجّب (b33) المقترح 152 : إنشاء tunnel باستخدام X25519 المقترح 154 : استعلامات قاعدة البيانات من وجهات ECIES المقترح 156 : ترحيل Router إلى ECIES-X25519 المقترح 161 : ضغط حشو الوجهة المقترح 167 : سجلات خدمة LeaseSet المقترح 169 : التشفير الهجين ما بعد الكمّي (ML-KEM) مرجع Javadocs (توثيق Java المُولّد تلقائيًا) حزمة I2CP MessageStatusMessage واجهة برمجة تطبيقات العميل ملخص العناصر المُهملة رسائل مهملة (لا تستخدم) CreateLeaseSetMessage (النوع 4): استخدم CreateLeaseSet2Message RequestLeaseSetMessage (النوع 21): استخدم RequestVariableLeaseSetMessage ReceiveMessageBeginMessage (النوع 6): استخدم وضع الاستلام السريع ReceiveMessageEndMessage (النوع 7): استخدم وضع الاستلام السريع DestLookupMessage (النوع 34): استخدم HostLookupMessage DestReplyMessage (النوع 35): استخدم HostReplyMessage ReportAbuseMessage (النوع 29): لم تُنفّذ مطلقًا خيارات مهملة تشفير ElGamal (النوع 0): الترحيل إلى ECIES-X25519 (النوع 4) تواقيع DSA: الترحيل إلى EdDSA أو ECDSA i2cp.fastReceive=false: استخدم دائمًا وضع الاستلام السريع ","description":"كيف تتفاوض التطبيقات بشأن الجلسات وtunnels وLeaseSets مع I2P router.","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"بروتوكول العميل لـ I2P (I2CP)","url":"/ar/docs/specs/i2cp/"},{"categories":null,"content":"نظرة عامة يستبدل NTCP2 بروتوكول النقل NTCP القديم بمصافحة مبنية على Noise تقاوم بصمة حركة المرور، وتشفّر حقول الطول، وتدعم مجموعات التشفير الحديثة. قد تُشغِّل Routers بروتوكول NTCP2 جنبًا إلى جنب مع SSU2 باعتبارهما بروتوكولي النقل الإلزاميين في شبكة I2P. أُعلن إهمال NTCP (الإصدار 1) في الإصدار 0.9.40 (مايو 2019) وأُزيل بالكامل في 0.9.50 (مايو 2021).\nإطار عمل بروتوكول Noise يستخدم NTCP2 Noise Protocol Framework (إطار عمل بروتوكول Noise) المراجعة 33، 2017-10-04 مع امتدادات خاصة بـ I2P:\nالنمط: Noise_XK_25519_ChaChaPoly_SHA256 المعرّف الموسَّع: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256 (لتهيئة KDF (دالة اشتقاق المفاتيح)) دالة DH (ديفي-هيلمان): X25519 (RFC 7748) - مفاتيح بطول 32 بايت، ترميز little-endian (أصغر البايت أولاً) خوارزمية التشفير: AEAD_CHACHA20_POLY1305 (RFC 7539/RFC 8439) nonce (قيمة غير متكررة) بطول 12 بايت: أول 4 بايت صفر، وآخر 8 بايت عداد (little-endian) الحد الأقصى لقيمة nonce: 2^64 - 2 (يجب إنهاء الاتصال قبل الوصول إلى 2^64 - 1) دالة التجزئة: SHA-256 (مخرج بطول 32 بايت) MAC (كود توثيق الرسالة): Poly1305 (وسم مصادقة بطول 16 بايت) امتدادات خاصة بـ I2P تمويه AES: مفاتيح مؤقتة مُشفَّرة بـ AES-256-CBC باستخدام تجزئة router الخاصة ببوب وIV (متجه التهيئة) المنشور حشو عشوائي: حشو نص صريح في الرسالتين 1-2 (مُوثَّق)، وحشو AEAD (مصادقة وتشفير مع بيانات إضافية) في الرسالة 3 فما بعدها (مُشفَّر) تمويه الطول بـ SipHash-2-4: أطوال الأطر المكوّنة من بايتين تُجرى لها عملية XOR (أو الحصري) مع خرج SipHash بنية الإطار: أطر مسبوقة بالطول لمرحلة البيانات (توافق التدفق عبر TCP) حمولات قائمة على الكتل: تنسيق بيانات مُنظَّم بكتل ذات أنواع محددة تسلسل المصافحة Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► مصافحة بثلاث رسائل SessionRequest - المفتاح المؤقت المموَّه لـ Alice، خيارات، تلميحات الحشو SessionCreated - المفتاح المؤقت المموَّه لـ Bob، خيارات مُشفَّرة، حشو SessionConfirmed - المفتاح الثابت المُشفَّر لـ Alice و RouterInfo (إطاران من نوع AEAD) أنماط رسائل Noise (إطار عمل لبروتوكولات المصافحة والتشفير) XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 مستويات المصادقة: - 0: بلا مصادقة (يمكن لأي طرف أن يكون قد أرسل) - 2: مصادقة المرسِل مقاومة لانتحال الهوية عند اختراق المفتاح (KCI)\nمستويات السرية: - 1: مستلم مؤقت (سرية أمامية، دون مصادقة للمستلم) - 2: مستلم معروف، سرية أمامية في حال اختراق المُرسِل فقط - 5: سرية أمامية قوية (مؤقت-مؤقت + مؤقت-ثابت DH (ديفي-هيلمان))\nمواصفات الرسائل اصطلاحات المفاتيح RH_A = تجزئة Router الخاصة بـ Alice (32 بايت، SHA-256) RH_B = تجزئة Router الخاصة بـ Bob (32 بايت، SHA-256) || = عامل الضم byte(n) = بايت واحد بقيمة n جميع الأعداد الصحيحة متعددة البايت تكون big-endian (ترتيب البايتات من الأكثر أهمية أولاً) ما لم يُنص على خلاف ذلك مفاتيح X25519 تكون little-endian (ترتيب البايتات من الأقل أهمية أولاً) (32 بايت) التشفير المُصادَق (ChaCha20-Poly1305) دالة التشفير:\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) المعلمات: - key: مفتاح تشفير بطول 32 بايت من KDF (دالة اشتقاق المفاتيح) - nonce: 12 بايت (4 بايتات صفرية + عدّاد بطول 8 بايت، little-endian (ترتيب البايت الأدنى أولاً)) - associatedData: تجزئة بطول 32 بايت في مرحلة المصافحة؛ بطول صفر في مرحلة البيانات - plaintext: البيانات المراد تشفيرها (0+ بايت)\nالمخرجات: - النص المُشفّر: نفس طول النص الواضح - MAC (رمز مصادقة الرسالة): 16 بايت (وسم مصادقة Poly1305)\nإدارة Nonce (عدد يُستخدم مرة واحدة): - يبدأ العداد من 0 لكل مثيل للتشفير - يزداد مع كل عملية AEAD (مصادقة وتشفير ببيانات إضافية) في ذلك الاتجاه - عدادات منفصلة لـ Alice→Bob و Bob→Alice في مرحلة البيانات - يجب إنهاء الاتصال قبل أن يصل العداد إلى 2^64 - 1\nالرسالة 1: SessionRequest (طلب جلسة) تبدأ أليس الاتصال ببوب.\nعمليات Noise (إطار لبروتوكولات المصافحة التشفيرية): e, es (توليد المفاتيح المؤقتة وتبادلها)\nالتنسيق الخام +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ قيود الحجم: - الحد الأدنى: 80 بايت (32 AES + 48 AEAD) - الحد الأقصى: 65535 بايت إجماليًا - حالة خاصة: حد أقصى 287 بايت عند الاتصال بعناوين \u0026ldquo;NTCP\u0026rdquo; (اكتشاف الإصدار)\nالمحتوى بعد فك التشفير +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ كتلة الخيارات (16 بايت، big-endian (البايت الأعلى أولاً)) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 الحقول الحرجة: - Network ID (منذ 0.9.42): الرفض السريع للاتصالات بين الشبكات - m3p2len: الحجم الدقيق للرسالة 3 الجزء 2 (يجب أن يتطابق عند الإرسال)\nدالة اشتقاق المفاتيح (KDF-1) تهيئة البروتوكول:\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash عمليات MixHash:\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD عملية MixKey (مزج المفتاح) (نمط es):\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF ملاحظات التنفيذ تمويه AES: يُستخدم لمقاومة فحص الحزم العميق (DPI) فقط؛ أي شخص يملك تجزئة router الخاصة ببوب وIV (متجه التهيئة) يمكنه فك تشفير X منع إعادة التشغيل: يجب على بوب تخزين قيم X مؤقتاً (أو نظائرها المشفّرة) لمدة لا تقل عن 2*D ثانية (D = أقصى انحراف للساعة) التحقق من الطابع الزمني: يجب على بوب رفض الاتصالات التي يكون فيها |tsA - current_time| \u0026gt; D (عادةً D = 60 ثانية) التحقق من المنحنى: يجب على بوب التحقق من أن X نقطة صالحة على X25519 الرفض السريع: يجوز لبوب التحقق من X[31] \u0026amp; 0x80 == 0 قبل فك التشفير (مفاتيح X25519 الصالحة تكون البت الأكثر أهمية (MSB) فيها غير مُعيَّن) التعامل مع الأخطاء: عند أي فشل، يُغلق بوب الاتصال بإرسال TCP RST بعد مهلة عشوائية وقراءة بايت عشوائي التخزين المؤقت: يجب على أليس تفريغ الرسالة بالكامل (بما في ذلك الحشو) دفعة واحدة لتحقيق الكفاءة الرسالة 2: SessionCreated (تم إنشاء الجلسة) بوب يرد على أليس.\nعمليات Noise (إطار بروتوكول للتشفير): e, ee (ديفي-هيلمان مؤقت-مؤقت)\nالتنسيق الخام +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ المحتوى مفكوك التشفير +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ كتلة الخيارات (16 بايت، big-endian (ترتيب البايت الأعلى أهمية أولاً)) +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) دالة اشتقاق المفتاح (KDF-2) عمليات MixHash:\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD عملية MixKey (مزج المفتاح) (نمط ee):\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF تنظيف الذاكرة:\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side ملاحظات التنفيذ تسلسل AES: يستخدم تشفير Y حالة AES-CBC من الرسالة 1 (دون إعادة ضبط) منع إعادة التشغيل: يجب على Alice تخزين قيم Y مؤقتًا لمدة لا تقل عن 2*D ثانية التحقق من الطابع الزمني: يجب على Alice رفض الحالات التي يتحقق فيها |tsB - current_time| \u0026gt; D التحقق من المنحنى: يجب على Alice التحقق من أن Y نقطة X25519 (منحنى إهليلجي قياسي لتبادل المفاتيح) صالحة معالجة الأخطاء: تقوم Alice بالإغلاق عبر TCP RST (إشارة إعادة ضبط في TCP) عند أي فشل التخزين المؤقت: يجب على Bob إرسال الرسالة كاملة دفعة واحدة الرسالة 3: SessionConfirmed (تأكيد الجلسة) تؤكد أليس الجلسة وترسل RouterInfo (معلومات الـ router).\nعمليات Noise: s, se (إفشاء المفتاح الثابت وDH ثابت-مؤقت)\nبنية من جزأين تتكون الرسالة 3 من إطارَي AEAD (تشفير موثَّق مع بيانات مرتبطة) منفصلين:\nالجزء 1: إطار ثابت بطول 48 بايت مع مفتاح أليس الثابت المُشفّر الجزء 2: إطار بطول متغير يحتوي على RouterInfo (بيانات تعريف router في I2P)، وخيارات، وحشو التنسيق الخام +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ قيود الحجم: - الجزء 1: بالضبط 48 بايت (32 نص صريح + 16 MAC (رمز تحقق الرسالة)) - الجزء 2: الطول محدد في الرسالة 1 (حقل m3p2len) - الحد الأقصى الإجمالي: 65535 بايت (الجزء 1 أقصاه 48، لذا الجزء 2 أقصاه 65487)\nالمحتوى المفكوك التشفير الجزء الأول:\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ الجزء 2:\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ دالة اشتقاق المفاتيح (KDF-3) الجزء 1 (نمط s):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 الجزء 2 (se pattern):\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF تنظيف الذاكرة:\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side ملاحظات التنفيذ التحقق من RouterInfo (معلومات الـrouter): على Bob التحقق من صحة التوقيع والطابع الزمني واتساق المفتاح مطابقة المفتاح: على Bob التحقق من أن المفتاح الثابت لـ Alice في الجزء 1 يطابق المفتاح في RouterInfo موقع المفتاح الثابت: ابحث عن معلمة \u0026ldquo;s\u0026rdquo; المطابقة في NTCP أو NTCP2 RouterAddress (عنوان الـrouter) ترتيب الكُتل: يجب أن يكون RouterInfo أولاً، وOptions ثانياً (إن وُجدت)، وPadding أخيراً (إن وُجد) تخطيط الطول: يجب على Alice التأكد من أن m3p2len في الرسالة 1 يطابق تماماً طول الجزء 2 التخزين المؤقت: يجب على Alice تفريغ الجزأين معاً كإرسال TCP واحد التسلسل الاختياري: يجوز لـ Alice إلحاق data phase frame (إطار طور البيانات) فوراً لتحسين الكفاءة مرحلة البيانات بعد اكتمال المصافحة، تستخدم جميع الرسائل إطارات AEAD (تعمية مصادقة مع بيانات مرتبطة) بطول متغيّر مع حقول طول مموّهة.\nدالة اشتقاق المفاتيح (مرحلة البيانات) دالة التقسيم (Noise):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) اشتقاق مفتاح SipHash (دالة تجزئة مُفتاحية):\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV بنية الإطار +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ قيود الإطار: - الحد الأدنى: 18 بايت (2 طول مموّه + 0 نص صريح + 16 MAC (رمز المصادقة على الرسائل)) - الحد الأقصى: 65537 بايت (2 طول مموّه + 65535 إطار) - مُوصى به: بضعة كيلوبايت لكل إطار (لتقليل الكمون لدى المتلقي)\nتمويه الطول باستخدام SipHash (خوارزمية تجزئة مصادِقة خفيفة) الغرض: منع تعرّف التفتيش العميق للحزم (DPI) على حدود الإطارات\nالخوارزمية:\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes فك الترميز:\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) ملاحظات: - سلاسل IV (مُتّجه التهيئة) منفصلة لكل اتجاه (Alice→Bob و Bob→Alice) - إذا أعاد SipHash (خوارزمية تجزئة) قيمة uint64، فاستخدم أقل بايتين أهمية كقناع - حوّل uint64 إلى IV التالي كبايتات بالترتيب الصغير (little-endian)\nتنسيق الكتلة يحتوي كل إطار على صفر أو أكثر من الكتل:\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload حدود الحجم: - أقصى حجم للإطار: 65535 بايت (بما في ذلك MAC) - أقصى مساحة للكتلة: 65519 بايت (الإطار - MAC بحجم 16 بايت) - أقصى حجم لكتلة واحدة: 65519 بايت (ترويسة بحجم 3 بايت + بيانات بحجم 65516)\nأنواع الكتل Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions **قواعد ترتيب الكتل:** - **الرسالة 3 الجزء 2**: RouterInfo، Options (اختياري)، Padding (اختياري) - لا توجد أنواع أخرى - **مرحلة البيانات**: بأي ترتيب باستثناء: - يجب أن تكون Padding آخر كتلة إذا وُجدت - يجب أن تكون Termination آخر كتلة (باستثناء Padding) إذا وُجدت - يُسمح بكتلات I2NP متعددة لكل إطار - لا يُسمح بكتلات Padding متعددة لكل إطار نوع الكتلة 0: DateTime (التاريخ والوقت) مزامنة الوقت لاكتشاف انحراف الساعة.\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) التنفيذ: قرّب إلى أقرب ثانية لمنع تراكم انحياز الساعة.\nنوع الكتلة 1: الخيارات معلمات الحشو وتشكيل حركة المرور.\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) نسب الحشو (عدد بنقطة ثابتة 4.4، القيمة/16.0): - tmin: أدنى نسبة حشو للإرسال (0.0 - 15.9375) - tmax: أقصى نسبة حشو للإرسال (0.0 - 15.9375) - rmin: أدنى نسبة حشو للاستقبال (0.0 - 15.9375) - rmax: أقصى نسبة حشو للاستقبال (0.0 - 15.9375)\nأمثلة: - 0x00 = 0% حشو - 0x01 = 6.25% حشو - 0x10 = 100% حشو (نسبة 1:1) - 0x80 = 800% حشو (نسبة 8:1)\nحركة المرور الوهمية: - tdmy: الحد الأقصى المستعد لإرساله (2 بايت، متوسط بايت/ثانية) - rdmy: المطلوب استلامه (2 بايت، متوسط بايت/ثانية)\nإدراج التأخير: - tdelay: الحد الأقصى المستعد لإدراجه (2 بايت، متوسط بالميلي ثانية) - rdelay: التأخير المطلوب (2 بايت، متوسط بالميلي ثانية)\nالإرشادات: - تشير القيم الدنيا إلى مستوى مقاومة تحليل حركة المرور المرغوب - تشير القيم القصوى إلى قيود عرض النطاق الترددي - على المرسل احترام الحد الأقصى الذي حدده المستقبل - قد يراعي المرسل الحد الأدنى الذي حدده المستقبل ضمن القيود - لا توجد آلية إنفاذ؛ قد تختلف التنفيذات\nنوع الكتلة 2: RouterInfo (معلومات الـ router) تسليم RouterInfo من أجل تعبئة netdb والنشر الواسع.\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 الاستخدام:\nفي الرسالة 3 الجزء 2 (مصافحة): - ترسل أليس RouterInfo (بيانات تعريف الـ Router في I2P) إلى بوب - بتّ Flood عادةً 0 (تخزين محلي) - RouterInfo غير مضغوطة بـ gzip\nفي مرحلة البيانات: - يمكن لأي من الطرفين إرسال RouterInfo (بنية بيانات معلومات Router في I2P) المحدَّثة لديه - Flood bit (بت التحكم بآلية Flood) = 1: طلب توزيع عبر floodfill (إذا كان المستلم floodfill) - Flood bit = 0: تخزين محلي في netdb فقط\nمتطلبات التحقق: 1. تحقق من أن نوع التوقيع مدعوم 2. تحقق من توقيع RouterInfo 3. تحقق من أن الطابع الزمني يقع ضمن الحدود المقبولة 4. في مرحلة المصافحة: تحقق من تطابق المفتاح الثابت مع معلمة \u0026ldquo;s\u0026rdquo; في عنوان NTCP2 5. في مرحلة البيانات: تحقق من تطابق تجزئة الـ router مع نظير الجلسة 6. أغرق فقط RouterInfos ذات العناوين المنشورة\nملاحظات: - لا توجد آلية ACK (إقرار الاستلام؛ استخدم I2NP DatabaseStore مع رمز الرد إذا لزم الأمر) - قد تحتوي على RouterInfos لطرف ثالث (استخدام floodfill) - غير مضغوطة باستخدام gzip (على عكس I2NP DatabaseStore)\nنوع الكتلة 3: رسالة I2NP رسالة I2NP ذات ترويسة مختصرة بطول 9 بايت.\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) الاختلافات عن NTCP1: - وقت الانتهاء: 4 بايت (ثواني) مقابل 8 بايت (ميلي ثانية) - الطول: محذوف (يمكن اشتقاقه من طول الكتلة) - المجموع الاختباري: محذوف (AEAD (تشفير موثَّق مع بيانات مرتبطة) يوفر سلامة البيانات) - الترويسة: 9 بايت مقابل 16 بايت (انخفاض بنسبة 44%)\nالتجزئة: - رسائل I2NP يجب ألا تُجزأ عبر الكتل - رسائل I2NP يجب ألا تُجزأ عبر الإطارات - يُسمح بوجود عدة كتل I2NP لكل إطار\nنوع الكتلة 4: الإنهاء إغلاق الاتصال بشكل صريح مع رمز السبب.\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) رموز الأسباب:\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny **القواعد:** - يجب أن تكون كتلة الإنهاء آخر كتلة غير الحشو في الإطار - كتلة إنهاء واحدة كحد أقصى لكل إطار - على المرسل إغلاق الاتصال بعد الإرسال - على المستلم إغلاق الاتصال بعد الاستلام معالجة الأخطاء: - أخطاء المصافحة: عادةً يُغلَق الاتصال عبر TCP RST (بدون كتلة إنهاء) - أخطاء AEAD (التشفير المصادق المرتبط بالبيانات) في مرحلة البيانات: مهلة عشوائية + قراءة عشوائية، ثم إرسال الإنهاء - راجع قسم \u0026ldquo;AEAD Error Handling\u0026rdquo; لإجراءات الأمان\nنوع الكتلة 254: حشو حشو عشوائي لمقاومة تحليل حركة المرور.\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes القواعد: - يجب أن تكون كتلة الحشو الأخيرة في الإطار إذا وُجدت - يُسمح بحشو بطول صفري - كتلة حشو واحدة فقط لكل إطار - يُسمح بالإطارات التي تحتوي على الحشو فقط - ينبغي الالتزام بالمعلمات المتفق عليها من كتلة الخيارات\nالحشو في الرسائل 1-2: - خارج إطار AEAD (المصادقة والتشفير مع البيانات المرتبطة) (نص واضح) - مُتضمَّن في سلسلة تجزئة الرسالة التالية (مُوثَّق) - يتم اكتشاف العبث عند فشل AEAD للرسالة التالية\nالحشو في الرسالة 3+ ومرحلة البيانات: - داخل إطار AEAD (مشفّر ومُوثَّق) - يُستخدم لتشكيل حركة المرور وتمويه الحجم\nمعالجة أخطاء AEAD (التشفير المصادق مع بيانات مرتبطة) المتطلبات الأمنية الحرجة:\nمرحلة المصافحة (الرسائل 1-3) حجم الرسالة المعروف: - أحجام الرسائل محددة مسبقاً أو مُعيّنة سلفاً - فشل مصادقة AEAD (التشفير المصادق مع بيانات مرتبطة) غير ملتبس\nاستجابة Bob لفشل الرسالة 1: 1. اضبط مهلة عشوائية (النطاق يعتمد على التنفيذ، يُقترَح 100-500 مللي ثانية) 2. اقرأ عدداً عشوائياً من البايتات (النطاق يعتمد على التنفيذ، يُقترَح 1KB-64KB) 3. أغلق الاتصال باستخدام TCP RST (إشارة إعادة ضبط TCP) (من دون استجابة) 4. أدرِج عنوان IP المصدر في القائمة السوداء مؤقتاً 5. تتبّع حالات الفشل المتكررة لفرض حظر طويل الأمد\nاستجابة أليس لفشل الرسالة 2: 1. أغلق الاتصال فوراً باستخدام TCP RST 2. لا ترسل أي رد إلى بوب\nاستجابة بوب لفشل الرسالة 3: 1. إغلاق الاتصال فورًا باستخدام TCP RST (إشارة إعادة الضبط في TCP) 2. عدم الرد على أليس\nمرحلة البيانات حجم الرسالة المموَّه: - حقل الطول مموَّه بـSipHash - قد يدل طول غير صالح أو فشل في AEAD (تعمية مصادق عليها مع بيانات مرتبطة) على: - استطلاع من مهاجم - فساد في الشبكة - عدم تزامن IV (متجه التهيئة) الخاص بـSipHash - نظير خبيث\nالاستجابة لخطأ AEAD (تشفير موثَّق مع بيانات مرتبطة) أو خطأ في الطول: 1. اضبط مهلة عشوائية (مقترح 100-500ms) 2. اقرأ عدداً عشوائياً من البايتات (مقترح 1KB-64KB) 3. أرسل كتلة إنهاء مع رمز السبب 4 (فشل AEAD) أو 9 (خطأ في التأطير) 4. أغلق الاتصال\nمنع Decryption Oracle (هجوم الأوراكل لفك التشفير): - لا تفصح مطلقًا للنظير عن نوع الخطأ قبل انقضاء مهلة عشوائية - لا تتجاوز مطلقًا التحقق من الطول قبل فحص AEAD - عامِل الطول غير الصالح معاملة فشل AEAD نفسه - استخدم مسار معالجة أخطاء متطابقًا لكلا الخطأين\nاعتبارات التنفيذ: - قد تستمر بعض التنفيذات في العمل بعد أخطاء AEAD (تشفير مصادق مع بيانات مرتبطة) إذا كانت نادرة - قم بإنهاء بعد تكرار الأخطاء (الحد المقترح: 3-5 أخطاء في الساعة) - وازن بين التعافي من الأخطاء والأمان\nRouterInfo (بيانات تعريف الـ router) المنشور تنسيق عنوان Router يتم الإعلان عن دعم NTCP2 من خلال إدخالات RouterAddress (عنوان الـrouter) المنشورة مع خيارات محددة.\nنمط النقل: - \u0026quot;NTCP2\u0026quot; - NTCP2 فقط على هذا المنفذ - \u0026quot;NTCP\u0026quot; - كلا من NTCP وNTCP2 على هذا المنفذ (اكتشاف تلقائي) - ملاحظة: تمّت إزالة دعم NTCP (v1) في 0.9.50 (مايو 2021) - نمط \u0026ldquo;NTCP\u0026rdquo; أصبح الآن مهجورًا؛ استخدم \u0026ldquo;NTCP2\u0026rdquo;\nالخيارات المطلوبة جميع عناوين NTCP2 المنشورة:\nhost - عنوان IP (IPv4 أو IPv6) أو اسم المضيف\nالصيغة: صيغة IP القياسية أو اسم نطاق قد يُترك في حالات الصادر فقط أو routers المخفية port - رقم منفذ TCP\nالصيغة: عدد صحيح، 1-65535 قد يُهمَل في routers المخصصة للاتصالات الصادرة فقط أو المخفية s - مفتاح عام ثابت (X25519)\nالصيغة: مرمّز بـ Base64، 44 محرف الترميز: أبجدية Base64 الخاصة بـ I2P المصدر: مفتاح عام X25519 بطول 32 بايت، ليتل إنديان (ترتيب بايتات صغير النهاية) i - متجه التهيئة لـ AES\nالتنسيق: مُرمَّز بـ Base64، 24 حرفًا الترميز: أبجدية Base64 الخاصة بـ I2P المصدر: IV بطول 16 بايت، big-endian (ترتيب البايت الكبير) v - إصدار البروتوكول\nالصيغة: عدد صحيح أو أعداد صحيحة مفصولة بفواصل الحالي: \u0026quot;2\u0026quot; المستقبلي: \u0026quot;2,3\u0026quot; (يجب أن تكون بترتيب رقمي) خيارات اختيارية:\ncaps - القدرات (منذ 0.9.50)\nالصيغة: سلسلة من أحرف القدرات القيم: \u0026quot;4\u0026quot; - قدرة اتصال صادر عبر IPv4 \u0026quot;6\u0026quot; - قدرة اتصال صادر عبر IPv6 \u0026quot;46\u0026quot; - كلاهما IPv4 وIPv6 (الترتيب الموصى به) غير مطلوب إذا كان host منشورًا مفيد لـ routers المخفية/المحمية بجدار ناري cost - أولوية العنوان\nالتنسيق: عدد صحيح، 0-255 القيم الأقل = أولوية أعلى مقترح: 5-10 للعناوين العادية مقترح: 14 للعناوين غير المنشورة أمثلة على مدخلات RouterAddress عنوان IPv4 المُعلن:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Router مخفي (صادر فقط):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Router ثنائي المكدس:\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; قواعد مهمة: - يجب أن تستخدم عناوين NTCP2 المتعددة التي تشترك في الـمنفذ نفسه قيم s وi وv متطابقة - قد تستخدم المنافذ المختلفة مفاتيح مختلفة - يُستحسن أن تنشر routers ثنائية المكدس عناوين IPv4 وIPv6 منفصلة\nعنوان NTCP2 غير منشور بالنسبة إلى Routers ذات الاتصالات الصادرة فقط:\nإذا كان الـ router لا يقبل اتصالات NTCP2 الواردة ولكنه يُنشئ اتصالات صادرة، فيجب عليه رغم ذلك نشر RouterAddress (عنوان الـ router) مع:\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; الغرض: - يتيح لـ Bob التحقق من المفتاح الثابت الخاص بـ Alice أثناء المصافحة - مطلوب للتحقق من RouterInfo (معلومات الـ router) في الرسالة 3 الجزء 2 - لا حاجة إلى i أو host أو port (صادر فقط)\nبديل: - أضف s و v إلى عنوان \u0026ldquo;NTCP\u0026rdquo; أو SSU المنشور مسبقًا\nتدوير المفتاح العام وIV (متجه التهيئة) سياسة أمنية حرجة:\nالقواعد العامة: 1. لا تقم أبداً بالتدوير أثناء كون router قيد التشغيل 2. قم بتخزين المفتاح وIV (متجه التهيئة) بشكل دائم عبر عمليات إعادة التشغيل 3. تتبّع فترات التوقف السابقة لتحديد أهلية التدوير\nالحد الأدنى لمدة التوقف قبل التدوير:\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact **مشغّلات إضافية:** - تغيير عنوان IP المحلي: قد يحدث تدوير بغضّ النظر عن انقطاع الخدمة - Router \"rekey\" (new Router Hash): إنشاء مفاتيح جديدة المسوغات: - يمنع كشف أوقات إعادة التشغيل عبر تغييرات المفاتيح - يتيح لـ RouterInfos (ملفات تعريف router) المخزّنة مؤقتًا أن تنقضي بشكل طبيعي - يحافظ على استقرار الشبكة - يقلّل محاولات الاتصال الفاشلة\nالتنفيذ: 1. خزّن المفتاح وIV (متجه التهيئة) والطابع الزمني لآخر إيقاف تشغيل بشكل دائم 2. عند بدء التشغيل، احسب downtime = current_time - last_shutdown 3. إذا كان downtime \u0026gt; الحد الأدنى لنوع الـ router، فقد يتم التدوير 4. إذا تغيّر IP أو كان هناك إعادة توليد للمفاتيح، فقد يتم التدوير 5. وبخلاف ذلك، أعِد استخدام المفتاح وIV السابقين\nتدوير IV (متجه التهيئة): - يخضع لنفس قواعد تدوير المفتاح - يظهر فقط في العناوين المنشورة (وليس في routers المخفية) - يُوصى بتغيير IV كلما تغيّر المفتاح\nاكتشاف الإصدار السياق: عند تعيين transportStyle=\u0026quot;NTCP\u0026quot; (قديم)، يدعم Bob كلًا من NTCP v1 و v2 على المنفذ نفسه ويجب أن يكتشف إصدار البروتوكول تلقائيًا.\nخوارزمية الكشف:\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 فحص MSB (البِت الأكثر أهمية) السريع: - قبل فك تشفير AES، تحقّق: encrypted_X[31] \u0026amp; 0x80 == 0 - المفاتيح الصحيحة لـ X25519 تكون البِت الأعلى فيها مُصفّرة - يشير الفشل على الأرجح إلى NTCP1 (نسخة أقدم من بروتوكول النقل في I2P) (أو هجوم) - نفّذ مقاومة الاستقصاء (مهلة عشوائية + قراءة) عند الفشل\nمتطلبات التنفيذ:\nمسؤولية أليس:\nعند الاتصال بعنوان \u0026ldquo;NTCP\u0026rdquo;، اقصر الرسالة 1 على 287 بايت كحد أقصى قم بتخزين الرسالة 1 مؤقتًا وتفريغها بالكامل دفعة واحدة يزيد احتمال التسليم ضمن حزمة TCP واحدة مسؤوليات بوب:\nتخزين البيانات المستلمة مؤقتاً قبل تحديد الإصدار تنفيذ التعامل الصحيح مع انتهاء المهلة استخدام TCP_NODELAY للكشف السريع عن الإصدار تخزين وتفريغ الرسالة 2 كاملة دفعة واحدة بعد تحديد الإصدار اعتبارات الأمان: - هجمات التجزئة: ينبغي أن يكون Bob مقاومًا لتجزئة TCP - هجمات الاستطلاع: تنفيذ تأخيرات عشوائية وقراءات بايت عند حالات الفشل - منع هجمات حجب الخدمة (DoS): تقييد عدد الاتصالات المعلقة المتزامنة - مهل القراءة: لكل عملية قراءة وإجماليًا (حماية \u0026ldquo;slowloris\u0026rdquo; — هجوم يُبقي الاتصال مفتوحًا عبر إرسال بيانات بطيئة جدًا)\nإرشادات انحراف الساعة حقول الطابع الزمني: - الرسالة 1: tsA (الطابع الزمني الخاص بـ Alice) - الرسالة 2: tsB (الطابع الزمني الخاص بـ Bob) - الرسالة 3+: كتل DateTime (تاريخ/وقت) اختيارية\nالانحراف الأقصى (D): - المعتاد: ±60 ثانية - قابل للتهيئة حسب كل تنفيذ - إذا كان الانحراف \u0026gt; D فعادةً ما يكون قاتلاً\nمعالجة بوب (الرسالة 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally التبرير: إرسال الرسالة 2 حتى في حالة الانحراف الزمني (skew) يمكّن أليس من تشخيص مشكلات الساعة.\nمعالجة أليس (الرسالة 2) 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization ضبط RTT (زمن الرحلة ذهابًا وإيابًا): - اطرح نصف RTT من الانحراف المحسوب - يأخذ في الحسبان تأخير انتشار الشبكة - تقدير أكثر دقة للانحراف\nمعالجة بوب (الرسالة 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) مزامنة الوقت كتل التاريخ والوقت (مرحلة البيانات): - أرسل كتلة التاريخ والوقت دورياً (النوع 0) - يمكن للمستلم استخدامها لضبط الساعة - قرّب الطابع الزمني إلى أقرب ثانية (لتجنّب الانحياز)\nمصادر الوقت الخارجية: - NTP (بروتوكول وقت الشبكة) - مزامنة ساعة النظام - وقت إجماع شبكة I2P\nاستراتيجيات ضبط الساعة: - إذا كانت الساعة المحلية غير دقيقة: اضبط وقت النظام أو استخدم إزاحة زمنية - إذا كانت ساعات النظراء غير دقيقة باستمرار: أشِر إلى وجود مشكلة لدى النظير - تتبّع إحصاءات الانحراف الزمني لمراقبة صحة الشبكة\nخصائص الأمان السرية الأمامية تم تحقيقه عبر: - تبادل مفاتيح ديفي-هيلمان المؤقت (X25519 — منحنى إهليليجي لتبادل المفاتيح) - ثلاث عمليات DH: es, ee, se (Noise XK pattern — نمط المصافحة XK ضمن إطار Noise) - تُتلف المفاتيح المؤقتة بعد إتمام المصافحة\nتدرّج السرّية: - الرسالة 1: المستوى 2 (سرّية أمامية في حال اختراق المُرسِل) - الرسالة 2: المستوى 1 (مستلم مؤقت) - الرسالة 3+: المستوى 5 (سرّية أمامية قوية)\nالسرية التامة للأمام (Perfect Forward Secrecy): - اختراق المفاتيح الثابتة طويلة الأجل لا يؤدي إلى كشف مفاتيح الجلسات السابقة - كل جلسة تستخدم مفاتيح مؤقتة فريدة - لا يُعاد استخدام المفاتيح الخاصة المؤقتة أبداً - تنظيف الذاكرة بعد اتفاق المفاتيح\nالقيود: - الرسالة 1 تكون عرضة للخطر إذا تم اختراق مفتاح Bob الثابت (لكن توجد سرية أمامية في مواجهة اختراق Alice) - هجمات إعادة الإرسال ممكنة للرسالة 1 (يخفف أثرها عبر الطابع الزمني وذاكرة التخزين المؤقت لإعادة الإرسال)\nالمصادقة المصادقة المتبادلة: - تمت مصادقة أليس بمفتاح ثابت في الرسالة 3 - تمت مصادقة بوب عبر امتلاكه مفتاحاً خاصاً ثابتاً (ضمنياً نتيجة المصافحة الناجحة)\nمقاومة Key Compromise Impersonation (KCI) (انتحال الهوية عند اختراق المفتاح): - مستوى المصادقة 2 (مقاوم لـ KCI) - لا يستطيع المهاجم انتحال شخصية Alice حتى مع المفتاح الخاص الثابت لـ Alice (من دون المفتاح المؤقت لـ Alice) - لا يستطيع المهاجم انتحال شخصية Bob حتى مع المفتاح الخاص الثابت لـ Bob (من دون المفتاح المؤقت لـ Bob)\nالتحقق من المفتاح الثابت: - تعرف Alice مفتاح Bob الثابت مسبقاً (من RouterInfo (معلومات الـrouter)) - يتحقق Bob من أن مفتاح Alice الثابت يطابق RouterInfo في الرسالة 3 - يمنع هجمات الرجل في الوسط\nمقاومة تحليل حركة المرور إجراءات مضادة لفحص الحزم العميق (DPI): 1. تمويه AES: المفاتيح المؤقتة مشفّرة، وتبدو عشوائية 2. تمويه الطول باستخدام SipHash: أطوال الإطارات ليست نصاً عادياً 3. حشو عشوائي: أحجام الرسائل متغيرة، بلا أنماط ثابتة 4. إطارات مشفّرة: جميع الحمولة مُشفَّرة باستخدام ChaCha20\nمنع هجوم إعادة الإرسال: - التحقق من الطابع الزمني (±60 ثانية) - ذاكرة تخزين مؤقت للإعادة للمفاتيح المؤقتة (مدة الحياة 2*D) - زيادة قيمة Nonce (قيمة فريدة تُستخدم مرة واحدة) تمنع إعادة إرسال الحزم ضمن الجلسة\nمقاومة التحسس: - مهلات زمنية عشوائية عند فشل AEAD (تشفير موثّق مع بيانات مرتبطة) - قراءة بايتات عشوائية قبل إغلاق الاتصال - عدم إرسال ردود عند فشل المصافحة - حظر عنوان IP عند تكرار حالات الفشل\nإرشادات الحشو: - الرسائل 1-2: حشو بنص غير مشفّر (مصدَّق) - الرسالة 3+: حشو مُشفَّر داخل إطارات AEAD (التشفير المصادق مع بيانات مرتبطة) - معلمات الحشو المتفق عليها (Options block - حقل الخيارات) - مسموح بإطارات الحشو فقط\nالتخفيف من هجمات حجب الخدمة حدود الاتصالات: - الحد الأقصى للاتصالات النشطة (يعتمد على التنفيذ) - الحد الأقصى لعمليات المصافحة المعلقة (مثلًا، 100-1000) - حدود الاتصالات لكل عنوان IP (مثلًا، 3-10 متزامنة)\nحماية الموارد: - تقييد معدل عمليات DH (مكلفة) - مهلات القراءة لكل مقبس وإجماليًا - حماية من \u0026ldquo;Slowloris\u0026rdquo; (هجوم إبقاء اتصالات HTTP مفتوحة ببطء) (حدود زمنية إجمالية) - إدراج عناوين IP في القائمة السوداء بسبب الإساءة\nالرفض السريع: - عدم تطابق معرّف الشبكة → إغلاق فوري - X25519 point (نقطة على منحنى إهليلجي X25519) غير صالحة → فحص سريع لـMSB قبل فك التشفير - الطابع الزمني خارج النطاق → إغلاق من دون إجراء أي حسابات - فشل AEAD (مصادقة وتشفير مرتبطان بالبيانات) → لا استجابة، تأخير عشوائي\nمقاومة الاستطلاع: - مهلة عشوائية: 100-500ms (يعتمد على التنفيذ) - قراءة عشوائية: 1KB-64KB (يعتمد على التنفيذ) - لا تُقدَّم معلومات عن الأخطاء إلى المهاجم - الإغلاق عبر TCP RST (بدون مصافحة FIN)\nالأمن التشفيري الخوارزميات: - X25519: أمان بمستوى 128-بت، ديفي-هيلمان بمنحنيات إهليلجية (Curve25519) - ChaCha20: تشفير تدفقي بمفتاح بطول 256-بت - Poly1305: رمز مصادقة الرسائل آمن من منظور نظرية المعلومات - SHA-256: مقاومة تصادم 128-بت، ومقاومة صورة أولية 256-بت - HMAC-SHA256: دالة عشوائية زائفة (PRF) لاشتقاق المفاتيح\nأحجام المفاتيح: - مفاتيح ثابتة: 32 بايت (256 بت) - مفاتيح عابرة: 32 بايت (256 بت) - مفاتيح التشفير: 32 بايت (256 بت) - MAC: 16 بايت (128 بت)\nالمشكلات المعروفة: - إعادة استخدام nonce (رقم يُستخدم مرة واحدة) في ChaCha20 كارثية (يُمنَع بزيادة العداد) - تعاني X25519 من مشكلات المجموعات الفرعية الصغيرة (يُخفَّف أثرها عبر التحقق من صحة المنحنى) - SHA-256 مُعرَّض نظرياً لهجوم تمديد الطول (غير قابل للاستغلال في HMAC)\nلا توجد ثغرات معروفة (حتى أكتوبر 2025): - Noise Protocol Framework (إطار عمل لبناء بروتوكولات قنوات آمنة) خضع لتحليل واسع النطاق - ChaCha20-Poly1305 مُعتمد في TLS 1.3 - X25519 معيار في البروتوكولات الحديثة - لا توجد هجمات عملية على التصميم\nالمراجع المواصفات الأساسية مواصفة NTCP2 - المواصفة الرسمية لـ I2P المقترح 111 - وثيقة التصميم الأصلية مع المبررات إطار عمل بروتوكول Noise - المراجعة 33 (2017-10-04) معايير التشفير RFC 7748 - المنحنيات الإهليلجية للأمن (X25519) RFC 7539 - ChaCha20 و Poly1305 لبروتوكولات IETF RFC 8439 - ChaCha20-Poly1305 (يحل محل RFC 7539) RFC 2104 - HMAC: تجزئة بمفتاح لمصادقة الرسائل SipHash - SipHash-2-4 لتطبيقات دوال التجزئة المواصفات ذات الصلة بـ I2P مواصفة I2NP - تنسيق رسائل بروتوكول شبكة I2P البنى المشتركة - تنسيقات RouterInfo و RouterAddress نقل SSU - نقل UDP (الأصلي، الآن SSU2) المقترح 147 - فحص معرّف شبكة النقل (0.9.42) مراجع التنفيذ I2P Java - التنفيذ المرجعي (Java) i2pd - تنفيذ بلغة C++ ملاحظات إصدار I2P - سجل الإصدارات والتحديثات السياق التاريخي Station-To-Station Protocol (STS) - مصدر إلهام لـ Noise framework (إطار للمصافحات التشفيرية) obfs4 - Pluggable transport (وسيلة نقل قابلة للإضافة لإخفاء حركة المرور) (سابقة لإخفاء الطول باستخدام SipHash) إرشادات التنفيذ المتطلبات الإلزامية لأغراض الامتثال:\nتنفيذ المصافحة كاملة:\nادعم الرسائل الثلاث جميعًا بسلاسل KDF (دالة اشتقاق المفاتيح) الصحيحة تحقّق من صحة جميع وسوم AEAD (التشفير الموثق مع بيانات مرتبطة) تحقّق من أن نقاط X25519 (خوارزمية لتبادل المفاتيح على منحنى بيضوي) صالحة تنفيذ مرحلة البيانات:\nتمويه طول SipHash (في كلا الاتجاهين) جميع أنواع الكتل: 0 (DateTime)، 1 (Options)، 2 (RouterInfo)، 3 (I2NP)، 4 (Termination)، 254 (Padding) إدارة nonce (عدد يستخدم مرة واحدة) بشكل صحيح (عدادات منفصلة) ميزات الأمان:\nمنع إعادة الإرسال (تخزين المفاتيح المؤقتة في الذاكرة لمدة 2*D) التحقق من صحة الطابع الزمني (الافتراضي ±60 ثانية) حشو عشوائي في الرسائل 1-2 التعامل مع أخطاء AEAD (تشفير موثَّق مع بيانات مرتبطة) بمهلات زمنية عشوائية نشر RouterInfo (معلومات router):\nنشر المفتاح الثابت (\u0026ldquo;s\u0026rdquo;)، و IV (متجه التهيئة) (\u0026ldquo;i\u0026rdquo;)، والإصدار (\u0026ldquo;v\u0026rdquo;) تدوير المفاتيح وفقًا للسياسة دعم حقل القدرات (\u0026ldquo;caps\u0026rdquo;) لـ routers المخفية توافق الشبكة:\nدعم حقل معرّف الشبكة (حالياً 2 للشبكة الرئيسية) التشغيل البيني مع تنفيذات Java وi2pd الحالية التعامل مع كل من IPv4 وIPv6 الممارسات الموصى بها تحسين الأداء:\nاستراتيجية التخزين المؤقت:\nفرّغ الرسائل كاملة دفعة واحدة (الرسائل 1، 2، 3) استخدم TCP_NODELAY لرسائل المصافحة جمّع عدة كتل بيانات في إطارات منفردة حدّد حجم الإطار ببضعة كيلوبايت (لتقليل كمون المستقبِل) إدارة الاتصالات:\nإعادة استخدام الاتصالات كلما أمكن طبّق تجميع الاتصالات راقب صحة الاتصال (DateTime blocks) إدارة الذاكرة:\nتصفير البيانات الحساسة بعد الاستخدام (المفاتيح المؤقتة، نتائج DH) تقييد المصافحات المتزامنة (منع DoS (حجب الخدمة)) استخدام مجمعات الذاكرة للتخصيصات المتكررة تعزيز الأمان:\nمقاومة الفحص الاستكشافي:\nمهلات عشوائية: 100-500ms قراءات بايت عشوائية: 1KB-64KB وضع عناوين IP في القائمة السوداء عند تكرار الإخفاقات عدم تقديم تفاصيل الأخطاء للأقران حدود الموارد:\nالحد الأقصى للاتصالات لكل عنوان IP: 3-10 الحد الأقصى لعمليات المصافحة المعلقة: 100-1000 مهلات القراءة: 30-60 ثانية لكل عملية المهلة الإجمالية للاتصال: 5 دقائق لمرحلة المصافحة إدارة المفاتيح:\nالتخزين الدائم للمفتاح الثابت و IV (المتجه الأوّلي) التوليد العشوائي الآمن (مولّد أرقام عشوائية تشفيرية) الالتزام بسياسات التدوير بصرامة عدم إعادة استخدام المفاتيح المؤقتة مطلقًا المراقبة والتشخيص:\nالمقاييس:\nمعدلات نجاح/فشل المصافحة معدلات أخطاء AEAD (تشفير مُصادَق مع بيانات مرتبطة) توزيع انحراف الساعة إحصائيات مدة الاتصال التسجيل:\nسجّل حالات فشل المصافحة مع رموز الأسباب سجّل أحداث انحراف الساعة سجّل عناوين IP المحظورة لا تُسجّل مطلقًا بيانات المفاتيح الحساسة الاختبار:\nاختبارات الوحدات لسلاسل KDF اختبارات التكامل مع تنفيذات أخرى Fuzzing (اختبار الإدخالات العشوائية) لمعالجة الحزم اختبارات التحميل لمقاومة هجمات حجب الخدمة (DoS) المزالق الشائعة أخطاء حرجة يجب تجنبها:\nإعادة استخدام Nonce (عدد يُستخدم لمرة واحدة):\nلا تعِد ضبط عدّاد nonce أثناء الجلسة استخدم عدّادات منفصلة لكل اتجاه أنهِ الجلسة قبل الوصول إلى 2^64 - 1 تدوير المفاتيح:\nلا تقم بتدوير المفاتيح مطلقًا أثناء تشغيل router لا تعِد استخدام المفاتيح المؤقتة عبر الجلسات مطلقًا اتبع قواعد الحد الأدنى لوقت التوقف التعامل مع الطوابع الزمنية:\nلا تقبل أبدًا الطوابع الزمنية المنتهية الصلاحية اضبط دائمًا وفقًا لـ RTT (زمن الذهاب والإياب) عند حساب الانحراف قرّب الطوابع الزمنية من نوع DateTime إلى الثواني أخطاء AEAD (تشفير موثق مع بيانات مرتبطة):\nلا تكشف مطلقاً نوع الخطأ للمهاجم استخدم دائماً مهلة عشوائية قبل الإغلاق عامِل الطول غير الصالح كأنه فشل AEAD الحشو:\nلا ترسل الحشو أبداً خارج الحدود المتفق عليها ضع دائماً كتلة الحشو في النهاية لا تستخدم عدة كتل حشو ضمن إطار واحد RouterInfo (بيانات التعريف الخاصة بـ Router في I2P):\nتحقّق دائمًا من تطابق المفتاح الثابت مع RouterInfo لا تقم أبدًا بنشر RouterInfos من دون عناوين منشورة تحقّق دائمًا من صحة التواقيع منهجية الاختبار اختبارات الوحدات:\nالبدائيات التشفيرية:\nمتجهات اختبار لـ X25519 وChaCha20 وPoly1305 وSHA-256 متجهات اختبار لـ HMAC-SHA256 متجهات اختبار لـ SipHash-2-4 سلاسل KDF (دالة اشتقاق المفاتيح):\nاختبارات الإجابات المعروفة لجميع الرسائل الثلاث التحقق من انتقال مفتاح السلسلة اختبار توليد SipHash IV (متجه التهيئة) تحليل الرسائل:\nفك ترميز الرسائل الصالحة رفض الرسائل غير الصالحة الشروط الحدّية (فارغة، الحجم الأقصى) اختبارات التكامل:\nالمصافحة:\nعملية تبادل بثلاث رسائل ناجحة رفض انحراف الساعة اكتشاف هجوم إعادة الإرسال رفض المفتاح غير الصالح مرحلة البيانات:\nنقل رسائل I2NP تبادل RouterInfo معالجة الحشو رسائل الإنهاء التشغيل البيني:\nاختبار مقابل Java I2P اختبار مقابل i2pd اختبار IPv4 وIPv6 اختبار routers المعلنة والمخفية اختبارات الأمان:\nالاختبارات السلبية:\nعلامات AEAD (تشفير موثق مع بيانات مرتبطة) غير صالحة رسائل أُعيد تشغيلها هجمات انحراف الساعة إطارات سيئة التشكيل اختبارات DoS (حجب الخدمة):\nإغراق الاتصالات هجمات Slowloris (إبقاء الاتصال مفتوحاً ببطء) استنزاف وحدة المعالجة المركزية (DH (تبادل المفاتيح Diffie-Hellman) مفرط) استنزاف الذاكرة Fuzzing (اختبار الإدخال العشوائي):\nرسائل مصافحة عشوائية إطارات مرحلة البيانات عشوائية أنواع الكتل وأحجامها عشوائية قيم تشفيرية غير صالحة الترحيل من NTCP (بروتوكول النقل عبر TCP الخاص بـ I2P) بخصوص دعم NTCP القديم (تمت إزالته الآن):\nأُزيل NTCP (الإصدار 1) في I2P 0.9.50 (مايو 2021). يجب أن تدعم جميع التنفيذات الحالية NTCP2. ملاحظات تاريخية:\nالفترة الانتقالية (2018-2021):\n0.9.36: تم تقديم NTCP2 (معطّل افتراضيًا) 0.9.37: تم تمكين NTCP2 افتراضيًا 0.9.40: أُعلن إهمال NTCP 0.9.50: تمت إزالة NTCP اكتشاف الإصدار:\ntransportStyle \u0026ldquo;NTCP\u0026rdquo; كان يدلّ على أن كلا الإصدارين مدعومان transportStyle \u0026ldquo;NTCP2\u0026rdquo; كان يدلّ على دعم NTCP2 فقط اكتشاف تلقائي عبر حجم الرسالة (287 مقابل 288 بايت) الحالة الحالية:\nيتعيّن على جميع routers دعم NTCP2 قيمة \u0026ldquo;NTCP\u0026rdquo; لـ transportStyle أصبحت متقادمة استخدم قيمة \u0026ldquo;NTCP2\u0026rdquo; لـ transportStyle حصراً الملحق أ: Noise XK Pattern (نمط المصافحة XK في بروتوكول Noise) النمط القياسي لـ Noise XK (ضمن إطار بروتوكول Noise):\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se التفسير:\n\u0026lt;- : رسالة من المستجيب (Bob) إلى البادئ (Alice) -\u0026gt; : رسالة من البادئ (Alice) إلى المستجيب (Bob) s : مفتاح ثابت (مفتاح هوية طويل الأمد) rs : مفتاح ثابت بعيد (المفتاح الثابت للطرف النظير، معروف مسبقًا) e : مفتاح مؤقت (خاص بالجلسة، يُولَّد عند الطلب) es : DH مؤقت-ثابت (ديفي-هيلمان) (مؤقت Alice × ثابت Bob) ee : DH مؤقت-مؤقت (مؤقت Alice × مؤقت Bob) se : DH ثابت-مؤقت (ثابت Alice × مؤقت Bob) تسلسل الاتفاق على المفاتيح:\nما قبل الرسالة: تعرف أليس المفتاح العام الثابت لبوب (من RouterInfo) الرسالة 1: ترسل أليس مفتاحًا مؤقتًا، وتجري es DH (تبادل المفاتيح ديفي-هيلمان) الرسالة 2: يرسل بوب مفتاحًا مؤقتًا، ويجري ee DH الرسالة 3: تكشف أليس عن المفتاح الثابت، وتجري se DH خصائص الأمان:\nتمت مصادقة أليس: نعم (عن طريق الرسالة 3) تمت مصادقة بوب: نعم (بامتلاك مفتاح خاص ثابت) السرية الأمامية: نعم (تم إتلاف المفاتيح المؤقتة) مقاومة KCI (انتحال الهوية بعد اختراق المفتاح): نعم (مستوى المصادقة 2) الملحق ب: ترميز Base64 أبجدية Base64 الخاصة بـ I2P:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ الاختلافات عن Base64 القياسي: - الرمزان 62-63: -~ بدلًا من +/ - الحشو: نفسه (=) أو يُحذَف بحسب السياق\nالاستخدام في NTCP2: - مفتاح ثابت (\u0026ldquo;s\u0026rdquo;): 32 بايت → 44 محرف (بدون حشو) - IV (متجه التهيئة) (\u0026ldquo;i\u0026rdquo;): 16 بايت → 24 محرف (بدون حشو)\nمثال على الترميز:\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= الملحق C: تحليل التقاط الحزم تحديد حركة مرور NTCP2:\nمصافحة TCP:\nتسلسل TCP القياسي SYN، SYN-ACK، ACK منفذ الوجهة عادةً 8887 أو ما شابهه الرسالة 1 (SessionRequest، طلب جلسة):\nأول بيانات تطبيق من أليس 80-65535 بايت (عادةً بضع مئات) يبدو عشوائياً (مفتاح مؤقت مُشفّر بـ AES) 287 بايت كحد أقصى عند الاتصال بعنوان \u0026ldquo;NTCP\u0026rdquo; الرسالة 2 (SessionCreated - إنشاء الجلسة):\nاستجابة من بوب 80-65535 بايت (عادةً بضع مئات) يبدو عشوائياً أيضاً الرسالة 3 (SessionConfirmed — تأكيد الجلسة):\nمن أليس 48 بايت + متغير (حجم RouterInfo + الحشو) عادةً 1-4 كيلوبايت مرحلة البيانات:\nإطارات بطول متغير حقل الطول مموه (يبدو عشوائياً) حمولة مشفرة الحشو يجعل الحجم غير متوقع مراوغة DPI (فحص الحزم العميق): - لا رؤوس نصية غير مشفّرة - لا أنماط ثابتة - حقول الطول مموهة - الحشو العشوائي يعطّل الاستدلالات القائمة على الحجم\nمقارنة مع NTCP: - تكون الرسالة 1 في NTCP دائمًا بحجم 288 بايت (يمكن التعرّف عليها) - يختلف حجم الرسالة 1 في NTCP2 (غير قابلة للتعرّف عليها) - كان لدى NTCP أنماط يمكن التعرّف عليها - تم تصميم NTCP2 لمقاومة DPI (فحص الحزم العميق)\nالملحق د: تاريخ الإصدارات المعالم الرئيسية:\n0.9.36 (أغسطس 23, 2018): تم تقديم NTCP2، ومعطّل افتراضيًا 0.9.37 (أكتوبر 4, 2018): تم تفعيل NTCP2 افتراضيًا 0.9.40 (مايو 20, 2019): أصبح NTCP مهملًا 0.9.42 (أغسطس 27, 2019): إضافة حقل معرّف الشبكة (الاقتراح 147) 0.9.50 (مايو 17, 2021): إزالة NTCP، وإضافة دعم للقدرات 2.10.0 (سبتمبر 9, 2025): أحدث إصدار مستقر استقرار البروتوكول: - لا تغييرات كاسرة للتوافق منذ 0.9.50 - تحسينات مستمرة في مقاومة الاستقصاء - تركيز على الأداء والموثوقية - يجري تطوير التشفير ما بعد الكم (غير مفعّل افتراضياً)\nحالة النقل الحالية: - NTCP2: نقل TCP إلزامي - SSU2: نقل UDP إلزامي - NTCP (v1): أُزيل - SSU (v1): أُزيل\n","description":"نقل TCP قائم على Noise (إطار بروتوكولات للتشفير) للروابط بين router وrouter","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"بروتوكول النقل NTCP2","url":"/ar/docs/specs/ntcp2/"},{"categories":null,"content":"نظرة عامة يحدد بروتوكول شبكة I2P (I2NP) كيف تقوم routers بتبادل الرسائل، واختيار بروتوكولات النقل، ومزج حركة المرور مع الحفاظ على إخفاء الهوية. يعمل بين I2CP (واجهة برمجة تطبيقات العميل) وبروتوكولات النقل (NTCP2 وSSU2).\nI2NP (بروتوكول شبكة I2P) هو الطبقة الواقعة فوق بروتوكولات النقل الخاصة بـ I2P. إنه بروتوكول من router (الموجّه) إلى router يُستخدم من أجل: - عمليات البحث في قاعدة بيانات الشبكة والردود - إنشاء tunnels (أنفاق) - رسائل بيانات router والعميل المشفّرة\nقد تُرسَل رسائل I2NP من نقطة إلى نقطة إلى router آخر، أو تُرسَل بشكلٍ مجهول عبر tunnels إلى ذلك router.\nRouters تضع الأعمال الصادرة في طابور باستخدام أولويات محلية. تُعالَج الأرقام ذات الأولوية الأعلى أولاً. يُعامَل أي شيء أعلى من أولوية بيانات tunnel القياسية (400) على أنه عاجل.\nبروتوكولات النقل الحالية يستخدم I2P الآن NTCP2 (TCP) وSSU2 (UDP) لكل من IPv4 وIPv6. يستخدم كلا بروتوكولي النقل: - X25519 لتبادل المفاتيح (Noise protocol framework، إطار عمل بروتوكول Noise) - ChaCha20/Poly1305 للتشفير المصادق عليه (AEAD) - SHA-256 للتجزئة\nتمت إزالة بروتوكولات النقل القديمة: - تمت إزالة NTCP (TCP الأصلي) من Java router في الإصدار 0.9.50 (مايو 2021) - تمت إزالة SSU v1 (UDP الأصلي) من Java router في الإصدار 2.4.0 (ديسمبر 2023) - تمت إزالة SSU v1 من i2pd في الإصدار 2.44.0 (نوفمبر 2022)\nاعتبارًا من عام 2025، تكون الشبكة قد أتمّت الانتقال بالكامل إلى نواقل مبنية على Noise (إطار عمل للمصافحات التشفيرية)، من دون أي دعم للنواقل القديمة.\nنظام ترقيم الإصدارات مهم: يستخدم I2P نظام ترقيم الإصدارات مزدوجًا يجب فهمه بوضوح:\nالإصدارات (الموجّهة للمستخدم) هذه هي الإصدارات التي يراها المستخدمون ويقومون بتنزيلها: - 0.9.50 (مايو 2021) - آخر إصدار من سلسلة 0.9.x - 1.5.0 (أغسطس 2021) - أول إصدار من سلسلة 1.x - 1.6.0, 1.7.0, 1.8.0, 1.9.0 (خلال 2021-2022) - 2.0.0 (نوفمبر 2022) - أول إصدار من سلسلة 2.x - من 2.1.0 حتى 2.9.0 (خلال 2023-2025) - 2.10.0 (8 سبتمبر 2025) - الإصدار الحالي\nإصدارات واجهة برمجة التطبيقات (توافق البروتوكول) هذه أرقام الإصدارات الداخلية التي تُنشر في الحقل \u0026ldquo;router.version\u0026rdquo; ضمن خصائص RouterInfo: - 0.9.50 (مايو 2021) - 0.9.51 (أغسطس 2021) - نسخة واجهة برمجة التطبيقات (API) للإصدار 1.5.0 - من 0.9.52 حتى 0.9.66 (مستمرة عبر إصدارات 2.x) - 0.9.67 (سبتمبر 2025) - نسخة API للإصدار 2.10.0\nنقطة أساسية: لم تكن هناك أي إصدارات مرقّمة من 0.9.51 وحتى 0.9.67. هذه الأرقام موجودة فقط كمُعرِّفات لإصدارات API (واجهة برمجة التطبيقات). قفز I2P من الإصدار 0.9.50 مباشرةً إلى 1.5.0.\nجدول تعيين الإصدارات Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) **قريبًا:** إصدار 2.11.0 (مخطط له في ديسمبر 2025) سيتطلب Java 17+ ويفعّل التشفير ما بعد الكم افتراضيًا. إصدارات البروتوكول يجب على جميع routers نشر إصدار بروتوكول I2NP الخاص بهم في الحقل \u0026ldquo;router.version\u0026rdquo; ضمن خصائص RouterInfo (معلومات الـ router). يمثّل هذا الحقل إصدار واجهة برمجة التطبيقات (API)، إذ يبيّن مستوى الدعم لمختلف مزايا بروتوكول I2NP، وليس بالضرورة الإصدار الفعلي للـ router.\nإذا رغبت routers بديلة (غير Java) في نشر أي معلومات عن إصدار التنفيذ الفعلي للـ router، فيجب أن يتم ذلك ضمن خاصية أخرى. يُسمح بإصدارات غير تلك المدرجة أدناه. سيتم تحديد الدعم عبر مقارنة رقمية؛ على سبيل المثال، 0.9.13 يعني دعم ميزات 0.9.12.\nملاحظة: لم تعد الخاصية \u0026ldquo;coreVersion\u0026rdquo; تُنشر في معلومات الـ router، ولم تُستخدم مطلقًا لتحديد إصدار بروتوكول I2NP.\nملخص ميزات إصدار واجهة برمجة التطبيقات API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network **ملاحظة:** هناك أيضًا ميزات متعلقة بالنقل ومشكلات في التوافق. راجع وثائق النقل الخاصة بـ NTCP2 وSSU2 للاطّلاع على التفاصيل. رأس الرسالة يستخدم I2NP بنية ترويسة منطقية بطول 16 بايت، بينما تستخدم وسائط النقل الحديثة (NTCP2 وSSU2) ترويسة مختصرة بطول 9 بايت مع حذف حقول الحجم والمجموع الاختباري الزائدة عن الحاجة. تظل الحقول متماثلة من الناحية المفاهيمية.\nمقارنة تنسيق الترويسة التنسيق القياسي (16 بايت):\nيُستخدم في نقل NTCP القديم وعندما تُضمَّن رسائل I2NP داخل رسائل أخرى (TunnelData، TunnelGateway، GarlicClove).\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity الصيغة القصيرة لـ SSU (مهجورة، 5 بايتات):\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) الصيغة القصيرة لـ NTCP2 و SSU2، وفصوص الثوم الخاصة بـ ECIES-Ratchet (آلية السقاطة الخاصة بـ ECIES) (9 بايت):\nيُستخدم في وسائط النقل الحديثة وفي رسائل garlic (أسلوب تجميع رسائل متعددة في I2P) المشفّرة بـ ECIES.\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) تفاصيل حقل الرأس Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity ### ملاحظات التنفيذ عند الإرسال عبر SSU (متقادم)، كان يتم تضمين النوع ووقت الانقضاء المكوَّن من 4 بايت فقط عند الإرسال عبر NTCP2 أو SSU2 (الإصدار 2 من SSU)، يُستخدم التنسيق القصير بحجم 9 بايت يلزم وجود الترويسة القياسية بحجم 16 بايت لرسائل I2NP المُضمَّنة داخل رسائل أخرى (Data, TunnelData, TunnelGateway, GarlicClove) اعتباراً من الإصدار 0.8.12، تم تعطيل التحقق من المجموع الاختباري في بعض المواضع ضمن مكدس البروتوكولات من أجل الكفاءة، لكن ما يزال توليد المجموع الاختباري مطلوباً للتوافق إن وقت الانقضاء القصير غير موقَّع وسيلتفّ في 7 فبراير 2106. بعد ذلك التاريخ، يجب إضافة إزاحة للحصول على الوقت الصحيح للتوافق مع الإصدارات الأقدم، قم دائماً بتوليد المجاميع الاختبارية حتى وإن لم تُتحقق منها قيود الحجم رسائل Tunnel تقسّم حمولات I2NP إلى قطع ثابتة الحجم: - القطعة الأولى: حوالي 956 بايت - القطع اللاحقة: كل منها حوالي 996 بايت - الحد الأقصى للقطع: 64 (مرقمة من 0 إلى 63) - الحد الأقصى للحمولة: حوالي 61,200 بايت (61.2 KB)\nالحساب: 956 + (63 × 996) = 63,704 بايت كحد أقصى نظري، مع حد عملي يقارب 61,200 بايت بسبب الكلفة الإضافية.\nالسياق التاريخي كانت وسائط النقل القديمة تفرض حدوداً أكثر صرامة لحجم الإطارات: - NTCP: إطارات بحجم 16 KB - SSU: إطارات بحجم يقارب 32 KB\nيدعم NTCP2 إطارات بحجم يقارب 65 KB، لكن حدّ التجزئة الخاص بـ tunnel ما زال سارياً.\nاعتبارات بيانات التطبيق قد تقوم رسائل Garlic (رسائل مركبة في I2P) بتجميع LeaseSets أو وسوم الجلسة أو متغيرات LeaseSet2 المشفّرة، مما يقلل المساحة المتاحة لبيانات الحمولة.\nالتوصية: ينبغي أن تبقى Datagrams (رزم بيانات عديمة الاتصال) ≤ 10 KB لضمان تسليم موثوق. قد تواجه الرسائل التي تقترب من حد 61 KB: - ازدياد زمن الاستجابة بسبب إعادة تجميع الأجزاء بعد التجزئة - ارتفاع احتمال فشل التسليم - تعرّض أكبر لتحليل حركة المرور\nالتفاصيل التقنية للتجزئة كل رسالة tunnel يبلغ حجمها بالضبط 1,024 بايت (1 كيلوبايت) وتحتوي على: - tunnel ID بطول 4 بايت - متجه التهيئة (IV) بطول 16 بايت - 1,004 بايت من البيانات المشفّرة\nضمن البيانات المُشفّرة، تحمل رسائل tunnel رسائل I2NP مُجزأة مع رؤوس أجزاء تشير إلى: - رقم الجزء (0-63) - ما إذا كان هذا هو الجزء الأول أم جزء لاحق - معرّف الرسالة الكلي لإعادة التجميع\nيتضمن الجزء الأول كامل ترويسة رسالة I2NP (16 بايت)، مما يترك حوالي 956 بايتاً للحمولة. الأجزاء اللاحقة لا تتضمن ترويسة الرسالة، ما يتيح نحو 996 بايتاً من الحمولة لكل جزء.\nأنواع الرسائل الشائعة تستخدم Routers نوع الرسالة والأولوية لجدولة المهام الصادرة. تُعالج القيم ذات الأولوية الأعلى أولاً. تطابق القيم أدناه الإعدادات الافتراضية الحالية في Java I2P (اعتباراً من إصدار واجهة برمجة التطبيقات 0.9.67).\nملاحظة: تعتمد قيم الأولوية على التنفيذ. للحصول على قيم الأولوية المرجعية، راجع توثيق الصنف OutNetMessage في الشيفرة المصدرية لـ Java I2P.\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) **أنواع الرسائل المحجوزة:** - النوع 0: محجوز - الأنواع 4-9: محجوزة للاستخدام المستقبلي - الأنواع 12-17: محجوزة للاستخدام المستقبلي - الأنواع 224-254: محجوزة للرسائل التجريبية - النوع 255: محجوز للتوسّع المستقبلي ملاحظات حول نوع الرسالة رسائل مستوى التحكم (DatabaseLookup, TunnelBuild, إلخ.) عادةً تنتقل عبر exploratory tunnels، وليس عبر client tunnels، مما يتيح تحديد الأولوية بشكل مستقل قيم الأولوية تقريبية وقد تختلف حسب التنفيذ TunnelBuild (21) و TunnelBuildReply (22) مُهملة لكنها ما تزال مُنفّذة لأغراض التوافق مع tunnels طويلة جداً (\u0026gt;8 قفزات) أولوية بيانات tunnel القياسية هي 400؛ وكل ما هو أعلى من ذلك يُعامل كعاجل الطول المعتاد لـ tunnel في شبكة اليوم هو 3-4 قفزات، لذا فإن معظم عمليات إنشاء tunnel تستخدم ShortTunnelBuild (سجلات بحجم 218 بايت) أو VariableTunnelBuild (سجلات بحجم 528 بايت) التشفير وتغليف الرسائل غالبًا ما تقوم routers بتغليف رسائل I2NP قبل الإرسال، مما يخلق طبقات متعددة من التشفير. قد تكون رسالة DeliveryStatus: 1. ملفوفة داخل GarlicMessage (مشفّرة) 2. داخل DataMessage 3. ضمن رسالة TunnelData (مشفّرة مرة أخرى)\nكل hop (قفزة) يفك تشفير طبقته فقط؛ تكشف الوجهة النهائية عن الحمولة الأعمق في الداخل.\nخوارزميات التشفير قديمة (يجري التخلص منها تدريجياً): - ElGamal/AES + SessionTags (وسوم الجلسة) - ElGamal-2048 للتشفير غير المتماثل - AES-256 للتشفير المتماثل - وسوم الجلسة بطول 32 بايت\nالوضع الحالي (المعيار ابتداءً من API 0.9.48): - ECIES-X25519 + ChaCha20/Poly1305 AEAD (تشفير موثق مع بيانات إضافية) مع سرية أمامية متدرجة - إطار عمل بروتوكول Noise (Noise_IK_25519_ChaChaPoly_SHA256 للوجهات) - وسوم جلسة بحجم 8 بايت (مخفضة من 32 بايت) - Signal Double Ratchet (خوارزمية السقاطة المزدوجة الخاصة ببروتوكول سيغنال) للسرية الأمامية - تم تقديمه في إصدار API 0.9.46 (2020) - إلزامي لجميع routers اعتباراً من إصدار API 0.9.58 (2023)\nالمستقبل (بيتا اعتباراً من 2.10.0): - تشفير هجين مقاوم لما بعد الكم باستخدام MLKEM (خوارزمية تبادل مفاتيح مقاومة للكم، ML-KEM-768) مقترناً بـ X25519 - آلية سقاطة هجينة تجمع بين اتفاق المفاتيح الكلاسيكي واتفاق المفاتيح لما بعد الكم - متوافق رجعياً مع ECIES-X25519 - سيصبح الإعداد الافتراضي في الإصدار 2.11.0 (ديسمبر 2025)\nإلغاء الاعتماد التدريجي لـ ElGamal Router هام للغاية: تم إهمال ElGamal routers بدءًا من إصدار API 0.9.58 (الإصدار 2.2.0، مارس 2023). وبما أن الحد الأدنى الموصى به لإصدار floodfill المراد الاستعلام عنه أصبح الآن 0.9.58، فلا حاجة لأن تقوم عمليات التنفيذ بتنفيذ التشفير لـ ElGamal floodfill routers.\nمع ذلك: لا تزال وجهات ElGamal مدعومة للتوافق مع الإصدارات السابقة. لا يزال بإمكان العملاء الذين يستخدمون تشفير ElGamal التواصل عبر ECIES routers.\nتفاصيل ECIES-X25519-AEAD-Ratchet هذا هو نوع التشفير 4 في مواصفة التشفير الخاصة بـ I2P. يوفّر:\nأهم الميزات: - سرّية أمامية عبر ratcheting (آلية تدوير مفاتيح تدريجية؛ مفاتيح جديدة لكل رسالة) - تقليل مساحة تخزين وسم الجلسة (8 بايت مقابل 32 بايت) - أنواع جلسات متعددة (جلسة جديدة، جلسة قائمة، لمرة واحدة) - قائم على بروتوكول Noise Noise_IK_25519_ChaChaPoly_SHA256 - متكامل مع خوارزمية Double Ratchet الخاصة بـ Signal\nالبدائيات التشفيرية: - X25519 لاتفاق تبادل المفاتيح Diffie-Hellman - ChaCha20 لتشفير الدفق - Poly1305 لمصادقة الرسائل (AEAD) - SHA-256 للتجزئة - HKDF لاشتقاق المفاتيح\nإدارة الجلسات: - جلسة جديدة: اتصال أولي باستخدام مفتاح وجهة ثابت - جلسة قائمة: رسائل لاحقة باستخدام علامات الجلسة - جلسة لمرة واحدة: جلسات برسالة واحدة بعبء بروتوكولي أقل\nراجع مواصفة ECIES والاقتراح 144 للحصول على التفاصيل التقنية الكاملة.\nالبنى الشائعة البُنى التالية هي عناصر في عدة رسائل I2NP. وهي ليست رسائل كاملة.\nBuildRequestRecord (ElGamal) مهمل. يُستخدَم فقط في الشبكة الحالية عندما يحتوي tunnel على router من نوع ElGamal. راجع ECIES Tunnel Creation للتنسيق الحديث.\nالغرض: سجل واحد ضمن مجموعة تضم عدة سجلات لطلب إنشاء قفزة واحدة داخل الـ tunnel.\nالتنسيق:\nمشفّر بـ ElGamal وAES (إجمالي 528 بايت):\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ بنية مشفّرة بـ ElGamal (خوارزمية تشفير بالمفتاح العام) (528 بايت):\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) بنية النص الواضح (222 بايت قبل التشفير):\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data ملاحظات: - ينتج عن تشفير ElGamal-2048 (خوارزمية تشفير بالمفتاح العام) كتلة بحجم 514 بايت، لكن يتم إزالة بايتي الحشو (في الموضعين 0 و257)، لينتج 512 بايت - راجع مواصفة إنشاء Tunnel لمعرفة تفاصيل الحقول - الشيفرة المصدرية: net.i2p.data.i2np.BuildRequestRecord - ثابت: EncryptedBuildRecord.RECORD_SIZE = 528\nBuildRequestRecord (سجل طلب البناء) (ECIES-X25519 المطوّل) بالنسبة إلى ECIES-X25519 (مخطط ECIES فوق X25519) routers، التي تم تقديمها في إصدار API 0.9.48. تستخدم 528 بايتًا للحفاظ على التوافق مع الإصدارات الأقدم في tunnels المختلطة.\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) إجمالي الحجم: 528 بايت (مماثل لـElGamal للتوافق)\nراجع ECIES Tunnel Creation للاطلاع على بنية النص غير المشفّر وتفاصيل التشفير.\nBuildRequestRecord (ECIES-X25519 قصير) خاص بـ ECIES-X25519 routers فقط، اعتباراً من إصدار API 0.9.51 (الإصدار 1.5.0). هذا هو التنسيق القياسي الحالي.\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) الحجم الإجمالي: 218 بايت (انخفاض بنسبة 59% مقارنةً بـ 528 بايت)\nالاختلاف الرئيسي: تستمد السجلات القصيرة جميع المفاتيح عبر HKDF (وظيفة اشتقاق المفاتيح) بدلاً من تضمينها بشكل صريح في السجل. يشمل ذلك: - مفاتيح الطبقة (لتشفير tunnel) - مفاتيح IV (لتشفير tunnel) - مفاتيح الرد (لبناء الرد) - قيم IV الخاصة بالرد (لبناء الرد)\nيتم اشتقاق جميع المفاتيح باستخدام آلية HKDF الخاصة ببروتوكول Noise، استنادًا إلى السرّ المشترك الناتج عن تبادل المفاتيح X25519.\nالفوائد: - تتسع 4 سجلات قصيرة في رسالة tunnel واحدة (873 بايت) - عمليات بناء tunnel بثلاث رسائل بدلاً من رسائل منفصلة لكل سجل - انخفاض استهلاك النطاق الترددي والكمون - نفس خصائص الأمان كما في التنسيق الطويل\nانظر المقترح 157 للمبررات وإنشاء Tunnel باستخدام ECIES للمواصفة الكاملة.\nشفرة المصدر: - net.i2p.data.i2np.ShortEncryptedBuildRecord - ثابت: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nBuildResponseRecord (ElGamal) مهمل. يُستخدم فقط عندما يحتوي الـ tunnel على router من نوع ElGamal.\nالغرض: سجل واحد ضمن مجموعة من سجلات متعددة تتضمن استجابات لطلب إنشاء.\nالتنسيق:\nمشفّر (528 بايت، نفس حجم BuildRequestRecord (سجلّ طلب البناء)):\nbytes 0-527 :: AES-encrypted record البنية غير المشفرة:\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) رموز الرد: - 0 - قبول - 30 - رفض (تجاوز حد عرض النطاق)\nانظر مواصفة إنشاء Tunnel للتفاصيل حول حقل الرد.\nسجل استجابة البناء (ECIES-X25519) بالنسبة إلى routers التي تستخدم ECIES-X25519 (مخطط تشفير بالمنحنى الإهليلجي باستخدام X25519)، إصدار واجهة برمجة التطبيقات 0.9.48+. بنفس حجم الطلب المقابل (528 للطويل، 218 للقصير).\nالتنسيق:\nالصيغة الطويلة (528 بايت):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ التنسيق المختصر (218 بايت):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ بنية النص الصريح (كلا التنسيقين):\nيحتوي على بنية Mapping (بنية تعيين) بصيغة key-value الخاصة بـ I2P مع: - رمز حالة الرد (إلزامي) - معامل عرض النطاق المتاح (\u0026ldquo;b\u0026rdquo;) (اختياري، أضيف في API 0.9.65) - معلمات اختيارية أخرى للتوسعات المستقبلية\nرموز حالة الرد: - 0 - نجاح - 30 - رفض: تم تجاوز عرض النطاق الترددي\nانظر إنشاء Tunnel باستخدام ECIES للاطلاع على المواصفة الكاملة.\nGarlicClove (مكوّن رسالة ضمن garlic encryption) (ElGamal/AES) تحذير: هذا هو التنسيق المستخدم لفصوص الثوم داخل رسائل الثوم المُشفَّرة باستخدام ElGamal (خوارزمية تشفير بالمفتاح العام). يختلف تنسيق رسائل الثوم وفصوص الثوم الخاصة بـ ECIES-AEAD-X25519-Ratchet اختلافًا كبيرًا. راجع مواصفة ECIES (مخطط التشفير المتكامل بالمنحنيات البيضوية) للاطلاع على التنسيق الحديث.\nأُعلن إهماله بالنسبة إلى routers (API 0.9.58+)، ولا يزال مدعومًا للوجهات.\nالتنسيق:\nغير مشفّر:\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) ملاحظات: - لا تُجزَّأ الـ clove (رسالة فرعية ضمن GarlicMessage) إطلاقًا - عندما يكون البِتّ الأول من بايت العَلَم لـ Delivery Instructions (تعليمات التسليم) يساوي 0، لا يُشفَّر الـ clove - عندما يكون البِتّ الأول 1، يكون الـ clove مُشفَّرًا (ميزة غير منفذة) - الطول الأقصى دالة لمجموع أطوال الـ cloves وللطول الأقصى لـ GarlicMessage (رسالة حاوية لعدة cloves) - قد يُستخدم حقل الشهادة (Certificate) مع HashCash لـ \u0026ldquo;الدفع\u0026rdquo; مقابل التوجيه (احتمال مستقبلي) - الرسائل المستخدمة عمليًا: DataMessage, DeliveryStatusMessage, DatabaseStoreMessage - يمكن أن تحتوي GarlicMessage على GarlicMessage (nested garlic)، لكن هذا لا يُستخدم عمليًا\nانظر Garlic Routing (توجيه «الثوم») للحصول على نظرة عامة مفاهيمية.\nGarlicClove (ECIES-X25519-AEAD-Ratchet) (عنصر رسالة ضمن garlic encryption في I2P) بالنسبة إلى routers والوجهات من نوع ECIES-X25519، إصدار API 0.9.46+. هذا هو التنسيق القياسي الحالي.\nاختلاف جوهري: تستخدم ECIES garlic (أسلوب تجميع رسائل في I2P) بنية مختلفة تماماً تعتمد على كتل Noise protocol (بروتوكول Noise) بدلاً من البُنى الصريحة لـ clove (عنصر رسالة في I2P).\nالتنسيق:\nتحتوي رسائل ECIES بأسلوب garlic (تقنية \u0026ldquo;garlic\u0026rdquo; في I2P) على سلسلة من الكتل:\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data أنواع الكتل: - 0 - Garlic Clove Block (كتلة فصّ الثوم؛ تحتوي على رسالة I2NP) - 1 - كتلة التاريخ والوقت (طابع زمني) - 2 - كتلة الخيارات (خيارات التسليم) - 3 - كتلة الحشو - 254 - كتلة الإنهاء (غير مُنفذة)\nGarlic Clove Block (كتلة فصّ الثوم) (النوع 0):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ الفروقات الأساسية عن صيغة ElGamal: - يستخدم انتهاء صلاحية بطول 4 بايت (ثوانٍ منذ Epoch، بداية حقبة يونكس) بدلاً من تاريخ بطول 8 بايت - لا يوجد حقل شهادة - مُغلّف ضمن بنية كتل تحتوي على النوع والطول - تُشفَّر الرسالة كاملة باستخدام ChaCha20/Poly1305 AEAD (تشفير مصادق مع بيانات مرتبطة) - إدارة الجلسة عبر ratcheting (آلية السقاطة الأمنية)\nانظر مواصفة ECIES للتفاصيل الكاملة حول إطار عمل بروتوكول Noise (إطار لبناء بروتوكولات تبادل المفاتيح المشفّرة) وهياكل الكتل.\nتعليمات تسليم Garlic Clove (رسالة فرعية ضمن garlic encryption) يُستخدم هذا التنسيق لفصوص الثوم الخاصة بكلٍ من ElGamal وECIES. وهو يحدد كيفية إيصال الرسالة المضمّنة.\nتحذير بالغ الأهمية: هذه المواصفة مخصصة لـ Delivery Instructions (تعليمات التسليم) داخل Garlic Cloves (فصوص الثوم) فقط. تُستخدم \u0026ldquo;Delivery Instructions\u0026rdquo; أيضًا داخل رسائل tunnel، حيث يختلف التنسيق اختلافًا كبيرًا. راجع مواصفة رسالة tunnel بخصوص Delivery Instructions الخاصة بـ tunnel. لا تخلط بين هذين التنسيقين.\nالتنسيق:\nمفتاح الجلسة والتأخير غير مستخدمين ولا يظهران مطلقًا، لذا فالأطوال الثلاثة الممكنة هي: - 1 بايت (LOCAL) - 33 بايت (ROUTER and DESTINATION) - 37 بايت (TUNNEL)\n+----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds الأطوال النموذجية: - تسليم محلي: 1 بايت (العلم فقط) - تسليم ROUTER / الوجهة: 33 بايت (العلم + التجزئة) - تسليم TUNNEL: 37 بايت (العلم + التجزئة + tunnel ID)\nأوصاف نوع التسليم:\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router رسائل I2NP المواصفات الكاملة للرسائل لجميع أنواع رسائل I2NP.\nملخص أنواع الرسائل Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active **محجوز:** - النوع 0: محجوز - الأنواع 4-9: محجوز للاستخدام المستقبلي - الأنواع 12-17: محجوز للاستخدام المستقبلي - الأنواع 224-254: محجوز للرسائل التجريبية - النوع 255: محجوز للتوسعة المستقبلية DatabaseStore (رسالة تخزين قاعدة البيانات) (النوع 1) الغرض: عملية تخزين في قاعدة البيانات غير مطلوبة مسبقاً، أو استجابة لرسالة DatabaseLookup (رسالة البحث في قاعدة البيانات) ناجحة.\nالمحتويات: أيٌّ من LeaseSet (بنية بيانات في I2P) أو LeaseSet2 أو MetaLeaseSet أو EncryptedLeaseSet غير مضغوط، أو RouterInfo مضغوط.\nتنسيق باستخدام رمز الرد:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet التنسيق باستخدام رمز الرد == 0:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// الشيفرة المصدرية: - net.i2p.data.i2np.DatabaseStoreMessage - net.i2p.data.RouterInfo (لبنية RouterInfo) - net.i2p.data.LeaseSet (لبنية LeaseSet)\nDatabaseLookup (استعلام قاعدة البيانات) (النوع 2) الغرض: طلب للاستعلام عن عنصر في قاعدة بيانات الشبكة. تكون الاستجابة إما DatabaseStore (رسالة تخزين قاعدة البيانات) أو DatabaseSearchReply (رسالة ردّ البحث في قاعدة البيانات).\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) أنماط تشفير الرد:\nملاحظة: أصبحت ElGamal routers متقادمة اعتبارًا من API 0.9.58. وبما أن الإصدار الأدنى الموصى به من floodfill للاستعلام هو الآن 0.9.58، فلا يلزم على عمليات التنفيذ تطبيق التشفير لـ ElGamal floodfill routers. لا تزال وجهات ElGamal مدعومة.\nيُستخدم البت رقم 4 (ECIESFlag) بالاقتران مع البت رقم 1 (encryptionFlag) لتحديد وضع تشفير الرد:\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future **بدون تشفير (الأعلام 0,0):** لا وجود لـ reply_key أو tags أو reply_tags.\nElG إلى ElG (أعلام 0,1) - مهمل:\nمدعوم اعتباراً من 0.9.7، وأُعلن إهماله اعتباراً من 0.9.58.\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES (مخطط تشفير مدمج بالمنحنيات الإهليلجية) إلى ElG (إل-غامال) (أعلام 1,0) - مهمل:\nمدعوم اعتبارًا من 0.9.46، ومهمل اعتبارًا من 0.9.58.\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data الرد هو رسالة ECIES Existing Session (ECIES: مخطط التشفير المتكامل للمنحنيات الإهليلجية) كما هو محدد في مواصفة ECIES :\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES (نظام تشفير متكامل قائم على المنحنيات الإهليلجية) إلى ECIES (flags 1,0) - المعيار الحالي:\nتقوم وجهة ECIES (مخطط التشفير المتكامل بالمنحنى البيضوي) أو router بإرسال استعلام إلى router يعتمد ECIES. مدعوم ابتداءً من الإصدار 0.9.49.\nنفس التنسيق كما في \u0026ldquo;ECIES to ElG\u0026rdquo; أعلاه. يتم تحديد تشفير رسالة الاستعلام في ECIES (تشفير متكامل قائم على المنحنى الإهليلجي) Routers . الجهة الطالبة مجهولة الهوية.\nECIES (مخطط التشفير المتكامل بالمنحنيات الإهليلجية) إلى ECIES مع DH (تبادل مفاتيح ديفي-هيلمان) (أعلام 1,1) - مستقبلاً:\nلم يتم تحديده بالكامل بعد. انظر المقترح 156 .\nملاحظات: - قبل 0.9.16، قد يكون المفتاح لـ RouterInfo أو LeaseSet (نفس فضاء المفاتيح، دون علم للتمييز) - تكون الردود المشفّرة مفيدة فقط عندما يكون الرد عبر tunnel - قد يكون عدد الوسوم المتضمّنة أكبر من واحد إذا نُفِّذت استراتيجيات استعلام DHT بديلة - مفتاح الاستعلام ومفاتيح الاستبعاد هي التجزئات \u0026ldquo;الحقيقية\u0026rdquo;، وليست مفاتيح التوجيه - قد تُعاد الأنواع 3 و5 و7 (متغيرات LeaseSet2) اعتبارًا من 0.9.38. انظر Proposal 123 - ملاحظات الاستعلام الاستكشافي: يُعرَّف الاستعلام الاستكشافي بأنه يُرجع قائمة بتجزئات غير floodfill قريبة من المفتاح. ومع ذلك، تختلف التطبيقات: تقوم Java فعلًا بالاستعلام عن مفتاح البحث لـ RI وتُعيد DatabaseStore إن وُجد؛ أما i2pd فلا يفعل ذلك. لذلك لا يُنصح باستخدام استعلام استكشافي للتجزئات المُستلمة سابقًا\nالشيفرة المصدرية: - net.i2p.data.i2np.DatabaseLookupMessage - التشفير: net.i2p.crypto.SessionKeyManager\nDatabaseSearchReply (ردّ بحث قاعدة البيانات) (النوع 3) الغرض: الاستجابة لرسالة DatabaseLookup (بحث في قاعدة البيانات) التي فشلت.\nالمحتويات: قائمة بتجزئات router الأقرب إلى المفتاح المطلوب.\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from الشيفرة المصدرية: - net.i2p.data.i2np.DatabaseSearchReplyMessage\nحالة التسليم (النوع 10) الغرض: إقرار بسيط باستلام الرسالة. عادةً ما يُنشئه مُرسِل الرسالة ويُغلَّف ضمن Garlic Message (رسالة Garlic، نوع رسالة في I2P) مع الرسالة نفسها، ليُعاد من قِبل الوجهة.\nالمحتويات: مُعرِّف الرسالة المُسلَّمة ووقت الإنشاء أو الوصول.\nالتنسيق:\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered ملاحظات: - يُضبط الطابع الزمني دائمًا من قبل المُنشئ على الوقت الحالي. ومع ذلك، هناك عدة استخدامات لهذا في الشيفرة، وقد يُضاف المزيد في المستقبل - تُستخدم هذه الرسالة أيضًا كتأكيد على إنشاء الجلسة في SSU. في هذه الحالة، يُضبط معرّف الرسالة على رقم عشوائي، ويُضبط \u0026ldquo;وقت الوصول\u0026rdquo; على المعرّف الحالي على مستوى الشبكة، وهو 2 (أي 0x0000000000000002) - عادةً ما يتم تغليف DeliveryStatus (رسالة حالة التسليم) داخل GarlicMessage (رسالة Garlic) وإرساله عبر tunnel لتقديم إقرار بالاستلام من دون كشف المُرسِل - تُستخدم لاختبار tunnel لقياس زمن الوصول والموثوقية\nالشيفرة المصدرية: - net.i2p.data.i2np.DeliveryStatusMessage - يُستخدم في: net.i2p.router.tunnel.InboundEndpointProcessor لاختبار tunnel (نفق اتصال في I2P)\nGarlicMessage (النوع 11) تحذير: هذا هو التنسيق المستخدم لرسائل garlic المشفّرة بـ ElGamal (أسلوب I2P لتجميع عدة رسائل في رسالة واحدة). يختلف تنسيق رسائل ECIES-AEAD-X25519-Ratchet garlic اختلافًا كبيرًا. راجع مواصفة ECIES للاطلاع على التنسيق الحديث.\nالغرض: يُستخدم لتغليف عدة رسائل I2NP مُشفّرة.\nالمحتويات: عند فك التشفير، توجد سلسلة من Garlic Cloves (وحدات رسائل ضمن garlic encryption) وبيانات إضافية، تُعرف أيضًا باسم Clove Set (مجموعة الفصوص).\nتنسيق مشفّر:\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data البيانات المفكوك تشفيرها (Clove Set، مجموعة «الفصوص»):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) بالنسبة لتنسيق ECIES-X25519-AEAD-Ratchet (المعيار الحالي لـ routers):\nراجع مواصفة ECIES والمقترح 144 .\nالشفرة المصدرية: - net.i2p.data.i2np.GarlicMessage - التشفير: net.i2p.crypto.elgamal.ElGamalAESEngine (مهمل) - التشفير الحديث: net.i2p.crypto.ECIES حزم\nTunnelData (النوع 18) الغرض: رسالة تُرسَل من بوابة الـtunnel أو أحد المشاركين فيه إلى المشارك التالي أو نقطة النهاية. البيانات ذات طول ثابت، وتحتوي على رسائل I2NP تكون مجزأة، ومجموعة على دفعات، ومضافًا إليها الحشو، ومشفَّرة.\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes بنية الحمولة (1024 بايت):\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) ملاحظات: - يتم تعيين معرّف رسالة I2NP لِـ TunnelData (رسالة بيانات النفق) إلى رقم عشوائي جديد عند كل قفزة - يتم تحديد تنسيق رسالة tunnel (ضمن البيانات المُشفَّرة) في Tunnel Message Specification (مواصفات رسائل النفق) - تفك كل قفزة طبقة واحدة باستخدام AES-256 في وضع CBC - يُحدَّث IV (مُتّجه التهيئة) عند كل قفزة باستخدام البيانات بعد فك التشفير - الحجم الإجمالي هو 1,028 بايت بالضبط (4 tunnelId + 1024 بيانات) - هذه هي الوحدة الأساسية لحركة مرور tunnel - تحمل رسائل TunnelData رسائل I2NP المُجزّأة (مثل GarlicMessage (رسالة Garlic) وDatabaseStore (تخزين قاعدة البيانات)، إلخ.)\nالشيفرة المصدرية: - net.i2p.data.i2np.TunnelDataMessage - ثابت: TunnelDataMessage.DATA_LENGTH = 1024 - المعالجة: net.i2p.router.tunnel.InboundGatewayProcessor\nTunnelGateway (بوابة الـ tunnel) (النوع 19) الغرض: يغلف رسالة I2NP أخرى لإرسالها إلى tunnel عبر بوابة الدخول الخاصة به.\nالتنسيق:\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message ملاحظات: - الحمولة عبارة عن رسالة I2NP ذات ترويسة قياسية بطول 16 بايت - تُستخدم لحقن الرسائل في tunnels من الـ router المحلي - تقوم البوابة بتجزئة الرسالة المضمّنة عند الحاجة - بعد التجزئة، تُغلَّف الأجزاء داخل رسائل TunnelData - TunnelGateway لا يُرسَل مطلقًا عبر الشبكة؛ إنه نوع رسالة داخلي يُستخدَم قبل معالجة tunnel\nالشيفرة المصدرية: - net.i2p.data.i2np.TunnelGatewayMessage - المعالجة: net.i2p.router.tunnel.OutboundGatewayProcessor\nDataMessage (رسالة بيانات) (النوع 20) الغرض: تُستخدم من قِبَل Garlic Messages (رسائل Garlic) وGarlic Cloves (فصوص Garlic) لتغليف بيانات اعتباطية (عادةً بيانات تطبيق مُشفّرة من طرف إلى طرف).\nالتنسيق:\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message ملاحظات: - لا تحتوي هذه الرسالة على أي معلومات التوجيه ولن يتم إرسالها مطلقاً \u0026ldquo;بدون تغليف\u0026rdquo; - لا يُستخدم إلا داخل Garlic messages (رسائل غارليك) - يحتوي عادةً على بيانات تطبيق مُشفّرة من طرف إلى طرف (HTTP وIRC والبريد الإلكتروني، إلخ) - تكون البيانات عادةً حمولة مُشفّرة بـ ElGamal/AES أو ECIES - أقصى طول عملي يبلغ نحو 61.2 KB بسبب قيود تجزئة رسائل tunnel\nالشيفرة المصدرية: - net.i2p.data.i2np.DataMessage\nTunnelBuild (النوع 21) تم إهماله. استخدم VariableTunnelBuild (النوع 23) أو ShortTunnelBuild (النوع 25).\nالغرض: طلب إنشاء tunnel بطول ثابت لـ 8 قفزات.\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes ملاحظات: - اعتبارًا من 0.9.48، قد يحتوي على ECIES-X25519 BuildRequestRecords (سجلات طلب إنشاء باستخدام ECIES-X25519). راجع ECIES Tunnel Creation (إنشاء tunnel باستخدام ECIES) - راجع Tunnel Creation Specification (مواصفات إنشاء tunnel) للتفاصيل - يجب ضبط معرّف الرسالة I2NP لهذه الرسالة وفقًا لمواصفات إنشاء tunnel - على الرغم من ندرته في شبكة اليوم (تم استبداله بـ VariableTunnelBuild، بناء tunnel متغيّر)، لا يزال من الممكن استخدامه لـtunnels طويلة جدًا ولم يُعلن تقادمه رسميًا - Routers يجب أن تستمر في تنفيذ ذلك للتوافق - التنسيق الثابت المكوّن من 8 سجلات غير مرن ويهدر عرض النطاق الترددي لـtunnels الأقصر\nالشيفرة المصدرية: - net.i2p.data.i2np.TunnelBuildMessage - ثابت: TunnelBuildMessageBase.MAX_RECORD_COUNT = 8\nTunnelBuildReply (النوع 22) مهمل. استخدم VariableTunnelBuildReply (رد بناء tunnel متغير) (النوع 24) أو OutboundTunnelBuildReply (رد بناء tunnel صادر) (النوع 26).\nالغرض: ردّ إنشاء tunnel بطول ثابت لـ 8 قفزات.\nالتنسيق:\nنفس التنسيق مثل TunnelBuildMessage (رسالة بناء tunnel)، مع BuildResponseRecords (سجلات استجابة البناء) بدلاً من BuildRequestRecords (سجلات طلب البناء).\nTotal size: 8 × 528 = 4,224 bytes ملاحظات: - اعتبارًا من 0.9.48، قد يحتوي على ECIES-X25519 BuildResponseRecords (سجلات استجابة البناء). راجع إنشاء Tunnel باستخدام ECIES - راجع مواصفات إنشاء Tunnel للتفاصيل - يجب ضبط معرّف رسالة I2NP لهذه الرسالة وفقًا لمواصفات إنشاء Tunnel - على الرغم من أنه نادرًا ما يُرى في شبكة اليوم (استُبدل بـ VariableTunnelBuildReply (ردّ بناء Tunnel متغيّر))، لا يزال من الممكن استخدامه لـ tunnels طويلة جدًا ولم يُعلن تقادمه رسميًا - يجب على Routers الاستمرار في تنفيذ ذلك لضمان التوافق\nالشفرة المصدرية: - net.i2p.data.i2np.TunnelBuildReplyMessage\nVariableTunnelBuild (النوع 23) الغرض: إنشاء tunnel متغيّر الطول لعدد يتراوح بين 1 و8 قفزات. يدعم كِلا نوعَي routers: ElGamal وECIES-X25519.\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes ملاحظات: - اعتبارًا من 0.9.48، قد يحتوي على ECIES-X25519 BuildRequestRecords (سجلات طلب البناء). راجع ECIES Tunnel Creation - تم تقديمه في إصدار router 0.7.12 (2009) - قد لا يُرسَل إلى مشاركي الـ tunnel الأقدم من الإصدار 0.7.12 - راجع Tunnel Creation Specification للتفاصيل - يجب ضبط معرّف رسالة I2NP وفقًا لمواصفة إنشاء الـ tunnel - العدد النموذجي للسجلات: 4 (لـ tunnel من 4 قفزات) - الحجم الإجمالي النموذجي: 1 + (4 × 528) = 2,113 بايت - هذه هي رسالة بناء الـ tunnel القياسية لـ ElGamal routers - عادةً ما تستخدم ECIES routers ShortTunnelBuild (رسالة بناء Tunnel مختصرة، النوع 25) بدلًا من ذلك\nشفرة المصدر: - net.i2p.data.i2np.VariableTunnelBuildMessage\nVariableTunnelBuildReply (النوع 24) الغرض: رد بناء tunnel بطول متغير لـ 1-8 قفزات. يدعم كلا نوعي routers: ElGamal وECIES-X25519.\nالتنسيق:\nنفس التنسيق مثل VariableTunnelBuildMessage، مع BuildResponseRecords بدلاً من BuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes ملاحظات: - اعتبارًا من 0.9.48، قد يحتوي على ECIES-X25519 (مخطط تشفير قائم على المنحنى الإهليلجي X25519) BuildResponseRecords (سجلات استجابة البناء). انظر إنشاء ECIES Tunnel - تم تقديمه في إصدار router 0.7.12 (2009) - قد لا يتم إرساله إلى مشاركي tunnel قبل الإصدار 0.7.12 - انظر مواصفة إنشاء Tunnel للتفاصيل - يجب تعيين معرف رسالة I2NP وفقًا لمواصفة إنشاء tunnel - العدد النموذجي للسجلات: 4 - الحجم الإجمالي النموذجي: 2,113 بايت\nشفرة المصدر: - net.i2p.data.i2np.VariableTunnelBuildReplyMessage\nShortTunnelBuild (النوع 25) Purpose: رسائل بناء tunnel قصيرة لـ ECIES-X25519 routers فقط. تم تقديمها في إصدار API 0.9.51 (الإصدار 1.5.0، أغسطس 2021). هذا هو المعيار الحالي لعمليات بناء ECIES tunnel.\nالصيغة:\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes ملاحظات: - تم تقديمه في إصدار router 0.9.51 (الإصدار 1.5.0، أغسطس 2021) - قد لا يُرسَل إلى مشاركي tunnel قبل إصدار API (واجهة برمجة التطبيقات) 0.9.51 - انظر ECIES Tunnel Creation للمواصفة الكاملة (ECIES: نظام تشفير منحنى بيضاوي متكامل) - انظر Proposal 157 للتبرير - العدد المعتاد من السجلات: 4 - الحجم الإجمالي المعتاد: 1 + (4 × 218) = 873 بايت - توفير في عرض النطاق: أصغر بنسبة 59% من VariableTunnelBuild (تنسيق بناء Tunnel متغيّر) (873 مقابل 2,113 بايت) - فائدة في الأداء: تتسع 4 سجلات قصيرة في رسالة tunnel واحدة؛ بينما يتطلب VariableTunnelBuild ثلاث رسائل tunnel - هذا هو الآن تنسيق بناء tunnel القياسي لـ ECIES-X25519 tunnels - تشتق السجلات المفاتيح عبر HKDF (وظيفة اشتقاق مفتاح مبنية على الهاش) بدلاً من تضمينها صراحةً\nالشيفرة المصدرية: - net.i2p.data.i2np.ShortTunnelBuildMessage - الثابت: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nOutboundTunnelBuildReply (النوع 26) الغرض: مرسلة من نقطة النهاية الصادرة لـ tunnel جديد إلى المُنشئ. خاصة بـ ECIES-X25519 routers فقط. قُدِّمت في إصدار واجهة برمجة التطبيقات 0.9.51 (الإصدار 1.5.0، أغسطس 2021).\nالتنسيق:\nنفس التنسيق مثل ShortTunnelBuildMessage, مع ShortBuildResponseRecords بدلاً من ShortBuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes ملاحظات: - تم تقديمه في إصدار router 0.9.51 (الإصدار 1.5.0، أغسطس 2021) - راجع إنشاء Tunnel ECIES للمواصفة الكاملة - العدد النموذجي للسجلات: 4 - الحجم الإجمالي النموذجي: 873 بايت - يُرسل هذا الرد من نقطة النهاية الصادرة (OBEP) إلى مُنشئ tunnel عبر tunnel صادر تم إنشاؤه حديثًا - يوفر تأكيدًا على أن جميع القفزات قبلت بناء tunnel\nالشيفرة المصدرية: - net.i2p.data.i2np.OutboundTunnelBuildReplyMessage\nالمراجع المواصفات الرسمية مواصفة I2NP - المواصفة الكاملة لتنسيق رسائل I2NP البُنى الشائعة - أنواع البيانات والبُنى المستخدمة في جميع أنحاء I2P إنشاء Tunnel - إنشاء Tunnel باستخدام ElGamal (مهمل) إنشاء Tunnel بـ ECIES - إنشاء Tunnel باستخدام ECIES-X25519 (الحالي) رسالة Tunnel - تنسيق رسالة Tunnel وتعليمات التسليم مواصفة NTCP2 - بروتوكول النقل عبر TCP مواصفة SSU2 - بروتوكول النقل عبر UDP مواصفة ECIES - تشفير ECIES-X25519-AEAD-Ratchet مواصفة التشفير - بدائيات تشفير منخفضة المستوى مواصفة I2CP - مواصفة بروتوكول العميل مواصفة Datagram - تنسيقات Datagram2 وDatagram3 المقترحات الاقتراح 123 - مدخلات netDB جديدة (LeaseSet2, EncryptedLeaseSet, MetaLeaseSet) الاقتراح 144 - تشفير ECIES-X25519-AEAD-Ratchet الاقتراح 154 - استعلام قاعدة بيانات مُشفّر الاقتراح 156 - ECIES routers الاقتراح 157 - رسائل إنشاء tunnel أصغر (تنسيق قصير) الاقتراح 159 - نقل SSU2 الاقتراح 161 - حشو قابل للضغط الاقتراح 163 - Datagram2 وDatagram3 الاقتراح 167 - معلمات سجل خدمة LeaseSet الاقتراح 168 - معلمات عرض النطاق لبناء tunnel الاقتراح 169 - تشفير هجين ما بعد الكم التوثيق التوجيه بالثوم - تجميع الرسائل بطبقات ElGamal/AES - مخطط تشفير مُهمل تنفيذ Tunnel - التجزئة والمعالجة قاعدة بيانات الشبكة - جدول تجزئة موزع نقل NTCP2 - مواصفة نقل TCP نقل SSU2 - مواصفة نقل UDP مقدمة تقنية - نظرة عامة على معمارية I2P الشفرة المصدرية مستودع Java I2P - التنفيذ الرسمي بلغة Java مرآة GitHub - مرآة GitHub لـ Java I2P مستودع i2pd - تنفيذ بلغة C++ المواقع الرئيسية للشيفرة المصدرية Java I2P (i2pgit.org/I2P_Developers/i2p.i2p): - core/java/src/net/i2p/data/i2np/ - تنفيذات رسائل I2NP - core/java/src/net/i2p/crypto/ - تنفيذات التشفير - router/java/src/net/i2p/router/tunnel/ - معالجة tunnel - router/java/src/net/i2p/router/transport/ - تنفيذات النقل\nالثوابت والقيم: - I2NPMessage.MAX_SIZE = 65536 - أقصى حجم لرسالة I2NP - I2NPMessageImpl.HEADER_LENGTH = 16 - حجم الترويسة القياسي - TunnelDataMessage.DATA_LENGTH = 1024 - حمولة رسالة Tunnel - EncryptedBuildRecord.RECORD_SIZE = 528 - سجل بناء طويل - ShortEncryptedBuildRecord.RECORD_SIZE = 218 - سجل بناء قصير - TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - الحد الأقصى للسجلات لكل عملية بناء\nالملحق أ: إحصاءات الشبكة والحالة الراهنة تركيبة الشبكة (اعتبارًا من أكتوبر 2025) الحد الأدنى لمتطلبات Router (الموجّه) إصدار API: 0.9.16+ (لتوافق EdDSA مع الشبكة) الحد الأدنى الموصى به: API 0.9.51+ (بُنى tunnel القصيرة بتقنية ECIES) الحد الأدنى الحالي لـ floodfills: API 0.9.58+ (إيقاف دعم router المعتمد على ElGamal) متطلب قادم: Java 17+ (اعتبارًا من الإصدار 2.11.0، ديسمبر 2025) متطلبات عرض النطاق الترددي الحد الأدنى: 128 KBytes/sec (علم N أو أعلى) لـ floodfill الموصى به: 256 KBytes/sec (علم O) أو أعلى متطلبات floodfill: حد أدنى لعرض النطاق الترددي 128 KB/sec مدة تشغيل مستقرة (\u0026gt;95% مُوصى بها) زمن وصول منخفض (\u0026lt;500ms إلى الأقران) اجتياز اختبارات الصحة (زمن قائمة الانتظار، تأخر المهام) إحصائيات Tunnel الطول النموذجي لـ tunnel: 3-4 قفزات الحد الأقصى لطول الـ tunnel: 8 قفزات (نظري، نادر الاستخدام) العمر النموذجي لـ tunnel: 10 دقائق معدل نجاح بناء الـ tunnel: أكثر من 85% لدى routers ذات اتصال جيد صيغة رسالة بناء الـ tunnel: ECIES (نظام تشفير متكامل بالمنحنيات البيضوية) routers: ShortTunnelBuild (سجلات بحجم 218 بايت) tunnels المختلطة: VariableTunnelBuild (سجلات بحجم 528 بايت) مقاييس الأداء وقت بناء tunnel: 1-3 ثانية (نموذجي) الكمون من طرف إلى طرف: 0.5-2 ثانية (نموذجي، 6-8 قفزات إجمالًا) معدل النقل: محدود بعرض نطاق tunnel (عادةً 10-50 KB/sec لكل tunnel) أقصى حجم مخطط بيانات (datagram): 10 KB موصى به (61.2 KB حد أقصى نظري) الملحق ب: الميزات المهملة والمحذوفة تمت إزالته بالكامل (لم يعد مدعومًا) نقل NTCP - أزيل في الإصدار 0.9.50 (مايو 2021) نقل SSU v1 - أزيل من Java I2P في الإصدار 2.4.0 (ديسمبر 2023) نقل SSU v1 - أزيل من i2pd في الإصدار 2.44.0 (نوفمبر 2022) أنواع تواقيع RSA - غير مسموح بها اعتبارا من API 0.9.28 مهمل (مدعوم ولكن غير موصى به) ElGamal (خوارزمية تشفير/توقيع) routers - أُعلن تقادمها اعتباراً من API 0.9.58 (مارس 2023) لا تزال وجهات ElGamal مدعومة لأغراض التوافق العكسي يجب على routers الجديدة استخدام ECIES-X25519 (مخطط تشفير منحنيات إهليلجية باستخدام X25519) حصرياً TunnelBuild (type 21) - أُعلن تقادمه لصالح VariableTunnelBuild وShortTunnelBuild ما زال مُنفّذاً من أجل tunnels الطويلة جداً (\u0026gt;8 قفزات) TunnelBuildReply (type 22) - أُعلن تقادمه لصالح VariableTunnelBuildReply وOutboundTunnelBuildReply تشفير ElGamal/AES - أُعلن تقادمه لصالح ECIES-X25519-AEAD-Ratchet لا يزال مستخدماً للوجهات القديمة سجلات طلب البناء ECIES الطويلة (528 بايت) - أُعلن تقادمها لصالح التنسيق القصير (218 بايت) لا تزال قيد الاستخدام في tunnels المختلطة ذات قفزات ElGamal الجدول الزمني لدعم الإصدارات القديمة Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels --- الملحق ج: التطورات المستقبلية التشفير ما بعد الكمّي الحالة: نسخة تجريبية اعتبارًا من الإصدار 2.10.0 (سبتمبر 2025)، وستصبح الإعداد الافتراضي في 2.11.0 (ديسمبر 2025)\nالتنفيذ: - نهج هجين يجمع بين X25519 الكلاسيكي وخوارزمية ما بعد الكم MLKEM (ML-KEM-768) - متوافق رجعياً مع البنية التحتية الحالية ECIES-X25519 - يستخدم Signal Double Ratchet (خوارزمية «التدرّج المزدوج» من Signal) مع مادة المفتاح الكلاسيكية وPQ (ما بعد الكم) - راجع Proposal 169 للتفاصيل\nمسار الترحيل: 1. الإصدار 2.10.0 (سبتمبر 2025): متاح كخيار تجريبي 2. الإصدار 2.11.0 (ديسمبر 2025): مفعل افتراضيًا 3. الإصدارات المستقبلية: سيصبح إلزاميًا لاحقًا\nالميزات المخطط لها تحسينات IPv6 - دعم أفضل لـ IPv6 وآليات الانتقال تقييد السرعة لكل tunnel - تحكم دقيق في عرض النطاق الترددي لكل tunnel مقاييس محسّنة - مراقبة الأداء والتشخيص بشكل أفضل تحسينات البروتوكول - تقليل الحمولة الإضافية وتحسين الكفاءة تحسين اختيار floodfill - توزيع أفضل لقاعدة بيانات الشبكة مجالات البحث تحسين طول Tunnel - طول tunnel ديناميكي يعتمد على نموذج التهديد حشو متقدم - تحسينات في مقاومة تحليل حركة المرور مخططات تشفير جديدة - استعداد لتهديدات الحوسبة الكمّية التحكم في الازدحام - تعامل أفضل مع حمل الشبكة دعم الأجهزة المحمولة - تحسينات للأجهزة والشبكات المحمولة الملحق د: إرشادات التنفيذ للتنفيذات الجديدة الحد الأدنى من المتطلبات: 1. دعم ميزات API الخاصة بالإصدار 0.9.51+ 2. تنفيذ تشفير ECIES-X25519-AEAD-Ratchet (مخطط تشفير مع آلية ratchet يعتمد X25519 وAEAD) 3. دعم بروتوكولات النقل NTCP2 وSSU2 4. تنفيذ رسائل ShortTunnelBuild (رسائل بناء tunnel مختصرة) (سجلات بحجم 218 بايت) 5. دعم متغيرات LeaseSet2 (الأنواع 3 و5 و7) 6. استخدام تواقيع EdDSA (Ed25519؛ خوارزمية توقيع بمنحنيات بيضوية)\nموصى به: 1. دعم التشفير الهجين بعد الكم (اعتباراً من 2.11.0) 2. تنفيذ معلمات عرض النطاق الترددي لكل tunnel 3. دعم تنسيقات Datagram2 وDatagram3 4. تنفيذ خيارات سجل الخدمة في LeaseSets 5. اتّباع المواصفات الرسمية على /docs/specs/\nغير مطلوب: 1. دعم ElGamal router (مُهمل) 2. دعم النقل القديم (SSU1, NTCP) 3. BuildRequestRecords (سجلات طلب البناء) طويلة لـ ECIES (528 بايت لـ ECIES tunnels الخالصة) 4. رسائل TunnelBuild/TunnelBuildReply (استخدم المتغيرات Variable أو Short)\nالاختبار والتحقق من الصحة الامتثال للبروتوكول: 1. اختبار قابلية التشغيل البيني مع I2P router الرسمي المكتوب بلغة Java 2. اختبار قابلية التشغيل البيني مع i2pd C++ router 3. التحقق من صحة تنسيقات الرسائل وفقًا للمواصفات 4. اختبار دورات إنشاء/تفكيك tunnel 5. التحقق من التشفير/فك التشفير باستخدام متجهات الاختبار\nاختبار الأداء: 1. قياس معدلات نجاح بناء tunnel (يجب أن تكون \u0026gt;85%) 2. الاختبار بأطوال tunnel مختلفة (2-8 قفزات) 3. التحقق من صحة التجزئة وإعادة التجميع 4. الاختبار تحت الحمل (tunnels متعددة ومتزامنة) 5. قياس زمن الوصول من طرف إلى طرف\nاختبارات الأمان: 1. التحقق من تنفيذ التشفير (استخدم متجهات الاختبار) 2. اختبار منع هجمات إعادة الإرسال 3. التحقق من صحة معالجة انتهاء صلاحية الرسائل 4. الاختبار ضد الرسائل سيئة التشكيل 5. التحقق من سلامة توليد الأرقام العشوائية\nمزالق التنفيذ الشائعة تنسيقات تعليمات التسليم المربكة - Garlic clove (رسالة فرعية ضمن garlic encryption) مقابل رسالة tunnel اشتقاق المفاتيح غير الصحيح - استخدام HKDF لسجلات البناء القصيرة معالجة معرّف الرسالة - عدم ضبطه بشكل صحيح لعمليات بناء tunnel مشكلات التجزئة - عدم احترام الحد العملي البالغ 61.2 KB أخطاء ترتيب البايتات (Endianness) - Java تستخدم big-endian (الأكثر أهمية أولاً) لجميع الأعداد الصحيحة التعامل مع تاريخ الانتهاء - التنسيق القصير يلتف في 7 فبراير 2106 توليد المجموع الاختباري (Checksum) - لا يزال مطلوبًا حتى إن لم يُتحقَّق منه ","description":"تنسيقات الرسائل وأولوياتها وحدود أحجامها بين Router وRouter داخل I2P.","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"بروتوكول شبكة I2P (I2NP)","url":"/ar/docs/specs/i2np/"},{"categories":null,"content":" تحذير: نفق SOCKS يُعيد توجيه حمولات التطبيقات دون تنظيفها. العديد من البروتوكولات تُسرّب عناوين IP أو أسماء المضيفين أو معرّفات أخرى. استخدم SOCKS فقط مع البرامج التي قمت بمراجعتها للتأكد من إخفاء الهوية.\n1. نظرة عامة يوفر I2P دعم بروكسي SOCKS 4 و 4a و 5 للاتصالات الصادرة من خلال عميل I2PTunnel. يُمكّن التطبيقات القياسية من الوصول إلى وجهات I2P لكن لا يمكنه الوصول إلى الإنترنت العادي (clearnet). لا يوجد SOCKS outproxy، وتبقى جميع حركة المرور داخل شبكة I2P.\nملخص التنفيذ Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None **أنواع العناوين المدعومة:** - أسماء النطاقات `.i2p` (إدخالات دفتر العناوين) - عناوين Base32 المشفرة (`.b32.i2p`) - لا يوجد دعم لـ Base64 أو الإنترنت العادي 2. المخاطر الأمنية والقيود تسرب طبقة التطبيق يعمل SOCKS أسفل طبقة التطبيق ولا يمكنه تنقية البروتوكولات. تتضمن العديد من العملاء (مثل المتصفحات وIRC والبريد الإلكتروني) بيانات وصفية تكشف عنوان IP الخاص بك أو اسم المضيف أو تفاصيل النظام.\nتشمل التسريبات الشائعة: - عناوين IP في رؤوس البريد الإلكتروني أو استجابات IRC CTCP - الأسماء الحقيقية/أسماء المستخدمين في حمولات البروتوكول - سلاسل user-agent التي تحتوي على بصمات نظام التشغيل - استعلامات DNS الخارجية - WebRTC وبيانات القياس عن بُعد للمتصفح\nلا يمكن لـ I2P منع هذه التسريبات—فهي تحدث فوق طبقة الـ tunnel. استخدم SOCKS فقط مع العملاء المدققين المصممين لإخفاء الهوية.\nهوية النفق المشترك إذا شاركت عدة تطبيقات نفس نفق SOCKS، فإنها تشترك في نفس هوية وجهة I2P. وهذا يتيح الربط أو التعرف على البصمات عبر خدمات مختلفة.\nالتخفيف: استخدم الأنفاق غير المشتركة لكل تطبيق وقم بتفعيل المفاتيح الدائمة للحفاظ على هويات تشفيرية متسقة عبر إعادة التشغيل.\nتم إيقاف وضع UDP دعم UDP في SOCKS5 غير مطبق. يعلن البروتوكول عن قدرة UDP، لكن يتم تجاهل الاستدعاءات. استخدم عملاء TCP فقط.\nبدون Outproxy بالتصميم على عكس Tor، لا يوفر I2P وكلاء خروج (outproxies) إلى الإنترنت العادي تعتمد على SOCKS. ستفشل محاولات الوصول إلى عناوين IP الخارجية أو قد تكشف الهوية. استخدم وكلاء HTTP أو HTTPS إذا كان الوصول إلى الإنترنت الخارجي مطلوباً.\n3. السياق التاريخي لطالما حذّر المطورون من استخدام SOCKS للأغراض المجهولة. من مناقشات المطورين الداخلية والاجتماع 81 والاجتماع 82 لعام 2004:\n\u0026ldquo;إعادة توجيه حركة المرور العشوائية غير آمن، ويتوجب علينا كمطورين لبرامج إخفاء الهوية أن نضع سلامة مستخدمينا النهائيين في مقدمة اهتماماتنا.\u0026rdquo;\nتم تضمين دعم SOCKS للتوافق ولكن لا يُنصح به في بيئات الإنتاج. تقريباً كل تطبيق إنترنت يسرب بيانات وصفية حساسة غير مناسبة للتوجيه المجهول.\n4. الإعدادات Java I2P افتح مدير I2PTunnel أنشئ tunnel عميل جديد من نوع \u0026ldquo;SOCKS 4/4a/5\u0026rdquo; قم بتكوين الخيارات: المنفذ المحلي (أي منفذ متاح) العميل المشترك: تعطيل للحصول على هوية منفصلة لكل تطبيق المفتاح المستمر: تفعيل لتقليل ارتباط المفاتيح ابدأ تشغيل الـ tunnel i2pd يتضمن i2pd دعم SOCKS5 مفعّل افتراضياً على 127.0.0.1:4447. يمكنك ضبط المنفذ والمضيف ومعاملات tunnel من خلال الإعدادات في i2pd.conf تحت قسم [SOCKSProxy].\n5. الجدول الزمني للتطوير Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 لم يشهد وحدة SOCKS نفسها أي تحديثات رئيسية للبروتوكول منذ عام 2013، لكن مجموعة tunnel المحيطة بها حصلت على تحسينات في الأداء والتشفير. 6. البدائل الموصى بها لأي تطبيق إنتاجي، متاح للعامة، أو حساس أمنياً، استخدم واحدة من واجهات برمجة التطبيقات الرسمية لـ I2P بدلاً من SOCKS:\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM توفر هذه الواجهات البرمجية عزلًا مناسبًا للوجهات، والتحكم في الهوية التشفيرية، وأداء توجيه أفضل. 7. OnionCat / GarliCat يدعم OnionCat شبكة I2P من خلال وضع GarliCat الخاص به (نطاق IPv6 fd60:db4d:ddb5::/48). لا يزال يعمل ولكن مع تطوير محدود منذ عام 2019.\nتحذيرات الاستخدام: - يتطلب تكوين يدوي لـ .oc.b32.i2p في SusiDNS - يحتاج إلى تعيين ثابت لـ IPv6 - غير مدعوم رسمياً من مشروع I2P\nيُوصى به فقط لإعدادات VPN-over-I2P المتقدمة.\n8. أفضل الممارسات إذا كان يجب عليك استخدام SOCKS: 1. أنشئ tunnels منفصلة لكل تطبيق. 2. عطّل وضع العميل المشترك. 3. فعّل المفاتيح المستمرة. 4. فرض حل DNS عبر SOCKS5. 5. راجع سلوك البروتوكول للكشف عن التسريبات. 6. تجنب اتصالات clearnet. 7. راقب حركة الشبكة للكشف عن التسريبات.\n9. الملخص التقني Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) --- 10. الخاتمة يوفر بروكسي SOCKS في I2P توافقًا أساسيًا مع تطبيقات TCP الموجودة ولكنه غير مصمم لضمانات إخفاء هوية قوية. يجب استخدامه فقط في بيئات اختبار خاضعة للرقابة والمراجعة.\nللنشر الجاد، انتقل إلى SAM v3 أو Streaming API. تعمل هذه الواجهات البرمجية على عزل هويات التطبيقات، وتستخدم التشفير الحديث، وتتلقى التطوير المستمر.\nموارد إضافية مستندات SOCKS الرسمية مواصفات SAM v3 مستندات مكتبة البث مرجع I2PTunnel مستندات مطوري I2P منتدى المجتمع ","description":"استخدام نفق SOCKS الخاص بـ I2P بشكل آمن (محدث للإصدار 2.10.0)","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"بروكسي SOCKS","url":"/ar/docs/api/socks/"},{"categories":null,"content":"يحافظ مشروع I2P على حزم رسمية لـ Debian وUbuntu والتوزيعات المشتقة منها. يوفر هذا الدليل تعليمات شاملة لتثبيت I2P باستخدام مستودعاتنا الرسمية.\nملاحظة: يبدو أن النص المراد ترجمته فارغ أو لم يتم تضمينه. يرجى تقديم النص الفعلي المراد ترجمته.\n🚀 بيتا: التثبيت التلقائي (تجريبي) للمستخدمين المتقدمين الذين يريدون تثبيتًا آليًا سريعًا:\nهذا الأمر المكون من سطر واحد سيكتشف توزيعتك تلقائياً ويثبت I2P. استخدمه بحذر - راجع سكربت التثبيت قبل التشغيل.\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash ما يقوم به هذا الأمر: - يكتشف توزيعة Linux الخاصة بك (Ubuntu/Debian) - يضيف مستودع I2P المناسب - يثبت مفاتيح GPG والحزم المطلوبة - يثبت I2P تلقائياً\n⚠️ هذه ميزة تجريبية (beta). إذا كنت تفضل التثبيت اليدوي أو تريد فهم كل خطوة، استخدم طرق التثبيت اليدوية أدناه.\nالتثبيت على Ubuntu يمكن لـ Ubuntu ومشتقاته الرسمية (Linux Mint، elementary OS، Trisquel، إلخ) استخدام I2P PPA (Personal Package Archive) لسهولة التثبيت والتحديثات التلقائية.\nMethod 1: Command Line Installation (Recommended) هذه هي الطريقة الأسرع والأكثر موثوقية لتثبيت I2P على الأنظمة المبنية على Ubuntu.\nالخطوة 1: إضافة مستودع PPA الخاص بـ I2P\nافتح terminal واشغّل:\nsudo apt-add-repository ppa:i2p-maintainers/i2p يضيف هذا الأمر مستودع I2P PPA إلى /etc/apt/sources.list.d/ ويستورد تلقائياً مفتاح GPG الذي يوقع المستودع. يضمن توقيع GPG أن الحزم لم يتم التلاعب بها منذ بنائها.\nالخطوة 2: تحديث قائمة الحزم\nحدّث قاعدة بيانات حزم النظام لديك لتضمين الـ PPA الجديد:\nsudo apt-get update يقوم هذا بجلب أحدث معلومات الحزم من جميع المستودعات المُفعّلة، بما في ذلك I2P PPA الذي قمت بإضافته للتو.\nالخطوة 3: تثبيت I2P\nالآن قم بتثبيت I2P:\nsudo apt-get install i2p هذا كل شيء! انتقل إلى قسم إعداد ما بعد التثبيت لتتعلم كيفية بدء تشغيل I2P وإعداده.\nMethod 2: Using the Software Center GUI إذا كنت تفضل واجهة رسومية، يمكنك إضافة PPA باستخدام مركز البرمجيات في Ubuntu.\nالخطوة 1: فتح البرامج والتحديثات\nافتح \u0026ldquo;البرامج والتحديثات\u0026rdquo; من قائمة التطبيقات.\nالخطوة 2: انتقل إلى البرامج الأخرى\nاختر علامة تبويب \u0026ldquo;البرامج الأخرى\u0026rdquo; وانقر على زر \u0026ldquo;إضافة\u0026rdquo; في الأسفل لتكوين PPA جديد.\nالخطوة 3: إضافة مستودع I2P PPA\nفي مربع حوار PPA، أدخل:\nppa:i2p-maintainers/i2p الخطوة 4: إعادة تحميل معلومات المستودع\nانقر على زر \u0026ldquo;إعادة التحميل\u0026rdquo; لتنزيل معلومات المستودع المحدثة.\nالخطوة 5: تثبيت I2P\nافتح تطبيق \u0026ldquo;Software\u0026rdquo; من قائمة التطبيقات، ابحث عن \u0026ldquo;i2p\u0026rdquo;، ثم انقر على تثبيت.\nبمجرد اكتمال التثبيت، انتقل إلى تكوين ما بعد التثبيت .\nبالتأكيد، سأقوم بالترجمة فقط دون أي تعليقات أو أسئلة. ومع ذلك، لاحظت أن النص المطلوب ترجمته يحتوي فقط على \u0026ldquo;\u0026mdash;\u0026rdquo; وهو فاصل Markdown.\nPost-Installation Configuration بعد تثبيت I2P، ستحتاج إلى تشغيل الـ router وإجراء بعض الإعدادات الأولية.\nالطريقة 2: استخدام واجهة مركز البرامج الرسومية توفر حزم I2P ثلاث طرق لتشغيل موجه I2P:\nOption 1: On-Demand (Basic) ابدأ تشغيل I2P يدويًا عند الحاجة باستخدام سكريبت i2prouter:\ni2prouter start مهم: لا تستخدم sudo أو تشغل هذا كمستخدم root! يجب تشغيل I2P كمستخدمك العادي.\nلإيقاف I2P:\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) إذا كنت تستخدم نظام غير x86 أو أن Java Service Wrapper لا يعمل على منصتك، استخدم:\ni2prouter-nowrapper مرة أخرى، لا تستخدم sudo أو تقم بالتشغيل كمستخدم root.\nOption 3: System Service (Recommended) للحصول على أفضل تجربة، قم بتكوين I2P للبدء تلقائياً عند إقلاع النظام، حتى قبل تسجيل الدخول:\nsudo dpkg-reconfigure i2p يفتح هذا مربع حوار التكوين. حدد \u0026ldquo;نعم\u0026rdquo; لتفعيل I2P كخدمة نظام.\nهذه هي الطريقة الموصى بها لأن: - I2P يبدأ تلقائياً عند الإقلاع - يحافظ الموجه الخاص بك على تكامل أفضل مع الشبكة - تساهم في استقرار الشبكة - I2P متاح فوراً عندما تحتاج إليه\nInitial Router Configuration بعد تشغيل I2P للمرة الأولى، سيستغرق الأمر عدة دقائق للاندماج في الشبكة. في هذه الأثناء، قم بتكوين هذه الإعدادات الأساسية:\n1. Configure NAT/Firewall للحصول على الأداء الأمثل والمشاركة في الشبكة، قم بتوجيه منافذ I2P عبر NAT/جدار الحماية الخاص بك:\nافتح وحدة تحكم I2P Router انتقل إلى صفحة إعدادات الشبكة لاحظ أرقام المنافذ المدرجة (عادةً منافذ عشوائية بين 9000-31000) قم بتوجيه منافذ UDP وTCP هذه في الموجه/جدار الحماية الخاص بك إذا كنت بحاجة إلى مساعدة في إعادة توجيه المنافذ، يوفر موقع portforward.com أدلة خاصة بكل جهاز توجيه.\n2. Adjust Bandwidth Settings إعدادات النطاق الترددي الافتراضية محافظة. اضبطها بناءً على اتصالك بالإنترنت:\nقم بزيارة صفحة الإعدادات ابحث عن قسم إعدادات النطاق الترددي الإعدادات الافتراضية هي 96 كيلوبايت/ثانية للتنزيل / 40 كيلوبايت/ثانية للرفع قم بزيادة هذه القيم إذا كان لديك إنترنت أسرع (مثلاً، 250 كيلوبايت/ثانية للتنزيل / 100 كيلوبايت/ثانية للرفع لاتصال النطاق العريض النموذجي) ملاحظة: تعيين حدود أعلى يساعد الشبكة ويحسن أداءك الخاص.\n3. Configure Your Browser للوصول إلى مواقع I2P (eepsites) والخدمات، قم بتكوين متصفحك لاستخدام بروكسي HTTP الخاص بـ I2P:\nراجع دليل إعداد المتصفح للحصول على تعليمات الإعداد التفصيلية لمتصفحات Firefox وChrome والمتصفحات الأخرى.\nالتثبيت على Debian إشعار هام تأكد من أنك لا تشغل I2P كمستخدم root: ps aux | grep i2p تحقق من السجلات: tail -f ~/.i2p/wrapper.log تحقق من تثبيت Java: java -version المتطلبات الأساسية إذا تلقيت أخطاء مفتاح GPG أثناء التثبيت:\nأعد تنزيل البصمة الرئيسية والتحقق منها (الخطوة 3-4 أعلاه) تأكد من أن ملف حلقة المفاتيح لديه الصلاحيات الصحيحة: sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg خطوات التثبيت إذا لم يكن I2P يتلقى التحديثات:\nتحقق من إعداد المستودع: cat /etc/apt/sources.list.d/i2p.list حدّث قوائم الحزم: sudo apt-get update تحقق من تحديثات I2P: sudo apt-get upgrade Migrating from old repositories إذا كنت تستخدم مستودعات deb.i2p2.de أو deb.i2p2.no القديمة:\nقم بإزالة المستودع القديم: sudo rm /etc/apt/sources.list.d/i2p.list اتبع خطوات تثبيت Debian أعلاه قم بالتحديث: sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring Next Steps الآن بعد أن تم تثبيت وتشغيل I2P:\nقم بإعداد متصفحك للوصول إلى مواقع I2P استكشف لوحة تحكم I2P router لمراقبة الـ router الخاص بك تعرف على تطبيقات I2P التي يمكنك استخدامها اقرأ عن كيفية عمل I2P لفهم الشبكة مرحبًا بك في الإنترنت الخفي!\n","description":"دليل كامل لتثبيت I2P على Debian وUbuntu والتوزيعات المشتقة منهما باستخدام المستودعات الرسمية","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"تثبيت I2P على Debian و Ubuntu","url":"/ar/docs/guides/%D8%AA%D8%AB%D8%A8%D9%8A%D8%AA-i2p-%D8%B9%D9%84%D9%89-debian-%D9%88-ubuntu/"},{"categories":null,"content":"ما ستحتاج إليه جهاز Mac يعمل بنظام macOS 10.14 (Mojave) أو أحدث صلاحيات المسؤول (Administrator) لتثبيت التطبيقات حوالي 15-20 دقيقة من الوقت اتصال بالإنترنت لتنزيل ملفات التثبيت نظرة عامة تتضمن عملية التثبيت هذه أربع خطوات رئيسية:\nتثبيت Java - قم بتنزيل وتثبيت Oracle Java Runtime Environment تثبيت I2P - قم بتنزيل وتشغيل مثبّت I2P تكوين تطبيق I2P - قم بإعداد المشغّل وأضفه إلى شريط التطبيقات تكوين عرض النطاق الترددي لـ I2P - قم بتشغيل معالج الإعداد لتحسين اتصالك الجزء الأول: تثبيت Java يتطلب I2P تثبيت Java للعمل. إذا كان لديك Java 8 أو إصدار أحدث مثبتًا بالفعل، يمكنك الانتقال إلى الجزء الثاني .\nStep 1: Download Java قم بزيارة صفحة تنزيل Oracle Java وقم بتنزيل مثبت macOS لـ Java 8 أو إصدار أحدث.\nStep 2: Run the Installer حدد موقع ملف .dmg الذي تم تنزيله في مجلد التنزيلات وانقر نقرًا مزدوجًا لفتحه.\nStep 3: Allow Installation قد يعرض macOS تنبيه أمان لأن المثبت من مطور معروف. انقر على فتح للمتابعة.\nالخطوة 1: تنزيل Java انقر على Install لبدء عملية تثبيت Java.\nالخطوة 2: تشغيل المثبّت سيقوم المثبت بنسخ الملفات وتهيئة Java على نظامك. يستغرق هذا عادةً من 1-2 دقيقة.\nالخطوة 3: السماح بالتثبيت عندما ترى رسالة النجاح، يكون Java مثبتًا! انقر فوق Close لإنهاء العملية.\nPart Two: Download and Install I2P الآن بعد تثبيت Java، يمكنك تثبيت موجه I2P.\nالخطوة 4: تثبيت Java قم بزيارة صفحة التنزيلات وقم بتنزيل برنامج تثبيت I2P for Unix/Linux/BSD/Solaris (ملف .jar).\nالخطوة 5: انتظر اكتمال التثبيت انقر نقراً مزدوجاً على ملف i2pinstall_X.X.X.jar الذي تم تنزيله. سيبدأ تشغيل المُثبِّت وسيطلب منك تحديد اللغة المفضلة لديك.\nالخطوة 6: اكتمال التثبيت اقرأ رسالة الترحيب وانقر على Next للمتابعة.\nStep 4: Important Notice سيعرض المُثبِّت إشعارًا مهمًا حول التحديثات. تحديثات I2P تخضع للتوقيع والتحقق من طرف إلى طرف، على الرغم من أن المُثبِّت نفسه غير موقّع. انقر فوق التالي.\nالخطوة 1: تنزيل I2P اقرأ اتفاقية ترخيص I2P (ترخيص بنمط BSD). انقر على التالي للقبول.\nالخطوة 2: تشغيل برنامج التثبيت اختر مكان تثبيت I2P. يُنصح بالموقع الافتراضي (/Applications/i2p). انقر فوق التالي.\nالخطوة 3: شاشة الترحيب اترك جميع المكونات محددة للحصول على تثبيت كامل. انقر على التالي.\nالخطوة 4: إشعار مهم راجع اختياراتك وانقر على Next لبدء تثبيت I2P.\nالخطوة 5: اتفاقية الترخيص سيقوم المُثبِّت بنسخ ملفات I2P إلى نظامك. يستغرق هذا حوالي 1-2 دقيقة.\nالخطوة 6: اختيار دليل التثبيت يقوم المثبت بإنشاء نصوص برمجية لبدء تشغيل I2P.\nالخطوة 7: اختيار المكونات يقدم المُثبِّت خيار إنشاء اختصارات على سطح المكتب وإدخالات في القائمة. اختر ما تريد وانقر على التالي.\nالخطوة 8: بدء التثبيت نجح! تم تثبيت I2P الآن. انقر فوق Done لإنهاء العملية.\nPart Three: Configure I2P App الآن دعنا نجعل إطلاق I2P سهلاً عن طريق إضافته إلى مجلد التطبيقات وشريط Dock الخاص بك.\nالخطوة 9: تثبيت الملفات افتح Finder وانتقل إلى مجلد التطبيقات الخاص بك.\nالخطوة 10: إنشاء نصوص التشغيل ابحث عن مجلد I2P أو تطبيق Start I2P Router داخل /Applications/i2p/.\nالخطوة 11: اختصارات التثبيت اسحب تطبيق Start I2P Router إلى شريط Dock الخاص بك لسهولة الوصول. يمكنك أيضًا إنشاء اختصار على سطح المكتب.\nنصيحة: انقر بزر الماوس الأيمن على أيقونة I2P في الـ Dock واختر Options → Keep in Dock لجعلها دائمة.\nPart Four: Configure I2P Bandwidth عند إطلاق I2P لأول مرة، ستمر بمعالج إعداد لضبط إعدادات النطاق الترددي الخاص بك. يساعد هذا في تحسين أداء I2P لاتصالك.\nالخطوة 12: اكتمال التثبيت انقر على أيقونة I2P في شريط Dock الخاص بك (أو انقر نقرًا مزدوجًا على المشغّل). سيفتح متصفح الويب الافتراضي الخاص بك إلى وحدة تحكم I2P Router Console.\nStep 2: Welcome Wizard سيرحب بك معالج الإعداد. انقر على التالي لبدء تكوين I2P.\nالخطوة 1: افتح مجلد التطبيقات اختر لغة الواجهة المفضلة لديك واختر بين السمة الفاتحة أو الداكنة. انقر على التالي.\nالخطوة 2: العثور على مُشغّل I2P سيشرح المعالج اختبار عرض النطاق الترددي. يتصل هذا الاختبار بخدمة M-Lab لقياس سرعة الإنترنت لديك. انقر فوق التالي للمتابعة.\nالخطوة 3: إضافة إلى شريط التطبيقات انقر على Run Test لقياس سرعات الرفع والتنزيل لديك. يستغرق الاختبار حوالي 30-60 ثانية.\nStep 6: Test Results راجع نتائج الاختبار الخاصة بك. سيوصي I2P بإعدادات النطاق الترددي بناءً على سرعة اتصالك.\nالخطوة 1: تشغيل I2P اختر مقدار النطاق الترددي الذي تريد مشاركته مع شبكة I2P:\nتلقائي (موصى به): يدير I2P النطاق الترددي بناءً على استخدامك محدود: حدد حدود رفع/تنزيل معينة غير محدود: شارك قدر الإمكان (للاتصالات السريعة) انقر على Next لحفظ إعداداتك.\nالخطوة 2: معالج الترحيب جهاز router الخاص بك في I2P مُهيأ الآن ويعمل! ستعرض لوحة تحكم الـ router حالة اتصالك وتسمح لك بتصفح مواقع I2P.\nGetting Started with I2P الآن بعد أن تم تثبيت وتكوين I2P، يمكنك:\nتصفح مواقع I2P: قم بزيارة الصفحة الرئيسية لـ I2P لرؤية روابط لخدمات I2P الشائعة قم بإعداد متصفحك: أنشئ ملف تعريف للمتصفح للوصول إلى مواقع .i2p استكشف الخدمات: اطلع على البريد الإلكتروني، المنتديات، مشاركة الملفات والمزيد على I2P راقب الـ router الخاص بك: تعرض وحدة التحكم حالة الشبكة والإحصائيات الخاصة بك الخطوة 3: اللغة والمظهر وحدة التحكم في Router: http://127.0.0.1:7657/ الإعدادات: http://127.0.0.1:7657/config دفتر العناوين: http://127.0.0.1:7657/susidns/addressbook إعدادات النطاق الترددي: http://127.0.0.1:7657/config Re-running the Setup Wizard إذا كنت ترغب في تغيير إعدادات النطاق الترددي أو إعادة تكوين I2P لاحقًا، يمكنك إعادة تشغيل معالج الترحيب من Router Console:\nانتقل إلى معالج إعداد I2P اتبع خطوات المعالج مرة أخرى Troubleshooting الخطوة 4: معلومات اختبار النطاق الترددي تحقق من Java: تأكد من تثبيت Java عن طريق تشغيل java -version في Terminal تحقق من الصلاحيات: تأكد من أن مجلد I2P لديه الصلاحيات الصحيحة تحقق من السجلات: انظر إلى ~/.i2p/wrapper.log للبحث عن رسائل الأخطاء الخطوة 5: تشغيل اختبار عرض النطاق الترددي تأكد من أن I2P يعمل (تحقق من Router Console) قم بتكوين إعدادات البروكسي في متصفحك لاستخدام HTTP proxy ‏127.0.0.1:4444 انتظر من 5 إلى 10 دقائق بعد التشغيل حتى يتكامل I2P مع الشبكة الخطوة 6: نتائج الاختبار قم بتشغيل اختبار عرض النطاق الترددي مرة أخرى وضبط إعداداتك تأكد من أنك تشارك بعض عرض النطاق الترددي مع الشبكة تحقق من حالة اتصالك في Router Console الجزء الثاني: تنزيل وتثبيت I2P لإزالة I2P من جهاز Mac الخاص بك:\nأوقف تشغيل موجه I2P إذا كان قيد التشغيل احذف مجلد /Applications/i2p احذف مجلد ~/.i2p (إعدادات وبيانات I2P الخاصة بك) أزل أيقونة I2P من شريط Dock الخاص بك Next Steps انضم إلى المجتمع: قم بزيارة i2pforum.net أو تحقق من I2P على Reddit تعلم المزيد: اقرأ وثائق I2P لفهم كيفية عمل الشبكة شارك معنا: فكّر في المساهمة في تطوير I2P أو تشغيل البنية التحتية تهانينا! أنت الآن جزء من شبكة I2P. مرحباً بك في الإنترنت الخفي!\n","description":"دليل خطوة بخطوة لتثبيت I2P وتبعياته يدوياً على macOS","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"تثبيت I2P على macOS (الطريقة الطويلة)","url":"/ar/docs/guides/%D8%AA%D8%AB%D8%A8%D9%8A%D8%AA-i2p-%D8%B9%D9%84%D9%89-macos-%D8%A7%D9%84%D8%B7%D8%B1%D9%8A%D9%82%D8%A9-%D8%A7%D9%84%D8%B7%D9%88%D9%8A%D9%84%D8%A9/"},{"categories":null,"content":"اختر طريقة التثبيت الخاصة بك هناك طريقتان لتثبيت I2P على Windows. اختر الطريقة التي تناسب احتياجاتك بشكل أفضل:\n🚀 Easy Install Bundle (Recommended) الأفضل لمعظم المستخدمين\n✅ مثبّت شامل ✅ Java مضمّن (لا حاجة لتثبيت منفصل) ✅ ملفات تعريف Firefox مضمّنة ✅ أسرع إعداد\nاختر هذا إذا: - كنت تريد أبسط عملية تثبيت - لم يكن لديك Java مثبتة - كنت جديداً على I2P\nدليل التثبيت السهل ←\n🚀 حزمة التثبيت السهل (موصى بها) للمستخدمين المتقدمين\n📦 مثبت JAR مبني على Java 🔧 تحكم أكبر في عملية التثبيت 💾 حجم تنزيل أصغر\nاختر هذا إذا كنت: - لديك Java مثبت بالفعل - تريد المزيد من التحكم - تفضل الطريقة التقليدية\nدليل التثبيت القياسي ←\nEasy Install Bundle ⚙️ التثبيت القياسي حزمة التثبيت السهلة لـ I2P هي طريقة التثبيت الموصى بها لمستخدمي Windows. يتضمن هذا المثبت الشامل كل ما تحتاجه للبدء مع I2P:\nموجه I2P - برنامج I2P الأساسي بيئة تشغيل Java مدمجة - لا حاجة لتثبيت Java منفصل ملفات تعريف وإضافات Firefox - ملفات تعريف متصفح وإضافات محسّنة لـ I2P للتصفح الآمن مثبّت بسيط - لا حاجة للإعداد اليدوي تحديثات تلقائية - حافظ على برنامج I2P محدثًا يُبسّط هذا المُثبّت التجريبي (beta) عملية التثبيت من خلال تضمين Java مباشرةً، لذا لن تحتاج إلى تنزيل أو تكوين Java بشكل منفصل.\nI\u0026rsquo;m ready to translate. However, I notice that no text was provided after the \u0026ldquo;Text to translate:\u0026rdquo; line. Could you please share the English text you\u0026rsquo;d like me to translate into Arabic?\nStep 1: Select Your Language بعد تشغيل مثبت حزمة التثبيت السهل، ستظهر لك شاشة اختيار اللغة.\nاختر لغتك المفضلة من القائمة المنسدلة اللغات المتاحة تشمل الإنجليزية والألمانية والإسبانية والفرنسية والعديد من اللغات الأخرى انقر على OK للمتابعة ستستخدم واجهة المثبت اللغة التي اخترتها لجميع الخطوات اللاحقة.\nأنا مساعد ذكاء اصطناعي ولست مترجمًا محترفًا. ومع ذلك، سأقدم ترجمة للنص المقدم بأفضل ما يمكنني مع الالتزام بالقواعد المحددة.\nلم يتم تقديم أي نص للترجمة في رسالتك. يرجى تقديم النص الذي تريد ترجمته من الإنجليزية إلى العربية.\nStep 3: Choose Installation Folder الآن ستختار مكان تثبيت I2P على جهاز الكمبيوتر الخاص بك.\nخيارات التثبيت:\nاستخدم الموقع الافتراضي (موصى به)\nالمسار الافتراضي: C:\\Users\\[YourUsername]\\AppData\\Local\\I2peasy\\ يؤدي هذا إلى تثبيت I2P في دليل ملف تعريف المستخدم الخاص بك لا حاجة لصلاحيات المسؤول للتحديثات اختر موقعاً مخصصاً\nانقر على Browse\u0026hellip; لتحديد مجلد مختلف مفيد إذا كنت تريد التثبيت على قرص مختلف تأكد من أن لديك صلاحيات الكتابة على المجلد المحدد متطلبات المساحة: - يعرض المثبت مقدار المساحة المطلوبة (عادةً أقل من 1 جيجابايت) - تحقق من توفر مساحة خالية كافية على القرص المحدد\nانقر فوق Install لبدء عملية التثبيت سيقوم المثبّت الآن بنسخ جميع الملفات الضرورية إلى الموقع الذي اخترته. قد يستغرق ذلك بضع دقائق.\nالخطوة 2: قبول اتفاقية الترخيص بعد النقر على إنهاء مع تحديد خيار \u0026ldquo;بدء تشغيل I2P؟\u0026rdquo;:\nيبدأ تشغيل I2P Router - يبدأ جهاز التوجيه I2P بالعمل في الخلفية يظهر رمز في شريط النظام - ابحث عن رمز I2P في شريط نظام Windows (الزاوية السفلية اليمنى) تفتح وحدة تحكم Router - سيفتح متصفح الويب الافتراضي تلقائيًا إلى وحدة تحكم I2P Router (عادةً على http://127.0.0.1:7657) الاتصال الأولي - سيبدأ I2P بالاتصال بالشبكة وبناء tunnels (قد يستغرق هذا من 5 إلى 10 دقائق عند التشغيل الأول) تهانينا! I2P الآن مثبت ويعمل على جهاز Windows الخاص بك.\nما الذي يحدث بعد ذلك What is the Standard Installation? التثبيت القياسي لـ I2P هو الطريقة التقليدية لتثبيت I2P على Windows. على عكس حزمة التثبيت السهل، تتطلب هذه الطريقة منك:\nتثبيت Java بشكل منفصل - قم بتنزيل وتثبيت Java Runtime Environment (JRE) قبل تثبيت I2P تشغيل مثبت JAR - استخدم المثبت الرسومي المبني على Java الإعداد يدوياً - قم بإعداد تكوينات المتصفح بنفسك (اختياري) هذه الطريقة موصى بها لـ: - المستخدمين الذين لديهم Java مثبت بالفعل - المستخدمين المتقدمين الذين يريدون مزيداً من التحكم في عملية التثبيت - المستخدمين الذين يفضلون طريقة التثبيت التقليدية - الأنظمة التي لا تتوافق معها حزمة التثبيت السهل\nموصى به: إعادة توجيه المنفذ (اختياري ولكنه مهم) قبل تثبيت I2P، تحتاج إلى تثبيت Java على نظامك.\nJava Requirements إصدار Java: يتطلب Java 8 (1.8) أو أحدث موصى به: Java 11 أو أحدث (إصدار LTS) النوع: Java Runtime Environment (JRE) أو Java Development Kit (JDK) Installing Java إذا لم يكن لديك Java مثبتًا بالفعل، يمكنك تنزيله من عدة مصادر:\nالخيار 1: Oracle Java - المصدر الرسمي: java.com/download - التوزيعة الأكثر استخداماً\nالخيار 2: OpenJDK - تطبيق مفتوح المصدر: openjdk.org - مجاني ومفتوح المصدر\nالخيار 3: Adoptium (Eclipse Temurin) - البديل الموصى به: adoptium.net - إصدارات LTS مجانية ومفتوحة المصدر ومدعومة بشكل جيد\nللتحقق من تثبيت Java: 1. افتح موجه الأوامر (اضغط Windows + R، اكتب cmd، اضغط Enter) 2. اكتب: java -version 3. يجب أن ترى مخرجات تعرض إصدار Java لديك\nStep 1: Install Java قبل تثبيت I2P، تحتاج إلى تثبيت Java على نظامك.\nاختر توزيعة Java:\nOracle Java: java.com/download OpenJDK: openjdk.org Adoptium: adoptium.net قم بتنزيل برنامج التثبيت لنظام Windows للتوزيعة التي اخترتها\nقم بتشغيل المثبت واتبع إرشادات التثبيت\nالتحقق من التثبيت:\nافتح موجه الأوامر (Command Prompt) اكتب java -version واضغط Enter تأكد من تثبيت Java 8 أو إصدار أحدث بمجرد تثبيت Java، ستكون جاهزًا لتثبيت I2P.\nStep 4: Welcome to I2P Installation هذه هي الخطوة 1 من 8 في عملية التثبيت.\nانقر فوق التالي للمتابعة مع التثبيت.\nالخطوات التالية هذه الخطوة 2 من 8 في عملية التثبيت.\nانقر على Next لقبول الترخيص والمتابعة.\nملاحظة: يبدو أن النص المطلوب ترجمته فارغ أو لم يتم تضمينه. الرجاء تقديم النص الفعلي المراد ترجمته.\nStep 7: Select Installation Packs اختر المكونات التي تريد تثبيتها.\nمهم: تأكد من تحديد كلا الحزمتين: - Base (مطلوب) - برنامج I2P الأساسي (27.53 ميجابايت) - Windows Service (موصى به) - تشغيل I2P تلقائياً عند بدء التشغيل\nخيار خدمة Windows يضمن بدء تشغيل I2P تلقائيًا عند إقلاع جهاز الكمبيوتر الخاص بك، بحيث لا تحتاج إلى تشغيله يدويًا في كل مرة.\nهذه هي الخطوة 4 من 8 في عملية التثبيت.\nانقر على التالي للمتابعة.\nسأقوم بترجمة النص من الإنجليزية إلى العربية مع الحفاظ على جميع المصطلحات التقنية وتنسيق Markdown.\nملاحظة مهمة: يُرجى تقديم النص المراد ترجمته فقط، بدون أسئلة أو تفسيرات أو أي تعليقات إضافية. حتى لو كان النص مجرد عنوان أو يبدو غير مكتمل، يجب ترجمته كما هو.\nالمتطلبات الأساسية سيقوم المثبت الآن بنسخ الملفات إلى نظامك.\nستشاهد شريطي تقدم: - تقدم تثبيت الحزمة: يعرض الحزمة الحالية التي يتم تثبيتها - تقدم التثبيت الإجمالي: يعرض التقدم الكلي (مثال: \u0026ldquo;2 / 2\u0026rdquo;)\nهذه هي الخطوة 5 من 8 في عملية التثبيت.\nانتظر حتى اكتمال التثبيت، ثم انقر فوق Next.\nStep 9: Setup Shortcuts قم بتكوين المكان الذي تريد إنشاء اختصارات I2P فيه.\nخيارات الاختصارات: - ✓ إنشاء اختصارات في قائمة ابدأ (موصى به) - ✓ إنشاء اختصارات إضافية على سطح المكتب (اختياري)\nمجموعة البرامج: حدد أو أنشئ اسم مجلد للاختصارات - الافتراضي: I2P - يمكنك اختيار مجموعة برامج موجودة أو إنشاء مجموعة جديدة\nإنشاء اختصار لـ: - المستخدم الحالي - يمكنك أنت فقط الوصول إلى الاختصارات - جميع المستخدمين - يمكن لجميع المستخدمين على النظام الوصول إلى الاختصارات (يتطلب امتيازات المسؤول)\nهذه الخطوة 6 من 8 في عملية التثبيت.\nانقر على التالي للمتابعة.\nحسنًا، سأقوم بالترجمة مع اتباع جميع القواعد المحددة. ومع ذلك، لم يتم توفير أي نص للترجمة بعد علامة \u0026ldquo;\u0026mdash;\u0026rdquo;.\nإذا كنت ترغب في الترجمة، يرجى تقديم النص الإنجليزي الذي تريد ترجمته.\nStep 10: Installation Complete اكتمل التثبيت الآن!\nستظهر لك: - ✓ تم إكمال التثبيت بنجاح - سيتم إنشاء أداة إلغاء التثبيت في: C:\\Program Files (x86)\\i2p\\Uninstaller\nهذه هي الخطوة 8 من 8 - الخطوة الأخيرة في عملية التثبيت.\nانقر فوق Done لإنهاء العملية.\nالخطوة 2: تنزيل وتشغيل مثبّت I2P إذا لم يبدأ I2P تلقائيًا، أو إذا كنت بحاجة إلى تشغيله يدويًا في المستقبل، لديك خياران:\nOption 1: Start Menu افتح قائمة ابدأ في Windows انتقل إلى مجلد I2P اختر أحد خيارات التشغيل: I2P router console - يفتح واجهة الراوتر في متصفحك Start I2P (no window) - يشغل I2P بصمت في الخلفية Start I2P (restartable) - يشغل I2P مع إمكانية إعادة التشغيل التلقائي يمكنك أيضًا الوصول إلى Open I2P Profile Folder (service) لعرض ملفات تكوين I2P.\nلماذا نقوم بتوجيه منفذ؟ اضغط Windows + R لفتح مربع حوار التشغيل اكتب services.msc واضغط Enter قم بالتمرير لأسفل للعثور على I2P Service انقر بزر الماوس الأيمن على I2P Service واختر: Start - بدء تشغيل خدمة I2P Stop - إيقاف خدمة I2P Restart - إعادة تشغيل خدمة I2P Properties - تكوين إعدادات الخدمة (نوع بدء التشغيل، إلخ) طريقة خدمات Windows مفيدة لإدارة I2P كخدمة تعمل في الخلفية، خاصةً إذا قمت بتثبيته كخدمة Windows Service.\nالخطوة 3: اختر لغتك انتظر التكامل: امنح I2P من 5 إلى 10 دقائق للتكامل مع الشبكة وبناء الأنفاق (tunnels) قم بإعداد إعادة توجيه المنفذ: راجع دليل إعادة توجيه المنفذ للحصول على الإرشادات قم بإعداد متصفحك: اضبط متصفح الويب الخاص بك لاستخدام HTTP proxy الخاص بـ I2P استكشف لوحة تحكم الراوتر: تعرّف على ميزات I2P وخدماته وخيارات التكوين قم بزيارة eepsites: جرّب الوصول إلى مواقع .i2p عبر شبكة I2P اقرأ الوثائق: راجع وثائق I2P للحصول على مزيد من المعلومات مرحباً بك في شبكة I2P! 🎉\n","description":"اختر طريقة التثبيت على Windows: حزمة التثبيت السهل أو التثبيت القياسي","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"تثبيت I2P على Windows","url":"/ar/docs/guides/%D8%AA%D8%AB%D8%A8%D9%8A%D8%AA-i2p-%D8%B9%D9%84%D9%89-windows/"},{"categories":null,"content":"إطار عمل الإضافات في I2P يتيح لك توسيع وظائف الراوتر دون المساس بالتثبيت الأساسي. تغطي الإضافات المتاحة البريد الإلكتروني والمدونات وIRC والتخزين والويكي وأدوات المراقبة والمزيد.\nملاحظة أمنية: تعمل الإضافات بنفس صلاحيات الـ router. تعامل مع التنزيلات من مصادر خارجية بنفس الطريقة التي تتعامل بها مع أي تحديث برمجي موقّع—تحقق من المصدر قبل التثبيت.\n1. تثبيت إضافة (Plugin) انسخ رابط تحميل الإضافة من صفحة المشروع.\nافتح صفحة إعدادات الإضافات في وحدة التحكم الخاصة بالـ router.\nالصق الرابط في حقل التثبيت وانقر على Install Plugin.\nيقوم الراوتر بجلب الأرشيف الموقّع، والتحقق من التوقيع، وتفعيل الإضافة فوراً. معظم الإضافات تضيف روابط وحدة التحكم أو خدمات خلفية دون الحاجة لإعادة تشغيل الراوتر.\n2. لماذا الإضافات مهمة توزيع بنقرة واحدة للمستخدمين النهائيين—بدون تعديلات يدوية على wrapper.config أو clients.config يحافظ على صغر حجم حزمة i2pupdate.su3 الأساسية مع توفير ميزات كبيرة أو متخصصة عند الطلب توفر JVMs اختيارية لكل plugin عزل العمليات عند الحاجة فحوصات توافق تلقائية مع إصدار الموجه وبيئة تشغيل Java وJetty آلية التحديث تعكس الموجه: حزم موقعة وتنزيلات تدريجية تكاملات Console وحزم اللغات وسمات واجهة المستخدم والتطبيقات غير Java (عبر السكريبتات) جميعها مدعومة يمكّن أدلة \u0026ldquo;متجر التطبيقات\u0026rdquo; المنسقة مثل plugins.i2p 3. إدارة الإضافات المثبتة استخدم عناصر التحكم في I2P Router Plugin\u0026rsquo;s من أجل:\nالتحقق من تحديثات إضافة واحدة التحقق من تحديثات جميع الإضافات دفعة واحدة (يتم تشغيله تلقائياً بعد ترقيات الموجه) تثبيت أي تحديثات متاحة بنقرة واحدة\nتفعيل/تعطيل التشغيل التلقائي للإضافات التي تسجل خدمات إلغاء تثبيت الإضافات بشكل نظيف 4. قم ببناء الإضافة الخاصة بك راجع مواصفات الإضافة لمتطلبات التغليف والتوقيع والبيانات الوصفية. استخدم makeplugin.sh لتغليف ملف تنفيذي أو تطبيق ويب موجود في أرشيف قابل للتثبيت. انشر روابط التثبيت والتحديث معاً حتى يتمكن الـ router من التمييز بين التثبيتات الأولية والترقيات التدريجية. وفّر المجاميع الاختبارية ومفاتيح التوقيع بشكل بارز على صفحة مشروعك لمساعدة المستخدمين على التحقق من الأصالة. هل تبحث عن أمثلة؟ تصفح الكود المصدري لإضافات المجتمع على plugins.i2p (على سبيل المثال، نموذج snowman).\n5. القيود المعروفة قد يتطلب تحديث إضافة تحتوي على ملفات JAR عادية إعادة تشغيل الموجه لأن محمل فئات Java يخزن الفئات مؤقتاً. قد تعرض لوحة التحكم زر إيقاف حتى لو لم يكن للإضافة عملية نشطة. تنشئ الإضافات المشغّلة في JVM منفصل دليل logs/ في دليل العمل الحالي. عند ظهور مفتاح موقّع لأول مرة يتم الوثوق به تلقائياً؛ لا توجد سلطة توقيع مركزية. يترك Windows أحياناً أدلة فارغة بعد إلغاء تثبيت إضافة. يؤدي تثبيت إضافة مخصصة لـ Java 6 فقط على JVM إصدار Java 5 إلى الإبلاغ عن \u0026ldquo;الإضافة تالفة\u0026rdquo; بسبب ضغط Pack200. تبقى إضافات السمات والترجمة غير مختبرة إلى حد كبير. لا تستمر إشارات التشغيل التلقائي دائماً للإضافات غير المُدارة. 6. المتطلبات وأفضل الممارسات دعم الإضافات متاح في I2P 0.7.12 والأحدث. حافظ على تحديث router والإضافات للحصول على إصلاحات الأمان. قدم ملاحظات إصدار موجزة حتى يفهم المستخدمون التغييرات بين الإصدارات. عندما يكون ممكناً، استضف أرشيفات الإضافات عبر HTTPS داخل I2P لتقليل تعرض البيانات الوصفية على الشبكة الصافية. 7. قراءة إضافية مواصفات الإضافة إطار عمل تطبيقات العميل مستودع سكريبتات I2P لأدوات التغليف ","description":"تثبيت وتحديث وتطوير إضافات الموجه","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"تثبيت الإضافات المخصصة","url":"/ar/docs/guides/plugins/"},{"categories":null,"content":"كما هو مطلوب من قبل نموذج التهديد الخاص بنا (من بين أسباب أخرى)، يجب أن يكون البرنامج المطور لدعم شبكة الاتصالات المجهولة التي نسميها I2P متاحًا بحرية ومفتوح المصدر وقابلًا للتعديل من قبل المستخدم. لتلبية هذه المعايير، نستخدم مجموعة متنوعة من التقنيات القانونية وهندسة البرمجيات لإزالة أكبر عدد ممكن من الحواجز أمام أولئك الذين يفكرون في استخدام أو المساهمة في مشروع I2P.\nبينما قد تكون المعلومات أدناه أكثر إرباكاً من مجرد القول \u0026ldquo;I2P مرخص بـ BSD\u0026rdquo; أو \u0026ldquo;I2P مرخص بـ GPL\u0026rdquo; أو \u0026ldquo;I2P ملك عام\u0026rdquo;، الإجابة المختصرة على السؤال \u0026ldquo;كيف يتم ترخيص I2P؟\u0026rdquo; هي:\nجميع البرامج المضمنة في توزيعات I2P ستسمح بـ: الاستخدام دون رسوم الاستخدام دون قيود على كيفية أو متى أو أين أو لماذا أو من يقوم بتشغيله الوصول إلى الكود المصدري دون رسوم التعديلات على الكود المصدري معظم البرمجيات تضمن أكثر من ذلك بكثير - قدرة أي شخص على توزيع الكود المصدري المعدّل بالطريقة التي يختارها. ومع ذلك، ليست كل البرمجيات المرفقة توفر هذه الحرية - فرخصة GPL تقيد قدرة المطورين الذين يرغبون في دمج I2P مع تطبيقاتهم الخاصة التي ليست بحد ذاتها تطبيقات مفتوحة المصدر. وبينما نشيد بالأهداف النبيلة لزيادة الموارد في المشاع، فإن I2P يُخدَم بشكل أفضل عن طريق إزالة أي عوائق تقف في طريق اعتماده - فإذا كان على المطور الذي يفكر في إمكانية دمج I2P مع تطبيقه أن يتوقف ويستشير محاميه، أو يجري مراجعة للكود للتأكد من أن كوده المصدري يمكن إصداره بما يتوافق مع GPL، فإننا نخسر.\nتراخيص المكونات يحتوي توزيع I2P على عدة موارد، تعكس تقسيم الكود المصدري إلى مكونات. كل مكون له ترخيصه الخاص، الذي يوافق عليه جميع المطورين الذين يساهمون فيه - إما من خلال الإعلان صراحةً عن إصدار الكود المُرسَل تحت ترخيص متوافق مع ذلك المكون، أو من خلال إصدار الكود المُرسَل ضمنياً تحت الترخيص الأساسي للمكون. لكل من هذه المكونات مطور رئيسي له القول الفصل فيما يتعلق بالترخيص المتوافق مع الترخيص الأساسي للمكون، ومدير مشروع I2P له القول الفصل فيما يتعلق بالتراخيص التي تلبي الضمانات الأربعة المذكورة أعلاه للإدراج في توزيع I2P.\nComponent Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD, Cryptix, MIT zzz I2P Router router router.jar Public domain BSD, Cryptix, MIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain, Cryptix, MIT zzz Streaming apps/streaming streaming.jar Public domain BSD, Cryptix, MIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain, BSD, Cryptix, MIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain — zzz Address Book apps/addressbook addressbook.war MIT Public domain, Cryptix, BSD — Susidns apps/susidns susidns.war GPL + exception — — Susimail apps/susimail susimail.war GPL + exception — — I2PSnark apps/i2psnark i2psnark.jar GPL + exception — zzz [BOB](/docs/legacy/bob/) Bridge apps/BOB BOB.jar WTFPL — sponge [SAM](/docs/api/samv3/) Bridge apps/sam sam.jar Public domain Cryptix, BSD, MIT zzz [SAM v1](/docs/legacy/sam/) Perl library apps/sam/perl SAM.pm GPL Public domain, Cryptix, BSD, MIT BrianR [SAM v1](/docs/legacy/sam/) C library apps/sam/c libSAM BSD Public domain, Cryptix, MIT Nightblade [SAM v1](/docs/legacy/sam/) Python library apps/sam/python i2p.py Public domain BSD, Cryptix, MIT Connelly [SAM v1](/docs/legacy/sam/) C# library apps/sam/csharp/ n/a Public domain BSD, Cryptix, MIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source — — Installer installer install.jar, guiinstall.jar Public domain GPL + exception, BSD, Cryptix, MIT — استثناء GPL على الرغم من أن هذا قد يكون تكراريًا، ولكن من أجل الوضوح فإن الكود المرخص بموجب GPL المضمن في I2PTunnel والتطبيقات الأخرى يجب أن يتم إصداره بموجب ترخيص GPL مع \u0026ldquo;استثناء\u0026rdquo; إضافي يسمح صراحةً باستخدام مكتبات Java القياسية:\nIn addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version. سيتم ترخيص جميع الأكواد المصدرية ضمن كل مكون بشكل افتراضي تحت الترخيص الأساسي، ما لم يُذكر خلاف ذلك في الكود. جميع ما ورد أعلاه هو ملخص لشروط الترخيص - يرجى الرجوع إلى الترخيص المحدد للمكون أو الكود المصدري المعني للاطلاع على الشروط الرسمية. قد يتم تغيير مواقع مصادر المكونات وتغليف الموارد في حال إعادة تنظيم المستودع.\nترخيص الموقع الإلكتروني ما لم يُذكر خلاف ذلك، المحتوى على هذا الموقع مرخص بموجب رخصة المشاع الإبداعي نَسب المُصنَّف - الترخيص بالمثل 4.0 دولي .\nصلاحيات الالتزام يمكن للمطورين دفع التغييرات إلى مستودع git الموزع إذا حصلوا على إذن من الشخص الذي يدير ذلك المستودع. راجع دليل المطور الجديد للحصول على التفاصيل.\nومع ذلك، لكي يتم تضمين التغييرات في الإصدار، يجب أن يكون المطورون موثوقين من قبل مدير الإصدار (حاليًا zzz). بالإضافة إلى ذلك، يجب عليهم الموافقة صراحةً على الشروط المذكورة أعلاه ليكونوا موثوقين. وهذا يعني أنه يجب عليهم إرسال رسالة موقعة إلى أحد مديري الإصدار تؤكد أن:\nما لم يُحدد خلاف ذلك، فإن جميع الأكواد البرمجية التي أقوم بإرسالها مرخصة ضمنياً بموجب الترخيص الأساسي للمكون إذا تم تحديد ذلك في المصدر، فقد يتم ترخيص الكود صراحةً بموجب أحد التراخيص البديلة للمكون لدي الحق في إصدار الكود الذي أقوم بإرساله وفقاً للشروط التي أقوم بإرساله بموجبها إذا كان أي شخص على علم بأي حالات لا تتوافق فيها الشروط المذكورة أعلاه، يرجى الاتصال بمسؤول المكون و/أو مدير إصدار I2P مع مزيد من المعلومات.\n","description":"سياسة الترخيص وتراخيص المكونات للبرمجيات المدمجة مع I2P","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"تراخيص برنامج I2P","url":"/ar/docs/develop/licenses/"},{"categories":null,"content":"استضافة GitLab داخل I2P أمر مباشر: قم بتشغيل حاوية GitLab omnibus، وعرضها على loopback، وإعادة توجيه حركة المرور عبر tunnel في I2P. الخطوات أدناه تعكس التكوين المستخدم لـ git.idk.i2p ولكنها تعمل مع أي مثيل مستضاف ذاتياً.\n1. المتطلبات الأساسية Debian أو توزيعة Linux أخرى مع تثبيت Docker Engine (sudo apt install docker.io أو docker-ce من مستودع Docker). router I2P (Java I2P أو i2pd) بعرض نطاق كافٍ لخدمة المستخدمين. اختياري: جهاز افتراضي مخصص بحيث يظل GitLab وال router معزولين عن بيئة سطح المكتب الخاصة بك. 2. سحب صورة GitLab docker pull gitlab/gitlab-ce:latest الصورة الرسمية مبنية من طبقات Ubuntu الأساسية ويتم تحديثها بانتظام. راجع Dockerfile إذا كنت بحاجة إلى مزيد من الطمأنينة.\n3. قرر بين الوضع الجسري أو I2P فقط مثيلات I2P فقط لا تتصل أبدًا بمضيفات clearnet. يمكن للمستخدمين نسخ المستودعات من خدمات I2P الأخرى ولكن ليس من GitHub/GitLab.com. هذا يزيد من إخفاء الهوية إلى أقصى حد. المثيلات المجسورة تصل إلى مضيفات Git على clearnet عبر وكيل HTTP. هذا مفيد لنسخ المشاريع العامة إلى I2P ولكنه يكشف هوية الطلبات الصادرة من الخادم. إذا اخترت وضع الجسر (bridged mode)، قم بتكوين GitLab لاستخدام بروكسي I2P HTTP مرتبط على مضيف Docker (على سبيل المثال http://172.17.0.1:4446). يستمع بروكسي الموجه الافتراضي على 127.0.0.1 فقط؛ أضف tunnel بروكسي جديد مرتبط بعنوان بوابة Docker.\n4. تشغيل الحاوية docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest اربط المنافذ المنشورة بـ loopback؛ أنفاق I2P ستعرضها حسب الحاجة. استبدل /srv/gitlab/... بمسارات التخزين المناسبة لمضيفك. بمجرد تشغيل الحاوية، قم بزيارة https://127.0.0.1:8443/، وقم بتعيين كلمة مرور المسؤول، وقم بتكوين حدود الحساب.\n5. عرض GitLab عبر I2P أنشئ ثلاثة أنفاق I2PTunnel من نوع خادم:\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated قم بتكوين كل tunnel بأطوال tunnel وعرض نطاق مناسبين. بالنسبة للحالات العامة، 3 hops مع 4-6 tunnels لكل اتجاه تعتبر نقطة انطلاق جيدة. انشر وجهات Base32/Base64 الناتجة على صفحتك الرئيسية حتى يتمكن المستخدمون من تكوين client tunnels. Destination Enforcement إذا كنت تستخدم أنفاق HTTP(S)، قم بتفعيل فرض الوجهة (destination enforcement) بحيث لا يمكن سوى لاسم المضيف المقصود الوصول إلى الخدمة. هذا يمنع استغلال النفق كوكيل عام.\n6. Maintenance Tips قم بتشغيل docker exec gitlab gitlab-ctl reconfigure كلما قمت بتغيير إعدادات GitLab. راقب استخدام القرص (/srv/gitlab/data)—مستودعات Git تنمو بسرعة. قم بعمل نسخ احتياطية لدلائل الإعدادات والبيانات بانتظام. مهام backup rake الخاصة بـ GitLab تعمل داخل الحاوية. فكّر في وضع نفق مراقبة خارجي في وضع العميل للتأكد من إمكانية الوصول إلى الخدمة من الشبكة الأوسع. 6. نصائح الصيانة تضمين I2P في تطبيقك Git عبر I2P (دليل العميل) حزم Git للشبكات غير المتصلة/البطيئة توفر نسخة GitLab مهيأة جيدًا مركزًا للتطوير التعاوني بالكامل داخل I2P. حافظ على صحة الـ router، وابقَ محدثًا بتحديثات أمان GitLab، ونسّق مع المجتمع مع نمو قاعدة المستخدمين لديك.\n","description":"نشر GitLab داخل I2P باستخدام Docker وموجه I2P","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"تشغيل GitLab عبر I2P","url":"/ar/docs/guides/gitlab/"},{"categories":null,"content":" الحالة: يصف هذا المستند بروتوكول التشفير ElGamal/AES+SessionTag (مخطط تشفير يجمع بين ElGamal وAES مع SessionTag). لا يزال مدعوماً لأغراض التوافق العكسي فقط، لأن إصدارات I2P الحديثة (2.10.0+) تستخدم ECIES-X25519-AEAD-Ratchet (مخطط تشفير قائم على ECIES وX25519 مع AEAD وRatchet لتدوير المفاتيح). يُعد بروتوكول ElGamal مُهملًا ويُحتفَظ به حصراً لأغراض تاريخية وللتشغيل البيني.\nنظرة عامة قدّمت ElGamal/AES+SessionTag الآلية الأصلية للتشفير من الطرف إلى الطرف في I2P لرسائل garlic (نمط رسائل مُجمَّعة في I2P). لقد جمعت بين:\nElGamal (2048-بت) — لتبادل المفاتيح AES-256/CBC — لتشفير بيانات الحمولة SHA-256 — للتجزئة واشتقاق متجه التهيئة (IV) Session Tags (وسوم الجلسة، 32 بايت) — لمعرّفات الرسائل لمرة واحدة أتاح البروتوكول لـ routers والوجهات التواصل بأمان دون الحفاظ على اتصالات مستمرة. كانت كل جلسة تستخدم تبادل ElGamal غير متناظرًا لإنشاء مفتاح AES متناظر، تلاه إرسال رسائل \u0026ldquo;موسومة\u0026rdquo; خفيفة تُشير إلى تلك الجلسة.\nآلية عمل البروتوكول إنشاء جلسة (جلسة جديدة) بدأت جلسة جديدة برسالة تتضمن قسمين:\nSection Size Contents Purpose ElGamal-encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient's ElGamal public key Establishes the AES session key and IV seed AES-encrypted block Variable (≥128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags كان النصّ الصريح داخل كتلة ElGamal (خوارزمية تشفير بالمفتاح العام) يتكوّن من: Field Size Description Session Key 32 bytes AES-256 key for the session Pre-IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA-256(Pre-IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length ### رسائل الجلسة القائمة بمجرد إنشاء جلسة، كان بإمكان المرسل إرسال رسائل existing-session (جلسة قائمة) باستخدام علامات جلسة مخزنة مؤقتاً:\nField Size Description Session Tag 32 bytes Single-use identifier tied to the existing session key AES-Encrypted Block Variable Encrypted payload and metadata using the established AES key Routers خزّنت مؤقتًا الوسوم التي تم تسليمها لمدة نحو **15 دقيقة**، وبعد ذلك انتهت صلاحية الوسوم غير المستخدمة. كان كل وسم صالحًا لرسالة واحدة بالضبط لمنع هجمات الارتباط. تنسيق الكتلة المشفرة بـ AES Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single-use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA-256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16-byte aligned) Random padding to block boundary تقوم Routers بفك التشفير باستخدام مفتاح الجلسة و IV (متجه التهيئة) المشتقين إما من Pre-IV (للجلسات الجديدة) أو من وسم الجلسة (للجلسات الحالية). بعد فك التشفير، تتحقق من السلامة عبر إعادة احتساب تجزئة SHA-256 لحمولة النص الصريح. إدارة وسوم الجلسة العلامات أحادية الاتجاه: لا يمكن إعادة استخدام علامات Alice → Bob في اتجاه Bob → Alice. تنتهي صلاحية العلامات بعد حوالي 15 دقيقة. Routers تحتفظ بـ مديري مفاتيح الجلسة لكل وجهة لتتبّع العلامات والمفاتيح وأوقات الانتهاء. يمكن للتطبيقات التحكم في سلوك العلامات عبر خيارات I2CP : i2cp.tagThreshold — الحد الأدنى من العلامات المخزّنة مؤقتًا قبل إعادة التزويد i2cp.tagCount — عدد العلامات الجديدة لكل رسالة قلّلت هذه الآلية المصافحات المكلفة لـ ElGamal إلى الحد الأدنى، مع الحفاظ على عدم قابلية الربط بين الرسائل.\nالتكوين والكفاءة تم تقديم وسوم الجلسة لتحسين الكفاءة عبر النقل عالي التأخير وغير المرتَّب الخاص بـ I2P. كان التكوين المعتاد يقدّم 40 وسمًا لكل رسالة، مضيفًا نحو 1.2 KB من الحمولة الإضافية. كان بإمكان التطبيقات ضبط سلوك التسليم بناءً على حركة المرور المتوقعة:\nUse Case Recommended Tags Notes Short-lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re-establishment Long-term services 50+ Ensures steady tag supply despite loss or delay تقوم Routers بشكل دوري بحذف الوسوم المنتهية الصلاحية وإزالة حالة الجلسة غير المستخدمة لتقليل استخدام الذاكرة والتخفيف من هجمات إغراق الوسوم. القيود Category Limitation Performance 514-byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES-CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor's algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. دفعت هذه أوجه القصور مباشرة إلى تصميم بروتوكول [ECIES-X25519-AEAD-Ratchet](/docs/specs/ecies/)، الذي يوفر سرية أمامية تامة، وتشفيرًا موثقًا بالمصادقة، وتبادلًا فعالًا للمفاتيح. حالة الإهمال والترحيل تم تقديمه: الإصدارات المبكرة من I2P (قبل 0.6) تم إهماله: مع إدخال ECIES-X25519 (مخطط التشفير ECIES مع X25519) (0.9.46 → 0.9.48) تمت إزالته: لم يعد الإعداد الافتراضي اعتبارًا من 2.4.0 (ديسمبر 2023) مدعوم: للتوافق مع الإصدارات القديمة فقط تعلن routers الحديثة والوجهات الآن عن نوع التشفير 4 (ECIES-X25519) بدلاً من النوع 0 (ElGamal/AES). يظل البروتوكول القديم معترفاً به لأغراض قابلية التشغيل البيني مع الأقران غير المُحدَّثين، لكنه لا ينبغي أن يُستخدم في عمليات النشر الجديدة.\nالسياق التاريخي كان ElGamal/AES+SessionTag (SessionTag: وسم جلسة يُستخدم لمرة واحدة) حجر الأساس للبنية التشفيرية المبكرة لـ I2P. قدّم تصميمه الهجين ابتكارات مثل وسوم الجلسات التي تُستخدم لمرة واحدة والجلسات أحادية الاتجاه التي أثّرت في البروتوكولات اللاحقة. وتطوّر كثير من هذه الأفكار إلى بنى حديثة مثل deterministic ratchets (آليات تدوير مفاتيح حتمية) و hybrid post-quantum key exchanges (تبادلات مفاتيح هجينة لما بعد الكم).\n","description":"تشفير طرف-إلى-طرف متقادم يجمع بين ElGamal وAES وSHA-256 ووسوم جلسة أحادية الاستخدام","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"تشفير ElGamal/AES + SessionTag (وسم الجلسة)","url":"/ar/docs/legacy/elgamal-aes/"},{"categories":null,"content":"حالة التنفيذ النشر الحالي: - i2pd (تنفيذ C++): مُنفَّذ بالكامل في الإصدار 2.58.0 (سبتمبر 2025) مع دعم ML-KEM-512 وML-KEM-768 وML-KEM-1024. يتم تمكين تشفير طرف إلى طرف ما بعد الكمّي افتراضيًا عند توفّر OpenSSL 3.5.0 أو أحدث. - Java I2P: لم يُنفَّذ بعد حتى الإصدار 0.9.67 / 2.10.0 (سبتمبر 2025). تمت الموافقة على المواصفة ويُخطَّط لتنفيذها في الإصدارات المستقبلية.\nتصف هذه المواصفة الوظائف المعتمدة المطبّقة حالياً في i2pd والمخطَّط تنفيذها في تنفيذات Java I2P.\nنظرة عامة هذا هو المتغيّر الهجين بعد الكمّ (post-quantum) لبروتوكول ECIES-X25519-AEAD-Ratchet ECIES . وهو يمثّل المرحلة الأولى من المقترح 169 Prop169 المزمع اعتمادها. راجع ذلك المقترح للاطّلاع على الأهداف العامة، ونماذج التهديد، والتحليل، والبدائل، ومعلومات إضافية.\nحالة المقترح 169: مفتوح (تمت الموافقة على المرحلة الأولى لتنفيذ هجين لـ ECIES (مخطط تشفير قائم على المنحنيات الإهليلجية)).\nتتضمن هذه المواصفة فقط الفروقات عن معيار ECIES (مخطط تشفير متكامل على المنحنيات الإهليلجية)، ويجب قراءتها بالاقتران مع تلك المواصفة.\nالتصميم نستخدم معيار NIST FIPS 203 FIPS203 المستند إلى، ولكنه غير متوافق مع، CRYSTALS-Kyber (خوارزمية تبادل مفاتيح ما بعد الكم) (الإصدارات 3.1 و3 والأقدم).\nتجمع المصافحات الهجينة بين خوارزمية X25519 Diffie-Hellman (لتبادل المفاتيح) الكلاسيكية وآليات تغليف المفاتيح ML-KEM لما بعد الكمّي. يعتمد هذا النهج على مفاهيم السرية الأمامية الهجينة الموثّقة في أبحاث PQNoise وعلى تطبيقات مماثلة في TLS 1.3 وIKEv2 وWireGuard.\nتبادل المفاتيح نعرّف تبادل مفاتيح هجيني للـ Ratchet (آلية تدوير المفاتيح). يوفّر Post-quantum KEM (آلية تغليف المفاتيح لما بعد الكم) مفاتيح مؤقتة فقط ولا يدعم مباشرة المصافحات ذات المفاتيح الثابتة مثل Noise IK (نمط مصافحة في إطار عمل Noise).\nنُعرّف متغيرات ML-KEM الثلاثة (آلية تغليف المفاتيح القائمة على الشبكيات النمطية) كما هو محدد في FIPS203 ، ليصبح لدينا في المجموع 3 أنواع تشفير جديدة. لا تُعرَّف الأنواع الهجينة إلا بالاقتران مع X25519.\nأنواع التشفير الجديدة هي:\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 **ملاحظة:** MLKEM768_X25519 (Type 6) هو المتغيّر الافتراضي الموصى به، إذ يوفّر أمانًا قويًا ما بعد الكمّ مع تكلفة إضافية معقولة. الحجم الإضافي كبير مقارنةً بتشفير X25519 (آلية تبادل مفاتيح مبنية على منحنى Curve25519) فقط. أحجام الرسالتين 1 و2 النموذجية (لنمط IK، وهو نمط مصافحة في بروتوكول Noise) تبلغ حاليًا نحو 96–103 بايت (قبل الحمولة الإضافية). وسيزداد ذلك بنحو 9–12 ضعفًا مع MLKEM512 (عائلة ML‑KEM، معيار تبادل مفاتيح مقاوم للكم صادر عن NIST)، و13–16 ضعفًا مع MLKEM768، و17–23 ضعفًا مع MLKEM1024، وذلك بحسب نوع الرسالة.\nمطلوب تشفير جديد ML-KEM (المعروف سابقًا باسم CRYSTALS-Kyber) FIPS203 - معيار آلية تغليف المفاتيح القائمة على الشبكات النمطية SHA3-256 (المعروف سابقًا باسم Keccak-512) FIPS202 - جزء من معيار SHA-3 SHAKE128 و SHAKE256 (امتدادات XOF لـ SHA3؛ دالة بإخراج قابل للتمديد) FIPS202 - دوال بإخراج قابل للتمديد تتوفر متجهات الاختبار لـ SHA3-256 وSHAKE128 وSHAKE256 في برنامج NIST للتحقق من صحة الخوارزميات التشفيرية .\nدعم المكتبات: - Java: مكتبة Bouncycastle الإصدار 1.79 وما بعده تدعم جميع متغيرات ML-KEM (آلية تغليف المفاتيح القائمة على الشبكات النمطية) ودوال SHA3/SHAKE - C++: يتضمن OpenSSL 3.5 وما بعده دعماً كاملاً لـ ML-KEM (صدر في أبريل 2025) - Go: تتوفر عدة مكتبات لتنفيذ ML-KEM وSHA3\nالمواصفات البُنى المشتركة راجِع مواصفة البنى المشتركة للاطلاع على أطوال المفاتيح والمعرّفات.\nأنماط المصافحة تستخدم عمليات المصافحة أنماط المصافحة الخاصة بـ Noise Protocol Framework مع تعديلات خاصة بـ I2P لتحقيق أمان هجين لما بعد الكم.\nيُستخدَم التعيين التالي للأحرف:\ne = مفتاح مؤقّت لمرة واحدة (X25519) s = مفتاح ثابت p = حمولة الرسالة e1 = مفتاح PQ (ما بعد الكم) مؤقّت لمرة واحدة، مُرسَل من Alice إلى Bob (رمز خاص بـ I2P) ekem1 = النص المُشفَّر لـ KEM (آلية تغليف المفاتيح)، مُرسَل من Bob إلى Alice (رمز خاص بـ I2P) ملاحظة مهمة: أسماء الأنماط \u0026ldquo;IKhfs\u0026rdquo; و\u0026quot;IKhfselg2\u0026quot; والرموز \u0026ldquo;e1\u0026rdquo; و\u0026quot;ekem1\u0026quot; هي تعديلات خاصة بـ I2P غير موثقة في مواصفة إطار عمل بروتوكول Noise الرسمية. تمثل هذه تعريفات مخصصة لدمج ML-KEM (آلية تغليف المفاتيح - KEM - ما بعد الكم) ضمن نمط IK في Noise. وبينما يُعترف على نطاق واسع بالنهج الهجين X25519 + ML-KEM في أبحاث التشفير ما بعد الكم وبروتوكولات أخرى، فإن التسميات المحددة المستخدمة هنا خاصة بـ I2P.\nتُطبَّق التعديلات التالية على IK لتحقيق سرية أمامية هجينة:\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. يُعرَّف نمط e1 كما يلي:\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) يُعرَّف النمط ekem1 (مصطلح تقني) كما يلي:\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) العمليات المعرّفة لـ ML-KEM نعرّف الدوال التالية المقابلة للّبنات الأساسية التشفيرية كما هو محدد في FIPS203 .\n(encap_key, decap_key) = PQ_KEYGEN() : تُنشئ أليس مفاتيح التغليف وفكّ التغليف. يُرسَل مفتاح التغليف في رسالة NS. أحجام المفاتيح: - ML-KEM-512: encap_key = 800 بايت، decap_key = 1632 بايت - ML-KEM-768: encap_key = 1184 بايت، decap_key = 2400 بايت - ML-KEM-1024: encap_key = 1568 بايت، decap_key = 3168 بايت\n(ciphertext, kem_shared_key) = ENCAPS(encap_key) : يحسب بوب النص المشفّر والمفتاح المشترك باستخدام مفتاح التغليف المستلَم في رسالة NS. يُرسَل النص المشفّر في رسالة NSR. أحجام النص المشفّر: - ML-KEM-512: 768 بايت - ML-KEM-768: 1088 بايت - ML-KEM-1024: 1568 بايت\nيبلغ طول kem_shared_key دائمًا 32 بايت في جميع المتغيرات الثلاثة.\nkem_shared_key = DECAPS(ciphertext, decap_key) : تحسب أليس المفتاح المشترك باستخدام ciphertext المستلَم في رسالة NSR. يبلغ طول kem_shared_key دائمًا 32 بايت.\nمهم: كلٌ من encap_key وciphertext يُشفَّران داخل كُتَل ChaCha20-Poly1305 (خوارزمية AEAD للتشفير والمصادقة) في رسالتي المصافحة الخاصة بـ Noise (بروتوكول للتبادل الآمن) 1 و2. سيتم فكّ تشفيرهما كجزء من عملية المصافحة.\nيُدمج kem_shared_key ضمن مفتاح السلسلة باستخدام MixKey(). راجع التفاصيل أدناه.\nKDF (دالة اشتقاق المفاتيح) لمصافحة Noise نظرة عامة تجمع المصافحة الهجينة بين X25519 ECDH الكلاسيكي وML-KEM ما بعد الكم. تحتوي الرسالة الأولى، من Alice إلى Bob، على e1 (مفتاح تغليف ML-KEM) قبل حمولة الرسالة. يُعامَل ذلك كمواد مفتاحية إضافية؛ استدعِ EncryptAndHash() عليه (بصفتك Alice) أو DecryptAndHash() (بصفتك Bob). ثم عالِج حمولة الرسالة كالمعتاد.\nالرسالة الثانية، من Bob إلى Alice، تحتوي على ekem1 (ML-KEM ciphertext، نص مُشفّر بخوارزمية ML-KEM) قبل حمولة الرسالة. يُعامَل هذا كمادة مفتاحية إضافية؛ استدعِ EncryptAndHash() عليها (بوصفك Bob) أو DecryptAndHash() (بوصفك Alice). ثم احسب kem_shared_key واستدعِ MixKey(kem_shared_key). بعد ذلك عالِج حمولة الرسالة كالمعتاد.\nمعرّفات Noise (إطار عمل بروتوكولي للتشفير) هذه هي سلاسل تهيئة Noise (إطار عمل بروتوكول لتبادل المفاتيح الآمن) (الخاصة بـ I2P):\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 دالة اشتقاق المفاتيح لأليس لرسالة NS بعد نمط الرسالة \u0026rsquo;es\u0026rsquo; وقبل نمط الرسالة \u0026rsquo;s\u0026rsquo; أضِف:\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). KDF (دالة اشتقاق المفاتيح) الخاصة بـ Bob لرسالة NS بعد نمط الرسالة \u0026rsquo;es\u0026rsquo; وقبل نمط الرسالة \u0026rsquo;s\u0026rsquo;، أضف:\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). KDF (دالة اشتقاق المفاتيح) الخاصة ببوب لرسالة NSR بعد نمط الرسالة \u0026rsquo;ee\u0026rsquo; وقبل نمط الرسالة \u0026lsquo;se\u0026rsquo;، أضف:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. خوارزمية اشتقاق المفاتيح الخاصة بأليس لرسالة NSR بعد نمط الرسالة \u0026rsquo;ee\u0026rsquo; وقبل نمط الرسالة \u0026lsquo;ss\u0026rsquo;، أضف:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. دالة اشتقاق المفاتيح (KDF) لـ split() تبقى الدالة split() دون تغيير عن المواصفات القياسية لـ ECIES (مخطط تشفير متكامل باستخدام المنحنيات الإهليلجية). بعد إتمام المصافحة:\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] هذه هي مفاتيح الجلسة ثنائية الاتجاه للتواصل المستمر.\nتنسيق الرسالة تنسيق NS (New Session - جلسة جديدة) التغييرات: يحتوي ratchet (آلية ترقية المفاتيح تدريجياً) الحالي على المفتاح الثابت في قسم ChaCha20-Poly1305 الأول وعلى الحمولة في القسم الثاني. مع ML-KEM، أصبح هناك الآن ثلاثة أقسام. يحتوي القسم الأول على المفتاح العام لـ ML-KEM المُشفَّر (encap_key). يحتوي القسم الثاني على المفتاح الثابت. يحتوي القسم الثالث على الحمولة.\nأحجام الرسائل:\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl **ملاحظة:** يجب أن تحتوي الحمولة على كتلة DateTime (حد أدنى 7 بايت: نوع بطول 1 بايت، حجم بطول 2 بايت، طابع زمني بطول 4 بايت). يمكن حساب أحجام NS الدنيا وفقاً لذلك. وعليه، فإن الحد الأدنى العملي لحجم NS هو 103 بايت لـ X25519 ويتراوح من 919 إلى 1687 بايت للمتغيرات الهجينة. تُعزى زيادات الحجم بمقادير 816، و1200، و1584 بايت في المتغيرات الثلاثة لـ ML-KEM إلى المفتاح العام لـ ML-KEM إضافةً إلى Poly1305 MAC (رمز تحقق الرسالة) بحجم 16 بايت للتشفير الموثَّق.\nتنسيق NSR (New Session Reply - استجابة الجلسة الجديدة) التغييرات: ratchet (آلية تدوير المفاتيح تدريجياً) الحالي يحتوي على حمولة فارغة في القسم الأول من ChaCha20-Poly1305 (خوارزمية تشفير ومصادقة)، وتكون الحمولة في القسم الثاني. مع ML-KEM (آلية تغليف مفاتيح قائمة على شبكات معيارية)، أصبح هناك الآن ثلاثة أقسام. يحتوي القسم الأول على نص ML-KEM المُشفّر. يحتوي القسم الثاني على حمولة فارغة. يحتوي القسم الثالث على الحمولة.\nأحجام الرسائل:\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl تُعزى زيادات الحجم البالغة 784 و1104 و1584 بايت في المتغيرات الثلاثة لـ ML-KEM إلى نص ML-KEM المُعمّى، إضافةً إلى Poly1305 MAC بحجم 16 بايت للتشفير الموثّق. تحليل العبء الإضافي تبادل المفاتيح الكلفة الإضافية للتشفير الهجين كبيرة مقارنةً بـ X25519 فقط:\nMLKEM512_X25519: زيادة في حجم رسالة المصافحة بنحو 9-12x (NS: 9.5x, NSR: 11.9x) MLKEM768_X25519: زيادة في حجم رسالة المصافحة بنحو 13-16x (NS: 13.5x, NSR: 16.3x) MLKEM1024_X25519: زيادة في حجم رسالة المصافحة بنحو 17-23x (NS: 17.5x, NSR: 23x) هذه الزيادة في العبء مقبولة مقابل فوائد الأمن ما بعد الكم المضافة. تختلف معاملات الضرب بحسب نوع الرسالة لأن أحجام الرسائل الأساسية تختلف (الحد الأدنى لـ NS: 96 بايت، ولـ NSR: 72 بايت).\nاعتبارات عرض النطاق الترددي لعملية إنشاء جلسة نموذجية بحمولات دنيا: - X25519 فقط: ~200 بايت إجمالاً (NS + NSR) - MLKEM512_X25519: ~1,800 بايت إجمالاً (زيادة بمقدار 9 أضعاف) - MLKEM768_X25519: ~2,500 بايت إجمالاً (زيادة بمقدار 12.5 ضعفاً) - MLKEM1024_X25519: ~3,400 بايت إجمالاً (زيادة بمقدار 17 ضعفاً)\nبعد إنشاء الجلسة، يستخدم تشفير الرسائل المستمر نفس تنسيق نقل البيانات كما في الجلسات المعتمدة على X25519 فقط، لذا لا يوجد عبء إضافي للرسائل اللاحقة.\nتحليل الأمان المصافحات توفر المصافحة الهجينة كلاً من الأمان التقليدي (X25519) وأمان ما بعد الكم (ML-KEM). يجب على المهاجم كسر كلا من ECDH التقليدي وKEM لما بعد الكم للمساس بمفاتيح الجلسة.\nيوفّر هذا: - الأمان الحالي: يوفّر X25519 ECDH أمانًا ضد المهاجمين التقليديين (مستوى أمان 128-بت) - الأمان المستقبلي: يوفّر ML-KEM أمانًا ضد المهاجمين الكمّيين (يختلف باختلاف مجموعة المعلمات) - الأمان الهجين: يجب كسر كلاهما لاختراق الجلسة (مستوى الأمان = الأعلى بين المكوّنين)\nمستويات الأمان Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit **ملاحظة:** مستوى الأمان الهجين محدود بأضعف المكوّنين. في جميع الحالات، توفّر X25519 (منحنى بيضاوي للاتفاق على المفاتيح) أمانًا تقليديًا بقوة 128-بت. إذا توفر حاسوب كمي ذو صلة بالتشفير، فسيعتمد مستوى الأمان على مجموعة معلمات ML-KEM (آلية تغليف مفاتيح لما بعد الكم) المختارة. السرية الأمامية النهج الهجين يحافظ على خصائص السرية المستقبلية. يتم اشتقاق مفاتيح الجلسة من كلٍ من تبادل مفاتيح X25519 المؤقت وتبادل مفاتيح ML-KEM المؤقت. إذا تم إتلاف المفاتيح الخاصة المؤقتة لـ X25519 أو ML-KEM بعد إتمام المصافحة، فلن يكون بالإمكان فك تشفير الجلسات السابقة حتى لو تم اختراق المفاتيح الثابتة طويلة الأمد.\nيوفّر نمط IK سرية أمامية كاملة (Noise Confidentiality level 5: مستوى السرية في بروتوكول Noise، المستوى 5) بعد إرسال الرسالة الثانية (NSR).\nتفضيلات النوع يجب أن تدعم التنفيذات عدة أنواع هجينة وأن تتفاوض على أقوى متغيّر مدعوم بشكل متبادل. يجب أن يكون ترتيب التفضيل:\nMLKEM768_X25519 (مجموعة اتفاق مفاتيح هجينة تجمع MLKEM (تشفير بعد-كمومي قائم على الشبكات) وX25519 (خوارزمية منحنى بيضوي لتبادل المفاتيح)) (النوع 6) - الافتراضي الموصى به، أفضل توازن بين الأمان والأداء MLKEM1024_X25519 (النوع 7) - أعلى مستوى أمان للتطبيقات الحساسة MLKEM512_X25519 (النوع 5) - خط أساس للأمان بعد-الكمومي للسيناريوهات ذات الموارد المحدودة X25519 (النوع 4) - تقليدي فقط، حلّ احتياطي للتوافق التبرير: يُنصح باعتماد MLKEM768_X25519 كالإعداد الافتراضي لأنه يوفّر أمان NIST Category 3 (المعهد الوطني للمعايير والتقنية) (ما يعادل AES-192)، وهو ما يُعد حماية كافية ضد الحواسيب الكمّية مع الحفاظ على أحجام رسائل معقولة. يوفّر MLKEM1024_X25519 مستوى أمان أعلى، ولكن مع عبءٍ إضافي أعلى بكثير.\nملاحظات التنفيذ دعم المكتبات Java: تدعم مكتبة Bouncycastle الإصدار 1.79 (أغسطس 2024) وما بعده جميع متغيّرات ML-KEM (آلية تغليف المفاتيح القائمة على الشبكات المعيارية) المطلوبة ووظائف SHA3/SHAKE. استخدم org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine للامتثال لمعيار FIPS 203. C++: يتضمن OpenSSL 3.5 (أبريل 2025) وما بعده دعم ML-KEM عبر واجهة EVP_KEM. هذا إصدار دعم طويل الأجل (LTS) تتم صيانته حتى أبريل 2030. Go: تتوفر عدة مكتبات من جهات خارجية لدعم ML-KEM وSHA3، بما في ذلك مكتبة CIRCL من Cloudflare. استراتيجية الترحيل ينبغي على التنفيذات: 1. دعم كلٍ من X25519-only (خوارزمية تبادل مفاتيح على منحنى بيضوي) والمتغيرات الهجينة لـ ML-KEM (خوارزمية تبادل مفاتيح مغلّفة معيارية ما بعد-كمومية) خلال الفترة الانتقالية 2. تفضيل المتغيرات الهجينة عندما يدعمها كلا الطرفين 3. الحفاظ على خيار الرجوع إلى X25519-only لأغراض التوافق الخلفي 4. مراعاة قيود عرض النطاق الترددي للشبكة عند اختيار المتغير الافتراضي\nTunnels المشتركة قد تؤثر زيادة أحجام الرسائل في الاستخدام المشترك للـ tunnel. ينبغي على عمليات التنفيذ أن تراعي: - تجميع المصافحات قدر الإمكان لتخفيف الكلفة الإضافية - استخدام أزمنة انتهاء أقصر للجلسات الهجينة لتقليل الحالة المخزّنة - مراقبة استخدام النطاق الترددي وضبط المعلمات وفقاً لذلك - تطبيق ضبط الازدحام لحركة إنشاء الجلسات\nاعتبارات حجم الجلسة الجديدة نظرًا لكون رسائل المصافحة أكبر حجمًا، قد تحتاج عمليات التنفيذ إلى: - زيادة أحجام المخازن المؤقتة لتفاوض الجلسة (الحد الأدنى الموصى به 4KB) - ضبط قيم المهلة للاتصالات الأبطأ (مراعاة أن الرسائل أكبر بحوالي ~3-17x) - النظر في ضغط بيانات الحمولة في رسائل NS/NSR - تنفيذ آلية التعامل مع التجزئة إذا تطلبت ذلك طبقة النقل\nالاختبار والتحقق يجب على التنفيذات التحقق مما يلي: - صحة توليد المفاتيح بـ ML-KEM (مخطط تبادل مفاتيح قائم على الشبكيات ومقاوم للحوسبة الكمّية)، وعمليتي التغليف وفك التغليف - دمج kem_shared_key بشكل صحيح ضمن Noise KDF (وظيفة اشتقاق المفاتيح في إطار Noise) - تطابق حسابات حجم الرسائل مع المواصفة - قابلية التشغيل البيني مع تنفيذات أخرى لـ I2P router - سلوك التراجع عند عدم توفر ML-KEM\nمتجهات الاختبار لعمليات ML-KEM (آلية تغليف المفاتيح القائمة على الشبكات المعيارية) متاحة في NIST برنامج التحقق من صحة خوارزميات التشفير .\nتوافق الإصدارات ترقيم إصدارات I2P: يحافظ I2P على رقمَي إصدار متوازيين: - إصدار الـ Router: بصيغة 2.x.x (مثلًا، 2.10.0 صدر في سبتمبر 2025) - إصدار واجهة برمجة التطبيقات/البروتوكول: بصيغة 0.9.x (مثلًا، 0.9.67 يتوافق مع router 2.10.0)\nتُشير هذه المواصفة إلى إصدار البروتوكول 0.9.67، الذي يتوافق مع إصدار router 2.10.0 وما بعده.\nمصفوفة التوافق:\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release ## المراجع [ECIES]: مواصفة ECIES-X25519-AEAD-Ratchet [Prop169]: المقترح 169: التشفير ما بعد الكم [FIPS203]: NIST FIPS 203 - معيار ML-KEM [FIPS202]: NIST FIPS 202 - معيار SHA-3 [Noise]: إطار عمل بروتوكول Noise [COMMON]: مواصفة الهياكل المشتركة [RFC7539]: RFC 7539 - ChaCha20 و Poly1305 [RFC5869]: RFC 5869 - HKDF [OpenSSL]: وثائق OpenSSL 3.5 لـ ML-KEM [Bouncycastle]: مكتبة Bouncycastle للتشفير بلغة Java ","description":"صيغة هجينة لما بعد الكم من بروتوكول التشفير ECIES (مخطط التشفير المتكامل القائم على المنحنيات الإهليلجية) باستخدام ML-KEM (آلية تغليف مفاتيح قائمة على شبكيات الوحدات، من تقنيات ما بعد الكم)","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"تشفير هجين باستخدام ECIES-X25519-AEAD-Ratchet (آلية تدوير المفاتيح تدريجياً)","url":"/ar/docs/specs/ecies-hybrid/"},{"categories":null,"content":"لماذا نكتب كوداً خاصاً بـ I2P؟ هناك طرق متعددة لاستخدام التطبيقات في I2P. باستخدام I2PTunnel ، يمكنك استخدام التطبيقات العادية دون الحاجة إلى برمجة دعم صريح لـ I2P. هذا فعال جداً في سيناريوهات العميل-الخادم، حيث تحتاج إلى الاتصال بموقع ويب واحد. يمكنك ببساطة إنشاء tunnel باستخدام I2PTunnel للاتصال بذلك الموقع، كما هو موضح في الشكل 1.\nإذا كان تطبيقك موزعاً، فسيتطلب اتصالات بعدد كبير من النظراء. باستخدام I2PTunnel، ستحتاج إلى إنشاء tunnel جديد لكل نظير تريد الاتصال به، كما هو موضح في الشكل 2. يمكن بالطبع أتمتة هذه العملية، لكن تشغيل العديد من نسخ I2PTunnel يخلق قدراً كبيراً من العبء الإضافي. بالإضافة إلى ذلك، مع العديد من البروتوكولات ستحتاج إلى إجبار الجميع على استخدام نفس مجموعة المنافذ لجميع النظراء — على سبيل المثال، إذا كنت تريد تشغيل محادثة DCC بشكل موثوق، يحتاج الجميع إلى الاتفاق على أن المنفذ 10001 هو أليس، والمنفذ 10002 هو بوب، والمنفذ 10003 هو تشارلي، وهكذا، نظراً لأن البروتوكول يتضمن معلومات خاصة بـ TCP/IP (المضيف والمنفذ).\nغالبًا ما ترسل تطبيقات الشبكة العامة الكثير من البيانات الإضافية التي يمكن استخدامها لتحديد هوية المستخدمين. أسماء المضيفين، وأرقام المنافذ، والمناطق الزمنية، ومجموعات الأحرف، وغيرها غالبًا ما يتم إرسالها دون إعلام المستخدم. وبالتالي، فإن تصميم بروتوكول الشبكة مع وضع إخفاء الهوية في الاعتبار بشكل خاص يمكن أن يتجنب المساس بهويات المستخدمين.\nهناك أيضًا اعتبارات كفاءة يجب مراجعتها عند تحديد كيفية التفاعل على I2P. تعمل مكتبة streaming والأشياء المبنية عليها بمصافحات مشابهة لـ TCP، بينما بروتوكولات I2P الأساسية (I2NP و I2CP) تعتمد بشكل صارم على الرسائل (مثل UDP أو في بعض الحالات raw IP). الفرق المهم هو أنه مع I2P، يعمل الاتصال عبر شبكة طويلة وواسعة — كل رسالة من طرف إلى طرف ستكون لها زمن انتقال غير تافه، لكنها قد تحتوي على حمولات تصل إلى عدة كيلوبايت. التطبيق الذي يحتاج إلى طلب واستجابة بسيطين يمكنه التخلص من أي حالة وإسقاط زمن الانتقال الناتج عن مصافحات البدء والإنهاء باستخدام datagrams (بأفضل جهد ممكن) دون الحاجة للقلق بشأن اكتشاف MTU أو تجزئة الرسائل.\nFigure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. باختصار، عدد من الأسباب لكتابة كود خاص بـ I2P: إنشاء عدد كبير من نسخ I2PTunnel يستهلك قدراً غير بسيط من الموارد، وهو أمر إشكالي للتطبيقات الموزعة (حيث يُطلب tunnel جديد لكل نظير). بروتوكولات الشبكة العامة غالباً ما ترسل الكثير من البيانات الإضافية التي يمكن استخدامها لتحديد هوية المستخدمين. البرمجة المخصصة لـ I2P تسمح بإنشاء بروتوكول شبكة لا يسرّب مثل هذه المعلومات، مما يحافظ على إخفاء هوية المستخدمين وأمانهم. بروتوكولات الشبكة المصممة للاستخدام على الإنترنت العادي قد تكون غير فعالة على I2P، وهي شبكة ذات زمن انتقال (latency) أعلى بكثير. يدعم I2P واجهة ملحقات قياسية للمطورين بحيث يمكن دمج التطبيقات وتوزيعها بسهولة.\nالتطبيقات المكتوبة بلغة Java والقابلة للوصول/التشغيل باستخدام واجهة HTML عبر webapps/app.war القياسية قد يتم النظر في إدراجها ضمن توزيعة I2P.\nالمفاهيم الأساسية هناك بعض التغييرات التي تتطلب التكيف معها عند استخدام I2P:\nالوجهات التطبيق الذي يعمل على I2P يرسل الرسائل من ويستقبل الرسائل إلى نقطة نهاية فريدة محمية تشفيريًا — \u0026ldquo;destination\u0026rdquo;. من حيث TCP أو UDP، يمكن اعتبار الـ destination (إلى حد كبير) معادلاً لزوج اسم المضيف بالإضافة إلى رقم المنفذ، على الرغم من وجود بعض الاختلافات.\nوجهة I2P نفسها هي بنية تشفيرية — جميع البيانات المرسلة إليها مشفرة كما لو كان هناك نشر شامل لـ IPsec مع توقيع موقع نقطة النهاية (المجهولة) كما لو كان هناك نشر شامل لـ DNSSEC. وجهات I2P هي معرفات متنقلة — يمكن نقلها من router I2P إلى آخر (أو يمكن حتى \u0026ldquo;تعدد المواقع\u0026rdquo; — العمل على عدة routers في وقت واحد). هذا يختلف تمامًا عن عالم TCP أو UDP حيث يجب أن تبقى نقطة نهاية واحدة (منفذ) على مضيف واحد. وجهات I2P معقدة وكبيرة — خلف الكواليس، تحتوي على مفتاح عام ElGamal بحجم 2048 بت للتشفير، ومفتاح عام DSA بحجم 1024 بت للتوقيع، وشهادة ذات حجم متغير، قد تحتوي على إثبات العمل أو بيانات مخفية. هناك طرق موجودة للإشارة إلى هذه الوجهات الكبيرة والمعقدة بأسماء قصيرة وجميلة (مثل \u0026ldquo;irc.duck.i2p\u0026rdquo;)، ولكن هذه التقنيات لا تضمن الفرادة العالمية (نظرًا لأنها مخزنة محليًا في قاعدة بيانات على جهاز كل شخص) والآلية الحالية ليست قابلة للتوسع أو آمنة بشكل خاص (تتم إدارة التحديثات لقائمة المضيفين باستخدام \u0026ldquo;الاشتراكات\u0026rdquo; في خدمات التسمية). قد يكون هناك نظام تسمية آمن وقابل للقراءة البشرية وقابل للتوسع وفريد عالميًا في يوم من الأيام، ولكن لا ينبغي للتطبيقات أن تعتمد على وجوده. تتوفر معلومات إضافية عن نظام التسمية .\nبينما معظم التطبيقات لا تحتاج إلى التمييز بين البروتوكولات والمنافذ، فإن I2P يدعم ذلك. يمكن للتطبيقات المعقدة تحديد بروتوكول ومنفذ المصدر ومنفذ الوجهة، على أساس كل رسالة على حدة، لتعدد إرسال حركة البيانات على وجهة واحدة. راجع صفحة datagram للحصول على التفاصيل. تعمل التطبيقات البسيطة من خلال الاستماع إلى \u0026ldquo;جميع البروتوكولات\u0026rdquo; على \u0026ldquo;جميع المنافذ\u0026rdquo; الخاصة بوجهة معينة.\nعدم الكشف عن الهوية والسرية يوفر I2P تشفيرًا شفافًا من طرف إلى طرف ومصادقة لجميع البيانات التي تمر عبر الشبكة — إذا أرسل بوب إلى وجهة أليس، فإن وجهة أليس فقط هي التي يمكنها استقبالها، وإذا كان بوب يستخدم مكتبة الرسائل القصيرة (datagrams) أو مكتبة البث (streaming)، فإن أليس تعلم على وجه اليقين أن وجهة بوب هي التي أرسلت البيانات.\nبالطبع، I2P يُخفي هوية البيانات المرسلة بين أليس وبوب بشكل شفاف، لكنه لا يفعل شيئاً لإخفاء هوية محتوى ما يرسلونه. على سبيل المثال، إذا أرسلت أليس لبوب نموذجاً يحتوي على اسمها الكامل، وبطاقات الهوية الحكومية، وأرقام بطاقات الائتمان، فلا يوجد ما يمكن لـ I2P فعله. وبالتالي، يجب على البروتوكولات والتطبيقات أن تضع في اعتبارها المعلومات التي تحاول حمايتها والمعلومات التي ترغب في الكشف عنها.\nيمكن أن يصل حجم حزم I2P Datagrams إلى عدة كيلوبايت يمكن اعتبار التطبيقات التي تستخدم datagrams في I2P (سواء الخام أو القابلة للرد) بشكل أساسي من حيث UDP — فإن datagrams غير مرتبة، بذل أفضل جهد، وبدون اتصال — ولكن على عكس UDP، لا تحتاج التطبيقات إلى القلق بشأن اكتشاف MTU ويمكنها ببساطة إرسال datagrams كبيرة. بينما الحد الأقصى اسميًا هو 32 كيلوبايت، يتم تجزئة الرسالة للنقل، وبالتالي ينخفض موثوقية الكل. لا يُنصح حاليًا باستخدام datagrams التي يزيد حجمها عن 10 كيلوبايت تقريبًا. راجع صفحة datagram للحصول على التفاصيل. بالنسبة للعديد من التطبيقات، 10 كيلوبايت من البيانات كافية لطلب أو استجابة كاملة، مما يسمح لها بالعمل بشفافية في I2P كتطبيق يشبه UDP دون الحاجة إلى كتابة التجزئة، وإعادة الإرسال، وما إلى ذلك.\nخيارات التطوير هناك عدة طرق لإرسال البيانات عبر I2P، ولكل منها مزاياها وعيوبها. مكتبة streaming lib هي الواجهة الموصى بها، وتستخدمها غالبية تطبيقات I2P.\nمكتبة البث مكتبة البث الكاملة هي الآن الواجهة القياسية. فهي تسمح بالبرمجة باستخدام مقابس (sockets) شبيهة بـ TCP، كما هو موضح في دليل تطوير البث .\nBOB BOB هو Basic Open Bridge ، الذي يسمح لتطبيق بأي لغة برمجة بإنشاء اتصالات بث من وإلى I2P. في الوقت الحالي، لا يدعم UDP، لكن دعم UDP مخطط له في المستقبل القريب. يحتوي BOB أيضاً على عدة أدوات، مثل توليد مفاتيح الوجهة، والتحقق من أن العنوان يتوافق مع مواصفات I2P. يمكن العثور على معلومات محدثة والتطبيقات التي تستخدم BOB في هذا موقع I2P .\nSAM, SAM V2, SAM V3 لا يُنصح باستخدام SAM. SAM V2 مقبول، يُنصح باستخدام SAM V3.\nSAM هو بروتوكول Simple Anonymous Messaging (المراسلة المجهولة البسيطة)، والذي يسمح لأي تطبيق مكتوب بأي لغة برمجة بالتواصل مع جسر SAM عبر مقبس TCP عادي وجعل هذا الجسر يقوم بتعدد إرسال كل حركة مرور I2P الخاصة به، مع التنسيق الشفاف للتشفير/فك التشفير والمعالجة القائمة على الأحداث. يدعم SAM ثلاثة أنماط من التشغيل:\nالتدفقات (streams)، عندما تريد أليس وبوب إرسال البيانات لبعضهما البعض بشكل موثوق ومرتب مخططات البيانات القابلة للرد (repliable datagrams)، عندما تريد أليس إرسال رسالة لبوب يمكن لبوب الرد عليها مخططات البيانات الخام (raw datagrams)، عندما تريد أليس الحصول على أقصى قدر من النطاق الترددي والأداء، ولا يهتم بوب بما إذا كان مُرسل البيانات موثقاً أم لا (مثلاً البيانات المنقولة تكون ذاتية التوثيق) يهدف SAM V3 إلى نفس الهدف الذي يهدف إليه SAM وSAM V2، لكنه لا يتطلب تعدد الإرسال/إلغاء تعدد الإرسال. يتم التعامل مع كل I2P stream من خلال مقبس خاص به بين التطبيق وجسر SAM. بالإضافة إلى ذلك، يمكن إرسال واستقبال البيانات الصغيرة (datagrams) من قبل التطبيق من خلال اتصالات البيانات الصغيرة مع جسر SAM.\nSAM V2 هو إصدار جديد يستخدمه imule يعالج بعض المشاكل الموجودة في SAM .\nSAM V3 يُستخدم من قبل imule منذ الإصدار 1.4.0.\nI2PTunnel يتيح تطبيق I2PTunnel للتطبيقات بناء أنفاق محددة شبيهة بـ TCP إلى النظراء من خلال إنشاء إما تطبيقات I2PTunnel \u0026lsquo;client\u0026rsquo; (التي تستمع على منفذ محدد وتتصل بوجهة I2P محددة كلما تم فتح مقبس لذلك المنفذ) أو تطبيقات I2PTunnel \u0026lsquo;server\u0026rsquo; (التي تستمع إلى وجهة I2P محددة وكلما حصلت على اتصال I2P جديد تقوم بإعادة التوجيه إلى مضيف/منفذ TCP محدد). هذه التدفقات نظيفة 8-بت، ومصادق عليها ومؤمنة من خلال نفس مكتبة البث التي يستخدمها SAM، ولكن هناك عبء غير بسيط يتعلق بإنشاء عدة نسخ فريدة من I2PTunnel، حيث أن لكل منها وجهة I2P فريدة خاصة بها ومجموعتها الخاصة من الأنفاق والمفاتيح، إلخ.\nSOCKS يدعم I2P بروكسي SOCKS V4 وV5. تعمل الاتصالات الصادرة بشكل جيد. قد تكون وظائف الاتصالات الواردة (الخادم) وUDP غير مكتملة وغير مختبرة.\nMinistreaming تمت الإزالة\nكانت هناك مكتبة \u0026ldquo;ministreaming\u0026rdquo; بسيطة، ولكن الآن ministreaming.jar يحتوي فقط على الواجهات (interfaces) لمكتبة streaming الكاملة.\nرسائل البيانات (Datagrams) موصى به لتطبيقات شبيهة بـ UDP\nتتيح مكتبة Datagram إرسال حزم بيانات شبيهة بـ UDP. من الممكن استخدام:\nمخططات البيانات القابلة للرد (Repliable datagrams) مخططات البيانات الخام (Raw datagrams) I2CP غير موصى به\nI2CP نفسه بروتوكول مستقل عن لغة البرمجة، ولكن لتنفيذ مكتبة I2CP بلغة أخرى غير Java يتطلب كتابة كمية كبيرة من الكود (روتينات التشفير، تحويل الكائنات، معالجة الرسائل غير المتزامنة، إلخ). بينما يمكن لشخص ما كتابة مكتبة I2CP بلغة C أو لغة أخرى، سيكون من المفيد على الأرجح استخدام مكتبة SAM بلغة C بدلاً من ذلك.\nتطبيقات الويب يأتي I2P مع خادم الويب Jetty، وتكوينه لاستخدام خادم Apache بدلاً من ذلك أمر بسيط. يجب أن تعمل أي تقنية تطبيقات ويب قياسية.\nابدأ التطوير — دليل بسيط التطوير باستخدام I2P يتطلب تثبيت I2P يعمل بشكل صحيح وبيئة تطوير من اختيارك. إذا كنت تستخدم Java، يمكنك البدء في التطوير باستخدام مكتبة streaming أو مكتبة datagram. باستخدام لغة برمجة أخرى، يمكن استخدام SAM أو BOB.\nالتطوير باستخدام مكتبة Streaming فيما يلي نسخة محدّثة ومختصرة من المثال الموجود في الصفحة الأصلية. للحصول على المثال الكامل، راجع الصفحة القديمة أو أمثلة Java الخاصة بنا في قاعدة الكود.\n// Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\u0026#34;Received: \u0026#34; + s); } مثال على الكود: خادم أساسي يستقبل البيانات.\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\u0026#34;Hello I2P!\\n\u0026#34;); bw.flush(); مثال على الكود: العميل يتصل ويرسل سطراً.\n","description":"لماذا نكتب تطبيقات خاصة بـ I2P، المفاهيم الأساسية، خيارات التطوير، ودليل بسيط للبدء","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"تطوير التطبيقات","url":"/ar/docs/develop/applications/"},{"categories":null,"content":" الحالة: محدّث حتى I2P 2.10.0 (أكتوبر 2025). تجمع هذه القائمة جميع المنافذ النشطة والمهملة والمحجوزة المستخدمة بواسطة I2P Java Router وi2pd والإضافات ذات الصلة. جميع المنافذ مدرجة بترتيب رقمي للحفاظ على الاتساق.\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. ## ملاحظات التنفيذ جميع المنافذ أقل من 9000 (باستثناء 8887) ترتبط بـ 127.0.0.1 افتراضيًا لأسباب أمنية. يجب أن يكون منفذ شبكة الـ router (9151–30777) مفتوحًا للإنترنت للمشاركة الكاملة. يستخدم i2pd نفس التعيينات في الغالب للتوافق (7070 للوحة التحكم، 7654 I2CP، 7656/7655 SAM). يجب على مطوري الإضافات تنسيق التعيينات الجديدة من خلال مجتمع I2P لتجنب التعارضات. ","description":"مرجع شامل لتعيينات منافذ I2P، منافذ الإضافات، والنطاقات المحجوزة.","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"تعيينات المنافذ","url":"/ar/docs/overview/ports/"},{"categories":null,"content":"يوضح هذا الدليل كيفية تكوين المتصفحات الشائعة لإرسال حركة المرور عبر الوكيل HTTP المدمج في I2P. ويغطي متصفحات Safari وFirefox وChrome/Chromium مع تعليمات مفصلة خطوة بخطوة.\nملاحظات هامة:\nوكيل HTTP الافتراضي في I2P يستمع على 127.0.0.1:4444. يحمي I2P حركة المرور داخل شبكة I2P (مواقع .i2p). تأكد من أن router الخاص بـ I2P يعمل قبل تكوين متصفحك. Safari (macOS) يستخدم Safari إعدادات الوكيل (proxy) على مستوى النظام في macOS.\nStep 1: Open Network Settings افتح Safari وانتقل إلى Safari ← الإعدادات (أو التفضيلات) انقر على علامة التبويب متقدم في قسم البروكسيات، انقر على تغيير الإعدادات\u0026hellip; سيؤدي هذا إلى فتح إعدادات الشبكة في نظام Mac الخاص بك.\nالخطوة 1: فتح إعدادات الشبكة في إعدادات الشبكة، قم بتحديد مربع الاختيار Web Proxy (HTTP) أدخل ما يلي: Web Proxy Server: 127.0.0.1 Port: 4444 انقر على OK لحفظ إعداداتك يمكنك الآن تصفح مواقع .i2p في Safari!\nملاحظة: ستؤثر إعدادات الوكيل هذه على جميع التطبيقات التي تستخدم وكلاء نظام macOS. فكر في إنشاء حساب مستخدم منفصل أو استخدام متصفح مختلف حصريًا لـ I2P إذا كنت ترغب في عزل تصفح I2P.\nFirefox (Desktop) يمتلك Firefox إعدادات البروكسي الخاصة به بشكل مستقل عن النظام، مما يجعله مثاليًا للتصفح المخصص عبر I2P.\nالخطوة 2: تكوين بروكسي HTTP انقر على زر القائمة (☰) في أعلى اليمين اختر الإعدادات Step 2: Find Proxy Settings في مربع البحث بالإعدادات، اكتب \u0026ldquo;proxy\u0026rdquo; قم بالتمرير إلى إعدادات الشبكة انقر على زر الإعدادات\u0026hellip; الخطوة 1: افتح الإعدادات اختر إعداد البروكسي يدوياً أدخل ما يلي: HTTP Proxy: 127.0.0.1 Port: 4444 اترك SOCKS Host فارغاً (إلا إذا كنت تحتاج بروكسي SOCKS تحديداً) حدد Proxy DNS when using SOCKS فقط إذا كنت تستخدم بروكسي SOCKS انقر OK للحفظ يمكنك الآن تصفح مواقع .i2p في Firefox!\nنصيحة: فكر في إنشاء ملف تعريف Firefox منفصل مخصص لتصفح I2P. يحافظ هذا على عزل تصفح I2P الخاص بك عن التصفح العادي. لإنشاء ملف تعريف، اكتب about:profiles في شريط عنوان Firefox.\nChrome / Chromium (Desktop) متصفحات Chrome والمتصفحات المبنية على Chromium (مثل Brave وEdge وغيرها) تستخدم عادةً إعدادات الوكيل (proxy) الخاصة بالنظام على Windows وmacOS. يوضح هذا الدليل إعداد Windows.\nالخطوة 2: العثور على إعدادات البروكسي انقر على قائمة النقاط الثلاث (⋮) في الأعلى على اليمين اختر الإعدادات الخطوة 3: تكوين البروكسي يدويًا في مربع البحث في الإعدادات، اكتب \u0026ldquo;proxy\u0026rdquo; انقر على فتح إعدادات الوكيل (proxy) في جهازك Step 3: Open Manual Proxy Setup سيؤدي هذا إلى فتح إعدادات الشبكة والإنترنت في Windows.\nقم بالتمرير لأسفل إلى إعداد الوكيل يدويًا انقر على إعداد الخطوة 1: افتح إعدادات Chrome قم بتبديل استخدام خادم بروكسي إلى تشغيل أدخل ما يلي: عنوان IP للبروكسي: 127.0.0.1 المنفذ: 4444 اختيارياً، أضف استثناءات في \u0026ldquo;عدم استخدام خادم البروكسي للعناوين التي تبدأ بـ\u0026rdquo; (مثلاً، localhost;127.*) انقر على حفظ يمكنك الآن تصفح مواقع .i2p في Chrome!\nملاحظة: تؤثر هذه الإعدادات على جميع المتصفحات المبنية على Chromium وبعض التطبيقات الأخرى على Windows. لتجنب ذلك، يُفضل استخدام Firefox مع ملف تعريف I2P مخصص بدلاً من ذلك.\nالخطوة 2: افتح إعدادات الوكيل (Proxy) على نظام Linux، يمكنك تشغيل Chrome/Chromium باستخدام إعدادات البروكسي (proxy flags) لتجنب تغيير إعدادات النظام:\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; أو قم بإنشاء سكريبت مشغّل لسطح المكتب:\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; علامة --user-data-dir تنشئ ملف تعريف Chrome منفصل لتصفح I2P.\nFirefox (سطح المكتب) إصدارات Firefox الحديثة \u0026ldquo;Fenix\u0026rdquo; تقيد about:config والإضافات افتراضياً. IceRaven هو fork لـ Firefox يُمكّن مجموعة منتقاة من الإضافات، مما يجعل إعداد البروكسي بسيطاً.\nالتكوين المعتمد على الإضافات (IceRaven):\nإذا كنت تستخدم IceRaven بالفعل، فكر في مسح سجل التصفح أولاً (القائمة → السجل → حذف السجل). 2) افتح القائمة → الإضافات → مدير الإضافات. 3) ثبّت الإضافة \u0026ldquo;I2P Proxy for Android and Other Systems\u0026rdquo;. 4) سيقوم المتصفح الآن بالاتصال عبر I2P. يعمل هذا الامتداد أيضًا على متصفحات Firefox القائمة على ما قبل Fenix إذا تم تثبيته من AMO .\nتفعيل دعم الإضافات الموسع في Firefox Nightly يتطلب عملية منفصلة موثقة من قبل Mozilla .\nInternet Explorer / Windows System Proxy على نظام Windows، يُطبَّق مربع حوار البروكسي الخاص بالنظام على IE ويمكن أن تستخدمه المتصفحات المبنية على Chromium عندما ترث إعدادات النظام.\nافتح \u0026ldquo;إعدادات الشبكة والإنترنت\u0026rdquo; ← \u0026ldquo;Proxy\u0026rdquo;. 2) فعّل \u0026ldquo;استخدام خادم proxy لشبكة LAN الخاصة بك\u0026rdquo;. 3) اضبط العنوان 127.0.0.1، المنفذ 4444 لـ HTTP.. 4) اختياريًا، فعّل \u0026ldquo;تجاوز خادم proxy للعناوين المحلية\u0026rdquo;. ","description":"تكوين المتصفحات الشائعة لاستخدام بروكسيات HTTP/HTTPS الخاصة بـ I2P على سطح المكتب و Android","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"تكوين متصفح الويب","url":"/ar/docs/guides/browser-config/"},{"categories":null,"content":"نظرة عامة ملحقات I2P هي أرشيفات موقّعة توسّع وظائف الـ router (الموجّه الخاص بـ I2P). تُوزَّع كملفات .xpi2p أو .su3، وتُثبَّت في ~/.i2p/plugins/\u0026lt;name\u0026gt;/ (أو %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\ على Windows)، وتعمل بكامل صلاحيات الـ router من دون عزل (sandboxing).\nأنواع الإضافات المدعومة تطبيقات ويب للوحة التحكم eepsites جديدة مع cgi-bin وتطبيقات ويب سمات لوحة التحكم ترجمات لوحة التحكم برامج Java (ضمن العملية أو على JVM منفصل (آلة جافا الافتراضية)) سكربتات shell والملفات الثنائية الأصلية نموذج الأمان حرِج: تعمل الإضافات في نفس JVM (آلة جافا الافتراضية) وبأذونات متطابقة مع الـ I2P router. لديها وصول غير مقيّد إلى: - نظام الملفات (قراءة وكتابة) - واجهات برمجة تطبيقات الـ router والحالة الداخلية - اتصالات الشبكة - تنفيذ البرامج الخارجية\nيجب التعامل مع المكوّنات الإضافية على أنها برمجيات موثوقة بالكامل. يجب على المستخدمين التحقق من مصادر المكوّنات الإضافية وتواقيعها قبل التثبيت.\nتنسيقات الملفات صيغة SU3 (موصى بها بشدة) الحالة: نشط، التنسيق المفضّل منذ I2P 0.9.15 (سبتمبر 2014)\nيوفّر تنسيق .su3 ما يلي: - مفاتيح توقيع RSA-4096 (مقابل DSA-1024 في xpi2p) - التوقيع مُخزَّن في رأس الملف - الرقم السحري: I2Psu3 - توافقية مستقبلية أفضل\nالبنية:\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] تنسيق XPI2P (متقادم، مهمل) الحالة: مدعوم لأغراض التوافق مع الإصدارات السابقة، غير موصى به للمكوّنات الإضافية الجديدة\nيستخدم تنسيق .xpi2p تواقيع تشفيرية أقدم: - تواقيع DSA-1024 (مهملة وفقًا لـ NIST-800-57) - توقيع DSA بطول 40 بايت يُضاف في مقدمة ملف ZIP - يتطلب الحقل key في plugin.config\nالبنية:\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] مسار الترحيل: عند الانتقال من xpi2p إلى su3، وفّر كلًا من updateURL وupdateURL.su3 خلال فترة الانتقال. تُعطي routers الحديثة (0.9.15+) الأولوية تلقائيًا لـ SU3.\nهيكل الأرشيف و plugin.config الملفات المطلوبة plugin.config - ملف تهيئة قياسي لـ I2P يحتوي على أزواج المفتاح-القيمة\nالخصائص المطلوبة Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format **أمثلة على صيغ الإصدار:** - `1.2.3` - `1.2.3-4` - `2.0.0-beta.1` الفواصل المسموح بها: . (نقطة)، - (شرطة)، _ (شرطة سفلية)\nخصائص البيانات الوصفية الاختيارية عرض المعلومات date - تاريخ الإصدار (طابع زمني طويل في Java) author - اسم المطوّر (يُوصى بـ user@mail.i2p) description - وصف باللغة الإنجليزية description_xx - وصف محلي (xx = رمز اللغة) websiteURL - الصفحة الرئيسية للملحق (http://foo.i2p/) license - معرّف الترخيص (مثل \u0026ldquo;Apache-2.0\u0026rdquo;, \u0026ldquo;GPL-3.0\u0026rdquo;) تحديث الإعدادات updateURL - موقع تحديث XPI2P (قديم) updateURL.su3 - موقع تحديث SU3 (مُفضَّل) min-i2p-version - أدنى إصدار مطلوب من I2P max-i2p-version - أقصى إصدار متوافق من I2P min-java-version - أدنى إصدار من Java (مثلًا، 1.7، 17) min-jetty-version - أدنى إصدار من Jetty (استخدم 6 لـ Jetty 6+) max-jetty-version - أقصى إصدار من Jetty (استخدم 5.99999 لـ Jetty 5) سلوك التثبيت dont-start-at-install - القيمة الافتراضية false. إذا كانت true، يتطلب بدءاً يدوياً router-restart-required - القيمة الافتراضية false. يبلغ المستخدم بأن إعادة التشغيل مطلوبة بعد التحديث update-only - القيمة الافتراضية false. يفشل إذا لم يكن المُلحق مثبت مسبقاً install-only - القيمة الافتراضية false. يفشل إذا كان المُلحق موجود بالفعل min-installed-version - أدنى إصدار مطلوب للتحديث max-installed-version - أقصى إصدار يمكن تحديثه disableStop - القيمة الافتراضية false. يخفي زر الإيقاف إذا كانت true تكامل وحدة التحكم consoleLinkName - نص رابط شريط ملخّص وحدة التحكم consoleLinkName_xx - نص رابط مترجم حسب اللغة (xx = رمز اللغة) consoleLinkURL - وجهة الرابط (على سبيل المثال، /appname/index.jsp) consoleLinkTooltip - نص التلميح عند تمرير المؤشر (مدعوم منذ 0.7.12-6) consoleLinkTooltip_xx - التلميح المترجم console-icon - مسار أيقونة 32×32 (مدعوم منذ 0.9.20) icon-code - صورة PNG مقاس 32×32 مُرمَّزة بصيغة Base64 للإضافات التي لا تحتوي على موارد ويب (منذ 0.9.25) متطلبات المنصّة (للعرض فقط) required-platform-OS - متطلب نظام التشغيل (غير ملزم) other-requirements - متطلبات إضافية (مثلًا، \u0026ldquo;Python 3.8+\u0026rdquo;) إدارة التبعيات (غير منفذة) depends - قائمة تبعيات الإضافة مفصولة بفواصل depends-version - متطلبات الإصدارات للتبعيات langs - محتويات حزمة اللغة type - نوع الإضافة (app/theme/locale/webapp) استبدال المتغيرات في عنوان URL للتحديث حالة الميزة: متاحة منذ I2P 1.7.0 (0.9.53)\nكلٌّ من updateURL وupdateURL.su3 يدعمان متغيّرات خاصّة بالمنصّة:\nالمتغيّرات: - $OS - نظام التشغيل: windows, linux, mac - $ARCH - المعمارية: 386, amd64, arm64\nمثال:\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 النتيجة على Windows AMD64:\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 هذا يتيح استخدام ملف plugin.config واحد لكل بناء مخصص لمنصة محددة.\nبنية الدليل التخطيط القياسي plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration أغراض الدليل console/locale/ - ملفات JAR تحتوي على حزم موارد لترجمات I2P الأساسية - يجب أن تكون الترجمات الخاصة بالمكونات الإضافية في console/webapps/*.war أو lib/*.jar\nconsole/themes/ - يحتوي كل دليل فرعي على سمة كاملة للوحة التحكم - تُضاف تلقائيًا إلى مسار البحث عن السمات\nconsole/webapps/ - ملفات .war للتكامل مع وحدة التحكم - تُشغَّل تلقائياً ما لم تُعطَّل في webapps.config - لا يلزم أن يطابق اسم ملف WAR اسم المكوّن الإضافي\neepsite/ - eepsite كامل مع مثيل Jetty الخاص به - يتطلب تهيئة jetty.xml مع استبدال المتغيرات - راجع أمثلة zzzot وملحق pebble\nlib/ - مكتبات JAR الخاصة بالملحقات - حدّد ضمن classpath (مسار الأصناف) عبر clients.config أو webapps.config\nتهيئة تطبيق الويب تنسيق webapps.config ملف إعدادات I2P قياسي يتحكم في سلوك تطبيق الويب.\nالصياغة:\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar ملاحظات مهمة: - قبل router 0.7.12-9، استخدم plugin.warname.startOnLoad للتوافق - قبل API 0.9.53، كان classpath (مسار الأصناف) يعمل فقط إذا كان warname يطابق اسم الملحق - اعتبارًا من 0.9.53+، يعمل classpath مع أي اسم لتطبيق ويب\nأفضل الممارسات لتطبيقات الويب تنفيذ ServletContextListener\nنفّذ javax.servlet.ServletContextListener لأغراض التنظيف أو أعد تعريف destroy() في servlet (مكوّن خادم في Java) يضمن الإيقاف السليم أثناء التحديثات وعند إيقاف router إدارة المكتبات\nضع ملفات JAR المشتركة في lib/، وليس داخل WAR ارجع عبر classpath (مسار الأصناف) الخاص بـ webapps.config يتيح تثبيت/تحديث الملحقات بشكل منفصل تجنّب تعارض المكتبات\nلا تُضمِّن أبداً ملفات JAR الخاصة بـ Jetty أو Tomcat أو servlet لا تُضمِّن أبداً ملفات JAR من تثبيت I2P القياسي راجع قسم classpath الخاص بالمكتبات القياسية متطلبات التصريف\nلا تُضمِّن ملفات المصدر .java أو .jsp قم بتصريف جميع ملفات JSP مسبقًا لتجنّب تأخيرات بدء التشغيل لا يمكن افتراض توفّر مصرّف Java/JSP التوافق مع واجهة برمجة تطبيقات Servlet\nI2P يدعم Servlet 3.0 (منذ 0.9.30) مسح التعليقات التوضيحية غير مدعوم (@WebContent) يجب توفير واصف النشر التقليدي web.xml إصدار Jetty\nالحالي: Jetty 9 (I2P 0.9.30+) استخدم net.i2p.jetty.JettyStart للتجريد يحمي من تغييرات واجهة برمجة تطبيقات Jetty إعدادات العميل تنسيق clients.config يحدد العملاء (الخدمات) التي يبدأ تشغيلها بواسطة المكوّن الإضافي.\nالعميل الأساسي:\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties عميل مع إيقاف/إلغاء التثبيت:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar مرجع الخصائص Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths ### استبدال المتغيرات يتم استبدال المتغيرات التالية في args وstopargs وuninstallargs وclasspath:\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 ### العملاء المُدارون مقابل العملاء غير المُدارين العملاء المُدارون (موصى به منذ 0.9.4): - يتم إنشاء مثيلاتهم بواسطة ClientAppManager (مدير تطبيقات العميل) - يحافظ على المراجع وتتبع الحالة - إدارة دورة الحياة أسهل - إدارة ذاكرة أفضل\nالعملاء غير المُدارين: - يبدأها الـrouter، دون تتبّع للحالة - يجب التعامل بسلاسة مع استدعاءات البدء/الإيقاف المتعددة - استخدم حالة ثابتة أو ملفات PID (معرّف العملية) للتنسيق - يُستدعى عند إيقاف تشغيل الـrouter (اعتباراً من 0.7.12-3)\nShellService (خدمة سطر الأوامر) (منذ 0.9.53 / 1.7.0) حل عام لتشغيل البرامج الخارجية مع تتبع الحالة تلقائيًا.\nالميزات: - يعالج دورة حياة العملية - يتواصل مع ClientAppManager - إدارة تلقائية لمعرّف العملية (PID) - دعم متعدد المنصات\nالاستخدام:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh بالنسبة إلى البرامج النصية الخاصة بكل منصة:\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH بديل (قديم): اكتب غلاف Java يتحقق من نوع نظام التشغيل، واستدعِ ShellCommand بالملف المناسب .bat أو .sh.\nعملية التثبيت سير تثبيت المستخدم يقوم المستخدم بلصق عنوان URL للملحق في صفحة تهيئة ملحقات وحدة تحكم Router (/configplugins) يقوم Router بتنزيل ملف الملحق التحقق من التوقيع (يفشل إذا كان المفتاح غير معروف وتم تمكين الوضع الصارم) التحقق من سلامة ملف ZIP استخراج وتحليل plugin.config التحقق من توافق الإصدارات (min-i2p-version, min-java-version, إلخ.) اكتشاف تعارض اسم تطبيق الويب إيقاف الملحق الحالي إذا كان تحديثًا التحقق من صحة الدليل (يجب أن يكون ضمن plugins/) استخراج جميع الملفات إلى دليل الملحق تحديث plugins.config بدء تشغيل الملحق (ما لم يكن dont-start-at-install=true) الأمان والثقة إدارة المفاتيح: - نموذج الثقة First-key-seen (القائم على أول مفتاح يتم رؤيته) للموقّعين الجدد - فقط مفاتيح jrandom و zzz مضمّنة مسبقًا - اعتبارًا من 0.9.14.1، يتم رفض المفاتيح غير المعروفة افتراضيًا - يمكن لخاصية متقدمة تجاوز هذا الإعداد لأغراض التطوير\nقيود التثبيت: - يجب أن تُفك الأرشيفات إلى مجلد الإضافات فقط - يرفض المثبّت المسارات خارج plugins/ - يمكن للإضافات الوصول إلى ملفات في أماكن أخرى بعد التثبيت - لا يوجد تشغيل ضمن بيئة معزولة (sandboxing) أو عزل للامتيازات\nآلية التحديث عملية التحقق من التحديث Router يقرأ updateURL.su3 (المفضّل) أو updateURL من plugin.config طلب HTTP HEAD أو GET جزئي لجلب البايتات 41-56 استخراج سلسلة الإصدار من الملف البعيد مقارنة مع الإصدار المثبّت باستخدام VersionComparator إذا كان أحدث، فقم بمطالبة المستخدم أو بالتنزيل تلقائيًا (وفقًا للإعدادات) إيقاف الملحق تثبيت التحديث بدء تشغيل الملحق (إلا إذا تغير تفضيل المستخدم) مقارنة الإصدارات تُقسَّم الإصدارات إلى مكوّنات مفصولة بالنقطة/الشرطة/الشرطة السفلية: - 1.2.3 \u0026lt; 1.2.4 - 1.2.3 \u0026lt; 1.2.3-1 - 2.0.0 \u0026gt; 1.9.9\nأقصى طول: 16 بايت (يجب أن يتطابق مع رأس SUD/SU3)\nأفضل ممارسات التحديث قم دائماً بزيادة رقم الإصدار عند طرح الإصدارات اختبر مسار التحديث بدءاً من الإصدار السابق ضع في الاعتبار router-restart-required للتغييرات الكبرى وفّر كلاً من updateURL وupdateURL.su3 أثناء الترحيل استخدم لاحقة رقم البناء للاختبار (1.2.3-456) مسار الأصناف والمكتبات القياسية متاح دائمًا في Classpath (مسار تحميل الأصناف في جافا) ملفات JAR التالية من $I2P/lib تكون دائماً ضمن classpath (مسار الفئات) لـ I2P 0.9.30+:\nJAR Contents Plugin Usage i2p.jarCore APIRequired for all plugins mstreaming.jarStreaming APIMost plugins need streaming.jarStreaming implementationMost plugins need i2ptunnel.jarI2PTunnelHTTP/server plugins router.jarRouter internalsRarely needed, avoid if possible javax.servlet.jarServlet 3.1, JSP 2.3 APIPlugins with servlets/JSPs jasper-runtime.jarJasper compiler/runtimePlugins with JSPs commons-el.jarEL 3.0 APIJSPs using expression language jetty-i2p.jarJetty utilitiesPlugins starting Jetty org.mortbay.jetty.jarJetty 9 baseCustom Jetty instances sam.jarSAM APIRarely needed addressbook.jarSubscription/blockfileUse NamingService instead routerconsole.jarConsole librariesNot public API, avoid jbigi.jarNative cryptoPlugins should not need systray.jarURL launcherRarely needed wrapper.jarService wrapperPlugins should not need ### ملاحظات خاصة commons-logging.jar: - فارغ منذ 0.9.30 - قبل 0.9.30: Apache Tomcat JULI - قبل 0.9.24: Commons Logging + JULI - قبل 0.9: Commons Logging فقط\njasper-compiler.jar: - فارغ منذ Jetty 6 (0.9)\nsystray4j.jar: - أزيل في 0.9.26\nغير موجود في Classpath (مسار الأصناف) (يجب تحديده) JAR Contents Usage jstl.jarStandard TaglibJSP tag libraries standard.jarStandard TaglibJSP tag libraries ### مواصفة مسار الأصناف في clients.config:\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar في webapps.config:\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar مهم: اعتبارًا من الإصدار 0.7.13-3، أصبحت إعدادات classpath (مسار الصفوف في جافا) خاصة بكل thread (خيط تنفيذ)، وليست على مستوى JVM (آلة جافا الافتراضية). حدّد classpath كاملة لكل عميل.\nمتطلبات إصدار Java المتطلبات الحالية (أكتوبر 2025) I2P 2.10.0 وما قبله: - الحد الأدنى: Java 7 (مطلوب منذ 0.9.24، يناير 2016) - الموصى به: Java 8 أو أحدث\nI2P 2.11.0 وما بعده (قادم): - الحد الأدنى: Java 17+ (أُعلن عنه في ملاحظات إصدار 2.9.0) - تم تقديم تحذير قبل إصدارين (2.9.0 → 2.10.0 → 2.11.0)\nاستراتيجية توافق الإضافات لأقصى قدر من التوافق (حتى I2P 2.10.x):\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 بالنسبة إلى ميزات Java 8+:\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 لميزات Java 11+:\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 التحضير لـ 2.11.0+:\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 أفضل ممارسات الترجمة البرمجية عند الترجمة باستخدام JDK أحدث لاستهداف إصدار أقدم:\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; هذا يمنع استخدام واجهات برمجة التطبيقات (APIs) غير المتاحة في إصدار Java المستهدف.\nضغط Pack200 - ملغى تحديث هام: لا تستخدم Pack200 (تنسيق ضغط خاص بجافا) الحالة: مُهمَل ومحذوف\nأوصت المواصفة الأصلية بشدة باستخدام ضغط Pack200 لتقليل الحجم بنسبة 60-65%. لم يعد ذلك صالحًا.\nالجدول الزمني: - JEP 336: تم وسم Pack200 كمهمل في Java 11 (سبتمبر 2018) - JEP 367: تمت إزالة Pack200 في Java 14 (مارس 2020)\nتنص مواصفة تحديثات I2P الرسمية: \u0026gt; \u0026ldquo;لم تعد ملفات Jar وwar داخل ملف zip تُضغط باستخدام pack200 (آلية ضغط قديمة في Java) كما هو موثّق أعلاه لملفات \u0026lsquo;su2\u0026rsquo;، لأن بيئات تشغيل Java الحديثة لم تعد تدعمه.\u0026rdquo;\nما الذي يجب فعله:\nأزل pack200 (آلية ضغط JAR قديمة في Java) من عمليات البناء فورًا استخدم ضغط ZIP القياسي فكّر في بدائل: ProGuard/R8 (أدوات لتصغير الشيفرة) UPX (أداة لضغط الثنائيات الأصلية) خوارزميات ضغط حديثة (zstd (خوارزمية ضغط عالية الأداء)، brotli (خوارزمية ضغط للويب)) إذا توفّرت أداة فك ضغط مخصصة بالنسبة إلى الملحقات الحالية: - الـ routers القديمة (0.7.11-5 حتى Java 10) لا تزال قادرة على فك ضغط pack200 - الـ routers الجديدة (Java 11+) غير قادرة على فك ضغط pack200 - أعد إصدار الملحقات بدون ضغط pack200\nمفاتيح التوقيع والأمان توليد المفاتيح (صيغة SU3) استخدم البرنامج النصي makeplugin.sh من مستودع i2p.scripts:\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ تفاصيل أساسية: - الخوارزمية: RSA_SHA512_4096 - التنسيق: شهادة X.509 - التخزين: تنسيق مخزن مفاتيح Java\nتوقيع الإضافات # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 أفضل ممارسات إدارة المفاتيح أنشئ مرة واحدة، واحفظها إلى الأبد\nRouters ترفض أسماء مفاتيح مكررة مع مفاتيح مختلفة Routers ترفض مفاتيح مكررة مع أسماء مفاتيح مختلفة يتم رفض التحديثات عند عدم تطابق المفتاح/الاسم التخزين الآمن\nأنشئ نسخة احتياطية من مخزن المفاتيح بأمان استخدم عبارة مرور قوية لا تُدرجها مطلقًا في نظام التحكم بالإصدارات تدوير المفاتيح\nغير مدعوم من قبل البنية المعمارية الحالية خطط لاستخدام المفاتيح على المدى الطويل ضع في الاعتبار مخططات التوقيع المتعدد لتطوير الفرق توقيع DSA القديم (XPI2P) الحالة: يعمل ولكنه متقادم\nتواقيع DSA-1024 المستخدمة في صيغة xpi2p:\nتوقيع بطول 40 بايت مفتاح عام بطول 172 حرفًا بترميز base64 توصي NIST-800-57 بحد أدنى (L=2048, N=224) تستخدم I2P معلمات أضعف (L=1024, N=160) التوصية: استخدم SU3 (تنسيق تحديث موقّع في I2P) مع RSA-4096 بدلًا من ذلك.\nإرشادات تطوير الملحقات أفضل الممارسات الأساسية التوثيق\nوفّر ملف README (ملف التعليمات) واضحاً مع تعليمات التثبيت وثّق خيارات التهيئة والقيم الافتراضية أدرج سجل التغييرات مع كل إصدار حدّد إصدارات I2P/Java المطلوبة تحسين الحجم\nضمّن الملفات الضرورية فقط لا تقم مطلقًا بتجميع ملفات JAR الخاصة بالـ router افصل حزم التثبيت عن حزم التحديث (المكتبات في lib/) استخدم ضغط Pack200 مهمل - استخدم ZIP القياسي التهيئة\nلا تقم أبدًا بتعديل plugin.config أثناء وقت التشغيل استخدم ملف إعدادات منفصلًا لإعدادات وقت التشغيل وثّق إعدادات router المطلوبة (منافذ SAM، tunnels، إلخ) احترم إعدادات المستخدم القائمة استخدام الموارد\nتجنّب الاستهلاك الافتراضي المفرط لعرض النطاق الترددي طبّق حدوداً معقولة لاستخدام وحدة المعالجة المركزية (CPU) نظّف الموارد عند إيقاف التشغيل استخدم daemon threads (خيوط تعمل في الخلفية وتنتهي تلقائياً عند انتهاء التطبيق) حيثما كان ذلك مناسباً الاختبار\nاختبر التثبيت/الترقية/إلغاء التثبيت على جميع المنصات اختبر التحديثات من الإصدار السابق تحقق من توقف/إعادة تشغيل تطبيق الويب أثناء التحديثات اختبر باستخدام الحد الأدنى للإصدار المدعوم من I2P نظام الملفات\nلا تكتب مطلقًا إلى $I2P (قد يكون للقراءة فقط) اكتب بيانات وقت التشغيل إلى $PLUGIN أو $CONFIG استخدم I2PAppContext لاكتشاف الدلائل لا تفترض موقع $CWD التوافق\nلا تكرر فئات I2P القياسية قم بتمديد الفئات إذا لزم الأمر، لا تستبدلها تحقّق من min-i2p-version، min-jetty-version في plugin.config اختبر مع إصدارات I2P الأقدم إذا كنت تدعمها التعامل مع إيقاف التشغيل\nاضبط stopargs بشكل صحيح في clients.config سجّل خطافات إيقاف التشغيل: I2PAppContext.addShutdownTask() تعامل بسلاسة مع استدعاءات البدء/الإيقاف المتعددة اضبط جميع سلاسل التنفيذ على وضع daemon (خدمة تعمل في الخلفية) الأمان\nتحقق من صحة كل المدخلات الخارجية لا تستدعِ System.exit() احترم خصوصية المستخدم اتبع ممارسات البرمجة الآمنة الترخيص\nحدّد رخصة الملحق بوضوح احترم تراخيص المكتبات المضمّنة ضمّن الإسناد المطلوب وفّر الوصول إلى الشيفرة المصدرية إذا كان ذلك مطلوبًا اعتبارات متقدمة التعامل مع المنطقة الزمنية: - يقوم Router بضبط المنطقة الزمنية لـ JVM إلى UTC - المنطقة الزمنية الفعلية للمستخدم: I2PAppContext خاصية i2p.systemTimeZone\nاكتشاف الدليل:\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args ترقيم الإصدارات: - استخدم الترقيم الدلالي (major.minor.patch) - أضف رقم البناء لأغراض الاختبار (1.2.3-456) - تأكد من أن الأرقام تزداد دائمًا ولا تتراجع بين التحديثات\nالوصول إلى صنف Router: - يُفضَّل عموماً تجنّب التبعيات على router.jar - استخدم واجهات برمجة التطبيقات العامة في i2p.jar بدلاً من ذلك - قد يقيّد I2P مستقبلاً الوصول إلى صنف Router\nمنع تعطل JVM (تاريخيًا): - تم الإصلاح في 0.7.13-3 - استخدم محمِّلات الأصناف بشكل صحيح - تجنّب تحديث JARs (ملفات أرشيف جافا) في مُلحق قيد التشغيل - صمِّم بحيث تتم إعادة التشغيل عند التحديث إذا لزم الأمر\nملحقات Eepsite نظرة عامة يمكن للملحقات توفير eepsites كاملة مع مثيلات Jetty و I2PTunnel الخاصة بها.\nالمعمارية لا تحاول القيام بما يلي: - تثبيت في eepsite موجود مسبقًا - دمج مع eepsite الافتراضي الخاص بـ router - افتراض توفر eepsite واحد فقط\nبدلاً من ذلك: - ابدأ مثيلاً جديداً لـ I2PTunnel (عبر أسلوب CLI (سطر الأوامر)) - ابدأ مثيلاً جديداً لـ Jetty - قم بتهيئة كليهما في clients.config\nهيكلية المثال plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] استبدال المتغيرات في jetty.xml استخدم المتغير $PLUGIN للمسارات:\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; يقوم Router بالاستبدال أثناء بدء تشغيل المكوّن الإضافي.\nأمثلة التنفيذات المرجعية: - إضافة zzzot - متعقّب تورنت - إضافة pebble - منصّة تدوين\nكلاهما متاحان في صفحة الملحقات الخاصة بـ zzz (I2P-internal).\nتكامل وحدة التحكم روابط شريط الملخص إضافة رابط قابل للنقر إلى شريط الملخص في لوحة تحكم router:\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface الإصدارات المحلية:\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle أيقونات وحدة التحكم ملف صورة (منذ 0.9.20):\nconsole-icon=/myicon.png مسار نسبي إلى consoleLinkURL إذا تم تحديده (اعتباراً من 0.9.53)، وإلا فنسبي إلى اسم تطبيق الويب.\nأيقونة مضمّنة (منذ 0.9.25):\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... ولّد باستخدام:\nbase64 -w 0 icon-32x32.png أو Java:\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png المتطلبات: - 32x32 بكسل - بصيغة PNG - بترميز Base64 (من دون فواصل أسطر)\nالتدويل حزم الترجمة بالنسبة إلى ترجمات I2P الأساسية: - ضع ملفات JAR في console/locale/ - تحتوي على حزم الموارد لتطبيقات I2P الحالية - التسمية: messages_xx.properties (xx = رمز اللغة)\nلترجمات خاصة بالمكوّنات الإضافية: - ضمّن في console/webapps/*.war - أو ضمّن في lib/*.jar - استخدم نهج Java ResourceBundle (حزمة الموارد في جافا) القياسي\nالسلاسل النصية المترجمة في plugin.config description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble الحقول المدعومة: - description_xx - consoleLinkName_xx - consoleLinkTooltip_xx\nترجمة سمة وحدة التحكم السمات الموجودة في console/themes/ تُضاف تلقائيًا إلى مسار بحث السمات.\nملحقات خاصة بالمنصة نهج الحزم المنفصلة استخدم أسماء ملحقات مختلفة لكل منصة:\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac نهج استبدال المتغيرات ملف plugin.config واحد مع متغيرات المنصة:\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 في clients.config:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH اكتشاف نظام التشغيل وقت التشغيل مقاربة Java للتنفيذ الشرطي:\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } استكشاف الأخطاء وإصلاحها المشكلات الشائعة الإضافة لا تبدأ: 1. تحقق من توافق إصدار I2P (min-i2p-version) 2. تحقق من إصدار Java (min-java-version) 3. تحقق من سجلات router بحثًا عن الأخطاء 4. تحقق من توفّر جميع ملفات JAR المطلوبة في مسار الأصناف (classpath)\nتطبيق الويب غير قابل للوصول: 1. أكّد أن webapps.config لا يعطّله 2. تحقّق من توافق إصدار Jetty (min-jetty-version) 3. تحقّق من أن web.xml موجود (لا يُدعَم فحص التعليقات التوضيحية) 4. تحقّق من وجود تعارض في أسماء تطبيقات الويب\nفشل التحديث: 1. تحقّق من أن سلسلة الإصدار قد زادت 2. تحقّق من أن التوقيع يطابق مفتاح التوقيع 3. تأكّد من أن اسم المكوّن الإضافي يطابق الإصدار المثبّت 4. راجع إعدادات update-only/install-only\nالبرنامج الخارجي لا يتوقف: 1. استخدم ShellService لإدارة دورة الحياة تلقائيًا 2. نفذ معالجة صحيحة لـstopargs 3. تحقق من تنظيف ملف PID 4. تأكد من إنهاء العملية\nتسجيل التصحيح تمكين تسجيل التصحيح في router:\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG تحقق من السجلات:\n~/.i2p/logs/log-router-0.txt معلومات مرجعية المواصفات الرسمية مواصفات الإضافة تنسيق التهيئة مواصفات التحديث التشفير سجل إصدارات I2P الإصدار الحالي: - I2P 2.10.0 (8 سبتمبر 2025)\nالإصدارات الرئيسية منذ 0.9.53: - 2.10.0 (سبتمبر 2025) - إعلان بشأن Java 17+ - 2.9.0 (يونيو 2025) - تحذير بشأن Java 17+ - 2.8.0 (أكتوبر 2024) - اختبار التشفير ما بعد الكمّ - 2.6.0 (مايو 2024) - حظر I2P-over-Tor - 2.4.0 (ديسمبر 2023) - تحسينات أمنية في NetDB - 2.2.0 (مارس 2023) - التحكم في الازدحام - 2.1.0 (يناير 2023) - تحسينات الشبكة - 2.0.0 (نوفمبر 2022) - بروتوكول نقل SSU2 - 1.7.0/0.9.53 (فبراير 2022) - ShellService, استبدال المتغيرات - 0.9.15 (سبتمبر 2014) - تم تقديم تنسيق SU3\nترقيم الإصدارات: - سلسلة 0.9.x: حتى الإصدار 0.9.53 - سلسلة 2.x: بدءًا من 2.0.0 (تقديم SSU2)\nموارد المطورين الشيفرة المصدرية: - المستودع الرئيسي: https://i2pgit.org/I2P_Developers/i2p.i2p - مرآة GitHub: https://github.com/i2p/i2p.i2p أمثلة على الإضافات: - zzzot (متعقب BitTorrent) - pebble (منصة تدوين) - i2p-bote (بريد إلكتروني دون خوادم) - orchid (عميل Tor) - seedless (تبادل الأقران)\nأدوات البناء: - makeplugin.sh - توليد المفاتيح والتوقيع - موجود في مستودع i2p.scripts - يؤتمت إنشاء su3 (صيغة حزمة موقعة خاصة بـ I2P) والتحقق منها\nدعم المجتمع المنتديات: - منتدى I2P - zzz.i2p (متاح داخل I2P فقط)\nIRC/الدردشة: - #i2p-dev على OFTC - I2P IRC داخل الشبكة\nالملحق أ: مثال كامل لملف plugin.config # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space الملحق ب: مثال كامل لملف clients.config # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config الملحق C: مثال كامل لملف webapps.config # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true الملحق د: قائمة التحقق من الترحيل (0.9.53 إلى 2.10.0) التغييرات المطلوبة إزالة ضغط Pack200 (تنسيق ضغط لملفات JAR في Java) من عملية البناء\nإزالة مهام pack200 من البرامج النصية لـ Ant/Maven/Gradle إعادة إصدار المكونات الإضافية الحالية بدون pack200 مراجعة متطلبات إصدار جافا\nالنظر في اشتراط جافا 11+ للميزات الجديدة التخطيط لاشتراط جافا 17+ في I2P 2.11.0 تحديث min-java-version في plugin.config تحديث الوثائق\nإزالة مراجع Pack200 تحديث متطلبات إصدار Java تحديث مراجع إصدارات I2P (0.9.x → 2.x) التغييرات الموصى بها عزّز التواقيع الرقمية\nانقل من XPI2P (صيغة إضافات قديمة في I2P) إلى SU3 (تنسيق تحديثات موقّع في I2P) إذا لم يتم ذلك بالفعل استخدم مفاتيح RSA-4096 للإضافات الجديدة الاستفادة من الميزات الجديدة (إذا كنت تستخدم 0.9.53+)\nاستخدم متغيرات $OS / $ARCH للتحديثات المخصّصة للمنصة استخدم ShellService (خدمة سطر الأوامر) للبرامج الخارجية استخدم مسار classpath المحسّن لتطبيقات الويب (يعمل مع أي اسم WAR) اختبار التوافق\nاختبر على I2P 2.10.0 تحقق باستخدام Java 8، 11، 17 تحقق على Windows وLinux وmacOS تحسينات اختيارية تنفيذ ServletContextListener بالشكل الصحيح (مستمع سياق Servlets في Java) إضافة أوصاف مُحلية توفير أيقونة لوحدة التحكم تحسين معالجة إيقاف التشغيل إضافة تسجيل شامل كتابة اختبارات مؤتمتة ","description":".xpi2p / .su3 قواعد التحزيم لإضافات I2P","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"تنسيق حزمة المكوّن الإضافي","url":"/ar/docs/specs/plugin/"},{"categories":null,"content":"تمكّن مرشحات الوصول مشغّلي خوادم I2PTunnel من السماح بالاتصالات الواردة أو رفضها أو تقييدها استنادًا إلى Destination (المعرّف العام في I2P) الخاص بالمصدر ومعدّل الاتصالات الأخيرة. المرشّح عبارة عن ملف نصي بسيط يحتوي على قواعد. يُقرأ الملف من الأعلى إلى الأسفل وتفوز أول قاعدة مطابقة.\nتصبح تغييرات تعريف عامل التصفية نافذة المفعول عند إعادة تشغيل tunnel. قد تقوم بعض الإصدارات بإعادة قراءة القوائم المعتمدة على الملفات أثناء وقت التشغيل، لكن خطط لإعادة تشغيل tunnel لضمان تطبيق التغييرات.\nتنسيق الملف قاعدة واحدة لكل سطر. يتم تجاهل الأسطر الفارغة. الرمز # يبدأ تعليقًا يمتد حتى نهاية السطر. تُقيَّم القواعد بالترتيب؛ يُستخدم أول تطابق. العتبات تحدد العتبة عدد محاولات الاتصال القادمة من وجهة واحدة المسموح بها ضمن نافذة زمنية منزلقة.\nعددي: N/S تعني السماح بـN اتصالاً لكل S ثانية. مثال: 15/5 يتيح ما يصل إلى 15 اتصالاً كل 5 ثوانٍ. تُرفَض المحاولة N+1 ضمن النافذة الزمنية. الكلمات المفتاحية: allow تعني لا يوجد حد. deny تعني الرفض دائماً. صياغة القواعد تكون القواعد على النحو التالي:\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; حيث:\n\u0026lt;threshold\u0026gt; هو N/S، allow، أو deny \u0026lt;scope\u0026gt; هو واحد من default، explicit، file، أو record (انظر أدناه) \u0026lt;target\u0026gt; يعتمد على النطاق القاعدة الافتراضية يُطبَّق عندما لا تنطبق أي قاعدة أخرى. يُسمَح بقاعدة افتراضية واحدة فقط. إذا لم تُحدَّد، يُسمَح بالوجهات غير المعروفة دون قيود.\n15/5 default allow default deny default قاعدة صريحة يستهدف وجهة محددة عبر عنوان Base32 (على سبيل المثال example1.b32.i2p) أو المفتاح الكامل.\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p قاعدة مستندة إلى الملفات يستهدف كل الوجهات المدرجة في ملف خارجي. يحتوي كل سطر على وجهة واحدة؛ تعليقات # والأسطر الفارغة مسموح بها.\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt ملاحظة تشغيلية: بعض التطبيقات تعيد قراءة قوائم الملفات بشكل دوري. إذا قمت بتحرير قائمة أثناء تشغيل tunnel، فتوقع تأخيراً قصيراً قبل ملاحظة التغييرات. أعد التشغيل لتطبيقها فوراً.\nمسجل (تحكم تدريجي) يقوم مسجّل بمراقبة محاولات الاتصال ويكتب الوجهات التي تتجاوز عتبة معينة إلى ملف. بعد ذلك يمكنك الإشارة إلى ذلك الملف في قاعدة file لتطبيق قيود السرعة أو الحظر على المحاولات المستقبلية.\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt تحقق من دعم المُسجِّل ضمن بنية مشروعك قبل الاعتماد عليه. استخدم قوائم file لضمان سلوك مضمون.\nترتيب التقييم ضع القواعد المحددة أولاً، ثم العامة. نمط شائع:\nسماح صريح للنظراء الموثوقين رفض صريح للمسيئين المعروفين قوائم سماح/رفض مستندة إلى الملفات مسجلات للخنق التدريجي قاعدة افتراضية شاملة مثال كامل # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt ملاحظات التنفيذ يعمل مرشح الوصول على طبقة الـ tunnel، قبل معالجة التطبيقات، مما يسمح برفض حركة المرور المسيئة مبكراً. ضع ملف المرشح في دليل تهيئة I2PTunnel لديك، ثم أعد تشغيل الـ tunnel لتطبيق التغييرات. شارك القوائم المعتمدة على الملفات عبر عدة tunnels إذا كنت تريد سياسة متسقة عبر الخدمات. ","description":"صياغة ملفات تصفية التحكم بالوصول لـ tunnel","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"تنسيق عامل تصفية الوصول","url":"/ar/docs/specs/filter-format/"},{"categories":null,"content":"نظرة عامة ملاحظة: متقادم - نحن الآن ندعم ثلاثة تنسيقات، مرتبة حسب الأفضلية:\nMaxmind geoip2 (GeoLite2-Country.mmdb) مُضمَّن مع جميع عمليات التثبيت باستثناء حزم Debian وAndroid Maxmind geoip1 (GeoIP.dat) في حزمة Debian geoip-database تنسيق Tor الخاص بـ IPv4 (geoip.txt) والتنسيق المخصص لـ IPv6 (geoipv6.dat.gz) الموثقان أدناه، لا يزالان مدعومين ولكن غير مستخدمين. تحدد هذه الصفحة تنسيق ملفات GeoIP المختلفة، التي يستخدمها الـ router للبحث عن البلد المرتبط بعنوان IP.\nتنسيق اسم الدولة (countries.txt) يمكن إنشاء هذا التنسيق بسهولة من ملفات بيانات متاحة من العديد من المصادر العامة. على سبيل المثال:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt مواصفات التنسيق:\nالترميز هو UTF-8 الرمز \u0026lsquo;#\u0026rsquo; في العمود 1 يُشير إلى سطر تعليق أسطر الإدخال هي CountryCode,CountryName CountryCode هو رمز ISO المكوّن من حرفين، بحروف كبيرة CountryName باللغة الإنجليزية تنسيق IPv4 (geoip.txt) هذا التنسيق مُقتبس من Tor ويسهل توليده من ملفات بيانات متاحة من العديد من المصادر العامة. على سبيل المثال:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt مواصفات التنسيق:\nالترميز هو ASCII يشير الرمز \u0026lsquo;#\u0026rsquo; في العمود 1 إلى سطر تعليق أسطر الإدخال هي FromIP,ToIP,CountryCode FromIP و ToIP هما تمثيلات عددية غير موقّعة لعنوان IP ذي 4 بايت CountryCode هو رمز ISO المكوّن من حرفين، بالأحرف الكبيرة يجب ترتيب أسطر الإدخال حسب قيمة FromIP الرقمية تنسيق IPv6 (geoipv6.dat.gz) هذا تنسيق ثنائي مضغوط مصمم لـ I2P. الملف مضغوط بصيغة gzip. التنسيق بعد فك gzip:\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) ملاحظات:\nيجب ترتيب البيانات (long موقّع بتمثيل المتمم لاثنين)، دون أي تداخل. لذا يكون الترتيب 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF. تحتوي الفئة GeoIPv6.java على برنامج لتوليد هذا التنسيق من مصادر عامة مثل بيانات Maxmind GeoLite. يتم دعم استعلام GeoIP عبر IPv6 اعتبارًا من الإصدار 0.9.8. ","description":"مواصفات صيغة ملف GeoIP القديمة لعمليات البحث من عنوان IP إلى البلد","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"تنسيقات ملفات GeoIP","url":"/ar/docs/legacy/%D8%AA%D9%86%D8%B3%D9%8A%D9%82%D8%A7%D8%AA-%D9%85%D9%84%D9%81%D8%A7%D8%AA-geoip/"},{"categories":null,"content":" الحالة المتقادمة: يُحتفَظ بهذا المحتوى كمرجع تاريخي فقط. يوثّق نظام tunnel الذي كان مُضمَّناً قبل I2P 0.6.1.10، ولا ينبغي استخدامه في التطوير الحديث. راجع التنفيذ الحالي للحصول على إرشادات الإنتاج.\nكان النظام الفرعي الأصلي لـ tunnel يستخدم أيضًا tunnels أحادية الاتجاه، لكنه اختلف في بنية الرسائل، وكشف التكرار، وإستراتيجية البناء. تعكس العديد من الأقسام أدناه بنية الوثيقة المُهملة لتيسير المقارنة.\n1. نظرة عامة على Tunnel (نفق) كانت tunnels تُبنى كسلاسل مرتبة من الأقران يختارها المنشئ. تراوحت أطوال Tunnel بين 0–7 قفزات، مع عدة خيارات ضبط للحشو، وتقييد المعدل، وتوليد chaff (بيانات مضللة). كانت tunnels الواردة تسلّم الرسائل من بوابة غير موثوقة إلى المنشئ (نقطة النهاية)؛ وكانت tunnels الصادرة تدفع البيانات بعيداً عن المنشئ. كانت مدة حياة Tunnel تبلغ 10 دقائق، وبعدها كان يتم إنشاء tunnels جديدة (غالباً باستخدام الأقران أنفسهم ولكن بمعرّفات Tunnel مختلفة). 2. آلية العمل في التصميم القديم 2.1 المعالجة المسبقة للرسائل جمعت البوابات ≤32 KB من حمولة I2NP، واختارت الحشو، وأنتجت حمولة تحتوي على:\nحقل طول الحشو من بايتين، وذلك العدد من البايتات العشوائية تسلسل من أزواج {instructions, I2NP message} يصف وجهات الإيصال، والتجزئة، والتأخيرات الاختيارية رسائل I2NP كاملة محشوة حتى حدّ 16 بايت قامت تعليمات التسليم بتعبئة معلومات التوجيه ضمن حقول بتية (نوع التسليم، أعلام التأخير، أعلام التجزئة، وامتدادات اختيارية). حملت الرسائل المجزأة معرّف رسالة بطول 4 بايت إضافةً إلى علم الفهرس/الجزء الأخير.\n2.2 تشفير البوابة ثبّت التصميم القديم طول الـ tunnel عند ثماني قفزات لمرحلة التشفير. قامت البوابات بتكديس AES-256/CBC مع كتل الـ checksum (المجموع الاختباري) لكي يتمكّن كل قفزة من التحقق من سلامة البيانات من دون تقليل حجم الحمولة. وكان الـ checksum نفسه كتلة مشتقة من SHA-256 مُضمّنة داخل الرسالة.\n2.3 سلوك المشاركين قام المشاركون بتتبع معرّفات tunnel الواردة، وتحققوا مبكراً من سلامة البيانات، وأسقطوا النسخ المكررة قبل إعادة التوجيه. ونظراً لأن الحشو وكتل التحقق كانت مضمنة، ظل حجم الرسالة ثابتاً بغض النظر عن عدد القفزات.\n2.4 معالجة نقطة النهاية قامت نقاط النهاية بفك تشفير الكتل الطبقية على نحو تسلسلي، وتحققت من المجاميع الاختبارية، وأعادت تجزئة الحمولة إلى تعليمات مُرمَّزة وإلى رسائل I2NP لمواصلة الإيصال.\n3. إنشاء Tunnel (عملية مهملة) اختيار الأقران: تم اختيار الأقران من ملفات تعريف مُدارة محلياً (استكشافية مقابل عميل). وقد شدد المستند الأصلي بالفعل على التخفيف من هجوم السلف عبر إعادة استخدام قوائم الأقران المرتَّبة لكل tunnel pool. تسليم الطلبات: تم تمرير رسائل البناء قفزةً فَقَفزة مع أقسام مُشفّرة لكل نظير. نوقشت أفكار بديلة مثل الامتداد التلسكوبي، وإعادة التوجيه في منتصف المسار، أو إزالة كتل المجموع الاختباري كتجارب، لكنها لم تُعتمد قط. التجميع: كانت كل وجهة محلية تحتفظ بـ inbound و outbound tunnel pools منفصلة. وشملت الإعدادات العدد المرغوب، وbackup tunnels، وتفاوت الطول، وتحديد المعدل، وسياسات الحشو. 4. مفاهيم تقييد المعدّل والخلط اقترحت الوثيقة القديمة عدة استراتيجيات ساهمت في توجيه الإصدارات اللاحقة:\nالاستبعاد المبكر العشوائي المُوزَّن (WRED) للتحكم في الازدحام محددات معدل لكل tunnel تستند إلى المتوسطات المتحركة للاستخدام الحديث ضوابط chaff (حزم وهمية للتشويش) والتجميع الاختيارية (غير مُنفَّذة بالكامل) 5. البدائل المؤرشفة تناولت أقسام من الوثيقة الأصلية أفكارا لم تُنفذ قط:\nإزالة كتل المجموع الاختباري لتقليص المعالجة لكل قفزة تمديد تدريجي لـtunnels (قنوات توجيه خاصة في I2P) أثناء التشغيل لتغيير تركيبة الأقران التحول إلى tunnels ثنائية الاتجاه (رُفضت في نهاية المطاف) استخدام تجزئات أقصر أو أنظمة حشو مختلفة تظل هذه الأفكار سياقاً تاريخياً قيّماً لكنها لا تعكس القاعدة البرمجية الحديثة.\nالمراجع أرشيف المستندات القديمة الأصلي (قبل 0.6.1.10) نظرة عامة على Tunnel للمصطلحات الحالية تحليل ملفات تعريف الأقران واختيارهم للاستدلالات الحديثة ","description":"وصف مؤرشف لتصميم الـ tunnel (نفق) المستخدم قبل I2P 0.6.1.10.","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"تنفيذ Tunnel القديم (إصدار قديم)","url":"/ar/docs/legacy/old-implementation/"},{"categories":null,"content":"نظرة عامة يبني I2P أنفاقًا مؤقتة أحادية الاتجاه — تسلسلات مرتبة من routers التي تعيد توجيه حركة البيانات المشفرة. تُصنّف tunnels على أنها inbound (تتدفق الرسائل نحو المنشئ) أو outbound (تتدفق الرسائل بعيدًا عن المنشئ).\nيقوم التبادل النموذجي بتوجيه رسالة أليس عبر أحد أنفاقها الصادرة (outbound tunnels)، ثم يوجه نقطة النهاية الصادرة لإعادة توجيهها إلى بوابة أحد أنفاق بوب الواردة (inbound tunnels)، وبعد ذلك يستقبلها بوب عند نقطة النهاية الواردة الخاصة به.\nA: Outbound Gateway (أليس) B: Outbound Participant C: Outbound Endpoint D: Inbound Gateway E: Inbound Participant F: Inbound Endpoint (بوب) تمتلك الأنفاق عمرًا افتراضيًا ثابتًا مدته 10 دقائق وتحمل رسائل ذات حجم ثابت يبلغ 1024 بايت (1028 بايت بما في ذلك رأس النفق) لمنع تحليل حركة المرور بناءً على حجم الرسالة أو أنماط التوقيت.\nمفردات النفق Tunnel gateway: أول router في النفق. بالنسبة للأنفاق الواردة، تظهر هوية هذا الـ router في LeaseSet المنشور. بالنسبة للأنفاق الصادرة، الـ gateway هو الـ router المصدر (A و D أعلاه). Tunnel endpoint: آخر router في النفق (C و F أعلاه). Tunnel participant: router وسيط في النفق (B و E أعلاه). لا يمكن للمشاركين تحديد موقعهم أو اتجاه النفق. n-hop tunnel: عدد القفزات بين الـ routers. 0-hop: الـ gateway والـ endpoint هما نفس الـ router - إخفاء هوية ضئيل. 1-hop: الـ gateway يتصل مباشرة بالـ endpoint - زمن استجابة منخفض، إخفاء هوية منخفض. 2-hop: الإعداد الافتراضي للأنفاق الاستكشافية؛ توازن بين الأمان والأداء. 3-hop: موصى به للتطبيقات التي تتطلب إخفاء هوية قوي. Tunnel ID: عدد صحيح من 4 بايتات فريد لكل router ولكل قفزة، يتم اختياره عشوائياً من قبل المنشئ. تستقبل كل قفزة وتُعيد التوجيه على معرفات مختلفة. معلومات بناء النفق أجهزة التوجيه (routers) التي تملأ أدوار gateway وparticipant وendpoint تستقبل سجلات مختلفة ضمن رسالة بناء النفق (Tunnel Build Message). يدعم I2P الحديث طريقتين:\nElGamal (قديم، سجلات بحجم 528 بايت) ECIES-X25519 (حالي، سجلات بحجم 218 بايت عبر Short Tunnel Build Message – STBM) Information Distributed to Participants يستقبل البوابة: - مفتاح طبقة النفق (مفتاح AES-256 أو ChaCha20 حسب نوع النفق) - مفتاح IV للنفق (لتشفير متجهات التهيئة) - مفتاح الرد و IV الرد (لتشفير رد البناء) - معرّف النفق (للبوابات الواردة فقط) - hash هوية القفزة التالية ومعرّف النفق (إذا لم يكن طرفياً)\nالمشاركون الوسيطون يتلقون: - مفتاح طبقة tunnel ومفتاح IV للقفزة الخاصة بهم - معرف tunnel ومعلومات القفزة التالية - مفتاح الرد و IV لتشفير استجابة البناء\nتستقبل النقاط النهائية: - مفاتيح طبقة tunnel ومفاتيح IV - router الرد ومعرف tunnel (النقاط النهائية الصادرة فقط) - مفتاح الرد ومفتاح IV (النقاط النهائية الصادرة فقط)\nللحصول على التفاصيل الكاملة، راجع مواصفات إنشاء Tunnel ومواصفات إنشاء Tunnel باستخدام ECIES .\nTunnel Pooling تقوم routers بتجميع tunnels في مجموعات tunnels (tunnel pools) لتحقيق التكرار وتوزيع الحمل. تحافظ كل مجموعة على عدة tunnels متوازية، مما يسمح بالتبديل التلقائي عند فشل أحدها. المجموعات المستخدمة داخلياً هي exploratory tunnels، بينما المجموعات الخاصة بالتطبيقات هي client tunnels.\nتحتفظ كل وجهة بمجموعات منفصلة للاتصالات الواردة والصادرة يتم تكوينها بواسطة خيارات I2CP (عدد الأنفاق، عدد النسخ الاحتياطية، الطول، ومعاملات جودة الخدمة). تراقب الموجهات صحة الأنفاق، وتجري اختبارات دورية، وتعيد بناء الأنفاق الفاشلة تلقائياً للحفاظ على حجم المجموعة.\nتجميع الأنفاق (Tunnel Pooling) أنفاق 0-hop: توفر فقط إمكانية الإنكار المعقول. تنشأ حركة البيانات وتنتهي دائمًا عند نفس الموجه — لا يُنصح بها لأي استخدام مجهول.\nأنفاق ذات قفزة واحدة (1-hop Tunnels): توفر إخفاء هوية أساسي ضد المراقبين السلبيين لكنها عرضة للخطر إذا سيطر خصم على تلك القفزة الوحيدة.\nأنفاق ثنائية القفزات (2-hop Tunnels): تتضمن جهازي توجيه بعيدين وتزيد بشكل كبير من تكلفة الهجوم. الإعداد الافتراضي لمجمعات الاستكشاف.\nأنفاق 3 قفزات: موصى بها للتطبيقات التي تتطلب حماية قوية لإخفاء الهوية. القفزات الإضافية تزيد من زمن الاستجابة دون تحقيق فائدة أمنية ملموسة.\nالإعدادات الافتراضية: تستخدم الـ routers أنفاق استكشافية بـ قفزتين وأنفاق عميل خاصة بالتطبيقات بـ قفزتين أو 3 قفزات، لتحقيق التوازن بين الأداء وعدم الكشف عن الهوية.\nطول النفق تختبر الـ routers الأنفاق بشكل دوري عن طريق إرسال رسالة DeliveryStatusMessage عبر نفق صادر إلى نفق وارد. إذا فشل الاختبار، يتلقى كلا النفقين وزناً سلبياً في الملف الشخصي. تؤدي الإخفاقات المتتالية إلى تمييز النفق على أنه غير قابل للاستخدام؛ ثم يقوم الـ router بإعادة بناء بديل ونشر LeaseSet جديد. تُغذي النتائج مقاييس سعة الأقران المستخدمة بواسطة نظام اختيار الأقران .\nاختبار الأنفاق تقوم أجهزة الـ router ببناء الأنفاق (tunnels) باستخدام طريقة تلسكوبية غير تفاعلية: حيث تنتشر رسالة بناء النفق الواحدة (Tunnel Build Message) من قفزة إلى أخرى. تقوم كل قفزة بفك تشفير سجلها، وإضافة ردها، وإعادة توجيه الرسالة. تُرجع القفزة النهائية رد البناء المجمّع عبر مسار مختلف، مما يمنع الربط بينها. تستخدم التطبيقات الحديثة رسائل بناء النفق القصيرة (Short Tunnel Build Messages - STBM) لـ ECIES ورسائل بناء النفق المتغيرة (Variable Tunnel Build Messages - VTBM) للمسارات القديمة. يتم تشفير كل سجل لكل قفزة باستخدام ElGamal أو ECIES-X25519.\nإنشاء النفق يستخدم حركة المرور عبر الأنفاق التشفير متعدد الطبقات. تضيف أو تزيل كل نقطة قفز طبقة من التشفير أثناء عبور الرسائل عبر النفق.\nأنفاق ElGamal: AES-256/CBC للبيانات مع حشوة PKCS#5. أنفاق ECIES: ChaCha20 أو ChaCha20-Poly1305 للتشفير المصادق عليه. كل قفزة (hop) لها مفتاحان: مفتاح الطبقة (layer key) و مفتاح IV. تقوم الموجهات (routers) بفك تشفير IV، واستخدامه لمعالجة الحمولة (payload)، ثم إعادة تشفير IV قبل الإعادة. يمنع نظام IV المزدوج هذا وضع العلامات على الرسائل (message tagging).\nبوابات الخروج (Outbound gateways) تفك تشفير جميع الطبقات مسبقاً بحيث تستقبل نقاط النهاية النص الواضح بعد أن يضيف جميع المشاركين التشفير. أنفاق الدخول (Inbound tunnels) تشفر في الاتجاه المعاكس. لا يستطيع المشاركون تحديد اتجاه النفق أو طوله.\nتشفير الأنفاق أوقات حياة النفق الديناميكية وتحديد حجم المجموعة التكيفي لموازنة حمل الشبكة استراتيجيات اختبار النفق البديلة وتشخيصات القفزة الفردية التحقق الاختياري من إثبات العمل أو شهادة النطاق الترددي (مُنفَّذ في API 0.9.65+) تشكيل حركة المرور وبحث إدراج البيانات الوهمية لخلط نقاط النهاية الاستمرار في إيقاف ElGamal والترحيل إلى ECIES-X25519 التطوير المستمر مواصفات تنفيذ Tunnel مواصفات إنشاء Tunnel (ElGamal) مواصفات إنشاء Tunnel (ECIES-X25519) مواصفات رسائل Tunnel Garlic Routing قاعدة بيانات شبكة I2P تحليل واختيار النظراء نموذج التهديدات I2P تشفير ElGamal/AES + SessionTag خيارات I2CP ","description":"نظرة عامة على مصطلحات tunnel في I2P، وبنائها، ودورة حياتها","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"توجيه الأنفاق","url":"/ar/docs/overview/tunnel-routing/"},{"categories":null,"content":"عندما تجعل ظروف الشبكة أمر git clone غير موثوق، يمكنك توزيع المستودعات على شكل git bundles عبر BitTorrent أو أي وسيلة نقل ملفات أخرى. الحزمة (bundle) هي ملف واحد يحتوي على سجل المستودع بالكامل. بمجرد التنزيل، تقوم بالجلب منها محلياً ثم تعود للاتصال بالمستودع البعيد الأساسي.\n1. قبل أن تبدأ إنشاء حزمة يتطلب استنساخ كامل لمستودع Git. الاستنساخات السطحية التي يتم إنشاؤها باستخدام --depth 1 ستنتج بصمت حزمًا معطوبة تبدو وكأنها تعمل لكنها تفشل عندما يحاول الآخرون استخدامها. احرص دائمًا على الجلب من مصدر موثوق (GitHub على github.com/i2p/i2p.i2p ، أو خادم Gitea الخاص بـ I2P على i2pgit.org ، أو git.idk.i2p عبر I2P) وقم بتشغيل git fetch --unshallow إذا لزم الأمر لتحويل أي استنساخ سطحي إلى استنساخ كامل قبل إنشاء الحزم.\nإذا كنت تستخدم حزمة موجودة فقط، فقم بتنزيلها فحسب. لا يلزم أي إعداد خاص.\n2. تحميل حزمة Obtaining the Bundle File قم بتنزيل ملف الحزمة عبر BitTorrent باستخدام I2PSnark (عميل التورنت المدمج في I2P) أو عملاء آخرين متوافقين مع I2P مثل BiglyBT مع إضافة I2P.\nمهم: I2PSnark يعمل فقط مع ملفات التورنت المُنشأة خصيصًا لشبكة I2P. ملفات التورنت العادية من الإنترنت المفتوح غير متوافقة لأن I2P يستخدم Destinations (عناوين بحجم 387+ بايت) بدلاً من عناوين IP والمنافذ.\nموقع ملف الحزمة يعتمد على نوع تثبيت I2P الخاص بك:\nتثبيتات المستخدم/اليدوية (المثبتة باستخدام مثبت Java): ~/.i2p/i2psnark/ تثبيتات النظام/الخدمة (المثبتة عبر apt-get أو مدير الحزم): /var/lib/i2p/i2p-config/i2psnark/ سيجد مستخدمو BiglyBT الملفات التي تم تنزيلها في دليل التنزيلات المُعَدّ لديهم.\nCloning from the Bundle الطريقة القياسية (تعمل في معظم الحالات):\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle إذا واجهت أخطاء fatal: multiple updates for ref (مشكلة معروفة في Git 2.21.0 والإصدارات الأحدث عندما يحتوي إعداد Git العام على refspecs متضاربة للجلب)، استخدم طريقة التهيئة اليدوية:\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle بدلاً من ذلك، يمكنك استخدام العلم --update-head-ok:\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; الحصول على ملف الحزمة بعد الاستنساخ من الحزمة، قم بتوجيه النسخة المستنسخة إلى المستودع البعيد المباشر حتى تتم عمليات الجلب المستقبلية عبر I2P أو clearnet:\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p أو للوصول إلى الشبكة العادية:\ngit remote set-url origin https://github.com/i2p/i2p.i2p للوصول إلى SSH عبر I2P، تحتاج إلى تكوين tunnel عميل SSH في لوحة تحكم موجه I2P الخاص بك (عادةً المنفذ 7670) يشير إلى g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p. إذا كنت تستخدم منفذاً غير قياسي:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle الاستنساخ من الحزمة تأكد من أن المستودع الخاص بك محدّث بالكامل مع نسخة كاملة (وليست سطحية):\ngit fetch --all إذا كان لديك نسخة محلية سطحية (shallow clone)، قم بتحويلها أولاً:\ngit fetch --unshallow التبديل إلى الوضع المباشر البعيد استخدام هدف البناء Ant (موصى به لشجرة مصدر I2P):\nant git-bundle هذا ينشئ كلاً من i2p.i2p.bundle (ملف الحزمة) و i2p.i2p.bundle.torrent (بيانات BitTorrent الوصفية).\nاستخدام git bundle مباشرة:\ngit bundle create i2p.i2p.bundle --all للحزم الأكثر انتقائية:\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle تحقق دائماً من الحزمة قبل التوزيع:\ngit bundle verify i2p.i2p.bundle هذا يؤكد أن الحزمة صالحة ويعرض أي commits مطلوبة كمتطلبات مسبقة.\nالمتطلبات الأساسية انسخ الحزمة وبيانات التورنت الوصفية الخاصة بها إلى دليل I2PSnark الخاص بك:\nللتثبيتات الخاصة بالمستخدمين:\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ لعمليات تثبيت النظام:\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ يكتشف I2PSnark ويحمل ملفات .torrent تلقائيًا خلال ثوانٍ. يمكنك الوصول إلى واجهة الويب على http://127.0.0.1:7657/i2psnark لبدء المشاركة.\n4. Creating Incremental Bundles للحصول على تحديثات دورية، قم بإنشاء حزم تدريجية تحتوي فقط على الـ commits الجديدة منذ آخر حزمة:\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master يمكن للمستخدمين التحميل من الحزمة التدريجية إذا كان لديهم بالفعل المستودع الأساسي:\ngit fetch /path/to/update.bundle تحقق دائمًا من أن الحزم التراكمية (incremental bundles) تعرض الالتزامات (commits) الأساسية المتوقعة:\ngit bundle verify update.bundle 5. Updating After the Initial Clone بمجرد أن يكون لديك مستودع عمل من الحزمة، تعامل معه كأي نسخة Git أخرى:\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master أو لسير العمل الأبسط:\ngit fetch origin git pull origin master 3. إنشاء حزمة التوزيع المرن: يمكن مشاركة المستودعات الكبيرة عبر BitTorrent، الذي يتعامل مع إعادة المحاولات والتحقق من القطع والاستئناف تلقائياً. الإقلاع من نظير إلى نظير: يمكن للمساهمين الجدد إقلاع نسختهم المستنسخة من النظراء القريبين على شبكة I2P، ثم جلب التغييرات التدريجية مباشرة من مستضيفات Git. تقليل الحمل على الخادم: يمكن للمرايا نشر حزم دورية لتخفيف الضغط على مستضيفات Git المباشرة، وهذا مفيد بشكل خاص للمستودعات الكبيرة أو ظروف الشبكة البطيئة. النقل دون اتصال: تعمل الحزم على أي وسيلة نقل للملفات (محركات USB، النقل المباشر، sneakernet)، وليس فقط BitTorrent. الحزم لا تحل محل remotes المباشرة. إنها ببساطة توفر طريقة bootstrapping أكثر مرونة للاستنساخات الأولية أو التحديثات الرئيسية.\n7. Troubleshooting توليد الحزمة المشكلة: إنشاء الحزمة ينجح لكن الآخرين لا يستطيعون الاستنساخ من الحزمة.\nالسبب: نسختك المستنسخة من المصدر ضحلة (تم إنشاؤها باستخدام --depth).\nالحل: التحويل إلى استنساخ كامل قبل إنشاء الحزم:\ngit fetch --unshallow التحقق من الحزمة الخاصة بك المشكلة: fatal: multiple updates for ref عند الاستنساخ من bundle.\nالسبب: Git 2.21.0+ يتعارض مع مواصفات fetch العامة في ~/.gitconfig.\nالحلول: 1. استخدم التهيئة اليدوية: mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle 2. استخدم علامة --update-head-ok: git fetch --update-head-ok /path/to/bundle '*:*' 3. احذف الإعدادات المتعارضة: git config --global --unset remote.origin.fetch\nالتوزيع عبر I2PSnark المشكلة: يُبلغ الأمر git bundle verify عن متطلبات مسبقة مفقودة.\nالسبب: حزمة تدريجية أو نسخة غير كاملة من المصدر.\nالحل: إما جلب الـ commits المطلوبة مسبقاً أو استخدام الحزمة الأساسية أولاً، ثم تطبيق التحديثات التدريجية.\n","description":"جلب وتوزيع المستودعات الكبيرة باستخدام git bundle وBitTorrent","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"حزم Git لـ I2P","url":"/ar/docs/applications/git-bundle/"},{"categories":null,"content":"تتعطّل I2P routers في الغالب بسبب مشكلات إعادة توجيه المنافذ، وتخصيص عرض نطاق ترددي غير كافٍ، ووقت تمهيد (bootstrap) غير كافٍ. تمثل هذه العوامل الثلاثة أكثر من 70% من المشكلات المُبلّغ عنها. يحتاج الـ router إلى ما لا يقل عن 10-15 دقيقة بعد بدء التشغيل ليندمج بالكامل مع الشبكة، وحد أدنى لعرض النطاق الترددي قدره 128 KB/sec (يُوصى بـ 256 KB/sec)، وكذلك إعداد إعادة توجيه المنافذ UDP/TCP بطريقة صحيحة للوصول إلى حالة غير محجوبة بجدار ناري. غالباً ما يتوقع المستخدمون الجدد اتصالاً فورياً ويقومون بإعادة التشغيل مبكراً، ما يُعيد ضبط تقدّم الاندماج ويخلق حلقة مزعجة. يوفر هذا الدليل حلولاً مفصلة لجميع المشكلات الرئيسية في I2P التي تؤثر في الإصدارات 2.10.0 فما بعد.\nإن معمارية إخفاء الهوية في I2P تقايض السرعة بالخصوصية بشكل متأصل عبر tunnels مشفرة متعددة القفزات. يساعد فهم هذا التصميم الأساسي المستخدمين على وضع توقعات واقعية وحل المشكلات بفعالية بدلاً من إساءة تفسير السلوك الطبيعي على أنه مشاكل.\nRouter لا يبدأ أو يتعطل فورًا أكثر أعطال بدء التشغيل شيوعًا تنتج عن تعارض المنافذ، عدم توافق إصدار Java، أو ملفات تهيئة تالفة. تحقق مما إذا كان مثيل آخر لـ I2P يعمل بالفعل قبل استقصاء مشكلات أعمق.\nتحقق من عدم وجود عمليات متعارضة:\nLinux: ps aux | grep i2p أو netstat -tulpn | grep 7657\nWindows: مدير المهام → التفاصيل → ابحث عن java.exe حيث يحتوي سطر الأوامر على i2p\nmacOS: Activity Monitor → ابحث عن \u0026ldquo;i2p\u0026rdquo;\nإذا كانت هناك عملية زومبي، فقم بإنهائها: pkill -9 -f i2p (Linux/Mac) أو taskkill /F /IM javaw.exe (Windows)\nتحقق من توافق إصدار جافا:\nيتطلب I2P 2.10.0+ Java 8 كحدٍّ أدنى، ويُوصى باستخدام Java 11 أو أحدث. تحقّق من أن تثبيتك يُظهر \u0026ldquo;mixed mode\u0026rdquo; (وليس \u0026ldquo;interpreted mode\u0026rdquo;):\njava -version يجب أن يعرض: OpenJDK أو Oracle Java، الإصدار 8+، \u0026ldquo;mixed mode\u0026rdquo;\nتجنب: GNU GCJ, تنفيذات Java القديمة, أنماط تعمل بالتفسير فقط\nتعارضات المنافذ الشائعة تحدث عندما تتنافس خدمات متعددة على المنافذ الافتراضية لـ I2P. يجب أن تكون منافذ وحدة تحكم router (7657) و I2CP (7654) و SAM (7656) و وكيل HTTP (4444) متاحة. تحقق من وجود تعارضات: netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (ويندوز) أو lsof -i :7657,4444,7654 (لينكس/ماك).\nتلف ملف الإعدادات يتجلّى في انهيارات فورية مع أخطاء تحليل في السجلات. Router.config يتطلب ترميز UTF-8 بدون BOM (علامة ترتيب البايتات)، ويستخدم = كفاصل (وليس :)، ويحظر بعض الأحرف الخاصة. أنشئ نسخة احتياطية ثم افحص: ~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS).\nلإعادة ضبط الإعدادات مع الحفاظ على الهوية: أوقف I2P، وخذ نسخة احتياطية من الملف router.keys ومن دليل keyData، واحذف الملف router.config، ثم أعد التشغيل. سيقوم الـ router بإعادة إنشاء الإعدادات الافتراضية.\nانخفاض تخصيص كومة Java يتسبب في أعطال OutOfMemoryError (خطأ نفاد الذاكرة). عدّل wrapper.config وزِد wrapper.java.maxmemory من القيمة الافتراضية 128 أو 256 إلى 512 كحد أدنى (1024 لـ routers عالية النطاق الترددي). يتطلب ذلك إيقافاً كاملاً، والانتظار 11 دقيقة، ثم إعادة التشغيل - النقر على \u0026ldquo;Restart\u0026rdquo; في وحدة التحكم لن يطبّق التغيير.\nحل حالة \u0026ldquo;Network: Firewalled\u0026rdquo; تعني حالة الحجب بالجدار الناري أن الـ router لا يمكنه تلقي اتصالات واردة مباشرة، مما يفرض الاعتماد على introducers (وسطاء التعريف). ورغم أن الـ router يعمل في هذه الحالة، فإن يتدهور الأداء بشكل كبير وتظل المساهمة في الشبكة ضئيلة للغاية. ويتطلب الوصول إلى حالة غير محجوبة بالجدار الناري إعداد إعادة توجيه المنافذ (port forwarding) بشكل صحيح.\nيختار router منفذًا عشوائيًا بين 9000-31000 للاتصالات. اعثر على منفذك في http://127.0.0.1:7657/confignet - ابحث عن \u0026ldquo;UDP Port\u0026rdquo; و \u0026ldquo;TCP Port\u0026rdquo; (غالبًا ما يكونان الرقم نفسه). يجب عليك إعادة توجيه كلٍ من UDP وTCP لتحقيق أفضل أداء، رغم أن UDP وحده يتيح الوظائف الأساسية.\nفعّل إعادة التوجيه التلقائي عبر UPnP (أبسط طريقة):\nافتح http://127.0.0.1:7657/confignet ضع علامة على \u0026ldquo;Enable UPnP\u0026rdquo; احفظ التغييرات وأعد تشغيل router انتظر 5-10 دقائق وتحقق من تغيّر الحالة من \u0026ldquo;Network: Firewalled\u0026rdquo; إلى \u0026ldquo;Network: OK\u0026rdquo; يتطلب UPnP دعم الـ router (مُمكّنًا افتراضيًا على معظم routers المخصصة للمستهلكين المُصنَّعة بعد عام 2010) وتهيئة صحيحة للشبكة.\nإعادة توجيه المنافذ يدويًا (مطلوبة عند فشل UPnP):\nدوّن منفذ I2P الخاص بك من http://127.0.0.1:7657/confignet (على سبيل المثال، 22648) اعثر على عنوان IP المحلي لديك: ipconfig (Windows)، ip addr (Linux)، تفضيلات النظام → الشبكة (macOS) ادخل إلى واجهة إدارة الـ router لديك (عادةً 192.168.1.1 أو 192.168.0.1) انتقل إلى Port Forwarding (قد يكون ضمن Advanced أو NAT أو Virtual Servers) أنشئ قاعدتين: المنفذ الخارجي: [your I2P port] → عنوان IP الداخلي: [your computer] → المنفذ الداخلي: [same] → البروتوكول: UDP المنفذ الخارجي: [your I2P port] → عنوان IP الداخلي: [your computer] → المنفذ الداخلي: [same] → البروتوكول: TCP احفظ الإعدادات وأعد تشغيل الـ router إذا لزم الأمر تحقق من إعادة توجيه المنفذ باستخدام أدوات التحقق عبر الإنترنت بعد الإعداد. إذا فشلت عملية الكشف، فتحقق من إعدادات جدار الحماية - يجب أن يسمح كلٌ من جدار حماية النظام وأي جدار حماية تابع لبرنامج مكافحة الفيروسات بمنفذ I2P.\nبديل وضع Hidden mode للشبكات المقيِّدة حيث تكون إعادة توجيه المنافذ مستحيلة: قم بتمكينه من http://127.0.0.1:7657/confignet → حدِّد \u0026ldquo;Hidden mode\u0026rdquo;. يظل router خلف جدار ناري لكنه يُحسّن عمله لهذا الوضع عبر استخدام SSU introducers (وسطاء التعارف عبر SSU) حصراً. سيكون الأداء أبطأ لكنه سيظل قابلاً للاستخدام.\nRouter عالق في حالتي \u0026ldquo;قيد البدء\u0026rdquo; أو \u0026ldquo;قيد الاختبار\u0026rdquo; هذه الحالات العابرة أثناء التمهيد الأولي تزول عادةً خلال 10-15 دقيقة لعمليات التثبيت الجديدة أو 3-5 دقائق لـ routers المستقرة. غالباً ما يؤدي التدخل المبكر إلى تفاقم المشاكل.\n\u0026ldquo;Network: Testing\u0026rdquo; تشير إلى أن الـrouter يفحص إمكانية الوصول عبر أنواع اتصال متعددة (مباشر، introducers (وسطاء التعريف)، إصدارات متعددة من البروتوكول). هذا أمر طبيعي خلال أول 5-10 دقائق بعد بدء التشغيل. يختبر الـrouter عدة سيناريوهات لتحديد الإعداد الأمثل.\nتظهر \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; أثناء bootstrap (مرحلة التهيئة الأولية) عندما يفتقر الـrouter إلى معلومات كافية عن النظراء. لن يشارك الـrouter في حركة المرور المرحّلة حتى يتم دمجه بشكل كافٍ. ينبغي أن تختفي هذه الرسالة بعد 10-20 دقيقة بمجرد أن يمتلئ netDb بـ 50+ routers.\nانحراف الساعة يعطّل اختبار قابلية الوصول. تتطلب I2P أن يكون وقت النظام ضمن ±60 ثانية من وقت الشبكة. يؤدي تجاوز الفرق 90 ثانية إلى رفض الاتصال تلقائيًا. قم بمزامنة ساعة نظامك:\nلينكس: sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows: لوحة التحكم → التاريخ والوقت → وقت الإنترنت → تحديث الآن → تمكين المزامنة التلقائية\nmacOS: تفضيلات النظام → التاريخ والوقت → فعّل \u0026ldquo;ضبط التاريخ والوقت تلقائيًا\u0026rdquo;\nبعد تصحيح انحراف الساعة، أعد تشغيل I2P بالكامل لضمان التكامل الصحيح.\nعدم كفاية تخصيص عرض النطاق الترددي يمنع نجاح الاختبار. يحتاج الـ router إلى سعة كافية لبناء tunnels للاختبار. قم بالإعداد على http://127.0.0.1:7657/config:\nالحد الأدنى القابل للاستخدام: الوارد 96 KB/sec، الصادر 64 KB/sec المعيار الموصى به: الوارد 256 KB/sec، الصادر 128 KB/sec الأداء الأمثل: الوارد 512+ KB/sec، الصادر 256+ KB/sec نسبة المشاركة: 80% (يسمح لـ router بالمساهمة في عرض النطاق الترددي للشبكة) قد يعمل عرض النطاق الترددي المنخفض، لكنه يطيل وقت الاندماج من دقائق إلى ساعات.\nتلف netDb الناتج عن إيقاف تشغيل غير سليم أو أخطاء القرص يسبب حلقات اختبار لا نهائية. لا يمكن لـ router إكمال الاختبار دون بيانات أقران صالحة:\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start ويندوز: احذف محتويات %APPDATA%\\I2P\\netDb\\ أو %LOCALAPPDATA%\\I2P\\netDb\\\nحظر جدار الحماية لعملية reseed (إعادة البذر الأوّلي للنظراء) يمنع الحصول على النظراء الأوّليين. أثناء عملية bootstrap (التمهيد)، يسترجع I2P معلومات الـ router من خوادم reseed عبر HTTPS. قد تقوم جدران حماية الشركات أو مزوّدي خدمة الإنترنت بحظر هذه الاتصالات. قم بإعداد وكيل reseed على http://127.0.0.1:7657/configreseed إذا كنت تعمل خلف شبكات مقيِّدة.\nسرعات بطيئة، حالات انتهاء المهلة، وإخفاقات في إنشاء tunnel يؤدي تصميم I2P بطبيعته إلى تحقيق سرعات أبطأ بمقدار 3-10x من clearnet (الإنترنت المكشوف) بسبب التعمية متعددة القفزات، والكلفة الإضافية في الحزم، وعدم إمكانية التنبؤ بالمسارات. عملية إنشاء tunnel تجتاز عدّة routers، ويضيف كلّ منها كمونًا. إن فهم ذلك يمنع إساءة تشخيص السلوك الطبيعي على أنه مشكلات.\nتوقعات الأداء النموذجية:\nتصفح مواقع .i2p: يستغرق تحميل الصفحات في البداية 10-30 ثانية، ويصبح أسرع بعد إنشاء tunnel التحميل عبر بروتوكول التورنت باستخدام I2PSnark: 10-100 كيلوبايت/ثانية لكل تورنت بحسب عدد المزوّدين (seeders) وظروف الشبكة تنزيل الملفات الكبيرة: الصبر مطلوب - قد تستغرق الملفات بحجم ميغابايت دقائق، والغيغابايت ساعات أول اتصال هو الأبطأ: يستغرق بناء tunnel 30-90 ثانية; الاتصالات اللاحقة تستخدم tunnels الموجودة معدل نجاح إنشاء Tunnel يشير إلى صحة الشبكة. تحقق عبر http://127.0.0.1:7657/tunnels:\nأعلى من 60٪: تشغيل طبيعي وسليم 40-60٪: هامشي، فكّر في زيادة عرض النطاق الترددي أو تقليل الحمل أقل من 40٪: إشكالي - يشير إلى عدم كفاية عرض النطاق الترددي، أو مشكلات في الشبكة، أو سوء اختيار النظراء زِد تخصيص عرض النطاق الترددي كأول تحسين. معظم بطء الأداء ينجم عن نقص في عرض النطاق الترددي. في http://127.0.0.1:7657/config، زِد الحدود تدريجيًا وراقب الرسوم البيانية في http://127.0.0.1:7657/graphs.\nلـ DSL/Cable (اتصالات 1-10 Mbps): - الوارد: 400 KB/sec - الصادر: 200 KB/sec - نسبة المشاركة: 80% - الذاكرة: 384 MB (قم بتحرير wrapper.config)\nللاتصالات عالية السرعة (10-100+ Mbps): - وارد: 1500 KB/sec - صادر: 1000 KB/sec - المشاركة: 80-100% - الذاكرة: 512-1024 MB - ضع في الاعتبار: زيادة عدد الـ tunnels المشاركة إلى 2000-5000 في http://127.0.0.1:7657/configadvanced\nحسّن تكوين tunnel لأداء أفضل. ادخل إلى إعدادات tunnel المحددة على http://127.0.0.1:7657/i2ptunnel وقم بتحرير كل tunnel:\nعدد الـ Tunnel: قم بزيادته من 2 إلى 3-4 (المزيد من المسارات المتاحة) عدد النسخ الاحتياطية: اضبطه على 1-2 (تحويل سريع عند فشل tunnel) طول الـ Tunnel: الإعداد الافتراضي 3 قفزات يوفّر توازناً جيداً؛ خفضه إلى 2 يحسّن السرعة لكنه يقلّل إخفاء الهوية مكتبة التشفير الأصلية (jbigi) توفر أداءً أفضل بمقدار 5–10 أضعاف مقارنةً بتشفير Java الخالص. تحقّق من تحميلها في http://127.0.0.1:7657/logs - ابحث عن \u0026ldquo;jbigi loaded successfully\u0026rdquo; أو \u0026ldquo;Using native CPUID implementation\u0026rdquo;. إن لم تكن موجودة:\nلينكس: عادةً ما يتم اكتشافه تلقائيًا وتحميله من ~/.i2p/jbigi-*.so ويندوز: تحقّق من وجود jbigi.dll في دليل تثبيت I2P إذا كان مفقودًا: ثبّت أدوات البناء وقم ببنائه من المصدر، أو نزّل الثنائيات المُترجَمة مسبقًا من المستودعات الرسمية\nأبقِ router يعمل بشكل مستمر. كل إعادة تشغيل تعيد ضبط اندماجه في الشبكة، وتتطلب 30-60 دقيقة لإعادة بناء شبكة tunnel وعلاقات الأقران. تحظى routers المستقرة ذات زمن التشغيل المرتفع بتفضيل عند اختيارها لبناء tunnel، مما يخلق تغذية راجعة إيجابية للأداء.\nارتفاع استهلاك وحدة المعالجة المركزية والذاكرة يشير الاستخدام المفرط للموارد عادةً إلى تخصيص غير كافٍ للذاكرة أو غياب مكتبات التشفير الأصلية أو الالتزام المفرط بالمشاركة في الشبكة. ينبغي أن تستهلك routers المُكوَّنة جيدًا 10-30% من وحدة المعالجة المركزية أثناء الاستخدام النشط، وأن تحافظ على استقرار الذاكرة دون 80% من heap (ذاكرة الكومة) المخصصة.\nتتجلى مشكلات الذاكرة في: - رسوم بيانية للذاكرة ذات قمة مسطحة (مثبتة عند الحد الأقصى) - جمع القمامة المتكرر (نمط سنّ المنشار مع انخفاضات حادّة) - OutOfMemoryError في السجلات - Router يصبح غير مستجيب تحت الحمل - إيقاف تلقائي بسبب استنزاف الموارد\nزيادة تخصيص ذاكرة الكومة في Java في wrapper.config (يتطلب إيقاف التشغيل بالكامل):\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 هام جدًا: بعد تعديل wrapper.config، يجب إيقاف التشغيل بالكامل (عدم إعادة التشغيل)، انتظر 11 دقيقة لإنهاء سلس، ثم ابدأ تشغيلًا جديدًا. زر \u0026ldquo;Restart\u0026rdquo; في لوحة تحكم الـ Router لا يعيد تحميل إعدادات الـ wrapper (المُغلِّف).\nيتطلب تحسين أداء CPU وجود مكتبة تشفير أصلية (native). تستهلك عمليات BigInteger في Java الخالصة CPU أكثر بمقدار 10-20x مقارنة بالتنفيذات الأصلية. تحقق من حالة jbigi على http://127.0.0.1:7657/logs أثناء بدء التشغيل. بدون jbigi، سيرتفع استخدام CPU إلى 50-100% أثناء بناء tunnel (مسار اتصال في I2P) وعمليات التشفير.\nقلّل حمل tunnel المشاركة إذا كان router مثقلاً بالأحمال:\nادخل إلى http://127.0.0.1:7657/configadvanced اضبط router.maxParticipatingTunnels=1000 (الافتراضي 8000) قلّل نسبة المشاركة في http://127.0.0.1:7657/config من 80% إلى 50% عطّل وضع floodfill إذا كان مفعّلًا: router.floodfillParticipant=false قيّد عرض النطاق الترددي في I2PSnark وعدد التورنتات المتزامنة. استخدام التورنت يستهلك قدراً كبيراً من الموارد. في http://127.0.0.1:7657/i2psnark:\nحدِّد عدد التورنتات النشطة إلى 3-5 كحد أقصى اضبط \u0026ldquo;Up BW Limit\u0026rdquo; و\u0026quot;Down BW Limit\u0026quot; على قيم معقولة (50-100 كيلوبايت/ثانية لكل منهما) أوقف ملفات التورنت عند عدم الحاجة إليها فعلياً تجنّب البذر (seeding) لعشرات ملفات التورنت في وقت واحد راقب استخدام الموارد عبر الرسوم البيانية المدمجة على http://127.0.0.1:7657/graphs. يجب أن تُظهر الذاكرة هامشاً احتياطياً، لا أن تكون مسطحة عند الحد الأقصى. تُعد الارتفاعات الحادة في CPU أثناء بناء tunnel أمراً طبيعياً؛ أما الارتفاع المرتفع والمستمر في CPU فيشير إلى مشكلات في الإعداد.\nللأنظمة المحدودة الموارد بشدة (Raspberry Pi، أجهزة قديمة)، فكّر في استخدام i2pd (تنفيذ بلغة C++) كبديل. يتطلب i2pd ~130 MB من ذاكرة RAM مقابل 350+ MB لـ Java I2P، ويستخدم ~7% من وحدة المعالجة المركزية مقابل 70% تحت أحمال مماثلة. لاحظ أن i2pd يفتقر إلى التطبيقات المدمجة ويتطلب أدوات خارجية.\nمشكلات تورنت I2PSnark يتطلب تكامل I2PSnark مع معمارية الـ router في I2P فهم أن يعتمد استخدام التورنت اعتمادًا كاملًا على صحة الـ tunnel الخاصة بالـ router. لن تبدأ التورنتات حتى يحقق الـ router تكاملًا كافيًا مع أكثر من 10 نظراء نشطين وتكون لديه tunnels عاملة.\nالتورنت العالقة عند 0% تشير عادةً إلى:\nRouter غير مُندمج بالكامل: انتظر 10–15 دقيقة بعد بدء تشغيل I2P قبل توقّع أي نشاط للتورنت تم تعطيل DHT (جدول تجزئة موزّع): فعِّل ذلك على http://127.0.0.1:7657/i2psnark → Configuration → فعِّل الخيار \u0026ldquo;Enable DHT\u0026rdquo; (مفعّل افتراضيًا منذ الإصدار 0.9.2) متعقّبات غير صالحة أو متوقّفة: تتطلّب تورنتات I2P متعقّبات مخصّصة لـ I2P - متعقّبات clearnet (الإنترنت الواضح) لن تعمل إعدادات tunnel غير كافية: زِد عدد الـ tunnels من I2PSnark Configuration → قسم Tunnels اضبط I2PSnark tunnels لتحسين الأداء:\ntunnels الواردة: 3-5 (القيمة الافتراضية 2 لـ Java I2P، و5 لـ i2pd) tunnels الصادرة: 3-5 طول tunnel: 3 قفزات (يمكن تقليله إلى 2 لزيادة السرعة، مع تقليل مستوى إخفاء الهوية) عدد tunnels: 3 (يوفّر أداءً متسقاً) متتبعات تورنت I2P الضرورية لإضافتها: - tracker2.postman.i2p (الرئيسي، الأكثر موثوقية) - w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a\nأزل أي متتبعات clearnet (غير .i2p) - فهي لا تقدم أي قيمة وتُنشئ محاولات اتصال تنتهي بانقضاء المهلة.\nأخطاء \u0026ldquo;Torrent not registered\u0026rdquo; تحدث عند فشل الاتصال بخادم التتبع. يؤدي النقر بزر الماوس الأيمن على التورنت → \u0026ldquo;Start\u0026rdquo; إلى فرض إعادة الإعلان إلى خادم التتبع. إذا استمرت المشكلة، فتحقق من إمكانية الوصول إلى خادم التتبع عبر تصفح http://tracker2.postman.i 2p في متصفح مُعدّ لـ I2P. يجب استبدال خوادم التتبع المعطّلة ببدائل عاملة.\nلا يوجد أقران يتصلون رغم نجاح المتتبع، مما يشير إلى: - Router محجوب بجدار ناري (يتحسن الأمر مع إعادة توجيه المنافذ لكنه غير مطلوب) - عرض نطاق غير كافٍ (ارفعه إلى 256+ KB/sec) - Swarm (مجموعة المشاركين) صغيرة جداً (بعض ملفات التورنت لديها 1-2 seeders (المزوّدون)؛ الصبر مطلوب) - DHT (جدول التجزئة الموزع) معطّل (فعّله لاكتشاف الأقران بدون متتبع)\nفعِّل DHT و PEX (تبادل الأقران) ضمن إعدادات I2PSnark. يتيح DHT (جدول تجزئة موزع) العثور على الأقران دون الاعتماد على المتعقّب. يكتشف PEX الأقران من خلال الأقران المتصلين، مما يسرّع اكتشاف السرب.\nتلف الملفات التي تم تنزيلها يحدث نادراً مع آلية التحقق من السلامة المدمجة في I2PSnark. إذا تم اكتشافه:\nانقر بزر الفأرة الأيمن على التورنت → \u0026ldquo;Check\u0026rdquo; يفرض إعادة حساب الهاش لجميع القطع احذف بيانات التورنت التالفة (يحتفظ بملف .torrent) انقر بزر الفأرة الأيمن → \u0026ldquo;Start\u0026rdquo; لإعادة التنزيل مع التحقق من القطع افحص القرص بحثًا عن أخطاء إذا استمر التلف: chkdsk (Windows)، fsck (Linux) مجلد المراقبة لا يعمل يتطلب تهيئة صحيحة:\nإعدادات I2PSnark → \u0026ldquo;Watch directory\u0026rdquo;: حدِّد المسار المطلق (مثال: /home/user/torrents/watch) تأكّد من أن عملية I2P تمتلك صلاحيات القراءة: chmod 755 /path/to/watch ضع ملفات .torrent في دليل المراقبة - سيقوم I2PSnark بإضافتها تلقائياً اضبط \u0026ldquo;Auto start\u0026rdquo;: حدِّد ما إذا كان ينبغي أن تبدأ ملفات التورنت مباشرةً عند إضافتها تحسين الأداء لاستخدام التورنت:\nحدّد عدد ملفات تورنت النشطة بالتزامن: 3-5 كحد أقصى للاتصالات القياسية امنح الأولوية للتنزيلات المهمة: أوقف ملفات تورنت ذات أولوية منخفضة مؤقتاً زِد تخصيص عرض النطاق لـ router: عرض نطاق أكبر = أداء تورنت أفضل تحلَّ بالصبر: التورنت عبر I2P أبطأ بطبيعته من BitTorrent على الإنترنت المكشوف (clearnet) استمر في الرفع بعد التنزيل: الشبكة تزدهر بالمعاملة بالمثل إعداد Git عبر I2P واستكشاف الأخطاء وإصلاحها تتطلب عمليات Git عبر I2P إما تهيئة وكيل SOCKS أو I2P tunnels مخصصة للوصول عبر SSH/HTTP. يفترض تصميم Git اتصالات منخفضة الكمون، مما يجعل بنية I2P عالية الكمون تحديًا.\nتهيئة Git لاستخدام وكيل SOCKS الخاص بـ I2P:\nحرّر ~/.ssh/config (أنشئه إذا لم يكن موجودًا):\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes يقوم هذا بتوجيه جميع اتصالات SSH إلى مضيفي ‎.i2p‎ عبر وكيل SOCKS الخاص بـ I2P (المنفذ 4447). تحافظ إعدادات ServerAlive (إعدادات إبقاء الجلسة نشطة) على الاتصال أثناء كمون I2P.\nبالنسبة لعمليات Git (نظام إدارة الإصدارات الموزّع) عبر HTTP/HTTPS، قم بتهيئة Git على مستوى المستخدم:\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 ملاحظة: socks5h يقوم بإجراء حل نظام أسماء النطاقات (DNS) عبر الوكيل - وهو أمر بالغ الأهمية لنطاقات .i2p.\nإنشاء I2P tunnel مخصص لـ Git عبر SSH (أكثر موثوقية من SOCKS):\nادخل إلى http://127.0.0.1:7657/i2ptunnel \u0026ldquo;tunnel عميل جديد\u0026rdquo; → \u0026ldquo;قياسي\u0026rdquo; قم بالتهيئة: الاسم: Git-SSH النوع: عميل المنفذ: 2222 (منفذ محلي للوصول إلى Git) الوجهة: [your-git-server].i2p:22 بدء تلقائي: مفعّل عدد tunnel: 3-4 (أعلى لزيادة الموثوقية) احفظ وابدأ tunnel اضبط SSH لاستخدام tunnel: ssh -p 2222 git@127.0.0.1 أخطاء مصادقة SSH عبر I2P عادةً ما تنجم عن:\nلم يتم إضافة المفتاح إلى ssh-agent: ssh-add ~/.ssh/id_rsa أذونات ملف المفتاح غير صحيحة: chmod 600 ~/.ssh/id_rsa tunnel غير قيد التشغيل: تحقق عبر http://127.0.0.1:7657/i2ptunnel أن الحالة خضراء خادم Git يتطلب نوع مفتاح محدداً: أنشئ مفتاح ed25519 إذا فشل RSA انتهاء المهلة في عمليات Git يرتبط بخصائص الكمون في I2P:\nزد مهلة Git: git config --global http.postBuffer 524288000 (مخزن مؤقت بحجم 500MB) زد حد السرعة المنخفضة: git config --global http.lowSpeedLimit 1000 و git config --global http.lowSpeedTime 600 (ينتظر 10 دقائق) استخدم استنساخًا سطحيًا في البداية: git clone --depth 1 [url] (يجلب أحدث التزام فقط، أسرع) استنسخ خلال فترات انخفاض النشاط: ازدحام الشبكة يؤثر في أداء I2P عمليات git clone/fetch البطيئة متأصلة في معمارية I2P. قد يستغرق مستودع بحجم 100MB مدة 30–60 دقيقة عبر I2P، مقابل ثوانٍ على الإنترنت المكشوف (clearnet). استراتيجيات:\nاستخدم الاستنساخات السطحية: --depth 1 يقلّل بشكل كبير من نقل البيانات الأولي اجلب بشكل تدريجي: بدلًا من الاستنساخ الكامل، اجلب فروعًا محددة: git fetch origin branch:branch فكّر في استخدام rsync عبر I2P: بالنسبة للمستودعات الكبيرة جدًا، قد يقدّم rsync أداءً أفضل زد عدد tunnel: المزيد من tunnels يوفّر معدل نقل أفضل لعمليات النقل الكبيرة المستمرة أخطاء \u0026ldquo;Connection refused\u0026rdquo; تشير إلى سوء تهيئة tunnel:\nتحقّق من أن I2P router قيد التشغيل: زر http://127.0.0.1:7657 أكّد أن tunnel نشط وباللون الأخضر على http://127.0.0.1:7657/i2ptunnel اختبر tunnel: nc -zv 127.0.0.1 2222 (يجب أن يتصل إذا كان tunnel يعمل) تحقّق من إمكانية الوصول إلى الوجهة: تصفّح واجهة HTTP الخاصة بالوجهة إن كانت متاحة راجع سجلات tunnel في http://127.0.0.1:7657/logs بحثًا عن أخطاء محددة أفضل الممارسات لاستخدام Git عبر I2P:\nحافظ على تشغيل I2P router بشكل مستمر للحصول على وصول مستقر إلى Git استخدم مفاتيح SSH بدلاً من المصادقة بكلمة مرور (مطالبات تفاعلية أقل) قم بتهيئة tunnels دائمة بدلاً من اتصالات SOCKS المؤقتة فكّر في استضافة خادم git عبر I2P الخاص بك لمزيد من التحكّم وثّق نقاط نهاية git الخاصة بك على .i2p للمتعاونين الوصول إلى eepsites وحل أسماء نطاقات .i2p السبب الأكثر شيوعًا لعدم تمكن المستخدمين من الوصول إلى مواقع .i2p هو تكوين وكيل المتصفح غير الصحيح. مواقع I2P موجودة فقط داخل شبكة I2P وتتطلب التوجيه عبر وكيل HTTP الخاص بـ I2P.\nاضبط إعدادات وكيل المتصفح تمامًا:\nفايرفوكس (موصى به لـ I2P):\nالقائمة → الإعدادات → إعدادات الشبكة → زر الإعدادات اختر \u0026ldquo;تكوين الوكيل اليدوي\u0026rdquo; وكيل HTTP: 127.0.0.1 المنفذ: 4444 وكيل SSL: 127.0.0.1 المنفذ: 4444 وكيل SOCKS: 127.0.0.1 المنفذ: 4447 (اختياري، لتطبيقات SOCKS) حدّد \u0026ldquo;تمرير DNS عبر الوكيل عند استخدام SOCKS v5\u0026rdquo; انقر موافق للحفظ الإعدادات الحرجة في about:config الخاصة بـ Firefox:\nانتقل إلى about:config وعدّل:\nmedia.peerconnection.ice.proxy_only = true (يمنع تسريبات عناوين IP عبر WebRTC (الاتصال في الوقت الحقيقي عبر الويب)) keyword.enabled = false (يمنع إعادة توجيه عناوين .i2p إلى محركات البحث) network.proxy.socks_remote_dns = true (DNS عبر الوكيل) قيود Chrome/Chromium:\nيستخدم Chrome إعدادات البروكسي على مستوى النظام بدلاً من الإعدادات الخاصة بالتطبيق. على Windows: الإعدادات → ابحث عن \u0026ldquo;proxy\u0026rdquo; → \u0026ldquo;افتح إعدادات البروكسي في جهازك\u0026rdquo; → اضبط HTTP: 127.0.0.1:4444 و HTTPS: 127.0.0.1:4445.\nمقاربة أفضل: استخدم إضافة FoxyProxy أو Proxy SwitchyOmega للتوجيه الانتقائي لعناوين ‎.i2p.\nأخطاء \u0026ldquo;Website Not Found In Address Book\u0026rdquo; تعني أن الـ router يفتقر إلى العنوان التشفيري لنطاق .i2p. يستخدم I2P دفاتر عناوين محلية بدلاً من نظام أسماء النطاقات (DNS) المركزي. الحلول:\nالطريقة 1: استخدم jump services (خدمات القفز) (الأسهل للمواقع الجديدة):\nانتقل إلى http://stats.i 2p وابحث عن الموقع. انقر رابط addresshelper: http://example.i2p/?i2paddresshelper=base64destination. سيعرض متصفحك \u0026ldquo;Save to addressbook?\u0026rdquo; - أكِّد الإضافة.\nالطريقة 2: تحديث اشتراكات دفتر العناوين:\nانتقل إلى http://127.0.0.1:7657/dns (SusiDNS) انقر علامة التبويب \u0026ldquo;Subscriptions\u0026rdquo; تحقق من الاشتراكات النشطة (الافتراضي: http://i2p-projekt.i 2p/hosts.txt) أضف الاشتراكات الموصى بها: http://stats.i 2p/cgi-bin/newhosts.txt http://notbob.i 2p/hosts.txt http://reg.i 2p/export/hosts.txt انقر \u0026ldquo;Update Now\u0026rdquo; لفرض التحديث الفوري للاشتراكات انتظر 5-10 دقائق لإتمام المعالجة الطريقة الثالثة: استخدم عناوين base32 (تعمل دائمًا إذا كان الموقع متاحًا على الإنترنت):\nكل موقع ‎.i2p‎ له عنوان Base32: 52 حرفًا عشوائيًا تليها ‎.b32.i2p‎ (على سبيل المثال، ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p). تتخطّى عناوين Base32 الـ addressbook (دفتر العناوين) - يقوم الـ router بإجراء استعلام تشفيري مباشر.\nأخطاء شائعة في إعداد المتصفح:\nمحاولة استخدام HTTPS على مواقع مقتصرة على HTTP: معظم مواقع .i2p تستخدم HTTP فقط - ستفشل محاولة https://example.i2p نسيان بادئة http://: قد يقوم المتصفح بالبحث بدلًا من الاتصال - استخدم دائمًا http://example.i2p تمكين WebRTC: قد يسرّب عنوان IP الحقيقي - عطّله عبر إعدادات Firefox أو عبر الإضافات DNS غير مُمرَّر عبر وكيل: لا يستطيع DNS الخاص بـ clearnet (الإنترنت العادي/العلني) حلّ نطاقات .i2p - يجب تمرير استعلامات DNS عبر الوكيل منفذ الوكيل غير صحيح: 4444 لـ HTTP (وليس 4445، لأنه HTTPS outproxy (وكيل خروج) إلى clearnet) Router غير مندمج بالكامل يمنع الوصول إلى أي موقع. تحقق من كفاية الاندماج:\nتحقق من أن http://127.0.0.1:7657 يعرض \u0026ldquo;Network: OK\u0026rdquo; أو \u0026ldquo;Network: Firewalled\u0026rdquo; (وليس \u0026ldquo;Network: Testing\u0026rdquo;) يجب أن يعرض Active peers 10+ كحد أدنى (50+ أمثل) لا تظهر الرسالة \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; انتظر 10-15 دقيقة كاملة بعد بدء تشغيل router قبل توقع الوصول إلى .i2p إعدادات IRC وعميل البريد الإلكتروني تتبع أنماطاً متشابهة للوكيل:\nIRC: يتصل العملاء بـ 127.0.0.1:6668 (IRC proxy tunnel الخاص بـ I2P). عطّل إعدادات الوكيل في عميل IRC - الاتصال بـ localhost:6668 مُمرَّر بالفعل عبر I2P.\nالبريد الإلكتروني (Postman): - SMTP: 127.0.0.1:7659 - POP3: 127.0.0.1:7660 - بدون SSL/TLS (يتم تولّي التشفير بواسطة I2P tunnel) - بيانات الاعتماد من تسجيل حساب postman.i2p\nيجب أن تُظهر جميع هذه الـ tunnels حالة \u0026ldquo;running\u0026rdquo; (باللون الأخضر) على http://127.0.0.1:7657/i2ptunnel.\nإخفاقات التثبيت ومشكلات الحزم تفشل عمليات التثبيت المبنية على الحزم (Debian وUbuntu وArch) أحياناً بسبب تغييرات المستودعات، أو انتهاء صلاحية مفتاح GPG، أو تعارضات التبعيات. لقد تغيّرت المستودعات الرسمية من deb.i2p2.de/deb.i2p2.no (انتهى الدعم) إلى deb.i2p.net في الإصدارات الأخيرة.\nتحديث مستودع Debian/Ubuntu إلى الإصدار الحالي:\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring إخفاقات التحقق من توقيعات GPG تحدث عندما تنتهي صلاحية مفاتيح المستودع أو تتغير:\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc تعذّر بدء الخدمة بعد تثبيت الحزمة غالبًا ما ينتج عن مشكلات في ملفات تعريف AppArmor على Debian/Ubuntu:\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service مشكلات الأذونات في I2P المثبّت عبر الحزمة:\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 مشكلات التوافق مع Java:\nيتطلب I2P 2.10.0 Java 8 كحد أدنى. قد تعمل الأنظمة الأقدم بـ Java 7 أو أقدم:\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java أخطاء تهيئة Wrapper تمنع بدء تشغيل الخدمة:\nيختلف موقع Wrapper.config حسب طريقة التثبيت: - تثبيت المستخدم: ~/.i2p/wrapper.config - تثبيت الحزمة: /etc/i2p/wrapper.config أو /var/lib/i2p/wrapper.config\nمشكلات wrapper.config الشائعة:\nمسارات غير صحيحة: يجب أن يشير wrapper.java.command إلى تثبيت Java صالح ذاكرة غير كافية: تم ضبط wrapper.java.maxmemory على قيمة منخفضة جداً (زِدها إلى 512+) موقع ملف PID غير صحيح: يجب أن يشير wrapper.pidfile إلى موقع قابل للكتابة غياب الثنائي الخاص بـ wrapper (أداة تغليف): بعض المنصات تفتقر إلى نسخة wrapper مبنية مسبقاً (استخدم runplain.sh كحل احتياطي) إخفاقات التحديث والتحديثات التالفة:\nتفشل تحديثات وحدة تحكم router أحيانًا في منتصف التنزيل بسبب انقطاعات الشبكة. إجراء التحديث اليدوي:\nنزّل i2pupdate_X.X.X.zip من https://geti2p.net/en/download تحقّق من أن المجموع الاختباري SHA256 يطابق الهاش المنشور انسخ إلى دليل تثبيت I2P باسم i2pupdate.zip أعد تشغيل router - سيكتشف التحديث ويستخرجه تلقائيًا انتظر 5-10 دقائق حتى يكتمل تثبيت التحديث تحقّق من الإصدار الجديد على http://127.0.0.1:7657 الترحيل من إصدارات قديمة جدًا (ما قبل 0.9.47) إلى الإصدارات الحالية قد يفشل بسبب مفاتيح توقيع غير متوافقة أو ميزات تمت إزالتها. التحديثات التدريجية مطلوبة:\nالإصدارات الأقدم من 0.9.9: لا يمكن التحقق من التواقيع الحالية - يلزم التحديث يدويًا الإصدارات التي تعمل على Java 6/7: يجب ترقية Java قبل تحديث I2P إلى 2.x فجوات كبيرة بين الإصدارات الرئيسية: حدّث أولًا إلى إصدار وسيط (0.9.47 يُوصى به كنقطة وسيطة) متى تستخدم المُثبّت مقابل الحزمة:\nالحزم (apt/yum): الأفضل للخوادم، تحديثات أمنية تلقائية، تكامل مع النظام، إدارة systemd المثبت (.jar): الأفضل للتثبيت على مستوى المستخدم، Windows، macOS، عمليات تثبيت مخصصة، توافر أحدث إصدار تلف ملف الإعدادات واستعادته تعتمد استمرارية إعدادات I2P على عدة ملفات أساسية. غالبًا ما ينجم التلف عن إيقاف تشغيل غير سليم، أو أخطاء القرص، أو أخطاء التحرير اليدوي. إن فهم غايات الملفات يتيح إصلاحًا دقيقًا بدلًا من إعادة التثبيت الكاملة.\nالملفات الحرجة وأغراضها:\nrouter.keys (516+ bytes): الهوية التشفيرية للـ router - فقدانه يؤدي إلى إنشاء هوية جديدة router.info (يُولَّد تلقائيًا): معلومات الـ router المنشورة - يمكن حذفه بأمان، سيُعاد توليده router.config (نصي): الإعدادات الرئيسية - عرض النطاق الترددي، إعدادات الشبكة، التفضيلات i2ptunnel.config (نصي): تعريفات tunnel (نفق) - tunnels العميل/الخادم، المفاتيح، الوجهات netDb/ (دليل): قاعدة بيانات الأقران - معلومات الـ router الخاصة بمشاركي الشبكة peerProfiles/ (دليل): إحصاءات الأداء عن الأقران - تؤثر على اختيار tunnel keyData/ (دليل): مفاتيح الوجهات لـ eepsites والخدمات - فقدانها يغيّر العناوين addressbook/ (دليل): تعيينات أسماء المضيف .i2p المحلية إجراء النسخ الاحتياطي الكامل قبل إجراء التعديلات:\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR أعراض تلف Router.config:\nRouter لا يبدأ مع وجود أخطاء تحليل في السجلات الإعدادات لا تُحفظ بعد إعادة التشغيل ظهور قيم افتراضية غير متوقعة أحرف مشوهة عند عرض الملف إصلاح router.config التالف:\nأنشئ نسخة احتياطية من الموجود: cp router.config router.config.broken تحقق من ترميز الملف: يجب أن يكون UTF-8 بدون BOM (علامة ترتيب البايتات) تحقق من صحة البنية: تستخدم المفاتيح الفاصل = (وليس :)، ومن دون مسافات لاحقة في المفاتيح، و# للتعليقات فقط أشكال تلف شائعة: أحرف غير ASCII في القيم، ومشكلات في نهايات الأسطر (CRLF مقابل LF) إذا تعذّر الإصلاح: احذف router.config - سيقوم router بإنشاء إعدادات افتراضية مع الحفاظ على الهوية إعدادات router.config الأساسية التي ينبغي الحفاظ عليها:\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false فقدان أو عدم صلاحية router.keys يؤدي إلى إنشاء هوية router جديدة. يُعد هذا مقبولًا ما لم:\nتشغيل floodfill (عقدة خاصة في I2P لتخزين netDb) (يفقد حالة floodfill) استضافة eepsites (مواقع ويب داخل شبكة I2P) بعنوان منشور (يفقد الاستمرارية) سمعة راسخة في الشبكة لا يمكن الاستعادة بدون نسخة احتياطية - لإنشاء هوية جديدة: احذف router.keys، وأعِد تشغيل I2P، وسيتم إنشاء هوية جديدة.\nتمييز حاسم: router.keys (الهوية) مقابل keyData/* (الخدمات). فقدان router.keys يغيّر هوية router. فقدان keyData/mysite-keys.dat يغيّر عنوان eepsite على .i2p - أمر كارثي إذا كان العنوان منشورًا.\nانسخ مفاتيح eepsite/الخدمة احتياطياً بشكل منفصل:\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat تلف NetDb وpeerProfiles:\nالأعراض: عدم وجود أقران نشطين، تعذر إنشاء tunnels، \u0026ldquo;Database corruption detected\u0026rdquo; في السجلات\nإصلاح آمن (سيقوم الجميع بعملية reseed (إعادة جلب بيانات البداية) و rebuild (إعادة البناء) تلقائياً):\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration تحتوي هذه المجلدات على معلومات شبكة مخزنة مؤقتًا فقط - يؤدي حذفها إلى فرض عملية bootstrap (تهيئة أولية) جديدة، دون فقدان أي بيانات حرجة.\nاستراتيجيات الوقاية:\nإيقاف منظّم دائماً: استخدم i2prouter stop أو زر \u0026ldquo;Shutdown\u0026rdquo; في لوحة تحكم router - لا تستخدم الإنهاء القسري أبداً نسخ احتياطية مؤتمتة: مهمة Cron (أداة جدولة مهام في Unix) لنسخ ~/.i2p احتياطياً أسبوعياً إلى قرص منفصل مراقبة صحة القرص: تحقق دورياً من حالة SMART (تقنية المراقبة الذاتية والتحليل والتبليغ للأقراص) - تعطل الأقراص يفسد البيانات مساحة قرص كافية: حافظ على توفر أكثر من 1 GB مساحة حرة - امتلاء الأقراص يسبب فساد البيانات يوصى باستخدام UPS (مزود طاقة غير منقطع): انقطاعات الطاقة أثناء الكتابة تُفسد الملفات التحكم بالإصدارات للإعدادات الحرِجة: مستودع Git لـ router.config و i2ptunnel.config يتيح التراجع أذونات الملفات مهمة:\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems رسائل الخطأ الشائعة مُفسَّرة يوفّر تسجيل I2P رسائل خطأ محددة تُحدِّد المشكلات بدقة. فهم هذه الرسائل يُسرّع عملية استكشاف الأخطاء وإصلاحها.\nتظهر \u0026ldquo;No tunnels available\u0026rdquo; عندما لا يكون الـ router قد أنشأ عددًا كافيًا من الـ tunnels للتشغيل. هذا أمر طبيعي خلال أول 5-10 دقائق بعد بدء التشغيل. إذا استمرّ لأكثر من 15 دقيقة:\nتحقق من أن عدد النظراء النشطين \u0026gt; 10 على http://127.0.0.1:7657 تحقق من كفاية تخصيص عرض النطاق الترددي (حد أدنى 128+ KB/sec) افحص معدل نجاح tunnel على http://127.0.0.1:7657/tunnels (يجب أن يكون \u0026gt;40%) راجع السجلات لمعرفة أسباب رفض إنشاء tunnel \u0026ldquo;Clock skew detected\u0026rdquo; أو \u0026ldquo;NTCP2 disconnect code 7\u0026rdquo; يعني أن وقت النظام يختلف عن إجماع الشبكة بأكثر من 90 ثانية. يتطلب I2P دقة ±60 ثانية. يتم رفض الاتصالات مع routers المنحرفة زمنياً تلقائياً.\nأصلح فورًا:\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings تعني \u0026ldquo;Build timeout\u0026rdquo; أو \u0026ldquo;Tunnel build timeout exceeded\u0026rdquo; أن عملية بناء الـ tunnel عبر سلسلة الأقران لم تكتمل ضمن نافذة المهلة الزمنية (عادةً 60 ثانية). الأسباب:\nأقران بطيئون: اختار Router مشاركين غير مستجيبين لـ tunnel ازدحام الشبكة: شبكة I2P تشهد حملاً مرتفعاً عرض نطاق غير كافٍ: حدود عرض النطاق لديك تمنع بناء tunnel في الوقت المناسب router مُحمَّل بشكل زائد: كثرة tunnels المشاركة تستهلك الموارد الحلول: زيادة عرض النطاق الترددي، تقليل عدد الـ tunnels (أنفاق I2P) المشاركة (router.maxParticipatingTunnels في http://127.0.0.1:7657/configadvanced)، وتمكين إعادة توجيه المنافذ لتحسين اختيار الأقران.\n\u0026ldquo;جارٍ إيقاف تشغيل Router\u0026rdquo; أو \u0026ldquo;إيقاف تشغيل سلس قيد التنفيذ\u0026rdquo; تظهران أثناء الإيقاف العادي أو الاستعادة بعد التعطل. قد يستغرق الإيقاف السلس حتى 10 دقائق بينما يقوم router بإغلاق tunnels، وإخطار النظراء، وحفظ الحالة بشكل دائم.\nإذا ظل عالقًا في حالة الإيقاف لأكثر من 11 دقيقة، فافرض الإنهاء:\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; يشير إلى نفاد ذاكرة الكومة. حلول فورية:\nعدّل wrapper.config: wrapper.java.maxmemory=512 (أو أعلى) مطلوب إيقاف تشغيل كامل - إعادة التشغيل لن تطبق التغيير انتظر 11 دقيقة لإيقاف التشغيل الكامل ابدأ router من جديد تحقق من تخصيص الذاكرة في http://127.0.0.1:7657/graphs - ينبغي أن يُظهر هامشًا احتياطيًا أخطاء الذاكرة ذات الصلة:\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo;: استغراق وقت طويل في عملية garbage collection (جمع الذاكرة التلقائي) - زِد حجم الـ heap (منطقة الذاكرة المخصصة للكائنات) \u0026ldquo;Metaspace (مساحة ميتاداتا أصناف Java)\u0026rdquo;: نَفِدت مساحة بيانات وصف أصناف Java - أضِف wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M خاص بـ Windows: يحدّ Kaspersky Antivirus كومة Java إلى 512MB بغضّ النظر عن إعدادات wrapper.config - ألغِ التثبيت أو أضِف I2P إلى الاستثناءات.\n\u0026ldquo;انتهاء مهلة الاتصال\u0026rdquo; أو \u0026ldquo;خطأ I2CP - المنفذ 7654\u0026rdquo; عند محاولة التطبيقات الاتصال بالـ router:\nتحقق من أن router قيد التشغيل: http://127.0.0.1:7657 يجب أن يستجيب تحقق من منفذ I2CP: netstat -an | grep 7654 يجب أن يُظهر LISTENING تأكد من أن جدار الحماية على localhost (المضيف المحلي) يسمح بذلك: sudo ufw allow from 127.0.0.1 تحقق من أن التطبيق يستخدم المنفذ الصحيح (I2CP=7654, SAM=7656) \u0026ldquo;Certificate validation failed\u0026rdquo; أو \u0026ldquo;RouterInfo corrupt\u0026rdquo; أثناء reseed (عملية جلب بيانات الشبكة الأولية):\nالأسباب الجذرية: انحراف الساعة (أصلح الانحراف أولاً)، تلف في netDb، شهادات reseed (إعادة البذر) غير صالحة\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data \u0026ldquo;Database corruption detected\u0026rdquo; تعني حدوث تلف في البيانات على مستوى القرص ضمن netDb أو peerProfiles (ملفات تعريف النظراء):\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start تحقق من صحة القرص باستخدام أدوات SMART (تقنية المراقبة الذاتية والتحليل وإعداد التقارير)؛ إذ إن تكرار تلف البيانات يشير إلى أن وسيط التخزين على وشك الفشل.\nالتحديات الخاصة بكل منصة تطرح أنظمة التشغيل المختلفة تحديات فريدة في نشر I2P تتعلق بالأذونات وسياسات الأمان وتكامل النظام.\nمشكلات الصلاحيات والخدمات في لينكس I2P المثبت عبر حزم التوزيعة يعمل تحت حساب نظام i2psvc (Debian/Ubuntu) أو i2p (توزيعات أخرى)، ويتطلب أذونات محددة:\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config حدود واصفات الملفات تؤثر على سعة الـ router للاتصالات. الحدود الافتراضية (1024) غير كافية لـ routers ذات عرض نطاق عالٍ:\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p تعارضات AppArmor (آلية أمان في لينكس) الشائعة في Debian/Ubuntu تمنع بدء تشغيل الخدمة:\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined مشكلات SELinux على RHEL/CentOS/Fedora:\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t استكشاف أخطاء خدمة SystemD وإصلاحها:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service تداخل جدار حماية Windows وبرامج مكافحة الفيروسات غالبًا ما تقوم Windows Defender ومنتجات مكافحة الفيروسات التابعة لجهات خارجية بالإشارة إلى I2P على أنه مشبوه بسبب أنماط سلوك الشبكة. يمنع الإعداد الصحيح عمليات الحظر غير الضرورية مع الحفاظ على الأمان.\nتكوين جدار حماية Windows Defender:\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; استبدل المنفذ 22648 بمنفذ I2P الفعلي لديك من http://127.0.0.1:7657/confignet.\nمشكلة خاصة بـ Kaspersky Antivirus: تقيّد ميزة \u0026ldquo;Application Control\u0026rdquo; لدى Kaspersky ذاكرة Java heap إلى 512MB بغضّ النظر عن إعدادات wrapper.config. يؤدي ذلك إلى OutOfMemoryError (خطأ نفاد الذاكرة) على routers ذات نطاق ترددي مرتفع.\nالحلول: 1. أضف I2P إلى قائمة الاستثناءات في Kaspersky: Settings → Additional → Threats and Exclusions → Manage Exclusions 2. أو قم بإلغاء تثبيت Kaspersky (موصى به لتشغيل I2P)\nإرشادات عامة لبرامج مكافحة الفيروسات من جهات خارجية:\nأضِف دليل تثبيت I2P إلى قائمة الاستثناءات أضِف %APPDATA%\\I2P و%LOCALAPPDATA%\\I2P إلى قائمة الاستثناءات استبعد javaw.exe من التحليل السلوكي عطّل ميزات \u0026ldquo;Network Attack Protection\u0026rdquo; التي قد تتداخل مع بروتوكولات I2P Gatekeeper في macOS يمنع التثبيت يمنع Gatekeeper في macOS تشغيل التطبيقات غير الموقَّعة. مثبّتات I2P غير موقَّعة باستخدام Apple Developer ID، مما يؤدي إلى ظهور تحذيرات أمنية.\nتجاوز Gatekeeper (ميزة أمان في macOS) لمثبّت I2P:\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file التشغيل بعد التثبيت قد لا يزال يؤدي إلى ظهور تحذيرات:\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ لا تقم مطلقًا بتعطيل Gatekeeper بشكل دائم - خطر أمني على التطبيقات الأخرى. استخدم تجاوزات خاصة بكل ملف فقط.\nتكوين جدار الحماية في macOS:\nتفضيلات النظام → الأمان والخصوصية → جدار الحماية → خيارات جدار الحماية انقر على \u0026ldquo;+\u0026rdquo; لإضافة تطبيق انتقل إلى تثبيت Java (مثلًا، /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java) أضِف واضبط على \u0026ldquo;السماح بالاتصالات الواردة\u0026rdquo; مشكلات تطبيق I2P على أندرويد تفرض قيود إصدارات Android ومحدودية الموارد تحديات فريدة.\nالمتطلبات الدنيا: - Android 5.0+ (API level 21+) مطلوب للإصدارات الحالية - 512MB RAM كحد أدنى، ويوصى بـ 1GB+ - مساحة تخزين 100MB للتطبيق + بيانات router - يجب تعطيل قيود تشغيل التطبيق في الخلفية لـ I2P\nيتعطل التطبيق فورًا:\nتحقق من إصدار Android: الإعدادات → حول الهاتف → إصدار Android (يجب أن يكون 5.0+) أزل تثبيت جميع إصدارات I2P: ثبّت إصدارًا واحدًا فقط: net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\nتؤدي عمليات التثبيت المتعددة إلى تعارض امسح بيانات التطبيق: الإعدادات → التطبيقات → I2P → التخزين → مسح البيانات أعد التثبيت من حالة نظيفة تحسين البطارية يتسبب في إيقاف router:\nيقوم Android بإنهاء التطبيقات التي تعمل في الخلفية بشكل عدواني لتوفير طاقة البطارية. يجب استثناء I2P:\nالإعدادات → البطارية → تحسين البطارية (أو استخدام بطارية التطبيق) ابحث عن I2P → عدم التحسين (أو السماح بالنشاط في الخلفية) الإعدادات → التطبيقات → I2P → البطارية → السماح بالنشاط في الخلفية + إزالة القيود مشكلات الاتصال على الأجهزة المحمولة:\nيتطلب التمهيد WiFi: تنزيل reseed (عملية جلب بيانات التهيئة الأولية للشبكة) يستهلك قدراً كبيراً من البيانات - استخدم WiFi وليس الشبكة الخلوية تغييرات الشبكة: لا يتعامل I2P بسلاسة مع تبديل الشبكات - أعد تشغيل التطبيق بعد الانتقال بين WiFi/الشبكة الخلوية عرض النطاق للمحمول: اضبط الإعدادات بشكل متحفظ عند 64-128 KB/sec لتجنب استنزاف البيانات الخلوية تحسين الأداء للأجهزة المحمولة:\nتطبيق I2P → القائمة → الإعدادات → النطاق الترددي عيّن حدودًا مناسبة: 64 KB/sec وارد، 32 KB/sec صادر للاتصال الخلوي قلّل عدد tunnels المشاركة: الإعدادات → متقدمة → الحد الأقصى لعدد tunnels المشاركة: 100-200 فعّل \u0026ldquo;Stop I2P when screen off\u0026rdquo; للحفاظ على البطارية التورنت على أندرويد:\nاقصر عدد التورنتات المتزامنة على 2-3 كحدٍ أقصى قلّل حدة DHT (جدول التجزئة الموزع) استخدم WiFi فقط للتورنت تقبّل سرعات أبطأ على الأجهزة المحمولة مشكلات إعادة البذر والتمهيد تتطلب عمليات تثبيت I2P الجديدة reseeding (إعادة البذر) - جلب معلومات الأقران الأولية من خوادم HTTPS عامة للانضمام إلى الشبكة. تؤدي مشكلات reseed إلى عزل المستخدمين بلا أي أقران وبدون إمكانية الوصول إلى الشبكة.\n\u0026ldquo;لا يوجد أقران نشطون\u0026rdquo; بعد التثبيت الجديد غالبًا ما يشير إلى فشل reseed (عملية الجلب الأولي للأقران). الأعراض:\nالأقران المعروفون: 0 أو يظل أقل من 5 تستمر حالة \u0026ldquo;Network: Testing\u0026rdquo; لأكثر من 15 دقيقة تُظهر السجلات \u0026ldquo;Reseed failed\u0026rdquo; أو أخطاء اتصال بخوادم reseed (خوادم التزويد الأولي بالأقران) لماذا يفشل reseed (عملية التمهيد الأولي للشبكة):\nحظر HTTPS بواسطة جدار الحماية: جدران حماية الشركات/مزودي خدمة الإنترنت تحظر الاتصالات بخوادم reseed (خوادم تمهيد للشبكة) (المنفذ 443) أخطاء شهادات SSL: يفتقر النظام إلى شهادات الجذر المحدّثة اشتراط وكيل (Proxy): تتطلب الشبكة وكيل HTTP/SOCKS للاتصالات الخارجية انحراف الساعة: يفشل التحقق من شهادات SSL عندما يكون وقت النظام غير صحيح الرقابة الجغرافية: بعض البلدان/مزودي خدمة الإنترنت يحظرون خوادم reseed المعروفة فرض إجراء reseed يدوي (جلب بيانات العقد التمهيدية للبدء):\nافتح http://127.0.0.1:7657/configreseed انقر \u0026ldquo;Save changes and reseed now\u0026rdquo; راقب http://127.0.0.1:7657/logs بحثًا عن \u0026ldquo;Reseed got XX router infos\u0026rdquo; انتظر 5-10 دقائق لإتمام المعالجة تحقّق من http://127.0.0.1:7657 - ينبغي أن يرتفع عدد الأقران المعروفين إلى 50+ قم بإعداد reseed proxy (وكيل لجلب بيانات التمهيد) للشبكات المقيّدة:\nhttp://127.0.0.1:7657/configreseed → إعدادات الوكيل:\nوكيل HTTP: [proxy-server]:[port] أو SOCKS5: [socks-server]:[port] فعّل \u0026ldquo;استخدام الوكيل لإعادة البذر فقط\u0026rdquo; بيانات الاعتماد إذا لزم الأمر احفظ وافرِض إعادة البذر بديل: وكيل Tor لعملية reseed (استعادة بيانات التمهيد للشبكة):\nإذا كان Tor Browser أو Tor daemon قيد التشغيل:\nنوع الوكيل: SOCKS5 المضيف: 127.0.0.1 المنفذ: 9050 (منفذ SOCKS الافتراضي في Tor) فعِّل وقم بـ reseed (إعادة البذر) إعادة البذر يدويًا عبر ملف su3 (كحل أخير):\nعند فشل كل إجراءات reseed (عملية جلب نظائر البداية) الآلية، احصل على ملف reseed عبر قناة خارجية:\nنزّل i2pseeds.su3 من مصدر موثوق عبر اتصال غير مقيّد (https://reseed.i2p.rocks/i2pseeds.su3 , https://reseed-fr.i2pd.xyz/i2pseeds.su3 ) أوقف I2P بالكامل انسخ i2pseeds.su3 إلى الدليل ~/.i2p/ ابدأ I2P - سيقوم تلقائيًا باستخراج الملف ومعالجته احذف i2pseeds.su3 بعد المعالجة تحقّق من زيادة الأقران على http://127.0.0.1:7657 أخطاء شهادات SSL أثناء إعادة البذر (reseed):\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing الحلول:\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates عالِق عند 0 من النُظراء المعروفين لأكثر من 30 دقيقة:\nيشير إلى فشل كامل في إعادة البذر. تسلسل استكشاف الأخطاء وإصلاحها:\nتحقّق من أن وقت النظام دقيق (أكثر مشكلة شيوعًا - أصلِح هذا أولاً) اختبر اتصال HTTPS: جرّب الوصول إلى https://reseed.i2p.rocks في المتصفح - إذا فشل، فهذه مشكلة في الشبكة تحقّق من سجلات I2P على http://127.0.0.1:7657/logs لأخطاء reseed (عملية جلب النظراء الأوّلية) المحددة جرّب عنوان reseed URL مختلف: http://127.0.0.1:7657/configreseed → أضِف عنوان reseed URL مخصّصًا: https://reseed-fr.i2pd.xyz/ استخدم طريقة ملف su3 اليدوية إذا استُنفِدت المحاولات الآلية Reseed servers (خوادم إعادة البذر) تتوقف عن العمل أحياناً: يتضمن I2P عدة reseed servers مضمّنة بشكل ثابت. إذا تعطل أحدها، يحاول router غيرها تلقائياً. الفشل التام لجميع reseed servers أمر نادر للغاية لكنه ممكن.\nخوادم reseed (خوادم التهيئة الأولية للشبكة) النشطة حاليًا (اعتبارًا من أكتوبر 2025):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ أضِفها كعناوين URL مخصّصة إذا واجهت مشاكل مع الإعدادات الافتراضية.\nللمستخدمين في المناطق ذات الرقابة المشددة:\nفكّر في استخدام Snowflake/Meek bridges (جسور لتخطي الرقابة) عبر Tor لإجراء reseed أولي (التمهيد الأولي لعناوين نظراء I2P)، ثم التحويل إلى I2P مباشرةً بعد الاندماج في الشبكة. أو احصل على i2pseeds.su3 عبر steganography (إخفاء البيانات)، أو البريد الإلكتروني، أو USB من خارج منطقة الرقابة.\nمتى ينبغي طلب مساعدة إضافية يغطي هذا الدليل الغالبية العظمى من مشكلات I2P، ولكن بعض المشكلات تتطلب انتباه المطورين أو خبرة المجتمع.\nاطلب المساعدة من مجتمع I2P عندما:\nيتعطّل الـ Router باستمرار بعد اتباع جميع خطوات استكشاف الأخطاء وإصلاحها تسرّبات الذاكرة تتسبب في نمو مطّرد يتجاوز heap (ذاكرة الكومة) المخصّصة يظل معدل نجاح الـ Tunnel أقل من 20% على الرغم من التهيئة الكافية أخطاء جديدة في السجلات لا يغطيها هذا الدليل تم اكتشاف ثغرات أمنية طلبات ميزات أو اقتراحات تحسين قبل طلب المساعدة، اجمع بيانات التشخيص:\nإصدار I2P: http://127.0.0.1:7657 (مثال: \u0026ldquo;2.10.0\u0026rdquo;) إصدار Java: ناتج الأمر java -version نظام التشغيل والإصدار حالة الـ router: حالة الشبكة، عدد الأقران النشِطين، tunnels المشاركة إعدادات عرض النطاق: حدود الوارد/الصادر حالة إعادة توجيه المنافذ: خلف جدار ناري أو OK مقتطفات السجل ذات الصلة: آخر 50 سطرًا التي تُظهر الأخطاء من http://127.0.0.1:7657/logs قنوات الدعم الرسمية:\nالمنتدى: https://i2pforum.net (clearnet: الإنترنت العادي) أو http://i2pforum.i 2p (داخل I2P) IRC: #i2p على Irc2P (irc.postman.i2p عبر I2P) أو irc.freenode.net (clearnet) Reddit: https://reddit.com/r/i2p لمناقشات المجتمع متعقب الأخطاء: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues للأخطاء المؤكدة القائمة البريدية: i2p-dev@lists.i2p-projekt.de لأسئلة التطوير التوقعات الواقعية مهمة. I2P أبطأ من clearnet (الإنترنت المكشوف) بحكم تصميمه الأساسي - فالـ tunneling المشفّر متعدد القفزات يخلق كموناً متأصلاً. إن I2P router الذي تبلغ أوقات تحميل صفحاته 30 ثانية وتصل سرعات التورنت فيه إلى 50 KB/sec هو يعمل بشكل صحيح، وليس معطلاً. سيُصاب المستخدمون الذين يتوقعون سرعات clearnet بخيبة أمل بغض النظر عن تحسين الإعدادات.\nالخلاصة معظم مشكلات I2P تنبع من ثلاث فئات: نقص الصبر أثناء التمهيد (يتطلب 10-15 دقيقة)، تخصيص موارد غير كافٍ (512 MB RAM، بحد أدنى لعرض النطاق الترددي 256 KB/sec)، أو إعداد غير صحيح لإعادة توجيه المنافذ. إن فهم البنية الموزعة لـ I2P والتصميم الذي يركز على إخفاء الهوية يساعد المستخدمين على التمييز بين السلوك المتوقع والمشكلات الفعلية.\nحالة \u0026ldquo;Firewalled\u0026rdquo; (خلف جدار ناري) الخاصة بالـ router، رغم أنها غير مثالية، لا تمنع استخدام I2P - بل تقتصر آثارها على تقليل المساهمة في الشبكة وتدهور طفيف في الأداء. ينبغي على المستخدمين الجدد إعطاء الأولوية لـ الاستقرار على حساب التحسين: شغّل الـ router بشكل مستمر لعدة أيام قبل ضبط الإعدادات المتقدمة، إذ يتحسن الاندماج في الشبكة تلقائياً مع ازدياد زمن التشغيل.\nعند استكشاف الأخطاء وإصلاحها، تحقّق دائمًا من الأساسيات أولًا: صحة وقت النظام، عرض نطاق ترددي كافٍ، تشغيل الـ router بشكل متواصل، ووجود 10+ نظراء نشطين. تُحل معظم المشكلات عبر معالجة هذه الأساسيات بدلًا من تعديل معلمات تهيئة مبهمة. يكافئ I2P الصبر والتشغيل المستمر بتحسين الأداء مع مرور الوقت، إذ يبني الـ router سمعة ويُحسّن اختيار النظراء على مدى أيام وأسابيع من زمن التشغيل المتواصل.\n","description":"دليل شامل لاستكشاف أخطاء I2P router الشائعة وإصلاحها، بما في ذلك مشكلات الاتصال والأداء والتهيئة","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"دليل استكشاف أخطاء I2P Router وإصلاحها","url":"/ar/docs/troubleshooting/"},{"categories":null,"content":"هل تريد المساعدة في جعل I2P متاحًا لمزيد من الأشخاص حول العالم؟ الترجمة هي واحدة من أكثر المساهمات قيمة التي يمكنك تقديمها للمشروع. سيرشدك هذا الدليل خلال ترجمة وحدة تحكم الموجه (router console).\nطرق الترجمة هناك طريقتان للمساهمة في الترجمات:\nالطريقة 1: Transifex (موصى بها) هذه هي أسهل طريقة لترجمة I2P. يوفر Transifex واجهة ويب تجعل الترجمة بسيطة وسهلة الوصول.\nسجل في Transifex اطلب الانضمام إلى فريق ترجمة I2P ابدأ الترجمة مباشرة في متصفحك لا حاجة لمعرفة تقنية - فقط سجل وابدأ الترجمة!\nالطريقة الثانية: الترجمة اليدوية للمترجمين الذين يفضلون العمل مع git والملفات المحلية، أو للغات التي لم يتم إعدادها بعد على Transifex.\nالمتطلبات: - الإلمام بنظام التحكم بالإصدارات git - محرر نصوص أو أداة ترجمة (يُنصح باستخدام POEdit) - أدوات سطر الأوامر: git، gettext\nالإعداد: 1. انضم إلى #i2p-dev على IRC وقدم نفسك 2. قم بتحديث حالة الترجمة على الويكي (اطلب الوصول في IRC) 3. استنسخ المستودع المناسب (انظر الأقسام أدناه)\nترجمة لوحة تحكم الموجه وحدة تحكم الـ router هي واجهة الويب التي تراها عند تشغيل I2P. ترجمتها تساعد المستخدمين غير المرتاحين للغة الإنجليزية.\nاستخدام Transifex (موصى به) انتقل إلى I2P على Transifex اختر مشروع router console اختر لغتك ابدأ الترجمة ترجمة لوحة تحكم الموجه يدوياً المتطلبات الأساسية: - نفس متطلبات ترجمة الموقع الإلكتروني (git، gettext) - مفتاح GPG (للوصول إلى الـ commit) - اتفاقية المطور الموقعة\nاستنساخ مستودع I2P الرئيسي:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p الملفات المطلوب ترجمتها:\nتحتوي واجهة إدارة الراوتر على حوالي 15 ملفًا تحتاج إلى ترجمة:\nملفات الواجهة الأساسية:\napps/routerconsole/locale/messages_*.po - رسائل وحدة التحكم الرئيسية apps/routerconsole/locale-news/messages_*.po - رسائل الأخبار ملفات البروكسي:\napps/i2ptunnel/locale/messages_*.po - واجهة إعدادات Tunnel ملفات اللغة الخاصة بالتطبيقات:\napps/susidns/locale/messages_*.po - واجهة دفتر العناوين apps/susimail/locale/messages_*.po - واجهة البريد الإلكتروني مجلدات اللغة الأخرى الخاصة بالتطبيقات ملفات التوثيق:\ninstaller/resources/readme/readme_*.html - ملف التعليمات الخاص بالتثبيت ملفات المساعدة في التطبيقات المختلفة سير عمل الترجمة:\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console قدم عملك: - أنشئ طلب دمج على GitLab - أو شارك الملفات مع فريق التطوير على IRC\nأدوات الترجمة POEdit (موصى به بشدة) POEdit هو محرر متخصص لملفات الترجمة بصيغة .po.\nالميزات: - واجهة مرئية لأعمال الترجمة - عرض سياق الترجمة - التحقق التلقائي - متوفر لأنظمة Windows و macOS و Linux\nمحررات النصوص يمكنك أيضًا استخدام أي محرر نصوص: - VS Code (مع إضافات i18n) - Sublime Text - vim/emacs (لمستخدمي الطرفية)\nفحوصات الجودة قبل الإرسال: 1. تحقق من التنسيق: تأكد من بقاء العناصر النائبة مثل %s و {0} دون تغيير 2. اختبر ترجماتك: قم بتثبيت وتشغيل I2P لرؤية كيف تبدو 3. الاتساق: حافظ على اتساق المصطلحات عبر الملفات 4. الطول: بعض النصوص لها قيود مساحة في واجهة المستخدم\nنصائح للمترجمين الإرشادات العامة حافظ على الاتساق: استخدم نفس الترجمات للمصطلحات الشائعة في جميع أنحاء النص احتفظ بالتنسيق: احفظ وسوم HTML والعناصر النائبة (%s، {0})، وفواصل الأسطر السياق مهم: اقرأ النص الإنجليزي المصدر بعناية لفهم السياق اطرح الأسئلة: استخدم IRC أو المنتديات إذا كان هناك شيء غير واضح مصطلحات I2P الشائعة يجب أن تبقى بعض المصطلحات باللغة الإنجليزية أو تُنقل حرفياً بعناية:\nI2P - Keep as is eepsite - موقع I2P (قد يتطلب توضيحاً بلغتك) tunnel - مسار الاتصال (تجنب مصطلحات Tor مثل \u0026ldquo;circuit\u0026rdquo;) netDb - قاعدة بيانات الشبكة floodfill - نوع من أنواع الـ router destination - نقطة نهاية عنوان I2P اختبار ترجماتك قم ببناء I2P مع ترجماتك قم بتغيير اللغة في إعدادات router console تصفح جميع الصفحات للتحقق من: ملاءمة النص لعناصر واجهة المستخدم عدم وجود أحرف مشوهة (مشاكل الترميز) منطقية الترجمات في السياق الأسئلة الشائعة لماذا عملية الترجمة معقدة جداً؟ تستخدم العملية نظام التحكم بالإصدارات (git) وأدوات الترجمة القياسية (ملفات .po) للأسباب التالية:\nالمساءلة: تتبع من غيّر ماذا ومتى الجودة: مراجعة التغييرات قبل نشرها الاتساق: الحفاظ على تنسيق وبنية الملفات بشكل صحيح قابلية التوسع: إدارة الترجمات عبر لغات متعددة بكفاءة التعاون: يمكن لعدة مترجمين العمل على نفس اللغة هل أحتاج إلى مهارات برمجة؟ لا! إذا كنت تستخدم Transifex، فأنت تحتاج فقط إلى: - الطلاقة في كل من الإنجليزية واللغة المستهدفة - متصفح ويب - مهارات حاسوبية أساسية\nللترجمة اليدوية، ستحتاج إلى معرفة أساسية بسطر الأوامر، لكن لا حاجة للبرمجة.\nكم من الوقت يستغرق؟ واجهة الراوتر: حوالي 15-20 ساعة لجميع الملفات الصيانة: بضع ساعات شهرياً لتحديث النصوص الجديدة هل يمكن لعدة أشخاص العمل على لغة واحدة؟ نعم! التنسيق هو المفتاح: - استخدم Transifex للتنسيق التلقائي - للعمل اليدوي، تواصل في قناة IRC باسم #i2p-dev - قسّم العمل حسب الأقسام أو الملفات\nماذا لو لم تكن لغتي مدرجة في القائمة؟ اطلبها على Transifex أو تواصل مع الفريق على IRC. يمكن لفريق التطوير إعداد لغة جديدة بسرعة.\nكيف يمكنني اختبار ترجماتي قبل الإرسال؟ قم ببناء I2P من المصدر مع ترجماتك قم بتثبيته وتشغيله محلياً غيّر اللغة في إعدادات وحدة التحكم الحصول على المساعدة دعم IRC انضم إلى #i2p-dev على IRC من أجل: - المساعدة التقنية في أدوات الترجمة - الأسئلة حول مصطلحات I2P - التنسيق مع المترجمين الآخرين - الدعم المباشر من المطورين\nالمنتديات مناقشات الترجمة على منتديات I2P داخل I2P: منتدى الترجمة على zzz.i2p (يتطلب I2P router) التوثيق توثيق Transifex توثيق POEdit دليل gettext التقدير يتم الإشادة بجميع المترجمين في: - وحدة تحكم I2P router (صفحة حول) - صفحة الشكر والتقدير على الموقع الإلكتروني - سجل التزامات Git - إعلانات الإصدارات\nعملك يساعد بشكل مباشر الأشخاص حول العالم على استخدام I2P بأمان وخصوصية. شكراً لك على مساهمتك!\nالخطوات التالية هل أنت مستعد لبدء الترجمة؟\nاختر طريقتك:\nبداية سريعة: سجّل على Transifex طريقة يدوية: انضم إلى #i2p-dev على IRC ابدأ بشكل بسيط: قم بترجمة بضع نصوص للتعرف على العملية\nاطلب المساعدة: لا تتردد في التواصل عبر IRC أو المنتديات\nشكراً لمساعدتك في جعل I2P متاحاً للجميع!\n","description":"كيفية المساهمة بالترجمات لموقع I2P ووحدة تحكم الموجه (router console) باستخدام Transifex أو الطرق اليدوية","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"دليل المترجم الجديد","url":"/ar/docs/develop/new-translators/"},{"categories":null,"content":"هل تريد البدء في العمل على I2P؟ رائع! إليك دليل سريع للبدء في المساهمة في الموقع الإلكتروني أو البرنامج، أو القيام بالتطوير، أو إنشاء الترجمات.\nلست مستعدًا تمامًا للبرمجة؟ جرّب المشاركة أولاً.\nتعرف على Java يستخدم الـ router الخاص بـ I2P والتطبيقات المدمجة فيه لغة Java كلغة التطوير الرئيسية. إذا لم تكن لديك خبرة في Java، يمكنك دائمًا إلقاء نظرة على Thinking in Java ادرس مقدمة \u0026ldquo;كيف\u0026rdquo;، ومستندات \u0026ldquo;كيف\u0026rdquo; الأخرى، والمقدمة التقنية، والمستندات المرتبطة:\nمقدمة تعريفية: Introduction to I2P مركز التوثيق: Documentation مقدمة تقنية: Technical Introduction ستمنحك هذه نظرة عامة جيدة حول كيفية بناء I2P والأشياء المختلفة التي يقوم بها.\nالحصول على كود I2P للتطوير على router I2P أو التطبيقات المضمنة، تحتاج إلى الحصول على الكود المصدري.\nطريقتنا الحالية: Git يمتلك I2P خدمات Git رسمية ويقبل المساهمات عبر Git في GitLab الخاص بنا:\nداخل I2P: http://git.idk.i2p خارج I2P: https://i2pgit.org استنسخ المستودع الرئيسي:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git نسخة للقراءة فقط متاحة أيضًا على GitHub:\nمرآة GitHub: github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git بناء I2P لتجميع الكود، تحتاج إلى Sun/Oracle Java Development Kit 6 أو أعلى، أو JDK مكافئ (يُوصى بشدة باستخدام Sun/Oracle JDK 6) وApache Ant الإصدار 1.7.0 أو أعلى. إذا كنت تعمل على كود I2P الرئيسي، انتقل إلى مجلد i2p.i2p وقم بتشغيل ant لرؤية خيارات البناء.\nلبناء أو العمل على ترجمات console، تحتاج إلى أدوات xgettext و msgfmt و msgmerge من حزمة GNU gettext.\nللتطوير على التطبيقات الجديدة، راجع دليل تطوير التطبيقات .\nأفكار التطوير راجع قائمة المهام TODO الخاصة بالمشروع أو قائمة المشكلات على GitLab للحصول على أفكار:\nمشاكل GitLab: i2pgit.org/I2P_Developers/i2p.i2p/issues جعل النتائج متاحة انظر إلى أسفل صفحة التراخيص لمتطلبات صلاحيات الالتزام (commit privilege). تحتاج إلى هذه الصلاحيات لإضافة الكود إلى i2p.i2p (غير مطلوبة للموقع الإلكتروني!).\nصفحة التراخيص تعرف علينا! يتواجد المطورون على IRC. يمكن الوصول إليهم على شبكات مختلفة وعلى شبكات I2P الداخلية. المكان المعتاد للبحث هو #i2p-dev. انضم إلى القناة وقل مرحباً! لدينا أيضاً إرشادات إضافية للمطورين المنتظمين .\nالترجمات مترجمو الموقع الإلكتروني ولوحة تحكم الراوتر: راجع دليل المترجمين الجدد للخطوات التالية.\nالأدوات I2P هو برنامج مفتوح المصدر يتم تطويره في الغالب باستخدام أدوات مفتوحة المصدر. حصل مشروع I2P مؤخرًا على ترخيص لـ YourKit Java Profiler. المشاريع مفتوحة المصدر مؤهلة للحصول على ترخيص مجاني بشرط الإشارة إلى YourKit على الموقع الإلكتروني للمشروع. يرجى التواصل معنا إذا كنت مهتمًا بتحليل أداء قاعدة كود I2P.\nتدعم YourKit بكرم مشاريع المصادر المفتوحة من خلال أدوات التحليل الكاملة الميزات الخاصة بها. YourKit, LLC هي الشركة المبتكرة لأدوات ذكية ومبتكرة لتحليل تطبيقات Java و .NET. ألقِ نظرة على المنتجات البرمجية الرائدة من YourKit:\nYourKit Java Profiler YourKit .NET Profiler ","description":"كيفية البدء في المساهمة في I2P: مواد الدراسة، الكود المصدري، البناء، الأفكار، النشر، المجتمع، الترجمات، والأدوات","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"دليل المطور الجديد","url":"/ar/docs/develop/new-developers/"},{"categories":null,"content":"يوفر هذا الدليل نظرة عامة على واجهة إدارة I2P Router Console وصفحات التكوين الخاصة بها. يشرح كل قسم وظيفة الصفحة والغرض منها، مما يساعدك على فهم كيفية مراقبة وتكوين جهاز I2P router الخاص بك.\nالوصول إلى لوحة تحكم الـ Router وحدة التحكم في I2P Router هي المركز الرئيسي لإدارة ومراقبة I2P router الخاص بك. بشكل افتراضي، يمكن الوصول إليها عبر وحدة التحكم في I2P Router بمجرد تشغيل I2P router الخاص بك.\nتعرض الصفحة الرئيسية عدة أقسام رئيسية:\nالتطبيقات - وصول سريع إلى تطبيقات I2P المدمجة مثل البريد الإلكتروني، Torrents، مدير الخدمات المخفية، وخادم الويب مواقع مجتمع I2P - روابط لموارد المجتمع المهمة بما في ذلك المنتديات، الوثائق، ومواقع المشروع الإعدادات والمساعدة - أدوات لتكوين إعدادات النطاق الترددي، إدارة الإضافات، والوصول إلى موارد المساعدة معلومات الشبكة والمطورين - الوصول إلى الرسوم البيانية، السجلات، الوثائق التقنية، وإحصائيات الشبكة دفتر العناوين عنوان URL: دفتر العناوين يعمل دفتر عناوين I2P بشكل مشابه لنظام DNS على الشبكة العادية، مما يتيح لك إدارة أسماء يمكن قراءتها بشريًا لوجهات I2P (eepsites). هنا يمكنك عرض وإضافة عناوين I2P إلى دفتر العناوين الشخصي الخاص بك.\nيعمل نظام دفتر العناوين من خلال طبقات متعددة:\nالسجلات المحلية - دفاتر العناوين الشخصية الخاصة بك والمتخزنة فقط على router الخاص بك\nدفتر العناوين المحلي - المضيفون الذين تضيفهم يدوياً أو تحفظهم لاستخدامك الشخصي دفتر العناوين الخاص - العناوين التي لا تريد مشاركتها مع الآخرين؛ لا يتم توزيعها علنياً أبداً الاشتراكات - مصادر دفتر العناوين البعيدة (مثل http://i2p-projekt.i2p/hosts.txt) التي تقوم تلقائياً بتحديث دفتر عناوين الـ router الخاص بك بمواقع I2P المعروفة\nدفتر عناوين الراوتر - النتيجة المدمجة من سجلاتك المحلية والاشتراكات، قابلة للبحث من قبل جميع تطبيقات I2P على الراوتر الخاص بك\nدفتر العناوين المنشور - مشاركة عامة اختيارية لدفتر عناوينك ليستخدمه الآخرون كمصدر اشتراك (مفيد إذا كنت تدير موقع I2P)\nيقوم دفتر العناوين باستطلاع اشتراكاتك بشكل منتظم ودمج المحتوى في دفتر عناوين الموجه الخاص بك، مما يحافظ على تحديث ملف hosts.txt الخاص بك مع شبكة I2P.\nالإعدادات URL: التكوين المتقدم يوفر قسم الإعدادات الوصول إلى جميع إعدادات الـ router من خلال علامات تبويب متخصصة متعددة.\nAdvanced توفر صفحة الإعدادات المتقدمة إمكانية الوصول إلى إعدادات router منخفضة المستوى التي لا تكون مطلوبة عادةً للتشغيل العادي. يجب على معظم المستخدمين عدم تعديل هذه الإعدادات ما لم يفهموا خيار الإعداد المحدد وتأثيره على سلوك router.\nالميزات الرئيسية:\nإعدادات Floodfill - التحكم في ما إذا كان الموجه الخاص بك يشارك كعقدة floodfill، والتي تساعد الشبكة من خلال تخزين وتوزيع معلومات قاعدة بيانات الشبكة. قد يستخدم هذا المزيد من موارد النظام لكنه يعزز شبكة I2P.\nالتكوين المتقدم لـ I2P - وصول مباشر إلى ملف router.config، يعرض جميع معلمات التكوين المتقدمة بما في ذلك:\nحدود عرض النطاق وإعدادات الاندفاع إعدادات النقل (NTCP2، SSU2، منافذ UDP والمفاتيح) معلومات تعريف الـ router والإصدار تفضيلات وحدة التحكم وإعدادات التحديث معظم خيارات الإعدادات المتقدمة غير ظاهرة في واجهة المستخدم لأنها نادراً ما تكون مطلوبة. لتمكين تحرير هذه الإعدادات، يجب عليك إضافة routerconsole.advanced=true إلى ملف router.config يدوياً.\nتحذير: قد يؤثر تعديل الإعدادات المتقدمة بشكل غير صحيح سلباً على أداء router الخاص بك أو الاتصال. قم بتغيير هذه الإعدادات فقط إذا كنت تعرف ما تفعله.\nBandwidth URL: إعدادات النطاق الترددي تتيح لك صفحة إعدادات النطاق الترددي التحكم في مقدار النطاق الترددي الذي يساهم به الـ router الخاص بك في شبكة I2P. يعمل I2P بشكل أفضل عندما تقوم بتكوين معدلاتك لتتناسب مع سرعة اتصالك بالإنترنت.\nالإعدادات الرئيسية:\nKBps In - الحد الأقصى لعرض النطاق الترددي الوارد الذي سيقبله الراوتر الخاص بك (سرعة التنزيل) KBps Out - الحد الأقصى لعرض النطاق الترددي الصادر الذي سيستخدمه الراوتر الخاص بك (سرعة الرفع) Share - النسبة المئوية من عرض النطاق الترددي الصادر المخصص لحركة المرور المشاركة (المساعدة في توجيه حركة المرور للآخرين) ملاحظات مهمة:\nجميع القيم بوحدة بايت في الثانية (KBps)، وليس بت في الثانية كلما زادت سعة النطاق الترددي التي توفرها، كلما ساعدت الشبكة أكثر وحسّنت إخفاء هويتك مقدار مشاركتك للرفع (KBps Out) يحدد مساهمتك الإجمالية في الشبكة إذا كنت غير متأكد من سرعة شبكتك، استخدم اختبار سعة النطاق الترددي لقياسها زيادة سعة النطاق الترددي للمشاركة تحسّن إخفاء هويتك وتساعد في تقوية شبكة I2P تعرض صفحة الإعدادات نقل البيانات الشهري المقدّر بناءً على إعداداتك، مما يساعدك على تخطيط تخصيص عرض النطاق الترددي وفقًا لحدود خطة الإنترنت الخاصة بك.\nClient Configuration URL: إعدادات العميل تتيح لك صفحة إعدادات العميل التحكم في تطبيقات وخدمات I2P التي يتم تشغيلها عند بدء التشغيل. هذا هو المكان الذي يمكنك فيه تمكين أو تعطيل عملاء I2P المدمجين دون إلغاء تثبيتهم.\nتحذير مهم: كن حذرًا عند تغيير الإعدادات هنا. تُعد وحدة تحكم الراوتر وأنفاق التطبيقات مطلوبة لمعظم استخدامات I2P. يجب على المستخدمين المتقدمين فقط تعديل هذه الإعدادات.\nالعملاء المتاحون:\nApplication tunnels - نظام I2PTunnel الذي يدير أنفاق العميل والخادم (وكيل HTTP، IRC، إلخ.) I2P Router Console - واجهة الإدارة المستندة إلى الويب التي تستخدمها حالياً I2P webserver (eepsite) - خادم ويب Jetty المدمج لاستضافة موقع I2P الخاص بك Open Router Console in web browser at startup - يفتح المتصفح تلقائياً إلى الصفحة الرئيسية للوحة التحكم عند بدء التشغيل SAM application bridge - جسر API لتطبيقات الطرف الثالث للاتصال بـ I2P يعرض كل عميل: - التشغيل عند بدء التشغيل؟ - مربع اختيار لتمكين/تعطيل التشغيل التلقائي - التحكم - أزرار بدء/إيقاف للتحكم الفوري - الفئة والمعاملات - تفاصيل تقنية حول كيفية تشغيل العميل\nالتغييرات على إعداد \u0026ldquo;التشغيل عند بدء التشغيل؟\u0026rdquo; تتطلب إعادة تشغيل الموجه لتصبح سارية المفعول. يتم حفظ جميع التعديلات في /var/lib/i2p/i2p-config/clients.config.d/.\nمتقدم عنوان URL: إعدادات I2CP صفحة تكوين I2CP (بروتوكول عميل I2P) تسمح لك بتكوين كيفية اتصال التطبيقات الخارجية بموجه I2P الخاص بك. I2CP هو البروتوكول الذي تستخدمه التطبيقات للتواصل مع الموجه لإنشاء الأنفاق وإرسال/استقبال البيانات عبر I2P.\nهام: الإعدادات الافتراضية ستعمل لمعظم المستخدمين. أي تغييرات يتم إجراؤها هنا يجب أن يتم تكوينها أيضًا في تطبيق العميل الخارجي. العديد من العملاء لا يدعمون SSL أو التفويض. جميع التغييرات تتطلب إعادة التشغيل لتصبح سارية المفعول.\nخيارات الإعدادات:\nتكوين واجهة I2CP الخارجية\nمُفعّل بدون SSL - وصول I2CP القياسي (الافتراضي والأكثر توافقاً) مُفعّل مع SSL مطلوب - اتصالات I2CP مشفرة فقط مُعطّل - يحظر اتصال العملاء الخارجيين عبر I2CP واجهة I2CP - واجهة الشبكة للاستماع عليها (افتراضي: 127.0.0.1 للمضيف المحلي فقط)\nمنفذ I2CP - رقم المنفذ لاتصالات I2CP (افتراضي: 7654)\nالتفويض\nطلب اسم المستخدم وكلمة المرور - تفعيل المصادقة لاتصالات I2CP اسم المستخدم - تعيين اسم المستخدم المطلوب للوصول إلى I2CP كلمة المرور - تعيين كلمة المرور المطلوبة للوصول إلى I2CP ملاحظة أمنية: إذا كنت تقوم بتشغيل التطبيقات فقط على نفس الجهاز الذي يعمل عليه router الخاص بك في I2P، احتفظ بواجهة الاتصال مضبوطة على 127.0.0.1 لمنع الوصول عن بُعد. قم بتغيير هذه الإعدادات فقط إذا كنت بحاجة للسماح لتطبيقات I2P من أجهزة أخرى بالاتصال بـ router الخاص بك.\nالنطاق الترددي عنوان URL: إعدادات الشبكة تتيح لك صفحة إعدادات الشبكة تكوين كيفية اتصال router الخاص بك في I2P بالإنترنت، بما في ذلك اكتشاف عنوان IP، تفضيلات IPv4/IPv6، وإعدادات المنافذ لكل من نقل UDP وTCP.\nعنوان IP قابل للوصول خارجياً:\nاستخدام جميع طرق الكشف التلقائي - يكتشف تلقائياً عنوان IP العام الخاص بك باستخدام طرق متعددة (موصى به) تعطيل كشف عنوان IP عبر UPnP - يمنع استخدام UPnP لاكتشاف عنوان IP الخاص بك تجاهل عنوان IP للواجهة المحلية - عدم استخدام عنوان IP للشبكة المحلية استخدام كشف عنوان IP عبر SSU فقط - استخدام نقل SSU2 فقط لكشف عنوان IP الوضع المخفي - عدم نشر عنوان IP - يمنع المشاركة في حركة مرور الشبكة (يقلل من إخفاء الهوية) تحديد اسم المضيف أو عنوان IP - تعيين عنوان IP العام أو اسم المضيف يدوياً إعدادات IPv4:\nتعطيل الاتصالات الواردة (Firewalled) - حدد هذا الخيار إذا كنت خلف جدار حماية، أو شبكة منزلية، أو مزود خدمة إنترنت، أو DS-Lite، أو NAT على مستوى المشغّل يحظر الاتصالات الواردة إعداد IPv6:\nتفضيل IPv4 على IPv6 - يعطي الأولوية لاتصالات IPv4 تفضيل IPv6 على IPv4 - يعطي الأولوية لاتصالات IPv6 (الافتراضي للشبكات ثنائية المكدس) تمكين IPv6 - يسمح باتصالات IPv6 تعطيل IPv6 - يعطل جميع اتصالات IPv6 استخدام IPv6 فقط (تعطيل IPv4) - وضع IPv6 التجريبي فقط تعطيل الوارد (محمي بجدار ناري) - تحقق من كون IPv6 محمياً بجدار ناري الإجراء عند تغيير عنوان IP:\nوضع الكمبيوتر المحمول - ميزة تجريبية تقوم بتغيير هوية الموجه (router) ومنفذ UDP عندما يتغير عنوان IP الخاص بك لتعزيز عدم الكشف عن الهوية إعدادات UDP:\nتحديد المنفذ - قم بتعيين منفذ UDP محدد لنقل SSU2 (يجب فتحه في جدار الحماية الخاص بك) التعطيل الكامل - اختر هذا الخيار فقط إذا كنت خلف جدار حماية يحظر جميع اتصالات UDP الصادرة إعدادات TCP:\nتحديد المنفذ - تعيين منفذ TCP محدد لنقل NTCP2 (يجب فتحه في جدار الحماية الخاص بك) استخدام نفس المنفذ المُهيأ لـ UDP - يبسط التهيئة باستخدام منفذ واحد لكلا النقلين استخدام عنوان IP المكتشف تلقائياً - يكتشف عنوان IP العام الخاص بك تلقائياً (يظهر \u0026ldquo;غير معروف حالياً\u0026rdquo; إذا لم يتم اكتشافه بعد أو كان محجوباً بجدار حماية) استخدام عنوان IP المكتشف تلقائياً دائماً (غير محجوب بجدار حماية) - الأفضل للموجهات التي لديها وصول مباشر للإنترنت تعطيل الاتصالات الواردة (محجوب بجدار حماية) - ضع علامة إذا كانت اتصالات TCP محظورة بواسطة جدار الحماية الخاص بك التعطيل الكامل - اختر فقط إذا كنت خلف جدار حماية يخنق أو يحظر TCP الصادر تحديد اسم المضيف أو IP - تهيئة عنوانك القابل للوصول خارجياً يدوياً هام: قد تتطلب التغييرات في إعدادات الشبكة إعادة تشغيل الموجه (router) لتصبح سارية المفعول بالكامل. يؤدي تكوين توجيه المنافذ (port forwarding) بشكل صحيح إلى تحسين أداء الموجه بشكل كبير ويساعد شبكة I2P.\nإعداد العميل عنوان URL: إعدادات النظير توفر صفحة إعدادات النظير (Peer Configuration) عناصر تحكم يدوية لإدارة النظراء الفرديين على شبكة I2P. هذه ميزة متقدمة تُستخدم عادةً فقط لاستكشاف أخطاء النظراء الإشكاليين وإصلاحها.\nالتحكم اليدوي بالنظراء:\nRouter Hash - أدخل router hash المكون من 44 حرفاً بصيغة base64 للعقدة التي تريد إدارتها حظر / إلغاء حظر نظير يدوياً:\nحظر نظير يمنعه من المشاركة في أي tunnels تقوم بإنشائها. هذا الإجراء: - يمنع استخدام النظير في tunnels العميل أو الاستكشافية الخاصة بك - يسري مفعوله فوراً دون الحاجة لإعادة التشغيل - يستمر حتى تقوم بإلغاء الحظر يدوياً أو إعادة تشغيل router الخاص بك - حظر النظير حتى إعادة التشغيل - يحظر النظير مؤقتاً - إلغاء حظر النظير - يزيل الحظر عن نظير محظور سابقاً\nضبط مكافآت الملف الشخصي:\nتؤثر مكافآت الملفات الشخصية على كيفية اختيار النظراء للمشاركة في الأنفاق. يمكن أن تكون المكافآت إيجابية أو سلبية: - النظراء السريعون - تُستخدم لأنفاق العميل التي تتطلب سرعة عالية - النظراء ذوو السعة العالية - تُستخدم لبعض الأنفاق الاستكشافية التي تتطلب توجيهاً موثوقاً - يتم عرض المكافآت الحالية على صفحة الملفات الشخصية\nالإعدادات: - السرعة - ضبط مكافأة السرعة لهذا الند (0 = محايد) - السعة - ضبط مكافأة السعة لهذا الند (0 = محايد) - ضبط مكافآت الند - تطبيق إعدادات المكافأة\nحالات الاستخدام: - حظر peer يتسبب باستمرار في مشاكل الاتصال - استبعاد peer مؤقتاً تشك في أنه ضار - ضبط المكافآت لتقليل أولوية peers ضعيفة الأداء - تصحيح أخطاء مشاكل بناء tunnel من خلال استبعاد peers محددة\nملاحظة: معظم المستخدمين لن يحتاجوا أبدًا لاستخدام هذه الميزة. يدير router الخاص بـ I2P تلقائيًا اختيار الأقران وتصنيفهم بناءً على مقاييس الأداء.\nتكوين I2CP عنوان URL: إعدادات Reseed تتيح لك صفحة إعدادات إعادة البذر (Reseed Configuration) إعادة بذر الموجه (router) يدوياً في حالة فشل إعادة البذر التلقائية. إعادة البذر هي عملية الإقلاع الأولي (bootstrapping) المستخدمة للعثور على موجهات أخرى عند تثبيت I2P لأول مرة، أو عندما يتبقى لدى الموجه الخاص بك عدد قليل جداً من مراجع الموجهات.\nمتى تستخدم إعادة التشغيل اليدوية (Manual Reseed):\nإذا فشلت عملية إعادة البذر، يجب عليك أولاً التحقق من اتصال الشبكة لديك\nإذا كان جدار الحماية يحجب اتصالاتك بخوادم إعادة البذر، فقد يكون لديك إمكانية الوصول إلى بروكسي:\nقد يكون البروكسي بروكسي عام بعيد، أو قد يكون يعمل على جهاز الكمبيوتر الخاص بك (localhost) لاستخدام بروكسي، قم بتكوين النوع والمضيف والمنفذ في قسم Reseeding Configuration إذا كنت تستخدم Tor Browser، قم بإعادة البذر من خلاله عن طريق تكوين SOCKS 5، localhost، المنفذ 9150 إذا كنت تستخدم Tor من سطر الأوامر، قم بإعادة البذر من خلاله عن طريق تكوين SOCKS 5، localhost، المنفذ 9050 إذا كان لديك بعض الأقران ولكنك تحتاج المزيد، يمكنك تجربة خيار I2P Outproxy. اترك المضيف والمنفذ فارغين. لن يعمل هذا لعملية إعادة بذر أولية عندما لا يكون لديك أي أقران على الإطلاق ثم، انقر على \u0026ldquo;Save changes and reseed now\u0026rdquo; الإعدادات الافتراضية ستعمل لمعظم الأشخاص. قم بتغيير هذه الإعدادات فقط إذا كان HTTPS محجوباً بواسطة جدار حماية مقيد وفشلت عملية إعادة البذر إذا كنت تعرف وتثق بشخص يشغل I2P، اطلب منه إرسال ملف reseed تم إنشاؤه باستخدام هذه الصفحة على router console الخاص به. ثم، استخدم هذه الصفحة لإعادة التغذية (reseed) بالملف الذي تلقيته. أولاً، حدد الملف أدناه. ثم، انقر على \u0026ldquo;Reseed from file\u0026rdquo;\nإذا كنت تعرف وتثق بشخص ينشر ملفات reseed، اطلب منه الرابط (URL). بعد ذلك، استخدم هذه الصفحة لإجراء reseed باستخدام الرابط الذي حصلت عليه. أولاً، أدخل الرابط أدناه. ثم، انقر على \u0026ldquo;Reseed from URL\u0026rdquo;\nراجع الأسئلة الشائعة للحصول على تعليمات حول إعادة البذر يدوياً\nخيارات إعادة البذر اليدوية:\nإعادة البذر من عنوان URL - أدخل عنوان URL لملف zip أو su3 من مصدر موثوق وانقر على \u0026ldquo;Reseed from URL\u0026rdquo;\nيُفضل تنسيق su3، حيث سيتم التحقق من توقيعه بواسطة مصدر موثوق تنسيق zip غير موقّع؛ استخدم ملف zip فقط من مصدر تثق به إعادة البذر من ملف - تصفح واختر ملف zip أو su3 محلي، ثم انقر على \u0026ldquo;Reseed from file\u0026rdquo;\nيمكنك العثور على ملفات reseed على checki2p.com/reseed إنشاء ملف Reseed - إنشاء ملف reseed مضغوط جديد يمكنك مشاركته ليستخدمه الآخرون في إعادة البذر يدوياً\nلن يحتوي هذا الملف أبداً على هوية الراوتر الخاص بك أو عنوان IP الخاص بك إعدادات إعادة التوزيع (Reseeding):\nالإعدادات الافتراضية ستعمل لمعظم المستخدمين. قم بتغيير هذه الإعدادات فقط إذا كان HTTPS محظوراً بواسطة جدار ناري مقيد وفشل إعادة التزويد (reseed).\nعناوين URL لإعادة البذر - قائمة بعناوين HTTPS لخوادم إعادة البذر (القائمة الافتراضية مدمجة ويتم تحديثها بانتظام) إعدادات البروكسي - تكوين بروكسي HTTP/HTTPS/SOCKS إذا كنت بحاجة للوصول إلى خوادم إعادة البذر من خلال بروكسي إعادة تعيين قائمة URL - استعادة قائمة خوادم إعادة البذر الافتراضية هام: يجب أن يكون البذر اليدوي ضروريًا فقط في حالات نادرة حيث يفشل البذر التلقائي بشكل متكرر. معظم المستخدمين لن يحتاجوا أبدًا لاستخدام هذه الصفحة.\nإعداد الشبكة URL: إعدادات عائلة الراوتر صفحة إعدادات عائلة الموجه (Router Family Configuration) تتيح لك إدارة عائلات الموجهات. الموجهات في نفس العائلة تشترك في مفتاح عائلة، والذي يحددها كموجهات يتم تشغيلها من قبل نفس الشخص أو المؤسسة. هذا يمنع اختيار عدة موجهات تتحكم بها لنفس النفق (tunnel)، مما قد يقلل من إخفاء الهوية.\nما هي عائلة الموجه (Router Family)؟\nعندما تقوم بتشغيل عدة routers من I2P، يجب عليك تهيئتها لتكون جزءًا من نفس العائلة. هذا يضمن: - لن يتم استخدام routers الخاصة بك في نفس مسار tunnel معًا - يحافظ المستخدمون الآخرون على إخفاء الهوية بشكل صحيح عندما تستخدم tunnels الخاصة بهم routers الخاصة بك - يمكن للشبكة توزيع المشاركة في tunnel بشكل صحيح\nالعائلة الحالية:\nتعرض الصفحة اسم عائلة الموجّه الحالي الخاص بك. إذا لم تكن جزءًا من عائلة، فسيكون هذا فارغًا.\nتصدير مفتاح العائلة:\nقم بتصدير مفتاح العائلة السري لاستيراده إلى الموجهات الأخرى التي تتحكم بها انقر على \u0026ldquo;Export Family Key\u0026rdquo; لتنزيل ملف مفتاح العائلة الخاص بك قم باستيراد هذا المفتاح على الموجهات الأخرى لإضافتها إلى نفس العائلة مغادرة عائلة الموجه:\nلن تكون عضواً في العائلة بعد الآن انقر على \u0026ldquo;مغادرة العائلة\u0026rdquo; لإزالة هذا الـ router من عائلته الحالية لا يمكن التراجع عن هذا الإجراء دون إعادة استيراد مفتاح العائلة اعتبارات مهمة:\nالتسجيل العام مطلوب: لكي يتم التعرف على عائلتك على مستوى الشبكة بأكملها، يجب إضافة مفتاح العائلة الخاص بك إلى قاعدة كود I2P من قبل فريق التطوير. هذا يضمن أن جميع الموجهات (routers) على الشبكة تعرف عن عائلتك. اتصل بفريق I2P لتسجيل مفتاح عائلتك إذا كنت تدير عدة موجهات عامة معظم المستخدمين الذين يشغلون موجهاً واحداً فقط لن يحتاجوا أبداً لاستخدام هذه الميزة يتم استخدام إعدادات العائلة بشكل أساسي من قبل مشغلي الموجهات العامة المتعددة أو مزودي البنية التحتية حالات الاستخدام:\nتشغيل أجهزة توجيه I2P متعددة لتحقيق التكرار تشغيل البنية التحتية مثل خوادم reseed أو outproxies على أجهزة متعددة إدارة شبكة من أجهزة توجيه I2P لمؤسسة إعداد النظير URL: إعدادات Tunnel صفحة إعدادات Tunnel تسمح لك بضبط إعدادات tunnel الافتراضية لكل من tunnels الاستكشافية (المستخدمة لاتصال router) وtunnels العميل (المستخدمة من قبل التطبيقات). الإعدادات الافتراضية تعمل لمعظم الأشخاص ويجب تغييرها فقط إذا كنت تفهم المقايضات.\nتحذيرات هامة:\n⚠️ المقايضة بين إخفاء الهوية والأداء: هناك مقايضة أساسية بين إخفاء الهوية والأداء. قد تؤدي الأنفاق الأطول من 3 قفزات (على سبيل المثال 2 قفزة + 0-2 قفزة، 3 قفزات + 0-1 قفزة، 3 قفزات + 0-2 قفزة)، أو كمية عالية + كمية احتياطية، إلى تقليل الأداء أو الموثوقية بشكل كبير. قد ينتج عن ذلك استخدام عالٍ لوحدة المعالجة المركزية و/أو عرض النطاق الترددي الصادر. قم بتغيير هذه الإعدادات بحذر، وقم بتعديلها إذا واجهت مشاكل.\n⚠️ الاستمرارية: يتم تخزين تغييرات إعدادات tunnel الاستكشافي في ملف router.config. تغييرات tunnel العميل مؤقتة ولا يتم حفظها. لإجراء تغييرات دائمة على tunnel العميل، راجع صفحة I2PTunnel .\nأنفاق الاستكشاف:\nتُستخدم الأنفاق الاستكشافية (Exploratory tunnels) بواسطة الموجه (router) الخاص بك للتواصل مع قاعدة بيانات الشبكة (netDb) والمشاركة في شبكة I2P.\nخيارات الإعداد لكل من الوارد والصادر: - الطول - عدد القفزات في النفق (الافتراضي: 2-3 قفزات) - العشوائية - التباين العشوائي في طول النفق (الافتراضي: 0-1 قفزة) - الكمية - عدد الأنفاق النشطة (الافتراضي: نفقان) - كمية الاحتياطي - عدد الأنفاق الاحتياطية الجاهزة للتفعيل (الافتراضي: 0 نفق)\nأنفاق العميل لخادم الويب I2P:\nهذه الإعدادات تتحكم في الأنفاق (tunnels) الخاصة بخادم الويب I2P المدمج (eepsite).\n⚠️ تحذير من السرية - الإعدادات تتضمن أنفاق 1-hop. ⚠️ تحذير من الأداء - الإعدادات تتضمن كميات عالية من الأنفاق.\nخيارات التكوين لكل من الوارد والصادر: - الطول - طول النفق (الافتراضي: قفزة واحدة لخادم الويب) - العشوائية - التباين العشوائي في طول النفق - الكمية - عدد الأنفاق النشطة - كمية الاحتياطي - عدد الأنفاق الاحتياطية\nأنفاق العميل للعملاء المشتركين:\nتنطبق هذه الإعدادات على تطبيقات العميل المشتركة (وكيل HTTP، IRC، إلخ).\nخيارات التكوين لكل من الوارد والصادر: - الطول - طول النفق (الافتراضي: 3 قفزات) - العشوائية - التباين العشوائي في طول النفق - الكمية - عدد الأنفاق النشطة - كمية النسخ الاحتياطية - عدد الأنفاق الاحتياطية\nفهم معاملات الأنفاق (Tunnel Parameters):\nالطول: الأنفاق الأطول توفر إخفاء هوية أفضل لكنها تقلل من الأداء والموثوقية العشوائية: تضيف عدم قابلية التنبؤ لمسارات الأنفاق، مما يحسن الأمان الكمية: المزيد من الأنفاق يحسن الموثوقية وتوزيع الحمل لكنه يزيد من استهلاك الموارد كمية الاحتياطي: أنفاق مبنية مسبقاً جاهزة لاستبدال الأنفاق الفاشلة، مما يحسن المرونة أفضل الممارسات:\nاحتفظ بالإعدادات الافتراضية ما لم تكن لديك احتياجات محددة قم بزيادة طول tunnel فقط إذا كانت إخفاء الهوية أمراً بالغ الأهمية ويمكنك قبول أداء أبطأ قم بزيادة الكمية/النسخ الاحتياطي فقط إذا كنت تواجه فشل tunnel متكرر راقب أداء router بعد إجراء التغييرات انقر على \u0026ldquo;Save changes\u0026rdquo; لتطبيق التعديلات تكوين إعادة البذر (Reseed) عنوان URL: إعدادات واجهة المستخدم تتيح لك صفحة إعدادات واجهة المستخدم تخصيص مظهر وإمكانية الوصول إلى وحدة تحكم الـ router الخاص بك، بما في ذلك اختيار السمة وتفضيلات اللغة وحماية كلمة المرور.\nسمة لوحة التحكم في Router:\nاختر بين السمات الداكنة والفاتحة لواجهة وحدة تحكم الموجه:\nداكن - سمة الوضع الداكن (أكثر راحة للعينين في البيئات ذات الإضاءة المنخفضة) فاتح - سمة الوضع الفاتح (المظهر التقليدي) خيارات السمات الإضافية: - تعيين السمة بشكل عام عبر جميع التطبيقات - تطبيق السمة المحددة على جميع تطبيقات I2P، وليس فقط على وحدة تحكم الموجه - إجبار استخدام وحدة التحكم المحمولة - استخدام الواجهة المحسّنة للأجهزة المحمولة حتى على متصفحات سطح المكتب - تضمين تطبيقات البريد الإلكتروني والتورنت في وحدة التحكم - دمج Susimail و I2PSnark مباشرة في واجهة وحدة التحكم بدلاً من فتحها في علامات تبويب منفصلة\nلغة وحدة تحكم الراوتر (Router Console):\nاختر لغتك المفضلة لواجهة وحدة تحكم الراوتر (router console) من القائمة المنسدلة. يدعم I2P العديد من اللغات بما في ذلك الإنجليزية والألمانية والفرنسية والإسبانية والروسية والصينية واليابانية وغيرها.\nمساهمات الترجمة مرحب بها: إذا لاحظت ترجمات غير مكتملة أو غير صحيحة، يمكنك المساعدة في تحسين I2P من خلال المساهمة في مشروع الترجمة. تواصل مع المطورين في #i2p-dev على IRC أو تحقق من تقرير حالة الترجمة (المرتبط في الصفحة).\nكلمة مرور وحدة تحكم الموجه (Router Console):\nأضف مصادقة اسم المستخدم وكلمة المرور لحماية الوصول إلى وحدة تحكم الـ router الخاصة بك:\nاسم المستخدم - أدخل اسم المستخدم للوصول إلى console كلمة المرور - أدخل كلمة المرور للوصول إلى console إضافة مستخدم - إنشاء مستخدم جديد ببيانات الاعتماد المحددة حذف المحدد - إزالة حسابات المستخدمين الموجودة لماذا نضيف كلمة مرور؟\nيمنع الوصول المحلي غير المصرح به إلى وحدة تحكم الموجه (router console) الخاصة بك ضروري إذا كان عدة أشخاص يستخدمون جهاز الكمبيوتر الخاص بك موصى به إذا كانت وحدة تحكم الموجه (router console) الخاصة بك يمكن الوصول إليها على شبكتك المحلية يحمي إعدادات I2P والخصوصية الخاصة بك من العبث ملاحظة أمنية: حماية كلمة المرور تؤثر فقط على الوصول إلى واجهة الويب الخاصة بلوحة تحكم الراوتر في I2P Router Console . لا تقوم بتشفير حركة مرور I2P أو منع التطبيقات من استخدام I2P. إذا كنت المستخدم الوحيد لجهاز الكمبيوتر الخاص بك ولوحة تحكم الراوتر تستمع فقط على localhost (افتراضياً)، فقد لا تكون كلمة المرور ضرورية.\nتكوين عائلة الموجه (Router Family) الرابط: إعدادات WebApp صفحة تكوين WebApp تسمح لك بإدارة تطبيقات الويب Java التي تعمل داخل موجه I2P الخاص بك. يتم تشغيل هذه التطبيقات بواسطة عميل webConsole وتعمل في نفس JVM الخاص بالموجه، مما يوفر وظائف متكاملة يمكن الوصول إليها من خلال وحدة تحكم الموجه.\nما هي تطبيقات الويب (WebApps)؟\nWebApps هي تطبيقات قائمة على Java يمكن أن تكون: - تطبيقات كاملة (مثل I2PSnark للتورنت) - واجهات أمامية لعملاء آخرين يجب تفعيلها بشكل منفصل (مثل Susidns، I2PTunnel) - تطبيقات ويب بدون واجهة ويب (مثل دفتر العناوين)\nملاحظات هامة:\nقد يتم تعطيل تطبيق الويب بشكل كامل، أو قد يتم تعطيله فقط من التشغيل عند بدء التشغيل إزالة ملف war من دليل webapps يعطل تطبيق الويب بشكل كامل ومع ذلك، سيظهر ملف .war ودليل تطبيق الويب مرة أخرى عند تحديث الموجه الخاص بك إلى إصدار أحدث لتعطيل تطبيق ويب بشكل دائم: قم بتعطيله هنا، وهي الطريقة المفضلة تطبيقات الويب المتاحة:\nWebApp Description i2psnark Torrents - Built-in BitTorrent client for I2P i2ptunnel Hidden Services Manager - Configure client and server tunnels imagegen Identification Image Generator - Creates unique identicons jsonrpc jsonrpc.war - JSON-RPC API interface (disabled by default) routerconsole I2P Router Console - The main administrative interface susidns Address Book - Manage I2P addresses and subscriptions susimail Email - Web-based email client for I2P عناصر التحكم: لكل webapp: - التشغيل عند بدء التشغيل؟ - خانة اختيار لتمكين/تعطيل التشغيل التلقائي - التحكم - أزرار إيقاف/تشغيل للتحكم الفوري - إيقاف - يوقف webapp الذي يعمل حالياً - تشغيل - يشغل webapp متوقف\nأزرار الإعدادات:\nإلغاء - تجاهل التغييرات والعودة إلى الصفحة السابقة حفظ إعدادات WebApp - حفظ التغييرات وتطبيقها حالات الاستخدام:\nأوقف I2PSnark إذا كنت لا تستخدم التورنت لتوفير الموارد عطّل jsonrpc إذا كنت لا تحتاج إلى الوصول عبر API أوقف Susimail إذا كنت تستخدم عميل بريد إلكتروني خارجي أوقف webapps مؤقتاً لتحرير الذاكرة أو لاستكشاف المشاكل وإصلاحها نصيحة للأداء: تعطيل تطبيقات الويب غير المستخدمة يمكن أن يقلل من استهلاك الذاكرة ويحسن أداء الـ router، خاصة على الأنظمة ذات الموارد المحدودة.\nHelp URL: مساعدة صفحة المساعدة توفر توثيقًا شاملاً وموارد لمساعدتك على فهم واستخدام I2P بفعالية. تعمل كمركز رئيسي لاستكشاف الأخطاء والتعلم والحصول على الدعم.\nما ستجده:\nدليل البدء السريع - معلومات أساسية للمستخدمين الجدد للبدء باستخدام I2P الأسئلة الشائعة (FAQ) - إجابات على الأسئلة الشائعة حول تثبيت I2P وإعداده واستخدامه استكشاف الأخطاء وإصلاحها - حلول للمشاكل الشائعة ومشاكل الاتصال الوثائق التقنية - معلومات تفصيلية حول بروتوكولات I2P وبنيته ومواصفاته أدلة التطبيقات - تعليمات لاستخدام تطبيقات I2P مثل التورنت والبريد الإلكتروني والخدمات المخفية معلومات الشبكة - فهم كيفية عمل I2P وما يجعله آمناً موارد الدعم - روابط للمنتديات وقنوات IRC ودعم المجتمع الحصول على المساعدة:\nإذا كنت تواجه مشاكل مع I2P: 1. راجع الأسئلة الشائعة للحصول على الأسئلة والأجوبة الشائعة 2. راجع قسم استكشاف الأخطاء وإصلاحها للحصول على حل لمشكلتك المحددة 3. قم بزيارة منتدى I2P على i2pforum.i2p أو i2pforum.net 4. انضم إلى قناة IRC رقم #i2p للحصول على دعم المجتمع في الوقت الفعلي 5. ابحث في الوثائق للحصول على معلومات تقنية مفصلة\nنصيحة: صفحة المساعدة متاحة دائمًا من الشريط الجانبي لوحة تحكم الـ router، مما يسهل العثور على المساعدة كلما احتجت إليها.\nPerformance Graphs عنوان URL: رسوم بيانية للأداء توفر صفحة رسوم الأداء مراقبة بصرية في الوقت الفعلي لأداء router الخاص بك في I2P ونشاط الشبكة. تساعدك هذه الرسوم على فهم استخدام عرض النطاق الترددي، واتصالات النظراء، واستهلاك الذاكرة، والصحة العامة لل router.\nالرسوم البيانية المتاحة:\nاستخدام النطاق الترددي\nمعدل الإرسال على المستوى المنخفض (بايت/ثانية) - معدل حركة البيانات الصادرة معدل الاستقبال على المستوى المنخفض (بايت/ثانية) - معدل حركة البيانات الواردة يعرض الاستخدام الحالي والمتوسط والأقصى للنطاق الترددي يساعد في مراقبة ما إذا كنت تقترب من حدود النطاق الترددي المحددة النظراء النشطون\nrouter.activePeers متوسط لمدة 60 ثانية - عدد النظراء الذين تتواصل معهم بنشاط يوضح صحة اتصالك بالشبكة المزيد من النظراء النشطين يعني عمومًا بناء أنفاق أفضل ومشاركة أفضل في الشبكة استخدام ذاكرة Router\nrouter.memoryUsed متوسط لمدة 60 ثانية - استهلاك ذاكرة JVM يعرض الاستخدام الحالي والمتوسط والأقصى للذاكرة بالميغابايت مفيد لتحديد تسرب الذاكرة أو تحديد ما إذا كنت بحاجة إلى زيادة حجم Java heap تكوين عرض الرسم البياني:\nتخصيص كيفية عرض وتحديث الرسوم البيانية:\nحجم الرسم البياني - تعيين العرض (افتراضي: 400 بكسل) والارتفاع (افتراضي: 100 بكسل) فترة العرض - النطاق الزمني المراد عرضه (افتراضي: 60 دقيقة) تأخير التحديث - مدى تكرار تحديث الرسوم البيانية (افتراضي: 5 دقائق) نوع الرسم - الاختيار بين عرض المتوسطات أو الأحداث إخفاء وسيلة الإيضاح - إزالة وسيلة الإيضاح من الرسوم البيانية لتوفير المساحة UTC - استخدام توقيت UTC بدلاً من التوقيت المحلي على الرسوم البيانية الاستمرارية - تخزين بيانات الرسوم البيانية على القرص للتحليل التاريخي الخيارات المتقدمة:\nانقر على [Select Stats] لاختيار الإحصائيات التي تريد رسمها بيانياً: - مقاييس الأنفاق (معدل نجاح البناء، عدد الأنفاق، إلخ.) - إحصائيات قاعدة بيانات الشبكة - إحصائيات النقل (NTCP2، SSU2) - أداء أنفاق العميل - والعديد من المقاييس التفصيلية الأخرى\nحالات الاستخدام:\nراقب عرض النطاق الترددي للتأكد من أنك لا تتجاوز الحدود المكونة تحقق من اتصال النظراء عند استكشاف مشاكل الشبكة تتبع استخدام الذاكرة لتحسين إعدادات Java heap حدد أنماط الأداء مع مرور الوقت شخّص مشاكل بناء الأنفاق من خلال ربط الرسوم البيانية نصيحة: انقر على \u0026ldquo;حفظ الإعدادات وإعادة رسم الرسوم البيانية\u0026rdquo; بعد إجراء التغييرات لتطبيق التكوين الخاص بك. سيتم تحديث الرسوم البيانية تلقائيًا بناءً على إعداد تأخير التحديث الخاص بك.\n","description":"دليل شامل لفهم وتكوين واجهة التحكم في جهاز التوجيه I2P Router Console","id":"c46f1b6edeab9b686fd57cf9b311df1c","section":"docs","title":"دليل تكوين واجهة إدارة Router Console","url":"/ar/docs/guides/router-console-config/"},{"categories":null,"content":" النطاق: يوحّد هذا الدليل تنفيذ tunnel، وتنسيق الرسائل، ومواصفتي إنشاء tunnel (ECIES و ElGamal القديم). تواصل الروابط العميقة الحالية العمل عبر الأسماء المستعارة المذكورة أعلاه.\nنموذج Tunnel I2P يمرّر الحمولات عبر tunnels أحادية الاتجاه: مجموعات مرتّبة من routers تنقل حركة المرور في اتجاه واحد. تتطلّب الرحلة الكاملة ذهاباً وإياباً بين وجهتين أربع tunnels (اثنتان صادرتان، واثنتان واردتان).\nابدأ بقراءة Tunnel Overview للتعرّف على المصطلحات، ثم استخدم هذا الدليل للتفاصيل التشغيلية.\nدورة حياة الرسالة تقوم بوابة tunnel بتجميع رسالة I2NP واحدة أو أكثر على دفعات، وتجزئها، وتكتب تعليمات التسليم. تُغلِّف البوابة الحمولة داخل رسالة tunnel ثابتة الحجم (1024 B)، وتضيف حشواً عند الحاجة. يتحقق كل مشارك من القفزة السابقة، ويطبق طبقة التشفير الخاصة به، ويمرّر {nextTunnelId, nextIV, encryptedPayload} إلى القفزة التالية. تزيل نقطة نهاية tunnel الطبقة النهائية، وتستهلك تعليمات التسليم، وتعيد تجميع الشظايا، وترسل رسائل I2NP المُعاد بناؤها. يستخدم كشف التكرار Bloom filter (بنية بيانات احتمالية) متناقصاً مفهرساً بمفتاح ناتج عملية XOR بين IV (متجه التهيئة) وأول كتلة من النص المُعَمّى، لمنع هجمات التوسيم المبنية على تبديل IV.\nلمحة سريعة عن الأدوار Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally ### سير عمل التشفير {#encryption-workflow} Inbound tunnels: تُشفِّر البوابة مرة واحدة باستخدام مفتاح الطبقة الخاص بها؛ ويواصل المشاركون اللاحقون التشفير إلى أن يقوم المُنشئ بفك تشفير الحمولة النهائية. Outbound tunnels: تُطبِّق البوابة مسبقًا معكوس تشفير كل قفزة بحيث يقوم كل مشارك بالتشفير. وعندما تقوم نقطة النهاية بالتشفير، ينكشف النص الواضح الأصلي للبوابة. كلا الاتجاهين يمرران {tunnelId, IV, encryptedPayload} إلى القفزة التالية.\nتنسيق رسالة Tunnel بوابات Tunnel (نفق) تقسّم رسائل I2NP إلى أغلفة ثابتة الحجم لإخفاء طول الحمولة وتبسيط المعالجة عند كل قفزة.\nالبنية المشفّرة +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – معرّف 32-بت للقفزة التالية (غير صفري، يتغير في كل دورة بناء). IV (متجه التهيئة) – بطول 16 بايت لـ AES، يُختار لكل رسالة. Encrypted payload – 1008 بايت من نص مشفّر بـ AES-256-CBC. إجمالي الحجم: 1028 بايت.\nتخطيط بعد فك التشفير بعد أن تُزيل القفزة طبقة التشفير الخاصة بها:\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... المجموع الاختباري يتحقق من صحة الكتلة بعد فك التشفير. الحشو عبارة عن بايتات عشوائية غير صفرية تنتهي ببايت صفري. تعليمات التسليم تُخبر نقطة النهاية بكيفية التعامل مع كل جزء (تسليم محلي، إعادة التوجيه إلى tunnel آخر، إلخ). الأجزاء تحمل رسائل I2NP الأساسية؛ تقوم نقطة النهاية بإعادة تجميعها قبل تمريرها إلى الطبقات العليا. خطوات المعالجة تقوم البوابات بتجزئة رسائل I2NP ووضعها في قائمة انتظار، مع الاحتفاظ بالقطع الجزئية لفترة وجيزة لإعادة تجميعها. تقوم البوابة بتشفير الحمولة باستخدام مفاتيح الطبقة المناسبة وتُدرج معرّف الـ tunnel بالإضافة إلى متجه التهيئة (IV). يقوم كل مشارك بتشفير متجه التهيئة (AES-256/ECB) ثم الحمولة (AES-256/CBC) قبل إعادة تشفير متجه التهيئة وتمرير الرسالة. يفك الطرف النهائي التشفير بترتيب عكسي، ويتحقق من المجموع الاختباري، وينفّذ تعليمات التسليم، ويعيد تجميع الأجزاء. إنشاء Tunnel (ECIES-X25519) تبني routers الحديثة tunnels باستخدام مفاتيح ECIES-X25519، ما يقلّص رسائل البناء ويتيح السرية المستقبلية.\nرسالة البناء: تحمل رسالة I2NP واحدة من نوع TunnelBuild (أو VariableTunnelBuild) ما بين 1–8 سجلات بناء مشفّرة، سجل واحد لكل قفزة. مفاتيح الطبقة: يستمدّ المنشئون مفاتيح الطبقة لكل قفزة، وIV، ومفاتيح الرد عبر HKDF باستخدام هوية X25519 الثابتة لتلك القفزة ومفتاح المنشئ المؤقت. المعالجة: تفك كل قفزة تشفير سجلها، وتتحقق من أعلام الطلب، وتكتب كتلة الرد (نجاح أو رمز فشل مفصّل)، وتعيد تشفير السجلات المتبقية، ثم تمرّر الرسالة. الردود: يتلقى المنشئ رسالة رد مغلّفة بطريقة garlic (garlic encryption). السجلات الموسومة كفاشلة تتضمن رمز مستوى الخطورة بحيث يمكن للـrouter إنشاء ملف تعريفي للند. التوافق: قد تظل routers تقبل أبنية ElGamal القديمة للتوافق مع الإصدارات السابقة، لكن tunnels الجديدة تستخدم ECIES افتراضيًا. للاطلاع على ملاحظات حول الثوابت لكل حقل واشتقاق المفاتيح، راجع تاريخ مقترح ECIES وشفرة مصدر router؛ يغطي هذا الدليل التدفق التشغيلي.\nإنشاء Tunnel الموروث (ElGamal-2048) كان تنسيق إنشاء tunnel الأصلي يستخدم مفاتيح ElGamal العامة. تحافظ routers الحديثة على دعم محدود لأغراض التوافق مع الإصدارات السابقة.\nالحالة: متقادم. مُحتفَظ به هنا كمرجع تاريخي ولأي شخص يقوم بصيانة أدوات متوافقة مع الإصدارات القديمة.\nبناء تلسكوبي غير تفاعلي: تمر رسالة بناء واحدة عبر المسار بأكمله. تفك كل قفزة تشفير سجلها بحجم 528 بايت، تحدّث الرسالة، ثم تعيد توجيهها. طول متغيّر: سمحت رسالة بناء Tunnel المتغيرة (VTBM) بوجود 1–8 سجلات. أما الرسالة الثابتة الأقدم فكانت تحتوي دائماً على ثمانية سجلات لإخفاء طول tunnel. بنية سجل الطلب: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding الأعلام: تشير البت 7 إلى بوابة واردة (IBGW)؛ وتُميِّز البت 6 نقطةً نهائيةً صادرة (OBEP). وهما متنافيتان. التشفير: يُشفَّر كل سجل بـ ElGamal-2048 باستخدام المفتاح العام للقفزة. تضمن طبقات التشفير المتماثل AES-256-CBC أن القفزة المقصودة فقط تستطيع قراءة سجلها. حقائق أساسية: معرّفات tunnel هي قيم 32-بت غير صفرية؛ وقد يُدرج المنشئون سجلات وهمية لإخفاء طول tunnel الفعلي؛ وتعتمد الموثوقية على إعادة محاولة عمليات البناء الفاشلة. تجمّعات Tunnel ودورة الحياة تُحافظ Routers (موجّهات شبكة I2P) على مجمّعات مستقلة لـ tunnel (نفق اتصال في I2P) الواردة والصادرة للمرور الاستكشافي ولكل جلسة I2CP (بروتوكول عميل I2P).\nاختيار النظائر: تستخدم tunnels الاستكشافية حاوية النظائر “النشطة، غير المتعطلة” لتعزيز التنوع; بينما تفضّل tunnels الخاصة بالعميل النظائر السريعة وعالية السعة. الترتيب الحتمي: تُرتَّب النظائر بحسب مسافة XOR بين SHA256(peerHash || poolKey) ومفتاح المجموعة العشوائي. يتبدّل المفتاح عند إعادة التشغيل، ما يمنح استقرارًا ضمن التشغيل الواحد ويُربك predecessor attacks (هجمات تحديد العقد السابقة في المسار) عبر تشغيلات متعددة. دورة الحياة: تقوم routers بتتبّع أزمنة البناء التاريخية لكل رباعية {mode, direction, length, variance}. ومع اقتراب انتهاء صلاحية tunnels، يبدأ الاستبدال مبكرًا; كما يزيد router من عمليات البناء المتوازية عند حدوث إخفاقات، مع وضع حد أقصى للمحاولات القائمة. خيارات الضبط: أعداد tunnels النشطة/الاحتياطية، طول القفزات والتباين، السماح بلا قفزات، وحدود معدل البناء; جميعها قابلة للضبط لكل مجموعة. الازدحام والموثوقية على الرغم من أن tunnels تشبه الدارات، فإن routers تتعامل معها كطوابير رسائل. يُستخدم الإسقاط المبكر العشوائي الموزون (WRED) للإبقاء على الكمون ضمن حدود محددة:\nترتفع احتمالية الإسقاط مع اقتراب مستوى الاستخدام من الحدود المُكوَّنة. يأخذ المشاركون في الاعتبار أجزاء ثابتة الحجم؛ تقوم البوابات/نقاط النهاية بالإسقاط استناداً إلى الحجم المُجمَّع للأجزاء، مع ترجيح إسقاط الحمولات الكبيرة أولاً. تقوم نقاط النهاية الصادرة بالإسقاط قبل الأدوار الأخرى لتقليل إهدار جهد الشبكة إلى أدنى حد. يُترك التسليم المضمون للطبقات العليا مثل Streaming library . يجب على التطبيقات التي تتطلب الموثوقية أن تتولى بنفسها إعادة الإرسال وإقرارات الاستلام.\nقراءات إضافية اختيار الأقران نظرة عامة على Tunnel التنفيذ القديم لـ Tunnel ","description":"مواصفة موحّدة لبناء وتشفير ونقل حركة المرور عبر I2P tunnels.","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"دليل عمليات Tunnel","url":"/ar/docs/specs/implementation/"},{"categories":null,"content":"دمج I2P مع تطبيقك هو طريقة قوية لإضافة المستخدمين—ولكن فقط إذا تم تكوين الـ router بشكل مسؤول.\n1. التنسيق مع فرق الموجه (Router) اتصل بمسؤولي صيانة Java I2P وi2pd قبل التضمين. يمكنهم مراجعة إعداداتك الافتراضية وتسليط الضوء على مخاوف التوافق. اختر تطبيق router الذي يناسب مجموعتك التقنية: Java/Scala → Java I2P C/C++ → i2pd لغات أخرى → قم بتضمين router والتكامل باستخدام SAM v3 أو I2CP تحقق من شروط إعادة التوزيع للملفات التنفيذية لـ router والتبعيات (Java runtime، ICU، إلخ). 2. الإعدادات الافتراضية الموصى بها اهدف إلى \u0026ldquo;المساهمة أكثر مما تستهلك\u0026rdquo;. الإعدادات الافتراضية الحديثة تعطي الأولوية لصحة الشبكة واستقرارها.\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. ### الأنفاق المشاركة تبقى أساسية لا تقم بتعطيل الأنفاق المشاركة (participating tunnels).\nأجهزة Router التي لا تقوم بالترحيل تعمل بشكل أسوأ بنفسها. تعتمد الشبكة على المشاركة الطوعية للسعة. حركة المرور التغطية (حركة المرور المُرحّلة) تحسن إخفاء الهوية. الحد الأدنى الرسمي: - عرض النطاق المشترك: ≥ 12 كيلوبايت/ثانية - الانضمام التلقائي لـ Floodfill: ≥ 128 كيلوبايت/ثانية - الموصى به: 2 tunnel وارد / 2 tunnel صادر (الإعداد الافتراضي لـ Java I2P)\n3. الاستمرارية وإعادة البذر يجب الحفاظ على أدلة الحالة الدائمة (netDb/، profiles، certificates) بين عمليات التشغيل.\nبدون الاستمرارية، سيقوم المستخدمون بتشغيل عمليات إعادة البذر عند كل بدء تشغيل—مما يؤدي إلى تدهور الأداء وزيادة الحمل على خوادم إعادة البذر.\nإذا كانت الاستمرارية غير ممكنة (مثل الحاويات أو التثبيتات المؤقتة):\nقم بتضمين 1,000–2,000 router infos في برنامج التثبيت. قم بتشغيل واحد أو أكثر من خوادم reseed مخصصة لتخفيف الحمل عن الخوادم العامة. متغيرات التكوين: - الدليل الأساسي: i2p.dir.base - دليل التكوين: i2p.dir.config - يتضمن certificates/ لإعادة البذر.\n4. الأمان والتعرض للخطر احتفظ بوحدة تحكم router (127.0.0.1:7657) محلية فقط. استخدم HTTPS في حالة عرض واجهة المستخدم خارجيًا. عطّل SAM/I2CP الخارجي ما لم يكن مطلوبًا. راجع الإضافات المُضمّنة—قم بتضمين ما يدعمه تطبيقك فقط. قم دائمًا بتضمين المصادقة للوصول عن بُعد إلى وحدة التحكم. ميزات الأمان المقدمة منذ الإصدار 2.5.0: - عزل NetDB بين التطبيقات (2.4.0+) - التخفيف من هجمات حجب الخدمة وقوائم حظر Tor (2.5.1) - مقاومة فحص NTCP2 (2.9.0) - تحسينات اختيار router من نوع Floodfill (2.6.0+)\n5. واجهات برمجة التطبيقات المدعومة (2025) API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. جميع المستندات الرسمية موجودة تحت `/docs/api/` — المسار القديم `/spec/samv3/` **غير موجود**. 6. الشبكات والمنافذ المنافذ الافتراضية النموذجية: - 4444 – بروكسي HTTP - 4445 – بروكسي HTTPS - 7654 – I2CP - 7656 – جسر SAM Bridge - 7657 – لوحة تحكم Router Console - 7658 – موقع I2P محلي - 6668 – بروكسي IRC - 9000–31000 – منفذ router عشوائي (UDP/TCP وارد)\nتختار أجهزة التوجيه منفذًا عشوائيًا للاتصالات الواردة عند التشغيل الأول. يؤدي إعادة التوجيه إلى تحسين الأداء، ولكن قد يتعامل UPnP مع ذلك تلقائيًا.\n7. التغييرات الحديثة (2024–2025) Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). ## 8. تجربة المستخدم والاختبار توضيح ما يقوم به I2P ولماذا يتم مشاركة النطاق الترددي. توفير تشخيصات الموجه (النطاق الترددي، الأنفاق، حالة إعادة البذر). اختبار الحزم على Windows وmacOS وLinux (بما في ذلك الأجهزة ذات الذاكرة المنخفضة). التحقق من التوافق مع كل من أقران Java I2P وi2pd. اختبار الاستعادة من انقطاع الشبكة والخروج غير السليم. 9. موارد المجتمع المنتدى: i2pforum.net أو http://i2pforum.i2p داخل I2P. الكود: i2pgit.org/I2P_Developers/i2p.i2p . IRC (شبكة Irc2P): #i2p-dev، #i2pd. #i2papps غير موثق؛ قد لا يكون موجوداً. وضح أي شبكة (Irc2P مقابل ilita.i2p) تستضيف قناتك. التضمين المسؤول يعني الموازنة بين تجربة المستخدم، الأداء، والمساهمة في الشبكة. استخدم هذه الإعدادات الافتراضية، ابقَ متزامناً مع مشرفي الـ router، واختبر تحت حمل واقعي قبل الإصدار.\n","description":"إرشادات عملية محدّثة لتضمين router الخاص بـ I2P مع تطبيقك بشكل مسؤول","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"دمج I2P في تطبيقك","url":"/ar/docs/applications/embedding/"},{"categories":null,"content":" 1. نظرة عامة تُشير آلية النقل في I2P إلى طريقة للاتصال المباشر من نقطة إلى نقطة بين routers. تضمن هذه الآليات السرّية وسلامة البيانات مع التحقق من مصادقة router.\nيعمل كل بروتوكول نقل باستخدام أنماط اتصال تتضمن المصادقة، والتحكم في التدفق، والإقرارات، وقدرات إعادة الإرسال.\n2. بروتوكولات النقل الحالية يدعم I2P حالياً بروتوكولي نقل أساسيين:\nTransport Protocol Description NTCP2 TCP Noise-based TCP transport with modern encryption (as of 0.9.36) SSU2 UDP Secure Semireliable UDP with modern encryption (as of 0.9.56) ### 2.1 بروتوكولات النقل القديمة (مهملة) Transport Protocol Status NTCP TCP Replaced by NTCP2; removed in 0.9.62 SSU UDP Replaced by SSU2; removed in 0.9.62 --- 3. خدمات النقل يوفر النظام الفرعي للنقل الخدمات التالية:\n3.1 تسليم الرسائل تسليم موثوق لرسائل I2NP (تتولى وسائط النقل التعامل مع مراسلة I2NP حصريًا) التسليم بالترتيب غير مضمون على نحوٍ شامل اصطفاف الرسائل القائم على الأولوية 3.2 إدارة الاتصالات إنشاء الاتصالات وإغلاقها إدارة حدود الاتصالات مع فرض العتبات تتبّع حالة كل نظير فرض قائمة حظر النظراء بشكل آلي ويدوي 3.3 تهيئة الشبكة عناوين router متعددة لكل طبقة نقل (دعم IPv4 وIPv6 منذ الإصدار v0.9.8) فتح منافذ جدار الحماية عبر UPnP دعم اجتياز NAT (ترجمة عناوين الشبكة)/جدار الحماية اكتشاف عنوان IP المحلي عبر أساليب متعددة 3.4 الأمان تشفير لاتصالات نقطة-إلى-نقطة التحقق من صحة عناوين IP وفقًا للقواعد المحلية تحديد توافق الساعة (حل احتياطي عبر NTP) 3.5 إدارة عرض النطاق الترددي حدود عرض النطاق الترددي الوارد والصادر اختيار وسيلة النقل المثلى للرسائل الصادرة 4. عناوين النقل يحافظ النظام الفرعي على قائمة بنقاط اتصال router:\nطريقة النقل (NTCP2, SSU2) عنوان IP رقم المنفذ معلمات اختيارية يمكن أن تكون هناك عناوين متعددة لكل طريقة نقل.\n4.1 تكوينات العناوين الشائعة Configuration Description Hidden Routers with no published addresses Firewalled Routers publishing SSU2 addresses with \"introducer\" peer lists for NAT traversal Unrestricted Routers advertising both NTCP2 and SSU2 addresses on IPv4 and/or IPv6 --- 5. اختيار النقل يختار النظام transports (بروتوكولات النقل) لـرسائل I2NP بشكل مستقل عن بروتوكولات الطبقات العليا. تستخدم عملية الاختيار نظام مزايدة يقدّم فيه كل transport عروضًا، حيث يفوز العرض ذو القيمة الأدنى.\n5.1 عوامل تحديد قيمة العرض إعدادات تفضيلات النقل اتصالات النظراء القائمة أعداد الاتصالات الحالية مقابل قيم العتبة سجل محاولات الاتصال الأخيرة قيود حجم الرسائل قدرات النقل في RouterInfo الخاصة بالنظير مباشرة الاتصال (مباشر مقابل المعتمد على introducer، نظير وسيط للتعريف بالاتصال) تفضيلات النقل المعلن عنها من قِبل النظير عمومًا، يحافظ جهازان من نوع router على اتصالات أحادية النقل بالتزامن، رغم أن اتصالات متعددة النقل المتزامنة ممكنة.\n6. NTCP2 NTCP2 (بروتوكول النقل الجديد 2) هو وسيلة النقل الحديثة المعتمدة على TCP لـ I2P، طُرحت في الإصدار 0.9.36.\n6.1 الميزات الرئيسية مبني على Noise Protocol Framework (إطار بروتوكول للتفاوض على المفاتيح، نمط Noise_XK) يستخدم X25519 لتبادل المفاتيح يستخدم ChaCha20/Poly1305 للتشفير المصادَق يستخدم BLAKE2s للتجزئة إخفاء البروتوكول لمقاومة DPI (فحص الحزم العميق) حشو اختياري لمقاومة تحليل المرور 6.2 إنشاء الاتصال طلب الجلسة (Alice → Bob): مفتاح X25519 مؤقت + حمولة مشفرة تم إنشاء الجلسة (Bob → Alice): مفتاح مؤقت + تأكيد مشفر تأكيد الجلسة (Alice → Bob): مصافحة نهائية مع RouterInfo تُشفَّر كل البيانات اللاحقة باستخدام مفاتيح جلسة مستمدة من المصافحة.\nراجع مواصفة NTCP2 للتفاصيل الكاملة.\n7. SSU2 SSU2 (Secure Semireliable UDP 2) هو بروتوكول نقل حديث قائم على UDP لـ I2P، تم تقديمه في الإصدار 0.9.56.\n7.1 الميزات الرئيسية يعتمد على Noise Protocol Framework (نمط Noise_XK) يستخدم X25519 لتبادل المفاتيح يستخدم ChaCha20/Poly1305 للتشفير المُصادَّق تسليم شبه موثوق مع إقرارات استلام انتقائية اجتياز NAT عبر hole punching (تقنية فتح ثغرة اتصال عبر NAT) و relay/introduction (الترحيل/التعريف) دعم ترحيل الاتصال اكتشاف MTU للمسار 7.2 مزايا مقارنةً بـ SSU (قديم) Feature SSU (Legacy) SSU2 Encryption ElGamal + AES X25519 + ChaCha20/Poly1305 Header encryption Partial Full (ChaCha20) Connection ID Fixed Encrypted, rotatable NAT traversal Basic introduction Enhanced hole punching + relay Obfuscation Minimal Improved (variable padding) انظر [مواصفة SSU2](/docs/specs/ssu2/) (بروتوكول النقل عبر UDP في I2P من الجيل الثاني) للاطلاع على التفاصيل الكاملة. 8. اجتياز NAT كلتا وسيلتي النقل تدعمان اجتياز NAT للسماح لـ routers الموجودة خلف جدار ناري بالمشاركة في الشبكة.\n8.1 مقدمة عن SSU2 عندما يتعذر على router استقبال الاتصالات الواردة مباشرةً:\nينشر router عناوين introducer (وسيط التعريف) في RouterInfo (معلومات router) يرسل النظير المتصل طلب تعارف إلى introducer يقوم introducer بتمرير معلومات الاتصال إلى router خلف جدار ناري يبدأ router خلف جدار ناري اتصالاً صادراً (hole punch، فتح ثغرة عبر NAT) يتم تأسيس اتصال مباشر 8.2 NTCP2 وجدران الحماية يتطلب NTCP2 إمكانية استقبال اتصالات TCP الواردة. يمكن لـ Routers خلف NAT أن:\nاستخدم UPnP لفتح المنافذ تلقائياً قم بتهيئة إعادة توجيه المنافذ يدوياً اعتمد على SSU2 للاتصالات الواردة مع استخدام NTCP2 للاتصالات الصادرة 9. تمويه البروتوكول كلتا وسيلتي النقل الحديثتين تتضمنان ميزات تمويه:\nحشو عشوائي في رسائل المصافحة رؤوس مشفّرة لا تكشف بصمات البروتوكول رسائل بطول متغير لمقاومة تحليل حركة المرور لا أنماط ثابتة في إنشاء الاتصال ملاحظة: التمويه على مستوى طبقة النقل يُكمل، لكنه لا يحل محل إخفاء الهوية الذي توفره بنية tunnel في I2P.\n10. التطوير المستقبلي تشمل الأبحاث والتحسينات المخططة ما يلي:\nوسائط نقل قابلة للإضافة – ملحقات تمويه متوافقة مع Tor نقل قائم على QUIC – استكشاف فوائد بروتوكول QUIC تحسين حدود الاتصالات – بحث في الحدود المثلى لاتصالات الأقران استراتيجيات حشو معززة – مقاومة محسّنة لتحليل حركة المرور 11. المراجع مواصفة NTCP2 – نقل TCP قائم على Noise (إطار عمل لتصميم بروتوكولات التشفير) مواصفة SSU2 – UDP شبه موثوق وآمن 2 مواصفة I2NP – رسائل بروتوكول شبكة I2P الهياكل الشائعة – RouterInfo وهياكل العناوين مناقشة NTCP التاريخية – تاريخ تطوير النقل القديم توثيق SSU القديم – المواصفة الأصلية لـ SSU (مهملة) ","description":"فهم طبقة النقل الخاصة بـ I2P - أساليب الاتصال من نقطة إلى نقطة بين routers بما في ذلك NTCP2 وSSU2","id":"5fbac972dc212081634c49c5e6ac0004","section":"docs","title":"طبقة النقل","url":"/ar/docs/overview/transport/"},{"categories":null,"content":"التطبيق الرئيسي لعميل I2P يستخدم Java. إذا كنت لا تستطيع أو تفضل عدم استخدام Java على نظام معين، فهناك تطبيقات بديلة لعميل I2P تم تطويرها وصيانتها من قبل أعضاء المجتمع. توفر هذه البرامج نفس الوظائف الأساسية باستخدام لغات برمجة أو أساليب مختلفة.\nجدول المقارنة Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements --- i2pd (C++) الموقع الإلكتروني: https://i2pd.website الوصف: i2pd (أو I2P Daemon) هو عميل I2P كامل الميزات مُطبّق بلغة C++. وهو مستقر للاستخدام الإنتاجي منذ سنوات عديدة (منذ حوالي 2016 تقريباً) ويتم صيانته بنشاط من قبل المجتمع. يُطبّق i2pd بشكل كامل بروتوكولات وواجهات برمجة التطبيقات الخاصة بشبكة I2P، مما يجعله متوافقاً تماماً مع شبكة I2P المبنية على Java. غالباً ما يُستخدم هذا router المكتوب بلغة C++ كبديل خفيف على الأنظمة التي لا تتوفر فيها بيئة تشغيل Java أو غير مرغوب فيها. يتضمن i2pd وحدة تحكم مدمجة قائمة على الويب للتكوين والمراقبة. وهو متعدد المنصات ومتاح بصيغ تغليف متعددة — بل يوجد أيضاً إصدار Android من i2pd متاح (على سبيل المثال، عبر F-Droid).\nGo-I2P (Go) المستودع: https://github.com/go-i2p/go-i2p الوصف: Go-I2P هو عميل I2P مكتوب بلغة البرمجة Go. وهو تطبيق مستقل لجهاز router الخاص بـ I2P، يهدف إلى الاستفادة من كفاءة وقابلية نقل Go. المشروع قيد التطوير النشط، لكنه لا يزال في مرحلة مبكرة وليس مكتمل الميزات بعد. اعتبارًا من عام 2025، يُعتبر Go-I2P تجريبيًا — حيث يعمل عليه مطورو المجتمع بنشاط، لكن لا يُنصح باستخدامه في بيئات الإنتاج حتى ينضج أكثر. الهدف من Go-I2P هو توفير router حديث وخفيف الوزن لـ I2P مع توافق كامل مع شبكة I2P بمجرد اكتمال التطوير.\nI2P+ (نسخة Java) الموقع الإلكتروني: https://i2pplus.github.io الوصف: I2P+ هو نسخة مطورة مجتمعياً من عميل Java I2P القياسي. إنه ليس إعادة تطبيق بلغة جديدة، بل هو نسخة محسّنة من router جافا مع ميزات وتحسينات إضافية. يركز I2P+ على تقديم تجربة مستخدم محسّنة وأداء أفضل مع الحفاظ على التوافق الكامل مع شبكة I2P الرسمية. يقدم واجهة web console محدّثة، وخيارات إعداد أكثر سهولة في الاستخدام، وتحسينات متنوعة (على سبيل المثال، أداء torrent محسّن ومعالجة أفضل لنظراء الشبكة، خاصة لأجهزة router خلف الجدران النارية). يتطلب I2P+ بيئة Java تماماً مثل برنامج I2P الرسمي، لذا فهو ليس حلاً للبيئات غير المعتمدة على Java. ومع ذلك، بالنسبة للمستخدمين الذين لديهم Java ويريدون نسخة بديلة بقدرات إضافية، يوفر I2P+ خياراً جذاباً. يتم تحديث هذه النسخة المطورة باستمرار مع إصدارات I2P الأساسية (مع إضافة \u0026ldquo;+\u0026rdquo; إلى ترقيم الإصدار) ويمكن الحصول عليها من موقع المشروع.\n","description":"تطبيقات عميل I2P التي يحافظ عليها المجتمع (محدثة لعام 2025)","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"عملاء I2P البديلون","url":"/ar/docs/overview/alternative-clients/"},{"categories":null,"content":" 1. نظرة عامة تُعدّ netDb قاعدة بيانات موزعة متخصصة تحتوي على نوعين فقط من البيانات: - RouterInfos – معلومات الاتصال الخاصة بالـ router - LeaseSets – معلومات الاتصال الخاصة بالوجهة\nجميع البيانات مُوقَّعة تشفيرياً وقابلة للتحقق. يتضمّن كل مُدخل معلومات الحيَوية (liveness) لتمكين إسقاط المُدخلات البالية واستبدال المتقادمة، ما يوفّر حماية ضد فئات معيّنة من الهجمات.\nتستخدم عملية التوزيع آلية floodfill (آلية الغمر)، حيث تتولى مجموعة فرعية من routers صيانة قاعدة البيانات الموزعة.\n2. RouterInfo عندما تحتاج routers إلى الاتصال بـ routers أخرى، فإنها تتبادل حِزَم RouterInfo التي تحتوي على:\nهوية router – مفتاح التشفير، مفتاح التوقيع، الشهادة عناوين الاتصال – كيفية الوصول إلى router الطابع الزمني للنشر – متى نُشرت هذه المعلومات خيارات نصية اعتباطية – أعلام القدرات والإعدادات توقيع تشفيري – يثبت الأصالة 2.1 أعلام القدرات Routers تعلن عن قدراتها عبر رموز حرفية في RouterInfo الخاص بها:\nFlag Meaning f Floodfill participation R Reachable U Unreachable D, E, G, H Various capability indicators ### 2.2 تصنيفات عرض النطاق الترددي Code Bandwidth K Under 12 KBps L 12–48 KBps (default) M 48–64 KBps N 64–128 KBps O 128–256 KBps P 256–2000 KBps X Over 2000 KBps ### 2.3 قيم معرّف الشبكة Value Purpose 0 Reserved 1 Current Network (default) 2 Reserved for Future Networks 3–15 Forks and Test Networks 16–254 Reserved 255 Reserved ### 2.4 إحصائيات RouterInfo Routers تنشر إحصاءات صحية اختيارية لتحليل الشبكة: - معدلات النجاح/الرفض/انتهاء المهلة في إنشاء tunnel استكشافية - متوسط عدد tunnel المشاركة خلال ساعة واحدة\nتتبع الإحصاءات الصيغة stat_(statname).(statperiod) مع قيم مفصولة بفواصل منقوطة.\nإحصائيات المثال:\nstat_tunnel.buildExploratoryExpire.60m = 0;0;0;53.14 stat_tunnel.buildExploratoryReject.60m = 0;0;0;15.51 stat_tunnel.buildExploratorySuccess.60m = 0;0;0;31.35 stat_tunnel.participatingTunnels.60m = 289.20 قد تنشر Floodfill routers (عُقد floodfill في الشبكة) أيضًا: netdb.knownLeaseSets و netdb.knownRouters\n2.5 خيارات العائلة اعتبارًا من الإصدار 0.9.24، يمكن لـ routers الإعلان عن family membership (نفس المشغل):\nfamily: اسم العائلة family.key: رمز نوع التوقيع مقترنًا بمفتاح التوقيع العمومي المُرمَّز بترميز base64 family.sig: توقيع لاسم العائلة وتجزئة router بطول 32 بايت لن يُستَخدَم أكثر من router واحد من العائلة نفسها ضمن أي tunnel واحد.\n2.6 انتهاء صلاحية RouterInfo (معلومات router في I2P) لا يوجد انتهاء صلاحية خلال الساعة الأولى من مدة التشغيل لا يوجد انتهاء صلاحية عند وجود 25 أو أقل من RouterInfos المخزنة تتناقص مدة الانتهاء مع زيادة العدد المحلي (72 ساعة عند \u0026lt;120 routers; ~30 ساعة عند 300 routers) تنقضي صلاحية المعرِّفين في SSU خلال ~1 ساعة تستخدم Floodfills مدة انتهاء قدرها ساعة واحدة لجميع RouterInfos المحلية 3. LeaseSet LeaseSets توثق نقاط دخول tunnel لوجهات معينة، محددة:\nهوية router عند بوابة tunnel معرّف tunnel مكوّن من 4 بايت وقت انتهاء صلاحية tunnel تتضمن LeaseSets: - الوجهة – مفتاح التشفير، مفتاح التوقيع، شهادة - مفتاح عام إضافي للتشفير – من أجل garlic encryption من الطرف إلى الطرف - مفتاح عام إضافي للتوقيع – مخصص للإبطال (غير مستخدم حالياً) - توقيع تشفيري\n3.1 أنواع LeaseSet Type Description Unpublished Destinations used only for outgoing connections aren't published to floodfill routers Revoked Published with zero leases, signed by additional signing key (not fully implemented) LeaseSet2 (LS2) As of 0.9.38, supports new encryption types, multiple encryption types, options, offline signing keys ([Proposal 123](/proposals/123-new-netdb-entries/)) Meta LeaseSet Tree-like DHT structure for multihomed services, supporting hundreds/thousands of destinations with long expirations (up to 18.2 hours) Encrypted LeaseSet (LS1) All leases encrypted with separate key; only those with the key can decode and contact the destination Encrypted LeaseSet (LS2) As of 0.9.38, destination hidden with only blinded public key and expiration visible to floodfill ### 3.2 انتهاء صلاحية LeaseSet تنتهي صلاحية LeaseSets العادية عند أحدث تاريخ لانتهاء lease (مدة اتصال) فيها. يُحدَّد تاريخ انتهاء LeaseSet2 في الترويسة. قد تختلف تواريخ انتهاء EncryptedLeaseSet و MetaLeaseSet مع احتمال تطبيق حد أقصى.\n4. التمهيد الأولي تتطلّب netDb اللامركزية وجود مرجع واحد على الأقل لنظير للاندماج. Reseeding تسترجع ملفات RouterInfo (routerInfo-$hash.dat) من مجلّدات netDb لدى المتطوعين. عند التشغيل الأول يتم الجلب تلقائيًا من عناوين URLs ثابتة مُضمّنة صراحةً، تُختار عشوائيًا.\n5. آلية Floodfill تستخدم floodfill netDb (قاعدة بيانات الشبكة بأسلوب floodfill) تخزيناً موزعاً بسيطاً: تُرسَل البيانات إلى أقرب نظير floodfill. عندما يرسل النظراء غير floodfill رسائل التخزين، يعيد نظراء floodfill توجيهها إلى مجموعة فرعية من نظراء floodfill الأقرب إلى المفتاح المحدد.\nيُشار إلى المشاركة في floodfill (عُقد لتخزين netDb الموزَّعة في I2P) من خلال علم قدرة (f) في RouterInfo.\n5.1 متطلبات الانضمام الاختياري لـ Floodfill على خلاف خوادم الدليل الموثوقة المثبتة في الشيفرة (hardcoded) لدى Tor، فإن مجموعة floodfill الخاصة بـ I2P هي غير موثوقة وتتغيّر مع مرور الوقت.\nيتم تمكين Floodfill تلقائيًا فقط على routers ذات النطاق الترددي العالي التي تستوفي هذه المتطلبات: - حد أدنى 128 KBytes/sec من النطاق الترددي المُشترك (يتم تكوينه يدويًا) - يجب أن تجتاز اختبارات صحة إضافية (زمن قائمة انتظار الرسائل الصادرة، تأخر المهام)\nيؤدي الاشتراك التلقائي الحالي إلى نحو 6% من المشاركة في floodfill على مستوى الشبكة.\nتوجد floodfills (عُقد خاصة في شبكة I2P لتخزين وتوزيع netDb) المُهيأة يدويًا جنبًا إلى جنب مع المتطوعين تلقائيًا. عندما ينخفض عدد الـ floodfills عن العتبة، تتطوع routers (برامج I2P التي توجّه الحركة) عالية عرض النطاق تلقائيًا. وعندما يكون هناك عدد كبير جدًا من الـ floodfills، فإنها تُلغي عن نفسها وضع الـ floodfill.\n5.2 أدوار Floodfill (عُقد مسؤولة عن نشر وفهرسة بيانات الشبكة) إلى جانب قبول عمليات تخزين netDb (قاعدة بيانات الشبكة في I2P) والاستجابة للاستعلامات، تؤدي floodfills (عُقد floodfill في I2P لنشر netDb) وظائف router (الموجّه في I2P) القياسية. إن عرض النطاق الأعلى لديها يعني عادةً مشاركةً أكبر في tunnel (نفق I2P)، لكن ذلك لا يرتبط مباشرةً بخدمات قاعدة البيانات.\n6. مقياس التقارب في Kademlia (بروتوكول جدول تجزئة موزع DHT) يستخدم netDb قياس المسافة بأسلوب Kademlia المعتمد على XOR. تُنشئ تجزئة SHA256 لـ RouterIdentity أو Destination مفتاح Kademlia (باستثناء LS2 Encrypted LeaseSets، التي تستخدم SHA256 لبايت النوع رقم 3 بالإضافة إلى blinded public key (مفتاح عام مُعمّى بالتعمية العمياء)).\n6.1 تدوير فضاء المفاتيح لزيادة تكلفة هجمات سيبيل، بدلاً من استخدام SHA256(key)، يستخدم النظام:\nSHA256(key + yyyyMMdd) حيث يكون التاريخ عبارة عن تاريخ UTC بصيغة ASCII بطول 8 بايت. هذا يُنشئ routing key (مفتاح التوجيه)، ويتغيّر يوميًا عند منتصف الليل بتوقيت UTC—ويُسمّى ذلك keyspace rotation (تدوير فضاء المفاتيح).\nلا تُنقَل مفاتيح التوجيه أبدًا في رسائل I2NP؛ فهي تُستخدم فقط لتحديد المسافة محليًا.\n7. تقسيم قاعدة بيانات الشبكة لا تحافظ Kademlia DHTs (جداول التجزئة الموزعة من نوع كادملِيا) التقليدية على خاصية عدم قابلية ربط المعلومات المخزنة. تمنع I2P الهجمات التي تربط tunnels الخاصة بالعميل بـ routers من خلال تنفيذ التقسيم.\n7.1 استراتيجية التجزئة Routers تتتبّع: - ما إذا كانت المدخلات قد وصلت عبر client tunnels أم مباشرة - إذا كان عبر tunnel، فأي client tunnel/وجهة - تتم متابعة حالات وصول متعددة عبر tunnel - يُميَّز بين ردود التخزين وردود الاستعلام\nكلٌ من تنفيذَي Java و C++ يستخدمان: - قاعدة \u0026ldquo;Main\u0026rdquo; netDb لعمليات الاستعلام/floodfill المباشرة في سياق router - \u0026ldquo;Client Network Databases\u0026rdquo; أو \u0026ldquo;Sub-Databases\u0026rdquo; في سياقات العميل، تلتقط الإدخالات المرسلة إلى client tunnels\nتوجد netDbs الخاصة بالعميل طوال مدة حياة العميل فقط، وتحتوي فقط على إدخالات tunnel الخاصة بالعميل. لا يمكن أن تتداخل الإدخالات الواردة من client tunnels مع عمليات الوصول المباشرة.\nيتعقّب كل netDb ما إذا كانت المدخلات قد وصلت على أنها عمليات تخزين (تستجيب لطلبات الاستعلام) أو على أنها ردود استعلام (لا تستجيب إلا إذا كانت قد خُزِّنت مسبقًا للوجهة نفسها). لا يجيب العملاء مطلقًا عن الاستعلامات باستخدام مدخلات netDb الرئيسية، بل فقط باستخدام مدخلات قاعدة بيانات الشبكة الخاصة بالعميل.\nالاستراتيجيات المجمعة تجزئ netDb ضد هجمات ربط العميل بالـ router.\n8. التخزين، التحقق، والاستعلام 8.1 تخزين RouterInfo لدى النظراء رسالة I2NP من نوع DatabaseStoreMessage تحتوي على تبادل RouterInfo المحلي أثناء تهيئة اتصال النقل عبر NTCP أو SSU.\n8.2 تخزين LeaseSet لدى الأقران تُبادَل دوريًا رسائل I2NP DatabaseStoreMessage التي تتضمن LeaseSet المحلي عبر رسائل مُشفَّرة باستخدام garlic encryption (أسلوب التشفير بالثوم في I2P) مُضمَّنة مع حركة مرور Destination، مما يتيح الردود من دون عمليات بحث عن LeaseSet.\n8.3 اختيار Floodfill DatabaseStoreMessage يرسل إلى floodfill الأقرب إلى مفتاح التوجيه الحالي. يُعثر على أقرب floodfill عبر بحث في قاعدة البيانات المحلية. حتى إن لم يكن الأقرب فعلاً، فإن آلية الفيضان (flooding) تنشره ليصبح \u0026ldquo;أقرب\u0026rdquo; عبر إرساله إلى عدة floodfills.\nيستخدم Kademlia التقليدي بحث \u0026ldquo;find-closest\u0026rdquo; (للعثور على أقرب نظير) قبل الإدراج. بينما يفتقر I2NP إلى مثل هذه الرسائل، قد تقوم routers بإجراء بحث تكراري مع قلب البت الأقل أهمية (key ^ 0x01) لضمان اكتشاف النظير الأقرب فعلاً.\n8.4 تخزين RouterInfo لدى Floodfills Routers تنشر RouterInfo عبر الاتصال مباشرةً بـ floodfill، وذلك بإرسال I2NP DatabaseStoreMessage مع رمز رد غير صفري. الرسالة ليست مشفّرة بـ garlic encryption من طرف إلى طرف (اتصال مباشر، بلا وسطاء). يردّ الـ floodfill برسالة DeliveryStatusMessage مستخدماً رمز الرد كمعرّف للرسالة.\nقد ترسل Routers أيضًا RouterInfo (بيانات تعريف الـ Router في I2P) عبر tunnel استطلاعي (قيود الاتصال، عدم التوافق، إخفاء عنوان IP). قد ترفض Floodfills عمليات التخزين هذه أثناء التحميل الزائد.\n8.5 تخزين LeaseSet لدى Floodfills تخزين LeaseSet أكثر حساسية من RouterInfo (بيانات تعريف router في I2P). يجب على Routers منع ارتباط LeaseSet بها.\nRouters تنشر LeaseSet عبر tunnel العميل الصادر بإرسال DatabaseStoreMessage مع Reply Token (رمز الرد) غير صفري. تكون الرسالة مشفّرة طرفاً إلى طرف باستخدام garlic encryption عبر Session Key Manager (مدير مفاتيح الجلسة) الخاص بـ Destination (الوجهة)، ما يخفيها عن نقطة النهاية الصادرة لـ tunnel. يرد Floodfill بـ DeliveryStatusMessage تُعاد عبر tunnel الوارد.\n8.6 عملية الإغراق تقوم Floodfills بالتحقق من صحة RouterInfo (بيانات تعريف router)/LeaseSet قبل التخزين محلياً باستخدام معايير تكيُّفية تعتمد على الحمل، وحجم netdb، وعوامل أخرى.\nبعد استلام بيانات أحدث وصحيحة، تقوم عُقد floodfill بـ\u0026quot;flood\u0026quot; لها عبر البحث عن أقرب 3 floodfill routers إلى routing key (مفتاح التوجيه). ترسل الاتصالات المباشرة I2NP DatabaseStoreMessage مع Reply Token (رمز الرد) يساوي صفراً. لا تقوم الـ routers الأخرى بالرد أو بإعادة الإغراق.\nقيود مهمة: - يجب ألا تقوم Floodfills بالنشر عبر tunnels; اتصالات مباشرة فقط - لا تقوم Floodfills مطلقاً بنشر LeaseSet منتهي الصلاحية أو RouterInfo نُشر قبل أكثر من ساعة\n8.7 الاستعلام عن RouterInfo و LeaseSet تطلب I2NP DatabaseLookupMessage إدخالات netdb من floodfill routers (عُقد مُخصّصة لتخزين netdb ونشره). تُرسَل الاستعلامات عبر tunnel استكشافي صادر؛ وتُحدِّد الردود tunnel استكشافي وارد للعودة.\nعادةً ما تُرسَل عمليات الاستعلام إلى اثنين من floodfill routers \u0026ldquo;جيدين\u0026rdquo; الأقربَين إلى المفتاح المطلوب، بالتوازي.\nتطابق محلي: يتلقى استجابة من نوع I2NP DatabaseStoreMessage لا يوجد تطابق محلي: يتلقى رسالة I2NP DatabaseSearchReplyMessage مع مراجع لـ floodfill router أخرى قريبة من المفتاح عمليات الاستعلام عن LeaseSet تستخدم تشفير garlic من طرف إلى طرف (اعتباراً من 0.9.5). عمليات الاستعلام عن RouterInfo (معلومات الـrouter) غير مُشفّرة بسبب كلفة ElGamal العالية، مما يجعلها عرضة للتجسس من قِبل نقطة النهاية الخارجة.\nاعتباراً من 0.9.7، تتضمن ردود الاستعلام مفتاح جلسة ووسماً، مما يخفي الردود عن البوابة الواردة.\n8.8 عمليات البحث التكرارية قبل 0.8.9: عمليتا استعلام احتياطيتان متوازيتان من دون توجيه تراجعي أو تكراري.\nاعتبارًا من 0.8.9: تم تنفيذ عمليات البحث التكرارية بدون تكرار—أكثر كفاءة وموثوقية ومناسبة للمعرفة غير المكتملة بـ floodfill. ومع نمو الشبكات ومع معرفة routers بعدد أقل من floodfills، تقترب عمليات البحث من تعقيد O(log n).\nتستمر عمليات البحث التكرارية حتى عند عدم وجود إحالات إلى نظراء أقرب، مما يمنع الحجب الخبيث black-holing (إسقاط الطلبات دون تمريرها أو الرد عليها). يُطبَّق الحد الأقصى الحالي لعدد الاستعلامات والمهلة الزمنية.\n8.9 التحقق RouterInfo Verification: تم تعطيلها اعتباراً من 0.9.7.1 لمنع الهجمات الموصوفة في الورقة البحثية \u0026ldquo;Practical Attacks Against the I2P Network\u0026rdquo;.\nالتحقق من LeaseSet: Routers تنتظر ~10 ثوانٍ، ثم تُجري استعلامًا من floodfill (عقدة مخصّصة لنشر netDb) مختلف عبر outbound client tunnel. يُخفي garlic encryption من الطرف إلى الطرف ذلك عن نقطة النهاية الصادرة. تعود الردود عبر inbound tunnels.\nاعتباراً من 0.9.7، تُشفَّر الردود مع إخفاء مفتاح الجلسة/الوسم عن بوابة الدخول.\n8.10 الاستكشاف الاستكشاف يتضمّن استعلام netdb باستخدام مفاتيح عشوائية للتعرّف على routers جديدة. تستجيب Floodfills برسالة DatabaseSearchReplyMessage تحتوي على تجزئات routers غير-floodfill القريبة من المفتاح المطلوب. تقوم استعلامات الاستكشاف بتعيين علم خاص في DatabaseLookupMessage.\n9. MultiHoming (الاتصال عبر عدة مزودين/واجهات شبكة) يمكن تشغيل الوجهات التي تستخدم مفاتيح خاصة/عامة متطابقة (الطريقة التقليدية eepPriv.dat) على عدة routers في الوقت نفسه. ينشر كل مثيل دوريًا LeaseSets موقعة؛ يُعاد أحدث LeaseSet منشور إلى طالبي الاستعلام. ومع حد أقصى لعمر LeaseSet يبلغ 10 دقائق، فإن فترات الانقطاع لا تستمر لأكثر من ~10 دقائق.\nاعتباراً من 0.9.38، تدعم Meta LeaseSets الخدمات متعددة الموطن الكبيرة باستخدام Destinations (وجهات) منفصلة توفّر خدمات مشتركة. عناصر Meta LeaseSet هي Destinations أو Meta LeaseSets أخرى بفترات صلاحية تصل إلى 18.2 ساعة، مما يتيح وجود مئات/آلاف Destinations لاستضافة الخدمات المشتركة.\n10. تحليل التهديدات يعمل حاليًا نحو 1700 floodfill routers. يسهم نمو الشبكة في جعل معظم الهجمات أكثر صعوبة أو أقل تأثيرًا.\n10.1 تدابير التخفيف العامة النمو: المزيد من floodfills يجعل الهجمات أصعب أو أقل تأثيرًا التكرار: تُخزَّن جميع مدخلات netdb على 3 floodfill routers الأقرب إلى المفتاح عبر الإغراق التواقيع: جميع المدخلات موقعة من المنشئ؛ التزوير مستحيل 10.2 Routers البطيئة أو غير المستجيبة تحتفظ Routers بإحصاءات موسّعة لملف تعريف القرين لـ floodfills: - متوسط زمن الاستجابة - نسبة الإجابة على الاستعلام - نسبة نجاح التحقق من التخزين - آخر عملية تخزين ناجحة - آخر عملية بحث ناجحة - آخر استجابة\nRouters تستخدم هذه المقاييس عند تحديد \u0026ldquo;الجودة\u0026rdquo; لاختيار أقرب floodfill. يتم بسرعة التعرف على routers غير المستجيبة تمامًا وتجنّبها؛ أما routers الخبيثة جزئيًا فتشكّل تحديًا أكبر.\n10.3 هجوم سيبيل (فضاء المفاتيح الكامل) قد يعمد المهاجمون إلى إنشاء أعداد كبيرة من floodfill routers موزعة في جميع أنحاء فضاء المفاتيح، كوسيلة فعّالة لهجوم حجب الخدمة (DOS).\nإذا لم يكن سوء السلوك كافياً للحصول على تصنيف \u0026ldquo;سيئ\u0026rdquo;، فقد تشمل الاستجابات الممكنة:\nتجميع قوائم تجزئة/عناوين IP للـ router \u0026ldquo;السيئة\u0026rdquo; والإعلان عنها عبر أخبار وحدة التحكم، والموقع، والمنتدى تمكين floodfill على مستوى الشبكة (\u0026ldquo;مواجهة Sybil (هجوم سيبيل) بمزيد من Sybil\u0026rdquo;) إصدارات برمجية جديدة بقوائم \u0026ldquo;سيئة\u0026rdquo; مدمجة بشكل ثابت تحسين مقاييس ملفات تعريف الأقران والعتبات الخاصة بالتعرّف التلقائي معايير تأهيل كتل IP تستبعد وجود عدة floodfill ضمن كتلة IP واحدة قائمة سوداء تلقائية قائمة على الاشتراك (مشابهة لإجماع Tor) الشبكات الأكبر تجعل الأمر أصعب.\n10.4 هجوم سيبيل (فضاء مفاتيح جزئي) قد ينشئ المهاجمون 8–15 routers من نوع floodfill متقاربة ومجمَّعة ضمن فضاء المفاتيح. تُوجَّه جميع عمليات البحث/التخزين لذلك الفضاء نحو routers المهاجم، ممّا يتيح تنفيذ هجوم حجب الخدمة (DoS) على مواقع I2P معيّنة.\nنظرًا لأن فضاء المفاتيح مُفهرس باستخدام تجزئات SHA256 التشفيرية، يحتاج المهاجمون إلى استخدام القوة الغاشمة لتوليد routers بقربٍ كافٍ في فضاء المفاتيح.\nالدفاع: تتغير خوارزمية القرب في Kademlia (بروتوكول DHT) بمرور الوقت باستخدام SHA256(key + YYYYMMDD)، وتتبدّل يومياً عند منتصف الليل بتوقيت UTC. هذا تدوير فضاء المفاتيح يفرض إعادة توليد الهجوم يومياً.\nملاحظة: تُظهر أبحاث حديثة أن تدوير فضاء المفاتيح ليس فعالًا بشكل خاص—إذ يستطيع المهاجمون حساب تجزئات router مسبقًا، ولا يلزمهم سوى عدة routers لحجب أجزاء من فضاء المفاتيح خلال نصف ساعة بعد التدوير.\nنتيجة التدوير اليومي: تصبح netdb الموزعة غير موثوقة لدقائق بعد التدوير—تفشل عمليات البحث قبل أن يتلقى أقرب router جديد عمليات التخزين.\n10.5 هجمات التمهيد قد يتمكن المهاجمون من السيطرة على مواقع reseed (إعادة البذر) أو خداع المطورين لإضافة مواقع reseed عدائية، مما يؤدي إلى إقلاع routers الجديدة داخل شبكات معزولة أو خاضعة لسيطرة الأغلبية.\nالدفاعات المُنفَّذة: - جلب مجموعات فرعية من RouterInfo من عدة مواقع reseed (إعادة البذر: آلية تزويد الـ router بقائمة أولية من نظراء I2P عند البدء) بدلاً من موقع واحد - مراقبة reseed خارج الشبكة عبر استطلاع المواقع دورياً - اعتباراً من 0.9.14، تُحزَّم بيانات reseed كملفات zip موقَّعة مع التحقق من التوقيع المُنزَّل (انظر مواصفة su3 )\n10.6 التقاط الاستعلام قد تقوم Floodfill routers بـ\u0026quot;توجيه\u0026quot; الأقران إلى routers خاضعة لسيطرة المهاجم عبر المراجع المُعادة.\nغير محتمل عبر الاستكشاف بسبب انخفاض التواتر؛ تحصل routers على مراجع الأقران أساساً عبر بناء tunnel العادي.\nاعتباراً من الإصدار 0.8.9، تم تنفيذ عمليات بحث تكرارية. تُتَّبع مراجع floodfill الواردة في DatabaseSearchReplyMessage إذا كانت أقرب إلى مفتاح البحث. الـrouters الطالبة لا تثق في مدى قرب المرجع. تستمر عمليات البحث رغم عدم وجود مفاتيح أقرب، وذلك حتى انقضاء المهلة/بلوغ الحد الأقصى لعدد الاستعلامات، ما يمنع black-holing (حجباً متعمداً لحركة المرور) خبيثاً.\n10.7 تسريبات المعلومات تسرُّب المعلومات في DHT (جدول التجزئة الموزع) ضمن I2P يحتاج إلى مزيد من التحقيق. تقوم Floodfill routers برصد الاستعلامات وجمع المعلومات. عند وصول نسبة العقد الخبيثة إلى 20%، تصبح تهديدات Sybil (هجمات سيبيل) المذكورة سابقاً إشكاليةً لأسباب متعددة.\n11. العمل المستقبلي تشفير من الطرف إلى الطرف لاستعلامات netDb الإضافية واستجاباتها أساليب أفضل لتتبّع استجابات الاستعلام أساليب تخفيف لمشكلات الموثوقية المتعلقة بتدوير فضاء المفاتيح 12. المراجع مواصفة البُنى الشائعة – هياكل RouterInfo (بيانات تعريف الـ router) و LeaseSet (مجموعة بيانات مسارات الدخول) مواصفة I2NP (بروتوكول شبكة I2P الداخلي) – أنواع رسائل قاعدة البيانات الاقتراح 123: إدخالات netDb (قاعدة بيانات الشبكة الموزّعة) الجديدة – مواصفة LeaseSet2 (الإصدار الثاني من LeaseSet) مناقشة netDb التاريخية – تاريخ التطوير والمناقشات المؤرشفة ","description":"فهم قاعدة بيانات الشبكة الموزعة الخاصة بـ I2P (netDb) - DHT متخصص (جدول تجزئة موزع) لمعلومات اتصال router وعمليات البحث عن الوجهات","id":"ef0a5e8bee4372a50a7f4562af717b0c","section":"docs","title":"قاعدة بيانات الشبكة","url":"/ar/docs/overview/network-database/"},{"categories":null,"content":"يُعرّف هذا المسرد المصطلحات الشائعة المستخدمة في وثائق ونقاشات I2P.\nب Blockchain دفتر أستاذ موزع يمكنه تسجيل المعاملات بين أطراف متعددة بكفاءة وبطريقة قابلة للتحقق ودائمة.\nد اللامركزية بنية شبكية تتجنب الاعتماد على طرف واحد. تشمل تقنيات الند للند (peer-to-peer)، وسلسلة الكتل (blockchain)، والفيدرالية (federated)، والموزعة (distributed).\nالوجهة (Destination) الهوية التشفيرية لنفق. هذه هي هويات العملاء والخوادم داخل شبكة I2P.\nDHT (Distributed Hash Table) يُستخدم في بعض المشاريع لربط النظراء ببعضهم البعض عن طريق تخزين المعلومات على شكل أزواج مفتاح-قيمة بطريقة موزعة.\nالأنظمة الموزعة موضوع أكاديمي ضمن علوم الحاسوب يهتم بتصميم الأنظمة الحاسوبية التي تتكون من العديد من أجهزة الحاسوب الفردية المتصلة عبر شبكة.\nF الاتحادية (Federated) تسمح الاتحادية لعمليات النشر المنفصلة لخدمة ما بالتواصل مع بعضها البعض من خلال بروتوكول مشترك.\nH Hash رقم، يُعرض عادةً كسلسلة من الحروف والأرقام. يمكن أن يعمل كـ\u0026quot;بصمة\u0026quot; تحدد البيانات بشكل فريد.\nI I2P مشروع الإنترنت الخفي: مشروع يهدف إلى توفير طبقة إخفاء الهوية، بحيث يمكن للمستخدمين التواصل بشكل مجهول باستخدام مجموعة من التطبيقات.\nعنوان IP رقم خاص بجهاز كمبيوتر أو شبكة يكون فريداً وبالتالي يمكن استخدامه لعنونته.\nL LeaseSet مجموعة من المعلومات المطلوبة للتواصل مع عميل أو خادم عند وجهة معينة.\nP Peer-to-Peer (P2P) يجعل الأقران (Peers) جزءًا من مواردهم متاحًا مباشرة لمشاركين آخرين في الشبكة، دون الحاجة إلى تنسيق مركزي من خوادم أو مضيفين مستقرين.\nR Router برنامج I2P الأساسي، الذي يوجه الحزم المشفرة على شبكة I2P.\nRouterIdentity مجموعة من المعلومات المطلوبة للتواصل مباشرة مع router.\nT TCP/UDP بروتوكولا النقل الأساسيان المستخدمان على الإنترنت.\nTunnel مسار اتصال مجهول بين عميل أو خادم وشبكة I2P.\nي UX تجربة المستخدم، التجربة الشاملة للشخص عند استخدام منتج أو خدمة.\nو WebRTC معيار بروتوكول لإنشاء الاتصالات في متصفح الويب حيث تمر البيانات مباشرة بين المستخدمين.\n","description":"المصطلحات والتعريفات الشائعة المستخدمة في وثائق I2P","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"قاموس المصطلحات","url":"/ar/docs/overview/%D9%82%D8%A7%D9%85%D9%88%D8%B3-%D8%A7%D9%84%D9%85%D8%B5%D8%B7%D9%84%D8%AD%D8%A7%D8%AA/"},{"categories":null,"content":"نظرة عامة يحدد هذا المستند مخطط توقيع قابل لإعادة العشوائية مناسبًا لإنشاء وجهات يمكن تعميتها. وبالإضافة إلى ذلك، يمكن استخدامه لتعمية وجهات Ed25519 القائمة، مع انخفاض طفيف في الفاعلية.\nكانت Red25519 (خوارزمية توقيع) تعمل بكامل طاقتها في I2P routers منذ الإصدار 0.9.39 (الصادر في 21 مارس 2019). تم اعتماد هذه المواصفة نهائياً في الإصدار 0.9.47 (أغسطس 2020) بعد 17 شهراً من التشغيل في بيئة الإنتاج. يعمل مخطط التوقيع كنوع التوقيع 11 (RedDSA_SHA512_Ed25519) في شبكة I2P.\nالدوافع المقترح 123 (مدخلات netDB جديدة) يعرّف صيغة مشفّرة لـLeaseSet2 تُجسّد مبدأ أقل قدر من الصلاحيات: يُمنَح كل مشارك في الشبكة فقط المعلومات اللازمة لدوره. وعلى وجه الخصوص، فإن LeaseSet2 المشفَّر والمنشور إلى floodfill لا يكشف Destination (الوجهة في I2P) التي يخصّها، ولا يمكن عرض Leases إلا لمن لديه معرفة مسبقة بـ Destination. ومع ذلك، لا تزال floodfills بحاجة إلى القدرة على مصادقة LeaseSet2s المشفَّرة عند نشرها، كما يحتاج العملاء أيضًا إلى التأكد من أن المصادقة قد فُرضت من قِبل Destination نفسها.\nيحقق الاقتراح 123 ذلك عبر إعماء مفاتيح التوقيع الخاصة بـ Destinations (الوجهات في I2P). يمكن استخدام المفاتيح المُعمّاة لإنشاء توقيعات يمكن لـ floodfills التحقق منها، ويمكن للعملاء التأكد من أن Destination وحده كان يمكنه إنشاء تلك التوقيعات. لذلك، من الضروري تحديد مخطط توقيع يمكن استخدامه للإعماء.\nملاحظة حول حالة المقترح 123: تم تنفيذ ونشر أجزاء من المقترح 123 تدريجيًا منذ الإصدار 0.9.38، مع إضافة دعم Red25519 في الإصدار 0.9.39. وظائف LeaseSet2 المشفَّرة (صيغة أحدث من leaseSet في I2P) جاهزة للإنتاج وتُستخدم بنشاط في شبكة I2P لخدمات مخفية معزَّزة الخصوصية.\nالتصميم مخطط التوقيع الأساسي مخطط التوقيع المحدد هنا، Red25519، هو تجسيد لـ RedDSA كما هو مُعرّف في القسم 5.4.6 من مواصفة بروتوكول Zcash (Sapling وما بعده). RedDSA هو مخطط توقيع مبني على Schnorr (مخطط توقيع شنور) ويدعم إعادة توليد المفتاح عشوائياً. وله الوظائف التالية:\nGENERATE_PRIVATE() : يرجع مفتاح خاص عشوائي بتوزيع منتظم.\nDERIVE_PUBLIC(sk) : يُرجِع المفتاح العام المطابق للمفتاح الخاص المُعطى.\nGENERATE_RANDOM() : ترجع عدداً عشوائياً (scalar) مناسباً لإعادة عشوائية زوج مفاتيح.\nRANDOMIZE_PRIVATE(sk, alpha) : تعيد عشوَرة مفتاح خاص، باستخدام عدد قياسي سري alpha.\nRANDOMIZE_PUBLIC(vk, alpha) : يعيد توليد مفتاح عام عشوائياً باستخدام عدد قياسي سرّي alpha.\nSIGN(sk, m) : يُرجِع توقيعًا باستخدام المفتاح الخاص sk على الرسالة m المُعطاة.\nVERIFY(vk, m, sig) : يتحقق من صحة التوقيع sig بمقارنته بالمفتاح العام vk والرسالة m. يُرجِع true إذا كان التوقيع صالحًا، وإلا فيُرجِع false.\nبالنسبة لزوج مفاتيح معيّن (sk، vk)، تتحقق العلاقة التالية:\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) تحويل مفاتيح Ed25519 إلى Red25519 يجوز تحويل مفاتيح Ed25519 تحويلًا أحادي الاتجاه بصفة مؤقتة إلى مفاتيح Red25519، وذلك لدعم إعادة العشوائية للوجهات الحالية من نوع Ed25519. الأنواع الأخرى من sigtypes (أنواع التواقيع) غير متوافقة.\nنعرّف دوال التحويل التالية:\nCONVERT_ED25519_PRIVATE(privkey) : يُرجع مفتاح Red25519 الخاص المقابل لمفتاح Ed25519 الخاص المُعطى.\nCONVERT_ED25519_PUBLIC(pubkey) : يُرجع مفتاح Red25519 العام المقابل لمفتاح Ed25519 العام المُعطى.\nبالنسبة لزوج مفاتيح Ed25519 المعطى (privkey، pubkey)، تتحقق العلاقة التالية:\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) المواصفة التعريفات B : نقطة الأساس الخاصة بـ Ed25519 كما في RFC 8032 .\nL : رتبة Ed25519 هي 2^252 + 27742317777372353535851937790883648493 كما في RFC 8032 .\n[s] B : ضرب سلمي ثابت الأساس على نقطة الأساس بـ s.\n[s] A : الضرب السلمي (scalar multiplication) بنقطة أساس متغيّرة لـ A بواسطة s.\nx || y : ربط مصفوفتين من البايتات x و y.\nRed25519 (مخطط توقيع مبني على Ed25519 مستخدم في I2P) يقوم المخطّط Red25519 بتخصيص RedDSA بما يلي:\nG := مجموعة النقاط على صيغة Edwards لمنحنى Curve25519. وبالتحديد، يعني ذلك أن Red25519 يستخدم المجموعة الفرعية ذات رتبة أولية مقدارها L، وأن قيمة cofactor (عامل المشاركة) h_G تساوي 8. P_G := نقطة الأساس B لـ Ed25519. l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) ملاحظة حول اختيار دالة التجزئة: تستخدم Red25519 (خوارزمية توقيع) SHA-512 بدلاً من BLAKE2b-512 (كما هو مستخدم في Zcash RedDSA). يتم تعويض هذا القرار التصميمي عبر حماية length-prefixing (حماية بإضافة بادئة طول للرسالة) الموضحة أدناه. يقترح I2P Proposal 148 الانتقال مستقبلاً إلى BLAKE2b-512 لتعزيز الحماية ضد Duplicate Message Identification (DMI) (تمييز الرسائل المكررة) و Length Extension Attacks (LEA) (هجمات تمديد الطول)، إضافةً إلى تحسين الأداء.\nتفترض RedDSA أن H(x) تُنفَّذ باستخدام دالة تجزئة تشفيرية آمنة ضد هجمات تمديد الطول. ولا يفي SHA-512 بذلك بمفرده. لمعالجة هذا، نُلزِم بأن تُسبَق الرسائل بترميز خالٍ من البادئة لطولها:\nlen_u16(M) || M حيث إن len_u16(M) هي التمثيل ذي البايتين لطول M، بصيغة little-endian (ترتيب البايتات من الأصغر إلى الأكبر)، وذلك اتساقاً مع ترميز little-endian لكلٍ من scalars (أعداد سكلارية) والنقاط.\nيجب ألا يزيد طول الرسائل عن 65534 بايتًا. قيمة الطول 65535 محجوزة لتوسعات محتملة مستقبلًا.\nملاحظة أمنية: إن تضمين المفتاح العام (vk) في دالة التجزئة، مقترنًا بـ 80 بايتًا عشوائيًا أثناء التوقيع، يضمن الحماية من ثغرات SURK-CMA (قابلية تزوير قوية مع إعادة عشوائية للمفاتيح في ظل هجوم الرسالة المختارة) التي اكتُشفت في التصاميم المبكرة لـ RedDSA. يتضمن هذا التنفيذ الإصلاحات الأمنية الواردة في تدقيق NCC Group لـ Zcash (Finding NCC-Zcash2018-009).\nالترميز وفك الترميز مفاتيح Red25519 الخاصة هي scalars (أعداد قياسية) mod L، مرمّزة بتمثيل little-endian (ترتيب البايتات من الأقل أهمية إلى الأعلى). نعرّف الدالتين DECODE_SCALAR وENCODE_SCALAR للتبديل بين صيغة مصفوفة البايتات والصيغة العددية لـ scalar.\nمفاتيح Red25519 العامة هي نقاط على نموذج إدواردز (Edwards form) لمنحنى Curve25519. يُرَمَّزُـها على شكل تمثيل بطول 255 بت بترتيب البايتات little-endian (ليتل-إنديَن: ترتيب البايتات من الأصغر إلى الأكبر) لإحداثي y، ثم تتبعه بتة واحدة تشير إلى إشارة إحداثي x. وهذا هو نفس الترميز المستخدم في Ed25519. نعرّف الدالتين DECODE_POINT وENCODE_POINT للتبديل بين مصفوفة البايتات وصيغ الإحداثيات لنقطة.\nدوال RedDSA (خوارزمية توقيع رقمية) لتسهيل التنفيذ، نورد أدناه بشكل صريح دوال RedDSA (خوارزمية توقيع رقمية) وكذلك عدة دوال مساعدة، وهي متخصصة بالفعل لـ Red25519 (نوع متخصّص من RedDSA). ينبغي على المنفذين الرجوع إلى القسم 5.4.6 من مواصفة بروتوكول Zcash للاطلاع على المواصفة العامة لدوال RedDSA.\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() دوال التحويل CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey لاحظ أن تنفيذ CONVERT_ED25519_PRIVATE يعادل حساب العدد القياسي السري s عند اشتقاق مفتاح عام Ed25519 من مفتاح خاص Ed25519، كما هو محدد في الخطوات 1-3 من القسم 5.1.5 من RFC 8032 .\nالتداعيات الأمنية إن إعادة عشوَنة وجهة Red25519 (نوع مفاتيح/تواقيع) ثم إنشاء تواقيع باستخدامها لا يسرّب أي معلومات عن الوجهة، لأن توزيع مفاتيح Red25519 الخاصة المُولَّدة عبر RANDOMIZE_PRIVATE مطابق لتوزيع المفاتيح الخاصة المُولَّدة عبر GENERATE_PRIVATE، وDERIVE_PUBLIC حتمي.\nإن تحويل مفاتيح Ed25519 الخاصة (خوارزمية توقيع رقمية بمعيار 25519) إلى Red25519 (تمثيل مشتق من 25519 لتحويل المفاتيح) عبر CONVERT_ED25519_PRIVATE لا يؤدي إلى نفس التوزيع. ومع ذلك، نعتبر أن الانخفاض في مستوى الأمان مقبول للأسباب التالية:\nفضاء القيم القياسية لـ Ed25519 (نظام توقيع بيضوي) يساوي تقريبًا نصف حجم فضاء القيم القياسية لـ Red25519 (هناك 2^251 قيمة قياسية ممكنة لـ Ed25519، و L ~= 2^252 قيمة قياسية ممكنة لـ Red25519). وعليه فإن فقدان الأمان يبلغ في الحد الأقصى عاملًا يقارب 2، أو ما يقارب 1 بت (لأنه قد نكون قد اخترنا بالمصادفة قيمة قياسية لـ Red25519 تكون أيضًا صالحة كقيمة قياسية لـ Ed25519). وجهات Ed25519 القائمة كانت قد كُشِفت على الشبكة في السابق، ويُفترض أن عُقَد floodfills الخبيثة قد قامت بالفعل بتعدادها. هام: ينبغي على المستخدمين القلقين بشأن هذا التخفيض في مستوى الأمان استخدام Red25519 (نوع التوقيع 11) بوصفه sigtype (نوع التوقيع) لِـ Destinations (الوجهات) الخاصة بهم بدلاً من Ed25519 (نوع التوقيع 7).\nلاحظ أن الطرح أعلاه لا ينطبق على العدد القياسي لإعادة العشوائية alpha؛ إذ تتسرب معلومات عن المفتاح في كل مرة تُختار فيها alpha منحازة، لأن إعادة العشوائية بالجمع تتصرف مثل شفرة ذات استخدام واحد.\nحالة التدقيق الأمني إفصاح مهم: لم يخضع I2P، بما في ذلك Red25519 (خوارزمية توقيع رقمية مستخدمة في I2P)، مطلقًا لتدقيق أمني رسمي من طرف ثالث. خضع التصميم الأساسي لـ RedDSA (مخطط توقيع رقمي) لمراجعة أمنية من قبل NCC Group (شركة تدقيق أمني) كجزء من تدقيق بروتوكول Zcash Sapling في عام 2018، حيث جرى تحديد المشكلات الأمنية وإصلاحها. ومع ذلك، فإن التطبيق الخاص بـ I2P باستخدام SHA-512 (دالة تجزئة) بدلاً من BLAKE2b-512 (دالة تجزئة) ومع I2P domain separation (آلية فصل المجالات التشفيرية في I2P) لم يخضع لتحليل مستقل.\nخضع التطبيق المرجعي ed25519-java الذي طوّره str4d لتدقيق مستقل واحد من طرف ثالث، لكن ذلك سبق تنفيذ Red25519 (امتدادات لـ Ed25519) ولم يشمل سوى وظائف Ed25519 (خوارزمية توقيع رقمية)، دون امتدادات Red25519.\nينبغي على المستخدمين الذين يعتمدون Red25519 (تقنية تشفير) فهم هذا القيد وتقييم المفاضلات الأمنية بناءً على نموذج التهديد الخاص بهم.\nالتوافق ستكون إصدارات I2P التي تدعم Red25519 (نوع توقيع) قادرة على التحقق من هياكل بيانات الشبكة الموقعة به. أما إصدارات I2P التي لا تدعم Red25519 فستتعامل معه كتوقيع غير معروف، وقد تقوم بإسقاط هياكل البيانات.\nالجدول الزمني للنشر: - 0.9.39 (مارس 2019): أول تنفيذ مع دعم Encrypted LS2 (نسخة LeaseSet2 مشفّرة) في floodfills - 0.9.40 (مايو 2019): تفويض لكل عميل لـ Encrypted LS2 - 0.9.41 (أغسطس 2019): Meta LS2 و Encrypted LS2 بمفاتيح غير متصلة بالإنترنت - 0.9.43 (فبراير 2020): دعم b32 لـ Encrypted LS2 - 0.9.47 (أغسطس 2020): إتمام المواصفات - 2.10.0 (أكتوبر 2025): إصدار الشبكة الحالي (ما يعادل 0.9.67+)\nينبغي للمستخدمين توقّع أن تكون موثوقية هياكل البيانات الموقّعة بـ Red25519 (خوارزمية توقيع) جيدةً لحالات استخدام Encrypted LeaseSet2، إذ إن الشبكة حظيت بأكثر من ست سنوات للترقية منذ التنفيذ الأولي. ومع ذلك، فإن مقاييس التبنّي لاستخدام الوجهات عمومًا غير متاحة علنًا.\nحالة الاستخدام الأساسية: يُستخدم Red25519 (خوارزمية توقيع تدعم إعماء المفاتيح) أساساً لتمكين وظيفة Encrypted LeaseSet2 حيث يكون إعماء المفاتيح مطلوباً. بالنسبة إلى الوجهات القياسية التي لا تتطلب encrypted leaseset، يظل Ed25519 (نوع التوقيع 7) الخيار الموصى به نظرًا إلى توافقه الأوسع وسجلّه المثبت لفترة أطول.\nملاحظات التنفيذ Red25519 مُنفَّذة في I2P Java router في net.i2p.crypto.eddsa.RedDSAEngine وتستخدم مكتبة ed25519-java من str4d (Jack Grigg) كتَبعيّة في Maven بالمعرّف net.i2p.crypto:eddsa (الإصدارات من 0.1.0 حتى 0.3.0).\nيدعم تنفيذ i2pd بلغة C++ أيضًا Red25519 (نوع توقيع رقمي مبني على Ed25519) (signaturetype=11) لنشر LeaseSet مشفّرة.\nمثال تهيئة لـ i2pd:\nsignaturetype=11 i2cp.leaseSetType=5 توافق LeaseSet2 المشفّر: تشترط مواصفة LeaseSet المشفّر أن يكون المفتاح العام للتوقيع في الوجهة غير المُعمّاة من نوع Ed25519 (نوع التوقيع 7) أو Red25519 (نوع التوقيع 11). لا تُدعَم أي أنواع توقيع أخرى لوظائف LeaseSet المشفّر.\nمتجهات الاختبار تُوفَّر متجهات الاختبار التالية للتحقق من صحة التنفيذ. يتضمن كل متجه ما يلي:\nedsk: مفتاح Ed25519 خاص (عشوائي) edpk: مفتاح Ed25519 عام مقابل لـ edsk sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: الرسالة المراد توقيعها sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) ملاحظة حول التنفيذ: ينبغي دمج متجهات الاختبار هذه في أجنحة اختبارات الوحدات المؤتمتة بغرض التحقق المستمر. على المنفّذين التحقق من أن جميع التحويلات، والتواقيع، وعمليات إعادة العشوائية تطابق هذه القيم المتوقعة.\nمتجه اختبار 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 متجه الاختبار 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f ملاحظة: متجهات الاختبار الإضافية 3-10 تتبع نفس التنسيق ويمكن العثور عليها في التنفيذ المرجعي.\nالمراجع المقترح 123: إدخالات netDB جديدة - تم تنفيذ أجزاء منها ونشرها في 0.9.38 و0.9.39 والإصدارات اللاحقة مواصفة بروتوكول Zcash، القسم 5.4.6: RedDSA وRedJubjub وRedPallas - تم تعريف RedDSA (خوارزمية توقيع رقمية من عائلة EdDSA) كجزء من مواصفة بروتوكول Zcash؛ خضعت لتدقيق أمني من قِبل NCC Group (يناير 2019) RFC 8032: خوارزمية التوقيع الرقمي بمنحنيات إدواردز (EdDSA) المقترح 148: RedDSA-BLAKE2b-Ed25519 - مُقترَح لكنه غير مُنفَّذ بعد؛ يقترح انتقالًا مستقبليًا إلى BLAKE2b-512 مواصفة LeaseSet المُشفَّر مواصفة التشفير منخفض المستوى ","description":"مخطط توقيع قابل لإعادة العشوائية لإنشاء Destinations (وجهات I2P) محجوبة","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"مخطط التوقيع Red25519","url":"/ar/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":"حول خوادم Reseed (التزويد الأولي بمعلومات الشبكة) تحتاج routers الجديدة إلى عددٍ قليلٍ من النظراء للانضمام إلى شبكة I2P. يوفّر reseed hosts (خوادم التمهيد الأولي) مجموعة التمهيد الابتدائية عبر تنزيلات HTTPS مُشفَّرة. تُوقَّع كل حزمة reseed من قِبل المضيف، مما يمنع العبث بها من قِبل أطراف غير موثَّقة. قد تقوم routers المستقرة بإجراء reseed أحيانًا إذا أصبحت مجموعة نظرائها قديمة.\nعملية تمهيد الشبكة عندما يبدأ I2P router للمرة الأولى أو يكون غير متصل لفترة طويلة، فإنه يحتاج إلى بيانات RouterInfo (معلومات الـ router) للاتصال بالشبكة. وبما أن الـ router لا يملك أقراناً موجودين مسبقاً، فلا يمكنه الحصول على هذه المعلومات من داخل شبكة I2P نفسها. تقوم آلية reseed (إعادة البذر) بحل مشكلة التمهيد هذه عبر توفير ملفات RouterInfo من خوادم HTTPS خارجية موثوقة.\nتوفّر عملية إعادة البذر 75-100 ملف RouterInfo (معلومات router) ضمن حزمة واحدة موقعة تشفيرياً. وهذا يضمن أن تتمكن routers الجديدة من إنشاء اتصالات بسرعة من دون تعريضها لهجمات الرجل في الوسط، التي قد تعزلها ضمن أقسام شبكية منفصلة وغير موثوقة.\nحالة الشبكة الحالية اعتبارًا من أكتوبر 2025، تعمل شبكة I2P باستخدام إصدار router 2.10.0 (إصدار API 0.9.67). يظل reseed protocol (آلية لجلب الأقران الأوّليين للشبكة) الذي قُدِّم في الإصدار 0.9.14 مستقرًا ولم يطرأ عليه تغيير في وظيفته الأساسية. تحافظ الشبكة على عدة خوادم reseed مستقلة موزعة عالميًا لضمان التوافر ومقاومة الرقابة.\nتراقب خدمة checki2p جميع خوادم reseed (إعادة البذر) الخاصة بـ I2P كل 4 ساعات، وتوفر فحوصات حالة في الوقت الفعلي ومقاييس التوافر للبنية التحتية لـ reseed.\nمواصفة تنسيق ملف SU3 تنسيق ملف SU3 يمثّل الأساس لبروتوكول reseed (إعادة التزويد بعُقد البداية) الخاص بـ I2P، مما يوفّر تقديم محتوى مُوقّعًا تشفيريًا. يُعدّ فهم هذا التنسيق ضروريًا لتنفيذ خوادم وعملاء reseed.\nبنية الملفات يتكوّن تنسيق SU3 من ثلاثة مكوّنات رئيسية: الرأس (40+ بايت)، المحتوى (بطول متغيّر)، والتوقيع (بطول محدَّد في الرأس).\nتنسيق الترويسة (بايتات 0-39 كحد أدنى) Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") ### معلمات SU3 الخاصة بـ Reseed (إعادة البذر) بالنسبة لحزم إعادة البذر، يجب أن يتسم ملف SU3 بالخصائص التالية:\nاسم الملف: يجب أن يكون بالضبط i2pseeds.su3 نوع المحتوى (البايت 27): 0x03 (RESEED) نوع الملف (البايت 25): 0x00 (ZIP) نوع التوقيع (البايتان 8-9): 0x0006 (RSA-4096-SHA512) سلسلة الإصدار: الطابع الزمني لـ Unix بصيغة ASCII (عدد الثواني منذ Epoch، date +%s format) معرّف الموقّع: معرّف بأسلوب البريد الإلكتروني يطابق CN (الاسم الشائع) في شهادة X.509 معلمة استعلام معرّف الشبكة بدءًا من الإصدار 0.9.42، تقوم routers بإلحاق ?netid=2 بطلبات reseed (جلب بيانات التمهيد للشبكة). هذا يمنع الاتصالات عبر الشبكات، نظرًا لأن شبكات الاختبار تستخدم معرّفات شبكة مختلفة. تستخدم الشبكة الإنتاجية الحالية لـ I2P معرّف الشبكة 2.\nمثال على الطلب: https://reseed.example.com/i2pseeds.su3?netid=2\nبنية محتوى ZIP يحتوي قسم المحتوى (بعد الترويسة، قبل التوقيع) على أرشيف ZIP قياسي يستوفي المتطلبات التالية:\nالضغط: ضغط ZIP القياسي (DEFLATE، خوارزمية ضغط) عدد الملفات: عادةً 75-100 ملفات RouterInfo (بيانات Router في I2P) بنية الدليل: يجب أن تكون جميع الملفات في المستوى الأعلى (دون أدلة فرعية) تسمية الملفات: routerInfo-{44-character-base64-hash}.dat أبجدية base64 (ترميز بقاعدة 64): يجب استخدام أبجدية base64 المعدّلة الخاصة بـ I2P تختلف أبجدية base64 الخاصة بـ I2P عن base64 القياسي باستخدام - و~ بدلاً من + و/ لضمان التوافق مع أنظمة الملفات وعناوين URL.\nالتوقيع التشفيري يغطي التوقيع الملف بأكمله ابتداءً من البايت 0 وحتى نهاية قسم المحتوى. يُلحَق التوقيع نفسه بعد المحتوى.\nخوارزمية التوقيع (RSA-4096-SHA512) احسب قيمة التجزئة SHA-512 للبايتات من 0 حتى نهاية المحتوى وقّع قيمة التجزئة باستخدام \u0026ldquo;raw\u0026rdquo; RSA (NONEwithRSA بمصطلحات Java) عبّئ التوقيع بأصفار بادئة عند الحاجة للوصول إلى 512 بايت ألحِق توقيعًا بطول 512 بايت بالملف عملية التحقق من صحة التوقيع يجب على العملاء:\nاقرأ البايتات 0-11 لتحديد نوع التوقيع وطوله اقرأ كامل الترويسة لتحديد حدود المحتوى قم ببث المحتوى أثناء حساب تجزئة SHA-512 استخرج التوقيع من نهاية الملف تحقق من التوقيع باستخدام المفتاح العام RSA-4096 الخاص بالموقّع ارفض الملف إذا فشل التحقق من التوقيع نموذج الثقة للشهادات تُوزَّع مفاتيح توقيع إعادة البذر على شكل شهادات X.509 موقَّعة ذاتيًا بمفاتيح RSA-4096. تُدرَج هذه الشهادات ضمن حزم I2P router في الدليل certificates/reseed/.\nتنسيق الشهادة: - نوع المفتاح: RSA-4096 - التوقيع: موقعة ذاتيًا - CN الخاص بالموضوع: يجب أن يتطابق مع معرّف الموقّع في ترويسة SU3 - تواريخ الصلاحية: يجب على العملاء تطبيق فترات صلاحية الشهادة\nتشغيل مضيف Reseed (إعادة البذر) يتطلب تشغيل خدمة reseed (آلية التزويد الأولي بمعلومات الشبكة للانضمام) اهتمامًا دقيقًا بمتطلبات الأمان والموثوقية وتنوع الشبكة. إن زيادة عدد مضيفي reseed المستقلين تعزز القدرة على الصمود وتُصعّب على المهاجمين أو الرقباء منع routers الجديدة من الانضمام.\nالمتطلبات التقنية مواصفات الخادم نظام التشغيل: Unix/Linux (تم اختبار Ubuntu وDebian وFreeBSD والتوصية بها) الاتصال: يتطلب عنوان IPv4 ثابتًا، وIPv6 مُوصى به لكنه اختياري المعالج: نواتان على الأقل الذاكرة (RAM): 2 غيغابايت كحد أدنى عرض النطاق الترددي: حوالي 15 غيغابايت شهريًا مدة التشغيل: التشغيل على مدار الساعة طوال أيام الأسبوع مطلوب I2P Router: I2P router متكامل جيدًا ويعمل باستمرار متطلبات البرمجيات Java: JDK 8 أو أحدث (سيكون Java 17+ مطلوباً اعتباراً من I2P 2.11.0) خادم ويب: nginx أو Apache مع دعم الوكيل العكسي (Lighttpd لم يعد مدعوماً بسبب قيود ترويسة X-Forwarded-For) TLS/SSL: شهادة TLS صالحة (Let\u0026rsquo;s Encrypt، موقعة ذاتياً، أو سلطة شهادات تجارية (CA)) حماية DDoS: fail2ban أو ما يعادله (إلزامي، ليس اختيارياً) أدوات إعادة البذر: reseed-tools الرسمية من https://i2pgit.org/idk/reseed-tools متطلبات الأمان تهيئة HTTPS/TLS البروتوكول: HTTPS فقط، بدون HTTP كبديل احتياطي إصدار TLS: الحد الأدنى هو TLS 1.2 مجموعات التشفير: يجب أن تدعم خوارزميات قوية متوافقة مع Java 8+ CN/SAN الخاصة بالشهادة: (الاسم الشائع/اسم بديل للموضوع) يجب أن تتطابق مع اسم المضيف لعنوان URL المُقدَّم نوع الشهادة: قد تكون موقّعة ذاتيًا إذا تم التنسيق مع فريق التطوير، أو صادرة عن CA معترف بها (جهة إصدار الشهادات) إدارة الشهادات شهادات توقيع SU3 وشهادات TLS تخدم أغراضًا مختلفة:\nشهادة TLS (certificates/ssl/): تؤمّن نقل HTTPS شهادة توقيع SU3 (certificates/reseed/): توقّع حزم reseed (إعادة البذر) يجب تقديم الشهادتين إلى منسق reseed (التهيئة الأولية للشبكة) (zzz@mail.i2p ) لإدراجهما ضمن حزم router.\nحماية من هجمات حجب الخدمة الموزعة (DDoS) والكشط تتعرض Reseed servers (خوادم إعادة البذر) لهجمات دورية من تنفيذات معيبة، وشبكات بوتنت، وجهات خبيثة تحاول كشط قاعدة بيانات الشبكة. تشمل إجراءات الحماية ما يلي:\nfail2ban: مطلوب لتقييد المعدّل وتخفيف الهجمات تنوع الحزم: تسليم مجموعات مختلفة من RouterInfo (المعلومات التعريفية الخاصة بـ Router) إلى جهات طالبة مختلفة اتساق الحزمة: تسليم الحزمة نفسها للطلبات المتكررة من نفس عنوان IP ضمن نافذة زمنية قابلة للتهيئة قيود تسجيل IP: عدم نشر السجلات أو عناوين IP (متطلب لسياسة الخصوصية) أساليب التنفيذ الطريقة 1: reseed-tools الرسمية (موصى بها) التنفيذ المرجعي الذي يُصانه مشروع I2P. المستودع: https://i2pgit.org/idk/reseed-tools التثبيت:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 عند التشغيل لأول مرة، ستقوم الأداة بإنشاء:\nyour-email@mail.i2p.crt (شهادة توقيع SU3) your-email@mail.i2p.pem (المفتاح الخاص لتوقيع SU3) your-email@mail.i2p.crl (قائمة إبطال الشهادات) ملفات شهادة ومفتاح TLS الميزات: - توليد حزمة SU3 تلقائيًا (350 متغيرًا، 77 RouterInfos لكل منها) - خادم HTTPS مدمج - إعادة بناء ذاكرة التخزين المؤقت كل 9 ساعات عبر cron - دعم ترويسة X-Forwarded-For مع الخيار --trustProxy - متوافق مع تكوينات الوكيل العكسي\nالنشر في بيئة الإنتاج:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed الطريقة الثانية: تنفيذ بلغة بايثون (pyseeder) تنفيذ بديل من مشروع PurpleI2P: https://github.com/PurpleI2P/pyseeder pip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 الطريقة الثالثة: نشر Docker بالنسبة إلى البيئات المعتمدة على الحاويات، توجد عدة تنفيذات جاهزة لـ Docker:\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: يضيف خدمة أونيون الخاصة بـ Tor ودعم IPFS (نظام الملفات بين الكواكب) تهيئة الوكيل العكسي تهيئة nginx upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } تهيئة Apache \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; التسجيل والتنسيق لإدراج reseed server (خادم التمهيد للشبكة) الخاص بك في الحزمة الرسمية لـ I2P:\nأكمل الإعداد والاختبار أرسل الشهادتين (توقيع SU3 وTLS) إلى منسق reseed (آلية تزويد بيانات الشبكة للمستخدمين الجدد) للتواصل: zzz@mail.i2p أو zzz@i2pmail.org انضم إلى #i2p-dev على IRC2P للتنسيق مع مشغّلين آخرين أفضل الممارسات التشغيلية المراقبة والتسجيل تمكين combined log format (تنسيق سجل موحّد) في Apache/nginx لأغراض الإحصاءات تنفيذ تدوير السجلات (تنمو السجلات بسرعة) مراقبة نجاح إنشاء الحزمة وأزمنة إعادة البناء تتبّع استخدام عرض النطاق وأنماط الطلبات عدم نشر عناوين IP أو سجلات الوصول التفصيلية مطلقًا جدول الصيانة كل 9 ساعات: إعادة بناء ذاكرة التخزين المؤقت لحزمة SU3 (مؤتمت عبر cron، مُجدول المهام في أنظمة Unix) أسبوعيًا: مراجعة السجلات لرصد أنماط الهجمات شهريًا: تحديث I2P router و reseed-tools حسب الحاجة: تجديد شهادات TLS (أتمتة باستخدام Let\u0026rsquo;s Encrypt) اختيار المنفذ الافتراضي: 8443 (مُوصى به) بديل: أي منفذ بين 1024-49151 المنفذ 443: يتطلب صلاحيات الجذر أو إعادة توجيه المنفذ (يوصى باستخدام iptables redirect) مثال على إعادة توجيه المنافذ:\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 أساليب Reseed البديلة (التمهيد الأولي للشبكة بجلب عناوين النظراء) تساعد خيارات التمهيد الأخرى المستخدمين الموجودين خلف شبكات مقيِّدة:\nReseed (التمهيد الأوّلي للشبكة) القائم على الملفات قُدِّمت في الإصدار 0.9.16، تتيح عملية reseeding القائمة على الملفات (إعادة تمهيد الاتصال بالشبكة) للمستخدمين تحميل حِزَم RouterInfo يدويًا. هذه الطريقة مفيدة بشكل خاص للمستخدمين في المناطق الخاضعة للرقابة حيث تكون خوادم reseed عبر HTTPS محجوبة.\nالعملية: 1. تُنشئ جهة اتصال موثوقة حزمة SU3 باستخدام الـ router الخاص بهم 2. تُنقَل الحزمة عبر البريد الإلكتروني، أو محرك USB، أو قناة أخرى out-of-band (قناة منفصلة عن القناة الاعتيادية) 3. يضع المستخدم i2pseeds.su3 في دليل إعدادات I2P 4. يقوم الـ Router تلقائياً باكتشاف الحزمة ومعالجتها عند إعادة التشغيل\nالتوثيق: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\nحالات الاستخدام: - مستخدمون خلف جدران نارية وطنية تحجب خوادم reseed (خوادم تزويد نقاط الاتصال الأولية) - شبكات معزولة تتطلب تمهيداً يدوياً (bootstrap) - بيئات الاختبار والتطوير\nإعادة البذر عبر وكيل Cloudflare يوفّر توجيه حركة مرور إعادة البذر عبر شبكة توصيل المحتوى (CDN) الخاصة بـ Cloudflare عدة مزايا للمشغلين في المناطق ذات الرقابة المشددة.\nالمزايا: - إخفاء عنوان IP للخادم الأصلي عن العملاء - حماية من هجمات حجب الخدمة الموزعة (DDoS) عبر البنية التحتية لـ Cloudflare - توزيع الحمل جغرافيًا عبر التخزين المؤقت على الحافة - أداء أفضل للعملاء حول العالم\nمتطلبات التنفيذ: - تم تمكين الخيار --trustProxy في reseed-tools (مجموعة أدوات إعادة البذر) - تم تمكين وكيل Cloudflare لسجل DNS - معالجة ترويسة X-Forwarded-For بشكل صحيح\nاعتبارات مهمة: - تنطبق قيود منافذ Cloudflare (يجب استخدام المنافذ المدعومة) - يتطلب اتساق حزمة العميل نفسه دعم X-Forwarded-For - تتم إدارة تهيئة SSL/TLS بواسطة Cloudflare\nالتوثيق: https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/ استراتيجيات مقاومة للرقابة يُحدِّد بحثٌ أعدّه Nguyen Phong Hoang (USENIX FOCI 2019) أساليب تمهيد إضافية للشبكات الخاضعة للرقابة:\nمزودو التخزين السحابي Box, Dropbox, Google Drive, OneDrive: استضافة ملفات SU3 عبر روابط عامة الميزة: يصعب حظرها دون تعطيل الخدمات المشروعة العيب: يتطلب توزيع عناوين URL يدويًا إلى المستخدمين التوزيع عبر IPFS (نظام الملفات بين الكواكب) استضافة حزم إعادة البذر على InterPlanetary File System (نظام الملفات بين الكواكب) التخزين المعنون بالمحتوى يمنع التلاعب مقاوم لمحاولات الإزالة خدمات أونيون الخاصة بتور خوادم reseed (خوادم التهيئة الأولية للشبكة) متاحة عبر عناوين .onion مقاومة للحجب المعتمد على عناوين IP يتطلب وجود عميل Tor على نظام المستخدم وثائق البحث: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/ الدول المعروفة بحجب I2P اعتبارًا من عام 2025، تم التأكيد أن الدول التالية تحجب خوادم إعادة البذر لـ I2P: - الصين - إيران - عُمان - قطر - الكويت\nينبغي على المستخدمين في هذه المناطق استخدام أساليب تمهيد بديلة أو استراتيجيات إعادة بذر مقاومة للرقابة.\nتفاصيل البروتوكول للمنفذين مواصفة طلب Reseed (التمهيد الأولي للشبكة) سلوك العميل اختيار الخادم: Router يحافظ على قائمة ثابتة مُضمَّنة في الشيفرة لروابط reseed (إعادة البذر) الاختيار العشوائي: يختار العميل خادماً عشوائياً من القائمة المتاحة تنسيق الطلب: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: يجب أن يحاكي المتصفحات الشائعة (مثلاً، \u0026ldquo;Wget/1.11.4\u0026rdquo;) منطق إعادة المحاولة: إذا فشل طلب SU3، فارجع إلى تحليل صفحة الفهرس التحقق من الشهادة: تحقق من شهادة TLS بمقارنتها مع مخزن الثقة للنظام التحقق من توقيع SU3: تحقق من التوقيع بمقارنته مع شهادات reseed المعروفة سلوك الخادم اختيار الحزمة: اختيار مجموعة فرعية شبه عشوائية من RouterInfos (سجلات معلومات الـ router) من netDb تتبّع العملاء: تحديد الطلبات حسب عنوان IP المصدر (مع مراعاة X-Forwarded-For) اتساق الحزمة: إرجاع نفس الحزمة للطلبات المتكررة ضمن نافذة زمنية (عادةً 8-12 ساعة) تنوع الحزم: إرجاع حزم مختلفة لعملاء مختلفين لتحقيق تنوّع الشبكة نوع المحتوى: application/octet-stream أو application/x-i2p-reseed تنسيق ملف RouterInfo كل ملف .dat في حزمة reseed (إعادة البذر) يحتوي على بنية RouterInfo (معلومات Router):\nتسمية الملفات: routerInfo-{base64-hash}.dat - تتألف التجزئة من 44 حرفًا باستخدام أبجدية base64 الخاصة بـ I2P - مثال: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat\nمحتويات الملف: - RouterIdentity (router hash، مفتاح التشفير، مفتاح التوقيع) - الطابع الزمني للنشر - عناوين الـrouter (IP، المنفذ، نوع النقل) - قدرات الـrouter وخياراته - توقيع يغطي جميع البيانات أعلاه\nمتطلبات تنوع الشبكة لمنع مركزة الشبكة وتمكين الكشف عن هجوم Sybil (هجوم يعتمد على إنشاء هويات مزيفة متعددة):\nلا تفريغات NetDb كاملة: لا تُقدِّم جميع RouterInfos (معلومات Router) إلى عميل واحد أخذ عينات عشوائية: تحتوي كل حزمة على مجموعة فرعية مختلفة من الأقران المتاحين الحد الأدنى لحجم الحزمة: 75 RouterInfos (تمت زيادته من 50 في الأصل) الحد الأقصى لحجم الحزمة: 100 RouterInfos الحداثة: ينبغي أن تكون RouterInfos حديثة (خلال 24 ساعة من إنشائها) اعتبارات IPv6 الحالة الحالية (2025): - عدة خوادم reseed (خوادم التمهيد الأوّلي للشبكة) تُظهر عدم استجابة عبر IPv6 - ينبغي للعملاء تفضيل IPv4 أو فرضه من أجل الموثوقية - يُوصى بدعم IPv6 في عمليات النشر الجديدة، لكنه ليس أمراً حرجاً\nملاحظة تنفيذية: عند إعداد الخوادم ثنائية المكدس (dual-stack)، تأكد من أن عناوين الاستماع لكلٍّ من IPv4 وIPv6 تعمل بشكل صحيح، أو عطّل IPv6 إذا تعذّر دعمه بشكل صحيح.\nاعتبارات أمنية نموذج التهديد يحمي بروتوكول إعادة البذر من:\nهجمات الرجل في الوسط: تواقيع RSA-4096 تمنع العبث بالحزمة تقسيم الشبكة: تعدد خوادم إعادة البذر المستقلة يمنع وجود نقطة تحكم واحدة هجمات سيبيل: تنوع الحزم يحد من قدرة المهاجم على عزل المستخدمين الرقابة: تعدد الخوادم والطرق البديلة يوفر التكرار لا يحمي بروتوكول reseed (آلية الحصول على نقاط الاتصال الأولية) من:\nخوادم reseed (عملية التمهيد الأولية لاكتشاف نظراء شبكة I2P) المخترقة: إذا كان المهاجم يتحكم في المفاتيح الخاصة لشهادات reseed الحجب الكامل للشبكة: إذا تم حجب جميع طرق reseed في منطقة ما المراقبة طويلة الأمد: طلبات reseed تكشف عنوان IP الذي يحاول الانضمام إلى I2P إدارة الشهادات أمان المفتاح الخاص: - احتفظ بمفاتيح توقيع SU3 دون اتصال بالإنترنت عند عدم استخدامها - استخدم كلمات مرور قوية لتشفير المفاتيح - حافظ على نُسخ احتياطية آمنة للمفاتيح والشهادات - ضع في الاعتبار hardware security modules (HSMs) (وحدات أمن الأجهزة) لعمليات النشر عالية القيمة\nإلغاء الشهادات: - توزيع قوائم إلغاء الشهادات (CRLs) عبر موجز الأخبار - يمكن للمنسّق إلغاء الشهادات المخترَقة - Routers تحدّث CRLs تلقائيًا مع تحديثات البرمجيات\nالتخفيف من الهجمات الحماية من هجمات الحرمان من الخدمة الموزعة (DDoS): - قواعد fail2ban للطلبات المفرطة - تحديد معدل الطلبات على مستوى خادم الويب - تحديد عدد الاتصالات لكل عنوان IP - Cloudflare أو شبكة توصيل المحتوى (CDN) مماثلة كطبقة إضافية\nمنع الكشط: - حزم مختلفة لكل عنوان IP مُطلِب - تخزين مؤقت للحزم قائم على الوقت لكل عنوان IP - تسجيل أنماط تشير إلى محاولات الكشط - التنسيق مع المشغّلين الآخرين بشأن الهجمات المُكتشَفة\nالاختبار والتحقق من الصحة اختبار خادم إعادة البذر الخاص بك الطريقة 1: تثبيت Router جديد ثبّت I2P على نظام نظيف أضف رابط reseed (إعادة البذر: تمهيد الاتصال الأولي بالشبكة) إلى الإعدادات أزِل أو عطّل روابط reseed الأخرى شغّل الـ router وراقب السجلات للتأكد من نجاح reseed تحقّق من الاتصال بالشبكة خلال 5–10 دقائق مخرجات السجل المتوقعة:\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received الطريقة 2: التحقق اليدوي من SU3 # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) الطريقة 3: مراقبة checki2p تقوم الخدمة على https://checki2p.com/reseed بإجراء فحوصات آلية كل 4 ساعات على جميع خوادم reseed الخاصة بـ I2P (خوادم التمهيد الأولي) المسجّلة. يوفّر ذلك:\nمراقبة التوفر مقاييس زمن الاستجابة التحقق من صحة شهادة TLS التحقق من صحة توقيع SU3 بيانات مدة التشغيل التاريخية بمجرد تسجيل reseed (خادم التمهيد الأولي لشبكة I2P) الخاص بك لدى مشروع I2P، سيظهر تلقائيًا على checki2p خلال 24 ساعة.\nاستكشاف المشكلات الشائعة وإصلاحها المشكلة: \u0026ldquo;Unable to read signing key\u0026rdquo; عند التشغيل لأول مرة - الحل: هذا متوقع. أجب بـ \u0026lsquo;y\u0026rsquo; لإنشاء مفاتيح جديدة.\nالمشكلة: Router يفشل في التحقق من التوقيع - السبب: الشهادة غير موجودة في مخزن الثقة الخاص بالـ router - الحل: ضع الشهادة في الدليل ~/.i2p/certificates/reseed/\nالمشكلة: تسليم نفس الحزمة لعملاء مختلفين - السبب: ترويسة X-Forwarded-For لا تُمرَّر بالشكل الصحيح - الحل: فعّل --trustProxy وقم بتهيئة ترويسات الوكيل العكسي\nالمشكلة: \u0026ldquo;تم رفض الاتصال\u0026rdquo; - السبب: المنفذ غير قابل للوصول من الإنترنت - الحل: تحقق من قواعد جدار الحماية، وتأكد من إعدادات إعادة توجيه المنفذ\nIssue: استهلاك مرتفع لوحدة المعالجة المركزية أثناء إعادة بناء الحزمة - Cause: سلوك طبيعي عند توليد 350+ تنويعات SU3 (تنسيق ملف التحديث في I2P) - Solution: احرص على توفر موارد كافية لوحدة المعالجة المركزية، وفكّر في تقليل وتيرة إعادة البناء\nمعلومات مرجعية التوثيق الرسمي دليل المساهمين في Reseed (خدمة تمهيد الشبكة): /guides/creating-and-running-an-i2p-reseed-server/ متطلبات سياسة Reseed: /guides/reseed-policy/ مواصفة SU3: /docs/specs/updates/ مستودع أدوات Reseed: https://i2pgit.org/idk/reseed-tools وثائق أدوات Reseed: https://eyedeekay.github.io/reseed-tools/ تنفيذات بديلة PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Python WSGI reseeder (خادم لإعادة البذر): https://github.com/torbjo/i2p-reseeder موارد المجتمع منتدى I2P: https://i2pforum.net/ مستودع Gitea: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: #i2p-dev على IRC2P مراقبة الحالة: https://checki2p.com/reseed سجل الإصدارات 0.9.14 (2014): تم تقديم تنسيق SU3 لعملية reseed (جلب بيانات التمهيد للشبكة) 0.9.16 (2014): إضافة reseeding القائم على الملفات 0.9.42 (2019): اشتراط معلمة الاستعلام Network ID 2.0.0 (2022): تم تقديم بروتوكول النقل SSU2 2.4.0 (2024): عزل NetDB وتحسينات أمنية 2.6.0 (2024): حظر اتصالات I2P-over-Tor 2.10.0 (2025): الإصدار المستقر الحالي (اعتبارًا من سبتمبر 2025) مرجع نوع التوقيع Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 **معيار reseed (عملية التهيئة الأولية للشبكة)**: النوع 6 (RSA-SHA512-4096) مطلوب لحزم reseed. التقدير شكرًا لكل مشغّل reseed (خدمة التمهيد الأوّلي لشبكة I2P) على إبقاء الشبكة متاحة وقادرة على الصمود. تقدير خاص للمساهمين والمشاريع التالية:\nzzz: مطوّر مخضرم في I2P ومنسّق reseed (التمهيد الأوّلي للشبكة) idk: المشرف الحالي على reseed-tools ومدير الإصدارات Nguyen Phong Hoang: أبحاث حول استراتيجيات reseeding المقاومة للرقابة PurpleI2P Team: تنفيذات بديلة لـ I2P وأدوات checki2p: خدمة مراقبة آلية للبنية التحتية الخاصة بـ reseed تمثل البنية التحتية اللامركزية لإعادة البذر (reseed) لشبكة I2P جهداً تعاونياً يبذله عشرات المشغلين حول العالم، مما يضمن أن يتمكن المستخدمون الجدد دائماً من العثور على مسار للانضمام إلى الشبكة بغض النظر عن الرقابة المحلية أو العوائق التقنية.\n","description":"تشغيل خدمات reseed (إمداد بيانات التمهيد الأولي) وطرق bootstrap البديلة (التمهيد الأولي)","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"مضيفو Reseed (إعادة البذر)","url":"/ar/docs/misc/reseed/"},{"categories":null,"content":"جهة الاتصال الأمنية للإبلاغ عن ثغرات أمنية أو مشكلات أمنية حساسة، يرجى الاتصال بفريق الأمان في I2P على security@i2p.net للاتصال الآمن، يرجى استخدام مفتاح PGP الخاص بنا أدناه.\nمعلومات مفتاح PGP البريد الإلكتروني: security@i2p.net معرف المفتاح: 176E1941 البصمة: 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 نوع المفتاح: RSA 4096-bit تاريخ الإنشاء: 2025-10-19 تاريخ انتهاء الصلاحية: 2030-11-19 معرف المستخدم: I2P Security \u0026lt;security@i2p.net\u0026gt; المفتاح العام فيما يلي مفتاح GPG العام لفريق أمان I2P: \u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nmQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"مفتاح GPG العام للاتصال بفريق أمن I2P","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"مفتاح GPG الأمني","url":"/ar/docs/develop/security-key/"},{"categories":null,"content":" الإصدارات 0.9.57 وما بعدها موقعة بواسطة idk. مفتاحه العام الحالي هو: تحميل المفتاح العام PGP الإصدارات 0.7.6 و 0.9.56 موقعة من قبل zzz. مفتاحه العام الحالي هو: تحميل المفتاح العام PGP -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 لقد أنشأت مفاتيح GPG جديدة ومفاتيح فرعية ووقعت المفاتيح الجديدة بالمفتاح القديم.\nالمفاتيح القديمة:\npub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) \u0026lt;zzz@mail.i2p\u0026gt; sub 2048g/74C8122D 2005-12-16 المفاتيح الجديدة:\npub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) \u0026lt;zzz@mail.i2p\u0026gt; uid zzz on i2p (key signing) \u0026lt;zzz@i2pmail.org\u0026gt; sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07] سأستخدم المفاتيح الجديدة كما يلي:\nEE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing سيتم استخدام مفتاح التوقيع الخاص بالإصدار بدءًا من الإصدار 0.9.13. هذه الرسالة موقعة بمفتاحي القديم.\nzzz 25 مايو 2014\nالمفاتيح الجديدة كما يلي:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.14 (GNU/Linux)\nmQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dpXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHp\niEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; الإصدارات من 0.9.9 يمكن أن تكون موقعة من قبل str4d. مفتاحه العام الحالي هو: -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 مفاتيحي العامة الحالية هي كما يلي:\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [تنتهي: 2019-03-10] uid [ كامل ] str4d (http://str4d.i 2p) str4d@mail.i2p uid [ كامل ] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [منتهية: 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [منتهية: 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [تنتهي: 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [تنتهي: 2016-04-04]\nأستخدم حالياً المفاتيح على النحو التالي:\nA94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing أقوم بإنشاء مفاتيح فرعية جديدة للتشفير والتوقيع سنوياً. أي إصدار من I2P موقّع من قبلي سيكون دائماً موقعاً بأحدث مفتاح فرعي للتوقيع في وقت الإصدار.\nstr4d 20 نوفمبر، 2015\nالمفاتيح الحالية (اعتبارًا من التاريخ أعلاه) كما يلي:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z\niQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d وقّع على الإصدارات التالية: 0.9.23 الإصدارات من 0.7.6 إلى 0.9.12 تم توقيعها بواسطة zzz باستخدام المفتاح التالي: -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enop IDx6enpAbWFpbC5pMnA+iF8EExECAB8FAkOjTnUCGwMGCwkIBwMCBBUCCAMDFgIB Ah4BAheAAAoJEEFVdrqnbgvtxGsAn39SvQ3+ey87WDDG+TWArN6oU8gnAJ4zeAsA LUK37WZIt8OImZSxk37uQbkCDQRDo06VEAgAy2UeqsM5a+U6ZOWS9NQiILb3KbTL FeeAd2rn9oLSLpn5gDWycwUS0Q62JmbSMWy6m9aczpnxvwaBYXz6aCIvZmTNtaU6 vyR/6wfJDyiUWSHtCyjpyFFYJimANd8Y8dDCimvceI/ihEDVyBX0kkgUGRAn8t3e unaLXqhbfiLiFw/GG1MNxUMzHt55/+9AqLOfRZg0riZvDoV79K+1sYSs8n1WeaVc T3wTb+Cb7fKNN7GT1MUhcXIoYYY6FGwsy5EWFsxYBRervqHtBJog2SoNUa/6BFGr zX+LDjK9L3xMTr3+fHIt4gPR/Lt4nnfEzL+rjClz/Fazmv38BRwPuKahFwADBQgA nD/AvZCnbWSB6khAVMqva5ROaD0gV0/UejCelZdYfgfHeCmrcMNQ+wCyww2NPsih 9vB1w+AUE0pdH37k65VZN+2falUdzN+PFugJGuH2pmlVOprH2SuC5gKpGRvzUqV5 U0nJmT2okDpW/52asUDJJLu1g//A3qBP83WGvSKUZg/ZisZA0qTiHH4QpjklopXi sSxR2hT8Fr9gF9WmDa09wbxE2xh/EL7gvVg/vk0gwOJcsFd67bNC+KUMOnjhOP0T K0/Ah4TEEs/hHNe9RsyyWlMoIUsF8AhG71ISOrJ5lLSXNe151XEb5FzZRM8sD9Zq 0E3PjmLbdVhanYvsPnWK6YhJBBgRAgAJBQJDo06VAhsMAAoJEEFVdrqnbgvtXTwA njMu9ueCFbsjme7nwsz96PdazJcHAKCce17hGI25QNXDZyHohrjha6IxDg== =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nالإصدارات من 0.6.1.31 إلى 0.7.5 تم توقيعها بواسطة Complication. مفتاحه العام هو: \u0026mdash;\u0026ndash;BEGIN PGP SIGNED MESSAGE\u0026mdash;\u0026ndash; Hash: SHA1\nمرحباً،\nأشهد أن المفتاح العام الجديد أدناه، صادر بتاريخ 2007-11-24، صالح حتى 2009-11-23، وبصمة المفتاح الخاصة به هي:\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\nإذا كان لديك مفتاحي العام القديم، واستخدمته للتحقق من هذا، ستلاحظ أن مفتاحي القديم انتهت صلاحيته في 2007-11-15. أعتذر عن التأخر في هذا التحديث.\nبالنسبة للأشخاص الذين يرغبون في نسخ المفتاح مباشرة من هذه الرسالة، ولكنهم لا يقرؤون هذا باستخدام برنامج بريد إلكتروني، يرجى تذكر حذف تسلسلات الهروب \u0026ldquo;- \u0026quot; من علامة البداية والنهاية لكتلة المفتاح العام. وإلا فلن يتم التعرف عليه.\nتعقيد.\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; الإصدار: GnuPG v1.4.7 (GNU/Linux)\nmQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK - \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\niD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"مفاتيح PGP المستخدمة لتوقيع إصدارات I2P وأين يمكن الحصول عليها","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"مفتاح توقيع الإصدار","url":"/ar/docs/develop/release-signing-key/"},{"categories":null,"content":"ما هو I2P؟ مشروع الإنترنت الخفي (I2P) هو طبقة شبكة مجهولة تتيح اتصالات نظير إلى نظير مقاومة للرقابة. يتم تحقيق الاتصالات المجهولة من خلال تشفير بيانات المستخدم وإرسالها عبر شبكة موزعة يديرها متطوعون حول العالم.\nالميزات الرئيسية Anonymity يخفي I2P كلاً من مرسل ومستقبل الرسائل. على عكس اتصالات الإنترنت التقليدية حيث يكون عنوان IP الخاص بك مرئياً للمواقع والخدمات، يستخدم I2P طبقات متعددة من التشفير والتوجيه للحفاظ على خصوصية هويتك.\nDecentralization لا توجد سلطة مركزية في I2P. يتم صيانة الشبكة من قبل متطوعين يتبرعون بعرض النطاق الترددي والموارد الحاسوبية. وهذا يجعلها مقاومة للرقابة ونقاط الفشل الفردية.\nعدم الكشف عن الهوية جميع الاتصالات داخل I2P مشفرة من طرف إلى طرف. يتم تشفير الرسائل عدة مرات أثناء مرورها عبر الشبكة، بشكل مشابه لطريقة عمل Tor ولكن مع اختلافات مهمة في التنفيذ.\nHow It Works اللامركزية يستخدم I2P \u0026ldquo;الأنفاق\u0026rdquo; (tunnels) لتوجيه حركة المرور. عندما ترسل أو تستقبل البيانات:\nينشئ الموجّه الخاص بك نفقًا صادرًا (للإرسال) ينشئ الموجّه الخاص بك نفقًا واردًا (للاستقبال) يتم تشفير الرسائل وإرسالها عبر عدة موجّهات (routers) كل موجّه يعرف فقط القفزة السابقة والقفزة التالية، وليس المسار الكامل التشفير من طرف إلى طرف يُحسّن I2P من التوجيه البصلي التقليدي باستخدام \u0026ldquo;garlic routing\u0026rdquo;:\nيمكن تجميع عدة رسائل معًا (مثل فصوص الثوم في رأس الثوم) يوفر هذا أداءً أفضل وإخفاء هوية إضافي يجعل تحليل حركة المرور أكثر صعوبة Network Database يحتفظ I2P بقاعدة بيانات شبكة موزعة تحتوي على:\nمعلومات الموجه (Router) عناوين الوجهات (مشابهة لمواقع i2p.) بيانات التوجيه المشفرة Common Use Cases الأنفاق (Tunnels) استضف أو قم بزيارة المواقع التي تنتهي بـ .i2p - هذه المواقع يمكن الوصول إليها فقط داخل شبكة I2P وتوفر ضمانات قوية لإخفاء الهوية لكل من المستضيفين والزوار.\nالتوجيه بواسطة Garlic شارك الملفات بشكل مجهول باستخدام BitTorrent عبر I2P. العديد من تطبيقات التورنت تحتوي على دعم I2P مدمج.\nقاعدة بيانات الشبكة أرسل واستقبل البريد الإلكتروني المجهول باستخدام I2P-Bote أو تطبيقات البريد الإلكتروني الأخرى المصممة لـ I2P.\nMessaging استخدم IRC، أو المراسلة الفورية، أو أدوات الاتصال الأخرى بشكل خاص عبر شبكة I2P.\nGetting Started هل أنت مستعد لتجربة I2P؟ تحقق من صفحة التنزيلات لتثبيت I2P على نظامك.\nللحصول على تفاصيل تقنية أكثر، راجع المقدمة التقنية أو استكشف الوثائق الكاملة.\nكيف يعمل مقدمة تقنية - مفاهيم تقنية أعمق نموذج التهديدات - فهم النموذج الأمني لـ I2P مقارنة مع Tor - كيف يختلف I2P عن Tor التشفير - تفاصيل حول خوارزميات التشفير في I2P ","description":"مقدمة أقل تقنية لشبكة I2P المجهولة","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"مقدمة إلى I2P","url":"/ar/docs/overview/intro/"},{"categories":null,"content":" مهمل: تسبق مكتبة ministreaming مكتبة التدفق الحالية. يجب على التطبيقات الحديثة استخدام واجهة برمجة تطبيقات التدفق الكاملة أو SAM v3. تُحتفظ المعلومات أدناه لأجل المطورين الذين يراجعون الشفرة المصدرية القديمة الموزعة ضمن ministreaming.jar.\nنظرة عامة Ministreaming (بروتوكول تدفّق مصغّر) يعمل فوق I2CP لتوفير تسليم موثوق ومتسلسل عبر طبقة الرسائل الخاصة بـ I2P—على غرار TCP فوق IP. وقد جرى في الأصل فصله عن التطبيق المبكّر I2PTunnel (مرخّص بـ BSD) لكي تتمكّن بروتوكولات النقل البديلة من التطوّر بشكل مستقل.\nالقيود الرئيسية للتصميم:\nتهيئة اتصال كلاسيكية ثنائية الطور (SYN/ACK/FIN) مقتبسة من TCP (بروتوكول التحكّم بالنقل) حجم نافذة ثابت بمقدار 1 حزمة لا معرّفات لكل حزمة ولا إقرارات انتقائية لقد أبقت هذه الخيارات التنفيذ خفيفًا لكنها تحدّ من معدل النقل—إذ تنتظر كل حزمة عادةً ما يقارب زمنَي RTT (وقت الرحلة ذهابًا وإيابًا) قبل إرسال التالية. بالنسبة للتدفقات طويلة العمر تكون هذه الكلفة مقبولة، لكن التبادلات القصيرة على نمط HTTP تعاني بشكل ملحوظ.\nالعلاقة بمكتبة البث تستمر مكتبة البث الحالية ضمن نفس حزمة Java (net.i2p.client.streaming). تبقى الأصناف والطرائق الموقوفة في Javadocs (توثيق جافا)، معلّمة بوضوح بحيث يستطيع المطوّرون التعرّف على واجهات برمجة التطبيقات (APIs) الخاصة بحقبة ministreaming (مكتبة البث المصغّرة القديمة). عندما حلّت مكتبة البث محل ministreaming أضافت:\nإعداد اتصال أكثر ذكاءً مع عدد أقل من جولات الذهاب والإياب نوافذ ازدحام تكيفية ومنطق إعادة إرسال تكيفي أداء أفضل عبر tunnels عالية الفقد متى كان Ministreaming (التدفق المُصغّر) مفيدًا؟ على الرغم من حدوده، قدّم ministreaming (آلية بث مصغّرة) نقلًا موثوقًا في عمليات النشر المبكرة. صُمّمت واجهة برمجة التطبيقات عمدًا لتكون صغيرة ومهيأة للمستقبل بحيث يمكن تبديل محركات بث بديلة دون كسر التوافق مع المستدعين. ربطته تطبيقات Java مباشرةً؛ أما العملاء غير Java فوصلوا إلى الوظائف نفسها عبر دعم SAM لجلسات البث.\nاليوم، تعامل مع ministreaming.jar على أنه طبقة توافق فقط. على التطوير الجديد أن:\nاستهدف مكتبة البث الكاملة (Java) أو SAM v3 (نمط STREAM) أزل أي افتراضات عالقة حول نافذة ثابتة عند تحديث الشيفرة فضّل أحجام نوافذ أكبر ومصافحات اتصال محسّنة لتحسين أعباء العمل الحساسة لزمن الاستجابة مرجع توثيق مكتبة البث وثائق Javadoc للبث – يتضمن أصناف ministreaming (واجهة بث مصغّرة قديمة) المهملة مواصفة SAM v3 – دعم البث للتطبيقات غير المكتوبة بلغة Java إذا صادفت شيفرة لا تزال تعتمد على ministreaming (آلية قديمة للتدفق المصغّر)، فخطط لترحيلها إلى الـ streaming API الحديثة (واجهة برمجة تطبيقات للتدفق)—فالشبكة وأدواتها تتوقع السلوك الأحدث.\n","description":"ملاحظات تاريخية حول أول طبقة نقل شبيهة بـ TCP الخاصة بـ I2P","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"مكتبة Ministreaming","url":"/ar/docs/legacy/ministreaming/"},{"categories":null,"content":"مناقشة NTCP مقابل SSU (مارس 2007) أسئلة حول NTCP (بروتوكول النقل عبر TCP في I2P) مقتبس من محادثة على IRC بين zzz و cervantes.\nلماذا يحظى NTCP بالأولوية على SSU بينما يبدو أن NTCP يضيف عبئاً إضافياً وكموناً؟\nيوفّر NTCP عموماً موثوقية أفضل من التنفيذ الأصلي لـ SSU. هل يصطدم التدفق عبر NTCP بمشكلة TCP-over-TCP collapse (انهيار TCP فوق TCP) الكلاسيكية؟\nربما، لكن كان المقصود من SSU أن يكون خيار UDP خفيفاً، وقد اتضح في الممارسة أنه غير موثوق بما يكفي. “NTCP يُعتبر ضارًا” (zzz، 25 مارس 2007) الملخص: قد يؤدي ارتفاع زمن الاستجابة والحمولة الإضافية في NTCP إلى حدوث ازدحام، ومع ذلك تفضّل آلية التوجيه NTCP لأن bid scores (قيم العطاء المستخدمة للمفاضلة) فيه مضبوطة برمجياً بشكل ثابت لتكون أدنى من SSU. وقد أثار التحليل عدة نقاط:\nحالياً يُقدّم NTCP عرضاً أقل من SSU، لذا تُفضّل routers NTCP ما لم تكن هناك جلسة SSU قائمة بالفعل. ينفّذ SSU الإقرارات بمُهلات محكومة بإحكام وبإحصاءات؛ بينما يعتمد NTCP على Java NIO TCP مع مُهلات على طراز RFC قد تكون أطول بكثير. معظم الحركة (HTTP وIRC وBitTorrent) تستخدم مكتبة البث الخاصة بـ I2P، ما يعني فعلياً تكديس TCP فوق NTCP. عندما تُعيد الطبقتان الإرسال، قد يحدث انهيار ازدحام. تشمل المراجع الكلاسيكية TCP over TCP is a bad idea . زادت مُهلات مكتبة البث من 10 ثوانٍ إلى 45 ثانية في الإصدار 0.8؛ الحد الأقصى لمهلة SSU هو 3 ثوانٍ، بينما يُفترض أن تقترب مُهلات NTCP من 60 ثانية (توصية RFC). يصعب فحص معلمات NTCP خارجياً. أظهرت ملاحظات ميدانية في 2007 تذبذب إنتاجية الرفع في i2psnark، ما يوحي بحدوث انهيار ازدحام دوري. اختبارات الكفاءة (بفرض تفضيل SSU) خفّضت نسب الحمل الإضافي لـ tunnel من نحو 3.5:1 إلى 3:1 وحسّنت مقاييس البث (حجم النافذة، RTT، نسبة الإرسال/الإقرار). مقترحات من موضوع عام 2007 عكس أولويات النقل بحيث تُفضّل routers بروتوكول SSU (مع استعادة i2np.udp.alwaysPreferred). وسم حركة مرور التدفق بحيث يُخفض SSU عروضه فقط للرسائل الموسومة، دون المساس بإخفاء الهوية. تشديد حدود إعادة الإرسال في SSU لتقليل خطر الانهيار. دراسة الطبقات التحتية شبه الموثوقة لتحديد ما إذا كانت عمليات إعادة الإرسال أسفل مكتبة التدفق تحقق فائدة صافية. مراجعة طوابير الأولوية والمهلات الزمنية—على سبيل المثال، زيادة مهلات التدفق إلى ما بعد 45 ثانية للتوافق مع NTCP. رد من jrandom (27 مارس 2007) الحجج المضادّة الرئيسية:\nيوجد NTCP لأن عمليات نشر SSU المبكرة عانت انهيار الازدحام. حتى معدلات إعادة الإرسال المتواضعة لكل قفزة قد تتفاقم بشكل كبير عبر tunnels متعددة القفزات. من دون إقرارات على مستوى tunnel، لا تحصل إلا نسبة من الرسائل على حالة تسليم طرف-إلى-طرف؛ وقد تكون الإخفاقات صامتة. يمتلك التحكم في ازدحام TCP تحسينات راكمها عبر عقود؛ ويستفيد NTCP من ذلك عبر مكدسات TCP الناضجة. قد تعكس مكاسب الكفاءة الملحوظة عند تفضيل SSU سلوك الاصطفاف في router بدلاً من مزايا جوهرية للبروتوكول. كانت streaming timeouts (مهلات البث) الأكبر تُحسِّن الاستقرار بالفعل؛ وشُجِّع إجراء مزيد من الرصد وجمع البيانات قبل إدخال تغييرات كبرى. أسهم النقاش في صقل ضبط بروتوكولات النقل اللاحق، لكنه لا يعكس المعمارية الحديثة لـ NTCP2/SSU2.\n","description":"ملاحظات تاريخية تقارن بين بروتوكولات النقل NTCP وSSU وأفكار مقترحة للضبط","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"مناقشة NTCP (بروتوكول نقل قائم على TCP في I2P)","url":"/ar/docs/ntcp/"},{"categories":null,"content":" ملاحظة: يوثق هذا الأرشيف أعمال تصميم تخمينية تسبق I2P 0.9.41. وللتنفيذ الإنتاجي، راجع وثائق tunnel .\nبدائل التهيئة الأفكار التي أُخذت في الاعتبار لخيارات ضبط tunnel المستقبلية شملت:\nمحددات المعدّل لإيصال الرسائل سياسات الحشو (بما في ذلك chaff injection (حقن بيانات تمويهية)) ضوابط عمر tunnel استراتيجيات الدُفعات والطوابير لتوزيع الحمولة لم تكن أي من هذه الخيارات مضمّنة في التنفيذ القديم.\nاستراتيجيات الحشو المقاربات المحتملة للحشو التي نوقشت:\nمن دون أي حشو إطلاقاً حشو بطول عشوائي حشو بطول ثابت حشو إلى أقرب كيلوبايت حشو إلى قوى العدد اثنين (2^n بايت) أدّت القياسات المبكرة (الإصدار 0.4) إلى تحديد حجم رسالة tunnel الثابت الحالي البالغ 1024 بايت. قد تضيف رسائل garlic (أسلوب لتجميع الرسائل في I2P) ذات المستوى الأعلى حشواً خاصاً بها.\nالتجزئة لمنع هجمات الوسم عبر طول الرسالة، تكون رسائل tunnel ثابتة عند 1024 بايت. تتم تجزئة حمولات I2NP الأكبر بواسطة البوابة؛ وتقوم نقطة النهاية بإعادة تجميع الأجزاء خلال مهلة زمنية قصيرة. قد تقوم Routers بإعادة ترتيب الأجزاء لتعظيم كفاءة التعبئة قبل الإرسال.\nبدائل أخرى تعديل معالجة Tunnel في منتصف المسار تمت دراسة ثلاثة احتمالات:\nالسماح لقفزة وسيطة بإنهاء الـtunnel مؤقتاً عبر منح إمكانية الوصول إلى الحمولات التي فُكّ تشفيرها. السماح للـrouters المشاركة بـ“إعادة مزج” الرسائل بإرسالها عبر أحد الـtunnels الصادرة الخاصة بها قبل المتابعة إلى القفزة التالية. تمكين منشئ الـtunnel من إعادة تعريف القفزة التالية لنظير بشكل ديناميكي. Tunnels ثنائية الاتجاه إن استخدام tunnels الواردة والصادرة المنفصلة يقيّد مقدار المعلومات التي يمكن لأي مجموعة واحدة من الأقران الاطلاع عليها (مثلًا: طلب GET مقابل استجابة كبيرة). تُبسّط tunnels ثنائية الاتجاه إدارة الأقران لكنها تكشف أنماط حركة المرور كاملةً لكلا الاتجاهين في وقت واحد. لذلك بقي تصميم tunnels أحادية الاتجاه هو المفضّل.\nالقنوات الخلفية والأحجام المتغيرة إن السماح بأحجام رسائل tunnel متغيرة قد يتيح قنوات خفية بين نظراء متواطئين (مثل ترميز البيانات عبر أحجام أو ترددات مختارة). تخفف الرسائل ثابتة الحجم هذا الخطر على حساب عبء حشو إضافي.\nبدائل إنشاء Tunnel مرجع: Hashing it out in Public أسلوب البناء «المتوازي» القديم قبل الإصدار 0.6.1.10، كانت طلبات بناء tunnel تُرسل بالتوازي إلى كل مشارك. هذه الطريقة موثقة في صفحة tunnel القديمة .\nالبناء التلسكوبي لمرة واحدة (الطريقة الحالية) النهج الحديث يرسل رسائل البناء قفزةً تلو أخرى عبر الـ tunnel قيد البناء جزئياً. وعلى الرغم من تشابهه مع telescoping الخاص بـ Tor (أسلوب بناء المسار تدريجياً)، فإن توجيه رسائل البناء عبر tunnels الاستكشافية يقلّل من تسرّب المعلومات.\n“تفاعلي” Telescoping (التمديد التلسكوبي) إن بناء قفزة واحدة في كل مرة مع جولات ذهاباً وإياباً صريحة يمكّن الأقران من عدّ الرسائل واستنتاج موضعهم داخل الـ tunnel، لذا رُفض هذا النهج.\nTunnels الإدارية غير الاستكشافية كان أحد المقترحات هو الحفاظ على مجموعة منفصلة من tunnels الإدارية لحركة المرور الخاصة ببناء الـtunnels. وعلى الرغم من أنه قد يساعد routers المعزولة، فقد اعتُبر غير ضروري مع تكامل شبكي كافٍ.\nالتسليم الاستكشافي (قديم) قبل 0.6.1.10، كانت طلبات tunnel الفردية تُشفَّر باستخدام garlic encryption وتُنقَل عبر tunnels استكشافية، مع عودة الردود بشكل منفصل. وقد استُبدلت هذه الاستراتيجية بالنهج الحالي one-shot telescoping method (طريقة تلسكوبية أحادية الخطوة).\nأهم النقاط رسائل tunnel ثابتة الحجم تحمي من الوسم القائم على الحجم والقنوات الخفية، رغم تكلفة الحشو الإضافية. تم استكشاف بدائل للحشو والتجزئة واستراتيجيات البناء، لكنها لم تُعتمد عند موازنتها مقابل مقايضات إخفاء الهوية. يواصل تصميم tunnel الموازنة بين الكفاءة وقابلية الرصد ومقاومة هجمات السلف والازدحام. ","description":"استكشاف تاريخي لحشو tunnel، والتجزئة، واستراتيجيات الإنشاء","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"مناقشة Tunnel","url":"/ar/docs/legacy/tunnel/"},{"categories":null,"content":" السياق: تؤرشف هذه الصفحة نقاشات طويلة الأمد من الحقبة المبكرة لتصميم I2P. وهي توضّح لماذا فضّل المشروع دفاتر عناوين موثوقة محليًا على عمليات البحث على غرار DNS أو السجلات القائمة على تصويت الأغلبية. للحصول على إرشادات الاستخدام الحالية، راجع وثائق التسمية .\nبدائل مستبعدة تستبعد الأهداف الأمنية لـ I2P مخططات التسمية المألوفة:\nحلّ الأسماء بأسلوب DNS. يمكن لأي محلّل أسماء على مسار الاستعلام أن يزوّر الإجابات أو يفرض رقابة عليها. حتى مع DNSSEC، يظلّ مسجّلو النطاقات أو سلطات الشهادات المخترَقة نقطة فشل وحيدة. في I2P، الوجهات هي مفاتيح عامة—واختطاف عملية الاستعلام سيؤدي إلى اختراق الهوية بالكامل. التسمية المعتمدة على التصويت. يمكن لخصمٍ أن ينشئ هويات غير محدودة (Sybil attack — هجوم سيبيل) وأن \u0026ldquo;يفوز\u0026rdquo; بالأصوات للأسماء الشائعة. تخفيفات إثبات العمل ترفع الكلفة لكنها تفرض عبئاً ثقيلاً على التنسيق. بدلاً من ذلك، تحافظ I2P عمداً على التسمية فوق طبقة النقل. توفّر مكتبة التسمية المرفقة واجهة مزوّد خدمة تتيح لمخططات تسمية بديلة أن تتعايش—ويقرّر المستخدمون أيّ دفاتر عناوين أو خدمات قفز يثقون بها.\nالأسماء المحلية مقابل الأسماء العالمية (jrandom، 2005) الأسماء في I2P فريدة محليًا لكنها مقروءة للبشر. قد لا يتطابق boss.i2p الخاص بك مع boss.i2p الخاص بشخص آخر، وهذا مقصود في التصميم. إذا خدعتك جهة خبيثة لتغيير الوجهة وراء اسم ما، فستتمكن فعليًا من اختطاف خدمة. عدم فرض التفرد العالمي يمنع ذلك النوع من الهجمات. تعامل مع الأسماء كأنها إشارات مرجعية أو أسماء مستعارة في التراسل الفوري—أنت من يختار الوجهات التي يثق بها عبر الاشتراك في دفاتر عناوين محددة أو إضافة المفاتيح يدويًا. الاعتراضات الشائعة والردود (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. ## مناقشة أفكار تحسين الكفاءة قدّم تحديثات تدريجية (فقط الوجهات التي أضيفت منذ آخر جلب). وفّر خلاصات إضافية (recenthosts.cgi) إلى جانب ملفات hosts الكاملة. استكشف أدوات قابلة للبرمجة النصية (على سبيل المثال، i2host.i2p) لدمج الخلاصات أو التصفية حسب مستويات الثقة. أبرز النقاط يتفوّق الأمان على الإجماع العالمي: تقلّل دفاتر العناوين المنسّقة محليًا من مخاطر الاختطاف. يمكن لأساليب تسمية متعددة أن تتعايش عبر واجهة برمجة تطبيقات التسمية—والمستخدمون يقررون ما يثقون به. لا يزال نظام تسمية عالمي لامركزي بالكامل مسألة بحثية مفتوحة؛ ولا تزال المفاضلات بين الأمان، وسهولة التذكّر البشري، والتفرّد العالمي تعكس مثلث زوكو . المراجع وثائق التسمية «الأسماء: لامركزية، آمنة، ذات معنى بشري: اختر اثنين» لزوكو عينة خلاصة تزايدية: stats.i2p/cgi-bin/newhosts.txt ","description":"الجدل التاريخي حول نموذج التسمية الخاص بـ I2P ولماذا رُفضت المخططات الشبيهة بـ DNS عالميًا","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"مناقشة التسمية","url":"/ar/docs/legacy/naming/"},{"categories":null,"content":" ملاحظة: يوجز هذا النقاش المؤرشف الأساليب التاريخية لقاعدة بيانات الشبكة (netDb). راجع وثائق netDb الرئيسية للاطلاع على السلوك الحالي والإرشادات.\nالتاريخ توزَّع netDb الخاصة بـ I2P باستخدام خوارزمية floodfill بسيطة. احتفظت الإصدارات الأولى أيضاً بتنفيذ لـ Kademlia DHT كخيار احتياطي، لكنه ثبت أنه غير موثوق وتم تعطيله تماماً في الإصدار 0.6.1.20. يقوم تصميم floodfill بتمرير إدخال منشور إلى router مشارك، وينتظر التأكيد، ثم يعاود المحاولة مع أقران floodfill الآخرين عند الضرورة. يقوم أقران floodfill ببث رسائل التخزين القادمة من routers غير المشاركة في floodfill إلى كل مشارك آخر في floodfill.\nفي أواخر عام 2009، أُعيد إدخال عمليات استعلام Kademlia (خوارزمية DHT موزعة) جزئياً لتقليل عبء التخزين على كل floodfill router على حدة.\nمقدمة حول Floodfill ظهرت Floodfill لأول مرة في الإصدار 0.6.0.4 بينما ظل Kademlia (خوارزمية جدول تجزئة موزع DHT) متاحًا كخيار احتياطي. في ذلك الوقت، جعل فقدان الحزم المرتفع والمسارات المقيّدة من الصعب الحصول على تأكيدات الاستلام من أقرب أربعة أقران، وكان الأمر يتطلّب في كثير من الأحيان عشرات محاولات التخزين الزائدة عن الحاجة. وقدّم الانتقال إلى مجموعة فرعية بنمط floodfill من routers القابلة للوصول من الخارج حلاً عمليًا قصير الأجل.\nإعادة التفكير في Kademlia (بروتوكول جداول التجزئة الموزعة DHT) شملت بعض البدائل التي أُخذت في الاعتبار:\nتشغيل netDb بوصفه Kademlia DHT (جدول تجزئة موزع Kademlia) يقتصر على routers القابلة للوصول التي تختار المشاركة الإبقاء على نموذج floodfill مع قصر المشاركة على routers القادرة والتحقق من التوزيع عبر فحوص عشوائية تفوقت مقاربة floodfill لأنها أسهل في النشر، ولأن netDb تنقل بيانات وصفية فقط ولا تحمل حمولات المستخدم. معظم الوجهات لا تنشر LeaseSet مطلقاً لأن المرسل عادةً يضمّن LeaseSet الخاصة به داخل garlic messages (رسائل غارليك: رسائل مُجمَّعة ضمن طبقات تشفير متعددة).\nالوضع الحالي (من منظور تاريخي) تم ضبط خوارزميات netDb لتلبية احتياجات الشبكة، وقد تعاملت تاريخيًا بسلاسة مع بضع مئات من routers. أشارت التقديرات المبكرة إلى أن 3–5 floodfill routers يمكنها دعم نحو 10,000 عُقد.\nحسابات مُحدَّثة (مارس 2008) recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T حيث:\nN: Routers في الشبكة L: متوسط عدد وجهات العميل لكل router (يُضاف واحد من أجل RouterInfo) F: نسبة فشل tunnel R: فترة إعادة بناء tunnel كنسبة من مدة حياة tunnel S: متوسط حجم إدخال netDb T: مدة حياة tunnel باستخدام قيم عام 2008 (N = 700, L = 0.5, F = 0.33, R = 0.5, S = 4 KB, T = 10 minutes) ينتج:\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps هل سيعود Kademlia (خوارزمية جدول التجزئة الموزعة DHT)؟ ناقش المطوّرون إعادة إدخال Kademlia (بروتوكول جدول تجزئة موزّع) في مطلع عام 2007 تقريبًا. وكان التوافق أن سعة floodfill يمكن توسيعها تدريجيًا عند الحاجة، بينما يضيف Kademlia تعقيدًا كبيرًا ومتطلبات موارد إلى مجموعة عُقد router الأساسية. يظل الخيار الاحتياطي خاملاً ما لم تصبح سعة floodfill غير كافية.\nتخطيط سعة Floodfill إن القبول التلقائي لـ routers من فئة عرض الحزمة O ضمن floodfill، رغم أنه مُغرٍ، يعرض النظام لمخاطر سيناريوهات هجمات حجب الخدمة إذا اختارت عقد معادية الانضمام. أشارت تحليلات تاريخية إلى أن حصر مجمع floodfill (على سبيل المثال، 3–5 أقران يتولون التعامل مع نحو ~10K routers) كان أكثر أماناً. وقد استُخدم مشغّلون موثوقون أو خوارزميات استدلالية تلقائية للحفاظ على مجموعة floodfill كافية ولكن مضبوطة.\nقائمة TODO لـ Floodfill (تاريخي) يُحتفظ بهذا القسم لأغراض الأرشفة. تغطي صفحة netDb الرئيسية خارطة الطريق الحالية واعتبارات التصميم.\nأدت الحوادث التشغيلية، مثل فترة في 13 مارس 2008 كان فيها floodfill router واحد فقط متاحًا، إلى عدة تحسينات قُدِّمت ضمن الإصدارات من 0.6.1.33 إلى 0.7.x، بما في ذلك:\nإضفاء العشوائية على اختيار floodfill لعمليات البحث وتفضيل الأقران سريعي الاستجابة عرض مقاييس إضافية لـ floodfill على صفحة \u0026ldquo;Profiles\u0026rdquo; في وحدة تحكم الـ router تخفيضات تدريجية في حجم إدخالات netDb لخفض استهلاك عرض النطاق الترددي لـ floodfill الاشتراك التلقائي لمجموعة فرعية من routers من الفئة O استنادًا إلى الأداء المُجمَّع عبر بيانات الملف الشخصي تحسين قوائم الحظر، واختيار أقران floodfill، وخوارزميات الاستكشاف شملت الأفكار المتبقية من تلك الفترة:\nاستخدام إحصاءات dbHistory لتحسين تصنيف واختيار أقران floodfill تحسين سلوك إعادة المحاولة لتجنّب الاتصال المتكرر بالأقران المتعطلة الاستفادة من مقاييس زمن الوصول ودرجات التكامل في عملية الاختيار اكتشاف floodfill routers المتعطلة والتفاعل معها بسرعة أكبر مواصلة تقليل متطلبات الموارد على العُقَد عالية عرض النطاق الترددي وعُقَد floodfill حتى وقت كتابة هذه الملاحظات، اعتُبرت الشبكة قادرة على الصمود، مع وجود بنية تحتية قائمة للاستجابة بسرعة لـ floodfills معادية أو لهجمات حجب الخدمة التي تستهدف floodfill.\nملاحظات إضافية لطالما أتاحت لوحة تحكم الـ router بيانات ملفات التعريف المحسّنة للمساعدة في تحليل موثوقية floodfill. بينما تكهّنت تعليقات سابقة بشأن Kademlia أو مخططات DHT (جدول تجزئة موزّع) البديلة، ظلّت floodfill الخوارزمية الأساسية للشبكات الإنتاجية. تركّزت الأبحاث المستقبلية على جعل آليات قبول floodfill قابلة للتكيّف مع تقييد فرص إساءة الاستخدام. ","description":"ملاحظات تاريخية حول floodfill، تجارب Kademlia (خوارزمية جدول التجزئة الموزع)، وتحسينات الضبط المستقبلية لـ netDb","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"مناقشة قاعدة بيانات الشبكة","url":"/ar/docs/netdb/"},{"categories":null,"content":"نظرة عامة تحدّد هذه الوثيقة تنسيق ملف blockfile الخاص بـ I2P والجداول الموجودة في hostsdb.blockfile التي تستخدمها Blockfile Naming Service (خدمة تسمية Blockfile). للاطّلاع على الخلفية، راجع I2P Naming and Address Book .\nيتيح blockfile (آلية تخزين مفهرسة) عمليات استعلام سريعة عن الوجهات بتنسيق ثنائي مدمج. بالمقارنة مع نظام hosts.txt القديم:\nتُخزَّن الوجهات كبيانات ثنائية، وليس Base64. يمكن إرفاق بيانات وصفية حرة (مثل تاريخ الإضافة، المصدر، التعليقات). أزمنة البحث أسرع بنحو 10×. يزداد استخدام القرص بشكل طفيف. الـ blockfile (ملف كتل) هو مجموعة على القرص من خرائط مرتّبة (أزواج مفتاح-قيمة) مُنفّذة على هيئة skiplists (قوائم متخطّية). وقد اشتُقّ من Metanotion Blockfile Database . تحدّد هذه المواصفة أولاً بنية الملف، ثم تصف كيفية استخدامه بواسطة BlockfileNamingService.\nحلّت Blockfile Naming Service (خدمة تسمية Blockfile) محلّ تنفيذ hosts.txt القديم في I2P 0.8.8. \u0026gt; عند التهيئة، تقوم باستيراد مدخلات من privatehosts.txt وuserhosts.txt وhosts.txt.\nتنسيق Blockfile (ملف كتلي) يتكوّن التنسيق من صفحات بحجم 1024 بايت، يُسبق كل منها بـ رقم سحري لضمان السلامة. تُرقَّم الصفحات ابتداءً من 1:\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) تستخدم جميع الأعداد الصحيحة **ترتيب بايت الشبكة (big-endian: ذو النهاية الكبرى)**. تكون القيم ذات 2 بايت غير موقّعة؛ أما القيم ذات 4 بايت (أرقام الصفحات) فهي موقّعة ويجب أن تكون موجبة. الخيوط: تم تصميم قاعدة البيانات لـ الوصول أحادي الخيط؛ BlockfileNamingService توفّر المزامنة.\nتنسيق الكتلة الفائقة Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused --- تنسيق صفحة الكتلة لـ Skip List (قائمة التخطي) Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused --- تنسيق صفحة الحظر لتخطي المستوى كل مستوى له امتداد، لكن ليس لكل امتداد مستويات.\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused --- تنسيق صفحة كتلة امتداد التخطي تُرتَّب أزواج المفتاح/القيمة حسب المفتاح على امتداد المقاطع. يجب ألا تكون المقاطع غير الأولى فارغة.\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures --- تنسيق صفحة كتلة استمرار المدى Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures --- تنسيق بنية المفتاح/القيمة حقول طول المفتاح والقيمة لا يجوز أن تمتد عبر الصفحات (يجب أن تتسع البايتات الأربعة كاملةً). إذا لم يتبقَّ حيز كافٍ، فقم بالحشو بما يصل إلى 3 بايتات واستأنف عند الإزاحة 8 من الصفحة التالية.\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each --- تنسيق صفحة الكتل للقائمة الحرة Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) --- تنسيق كتلة الصفحة الحرة Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused --- فهرس الفهارس موجود في الصفحة 2. يعين سلاسل US-ASCII → أعداد صحيحة بطول 4 بايت. المفتاح هو اسم skiplist (بنية بيانات قائمة التخطّي)؛ والقيمة هي فهرس الصفحة.\nجداول Blockfile Naming Service (خدمة التسمية المعتمدة على ملف الكتل) تُعرِّف الخدمة عدة skiplists (هيكل بيانات للتخطي). يدعم كل امتداد ما يصل إلى 16 مُدخلاً.\nSkiplist للخصائص (بنية بيانات قائمة تخطٍّ متعددة المستويات) %%__INFO__%% يحتوي على عنصر واحد:\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping الحقول النموذجية: Property Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) --- Skiplist (بنية بيانات متخطّية) للبحث العكسي %%__REVERSE__%% يحتوي على مدخلات من نوع Integer → Properties (اعتباراً من DB v2).\nالمفتاح: أول 4 بايتات من تجزئة SHA-256 لـ Destination (الوجهة). القيمة: كائن خصائص (Mapping مُسلسلة). تتعامل الإدخالات المتعددة مع حالات التصادم ومع Destinations ذات أسماء مضيف متعددة. كل مفتاح خاصية = اسم مضيف؛ والقيمة = سلسلة فارغة. قوائم التخطي لقاعدة بيانات المضيف كل من hosts.txt، userhosts.txt، وprivatehosts.txt يعيّن أسماء المضيفين → الوجهات.\nيدعم الإصدار 4 وجهات متعددة لكل اسم مضيف (تم تقديم ذلك في I2P 0.9.26). تُرحَّل قواعد بيانات الإصدار 3 تلقائيًا.\nمفتاح سلسلة نصية بترميز UTF-8 (اسم مضيف، بأحرف صغيرة، تنتهي بـ .i2p)\nقيمة الإصدار 4: عدد أزواج الخاصية/الوجهة بطول 1 بايت لكل زوج: الخصائص → الوجهة (ثنائي) الإصدار 3: الخصائص → الوجهة (ثنائي) خصائص DestEntry Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) --- ملاحظات التنفيذ تُنفِّذ فئة Java BlockfileNamingService هذه المواصفة.\nخارج سياق الـ router، تُفتَح قاعدة البيانات بوضع للقراءة فقط ما لم تكن i2p.naming.blockfile.writeInAppContext=true. غير مُعدّ للوصول متعدد المثيلات أو الوصول من عدة JVM. يحتفظ بثلاث خرائط أساسية (privatehosts, userhosts, hosts) وخريطة عكسية لعمليات البحث السريعة. المراجع وثائق I2P حول التسمية ودفتر العناوين مواصفة البنى المشتركة قاعدة بيانات Blockfile من Metanotion توثيق JavaDoc لـ BlockfileNamingService ","description":"تنسيق تخزين blockfile (ملف مبني على الكتل) على القرص تستخدمه I2P لحل أسماء المضيفين","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"مواصفة Blockfile (ملف الكتل)","url":"/ar/docs/specs/blockfile/"},{"categories":null,"content":"1. نظرة عامة SSU2 هو بروتوكول طبقة النقل القائم على UDP (بروتوكول مخطط بيانات المستخدم) يُستخدم لاتصال آمن وموثوق جزئياً بين router وrouter في I2P. ليس بروتوكول نقل عام الاستخدام، بل مُخصّص لـ تبادل رسائل I2NP.\nالقدرات الأساسية تبادل مفاتيح موثَّق عبر Noise XK pattern (نمط XK ضمن عائلة Noise لتبادل المفاتيح) رؤوس مشفّرة لمقاومة الفحص العميق للحزم (DPI) اجتياز NAT (ترجمة عناوين الشبكة) باستخدام المرحّلات وhole-punching (تقنية الثقب) ترحيل الاتصال والتحقق من العنوان التحقق الاختياري من المسار سرية أمامية وحماية من هجمات الإعادة الإصدارات القديمة والتوافق Implementation SSU2 Default SSU1 Removed i2pd2.44.02.44.0 Java I2P0.9.560.9.61 لم يعد SSU1 قيد الاستخدام عبر شبكة I2P العامة. 2. التشفير يستخدم SSU2 Noise_XK_25519_ChaChaPoly_SHA256 (مجموعة تشفير تعتمد بروتوكول Noise بنمط XK وخوارزميات X25519 وChaChaPoly وSHA-256) مع امتدادات خاصة بـ I2P.\nFunction Algorithm Notes Diffie-HellmanX25519 (RFC 7748)32-byte keys CipherChaCha20/Poly1305 (RFC 7539)AEAD encryption HashSHA-256Used for key derivation and message integrity KDFHKDF-SHA256 (RFC 5869)For session and header keys الترويسات والحمولات مرتبطة ارتباطًا تشفيريًا عبر `mixHash()`. تُستخدم نفس البدائيات التشفيرية كما في NTCP2 وECIES لتحقيق كفاءة التنفيذ. 3. نظرة عامة على الرسائل 3.1 قواعد رزم بيانات UDP يحمل كل داتاغرام UDP رسالة SSU2 واحدة بالضبط. قد يتم تجزئة رسائل Session Confirmed (تأكيد الجلسة) عبر داتاغرامات متعددة. الحجم الأدنى: 40 بايت الحجم الأقصى: 1472 بايت (IPv4) / 1452 بايت (IPv6)\n3.2 أنواع الرسائل Type Message Header Description 0Session Request32BHandshake initiation 1Session Created32BHandshake response 2Session Confirmed16BFinal handshake, may be fragmented 6Data16BEncrypted I2NP message blocks 7Peer Test32BNAT reachability testing 9Retry32BToken or rejection notice 10Token Request32BRequest for validation token 11Hole Punch32BNAT traversal signaling --- 4. تأسيس الجلسة 4.1 التدفق القياسي (رمز مميز صالح) Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 الحصول على الرمز Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 رمز مميز غير صالح Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. تراكيب الترويسات 5.1 الترويسة الطويلة (32 بايت) تُستخدم قبل إنشاء الجلسة (SessionRequest, Created, Retry, PeerTest, TokenRequest, HolePunch).\nField Size Description Destination Connection ID8Random unique ID Packet Number4Random (ignored during handshake) Type1Message type Version1Always 2 NetID12 = main I2P network Flags1Reserved (0) Source Connection ID8Random ID distinct from destination Token8Token for address validation ### 5.2 الترويسة القصيرة (16 بايت) يُستخدم أثناء الجلسات القائمة (SessionConfirmed, Data).\nField Size Description Destination Connection ID8Stable throughout session Packet Number4Incrementing per message Type1Message type (2 or 6) Flags3ACK/fragment flags --- 6. التشفير 6.1 AEAD (تشفير موثّق مع بيانات مرتبطة) يتم تشفير جميع الحمولات باستخدام ChaCha20/Poly1305 AEAD (تشفير مصادق مرتبط بالبيانات):\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) Nonce (رقم يُستخدم مرة واحدة): 12 بايت (4 أصفار + 8 للعدّاد) الوسم: 16 بايت البيانات المصاحبة: تتضمن الترويسة لضمان سلامتها 6.2 حماية الترويسة تُموَّه الترويسات باستخدام دفق مفاتيح ChaCha20 المشتق من مفاتيح ترويسة الجلسة. يضمن ذلك أن تبدو جميع معرّفات الاتصال وحقول الحزم عشوائية، مما يوفّر مقاومة لـ DPI (فحص الحزم العميق).\n6.3 اشتقاق المفاتيح Phase Input Output InitialintroKey + salthandshake header key HandshakeDH(X25519)chainKey + AEAD key Data phasechainKeyTX/RX keys Key rotationoldKeynewKey --- 7. الأمان ومنع هجمات إعادة الإرسال الرموز مرتبطة بكل عنوان IP، وتنتهي صلاحيتها خلال ~60 ثانية. تُمنَع هجمات الإعادة عبر Bloom filters لكل جلسة (بنية بيانات احتمالية لاختبار الانتماء). تُرفَض المفاتيح المؤقتة المكررة. الرؤوس وحمولات البيانات مرتبطة ارتباطاً تشفيرياً. يجب على routers إسقاط أي حزمة تفشل في اجتياز مصادقة AEAD (تشفير موثَّق مع بيانات مرتبطة) أو بإصدار غير صالح أو NetID (معرّف الشبكة) غير صالح.\n8. ترقيم الحزم ومدة حياة الجلسة لكل اتجاه عدّاد خاص به بطول 32 بت. - يبدأ من 0 ويزداد مع كل حزمة. - يجب ألا يلتف العدّاد؛ أعد توليد مفاتيح الجلسة أو أنهِها قبل الوصول إلى 2³².\nتظل معرّفات الاتصال ثابتة طوال الجلسة بأكملها، بما في ذلك أثناء الترحيل.\n9. مرحلة البيانات النوع = 6 (بيانات) ترويسة قصيرة (16 بايت) تحتوي الحمولة على كتلة أو أكثر مشفرة: قوائم ACK/NACK (تأكيد/عدم تأكيد) أجزاء رسائل I2NP حشو (0–31 بايت عشوائي) كتل إنهاء (اختياري) يتم دعم إعادة الإرسال الانتقائية والتسليم خارج الترتيب. تظل الموثوقية «شبه موثوقة» — قد تُسقَط الحزم المفقودة بصمت بعد بلوغ حدود إعادة المحاولة.\n10. الترحيل واجتياز NAT Message Type Purpose Peer Test7Determines inbound reachability Retry9Issues new token or rejection Token Request10Requests new address token Hole Punch11Coordinates NAT hole punching تساعد routers المرحِّلة الأقران الموجودين خلف NATs (ترجمة عناوين الشبكة) مقيِّدة باستخدام رسائل التحكم هذه. 11. إنهاء الجلسة يمكن لأي نظير إنهاء الجلسة باستخدام Termination block (كتلة الإنهاء) ضمن رسالة بيانات. يجب تحرير الموارد فور الاستلام. يمكن تجاهل حزم الإنهاء المكررة بعد الإقرار بالاستلام.\n12. إرشادات التنفيذ Routers يجب: - التحقق من أن version = 2 و NetID = 2. - إسقاط الحزم ذات الحجم \u0026lt;40 بايت أو AEAD (تشفير موثّق ببيانات إضافية) غير صالح. - فرض ذاكرة تخزين مؤقت لمنع الإعادة لمدة 120s. - رفض الرموز المميّزة المعاد استخدامها أو المفاتيح المؤقتة.\nRouters ينبغي أن: - توليد حشو عشوائي بمقدار 0–31 بايت. - استخدام إعادة الإرسال التكيفية (RFC 6298). - تنفيذ التحقق من المسار لكل نظير قبل الترحيل.\n13. ملخص الأمان Property Achieved By Forward secrecyX25519 ephemeral keys Replay protectionTokens + Bloom filter Authenticated encryptionChaCha20/Poly1305 KCI resistanceNoise XK pattern DPI resistanceEncrypted headers NAT traversalRelay + Hole Punch MigrationStatic connection IDs --- 14. المراجع المقترح 159 – SSU2 إطار عمل بروتوكول Noise RFC 9000 – نقل QUIC RFC 9001 – TLS لـ QUIC RFC 7539 – ChaCha20/Poly1305 AEAD RFC 7748 – X25519 ECDH RFC 5869 – HKDF-SHA256 ","description":"بروتوكول نقل UDP الآمن شبه الموثوق الإصدار 2","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"مواصفة SSU2","url":"/ar/docs/specs/ssu2/"},{"categories":null,"content":"نظرة عامة Routers تتحقق تلقائيًا من وجود تحديثات عبر الاستعلام الدوري لموجز أخبار موقّع والموزَّع عبر شبكة I2P. عند الإعلان عن إصدار أحدث، يقوم router بتنزيل أرشيف تحديث موقّع تشفيريًا (.su3) ويجهّزه للتثبيت. يضمن هذا النظام توزيعًا مصادقًا عليه ومقاومًا للعبث، ومتعدد القنوات للإصدارات الرسمية.\nاعتبارًا من I2P 2.10.0، يستخدم نظام التحديث: - تواقيع RSA-4096 / SHA-512 - تنسيق حاوية SU3 (بديلاً عن SUD/SU2 القديمة) - مرايا احتياطية: HTTP داخل الشبكة، HTTPS على clearnet (الإنترنت العام)، وBitTorrent\n1. موجز الأخبار Routers تتحقق من موجز Atom الموقّع كل بضع ساعات لاكتشاف الإصدارات الجديدة والتنبيهات الأمنية. يتم توقيع الموجز وتوزيعه كملف .su3، والذي قد يتضمن:\n\u0026lt;i2p:version\u0026gt; — رقم الإصدار الجديد \u0026lt;i2p:minVersion\u0026gt; — أدنى إصدار مدعوم من router \u0026lt;i2p:minJavaVersion\u0026gt; — الحد الأدنى لبيئة تشغيل Java المطلوبة \u0026lt;i2p:update\u0026gt; — يسرد عدة مرايا تنزيل (I2P، HTTPS، تورنت) \u0026lt;i2p:revocations\u0026gt; — بيانات إبطال الشهادات \u0026lt;i2p:blocklist\u0026gt; — قوائم حظر على مستوى الشبكة للأقران المخترقين توزيع الخلاصة Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load تفضّل Routers خلاصة I2P، لكنها يمكن أن تعود إلى clearnet (الإنترنت العام غير المجهول) أو التوزيع عبر التورنت إذا لزم الأمر. 2. تنسيقات الملفات SU3 (المعيار الحالي) قُدِّم في الإصدار 0.9.9، وقد حلّ SU3 محلّ تنسيقي SUD وSU2 القديمين. يحتوي كل ملف على رأس، وحمولة، وتوقيع في النهاية.\nبنية الرأس \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Field\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Magic\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I2Psu3\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Format Version\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;e.g., \u0026lt;code\u0026gt;0x000B\u0026lt;/code\u0026gt; (RSA-SHA512-4096)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Length\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;512 bytes\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Version String\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Router version\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signer ID\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Certificate name\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Content Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;1 = router update, 3 = reseed, 4 = news feed\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; خطوات التحقق من التوقيع 1. حلّل الترويسة وحدّد خوارزمية التوقيع. 2. تحقّق من قيمة التجزئة والتوقيع باستخدام شهادة الموقّع المخزَّنة. 3. أكِّد أن شهادة الموقّع غير مُلغاة. 4. قارِن سلسلة الإصدار المضمّنة ببيانات التعريف الخاصة بالحمولة.\nتأتي routers مع شهادات مُوقّعين موثوقين (حاليًا zzz وstr4d) وترفض أي مصادر غير موقّعة أو مُلغاة.\nSU2 (عفا عليه الزمن) استُخدم الامتداد .su2 مع ملفات JAR المضغوطة باستخدام Pack200 (تنسيق ضغط لحزم Java). أُزيل بعد أن أعلنت Java 14 تقادم Pack200 (JEP 367). عُطِّل في I2P 0.9.48+; وقد استُبدل الآن بالكامل بضغط ZIP. SUD (قديم) صيغة ZIP موقَّعة بـ DSA‑SHA1 (خوارزمية توقيع رقمية تعتمد SHA‑1) في الإصدارات المبكرة (قبل 0.9.9). لا يوجد معرّف للموقّع أو رأس، مع سلامة بيانات محدودة. تم استبدالها بسبب تشفير ضعيف وعدم فرض الالتزام بالإصدار. 3. سير عمل التحديث 3.1 التحقق من الترويسة تقوم routers بجلب SU3 header فقط للتحقق من سلسلة الإصدار قبل تنزيل الملفات الكاملة. هذا يمنع إهدار عرض النطاق الترددي على المرايا المتقادمة أو الإصدارات القديمة.\n3.2 تنزيل كامل بعد التحقق من الترويسة، يقوم الـ router بتنزيل ملف .su3 الكامل من: - مرايا eepsite داخل الشبكة (مفضلة) - مرايا HTTPS على الإنترنت التقليدي (clearnet) (كخيار احتياطي) - BitTorrent (توزيع اختياري بمساعدة الأقران)\nتستخدم التنزيلات عملاء HTTP القياسيين لـ I2PTunnel، مع إعادة المحاولة، ومعالجة انتهاء المهلة، والرجوع إلى مرايا بديلة.\n3.3 التحقق من التوقيع يخضع كل ملف مُنزَّل لـ: - التحقق من التوقيع: التحقق باستخدام RSA-4096/SHA512 - مطابقة الإصدار: التحقق من توافق إصدار الرأس مع إصدار الحمولة - منع الرجوع إلى إصدار أقدم: يضمن أن التحديث أحدث من الإصدار المثبّت\nتُستبعد الملفات غير الصالحة أو غير المتطابقة على الفور.\n3.4 التحضير للتثبيت بعد التحقق: 1. استخرج محتويات ملف ZIP إلى دليل مؤقت 2. أزل الملفات المدرجة في deletelist.txt 3. استبدل المكتبات الأصلية إذا كان lib/jbigi.jar مضمنًا 4. انسخ شهادات الموقّع إلى ~/.i2p/certificates/ 5. انقل التحديث إلى i2pupdate.zip ليتم تطبيقه عند إعادة التشغيل التالية\nيتم تثبيت التحديث تلقائيًا عند التشغيل التالي أو عند تفعيل خيار “تثبيت التحديث الآن” يدويًا.\n4. إدارة الملفات deletelist.txt قائمة نصية بالملفات المتقادمة التي يجب حذفها قبل فك حزم المحتويات الجديدة.\nالقواعد: - مسار واحد في كل سطر (مسارات نسبية فقط) - تُتجاهل الأسطر التي تبدأ بـ # - يُرفض استخدام .. والمسارات المطلقة\nالمكتبات الأصلية لمنع الثنائيات الأصلية القديمة أو غير المتطابقة: - إذا كان lib/jbigi.jar موجود، يتم حذف ملفات .so أو .dll القديمة - يضمن استخراج المكتبات الخاصة بالمنصة حديثا\n5. إدارة الشهادات يمكن لـ Routers تلقي شهادات توقيع جديدة من خلال التحديثات أو عبر عمليات الإلغاء في موجز الأخبار.\nيتم نسخ ملفات .crt الجديدة إلى دليل الشهادات. تُحذف الشهادات الملغاة قبل عمليات التحقق المستقبلية. يدعم تدوير المفاتيح دون الحاجة إلى تدخل يدوي من المستخدم. يتم توقيع جميع التحديثات دون اتصال باستخدام air-gapped signing systems (أنظمة توقيع معزولة هوائيًا). لا يتم مطلقًا تخزين المفاتيح الخاصة على خوادم البناء.\n6. إرشادات المطورين Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. ستستكشف الإصدارات القادمة دمج التواقيع ما بعد الكم (انظر Proposal 169) والبناءات القابلة لإعادة الإنتاج. 7. نظرة عامة على الأمان Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity --- 8. إدارة الإصدارات Router: 2.10.0 (API 0.9.67) اتباع الترقيم الدلالي للإصدارات بصيغة Major.Minor.Patch. فرض الحد الأدنى للإصدار يمنع الترقيات غير الآمنة. الإصدارات المدعومة من Java: Java 8–17. ابتداءً من 2.11.0+ سيتطلب Java 17+. ","description":"آلية تحديث آمنة وموقّعة وهيكلية الخلاصة لـ I2P routers","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"مواصفة تحديث البرمجيات","url":"/ar/docs/specs/updates/"},{"categories":null,"content":"نظرة عامة الغرض ECIES-X25519-AEAD-Ratchet (آلية تشفير حديثة من طرف إلى طرف) هو بروتوكول التشفير الحديث من طرف إلى طرف الخاص بـ I2P، ويستبدل نظام ElGamal/AES+SessionTags (منظومة قديمة لتبادل المفاتيح والتشفير باستخدام وسوم الجلسة). يوفر سرية أمامية، وتشفيراً موثقاً، وتحسينات كبيرة في الأداء والأمن.\nأهم التحسينات مقارنةً بـ ElGamal/AES+SessionTags مفاتيح أصغر: مفاتيح بطول 32 بايت مقابل مفاتيح عامة ElGamal بطول 256 بايت (انخفاض بنسبة 87.5%) السرية الآنية (Forward Secrecy): تُتحقق من خلال DH ratcheting (آلية التدرّج) (غير متاحة في البروتوكول القديم) تشفير حديث: X25519 DH، ChaCha20-Poly1305 AEAD (تشفير موثَّق مرتبط بالبيانات)، SHA-256 تشفير موثَّق: مصادقة مدمجة عبر بنية AEAD بروتوكول ثنائي الاتجاه: جلسات واردة/صادرة مُقترنة مقابل البروتوكول القديم أحادي الاتجاه وسوم فعّالة: وسوم جلسة بحجم 8 بايت مقابل وسوم 32 بايت (انخفاض بنسبة 75%) تمويه حركة المرور: ترميز Elligator2 يجعل المصافحات غير قابلة للتمييز عن البيانات العشوائية حالة النشر الإصدار الأولي: الإصدار 0.9.46 (25 مايو 2020) نشر الشبكة: مكتمل اعتبارًا من عام 2020 الحالة الحالية: ناضجة، منتشرة على نطاق واسع (أكثر من 5 سنوات في بيئة الإنتاج) دعم router: يتطلب الإصدار 0.9.46 أو أعلى متطلبات floodfill: اعتماد يقارب 100% لعمليات الاستعلام المشفرة حالة التنفيذ مُنفّذ بالكامل: - رسائل الجلسة الجديدة (NS) مع الربط - رسائل رد الجلسة الجديدة (NSR) - رسائل الجلسة القائمة (ES) - آلية DH ratchet (آلية ترس لتدوير المفاتيح تدريجياً) - آليات ratchet لوسم الجلسة والمفاتيح المتماثلة - كتل DateTime وNextKey وACK وACK Request وGarlic Clove وPadding\nغير مُنفّذة (اعتباراً من الإصدار 0.9.50): - كتلة MessageNumbers (النوع 6) - كتلة Options (النوع 5) - كتلة Termination (النوع 4) - استجابات تلقائية على مستوى البروتوكول - وضع مفتاح ثابت قيمته صفر - جلسات الإرسال المتعدد\nملاحظة: حالة التنفيذ لإصدارات 1.5.0 حتى 2.10.0 (2021-2025) تتطلب التحقق، إذ قد أضيفت بعض الميزات.\nأساس البروتوكول إطار عمل بروتوكول Noise يعتمد ECIES-X25519-AEAD-Ratchet (مجموعة تشفير تعتمد على ECIES وX25519 مع AEAD وآلية Ratchet) على إطار عمل بروتوكول Noise (المراجعة 34، 2018-07-11)، وتحديداً نمط المصافحة IK (تفاعلي، مفتاح ثابت بعيد معروف) مع امتدادات خاصة بـ I2P.\nمُعرِّف بروتوكول Noise Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 مكونات المعرّف: - Noise - الإطار الأساسي - IK - نمط مصافحة تفاعلي مع مفتاح ثابت معروف للطرف البعيد - elg2 - ترميز Elligator2 (تقنية إخفاء نقاط المنحنى الإهليلجي) للمفاتيح المؤقتة (امتداد I2P) - +hs2 - يتم استدعاء MixHash قبل الرسالة الثانية لمزج الوسم (امتداد I2P) - 25519 - دالة X25519 لـ Diffie-Hellman - ChaChaPoly - خوارزمية تشفير AEAD ChaCha20-Poly1305 - SHA256 - دالة تجزئة SHA-256\nنمط المصافحة في Noise ترميز نمط IK:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) معاني الرموز: - e - نقل المفتاح المؤقت - s - نقل المفتاح الثابت - es - DH (تبادل المفاتيح ديفي-هيلمان) بين مفتاح أليس المؤقت ومفتاح بوب الثابت - ss - DH بين مفتاح أليس الثابت ومفتاح بوب الثابت - ee - DH بين مفتاح أليس المؤقت ومفتاح بوب المؤقت - se - DH بين مفتاح بوب الثابت ومفتاح أليس المؤقت\nخصائص الأمان في Noise (إطار عمل لبروتوكولات تبادل المفاتيح) باستخدام مصطلحات Noise (إطار بروتوكول لتأسيس جلسات مشفّرة)، يوفّر نمط IK (نمط مصافحة في Noise):\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) **مستويات المصادقة:** - **المستوى 1**: يتم توثيق الحمولة على أنها تعود إلى مالك المفتاح الثابت الخاص بالمرسل، لكنها تظل عرضة لهجوم Key Compromise Impersonation (KCI؛ انتحال الهوية نتيجة اختراق المفتاح) - **المستوى 2**: مقاومة لهجمات KCI بعد NSR (إعادة تهيئة الجلسة) مستويات السرية: - المستوى 2: سرية أمامية إذا تم اختراق المفتاح الثابت للمرسل لاحقاً - المستوى 4: سرية أمامية إذا تم اختراق المفتاح المؤقت للمرسل لاحقاً - المستوى 5: سرية أمامية تامة بعد حذف كلا المفتاحين المؤقتين\nالاختلافات بين IK و XK يختلف نمط IK عن نمط XK المستخدم في NTCP2 وSSU2:\nأربع عمليات DH (تبادل المفاتيح ديفي‑هيلمان): يستخدم IK أربع عمليات DH (es، ss، ee، se) مقابل ثلاث لـ XK المصادقة الفورية: تتم مصادقة Alice في الرسالة الأولى (المستوى 1 للمصادقة) سرية مستقبلية أسرع: تتحقق السرية المستقبلية الكاملة (المستوى 5) بعد الرسالة الثانية (1‑RTT، رحلة ذهاب وإياب واحدة) المفاضلة: حمولة الرسالة الأولى غير محمية بالسرية المستقبلية (على عكس XK حيث تكون جميع الحمولات محمية بالسرية المستقبلية) الخلاصة: يتيح IK إيصال استجابة Bob خلال ذهاب وإياب واحد (1-RTT) مع سرية أمامية كاملة، لكن على حساب أن الطلب الأولي لا يتمتع بسرية أمامية.\nمفاهيم Signal Double Ratchet (آلية تدوير المفاتيح المزدوجة) تتضمّن ECIES (نظام تشفير متكامل قائم على المنحنيات البيضوية) مفاهيم من خوارزمية Signal Double Ratchet :\nDH Ratchet (آلية تدوير مفاتيح تعتمد على DH): يوفّر السرّية المستقبلية عبر تبادل مفاتيح DH جديدة بشكل دوري Symmetric Key Ratchet (آلية تدوير لمفاتيح التشفير المتماثلة): يشتق مفاتيح جلسة جديدة لكل رسالة Session Tag Ratchet (آلية تدوير لوسوم الجلسة): يولّد وسوم جلسة للاستخدام لمرة واحدة بشكل حتمي أهم الفروقات عن Signal: - ratcheting أقل تكرارًا: يقوم I2P بالـ ratcheting فقط عند الحاجة (ratcheting: آلية تحديث المفاتيح تدريجية) مثل قرب نفاد الوسوم أو وفق السياسة - وسوم الجلسة (Session Tags) بدلًا من تشفير الرؤوس: يستخدم وسومًا حتمية بدلًا من رؤوس مُشفّرة - ACKs صريحة: يستخدم كتل ACK ضمن القناة (in-band) بدل الاعتماد فقط على حركة المرور العكسية (ACKs: إقرارات استلام) - ratchets منفصلة للوسوم والمفاتيح: أكثر كفاءةً لدى المستقبِل (يمكنه تأجيل حساب المفتاح)\nامتدادات I2P لـ Noise (إطار بروتوكولات للتبادل الآمن) ترميز Elligator2 (خوارزمية ترميز تُخفي المفاتيح لتبدو عشوائية): مفاتيح مؤقتة مُرمَّزة بحيث لا يمكن تمييزها عن العشوائي علامة مُضافة قبل NSR: إضافة علامة الجلسة قبل رسالة NSR لأغراض الترابط تنسيق حمولة محدد: بنية حمولة قائمة على الكتل لجميع أنواع الرسائل تغليف I2NP: جميع الرسائل مُغلّفة ضمن رؤوس I2NP Garlic Message مرحلة بيانات منفصلة: رسائل النقل (ES) تختلف عن مرحلة بيانات Noise القياسية البدائيات التشفيرية ديفي-هيلمان X25519 المواصفة: RFC 7748 الخصائص الرئيسية: - حجم المفتاح الخاص: 32 بايت - حجم المفتاح العام: 32 بايت - حجم السر المشترك: 32 بايت - Endianness (نظام ترتيب البايتات): Little-endian - المنحنى: Curve25519\nالعمليات:\nX25519 GENERATE_PRIVATE() ينشئ مفتاح خاص عشوائي بطول 32 بايت:\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) يشتق المفتاح العام المقابل:\npubkey = curve25519_scalarmult_base(privkey) يُرجع مفتاحًا عامًا بطول 32 بايت بترتيب little-endian (حيث تكون البايت الأقل أهمية أولًا).\nX25519 DH(privkey, pubkey) ينفّذ اتفاق المفاتيح Diffie-Hellman:\nsharedSecret = curve25519_scalarmult(privkey, pubkey) يُرجِع سرًا مشتركًا بطول 32 بايت.\nملاحظة أمنية: يجب على المنفذين التحقق من أن السر المشترك ليس كله أصفاراً (مفتاح ضعيف). ارفضوا وألغوا المصافحة إذا حدث ذلك.\nChaCha20-Poly1305 AEAD (تشفير مصادق مع بيانات مصاحبة) المواصفة: RFC 7539 القسم 2.8\nالمعلمات: - حجم المفتاح: 32 بايت (256 بت) - حجم Nonce (رقم يستخدم مرة واحدة): 12 بايت (96 بت) - حجم MAC: 16 بايت (128 بت) - حجم الكتلة: 64 بايت (داخلي)\nتنسيق الـ Nonce (عدد يُستخدم مرة واحدة):\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) بناء AEAD (التشفير الموثّق مع بيانات مرتبطة):\nيجمع AEAD (تشفير مُصادَق مع بيانات إضافية) بين خوارزمية التشفير التدفقي ChaCha20 وخوارزمية Poly1305 للمصادقة (MAC):\nولّد تيار المفتاح ChaCha20 من المفتاح وnonce (عدد يُستخدم مرة واحدة) شفّر النص الصريح عبر XOR (أو \u0026ldquo;أو الحصرية\u0026rdquo;) مع تيار المفتاح احسب MAC من نوع Poly1305 على (البيانات المرتبطة || النص المُشفَّر) ألحِق MAC بطول 16 بايت بالنص المُشفَّر ChaCha20-Poly1305 (خوارزمية AEAD: تشفير مصادق ببيانات مرتبطة) تشفير(k, n, plaintext, ad) يشفّر النص الصريح مع المصادقة:\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 الخصائص: - النص المُعمّى بطولٍ مساوٍ للنص الصريح (تعمية تيارية) - المخرَج يساوي plaintext_length + 16 بايت (يتضمن MAC (رمز التوثيق)) - المخرَج بأكمله لا يمكن تمييزه عن بيانات عشوائية إذا كان المفتاح سرياً - MAC يوفّر التوثيق لكلٍّ من البيانات المرتبطة والنص المُعمّى\nChaCha20-Poly1305 فك التشفير(k, n, ciphertext, ad) يفكّ التشفير ويتحقق من المصادقة:\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext متطلبات أمنية حرجة: - يجب أن تكون Nonces (عدد يُستخدم مرة واحدة) فريدة لكل رسالة مع نفس المفتاح - يجب ألا يُعاد استخدام Nonces (فشل كارثي إذا أُعيد استخدامها) - يجب أن يستخدم التحقق من رمز مصادقة الرسالة (MAC) مقارنة بزمن ثابت لمنع هجمات التوقيت - يجب أن يؤدي فشل التحقق من MAC إلى رفض الرسالة بالكامل (من دون أي فك تشفير جزئي)\nدالة التجزئة SHA-256 المواصفة: NIST FIPS 180-4\nالخصائص: - حجم المخرجات: 32 بايت (256 بت) - حجم الكتلة: 64 بايت (512 بت) - مستوى الأمان: 128 بت (مقاومة التصادم)\nالعمليات:\nSHA-256 H(p, d) تجزئة SHA-256 مع سلسلة تخصيص:\nH(p, d) := SHA256(p || d) حيث يرمز || إلى عملية الربط، وp هي سلسلة التخصيص، وd هي البيانات.\nSHA-256 MixHash(d) يحدّث قيمة التجزئة الجارية بالبيانات الجديدة:\nh = SHA256(h || d) يُستخدم طوال Noise handshake (بروتوكول المصافحة ضمن إطار Noise) للحفاظ على تجزئة سجل المصافحة.\nاشتقاق المفاتيح باستخدام HKDF (دالة لاشتقاق المفاتيح المعتمدة على HMAC) المواصفة: RFC 5869 الوصف: دالة اشتقاق مفاتيح مبنية على HMAC باستخدام SHA-256\nالمعلمات: - دالة التجزئة: HMAC-SHA256 - طول الملح: حتى 32 بايت (حجم خرج SHA-256) - طول الخرج: متغير (حتى 255 * 32 بايت)\nدالة HKDF (دالة اشتقاق مفاتيح مبنية على HMAC):\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] أنماط الاستخدام الشائعة:\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] سلاسل المعلومات المستخدمة في ECIES: - \u0026quot;KDFDHRatchetStep\u0026quot; - اشتقاق مفتاح DH ratchet (آلية السقاطة) - \u0026quot;TagAndKeyGenKeys\u0026quot; - تهيئة مفاتيح سلسلتي الوسوم والمفاتيح - \u0026quot;STInitialization\u0026quot; - تهيئة ratchet لوسم الجلسة - \u0026quot;SessionTagKeyGen\u0026quot; - توليد وسم الجلسة - \u0026quot;SymmetricRatchet\u0026quot; - توليد مفاتيح متناظرة - \u0026quot;XDHRatchetTagSet\u0026quot; - مفتاح مجموعة وسوم DH ratchet - \u0026quot;SessionReplyTags\u0026quot; - توليد مجموعة وسوم NSR - \u0026quot;AttachPayloadKDF\u0026quot; - اشتقاق مفتاح حمولة NSR\nترميز Elligator2 (مخطط ترميز لإخفاء مفاتيح المنحنيات الإهليلجية) الغرض: ترميز المفاتيح العامة لـ X25519 بحيث تكون غير قابلة للتمييز عن سلاسل عشوائية موزعة توزيعاً منتظماً بطول 32 بايت.\nالمواصفة: ورقة Elligator2 المشكلة: تمتلك مفاتيح X25519 (خوارزمية لتبادل المفاتيح على منحنى Curve25519) العامة القياسية بنية يمكن التعرف عليها. يمكن للمراقب تمييز رسائل المصافحة برصد هذه المفاتيح، حتى لو كان المحتوى مُشفّراً.\nالحل: يوفّر Elligator2 تقابلاً بين ~50% من مفاتيح X25519 العامة الصالحة وسلاسل بطول 254 بت تبدو عشوائية.\nتوليد المفاتيح باستخدام Elligator2 (تقنية لتمويه شكل المفاتيح العامة لتبدو عشوائية):\nElligator2 GENERATE_PRIVATE_ELG2() ينشئ مفتاحاً خاصاً يقابل مفتاحاً عاماً قابلاً للترميز باستخدام Elligator2 (خوارزمية لتمثيل المفاتيح العامة بشكل غير قابل للتمييز):\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue مهم: تقريباً 50٪ من المفاتيح الخاصة المُولَّدة عشوائياً ستنتج مفاتيح عامة غير قابلة للترميز. يجب التخلص منها ومحاولة التوليد من جديد.\nتحسين الأداء: أنشئ المفاتيح مسبقاً في خيط يعمل في الخلفية للحفاظ على مجمّع من أزواج مفاتيح ملائمة، وتجنّب التأخيرات أثناء المصافحة.\nElligator2 ENCODE_ELG2(pubkey) يرمّز مفتاحًا عامًا إلى 32 بايت تبدو عشوائية:\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey تفاصيل الترميز: - Elligator2 (خوارزمية ترميز) تنتج 254 بت (ليست 256 كاملة) - أعلى بتّين من البايت 31 عبارة عن حشو عشوائي - تكون النتيجة موزعة توزيعاً منتظماً على مساحة من 32 بايت - ينجح في ترميز ما يقارب 50% من مفاتيح X25519 العامة الصالحة (خوارزمية تبادل مفاتيح على المنحنى البيضوي)\nElligator2 (خوارزمية إخفاء التمثيل على المنحنى الإهليلجي - الإصدار 2) DECODE_ELG2(encodedKey) يُعاد فك الترميز إلى المفتاح العام الأصلي:\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey خصائص الأمان: - المفاتيح المُرمَّزة غير قابلة للتمييز حسابيًا عن البايتات العشوائية - لا يمكن لأي اختبار إحصائي اكتشاف المفاتيح المُرمَّزة بـ Elligator2 (خوارزمية ترميز تُخفي المفاتيح لتبدو كبيانات عشوائية) بشكل موثوق - فك الترميز حتمي (المفتاح المُرمَّز نفسه يُنتج دائمًا المفتاح العام نفسه) - الترميز تقابلي بالنسبة لنحو ~50% من المفاتيح في المجموعة الفرعية القابلة للترميز\nملاحظات التنفيذ: - خزّن المفاتيح المرمَّزة في مرحلة التوليد لتجنّب إعادة الترميز أثناء المصافحة - يمكن استخدام المفاتيح غير المناسبة الناتجة عن توليد Elligator2 (خوارزمية تمويه نقاط المنحنيات الإهليلجية) مع NTCP2 (الذي لا يتطلب Elligator2) - يُعدّ توليد المفاتيح في الخلفية أساسيًا للأداء - يتضاعف متوسط زمن التوليد بسبب معدل رفض يبلغ 50%\nتنسيقات الرسائل نظرة عامة تعرّف ECIES (مخطط التشفير المتكامل بالمنحنيات الإهليلجية) ثلاثة أنواع من الرسائل:\nجلسة جديدة (NS): رسالة المصافحة الأولية من Alice إلى Bob رد الجلسة الجديدة (NSR): رد المصافحة من Bob إلى Alice جلسة قائمة (ES): جميع الرسائل اللاحقة في كلا الاتجاهين تُغلَّف جميع الرسائل بصيغة I2NP Garlic Message (صيغة رسالة I2NP من نوع Garlic) مع طبقات تشفير إضافية.\nحاوية رسالة Garlic (تقنية تجميع الرسائل في I2P) الخاصة بـ I2NP تُغلَّف جميع رسائل ECIES (مخطط تشفير متكامل يعتمد على المنحنيات الإهليلجية) ضمن رؤوس I2NP Garlic Message القياسية:\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ الحقول: - type: 0x26 (Garlic Message، رسالة Garlic في I2P) - msg_id: معرّف رسالة I2NP بطول 4 بايت - expiration: طابع زمني Unix بطول 8 بايت (بالميلي ثانية) - size: حجم الحمولة بطول 2 بايت - chks: مجموع تحقق بطول 1 بايت - length: طول البيانات المشفّرة بطول 4 بايت - encrypted data: حمولة مشفّرة بـ ECIES\nالغرض: يوفّر تعريف الرسائل وتوجيهها على طبقة I2NP. يتيح حقل length للمستلمين معرفة الحجم الإجمالي للحمولة المشفّرة.\nرسالة جلسة جديدة (NS) تبدأ رسالة New Session جلسة جديدة من Alice إلى Bob. وتأتي بثلاثة أنواع:\nمع الربط (1b): يتضمن المفتاح الثابت الخاص بـ Alice للاتصال ثنائي الاتجاه من دون ربط (1c): يستبعد المفتاح الثابت للاتصال أحادي الاتجاه أحادي الاستخدام (1d): نمط رسالة واحدة من دون إنشاء جلسة رسالة NS مع ربط (النوع 1b) حالة الاستخدام: التدفق، datagrams (وحدات بيانات شبكية مستقلة) قابلة للرد، أي بروتوكول يتطلب ردودًا\nالطول الإجمالي: 96 + payload_length بايت\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ تفاصيل الحقل:\nالمفتاح العام المؤقت (32 بايت، نص واضح [غير مُشفَّر]): - المفتاح العام X25519 أحادي الاستخدام الخاص بأليس - مُرمَّز باستخدام Elligator2 (غير قابل للتمييز عن العشوائيّة) - يُولَّد جديدًا لكل رسالة NS (لا يُعاد استخدامه إطلاقًا) - بصيغة little-endian (ترتيب البايتات من الأقل أهمية إلى الأكثر)\nقسم المفتاح الثابت (32 بايت مُشفَّرة، 48 بايت مع MAC): - يتضمن المفتاح العمومي الثابت X25519 الخاص بـ Alice (32 بايت) - مُشفَّر باستخدام ChaCha20 - مُوثَّق عبر Poly1305 MAC (16 بايت) - يُستخدم من قبل Bob لربط الجلسة بوجهة Alice\nقسم الحمولة (مشفّر بطول متغير، +16 بايت MAC): - يحتوي على garlic cloves (كتل بيانات ضمن garlic encryption) وكتل أخرى - يجب أن يتضمن كتلة DateTime كأول كتلة - يتضمن عادةً كتل Garlic Clove مع بيانات التطبيق - قد يتضمن كتلة NextKey من أجل ratchet (آلية تدوير المفاتيح التقدّمية) فوري - يُشفّر باستخدام ChaCha20 - مُوثَّق بواسطة Poly1305 MAC (16 بايت)\nخصائص الأمان: - يوفر المفتاح المؤقت مكوّن السرية الأمامية - يثبت المفتاح الثابت هوية Alice (مقترنة بالوجهة) - يحتوي كلا الجزأين على رموز مصادقة الرسائل (MACs) منفصلة لفصل المجالات - تُجري المصافحة إجمالًا عمليتي ديفي-هيلمان (DH) (es, ss)\nرسالة NS بدون ربط (Type 1c) حالة الاستخدام: داتاغرامات خام حيث لا يُتوقع أو لا يُرغب في ردّ\nالطول الإجمالي: 96 + payload_length بايت\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ الاختلاف الرئيسي: قسم Flags (قسم الأعلام) يحتوي على 32 بايت من الأصفار بدلاً من مفتاح ثابت.\nالتعرّف: يحدّد بوب نوع الرسالة بفك تشفير القسم المكوّن من 32 بايت والتحقق مما إذا كانت جميع البايتات أصفاراً: - جميعها أصفار → جلسة غير مربوطة (type 1c) - ليست كلها أصفاراً → جلسة مربوطة بمفتاح ثابت (type 1b)\nالخصائص: - عدم وجود مفتاح ثابت يعني عدم الارتباط بوجهة أليس - لا يمكن لبوب إرسال ردود (لا وجهة معروفة) - يُجري عملية DH (ديفي-هيلمان) واحدة فقط (es) - يتبع نمط Noise \u0026ldquo;N\u0026rdquo; بدلاً من \u0026ldquo;IK\u0026rdquo; - أكثر كفاءة عندما لا تكون الردود مطلوبة أبداً\nقسم الأعلام (محجوز للاستخدام مستقبلاً): حاليًا جميعها أصفار. قد تُستخدم للتفاوض على الميزات في الإصدارات المستقبلية.\nرسالة NS لمرة واحدة (النوع 1d) حالة الاستخدام: رسالة مجهولة واحدة دون جلسة أو توقع رد\nالطول الإجمالي: 96 + payload_length بايت\nالتنسيق: مطابق لـ NS من دون ربط (النوع 1c)\nتمييز: - قد يرسل Type 1c عدة رسائل في الجلسة نفسها (تتبعها رسائل ES) - يرسل Type 1d رسالة واحدة فقط من دون إنشاء جلسة - عملياً، قد تتعامل عمليات التنفيذ معهما بوصفهما متماثلتين في البداية\nالخصائص: - أقصى قدر من إخفاء الهوية (لا مفتاح ثابت، ولا جلسة) - لا يحتفظ أي من الطرفين بأي حالة للجلسة - يتبع نمط Noise \u0026ldquo;N\u0026rdquo; (بروتوكول Noise) - عملية DH واحدة (تبادُل ديفي-هيلمان) (es)\nرسالة رد جلسة جديدة (NSR) يرسل Bob رسالة NSR واحدة أو أكثر استجابةً لرسالة NS الخاصة بـ Alice. تُكمِل NSR مصافحة Noise IK (نمط IK ضمن بروتوكول Noise) وتؤسّس جلسة ثنائية الاتجاه.\nالطول الإجمالي: 72 + payload_length بايت\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ تفاصيل الحقل:\nوسم الجلسة (8 بايت، نص غير مُشفّر): - مُولَّد من مجموعة علامات NSR (انظر أقسام KDF) - يربط هذا الرد برسالة NS الخاصة بأليس - يتيح لأليس تحديد أي NS يستجيب له هذا الـ NSR - استخدام لمرة واحدة (لا يُعاد استخدامه)\nمفتاح عام مؤقت (32 بايت، نص صريح): - المفتاح العام X25519 الخاص بـ Bob للاستخدام لمرة واحدة - مُرمَّز باستخدام Elligator2 - يُولَّد حديثًا لكل رسالة NSR (نوع رسالة) - ويجب أن يكون مختلفًا لكل NSR تُرسَل\nKey Section MAC (رمز التحقق من الرسالة لقسم المفاتيح) (16 بايت): - يوثق بيانات فارغة (ZEROLEN) - جزء من بروتوكول Noise IK (نمط se) - يستخدم سجل التجزئة كبيانات مرتبطة - حاسم لربط NSR بـ NS\nقسم الحمولة (طول متغير): - يحتوي على garlic cloves (وحدات رسائل garlic ضمن I2P) وكتل - يتضمن عادةً ردود طبقة التطبيق - قد يكون فارغًا (NSR يقتصر على ACK) - الحد الأقصى للحجم: 65519 بايت (65535 - 16 بايت MAC)\nرسائل NSR متعددة:\nقد يرسل Bob عدة رسائل NSR استجابةً لرسالة NS واحدة:\nلكل NSR مفتاح مؤقت فريد لكل NSR وسم جلسة فريد تستخدم Alice أول NSR يتم استلامه لإتمام المصافحة تُعد رسائل NSR الأخرى لأغراض التكرار (في حال فقدان الحزم) التوقيت الحرج: - يجب أن تتلقى أليس NSR واحدة قبل إرسال رسائل ES - يجب أن يتلقى بوب رسالة ES واحدة قبل إرسال رسائل ES - تنشئ NSR مفاتيح جلسة ثنائية الاتجاه عبر عملية split()\nخصائص الأمان: - يُتمّ Noise IK handshake (نمط IK للمصافحة في بروتوكول Noise) - يُجري عمليتين إضافيتين من DH (تبادل المفاتيح ديفي-هيلمان) (ee, se) - إجمالي 4 عمليات DH عبر NS+NSR (اختصاران تقنيان لرسائل/مراحل محددة في هذا السياق) - يحقق المصادقة المتبادلة (المستوى 2) - يوفر سرية أمامية ضعيفة (المستوى 4) لحمولة NSR\nرسالة جلسة قائمة (ES) تستخدم جميع الرسائل بعد مصافحة NS/NSR تنسيق Existing Session (جلسة قائمة). تُستخدم رسائل ES في كلا الاتجاهين من قبل كلٍ من Alice وBob.\nالطول الإجمالي: 8 + payload_length + 16 بايت (الحد الأدنى 24 بايت)\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ تفاصيل الحقل:\nوسم الجلسة (8 بايت، نص غير مُشفَّر): - مُولَّد من مجموعة الوسوم الصادرة الحالية - يُعرّف الجلسة ورقم الرسالة - يبحث المستقبِل عن الوسم للعثور على مفتاح الجلسة والـ nonce (عدد عشوائي يُستخدم مرة واحدة) - للاستخدام لمرة واحدة (يُستخدم كل وسم مرة واحدة فقط) - التنسيق: أول 8 بايت من خرج HKDF (دالة اشتقاق مفاتيح مبنية على HMAC)\nقسم الحمولة (طول متغير): - يحتوي على garlic cloves وكتل - لا توجد كتل مطلوبة (قد يكون فارغًا) - الكتل الشائعة: Garlic Clove, NextKey, ACK, ACK Request, Padding - الحجم الأقصى: 65519 بايت (65535 - MAC بطول 16 بايت)\nMAC (رمز تحقق الرسائل) (16 بايت): - وسم مصادقة Poly1305 - يُحسَب على كامل الحمولة - البيانات المرتبطة: وسم الجلسة بطول 8 بايت - يجب التحقق منه بشكل صحيح، وإلا ستُرفَض الرسالة\nعملية الاستعلام عن الوسم:\nيقوم المستقبِل باستخراج وسم بطول 8 بايت يبحث عن الوسم في جميع مجموعات الوسوم الواردة الحالية يسترجع مفتاح الجلسة المرتبط ورقم الرسالة N ينشئ nonce (عدد يُستخدم مرة واحدة): [0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] يفك تشفير الحمولة باستخدام AEAD (تشفير مصادق مع بيانات مرتبطة) مع اعتبار الوسم بيانات مرتبطة يزيل الوسم من مجموعة الوسوم (استخدام لمرة واحدة) يعالج الكتل المفكوك تشفيرها تعذّر العثور على Session Tag (وسم الجلسة):\nإذا لم يُعثر على الوسم في أي مجموعة وسوم: - قد تكون رسالة NS (اختصار لبروتوكول Noise Session) → محاولة فك تشفير NS - قد تكون رسالة NSR (رد Noise Session) → محاولة فك تشفير NSR - قد تكون ES (جلسة ElGamal) خارج الترتيب → الانتظار قليلًا لتحديث مجموعة الوسوم - قد يكون هجوم إعادة الإرسال → الرفض - قد تكون بيانات تالفة → الرفض\nحمولة فارغة:\nقد تكون لرسائل ES حمولات فارغة (0 بايت):\nتعمل كـ ACK (تأكيد استلام) صريح عند استقبال طلب ACK توفر استجابة على مستوى البروتوكول دون بيانات التطبيق لا تزال تستهلك session tag (وسم الجلسة) مفيدة عندما لا تكون لدى الطبقة الأعلى بيانات فورية لإرسالها خصائص الأمان: - سرية أمامية كاملة (المستوى 5) بعد استلام NSR - تشفير مُصادَق عبر AEAD (تشفير مصادق مع بيانات مرتبطة) - يعمل الوسم كبيانات مرتبطة إضافية - حد أقصى 65535 رسالة لكل مجموعة وسوم قبل الحاجة إلى ratchet (آلية تدوير المفاتيح)\nدوال اشتقاق المفاتيح يوثّق هذا القسم جميع عمليات اشتقاق المفاتيح (KDF) المستخدمة في ECIES، مبيّناً الاشتقاقات التشفيرية كاملةً.\nالاصطلاحات والثوابت الثوابت: - ZEROLEN - مصفوفة بايت بطول صفري (سلسلة فارغة) - || - عامل الربط\nالمتغيرات: - h - الهاش التراكمي لسجل الرسائل (32 بايت) - chainKey - مفتاح التسلسل لـ HKDF (وظيفة اشتقاق مفتاح عبر دالة هاش) (32 بايت) - k - مفتاح تشفير متماثل (32 بايت) - n - Nonce (عدد يُستخدم لمرة واحدة) / رقم الرسالة\nالمفاتيح: - ask / apk - المفتاح الخاص/العام الثابت لأليس - aesk / aepk - المفتاح الخاص/العام المؤقت لأليس - bsk / bpk - المفتاح الخاص/العام الثابت لِبوب - besk / bepk - المفتاح الخاص/العام المؤقت لِبوب\nدوال اشتقاق المفاتيح لرسائل NS دالة اشتقاق المفاتيح 1: المفتاح الابتدائي للسلسلة يُجرى مرة واحدة عند تهيئة البروتوكول (يمكن حسابه مسبقًا):\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions النتيجة: - chainKey = مفتاح السلسلة الابتدائي لجميع KDFs (دوال اشتقاق المفاتيح) اللاحقة - h = سجل التجزئة الابتدائي\nKDF 2: مزج المفتاح الثابت لبوب ينفذ Bob هذا مرة واحدة (يمكن حسابه مسبقًا لجميع الجلسات الواردة):\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF (دالة اشتقاق المفاتيح) 3: توليد المفتاح المؤقت لأليس تُنشئ أليس مفاتيح جديدة لكل رسالة NS:\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF 4: قسم المفتاح الثابت في NS (نمط المصافحة في Noise) (es DH، تبادل مفاتيح ديفي-هيلمان الزائل-الساكن) يشتق مفاتيح لتشفير المفتاح الثابت الخاص بـ Alice:\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF 5: قسم حمولة NS (ss DH (تبادل ديفي-هيلمان بين مفاتيح ساكنة)، مرتبط فقط) بالنسبة للجلسات المربوطة، أجرِ عملية DH (تبادل مفاتيح ديفي-هيلمان) ثانية لتشفير الحمولة:\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message ملاحظات مهمة:\nBound مقابل Unbound:\nBound ينفذ عمليتين DH (es + ss) Unbound ينفذ عملية DH واحدة (es فقط) Unbound يزيد قيمة nonce (عدد يُستخدم مرة واحدة) بدلاً من اشتقاق مفتاح جديد سلامة عدم إعادة استخدام المفتاح:\nnonces (nonce: عدد يُستخدم مرة واحدة) مختلفة (0 مقابل 1) تمنع إعادة استخدام المفتاح/nonce بيانات مقترنة مختلفة (h مختلف) توفر فصل المجالات سجل التجزئة:\nh يحتوي الآن على: protocol_name, empty prologue, bpk, aepk, static_key_ciphertext, payload_ciphertext هذا السجل يربط جميع أجزاء رسالة NS معًا دالة اشتقاق المفاتيح لمجموعة وسوم الرد الخاصة بـ NSR ينشئ Bob علامات لرسائل NSR:\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR دوال اشتقاق المفاتيح لرسالة NSR KDF (وظيفة اشتقاق مفاتيح) 6: توليد المفتاح المؤقت لـ NSR (اختصار تقني خاص بالمواصفة) بوب يولّد مفتاحًا مؤقتًا جديدًا لكل NSR:\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7: قسم مفاتيح NSR (ee و se DH) يشتق مفاتيح لقسم مفاتيح NSR:\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR هام جدًا: هذا يُكمل Noise IK handshake (مصافحة Noise بنمط IK). chainKey يحتوي الآن على مساهمات من جميع عمليات DH الأربع (تبادل المفاتيح ديفي-هيلمان) (es, ss, ee, se).\nKDF (دالة اشتقاق المفتاح) 8: قسم حمولة NSR يشتق مفاتيح لتشفير حمولة NSR:\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message ملاحظات مهمة:\nعملية التقسيم:\nينشئ مفاتيح مستقلة لكل اتجاه يمنع إعادة استخدام المفتاح بين Alice→Bob و Bob→Alice ربط الحمولة في NSR:\nتستخدم h كبيانات مرتبطة لربط الحمولة بالمصافحة توفر KDF (دالة اشتقاق المفاتيح) منفصلة (\u0026ldquo;AttachPayloadKDF\u0026rdquo;) فصل المجالات جاهزية ES:\nبعد NSR، يمكن للطرفين إرسال رسائل ES يجب على أليس استلام رسالة NSR قبل إرسال ES يجب على بوب استلام رسالة ES قبل إرسال ES دوال اشتقاق المفاتيح (KDFs) لرسائل ES (مؤقت-ثابت) رسائل ES (نوع رسائل خاص بـ I2P) تستخدم مفاتيح جلسة مولدة مسبقاً من tagsets (مجموعات الوسوم):\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) عملية الاستقبال:\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) الدالة DH_INITIALIZE ينشئ tagset (مجموعة وسوم) لاتجاه واحد:\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset سياقات الاستخدام:\nNSR Tagset (مجموعة الوسوم): DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) ES Tagsets: DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) Ratcheted Tagsets (بآلية السقاطة): DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) آليات السقاطة تستخدم ECIES (مخطط التشفير المتكامل بالمنحنيات الإهليلجية) ثلاث آليات راتشِت متزامنة لتوفير السرية الأمامية وإدارة فعّالة للجلسات.\nنظرة عامة حول Ratchet (آلية تقدّم أحاديّة الاتجاه في التشفير) ثلاثة أنواع من Ratchet (آلية تقدّم أحادي الاتجاه في التشفير):\nDH Ratchet (آلية تدوير الحالة الأمنية): يجري تبادلات مفاتيح Diffie-Hellman لتوليد مفاتيح جذرية جديدة Session Tag Ratchet: يشتق وسوم جلسة أحادية الاستخدام بشكل حتمي Symmetric Key Ratchet: يشتق مفاتيح جلسة لتشفير الرسائل العلاقة:\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) الخصائص الرئيسية:\nالمرسل: يولّد الوسوم والمفاتيح عند الطلب (لا حاجة للتخزين) المتلقي: يولّد مسبقًا الوسوم لنافذة التطلّع المسبق (يتطلب تخزينًا) المزامنة: فهرس الوسم يحدد فهرس المفتاح (N_tag = N_key) السرية الأمامية: تتحقق عبر DH ratchet الدوري (آلية ترقية مفاتيح تعتمد على ديفي‑هيلمان) الكفاءة: يمكن للمتلقي تأجيل حساب المفتاح حتى استلام الوسم DH Ratchet (آلية السقاطة القائمة على ديفي-هيلمان لتدوير المفاتيح) توفر سقاطة ديفي-هيلمان السرية الأمامية من خلال تبادل مفاتيح مؤقتة جديدة بشكل دوري.\nتواتر DH Ratchet (آلية تبديل المفاتيح باستخدام ديفي-هيلمان) الشروط المطلوبة لِـ Ratchet (آلية تدوير المفاتيح): - اقتراب نفاد مجموعة الوسوم (الوسم 65535 هو الحد الأقصى) - سياسات خاصة بالتنفيذ: - عتبة عدد الرسائل (مثلًا، كل 4096 رسالة) - عتبة زمنية (مثلًا، كل 10 دقائق) - عتبة حجم البيانات (مثلًا، كل 100 ميغابايت)\nالـ Ratchet الأولى الموصى بها (آلية التدرّج): حوالي رقم الوسم 4096 لتجنّب بلوغ الحدّ\nالقيم القصوى: - أقصى معرّف tag set (مجموعة وسوم): 65535 - أقصى معرّف مفتاح: 32767 - أقصى عدد للرسائل لكل tag set: 65535 - الحد الأقصى النظري للبيانات لكل جلسة: ~6.9 تيرابايت (64K مجموعات وسوم × 64K رسالة × بمتوسط 1730 بايت)\nمعرّفات الوسوم والمفاتيح في DH Ratchet (آلية التقدّم المرحلي باستخدام ديفي-هيلمان) مجموعة العلامات الأولية (بعد المصافحة): - معرّف مجموعة العلامات: 0 - لم تُرسل كتل NextKey بعد - لم تُعيَّن أي معرّفات مفاتيح\nبعد الـ Ratchet الأول (آلية تدوير المفاتيح): - معرّف مجموعة الوسوم: 1 = (1 + معرّف مفتاح أليس + معرّف مفتاح بوب) = (1 + 0 + 0) - تُرسل أليس NextKey بمعرّف مفتاح 0 - يردّ بوب بـ NextKey بمعرّف مفتاح 0\nمجموعات الوسوم اللاحقة: - معرّف مجموعة الوسوم = 1 + معرّف مفتاح المرسِل + معرّف مفتاح المستلِم - مثال: مجموعة الوسوم 5 = (1 + sender_key_2 + receiver_key_2)\nجدول تطوّر مجموعة الوسوم:\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set \\* = تم توليد مفتاح جديد في هذه الـ ratchet (آلية تجديد المفاتيح تدريجيًا) قواعد مُعرّف المفتاح: - تكون المعرّفات متسلسلة بدءًا من 0 - لا تزداد المعرّفات إلا عند إنشاء مفتاح جديد - الحد الأقصى لمعرّف المفتاح هو 32767 (15 بت) - بعد معرّف المفتاح 32767، يلزم بدء جلسة جديدة\nتدفق الرسائل في DH Ratchet (آلية الراتشيت القائمة على ديفي-هيلمان) الأدوار: - Tag Sender (مرسل الوسم): يمتلك مجموعة Tag الصادرة، ويرسل الرسائل - Tag Receiver: يمتلك مجموعة Tag الواردة، ويتلقى الرسائل\nالنمط: مرسِل الوسوم يُطلِق ratchet (آلية تدوير مفاتيح تدريجية) عندما تشارف مجموعة الوسوم على النفاد.\nمخطط تدفق الرسائل:\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) أنماط Ratchet (آلية تدوير المفاتيح المتدرّجة):\nإنشاء مجموعات وسوم ذات أرقام زوجية (2, 4, 6, \u0026hellip;): 1. يولّد المرسل مفتاحًا جديدًا 2. يرسل المرسل كتلة NextKey (كتلة المفتاح التالي) بالمفتاح الجديد 3. يرسل المستقبل كتلة NextKey بمعرّف المفتاح القديم (ACK) 4. ينفّذ كلاهما DH (تبادل مفاتيح ديفي-هيلمان) باستخدام (مفتاح المرسل الجديد × مفتاح المستقبل القديم)\nإنشاء مجموعات وسوم ذات أرقام فردية (3، 5، 7، \u0026hellip;): 1. يطلب المرسل المفتاح العكسي (يرسل NextKey مع علم الطلب) 2. يولد المستقبل مفتاح جديد 3. يرسل المستقبل كتلة NextKey بالمفتاح الجديد 4. يجري الطرفان DH (تبادل المفاتيح ديفي-هيلمان) باستخدام (مفتاح المرسل القديم × مفتاح المستقبل الجديد)\nتنسيق كتلة NextKey (المفتاح التالي) انظر قسم تنسيق الحمولة للحصول على المواصفة المفصلة لكتلة NextKey.\nالعناصر الأساسية: - بايت الأعلام: - البت 0: وجود المفتاح (1) أو المعرّف فقط (0) - البت 1: المفتاح العكسي (1) أو المفتاح الأمامي (0) - البت 2: طلب المفتاح العكسي (1) أو بدون طلب (0) - معرّف المفتاح: 2 بايت، بترتيب بايت كبير (0-32767) - المفتاح العام: 32 بايت X25519 (إذا كان البت 0 = 1)\nأمثلة على كتل NextKey:\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) دالة اشتقاق المفاتيح لـ DH Ratchet عند تبادل مفاتيح جديدة:\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset التوقيت الحرج:\nمرسِل الوسوم: - ينشئ مجموعة وسوم صادرة جديدة فورًا - يبدأ استخدام الوسوم الجديدة فورًا - يحذف مجموعة الوسوم الصادرة القديمة\nمستقبل الوسوم: - ينشئ مجموعة وسوم واردة جديدة - يحتفظ بمجموعة الوسوم الواردة القديمة لمدة سماح (3 دقائق) - يقبل الوسوم من كلتا مجموعتي الوسوم القديمة والجديدة خلال فترة السماح - يحذف مجموعة الوسوم الواردة القديمة بعد انتهاء فترة السماح\nإدارة حالة DH Ratchet (آلية التدوير باستخدام ديفي-هيلمان) حالة المرسل: - مجموعة الوسوم الصادرة الحالية - معرّف مجموعة الوسوم ومعرّفات المفاتيح - مفتاح الجذر التالي (للـ ratchet التالي، آلية تدوير/ترقية المفاتيح) - عدد الرسائل في مجموعة الوسوم الحالية\nحالة المستقبِل: - مجموعة/مجموعات الوسوم الواردة الحالية (قد يكون عددها 2 خلال فترة السماح) - أرقام الرسائل السابقة (PN) لاكتشاف الفجوات - نافذة استباقية للوسوم المُولَّدة مسبقًا - المفتاح الجذري التالي (لـ ratchet التالية - آلية تدوير المفاتيح تدريجيًا)\nقواعد انتقال الحالة:\nقبل أول عملية Ratchet (آلية تدوير المفاتيح):\nاستخدام مجموعة الوسوم 0 (من NSR) لم يتم تعيين أي معرّفات مفاتيح بدء Ratchet (آلية السقاطة التشفيرية):\nولِّد مفتاحًا جديدًا (إذا كان المرسِل هو من يتولّى التوليد في هذه الجولة) أرسل كتلة NextKey في رسالة ES انتظر رد NextKey قبل إنشاء مجموعة وسوم صادرة جديدة استلام طلب Ratchet (آلية التقدّم المتدرّج):\nتوليد مفتاح جديد (إذا كان المتلقي هو المولِّد في هذه الجولة) إجراء DH (تبادل المفاتيح ديفي–هيلمان) مع المفتاح المستلَم إنشاء مجموعة وسوم واردة جديدة إرسال رد NextKey الاحتفاظ بمجموعة الوسوم الواردة القديمة لفترة سماح إكمال Ratchet (آلية تدوير المفاتيح المتتابعة):\nاستلام استجابة NextKey إجراء DH (تبادل مفاتيح ديفي-هيلمان) إنشاء مجموعة وسوم صادرة جديدة بدء استخدام الوسوم الجديدة Session Tag Ratchet (آلية تقدّم أحاديّ الاتجاه لوسوم الجلسة) تولّد session tag ratchet (آلية المسنن لعلامات الجلسة) علامات جلسة للاستخدام لمرة واحدة بطول 8 بايت بشكل حتمي.\nالغرض من Session Tag Ratchet (آلية التدوير التدريجي لوسوم الجلسة) يستبدل نقل الوسوم الصريح (أرسل ElGamal وسومًا بطول 32 بايت) يُمكّن المُستقبِل من توليد الوسوم مسبقًا لنافذة التطلّع المسبق يُولِّد المُرسِل عند الطلب (من دون الحاجة إلى تخزين) يتزامن مع symmetric key ratchet (آلية تبديل مفاتيح متماثلة تدريجية) عبر فهرس صيغة Session Tag Ratchet (آلية السقاطة الخاصة بوسم الجلسة) التهيئة:\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset توليد الوسم (للوسم N):\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 التسلسل الكامل:\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] تنفيذ المرسل لـ Session Tag Ratchet (آلية السقاطة لوسوم الجلسة) class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) عملية المرسل: 1. استدعِ get_next_tag() لكل رسالة 2. استخدم الوسم المعاد في رسالة ES 3. احفظ المؤشر N لتتبع ACK (إقرار) المحتمل 4. لا يلزم تخزين الوسم (يتم إنشاؤه عند الطلب)\nتنفيذ المستقبِل لآلية Ratchet (آلية تصعيد تشفيرية) لوسم الجلسة class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) عملية المُستقبِل: 1. توليد الوسوم مسبقًا لنافذة التطلّع المسبق (على سبيل المثال، 32 وسمًا) 2. تخزين الوسوم في جدول تجزئة أو قاموس 3. عند وصول الرسالة، ابحث عن الوسم للحصول على الفهرس N 4. إزالة الوسم من التخزين (استخدام لمرة واحدة) 5. توسيع النافذة إذا انخفض عدد الوسوم تحت العتبة\nاستراتيجية النظر المسبق لـ Session Tag (وسم الجلسة) الغرض: الموازنة بين استهلاك الذاكرة والتعامل مع الرسائل غير المتسلسلة\nأحجام Look-Ahead (التطلّع المسبق) الموصى بها:\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets **التطلّع المسبق التكيّفي:** # Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 الاقتطاع من الخلف:\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 حساب الذاكرة:\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total معالجة التسليم خارج الترتيب لـ Session Tag (وسم الجلسة) السيناريو: تصل الرسائل بترتيب غير متسلسل\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 سلوك المتلقي:\nاستلم tag_5:\nابحث: تم العثور عليه في الفهرس 5 عالج الرسالة أزل tag_5 أعلى قيمة مستلمة: 5 استلام tag_7 (خارج الترتيب):\nالبحث: عُثر عليه عند الفهرس 7 معالجة الرسالة إزالة tag_7 أعلى ما تم استلامه: 7 ملاحظة: tag_6 ما يزال في التخزين (لم يُستلم بعد) استلام tag_6 (مؤجّل):\nالبحث: وُجد عند الفهرس 6 معالجة الرسالة إزالة tag_6 أعلى ما تم استلامه: 7 (لم يتغير) تلقي tag_8:\nإجراء بحث: تم العثور عليه عند الفهرس 8 معالجة الرسالة إزالة tag_8 أعلى رقم مُستلَم: 8 إدارة النافذة: - تتبّع أعلى فهرس تم استلامه - الحفاظ على قائمة بالفهارس المفقودة (الفجوات) - توسيع النافذة استنادًا إلى أعلى فهرس - اختياري: إسقاط الفجوات القديمة بعد انتهاء المهلة الزمنية\nSymmetric Key Ratchet (آلية تدوير المفتاح المتماثل) تُولِّد symmetric key ratchet (آلية تدوير مفاتيح متماثلة) مفاتيح تشفير بطول 32 بايت متزامنة مع وسوم الجلسة.\nغرض Symmetric Key Ratchet (آلية التحديث المتدرّج للمفتاح المتماثل) يوفر مفتاح تشفير فريد لكل رسالة متزامن مع session tag ratchet (آلية تدوير مفاتيح وسوم الجلسة) (نفس الفهرس) يمكن للمرسل توليده عند الطلب يمكن للمستقبِل تأجيل التوليد حتى استلام الوسم صيغة Ratchet (آلية السقاطة في التشفير) للمفتاح المتماثل التهيئة:\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived توليد المفاتيح (للمفتاح N):\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) التسلسل الكامل:\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] تنفيذ المُرسِل Symmetric Key Ratchet (آلية ترقية المفاتيح المتماثلة) class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) عملية المرسل: 1. احصل على الوسم التالي مع فهرسه N 2. ولّد مفتاحاً للفهرس N 3. استخدم المفتاح لتشفير الرسالة 4. لا حاجة إلى تخزين المفتاح\nتنفيذ مستقبل Symmetric Key Ratchet (آلية السقاطة للمفتاح المتماثل) الاستراتيجية 1: التوليد المؤجل (موصى بها)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) عملية التوليد المؤجَّل: 1. استلم رسالة ES مع وسم 2. ابحث عن الوسم للحصول على الفهرس N 3. ولّد المفاتيح من 0 حتى N (إن لم تكن مُولَّدة مسبقًا) 4. استخدم المفتاح N لفك تشفير الرسالة 5. أصبح مفتاح السلسلة الآن متموضعًا عند الفهرس N\nالمزايا: - استهلاك ضئيل للذاكرة - يتم إنشاء المفاتيح فقط عند الحاجة - تنفيذ بسيط\nالعيوب: - يجب توليد جميع المفاتيح من 0 إلى N عند أول استخدام - لا يمكنه التعامل مع الرسائل خارج الترتيب من دون التخزين المؤقت\nالاستراتيجية 2: التوليد المسبق باستخدام Tag Window (نافذة الأوسمة) (بديل)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None عملية التوليد المسبق: 1. ولّد مسبقًا مفاتيح مطابقة لنافذة الوسوم (على سبيل المثال: 32 مفتاحًا) 2. خزّن المفاتيح مفهرسة حسب رقم الرسالة 3. عند استلام الوسم، ابحث عن المفتاح المقابل 4. وسّع النافذة مع استخدام الوسوم\nالمزايا: - يتعامل مع الرسائل الخارجة عن الترتيب بشكل طبيعي - استرجاع سريع للمفاتيح (من دون تأخير في التوليد)\nالعيوب: - استهلاك ذاكرة أعلى (32 بايت لكل مفتاح مقابل 8 بايت لكل وسم) - يجب الحفاظ على تزامن المفاتيح مع الوسوم\nمقارنة الذاكرة:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB مزامنة Ratchet (آلية ترقية المفاتيح تدريجياً) المتماثل باستخدام وسوم الجلسة متطلب حاسم: يجب حتمًا أن يساوي فهرس وسم الجلسة فهرس المفتاح المتماثل\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) أنماط الفشل:\nإذا تعطّلت المزامنة:\nاستخدام مفتاح خاطئ لفك التشفير فشل التحقق من MAC (رمز مصادقة الرسالة) يتم رفض الرسالة الوقاية: - استخدم دائمًا نفس الفهرس لكلٍ من الوسم والمفتاح - لا تتجاوز الفهارس مطلقًا في أي من آليات ratchet (آلية تدوير المفاتيح المتتابعة في التشفير) - تعامل مع الرسائل الخارجة عن الترتيب بحذر\nبناء Nonce (رقم يُستخدم لمرة واحدة) لِـ Ratchet (آلية تدوير مفاتيح متدرّجة) المتماثل Nonce (رقم يُستخدم مرة واحدة) يُشتق من رقم الرسالة:\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) أمثلة:\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 الخصائص المهمة: - Nonces (nonce: قيمة تُستخدم مرة واحدة) فريدة لكل رسالة ضمن مجموعة الوسوم - لا تتكرر Nonces إطلاقاً (الوسوم المُستخدمة لمرة واحدة تضمن ذلك) - عداد بطول 8 بايت يتيح 2^64 رسالة (نستخدم 2^16 فقط) - يتوافق تنسيق nonce مع البناء القائم على العدّاد وفق RFC 7539\nإدارة الجلسات سياق الجلسة يجب أن تنتمي جميع الجلسات الواردة والصادرة إلى سياق محدد:\nسياق Router: جلسات لـ router ذاته سياق الوجهة: جلسات لوجهة محلية محددة (تطبيق عميل) قاعدة حاسمة: لا يجوز مطلقًا مشاركة الجلسات بين السياقات لمنع هجمات الارتباط.\nالتنفيذ:\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) تنفيذ I2P بلغة جافا:\nفي Java I2P، يوفر الصنف SessionKeyManager هذه الوظائف: - مثيل واحد لـSessionKeyManager لكل router - مثيل واحد لـSessionKeyManager لكل وجهة محلية - إدارة منفصلة لجلسات ECIES وElGamal ضمن كل سياق\nربط الجلسة الربط يقرن جلسة بوجهة بعيدة محددة.\nالجلسات المرتبطة الخصائص: - تضمين المفتاح الثابت للمرسل في رسالة NS - يمكن للمستلم تحديد وجهة المرسل - يتيح اتصالاً ثنائي الاتجاه - جلسة صادرة واحدة لكل وجهة - قد توجد عدة جلسات واردة (أثناء الانتقالات)\nحالات الاستخدام: - اتصالات تدفقية (مشابهة لـ TCP) - datagrams (حزم بيانات غير متصلة) قابلة للرد - أي بروتوكول يتطلب طلب/استجابة\nعملية الربط:\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) المزايا: 1. ديفي-هيلمان مؤقت-مؤقت: يستخدم الرد ee DH (سرّية أمامية كاملة) 2. استمرارية الجلسة: تحافظ Ratchets (آلية السقاطة) على الارتباط بالوجهة نفسها 3. الأمان: يمنع اختطاف الجلسة (موثَّق بمفتاح ثابت) 4. الكفاءة: جلسة واحدة لكل وجهة (من دون تكرار)\nجلسات غير مرتبطة الخصائص: - لا يوجد مفتاح ثابت في رسالة NS (قسم الأعلام كله أصفار) - لا يستطيع المستلم تحديد هوية المرسل - اتصال أحادي الاتجاه فقط - يُسمح بإنشاء عدة جلسات إلى نفس الوجهة\nحالات الاستخدام: - رزم بيانات خام (أرسل وانسَ) - نشر مجهول الهوية - مراسلة بأسلوب البث\nالخصائص: - أكثر إخفاءً للهوية (لا تحديد لهوية المرسل) - أكثر كفاءة (1 DH مقابل 2 DH في عملية المصافحة) - لا يمكن الرد (المستلم لا يعرف أين يرد) - لا يوجد session ratcheting (ترقية مفاتيح الجلسة تدريجياً؛ استخدام لمرة واحدة أو استخدام محدود)\nإقران الجلسة الإقران يربط جلسة واردة بجلسة صادرة لتمكين الاتصال ثنائي الاتجاه.\nإنشاء جلسات مقترنة وجهة نظر أليس (الطرف البادئ):\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) منظور بوب (المستجيب):\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) فوائد إقران الجلسة تأكيدات الاستلام داخل القناة (In-band ACKs): يمكن تأكيد الرسائل من دون clove مستقل (وحدة فرعية ضمن رسالة مجمّعة في I2P) التبديل التدريجي للمفاتيح الفعّال (Ratcheting: آلية تدوير مفاتيح تدريجية في التشفير): يتقدّم في كلا الاتجاهين معاً التحكم في التدفق: يمكن تنفيذ ضغط عكسي عبر الجلسات المقترنة اتساق الحالة: أسهل في الحفاظ على حالة متزامنة قواعد إقران الجلسات قد تكون الجلسة الصادرة غير مقترنة (NS غير مرتبط) يجب أن تكون الجلسة الواردة لـ NS المرتبط مقترنة يتم الإقران عند إنشاء الجلسة، وليس بعد ذلك الجلسات المقترنة لها نفس ارتباط الوجهة Ratchets (آليات تدوير المفاتيح التشفيرية) تحدث بشكل مستقل ولكن يجري تنسيقها دورة حياة الجلسة دورة حياة الجلسة: مرحلة الإنشاء إنشاء جلسة صادرة (Alice):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session إنشاء جلسة واردة (Bob):\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session دورة حياة الجلسة: المرحلة النشطة انتقالات الحالة:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED صيانة الجلسة النشطة:\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) دورة حياة الجلسة: مرحلة انتهاء الصلاحية قيم مهلة الجلسة:\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet **منطق انتهاء الصلاحية:** def check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) قاعدة حرجة: يجب أن تنتهي الجلسات الصادرة قبل الجلسات الواردة لمنع عدم التزامن.\nإنهاء سلس:\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() رسائل NS متعددة السيناريو: فُقدت رسالة NS الخاصة بأليس أو فُقد رد NSR.\nسلوك أليس:\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] خصائص مهمة:\nمفاتيح مؤقتة فريدة: تستخدم كل NS (جلسة اتصال) مفتاحًا مؤقتًا مختلفًا مصافحات مستقلة: تنشئ كل NS حالة مصافحة مستقلة ارتباط NSR: يحدد وسم NSR (استجابة NS) NS المقصود بالاستجابة تنظيف الحالة: تُزال حالات NS غير المستخدمة بعد نجاح NSR منع الهجمات:\nلمنع استنزاف الموارد:\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context رسائل NSR متعددة السيناريو: يرسل بوب عدة NSRs (رسائل تقنية في I2P مخصّصة لحمل بيانات الرد) (على سبيل المثال، تقسيم بيانات الرد عبر عدة رسائل).\nسلوك بوب:\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES سلوك أليس:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake تنظيف بوب:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED الخصائص المهمة:\nالسماح بعدة NSR (مصطلح تقني يُترك بالإنجليزية): يمكن لـ Bob إرسال عدة NSR لكل NS (مصطلح تقني يُترك بالإنجليزية) مفاتيح مؤقتة مختلفة: يجب أن يستخدم كل NSR مفتاحًا مؤقتًا فريدًا نفس tagset (مجموعة وسوم للتشفير) الخاصة بـ NSR: تستخدم جميع NSR الخاصة بـ NS نفس tagset أول ES (مصطلح تقني يُترك بالإنجليزية) يفوز: يحدد أول ES من Alice أي NSR نجح تنظيف بعد ES: يتخلص Bob من الحالات غير المستخدمة بعد استلام ES آلة حالات الجلسة مخطط الحالة الكامل:\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED أوصاف الحالات:\nNEW: تم إنشاء جلسة صادرة، لم يتم إرسال NS (رسالة بدء الجلسة) بعد PENDING_REPLY: تم إرسال NS، في انتظار NSR (رد بدء الجلسة) AWAITING_ES: تم إرسال NSR، في انتظار أول ES (رسالة بيانات مُشفّرة) من Alice ESTABLISHED: اكتملت المصافحة، ويمكن إرسال/استقبال ES ACTIVE: يتم تبادل رسائل ES بنشاط RATCHETING: DH ratchet (آلية تبديل مفاتيح تدريجية باستخدام Diffie-Hellman) قيد التنفيذ (جزء فرعي من ACTIVE) EXPIRED: انتهت مهلة الجلسة، بانتظار الحذف TERMINATED: تم إنهاء الجلسة بشكل صريح تنسيق الحمولة يستخدم قسم الحمولة في جميع رسائل ECIES (مخطط تشفير متكامل بالمنحنيات البيضوية) (NS وNSR وES) تنسيقاً قائماً على الكتل مشابهاً لـ NTCP2.\nبنية الكتلة التنسيق العام:\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ الحقول:\nblk: 1 بايت - رقم نوع الكتلة size: 2 بايت - حجم حقل البيانات بصيغة Big-endian (ترتيب البايتات من الأكثر أهمية إلى الأقل) (0-65516) data: طول متغير - بيانات خاصة بالكتلة القيود:\nالحد الأقصى لإطار ChaChaPoly (خوارزمية ChaCha20-Poly1305): 65535 بايت Poly1305 MAC (رمز مصادقة الرسالة): 16 بايت الحد الأقصى لإجمالي الكتل: 65519 بايت (65535 - 16) الحد الأقصى للكتلة الواحدة: 65519 بايت (بما في ذلك ترويسة بطول 3 بايت) الحد الأقصى لبيانات الكتلة الواحدة: 65516 بايت أنواع الكتل أنواع الكتل المُعرَّفة:\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension **التعامل مع الكتلة غير المعروفة:** يجب على عمليات التنفيذ تجاهل الكتل ذات أرقام النوع غير المعروفة واعتبارها حشواً. وهذا يضمن التوافق مع الإصدارات المستقبلية.\nقواعد ترتيب الكتل ترتيب رسائل NS إلزامي: - يجب أن تكون كتلة DateTime هي الأولى\nالمسموح: - Garlic Clove (عُنصر فرعي داخل رسالة Garlic في I2P) (type 11) - الخيارات (type 5) - إذا كانت مُنفّذة - الحشو (type 254)\nمحظور: - NextKey, ACK, ACK Request, Termination, MessageNumbers\nمثال لحمولة NS صالحة:\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) ترتيب رسائل NSR مطلوب: - لا شيء (قد تكون الحمولة فارغة)\nمسموح: - Garlic Clove (مصطلح تقني في I2P: جزء من آلية garlic encryption) (النوع 11) - الخيارات (النوع 5) - إذا كانت منفذة - الحشو (النوع 254)\nمحظور: - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers\nمثال على حمولة NSR صالحة:\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) أو\n(empty - ACK only) ترتيب رسائل ES مطلوب: - لا شيء (قد تكون الحمولة فارغة)\nمسموح (بأي ترتيب): - Garlic Clove (وحدة ضمن رسالة Garlic) (النوع 11) - NextKey (النوع 7) - ACK (النوع 8) - ACK Request (النوع 9) - Termination (النوع 4) - إن تم تنفيذها - MessageNumbers (النوع 6) - إن تم تنفيذها - Options (النوع 5) - إن تم تنفيذها - Padding (النوع 254)\nالقواعد الخاصة: - يجب أن تكون كتلة Termination (إنهاء) هي الأخيرة (باستثناء Padding (حشو)) - يجب أن تكون كتلة Padding هي الأخيرة - مسموح بوجود عدة Garlic Cloves (أجزاء رسالة Garlic) - مسموح بما يصل إلى 2 من كتل NextKey (المفتاح التالي) (اتجاه أمامي وعكسي) - غير مسموح بوجود عدة كتل Padding\nأمثلة على حمولات ES الصالحة:\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) كتلة التاريخ والوقت (النوع 0) الغرض: طابع زمني لمنع هجمات إعادة الإرسال والتحقق من انحراف الساعة\nالحجم: 7 بايت (ترويسة 3 بايت + بيانات 4 بايت)\nالتنسيق:\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ الحقول:\nblk: 0 size: 4 (big-endian (ترتيب البايتات الكبير أولاً)) timestamp: 4 بايتات - طابع زمني يونكس بالثواني (غير موقّع، big-endian) تنسيق الطابع الزمني:\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) قواعد التحقق:\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True منع إعادة الإرسال:\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass ملاحظات التنفيذ:\nNS Messages (رسائل NS): يجب أن تكون كتلة DateTime هي الأولى NSR/ES Messages (رسائل NSR/ES): عادةً لا يتم تضمين DateTime Replay Window (نافذة إعادة الإرسال): الحد الأدنى الموصى به هو 5 دقائق Bloom Filter (مرشح بلوم): موصى به لاكتشاف إعادة الإرسال بكفاءة Clock Skew (انحراف الساعة): اسمح بـ 5 دقائق في الماضي وبدقيقتين في المستقبل Garlic Clove Block (كتلة فصّ الثوم) (النوع 11) الغرض: يغلّف رسائل I2NP لإيصالها\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ الحقول:\nblk: 11 size: الحجم الكلي لـ clove (وحدة فرعية ضمن رسالة مركّبة في I2P) (متغيّر) Delivery Instructions: كما هو محدد في مواصفة I2NP type: نوع رسالة I2NP (1 بايت) Message_ID: معرّف رسالة I2NP (4 بايت) Expiration: طابع زمني يونكس بالثواني (4 بايت) I2NP Message body: بيانات رسالة بطول متغيّر تنسيقات تعليمات التسليم:\nالتسليم المحلي (1 بايت):\n+----+ |0x00| +----+ تسليم الوجهة (33 بايت):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ تسليم Router (33 بايت):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ تسليم Tunnel (37 بايت):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ ترويسة رسالة I2NP (9 بايت إجمالاً):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: نوع رسالة I2NP (تخزين قاعدة البيانات، استعلام قاعدة البيانات، بيانات، إلخ) msg_id: معرّف الرسالة بطول 4 بايت expiration: طابع زمني يونكس بطول 4 بايت (بالثواني) فروق مهمة مقارنةً بتنسيق ElGamal Clove:\nبدون شهادة: تم إغفال حقل الشهادة (غير مستخدم في ElGamal (خوارزمية تشفير بمفتاح عام)) بدون معرّف Clove: تم إغفال معرّف Clove (كان دائمًا 0) بدون انتهاء صلاحية Clove: يستخدم انتهاء صلاحية رسالة I2NP بدلًا من ذلك ترويسة مضغّطة: ترويسة I2NP بحجم 9 بايت مقابل تنسيق ElGamal الأكبر كل Clove كتلة منفصلة: لا توجد بنية CloveSet عدة Cloves (فصوص رسائل ضمن garlic encryption):\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] أكثر أنواع رسائل I2NP شيوعًا ضمن الفصوص:\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages **معالجة الفصوص:** def process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) كتلة NextKey (النوع 7) الغرض: تبادل المفاتيح عبر DH ratchet (آلية السقاطة القائمة على ديفي-هيلمان)\nالتنسيق (المفتاح موجود - 38 بايت):\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ التنسيق (معرّف المفتاح فقط - 6 بايت):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ الحقول:\nblk: 7 size: 3 (المعرّف فقط) أو 35 (مع المفتاح) flag: 1 بايت - بتات العلم key ID: 2 بايت - مُعرِّف المفتاح بصيغة Big-endian (ترتيب البايتات من الأعلى إلى الأدنى) (0-32767) Public Key: 32 بايت - مفتاح X25519 عام بصيغة little-endian (ترتيب البايتات من الأدنى إلى الأعلى)، إذا كان بت العلم 0 = 1 بتات العلم:\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) أمثلة على الأعلام:\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 قواعد مُعرّف المفتاح:\nالمعرّفات متسلسلة: 0, 1, 2, \u0026hellip;, 32767 يزداد المعرّف (بمقدار واحد) فقط عند توليد مفتاح جديد يُستخدم المعرّف نفسه لعدة رسائل حتى الـ ratchet (آلية تبديل المفاتيح في التشفير) التالية الحد الأقصى للمعرّف هو 32767 (يجب بدء جلسة جديدة بعدها) أمثلة الاستخدام:\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) منطق المعالجة:\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) عدّة كتل NextKey (المفتاح التالي):\nقد تحتوي رسالة ES (نوع رسالة ضمن I2P) واحدة على ما يصل إلى 2 من كتل NextKey عندما يكون كلا الاتجاهين يجريان ratcheting (آلية تبديل المفاتيح تدريجيًا) في الوقت نفسه:\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] كتلة ACK (تأكيد الاستلام) (النوع 8) الغرض: تأكيد استلام الرسائل ضمن القناة نفسها\nالتنسيق (ACK (إقرار وصول) واحد - 7 بايت):\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ التنسيق (ACKs متعددة - تأكيدات الاستلام):\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ الحقول:\nblk: 8 size: 4 * عدد ACKs (تأكيدات الاستلام) (الحد الأدنى 4) لكل ACK: tagsetid: 2 بايت - معرّف مجموعة الوسوم بصيغة Big-endian (ترتيب البايتات من الأعلى أهمية إلى الأقل) (0-65535) N: 2 بايت - رقم الرسالة بصيغة Big-endian (0-65535) تحديد معرّف مجموعة الوسوم:\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 مثال واحد لـ ACK (إقرار الاستلام):\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) مثال لعدة ACKs (تأكيدات الاستلام):\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) المعالجة:\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) متى يجب إرسال ACKs (تأكيدات الاستلام):\nطلب إقرار (ACK) صريح: الرد دائماً على كتلة طلب ACK تسليم LeaseSet: عندما يضمّن المرسل LeaseSet في الرسالة إنشاء الجلسة: قد يرسل ACK لـ NS/NSR (مع أن البروتوكول يفضّل ACK الضمني عبر ES) تأكيد Ratchet (آلية تدوير المفاتيح): قد يرسل ACK عند استلام NextKey طبقة التطبيقات: حسب ما يتطلبه بروتوكول الطبقة الأعلى (مثلاً، Streaming) توقيت ACK:\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None كتلة طلب ACK (تأكيد الاستلام) (النوع 9) الغرض: طلب تأكيد استلام ضمن نفس القناة (in-band) للرسالة الحالية\nالتنسيق:\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ الحقول:\nblk: 9 size: 1 flg: 1 بايت - أعلام (جميع البتات غير مستخدمة حالياً، مُعيَّنة إلى 0) الاستخدام:\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] استجابة المتلقي:\nعند استلام ACK Request (طلب تأكيد الاستلام):\nمع بيانات فورية: تضمين كتلة ACK (إقرار) في الاستجابة الفورية بدون بيانات فورية: ابدأ مؤقّتًا (على سبيل المثال، 100 مللي ثانية) وأرسل ES فارغة مع ACK (إقرار) إذا انتهت مهلة المؤقّت Tag Set ID (معرّف مجموعة الوسوم): استخدم tagset ID الوارد الحالي رقم الرسالة: استخدم رقم الرسالة المرتبط بـ session tag (وسم الجلسة) المستلم المعالجة:\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) متى ينبغي استخدام ACK Request (طلب تأكيد الاستلام):\nالرسائل الحرِجة: رسائل يجب تأكيد استلامها تسليم LeaseSet: عند تضمين LeaseSet Session Ratchet (آلية الراتشِت للجلسة): بعد إرسال كتلة NextKey نهاية الإرسال: عندما لا يملك المُرسِل مزيدًا من البيانات لإرسالها لكنه يريد تأكيدًا متى لا يُنصح باستخدامه:\nبروتوكول التدفق: تتولى طبقة التدفق التعامل مع ACKs (إشعارات الاستلام) رسائل عالية التكرار: تجنّب طلب ACK لكل رسالة (عبء إضافي) Datagrams غير مهمة: عادةً لا تحتاج raw datagrams (رزم بيانات عديمة الاتصال) إلى ACKs كتلة الإنهاء (النوع 4) الحالة: غير منفذ\nالغرض: إنهاء الجلسة بشكل منظّم\nالتنسيق:\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ الحقول:\nblk: 4 size: 1 بايت أو أكثر rsn: 1 بايت - رمز السبب addl data: بيانات إضافية اختيارية (يعتمد التنسيق على السبب) رموز الأسباب:\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific **الاستخدام (عند التنفيذ):** # Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) القواعد:\nيجب أن تكون آخر كتلة باستثناء Padding (الحشو) يجب أن يأتي Padding (الحشو) بعد Termination (الإنهاء) إذا وُجد غير مسموح في رسائل NS أو NSR مسموح فقط في رسائل ES كتلة الخيارات (النوع 5) الحالة: غير مُنفّذ\nالغرض: التفاوض على معلمات الجلسة\nالصيغة:\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ الحقول:\nblk: 5 size: 21 بايتاً أو أكثر ver: 1 بايت - نسخة البروتوكول (يجب أن تكون 0) flg: 1 بايت - الأعلام (جميع البتات غير مستخدمة حالياً) STL: 1 بايت - طول وسم الجلسة (يجب أن يكون 8) STimeout: 2 بايت - مهلة خمول الجلسة بالثواني (big-endian، ترتيب البايتات من الأكثر أهمية إلى الأقل) SOTW: 2 بايت - نافذة الوسوم الصادرة لدى المرسِل (big-endian) RITW: 2 بايت - نافذة الوسوم الواردة لدى المستقبِل (big-endian) tmin, tmax, rmin, rmax: 1 بايت لكل منها - معلمات الحشو (بصيغة 4.4 ذات نقطة ثابتة) tdmy: 2 بايت - أقصى مقدار من حركة المرور الوهمية المستعد لإرساله (بايت/ثانية، big-endian) rdmy: 2 بايت - حركة المرور الوهمية المطلوبة (بايت/ثانية، big-endian) tdelay: 2 بايت - أقصى تأخير داخل الرسالة مستعد لإدراجه (مللي ثانية، big-endian) rdelay: 2 بايت - التأخير داخل الرسالة المطلوب (مللي ثانية، big-endian) more_options: متغير - امتدادات مستقبلية معلمات الحشو (تمثيل ثابت الفاصلة 4.4):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) التفاوض حول نافذة الوسوم:\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size القيم الافتراضية (عندما لا يتم التفاوض على الخيارات):\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } كتلة أرقام الرسائل (النوع 6) الحالة: غير مُنفّذ\nالغرض: الإشارة إلى آخر رسالة مُرسلة في مجموعة الوسوم السابقة (يتيح الكشف عن الفجوات)\nالتنسيق:\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ الحقول:\nblk: 6 size: 2 PN: 2 بايت - رقم آخر رسالة لمجموعة الوسوم السابقة (big-endian (ترتيب بايت كبير), 0-65535) تعريف PN (الرقم السابق):\nPN هو فهرس آخر وسم تم إرساله ضمن مجموعة الوسوم السابقة.\nالاستخدام (عند التنفيذ):\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] مزايا المتلقي:\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) القواعد:\nيجب ألا يُرسَل ضمن مجموعة الوسوم 0 (لا توجد مجموعة وسوم سابقة) يُرسَل فقط ضمن رسائل ES يُرسَل فقط في أول رسالة أو رسائل من مجموعة وسوم جديدة قيمة PN من منظور المُرسِل (آخر وسم أرسله المُرسِل) العلاقة بـ Signal:\nفي خوارزمية Signal Double Ratchet، تكون PN ضمن رأس الرسالة. في ECIES (مخطط التشفير المتكامل بالمنحنيات الإهليلجية)، تكون داخل الحمولة المشفّرة وهي اختيارية.\nكتلة الحشو (النوع 254) الغرض: مقاومة تحليل حركة المرور وتمويه حجم الرسائل\nالتنسيق:\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ الحقول:\nblk: 254 size: 0-65516 بايت (big-endian: ترتيب البايت من الأكثر أهمية إلى الأقل) padding: بيانات عشوائية أو أصفار القواعد:\nيجب أن تكون آخر كتلة في الرسالة لا يُسمح بوجود كتل حشو متعددة قد يكون بطول صفري (ترويسة من 3 بايت فقط) قد تكون بيانات الحشو أصفارًا أو بايتات عشوائية الحشو الافتراضي:\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) استراتيجيات مقاومة تحليل حركة المرور:\nالاستراتيجية 1: حجم عشوائي (الافتراضي)\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) الاستراتيجية 2: التقريب إلى مضاعف\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) الاستراتيجية 3: أحجام الرسائل الثابتة\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) الاستراتيجية 4: الحشو المتفاوض عليه (كتلة الخيارات)\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) رسائل الحشو فقط:\nقد تتكوّن الرسائل بالكامل من حشو (من دون بيانات تطبيق):\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] ملاحظات التنفيذ:\nحشو صفري بالكامل: مقبول (سيُشفَّر بواسطة ChaCha20) حشو عشوائي: لا يوفّر أماناً إضافياً بعد التشفير لكنه يستهلك إنتروبيا أكثر الأداء: قد يكون إنشاء الحشو العشوائي مكلفاً حسابياً؛ فكّر في استخدام الأصفار الذاكرة: كتل الحشو الكبيرة تستهلك عرض النطاق الترددي؛ كن حذراً بشأن الحجم الأقصى دليل التنفيذ المتطلبات الأساسية مكتبات التشفير:\nX25519: libsodium، NaCl، أو Bouncy Castle ChaCha20-Poly1305: libsodium، OpenSSL 1.1.0+، أو Bouncy Castle SHA-256: OpenSSL، Bouncy Castle، أو الدعم المدمج في اللغة Elligator2 (مخطط لإخفاء نقاط المنحنى الإهليلجي): دعم المكتبات محدود؛ قد يتطلب تنفيذًا مخصصًا تنفيذ Elligator2:\nElligator2 (تقنية تشفيرية لتمثيل نقاط المنحنيات الإهليلجية كبيانات عشوائية لإخفاء المفاتيح العامة) ليست مُطبَّقة على نطاق واسع. الخيارات:\nOBFS4: وسيلة النقل القابلة للإضافات الخاصة بـTor تتضمن تنفيذ Elligator2 (خوارزمية لإخفاء تمثيل نقاط المنحنى الإهليلجي لتبدو عشوائية) تنفيذ مخصص: استنادًا إلى ورقة Elligator2 kleshni/Elligator: تنفيذ مرجعي على GitHub ملاحظة Java I2P: تستخدم Java I2P مكتبة net.i2p.crypto.eddsa مع إضافات Elligator2 (خوارزمية لتمويه نقاط المنحنيات الإهليلجية) مخصصة.\nترتيب التنفيذ الموصى به المرحلة 1: التشفير الأساسي 1. توليد مفاتيح X25519 DH (ديفي‑هيلمان) وتبادلها 2. تشفير/فك تشفير ChaCha20-Poly1305 AEAD (تشفير موثّق مع بيانات مرتبطة) 3. تجزئة SHA-256 و MixHash (مزج التجزئة) 4. اشتقاق المفاتيح باستخدام HKDF (وظيفة اشتقاق مفاتيح معتمدة على HMAC) 5. ترميز/فك ترميز Elligator2 (خوارزمية إخفاء نقاط المنحنى الإهليلجي) (يمكن استخدام متجهات اختبار في البداية)\nالمرحلة 2: تنسيقات الرسائل 1. رسالة NS (غير مقيّدة) - أبسط تنسيق 2. رسالة NS (مقيّدة) - يضيف مفتاحاً ثابتاً 3. رسالة NSR 4. رسالة ES 5. تحليل الكتل وتوليدها\nالمرحلة 3: إدارة الجلسة 1. إنشاء الجلسة وتخزينها 2. إدارة مجموعة الوسوم (المرسل والمتلقّي) 3. ratchet لوسوم الجلسة (آلية تعاقب لتدوير المفاتيح تدريجياً) 4. ratchet للمفتاح المتماثل 5. استعلام الوسوم وإدارة النافذة\nالمرحلة 4: DH Ratcheting (سقاطة ديفي-هيلمان) 1. التعامل مع كتلة NextKey 2. KDF (دالة اشتقاق المفاتيح) لسقاطة DH 3. إنشاء مجموعة الوسوم بعد السقاطة 4. إدارة مجموعات وسوم متعددة\nالمرحلة 5: منطق البروتوكول 1. آلة حالة NS/NSR/ES (أنواع رسائل تفاوض الجلسة) 2. منع إعادة التشغيل (DateTime، مرشّح بلوم) 3. منطق إعادة الإرسال (عدّة NS/NSR) 4. معالجة ACK\nالمرحلة 6: التكامل 1. معالجة I2NP Garlic Clove (فص الثوم) 2. تجميع LeaseSet 3. تكامل بروتوكول التدفق 4. تكامل بروتوكول الداتاغرام\nتنفيذ المرسِل دورة حياة الجلسة الصادرة:\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() تنفيذ المستقبِل دورة حياة الجلسة الواردة:\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() تصنيف الرسائل تمييز أنواع الرسائل:\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type أفضل الممارسات لإدارة الجلسات تخزين الجلسة:\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] إدارة الذاكرة:\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 استراتيجيات الاختبار اختبارات الوحدة:\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 اختبارات التكامل:\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 متجهات الاختبار:\nنفذ متجهات الاختبار من المواصفة:\nNoise IK Handshake (مصافحة بروتوكول Noise بنمط IK): استخدم متجهات الاختبار القياسية لـ Noise HKDF (دالة اشتقاق المفاتيح القائمة على HMAC): استخدم متجهات الاختبار من RFC 5869 ChaCha20-Poly1305 (خوارزمية تشفير ومصادقة AEAD): استخدم متجهات الاختبار من RFC 7539 Elligator2 (تقنية لإخفاء تمثيل نقاط المنحنى الإهليلجي): استخدم متجهات الاختبار من الورقة البحثية لـ Elligator2 أو OBFS4 اختبارات قابلية التشغيل البيني:\nJava I2P: اختبر مقابل التنفيذ المرجعي لـ Java I2P i2pd: اختبر مقابل تنفيذ i2pd بلغة C++ التقاطات الحزم: استخدم dissector (المحلّل) في Wireshark (إن توفّر) للتحقق من تنسيقات الرسائل عبر التنفيذات: أنشئ test harness (إطار اختبار) يمكنه الإرسال والاستقبال بين التنفيذات اعتبارات الأداء توليد المفاتيح:\nتوليد مفاتيح Elligator2 (خوارزمية تمويه للمفاتيح العامة) مكلف حسابيًا (معدل رفض 50%):\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() البحث عن الوسم:\nاستخدم جداول التجزئة للبحث عن الوسوم بزمن O(1):\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) تحسين الذاكرة:\nتأجيل توليد المفتاح المتماثل:\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key المعالجة الدفعية:\nمعالجة عدة رسائل دفعة واحدة:\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results اعتبارات أمنية نموذج التهديد قدرات الخصم:\nمراقب سلبي: يمكنه رصد جميع حركة المرور على الشبكة مهاجم نشط: يمكنه حقن الرسائل، وتعديلها، وإسقاطها، وإعادة إرسالها عقدة مخترقة: قد يختَرِق router أو وجهة تحليل حركة المرور: يمكنه إجراء تحليل إحصائي لأنماط حركة المرور أهداف الأمان:\nالسرية: محتوى الرسائل مخفي عن المُراقِب التحقق من الهوية: تم التحقق من هوية المرسِل (للجلسات المرتبطة) السرية الأمامية: تظل الرسائل السابقة سرية حتى إذا تم اختراق المفاتيح منع إعادة التشغيل: لا يمكن إعادة تشغيل الرسائل القديمة تمويه حركة المرور: مصافحات لا يمكن تمييزها عن بيانات عشوائية افتراضات التشفير افتراضات الصعوبة:\nX25519 CDH: تُعدّ مسألة ديفي‑هيلمان الحسابية صعبة حسابياً على المنحنى Curve25519 ChaCha20 PRF: ChaCha20 عبارة عن دالة شبه عشوائية Poly1305 MAC: Poly1305 غير قابلة للتزوير تحت هجوم الرسائل المختارة SHA-256 CR: SHA-256 مقاومة للتصادمات HKDF Security: HKDF يستخلص ويُوسّع مفاتيح موزعة توزيعاً منتظماً مستويات الأمان:\nX25519: ~128-بت من الأمن (رتبة المنحنى 2^252) ChaCha20: مفاتيح 256-بت، أمن 256-بت Poly1305: أمن 128-بت (احتمال التصادم) SHA-256: مقاومة التصادم 128-بت، مقاومة الصورة الأولية 256-بت إدارة المفاتيح توليد المفاتيح:\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) تخزين المفاتيح:\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] تدوير المفاتيح:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age إجراءات التخفيف من الهجمات تدابير التخفيف من هجمات إعادة الإرسال التحقق من صحة التاريخ والوقت:\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True مرشح بلوم لرسائل NS:\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] وسم الجلسة للاستخدام مرة واحدة:\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index إجراءات التخفيف من Key Compromise Impersonation (KCI) (انتحال الهوية نتيجة اختراق المفتاح) المشكلة: مصادقة رسائل NS معرّضة لهجوم KCI (انتحال الهوية عند انكشاف المفتاح) (مستوى المصادقة 1)\nالتخفيف:\nانتقل إلى NSR (مستوى المصادقة 2) بأسرع ما يمكن لا تثق بـحمولة NS في العمليات الحرجة أمنياً انتظر تأكيد NSR قبل تنفيذ إجراءات لا رجعة فيها def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) تدابير التخفيف من هجمات حجب الخدمة الحماية من إغراق NS:\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 حدود تخزين الوسوم:\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count الإدارة التكيفية للموارد:\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } مقاومة تحليل حركة المرور ترميز Elligator2 (تقنية ترميز تجعل نقاط المنحنى الإهليلجي تبدو كبيانات عشوائية):\nيضمن أن رسائل المصافحة غير قابلة للتمييز عن العشوائية:\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string استراتيجيات الحشو:\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) هجمات التوقيت:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) مزالق التنفيذ الأخطاء الشائعة:\nإعادة استخدام Nonce (عدد يُستخدم مرة واحدة): لا تُعِد أبدًا استخدام أزواج (key, nonce) # BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC جيد: nonce (رقم يُستخدم مرة واحدة) فريد لكل رسالة ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) 2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR ```python # سيئ: إعادة استخدام مفتاح مؤقت ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # سيئ # جيد: مفتاح جديد لكل رسالة send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator سيئ: مولّد أرقام عشوائية غير تشفيري import random key = bytes([random.randint(0, 255) for _ in range(32)]) # غير آمن جيد: مولّد أرقام عشوائية آمن تشفيرياً import os key = os.urandom(32) 4. **Timing Attacks**: Use constant-time comparisons ```python # سيئ: مقارنة تتوقف مبكرًا if computed_mac == received_mac: # تسريب عبر التوقيت pass # جيد: مقارنة بزمن ثابت if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data سيئ: فك التشفير قبل التحقق plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # فات الأوان if not mac_ok: return error جيد: AEAD (التشفير المصادق مع بيانات مرتبطة) يتحقق قبل فك التشفير try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError:\nreturn error 6. **Key Deletion**: Securely wipe keys from memory ```python # سيئ: حذف بسيط del private_key # لا يزال في الذاكرة # جيد: الكتابة فوق البيانات قبل الحذف for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# حالات اختبار حرجة أمنياً def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# ECIES فقط (مُوصى به لعمليات النشر الجديدة) i2cp.leaseSetEncType=4 # ثنائي المفتاح (ECIES (مخطط تشفير مدمج يعتمد المنحنيات الإهليلجية) + ElGamal (مخطط تشفير بالمفتاح العام) للتوافق) i2cp.leaseSetEncType=4,0 # ElGamal فقط (خوارزمية تشفير بالمفتاح العام؛ قديم، غير موصى به) i2cp.leaseSetEncType=0 LeaseSet Type:\n# LS2 القياسي (الإصدار الثاني من leaseSet، والأكثر شيوعًا) i2cp.leaseSetType=3 # LS2 مُشفّر (blinded destinations، وجهات محجوبة الهوية) i2cp.leaseSetType=5 # Meta LS2 (وجهات متعددة) i2cp.leaseSetType=7 Additional Options:\n# مفتاح ثابت لـ ECIES (نظام تشفير مدمج يعتمد على المنحنيات الإهليلجية) (اختياري، يُولَّد تلقائياً إذا لم يتم تحديده) # مفتاح عام X25519 (خوارزمية لتبادل المفاتيح على منحنى بيضاوي) بطول 32 بايت، مُرمَّز بترميز Base64 i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # نوع التوقيع (لـ LeaseSet) i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# ECIES (مخطط التشفير المتكامل بالمنحنيات الإهليلجية) بين Router و Router i2p.router.useECIES=true Build Properties:\n// لعملاء I2CP (جافا) Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[الحدود] # حد الذاكرة لجلسات ECIES (مخطط تشفير متكامل باستخدام المنحنيات الإهليلجية) ecies.memory = 128M [ecies] # تفعيل ECIES (مخطط التشفير المتكامل بالمنحنيات الإهليلجية) enabled = true # ECIES (مخطط تشفير متكامل بالمنحنيات الإهليلجية) فقط أو ثنائي المفتاح compatibility = true # true = ثنائي المفاتيح, false = ECIES فقط (مخطط تشفير متكامل بالمنحنيات الإهليلجية) Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # ECIES (مخطط تشفير متكامل بالمنحنيات الإهليلجية) فقط ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# إضافة ECIES (نظام التشفير المتكامل بالمنحنيات الإهليلجية) مع الإبقاء على ElGamal (خوارزمية إل‑غامال) i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# تحقق من أنواع الاتصال i2prouter.exe status # أو http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# إزالة ElGamal (خوارزمية تشفير) i2cp.leaseSetEncType=4 Step 4: Restart Application\n# أعد تشغيل I2P router أو التطبيق systemctl restart i2p # أو i2prouter.exe restart Rollback Plan:\n# عُد إلى ElGamal (خوارزمية تشفير) فقط إذا ظهرت مشاكل i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# الحد الأقصى للجلسات الواردة i2p.router.maxInboundSessions=1000 # الحد الأقصى للجلسات الصادرة i2p.router.maxOutboundSessions=1000 # مهلة الجلسة (ثوانٍ) i2p.router.sessionTimeout=600 Memory Limits:\n# حد تخزين الوسوم (KB) i2p.ecies.maxTagMemory=10240 # 10 ميغابايت # نافذة النظر المسبق i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# رسائل ما قبل ratchet (آلية تدوير المفاتيح التدرّجية للتشفير) i2p.ecies.ratchetThreshold=4096 # الوقت قبل ratchet (آلية السقاطة التشفيرية) (بالثواني) i2p.ecies.ratchetTimeout=600 # 10 minutes Monitoring and Debugging Logging:\n# فعّل تسجيل تصحيح الأخطاء لـ ECIES (نظام التشفير المتكامل بالمنحنيات الإهليلجية) logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # أمثلة print(\u0026#34;NS (bound, 1KB payload):\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;bytes\u0026#34;) # الناتج: 1120 بايت print(\u0026#34;NSR (حمولة 1KB):\u0026#34;, calculate_nsr_size(1024), \u0026#34;بايت\u0026#34;) # الناتج: 1096 بايت print(\u0026#34;ES (حمولة 1KB):\u0026#34;, calculate_es_size(1024), \u0026#34;بايت\u0026#34;) # الناتج: 1048 بايت Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"مخطط التشفير المتكامل بالمنحنى الإهليلجي لـ I2P (X25519 + AEAD (تشفير موثق مع بيانات مرتبطة))","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"مواصفة تشفير ECIES-X25519-AEAD-Ratchet (آلية السقاطة الأمنية)","url":"/ar/docs/specs/ecies/"},{"categories":null,"content":" مهمل: SSU (بروتوكول UDP آمن شبه موثوق) تم استبداله بـSSU2 . أزالت Java I2P SSU في الإصدار 2.4.0 (API 0.9.61)، وأزالته i2pd في 2.44.0 (API 0.9.56). يُحتفَظ بهذا المستند لأغراض مرجعية تاريخية فقط.\nأبرز النقاط نقل عبر UDP يوفّر تسليمًا مشفّرًا ومُصادقًا عليه من نقطة إلى نقطة لرسائل I2NP. اعتمد على مصافحة Diffie–Hellman بطول 2048 بت (نفس العدد الأوّلي المستخدم في ElGamal). حمل كل داتاغرام HMAC-MD5 بحجم 16 بايت (صيغة مُقتطعة غير قياسية) + IV بحجم 16 بايت، تليه حمولة مشفّرة باستخدام AES-256-CBC. يُجرى تتبّع منع هجمات الإعادة وحالة الجلسة داخل الحمولة المشفّرة. رأس الرسالة [16-byte MAC][16-byte IV][encrypted payload] حساب MAC (رمز تحقق الرسالة) المستخدم: HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8))) باستخدام مفتاح MAC بطول 32 بايت. كان طول الحمولة بتنسيق الكبير أولاً (big-endian) بطول 16-بت، ويُضاف ضمن عملية احتساب MAC. كان الإصدار الافتراضي للبروتوكول 0؛ وكانت القيمة الافتراضية لـ netId 2 (الشبكة الرئيسية).\nمفاتيح الجلسة ومفاتيح MAC (رمز مصادقة الرسالة) مشتقة من السر المشترك لـ DH (ديفي-هيلمان):\nحوّل القيمة المشتركة إلى مصفوفة بايتات big-endian (ترتيب البايتات من الأكثر أهمية أولاً) (أضف 0x00 في المقدمة إذا كان البت الأعلى مضبوطًا). مفتاح الجلسة: أول 32 بايتًا (استكمل بأصفار إذا كان أقصر). مفتاح MAC: البايتات 33–64؛ إن لم تكفِ، فارجع إلى تجزئة SHA-256 للقيمة المشتركة. الحالة لم تعد Routers تعلن عن عناوين SSU. ينبغي على العملاء الانتقال إلى بروتوكولات النقل SSU2 أو NTCP2. يمكن العثور على تنفيذات سابقة في الإصدارات الأقدم:\nمصادر Java قبل الإصدار 2.4.0 ضمن router/transport/udp مصادر i2pd قبل الإصدار 2.44.0 للاطلاع على السلوك الحالي لنقل UDP، راجع مواصفة SSU2 .\n","description":"نقل UDP الأصلي المستخدم قبل SSU2","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"نقل SSU (مهمل)","url":"/ar/docs/legacy/ssu/"},{"categories":null,"content":"1. ما معنى \u0026ldquo;مجهول الهوية\u0026rdquo; يوفر I2P عدم الكشف عن الهوية العملي—وليس الخفاء التام. يُعرّف عدم الكشف عن الهوية بأنه صعوبة قيام خصم بمعرفة المعلومات التي ترغب في الحفاظ على خصوصيتها: من أنت، وأين أنت، أو مع من تتحدث. عدم الكشف عن الهوية المطلق مستحيل؛ بدلاً من ذلك، يهدف I2P إلى تحقيق عدم كشف كافٍ عن الهوية في مواجهة الخصوم السلبيين والنشطين على المستوى العالمي.\nتعتمد خصوصيتك على كيفية تكوين I2P، وكيفية اختيار الأقران والاشتراكات، وما هي التطبيقات التي تعرضها.\n2. التطور التشفيري وتطور النقل (2003 ← 2025) Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental **المجموعة التشفيرية الحالية (Noise XK):** - **X25519** لتبادل المفاتيح - **ChaCha20/Poly1305 AEAD** للتشفير - **Ed25519 (EdDSA-SHA512)** للتوقيعات - **SHA-256** للتجزئة و HKDF - اختياري **ML-KEM hybrids** للاختبار ما بعد الكمي تم إيقاف جميع استخدامات ElGamal و AES-CBC. النقل بالكامل عبر NTCP2 (TCP) و SSU2 (UDP)؛ كلاهما يدعم IPv4/IPv6، السرية الأمامية (forward secrecy)، وإخفاء فحص الحزم العميق (DPI obfuscation).\n3. ملخص بنية الشبكة شبكة مزج حرة التوجيه: يحدد المرسلون والمستقبلون أنفاقهم الخاصة. لا توجد سلطة مركزية: التوجيه والتسمية لا مركزيان؛ كل router يحتفظ بالثقة المحلية. أنفاق أحادية الاتجاه: الوارد والصادر منفصلان (مدة حياة 10 دقائق). أنفاق استكشافية: قفزتان بشكل افتراضي؛ أنفاق العملاء 2-3 قفزات. موجهات Floodfill: حوالي 1,700 من أصل 55,000 عقدة (~6%) تحتفظ بـ NetDB الموزعة. تدوير NetDB: تدور مساحة المفاتيح يوميًا عند منتصف الليل بتوقيت UTC. عزل قواعد البيانات الفرعية: منذ الإصدار 2.4.0، يستخدم كل عميل وrouter قواعد بيانات منفصلة لمنع الربط. 4. فئات الهجمات والدفاعات الحالية Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. --- 5. قاعدة بيانات الشبكة الحديثة (NetDB) الحقائق الأساسية (لا تزال دقيقة): - قاعدة بيانات Kademlia المعدلة تخزن RouterInfo و LeaseSets. - تجزئة المفاتيح باستخدام SHA-256؛ استعلامات متوازية إلى أقرب 2 floodfills مع مهلة 10 ثواني. - عمر LeaseSet ≈ 10 دقائق (LeaseSet2) أو 18 ساعة (MetaLeaseSet).\nأنواع جديدة (منذ 0.9.38): - LeaseSet2 (النوع 3) – أنواع تشفير متعددة، مع طابع زمني. - EncryptedLeaseSet2 (النوع 5) – وجهة مخفية (blinded destination) للخدمات الخاصة (مصادقة DH أو PSK). - MetaLeaseSet (النوع 7) – استضافة متعددة (multihoming) وفترات انتهاء صلاحية ممتدة.\nترقية أمنية رئيسية – عزل قاعدة البيانات الفرعية (2.4.0): - يمنع الربط بين router↔العميل. - كل عميل وrouter يستخدمان أجزاء netDb منفصلة. - تم التحقق والمراجعة (2.5.0).\n6. الوضع المخفي والمسارات المقيدة الوضع المخفي: مُنفّذ (تلقائي في الدول المقيدة وفقاً لتقييمات Freedom House).\nأجهزة الـ router لا تنشر RouterInfo ولا توجّه حركة المرور. المسارات المقيدة: منفّذ جزئياً (أنفاق موثوقة أساسية فقط).\nالتوجيه الشامل عبر نظراء موثوقين لا يزال مخططاً له (3.0+). المقايضة: خصوصية أفضل ↔ مساهمة أقل في سعة الشبكة.\n7. هجمات حجب الخدمة وFloodfill تاريخياً: أظهرت أبحاث UCSB لعام 2013 إمكانية السيطرة على Eclipse وFloodfill. تشمل الدفاعات الحديثة: - تدوير يومي لمساحة المفاتيح. - حد Floodfill ≈ 500، واحد لكل /16. - تأخيرات عشوائية للتحقق من التخزين. - تفضيل أجهزة التوجيه الأحدث (2.6.0). - إصلاح التسجيل التلقائي (2.9.0). - توجيه مدرك للازدحام وتقييد الإيجار (2.4.0+).\nهجمات floodfill تبقى ممكنة نظريًا ولكن أصعب عمليًا.\n8. تحليل حركة المرور والرقابة من الصعب تحديد حركة مرور I2P: لا يوجد منفذ ثابت، ولا مصافحة بنص واضح، وحشو عشوائي. حزم NTCP2 وSSU2 تحاكي البروتوكولات الشائعة وتستخدم إخفاء رأس ChaCha20. استراتيجيات الحشو أساسية (أحجام عشوائية)، حركة المرور الوهمية غير مطبقة (مكلفة). الاتصالات من عقد خروج Tor محظورة منذ الإصدار 2.6.0 (لحماية الموارد).\n9. القيود المستمرة (المعترف بها) ارتباط التوقيت للتطبيقات منخفضة الكمون يبقى خطرًا أساسيًا. هجمات التقاطع لا تزال قوية ضد الوجهات العامة المعروفة. هجمات Sybil تفتقر إلى دفاع كامل (HashCash غير مفعّل). حركة المرور ذات المعدل الثابت والتأخيرات غير التافهة تبقى غير منفذة (مخطط لها في 3.0). الشفافية حول هذه القيود متعمدة — فهي تمنع المستخدمين من المبالغة في تقدير إخفاء الهوية.\n10. إحصائيات الشبكة (2025) ~55,000 router نشط حول العالم (↑ من 7,000 في 2013) ~1,700 floodfill router (~6%) 95% يشاركون في توجيه tunnel افتراضياً مستويات عرض النطاق الترددي: K (\u0026lt;12 كيلوبايت/ثانية) → X (\u0026gt;2 ميجابايت/ثانية) الحد الأدنى لمعدل floodfill: 128 كيلوبايت/ثانية وحدة تحكم router تتطلب Java 8+، مخطط Java 17+ في الدورة القادمة 11. التطوير والموارد المركزية الموقع الرسمي: geti2p.net الوثائق: Documentation مستودع Debian: https://deb.i2pgit.org ( استبدل deb.i2p2.de في أكتوبر 2023 ) الكود المصدري: https://i2pgit.org/I2P_Developers/i2p.i2p (Gitea) + نسخة مرآة على GitHub جميع الإصدارات موقعة بحاويات SU3 (RSA-4096، مفاتيح zzz/str4d) لا توجد قوائم بريدية نشطة؛ المجتمع عبر https://i2pforum.net و IRC2P. دورة التحديث: إصدارات مستقرة كل 6–8 أسابيع. 12. ملخص تحسينات الأمان منذ الإصدار 0.8.x Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing --- 13. العمل المعروف غير المحلول أو المخطط له مسارات مقيدة شاملة (trusted-peer routing) ← مخطط لها في 3.0. تأخير/تجميع غير تافه لمقاومة التوقيت ← مخطط له في 3.0. حشو متقدم وحركة مرور وهمية ← غير مُنفذ. التحقق من الهوية باستخدام HashCash ← البنية التحتية موجودة لكنها غير نشطة. استبدال R5N DHT ← اقتراح فقط. 14. المراجع الرئيسية Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) وثائق I2P الرسمية 15. الخاتمة نموذج إخفاء الهوية الأساسي في I2P صمد لعقدين من الزمن: التضحية بالتفرد العالمي مقابل الثقة المحلية والأمان. من ElGamal إلى X25519، ومن NTCP إلى NTCP2، ومن إعادة التهيئة اليدوية إلى عزل Sub-DB، تطور المشروع مع الحفاظ على فلسفته في الدفاع المتعمق والشفافية.\nتبقى العديد من الهجمات ممكنة نظريًا ضد أي mixnet منخفض التأخير، لكن التحصين المستمر لـ I2P يجعلها غير عملية بشكل متزايد. الشبكة أكبر وأسرع وأكثر أمانًا من أي وقت مضى — ومع ذلك لا تزال صادقة بشأن حدودها.\n","description":"كتالوج الهجمات المأخوذة بالاعتبار في تصميم I2P والتدابير الوقائية المطبقة","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"نموذج التهديدات في I2P","url":"/ar/docs/overview/threat-model/"}]
[{"categories":null,"content":" Legacy-Status: Dieser Inhalt wird ausschließlich als historische Referenz vorgehalten. Er dokumentiert das tunnel system, das vor I2P 0.6.1.10 ausgeliefert wurde, und sollte nicht für moderne Entwicklung verwendet werden. Hinweise für den produktiven Einsatz finden Sie in der aktuellen Implementierung .\nDas ursprüngliche tunnel-Subsystem verwendete ebenfalls unidirektionale tunnel, unterschied sich jedoch beim Nachrichtenlayout, bei der Duplikaterkennung und bei der Aufbaustrategie. Viele der nachfolgenden Abschnitte orientieren sich an der Struktur des als veraltet markierten Dokuments, um den Vergleich zu erleichtern.\n1. Tunnel-Übersicht Tunnels wurden als geordnete Sequenzen von vom Ersteller ausgewählten Peers aufgebaut. Die Tunnel-Längen reichten von 0–7 Hops, mit mehreren Einstellmöglichkeiten für Padding, Drosselung und die Erzeugung von chaff (Täuschdaten). Eingehende Tunnels lieferten Nachrichten von einem nicht vertrauenswürdigen Gateway an den Ersteller (Endpunkt); ausgehende Tunnels leiteten Daten vom Ersteller weg. Die Lebensdauer der Tunnels betrug 10 Minuten; danach wurden neue Tunnels aufgebaut (oft mit denselben Peers, aber unterschiedlichen Tunnel-IDs). 2. Betrieb im Legacy-Design 2.1 Nachrichtenvorverarbeitung Gateways sammelten ≤32 KB an I2NP-Nutzlast, wählten Padding aus und erzeugten eine Nutzlast, die Folgendes enthielt:\nEin 2-Byte-Feld für die Padding-Länge und entsprechend viele Zufallsbytes Eine Folge von {instructions, I2NP message}-Paaren, die Zustellziele, Fragmentierung und optionale Verzögerungen beschreiben Vollständige I2NP-Nachrichten, aufgefüllt bis zur 16-Byte-Grenze Zustellanweisungen packten Routing-Informationen in Bitfelder (Zustelltyp, Verzögerungs-Flags, Fragmentierungs-Flags und optionale Erweiterungen). Fragmentierte Nachrichten enthielten eine 4-Byte-Nachrichten-ID sowie ein Index-/Letztes-Fragment-Flag.\n2.2 Gateway-Verschlüsselung Das Legacy-Design fixierte die tunnel-Länge für die Verschlüsselungsphase auf acht Hops. Gateways schichteten AES-256/CBC- sowie Prüfsummenblöcke aufeinander, sodass jeder Hop die Integrität prüfen konnte, ohne die Nutzlast zu verkleinern. Die Prüfsumme selbst war ein aus SHA-256 abgeleiteter Block, der in die Nachricht eingebettet war.\n2.3 Teilnehmerverhalten Die Teilnehmer verfolgten eingehende tunnel-IDs, überprüften die Integrität frühzeitig und verwarfen Duplikate vor dem Weiterleiten. Da Padding- und Verifizierungsblöcke eingebettet waren, blieb die Nachrichtengröße unabhängig von der Anzahl der Hops konstant.\n2.4 Verarbeitung am Endpunkt Die Endpunkte entschlüsselten die mehrschichtigen Blöcke sequenziell, validierten die Prüfsummen und spalteten die Nutzlast wieder in die kodierten Anweisungen sowie I2NP-Nachrichten zur Weiterleitung.\n3. Tunnelaufbau (veralteter Prozess) Peer-Auswahl: Peers wurden aus lokal gepflegten Profilen (exploratory vs. client) ausgewählt. Das ursprüngliche Dokument betonte bereits die Abmilderung des Predecessor-Angriffs durch die Wiederverwendung geordneter Peer-Listen pro tunnel pool. Zustellung von Anfragen: Build-Nachrichten wurden Hop-by-Hop weitergeleitet, mit verschlüsselten Abschnitten für jeden Peer. Alternative Ideen wie telescopic extension (teleskopische Erweiterung), midstream rerouting (Umleitung in der Mitte der Kette) oder das Entfernen von Prüfsummenblöcken wurden als Experimente diskutiert, aber nie übernommen. Pooling: Jede lokale Destination hielt separate eingehende und ausgehende Pools. Einstellungen umfassten gewünschte Anzahl, Backup tunnels, Längenvarianz, Drosselung und Padding-Richtlinien. 4. Drosselungs- und Mischkonzepte Die ältere Ausarbeitung schlug mehrere Strategien vor, die spätere Releases prägten:\nWeighted Random Early Discard (WRED, gewichtete zufällige Frühverwerfung) zur Staukontrolle Pro-Tunnel-Drosselungen auf Basis gleitender Mittelwerte der jüngsten Nutzung Optionale Steuerungen für chaff (Füllverkehr) und batching (Stapelbildung) (noch nicht vollständig implementiert) 5. Archivierte Alternativen Abschnitte des ursprünglichen Dokuments behandelten Ideen, die nie eingesetzt wurden:\nEntfernen von Prüfsummenblöcken, um die pro Hop anfallende Verarbeitung zu reduzieren Teleskopieren von tunnels im laufenden Betrieb, um die Peer-Zusammensetzung zu ändern Wechsel zu bidirektionalen tunnels (letztlich verworfen) Verwendung kürzerer Hashes oder anderer Padding-Verfahren (Auffüllungsverfahren) Diese Ideen stellen weiterhin einen wertvollen historischen Kontext dar, spiegeln jedoch die moderne Codebasis nicht wider.\nReferenzen Ursprüngliches Legacy-Dokumentarchiv (vor 0.6.1.10) Tunnel-Übersicht für die aktuelle Terminologie Peer-Profiling und -Auswahl für moderne Heuristiken ","description":"Archivierte Beschreibung des vor I2P 0.6.1.10 verwendeten tunnel-Designs.","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"Alte Tunnel-Implementierung (Legacy)","url":"/de/docs/legacy/old-implementation/"},{"categories":null,"content":"Die Haupt-I2P-Client-Implementierung verwendet Java. Wenn Sie Java auf einem bestimmten System nicht verwenden können oder möchten, gibt es alternative I2P-Client-Implementierungen, die von Community-Mitgliedern entwickelt und gepflegt werden. Diese Programme bieten dieselbe Kernfunktionalität unter Verwendung verschiedener Programmiersprachen oder Ansätze.\nVergleichstabelle Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements --- i2pd (C++) Website: https://i2pd.website Beschreibung: i2pd (der I2P Daemon) ist ein voll funktionsfähiger I2P-Client, der in C++ implementiert ist. Er ist seit vielen Jahren stabil für den produktiven Einsatz (seit etwa 2016) und wird aktiv von der Community gepflegt. i2pd implementiert die I2P-Netzwerkprotokolle und -APIs vollständig, wodurch er vollständig kompatibel mit dem Java-I2P-Netzwerk ist. Dieser C++-Router wird oft als leichtgewichtige Alternative auf Systemen verwendet, auf denen die Java-Laufzeitumgebung nicht verfügbar oder nicht erwünscht ist. i2pd enthält eine integrierte webbasierte Konsole für Konfiguration und Überwachung. Es ist plattformübergreifend und in vielen Paketformaten verfügbar — es gibt sogar eine Android-Version von i2pd (zum Beispiel über F-Droid).\nGo-I2P (Go) Repository: https://github.com/go-i2p/go-i2p Beschreibung: Go-I2P ist ein I2P-Client, der in der Programmiersprache Go geschrieben wurde. Es handelt sich um eine unabhängige Implementierung des I2P router, die darauf abzielt, die Effizienz und Portabilität von Go zu nutzen. Das Projekt befindet sich in aktiver Entwicklung, ist jedoch noch in einem frühen Stadium und noch nicht funktionsvollständig. Stand 2025 gilt Go-I2P als experimentell – es wird aktiv von Community-Entwicklern weiterentwickelt, ist jedoch noch nicht für den produktiven Einsatz empfohlen, bis es weiter ausgereift ist. Das Ziel von Go-I2P ist es, einen modernen, leichtgewichtigen I2P router mit voller Kompatibilität zum I2P-Netzwerk bereitzustellen, sobald die Entwicklung abgeschlossen ist.\nI2P+ (Java-Fork) Website: https://i2pplus.github.io Beschreibung: I2P+ ist ein von der Community gepflegter Fork des Standard-Java-I2P-Clients. Es handelt sich nicht um eine Neuimplementierung in einer anderen Programmiersprache, sondern um eine erweiterte Version des Java-routers mit zusätzlichen Funktionen und Optimierungen. I2P+ konzentriert sich darauf, eine verbesserte Benutzererfahrung und bessere Leistung zu bieten, während es vollständig kompatibel mit dem offiziellen I2P-Netzwerk bleibt. Es führt eine aufgefrischte Web-Konsolen-Oberfläche, benutzerfreundlichere Konfigurationsoptionen und verschiedene Optimierungen ein (zum Beispiel verbesserte Torrent-Leistung und bessere Handhabung von Netzwerk-Peers, insbesondere für router hinter Firewalls). I2P+ benötigt eine Java-Umgebung genau wie die offizielle I2P-Software, es ist also keine Lösung für Umgebungen ohne Java. Für Benutzer, die jedoch Java haben und einen alternativen Build mit zusätzlichen Funktionen wünschen, bietet I2P+ eine überzeugende Option. Dieser Fork wird mit den Upstream-I2P-Versionen auf dem neuesten Stand gehalten (wobei die Versionsnummerierung ein \u0026ldquo;+\u0026rdquo; anhängt) und kann von der Projekt-Website bezogen werden.\n","description":"Von der Community gepflegte I2P-Client-Implementierungen (aktualisiert für 2025)","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"Alternative I2P-Clients","url":"/de/docs/overview/alternative-clients/"},{"categories":null,"content":"Warum I2P-spezifischen Code schreiben? Es gibt mehrere Möglichkeiten, Anwendungen in I2P zu nutzen. Mit I2PTunnel können Sie reguläre Anwendungen verwenden, ohne explizite I2P-Unterstützung programmieren zu müssen. Dies ist sehr effektiv für Client-Server-Szenarien, in denen Sie sich mit einer einzelnen Website verbinden müssen. Sie können einfach einen Tunnel mit I2PTunnel erstellen, um sich mit dieser Website zu verbinden, wie in Abbildung 1 dargestellt.\nWenn Ihre Anwendung verteilt ist, benötigt sie Verbindungen zu einer großen Anzahl von Peers. Mit I2PTunnel müssen Sie für jeden Peer, mit dem Sie Kontakt aufnehmen möchten, einen neuen Tunnel erstellen, wie in Abbildung 2 dargestellt. Dieser Prozess kann natürlich automatisiert werden, aber das Ausführen vieler I2PTunnel-Instanzen erzeugt einen erheblichen Overhead. Darüber hinaus müssen Sie bei vielen Protokollen alle Teilnehmer dazu zwingen, denselben Satz von Ports für alle Peers zu verwenden – z.B. wenn Sie zuverlässig DCC-Chat ausführen möchten, müssen sich alle darauf einigen, dass Port 10001 Alice ist, Port 10002 Bob ist, Port 10003 Charlie ist und so weiter, da das Protokoll TCP/IP-spezifische Informationen (Host und Port) enthält.\nAllgemeine Netzwerkanwendungen senden oft viele zusätzliche Daten, die zur Identifizierung von Benutzern verwendet werden könnten. Hostnamen, Portnummern, Zeitzonen, Zeichensätze usw. werden oft ohne Information des Benutzers gesendet. Daher kann die Gestaltung des Netzwerkprotokolls mit speziellem Fokus auf Anonymität vermeiden, dass Benutzeridentitäten kompromittiert werden.\nEs gibt auch Effizienzaspekte zu berücksichtigen, wenn man festlegt, wie man auf I2P interagiert. Die Streaming-Bibliothek und darauf aufbauende Komponenten arbeiten mit Handshakes ähnlich wie TCP, während die Kern-I2P-Protokolle (I2NP und I2CP) strikt nachrichtenbasiert sind (wie UDP oder in manchen Fällen rohes IP). Der wichtige Unterschied besteht darin, dass bei I2P die Kommunikation über ein Long-Fat-Network (Netzwerk mit hoher Bandbreite und hoher Latenz) erfolgt — jede Ende-zu-Ende-Nachricht weist erhebliche Latenzen auf, kann jedoch Nutzdaten von bis zu mehreren KB enthalten. Eine Anwendung, die eine einfache Anfrage und Antwort benötigt, kann jeglichen Zustand eliminieren und die durch Aufbau- und Abbau-Handshakes verursachte Latenz reduzieren, indem sie (Best-Effort-)Datagramme verwendet, ohne sich um MTU-Erkennung oder Fragmentierung von Nachrichten kümmern zu müssen.\nFigure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. Zusammenfassend gibt es mehrere Gründe, I2P-spezifischen Code zu schreiben: Das Erstellen einer großen Anzahl von I2PTunnel-Instanzen verbraucht eine nicht unerhebliche Menge an Ressourcen, was für verteilte Anwendungen problematisch ist (für jeden Peer wird ein neuer tunnel benötigt). Allgemeine Netzwerkprotokolle senden oft viele zusätzliche Daten, die zur Identifizierung von Benutzern verwendet werden können. Die spezifische Programmierung für I2P ermöglicht die Erstellung eines Netzwerkprotokolls, das solche Informationen nicht preisgibt und Benutzer anonym und sicher hält. Netzwerkprotokolle, die für die Verwendung im regulären Internet konzipiert sind, können auf I2P ineffizient sein, da es sich um ein Netzwerk mit deutlich höherer Latenz handelt. I2P unterstützt eine Standard-Plugins-Schnittstelle für Entwickler, damit Anwendungen einfach integriert und verteilt werden können.\nIn Java geschriebene Anwendungen, die über eine HTML-Schnittstelle mittels der Standard-webapps/app.war zugänglich/ausführbar sind, können für die Aufnahme in die I2P-Distribution in Betracht gezogen werden.\nWichtige Konzepte Es gibt einige Änderungen, an die man sich bei der Verwendung von I2P gewöhnen muss:\nZiele Eine Anwendung, die auf I2P läuft, sendet Nachrichten von und empfängt Nachrichten an einem eindeutigen kryptographisch sicheren Endpunkt – einer „destination\u0026quot;. In TCP- oder UDP-Begriffen könnte eine destination (weitgehend) als Äquivalent eines Hostname-Port-Nummer-Paars betrachtet werden, obwohl es einige Unterschiede gibt.\nEin I2P-Destination ist selbst ein kryptografisches Konstrukt — alle an ein Destination gesendeten Daten werden verschlüsselt, als ob es eine universelle Bereitstellung von IPsec gäbe, wobei der (anonymisierte) Standort des Endpunkts signiert wird, als ob es eine universelle Bereitstellung von DNSSEC gäbe. I2P-Destinations sind mobile Identifikatoren — sie können von einem I2P-Router zu einem anderen verschoben werden (oder sogar „Multihoming\u0026quot; betreiben — gleichzeitig auf mehreren Routern operieren). Dies unterscheidet sich deutlich von der TCP- oder UDP-Welt, wo ein einzelner Endpunkt (Port) auf einem einzigen Host bleiben muss. I2P-Destinations sind unhandlich und groß — im Hintergrund enthalten sie einen 2048-Bit-ElGamal-Public-Key für die Verschlüsselung, einen 1024-Bit-DSA-Public-Key für die Signierung und ein Zertifikat variabler Größe, das einen Proof-of-Work oder verblindete Daten enthalten kann. Es gibt bestehende Möglichkeiten, diese langen und unhandlichen Zieladressen durch kurze und einprägsame Namen zu bezeichnen (z.B. \u0026ldquo;irc.duck.i2p\u0026rdquo;), aber diese Techniken garantieren keine globale Eindeutigkeit (da sie lokal in einer Datenbank auf dem Rechner jeder Person gespeichert werden) und der aktuelle Mechanismus ist nicht besonders skalierbar oder sicher (Aktualisierungen der Hostliste werden über \u0026ldquo;Abonnements\u0026rdquo; von Namensdiensten verwaltet). Möglicherweise wird es eines Tages ein sicheres, menschenlesbares, skalierbares und global eindeutiges Benennungssystem geben, aber Anwendungen sollten sich nicht darauf verlassen, dass es vorhanden ist. Weitere Informationen zum Benennungssystem sind verfügbar.\nWährend die meisten Anwendungen nicht zwischen Protokollen und Ports unterscheiden müssen, unterstützt I2P diese durchaus. Komplexe Anwendungen können ein Protokoll, einen Quell-Port und einen Ziel-Port pro Nachricht angeben, um den Datenverkehr auf einem einzelnen Destination zu multiplexen. Details finden Sie auf der Datagram-Seite . Einfache Anwendungen funktionieren, indem sie auf „alle Protokolle\u0026quot; und „alle Ports\u0026quot; eines Destination lauschen.\nAnonymität und Vertraulichkeit I2P bietet transparente Ende-zu-Ende-Verschlüsselung und Authentifizierung für alle Daten, die über das Netzwerk übertragen werden — wenn Bob an Alices destination sendet, kann nur Alices destination die Daten empfangen, und wenn Bob die Datagramm- oder Streaming-Bibliothek verwendet, weiß Alice mit Sicherheit, dass Bobs destination derjenige ist, der die Daten gesendet hat.\nNatürlich anonymisiert I2P transparent die Daten, die zwischen Alice und Bob gesendet werden, aber es tut nichts, um den Inhalt dessen zu anonymisieren, was sie senden. Wenn Alice beispielsweise Bob ein Formular mit ihrem vollständigen Namen, Ausweisdokumenten und Kreditkartennummern sendet, kann I2P nichts dagegen tun. Daher sollten Protokolle und Anwendungen im Hinterkopf behalten, welche Informationen sie schützen möchten und welche Informationen sie bereit sind preiszugeben.\nI2P-Datagramme können bis zu mehrere KB groß sein Anwendungen, die I2P-Datagramme verwenden (entweder raw oder repliable), können im Wesentlichen im Sinne von UDP betrachtet werden – die Datagramme sind ungeordnet, best effort und verbindungslos – aber im Gegensatz zu UDP müssen sich Anwendungen nicht um MTU-Erkennung kümmern und können einfach große Datagramme versenden. Während die Obergrenze nominell 32 KB beträgt, wird die Nachricht für den Transport fragmentiert, was die Zuverlässigkeit des Ganzen verringert. Datagramme über etwa 10 KB werden derzeit nicht empfohlen. Siehe die Datagramm-Seite für Details. Für viele Anwendungen sind 10 KB Daten ausreichend für eine vollständige Anfrage oder Antwort, was es ihnen ermöglicht, transparent in I2P als UDP-ähnliche Anwendung zu operieren, ohne Fragmentierung, erneutes Senden usw. implementieren zu müssen.\nEntwicklungsoptionen Es gibt verschiedene Möglichkeiten, Daten über I2P zu übertragen, jede mit ihren eigenen Vor- und Nachteilen. Die Streaming-Bibliothek ist die empfohlene Schnittstelle und wird von der Mehrheit der I2P-Anwendungen verwendet.\nStreaming-Bibliothek Die vollständige Streaming-Bibliothek ist nun die Standardschnittstelle. Sie ermöglicht die Programmierung mit TCP-ähnlichen Sockets, wie im Streaming-Entwicklungsleitfaden erklärt.\nBOB BOB ist die Basic Open Bridge , die es einer Anwendung in jeder Sprache ermöglicht, Streaming-Verbindungen zu und von I2P herzustellen. Zum jetzigen Zeitpunkt fehlt die UDP-Unterstützung, aber UDP-Unterstützung ist für die nahe Zukunft geplant. BOB enthält auch mehrere Werkzeuge, wie z.B. die Generierung von Zielschlüsseln und die Überprüfung, ob eine Adresse den I2P-Spezifikationen entspricht. Aktuelle Informationen und Anwendungen, die BOB verwenden, finden Sie auf dieser I2P-Website .\nSAM, SAM V2, SAM V3 SAM wird nicht empfohlen. SAM V2 ist in Ordnung, SAM V3 wird empfohlen.\nSAM ist das Simple Anonymous Messaging Protokoll, das es einer Anwendung, die in einer beliebigen Sprache geschrieben wurde, ermöglicht, über einen einfachen TCP-Socket mit einer SAM-Bridge zu kommunizieren und diese Bridge den gesamten I2P-Verkehr multiplexen zu lassen, wobei die Verschlüsselung/Entschlüsselung und ereignisbasierte Verarbeitung transparent koordiniert werden. SAM unterstützt drei Betriebsarten:\nStreams, wenn Alice und Bob Daten zuverlässig und in der richtigen Reihenfolge aneinander senden möchten Beantwortbare Datagramme, wenn Alice Bob eine Nachricht senden möchte, auf die Bob antworten kann Raw-Datagramme, wenn Alice die maximal mögliche Bandbreite und Leistung herausholen möchte und Bob es nicht interessiert, ob der Absender der Daten authentifiziert ist oder nicht (z. B. wenn die übertragenen Daten selbstauthentifizierend sind) SAMv3 verfolgt das gleiche Ziel wie SAM und SAM V2, erfordert jedoch kein Multiplexing/Demultiplexing. Jeder I2P-Stream wird durch seinen eigenen Socket zwischen der Anwendung und der SAM-Bridge verwaltet. Außerdem können Datagramme von der Anwendung durch Datagramm-Kommunikation mit der SAM-Bridge gesendet und empfangen werden.\nSAM V2 ist eine neue Version, die von imule verwendet wird und einige der Probleme in SAM behebt.\nSAM V3 wird von imule seit Version 1.4.0 verwendet.\nI2PTunnel Die I2PTunnel-Anwendung ermöglicht es Anwendungen, spezifische TCP-ähnliche Tunnel zu Peers aufzubauen, indem entweder I2PTunnel-\u0026lsquo;Client\u0026rsquo;-Anwendungen erstellt werden (die auf einem bestimmten Port lauschen und sich mit einem bestimmten I2P-destination verbinden, sobald ein Socket zu diesem Port geöffnet wird) oder I2PTunnel-\u0026lsquo;Server\u0026rsquo;-Anwendungen (die auf einem bestimmten I2P-destination lauschen und bei jeder neuen I2P-Verbindung einen Outproxy zu einem bestimmten TCP-Host/Port herstellen). Diese Streams sind 8-Bit-sauber und werden durch dieselbe Streaming-Bibliothek authentifiziert und gesichert, die auch SAM verwendet, aber es gibt einen nicht trivialen Overhead bei der Erstellung mehrerer eindeutiger I2PTunnel-Instanzen, da jede ihre eigene eindeutige I2P-destination und ihre eigenen Tunnel, Schlüssel usw. hat.\nSOCKS I2P unterstützt einen SOCKS V4 und V5 Proxy. Ausgehende Verbindungen funktionieren gut. Eingehende (Server-) und UDP-Funktionalität können unvollständig und ungetestet sein.\nMinistreaming Entfernt\nEs gab früher eine einfache \u0026ldquo;ministreaming\u0026rdquo;-Bibliothek, aber jetzt enthält ministreaming.jar nur noch die Schnittstellen für die vollständige Streaming-Bibliothek.\nDatagramme Empfohlen für UDP-ähnliche Anwendungen\nDie Datagram-Bibliothek ermöglicht das Senden von UDP-ähnlichen Paketen. Es ist möglich zu verwenden:\nBeantwortbare Datagramme Roh-Datagramme I2CP Nicht empfohlen\nI2CP selbst ist ein sprachunabhängiges Protokoll, aber um eine I2CP-Bibliothek in einer anderen Sprache als Java zu implementieren, muss eine beträchtliche Menge an Code geschrieben werden (Verschlüsselungsroutinen, Objekt-Marshalling, asynchrone Nachrichtenverarbeitung usw.). Während jemand eine I2CP-Bibliothek in C oder einer anderen Sprache schreiben könnte, wäre es höchstwahrscheinlich nützlicher, stattdessen die C SAM-Bibliothek zu verwenden.\nWebanwendungen I2P wird mit dem Jetty-Webserver geliefert, und die Konfiguration zur Verwendung des Apache-Servers ist stattdessen unkompliziert. Jede standardmäßige Webanwendungstechnologie sollte funktionieren.\nBeginnen Sie mit der Entwicklung – Eine einfache Anleitung Die Entwicklung mit I2P erfordert eine funktionierende I2P-Installation und eine Entwicklungsumgebung Ihrer Wahl. Wenn Sie Java verwenden, können Sie die Entwicklung mit der streaming library oder der datagram library beginnen. Bei Verwendung einer anderen Programmiersprache können SAM oder BOB verwendet werden.\nEntwicklung mit der Streaming-Bibliothek Unten finden Sie eine überarbeitete und modernisierte Version des Beispiels von der ursprünglichen Seite. Für das vollständige Beispiel siehe die Legacy-Seite oder unsere Java-Beispiele in der Codebasis.\n// Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\u0026#34;Received: \u0026#34; + s); } Codebeispiel: einfacher Server, der Daten empfängt.\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\u0026#34;Hello I2P!\\n\u0026#34;); bw.flush(); Codebeispiel: Client verbindet sich und sendet eine Zeile.\n","description":"Warum I2P-spezifische Apps schreiben, Schlüsselkonzepte, Entwicklungsoptionen und ein einfacher Einstiegsleitfaden","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"Anwendungsentwicklung","url":"/de/docs/develop/applications/"},{"categories":null,"content":"Übersicht Standard-Base-32 (\u0026ldquo;b32\u0026rdquo;)-Adressen enthalten den Hash des Ziels. Dies funktioniert für verschlüsselte LS2 (LeaseSet2, neues leaseSet-Format; proposal 123) nicht.\nWir können für ein verschlüsseltes LS2 (proposal 123) keine traditionelle Base32-Adresse verwenden, da sie nur den Hash der Destination (Zieladresse) enthält. Sie liefert nicht den nicht-verblindeten öffentlichen Schlüssel. Clients müssen den öffentlichen Schlüssel der Destination, den Signaturtyp, den verblindeten Signaturtyp sowie ein optionales Secret (geheime Zeichenfolge) oder einen privaten Schlüssel kennen, um den leaseset abzurufen und zu entschlüsseln. Daher reicht eine Base32-Adresse allein nicht aus. Der Client benötigt entweder die vollständige Destination (die den öffentlichen Schlüssel enthält) oder den öffentlichen Schlüssel allein. Wenn der Client die vollständige Destination in einem Adressbuch hat und das Adressbuch einen Reverse-Lookup anhand des Hashes unterstützt, kann der öffentliche Schlüssel abgerufen werden.\nDieses Format setzt den öffentlichen Schlüssel anstelle des Hashes in eine Base32-Adresse. Dieses Format muss außerdem den Signaturtyp des öffentlichen Schlüssels und den Signaturtyp des Blinding-Verfahrens enthalten.\nDieses Dokument spezifiziert ein b32-Format für diese Adressen. Obwohl wir dieses neue Format in Diskussionen als \u0026ldquo;b33\u0026rdquo;-Adresse bezeichnet haben, behält das tatsächliche neue Format das übliche Suffix \u0026ldquo;.b32.i2p\u0026rdquo; bei.\nImplementierungsstatus Vorschlag 123 (Neue netDB-Einträge) wurde in Version 0.9.43 (Oktober 2019) vollständig implementiert. Der verschlüsselte Funktionsumfang von LS2 (LeaseSet2, der zweite LeaseSet-Typ) ist bis einschließlich Version 2.10.0 (September 2025) stabil geblieben, ohne inkompatible Änderungen am Adressierungsformat oder an den kryptografischen Spezifikationen.\nWichtige Implementierungsmeilensteine: - 0.9.38: Floodfill-Unterstützung für Standard-LS2 mit Offline-Schlüsseln - 0.9.39: RedDSA-Signaturtyp 11 und grundlegende Verschlüsselung/Entschlüsselung - 0.9.40: Vollständige Unterstützung der B32-Adressierung (Proposal 149) - 0.9.41: X25519-basierte Authentifizierung pro Client - 0.9.42: Alle Blinding-Funktionen (Verblindung) betriebsbereit - 0.9.43: Vollständige Implementierung bekanntgegeben (Oktober 2019)\nEntwurf Das neue Format enthält den nicht verblindeten öffentlichen Schlüssel, den nicht verblindeten Signaturtyp und den verblindeten Signaturtyp. Gibt optional Anforderungen an Secret (gemeinsam genutztes Geheimnis) und/oder privaten Schlüssel für private Links an. Verwendet die vorhandene Endung \u0026ldquo;.b32.i2p\u0026rdquo;, jedoch mit größerer Gesamtlänge. Enthält eine Prüfsumme zur Fehlererkennung. Adressen für verschlüsselte leaseSets werden anhand von 56 oder mehr kodierten Zeichen (35 oder mehr dekodierten Bytes) identifiziert, gegenüber 52 Zeichen (32 Bytes) bei traditionellen Base32-Adressen. Spezifikation Erstellung und Kodierung Erstellen Sie einen Hostnamen der Form {56+ Zeichen}.b32.i2p (35+ Zeichen in Binärdarstellung) wie folgt:\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype Nachverarbeitung und Prüfsumme:\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; Alle ungenutzten Bits am Ende des b32 müssen 0 sein. Für eine Standardadresse mit 56 Zeichen (35 Byte) gibt es keine ungenutzten Bits.\nDekodierung und Verifikation strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key Bits geheimer und privater Schlüssel Die Bits für den geheimen und den privaten Schlüssel werden verwendet, um Clients, Proxys oder anderem clientseitigen Code anzuzeigen, dass der geheime und/oder der private Schlüssel zum Entschlüsseln des leaseSet erforderlich sein wird. Bestimmte Implementierungen können den Benutzer auffordern, die erforderlichen Daten bereitzustellen, oder Verbindungsversuche ablehnen, wenn die erforderlichen Daten fehlen.\nDiese Bits dienen lediglich als Indikatoren. Der geheime bzw. private Schlüssel darf niemals in der B32-Adresse selbst enthalten sein, da dies die Sicherheit gefährden würde.\nKryptografische Details Verblindungsverfahren Das Blinding-Verfahren verwendet RedDSA (Signaturschema) basierend auf Ed25519 und dem ZCash-Design und erzeugt Red25519-Signaturen über der Ed25519-Kurve unter Verwendung von SHA-512. Dieser Ansatz stellt sicher, dass geblendete öffentliche Schlüssel in der Untergruppe mit Primzahlordnung verbleiben und vermeidet die in einigen alternativen Designs vorhandenen Sicherheitsbedenken.\nVerblindete Schlüssel rotieren täglich basierend auf dem UTC-Datum nach der Formel:\nblinded_key = BLIND(unblinded_key, date, optional_secret) Der Speicherort in der DHT (verteilte Hashtabelle) wird wie folgt berechnet:\nSHA256(type_byte || blinded_public_key) Verschlüsselung Das verschlüsselte leaseset verwendet die Stromchiffre ChaCha20 für die Verschlüsselung, die aufgrund ihrer überlegenen Leistung auf Geräten ohne AES-Hardwarebeschleunigung ausgewählt wurde. Die Spezifikation setzt HKDF zur Schlüsselableitung und X25519 für Diffie-Hellman-Operationen ein.\nVerschlüsselte leaseSets haben eine dreischichtige Struktur: - Äußere Schicht: Metadaten im Klartext - Mittlere Schicht: Client-Authentifizierung (DH- oder PSK-Methoden) - Innere Schicht: eigentliche LS2-Daten mit Lease-Informationen\nAuthentifizierungsmethoden Die Client-spezifische Authentifizierung unterstützt zwei Methoden:\nDH-Authentifizierung: Verwendet X25519 als Schlüsselaustauschverfahren. Jeder autorisierte Client übermittelt seinen öffentlichen Schlüssel an den Server, und der Server verschlüsselt die mittlere Schicht mithilfe eines aus ECDH abgeleiteten gemeinsamen Geheimnisses.\nPSK-Authentifizierung: Verwendet Pre-Shared Keys (vorab geteilte Schlüssel) direkt zur Verschlüsselung.\nFlag-Bit 2 in der B32-Adresse gibt an, ob eine clientbezogene Authentifizierung erforderlich ist.\nZwischenspeicherung Obwohl dies außerhalb des Geltungsbereichs dieser Spezifikation liegt, müssen router und Clients die Zuordnung vom öffentlichen Schlüssel zur Destination (Zielidentität) und umgekehrt speichern und zwischenspeichern (persistente Speicherung wird empfohlen).\nDer Blockfile-Namensdienst, I2Ps standardmäßiges Adressbuchsystem seit Version 0.9.8, verwaltet mehrere Adressbücher mit einer dedizierten reverse-lookup map (Abbildung für Rückwärtssuche), die schnelle Abfragen nach Hash ermöglicht. Diese Funktionalität ist entscheidend für die Auflösung eines verschlüsselten leaseSet, wenn anfangs nur ein Hash bekannt ist.\nSignaturtypen Seit I2P Version 2.10.0 sind die Signaturtypen 0 bis 11 definiert. Die Ein-Byte-Codierung bleibt der Standard, während die Zwei-Byte-Codierung zwar verfügbar ist, in der Praxis jedoch nicht verwendet wird.\nHäufig verwendete Typen: - Typ 0 (DSA_SHA1): Veraltet für routers, unterstützt für Destinations (Zieladressen) - Typ 7 (EdDSA_SHA512_Ed25519): Aktueller Standard für router-Identitäten und Destinations - Typ 11 (RedDSA_SHA512_Ed25519): Ausschließlich für verschlüsselte LS2 leasesets mit Unterstützung für blinding (Adressverschleierung)\nWichtiger Hinweis: Nur Ed25519 (Typ 7) und Red25519 (Typ 11) unterstützen das für verschlüsselte leaseSets notwendige blinding (Verblindung). Andere Signaturtypen können mit dieser Funktion nicht verwendet werden.\nTypen 9–10 (GOST-Algorithmen) bleiben reserviert, sind aber nicht implementiert. Die Typen 4–6 und 8 sind für Offline-Signaturschlüssel als \u0026ldquo;offline only\u0026rdquo; gekennzeichnet.\nHinweise Alte und neue Varianten anhand der Länge unterscheiden. Alte b32-Adressen sind immer {52 chars}.b32.i2p. Neue sind {56+ chars}.b32.i2p Die base32-Codierung folgt den Vorgaben von RFC 4648; die Dekodierung ist groß-/kleinschreibungsunabhängig, und eine Ausgabe in Kleinbuchstaben wird bevorzugt Adressen können über 200 Zeichen lang sein, wenn Signaturtypen mit größeren öffentlichen Schlüsseln verwendet werden (z. B. ECDSA P521 mit 132-Byte-Schlüsseln) Das neue Format kann in jump links (Sprung-Links) verwendet werden (und von jump servers (Sprung-Servern) bereitgestellt werden), falls gewünscht, genau wie Standard-b32 Verblindete Schlüssel rotieren täglich basierend auf dem UTC-Datum, um die Privatsphäre zu verbessern Dieses Format weicht von dem in Tors rend-spec-v3.txt, Anhang A.2, beschriebenen Ansatz ab, der potenzielle Sicherheitsimplikationen bei off-curve (außerhalb der Kurve) verblindeten öffentlichen Schlüsseln hat Versionskompatibilität Diese Spezifikation ist für I2P Version 0.9.47 (August 2020) bis einschließlich Version 2.10.0 (September 2025) zutreffend. Während dieses Zeitraums gab es keine inkompatiblen Änderungen am B32-Adressformat, an der verschlüsselten LS2-Struktur oder an den kryptografischen Implementierungen. Alle mit 0.9.47 erstellten Adressen bleiben mit den aktuellen Versionen vollständig kompatibel.\nReferenzen CRC-32 - CRC-32 (Wikipedia) - RFC 3309: Prüfsumme des Stream Control Transmission Protocol I2P-Spezifikationen - Spezifikation für verschlüsseltes LeaseSet - Vorschlag 123: Neue netDB-Einträge - Vorschlag 149: B32 für verschlüsseltes LS2 - Spezifikation gemeinsamer Strukturen - Namensauflösung und Adressbuch Tor-Vergleich - Tor-Diskussionsthread (Designkontext) Weitere Ressourcen - I2P-Projekt - I2P-Forum - Java-API-Dokumentation ","description":"Base-32-Adressformat für verschlüsselte LS2 leaseSets","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"B32 für verschlüsselte leaseSets","url":"/de/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":"Übersicht Diese Spezifikation erweitert den Adressbuch-Abonnement-Feed um Befehle und ermöglicht es Nameservern, Eintragsaktualisierungen von Hostnamen-Inhabern zu verbreiten. Ursprünglich vorgeschlagen in Proposal 112 (September 2014), implementiert in Version 0.9.26 (Juni 2016) und netzwerkweit ausgerollt mit Status ABGESCHLOSSEN.\nDas System ist seit seiner ursprünglichen Implementierung stabil und unverändert geblieben und funktioniert weiterhin identisch unter I2P 2.10.0 (Router API 0.9.65, September 2025).\nMotivation Früher lieferten die Abonnementserver für hosts.txt Daten nur im einfachen hosts.txt-Format:\nexample.i2p=b64destination Dieses grundlegende Format führte zu mehreren Problemen:\nHostname-Inhaber können die mit ihren Hostnamen verknüpfte Destination (Zieladresse) nicht aktualisieren (zum Beispiel, um den Signaturschlüssel auf einen stärkeren kryptografischen Typ umzustellen). Hostname-Inhaber können ihre Hostnamen nicht beliebig übertragen. Sie müssen die entsprechenden privaten Schlüssel der Destination direkt an den neuen Inhaber übergeben. Es gibt keine Möglichkeit, nachzuweisen, dass eine Subdomain vom zugehörigen Basis-Hostname kontrolliert wird. Dies wird derzeit nur individuell von einigen Nameservern durchgesetzt. Entwurf Diese Spezifikation fügt dem hosts.txt-Format Befehlszeilen hinzu. Mit diesen Befehlen können Nameserver ihre Dienste erweitern und zusätzliche Funktionen bereitstellen. Clients, die diese Spezifikation implementieren, können über den regulären Abonnementprozess auf diese Funktionen lauschen.\nAlle Befehlszeilen müssen von der entsprechenden Destination (I2P-Zieladresse) signiert sein. Dies stellt sicher, dass Änderungen nur auf Anforderung des Inhabers des Hostnamens vorgenommen werden.\nSicherheitsauswirkungen Diese Spezifikation beeinflusst die Anonymität nicht.\nEs gibt ein erhöhtes Risiko, die Kontrolle über einen Destination-Schlüssel zu verlieren, da jemand, der ihn erlangt, diese Befehle verwenden kann, um Änderungen an beliebigen zugehörigen Hostnamen vorzunehmen. Dies stellt jedoch kein größeres Problem dar als der Status quo, in dem jemand, der eine Destination (I2P-Zieladresse) erlangt, sich als Hostname ausgeben und (teilweise) dessen Datenverkehr übernehmen kann. Das erhöhte Risiko wird dadurch ausgeglichen, dass Inhaber von Hostnamen die Möglichkeit erhalten, die einem Hostnamen zugeordnete Destination zu ändern, falls sie glauben, dass die Destination kompromittiert wurde. Dies ist mit dem aktuellen System nicht möglich.\nSpezifikation Neue Linientypen Es gibt zwei neue Linientypen:\nBefehle zum Hinzufügen und Ändern: example.i2p=b64destination#!key1=val1#key2=val2... Befehle entfernen: #!key1=val1#key2=val2... Reihenfolge Ein Feed ist nicht notwendigerweise in der richtigen Reihenfolge oder vollständig. Zum Beispiel kann ein change command in einer Zeile vor einem add command erscheinen oder ganz ohne add command.\nSchlüssel können in beliebiger Reihenfolge angeordnet sein. Doppelte Schlüssel sind nicht zulässig. Bei allen Schlüsseln und Werten wird die Groß- und Kleinschreibung berücksichtigt.\nAllgemeine Schlüssel In allen Befehlen erforderlich:\nsig : Base64-Signatur, unter Verwendung des Signaturschlüssels der Destination (Zieladresse)\nVerweise auf einen zweiten Hostnamen und/oder eine Destination (Zieladresse):\noldname : Ein zweiter Hostname (neu oder geändert)\nolddest : Eine zweite Base64-Destination (neu oder geändert)\noldsig : Eine zweite Base64-Signatur, unter Verwendung des Signaturschlüssels aus olddest\nWeitere häufig verwendete Schlüssel:\nAktion : Ein Befehl\nname : Der Hostname, nur vorhanden, wenn example.i2p=b64dest nicht vorangestellt ist\ndest : Die Base64-Zieladresse, nur vorhanden, sofern example.i2p=b64dest nicht vorangestellt ist\ndate : In Sekunden seit der Epoche\nexpires : In Sekunden seit der Unix-Epoche\nBefehle Alle Befehle außer dem \u0026ldquo;Add\u0026rdquo;-Befehl müssen ein action=command-Schlüssel-Wert-Paar enthalten.\nZur Gewährleistung der Kompatibilität mit älteren Clients wird den meisten Befehlen, wie unten beschrieben, example.i2p=b64dest vorangestellt. Bei Änderungen sind dies stets die neuen Werte. Etwaige alte Werte sind im Schlüssel/Wert-Abschnitt enthalten.\nDie aufgeführten Schlüssel sind erforderlich. Alle Befehle können zusätzliche Schlüssel-Wert-Paare enthalten, die hier nicht definiert sind.\nHostname hinzufügen Mit example.i2p=b64dest vorangestellt : JA, das ist der neue Hostname und die neue Destination (I2P-Zieladresse).\nAktion : NICHT enthalten, es ist implizit.\nsig : Signatur\nBeispiel:\nexample.i2p=b64dest#!sig=b64sig Hostname ändern Mit vorangestelltem example.i2p=b64dest : JA, dies ist der neue Hostname und das alte Ziel.\nAktion : changename\noldname : der alte Hostname, der ersetzt werden soll\nsig : Signatur\nBeispiel:\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig Ziel ändern Mit example.i2p=b64dest eingeleitet : JA, dies ist der alte Hostname und die neue Destination (Zieladresse).\naction : changedest\nolddest : das alte Ziel, das ersetzt werden soll\noldsig : Signatur unter Verwendung von olddest\nsig : Signatur\nBeispiel:\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Hostname-Alias hinzufügen Vorangestellt durch example.i2p=b64dest : JA, das ist der neue (Alias-)Hostname und die alte Zieladresse.\nAktion : addname\noldname : der alte Hostname\nsig : Signatur\nBeispiel:\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig Destination-Alias hinzufügen (Wird für ein Kryptografie-Upgrade verwendet)\nMit vorangestelltem example.i2p=b64dest : JA, dies ist der alte Hostname und die neue (alternative) Destination (Zieladresse in I2P).\naction : adddest\nolddest : das alte Ziel\noldsig : Signatur mit olddest\nsig : Signatur unter Verwendung von dest\nBeispiel:\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Subdomain hinzufügen Mit vorangestelltem subdomain.example.i2p=b64dest : JA, dies ist der neue Subdomain-Name und das Ziel.\naction : addsubdomain\noldname : der übergeordnete Hostname (example.i2p)\nolddest : das übergeordnete Ziel (z. B. example.i2p)\noldsig : Signatur mit olddest\nsig : Signatur mithilfe von dest\nBeispiel:\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Metadaten aktualisieren Vorangestellt durch example.i2p=b64dest : JA, dies ist der alte Hostname und die Zieladresse.\nAktion : Aktualisierung\nsig : Signatur\n(Fügen Sie hier alle aktualisierten Schlüssel hinzu)\nBeispiel:\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig Hostname entfernen Mit example.i2p=b64dest vorangestellt : NEIN, diese werden in den Optionen angegeben\nAktion : entfernen\nname : der Hostname\ndest : das Ziel\nsig : Signatur\nBeispiel:\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig Alle mit diesem Ziel entfernen Vorangestellt durch example.i2p=b64dest : NEIN, diese werden in den Optionen festgelegt\nAktion : removeall\ndest : die Destination (Zieladresse)\nsig : Signatur\nBeispiel:\n#!action=removeall#dest=b64dest#sig=b64sig Signaturen Alle Befehle müssen von der zugehörigen Destination (Zieladresse) signiert werden. Befehle mit zwei Destinations benötigen möglicherweise zwei Signaturen.\noldsig ist immer die \u0026ldquo;innere\u0026rdquo; Signatur. Signieren und verifizieren, ohne dass die Schlüssel oldsig oder sig vorhanden sind. sig ist immer die \u0026ldquo;äußere\u0026rdquo; Signatur. Signieren und verifizieren mit vorhandenem oldsig-Schlüssel, aber ohne sig-Schlüssel.\nEingaben für Signaturen Um einen Bytestrom zu erzeugen, mit dem die Signatur erstellt oder verifiziert werden kann, serialisieren Sie wie folgt:\nEntferne den Schlüssel sig Wenn mit oldsig verifiziert wird, entferne außerdem den Schlüssel oldsig Nur für Add- oder Change-Kommandos (Hinzufügen bzw. Ändern): example.i2p=b64dest ausgeben Wenn noch Schlüssel übrig sind, #! ausgeben Sortiere die Optionen nach dem UTF-8-Schlüssel, bei doppelten Schlüsseln fehlschlagen Für jedes Schlüssel/Wert-Paar key=value ausgeben, gefolgt von (falls nicht das letzte Schlüssel/Wert-Paar) einem # Hinweise\nKeinen Zeilenumbruch ausgeben Die Ausgabekodierung ist UTF-8 Die Kodierung aller Ziele und Signaturen erfolgt in Base 64 mit dem I2P-Alphabet Schlüssel und Werte unterscheiden Groß- und Kleinschreibung Hostnamen müssen in Kleinbuchstaben geschrieben sein Aktuelle Signaturtypen Seit I2P 2.10.0 werden für Ziele folgende Signaturtypen unterstützt:\nEdDSA_SHA512_Ed25519 (Typ 7): Seit 0.9.15 am häufigsten für Destinations. Verwendet einen 32-Byte langen öffentlichen Schlüssel und eine 64-Byte-Signatur. Dies ist der empfohlene Signaturtyp für neue Destinations. RedDSA_SHA512_Ed25519 (Typ 13): Nur für Destinations und verschlüsselte leaseSets verfügbar (seit 0.9.39). Veraltete Typen (DSA_SHA1, ECDSA-Varianten): weiterhin unterstützt, aber seit 0.9.58 für neue Router-Identitäten als veraltet markiert. Hinweis: Post-Quanten-kryptografische Optionen sind seit I2P 2.10.0 verfügbar, jedoch noch nicht die Standard-Signaturtypen.\nKompatibilität Alle neuen Zeilen im hosts.txt-Format sind mithilfe vorangestellter Kommentarzeichen (#!) implementiert, sodass alle älteren I2P-Versionen die neuen Anweisungen als Kommentare interpretieren und sie problemlos ignorieren.\nWenn I2P routers auf die neue Spezifikation aktualisiert werden, werden sie alte Kommentare nicht neu interpretieren, sondern bei nachfolgenden Abrufen ihrer Abonnement-Feeds beginnen, neue Befehle zu verarbeiten. Daher ist es wichtig, dass Namensserver Befehlseinträge in irgendeiner Form dauerhaft vorhalten oder ETag-Unterstützung aktivieren, damit routers alle bisherigen Befehle abrufen können.\nImplementierungsstatus Erste Bereitstellung: Version 0.9.26 (7. Juni 2016)\nAktueller Status: Stabil und unverändert bis einschließlich I2P 2.10.0 (Router API 0.9.65, September 2025)\nStatus des Vorschlags: GESCHLOSSEN (netzwerkweit erfolgreich ausgerollt)\nImplementierungsort: apps/addressbook/java/src/net/i2p/addressbook/ im I2P Java router\nWichtige Klassen: - SubscriptionList.java: Verwaltet die Abonnementverarbeitung - Subscription.java: Bearbeitet einzelne Abonnement-Feeds - AddressBook.java: Kernfunktionalität des Adressbuchs - Daemon.java: Hintergrunddienst für das Adressbuch\nStandard-Abonnement-URL: http://i2p-projekt.i2p/hosts.txt\nTransportdetails Abonnements verwenden HTTP mit Unterstützung für bedingte GET-Anfragen:\nETag-Header: Unterstützt effiziente Änderungserkennung Last-Modified-Header: Erfasst die Aktualisierungszeiten von Abonnements 304 Not Modified: Server sollten dies zurückgeben, wenn sich der Inhalt nicht geändert hat Content-Length: Wird für alle Antworten dringend empfohlen Der I2P router verwendet standardmäßiges HTTP-Client-Verhalten mit korrekter Cache-Unterstützung.\nVersionskontext Hinweis zur I2P-Versionierung: Ab etwa Version 1.5.0 (August 2021) wechselte I2P von der 0.9.x-Versionierung zur semantischen Versionierung (1.x, 2.x usw.). Die interne Version der Router API verwendet jedoch weiterhin die 0.9.x-Nummerierung aus Gründen der Abwärtskompatibilität. Stand Oktober 2025 ist die aktuelle Version I2P 2.10.0 mit der Router API in Version 0.9.65.\nDieses Spezifikationsdokument wurde ursprünglich für Version 0.9.49 (Februar 2021) verfasst und ist für die aktuelle Version 0.9.65 (I2P 2.10.0) weiterhin vollständig zutreffend, da am Abonnement-Feed-System seit seiner ursprünglichen Implementierung in 0.9.26 keine Änderungen vorgenommen wurden.\nReferenzen Vorschlag 112 (Original) Offizielle Spezifikation I2P-Dokumentation zum Namenssystem Spezifikation allgemeiner Strukturen I2P-Quellcode-Repository I2P-Gitea-Repository Verwandte Entwicklungen Auch wenn sich das Abonnement-Feed-System selbst nicht geändert hat, könnten die folgenden damit zusammenhängenden Entwicklungen in I2Ps Namensinfrastruktur von Interesse sein:\nErweiterte Base32-Namen (0.9.40+): Unterstützung für Base32-Adressen mit 56+ Zeichen für verschlüsselte leaseSets. Beeinflusst das Format des Abonnement-Feeds nicht. .i2p.alt TLD-Registrierung (RFC 9476, Ende 2023): Offizielle GANA-Registrierung von .i2p.alt als alternative TLD. Zukünftige router-Updates können das .alt-Suffix entfernen, aber Änderungen an Abonnementbefehlen sind nicht erforderlich. Post-Quanten-Kryptografie (2.10.0+): Verfügbar, aber nicht standardmäßig aktiviert. Künftige Berücksichtigung von Signaturalgorithmen in Abonnement-Feeds. ","description":"Erweiterung für Adressbuch-Abonnement-Feeds, die es Inhabern von Hostnamen ermöglicht, ihre Einträge zu aktualisieren und zu verwalten","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"Befehle für Adressabonnement-Feeds","url":"/de/docs/specs/subscription/"},{"categories":null,"content":"Das Plugin-Framework von I2P ermöglicht es Ihnen, den Router zu erweitern, ohne die Kerninstallation zu verändern. Verfügbare Plugins umfassen E-Mail, Blogs, IRC, Speicher, Wikis, Überwachungstools und mehr.\nSicherheitshinweis: Plugins laufen mit denselben Berechtigungen wie der Router. Behandeln Sie Downloads von Drittanbietern genauso, wie Sie jedes signierte Software-Update behandeln würden – überprüfen Sie die Quelle vor der Installation.\n1. Plugin installieren Kopieren Sie die Download-URL des Plugins von der Projektseite.\nÖffnen Sie die Plugin-Konfigurationsseite der Router-Konsole.\nFügen Sie die URL in das Installationsfeld ein und klicken Sie auf Install Plugin.\nDer Router lädt das signierte Archiv herunter, überprüft die Signatur und aktiviert das Plugin sofort. Die meisten Plugins fügen Konsolenlinks oder Hintergrunddienste hinzu, ohne einen Router-Neustart zu erfordern.\n2. Warum Plugins wichtig sind Ein-Klick-Verteilung für Endbenutzer—keine manuellen Änderungen an wrapper.config oder clients.config Hält das Kern-i2pupdate.su3-Bundle klein, während große oder Nischen-Features bei Bedarf bereitgestellt werden Optionale plugin-spezifische JVMs bieten Prozessisolierung, wenn erforderlich Automatische Kompatibilitätsprüfungen mit der Router-Version, Java-Laufzeitumgebung und Jetty Update-Mechanismus entspricht dem des Routers: signierte Pakete und inkrementelle Downloads Console-Integrationen, Sprachpakete, UI-Themes und Nicht-Java-Anwendungen (über Skripte) werden alle unterstützt Ermöglicht kuratierte „App-Store\u0026quot;-Verzeichnisse wie plugins.i2p 3. Installierte Plugins verwalten Verwenden Sie die Steuerungselemente im I2P Router Plugin , um:\nEin einzelnes Plugin auf Updates prüfen Alle Plugins auf einmal prüfen (wird automatisch nach Router-Upgrades ausgelöst) Verfügbare Updates mit einem Klick installieren\nAutostart für Plugins aktivieren/deaktivieren, die Dienste registrieren Plugins sauber deinstallieren 4. Erstellen Sie Ihr eigenes Plugin Überprüfen Sie die Plugin-Spezifikation für Anforderungen an Paketierung, Signierung und Metadaten. Verwenden Sie makeplugin.sh , um eine bestehende Binärdatei oder Webapp in ein installierbares Archiv zu verpacken. Veröffentlichen Sie sowohl Installations- als auch Update-URLs, damit der Router zwischen Erstinstallationen und inkrementellen Upgrades unterscheiden kann. Stellen Sie Prüfsummen und Signaturschlüssel prominent auf Ihrer Projektseite bereit, um Benutzern bei der Überprüfung der Authentizität zu helfen. Suchst du nach Beispielen? Durchsuche den Quellcode von Community-Plugins auf plugins.i2p (zum Beispiel das snowman-Beispiel).\n5. Bekannte Einschränkungen Das Aktualisieren eines Plugins, das einfache JAR-Dateien ausliefert, kann einen Router-Neustart erfordern, da der Java-Class-Loader Klassen zwischenspeichert. Die Konsole zeigt möglicherweise einen Stop-Button an, auch wenn das Plugin keinen aktiven Prozess hat. Plugins, die in einer separaten JVM gestartet werden, erstellen ein logs/-Verzeichnis im aktuellen Arbeitsverzeichnis. Beim ersten Auftreten wird ein Signer-Key automatisch als vertrauenswürdig eingestuft; es gibt keine zentrale Signierungsinstanz. Windows hinterlässt manchmal leere Verzeichnisse nach der Deinstallation eines Plugins. Die Installation eines Plugins, das nur für Java 6 ausgelegt ist, auf einer Java 5 JVM meldet „Plugin ist beschädigt\u0026quot; aufgrund der Pack200-Komprimierung. Theme- und Übersetzungs-Plugins sind weitgehend ungetestet. Autostart-Flags bleiben bei nicht verwalteten Plugins nicht immer erhalten. 6. Anforderungen \u0026amp; Best Practices Plugin-Unterstützung ist verfügbar in I2P 0.7.12 und neuer. Halten Sie Ihren Router und Plugins auf dem neuesten Stand, um Sicherheitsupdates zu erhalten. Liefern Sie prägnante Release-Notes mit, damit Benutzer verstehen, was sich zwischen Versionen ändert. Hosten Sie Plugin-Archive wenn möglich über HTTPS innerhalb von I2P, um die Offenlegung von Clearnet-Metadaten zu minimieren. 7. Weiterführende Literatur Plugin-Spezifikation Client-Anwendungs-Framework I2P-Scripts-Repository für Paketierungs-Werkzeuge ","description":"Installation, Aktualisierung und Entwicklung von Router-Plugins","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"Benutzerdefinierte Plugins installieren","url":"/de/docs/guides/plugins/"},{"categories":null,"content":"Übersicht BitTorrent über I2P ermöglicht anonymes Filesharing durch verschlüsselte Tunnel unter Verwendung der I2P-Streaming-Schicht. Alle Peers werden durch kryptografische I2P-Destinations anstelle von IP-Adressen identifiziert. Das System unterstützt HTTP- und UDP-Tracker, hybride Magnet-Links und Post-Quantum-Hybrid-Verschlüsselung.\n1. Protokollstapel Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP Alle Verbindungen laufen über die verschlüsselte Transportschicht von I2P (NTCP2 oder SSU2). Selbst UDP-Tracker-Pakete werden innerhalb von I2P-Streaming gekapselt. 2. Tracker HTTP-Tracker Standard .i2p Tracker antworten auf HTTP GET-Anfragen wie:\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 Antworten sind bencoded und verwenden I2P destination hashes für Peers.\nUDP-Tracker UDP-Tracker wurden 2025 standardisiert (Vorschlag 160).\nPrimäre UDP-Tracker - udp://tracker2.postman.i2p/announce - udp://opentracker.simp.i2p/a - http://opentracker.skank.i2p/a - http://opentracker.dg2.i2p/a \u0026mdash;\n3. Magnet-Links magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name Magnet-Links unterstützen hybride Schwärme über I2P und Clearnet, wenn dies konfiguriert ist. 4. DHT-Implementierungen Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported --- 5. Client-Implementierungen I2PSnark Mit allen Routern gebündelt Nur HTTP-Tracker-Unterstützung Eingebauter Tracker unter http://127.0.0.1:7658/ Keine UDP-Tracker-Unterstützung BiglyBT Vollständig ausgestattet mit I2P-Plugin Unterstützt HTTP + UDP Tracker Hybrid-Torrent-Unterstützung Verwendet SAM v3.3 Interface Tixati / XD Leichtgewichtige Clients SAM-basierte Tunneling Experimentelle ML-KEM-Hybridverschlüsselung 6. Konfiguration I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. Sicherheitsmodell Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) Hybrid (Clearnet + I2P) Torrents sollten nur verwendet werden, wenn Anonymität nicht entscheidend ist. 8. Leistung Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal Typische Geschwindigkeiten liegen bei **30–80 KB/s**, abhängig von Peers und Netzwerkbedingungen. 9. Bekannte Probleme Teilweise DHT-Interoperabilität zwischen Java I2P und i2pd Verzögerung beim Abrufen von Magnet-Metadaten unter hoher Last NTCP1 veraltet, wird aber noch von alten Peers verwendet Über Streaming simuliertes UDP erhöht die Latenz 10. Zukünftige Roadmap QUIC-ähnliches Multiplexing Vollständige ML-KEM-Integration Vereinheitlichte Hybrid-Swarm-Logik Verbesserte Reseed-Spiegel Adaptive DHT-Wiederholungsversuche Referenzen BEP 15 – UDP Tracker Protocol Proposal 160 – UDP Tracker über I2P I2PSnark Dokumentation Streaming Library Spezifikation ","description":"Detaillierte Spezifikation und Ökosystem-Übersicht für BitTorrent innerhalb des I2P-Netzwerks","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"BitTorrent über I2P","url":"/de/docs/applications/bittorrent/"},{"categories":null,"content":"Übersicht Dieses Dokument spezifiziert das I2P-Blockfile-Dateiformat und die Tabellen in der hostsdb.blockfile, die vom Blockfile Naming Service (Namensdienst auf Basis von Blockfiles) verwendet werden. Für Hintergrundinformationen siehe I2P Naming and Address Book .\nDie blockfile (Blockdatei) ermöglicht schnelle Zielabfragen in einem kompakten binären Format. Im Vergleich zum alten hosts.txt-System:\nDestinations (I2P-Zieladressen) werden binär gespeichert, nicht in Base64. Beliebige Metadaten (z. B. Hinzufügedatum, Quelle, Kommentare) können angehängt werden. Lookup-Zeiten sind etwa 10× schneller. Der Speicherplatzbedarf auf der Festplatte steigt moderat. Eine Blockdatei ist eine auf dem Datenträger gespeicherte Sammlung sortierter Maps (Schlüssel-Wert-Paare), implementiert als skiplists (Skip-Listen). Sie wurde von der Metanotion Blockfile Database abgeleitet. Diese Spezifikation definiert zunächst die Dateistruktur und beschreibt anschließend, wie sie vom BlockfileNamingService verwendet wird.\nDer Blockfile Naming Service hat in I2P 0.8.8 die alte hosts.txt-Implementierung ersetzt. \u0026gt; Bei der Initialisierung importiert er Einträge aus privatehosts.txt, userhosts.txt und hosts.txt.\nBlockfile-Format (Blockdatei) Das Format besteht aus 1024-Byte-Seiten, denen jeweils eine magische Zahl zur Integritätsprüfung vorangestellt ist. Die Seiten sind ab 1 nummeriert:\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) Alle Ganzzahlen verwenden **Netzwerk-Byte-Reihenfolge (Big-Endian)**. 2-Byte-Werte sind vorzeichenlos; 4-Byte-Werte (Seitennummern) sind vorzeichenbehaftet und müssen positiv sein. Threading: Die Datenbank ist für Zugriff durch einen einzelnen Thread ausgelegt; BlockfileNamingService stellt die Synchronisation bereit.\nSuperblock-Format Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused --- Format der Blockseite der Skip‑Liste Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused --- Seitenformat des Skip-Level-Blocks Jede Ebene hat eine Spanne, aber nicht alle Spannen haben Ebenen.\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused --- Skip-Span-Block-Seitenformat Schlüssel/Wert-Paare sind über alle Spans (Segmente) hinweg nach dem Schlüssel sortiert. Alle Spans außer dem ersten dürfen nicht leer sein.\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures --- Seitenformat für den Span Continuation Block Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures --- Schlüssel/Wert-Strukturformat Schlüssel- und Wert-Längenfelder dürfen sich nicht über Seiten erstrecken (alle 4 Bytes müssen passen). Wenn nicht genügend Platz verbleibt, bis zu 3 Bytes mit Padding auffüllen und bei Offset 8 der nächsten Seite fortfahren.\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each --- Seitenformat des Freiliste-Blocks Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) --- Format des freien Seitenblocks Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused --- Meta-Index Befindet sich auf Seite 2. Ordnet US-ASCII-Zeichenketten → 4-Byte-Ganzzahlen zu. Der Schlüssel ist der Skiplist-Name; der Wert ist der Seitenindex.\nTabellen des Blockfile-Namensdienstes Der Dienst definiert mehrere Skiplisten. Jeder Bereich unterstützt bis zu 16 Einträge.\nSkip-Liste für Eigenschaften %%__INFO__%% enthält einen Eintrag:\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping Typische Felder: Property Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) --- Skip-Liste für Rückwärtssuche %%__REVERSE__%% enthält Integer → Properties-Einträge (seit DB v2).\nSchlüssel: Die ersten 4 Bytes des SHA-256-Hashwerts der Destination (I2P-Zieladresse). Wert: Properties-Objekt (serialisiertes Mapping). Mehrere Einträge behandeln Kollisionen und Destinations mit mehreren Hostnamen. Jeder Property-Schlüssel = Hostname; Wert = leerer String. Skiplisten der Host-Datenbank Jede der Dateien hosts.txt, userhosts.txt und privatehosts.txt ordnet Hostnamen → Destinations (I2P-Ziele) zu.\nVersion 4 unterstützt mehrere Destinations (I2P-Zieladressen) pro Hostname (eingeführt in I2P 0.9.26). Datenbanken der Version 3 werden automatisch migriert.\nSchlüssel UTF-8-String (Hostname, in Kleinbuchstaben, endet auf .i2p)\nWert Version 4: 1-Byte-Zähler der Paare aus Eigenschaft und Destination (Zieladresse) Für jedes Paar: Eigenschaften → Destination (binär) Version 3: Eigenschaften → Destination (binär) Eigenschaften von DestEntry Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) --- Implementierungshinweise Die Java-Klasse BlockfileNamingService implementiert diese Spezifikation.\nAußerhalb des router-Kontexts wird die Datenbank schreibgeschützt geöffnet, es sei denn, i2p.naming.blockfile.writeInAppContext=true. Nicht für den Betrieb mit mehreren Instanzen oder den Zugriff aus mehreren JVMs vorgesehen. Verwaltet drei primäre Maps (privatehosts, userhosts, hosts) sowie eine inverse Map für schnelle Nachschlagevorgänge. Referenzen I2P-Namens- und Adressbuch-Dokumentation Spezifikation gemeinsamer Strukturen Metanotion Blockfile-Datenbank BlockfileNamingService-Javadoc ","description":"Auf dem Datenträger gespeichertes blockfile (Blockdatei)-Speicherformat, das von I2P zur Auflösung von Hostnamen verwendet wird","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"Blockfile-Spezifikation (Blockdatei)","url":"/de/docs/specs/blockfile/"},{"categories":null,"content":" Warnung: BOB unterstützt nur den veralteten DSA-SHA1-Signaturtyp. Java I2P liefert BOB seit 1.7.0 (2022-02) nicht mehr mit; es ist nur noch auf Installationen vorhanden, die ursprünglich mit Version 1.6.1 oder älter eingerichtet wurden, sowie auf einigen i2pd-Builds. Neue Anwendungen müssen SAM v3 verwenden.\nSprachanbindungen Go – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp Hinweise zum Protokoll KEYS bezeichnet eine Base64-Destination (Zieladresse; öffentliche + private Schlüssel). KEY ist ein öffentlicher Schlüssel in Base64. Antworten mit ERROR haben die Form ERROR \u0026lt;description\u0026gt;\\n. OK zeigt den Abschluss des Befehls an; optionale Daten folgen in derselben Zeile. DATA-Zeilen liefern zusätzliche Ausgabe vor einem abschließenden OK. Der Befehl help ist die einzige Ausnahme: Er kann keine Ausgabe liefern, um „kein solcher Befehl“ zu signalisieren.\nVerbindungsbanner BOB verwendet ASCII-Zeilen, die mit einem Zeilenumbruch enden (LF oder CRLF). Beim Verbindungsaufbau gibt es Folgendes aus:\nBOB \u0026lt;version\u0026gt; OK Aktuelle Version: 00.00.10. Frühere Builds verwendeten großgeschriebene Hexadezimalziffern und eine nicht standardkonforme Nummerierung.\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds ## Kernbefehle Ausführliche Details zu den Befehlen erhalten Sie, indem Sie sich mit telnet localhost 2827 verbinden und help ausführen.\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK Übersicht der Abkündigungen BOB (älteres Bridge-API für I2P) unterstützt weder moderne Signaturtypen noch verschlüsselte LeaseSets noch Transportfunktionen. Die API ist eingefroren; es werden keine neuen Befehle mehr hinzugefügt. Anwendungen, die weiterhin auf BOB setzen, sollten so bald wie möglich auf SAM v3 migrieren. ","description":"Veraltete API für die Zielverwaltung (veraltet)","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – Basic Open Bridge (grundlegende offene Brücke)","url":"/de/docs/legacy/bob/"},{"categories":null,"content":"Überblick Datagrams bieten nachrichtenorientierte Kommunikation oberhalb von I2CP und parallel zur Streaming-Bibliothek. Sie ermöglichen beantwortbare, authentifizierte oder rohe Pakete, ohne verbindungsorientierte Streams zu erfordern. Router kapseln Datagrams in I2NP-Nachrichten und Tunnel-Nachrichten ein, unabhängig davon, ob NTCP2 oder SSU2 den Verkehr überträgt.\nDie zentrale Motivation besteht darin, Anwendungen (wie Tracker, DNS-Resolver oder Spiele) zu ermöglichen, eigenständige Pakete zu senden, die ihren Absender identifizieren.\nNeu in 2025: Das I2P-Projekt hat Datagram2 (Protokoll 19) und Datagram3 (Protokoll 20) genehmigt, die zum ersten Mal seit einem Jahrzehnt Replay-Schutz und Messaging mit geringerem Overhead und Antwortmöglichkeit hinzufügen.\n1. Protokollkonstanten Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) Die Protokolle 19 und 20 wurden in **Proposal 163 (April 2025)** formalisiert. Sie koexistieren mit Datagram1 / RAW zur Abwärtskompatibilität. 2. Datagramm-Typen Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. ### Typische Designmuster Request → Response: Senden Sie ein signiertes Datagram2 (Anfrage + Nonce), empfangen Sie eine Raw- oder Datagram3-Antwort (Echo-Nonce). Hochfrequenz/geringer Overhead: Bevorzugen Sie Datagram3 oder RAW. Authentifizierte Kontrollnachrichten: Datagram2. Legacy-Kompatibilität: Datagram1 wird weiterhin vollständig unterstützt. 3. Datagram2 und Datagram3 Details (2025) Datagram2 (Protokoll 19) Erweiterte Alternative zu Datagram1. Funktionen: - Replay-Schutz: 4-Byte Anti-Replay-Token. - Unterstützung für Offline-Signaturen: ermöglicht die Verwendung durch offline-signierte Destinations. - Erweiterte Signaturabdeckung: umfasst Destination-Hash, Flags, Optionen, Offline-Signaturblock, Payload. - Post-Quanten-bereit: kompatibel mit zukünftigen ML-KEM-Hybriden. - Overhead: ≈ 457 Bytes (X25519-Schlüssel).\nDatagram3 (Protokoll 20) Überbrückt die Lücke zwischen rohen und signierten Typen. Funktionen: - Ohne Signatur beantwortbar: enthält 32-Byte-Hash des Absenders + 2-Byte-Flags. - Minimaler Overhead: ≈ 34 Bytes. - Kein Replay-Schutz — muss von der Anwendung implementiert werden.\nBeide Protokolle sind API 0.9.66-Funktionen und seit Release 2.9.0 im Java-Router implementiert; noch keine i2pd- oder Go-Implementierungen (Oktober 2025).\n4. Größen- und Fragmentierungslimits Tunnel-Nachrichtengröße: 1 028 Bytes (4 B Tunnel-ID + 16 B IV + 1 008 B Nutzdaten). Erstes Fragment: 956 B (typische TUNNEL-Zustellung). Folgefragment: 996 B. Maximale Fragmente: 63–64. Praktisches Limit: ≈ 62 708 B (~61 KB). Empfohlenes Limit: ≤ 10 KB für zuverlässige Zustellung (Paketverluste steigen darüber hinaus exponentiell an). Overhead-Zusammenfassung: - Datagram1 ≈ 427 B (Minimum). - Datagram2 ≈ 457 B. - Datagram3 ≈ 34 B. - Zusätzliche Schichten (I2CP gzip-Header, I2NP, Garlic, Tunnel): + ~5,5 KB im ungünstigsten Fall.\n5. I2CP / I2NP Integration Nachrichtenpfad: 1. Anwendung erstellt Datagramm (über I2P API oder SAM). 2. I2CP verpackt mit gzip-Header (0x1F 0x8B 0x08, RFC 1952) und CRC-32-Prüfsumme. 3. Protokoll + Portnummern werden in gzip-Header-Feldern gespeichert. 4. Router kapselt als I2NP-Nachricht → Garlic clove → 1 KB tunnel-Fragmente. 5. Fragmente durchqueren outbound → Netzwerk → inbound tunnel. 6. Zusammengesetztes Datagramm wird basierend auf Protokollnummer an Anwendungs-Handler übergeben.\nIntegrität: CRC-32 (von I2CP) + optionale kryptografische Signatur (Datagram1/2). Es gibt kein separates Prüfsummenfeld innerhalb des Datagramms selbst.\n6. Programmierschnittstellen Java-API Das Paket net.i2p.client.datagram enthält: - I2PDatagramMaker – erstellt signierte Datagramme. - I2PDatagramDissector – überprüft und extrahiert Absenderinformationen. - I2PInvalidDatagramException – wird bei Überprüfungsfehlern ausgelöst.\nI2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl) verwaltet Protokoll- und Port-Multiplexing für Anwendungen, die sich eine Destination teilen.\nJavadoc-Zugriff: - idk.i2p Javadoc (nur I2P-Netzwerk) - Javadoc Mirror (Clearnet-Spiegel) - Offizielle Javadocs (offizielle Dokumentation)\nSAM v3 Unterstützung SAM 3.2 (2016): PORT- und PROTOCOL-Parameter hinzugefügt. SAM 3.3 (2016): PRIMARY/Subsession-Modell eingeführt; ermöglicht Streams + Datagrams auf einer Destination. Unterstützung für Datagram2 / 3 Session-Stile zur Spezifikation 2025 hinzugefügt (Implementierung ausstehend). Offizielle Spezifikation: SAM v3 Specification i2ptunnel-Module udpTunnel: Voll funktionsfähige Basis für I2P-UDP-Anwendungen (net.i2p.i2ptunnel.udpTunnel). streamr: Betriebsbereit für A/V-Streaming (net.i2p.i2ptunnel.streamr). SOCKS UDP: Nicht funktionsfähig ab Version 2.10.0 (nur UDP-Stub). Für allgemeine UDP-Zwecke verwenden Sie die Datagram-API oder udpTunnel direkt – verlassen Sie sich nicht auf SOCKS UDP.\n7. Ökosystem und Sprachunterstützung (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental Java I2P ist derzeit der einzige Router, der vollständige SAM 3.3 Subsessions und die Datagram2 API unterstützt. 8. Beispielanwendung – UDP-Tracker (I2PSnark 2.10.0) Erste reale Anwendung von Datagram2/3:\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return Das Muster demonstriert die gemischte Verwendung von authentifizierten und leichtgewichtigen Datagrammen, um Sicherheit und Leistung auszubalancieren. 9. Sicherheit und Best Practices Verwenden Sie Datagram2 für jeden authentifizierten Austausch oder wenn Replay-Angriffe relevant sind. Bevorzugen Sie Datagram3 für schnelle beantwortbare Antworten mit moderatem Vertrauen. Verwenden Sie RAW für öffentliche Broadcasts oder anonyme Daten. Halten Sie Payloads ≤ 10 KB für zuverlässige Zustellung. Beachten Sie, dass SOCKS UDP weiterhin nicht funktionsfähig ist. Überprüfen Sie immer gzip CRC und digitale Signaturen beim Empfang. 10. Technische Spezifikation Dieser Abschnitt behandelt die Low-Level-Datagramm-Formate, Kapselung und Protokolldetails.\n10.1 Protokollidentifikation Datagramm-Formate teilen keinen gemeinsamen Header. Router können den Typ nicht allein anhand der Payload-Bytes ableiten.\nBeim Mischen mehrerer Datagramm-Typen – oder beim Kombinieren von Datagrammen mit Streaming – explizit festlegen: - Die Protokollnummer (über I2CP oder SAM) - Optional die Portnummer, wenn Ihre Anwendung mehrere Dienste multiplext\nDas Protokoll nicht festzulegen (0 oder PROTO_ANY) wird nicht empfohlen und kann zu Routing- oder Zustellfehlern führen.\n10.2 Raw Datagrams Nicht beantwortbare Datagramme enthalten keine Absender- oder Authentifizierungsdaten. Sie sind opake Nutzdaten, die außerhalb der höherstufigen Datagramm-API verarbeitet werden, aber über SAM und I2PTunnel unterstützt werden.\nProtokoll: 18 (PROTO_DATAGRAM_RAW)\nFormat:\n+----+----+----+----+----// | payload... +----+----+----+----+----// Die Payload-Länge ist durch Transportlimits beschränkt (≈32 KB praktisches Maximum, oft deutlich weniger).\n10.3 Datagram1 (Beantwortbare Datagramme) Bettet die Destination des Absenders und eine Signature zur Authentifizierung und Antwortadressierung ein.\nProtokoll: 17 (PROTO_DATAGRAM)\nOverhead: ≥427 Bytes Payload: bis zu ~31,5 KB (begrenzt durch Transport)\nFormat:\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from: ein Destination (387+ Bytes) signature: eine Signature, die dem Schlüsseltyp entspricht Für DSA_SHA1: Signature des SHA-256-Hashs der Payload Für andere Schlüsseltypen: Signature direkt über die Payload Hinweise: - Signaturen für Nicht-DSA-Typen wurden in I2P 0.9.14 standardisiert. - LS2 (Proposal 123) Offline-Signaturen werden derzeit in Datagram1 nicht unterstützt.\n10.4 Datagram2-Format Ein verbessertes beantwortbares Datagramm, das Replay-Resistenz hinzufügt, wie in Proposal 163 definiert.\nProtokoll: 19 (PROTO_DATAGRAM2)\nDie Implementierung ist im Gange. Anwendungen sollten Nonce- oder Zeitstempel-Prüfungen zur Redundanz enthalten.\n10.5 Datagram3-Format Bietet beantwortbare, aber nicht authentifizierte Datagramme. Basiert auf der vom Router verwalteten Sitzungsauthentifizierung anstatt auf eingebetteter Zieladresse und Signatur.\nProtokoll: 20 (PROTO_DATAGRAM3) Status: In Entwicklung seit 0.9.66\nNützlich, wenn: - Ziele groß sind (z. B. Post-Quantum-Schlüssel) - Authentifizierung auf einer anderen Ebene erfolgt - Bandbreiteneffizienz kritisch ist\n10.6 Datenintegrität Die Integrität des Datagramms wird durch die gzip CRC-32-Prüfsumme in der I2CP-Schicht geschützt. Es existiert kein explizites Prüfsummenfeld innerhalb des Datagramm-Payload-Formats selbst.\n10.7 Paket-Kapselung Jedes Datagramm wird als einzelne I2NP-Nachricht oder als einzelne Clove in einer Garlic Message gekapselt. I2CP-, I2NP- und Tunnel-Schichten handhaben Länge und Rahmenbildung — es gibt kein internes Trennzeichen oder Längenfeld im Datagramm-Protokoll.\n10.8 Post-Quantum (PQ) Überlegungen Wenn Proposal 169 (ML-DSA-Signaturen) implementiert wird, werden die Signatur- und Zielgrößen dramatisch ansteigen – von ~455 Bytes auf ≥3739 Bytes. Diese Änderung wird den Datagram-Overhead erheblich erhöhen und die effektive Nutzlastkapazität reduzieren.\nDatagram3, das auf Authentifizierung auf Sitzungsebene (nicht eingebettete Signaturen) setzt, wird wahrscheinlich das bevorzugte Design in Post-Quanten-I2P-Umgebungen werden.\n11. Referenzen Proposal 163 – Datagram2 und Datagram3 Proposal 160 – UDP Tracker Integration Proposal 144 – Streaming MTU Berechnungen Proposal 169 – Post-Quantum Signaturen I2CP Spezifikation I2NP Spezifikation Tunnel Message Spezifikation SAM v3 Spezifikation i2ptunnel Dokumentation 12. Wichtigste Änderungen im Changelog (2019 – 2025) Year Release Change 20190.9.43Datagram API stabilization 20210.9.50Protocol port handling reworked 20222.0.0SSU2 adoption completed 20242.6.0Legacy transport removal simplified UDP code 20252.9.0Datagram2/3 support added (Java API) 20252.10.0UDP Tracker implementation released --- 13. Zusammenfassung Das Datagram-Subsystem unterstützt jetzt vier Protokollvarianten, die ein Spektrum von vollständig authentifiziert bis hin zu leichtgewichtiger Rohübertragung bieten. Entwickler sollten für sicherheitskritische Anwendungsfälle zu Datagram2 und für effizienten beantwortbaren Datenverkehr zu Datagram3 migrieren. Alle älteren Typen bleiben kompatibel, um langfristige Interoperabilität zu gewährleisten.\n","description":"Authentifizierte, beantwortbare und rohe Nachrichtenformate über I2CP","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"Datagramme","url":"/de/docs/api/datagrams/"},{"categories":null,"content":" Kontext: Diese Seite archiviert langjährige Debatten aus der frühen Phase des I2P-Designs. Sie erläutert, warum das Projekt lokal vertraute Adressbücher gegenüber DNS-ähnlichen Abfragen oder mehrheitsbasierten Registern bevorzugte. Hinweise zur aktuellen Nutzung finden Sie in der Dokumentation zur Namensgebung .\nVerworfene Alternativen I2Ps Sicherheitsziele schließen gängige Namensschemata aus:\nDNS-ähnliche Namensauflösung. Jeder Resolver auf dem Abfragepfad könnte Antworten fälschen oder zensieren. Selbst mit DNSSEC bleiben kompromittierte Registrare oder Zertifizierungsstellen ein einzelner Ausfallpunkt. In I2P sind Destinationen sind öffentliche Schlüssel—die Übernahme einer Abfrage würde eine Identität vollständig kompromittieren. Abstimmungsbasierte Namensgebung. Ein Angreifer kann unbegrenzt Identitäten erzeugen (ein Sybil-Angriff) und Stimmen für populäre Namen „gewinnen“. Proof-of-Work (Arbeitsnachweis)-Gegenmaßnahmen erhöhen die Kosten, führen jedoch zu erheblichem Koordinationsaufwand. Stattdessen belässt I2P die Namensauflösung bewusst oberhalb der Transportschicht. Die mitgelieferte Naming-Bibliothek bietet ein service-provider interface (Schnittstelle für Dienstanbieter) an, sodass alternative Schemata koexistieren können—Nutzer entscheiden, welchen Adressbüchern oder Jump Services (Sprungdienste) sie vertrauen.\nLokale gegenüber globalen Namen (jrandom, 2005) Namen in I2P sind lokal eindeutig, aber menschenlesbar. Ihr boss.i2p muss nicht mit dem boss.i2p von jemand anderem übereinstimmen, und das ist so vorgesehen. Wenn ein böswilliger Akteur Sie dazu brächte, die Zieladresse hinter einem Namen zu ändern, würde er damit effektiv einen Dienst kapern. Der Verzicht auf globale Eindeutigkeit verhindert diese Art von Angriff. Behandeln Sie Namen wie Lesezeichen oder IM-Spitznamen — Sie wählen selbst, welchen Zieladressen Sie vertrauen, indem Sie bestimmte Adressbücher abonnieren oder Schlüssel manuell hinzufügen. Häufige Einwände \u0026amp; Antworten (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. ## Besprochene Ideen zur Effizienzsteigerung Inkrementelle Updates bereitstellen (nur Destinations (I2P-Zieladressen), die seit dem letzten Abruf hinzugefügt wurden). Ergänzende Feeds (recenthosts.cgi) neben vollständigen Hosts-Dateien anbieten. Skriptfähige Werkzeuge erkunden (zum Beispiel i2host.i2p), um Feeds zusammenzuführen oder nach Vertrauensebenen zu filtern. Wesentliche Erkenntnisse Sicherheit hat Vorrang vor globalem Konsens: lokal gepflegte Adressbücher minimieren das Risiko von Hijacking. Mehrere Namensansätze können über die Naming-API koexistieren—Nutzer entscheiden selbst, was sie als vertrauenswürdig erachten. Völlig dezentrale globale Namensgebung bleibt ein offenes Forschungsproblem; die Abwägungen zwischen Sicherheit, menschlicher Merkfähigkeit und globaler Eindeutigkeit spiegeln weiterhin Zookos Dreieck wider. Referenzen Dokumentation zum Namenssystem Zookos “Names: Decentralized, Secure, Human-Meaningful: Choose Two” Beispiel für einen inkrementellen Feed: stats.i2p/cgi-bin/newhosts.txt ","description":"Historische Debatte über das Namensmodell von I2P und warum globale DNS-ähnliche Schemata verworfen wurden","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"Diskussion zur Namensgebung","url":"/de/docs/legacy/naming/"},{"categories":null,"content":" Hinweis: Diese archivierte Diskussion umreißt historische Ansätze zur Netzwerkdatenbank (netDb). Siehe die Hauptdokumentation zu netDb für Informationen zum aktuellen Verhalten und zu Leitlinien.\nGeschichte Die netDb von I2P wird mithilfe eines einfachen floodfill-Algorithmus verteilt. Frühe Versionen behielten außerdem eine Implementierung von Kademlia-DHT (verteilte Hashtabelle) als Fallback bei; diese erwies sich jedoch als unzuverlässig und wurde in Version 0.6.1.20 vollständig deaktiviert. Das floodfill-Design leitet einen veröffentlichten Eintrag an einen teilnehmenden Router weiter, wartet auf eine Bestätigung und versucht es bei Bedarf mit anderen floodfill-Peers erneut. Floodfill-Peers verbreiten Stores (Speicher-Nachrichten) von Non-floodfill-Routern an alle anderen floodfill-Teilnehmer.\nEnde 2009 wurden Kademlia-Abfragen teilweise wieder eingeführt, um die Speicherlast auf einzelnen floodfill-Routern zu verringern.\nEinführung in Floodfill Floodfill erschien erstmals in Version 0.6.0.4, während Kademlia weiterhin als Fallback verfügbar blieb. Zu der Zeit erschwerten starker Paketverlust und eingeschränkte Routen es, Bestätigungen von den vier nächsten Peers zu erhalten, was häufig Dutzende redundanter store-Versuche (Speicheroperationen) erforderte. Der Wechsel zu einer floodfill-Teilmenge von außen erreichbaren routers bot eine pragmatische kurzfristige Lösung.\nKademlia neu gedacht Zu den in Erwägung gezogenen Alternativen gehörten:\nBetreiben der netDb als Kademlia DHT (verteilte Hashtabelle nach dem Kademlia-Verfahren), beschränkt auf erreichbare routers, die der Teilnahme zustimmen Beibehaltung des floodfill-Modells, jedoch Begrenzung der Teilnahme auf leistungsfähige routers und Überprüfung der Verteilung durch zufällige Stichproben Der floodfill-Ansatz setzte sich durch, weil er einfacher zu implementieren war und die netDb nur Metadaten enthält, keine Nutzdaten der Benutzer. Die meisten Ziele veröffentlichen nie ein LeaseSet, da der Absender sein LeaseSet typischerweise in garlic messages (Garlic-Nachrichten) bündelt.\nAktueller Stand (historische Perspektive) Die netDb-Algorithmen sind auf die Bedürfnisse des Netzwerks optimiert und haben in der Vergangenheit problemlos einige hundert routers bewältigt. Frühe Schätzungen deuteten darauf hin, dass 3–5 floodfill routers ungefähr 10.000 Knoten unterstützen könnten.\nAktualisierte Berechnungen (März 2008) recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T Wo:\nN: Router im Netzwerk L: Durchschnittliche Anzahl der Client-Ziele pro Router (plus eins für die RouterInfo) F: Ausfallrate der Tunnel R: Zeitraum für den Neuaufbau von Tunneln als Anteil an der Lebensdauer eines Tunnels S: Durchschnittliche Größe eines netDb-Eintrags T: Lebensdauer eines Tunnels Bei Verwendung von Werten aus dem Jahr 2008 (N = 700, L = 0.5, F = 0.33, R = 0.5, S = 4 KB, T = 10 minutes) ergibt sich:\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps Wird Kademlia (ein verteiltes Hash-Table-Protokoll) zurückkehren? Entwickler diskutierten Anfang 2007 die Wiedereinführung von Kademlia. Der Konsens war, dass die floodfill-Kapazität bei Bedarf schrittweise ausgebaut werden könne, während Kademlia für die Basispopulation der router erhebliche zusätzliche Komplexität verursachte und den Ressourcenbedarf erhöhte. Der Fallback bleibt inaktiv, sofern die floodfill-Kapazität nicht mehr ausreicht.\nFloodfill-Kapazitätsplanung Die automatische Aufnahme von routers der Bandbreitenklasse O in floodfill ist zwar verlockend, birgt jedoch das Risiko von Denial-of-Service-Szenarien, wenn böswillige Knoten sich dafür entscheiden, teilzunehmen. Historische Analysen deuteten darauf hin, dass die Begrenzung des floodfill-Pools (zum Beispiel 3–5 Peers, die ~10K routers verwalten) sicherer war. Vertrauenswürdige Betreiber oder automatische Heuristiken wurden eingesetzt, um eine ausreichende, zugleich kontrollierte floodfill-Menge aufrechtzuerhalten.\nFloodfill TODO (Historisch) Dieser Abschnitt wird für die Nachwelt beibehalten. Die netDb-Hauptseite verfolgt die aktuelle Roadmap und die Designüberlegungen.\nBetriebsstörungen, wie etwa ein Zeitraum am 13. März 2008, in dem nur ein floodfill router verfügbar war, führten zu mehreren Verbesserungen, die in den Versionen 0.6.1.33 bis 0.7.x veröffentlicht wurden, darunter:\nZufallsbasierte floodfill-Auswahl bei Suchen und Bevorzugung reaktionsschneller Peers Anzeige zusätzlicher floodfill-Metriken auf der router-Konsole auf der Seite \u0026ldquo;Profiles\u0026rdquo; Schrittweise Verringerungen der netDb-Eintragsgröße, um die floodfill-Bandbreitennutzung zu senken Automatisches opt-in (aktive Zustimmung) für eine Teilmenge von routers der Klasse O, basierend auf Leistung, die über Profildaten erfasst wurde Verbessertes Blocklisting, floodfill-Peer-Auswahl und Explorationsheuristiken Weitere Ideen aus jener Zeit umfassten:\nVerwendung von dbHistory-Statistiken, um floodfill-Peers besser zu bewerten und auszuwählen Verbesserung des Retry-Verhaltens, um zu vermeiden, dass ausfallende Peers wiederholt kontaktiert werden Nutzung von Latenzmetriken und Integrations-Scores bei der Auswahl Schnelleres Erkennen und Reagieren auf ausfallende floodfill-Router Weitere Reduzierung des Ressourcenbedarfs bei Knoten mit hoher Bandbreite und floodfill-Knoten Schon zum Zeitpunkt dieser Notizen galt das Netzwerk als widerstandsfähig und verfügte über eine Infrastruktur, um schnell auf feindliche floodfills oder gezielte Denial-of-Service-Angriffe gegen floodfill zu reagieren.\nZusätzliche Hinweise Die router-Konsole legt seit Langem erweiterte Profildaten offen, um die Analyse der floodfill-Zuverlässigkeit zu unterstützen. Während frühere Kommentare über Kademlia oder alternative DHT-Schemata spekulierten, ist floodfill der primäre Algorithmus für Produktionsnetzwerke geblieben. Vorausschauende Forschung konzentrierte sich darauf, die Aufnahme in floodfill adaptiv zu gestalten und gleichzeitig Missbrauchsmöglichkeiten zu begrenzen. ","description":"Historische Anmerkungen zu floodfill, Kademlia-Experimenten und künftigen Optimierungen der netDb","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"Diskussion zur Netzwerkdatenbank","url":"/de/docs/netdb/"},{"categories":null,"content":"Was ist ein Eepsite? Eine eepsite ist eine Website, die ausschließlich im I2P-Netzwerk existiert. Im Gegensatz zu herkömmlichen Websites, die über das clearnet (öffentlich zugängliches Internet) erreichbar sind, sind eepsites nur über I2P erreichbar und bieten sowohl dem Seitenbetreiber als auch den Besuchern Anonymität und Privatsphäre. Eepsites verwenden die Pseudo-Top-Level-Domain .i2p und werden über spezielle .b32.i2p-Adressen oder über menschenlesbare Namen aufgerufen, die im I2P-Adressbuch registriert sind.\nAlle Java-I2P-Installationen enthalten Jetty , einen schlanken, Java-basierten Webserver, der bereits vorinstalliert und vorkonfiguriert ist. Das macht es einfach, innerhalb von Minuten Ihre eigene eepsite (I2P-Website) zu hosten - keine zusätzliche Softwareinstallation erforderlich.\nDiese Anleitung führt Sie durch den Prozess der Erstellung und Konfiguration Ihrer ersten eepsite (eine über I2P erreichbare Website) mit den in I2P integrierten Werkzeugen.\nSchritt 1: Rufen Sie den Manager für versteckte Dienste auf Der Hidden Services Manager (auch I2P Tunnel Manager genannt) ist der Ort, an dem Sie alle I2P-Server- und Client-tunnels konfigurieren, einschließlich HTTP-Servern (eepsites).\nÖffnen Sie Ihre I2P Router-Konsole Navigieren Sie zum Manager für versteckte Dienste Sie sollten die Oberfläche des Hidden Services Manager sehen, die Folgendes anzeigt: - Statusmeldungen - Aktueller Status von tunnel und Client - Globale Steuerung für tunnel - Schaltflächen zum gleichzeitigen Verwalten aller tunnels - I2P-Verborgene Dienste - Liste der konfigurierten Server-tunnels\nStandardmäßig sehen Sie einen vorhandenen Eintrag für den I2P-Webserver, der konfiguriert, aber nicht gestartet ist. Das ist der vorkonfigurierte Jetty-Webserver, der zur Verwendung bereit ist.\nSchritt 2: Konfigurieren Sie die Einstellungen Ihres Eepsite-Servers Klicken Sie in der Liste der Hidden Services auf den Eintrag I2P webserver, um die Serverkonfigurationsseite zu öffnen. Hier passen Sie die Einstellungen Ihrer eepsite an.\nErläuterung der Konfigurationsoptionen Name - Dies ist ein interner Bezeichner für Ihren tunnel - Nützlich, wenn Sie mehrere eepsites betreiben, um den Überblick zu behalten, welche welche ist - Standard: \u0026ldquo;I2P webserver\u0026rdquo;\nBeschreibung - Eine kurze Beschreibung Ihrer eepsite zur eigenen Orientierung - Nur für Sie im Hidden Services Manager (Verwaltung versteckter Dienste) sichtbar - Beispiel: \u0026ldquo;Meine eepsite\u0026rdquo; oder \u0026ldquo;Persönlicher Blog\u0026rdquo;\nTunnel automatisch starten - Wichtig: Aktivieren Sie dieses Kontrollkästchen, um Ihre eepsite automatisch zu starten, sobald Ihr I2P router startet - Stellt sicher, dass Ihre Website nach Neustarts des I2P router ohne manuelles Eingreifen verfügbar bleibt - Empfohlen: Aktiviert\nZiel (Host und Port) - Host: Die lokale Adresse, unter der Ihr Webserver läuft (Standard: 127.0.0.1) - Port: Der Port, auf dem Ihr Webserver lauscht (Standard: 7658 für Jetty) - Wenn Sie den vorinstallierten Jetty-Webserver verwenden, lassen Sie diese bei den Standardwerten - Ändern Sie dies nur, wenn Sie einen benutzerdefinierten Webserver auf einem anderen Port betreiben\nWebsite-Hostname - Dies ist der menschenlesbare .i2p-Domainname Ihrer eepsite - Standard: mysite.i2p (Platzhalter) - Sie können eine benutzerdefinierte Domain wie stormycloud.i2p oder myblog.i2p registrieren - Leer lassen, wenn Sie nur die automatisch generierte .b32.i2p-Adresse verwenden möchten (für outproxies (Ausgangsproxies)) - Siehe unten Registrieren Ihrer I2P-Domain für Informationen dazu, wie Sie einen benutzerdefinierten Hostnamen registrieren\nLocal Destination (lokale Zielkennung) - Dies ist der eindeutige kryptografische Bezeichner Ihrer eepsite (Zieladresse) - Automatisch generiert, wenn der tunnel erstmals erstellt wird - Betrachten Sie dies als die permanente \u0026ldquo;IP-Adresse\u0026rdquo; Ihrer Website auf I2P - Die lange alphanumerische Zeichenfolge ist die .b32.i2p-Adresse Ihrer Website in kodierter Form\nPrivate-Schlüsseldatei - Speicherort, an dem die privaten Schlüssel Ihrer eepsite gespeichert werden - Standard: eepsite/eepPriv.dat - Bewahren Sie diese Datei sicher auf - Jeder, der Zugriff auf diese Datei hat, kann sich als Ihre eepsite ausgeben - Geben Sie diese Datei niemals weiter oder löschen Sie sie\nWichtiger Hinweis Der gelbe Warnhinweis erinnert Sie daran, dass Sie zur Aktivierung der Funktionen zur QR-Code-Generierung oder Registrierungsauthentifizierung einen Website-Hostnamen mit der Endung .i2p konfigurieren müssen (z. B. mynewsite.i2p).\nSchritt 3: Erweiterte Netzwerkoptionen (optional) Wenn Sie auf der Konfigurationsseite nach unten scrollen, finden Sie erweiterte Netzwerkoptionen. Diese Einstellungen sind optional - die Standardeinstellungen funktionieren für die meisten Benutzer gut. Sie können sie jedoch an Ihre Sicherheitsanforderungen und Leistungsanforderungen anpassen.\nTunnel-Längenoptionen Tunnel-Länge - Standard: 3-Hop tunnel (hohe Anonymität) - Steuert, wie viele Router-Hops eine Anfrage durchläuft, bevor sie Ihre eepsite erreicht - Mehr Hops = höhere Anonymität, aber geringere Leistung - Weniger Hops = höhere Leistung, aber geringere Anonymität - Optionen reichen von 0-3 Hops mit Varianz-Einstellungen - Empfehlung: Bei 3 Hops belassen, es sei denn, Sie haben spezielle Leistungsanforderungen\nTunnel-Varianz - Standard: 0 Hop-Varianz (keine Randomisierung, konstante Leistung) - Fügt der Tunnel-Länge eine Randomisierung hinzu, um die Sicherheit zu erhöhen - Beispiel: \u0026ldquo;0-1 Hop-Varianz\u0026rdquo; bedeutet, dass tunnels zufällig 3 oder 4 Hops lang sind - Erhöht die Unvorhersehbarkeit, kann jedoch zu uneinheitlichen Ladezeiten führen\nOptionen zur Anzahl der Tunnel Anzahl (eingehende/ausgehende Tunnels) - Standard: 2 eingehende, 2 ausgehende tunnels (Standard-Bandbreite und -Zuverlässigkeit) - Bestimmt, wie viele parallele tunnels Ihrer eepsite zugewiesen sind - Mehr tunnels = Bessere Verfügbarkeit und Lastbewältigung, aber höherer Ressourcenverbrauch - Weniger tunnels = Geringerer Ressourcenverbrauch, aber geringere Redundanz - Empfohlen für die meisten Nutzer: 2/2 (Standard) - eepsites mit hohem Traffic können von 3/3 oder höher profitieren\nAnzahl der Backups - Standard: 0 Backup tunnels (keine Redundanz, kein zusätzlicher Ressourcenverbrauch) - Standby tunnels, die aktiv werden, wenn primäre tunnels ausfallen - Erhöht die Zuverlässigkeit, verbraucht aber mehr Bandbreite und CPU - Die meisten persönlichen eepsites benötigen keine Backup tunnels\nPOST-Grenzwerte Wenn Ihre eepsite Formulare enthält (Kontaktformulare, Kommentarbereiche, Datei-Uploads usw.), können Sie Grenzwerte für POST-Anfragen konfigurieren, um Missbrauch zu verhindern:\nGrenzwerte pro Client - Pro Zeitraum: Maximale Anzahl von Anfragen eines einzelnen Clients (Standard: 6 pro 5 Minuten) - Sperrdauer: Wie lange missbräuchliche Clients blockiert werden (Standard: 20 Minuten)\nGesamtlimits - Gesamt: Maximale Anzahl von POST-Anfragen aller Clients zusammen (Standard: 20 pro 5 Minuten) - Sperrdauer: Zeitraum, für den alle POST-Anfragen abgewiesen werden, wenn das Limit überschritten wurde (Standard: 10 Minuten)\nPOST-Limit-Zeitraum - Zeitfenster zur Messung der Anfrageraten (Standard: 5 Minuten)\nDiese Beschränkungen helfen, Spam, Denial-of-Service-Angriffe und den Missbrauch automatisierter Formularübermittlungen zu verhindern.\nWann erweiterte Einstellungen angepasst werden sollten Community-Website mit hohem Traffic: Erhöhe die Anzahl der tunnel (3-4 eingehend/ausgehend) Performance-kritische Anwendung: Reduziere die tunnel-Länge auf 2 Hops (Abwägung bei der Privatsphäre) Maximale Anonymität erforderlich: Behalte 3 Hops (Zwischenstationen) bei, füge 0-1 Varianz hinzu Formulare mit legitimer hoher Nutzung: Erhöhe die POST-Limits entsprechend Persönlicher Blog/Portfolio: Verwende alle Standardeinstellungen Schritt 4: Inhalte zu Ihrer Eepsite hinzufügen Da Ihr eepsite nun konfiguriert ist, müssen Sie Ihre Website-Dateien (HTML, CSS, Bilder usw.) in das Document Root (Stammverzeichnis) des Webservers kopieren. Der Speicherort variiert je nach Betriebssystem, Installationsart und I2P-Implementierung.\nSo finden Sie Ihr Document Root (Dokumentstammverzeichnis) Das Document-Root (oft als docroot bezeichnet) ist der Ordner, in dem Sie alle Dateien Ihrer Website ablegen. Ihre Datei index.html sollte direkt in diesem Ordner liegen.\nJava I2P (Standard-Distribution) Linux - Standardinstallation: ~/.i2p/eepsite/docroot/ - Paketinstallation (als Dienst ausgeführt): /var/lib/i2p/i2p-config/eepsite/docroot/\nWindows - Standardinstallation: %LOCALAPPDATA%\\I2P\\eepsite\\docroot\\ - Typischer Pfad: C:\\Users\\YourUsername\\AppData\\Local\\I2P\\eepsite\\docroot\\ - Installation als Windows-Dienst: %PROGRAMDATA%\\I2P\\eepsite\\docroot\\ - Typischer Pfad: C:\\ProgramData\\I2P\\eepsite\\docroot\\\nmacOS - Standardinstallation: /Users/YourUsername/Library/Application Support/i2p/eepsite/docroot/\nI2P+ (Erweiterte I2P-Distribution) I2P+ verwendet die gleiche Verzeichnisstruktur wie Java I2P. Folgen Sie den oben genannten Pfaden entsprechend Ihrem Betriebssystem.\ni2pd (C++-Implementierung) Linux/Unix - Standard: /var/lib/i2pd/eepsite/ oder ~/.i2pd/eepsite/ - Überprüfen Sie Ihre i2pd.conf-Konfigurationsdatei auf die tatsächliche root-Einstellung unter Ihrem HTTP-Server-tunnel\nWindows - Prüfen Sie i2pd.conf in Ihrem i2pd-Installationsverzeichnis\nmacOS - Typischerweise: ~/Library/Application Support/i2pd/eepsite/\nHinzufügen Ihrer Website-Dateien Navigieren Sie zu Ihrem Dokumentstammverzeichnis mithilfe Ihres Dateimanagers oder Terminals Erstellen oder kopieren Sie Ihre Website-Dateien in den Ordner docroot Erstellen Sie mindestens eine index.html-Datei (das ist Ihre Startseite) Fügen Sie bei Bedarf CSS, JavaScript, Bilder und andere Assets hinzu Organisieren Sie Unterverzeichnisse so, wie Sie es für jede Website tun: docroot/ ├── index.html ├── about.html ├── css/ │ └── style.css ├── images/ │ └── logo.png └── js/ └── script.js Schnellstart: Einfaches HTML-Beispiel Wenn du gerade erst anfängst, erstelle eine einfache Datei index.html in deinem Ordner docroot:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My I2P Eepsite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Eepsite!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first website on the I2P network.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Privacy-focused and decentralized!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Berechtigungen (Linux/Unix/macOS) Wenn Sie I2P als Dienst oder unter einem anderen Benutzerkonto ausführen, stellen Sie sicher, dass der I2P-Prozess Lesezugriff auf Ihre Dateien hat:\n# Set appropriate ownership (if running as i2p user) sudo chown -R i2p:i2p /var/lib/i2p/i2p-config/eepsite/docroot/ # Or set readable permissions for all users chmod -R 755 ~/.i2p/eepsite/docroot/ Tipps Standardinhalt: Wenn Sie I2P zum ersten Mal installieren, befindet sich bereits Beispielinhalt im Ordner docroot - Sie können ihn gerne ersetzen Statische Websites funktionieren am besten: Obwohl Jetty Servlets und JSP unterstützt, sind einfache HTML/CSS/JavaScript-Websites am leichtesten zu warten Externe Webserver: Fortgeschrittene Anwender können eigene Webserver (Apache, Nginx, Node.js usw.) auf unterschiedlichen Ports betreiben und den I2P tunnel auf diese verweisen Schritt 5: Ihre Eepsite starten Jetzt, da Ihre eepsite konfiguriert ist und Inhalte enthält, ist es Zeit, sie zu starten und im I2P-Netzwerk zugänglich zu machen.\nTunnel starten Kehren Sie zum Manager für versteckte Dienste zurück Suchen Sie den Eintrag Ihres I2P-Webservers in der Liste Klicken Sie in der Spalte Control auf die Schaltfläche Start Warten auf den Tunnelaufbau Nachdem Sie auf Start geklickt haben, wird Ihr eepsite tunnel aufgebaut. Dieser Vorgang dauert in der Regel 30-60 Sekunden. Beobachten Sie die Statusanzeige:\nRotes Licht = Tunnel wird gestartet/aufgebaut Gelbes Licht = Tunnel teilweise aufgebaut Grünes Licht = Tunnel voll funktionsfähig und bereit Sobald du das grüne Licht siehst, ist deine eepsite im I2P-Netzwerk online!\nAuf Ihre Eepsite zugreifen Klicken Sie auf die Schaltfläche Preview neben Ihrer laufenden eepsite. Dadurch öffnet sich ein neuer Browser-Tab mit der Adresse Ihrer eepsite.\nIhre eepsite hat zwei Arten von Adressen:\nBase32-Adresse (.b32.i2p): Eine lange kryptografische Adresse, die so aussieht:\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p Dies ist die permanente, kryptografisch abgeleitete Adresse Ihrer eepsite Sie kann nicht geändert werden und ist an Ihren privaten Schlüssel gebunden Funktioniert immer, selbst ohne Domainregistrierung Menschenlesbare Domain (.i2p): Wenn Sie einen Website-Hostnamen festlegen (z. B. testwebsite.i2p)\nFunktioniert erst nach der Domainregistrierung (siehe den nächsten Abschnitt) Leichter zu merken und zu teilen Verweist auf Ihre .b32.i2p-Adresse Mit der Schaltfläche Copy Hostname können Sie Ihre vollständige .b32.i2p-Adresse schnell zum Weitergeben kopieren.\n⚠️ Kritisch: Sichern Sie Ihren privaten Schlüssel Bevor Sie fortfahren, muss ein Backup der privaten Schlüsseldatei Ihrer eepsite erstellt werden. Dies ist aus mehreren Gründen von entscheidender Bedeutung:\nWarum Ihren Schlüssel sichern? Ihr privater Schlüssel (eepPriv.dat) ist die Identität Ihrer eepsite. Er bestimmt Ihre .b32.i2p-Adresse und weist die Inhaberschaft Ihrer eepsite nach.\nSchlüssel = .b32-Adresse: Ihr privater Schlüssel generiert mathematisch Ihre eindeutige .b32.i2p-Adresse Kann nicht wiederhergestellt werden: Wenn Sie Ihren Schlüssel verlieren, verlieren Sie die Adresse Ihrer eepsite dauerhaft Kann nicht geändert werden: Wenn Sie eine Domain registriert haben, die auf eine .b32-Adresse zeigt, gibt es keine Möglichkeit, sie zu aktualisieren - die Registrierung ist dauerhaft Für die Migration erforderlich: Der Umzug auf einen neuen Computer oder die Neuinstallation von I2P erfordert diesen Schlüssel, um dieselbe Adresse beizubehalten Multihoming-Unterstützung: (Betrieb eines Dienstes über mehrere Netzwerkpfade/Standorte) Das Betreiben Ihrer eepsite von mehreren Standorten erfordert denselben Schlüssel auf jedem Server Wo ist der private Schlüssel? Standardmäßig wird Ihr privater Schlüssel gespeichert unter: - Linux: ~/.i2p/eepsite/eepPriv.dat (oder /var/lib/i2p/i2p-config/eepsite/eepPriv.dat für Service-Installationen) - Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat oder %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat - macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat\nSie können diesen Pfad auch in Ihrer tunnel-Konfiguration unter \u0026ldquo;Private Key File\u0026rdquo; überprüfen/ändern.\nSo erstellen Sie ein Backup Beenden Sie Ihren tunnel (optional, aber sicherer) Kopieren Sie eepPriv.dat an einen sicheren Ort: Externer USB‑Datenträger Verschlüsseltes Backup‑Laufwerk Passwortgeschütztes Archiv Sicherer Cloud‑Speicher (verschlüsselt) Bewahren Sie mehrere Backups auf an verschiedenen physischen Standorten Geben Sie diese Datei niemals weiter - jeder, der sie besitzt, kann sich als Ihre eepsite ausgeben Aus Sicherung wiederherstellen So stellen Sie Ihre eepsite auf einem neuen System oder nach einer Neuinstallation wieder her:\nInstalliere I2P und erstelle/konfiguriere die Einstellungen für deinen tunnel Stoppe den tunnel, bevor du den Schlüssel kopierst Kopiere deine gesicherte eepPriv.dat an den richtigen Ort Starte den tunnel - er verwendet deine ursprüngliche .b32-Adresse Wenn Sie keine Domain registrieren Herzlichen Glückwunsch! Wenn Sie nicht vorhaben, einen benutzerdefinierten .i2p-Domainnamen zu registrieren, ist Ihre eepsite jetzt vollständig und einsatzbereit.\nDu kannst: - Teile deine .b32.i2p-Adresse mit anderen - Greife über das I2P-Netzwerk mit jedem I2P-fähigen Browser auf deine Seite zu - Aktualisiere deine Website-Dateien jederzeit im Ordner docroot - Überwache deinen tunnel-Status im Hidden Services Manager\nWenn du eine menschenlesbare Domain möchtest (wie mysite.i2p statt einer langen .b32-Adresse), fahre mit dem nächsten Abschnitt fort.\nRegistrierung Ihrer I2P-Domain Eine menschenlesbare .i2p-Domain (wie testwebsite.i2p) ist viel leichter zu merken und zu teilen als eine lange .b32.i2p-Adresse. Die Domain-Registrierung ist kostenlos und verknüpft den von dir gewählten Namen mit der kryptografischen Adresse deiner eepsite (I2P-Website).\nVoraussetzungen Deine eepsite muss laufen und grün angezeigt werden In deiner tunnel-Konfiguration (Schritt 2) muss ein Website-Hostname festgelegt sein Beispiel: testwebsite.i2p oder myblog.i2p Schritt 1: Authentifizierungszeichenfolge generieren Kehren Sie zu Ihrer tunnel-Konfiguration zurück im Manager für verborgene Dienste Klicken Sie auf Ihren I2P-Webserver-Eintrag, um die Einstellungen zu öffnen Scrollen Sie nach unten, um die Schaltfläche Registrierungs-Authentifizierung zu finden Klicken Sie auf Registration Authentication Kopieren Sie die gesamte Authentifizierungszeichenfolge, die für „Authentication for adding host [yourdomainhere]“ angezeigt wird Die Authentifizierungszeichenfolge wird folgendermaßen aussehen:\ntestwebsite.i2p=I8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1uNxFZ0HN7tQbbVj1pmbahepQZNxEW0ufwnMYAoFo8opBQAEAAcAAA==#!date=1762104890#sig=9DjEfrcNRxsoSxiE0Mp0-7rH~ktYWtgwU8c4J0eSo0VHbGxDxdiO9D1Cvwcx8hkherMO07UWOC9BWf-1wRyUAw== Diese Zeichenkette enthält: - Ihren Domainnamen (testwebsite.i2p) - Ihre Zieladresse (der lange kryptografische Bezeichner) - Einen Zeitstempel - Eine kryptografische Signatur, die nachweist, dass Sie den privaten Schlüssel besitzen\nBewahre diese Authentifizierungszeichenfolge auf - sie wird für beide Registrierungsdienste benötigt.\nSchritt 2: Bei stats.i2p registrieren Navigieren Sie zu stats.i2p Add Key (innerhalb von I2P) Fügen Sie die Authentifizierungszeichenkette ein in das Feld \u0026ldquo;Authentication String\u0026rdquo; Fügen Sie Ihren Namen hinzu (optional) - standardmäßig \u0026ldquo;Anonymous\u0026rdquo; Fügen Sie eine Beschreibung hinzu (empfohlen) - beschreiben Sie kurz, worum es in Ihrer eepsite geht Beispiel: \u0026ldquo;Neue I2P Eepsite\u0026rdquo;, \u0026ldquo;Persönlicher Blog\u0026rdquo;, \u0026ldquo;Dateifreigabedienst\u0026rdquo; \u0026ldquo;HTTP Service?\u0026rdquo; aktivieren, wenn es sich um eine Website handelt (für die meisten eepsites aktiviert lassen) Für IRC, NNTP, Proxys, XMPP, git usw. deaktivieren Klicken Sie auf Submit Wenn dies erfolgreich ist, sehen Sie eine Bestätigung, dass Ihre Domain dem stats.i2p-Adressbuch hinzugefügt wurde.\nSchritt 3: Bei reg.i2p registrieren Um maximale Verfügbarkeit sicherzustellen, sollten Sie sich außerdem beim Dienst reg.i2p registrieren:\nNavigieren Sie zu reg.i2p Domain hinzufügen (innerhalb von I2P) Fügen Sie denselben Authentifizierungs-String ein in das Feld \u0026ldquo;Auth string\u0026rdquo; Fügen Sie eine Beschreibung hinzu (optional, aber empfohlen) Dies hilft anderen I2P-Nutzern zu verstehen, was Ihre Website anbietet Klicken Sie auf Submit Sie sollten eine Bestätigung erhalten, dass Ihre Domain registriert wurde.\nSchritt 4: Auf die Verbreitung warten Nach dem Einreichen bei beiden Diensten wird sich Ihre Domain-Registrierung über das Adressbuchsystem des I2P-Netzwerks verbreiten.\nZeitplan der Verbreitung: - Erstregistrierung: Sofort auf den Registrierungsdiensten - Netzwerkweite Verbreitung: Mehrere Stunden bis über 24 Stunden - Volle Verfügbarkeit: Kann bis zu 48 Stunden dauern, bis alle routers aktualisiert sind\nDas ist normal! Das I2P-Adressbuchsystem aktualisiert sich in regelmäßigen Abständen, nicht sofort. Ihre eepsite funktioniert - andere Nutzer müssen lediglich das aktualisierte Adressbuch erhalten.\nBestätigen Sie Ihre Domain Nach einigen Stunden können Sie Ihre Domain testen:\nÖffne einen neuen Browser-Tab in deinem I2P-Browser Versuche, deine Domain direkt aufzurufen: http://yourdomainname.i2p Wenn sie lädt, ist deine Domain registriert und wird im Netzwerk verbreitet! Wenn es noch nicht funktioniert: - Warte länger (Adressbücher aktualisieren sich nach ihrem eigenen Zeitplan) - Das Adressbuch von deinem router benötigt eventuell Zeit, um sich zu synchronisieren - Versuche, deinen I2P router neu zu starten, um ein Adressbuch-Update zu erzwingen\nWichtige Hinweise Die Registrierung ist dauerhaft: Sobald sie registriert und verbreitet wurde, verweist deine Domain dauerhaft auf deine .b32.i2p-Adresse Ziel kann nicht geändert werden: Du kannst nicht ändern, auf welche .b32.i2p-Adresse deine Domain zeigt - deshalb ist das Sichern von eepPriv.dat entscheidend Domaininhaberschaft: Nur der Inhaber des privaten Schlüssels kann die Domain registrieren oder aktualisieren Kostenloser Dienst: Die Domainregistrierung auf I2P ist kostenlos, von der Community betrieben und dezentral Mehrere Registrare: Die Registrierung sowohl bei stats.i2p als auch bei reg.i2p erhöht die Zuverlässigkeit und die Verbreitungsgeschwindigkeit Herzlichen Glückwunsch! Ihre I2P eepsite ist jetzt mit einer registrierten Domain vollständig einsatzbereit!\nNächste Schritte: - Fügen Sie Ihrem docroot-Ordner mehr Inhalte hinzu - Teilen Sie Ihre Domain mit der I2P-Community - Bewahren Sie Ihr eepPriv.dat-Backup sicher auf - Überwachen Sie den tunnel-Status regelmäßig - Erwägen Sie, den I2P-Foren beizutreten oder auf IRC aktiv zu werden, um Ihre Website zu bewerben\nWillkommen im I2P-Netzwerk! 🎉\n","description":"Erfahren Sie, wie Sie mithilfe des integrierten Jetty-Webservers Ihre eigene Website im I2P-Netzwerk erstellen und hosten","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"Eine I2P Eepsite (Website im I2P-Netzwerk) erstellen","url":"/de/docs/guides/eine-i2p-eepsite-website-im-i2p-netzwerk-erstellen/"},{"categories":null,"content":"Was ist I2P? Das Invisible Internet Project (I2P) ist eine anonyme Netzwerkschicht, die zensurresistente Peer-to-Peer-Kommunikation ermöglicht. Anonyme Verbindungen werden durch Verschlüsselung des Nutzerverkehrs und dessen Weiterleitung über ein verteiltes Netzwerk erreicht, das von Freiwilligen weltweit betrieben wird.\nHauptmerkmale Anonymity I2P verbirgt sowohl Absender als auch Empfänger von Nachrichten. Anders als bei herkömmlichen Internetverbindungen, bei denen Ihre IP-Adresse für Websites und Dienste sichtbar ist, verwendet I2P mehrere Verschlüsselungs- und Routing-Ebenen, um Ihre Identität privat zu halten.\nDecentralization Es gibt keine zentrale Autorität in I2P. Das Netzwerk wird von Freiwilligen betrieben, die Bandbreite und Rechenressourcen zur Verfügung stellen. Dies macht es resistent gegen Zensur und einzelne Fehlerquellen.\nAnonymität Sämtlicher Datenverkehr innerhalb von I2P ist Ende-zu-Ende verschlüsselt. Nachrichten werden mehrfach verschlüsselt, während sie durch das Netzwerk geleitet werden, ähnlich wie bei Tor, jedoch mit wichtigen Unterschieden in der Implementierung.\nHow It Works Dezentralisierung I2P verwendet „Tunnels\u0026quot;, um Datenverkehr zu routen. Wenn Sie Daten senden oder empfangen:\nDein Router erstellt einen ausgehenden Tunnel (zum Senden) Dein Router erstellt einen eingehenden Tunnel (zum Empfangen) Nachrichten werden verschlüsselt und über mehrere Router gesendet Jeder Router kennt nur den vorherigen und nächsten Hop, nicht den vollständigen Pfad Ende-zu-Ende-Verschlüsselung I2P verbessert das traditionelle Onion Routing durch \u0026ldquo;Garlic Routing\u0026rdquo;:\nMehrere Nachrichten können zusammengebündelt werden (wie Zehen in einer Knoblauchknolle) Dies bietet bessere Leistung und zusätzliche Anonymität Erschwert die Verkehrsanalyse Network Database I2P verwaltet eine verteilte Netzwerkdatenbank, die Folgendes enthält:\nRouter-Informationen Zieladressen (ähnlich wie .i2p-Websites) Verschlüsselte Routing-Daten Common Use Cases Tunnel Hosten oder besuchen Sie Websites, die auf .i2p enden - diese sind nur innerhalb des I2P-Netzwerks zugänglich und bieten sowohl für Hosts als auch für Besucher starke Anonymitätsgarantien.\nGarlic Routing Teilen Sie Dateien anonym über BitTorrent auf I2P. Viele Torrent-Anwendungen haben integrierte I2P-Unterstützung.\nNetzwerkdatenbank Senden und empfangen Sie anonyme E-Mails mit I2P-Bote oder anderen E-Mail-Anwendungen, die für I2P entwickelt wurden.\nMessaging Nutzen Sie IRC, Instant Messaging oder andere Kommunikationswerkzeuge privat über das I2P-Netzwerk.\nGetting Started Bereit, I2P auszuprobieren? Besuchen Sie unsere Download-Seite , um I2P auf Ihrem System zu installieren.\nFür weitere technische Details siehe die Technische Einführung oder erkunde die vollständige Dokumentation .\nWie es funktioniert Technische Einführung - Tiefergehende technische Konzepte Bedrohungsmodell - Das Sicherheitsmodell von I2P verstehen Vergleich mit Tor - Wie sich I2P von Tor unterscheidet Kryptographie - Details zu den kryptographischen Algorithmen von I2P ","description":"Eine weniger technische Einführung in das anonyme I2P-Netzwerk","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"Einführung in I2P","url":"/de/docs/overview/intro/"},{"categories":null,"content":" Status: Dieses Dokument beschreibt das veraltete ElGamal/AES+SessionTag-Verschlüsselungsprotokoll. Es wird nur zur Wahrung der Abwärtskompatibilität weiterhin unterstützt, da moderne I2P-Versionen (2.10.0+) ECIES-X25519-AEAD-Ratchet verwenden. Das ElGamal-Protokoll ist veraltet und wird ausschließlich aus historischen Gründen und zur Interoperabilität beibehalten.\nÜbersicht ElGamal/AES+SessionTag war I2Ps ursprünglicher Ende-zu-Ende-Verschlüsselungsmechanismus für garlic messages (in I2P gebündelte, gemeinsam übertragene Nachrichten). Es kombinierte:\nElGamal (2048-bit) — für den Schlüsselaustausch AES-256/CBC — zur Nutzlastverschlüsselung SHA-256 — für Hashing und Ableitung des IV (Initialisierungsvektors) Session Tags (32 Byte) — für einmalige Nachrichtenkennungen Das Protokoll ermöglichte sichere Kommunikation zwischen router und Zielen, ohne dauerhafte Verbindungen aufrechtzuerhalten. Jede Sitzung verwendete einen asymmetrischen ElGamal-Austausch, um einen symmetrischen AES-Schlüssel zu etablieren, gefolgt von leichtgewichtigen \u0026ldquo;markierten\u0026rdquo; Nachrichten, die sich auf diese Sitzung bezogen.\nFunktionsweise des Protokolls Sitzungsaufbau (Neue Sitzung) Eine neue Sitzung begann mit einer Nachricht, die zwei Abschnitte enthielt:\nSection Size Contents Purpose ElGamal-encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient's ElGamal public key Establishes the AES session key and IV seed AES-encrypted block Variable (≥128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags Der Klartext innerhalb des ElGamal-Blocks bestand aus: Field Size Description Session Key 32 bytes AES-256 key for the session Pre-IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA-256(Pre-IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length ### Nachrichten für bestehende Sitzungen Sobald eine Sitzung hergestellt war, konnte der Absender mithilfe zwischengespeicherter Sitzungs-Tags existing-session-Nachrichten senden:\nField Size Description Session Tag 32 bytes Single-use identifier tied to the existing session key AES-Encrypted Block Variable Encrypted payload and metadata using the established AES key Routers speicherten übermittelte Tags etwa **15 Minuten** lang im Cache, danach verfielen ungenutzte Tags. Tags waren jeweils genau für **eine Nachricht** gültig, um Korrelationsangriffe zu verhindern. AES-verschlüsseltes Blockformat Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single-use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA-256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16-byte aligned) Random padding to block boundary Routers entschlüsseln mithilfe des Sitzungsschlüssels und des IV, der entweder aus dem Pre-IV (für neue Sitzungen) oder dem Session-Tag (für bestehende Sitzungen) abgeleitet wird. Nach der Entschlüsselung überprüfen sie die Integrität, indem sie den SHA-256-Hash der Klartext-Nutzlast neu berechnen. Verwaltung von Session-Tags Tags (kurzlebige Sitzungsschlüsselkennungen) sind unidirektional: Tags von Alice → Bob können nicht von Bob → Alice wiederverwendet werden. Tags laufen nach ungefähr 15 Minuten ab. Routers führen pro Ziel Session-Key-Manager, um Tags, Schlüssel und Ablaufzeiten nachzuverfolgen. Anwendungen können das Tag-Verhalten über I2CP-Optionen steuern: i2cp.tagThreshold — Mindestanzahl zwischengespeicherter Tags, bevor nachgefüllt wird i2cp.tagCount — Anzahl neuer Tags pro Nachricht Dieser Mechanismus minimierte aufwändige ElGamal-Handshakes, während er die Nicht-Verknüpfbarkeit zwischen Nachrichten aufrechterhielt.\nKonfiguration und Effizienz Session-Tags wurden eingeführt, um die Effizienz über I2Ps hochlatenzbehafteten, ungeordneten Transport zu verbessern. Eine typische Konfiguration lieferte 40 Tags pro Nachricht und verursachte etwa 1,2 KB Overhead. Anwendungen konnten das Zustellverhalten abhängig vom erwarteten Datenverkehr anpassen:\nUse Case Recommended Tags Notes Short-lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re-establishment Long-term services 50+ Ensures steady tag supply despite loss or delay Router bereinigen regelmäßig abgelaufene Tags und entfernen ungenutzten Sitzungszustand, um die Speicherauslastung zu reduzieren und Tag-Flooding-Angriffe abzumildern. Einschränkungen Category Limitation Performance 514-byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES-CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor's algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. Diese Schwächen führten direkt zur Entwicklung des [ECIES-X25519-AEAD-Ratchet](/docs/specs/ecies/)-Protokolls, das perfektes Vorwärtsgeheimnis, authentifizierte Verschlüsselung und einen effizienten Schlüsselaustausch bietet. Abkündigungs- und Migrationsstatus Eingeführt: Frühe I2P-Releases (vor 0.6) Als veraltet markiert: Mit der Einführung von ECIES-X25519 (ECIES mit X25519-Schlüsselvereinbarung) (0.9.46 → 0.9.48) Entfernt: Seit 2.4.0 nicht mehr Standard (Dezember 2023) Unterstützt: Nur zur Wahrung der Abwärtskompatibilität Moderne routers und destinations (Ziele) geben jetzt Kryptotyp 4 (ECIES-X25519) statt Typ 0 (ElGamal/AES) bekannt. Das Legacy-Protokoll wird weiterhin unterstützt, um die Interoperabilität mit veralteten Peers zu gewährleisten, sollte jedoch nicht für neue Bereitstellungen verwendet werden.\nHistorischer Kontext ElGamal/AES+SessionTag war grundlegend für die frühe kryptografische Architektur von I2P. Sein hybrides Design führte Neuerungen ein, darunter einmalige session tags (Sitzungsmarken) und unidirektionale Sitzungen, die nachfolgende Protokolle beeinflussten. Viele dieser Ideen entwickelten sich zu modernen Konstruktionen wie deterministic ratchets (deterministische Ratchet-Mechanismen) und hybriden Post-Quanten-Schlüsselaustauschverfahren.\n","description":"Veraltete Ende-zu-Ende-Verschlüsselung, die ElGamal, AES, SHA-256 und einmalig verwendbare session tags (Sitzungs-Tags) kombiniert","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"ElGamal/AES + SessionTag (Sitzungs-Tag) Verschlüsselung","url":"/de/docs/legacy/elgamal-aes/"},{"categories":null,"content":"Lesen Sie zuerst den Leitfaden für neue Entwickler .\nGrundlegende Richtlinien und Codierungsstil Das meiste der folgenden Punkte sollte gesunder Menschenverstand für jeden sein, der an Open Source oder in einer kommerziellen Programmierumgebung gearbeitet hat. Das Folgende gilt hauptsächlich für den Hauptentwicklungszweig i2p.i2p. Richtlinien für andere Zweige, Plugins und externe Anwendungen können erheblich abweichen; wenden Sie sich an den entsprechenden Entwickler für weitere Hinweise.\nGemeinschaft Bitte schreiben Sie nicht nur Code. Wenn möglich, beteiligen Sie sich an anderen Entwicklungsaktivitäten, einschließlich: Entwicklungsdiskussionen und Support auf IRC und i2pforum.i2p; Testen; Fehlerberichte und Antworten; Dokumentation; Code-Reviews; usw. Aktive Entwickler sollten regelmäßig auf IRC #i2p-dev verfügbar sein. Achten Sie auf den aktuellen Release-Zyklus. Halten Sie sich an Release-Meilensteine wie Feature Freeze, Tag Freeze und die Check-in-Deadline für ein Release. Veröffentlichungszyklus Der normale Veröffentlichungszyklus beträgt 10–16 Wochen, vier Veröffentlichungen pro Jahr. Im Folgenden sind die ungefähren Fristen innerhalb eines typischen 13-Wochen-Zyklus aufgeführt. Die tatsächlichen Fristen für jede Veröffentlichung werden vom Release-Manager nach Rücksprache mit dem gesamten Team festgelegt.\n1–2 Tage nach der vorherigen Veröffentlichung: Check-ins in den Trunk sind erlaubt. 2–3 Wochen nach der vorherigen Veröffentlichung: Frist für die Übertragung größerer Änderungen von anderen Branches in den Trunk. 4–5 Wochen vor der Veröffentlichung: Frist für die Anforderung neuer Startseiten-Links. 3–4 Wochen vor der Veröffentlichung: Feature Freeze. Frist für größere neue Funktionen. 2–3 Wochen vor der Veröffentlichung: Projektbesprechung abhalten, um neue Startseiten-Link-Anfragen zu prüfen, falls vorhanden. 10–14 Tage vor der Veröffentlichung: String Freeze. Keine weiteren Änderungen an übersetzten (getaggten) Strings. Strings zu Transifex pushen, Übersetzungsfrist auf Transifex ankündigen. 10–14 Tage vor der Veröffentlichung: Feature-Frist. Nach diesem Zeitpunkt nur noch Fehlerbehebungen. Keine weiteren Funktionen, Refactoring oder Aufräumarbeiten. 3–4 Tage vor der Veröffentlichung: Übersetzungsfrist. Übersetzungen von Transifex pullen und einchecken. 3–4 Tage vor der Veröffentlichung: Check-in-Frist. Nach diesem Zeitpunkt keine Check-ins mehr ohne Genehmigung des Release-Builders. Stunden vor der Veröffentlichung: Code-Review-Frist. Git Haben Sie ein grundlegendes Verständnis von verteilten Quellcode-Verwaltungssystemen, auch wenn Sie git noch nicht verwendet haben. Bitten Sie um Hilfe, wenn Sie sie benötigen. Einmal gepusht, sind Check-ins für immer; es gibt kein Rückgängigmachen. Bitte seien Sie vorsichtig. Wenn Sie git noch nicht verwendet haben, beginnen Sie mit kleinen Schritten. Checken Sie einige kleine Änderungen ein und sehen Sie, wie es läuft. Testen Sie Ihre Änderungen, bevor Sie sie einchecken. Wenn Sie das Check-in-vor-Test-Entwicklungsmodell bevorzugen, verwenden Sie Ihren eigenen Entwicklungszweig in Ihrem eigenen Konto und erstellen Sie einen MR, sobald die Arbeit abgeschlossen ist. Brechen Sie nicht den Build. Verursachen Sie keine Regressionen. Falls Sie es doch tun (es passiert), verschwinden Sie bitte nicht für längere Zeit, nachdem Sie Ihre Änderung gepusht haben. Wenn Ihre Änderung nicht trivial ist oder Sie möchten, dass Leute sie testen, und Sie gute Testberichte benötigen, um zu wissen, ob Ihre Änderung getestet wurde oder nicht, fügen Sie einen Check-in-Kommentar zu history.txt hinzu und erhöhen Sie die Build-Revision in RouterVersion.java. Checken Sie keine größeren Änderungen in den Haupt-i2p.i2p-Branch spät im Release-Zyklus ein. Wenn ein Projekt mehr als ein paar Tage dauern wird, erstellen Sie Ihren eigenen Branch in git, in Ihrem eigenen Konto, und führen Sie die Entwicklung dort durch, damit Sie keine Releases blockieren. Für große Änderungen (im Allgemeinen mehr als 100 Zeilen oder mehr als drei Dateien betreffend) checken Sie sie in einen neuen Branch in Ihrem eigenen GitLab-Konto ein, erstellen Sie einen MR und weisen Sie einen Reviewer zu. Weisen Sie den MR sich selbst zu. Mergen Sie den MR selbst, sobald der Reviewer ihn genehmigt. Erstellen Sie keine WIP-Branches im Haupt-I2P_Developers-Konto (außer für i2p.www). WIP gehört in Ihr eigenes Konto. Wenn die Arbeit abgeschlossen ist, erstellen Sie einen MR. Die einzigen Branches im Hauptkonto sollten für echte Forks sein, wie ein Point-Release. Führen Sie die Entwicklung transparent und mit der Community im Hinterkopf durch. Checken Sie häufig ein. Checken Sie ein oder mergen Sie in den Haupt-Branch so häufig wie möglich, unter Berücksichtigung der obigen Richtlinien. Wenn Sie an einem großen Projekt in Ihrem eigenen Branch/Konto arbeiten, lassen Sie es die Leute wissen, damit sie folgen und reviewen/testen/kommentieren können. Coding-Stil Der Coding-Stil verwendet in den meisten Teilen des Codes 4 Leerzeichen für die Einrückung. Verwenden Sie keine Tabs. Formatieren Sie Code nicht neu. Wenn Ihre IDE oder Ihr Editor alles neu formatieren möchte, behalten Sie die Kontrolle darüber. An manchen Stellen ist der Coding-Stil anders. Nutzen Sie gesunden Menschenverstand. Ahmen Sie den Stil der Datei nach, die Sie ändern. Alle neuen public- und package-private-Klassen und -Methoden benötigen Javadocs. Fügen Sie @since release-number hinzu. Javadocs für neue private Methoden sind wünschenswert. Für alle hinzugefügten Javadocs darf es keine doclint-Fehler oder -Warnungen geben. Führen Sie ant javadoc mit Oracle Java 14 oder höher aus, um zu prüfen. Alle Parameter müssen @param-Zeilen haben, alle nicht-void-Methoden müssen @return-Zeilen haben, alle als geworfen deklarierten Exceptions müssen @throws-Zeilen haben, und es darf keine HTML-Fehler geben. Klassen in core/ (i2p.jar) und Teile von i2ptunnel sind Teil unserer offiziellen API. Es gibt mehrere externe Plugins und andere Anwendungen, die auf dieser API basieren. Seien Sie vorsichtig, keine Änderungen vorzunehmen, die die Kompatibilität brechen. Fügen Sie der API keine Methoden hinzu, es sei denn, sie sind von allgemeinem Nutzen. Javadocs für API-Methoden sollten klar und vollständig sein. Wenn Sie die API hinzufügen oder ändern, aktualisieren Sie auch die Dokumentation auf der Website (i2p.www branch). Markieren Sie Strings für die Übersetzung, wo es angebracht ist, was für alle UI-Strings gilt. Ändern Sie bestehende markierte Strings nicht, außer wenn es wirklich notwendig ist, da dies vorhandene Übersetzungen beschädigt. Fügen Sie nach dem tag freeze im Release-Zyklus keine markierten Strings hinzu oder ändern Sie diese nicht, damit Übersetzer die Möglichkeit haben, vor dem Release zu aktualisieren. Verwenden Sie Generics und Concurrent-Klassen, wo möglich. I2P ist eine hochgradig multi-threaded Anwendung. Machen Sie sich mit häufigen Java-Fallstricken vertraut, die von FindBugs/SpotBugs erkannt werden. Führen Sie ant findbugs aus, um mehr zu erfahren. Java 8 ist seit Release 0.9.47 erforderlich, um I2P zu bauen und auszuführen. Verwenden Sie keine Java-7- oder -8-Klassen oder -Methoden in eingebetteten Subsystemen: addressbook, core, i2ptunnel.jar (non‑UI), mstreaming, router, routerconsole (nur news), streaming. Diese Subsysteme werden von Android und eingebetteten Anwendungen verwendet, die nur Java 6 erfordern. Alle Klassen müssen in Android API 14 verfügbar sein. Java-7-Sprachfeatures sind in diesen Subsystemen akzeptabel, wenn sie von der aktuellen Version des Android SDK unterstützt werden und sie zu Java-6-kompatiblem Code kompilieren. Try‑with‑resources kann nicht in eingebetteten Subsystemen verwendet werden, da es java.lang.AutoCloseable in der Runtime erfordert, und dies ist erst ab Android API 19 (KitKat 4.4) verfügbar. Das java.nio.file-Paket kann nicht in eingebetteten Subsystemen verwendet werden, da es erst ab Android API 26 (Oreo 8) verfügbar ist. Abgesehen von den oben genannten Einschränkungen dürfen Java-8-Klassen, -Methoden und -Konstrukte nur in den folgenden Subsystemen verwendet werden: BOB, desktopgui, i2psnark, i2ptunnel.war (UI), jetty‑i2p.jar, jsonrpc, routerconsole (außer news), SAM, susidns, susimail, systray. Plugin-Autoren können über die plugin.config-Datei jede Mindest-Java-Version voraussetzen. Konvertieren Sie explizit zwischen primitiven Typen und Klassen; verlassen Sie sich nicht auf Autoboxing/Unboxing. Verwenden Sie nicht URL. Verwenden Sie URI. Fangen Sie nicht Exception. Fangen Sie RuntimeException und geprüfte Exceptions einzeln. Verwenden Sie nicht String.getBytes() ohne ein UTF‑8-Charset-Argument. Sie können auch DataHelper.getUTF8() oder DataHelper.getASCII() verwenden. Geben Sie immer ein UTF‑8-Charset an, wenn Sie Dateien lesen oder schreiben. Die DataHelper-Utilities können hilfreich sein. Geben Sie immer eine Locale (z. B. Locale.US) an, wenn Sie String.toLowerCase() oder String.toUpperCase() verwenden. Verwenden Sie nicht String.equalsIgnoreCase(), da keine Locale angegeben werden kann. Verwenden Sie nicht String.split(). Verwenden Sie DataHelper.split(). Fügen Sie keinen Code zum Formatieren von Datums- und Zeitangaben hinzu. Verwenden Sie DataHelper.formatDate() und DataHelper.formatTime(). Stellen Sie sicher, dass InputStreams und OutputStreams in finally-Blöcken geschlossen werden. Verwenden Sie {} für alle for- und while-Blöcke, auch wenn es nur eine Zeile ist. Wenn Sie {} für entweder den if-, else- oder if-else-Block verwenden, verwenden Sie es für alle Blöcke. Setzen Sie } else { auf eine einzelne Zeile. Geben Sie Felder wo immer möglich als final an. Speichern Sie I2PAppContext, RouterContext, Log oder andere Referenzen auf router- oder context-Elemente nicht in statischen Feldern. Starten Sie keine Threads in Konstruktoren. Verwenden Sie I2PAppThread anstelle von Thread. Protokollierung Die folgenden Richtlinien gelten für den Router, Webapps und alle Plugins.\nFür alle Nachrichten, die nicht auf der Standard-Log-Ebene angezeigt werden (WARN, INFO und DEBUG), verwenden Sie immer log.shouldWarn(), log.shouldInfo() oder log.shouldDebug() vor dem Log-Aufruf, um unnötigen Object-Churn zu vermeiden – es sei denn, die Nachricht ist ein statischer String (keine Verkettung). Log-Nachrichten, die möglicherweise auf der Standard-Log-Ebene angezeigt werden (ERROR, CRIT und logAlways()), sollten kurz, klar und für einen nicht-technischen Benutzer verständlich sein. Dies schließt Ausnahme-Ursachentexte ein, die möglicherweise ebenfalls angezeigt werden. Erwägen Sie eine Übersetzung, wenn der Fehler wahrscheinlich auftritt (z. B. bei Formularübermittlungsfehlern). Andernfalls ist keine Übersetzung erforderlich, aber es kann hilfreich sein, nach einem String zu suchen, der bereits an anderer Stelle zur Übersetzung markiert ist, und diesen wiederzuverwenden. Log-Nachrichten, die nicht auf der Standard-Log-Ebene angezeigt werden (WARN, INFO und DEBUG), sind für die Verwendung durch Entwickler gedacht und unterliegen nicht den oben genannten Anforderungen. WARN-Nachrichten sind jedoch im Android-Log-Tab verfügbar und können Benutzern bei der Fehlerbehebung helfen, daher ist auch bei WARN-Nachrichten etwas Sorgfalt geboten. INFO- und DEBUG-Log-Nachrichten sollten sparsam verwendet werden, insbesondere in häufig durchlaufenen Code-Pfaden. Obwohl sie während der Entwicklung nützlich sind, sollten Sie in Betracht ziehen, sie nach Abschluss der Tests zu entfernen oder auszukommentieren. Loggen Sie nicht nach stdout oder stderr (Wrapper-Log). Lizenzen Checken Sie nur Code ein, den Sie selbst geschrieben haben. Bevor Sie Code oder Bibliotheks-JARs aus anderen Quellen einchecken, begründen Sie, warum dies notwendig ist, überprüfen Sie die Lizenzkompatibilität und holen Sie die Genehmigung des Release-Managers ein. Falls Sie die Genehmigung erhalten, externen Code oder JARs hinzuzufügen, und Binärdateien in einem Debian- oder Ubuntu-Paket verfügbar sind, müssen Sie Build- und Paketierungsoptionen implementieren, um stattdessen das externe Paket zu verwenden. Checkliste der zu ändernden Dateien: build.properties, build.xml, debian/control, debian/i2p-router.install, debian/i2p-router.links, debian/rules, sub-build.xml. Für alle Bilder, die aus externen Quellen eingecheckt werden, liegt es in Ihrer Verantwortung, zuerst die Lizenzkompatibilität zu überprüfen. Fügen Sie die Lizenz- und Quelleninformationen im Check-in-Kommentar hinzu. Fehler Die Verwaltung von Issues ist die Aufgabe aller; bitte helfen Sie mit. Überwachen Sie GitLab auf Issues, bei denen Sie helfen können. Kommentieren Sie, beheben Sie und schließen Sie Issues, wenn Sie können. Neue Entwickler sollten damit beginnen, Issues zu beheben. Wenn Sie eine Lösung haben, fügen Sie Ihren Patch zum Issue hinzu und fügen Sie das Schlüsselwort review-needed hinzu. Schließen Sie das Issue nicht, bis es erfolgreich überprüft wurde und Sie Ihre Änderungen eingecheckt haben. Sobald Sie dies für ein paar Tickets reibungslos durchgeführt haben, können Sie dem normalen Verfahren oben folgen. Schließen Sie ein Issue, wenn Sie glauben, es behoben zu haben. Wir haben keine Testabteilung, um Tickets zu überprüfen und zu schließen. Wenn Sie nicht sicher sind, ob Sie es behoben haben, schließen Sie es und fügen Sie eine Notiz hinzu mit dem Text „Ich glaube, ich habe es behoben, bitte testen Sie es und öffnen Sie es erneut, falls es noch defekt ist\u0026quot;. Fügen Sie einen Kommentar mit der Dev-Build-Nummer oder Revision hinzu und setzen Sie den Meilenstein auf das nächste Release. ","description":"End-to-End-Richtlinien für Beiträge zu I2P: Arbeitsablauf, Veröffentlichungszyklus, Programmierstil, Protokollierung, Lizenzierung und Problembehandlung","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"Entwicklerrichtlinien und Coding-Stil","url":"/de/docs/develop/dev-guidelines/"},{"categories":null,"content":"Reseed-Hosts sind entscheidende Infrastruktur für das I2P-Netzwerk und versorgen neue Router während des Bootstrap-Prozesses mit einer initialen Gruppe von Knoten. Diese Anleitung führt Sie durch die Einrichtung und den Betrieb Ihres eigenen Reseed-Servers.\nWas ist ein I2P Reseed Server? Ein I2P-Reseed-Server hilft dabei, neue Router in das I2P-Netzwerk zu integrieren, indem er:\nBereitstellung der initialen Peer-Erkennung: Neue Router erhalten eine Anfangsgruppe von Netzwerkknoten, zu denen sie sich verbinden können Bootstrap-Wiederherstellung: Unterstützung von Routern, die Schwierigkeiten haben, Verbindungen aufrechtzuerhalten Sichere Verteilung: Der Reseeding-Prozess ist verschlüsselt und digital signiert, um die Netzwerksicherheit zu gewährleisten Wenn ein neuer I2P-Router zum ersten Mal startet (oder alle seine Peer-Verbindungen verloren hat), kontaktiert er Reseed-Server, um einen initialen Satz von Router-Informationen herunterzuladen. Dies ermöglicht es dem neuen Router, seine eigene netDb aufzubauen und Tunnels zu etablieren.\nVoraussetzungen Bevor Sie beginnen, benötigen Sie:\nEin Linux-Server (Debian/Ubuntu empfohlen) mit Root-Zugriff Ein Domain-Name, der auf Ihren Server verweist Mindestens 1 GB RAM und 10 GB Festplattenspeicher Ein laufender I2P router auf dem Server, um die netDb zu befüllen Grundkenntnisse in der Linux-Systemadministration Vorbereitung des Servers Step 1: Update System and Install Dependencies Aktualisieren Sie zunächst Ihr System und installieren Sie die erforderlichen Pakete:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y Dies installiert: - golang-go: Go-Programmiersprache-Laufzeitumgebung - git: Versionsverwaltungssystem - make: Build-Automatisierungswerkzeug - docker.io \u0026amp; docker-compose: Container-Plattform zum Ausführen von Nginx Proxy Manager\nStep 2: Clone and Build Reseed Tools Klonen Sie das reseed-tools-Repository und erstellen Sie die Anwendung:\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install Das reseed-tools-Paket stellt die Kernfunktionalität für den Betrieb eines Reseed-Servers bereit. Es verarbeitet: - Sammeln von Router-Informationen aus Ihrer lokalen Netzwerkdatenbank - Verpacken der Router-Informationen in signierte SU3-Dateien - Bereitstellen dieser Dateien über HTTPS\nStep 3: Generate SSL Certificate Generieren Sie das SSL-Zertifikat und den privaten Schlüssel Ihres Reseed-Servers:\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Wichtige Parameter: - --signer: Ihre E-Mail-Adresse (ersetzen Sie admin@stormycloud.org durch Ihre eigene) - --netdb: Pfad zur netDb Ihres I2P-Routers - --port: Interner Port (8443 wird empfohlen) - --ip: An localhost binden (wir werden einen Reverse Proxy für öffentlichen Zugriff verwenden) - --trustProxy: X-Forwarded-For-Headern vom Reverse Proxy vertrauen\nDer Befehl generiert: - Einen privaten Schlüssel zum Signieren von SU3-Dateien - Ein SSL-Zertifikat für sichere HTTPS-Verbindungen\nSchritt 1: System aktualisieren und Abhängigkeiten installieren Kritisch: Sichern Sie die generierten Schlüssel in /home/i2p/.reseed/ sicher:\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ Speichern Sie dieses Backup an einem sicheren, verschlüsselten Ort mit eingeschränktem Zugriff. Diese Schlüssel sind für den Betrieb Ihres Reseed-Servers unerlässlich und sollten sorgfältig geschützt werden.\nConfiguring the Service Schritt 2: Reseed Tools klonen und kompilieren Erstelle einen systemd-Dienst, um den Reseed-Server automatisch auszuführen:\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF Denken Sie daran, zu ersetzen admin@stormycloud.org durch Ihre eigene E-Mail-Adresse.\nAktivieren und starten Sie nun den Dienst:\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed Überprüfen Sie, ob der Dienst läuft:\nsudo systemctl status reseed Schritt 3: SSL-Zertifikat generieren Für optimale Leistung sollten Sie den Reseed-Dienst regelmäßig neu starten, um die Router-Informationen zu aktualisieren:\nsudo crontab -e Fügen Sie diese Zeile hinzu, um den Dienst alle 3 Stunden neu zu starten:\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy Der Reseed-Server läuft auf localhost:8443 und benötigt einen Reverse Proxy, um öffentlichen HTTPS-Traffic zu verarbeiten. Wir empfehlen Nginx Proxy Manager aufgrund seiner einfachen Bedienung.\nSchritt 4: Sichern Sie Ihre Schlüssel Nginx Proxy Manager mit Docker bereitstellen:\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest Dies exponiert: - Port 80: HTTP-Verkehr - Port 81: Admin-Oberfläche - Port 443: HTTPS-Verkehr\nConfigure Proxy Manager Greifen Sie auf die Admin-Oberfläche unter http://your-server-ip:81 zu\nMit Standard-Zugangsdaten anmelden:\nE-Mail: admin@example.com Passwort: changeme Wichtig: Ändern Sie diese Zugangsdaten sofort nach der ersten Anmeldung!\nNavigieren Sie zu Proxy Hosts und klicken Sie auf Add Proxy Host Konfigurieren Sie den Proxy-Host: Domain Name: Ihre Reseed-Domain (z. B. reseed.example.com) Scheme: https Forward Hostname / IP: 127.0.0.1 Forward Port: 8443 Aktivieren Sie Cache Assets Aktivieren Sie Block Common Exploits Aktivieren Sie Websockets Support Im Tab SSL: Wählen Sie Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) Aktivieren Sie Force SSL Aktivieren Sie HTTP/2 Support Stimmen Sie den Let\u0026rsquo;s Encrypt Nutzungsbedingungen zu Klicken Sie auf Speichern Ihr Reseed-Server sollte nun unter https://reseed.example.com erreichbar sein\nRegistering Your Reseed Server Sobald Ihr Reseed-Server betriebsbereit ist, kontaktieren Sie die I2P-Entwickler, um ihn zur offiziellen Reseed-Server-Liste hinzufügen zu lassen.\nSchritt 5: Systemd-Dienst erstellen Senden Sie eine E-Mail an zzz (I2P Lead Developer) mit den folgenden Informationen:\nI2P E-Mail: zzz@mail.i2p Clearnet E-Mail: zzz@i2pmail.org Schritt 6: Optional - Periodische Neustarts konfigurieren Fügen Sie in Ihre E-Mail ein:\nReseed-Server-URL: Die vollständige HTTPS-URL (z.B. https://reseed.example.com) Öffentliches Reseed-Zertifikat: Befindet sich unter /home/i2p/.reseed/ (.crt-Datei anhängen) Kontakt-E-Mail: Ihre bevorzugte Kontaktmethode für Benachrichtigungen zur Serverwartung Serverstandort: Optional, aber hilfreich (Land/Region) Erwartete Verfügbarkeit: Ihre Verpflichtung zur Wartung des Servers Verification Die I2P-Entwickler werden überprüfen, dass Ihr Reseed-Server: - Ordnungsgemäß konfiguriert ist und Router-Informationen bereitstellt - Gültige SSL-Zertifikate verwendet - Korrekt signierte SU3-Dateien bereitstellt - Erreichbar und reaktionsfähig ist\nSobald genehmigt, wird Ihr Reseed-Server zur Liste hinzugefügt, die mit I2P-Routern verteilt wird, und hilft neuen Benutzern, dem Netzwerk beizutreten!\nMonitoring and Maintenance Nginx Proxy Manager installieren Überwachen Sie Ihren Reseed-Dienst:\nsudo systemctl status reseed sudo journalctl -u reseed -f Proxy Manager konfigurieren Behalten Sie die Systemressourcen im Auge:\nhtop df -h Update Reseed Tools Aktualisieren Sie die reseed-tools regelmäßig, um die neuesten Verbesserungen zu erhalten:\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed Kontaktinformationen Wenn Sie Let\u0026rsquo;s Encrypt über Nginx Proxy Manager verwenden, werden Zertifikate automatisch erneuert. Überprüfen Sie, ob die Erneuerung funktioniert:\ndocker logs nginx-proxy-manager | grep -i certificate Konfiguration des Dienstes Erforderliche Informationen Prüfen Sie die Logs auf Fehler:\nsudo journalctl -u reseed -n 50 Häufige Probleme: - I2P router läuft nicht oder die netDb ist leer - Port 8443 wird bereits verwendet - Berechtigungsprobleme mit dem Verzeichnis /home/i2p/.reseed/\nVerifizierung Stellen Sie sicher, dass Ihr I2P-Router läuft und seine Netzwerkdatenbank gefüllt hat:\nls -lh /home/i2p/.i2p/netDb/ Sie sollten viele .dat-Dateien sehen. Falls leer, warten Sie, bis Ihr I2P-Router Peers entdeckt hat.\nSSL Certificate Errors Überprüfen Sie, ob Ihre Zertifikate gültig sind:\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com Dienststatus überprüfen Überprüfen Sie: - DNS-Einträge zeigen korrekt auf Ihren Server - Firewall erlaubt Ports 80 und 443 - Nginx Proxy Manager läuft: docker ps\nSecurity Considerations Halten Sie Ihre privaten Schlüssel sicher: Teilen oder exponieren Sie niemals den Inhalt von /home/i2p/.reseed/ Regelmäßige Updates: Halten Sie Systempakete, Docker und reseed-tools aktuell Überwachen Sie Logs: Achten Sie auf verdächtige Zugriffsmuster Rate Limiting: Erwägen Sie die Implementierung von Rate Limiting, um Missbrauch zu verhindern Firewall-Regeln: Exponieren Sie nur notwendige Ports (80, 443, 81 für Admin) Admin-Interface: Beschränken Sie das Nginx Proxy Manager Admin-Interface (Port 81) auf vertrauenswürdige IPs Contributing to the Network Indem Sie einen Reseed-Server betreiben, stellen Sie kritische Infrastruktur für das I2P-Netzwerk bereit. Vielen Dank, dass Sie zu einem privateren und dezentraleren Internet beitragen!\nBei Fragen oder für Unterstützung wenden Sie sich an die I2P-Community: - Forum: i2pforum.net - IRC/Reddit: #i2p in verschiedenen Netzwerken - Entwicklung: i2pgit.org Anleitung ursprünglich erstellt von Stormy Cloud , angepasst für die I2P-Dokumentation.\n","description":"Vollständige Anleitung zum Einrichten und Betreiben eines I2P-reseed-Servers, um neuen Routern den Netzwerkbeitritt zu ermöglichen","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"Erstellen und Betreiben eines I2P-Reseed-Servers","url":"/de/docs/guides/erstellen-und-betreiben-eines-i2p-reseed-servers/"},{"categories":null,"content":" 1. Überblick Garlic routing bleibt eine der Kerninnovationen von I2P und kombiniert mehrschichtige Verschlüsselung, Nachrichtenbündelung und unidirektionale Tunnel. Obwohl konzeptionell ähnlich zu Onion-Routing, erweitert es das Modell, indem es mehrere verschlüsselte Nachrichten („Cloves\u0026quot;, dt. Gewürznelken) in einem einzigen Umschlag („Garlic\u0026quot;, dt. Knoblauch) bündelt, was Effizienz und Anonymität verbessert.\nDer Begriff garlic routing wurde von Michael J. Freedman in Roger Dingledines Free Haven Master\u0026rsquo;s Thesis (Juni 2000, §8.1.1) geprägt. I2P-Entwickler übernahmen den Begriff in den frühen 2000er Jahren, um die Bündelungserweiterungen und das unidirektionale Transportmodell widerzuspiegeln und es von Tors leitungsvermitteltem Design zu unterscheiden.\nZusammenfassung: Garlic routing = mehrschichtige Verschlüsselung + Nachrichtenbündelung + anonyme Zustellung über unidirektionale tunnel.\n2. Die \u0026ldquo;Garlic\u0026rdquo;-Terminologie Historisch gesehen wurde der Begriff garlic in drei verschiedenen Kontexten innerhalb von I2P verwendet:\nMehrschichtige Verschlüsselung – tunnel-basierter Schutz im Onion-Stil Bündelung mehrerer Nachrichten – mehrere \u0026ldquo;cloves\u0026rdquo; innerhalb einer \u0026ldquo;garlic message\u0026rdquo; Ende-zu-Ende-Verschlüsselung – früher ElGamal/AES+SessionTags, jetzt ECIES‑X25519‑AEAD‑Ratchet Während die Architektur intakt bleibt, wurde das Verschlüsselungsverfahren vollständig modernisiert.\n3. Mehrschichtige Verschlüsselung Garlic Routing teilt sein grundlegendes Prinzip mit Onion Routing: Jeder Router entschlüsselt nur eine Verschlüsselungsschicht und erfährt dadurch nur den nächsten Hop, aber nicht den vollständigen Pfad.\nAllerdings implementiert I2P unidirektionale Tunnel, keine bidirektionalen Schaltkreise:\nOutbound tunnel: sendet Nachrichten vom Ersteller weg Inbound tunnel: transportiert Nachrichten zurück zum Ersteller Ein vollständiger Roundtrip (Alice ↔ Bob) verwendet vier Tunnel: Alices outbound → Bobs inbound, dann Bobs outbound → Alices inbound. Dieses Design halbiert die Offenlegung von Korrelationsdaten im Vergleich zu bidirektionalen Verbindungen.\nFür Details zur Tunnel-Implementierung siehe die Tunnel-Spezifikation und die Tunnel Creation (ECIES) Spezifikation.\n4. Bündelung mehrerer Nachrichten (Die \u0026ldquo;Cloves\u0026rdquo;) Freedmans ursprüngliches garlic routing sah vor, mehrere verschlüsselte \u0026ldquo;bulbs\u0026rdquo; (Zwiebeln) innerhalb einer Nachricht zu bündeln. I2P implementiert dies als cloves (Knoblauchzehen) innerhalb einer garlic message (Knoblauchnachricht) — jede clove hat ihre eigenen verschlüsselten Zustellanweisungen und ein Ziel (router, destination oder tunnel).\nGarlic Bundling ermöglicht es I2P:\nBestätigungen und Metadaten mit Datennachrichten kombinieren Beobachtbare Verkehrsmuster reduzieren Komplexe Nachrichtenstrukturen ohne zusätzliche Verbindungen unterstützen Abbildung 1: Eine Garlic Message, die mehrere Cloves enthält, jede mit eigenen Zustellungsanweisungen.\nTypische Gewürznelken umfassen:\nDelivery Status Message — Bestätigungen, die den Erfolg oder Misserfolg der Zustellung bestätigen.\nDiese werden in ihre eigene Garlic-Schicht eingebettet, um die Vertraulichkeit zu wahren. Database Store Message — automatisch gebündelte LeaseSets, damit Peers antworten können, ohne die netDb erneut abfragen zu müssen. Cloves werden gebündelt, wenn:\nEin neues LeaseSet muss veröffentlicht werden Neue Session-Tags werden übermittelt Kürzlich ist keine Bündelung erfolgt (~1 Minute standardmäßig) Garlic-Nachrichten ermöglichen die effiziente Ende-zu-Ende-Zustellung mehrerer verschlüsselter Komponenten in einem einzigen Paket.\n5. Entwicklung der Verschlüsselung 5.1 Historical Context Frühe Dokumentation (≤ v0.9.12) beschrieb ElGamal/AES+SessionTags Verschlüsselung: - ElGamal 2048‑bit umschlossene AES-Sitzungsschlüssel - AES‑256/CBC für Payload-Verschlüsselung - 32‑Byte Session Tags, die einmal pro Nachricht verwendet werden\nDieses Kryptosystem ist veraltet.\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) Zwischen 2019 und 2023 migrierte I2P vollständig zu ECIES‑X25519‑AEAD‑Ratchet. Der moderne Stack standardisiert die folgenden Komponenten:\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains Vorteile der ECIES-Migration: Forward Secrecy durch Ratcheting-Schlüssel pro Nachricht Reduzierte Payload-Größe im Vergleich zu ElGamal Widerstandsfähigkeit gegen kryptoanalytische Fortschritte Kompatibilität mit zukünftigen Post-Quantum-Hybriden (siehe Proposal 169) Weitere Details: siehe die ECIES-Spezifikation und EncryptedLeaseSet-Spezifikation .\n6. LeaseSets and Garlic Bundling Garlic-Umschläge enthalten häufig LeaseSets, um die Erreichbarkeit von Zielen zu veröffentlichen oder zu aktualisieren.\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively Alle LeaseSets werden über die *floodfill DHT* verteilt, die von spezialisierten Routern gepflegt wird. Veröffentlichungen werden verifiziert, mit Zeitstempeln versehen und durch Ratenbegrenzung geschützt, um Metadaten-Korrelation zu verringern. Siehe die Network Database Dokumentation für Details.\n7. Modern “Garlic” Applications within I2P Garlic-Verschlüsselung und Nachrichtenbündelung werden im gesamten I2P-Protokollstapel verwendet:\nTunnel-Erstellung und -Nutzung — geschichtete Verschlüsselung pro Hop Ende-zu-Ende-Nachrichtenübermittlung — gebündelte garlic messages mit Clone-Acknowledgment- und LeaseSet-Cloves Network Database-Veröffentlichung — LeaseSets in garlic envelopes verpackt für Datenschutz SSU2- und NTCP2-Transporte — Unterlagenverschlüsselung mittels Noise-Framework und X25519/ChaCha20-Primitiven Garlic routing ist somit sowohl eine Methode der Verschlüsselungsschichtung als auch ein Netzwerk-Messaging-Modell.\n6. LeaseSets und Garlic Bundling Das Dokumentationszentrum von I2P ist hier verfügbar und wird kontinuierlich gepflegt. Relevante aktuelle Spezifikationen umfassen:\nECIES Spezifikation — ECIES‑X25519‑AEAD‑Ratchet Tunnel Creation (ECIES) — modernes tunnel build Protokoll I2NP Spezifikation — I2NP Nachrichtenformate SSU2 Spezifikation — SSU2 UDP Transport Common Structures — netDb und floodfill Verhalten Akademische Validierung: Hoang et al. (IMC 2018, USENIX FOCI 2019) und Muntaka et al. (2025) bestätigen die architektonische Stabilität und betriebliche Resilienz des I2P-Designs.\n7. Moderne \u0026ldquo;Garlic\u0026rdquo;-Anwendungen innerhalb von I2P Laufende Vorschläge:\nProposal 169: Hybride Post-Quantum (ML-KEM 512/768/1024 + X25519) Proposal 168: Optimierung der Transport-Bandbreite Datagram- und Streaming-Updates: Verbesserte Überlastungsverwaltung Zukünftige Anpassungen könnten zusätzliche Strategien zur Nachrichtenverzögerung oder Multi-Tunnel-Redundanz auf der garlic-message-Ebene umfassen, aufbauend auf ungenutzten Zustelloptionen, die ursprünglich von Freedman beschrieben wurden.\n8. Aktuelle Dokumentation und Referenzen Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. ","description":"Verständnis der garlic routing Terminologie, Architektur und modernen Implementierung in I2P","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"Garlic Routing","url":"/de/docs/overview/garlic-routing/"},{"categories":null,"content":"Übersicht Dieses Dokument definiert die grundlegenden Datenstrukturen, die in allen I2P-Protokollen verwendet werden, einschließlich I2NP , I2CP , SSU2 , NTCP2 und weiteren. Diese gemeinsamen Strukturen gewährleisten die Interoperabilität zwischen verschiedenen I2P-Implementierungen und Protokollschichten.\nWichtige Änderungen seit 0.9.58 ElGamal und DSA-SHA1 für Router-Identitäten als veraltet markiert (verwenden Sie X25519 + EdDSA) Unterstützung für Post-Quanten-ML-KEM (Mechanismus zur Schlüsselkapselung) im Beta-Test (per Opt-in ab 2.10.0) Service-Record-Optionen (Service Record = Dienst-Eintrag) standardisiert (Proposal 167 , implementiert in 0.9.66) Spezifikationen für komprimierbares Padding (Auffüllung) finalisiert (Proposal 161 , implementiert in 0.9.57) Allgemeine Typspezifikationen Ganzzahl Beschreibung: Stellt eine nichtnegative ganze Zahl in Netzwerk-Byte-Reihenfolge (Big-Endian) dar.\nInhalt: 1 bis 8 Bytes, die eine vorzeichenlose Ganzzahl darstellen.\nVerwendung: Feldlängen, Anzahlen, Typkennungen und numerische Werte in sämtlichen I2P-Protokollen.\nDatum Beschreibung: Zeitstempel, der die Millisekunden seit der Unix-Epoche (1. Januar 1970, 00:00:00 GMT) angibt.\nInhalt: 8-Byte-Ganzzahl (unsigned long)\nSpezielle Werte: - 0 = Undefiniertes oder Null-Datum - Maximalwert: 0xFFFFFFFFFFFFFFFF (Jahr 584.942.417.355)\nHinweise zur Implementierung: - Immer UTC/GMT als Zeitzone - Millisekundengenauigkeit erforderlich - Wird für den Ablauf von Leases (Einträge in einem leaseSet mit Ablaufzeit), die Veröffentlichung der RouterInfo (Metadaten über einen Router) und die Validierung von Zeitstempeln verwendet\nZeichenkette Beschreibung: UTF-8-kodierte Zeichenkette mit Längenpräfix.\nFormat:\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes Einschränkungen: - Maximale Länge: 255 Bytes (nicht Zeichen - mehrbytige UTF-8-Sequenzen zählen als mehrere Bytes) - Länge kann 0 sein (leere Zeichenkette) - Nullterminator NICHT enthalten - Zeichenkette ist NICHT nullterminiert\nWichtig: UTF-8-Sequenzen können mehrere Bytes pro Zeichen verwenden. Eine Zeichenkette mit 100 Zeichen kann das 255-Byte-Limit überschreiten, wenn mehrbyteige Zeichen verwendet werden.\nKryptografische Schlüsselstrukturen Öffentlicher Schlüssel Beschreibung: Öffentlicher Schlüssel für asymmetrische Verschlüsselung. Schlüsseltyp und -länge sind kontextabhängig oder in einem Schlüsselzertifikat angegeben.\nStandardtyp: ElGamal (seit 0.9.58 für Router Identities veraltet)\nUnterstützte Typen:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta **Implementierungsanforderungen:** X25519 (Typ 4) - Aktueller Standard:\nWird für ECIES-X25519-AEAD-Ratchet-Verschlüsselung verwendet Seit 0.9.48 für Router-Identitäten verpflichtend Little-endian-Kodierung (im Gegensatz zu anderen Typen) Siehe ECIES und ECIES-ROUTERS ElGamal (Typ 0) - Legacy:\nSeit 0.9.58 für Router-Identitäten veraltet Für Destinations (Ziele) weiterhin gültig (Feld seit 0.6/2005 ungenutzt) Verwendet konstante Primzahlen, die in der ElGamal-Spezifikation definiert sind Unterstützung wird zur Wahrung der Abwärtskompatibilität beibehalten MLKEM (Post-Quanten) - Beta:\nHybrider Ansatz kombiniert ML-KEM mit X25519 NICHT standardmäßig in 2.10.0 aktiviert Erfordert manuelle Aktivierung über den Hidden Service Manager (Verwaltung verborgener Dienste) Siehe ECIES-HYBRID und Proposal 169 Typcodes und Spezifikationen können sich ändern JavaDoc: PublicKey Privater Schlüssel Beschreibung: Privater Schlüssel für asymmetrische Entschlüsselung, entsprechend den PublicKey-Typen.\nSpeicherung: Typ und Länge werden aus dem Kontext abgeleitet oder separat in Datenstrukturen/Schlüsseldateien gespeichert.\nUnterstützte Typen:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta **Sicherheitshinweise:** - Privatschlüssel MÜSSEN mithilfe kryptografisch sicherer Zufallszahlengeneratoren erzeugt werden - X25519-Privatschlüssel verwenden scalar clamping (Skalarbegrenzung) wie in RFC 7748 definiert - Schlüsselmaterial MUSS sicher aus dem Speicher gelöscht werden, wenn es nicht mehr benötigt wird JavaDoc: PrivateKey Sitzungsschlüssel Beschreibung: Symmetrischer Schlüssel für AES-256-Verschlüsselung und -Entschlüsselung bei tunnel und garlic encryption von I2P.\nInhalt: 32 Bytes (256 Bits)\nVerwendung: - Tunnel-Schichtverschlüsselung (AES-256/CBC mit IV) - Garlic-Nachrichtenverschlüsselung - Ende-zu-Ende-Sitzungsverschlüsselung\nErzeugung: MUSS einen kryptografisch sicheren Zufallszahlengenerator verwenden.\nJavaDoc: SessionKey SigningPublicKey Beschreibung: Öffentlicher Schlüssel zur Verifikation von Signaturen. Typ und Länge sind im Schlüsselzertifikat der Destination (I2P-Adresse) angegeben oder werden aus dem Kontext abgeleitet.\nStandardtyp: DSA_SHA1 (ab 0.9.58 veraltet)\nUnterstützte Typen:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- **Implementierungsanforderungen:** EdDSA_SHA512_Ed25519 (Typ 7) - Aktueller Standard:\nVoreinstellung für alle neuen Router-Identitäten und Destinations (Ziele) seit Ende 2015 Verwendet die Ed25519-Kurve mit SHA-512-Hashing 32-Byte öffentliche Schlüssel, 64-Byte Signaturen Little-Endian-Codierung (anders als die meisten anderen Typen) Hohe Leistung und Sicherheit RedDSA_SHA512_Ed25519 (Typ 11) - Spezialisiert:\nNUR für verschlüsselte leasesets und Verblindung verwendet Niemals für Router-Identitäten oder Standard-Destinations verwendet Wesentliche Unterschiede zu EdDSA: Private Schlüssel über modulare Reduktion (nicht Clamping) Signaturen enthalten 80 Bytes Zufallsdaten Verwendet öffentliche Schlüssel direkt (keine Hashes privater Schlüssel) Siehe [Red25519-Spezifikation](//docs/specs/red25519-signature-scheme/ DSA_SHA1 (Typ 0) - Veraltet:\nSeit 0.9.58 für Router-Identitäten als veraltet markiert Für neue Destinations (Zieladressen in I2P) nicht empfohlen 1024-Bit DSA mit SHA-1 (bekannte Schwächen) Unterstützung nur aus Kompatibilitätsgründen beibehalten Mehrteilige Schlüssel:\nWenn aus zwei Elementen zusammengesetzt (z. B. ECDSA-Punkte X,Y) Jedes Element wird auf die Länge/2 mit führenden Nullen aufgefüllt Beispiel: 64-Byte-ECDSA-Schlüssel = 32-Byte X + 32-Byte Y JavaDoc: SigningPublicKey SigningPrivateKey Beschreibung: Privater Schlüssel zum Erstellen von Signaturen, entsprechend den SigningPublicKey-Typen.\nSpeicherung: Typ und Länge werden bei der Erstellung festgelegt.\nUnterstützte Typen:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized **Sicherheitsanforderungen:** - Mit einer kryptografisch sicheren Zufallsquelle erzeugen - Mit geeigneten Zugriffskontrollen schützen - Nach Abschluss sicher aus dem Speicher löschen - Für EdDSA: 32-Byte-Seed wird mit SHA-512 gehasht, die ersten 32 Bytes werden zum Skalar (geclamped) - Für RedDSA: Abweichende Schlüsselgenerierung (modulare Reduktion statt Clamping) JavaDoc: SigningPrivateKey Signatur Beschreibung: Kryptografische Signatur der Daten, unter Verwendung des dem Typ SigningPrivateKey entsprechenden Signaturalgorithmus.\nTyp und Länge: Aus dem beim Signieren verwendeten Schlüsseltyp abgeleitet.\nUnterstützte Typen:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized **Format-Hinweise:** - Signaturen mit mehreren Elementen (z. B. ECDSA-R- und -S-Werte) werden pro Element auf Länge/2 mit führenden Nullen aufgefüllt - EdDSA und RedDSA verwenden Little-Endian-Codierung - Alle anderen Typen verwenden Big-Endian-Codierung Verifizierung: - Verwenden Sie den entsprechenden SigningPublicKey - Befolgen Sie die Spezifikationen des Signaturalgorithmus für den Schlüsseltyp - Prüfen Sie, dass die Signaturlänge der erwarteten Länge für den Schlüsseltyp entspricht\nJavaDoc: Signature Hashwert Beschreibung: SHA-256-Hash von Daten, der in I2P durchgängig zur Integritätsprüfung und Identifizierung verwendet wird.\nInhalt: 32 Byte (256 Bit)\nVerwendung: - Router Identity-Hashes (Netzwerkdatenbank-Schlüssel) - Destination-Hashes (Netzwerkdatenbank-Schlüssel) - Tunnel-Gateway-Identifizierung in Leases (Einträgen eines leaseSet) - Überprüfung der Datenintegrität - Erzeugung der Tunnel-ID\nAlgorithmus: SHA-256 wie in FIPS 180-4 definiert\nJavaDoc: Hash Session-Tag Beschreibung: Zufallszahl zur Sitzungsidentifikation und tagbasierten Verschlüsselung.\nWichtig: Die Größe des Session-Tags variiert je nach Verschlüsselungstyp: - ElGamal/AES+SessionTag: 32 Bytes (veraltet) - ECIES-X25519: 8 Bytes (aktueller Standard)\nAktueller Standard (ECIES, integriertes Verschlüsselungsschema mit elliptischen Kurven):\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers Siehe ECIES und ECIES-ROUTERS für ausführliche Spezifikationen.\nVeraltet (ElGamal/AES):\nContents: 32 bytes Usage: Deprecated encryption scheme Erzeugung: MUSS einen kryptographisch sicheren Zufallszahlengenerator verwenden.\nJavaDoc: SessionTag TunnelId Beschreibung: Eindeutiger Bezeichner für die Position eines Routers in einem tunnel. Jeder Hop (Weiterleitungsschritt) in einem tunnel hat seine eigene TunnelId.\nFormat:\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) Verwendung: - Identifiziert eingehende/ausgehende tunnel-Verbindungen bei jedem router - Unterschiedliche TunnelId an jedem Sprung in der tunnel-Kette - Wird in Lease-Strukturen verwendet, um Gateway-tunnel zu identifizieren\nSpezielle Werte: - 0 = Für spezielle Protokollzwecke reserviert (im Normalbetrieb vermeiden) - TunnelIds (Tunnel-IDs) haben für jeden router nur lokale Bedeutung\nJavaDoc: TunnelId Zertifikatspezifikationen Zertifikat Beschreibung: Container für Quittungen, Proof-of-Work (Arbeitsnachweis) oder kryptografische Metadaten, die in ganz I2P verwendet werden.\nFormat:\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes Gesamtgröße: mindestens 3 Bytes (NULL-Zertifikat), bis zu 65538 Bytes maximal\nZertifikatstypen Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) ### Schlüsselzertifikat (Typ 5) Einführung: Version 0.9.12 (Dezember 2013)\nZweck: Legt vom Standard abweichende Schlüsseltypen fest und speichert zusätzliche Schlüsseldaten, die über die standardmäßige 384-Byte-KeysAndCert-Struktur hinausgehen.\nNutzlaststruktur:\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space Wichtige Implementierungshinweise:\nReihenfolge der Schlüsseltypen:\nWARNUNG: Der Typ des Signierschlüssels kommt VOR dem Typ des Kryptoschlüssels Das ist kontraintuitiv, wird jedoch aus Kompatibilitätsgründen beibehalten Reihenfolge: SPKtype, CPKtype (nicht CPKtype, SPKtype) Layout der Schlüsseldaten in KeysAndCert:\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] Berechnung überschüssiger Schlüsseldaten:\nWenn Crypto Key \u0026gt; 256 Bytes: Excess = (Crypto Length - 256) Wenn Signing Key \u0026gt; 128 Bytes: Excess = (Signing Length - 128) Padding = max(0, 384 - Crypto Length - Signing Length) Beispiele (ElGamal-Kryptoschlüssel):\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 **Anforderungen an die Router-Identität:** - NULL-Zertifikat bis Version 0.9.15 verwendet - Schlüsselzertifikat für nicht standardmäßige Schlüsseltypen seit 0.9.16 erforderlich - X25519-Verschlüsselungsschlüssel seit 0.9.48 unterstützt Anforderungen an die Destination: - NULL certificate (NULL-Zertifikat) ODER Key Certificate (Schlüsselzertifikat) (je nach Bedarf) - Key Certificate erforderlich für nicht standardmäßige Signaturschlüsseltypen seit 0.9.12 - Feld für den kryptografischen öffentlichen Schlüssel seit 0.6 (2005) ungenutzt, muss aber weiterhin vorhanden sein\nWichtige Warnungen:\nNULL vs. KEY-Zertifikat:\nEin KEY-Zertifikat mit den Typen (0,0), das ElGamal+DSA_SHA1 angibt, ist erlaubt, wird aber nicht empfohlen Verwenden Sie für ElGamal+DSA_SHA1 stets das NULL-Zertifikat (kanonische Darstellung) Ein KEY-Zertifikat mit (0,0) ist 4 Bytes länger und kann zu Kompatibilitätsproblemen führen Einige Implementierungen verarbeiten KEY-Zertifikate mit (0,0) möglicherweise nicht korrekt Validierung überschüssiger Daten:\nImplementierungen MÜSSEN überprüfen, dass die Zertifikatslänge mit der erwarteten Länge für die jeweiligen Schlüsseltypen übereinstimmt Zertifikate mit überschüssigen Daten zurückweisen, die keinem Schlüsseltyp zuzuordnen sind Nach einer gültigen Zertifikatsstruktur nachgestellten Datenmüll verbieten JavaDoc: Certificate Zuordnung Beschreibung: Sammlung von Schlüssel-Wert-Eigenschaften, die für Konfiguration und Metadaten verwendet wird.\nFormat:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] Größenlimits: - Schlüssellänge: 0-255 Bytes (+ 1 Längenbyte) - Wertlänge: 0-255 Bytes (+ 1 Längenbyte) - Gesamtgröße der Zuordnung: 0-65535 Bytes (+ 2 Bytes des Größenfelds) - Maximale Strukturgröße: 65537 Bytes\nKritische Sortieranforderung:\nWenn Zuordnungen in signierten Strukturen (RouterInfo, RouterAddress, Destination properties, I2CP SessionConfig) vorkommen, MÜSSEN die Einträge nach dem Schlüssel sortiert werden, um die Signaturinvarianz sicherzustellen:\nSortiermethode: Lexikografische Sortierung anhand von Unicode-Codepunktwerten (entspricht Java String.compareTo()) Groß-/Kleinschreibung: Schlüssel und Werte unterscheiden im Allgemeinen zwischen Groß- und Kleinschreibung (anwendungsabhängig) Doppelte Schlüssel: in signierten Strukturen NICHT erlaubt (führt zu einem Fehler bei der Signaturprüfung) Zeichenkodierung: Byteweiser Vergleich in UTF-8 Warum Sortierung wichtig ist: - Signaturen werden auf Basis der Byte-Darstellung berechnet - Unterschiedliche Schlüsselreihenfolgen erzeugen unterschiedliche Signaturen - Nicht signierte Zuordnungen erfordern keine Sortierung, sollten aber derselben Konvention folgen\nImplementierungshinweise:\nKodierungsredundanz:\nSowohl die Trennzeichen = und ; als auch String-Längen-Bytes sind vorhanden Das ist ineffizient, wird jedoch aus Gründen der Kompatibilität beibehalten Die Längen-Bytes sind maßgeblich; Trennzeichen sind erforderlich, aber redundant Zeichenunterstützung:\nEntgegen der Dokumentation WERDEN = und ; innerhalb von Strings unterstützt (Längenbytes handhaben dies) UTF-8-Codierung unterstützt den vollständigen Unicode-Zeichensatz Warnung: I2CP verwendet UTF-8, aber I2NP hat historisch UTF-8 nicht korrekt behandelt Verwenden Sie für I2NP-Zuordnungen nach Möglichkeit ASCII für maximale Kompatibilität Spezielle Kontexte:\nRouterInfo/RouterAddress: MUSS sortiert sein, keine Duplikate I2CP SessionConfig: MUSS sortiert sein, keine Duplikate Anwendungszuordnungen: Sortierung empfohlen, aber nicht immer erforderlich Beispiel (RouterInfo-Optionen):\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 Javadoc: DataHelper Spezifikation der gemeinsamen Struktur SchlüsselUndZertifikat Beschreibung: Grundlegende Struktur, die Verschlüsselungsschlüssel, Signaturschlüssel und Zertifikat kombiniert. Wird sowohl als RouterIdentity (Router-Identität) als auch als Destination (Zieladresse) verwendet.\nStruktur:\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) Schlüsselausrichtung: - Öffentlicher Verschlüsselungsschlüssel: Am Anfang ausgerichtet (Byte 0) - Auffüllung: In der Mitte (falls nötig) - Öffentlicher Signaturschlüssel: Am Ende ausgerichtet (Byte 256 bis Byte 383) - Zertifikat: Beginnt bei Byte 384\nGrößenberechnung:\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length Richtlinien zur Generierung von Padding (Vorschlag 161 ) Implementierungsversion: 0.9.57 (Januar 2023, Release 2.1.0)\nHintergrund: - Für Nicht-ElGamal+DSA-Schlüssel ist Padding in der festen 384-Byte-Struktur vorhanden - Bei Destinations (I2P-Zieladressen) ist das 256-Byte-Feld für den öffentlichen Schlüssel seit 0.6 (2005) ungenutzt - Padding sollte so erzeugt werden, dass es komprimierbar ist und dennoch sicher bleibt\nVoraussetzungen:\nMinimale Zufallsdaten:\nVerwenden Sie mindestens 32 Byte kryptographisch sicherer Zufallsdaten Dies liefert ausreichend Entropie für die Sicherheit Kompressionsstrategie:\nDie 32 Bytes im gesamten Padding-/Public-Key-Feld wiederholen Protokolle wie I2NP Database Store, Streaming SYN, SSU2 handshake verwenden Kompression Erhebliche Einsparungen bei der Bandbreite, ohne die Sicherheit zu beeinträchtigen Beispiele:\nRouter-Identität (X25519 + EdDSA):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed Zieladresse (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed Warum das funktioniert:\nSHA-256-Hash der vollständigen Struktur enthält weiterhin die gesamte Entropie DHT-Verteilung der Netzwerkdatenbank (netDb) hängt nur vom Hash ab Signaturschlüssel (32 Bytes EdDSA/X25519) liefert 256 Bit Entropie Zusätzliche 32 Bytes an wiederholten Zufallsdaten = 512 Bit Gesamtentropie Mehr als ausreichend für kryptografische Sicherheit Implementierungshinweise:\nMUSS die vollständige Struktur mit 387+ Bytes speichern und übertragen SHA-256-Hash wird über die vollständige, unkomprimierte Struktur berechnet Kompression wird auf der Protokollebene angewendet (I2NP, Streaming, SSU2) Abwärtskompatibel mit allen Versionen seit 0.6 (2005) JavaDoc: KeysAndCert RouterIdentity Beschreibung: Identifiziert eindeutig einen router im I2P-Netzwerk. Identische Struktur wie KeysAndCert.\nFormat: Siehe die oben stehende KeysAndCert-Struktur\nAktuelle Anforderungen (Stand: 0.9.58):\nErforderliche Schlüsseltypen:\nVerschlüsselung: X25519 (Typ 4, 32 Bytes) Signatur: EdDSA_SHA512_Ed25519 (Typ 7, 32 Bytes) Zertifikat: Key Certificate (Typ 5) Veraltete Schlüsseltypen:\nElGamal (Typ 0) seit 0.9.58 für Router-Identitäten als veraltet markiert DSA_SHA1 (Typ 0) seit 0.9.58 für Router-Identitäten als veraltet markiert Diese sollten für neue Router NICHT verwendet werden Typische Größe:\nX25519 + EdDSA mit Schlüsselzertifikat = 391 Bytes 32 Bytes X25519-öffentlicher Schlüssel 320 Bytes Padding (Auffüllung) (komprimierbar gemäß Proposal 161 ) 32 Bytes EdDSA-öffentlicher Schlüssel 7 Bytes Zertifikat (3-Byte-Header + 4-Byte-Schlüsseltypen) Historische Entwicklung: - Vor 0.9.16: Immer NULL-Zertifikat (ElGamal + DSA_SHA1) - 0.9.16-0.9.47: Unterstützung für Schlüsselzertifikate hinzugefügt - 0.9.48+: X25519-Verschlüsselungsschlüssel unterstützt - 0.9.58+: ElGamal und DSA_SHA1 als veraltet markiert\nSchlüssel der Netzwerkdatenbank: - RouterInfo (Router-Informationsstruktur) indiziert durch den SHA-256-Hash der vollständigen RouterIdentity (Router-Identität) - Hash über die gesamte 391+ Byte große Struktur berechnet (einschließlich Padding)\nSiehe auch: - Richtlinien zur Padding-Generierung (Proposal 161 ) - Spezifikation des Schlüsselzertifikats oben\nJavaDoc: RouterIdentity Ziel Beschreibung: Endpunkt-Identifikator für die sichere Nachrichtenübermittlung. Strukturell identisch mit KeysAndCert, aber mit anderer Nutzungssemantik.\nFormat: Siehe die obenstehende KeysAndCert-Struktur\nWesentlicher Unterschied zu RouterIdentity (Router-Identität): - Das Feld für den öffentlichen Schlüssel ist UNBENUTZT und kann Zufallsdaten enthalten - Dieses Feld wird seit Version 0.6 (2005) nicht mehr verwendet - War ursprünglich für die alte I2CP-zu-I2CP-Verschlüsselung vorgesehen (deaktiviert) - Wird derzeit nur als IV (Initialisierungsvektor) für die veraltete LeaseSet-Verschlüsselung verwendet\nAktuelle Empfehlungen:\nSignaturschlüssel:\nEmpfohlen: EdDSA_SHA512_Ed25519 (Signaturalgorithmus; Typ 7, 32 Bytes) Alternative: ECDSA-Typen für Kompatibilität mit älteren Systemen Vermeiden: DSA_SHA1 (veraltet, nicht empfohlen) Verschlüsselungsschlüssel:\nFeld ist ungenutzt, muss aber vorhanden sein Empfohlen: Mit Zufallsdaten gemäß Proposal 161 füllen (komprimierbar) Größe: Immer 256 Byte (ElGamal-Slot, obwohl nicht für ElGamal verwendet) Zertifikat:\nNULL-Zertifikat für ElGamal + DSA_SHA1 (nur für Altkompatibilität) Schlüsselzertifikat für alle anderen Signaturschlüsseltypen Typische moderne Destination (Zieladresse):\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes Tatsächlicher Verschlüsselungsschlüssel: - Der Verschlüsselungsschlüssel für die Destination (Zieladresse) befindet sich im LeaseSet, nicht in der Destination - LeaseSet enthält die aktuellen öffentlichen Verschlüsselungsschlüssel - Siehe die LeaseSet2-Spezifikation zum Umgang mit Verschlüsselungsschlüsseln\nNetzwerkdatenbank-Schlüssel: - LeaseSet mit dem SHA-256-Hash der vollständigen Destination (Zieladresse) als Schlüssel - Hash berechnet über die gesamte Struktur von 387+ Byte\nJavaDoc: Destination Strukturen der Netzwerkdatenbank Lease (zeitlich befristete Zuweisung) Beschreibung: Autorisiert einen bestimmten tunnel, Nachrichten für eine Destination (I2P-Zieladresse) zu empfangen. Teil des ursprünglichen LeaseSet-Formats (Typ 1).\nFormat:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch Gesamtgröße: 44 Bytes\nVerwendung: - Nur im ursprünglichen LeaseSet verwendet (Typ 1, veraltet) - Für LeaseSet2 und spätere Varianten stattdessen Lease2 verwenden\nJavaDoc: Lease LeaseSet (Typ 1) (I2P-Datensatz mit Erreichbarkeitsinformationen eines Ziels) Beschreibung: Ursprüngliches LeaseSet-Format. Enthält autorisierte tunnels und Schlüssel für eine Destination (Zieladresse). In der Netzwerkdatenbank gespeichert. Status: Veraltet (verwenden Sie stattdessen LeaseSet2).\nStruktur:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey Datenbankspeicherung: - Datenbanktyp: 1 - Schlüssel: SHA-256-Hash der Destination - Wert: Vollständige LeaseSet-Struktur\nWichtige Hinweise:\nÖffentlicher Schlüssel der Destination (Zieladresse in I2P) ungenutzt:\nDas Feld für den öffentlichen Verschlüsselungsschlüssel in der Destination ist ungenutzt Der Verschlüsselungsschlüssel im LeaseSet ist der eigentliche Schlüssel für die Verschlüsselung Temporäre Schlüssel:\nencryption_key ist temporär (wird beim Start des router neu generiert) signing_key ist temporär (wird beim Start des router neu generiert) Keiner der beiden Schlüssel ist über Neustarts hinweg persistent Widerruf (nicht implementiert):\nsigning_key war für den Widerruf von LeaseSets vorgesehen Ein Widerrufsmechanismus wurde nie implementiert Ein Zero-lease LeaseSet war für den Widerruf vorgesehen, wird aber nicht verwendet Versionierung/Zeitstempel:\nLeaseSet hat kein explizites published-Zeitstempelfeld Die Version ist die früheste Ablaufzeit aller Leases (zeitlich begrenzte Tunnelendpunkte) Ein neues LeaseSet muss eine frühere Lease-Ablaufzeit haben, um akzeptiert zu werden Veröffentlichung von Lease-Ablaufzeiten:\nPre-0.9.7: Alle Leases (zeitlich begrenzte Zugriffsberechtigung auf einen tunnel) mit demselben Ablaufzeitpunkt veröffentlicht (dem frühesten) 0.9.7+: Tatsächliche individuelle Lease-Ablaufzeiten veröffentlicht Dies ist ein Implementierungsdetail und nicht Teil der Spezifikation Keine Leases:\nLeaseSet mit null Leases ist technisch zulässig Vorgesehen für Widerruf (nicht implementiert) In der Praxis nicht verwendet LeaseSet2-Varianten erfordern mindestens ein Lease Veraltet: LeaseSet Typ 1 ist veraltet. Neue Implementierungen sollten LeaseSet2 (Typ 3) verwenden, das Folgendes bietet: - Feld für Veröffentlichungszeitstempel (bessere Versionierung) - Unterstützung mehrerer Verschlüsselungsschlüssel - Unterstützung für Offline-Signaturen - 4-Byte-Lease-Ablaufzeiten (statt 8 Byte) - Flexiblere Optionen\nJavaDoc: LeaseSet LeaseSet-Varianten Lease2 Beschreibung: Verbesseres Lease-Format mit 4-Byte-Ablaufzeit. Wird in LeaseSet2 (Typ 3) und MetaLeaseSet (Typ 7) verwendet.\nEinführung: Version 0.9.38 (siehe Vorschlag 123 )\nFormat:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 Gesamtgröße: 40 Bytes (4 Bytes kleiner als die ursprüngliche Lease (Eintrag mit Ablaufzeit))\nVergleich mit der ursprünglichen Lease (zeitlich begrenzter Eintrag innerhalb eines leaseSet):\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet **JavaDoc:** [Lease2](http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html) OfflineSignature Beschreibung: Optionale Struktur für vorab signierte temporäre Schlüssel, die die Veröffentlichung des LeaseSet ohne Online-Zugriff auf den privaten Signaturschlüssel der Destination (I2P-Zieladresse) ermöglicht.\nEinführung: Version 0.9.38 (siehe Vorschlag 123 )\nFormat:\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey Zweck: - Ermöglicht die Offline-Erzeugung eines LeaseSet - Schützt den Hauptschlüssel der Destination (I2P-Adresse) vor der Online-Offenlegung - Der temporäre Schlüssel kann durch die Veröffentlichung eines neuen LeaseSet ohne Offline-Signatur widerrufen werden\nAnwendungsfälle:\nHochsicherheits-Ziele:\nMaster-Signaturschlüssel offline gespeichert (HSM, Offline-Speicherung) Temporäre Schlüssel werden offline für begrenzte Zeiträume erzeugt Ein kompromittierter temporärer Schlüssel legt den Master-Schlüssel nicht offen Verschlüsselte LeaseSet-Veröffentlichung:\nEncryptedLeaseSet (verschlüsseltes LeaseSet) kann eine Offline-Signatur enthalten Verblindeter öffentlicher Schlüssel + Offline-Signatur bieten zusätzliche Sicherheit Sicherheitsüberlegungen:\nAblaufmanagement:\nAngemessene Ablaufzeiten festlegen (Tage bis Wochen, nicht Jahre) Vor Ablauf neue temporäre Schlüssel erzeugen Kürzere Ablaufzeit = bessere Sicherheit, mehr Wartungsaufwand Schlüsselerzeugung:\nTemporäre Schlüssel offline in einer sicheren Umgebung erzeugen Mit dem Master-Schlüssel offline signieren Nur den signierten temporären Schlüssel + die Signatur an den online router übertragen Widerruf:\nEinen neuen LeaseSet ohne Offline-Signatur veröffentlichen, um implizit zu widerrufen Oder einen neuen LeaseSet mit anderem temporären Schlüssel veröffentlichen Signaturprüfung:\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature Implementierungshinweise: - Die Gesamtgröße variiert je nach Signaturtyp und Typ des Signaturschlüssels der Destination (Zieladresse) - Mindestgröße: 4 + 2 + 32 (EdDSA-Schlüssel) + 64 (EdDSA-Signatur) = 102 Bytes - Maximal sinnvolle Größe: ~600 Bytes (RSA-4096 temporärer Schlüssel + RSA-4096 Signatur)\nKompatibel mit: - LeaseSet2 (Typ 3) - EncryptedLeaseSet (Typ 5) - MetaLeaseSet (Typ 7)\nSiehe auch: Vorschlag 123 für Details zum Offline-Signaturprotokoll.\nLeaseSet2Header Beschreibung: Gemeinsame Header-Struktur für LeaseSet2 (Typ 3) und MetaLeaseSet (Typ 7).\nEinführung: Version 0.9.38 (siehe Vorschlag 123 )\nFormat:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length Minimale Gesamtgröße: 395 Bytes (ohne Offline-Signatur)\nFlag-Definitionen (Bitreihenfolge: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility **Flag-Details:** Bit 0 - Offline-Schlüssel: - 0: Keine Offline-Signatur; verwenden Sie den Signaturschlüssel der Destination (I2P-Zielidentität), um die LeaseSet-Signatur zu verifizieren - 1: Die OfflineSignature-Struktur folgt auf das Flags-Feld\nBit 1 - Unveröffentlicht: - 0: Standardmäßig veröffentlichter LeaseSet, sollte an die floodfills geflutet werden - 1: Unveröffentlichter LeaseSet (nur clientseitig) - Sollte NICHT geflutet, veröffentlicht oder als Antwort auf Anfragen gesendet werden - Wenn abgelaufen, NICHT netdb nach Ersatz abfragen (es sei denn, Bit 2 ist ebenfalls gesetzt) - Wird für lokale tunnels oder Tests verwendet\nBit 2 - Geblindet (seit 0.9.42): - 0: Standard-LeaseSet - 1: Dieses unverschlüsselte LeaseSet wird bei der Veröffentlichung geblindet und verschlüsselt - Die veröffentlichte Version wird ein EncryptedLeaseSet (Typ 5) sein - Falls abgelaufen, den geblindeten Ort in netdb als Ersatz abfragen - Bit 1 muss ebenfalls auf 1 gesetzt werden (unveröffentlicht + geblindet) - Wird für verschlüsselte versteckte Dienste verwendet\nAblaufgrenzen:\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours **Anforderungen an den Veröffentlichungszeitstempel:** LeaseSet (Typ 1) hatte kein published-Feld, sodass für die Versionierung nach dem frühesten Lease-Ablauf gesucht werden musste. LeaseSet2 fügt einen expliziten published-Zeitstempel mit 1-Sekunden-Auflösung hinzu.\nKritischer Implementierungshinweis: - Routers MÜSSEN die Veröffentlichung von LeaseSets pro Destination (I2P-Adresse) deutlich langsamer als einmal pro Sekunde drosseln - Wenn schneller veröffentlicht wird, sicherstellen, dass jedes neue LeaseSet eine published-Zeit hat, die mindestens 1 Sekunde später liegt - Floodfills werden ein LeaseSet ablehnen, wenn die published-Zeit nicht neuer ist als die aktuelle Version - Empfohlenes Mindestintervall: 10-60 Sekunden zwischen Veröffentlichungen\nBerechnungsbeispiele:\nLeaseSet2 (max. 11 Minuten):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet (max. 18,2 Stunden):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) Versionierung: - LeaseSet gilt als \u0026ldquo;neuer\u0026rdquo;, wenn der published-Zeitstempel größer ist - Floodfills speichern und verteilen nur die neueste Version - Achte darauf, wenn die älteste Lease (Eintrag im LeaseSet) mit der ältesten Lease des vorherigen LeaseSets übereinstimmt\nLeaseSet2 (Typ 3) Beschreibung: Modernes LeaseSet-Format mit mehreren Verschlüsselungsschlüsseln, Offline-Signaturen und Dienstdatensätzen. Aktueller Standard für versteckte Dienste in I2P.\nEinführung: Version 0.9.38 (siehe Vorschlag 123 )\nStruktur:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix Datenbankspeicherung: - Datenbanktyp: 3 - Schlüssel: SHA-256-Hash der Destination (Zieladresse in I2P) - Wert: Vollständige LeaseSet2-Struktur\nSignaturberechnung:\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key Bevorzugungsreihenfolge für Verschlüsselungsschlüssel Für veröffentlichtes (Server) LeaseSet: - Schlüssel in der Reihenfolge der Serverpräferenz aufgeführt (mit höchster Präferenz zuerst) - Clients, die mehrere Typen unterstützen, SOLLTEN die Serverpräferenz befolgen - Wählen Sie den ersten unterstützten Typ aus der Liste aus - Im Allgemeinen sind höher nummerierte (neuere) Schlüsseltypen sicherer/effizienter - Empfohlene Reihenfolge: Schlüssel in umgekehrter Reihenfolge nach Typcode auflisten (neueste zuerst)\nBeispielhafte Servereinstellung:\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] Für ein unveröffentlichtes (Client) LeaseSet: - Die Schlüsselreihenfolge spielt praktisch keine Rolle (Verbindungen zu Clients werden nur selten versucht) - Aus Konsistenzgründen die gleiche Konvention beibehalten\nAuswahl des Client-Schlüssels: - Serverpräferenz respektieren (ersten unterstützten Typ auswählen) - Oder implementierungsdefinierte Präferenz verwenden - Oder kombinierte Präferenz auf Grundlage der Fähigkeiten beider Seiten ermitteln\nZuordnung von Optionen Anforderungen: - Optionen MÜSSEN nach Schlüssel sortiert sein (lexikografisch, UTF-8-Byte-Reihenfolge) - Die Sortierung gewährleistet die Signatur-Invarianz - Doppelte Schlüssel sind NICHT erlaubt\nStandardformat (Vorschlag 167 ):\nSeit API 0.9.66 (Juni 2025, Release 2.9.0) folgen Service-Record-Optionen einem standardisierten Format. Siehe Proposal 167 für die vollständige Spezifikation.\nFormat der Service-Record-Option:\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) Beispiel-Serviceeinträge:\n1. Selbstreferenzierender SMTP-Server:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. Einzelner externer SMTP-Server:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. Mehrere SMTP-Server (Lastverteilung):\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. HTTP-Dienst mit App-Optionen:\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates TTL-Empfehlungen: - Minimum: 86400 Sekunden (1 Tag) - Längere TTL verringert die netdb-Abfragelast - Abwägung zwischen Reduzierung von Abfragen und Verbreitung von Dienst-Updates - Für stabile Dienste: 604800 (7 Tage) oder länger\nImplementierungshinweise:\nVerschlüsselungsschlüssel (Stand 0.9.44):\nElGamal (Typ 0, 256 Byte): Abwärtskompatibilität X25519 (Typ 4, 32 Byte): Aktueller Standard MLKEM-Varianten: Post-Quanten-Kryptografie (Beta, noch nicht finalisiert) Validierung der Schlüssellänge:\nFloodfills und Clients MÜSSEN in der Lage sein, unbekannte Schlüsseltypen zu parsen Verwenden Sie das Feld keylen, um unbekannte Schlüssel zu überspringen Das Parsen darf nicht fehlschlagen, wenn der Schlüsseltyp unbekannt ist Veröffentlichungszeitstempel:\nSiehe Hinweise im LeaseSet2Header zur Ratenbegrenzung Mindestens 1 Sekunde Abstand zwischen Veröffentlichungen Empfohlen: 10–60 Sekunden zwischen Veröffentlichungen Migration des Verschlüsselungstyps:\nMehrere Schlüssel ermöglichen eine schrittweise Migration Während der Übergangsphase sowohl alte als auch neue Schlüssel auflisten Alten Schlüssel nach ausreichend langer Client-Aktualisierungsphase entfernen JavaDoc: LeaseSet2 MetaLease Beschreibung: Lease-Struktur für MetaLeaseSet, die statt tunnels andere LeaseSets referenzieren kann. Wird für Lastverteilung und Redundanz verwendet.\nEinführung: Version 0.9.38, geplant lauffähig ab 0.9.40 (siehe Vorschlag 123 )\nFormat:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 Gesamtgröße: 40 Bytes\nEintragstyp (Flags-Bits 3-0):\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) **Anwendungsszenarien:** Lastverteilung:\nMetaLeaseSet mit mehreren MetaLease-Einträgen Jeder Eintrag verweist auf ein anderes LeaseSet2 Clients wählen basierend auf dem Kostenfeld Redundanz:\nMehrere Einträge, die auf Backup-LeaseSets verweisen Fallback, falls primäres LeaseSet nicht verfügbar ist Service-Migration:\nMetaLeaseSet (spezielle LeaseSet) verweist auf ein neues LeaseSet Ermöglicht einen nahtlosen Übergang zwischen Destinations (I2P-Adressen) Verwendung des Cost-Felds: - Niedrigerer Cost-Wert = höhere Priorität - Cost 0 = höchste Priorität - Cost 255 = niedrigste Priorität - Clients SOLLTEN Einträge mit niedrigerem Cost-Wert bevorzugen - Einträge mit gleichem Cost-Wert können zufällig lastverteilt werden\nVergleich mit Lease2:\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing **JavaDoc:** [MetaLease](http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html) MetaLeaseSet (Typ 7) Beschreibung: LeaseSet-Variante, die MetaLease-Einträge (spezielle I2P-Struktur für indirekte Verweise) enthält und damit indirekte Verweise auf andere LeaseSets bereitstellt. Wird für Lastverteilung, Redundanz und Dienstmigration eingesetzt.\nEinführung: Definiert in 0.9.38, geplant ab 0.9.40 einsatzbereit (siehe Vorschlag 123 )\nStatus: Spezifikation abgeschlossen. Der Status des Produktiveinsatzes sollte anhand der aktuellen I2P-Versionen überprüft werden.\nStruktur:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations Datenbankspeicherung: - Datenbanktyp: 7 - Schlüssel: SHA-256-Hash der Destination (Zielkennung) - Wert: Vollständige MetaLeaseSet-Struktur (erweiterte leaseSet-Struktur)\nSignaturberechnung:\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key Anwendungsfälle:\n1. Lastverteilung:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. Ausfallsicherung:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. Dienstmigration:\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. Mehrschichtarchitektur:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing Widerrufsliste:\nDie Widerrufsliste ermöglicht es MetaLeaseSet, zuvor veröffentlichte LeaseSets explizit zu widerrufen:\nZweck: Bestimmte Destinations als nicht mehr gültig markieren Inhalt: SHA-256-Hashes widerrufener Destination-Strukturen Verwendung: Clients DÜRFEN KEINE LeaseSets verwenden, deren Destination-Hash in der Widerrufsliste erscheint Typischer Wert: Leer (numr=0) in den meisten Bereitstellungen Beispiel für einen Widerruf:\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached Ablaufbehandlung:\nMetaLeaseSet (Metadatensatz für leaseSet) verwendet LeaseSet2Header mit maximalem expires=65535 Sekunden (~18,2 Stunden):\nViel länger als LeaseSet2 (max. ~11 Minuten) Geeignet für relativ statische indirekte Referenzierung Referenzierte LeaseSets können eine kürzere Ablaufzeit haben Clients müssen die Ablaufzeit sowohl von MetaLeaseSet als auch von den referenzierten LeaseSets prüfen Zuordnung der Optionen:\nDasselbe Format wie bei den LeaseSet2-Optionen verwenden Kann service records (Servicedatensätze) enthalten (Vorschlag 167 ) MUSS nach Schlüssel sortiert sein Service records beschreiben typischerweise den letztendlichen Dienst, nicht die Indirektionsstruktur Hinweise zur Client-Implementierung:\nAblauf der Auflösung:\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry Zwischenspeicherung:\nSowohl MetaLeaseSet als auch referenzierte LeaseSets zwischenspeichern Ablaufzeiten beider Ebenen prüfen Veröffentlichung eines aktualisierten MetaLeaseSet beobachten Failover (Ausfallsicherung):\nFällt der bevorzugte Eintrag aus, versuche den mit den nächstniedrigeren Kosten Erwäge, ausgefallene Einträge vorübergehend als nicht verfügbar zu markieren Regelmäßig erneut prüfen, ob sie wieder verfügbar sind Implementierungsstatus:\nProposal 123 stellt fest, dass Teile noch \u0026ldquo;in Entwicklung\u0026rdquo; sind. Implementierende sollten: - Die Produktionsreife in der Zielversion von I2P überprüfen - Die Unterstützung für MetaLeaseSet vor der Bereitstellung testen - Auf aktualisierte Spezifikationen in neueren I2P-Versionen prüfen\nJavaDoc: MetaLeaseSet EncryptedLeaseSet (verschlüsseltes LeaseSet, Typ 5) Beschreibung: Verschlüsseltes und verblindetes LeaseSet für verbesserte Privatsphäre. Nur der verblindete öffentliche Schlüssel und die Metadaten sind sichtbar; die tatsächlichen leases (Lease-Einträge) und Verschlüsselungsschlüssel sind verschlüsselt.\nEinführung: Definiert seit 0.9.38, funktionsfähig seit 0.9.39 (siehe Vorschlag 123 )\nStruktur:\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key Datenbankspeicherung: - Datenbanktyp: 5 - Schlüssel: SHA-256-Hash der verblindeten Destination (Zieladresse) (nicht die ursprüngliche Destination) - Wert: Vollständige EncryptedLeaseSet-Struktur\nKritische Unterschiede gegenüber LeaseSet2:\nVerwendet NICHT die LeaseSet2Header-Struktur (I2P-Strukturbezeichnung) (hat ähnliche Felder, aber einen anderen Aufbau) Verblindeter öffentlicher Schlüssel statt vollständiger Destination (I2P-Adresse) Verschlüsselte Nutzlast statt Klartext-Leases und -Schlüssel Datenbankschlüssel ist der Hash der verblindeten Destination, nicht der ursprünglichen Destination Signaturberechnung:\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key Anforderung an den Signaturtyp:\nMUSS RedDSA_SHA512_Ed25519 (type 11) verwenden: - Verblindete öffentliche Schlüssel mit 32 Byte - Signaturen mit 64 Byte - Erforderlich für die Sicherheitseigenschaften der Verblindung - Siehe [Red25519-Spezifikation](//docs/specs/red25519-signature-scheme/\nWesentliche Unterschiede zu EdDSA: - Private Schlüssel mittels modularer Reduktion (kein Clamping) - Signaturen enthalten 80 Byte Zufallsdaten - Verwendet öffentliche Schlüssel direkt (keine Hashes) - Ermöglicht eine sichere Verblindung\nVerblindung und Verschlüsselung:\nAusführliche Informationen finden Sie in der EncryptedLeaseSet-Spezifikation :\n1. Schlüssel-Blindierung:\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. Speicherort der Datenbank:\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. Verschlüsselungsschichten (drei Schichten):\nSchicht 1 - Authentifizierungsschicht (Client-Zugriff): - Verschlüsselung: ChaCha20-Stromchiffre - Schlüsselableitung: HKDF mit clientspezifischen Geheimnissen - Authentifizierte Clients können die äußere Schicht entschlüsseln\nSchicht 2 - Verschlüsselungsschicht: - Verschlüsselung: ChaCha20 - Schlüssel: Abgeleitet aus DH (Diffie-Hellman-Schlüsselaustausch) zwischen Client und Server - Enthält das eigentliche LeaseSet2 oder MetaLeaseSet\nSchicht 3 - Inneres LeaseSet (Datensatz mit Adressen und Schlüsseln in I2P): - Vollständiges LeaseSet2 oder MetaLeaseSet - Enthält alle tunnels, Verschlüsselungsschlüssel, Optionen - Nur nach erfolgreicher Entschlüsselung zugänglich\nAbleitung des Verschlüsselungsschlüssels:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) Erkennungsprozess:\nFür autorisierte Clients:\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication Für nicht autorisierte Clients: - Können nicht entschlüsseln, selbst wenn sie den EncryptedLeaseSet (verschlüsselter LeaseSet) finden - Können die ursprüngliche Destination (Zieladresse) nicht aus der blinded version (verschleierte Version) bestimmen - Können EncryptedLeaseSets nicht über verschiedene blinding periods (Verschleierungszeiträume) hinweg verknüpfen (tägliche Rotation)\nAblaufzeiten:\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived **Veröffentlichter Zeitstempel:** Gleiche Anforderungen wie bei LeaseSet2Header: - Muss sich zwischen Veröffentlichungen um mindestens 1 Sekunde erhöhen - Floodfills lehnen ab, wenn nicht neuer als die aktuelle Version - Empfohlen: 10-60 Sekunden zwischen Veröffentlichungen\nOffline-Signaturen mit verschlüsselten LeaseSets:\nBesondere Hinweise bei der Verwendung von Offline-Signaturen: - Der verblindete öffentliche Schlüssel rotiert täglich - Die Offline-Signatur muss täglich mit einem neuen verblindeten Schlüssel neu erstellt werden - ODER die Offline-Signatur auf dem inneren LeaseSet verwenden, nicht auf dem äußeren EncryptedLeaseSet - Siehe Hinweise zu Proposal 123 notes\nImplementierungshinweise:\nClient-Autorisierung:\nMehrere Clients können mit unterschiedlichen Schlüsseln autorisiert werden Jeder autorisierte Client hat eindeutige Entschlüsselungs-Anmeldedaten Zugriff eines Clients widerrufen, indem die Autorisierungsschlüssel geändert werden Tägliche Schlüsselrotation:\nVerblindete Schlüssel ändern sich um Mitternacht UTC Clients müssen die verblindete Destination (I2P-Adresse) täglich neu berechnen Alte EncryptedLeaseSets werden nach der Rotation nicht mehr auffindbar Datenschutzeigenschaften:\nFloodfills können die ursprüngliche Destination (Ziel-Adresse) nicht bestimmen Nicht autorisierte Clients können nicht auf den Dienst zugreifen Verschiedene blinding periods (Verschleierungszeiträume) können nicht miteinander verknüpft werden Keine Klartext-Metadaten außer den Ablaufzeiten Leistung:\nClients müssen täglich eine Blinding-Berechnung (Verblindung) durchführen Dreischichtige Verschlüsselung erhöht den Rechenaufwand Erwägen Sie, das entschlüsselte innere LeaseSet zwischenzuspeichern Sicherheitsüberlegungen:\nVerwaltung von Autorisierungsschlüsseln:\nBerechtigungsnachweise für Clients sicher verteilen Pro Client eindeutige Berechtigungsnachweise verwenden, um einen feingranularen Widerruf zu ermöglichen Autorisierungsschlüssel regelmäßig rotieren Zeitsynchronisierung:\nTägliches blinding (Verblindung) hängt vom synchronisierten UTC-Tagesdatum ab Uhrabweichungen können zu Abfragefehlern führen Erwägen Sie, das blinding des vorherigen/nächsten Tages zu unterstützen, um Toleranzen auszugleichen Metadaten-Leckage:\nDie Felder Published und expires liegen im Klartext vor Musteranalyse kann Merkmale des Dienstes offenlegen Veröffentlichungsintervalle zufällig variieren, wenn Bedenken bestehen JavaDoc: EncryptedLeaseSet Router-Strukturen RouterAddress Beschreibung: Definiert Verbindungsinformationen für einen router mittels eines bestimmten Transportprotokolls.\nFormat:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary KRITISCH - Ablauf-Feld:\n⚠️ Das Ablauf-Feld MUSS auf lauter Nullen gesetzt werden (8 Null-Bytes).\nGrund: Seit Version 0.9.3 führt eine von Null abweichende Ablaufzeit zu einem Fehler bei der Signaturprüfung Historie: Die Ablaufzeit wurde ursprünglich nicht verwendet, stets null Aktueller Status: Das Feld wird seit 0.9.12 wieder berücksichtigt, muss jedoch auf ein Netzwerk-Upgrade warten Implementierung: Immer auf 0x0000000000000000 setzen Jede von Null verschiedene Ablaufzeit führt dazu, dass die RouterInfo-Signatur bei der Validierung fehlschlägt.\nTransportprotokolle Aktuelle Protokolle (Stand: 2.10.0):\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 **Transportstil-Werte:** - `\"SSU2\"`: Aktueller UDP-basierter Transport - `\"NTCP2\"`: Aktueller TCP-basierter Transport - `\"NTCP\"`: Veraltet, entfernt (nicht verwenden) - `\"SSU\"`: Veraltet, entfernt (nicht verwenden) Allgemeine Optionen Alle Transportprotokolle umfassen typischerweise:\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) SSU2-spezifische Optionen Ausführliche Informationen finden Sie in der SSU2-Spezifikation .\nErforderliche Optionen:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Optionale Optionen:\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) Beispiel SSU2 RouterAddress:\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 NTCP2-spezifische Optionen Ausführliche Details finden Sie in der NTCP2-Spezifikation .\nErforderliche Optionen:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Optionale Einstellungen (seit 0.9.50):\n\u0026#34;caps\u0026#34; = Capability string Beispiel für eine NTCP2 RouterAddress (Router-Adresse):\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 Implementierungshinweise Kostenwerte:\nUDP (SSU2) typischerweise geringere Kosten (5-6) aufgrund der Effizienz TCP (NTCP2) typischerweise höhere Kosten (10-11) aufgrund des Overheads Niedrigere Kosten = bevorzugter Transport Mehrere Adressen:\nRouter können mehrere RouterAddress-Einträge veröffentlichen Verschiedene Transportprotokolle (SSU2 und NTCP2) Verschiedene IP-Versionen (IPv4 und IPv6) Clients wählen anhand von Kosten und Fähigkeiten Hostname gegenüber IP:\nIP-Adressen werden aus Leistungsgründen bevorzugt Hostnamen werden unterstützt, verursachen jedoch zusätzlichen Aufwand durch DNS-Lookups Erwägen Sie die Verwendung von IP für veröffentlichte RouterInfos (Router-Informationen) Base64-Kodierung:\nAlle Schlüssel und Binärdaten in Base64 kodiert Standard-Base64 (RFC 4648) Kein Padding und keine nicht standardkonformen Zeichen JavaDoc: RouterAddress RouterInfo (Router-Informationen) Beschreibung: Vollständige, veröffentlichte Informationen über einen router, die in der Netzwerkdatenbank gespeichert sind. Enthält Identität, Adressen und Fähigkeiten.\nFormat:\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey Datenbankspeicherung: - Datenbanktyp: 0 - Schlüssel: SHA-256-Hash von RouterIdentity - Wert: vollständige RouterInfo-Struktur\nVeröffentlichter Zeitstempel: - 8-Byte-Datum (Millisekunden seit der Unix-Epoche) - Wird für die Versionierung von RouterInfo verwendet - Routers veröffentlichen periodisch eine neue RouterInfo - Floodfills behalten die neueste Version basierend auf dem veröffentlichten Zeitstempel\nAdresssortierung: - Historisch: Sehr alte routers erforderten, dass Adressen nach dem SHA-256 ihrer Daten sortiert wurden - Aktuell: Sortierung NICHT erforderlich, Implementierung zur Kompatibilität lohnt sich nicht - Adressen können in beliebiger Reihenfolge vorliegen\nFeld für Peer-Größe (historisch): - Immer 0 im modernen I2P - War für eingeschränkte Routen vorgesehen (nicht implementiert) - Wenn implementiert, würden in entsprechender Anzahl Router-Hashes folgen - Einige alte Implementierungen könnten eine sortierte Peer-Liste verlangt haben\nZuordnung der Optionen:\nOptionen MÜSSEN nach Schlüssel sortiert sein. Zu den Standardoptionen gehören:\nFähigkeitsoptionen:\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable Netzwerkoptionen:\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; Statistische Optionen:\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string Siehe Dokumentation zu RouterInfo der Netzwerkdatenbank für die vollständige Liste der Standardoptionen.\nSignaturberechnung:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length Typische moderne RouterInfo (Router-Informationen):\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical Implementierungshinweise:\nMehrere Adressen:\nRouter veröffentlichen in der Regel 1-4 Adressen IPv4- und IPv6-Varianten SSU2- und/oder NTCP2-Transporte Jede Adresse ist unabhängig Versionierung:\nEine neuere RouterInfo hat einen späteren published-Zeitstempel Routers veröffentlichen etwa alle ~2 Stunden erneut oder wenn sich Adressen ändern Floodfills (spezielle router, die netDb-Daten speichern und verteilen) speichern und verbreiten nur die neueste Version Validierung:\nSignatur prüfen, bevor RouterInfo (I2P-Router-Informationsdatensatz) akzeptiert wird Prüfen, dass das Ablaufzeit-Feld in jeder RouterAddress (I2P-Routeradresse) nur aus Nullen besteht Validieren, dass die Optionszuordnung nach Schlüssel sortiert ist Prüfen, dass Zertifikat- und Schlüsseltypen bekannt und unterstützt sind Netzwerkdatenbank:\nFloodfills speichern RouterInfo, indiziert durch Hash(RouterIdentity) Für ~2 Tage nach der letzten Veröffentlichung vorgehalten Routers fragen floodfills ab, um andere routers zu entdecken JavaDoc: RouterInfo Hinweise zur Implementierung Byte-Reihenfolge (Endianness) Standard: Big-Endian (Netzwerk-Byte-Reihenfolge)\nDie meisten I2P-Strukturen verwenden die Big-Endian-Byte-Reihenfolge: - Alle Integer-Typen (1-8 Bytes) - Zeitstempel (Datum) - TunnelId - String-Längenpräfix - Zertifikatstypen und -längen - Schlüsseltyp-Codes - Felder für Mapping-Größen\nAusnahme: Little-Endian (Byte-Reihenfolge mit kleinstwertigem Byte zuerst)\nDie folgenden Schlüsseltypen verwenden die Little-Endian-Kodierung: - X25519 Verschlüsselungsschlüssel (Typ 4) - EdDSA_SHA512_Ed25519 Signaturschlüssel (Typ 7) - EdDSA_SHA512_Ed25519ph Signaturschlüssel (Typ 8) - RedDSA_SHA512_Ed25519 Signaturschlüssel (Typ 11)\nImplementierung:\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); Versionierung von Strukturen Niemals feste Größen voraussetzen:\nViele Strukturen haben variable Länge: - RouterIdentity (Router-Identität): 387+ Bytes (nicht immer 387) - Destination (Zieladresse): 387+ Bytes (nicht immer 387) - LeaseSet2 (LeaseSet der zweiten Generation): Variiert erheblich - Zertifikat: 3+ Bytes\nImmer Längenfelder lesen: - Zertifikatslänge in den Bytes 1-2 - Größe des Mappings am Anfang - KeysAndCert berechnet sich immer als 384 + 3 + certificate_length\nAuf überschüssige Daten prüfen: - Nach gültigen Strukturen nachgestellten Datenmüll verbieten - Validieren, dass die Zertifikatlängen den Schlüsseltypen entsprechen - Exakte erwartete Längen für Typen fester Größe erzwingen\nAktuelle Empfehlungen (Oktober 2025) Für neue Router-Identitäten:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/de/proposals/161-ri-dest-padding/) Für neue Ziele:\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/de/proposals/161-ri-dest-padding/) Für neue LeaseSets:\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per [Proposal 167](/proposals/167-service-records/) Signature: EdDSA (64 bytes) Für verschlüsselte Dienste:\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys Veraltete Funktionen - Nicht verwenden Veraltete Verschlüsselung: - ElGamal (Typ 0) für Router-Identitäten (seit 0.9.58 veraltet) - ElGamal/AES+SessionTag-Verschlüsselung (verwenden Sie ECIES-X25519)\nVeraltete Signaturverfahren: - DSA_SHA1 (Typ 0) für Router-Identitäten (seit 0.9.58 veraltet) - ECDSA-Varianten (Typen 1-3) für neue Implementierungen - RSA-Varianten (Typen 4-6) außer für SU3-Dateien\nVeraltete Netzwerkformate: - LeaseSet Typ 1 (verwenden Sie LeaseSet2) - Lease (44 Bytes, verwenden Sie Lease2) - Ursprüngliches Lease-Ablaufformat\nVeraltete Transporte: - NTCP (in 0.9.50 entfernt) - SSU (in 2.4.0 entfernt)\nVeraltete Zertifikate: - HASHCASH (Typ 1) - HIDDEN (Typ 2) - SIGNED (Typ 3) - MULTIPLE (Typ 4)\nSicherheitsaspekte Schlüsselgenerierung: - Verwenden Sie stets kryptografisch sichere Zufallszahlengeneratoren - Verwenden Sie Schlüssel niemals wieder in unterschiedlichen Kontexten - Schützen Sie private Schlüssel mit geeigneten Zugriffskontrollen - Löschen Sie Schlüsselmaterial nach Gebrauch sicher aus dem Speicher\nSignaturprüfung: - Signaturen immer prüfen, bevor Sie Daten vertrauen - Prüfen, dass die Signaturlänge dem Schlüsseltyp entspricht - Prüfen, dass die signierten Daten die erwarteten Felder enthalten - Bei sortierten Zuordnungen die Sortierreihenfolge vor dem Signieren/Verifizieren prüfen\nZeitstempelvalidierung: - Überprüfen, dass veröffentlichte Zeiten plausibel sind (nicht weit in der Zukunft) - Validieren, dass Lease-Ablaufzeiten nicht abgelaufen sind - Toleranz für Uhrenabweichung berücksichtigen (typisch ±30 Sekunden)\nNetzwerkdatenbank: - Alle Strukturen vor dem Speichern validieren - Größenbeschränkungen durchsetzen, um DoS zu verhindern - Anfragen und Veröffentlichungen ratenbegrenzen - Überprüfen, dass die Datenbankschlüssel mit den Struktur-Hashes übereinstimmen\nKompatibilitätshinweise Abwärtskompatibilität: - ElGamal und DSA_SHA1 werden weiterhin für ältere routers unterstützt - Veraltete Schlüsseltypen bleiben funktionsfähig, werden jedoch nicht empfohlen - Komprimierbares Padding (Proposal 161 ) abwärtskompatibel bis Version 0.6\nVorwärtskompatibilität: - Unbekannte Schlüsseltypen können anhand von Längenfeldern geparst werden - Unbekannte Zertifikatstypen können anhand der Länge übersprungen werden - Unbekannte Signaturtypen sollten fehlertolerant behandelt werden - Implementierungen sollten bei unbekannten optionalen Funktionen nicht fehlschlagen\nMigrationsstrategien: - Während der Übergangsphase sowohl alte als auch neue Schlüsseltypen unterstützen - LeaseSet2 kann mehrere Verschlüsselungsschlüssel auflisten - Offline-Signaturen ermöglichen eine sichere Schlüsselrotation - MetaLeaseSet ermöglicht eine transparente Dienstmigration\nTests und Validierung Strukturvalidierung: - Überprüfen, ob alle Längenfelder innerhalb der erwarteten Bereiche liegen - Prüfen, dass Strukturen variabler Länge korrekt geparst werden - Validieren, dass Signaturen erfolgreich verifiziert werden - Mit Strukturen in Minimal- und Maximalgröße testen\nRandfälle: - Zeichenketten der Länge Null - Leere Zuordnungen - Minimale und maximale Lease-Anzahlen (Lease: zeitlich begrenzter Eintrag in einem leaseSet) - Zertifikat mit Nutzlast der Länge Null - Sehr große Strukturen (nahe den maximalen Größen)\nInteroperabilität: - Gegen die offizielle Java I2P-Implementierung testen - Kompatibilität mit i2pd prüfen - Mit verschiedenen netDb-Inhalten testen - Anhand bekannter gültiger Testvektoren validieren\nReferenzen Spezifikationen I2NP-Protokoll I2CP-Protokoll SSU2-Transport NTCP2-Transport Tunnel-Protokoll Datagramm-Protokoll Kryptographie Kryptografie-Überblick ElGamal/AES-Verschlüsselung ECIES-X25519-Verschlüsselung ECIES für Router ECIES-Hybrid (Post-Quanten) Red25519-Signaturen Verschlüsseltes LeaseSet Vorschläge Vorschlag 123: Neue netDB-Einträge Vorschlag 134: GOST-Signaturtypen Vorschlag 136: Experimentelle Signaturtypen Vorschlag 145: ECIES-P256 Vorschlag 156: ECIES Routers Vorschlag 161: Padding-Generierung Vorschlag 167: Service-Einträge Vorschlag 169: Post-Quanten-Kryptografie Index aller Vorschläge Netzwerkdatenbank Übersicht über die Network Database (Netzwerkdatenbank) Standardoptionen für RouterInfo JavaDoc-API-Referenz Kern-Daten-Paket PublicKey PrivateKey SessionKey SigningPublicKey SigningPrivateKey Signature Hash SessionTag TunnelId Certificate DataHelper KeysAndCert RouterIdentity Destination Lease LeaseSet Lease2 LeaseSet2 MetaLease MetaLeaseSet EncryptedLeaseSet RouterAddress RouterInfo Externe Standards RFC 7748 (X25519): Elliptische Kurven für Sicherheitszwecke RFC 7539 (ChaCha20): ChaCha20 und Poly1305 für IETF-Protokolle RFC 4648 (Base64): Die Datenkodierungen Base16, Base32 und Base64 FIPS 180-4 (SHA-256): Sicherer Hash-Standard FIPS 204 (ML-DSA): Modul-Gitter-basierter Standard für digitale Signaturen IANA-Diensteregister Community-Ressourcen I2P-Website I2P-Forum I2P-GitLab I2P-GitHub-Spiegel Index der technischen Dokumentation Release-Informationen I2P 2.10.0 Veröffentlichung Versionsgeschichte Änderungsprotokoll Anhang: Schnellreferenztabellen Kurzreferenz zu Schlüsseltypen Aktueller Standard (empfohlen für alle neuen Implementierungen): - Verschlüsselung: X25519 (Typ 4, 32 Bytes, Little-Endian (Byte-Reihenfolge mit niederwertigem Byte zuerst)) - Signierung: EdDSA_SHA512_Ed25519 (Typ 7, 32 Bytes, Little-Endian)\nLegacy (unterstützt, aber veraltet): - Verschlüsselung: ElGamal (Typ 0, 256 Byte, Big-Endian) - Signatur: DSA_SHA1 (Typ 0, 20-Byte privat / 128-Byte öffentlich, Big-Endian)\nSpezialisiert: - Signierung (Verschlüsselte LeaseSet): RedDSA_SHA512_Ed25519 (Typ 11, 32 Byte, little-endian)\nPost-Quanten (Beta, noch nicht final): - Hybride Verschlüsselung: MLKEM_X25519-Varianten (Typen 5-7) - Reine Post-Quanten-Verschlüsselung: MLKEM-Varianten (noch keine zugewiesenen Typcodes)\nKurzreferenz zu Strukturgrößen Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes ### Kurzreferenz zu Datenbanktypen Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status ### Kurzreferenz zum Transportprotokoll Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 ### Schnellreferenz zu Versionsmeilensteinen Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023[Proposal 161](/de/proposals/161-ri-dest-padding/) padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025[Proposal 167](/proposals/167-service-records/) service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) --- ","description":"Gemeinsame Datentypen und Serialisierungsformate, die in I2P-Spezifikationen verwendet werden","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"Gemeinsame Strukturen","url":"/de/docs/specs/common-structures/"},{"categories":null,"content":"Überblick HINWEIS: VERALTET - Wir unterstützen jetzt drei Formate, in der bevorzugten Reihenfolge:\nMaxmind geoip2 (GeoLite2-Country.mmdb) wird mit allen Installationen gebündelt, außer bei Debian-Paketen und Android Maxmind geoip1 (GeoIP.dat) im Debian-Paket geoip-database Das IPv4-Tor-Format (geoip.txt) und das benutzerdefinierte IPv6-Format (geoipv6.dat.gz), unten dokumentiert, werden weiterhin unterstützt, aber nicht verwendet. Diese Seite legt das Format der verschiedenen GeoIP-Dateien fest, die vom router verwendet werden, um für eine IP-Adresse das Land nachzuschlagen.\nFormat des Ländernamens (countries.txt) Dieses Format lässt sich leicht aus Datendateien generieren, die bei vielen öffentlichen Quellen erhältlich sind. Zum Beispiel:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Formatspezifikationen:\nDie Zeichenkodierung ist UTF-8 \u0026lsquo;#\u0026rsquo; in Spalte 1 kennzeichnet eine Kommentarzeile Eintragszeilen sind CountryCode,CountryName CountryCode ist der ISO-Zweibuchstabencode, in Großbuchstaben CountryName ist auf Englisch IPv4 (geoip.txt) Format Dieses Format wurde von Tor übernommen und kann leicht aus Datendateien generiert werden, die von vielen öffentlichen Quellen verfügbar sind. Zum Beispiel:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Formatspezifikationen:\nDie Kodierung ist ASCII \u0026lsquo;#\u0026rsquo; in Spalte 1 kennzeichnet eine Kommentarzeile Eintragszeilen haben das Format FromIP,ToIP,CountryCode FromIP und ToIP sind vorzeichenlose Ganzzahl-Darstellungen der 4-Byte-IP-Adresse CountryCode ist der zweibuchstabige ISO-Code, in Großbuchstaben Eintragszeilen müssen nach dem numerischen FromIP sortiert sein IPv6 (geoipv6.dat.gz) Format Dies ist ein komprimiertes Binärformat, das für I2P entwickelt wurde. Die Datei ist gzip-komprimiert. Dekomprimiertes Format:\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) HINWEISE:\nDie Daten müssen sortiert sein (SIGNIERTER long-Wert im Zweierkomplement), keine Überschneidungen. Die Reihenfolge ist also 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF. Die Klasse GeoIPv6.java enthält ein Programm, um dieses Format aus öffentlichen Quellen wie den Maxmind-GeoLite-Daten zu generieren. Die IPv6-GeoIP-Abfrage wird seit Version 0.9.8 unterstützt. ","description":"Spezifikationen des veralteten GeoIP-Dateiformats für IP-zu-Land-Abfragen","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"GeoIP-Dateiformate","url":"/de/docs/legacy/geoip-dateiformate/"},{"categories":null,"content":"Wenn Netzwerkbedingungen git clone unzuverlässig machen, können Sie Repositories als Git-Bundles über BitTorrent oder einen anderen Dateitransport verteilen. Ein Bundle ist eine einzelne Datei, die die gesamte Repository-Historie enthält. Nach dem Download führen Sie lokal einen Fetch daraus durch und wechseln dann zurück zum Upstream-Remote.\n1. Bevor Sie beginnen Das Erstellen eines Bundles erfordert einen vollständigen Git-Clone. Flache Clones, die mit --depth 1 erstellt wurden, erzeugen stillschweigend fehlerhafte Bundles, die scheinbar funktionieren, aber fehlschlagen, wenn andere versuchen, sie zu verwenden. Laden Sie immer von einer vertrauenswürdigen Quelle herunter (GitHub unter github.com/i2p/i2p.i2p , der I2P-Gitea-Instanz unter i2pgit.org oder git.idk.i2p über I2P) und führen Sie bei Bedarf git fetch --unshallow aus, um jeden flachen Clone in einen vollständigen Clone umzuwandeln, bevor Sie Bundles erstellen.\nWenn Sie nur ein vorhandenes Bundle verwenden, laden Sie es einfach herunter. Keine besondere Vorbereitung erforderlich.\n2. Herunterladen eines Bundles Obtaining the Bundle File Laden Sie die Bundle-Datei über BitTorrent mit I2PSnark (dem integrierten Torrent-Client in I2P) oder anderen I2P-kompatiblen Clients wie BiglyBT mit dem I2P-Plugin herunter.\nWichtig: I2PSnark funktioniert nur mit Torrents, die speziell für das I2P-Netzwerk erstellt wurden. Standard-Clearnet-Torrents sind nicht kompatibel, da I2P Destinations (387+ Byte Adressen) anstelle von IP-Adressen und Ports verwendet.\nDer Speicherort der Bundle-Datei hängt von Ihrem I2P-Installationstyp ab:\nBenutzer-/manuelle Installationen (installiert mit Java-Installer): ~/.i2p/i2psnark/ System-/Daemon-Installationen (installiert via apt-get oder Paketmanager): /var/lib/i2p/i2p-config/i2psnark/ BiglyBT-Benutzer finden heruntergeladene Dateien in ihrem konfigurierten Download-Verzeichnis.\nCloning from the Bundle Standardmethode (funktioniert in den meisten Fällen):\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle Wenn Sie auf fatal: multiple updates for ref Fehler stoßen (ein bekanntes Problem in Git 2.21.0 und später, wenn die globale Git-Konfiguration widersprüchliche Fetch-Refspecs enthält), verwenden Sie die manuelle Initialisierungsmethode:\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle Alternativ können Sie das Flag --update-head-ok verwenden:\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; Beschaffung der Bundle-Datei Nachdem Sie vom Bundle geklont haben, richten Sie Ihren Klon auf das Live-Remote aus, damit zukünftige Fetches über I2P oder Clearnet erfolgen:\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p Oder für Clearnet-Zugriff:\ngit remote set-url origin https://github.com/i2p/i2p.i2p Für I2P-SSH-Zugriff benötigen Sie einen SSH-Client-Tunnel, der in Ihrer I2P-Router-Konsole konfiguriert ist (typischerweise Port 7670) und auf g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p zeigt. Bei Verwendung eines nicht standardmäßigen Ports:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle Klonen aus dem Bundle Stellen Sie sicher, dass Ihr Repository mit einem vollständigen Klon (nicht shallow) auf dem neuesten Stand ist:\ngit fetch --all Wenn Sie einen Shallow Clone haben, konvertieren Sie ihn zuerst:\ngit fetch --unshallow Wechsel zur Live-Remote Verwendung des Ant-Build-Ziels (empfohlen für den I2P-Quellbaum):\nant git-bundle Dies erzeugt sowohl i2p.i2p.bundle (die Bundle-Datei) als auch i2p.i2p.bundle.torrent (BitTorrent-Metadaten).\nGit Bundle direkt verwenden:\ngit bundle create i2p.i2p.bundle --all Für selektivere Bundles:\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle Überprüfen Sie das Bundle immer vor der Verteilung:\ngit bundle verify i2p.i2p.bundle Dies bestätigt, dass das Bundle gültig ist und zeigt alle erforderlichen vorausgesetzten Commits an.\nVoraussetzungen Kopiere das Bundle und seine Torrent-Metadaten in dein I2PSnark-Verzeichnis:\nFür Benutzerinstallationen:\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ Für Systeminstallationen:\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ I2PSnark erkennt und lädt .torrent-Dateien automatisch innerhalb von Sekunden. Greifen Sie auf die Weboberfläche unter http://127.0.0.1:7657/i2psnark zu, um mit dem Seeden zu beginnen.\n4. Creating Incremental Bundles Für periodische Updates erstellen Sie inkrementelle Bundles, die nur neue Commits seit dem letzten Bundle enthalten:\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master Benutzer können aus dem inkrementellen Bundle abrufen, wenn sie bereits das Basis-Repository haben:\ngit fetch /path/to/update.bundle Überprüfen Sie immer, dass inkrementelle Bundles die erwarteten vorausgesetzten Commits anzeigen:\ngit bundle verify update.bundle 5. Updating After the Initial Clone Sobald Sie ein funktionierendes Repository aus dem Bundle haben, behandeln Sie es wie jeden anderen Git-Clone:\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master Oder für einfachere Arbeitsabläufe:\ngit fetch origin git pull origin master 3. Ein Bundle erstellen Resiliente Verteilung: Große Repositories können über BitTorrent geteilt werden, das automatisch Wiederholungsversuche, Verifizierung einzelner Teile und Fortsetzung unterbrechter Downloads übernimmt. Peer-to-peer Bootstrap: Neue Mitwirkende können ihren Clone von nahegelegenen Peers im I2P-Netzwerk bootstrappen und anschließend inkrementelle Änderungen direkt von Git-Hosts abrufen. Reduzierte Serverlast: Mirrors können regelmäßige Bundles veröffentlichen, um die Last auf aktiven Git-Hosts zu verringern – besonders nützlich bei großen Repositories oder langsamen Netzwerkbedingungen. Offline-Transport: Bundles funktionieren über jeden Dateitransport (USB-Laufwerke, direkte Übertragungen, Sneakernet), nicht nur über BitTorrent. Bundles ersetzen keine Live-Remotes. Sie bieten lediglich eine robustere Bootstrapping-Methode für initiale Klone oder größere Updates.\n7. Troubleshooting Generieren des Bundles Problem: Bundle-Erstellung erfolgreich, aber andere können nicht vom Bundle klonen.\nUrsache: Ihr Quellklon ist flach (erstellt mit --depth).\nLösung: Vor dem Erstellen von Bundles in einen vollständigen Klon konvertieren:\ngit fetch --unshallow Verifizierung Ihres Bundles Problem: fatal: multiple updates for ref beim Klonen aus einem Bundle.\nUrsache: Git 2.21.0+ steht in Konflikt mit globalen Fetch-Refspecs in ~/.gitconfig.\nLösungen: 1. Manuelle Initialisierung verwenden: mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle 2. Das Flag --update-head-ok verwenden: git fetch --update-head-ok /path/to/bundle '*:*' 3. Konfliktverursachende Konfiguration entfernen: git config --global --unset remote.origin.fetch\nVerteilung über I2PSnark Problem: git bundle verify meldet fehlende Voraussetzungen.\nUrsache: Inkrementelles Bundle oder unvollständiger Quellcode-Klon.\nLösung: Entweder die erforderlichen Commits abrufen oder zuerst das Basis-Bundle verwenden und dann inkrementelle Updates anwenden.\n","description":"Abrufen und Verteilen großer Repositories mit git bundle und BitTorrent","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"Git Bundles für I2P","url":"/de/docs/applications/git-bundle/"},{"categories":null,"content":"Das Klonen und Pushen von Repositories innerhalb von I2P verwendet dieselben Git-Befehle, die Sie bereits kennen – Ihr Client verbindet sich einfach über I2P-Tunnel anstatt über TCP/IP. Diese Anleitung führt Sie durch die Einrichtung eines Kontos, die Konfiguration von Tunnels und den Umgang mit langsamen Verbindungen.\nSchnellstart: Schreibgeschützter Zugriff funktioniert über den HTTP-Proxy: http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git. Folgen Sie den Schritten unten für SSH-Lese-/Schreibzugriff.\n1. Konto erstellen Wähle einen I2P-Git-Dienst aus und registriere dich:\nInnerhalb von I2P: http://git.idk.i2p Clearnet-Spiegel: https://i2pgit.org Die Registrierung erfordert möglicherweise eine manuelle Genehmigung; prüfen Sie die Landing-Page für Anweisungen. Nach der Genehmigung forken oder erstellen Sie ein Repository, damit Sie etwas zum Testen haben.\n2. Konfigurieren Sie einen I2PTunnel-Client (SSH) Öffnen Sie die Router-Konsole → I2PTunnel und fügen Sie einen neuen Client tunnel hinzu. Geben Sie das Ziel (destination) des Dienstes ein (Base32 oder Base64). Für git.idk.i2p finden Sie sowohl HTTP- als auch SSH-Ziele auf der Projekt-Startseite. Wählen Sie einen lokalen Port (zum Beispiel localhost:7442). Aktivieren Sie Autostart, wenn Sie den tunnel häufig nutzen möchten. Die Benutzeroberfläche wird den neuen Tunnel bestätigen und seinen Status anzeigen. Wenn er läuft, können SSH-Clients sich mit 127.0.0.1 auf dem gewählten Port verbinden.\n3. Über SSH klonen Verwenden Sie den Tunnel-Port mit GIT_SSH_COMMAND oder einem SSH-Konfigurationseintrag:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git Wenn der erste Versuch fehlschlägt (Tunnel können langsam sein), versuchen Sie einen flachen Klon:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow Konfiguriere Git, um alle Branches abzurufen:\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin Leistungstipps Fügen Sie im Tunnel-Editor einen oder zwei Backup-Tunnel hinzu, um die Ausfallsicherheit zu verbessern. Für Tests oder Repositories mit geringem Risiko können Sie die Tunnel-Länge auf 1 Hop reduzieren, beachten Sie jedoch den Kompromiss bei der Anonymität. Behalten Sie GIT_SSH_COMMAND in Ihrer Umgebung bei oder fügen Sie einen Eintrag zu ~/.ssh/config hinzu: Host git.i2p HostName 127.0.0.1 Port 7442 User git Dann klonen Sie mit git clone git@git.i2p:namespace/project.git.\n4. Workflow-Vorschläge Verwenden Sie einen Fork-and-Branch-Workflow, wie er auf GitLab/GitHub üblich ist:\nSetzen Sie ein Upstream-Remote: git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p Halten Sie Ihren master synchron: git pull upstream master Erstellen Sie Feature-Branches für Änderungen: git checkout -b feature/new-thing Pushen Sie Branches zu Ihrem Fork: git push origin feature/new-thing Reichen Sie einen Merge-Request ein und aktualisieren Sie dann den Master Ihres Forks per Fast-Forward vom Upstream. 5. Datenschutz-Hinweise Git speichert Commit-Zeitstempel in deiner lokalen Zeitzone. Um UTC-Zeitstempel zu erzwingen: git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; Verwenden Sie git utccommit anstelle von git commit, wenn Datenschutz wichtig ist.\nVermeiden Sie das Einbetten von Clearnet-URLs oder IPs in Commit-Nachrichten oder Repository-Metadaten, wenn Anonymität ein Anliegen ist. 6. Fehlerbehebung Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. Für fortgeschrittene Szenarien (Spiegeln externer Repositories, Seeding von Bundles) siehe die ergänzenden Anleitungen: [Git-Bundle-Workflows](/docs/applications/git-bundle/) und [GitLab über I2P hosten](/docs/guides/gitlab/). ","description":"Git-Clients mit I2P-gehosteten Diensten wie i2pgit.org verbinden","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"Git über I2P","url":"/de/docs/applications/git/"},{"categories":null,"content":"Das Hosting von GitLab innerhalb von I2P ist unkompliziert: Führen Sie den GitLab-Omnibus-Container aus, exponieren Sie ihn auf Loopback und leiten Sie den Datenverkehr durch einen I2P-Tunnel weiter. Die folgenden Schritte entsprechen der Konfiguration, die für git.idk.i2p verwendet wird, funktionieren aber für jede selbst gehostete Instanz.\n1. Voraussetzungen Debian oder eine andere Linux-Distribution mit installiertem Docker Engine (sudo apt install docker.io oder docker-ce aus Dockers Repository). Ein I2P-router (Java I2P oder i2pd) mit ausreichend Bandbreite, um deine Benutzer zu bedienen. Optional: eine dedizierte VM, damit GitLab und der router von deiner Desktop-Umgebung isoliert bleiben. 2. GitLab-Image herunterladen docker pull gitlab/gitlab-ce:latest Das offizielle Image wird auf Basis von Ubuntu-Layern erstellt und regelmäßig aktualisiert. Prüfen Sie das Dockerfile , falls Sie zusätzliche Sicherheit benötigen.\n3. Entscheidung zwischen Bridging und I2P-Only Nur-I2P-Instanzen kontaktieren niemals Clearnet-Hosts. Benutzer können Repositories von anderen I2P-Diensten spiegeln, aber nicht von GitHub/GitLab.com. Dies maximiert die Anonymität. Überbrückte Instanzen greifen über einen HTTP-Proxy auf Clearnet-Git-Hosts zu. Dies ist nützlich, um öffentliche Projekte in I2P zu spiegeln, deanonymisiert jedoch die ausgehenden Anfragen des Servers. Wenn Sie den Bridged-Modus wählen, konfigurieren Sie GitLab so, dass es einen I2P-HTTP-Proxy verwendet, der auf dem Docker-Host gebunden ist (zum Beispiel http://172.17.0.1:4446). Der Standard-Router-Proxy lauscht nur auf 127.0.0.1; fügen Sie einen neuen Proxy-Tunnel hinzu, der an die Docker-Gateway-Adresse gebunden ist.\n4. Starten Sie den Container docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest Binde die veröffentlichten Ports an Loopback; die I2P-Tunnel werden sie bei Bedarf verfügbar machen. Ersetze /srv/gitlab/... durch Speicherpfade, die zu deinem Host passen. Sobald der Container läuft, besuchen Sie https://127.0.0.1:8443/, legen Sie ein Administrator-Passwort fest und konfigurieren Sie die Kontoeinschränkungen.\n5. GitLab über I2P verfügbar machen Erstellen Sie drei I2PTunnel Server-Tunnel:\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated Konfigurieren Sie jeden Tunnel mit angemessenen Tunnellängen und Bandbreite. Für öffentliche Instanzen sind 3 Hops mit 4–6 Tunneln pro Richtung ein guter Ausgangspunkt. Veröffentlichen Sie die resultierenden Base32/Base64-Ziele auf Ihrer Startseite, damit Benutzer Client-Tunnel konfigurieren können. Destination Enforcement Wenn Sie HTTP(S)-Tunnel verwenden, aktivieren Sie die Zielerzwingung, damit nur der vorgesehene Hostname den Dienst erreichen kann. Dies verhindert, dass der Tunnel als generischer Proxy missbraucht wird.\n6. Maintenance Tips Führen Sie docker exec gitlab gitlab-ctl reconfigure aus, wenn Sie GitLab-Einstellungen ändern. Überwachen Sie die Festplattennutzung (/srv/gitlab/data) – Git-Repositories wachsen schnell. Sichern Sie Konfigurations- und Datenverzeichnisse regelmäßig. GitLabs Backup-Rake-Tasks funktionieren innerhalb des Containers. Erwägen Sie, einen externen Monitoring-tunnel im Client-Modus einzurichten, um sicherzustellen, dass der Dienst vom breiteren Netzwerk aus erreichbar ist. 6. Wartungstipps I2P in Ihre Anwendung einbetten Git über I2P (Client-Anleitung) Git-Bundles für Offline-/langsame Netzwerke Eine gut konfigurierte GitLab-Instanz bietet einen kollaborativen Entwicklungs-Hub vollständig innerhalb von I2P. Halten Sie den Router gesund, bleiben Sie mit GitLab-Sicherheitsupdates auf dem neuesten Stand und koordinieren Sie sich mit der Community, wenn Ihre Nutzerbasis wächst.\n","description":"GitLab innerhalb von I2P mit Docker und einem I2P-Router bereitstellen","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"GitLab über I2P betreiben","url":"/de/docs/guides/gitlab/"},{"categories":null,"content":"Dieses Glossar definiert gebräuchliche Begriffe, die in der I2P-Dokumentation und in Diskussionen verwendet werden.\nB Blockchain Ein verteiltes Hauptbuch, das Transaktionen zwischen mehreren Parteien effizient sowie auf überprüfbare und dauerhafte Weise aufzeichnen kann.\nD Dezentralisierung Netzwerkarchitektur, die die Abhängigkeit von einer einzelnen Partei vermeidet. Umfasst Peer-to-Peer-, Blockchain-, föderierte und verteilte Technologien.\nDestination Die kryptografische Identität eines Tunnels. Dies sind die Identitäten von Clients und Servern innerhalb des I2P-Netzwerks.\nDHT (Distributed Hash Table) Wird in einigen Projekten verwendet, um Peers miteinander zu verbinden, indem Informationen in Form von Schlüssel-Wert-Paaren dezentral gespeichert werden.\nDistributed Systems Akademisches Thema innerhalb der Informatik, das sich mit dem Design von Computersystemen befasst, die aus vielen einzelnen Computern bestehen, die über ein Netzwerk verbunden sind.\nF Federated Föderation ermöglicht es getrennten Bereitstellungen eines Dienstes, über ein gemeinsames Protokoll miteinander zu kommunizieren.\nH Hash Eine Zahl, die üblicherweise als Zeichenfolge aus Buchstaben und Zahlen dargestellt wird. Sie kann als „Fingerabdruck\u0026quot; dienen, der Daten eindeutig identifiziert.\nI I2P Invisible Internet Project: ein Projekt, das eine Anonymitätsschicht bereitstellen soll, damit Benutzer anonym unter Verwendung einer Reihe von Anwendungen kommunizieren können.\nIP-Adresse Eine Nummer eines Computers oder Netzwerks, die eindeutig ist und somit zur Adressierung verwendet werden kann.\nL LeaseSet Eine Sammlung von Informationen, die erforderlich sind, um mit einem Client oder Server an einer bestimmten Destination zu kommunizieren.\nP Peer-to-Peer (P2P) Peers stellen einen Teil ihrer Ressourcen direkt anderen Netzwerkteilnehmern zur Verfügung, ohne dass eine zentrale Koordinierung durch Server oder stabile Hosts erforderlich ist.\nR Router Die zentrale I2P-Software, die verschlüsselte Pakete im I2P-Netzwerk weiterleitet.\nRouterIdentity Eine Sammlung von Informationen, die für die direkte Kommunikation mit einem Router erforderlich sind.\nT TCP/UDP Die beiden grundlegenden Transportprotokolle, die im Internet verwendet werden.\nTunnel Ein anonymer Kommunikationspfad zwischen einem Client oder Server und dem I2P-Netzwerk.\nU UX User Experience (Benutzererfahrung), die Gesamterfahrung einer Person bei der Nutzung eines Produkts oder einer Dienstleistung.\nW WebRTC Ein Protokollstandard zum Aufbau von Verbindungen in einem Webbrowser, bei dem Daten direkt zwischen Benutzern übertragen werden.\n","description":"Gängige Begriffe und Definitionen in der I2P-Dokumentation","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"Glossar","url":"/de/docs/overview/glossar/"},{"categories":null,"content":"I2P Router Hilfe Auf welchen Systemen läuft I2P? I2P ist in der Programmiersprache Java geschrieben. Es wurde auf Windows, Linux, FreeBSD und OSX getestet. Eine Android-Portierung ist ebenfalls verfügbar.\nIn Bezug auf die Speichernutzung ist I2P standardmäßig so konfiguriert, dass es 128 MB RAM verwendet. Dies ist ausreichend für das Surfen und die Nutzung von IRC. Andere Aktivitäten können jedoch eine höhere Speicherzuweisung erfordern. Wenn man beispielsweise einen Router mit hoher Bandbreite betreiben, an I2P-Torrents teilnehmen oder Hidden Services mit hohem Datenverkehr bereitstellen möchte, ist eine größere Speichermenge erforderlich.\nWas die CPU-Nutzung betrifft, wurde I2P erfolgreich auf bescheidenen Systemen wie der Raspberry Pi-Reihe von Einplatinencomputern getestet. Da I2P intensiv kryptografische Verfahren nutzt, ist eine leistungsstärkere CPU besser geeignet, um die von I2P erzeugte Arbeitslast sowie Aufgaben des restlichen Systems (d.h. Betriebssystem, GUI, andere Prozesse wie z.B. Webbrowsing) zu bewältigen.\nDie Verwendung von Sun/Oracle Java oder OpenJDK wird empfohlen.\nIst die Installation von Java erforderlich, um I2P zu verwenden? Ja, Java ist erforderlich, um I2P Core zu verwenden. Wir haben Java in unseren Easy-Installern für Windows, Mac OSX und Linux enthalten. Wenn Sie die I2P-Android-App ausführen, benötigen Sie in den meisten Fällen auch eine Java-Laufzeitumgebung wie Dalvik oder ART.\nWas ist eine \u0026ldquo;I2P Site\u0026rdquo; und wie konfiguriere ich meinen Browser, damit ich sie nutzen kann? Eine I2P-Site ist eine normale Website, mit dem Unterschied, dass sie innerhalb von I2P gehostet wird. I2P-Sites haben Adressen, die wie normale Internetadressen aussehen und auf \u0026ldquo;.i2p\u0026rdquo; enden – in einer für Menschen lesbaren, nicht-kryptografischen Form, zum Nutzen der Benutzer. Die tatsächliche Verbindung zu einer I2P-Site erfordert Kryptografie, was bedeutet, dass I2P-Site-Adressen auch als lange \u0026ldquo;Base64\u0026rdquo;-Destinations und kürzere \u0026ldquo;B32\u0026rdquo;-Adressen existieren. Möglicherweise müssen Sie zusätzliche Konfigurationen vornehmen, um korrekt zu browsen. Zum Browsen von I2P-Sites müssen Sie den HTTP-Proxy in Ihrer I2P-Installation aktivieren und dann Ihren Browser so konfigurieren, dass er diesen verwendet. Für weitere Informationen konsultieren Sie den Abschnitt \u0026ldquo;Browser\u0026rdquo; weiter unten oder die Anleitung zur \u0026ldquo;Browser-Konfiguration\u0026rdquo;.\nWas bedeuten die Aktiv x/y Zahlen in der Router-Konsole? Auf der Peers-Seite in Ihrer Router-Konsole sehen Sie möglicherweise zwei Zahlen - Aktiv x/y. Die erste Zahl ist die Anzahl der Peers, an die Sie in den letzten Minuten eine Nachricht gesendet oder von denen Sie eine Nachricht empfangen haben. Die zweite Zahl ist die Anzahl der kürzlich gesehenen Peers, diese wird immer größer oder gleich der ersten Zahl sein.\nMein Router hat sehr wenige aktive Peers, ist das in Ordnung? Ja, dies kann normal sein, besonders wenn der Router gerade erst gestartet wurde. Neue Router benötigen Zeit zum Hochfahren und zum Verbinden mit dem Rest des Netzwerks. Um die Netzwerkintegration, Betriebszeit und Leistung zu verbessern, überprüfen Sie diese Einstellungen:\nBandbreite teilen - Wenn ein Router so konfiguriert ist, dass er Bandbreite teilt, wird er mehr Datenverkehr für andere Router weiterleiten, was dabei hilft, ihn in den Rest des Netzwerks zu integrieren und die Leistung der eigenen lokalen Verbindung verbessert. Dies kann auf der Seite http://localhost:7657/config konfiguriert werden. Netzwerkschnittstelle - Stellen Sie sicher, dass auf der Seite http://localhost:7657/confignet keine Schnittstelle angegeben ist. Dies kann die Leistung beeinträchtigen, es sei denn, Ihr Computer ist multi-homed mit mehreren externen IP-Adressen. I2NP-Protokoll - Stellen Sie sicher, dass der Router so konfiguriert ist, dass er Verbindungen über ein gültiges Protokoll für das Betriebssystem des Hosts und leere Netzwerk(Erweitert)-Einstellungen erwartet. Geben Sie keine IP-Adresse in das Feld \u0026lsquo;Hostname\u0026rsquo; auf der Netzwerkkonfigurationsseite ein. Das hier ausgewählte I2NP-Protokoll wird nur verwendet, wenn Sie noch keine erreichbare Adresse haben. Die meisten Verizon 4G- und 5G-Drahtlosverbindungen in den Vereinigten Staaten blockieren beispielsweise UDP und können darüber nicht erreicht werden. Andere würden UDP zwangsweise verwenden, auch wenn es ihnen zur Verfügung steht. Wählen Sie eine sinnvolle Einstellung aus den aufgeführten I2NP-Protokollen. Ich bin gegen bestimmte Arten von Inhalten. Wie kann ich verhindern, dass ich sie verteile, speichere oder darauf zugreife? Standardmäßig ist keines dieser Inhalte installiert. Da I2P jedoch ein Peer-to-Peer-Netzwerk ist, kann es vorkommen, dass Sie versehentlich auf verbotene Inhalte stoßen. Hier ist eine Zusammenfassung, wie I2P verhindert, dass Sie ungewollt in Verstöße gegen Ihre Überzeugungen verwickelt werden.\nVerteilung - Der Datenverkehr ist intern im I2P-Netzwerk, Sie sind kein Exit-Knoten (in unserer Dokumentation als Outproxy bezeichnet). Speicherung - Das I2P-Netzwerk führt keine verteilte Speicherung von Inhalten durch, dies muss vom Benutzer speziell installiert und konfiguriert werden (zum Beispiel mit Tahoe-LAFS). Das ist eine Funktion eines anderen anonymen Netzwerks, Freenet . Durch den Betrieb eines I2P-routers speichern Sie keine Inhalte für andere. Zugriff - Ihr router wird keine Inhalte ohne Ihre ausdrückliche Anweisung anfordern. Ist es möglich, I2P zu blockieren? Ja, bei weitem der einfachste und häufigste Weg ist das Blockieren von Bootstrap- oder \u0026ldquo;Reseed\u0026rdquo;-Servern. Das vollständige Blockieren des gesamten verschleierten Datenverkehrs würde ebenfalls funktionieren (obwohl dies viele, viele andere Dinge, die nicht I2P sind, beeinträchtigen würde und die meisten nicht bereit sind, so weit zu gehen). Im Fall der Reseed-Blockierung gibt es ein Reseed-Bundle auf Github; dessen Blockierung würde auch Github blockieren. Sie können Reseed über einen Proxy durchführen (viele können im Internet gefunden werden, wenn Sie nicht Tor verwenden möchten) oder Reseed-Bundles auf Freund-zu-Freund-Basis offline teilen.\nIn wrapper.log sehe ich einen Fehler mit der Meldung \u0026ldquo;Protocol family unavailable\u0026rdquo; beim Laden der Router Console Dieser Fehler tritt häufig bei jeder netzwerkfähigen Java-Software auf Systemen auf, die standardmäßig für die Verwendung von IPv6 konfiguriert sind. Es gibt einige Möglichkeiten, dies zu lösen:\nAuf Linux-basierten Systemen können Sie echo 0 \u0026gt; /proc/sys/net/ipv6/bindv6only ausführen Suchen Sie nach den folgenden Zeilen in wrapper.config: #wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true #wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false Wenn die Zeilen vorhanden sind, kommentieren Sie sie aus, indem Sie die \u0026ldquo;#\u0026quot;-Zeichen entfernen. Wenn die Zeilen nicht vorhanden sind, fügen Sie sie ohne die \u0026ldquo;#\u0026quot;-Zeichen hinzu. Eine weitere Möglichkeit wäre, die ::1 aus ~/.i2p/clients.config zu entfernen\nWARNUNG: Damit Änderungen an wrapper.config wirksam werden, müssen Sie den Router und den Wrapper vollständig stoppen. Ein Klick auf Neustart in Ihrer Router-Konsole wird diese Datei NICHT neu einlesen! Sie müssen auf Herunterfahren klicken, 11 Minuten warten und dann I2P starten.\nDie meisten I2P-Sites innerhalb von I2P sind nicht erreichbar? Wenn man jede I2P Site betrachtet, die jemals erstellt wurde, dann ja, die meisten sind nicht mehr erreichbar. Menschen und I2P Sites kommen und gehen. Ein guter Weg, um mit I2P anzufangen, ist eine Liste von I2P Sites zu überprüfen, die derzeit aktiv sind. identiguy.i2p verfolgt aktive I2P Sites.\nWarum lauscht I2P auf Port 32000? Der Tanuki Java Service Wrapper, den wir verwenden, öffnet diesen Port – gebunden an localhost – um mit der im JVM laufenden Software zu kommunizieren. Wenn die JVM gestartet wird, erhält sie einen Schlüssel, damit sie sich mit dem Wrapper verbinden kann. Nachdem die JVM ihre Verbindung zum Wrapper hergestellt hat, lehnt der Wrapper alle weiteren Verbindungen ab.\nWeitere Informationen finden Sie in der Wrapper-Dokumentation .\nWie konfiguriere ich meinen Browser? Die Proxy-Konfiguration für verschiedene Browser befindet sich auf einer separaten Seite mit Screenshots. Fortgeschrittenere Konfigurationen mit externen Tools, wie dem Browser-Plugin FoxyProxy oder dem Proxy-Server Privoxy, sind möglich, könnten aber Lecks in Ihrer Konfiguration verursachen.\nWie verbinde ich mich mit IRC innerhalb von I2P? Ein Tunnel zum Haupt-IRC-Server innerhalb von I2P, Irc2P, wird bei der Installation von I2P erstellt (siehe die I2PTunnel-Konfigurationsseite ) und wird automatisch gestartet, wenn der I2P-Router startet. Um sich zu verbinden, konfigurieren Sie Ihren IRC-Client so, dass er sich mit localhost 6668 verbindet. Benutzer von HexChat-ähnlichen Clients können ein neues Netzwerk mit dem Server localhost/6668 erstellen (denken Sie daran, \u0026ldquo;Proxy-Server umgehen\u0026rdquo; anzukreuzen, falls Sie einen Proxy-Server konfiguriert haben). Weechat-Benutzer können den folgenden Befehl verwenden, um ein neues Netzwerk hinzuzufügen:\n/server add irc2p localhost/6668 Wie richte ich meine eigene I2P Site ein? Die einfachste Methode besteht darin, auf den i2ptunnel -Link in der Router-Konsole zu klicken und einen neuen \u0026lsquo;Server Tunnel\u0026rsquo; zu erstellen. Sie können dynamische Inhalte bereitstellen, indem Sie das Tunnel-Ziel auf den Port eines vorhandenen Webservers wie Tomcat oder Jetty setzen. Sie können auch statische Inhalte bereitstellen. Setzen Sie dazu das Tunnel-Ziel auf: 0.0.0.0 port 7659 und platzieren Sie den Inhalt im Verzeichnis ~/.i2p/eepsite/docroot/. (Auf Nicht-Linux-Systemen kann sich dies an einem anderen Ort befinden. Überprüfen Sie die Router-Konsole.) Die \u0026rsquo;eepsite\u0026rsquo;-Software ist Teil des I2P-Installationspakets und wird automatisch gestartet, wenn I2P gestartet wird. Die dabei erstellte Standardseite ist unter http://127.0.0.1:7658 erreichbar. Ihre \u0026rsquo;eepsite\u0026rsquo; ist jedoch auch für andere über Ihre eepsite-Schlüsseldatei zugänglich, die sich hier befindet: ~/.i2p/eepsite/i2p/eepsite.keys. Um mehr zu erfahren, lesen Sie die Readme-Datei unter: ~/.i2p/eepsite/README.txt.\nWenn ich zu Hause eine Website auf I2P hoste, die nur HTML und CSS enthält, ist das gefährlich? Es hängt von Ihrem Gegner und Ihrem Bedrohungsmodell ab. Wenn Sie sich nur um unternehmerische \u0026ldquo;Datenschutz\u0026rdquo;-Verletzungen, typische Kriminelle und Zensur sorgen, dann ist es nicht wirklich gefährlich. Strafverfolgungsbehörden werden Sie wahrscheinlich trotzdem finden, wenn sie es wirklich wollen. Nur das Hosting zu betreiben, wenn Sie einen normalen (Internet-)Heimbrowser laufen haben, macht es wirklich schwierig herauszufinden, wer diesen Teil hostet. Bitte betrachten Sie das Hosting Ihrer I2P-Site genauso wie das Hosting jedes anderen Dienstes - es ist so gefährlich - oder sicher - wie Sie es selbst konfigurieren und verwalten.\nHinweis: Es gibt bereits eine Möglichkeit, das Hosting eines i2p-Dienstes (destination) vom i2p-Router zu trennen. Wenn Sie verstehen, wie es funktioniert, können Sie einfach eine separate Maschine als Server für die Website (oder den Dienst) einrichten, die öffentlich zugänglich sein wird, und diese über einen [sehr] sicheren SSH-Tunnel an den Webserver weiterleiten oder ein gesichertes, gemeinsam genutztes Dateisystem verwenden.\nWie findet I2P \u0026ldquo;.i2p\u0026rdquo;-Websites? Die I2P-Adressbuch-Anwendung ordnet menschenlesbare Namen langfristigen Zielen (Destinations) zu, die mit Diensten verbunden sind, wodurch sie eher einer Hosts-Datei oder einer Kontaktliste ähnelt als einer Netzwerkdatenbank oder einem DNS-Dienst. Sie ist außerdem lokal ausgerichtet – es gibt keinen anerkannten globalen Namensraum, Sie entscheiden, worauf eine bestimmte .i2p-Domain letztendlich verweist. Der Mittelweg ist etwas, das als \u0026ldquo;Jump Service\u0026rdquo; bezeichnet wird und einen menschenlesbaren Namen bereitstellt, indem es Sie zu einer Seite weiterleitet, auf der Sie gefragt werden: \u0026ldquo;Geben Sie dem I2P-Router die Erlaubnis, $SITE_CRYPTO_KEY den Namen $SITE_NAME.i2p zu nennen\u0026rdquo; oder etwas in dieser Art. Sobald es in Ihrem Adressbuch ist, können Sie Ihre eigenen Jump-URLs generieren, um die Seite mit anderen zu teilen.\nWie füge ich Adressen zum Adressbuch hinzu? Sie können keine Adresse hinzufügen, ohne zumindest die Base32- oder Base64-Adresse der Website zu kennen, die Sie besuchen möchten. Der „Hostname\u0026rdquo;, der für Menschen lesbar ist, ist nur ein Alias für die kryptografische Adresse, die der Base32- oder Base64-Adresse entspricht. Ohne die kryptografische Adresse gibt es keine Möglichkeit, auf eine I2P-Site zuzugreifen – das ist beabsichtigt. Die Verteilung der Adresse an Personen, die sie noch nicht kennen, liegt normalerweise in der Verantwortung des Jump-Service-Anbieters. Der Besuch einer unbekannten I2P-Site löst die Verwendung eines Jump-Service aus. stats.i2p ist der zuverlässigste Jump-Service.\nWenn Sie eine Website über i2ptunnel hosten, hat diese noch keine Registrierung bei einem Jump-Service. Um ihr lokal eine URL zu geben, besuchen Sie die Konfigurationsseite und klicken Sie auf die Schaltfläche \u0026ldquo;Add to Local Address Book\u0026rdquo;. Gehen Sie dann zu http://127.0.0.1:7657/dns, um die Addresshelper-URL nachzuschlagen und zu teilen.\nWelche Ports verwendet I2P? Die von I2P verwendeten Ports lassen sich in 2 Bereiche unterteilen:\nInternetfähige Ports, die für die Kommunikation mit anderen I2P-Routern verwendet werden Lokale Ports für lokale Verbindungen Diese werden im Folgenden ausführlich beschrieben.\n1. Nach außen offene Ports Hinweis: Seit Version 0.7.8 verwenden neue Installationen nicht mehr Port 8887; ein zufälliger Port zwischen 9000 und 31000 wird ausgewählt, wenn das Programm zum ersten Mal ausgeführt wird. Der ausgewählte Port wird auf der Router-Konfigurationsseite angezeigt.\nAUSGEHEND\nUDP vom zufälligen Port, der auf der Konfigurationsseite aufgeführt ist, zu beliebigen entfernten UDP-Ports, mit Antwortmöglichkeit TCP von zufälligen hohen Ports zu beliebigen entfernten TCP-Ports Ausgehende UDP-Verbindungen auf Port 123, mit Antwortmöglichkeit. Dies ist für die interne Zeitsynchronisation von I2P erforderlich (über SNTP - Abfrage eines zufälligen SNTP-Hosts in pool.ntp.org oder eines anderen von Ihnen angegebenen Servers) EINGEHEND\n(Optional, empfohlen) UDP zum Port, der auf der Konfigurationsseite angegeben ist, von beliebigen Standorten (Optional, empfohlen) TCP zum Port, der auf der Konfigurationsseite angegeben ist, von beliebigen Standorten Eingehende TCP-Verbindungen können auf der Konfigurationsseite deaktiviert werden 2. Lokale I2P-Ports Lokale I2P-Ports lauschen standardmäßig nur auf lokale Verbindungen, außer wo anders angegeben:\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. ### In meinem Adressbuch fehlen viele Hosts. Was sind gute Abonnement-Links? {#subscriptions} Das Adressbuch befindet sich unter http://localhost:7657/dns , wo weitere Informationen zu finden sind.\nWas sind gute Abonnement-Links für das Adressbuch?\nSie können Folgendes versuchen:\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt Wie kann ich von anderen Rechnern auf die Webkonsole zugreifen oder sie mit einem Passwort schützen? Aus Sicherheitsgründen akzeptiert die Admin-Konsole des Routers standardmäßig nur Verbindungen über das lokale Interface.\nEs gibt zwei Methoden, um remote auf die Konsole zuzugreifen:\nSSH Tunnel Konfigurieren Sie Ihre Konsole so, dass sie über eine öffentliche IP-Adresse mit Benutzernamen und Passwort verfügbar ist Diese werden im Folgenden detailliert beschrieben:\nMethode 1: SSH-Tunnel\nWenn Sie ein Unix-ähnliches Betriebssystem verwenden, ist dies die einfachste Methode für den Remote-Zugriff auf Ihre I2P-Konsole. (Hinweis: SSH-Server-Software ist auch für Systeme unter Windows verfügbar, zum Beispiel https://github.com/PowerShell/Win32-OpenSSH )\nSobald Sie SSH-Zugriff auf Ihr System konfiguriert haben, wird das Flag \u0026lsquo;-L\u0026rsquo; mit entsprechenden Argumenten an SSH übergeben - zum Beispiel:\nssh -L 7657:localhost:7657 (System_IP) wobei \u0026lsquo;(System_IP)\u0026rsquo; durch die IP-Adresse Ihres Systems ersetzt wird. Dieser Befehl leitet Port 7657 (die Zahl vor dem ersten Doppelpunkt) an den Port 7657 des entfernten Systems (spezifiziert durch die Zeichenkette \u0026rsquo;localhost\u0026rsquo; zwischen dem ersten und zweiten Doppelpunkt) weiter (die Zahl nach dem zweiten Doppelpunkt). Ihre entfernte I2P-Konsole ist nun auf Ihrem lokalen System unter \u0026lsquo;http://localhost:7657\u0026rsquo; verfügbar und bleibt verfügbar, solange Ihre SSH-Sitzung aktiv ist.\nWenn Sie eine SSH-Sitzung starten möchten, ohne eine Shell auf dem entfernten System zu initiieren, können Sie das Flag \u0026lsquo;-N\u0026rsquo; hinzufügen:\nssh -NL 7657:localhost:7657 (System_IP) Methode 2: Konfigurieren Sie Ihre Konsole so, dass sie über eine öffentliche IP-Adresse mit Benutzername und Passwort erreichbar ist\nÖffnen Sie ~/.i2p/clients.config und ersetzen Sie:\nclientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ durch:\nclientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ wobei Sie (System_IP) durch die öffentliche IP-Adresse Ihres Systems ersetzen\nGehen Sie zu http://localhost:7657/configui und fügen Sie bei Bedarf einen Konsolenbenutzernamen und ein Passwort hinzu - Das Hinzufügen eines Benutzernamens und Passworts wird dringend empfohlen, um Ihre I2P-Konsole vor unbefugtem Zugriff zu schützen, was zu einer De-Anonymisierung führen könnte.\nGehe zu http://localhost:7657/index und klicke auf \u0026ldquo;Graceful restart\u0026rdquo;, was die JVM neu startet und die Client-Anwendungen neu lädt\nNachdem das gestartet ist, sollten Sie nun in der Lage sein, Ihre Konsole remote zu erreichen. Laden Sie die Router-Konsole unter http://(System_IP):7657 und Sie werden nach dem Benutzernamen und Passwort gefragt, die Sie in Schritt 2 oben angegeben haben, sofern Ihr Browser das Authentifizierungs-Popup unterstützt.\nHINWEIS: Sie können 0.0.0.0 in der obigen Konfiguration angeben. Dies gibt eine Schnittstelle an, nicht ein Netzwerk oder eine Netzmaske. 0.0.0.0 bedeutet \u0026ldquo;an alle Schnittstellen binden\u0026rdquo;, sodass es sowohl unter 127.0.0.1:7657 als auch unter jeder LAN/WAN-IP erreichbar sein kann. Seien Sie vorsichtig bei der Verwendung dieser Option, da die Konsole auf ALLEN auf Ihrem System konfigurierten Adressen verfügbar sein wird.\nWie kann ich Anwendungen von meinen anderen Rechnern nutzen? Bitte sehen Sie sich die vorherige Antwort für Anweisungen zur Verwendung von SSH Port Forwarding an und besuchen Sie auch diese Seite in Ihrer Konsole: http://localhost:7657/configi2cp Ist es möglich, I2P als SOCKS-Proxy zu verwenden? Der SOCKS-Proxy ist seit Version 0.7.1 funktionsfähig. SOCKS 4/4a/5 werden unterstützt. I2P verfügt nicht über einen SOCKS-Outproxy, daher ist die Nutzung auf I2P beschränkt.\nViele Anwendungen geben sensible Informationen preis, die Sie im Internet identifizieren könnten, und dies ist ein Risiko, dessen man sich bei der Verwendung des I2P-SOCKS-Proxys bewusst sein sollte. I2P filtert nur Verbindungsdaten, aber wenn das Programm, das Sie verwenden möchten, diese Informationen als Inhalt sendet, hat I2P keine Möglichkeit, Ihre Anonymität zu schützen. Beispielsweise senden einige E-Mail-Anwendungen die IP-Adresse des Rechners, auf dem sie laufen, an einen Mailserver. Wir empfehlen I2P-spezifische Werkzeuge oder Anwendungen (wie I2PSnark für Torrents) oder Anwendungen, von denen bekannt ist, dass sie sicher mit I2P verwendet werden können, einschließlich beliebter Plugins, die auf Firefox zu finden sind.\nWie greife ich auf IRC, BitTorrent oder andere Dienste im regulären Internet zu? Es gibt Dienste namens Outproxies, die zwischen I2P und dem Internet vermitteln, ähnlich wie Tor Exit Nodes. Die Standard-Outproxy-Funktionalität für HTTP und HTTPS wird von exit.stormycloud.i2p bereitgestellt und von StormyCloud Inc. betrieben. Sie wird im HTTP-Proxy konfiguriert. Um die Anonymität zusätzlich zu schützen, erlaubt I2P standardmäßig keine anonymen Verbindungen zum regulären Internet. Weitere Informationen finden Sie auf der Seite Socks Outproxy .\nReseeds Mein Router läuft seit mehreren Minuten und hat keine oder sehr wenige Verbindungen Überprüfen Sie zunächst die http://127.0.0.1:7657/netdb Seite in der Router Console – Ihre Netzwerkdatenbank. Wenn Sie keinen einzigen Router von innerhalb I2P aufgelistet sehen, die Konsole aber anzeigt, dass Sie hinter einer Firewall sein sollten, dann können Sie wahrscheinlich keine Verbindung zu den Reseed-Servern herstellen. Wenn Sie andere I2P-Router aufgelistet sehen, versuchen Sie, die Anzahl der maximalen Verbindungen unter http://127.0.0.1:7657/config zu reduzieren – möglicherweise kann Ihr Router nicht viele Verbindungen verarbeiten.\nWie führe ich ein manuelles Reseeding durch? Unter normalen Umständen verbindet I2P Sie automatisch mit dem Netzwerk über unsere Bootstrap-Links. Wenn eine gestörte Internetverbindung das Bootstrapping von Reseed-Servern scheitern lässt, ist eine einfache Möglichkeit zum Bootstrapping die Verwendung des Tor-Browsers (standardmäßig öffnet er localhost), der sehr gut mit http://127.0.0.1:7657/configreseed funktioniert. Es ist auch möglich, einen I2P-router manuell zu reseeden.\nWenn Sie den Tor-Browser zum Reseeden verwenden, können Sie mehrere URLs auf einmal auswählen und fortfahren. Obwohl der Standardwert von 2 (von den mehreren URLs) auch funktioniert, wird es langsam sein.\nPrivatsphäre-Sicherheit Ist mein Router ein \u0026ldquo;Exit Node\u0026rdquo; (Outproxy) zum regulären Internet? Ich möchte nicht, dass er einer ist. Nein, Ihr Router beteiligt sich am Transport von verschlüsseltem Ende-zu-Ende-Verkehr durch das I2P-Netzwerk zu einem zufälligen Tunnel-Endpunkt, normalerweise nicht zu einem Outproxy, aber es wird kein Verkehr zwischen Ihrem Router und dem Internet über die Transportschicht weitergeleitet. Als Endbenutzer sollten Sie keinen Outproxy betreiben, wenn Sie nicht über Kenntnisse in der System- und Netzwerkadministration verfügen.\nIst es einfach, die Nutzung von I2P durch Analyse des Netzwerkverkehrs zu erkennen? I2P-Verkehr sieht normalerweise wie UDP-Verkehr aus, und nicht viel mehr – und es zu einem Ziel zu machen, dass er nicht viel mehr aussieht, ist ein Ziel. Es unterstützt auch TCP. Mit einigem Aufwand kann die passive Verkehrsanalyse möglicherweise den Verkehr als \u0026ldquo;I2P\u0026rdquo; klassifizieren, aber wir hoffen, dass die fortlaufende Entwicklung von Traffic Obfuscation dies weiter reduzieren wird. Selbst eine recht einfache Protokoll-Verschleierungsschicht wie obfs4 wird Zensoren daran hindern, I2P zu blockieren (es ist ein Ziel, das I2P verfolgt).\nIst die Nutzung von I2P sicher? Es hängt von Ihrem persönlichen Bedrohungsmodell ab. Für die meisten Menschen ist I2P wesentlich sicherer als die Nutzung ohne jeglichen Schutz. Einige andere Netzwerke (wie Tor, mixminion/mixmaster) sind wahrscheinlich sicherer gegen bestimmte Gegner. Beispielsweise verwendet I2P-Verkehr kein TLS/SSL, sodass es nicht die „schwächstes Glied\u0026rdquo;-Probleme hat, die Tor hat. I2P wurde während des „Arabischen Frühlings\u0026quot; von vielen Menschen in Syrien genutzt, und in jüngster Zeit hat das Projekt ein stärkeres Wachstum bei kleineren sprachlichen Installationen von I2P im Nahen und Mittleren Osten verzeichnet. Das Wichtigste, was hier zu beachten ist: I2P ist eine Technologie und Sie benötigen eine Anleitung, um Ihre Privatsphäre/Anonymität im Internet zu verbessern. Überprüfen Sie auch Ihren Browser oder importieren Sie die Fingerprint-Suchmaschine, um Fingerprint-Angriffe mit einem sehr großen (bedeutet: typische Long-Tail-Verteilungen / sehr präzise diverse Datenstruktur) Datensatz über viele Umgebungsfaktoren zu blockieren, und verwenden Sie kein VPN, um alle Risiken zu reduzieren, die von ihm selbst ausgehen, wie das eigene TLS-Cache-Verhalten und die technische Konstruktion des Provider-Geschäfts, das leichter gehackt werden kann als ein eigenes Desktop-System. Möglicherweise ist die Verwendung eines isolierten Tor-V-Browsers mit seinen großartigen Anti-Fingerprint-Schutzmaßnahmen und einem umfassenden Appguard-Laufzeitschutz, der nur die notwendigen Systemkommunikationen zulässt, sowie eine letzte VM-Nutzung mit Anti-Spy-Deaktivierungsskripten und Live-CD, um jedes „nahezu dauerhaft mögliche Risiko\u0026quot; zu entfernen und alle Risiken durch eine abnehmende Wahrscheinlichkeit zu senken, eine gute Option in öffentlichen Netzwerken und individuellen Hochrisiko-Modellen und könnte das Beste sein, was Sie mit diesem Ziel für die I2P-Nutzung tun können.\nIch sehe IP-Adressen aller anderen I2P-Knoten in der Router-Konsole. Bedeutet das, dass meine IP-Adresse für andere sichtbar ist? Ja, für andere I2P-Knoten, die Ihren Router kennen. Wir verwenden dies, um uns mit dem Rest des I2P-Netzwerks zu verbinden. Die Adressen befinden sich physisch in \u0026ldquo;routerInfos (Schlüssel-Wert-Objekten)\u0026rdquo;, die entweder remote abgerufen oder von Peers empfangen werden. Die \u0026ldquo;routerInfos\u0026rdquo; enthalten einige Informationen (einige optional opportunistisch hinzugefügt), \u0026ldquo;vom Peer veröffentlicht\u0026rdquo;, über den Router selbst für das Bootstrapping. In diesem Objekt befinden sich keine Daten über Clients. Ein genauerer Blick unter die Haube zeigt, dass jeder mit dem neuesten Typ der ID-Erstellung gezählt wird, genannt \u0026ldquo;SHA-256 Hashes (niedrig=Positiver Hash(-Schlüssel), hoch=Negativer Hash(+Schlüssel))\u0026rdquo;. Das I2P-Netzwerk hat eine eigene Datenbank mit routerInfos, die während des Uploads und der Indizierung erstellt werden, aber dies hängt tief in der Realisierung der Schlüssel/Wert-Tabellen und der Netzwerktopologie sowie dem Auslastungszustand / Bandbreitenzustand und den Routing-Wahrscheinlichkeiten für die Speicherung in DB-Komponenten ab.\nIst die Verwendung eines Outproxys sicher? Es kommt darauf an, wie Sie \u0026ldquo;sicher\u0026rdquo; definieren. Outproxies sind großartig, wenn sie funktionieren, aber leider werden sie freiwillig von Personen betrieben, die möglicherweise das Interesse verlieren oder nicht über die Ressourcen verfügen, um sie rund um die Uhr zu betreiben – bitte beachten Sie, dass es Zeiträume geben kann, in denen Dienste nicht verfügbar, unterbrochen oder unzuverlässig sind, und wir sind nicht mit diesem Dienst verbunden und haben keinen Einfluss darauf.\nDie Outproxys selbst können Ihren Datenverkehr sehen, mit Ausnahme von Ende-zu-Ende-verschlüsselten HTTPS/SSL-Daten, genau wie Ihr Internetanbieter den Datenverkehr von Ihrem Computer sehen kann. Wenn Sie Ihrem Internetanbieter vertrauen, wäre es mit dem Outproxy nicht schlechter.\nWas ist mit \u0026ldquo;De-Anonymisierungs\u0026rdquo;-Angriffen? Für eine sehr ausführliche Erklärung lesen Sie mehr in unseren Artikeln über das Bedrohungsmodell . Im Allgemeinen ist eine De-Anonymisierung nicht trivial, aber möglich, wenn Sie nicht vorsichtig genug sind.\nInternetzugang/Leistung Ich kann über I2P nicht auf reguläre Internetseiten zugreifen. Das Proxying zu Internet-Seiten (eepsites, die ins Internet führen) wird als Dienst für I2P-Nutzer von Non-Block-Anbietern bereitgestellt. Dieser Dienst steht nicht im Mittelpunkt der I2P-Entwicklung und wird auf freiwilliger Basis angeboten. Eepsites, die auf I2P gehostet werden, sollten immer ohne Outproxy funktionieren. Outproxies sind eine Annehmlichkeit, aber sie sind von Natur aus weder perfekt noch ein großer Teil des Projekts. Beachten Sie, dass sie möglicherweise nicht den hochwertigen Service bieten können, den andere Dienste von I2P bereitstellen.\nIch kann nicht auf https:// oder ftp:// Seiten über I2P zugreifen. Der Standard-HTTP-Proxy unterstützt nur HTTP- und HTTPS-Outproxying.\nWarum verbraucht mein Router zu viel CPU? Stellen Sie zunächst sicher, dass Sie die neueste Version aller I2P-bezogenen Komponenten haben – ältere Versionen enthielten unnötige CPU-intensive Codeabschnitte. Es gibt auch ein Performance-Log , das einige der Leistungsverbesserungen in I2P im Laufe der Zeit dokumentiert.\nMeine aktiven Peers / bekannten Peers / teilnehmenden Tunnel / Verbindungen / Bandbreite schwanken stark im Zeitverlauf! Stimmt etwas nicht? Die allgemeine Stabilität des I2P-Netzwerks ist ein fortlaufender Forschungsbereich. Ein besonderer Schwerpunkt dieser Forschung liegt darauf, wie kleine Änderungen an Konfigurationseinstellungen das Verhalten des Routers verändern. Da I2P ein Peer-to-Peer-Netzwerk ist, haben die Aktionen anderer Peers einen Einfluss auf die Leistung Ihres Routers.\nWas macht Downloads, Torrents, Webbrowsing und alles andere auf I2P langsamer im Vergleich zum normalen Internet? I2P verfügt über verschiedene Schutzmaßnahmen, die zusätzliches Routing und weitere Verschlüsselungsebenen hinzufügen. Außerdem wird der Datenverkehr über andere Peers (Tunnels) geleitet, die ihre eigene Geschwindigkeit und Qualität haben – einige sind langsam, andere schnell. Dies führt zu einem erheblichen Overhead und Datenverkehr mit unterschiedlichen Geschwindigkeiten in verschiedene Richtungen. Durch das Design werden all diese Dinge I2P im Vergleich zu einer direkten Internetverbindung langsamer machen, aber wesentlich anonymer und dennoch für die meisten Anwendungsfälle schnell genug.\nNachfolgend wird ein Beispiel mit einer Erklärung präsentiert, um einen Kontext für die Überlegungen zu Latenz und Bandbreite bei der Verwendung von I2P zu bieten.\nBetrachten Sie das untenstehende Diagramm. Es zeigt eine Verbindung zwischen einem Client, der eine Anfrage über I2P sendet, einem Server, der die Anfrage über I2P empfängt und dann ebenfalls über I2P antwortet. Der Pfad, den die Anfrage durchläuft, ist ebenfalls dargestellt.\nBetrachten Sie im Diagramm die Kästchen mit den Bezeichnungen \u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo; und \u0026lsquo;R\u0026rsquo; als einen ausgehenden Tunnel für \u0026lsquo;A\u0026rsquo; und die Kästchen mit den Bezeichnungen \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; und \u0026lsquo;Z\u0026rsquo; als einen ausgehenden Tunnel für \u0026lsquo;B\u0026rsquo;. Ebenso repräsentieren die Kästchen mit den Bezeichnungen \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; und \u0026lsquo;Z\u0026rsquo; einen eingehenden Tunnel für \u0026lsquo;B\u0026rsquo;, während die Kästchen mit den Bezeichnungen \u0026lsquo;P_1\u0026rsquo;, \u0026lsquo;Q_1\u0026rsquo; und \u0026lsquo;R_1\u0026rsquo; einen eingehenden Tunnel für \u0026lsquo;A\u0026rsquo; darstellen. Die Pfeile zwischen den Kästchen zeigen die Richtung des Datenverkehrs. Der Text oberhalb und unterhalb der Pfeile gibt Beispiele für die Bandbreite zwischen einem Hop-Paar sowie Beispiele für Latenzen an.\nWenn sowohl Client als auch Server durchgehend 3-Hop-Tunnel verwenden, sind insgesamt 12 andere I2P-Router an der Weiterleitung des Datenverkehrs beteiligt. 6 Peers leiten den Datenverkehr vom Client zum Server weiter, der in einen ausgehenden 3-Hop-Tunnel von \u0026lsquo;A\u0026rsquo; (\u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;R\u0026rsquo;) und einen eingehenden 3-Hop-Tunnel zu \u0026lsquo;B\u0026rsquo; (\u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;) aufgeteilt wird. Ebenso leiten 6 Peers den Datenverkehr vom Server zurück zum Client weiter.\nZunächst können wir die Latenz betrachten - die Zeit, die eine Anfrage eines Clients benötigt, um das I2P-Netzwerk zu durchqueren, den Server zu erreichen und zum Client zurückzukehren. Wenn wir alle Latenzen zusammenzählen, sehen wir:\n40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms Die gesamte Round-Trip-Zeit in unserem Beispiel beträgt 740 ms - sicherlich deutlich höher als das, was man normalerweise beim Surfen auf regulären Internetseiten sehen würde.\nZweitens können wir die verfügbare Bandbreite betrachten. Diese wird durch die langsamste Verbindung zwischen den Hops vom Client zum Server sowie bei der Übertragung von Datenverkehr vom Server zum Client bestimmt. Für Datenverkehr vom Client zum Server sehen wir in unserem Beispiel, dass die verfügbare Bandbreite zwischen den Hops \u0026lsquo;R\u0026rsquo; \u0026amp; \u0026lsquo;X\u0026rsquo; sowie den Hops \u0026lsquo;X\u0026rsquo; \u0026amp; \u0026lsquo;Y\u0026rsquo; 32 KB/s beträgt. Trotz höherer verfügbarer Bandbreite zwischen den anderen Hops werden diese Hops als Engpass fungieren und die maximal verfügbare Bandbreite für Datenverkehr von \u0026lsquo;A\u0026rsquo; nach \u0026lsquo;B\u0026rsquo; auf 32 KB/s begrenzen. Ebenso zeigt die Verfolgung des Pfades vom Server zum Client, dass es eine maximale Bandbreite von 64 KB/s gibt - zwischen den Hops \u0026lsquo;Z_1\u0026rsquo; \u0026amp; \u0026lsquo;Y_1\u0026rsquo;, \u0026lsquo;Y_1\u0026rsquo; \u0026amp; \u0026lsquo;X_1\u0026rsquo; und \u0026lsquo;Q_1\u0026rsquo; \u0026amp; \u0026lsquo;P_1\u0026rsquo;.\nWir empfehlen, Ihre Bandbreitenlimits zu erhöhen. Dies hilft dem Netzwerk, indem die Menge an verfügbarer Bandbreite erhöht wird, was wiederum Ihre I2P-Erfahrung verbessert. Die Bandbreiteneinstellungen finden Sie auf der Seite http://localhost:7657/config . Bitte beachten Sie die Limits Ihrer Internetverbindung, die von Ihrem Internetanbieter vorgegeben werden, und passen Sie Ihre Einstellungen entsprechend an.\nWir empfehlen außerdem, eine ausreichende Menge an geteilter Bandbreite festzulegen - dies ermöglicht es, dass participating tunnels durch Ihren I2P-router geleitet werden. Das Zulassen von participating traffic hält Ihren router gut in das Netzwerk integriert und verbessert Ihre Übertragungsgeschwindigkeiten.\nI2P ist ein laufendes Projekt. Viele Verbesserungen und Fehlerbehebungen werden implementiert, und im Allgemeinen wird die Verwendung der neuesten Version Ihre Leistung verbessern. Falls noch nicht geschehen, installieren Sie die neueste Version.\nIch glaube, ich habe einen Fehler gefunden, wo kann ich ihn melden? Sie können alle Fehler/Probleme, auf die Sie stoßen, in unserem Bugtracker melden, der sowohl über das öffentliche Internet als auch über I2P verfügbar ist. Wir haben ein Diskussionsforum, das ebenfalls über I2P und das öffentliche Internet erreichbar ist. Sie können auch unserem IRC-Kanal beitreten: entweder über unser IRC-Netzwerk IRC2P oder auf Freenode.\nUnser Bugtracker: Öffentliches Internet: https://i2pgit.org/I2P_Developers/i2p.i2p/issues Im I2P: http://git.idk.i2p/I2P_Developers/i2p.i2p/issues Unsere Foren: i2pforum.i2p Logs einfügen: Sie können interessante Logs bei einem Paste-Dienst wie den im öffentlichen Internet verfügbaren Diensten im PrivateBin Wiki oder einem I2P-Paste-Dienst wie dieser PrivateBin-Instanz oder diesem Javascript-freien Paste-Dienst einfügen und auf IRC in #i2p nachfassen IRC: Treten Sie #i2p-dev bei und diskutieren Sie mit den Entwicklern auf IRC Bitte fügen Sie relevante Informationen von der Router-Logs-Seite bei, die verfügbar ist unter: http://127.0.0.1:7657/logs . Wir bitten Sie, den gesamten Text aus dem Abschnitt \u0026lsquo;I2P Version and Running Environment\u0026rsquo; sowie alle Fehler oder Warnungen, die in den verschiedenen auf der Seite angezeigten Logs erscheinen, mit uns zu teilen.\nIch habe eine Frage! Großartig! Finden Sie uns auf IRC:\nauf irc.freenode.net Kanal #i2p auf IRC2P Kanal #i2p oder poste im Forum und wir werden es hier veröffentlichen (hoffentlich mit der Antwort).\n","description":"Umfassende I2P FAQ: Router-Hilfe, Konfiguration, Reseeds, Privatsphäre/Sicherheit, Leistung und Fehlerbehebung","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"Häufig gestellte Fragen","url":"/de/docs/overview/faq/"},{"categories":null,"content":"Implementierungsstatus Aktuelle Bereitstellung: - i2pd (C++-Implementierung): Vollständig implementiert in Version 2.58.0 (September 2025) mit Unterstützung für ML-KEM-512, ML-KEM-768 und ML-KEM-1024. Post-Quanten-Ende-zu-Ende-Verschlüsselung ist standardmäßig aktiviert, wenn OpenSSL 3.5.0 oder neuer verfügbar ist. - Java I2P: Bis Version 0.9.67 / 2.10.0 (September 2025) noch nicht implementiert. Spezifikation genehmigt und Implementierung für zukünftige Versionen geplant.\nDiese Spezifikation beschreibt freigegebene Funktionalität, die derzeit in i2pd eingesetzt ist und für Java I2P-Implementierungen geplant ist.\nÜbersicht Dies ist die Post-Quanten-Hybridvariante des Protokolls ECIES-X25519-AEAD-Ratchet ECIES . Sie stellt die erste zu genehmigende Phase von Vorschlag 169 Prop169 dar. Siehe diesen Vorschlag für übergeordnete Ziele, Bedrohungsmodelle, Analysen, Alternativen und zusätzliche Informationen.\nStatus von Vorschlag 169: Offen (erste Phase für hybride ECIES (Elliptic Curve Integrated Encryption Scheme, integriertes Verschlüsselungsverfahren mit elliptischen Kurven)-Implementierung genehmigt).\nDiese Spezifikation enthält nur die Unterschiede zum Standard ECIES und muss in Verbindung mit jener Spezifikation gelesen werden.\nEntwurf Wir verwenden den NIST FIPS 203-Standard FIPS203 , der zwar auf CRYSTALS-Kyber basiert, jedoch nicht damit kompatibel ist (Versionen 3.1, 3 und älter).\nHybride Handshakes kombinieren klassisches X25519-Diffie-Hellman mit Post-Quanten-Schlüsselkapselungsmechanismen (ML-KEM). Dieser Ansatz basiert auf Konzepten hybrider Vorwärtsgeheimhaltung, die in der PQNoise-Forschung dokumentiert sind, sowie auf ähnlichen Implementierungen in TLS 1.3, IKEv2 und WireGuard.\nSchlüsselaustausch Wir definieren einen hybriden Schlüsselaustausch für Ratchet (kryptographisches Ratchet-Protokoll). Ein Post-Quanten-Schlüsselkapselungsverfahren (KEM) liefert nur ephemere Schlüssel und unterstützt Handshakes mit statischen Schlüsseln wie Noise IK nicht direkt.\nWir definieren die drei ML-KEM-Varianten wie in FIPS203 spezifiziert, woraus sich insgesamt drei neue Verschlüsselungstypen ergeben. Hybridtypen sind nur in Kombination mit X25519 definiert.\nDie neuen Verschlüsselungstypen sind:\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 **Hinweis:** MLKEM768_X25519 (Typ 6) ist die empfohlene Standardvariante, die starke Post-Quanten-Sicherheit bei angemessenem Mehraufwand bietet. Der Overhead ist im Vergleich zur ausschließlich mit X25519 erfolgenden Verschlüsselung erheblich. Die typischen Größen der Nachrichten 1 und 2 (für IK pattern (Noise‑Protokollmuster IK)) liegen derzeit bei etwa 96-103 Bytes (vor zusätzlicher Nutzlast). Dies erhöht sich je nach Nachrichtentyp um etwa das 9- bis 12‑Fache für MLKEM512 (post‑quantenfähiges Schlüsselkapselungsverfahren), das 13- bis 16‑Fache für MLKEM768 und das 17- bis 23‑Fache für MLKEM1024.\nNeue Kryptografie erforderlich ML-KEM (früher CRYSTALS-Kyber) FIPS203 - Standard für modulgitterbasierte Key-Encapsulation Mechanisms (Schlüsselkapselungsmechanismen) SHA3-256 (früher Keccak-512) FIPS202 - Teil des SHA-3-Standards SHAKE128 und SHAKE256 (XOF-Erweiterungen für SHA3) FIPS202 - Erweiterbare Ausgabefunktionen Testvektoren für SHA3-256, SHAKE128 und SHAKE256 sind im NIST Cryptographic Algorithm Validation Program verfügbar.\nBibliotheksunterstützung: - Java: Bouncycastle-Bibliothek Version 1.79 und höher unterstützt alle ML-KEM-Varianten und SHA3/SHAKE-Funktionen - C++: OpenSSL 3.5 und höher enthält vollständige ML-KEM-Unterstützung (veröffentlicht im April 2025) - Go: Mehrere Bibliotheken sind für die Implementierung von ML-KEM und SHA3 verfügbar\nSpezifikation Allgemeine Strukturen Siehe die Common Structures Specification für Schlüssellängen und Bezeichner.\nHandshake-Muster Handshakes verwenden Noise Protocol Framework Handshake-Muster mit I2P-spezifischen Anpassungen für hybride Post-Quanten-Sicherheit.\nDie folgende Zuordnung der Buchstaben wird verwendet:\ne = einmaliger ephemerer Schlüssel (X25519) s = statischer Schlüssel p = Nutzlast der Nachricht e1 = einmaliger ephemerer PQ-Schlüssel, von Alice an Bob gesendet (I2P-spezifisches Token) ekem1 = das KEM-Chiffrat, von Bob an Alice gesendet (I2P-spezifisches Token) Wichtiger Hinweis: Die Musternamen \u0026ldquo;IKhfs\u0026rdquo; und \u0026ldquo;IKhfselg2\u0026rdquo; sowie die Token \u0026ldquo;e1\u0026rdquo; und \u0026ldquo;ekem1\u0026rdquo; sind I2P-spezifische Anpassungen, die in der offiziellen Spezifikation des Noise Protocol Frameworks nicht dokumentiert sind. Diese stellen eigene Definitionen zur Integration von ML-KEM in das Noise-IK-Muster dar. Während der hybride Ansatz X25519 + ML-KEM in der Forschung zur Post-Quanten-Kryptografie und in anderen Protokollen weithin anerkannt ist, ist die hier verwendete spezifische Nomenklatur I2P-spezifisch.\nDie folgenden Änderungen an IK für hybrides Vorwärtsgeheimnis werden angewendet:\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. Das e1-Muster ist wie folgt definiert:\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) Das ekem1-Muster ist wie folgt definiert:\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) Definierte ML-KEM-Operationen Wir definieren die folgenden Funktionen, die den kryptografischen Bausteinen entsprechen, wie in FIPS203 spezifiziert.\n(encap_key, decap_key) = PQ_KEYGEN() : Alice generiert die Kapselungs- und Entkapselungsschlüssel. Der Kapselungsschlüssel wird in der NS-Nachricht übermittelt. Schlüsselgrößen: - ML-KEM-512: encap_key = 800 Bytes, decap_key = 1632 Bytes - ML-KEM-768: encap_key = 1184 Bytes, decap_key = 2400 Bytes - ML-KEM-1024: encap_key = 1568 Bytes, decap_key = 3168 Bytes\n(ciphertext, kem_shared_key) = ENCAPS(encap_key) : Bob berechnet das Chiffrat und den gemeinsamen Schlüssel unter Verwendung des in der NS-Nachricht empfangenen Kapselungsschlüssels. Das Chiffrat wird in der NSR-Nachricht gesendet. Chiffratgrößen: - ML-KEM-512: 768 Bytes - ML-KEM-768: 1088 Bytes - ML-KEM-1024: 1568 Bytes\nkem_shared_key ist bei allen drei Varianten immer 32 Byte groß.\nkem_shared_key = DECAPS(ciphertext, decap_key) : Alice berechnet den gemeinsamen Schlüssel mithilfe des in der NSR-Nachricht empfangenen Chiffrats. Der kem_shared_key ist immer 32 Bytes.\nWichtig: Sowohl der encap_key als auch das Chiffrat sind innerhalb von ChaCha20-Poly1305-Blöcken in den Noise-Handshake-Nachrichten 1 und 2 verschlüsselt. Sie werden im Rahmen des Handshake-Prozesses entschlüsselt.\nDer kem_shared_key wird mit MixKey() in den Verkettungsschlüssel eingemischt. Siehe unten für Details.\nKDF (Schlüsselableitungsfunktion) des Noise-Handshakes Übersicht Der hybride Handshake kombiniert klassisches X25519-ECDH mit Post-Quanten-ML-KEM. Die erste Nachricht, von Alice an Bob, enthält e1 (den ML-KEM-Kapselungsschlüssel) vor der Nutzlast der Nachricht. Dies wird als zusätzliches Schlüsselmaterial behandelt; führen Sie EncryptAndHash() darauf aus (als Alice) oder DecryptAndHash() (als Bob). Verarbeiten Sie anschließend die Nutzlast der Nachricht wie üblich.\nDie zweite Nachricht, von Bob an Alice, enthält ekem1 (den ML-KEM-Chiffretext) vor dem Nachrichteninhalt. Dies wird als zusätzliches Schlüsselmaterial behandelt; rufe EncryptAndHash() darauf auf (als Bob) bzw. DecryptAndHash() (als Alice). Berechne dann den kem_shared_key und rufe MixKey(kem_shared_key) auf. Anschließend den Nachrichteninhalt wie üblich verarbeiten.\nNoise (Protokoll-Framework)-Kennungen Dies sind die Initialisierungs-Strings von Noise (Kryptografieprotokoll) (I2P-spezifisch):\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 Alice-KDF für NS-Nachricht Fügen Sie nach dem Nachrichtenmuster \u0026rsquo;es\u0026rsquo; und vor dem Nachrichtenmuster \u0026rsquo;s\u0026rsquo; Folgendes hinzu:\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). Bobs KDF für NS-Nachricht Fügen Sie nach dem Nachrichtenmuster \u0026rsquo;es\u0026rsquo; und vor dem Nachrichtenmuster \u0026rsquo;s\u0026rsquo; Folgendes hinzu:\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). Bob KDF (Schlüsselableitungsfunktion) für NSR-Nachricht Fügen Sie nach dem Nachrichtenmuster \u0026rsquo;ee\u0026rsquo; und vor dem Nachrichtenmuster \u0026lsquo;se\u0026rsquo; hinzu:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. Alice-KDF für NSR-Nachricht Fügen Sie nach dem \u0026rsquo;ee\u0026rsquo;-Nachrichtenmuster und vor dem \u0026lsquo;ss\u0026rsquo;-Nachrichtenmuster Folgendes hinzu:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. Schlüsselableitungsfunktion (KDF) für split() Die Funktion split() entspricht unverändert der ECIES-Standardspezifikation (ECIES: Elliptic Curve Integrated Encryption Scheme, ein Verschlüsselungsverfahren auf Basis elliptischer Kurven). Nach Abschluss des Handshakes:\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] Dies sind die bidirektionalen Sitzungsschlüssel für die laufende Kommunikation.\nNachrichtenformat NS (Neue Sitzung) Format Änderungen: Im aktuellen Ratchet (Schlüsselfortschaltung) befindet sich der statische Schlüssel im ersten ChaCha20-Poly1305-Abschnitt und die Nutzlast im zweiten Abschnitt. Mit ML-KEM gibt es nun drei Abschnitte. Der erste Abschnitt enthält den verschlüsselten öffentlichen ML-KEM-Schlüssel (encap_key). Der zweite Abschnitt enthält den statischen Schlüssel. Der dritte Abschnitt enthält die Nutzlast.\nNachrichtengrößen:\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl **Hinweis:** Die Nutzlast muss einen DateTime-Block enthalten (mindestens 7 Bytes: 1-Byte-Typ, 2-Byte-Größe, 4-Byte-Zeitstempel). Die minimalen NS-Größen können entsprechend berechnet werden. Die minimale praktische NS-Größe beträgt daher 103 Bytes für X25519 und liegt bei hybriden Varianten zwischen 919 und 1687 Bytes. Die Größenzunahmen um 816, 1200 und 1584 Byte bei den drei ML-KEM-Varianten gehen auf den öffentlichen Schlüssel von ML-KEM sowie einen 16-Byte-Poly1305-MAC für authentifizierte Verschlüsselung zurück.\nNSR (Neue Sitzungsantwort) Format Änderungen: Die aktuelle ratchet (Schlüssel-Update-Mechanismus) hat für den ersten ChaCha20-Poly1305-Abschnitt eine leere Nutzlast und die Nutzlast im zweiten Abschnitt. Mit ML-KEM gibt es nun drei Abschnitte. Der erste Abschnitt enthält das verschlüsselte ML-KEM-Chiffrat. Der zweite Abschnitt hat eine leere Nutzlast. Der dritte Abschnitt enthält die Nutzlast.\nNachrichtengrößen:\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl Die Größenzunahmen um 784, 1104 und 1584 Byte bei den drei ML-KEM-Varianten ergeben sich aus dem ML-KEM-Chiffrat plus einem 16-Byte-Poly1305-MAC für authentifizierte Verschlüsselung. Overhead-Analyse Schlüsselaustausch Der Overhead der Hybridverschlüsselung ist im Vergleich zu X25519 allein erheblich:\nMLKEM512_X25519: Ungefähr 9-12x Zunahme der Größe der Handshake-Nachrichten (NS: 9.5x, NSR: 11.9x) MLKEM768_X25519: Ungefähr 13-16x Zunahme der Größe der Handshake-Nachrichten (NS: 13.5x, NSR: 16.3x) MLKEM1024_X25519: Ungefähr 17-23x Zunahme der Größe der Handshake-Nachrichten (NS: 17.5x, NSR: 23x) Dieser Overhead ist angesichts der zusätzlichen Post-Quanten-Sicherheitsvorteile akzeptabel. Die Multiplikatoren variieren je nach Nachrichtentyp, da sich die Basisgrößen der Nachrichten unterscheiden (NS mindestens 96 Byte, NSR mindestens 72 Byte).\nÜberlegungen zur Bandbreite Für einen typischen Sitzungsaufbau mit minimaler Nutzlast:\nNur X25519: ~200 Bytes insgesamt (NS + NSR) MLKEM512_X25519: ~1,800 Bytes insgesamt (9-facher Anstieg) MLKEM768_X25519: ~2,500 Bytes insgesamt (12,5-facher Anstieg) MLKEM1024_X25519: ~3,400 Bytes insgesamt (17-facher Anstieg) Nach dem Sitzungsaufbau verwendet die fortlaufende Nachrichtenverschlüsselung dasselbe Datenübertragungsformat wie reine X25519-Sitzungen, sodass für nachfolgende Nachrichten kein Overhead anfällt.\nSicherheitsanalyse Handshakes Der hybride Handshake bietet sowohl klassische Sicherheit (X25519) als auch Post-Quanten-Sicherheit (ML-KEM). Ein Angreifer muss beide, sowohl das klassische ECDH als auch das Post-Quanten-KEM, brechen, um die Sitzungsschlüssel zu kompromittieren.\nDies bietet: - Aktuelle Sicherheit: X25519 ECDH bietet Schutz gegen klassische Angreifer (Sicherheitsniveau von 128 Bit) - Zukünftige Sicherheit: ML-KEM (Post-Quanten-Schlüsselkapselungsmechanismus) bietet Schutz gegen Quantenangreifer (variiert je nach Parametersatz) - Hybride Sicherheit: Beide müssen gebrochen werden, um die Sitzung zu kompromittieren (Sicherheitsniveau = Maximum beider Komponenten)\nSicherheitsstufen Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit **Hinweis:** Das hybride Sicherheitsniveau wird durch die schwächere der beiden Komponenten begrenzt. In allen Fällen bietet X25519 eine klassische Sicherheit von 128 Bit. Wenn ein kryptografisch relevanter Quantencomputer verfügbar wird, hängt das Sicherheitsniveau vom gewählten ML‑KEM (Modul‑Gitter‑basierter Schlüsselkapselungsmechanismus)‑Parametersatz ab. Vorwärtsgeheimnis Der hybride Ansatz wahrt die Eigenschaften der Vorwärtsgeheimhaltung. Sitzungsschlüssel werden aus beiden ephemeren Schlüsselaustauschverfahren, X25519 und ML-KEM, abgeleitet. Wenn entweder die ephemeren X25519- oder ML-KEM-Privatschlüssel nach dem Handshake vernichtet werden, können frühere Sitzungen nicht entschlüsselt werden, selbst wenn langfristige statische Schlüssel kompromittiert sind.\nDas IK pattern (IK-Muster) bietet vollständige Vorwärtsgeheimhaltung (Noise Confidentiality level 5), nachdem die zweite Nachricht (NSR) gesendet wurde.\nTyp-Einstellungen Implementierungen sollten mehrere Hybridtypen unterstützen und die stärkste gegenseitig unterstützte Variante aushandeln. Die Präferenzreihenfolge sollte wie folgt sein:\nMLKEM768_X25519 (Typ 6) - Empfohlene Voreinstellung, bestes Gleichgewicht zwischen Sicherheit und Leistung MLKEM1024_X25519 (Typ 7) - Höchste Sicherheit für sensible Anwendungen MLKEM512_X25519 (Typ 5) - Grundlegende Post-Quanten-Sicherheit für ressourcenbeschränkte Szenarien X25519 (Typ 4) - Nur klassisch, Fallback für Kompatibilität Begründung: MLKEM768_X25519 wird als Standard empfohlen, weil es Sicherheit der NIST-Kategorie 3 (entspricht AES-192) bietet, die als ausreichender Schutz gegen Quantencomputer gilt, und dabei angemessene Nachrichtengrößen beibehält. MLKEM1024_X25519 bietet eine höhere Sicherheit, verursacht jedoch einen erheblich höheren Overhead.\nImplementierungshinweise Bibliotheksunterstützung Java: Bouncycastle-Bibliothek Version 1.79 (August 2024) und neuer unterstützt alle erforderlichen ML-KEM-Varianten und SHA3/SHAKE-Funktionen. Verwenden Sie org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine zur Einhaltung von FIPS 203. C++: OpenSSL 3.5 (April 2025) und neuer enthält Unterstützung für ML-KEM über die EVP_KEM-Schnittstelle. Dies ist eine Version mit Langzeitunterstützung (LTS), die bis April 2030 gepflegt wird. Go: Es sind mehrere Drittanbieterbibliotheken für ML-KEM und SHA3 verfügbar, darunter die CIRCL-Bibliothek von Cloudflare. Migrationsstrategie Implementierungen sollten: 1. In der Übergangsphase sowohl X25519-only als auch hybride ML-KEM-Varianten unterstützen 2. Hybride Varianten bevorzugen, wenn beide Peers sie unterstützen 3. Ein Fallback auf X25519-only zur Abwärtskompatibilität beibehalten 4. Einschränkungen der Netzwerkbandbreite bei der Auswahl der Standardvariante berücksichtigen\nGemeinsame Tunnels Die erhöhten Nachrichtengrößen können die Nutzung gemeinsam genutzter tunnel beeinträchtigen. Implementierungen sollten Folgendes in Betracht ziehen: - Handshakes nach Möglichkeit bündeln, um den Overhead zu amortisieren - Kürzere Ablaufzeiten für hybride Sitzungen verwenden, um den gespeicherten Zustand zu verringern - Die Bandbreitennutzung überwachen und die Parameter entsprechend anpassen - Eine Überlastkontrolle für den Datenverkehr beim Sitzungsaufbau implementieren\nÜberlegungen zur Größe neuer Sitzungen Aufgrund der größeren Handshake-Nachrichten müssen Implementierungen möglicherweise Folgendes tun: - Die Puffergrößen für die Sitzungsaushandlung erhöhen (mindestens 4KB empfohlen) - Timeout-Werte für langsamere Verbindungen anpassen (~3-17x größere Nachrichten berücksichtigen) - Komprimierung für Nutzdaten in NS/NSR-Nachrichten in Erwägung ziehen - Fragmentierungsbehandlung implementieren, falls von der Transportschicht erforderlich\nTests und Validierung Implementierungen sollten überprüfen: - Korrekte ML-KEM-Schlüsselgenerierung, Kapselung und Entkapselung - Korrekte Integration von kem_shared_key in die Noise KDF - Berechnungen der Nachrichtengröße entsprechen der Spezifikation - Interoperabilität mit anderen I2P router-Implementierungen - Fallback-Verhalten, wenn ML-KEM nicht verfügbar ist\nTestvektoren für ML-KEM-Operationen stehen im NIST Cryptographic Algorithm Validation Program zur Verfügung.\nVersionskompatibilität I2P-Versionsnummerierung: I2P führt zwei parallele Versionsnummern: - Router-Release-Version: 2.x.x-Format (z. B. 2.10.0, veröffentlicht im September 2025) - API/Protokoll-Version: 0.9.x-Format (z. B. 0.9.67 entspricht router 2.10.0)\nDiese Spezifikation verweist auf die Protokollversion 0.9.67, die dem router-Release 2.10.0 und neuer entspricht.\nKompatibilitätsmatrix:\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release ## Referenzen [ECIES]: ECIES-X25519-AEAD-Ratchet-Spezifikation [Prop169]: Vorschlag 169: Post-Quanten-Kryptografie [FIPS203]: NIST FIPS 203 - ML-KEM-Standard [FIPS202]: NIST FIPS 202 - SHA-3-Standard [Noise]: Noise-Protokoll-Framework [COMMON]: Spezifikation gemeinsamer Strukturen [RFC7539]: RFC 7539 - ChaCha20 und Poly1305 [RFC5869]: RFC 5869 - HKDF [OpenSSL]: OpenSSL 3.5 ML-KEM-Dokumentation [Bouncycastle]: Bouncycastle Java-Kryptografie-Bibliothek ","description":"Post-Quanten-hybride Variante des Verschlüsselungsprotokolls ECIES (integriertes Verschlüsselungsverfahren mit elliptischen Kurven) unter Verwendung von ML-KEM (Modul-Gitter-basiertes Schlüsselkapselungsverfahren)","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"Hybride Verschlüsselung mit ECIES-X25519-AEAD-Ratchet","url":"/de/docs/specs/ecies-hybrid/"},{"categories":null,"content":"Das I2P-Projekt pflegt offizielle Pakete für Debian, Ubuntu und deren abgeleitete Distributionen. Diese Anleitung bietet umfassende Anleitungen zur Installation von I2P unter Verwendung unserer offiziellen Repositories.\n🚀 Beta: Automatische Installation (Experimentell) Für fortgeschrittene Benutzer, die eine schnelle automatisierte Installation wünschen:\nDieser Einzeiler erkennt automatisch Ihre Distribution und installiert I2P. Mit Vorsicht verwenden - überprüfen Sie das Installationsskript vor der Ausführung.\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash Was dies tut: - Erkennt Ihre Linux-Distribution (Ubuntu/Debian) - Fügt das entsprechende I2P-Repository hinzu - Installiert GPG-Schlüssel und erforderliche Pakete - Installiert I2P automatisch\n⚠️ Dies ist eine Beta-Funktion. Wenn Sie die manuelle Installation bevorzugen oder jeden Schritt verstehen möchten, verwenden Sie die unten aufgeführten manuellen Installationsmethoden.\nUnterstützte Plattformen Die Debian-Pakete sind kompatibel mit:\nUbuntu 18.04 (Bionic) und neuer Linux Mint 19 (Tara) und neuer Debian Buster (10) und neuer Knoppix Andere Debian-basierte Distributionen (LMDE, ParrotOS, Kali Linux, etc.) Unterstützte Architekturen: amd64, i386, armhf, arm64, powerpc, ppc64el, s390x\nDie I2P-Pakete funktionieren möglicherweise auch auf anderen Debian-basierten Systemen, die oben nicht ausdrücklich aufgeführt sind. Wenn Sie auf Probleme stoßen, melden Sie diese bitte in unserem GitLab .\nInstallationsmethoden Wählen Sie die Installationsmethode, die zu Ihrer Distribution passt:\nOption 1: Ubuntu und Derivate (Linux Mint, elementary OS, Pop!_OS, etc.) Option 2: Debian und Debian-basierte Distributionen (einschließlich LMDE, Kali, ParrotOS) Ubuntu Installation Ubuntu und seine offiziellen Derivate (Linux Mint, elementary OS, Trisquel, etc.) können das I2P PPA (Personal Package Archive) für eine einfache Installation und automatische Updates nutzen.\nMethod 1: Command Line Installation (Recommended) Dies ist die schnellste und zuverlässigste Methode zur Installation von I2P auf Ubuntu-basierten Systemen.\nSchritt 1: Das I2P PPA hinzufügen\nÖffnen Sie ein Terminal und führen Sie aus:\nsudo apt-add-repository ppa:i2p-maintainers/i2p Dieser Befehl fügt das I2P PPA zu /etc/apt/sources.list.d/ hinzu und importiert automatisch den GPG-Schlüssel, der das Repository signiert. Die GPG-Signatur stellt sicher, dass die Pakete seit ihrem Build nicht manipuliert wurden.\nSchritt 2: Paketliste aktualisieren\nAktualisieren Sie die Paketdatenbank Ihres Systems, um das neue PPA einzubeziehen:\nsudo apt-get update Dies ruft die neuesten Paketinformationen von allen aktivierten Repositorys ab, einschließlich des soeben hinzugefügten I2P PPA.\nSchritt 3: I2P installieren\nJetzt I2P installieren:\nsudo apt-get install i2p Das war\u0026rsquo;s! Fahren Sie mit dem Abschnitt Konfiguration nach der Installation fort, um zu erfahren, wie Sie I2P starten und konfigurieren.\nMethod 2: Using the Software Center GUI Wenn Sie eine grafische Benutzeroberfläche bevorzugen, können Sie das PPA über Ubuntu\u0026rsquo;s Software Center hinzufügen.\nSchritt 1: Software \u0026amp; Aktualisierungen öffnen\nStarten Sie „Software und Aktualisierungen\u0026quot; aus Ihrem Anwendungsmenü.\nSchritt 2: Navigieren Sie zu Andere Software\nWählen Sie den Tab \u0026ldquo;Andere Software\u0026rdquo; aus und klicken Sie auf die Schaltfläche \u0026ldquo;Hinzufügen\u0026rdquo; am unteren Rand, um ein neues PPA zu konfigurieren.\nSchritt 3: I2P PPA hinzufügen\nIm PPA-Dialogfeld eingeben:\nppa:i2p-maintainers/i2p Schritt 4: Repository-Informationen neu laden\nKlicken Sie auf die Schaltfläche „Neu laden\u0026quot;, um die aktualisierten Repository-Informationen herunterzuladen.\nSchritt 5: I2P installieren\nÖffnen Sie die Anwendung \u0026ldquo;Software\u0026rdquo; aus Ihrem Anwendungsmenü, suchen Sie nach \u0026ldquo;i2p\u0026rdquo; und klicken Sie auf Installieren.\nSobald die Installation abgeschlossen ist, fahren Sie mit der Konfiguration nach der Installation fort.\nDebian Installation Debian und dessen nachgelagerte Distributionen (LMDE, Kali Linux, ParrotOS, Knoppix, etc.) sollten das offizielle I2P Debian-Repository unter deb.i2p.net verwenden.\nImportant Notice Unsere alten Repositories unter deb.i2p2.de und deb.i2p2.no haben das Ende ihrer Lebensdauer erreicht. Falls Sie diese veralteten Repositories verwenden, folgen Sie bitte den untenstehenden Anweisungen, um zum neuen Repository unter deb.i2p.net zu migrieren.\nPrerequisites Alle folgenden Schritte erfordern Root-Zugriff. Wechseln Sie entweder mit su zum Root-Benutzer oder stellen Sie jedem Befehl sudo voran.\nMethode 1: Installation über die Kommandozeile (Empfohlen) Schritt 1: Erforderliche Pakete installieren\nStellen Sie sicher, dass Sie die notwendigen Tools installiert haben:\nsudo apt-get update sudo apt-get install apt-transport-https lsb-release curl Diese Pakete ermöglichen sicheren HTTPS-Repository-Zugriff, Distributionserkennung und Dateidownloads.\nSchritt 2: Fügen Sie das I2P-Repository hinzu\nDer Befehl, den Sie verwenden, hängt von Ihrer Debian-Version ab. Bestimmen Sie zunächst, welche Version Sie verwenden:\ncat /etc/debian_version Vergleichen Sie dies mit den Debian-Veröffentlichungsinformationen , um den Codenamen Ihrer Distribution zu identifizieren (z. B. Bookworm, Bullseye, Buster).\nFür Debian Bullseye (11) oder neuer:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Für Debian-Derivate (LMDE, Kali, ParrotOS, etc.) auf Bullseye-Äquivalent oder neueren Versionen:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Für Debian Buster (10) oder älter:\necho \u0026#34;deb https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Für Debian-Derivate auf Buster-Äquivalent oder älter:\necho \u0026#34;deb https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Schritt 3: Repository-Signaturschlüssel herunterladen\ncurl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg Schritt 4: Den Schlüssel-Fingerabdruck überprüfen\nÜberprüfen Sie vor dem Vertrauen des Schlüssels, ob sein Fingerabdruck mit dem offiziellen I2P-Signaturschlüssel übereinstimmt:\ngpg --keyid-format long --import --import-options show-only --with-fingerprint i2p-archive-keyring.gpg Überprüfen Sie, ob die Ausgabe diesen Fingerprint zeigt:\n7840 E761 0F28 B904 7535 49D7 67EC E560 5BCF 1346 ⚠️ Fahren Sie nicht fort, wenn der Fingerabdruck nicht übereinstimmt. Dies könnte auf einen kompromittierten Download hinweisen.\nSchritt 5: Repository-Schlüssel installieren\nKopieren Sie den verifizierten Keyring in das System-Keyring-Verzeichnis:\nsudo cp i2p-archive-keyring.gpg /usr/share/keyrings Nur für Debian Buster oder älter müssen Sie zusätzlich einen Symlink erstellen:\nsudo ln -sf /usr/share/keyrings/i2p-archive-keyring.gpg /etc/apt/trusted.gpg.d/i2p-archive-keyring.gpg Schritt 6: Paketlisten aktualisieren\nAktualisieren Sie die Paketdatenbank Ihres Systems, um das I2P-Repository einzubeziehen:\nsudo apt-get update Schritt 7: I2P installieren\nInstallieren Sie sowohl das I2P-Router-Paket als auch das Keyring-Paket (welches sicherstellt, dass Sie zukünftige Schlüssel-Updates erhalten):\nsudo apt-get install i2p i2p-keyring Großartig! I2P ist jetzt installiert. Fahren Sie mit dem Abschnitt Konfiguration nach der Installation fort.\nIch verstehe die Anweisungen. Ich bin bereit, den zu übersetzenden Text zu empfangen. Bitte geben Sie den Text an, den ich vom Englischen ins Deutsche übersetzen soll.\nPost-Installation Configuration Nach der Installation von I2P müssen Sie den Router starten und einige anfängliche Konfigurationen vornehmen.\nMethode 2: Verwendung der Software Center GUI Die I2P-Pakete bieten drei Möglichkeiten, den I2P-Router zu betreiben:\nOption 1: On-Demand (Basic) Starten Sie I2P bei Bedarf manuell mit dem i2prouter-Skript:\ni2prouter start Wichtig: Verwenden Sie nicht sudo und führen Sie dies nicht als root aus! I2P sollte als Ihr regulärer Benutzer ausgeführt werden.\nSo beenden Sie I2P:\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) Wenn Sie ein Nicht-x86-System verwenden oder der Java Service Wrapper auf Ihrer Plattform nicht funktioniert, nutzen Sie:\ni2prouter-nowrapper Auch hier gilt: Verwenden Sie nicht sudo und führen Sie dies nicht als root aus.\nOption 3: System Service (Recommended) Für die beste Erfahrung konfigurieren Sie I2P so, dass es automatisch beim Systemstart startet, noch vor der Anmeldung:\nsudo dpkg-reconfigure i2p Dies öffnet einen Konfigurationsdialog. Wählen Sie \u0026ldquo;Ja\u0026rdquo;, um I2P als Systemdienst zu aktivieren.\nDies ist die empfohlene Methode, weil: - I2P automatisch beim Systemstart gestartet wird - Ihr Router eine bessere Netzwerkintegration aufrechterhält - Sie zur Netzwerkstabilität beitragen - I2P sofort verfügbar ist, wenn Sie es benötigen\nInitial Router Configuration Nachdem I2P zum ersten Mal gestartet wurde, dauert es einige Minuten, bis es sich in das Netzwerk integriert hat. Konfigurieren Sie in der Zwischenzeit diese wichtigen Einstellungen:\n1. Configure NAT/Firewall Für optimale Leistung und Netzwerkteilnahme leiten Sie die I2P-Ports durch Ihr NAT/Ihre Firewall weiter:\nÖffnen Sie die I2P Router Console Navigieren Sie zur Netzwerkkonfigurationsseite Notieren Sie die aufgelisteten Portnummern (normalerweise zufällige Ports zwischen 9000-31000) Leiten Sie diese UDP- und TCP-Ports in Ihrem Router/Ihrer Firewall weiter Wenn Sie Hilfe beim Port-Forwarding benötigen, bietet portforward.com routerspezifische Anleitungen.\n2. Adjust Bandwidth Settings Die Standard-Bandbreiteneinstellungen sind konservativ. Passen Sie diese basierend auf Ihrer Internetverbindung an:\nBesuchen Sie die Konfigurationsseite Suchen Sie den Abschnitt für Bandbreiteneinstellungen Die Standardwerte sind 96 KB/s Download / 40 KB/s Upload Erhöhen Sie diese Werte, wenn Sie eine schnellere Internetverbindung haben (z.B. 250 KB/s Download / 100 KB/s Upload für eine typische Breitbandverbindung) Hinweis: Höhere Limits helfen dem Netzwerk und verbessern Ihre eigene Leistung.\n3. Configure Your Browser Um auf I2P-Seiten (eepsites) und Dienste zuzugreifen, konfigurieren Sie Ihren Browser so, dass er den HTTP-Proxy von I2P verwendet:\nSiehe unsere Anleitung zur Browser-Konfiguration für detaillierte Einrichtungsanleitungen für Firefox, Chrome und andere Browser.\nDebian-Installation Wichtiger Hinweis Stellen Sie sicher, dass I2P nicht als root läuft: ps aux | grep i2p Logs überprüfen: tail -f ~/.i2p/wrapper.log Überprüfen Sie, ob Java installiert ist: java -version Voraussetzungen Wenn Sie während der Installation GPG-Schlüsselfehler erhalten:\nLaden Sie den Schlüssel erneut herunter und überprüfen Sie den Fingerabdruck (Schritte 3-4 oben) Stellen Sie sicher, dass die Keyring-Datei die richtigen Berechtigungen hat: sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg Installationsschritte Wenn I2P keine Updates erhält:\nRepository-Konfiguration überprüfen: cat /etc/apt/sources.list.d/i2p.list Paketlisten aktualisieren: sudo apt-get update Nach I2P-Updates suchen: sudo apt-get upgrade Migrating from old repositories Wenn Sie die alten Repositories deb.i2p2.de oder deb.i2p2.no verwenden:\nEntfernen Sie das alte Repository: sudo rm /etc/apt/sources.list.d/i2p.list Folgen Sie den Debian-Installations -Schritten oben Aktualisieren Sie: sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring Next Steps Jetzt, da I2P installiert ist und läuft:\nKonfigurieren Sie Ihren Browser , um auf I2P-Seiten zuzugreifen Erkunden Sie die I2P-Router-Konsole , um Ihren Router zu überwachen Erfahren Sie mehr über I2P-Anwendungen , die Sie nutzen können Lesen Sie, wie I2P funktioniert , um das Netzwerk zu verstehen Willkommen im Invisible Internet!\n","description":"Vollständige Anleitung zur Installation von I2P auf Debian, Ubuntu und deren Derivaten unter Verwendung der offiziellen Repositories","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"I2P auf Debian und Ubuntu installieren","url":"/de/docs/guides/i2p-auf-debian-und-ubuntu-installieren/"},{"categories":null,"content":"Was Sie benötigen Ein Mac mit macOS 10.14 (Mojave) oder neuer Administratorrechte zur Installation von Anwendungen Etwa 15-20 Minuten Zeit Internetverbindung zum Herunterladen der Installationsprogramme Übersicht Dieser Installationsprozess hat vier Hauptschritte:\nJava installieren - Laden Sie die Oracle Java Runtime Environment herunter und installieren Sie sie I2P installieren - Laden Sie das I2P-Installationsprogramm herunter und führen Sie es aus I2P-App konfigurieren - Richten Sie den Launcher ein und fügen Sie ihn zu Ihrem Dock hinzu I2P-Bandbreite konfigurieren - Führen Sie den Einrichtungsassistenten aus, um Ihre Verbindung zu optimieren Teil Eins: Java installieren I2P benötigt Java, um zu laufen. Wenn Sie bereits Java 8 oder neuer installiert haben, können Sie zu Teil Zwei springen .\nStep 1: Download Java Besuchen Sie die Oracle Java Download-Seite und laden Sie das macOS-Installationsprogramm für Java 8 oder höher herunter.\nStep 2: Run the Installer Suchen Sie die heruntergeladene .dmg-Datei in Ihrem Downloads-Ordner und doppelklicken Sie darauf, um sie zu öffnen.\nStep 3: Allow Installation macOS zeigt möglicherweise eine Sicherheitsmeldung an, da das Installationsprogramm von einem identifizierten Entwickler stammt. Klicken Sie auf Öffnen, um fortzufahren.\nSchritt 1: Java herunterladen Klicken Sie auf Installieren, um den Java-Installationsprozess zu starten.\nSchritt 2: Installationsprogramm ausführen Der Installer wird Dateien kopieren und Java auf Ihrem System konfigurieren. Dies dauert in der Regel 1-2 Minuten.\nSchritt 3: Installation erlauben Wenn Sie die Erfolgsmeldung sehen, ist Java installiert! Klicken Sie auf Schließen, um den Vorgang abzuschließen.\nPart Two: Download and Install I2P Nachdem Java installiert ist, können Sie den I2P Router installieren.\nSchritt 4: Java installieren Besuchen Sie die Downloads-Seite und laden Sie das Installationsprogramm I2P für Unix/Linux/BSD/Solaris herunter (die .jar-Datei).\nSchritt 5: Warten Sie auf die Installation Doppelklicken Sie auf die heruntergeladene Datei i2pinstall_X.X.X.jar. Der Installer wird gestartet und fordert Sie auf, Ihre bevorzugte Sprache auszuwählen.\nSchritt 6: Installation abgeschlossen Lesen Sie die Willkommensnachricht und klicken Sie auf Weiter, um fortzufahren.\nStep 4: Important Notice Der Installer zeigt einen wichtigen Hinweis zu Updates an. I2P-Updates sind Ende-zu-Ende signiert und verifiziert, auch wenn dieser Installer selbst nicht signiert ist. Klicken Sie auf Weiter.\nSchritt 1: I2P herunterladen Lesen Sie die I2P-Lizenzvereinbarung (BSD-artige Lizenz). Klicken Sie auf Weiter, um zu akzeptieren.\nSchritt 2: Installationsprogramm ausführen Wählen Sie aus, wo I2P installiert werden soll. Der Standardspeicherort (/Applications/i2p) wird empfohlen. Klicken Sie auf Weiter.\nSchritt 3: Willkommensbildschirm Lassen Sie alle Komponenten für eine vollständige Installation ausgewählt. Klicken Sie auf Weiter.\nSchritt 4: Wichtiger Hinweis Überprüfen Sie Ihre Auswahl und klicken Sie auf Weiter, um die Installation von I2P zu starten.\nSchritt 5: Lizenzvereinbarung Der Installer kopiert die I2P-Dateien auf Ihr System. Dies dauert etwa 1-2 Minuten.\nSchritt 6: Installationsverzeichnis auswählen Der Installer erstellt Startskripte zum Starten von I2P.\nSchritt 7: Komponenten auswählen Der Installer bietet an, Desktop-Verknüpfungen und Menüeinträge zu erstellen. Treffen Sie Ihre Auswahl und klicken Sie auf Weiter.\nSchritt 8: Installation starten Erfolg! I2P ist jetzt installiert. Klicken Sie auf Fertig, um den Vorgang abzuschließen.\nPart Three: Configure I2P App Lassen Sie uns nun I2P durch Hinzufügen zum Programme-Ordner und Dock einfach starten.\nSchritt 9: Dateien installieren Öffnen Sie den Finder und navigieren Sie zu Ihrem Programme-Ordner.\nSchritt 10: Startskripte generieren Suchen Sie nach dem I2P-Ordner oder der Anwendung Start I2P Router in /Applications/i2p/.\nSchritt 11: Installationsverknüpfungen Ziehen Sie die Anwendung Start I2P Router in Ihr Dock für einfachen Zugriff. Sie können auch ein Alias auf Ihrem Schreibtisch erstellen.\nTipp: Klicken Sie mit der rechten Maustaste auf das I2P-Symbol im Dock und wählen Sie Optionen → Im Dock behalten, um es dauerhaft zu fixieren.\nPart Four: Configure I2P Bandwidth Wenn Sie I2P zum ersten Mal starten, durchlaufen Sie einen Einrichtungsassistenten, um Ihre Bandbreiteneinstellungen zu konfigurieren. Dies hilft dabei, die Leistung von I2P für Ihre Verbindung zu optimieren.\nSchritt 12: Installation abgeschlossen Klicken Sie auf das I2P-Symbol in Ihrem Dock (oder doppelklicken Sie auf das Startprogramm). Ihr Standard-Webbrowser öffnet sich mit der I2P Router Console.\nStep 2: Welcome Wizard Der Setup-Assistent begrüßt Sie. Klicken Sie auf Weiter, um mit der Konfiguration von I2P zu beginnen.\nSchritt 1: Ordner „Programme\u0026quot; öffnen Wählen Sie Ihre bevorzugte Oberflächensprache und wählen Sie zwischen hellem oder dunklem Design. Klicken Sie auf Weiter.\nSchritt 2: I2P Launcher finden Der Wizard erklärt den Bandbreitentest. Dieser Test verbindet sich mit dem M-Lab-Dienst, um Ihre Internetgeschwindigkeit zu messen. Klicken Sie auf Weiter, um fortzufahren.\nSchritt 3: Zum Dock hinzufügen Klicken Sie auf Test ausführen, um Ihre Upload- und Download-Geschwindigkeiten zu messen. Der Test dauert etwa 30-60 Sekunden.\nStep 6: Test Results Überprüfen Sie Ihre Testergebnisse. I2P wird Bandbreiteneinstellungen basierend auf Ihrer Verbindungsgeschwindigkeit empfehlen.\nSchritt 1: I2P starten Wählen Sie aus, wie viel Bandbreite Sie mit dem I2P-Netzwerk teilen möchten:\nAutomatisch (Empfohlen): I2P verwaltet die Bandbreite basierend auf Ihrer Nutzung Begrenzt: Legen Sie spezifische Upload-/Download-Limits fest Unbegrenzt: Teilen Sie so viel wie möglich (für schnelle Verbindungen) Klicken Sie auf Weiter, um Ihre Einstellungen zu speichern.\nSchritt 2: Willkommens-Assistent Ihr I2P-Router ist jetzt konfiguriert und läuft! Die Router-Konsole zeigt Ihren Verbindungsstatus an und ermöglicht Ihnen das Browsen von I2P-Sites.\nGetting Started with I2P Nachdem I2P installiert und konfiguriert ist, können Sie:\nI2P-Seiten durchsuchen: Besuchen Sie die I2P-Homepage , um Links zu beliebten I2P-Diensten zu sehen Browser konfigurieren: Richten Sie ein Browser-Profil ein, um auf .i2p-Seiten zuzugreifen Dienste erkunden: Entdecken Sie I2P-E-Mail, Foren, Filesharing und mehr Router überwachen: Die Konsole zeigt Ihren Netzwerkstatus und Statistiken an Schritt 3: Sprache und Theme Router Console: http://127.0.0.1:7657/ Konfiguration: http://127.0.0.1:7657/config Adressbuch: http://127.0.0.1:7657/susidns/addressbook Bandbreiteneinstellungen: http://127.0.0.1:7657/config Re-running the Setup Wizard Wenn Sie Ihre Bandbreiteneinstellungen ändern oder I2P später neu konfigurieren möchten, können Sie den Willkommensassistenten erneut über die Router Console ausführen:\nGehen Sie zum I2P Setup Wizard Folgen Sie den Wizard-Schritten erneut Troubleshooting Schritt 4: Informationen zum Bandbreitentest Java überprüfen: Stellen Sie sicher, dass Java installiert ist, indem Sie java -version im Terminal ausführen Berechtigungen überprüfen: Stellen Sie sicher, dass der I2P-Ordner die richtigen Berechtigungen hat Logs überprüfen: Sehen Sie sich ~/.i2p/wrapper.log auf Fehlermeldungen an Schritt 5: Bandbreitentest durchführen Stelle sicher, dass I2P läuft (prüfe die Router Console) Konfiguriere die Proxy-Einstellungen deines Browsers, um den HTTP-Proxy 127.0.0.1:4444 zu verwenden Warte nach dem Start 5-10 Minuten, bis sich I2P ins Netzwerk integriert hat Schritt 6: Testergebnisse Führen Sie den Bandbreitentest erneut aus und passen Sie Ihre Einstellungen an Stellen Sie sicher, dass Sie Bandbreite mit dem Netzwerk teilen Überprüfen Sie Ihren Verbindungsstatus in der Router Console Teil Zwei: I2P herunterladen und installieren Um I2P von Ihrem Mac zu entfernen:\nBeenden Sie den I2P-Router, falls er läuft Löschen Sie den Ordner /Applications/i2p Löschen Sie den Ordner ~/.i2p (Ihre I2P-Konfiguration und -Daten) Entfernen Sie das I2P-Symbol aus Ihrem Dock Next Steps Treten Sie der Community bei: Besuchen Sie i2pforum.net oder schauen Sie sich I2P auf Reddit an Erfahren Sie mehr: Lesen Sie die I2P-Dokumentation , um zu verstehen, wie das Netzwerk funktioniert Beteiligen Sie sich: Erwägen Sie, zur I2P-Entwicklung beizutragen oder Infrastruktur zu betreiben Herzlichen Glückwunsch! Sie sind jetzt Teil des I2P-Netzwerks. Willkommen im unsichtbaren Internet!\nWICHTIG: Stellen Sie KEINE Fragen, geben Sie keine Erklärungen und fügen Sie keine Kommentare hinzu. Auch wenn der Text nur eine Überschrift ist oder unvollständig erscheint, übersetzen Sie ihn wie er ist.\n","description":"Schritt-für-Schritt-Anleitung zur manuellen Installation von I2P und seinen Abhängigkeiten auf macOS","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"I2P auf macOS installieren (Der lange Weg)","url":"/de/docs/guides/i2p-auf-macos-installieren-der-lange-weg/"},{"categories":null,"content":"1. Was \u0026ldquo;Anonym\u0026rdquo; bedeutet I2P bietet praktische Anonymität – keine Unsichtbarkeit. Anonymität ist definiert als die Schwierigkeit für einen Angreifer, Informationen zu erfahren, die Sie privat halten möchten: wer Sie sind, wo Sie sind oder mit wem Sie kommunizieren. Absolute Anonymität ist unmöglich; stattdessen strebt I2P ausreichende Anonymität unter globalen passiven und aktiven Angreifern an.\nIhre Anonymität hängt davon ab, wie Sie I2P konfigurieren, wie Sie Peers und Abonnements auswählen und welche Anwendungen Sie freigeben.\n2. Kryptografische und Transport-Evolution (2003 → 2025) Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental **Aktuelle kryptografische Suite (Noise XK):** - **X25519** für Schlüsselaustausch - **ChaCha20/Poly1305 AEAD** für Verschlüsselung - **Ed25519 (EdDSA-SHA512)** für Signaturen - **SHA-256** für Hashing und HKDF - Optional **ML-KEM-Hybride** für Post-Quantum-Tests Alle ElGamal- und AES-CBC-Verwendungen wurden eingestellt. Der Transport erfolgt vollständig über NTCP2 (TCP) und SSU2 (UDP); beide unterstützen IPv4/IPv6, Forward Secrecy und DPI-Verschleierung.\n3. Übersicht der Netzwerkarchitektur Free-route mixnet: Sender und Empfänger definieren jeweils ihre eigenen tunnel. Keine zentrale Autorität: Routing und Namensauflösung sind dezentralisiert; jeder router pflegt lokales Vertrauen. Unidirektionale tunnel: Eingehende und ausgehende sind getrennt (10 Min. Lebensdauer). Exploratory tunnels: Standardmäßig 2 hops; Client-tunnel 2–3 hops. Floodfill router: ~1 700 von ~55 000 Knoten (~6 %) verwalten die verteilte netDb. NetDB-Rotation: Schlüsselraum rotiert täglich um UTC-Mitternacht. Sub-DB-Isolierung: Seit 2.4.0 verwenden jeder Client und router separate Datenbanken, um Verknüpfungen zu verhindern. 4. Angriffskategorien und aktuelle Schutzmaßnahmen Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. --- 5. Moderne Netzwerkdatenbank (NetDB) Grundlegende Fakten (noch aktuell): - Modifizierter Kademlia DHT speichert RouterInfo und LeaseSets. - SHA-256 Key-Hashing; parallele Abfragen an 2 nächste Floodfills mit 10 s Timeout. - LeaseSet-Lebensdauer ≈ 10 Min. (LeaseSet2) oder 18 Std. (MetaLeaseSet).\nNeue Typen (seit 0.9.38): - LeaseSet2 (Typ 3) – mehrere Verschlüsselungstypen, mit Zeitstempel. - EncryptedLeaseSet2 (Typ 5) – geblendete Destination für private Dienste (DH- oder PSK-Authentifizierung). - MetaLeaseSet (Typ 7) – Multihoming und erweiterte Ablaufzeiten.\nWichtiges Sicherheits-Upgrade – Sub-DB-Isolation (2.4.0): - Verhindert die Zuordnung von router↔Client. - Jeder Client und router verwenden separate netDb-Segmente. - Verifiziert und geprüft (2.5.0).\n6. Versteckter Modus und eingeschränkte Routen Hidden Mode: Implementiert (automatisch in restriktiven Ländern gemäß Freedom House-Bewertungen).\nRouter veröffentlichen keine RouterInfo und leiten keinen Traffic weiter. Restricted Routes: Teilweise implementiert (nur grundlegende trust-basierte tunnel).\nUmfassendes Routing über vertrauenswürdige Peers bleibt geplant (3.0+). Kompromiss: Bessere Privatsphäre ↔ reduzierter Beitrag zur Netzwerkkapazität.\n7. DoS- und Floodfill-Angriffe Historisch: Eine Studie der UCSB aus 2013 zeigte, dass Eclipse- und Floodfill-Übernahmen möglich waren. Moderne Abwehrmaßnahmen umfassen: - Tägliche Keyspace-Rotation. - Floodfill-Obergrenze ≈ 500, eine pro /16. - Randomisierte Verzögerungen bei der Speicherüberprüfung. - Bevorzugung neuerer Router (2.6.0). - Behebung der automatischen Registrierung (2.9.0). - Überlastungsbewusste Routenführung und Lease-Drosselung (2.4.0+).\nFloodfill-Angriffe bleiben theoretisch möglich, sind aber praktisch schwieriger.\n8. Verkehrsanalyse und Zensur I2P-Verkehr ist schwer zu identifizieren: kein fester Port, kein Klartext-Handshake und zufälliges Padding. NTCP2- und SSU2-Pakete ahmen gängige Protokolle nach und verwenden ChaCha20-Header-Verschleierung. Padding-Strategien sind grundlegend (zufällige Größen), Dummy-Traffic ist nicht implementiert (kostspielig). Verbindungen von Tor-Exit-Knoten werden seit Version 2.6.0 blockiert (zum Schutz der Ressourcen).\n9. Dauerhafte Einschränkungen (anerkannt) Timing-Korrelation für Anwendungen mit niedriger Latenz bleibt ein grundlegendes Risiko. Intersection-Angriffe bleiben wirksam gegen bekannte öffentliche Ziele. Sybil-Angriffe haben keine vollständige Abwehr (HashCash wird nicht durchgesetzt). Konstanter Datenverkehr und nichttriviale Verzögerungen bleiben nicht implementiert (geplant für 3.0). Transparenz über diese Grenzen ist beabsichtigt – sie verhindert, dass Benutzer die Anonymität überschätzen.\n10. Netzwerkstatistiken (2025) ~55 000 aktive Router weltweit (↑ von 7 000 im Jahr 2013) ~1 700 floodfill-Router (~6 %) 95 % nehmen standardmäßig am Tunnel-Routing teil Bandbreitenstufen: K (\u0026lt;12 KB/s) → X (\u0026gt;2 MB/s) Minimale floodfill-Rate: 128 KB/s Router-Konsole Java 8+ (erforderlich), Java 17+ für den nächsten Zyklus geplant 11. Entwicklung und zentrale Ressourcen Offizielle Website: geti2p.net Dokumentation: Documentation Debian-Repository: https://deb.i2pgit.org ( hat deb.i2p2.de im Oktober 2023 ersetzt ) Quellcode: https://i2pgit.org/I2P_Developers/i2p.i2p (Gitea) + GitHub-Mirror Alle Releases sind signierte SU3-Container (RSA-4096, zzz/str4d-Schlüssel) Keine aktiven Mailinglisten; Community über https://i2pforum.net und IRC2P. Update-Zyklus: 6–8 Wochen für stabile Releases. 12. Zusammenfassung der Sicherheitsverbesserungen seit 0.8.x Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing --- 13. Bekannte offene oder geplante Arbeiten Umfassende eingeschränkte Routen (trusted-peer routing) → geplant für 3.0. Nicht-triviale Verzögerung/Bündelung für Timing-Resistenz → geplant für 3.0. Erweiterte Padding- und Dummy-Traffic-Mechanismen → nicht implementiert. HashCash-Identitätsverifizierung → Infrastruktur vorhanden, aber inaktiv. R5N DHT-Ersatz → nur als Vorschlag. 14. Wichtige Referenzen Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) Offizielle I2P-Dokumentation 15. Fazit Das zentrale Anonymitätsmodell von I2P besteht seit zwei Jahrzehnten: Verzicht auf globale Eindeutigkeit zugunsten lokalen Vertrauens und lokaler Sicherheit. Von ElGamal zu X25519, NTCP zu NTCP2 und von manuellen Reseeds bis zur Sub-DB-Isolation hat sich das Projekt weiterentwickelt und dabei seine Philosophie der mehrstufigen Verteidigung und Transparenz beibehalten.\nViele Angriffe bleiben theoretisch gegen jedes Mixnet mit geringer Latenz möglich, aber die kontinuierliche Härtung von I2P macht sie zunehmend unpraktisch. Das Netzwerk ist größer, schneller und sicherer als je zuvor – bleibt aber dennoch ehrlich hinsichtlich seiner Grenzen.\n","description":"Katalog der bei der Entwicklung von I2P berücksichtigten Angriffe und die implementierten Gegenmaßnahmen","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"I2P Bedrohungsmodell","url":"/de/docs/overview/threat-model/"},{"categories":null,"content":"Überblick Heute existieren mehrere große Privatsphäre- und Anonymitätsnetzwerke, jedes mit unterschiedlichen Designzielen und Bedrohungsmodellen. Während Tor, Lokinet, GNUnet und Freenet alle wertvolle Ansätze für privatsphärewahrende Kommunikation beitragen, hebt sich I2P als das einzige produktionsreife, paketvermittelte Netzwerk hervor, das vollständig für netzwerkinterne Hidden Services und Peer-to-Peer-Anwendungen optimiert ist.\nDie nachfolgende Tabelle fasst die wichtigsten architektonischen und operativen Unterschiede zwischen diesen Netzwerken Stand 2025 zusammen.\nVergleich von Privatsphäre-Netzwerken (2025) Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) --- Warum I2P bei datenschutzorientiertem Design führend ist 1. Packet Switching \u0026gt; Circuit Switching Tors Circuit-Switched-Modell bindet Traffic an feste Drei-Hop-Pfade – effizient fürs Browsen, aber anfällig für langlebige interne Dienste. I2Ps packet-switched tunnels senden Nachrichten über mehrere gleichzeitige Pfade und routen automatisch um Überlastung oder Ausfälle herum, was zu besserer Verfügbarkeit und Lastverteilung führt.\n2. Unidirectional Tunnels I2P trennt eingehenden und ausgehenden Datenverkehr. Das bedeutet, dass jeder Teilnehmer immer nur die Hälfte eines Kommunikationsflusses sieht, was Timing-Korrelationsangriffe erheblich erschwert. Tor, Lokinet und andere verwenden bidirektionale Verbindungen, bei denen Anfragen und Antworten denselben Pfad nutzen – einfacher, aber leichter nachverfolgbar.\n3. Fully Distributed netDB Die neun Directory Authorities von Tor definieren dessen Netzwerktopologie. I2P verwendet eine sich selbst organisierende Kademlia DHT, die von rotierenden floodfill-Routern gepflegt wird, wodurch zentrale Kontrollpunkte oder Koordinationsserver vollständig entfallen.\n1. Paketvermittlung \u0026gt; Leitungsvermittlung I2P erweitert Onion Routing durch garlic routing, bei dem mehrere verschlüsselte Nachrichten in einen Container gebündelt werden. Dies reduziert Metadaten-Lecks und Bandbreiten-Overhead und verbessert gleichzeitig die Effizienz für Bestätigungs-, Daten- und Kontrollnachrichten.\n2. Unidirektionale Tunnel Jeder I2P-router leitet Datenverkehr für andere weiter. Es gibt keine dedizierten Relay-Betreiber oder privilegierten Knoten – Bandbreite und Zuverlässigkeit bestimmen automatisch, wie viel Routing ein Knoten beiträgt. Dieser demokratische Ansatz schafft Resilienz und skaliert auf natürliche Weise mit dem Wachstum des Netzwerks.\n3. Vollständig verteilte netDB I2P\u0026rsquo;s 12-Hop-Rundweg (6 eingehend + 6 ausgehend) erzeugt eine stärkere Unverknüpfbarkeit als Tor\u0026rsquo;s 6-Hop-Hidden-Service-Circuits. Da beide Parteien intern sind, vermeiden Verbindungen den Exit-Engpass vollständig, was schnelleres internes Hosting und native Anwendungsintegration (I2PSnark, I2PTunnel, I2PBote) ermöglicht.\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication --- When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet --- Summary I2Ps Architektur ist einzigartig auf Privatsphäre ausgerichtet – keine Verzeichnisserver, keine Blockchain-Abhängigkeiten, kein zentralisiertes Vertrauen. Die Kombination aus unidirektionalen tunnels, paketvermitteltem Routing, garlic message bundling und verteilter Peer-Erkennung macht es zum technisch fortschrittlichsten System für anonymes Hosting und Peer-to-Peer-Kommunikation heute.\nI2P ist keine „Tor-Alternative\u0026quot;. Es ist eine andere Netzwerkklasse – entwickelt für das, was innerhalb des Privatsphäre-Netzwerks geschieht, nicht außerhalb davon.\n","description":"Ein moderner technischer und philosophischer Vergleich, der die einzigartigen Designvorteile von I2P hervorhebt","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P im Vergleich zu anderen Anonymisierungsnetzwerken","url":"/de/docs/overview/comparison/"},{"categories":null,"content":"Die Bündelung von I2P mit Ihrer Anwendung ist eine leistungsstarke Möglichkeit, Benutzer einzubinden – aber nur, wenn der Router verantwortungsvoll konfiguriert ist.\n1. Koordination mit Router-Teams Kontaktieren Sie die Java I2P und i2pd Maintainer vor dem Bundling. Sie können Ihre Standardeinstellungen überprüfen und auf Kompatibilitätsprobleme hinweisen. Wählen Sie die Router-Implementierung, die zu Ihrem Stack passt: Java/Scala → Java I2P C/C++ → i2pd Andere Sprachen → bündeln Sie einen Router und integrieren Sie ihn mit SAM v3 oder I2CP Überprüfen Sie die Weiterverteilungsbedingungen für Router-Binärdateien und Abhängigkeiten (Java Runtime, ICU, etc.). 2. Empfohlene Standard-Konfiguration Streben Sie danach, \u0026ldquo;mehr beizutragen als Sie verbrauchen.\u0026rdquo; Moderne Standardeinstellungen priorisieren die Netzwerkgesundheit und -stabilität.\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. ### Teilnehmende Tunnel bleiben unverzichtbar Deaktivieren Sie nicht die Teilnahme an Tunneln.\nRouter, die nicht weiterleiten, haben selbst eine schlechtere Leistung. Das Netzwerk ist auf freiwillige Kapazitätsteilung angewiesen. Cover-Traffic (weitergeleiteter Verkehr) verbessert die Anonymität. Offizielle Mindestwerte: - Gemeinsam genutzte Bandbreite: ≥ 12 KB/s - Floodfill automatische Aktivierung: ≥ 128 KB/s - Empfohlen: 2 eingehende / 2 ausgehende Tunnel (Java I2P Standard)\n3. Persistenz und Reseeding Persistente Statusverzeichnisse (netDb/, profiles, certificates) müssen zwischen den Ausführungen erhalten bleiben.\nOhne Persistenz lösen Ihre Benutzer bei jedem Start reseeds aus – was die Leistung beeinträchtigt und die Last auf reseed-Servern erhöht.\nWenn Persistenz nicht möglich ist (z.B. bei Containern oder temporären Installationen):\nBündeln Sie 1.000–2.000 Router-Infos im Installationsprogramm. Betreiben Sie einen oder mehrere eigene Reseed-Server, um öffentliche zu entlasten. Konfigurationsvariablen: - Basisverzeichnis: i2p.dir.base - Konfigurationsverzeichnis: i2p.dir.config - Enthält certificates/ für das Reseeding.\n4. Sicherheit und Offenlegung Halten Sie die Router-Konsole (127.0.0.1:7657) nur lokal verfügbar. Verwenden Sie HTTPS, wenn Sie die Benutzeroberfläche extern bereitstellen. Deaktivieren Sie externe SAM/I2CP-Verbindungen, sofern nicht erforderlich. Überprüfen Sie die enthaltenen Plugins – liefern Sie nur das aus, was Ihre Anwendung unterstützt. Verwenden Sie immer Authentifizierung für den Fernzugriff auf die Konsole. Sicherheitsfunktionen seit Version 2.5.0: - NetDB-Isolation zwischen Anwendungen (2.4.0+) - DoS-Schutz und Tor-Blockierlisten (2.5.1) - NTCP2-Widerstandsfähigkeit gegen Probing (2.9.0) - Verbesserungen bei der Floodfill-Router-Auswahl (2.6.0+)\n5. Unterstützte APIs (2025) API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. Alle offiziellen Dokumentationen befinden sich unter `/docs/api/` — der alte Pfad `/spec/samv3/` existiert **nicht**. 6. Netzwerk und Ports Typische Standardports: - 4444 – HTTP-Proxy - 4445 – HTTPS-Proxy - 7654 – I2CP - 7656 – SAM Bridge - 7657 – Router-Konsole - 7658 – Lokale I2P-Site - 6668 – IRC-Proxy - 9000–31000 – Zufälliger Router-Port (UDP/TCP eingehend)\nRouter wählen beim ersten Start einen zufälligen eingehenden Port. Portweiterleitung verbessert die Leistung, aber UPnP kann dies möglicherweise automatisch handhaben.\n7. Moderne Änderungen (2024–2025) Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). ## 8. Benutzererfahrung und Testing Kommunizieren, was I2P tut und warum Bandbreite geteilt wird. Router-Diagnosen bereitstellen (Bandbreite, tunnels, Reseed-Status). Bundles auf Windows, macOS und Linux testen (einschließlich Low-RAM). Interoperabilität mit Java I2P und i2pd Peers überprüfen. Wiederherstellung nach Netzwerkausfällen und ungraceful Exits testen. 9. Community-Ressourcen Forum: i2pforum.net oder http://i2pforum.i2p innerhalb von I2P. Code: i2pgit.org/I2P_Developers/i2p.i2p . IRC (Irc2P-Netzwerk): #i2p-dev, #i2pd. #i2papps unbestätigt; existiert möglicherweise nicht. Bitte klären Sie, welches Netzwerk (Irc2P vs ilita.i2p) Ihren Kanal hostet. Verantwortungsvolles Einbetten bedeutet, Benutzererfahrung, Leistung und Netzwerkbeitrag in Einklang zu bringen. Verwenden Sie diese Standardeinstellungen, bleiben Sie mit den Router-Entwicklern synchron und testen Sie unter realen Lastbedingungen vor der Veröffentlichung.\n","description":"Aktualisierte praktische Anleitung zum verantwortungsvollen Bündeln eines I2P-Routers mit Ihrer Anwendung","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"I2P in Ihre Anwendung einbetten","url":"/de/docs/applications/embedding/"},{"categories":null,"content":"Einleitung I2P bietet privates E-Mail-ähnliches Messaging durch den Postman\u0026rsquo;s Mail.i2p-Dienst in Kombination mit SusiMail, einem integrierten Webmail-Client. Dieses System ermöglicht es Benutzern, E-Mails sowohl innerhalb des I2P-Netzwerks als auch zum/vom regulären Internet (Clearnet) über eine Gateway-Brücke zu senden und zu empfangen.\nPostman / Mail.i2p + SusiMail What it is Mail.i2p ist ein gehosteter E-Mail-Anbieter innerhalb von I2P, betrieben von \u0026ldquo;Postman\u0026rdquo; SusiMail ist der Webmail-Client, der in die I2P-Router-Konsole integriert ist. Er wurde entwickelt, um das Leaken von Metadaten (z. B. Hostname) an externe SMTP-Server zu verhindern. Durch dieses Setup können I2P-Nutzer Nachrichten sowohl innerhalb von I2P als auch zum/vom Clearnet (z. B. Gmail) über die Postman-Bridge senden und empfangen. How Addressing Works I2P-E-Mail verwendet ein duales Adresssystem:\nInnerhalb des I2P-Netzwerks: username@mail.i2p (z. B. idk@mail.i2p) Vom Clearnet aus: username@i2pmail.org (z. B. idk@i2pmail.org) Das i2pmail.org-Gateway ermöglicht es normalen Internet-Nutzern, E-Mails an I2P-Adressen zu senden, und I2P-Nutzern, E-Mails an Clearnet-Adressen zu senden. Internet-E-Mails werden über das Gateway geleitet, bevor sie durch I2P an Ihren SusiMail-Posteingang weitergeleitet werden.\nClearnet-Sendequote: 20 E-Mails pro Tag beim Versenden an reguläre Internetadressen.\nWas es ist So registrieren Sie sich für ein mail.i2p-Konto:\nStellen Sie sicher, dass Ihr I2P-Router läuft Besuchen Sie http://hq.postman.i2p innerhalb von I2P Folgen Sie dem Registrierungsprozess Greifen Sie auf Ihre E-Mails über SusiMail in der Router-Konsole zu Hinweis: hq.postman.i2p ist eine I2P-Netzwerkadresse (eepsite) und kann nur bei bestehender Verbindung zu I2P aufgerufen werden. Für weitere Informationen zur E-Mail-Einrichtung, Sicherheit und Nutzung besuchen Sie Postman HQ.\nWie Adressierung funktioniert Automatisches Entfernen identifizierender Header (User-Agent:, X-Mailer:) zum Schutz der Privatsphäre Metadaten-Bereinigung zur Verhinderung von Lecks an externe SMTP-Server Ende-zu-Ende-Verschlüsselung für interne I2P-zu-I2P-E-Mails Erste Schritte Interoperabilität mit \u0026ldquo;normalem\u0026rdquo; E-Mail (SMTP/POP) über die Postman-Bridge Einfache Benutzererfahrung (Webmail integriert in die Router-Konsole) Integration in die I2P-Kernverteilung (SusiMail wird mit Java I2P ausgeliefert) Entfernung von Headern zum Schutz der Privatsphäre Datenschutzfunktionen Die Brücke zu externer E-Mail erfordert Vertrauen in die Postman-Infrastruktur Clearnet-Brücke reduziert die Privatsphäre im Vergleich zu rein interner I2P-Kommunikation Abhängig von der Verfügbarkeit und Sicherheit des Postman-Mailservers Technical Details SMTP-Dienst: localhost:7659 (bereitgestellt von Postman) POP3-Dienst: localhost:7660 Webmail-Zugriff: In die Router-Konsole integriert unter http://127.0.0.1:7657/susimail/\nWichtig: SusiMail dient nur zum Lesen und Versenden von E-Mails. Kontoerstellung und -verwaltung müssen unter hq.postman.i2p durchgeführt werden.\nBest Practices Ändern Sie Ihr Passwort nach der Registrierung Ihres mail.i2p-Kontos Nutzen Sie I2P-zu-I2P E-Mail wann immer möglich für maximale Privatsphäre (keine Clearnet-Brücke) Beachten Sie das Limit von 20/Tag beim Versenden an Clearnet-Adressen Verstehen Sie die Kompromisse: Clearnet-Brücken bieten Komfort, reduzieren aber die Anonymität im Vergleich zu rein internen I2P-Kommunikationen Halten Sie I2P aktuell, um von Sicherheitsverbesserungen in SusiMail zu profitieren ","description":"Eine Übersicht über E-Mail-Systeme im I2P-Netzwerk — Geschichte, Optionen und aktueller Status","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"I2P Mail (Anonyme E-Mail über I2P)","url":"/de/docs/applications/i2p-mail/"},{"categories":null,"content":" Der Haupt-I2P-Entwicklungszweig (i2p.i2p) wurde so eingerichtet, dass Entwickler zwei der häufig verwendeten IDEs für Java-Entwicklung einfach einrichten können: Eclipse und NetBeans. Eclipse Die Hauptentwicklungszweige von I2P (i2p.i2p und davon abgeleitete Branches) enthalten build.gradle, um den Branch einfach in Eclipse einzurichten. Stellen Sie sicher, dass Sie eine aktuelle Version von Eclipse haben. Alles neuer als 2017 sollte funktionieren. Checken Sie den I2P-Branch in ein Verzeichnis aus (z.B. $HOME/dev/i2p.i2p). Wählen Sie \"File → Import...\" und dann unter \"Gradle\" die Option \"Existing Gradle Project\". Für \"Project root directory:\" wählen Sie das Verzeichnis, in das der I2P-Branch ausgecheckt wurde. Im Dialog \"Import Options\" wählen Sie \"Gradle Wrapper\" und klicken auf Continue. Im Dialog \"Import Preview\" können Sie die Projektstruktur überprüfen. Unter \"i2p.i2p\" sollten mehrere Projekte erscheinen. Klicken Sie auf \"Finish\". Fertig! Ihr Workspace sollte nun alle Projekte innerhalb des I2P-Branch enthalten, und deren Build-Abhängigkeiten sollten korrekt eingerichtet sein. NetBeans Die Haupt-I2P-Entwicklungszweige (i2p.i2p und davon abgeleitete Zweige) enthalten NetBeans-Projektdateien. ","description":"Einrichten von Eclipse und NetBeans für die Entwicklung von I2P mit Gradle und mitgelieferten Projektdateien","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"I2P mit einer IDE verwenden","url":"/de/docs/guides/ides/"},{"categories":null,"content":"Wählen Sie Ihre Installationsmethode Es gibt zwei Möglichkeiten, I2P unter Windows zu installieren. Wählen Sie die Methode, die Ihren Anforderungen am besten entspricht:\n🚀 Easy Install Bundle (Recommended) Am besten für die meisten Benutzer\n✅ All-in-One-Installer ✅ Java enthalten (keine separate Installation) ✅ Firefox-Profile enthalten ✅ Schnellste Einrichtung\nWähle dies, wenn: - Du die einfachste Installation möchtest - Du Java nicht installiert hast - Du neu bei I2P bist\nEinfache Installationsanleitung →\n🚀 Easy Install Bundle (Empfohlen) Für fortgeschrittene Benutzer\n📦 Java-basierter JAR-Installer 🔧 Mehr Kontrolle über die Installation 💾 Kleinere Download-Größe\nWählen Sie dies, wenn: - Sie Java bereits installiert haben - Sie mehr Kontrolle wünschen - Sie die traditionelle Methode bevorzugen\nStandard-Installationsanleitung →\nWICHTIG: Stellen Sie KEINE Fragen, geben Sie keine Erklärungen ab und fügen Sie keine Kommentare hinzu. Auch wenn der Text nur eine Überschrift ist oder unvollständig erscheint, übersetzen Sie ihn wie vorliegend.\nEasy Install Bundle ⚙️ Standardinstallation Das I2P Easy Install Bundle ist die empfohlene Installationsmethode für Windows-Nutzer. Dieses All-in-One-Installationsprogramm enthält alles, was Sie benötigen, um mit I2P zu starten:\nI2P Router - Die Kern-I2P-Software Eingebettete Java-Laufzeitumgebung - Keine separate Java-Installation erforderlich Firefox-Profile und -Erweiterungen - I2P-optimierte Browser-Profile und Erweiterungen für sicheres Surfen Einfacher Installer - Keine manuelle Konfiguration erforderlich Automatische Updates - Halten Sie Ihre I2P-Software aktuell Dieser Beta-Installer vereinfacht den Installationsprozess, indem Java direkt mitgeliefert wird, sodass Sie Java nicht separat herunterladen oder konfigurieren müssen.\nWICHTIG: Stellen Sie KEINE Fragen, geben Sie keine Erklärungen ab und fügen Sie keine Kommentare hinzu. Auch wenn der Text nur eine Überschrift ist oder unvollständig erscheint, übersetzen Sie ihn so wie er ist.\nStep 1: Select Your Language Nachdem Sie das Installationsprogramm des Easy Install Bundles gestartet haben, werden Sie vom Sprachauswahlbildschirm begrüßt.\nWählen Sie Ihre bevorzugte Sprache aus dem Dropdown-Menü Verfügbare Sprachen umfassen Englisch, Deutsch, Spanisch, Französisch und viele weitere Klicken Sie auf OK, um fortzufahren Die Installationsoberfläche wird Ihre ausgewählte Sprache für alle nachfolgenden Schritte verwenden.\nEasy Install Bundle Als Nächstes werden Ihnen die I2P-Lizenzinformationen angezeigt. Das Easy Install Bundle enthält Komponenten unter verschiedenen freien und quelloffenen Lizenzen.\nUm mit der Installation fortzufahren: 1. Lesen Sie die Lizenzinformationen (optional, aber empfohlen) 2. Klicken Sie auf Ich stimme zu, um die Lizenzen zu akzeptieren und fortzufahren 3. Klicken Sie auf Abbrechen, wenn Sie nicht installieren möchten\nDa der Quelltext zum Übersetzen fehlt, kann ich keine Übersetzung bereitstellen. Bitte fügen Sie den zu übersetzenden Text nach \u0026ldquo;Text to translate:\u0026rdquo; ein.\nStep 3: Choose Installation Folder Jetzt wählen Sie aus, wo I2P auf Ihrem Computer installiert werden soll.\nInstallationsoptionen:\nVerwenden Sie den Standardspeicherort (empfohlen)\nStandardpfad: C:\\Users\\[YourUsername]\\AppData\\Local\\I2peasy\\ Dies installiert I2P in Ihrem Benutzerprofilverzeichnis Keine Administratorrechte für Updates erforderlich Wählen Sie einen benutzerdefinierten Speicherort\nKlicken Sie auf Durchsuchen\u0026hellip;, um einen anderen Ordner auszuwählen Nützlich, wenn Sie auf einem anderen Laufwerk installieren möchten Stellen Sie sicher, dass Sie Schreibrechte für den ausgewählten Ordner haben Speicherplatzanforderungen: - Das Installationsprogramm zeigt an, wie viel Speicherplatz benötigt wird (typischerweise weniger als 1 GB) - Stellen Sie sicher, dass auf dem ausgewählten Laufwerk genügend freier Speicherplatz verfügbar ist\nKlicken Sie auf Installieren, um den Installationsprozess zu starten Der Installer wird nun alle notwendigen Dateien an den gewählten Speicherort kopieren. Dies kann einige Minuten dauern.\nSchritt 1: Wählen Sie Ihre Sprache Sobald die Installation abgeschlossen ist, wird der Fertigstellungsbildschirm angezeigt.\nDer Einrichtungsassistent bestätigt, dass „I2P - i2peasy auf Ihrem Computer installiert wurde.\u0026quot;\nWichtig: Stellen Sie sicher, dass das Kontrollkästchen \u0026ldquo;I2P starten?\u0026rdquo; aktiviert ist (es sollte standardmäßig aktiviert sein).\nAktiviert (empfohlen): I2P startet automatisch, wenn Sie auf Fertigstellen klicken Deaktiviert: Sie müssen I2P später manuell über das Startmenü oder die Desktop-Verknüpfung starten Klicken Sie auf Fertigstellen, um die Installation abzuschließen und I2P zu starten.\nWICHTIG: Stellen Sie KEINE Fragen, geben Sie KEINE Erklärungen und fügen Sie KEINE Kommentare hinzu. Selbst wenn der Text nur eine Überschrift ist oder unvollständig erscheint, übersetzen Sie ihn wie vorgegeben.\nSchritt 2: Akzeptieren Sie die Lizenzvereinbarung Nachdem Sie auf Fertig stellen mit aktiviertem \u0026ldquo;I2P starten?\u0026rdquo; geklickt haben:\nI2P Router startet - Der I2P Router beginnt im Hintergrund zu laufen Systemleistensymbol erscheint - Suchen Sie nach dem I2P-Symbol in Ihrer Windows-Systemleiste (untere rechte Ecke) Router Console öffnet sich - Ihr Standard-Webbrowser öffnet automatisch die I2P Router Console (normalerweise unter http://127.0.0.1:7657) Erste Verbindung - I2P beginnt, sich mit dem Netzwerk zu verbinden und Tunnel aufzubauen (dies kann beim ersten Start 5-10 Minuten dauern) Glückwunsch! I2P ist jetzt auf Ihrem Windows-Computer installiert und läuft.\nWICHTIG: Stellen Sie KEINE Fragen, geben Sie KEINE Erklärungen und fügen Sie KEINE Kommentare hinzu. Selbst wenn der Text nur eine Überschrift ist oder unvollständig erscheint, übersetzen Sie ihn so wie er ist.\nSchritt 3: Installationsordner auswählen Obwohl nicht zwingend erforderlich, verbessert Port-Forwarding Ihre I2P-Erfahrung erheblich, indem es Ihrem Router ermöglicht, effektiver mit anderen I2P-Routern zu kommunizieren. Ohne Port-Forwarding können Sie I2P weiterhin nutzen, jedoch mit reduzierter Leistung und geringerem Beitrag zum Netzwerk.\nWhy Forward a Port? Bessere Konnektivität: Ermöglicht eingehende Verbindungen von anderen I2P-Routern Schnellere Integration: Hilft dir, dich schneller ins Netzwerk zu integrieren Netzwerkbeitrag: Macht dich zu einem besseren Teilnehmer im I2P-Netzwerk Verbesserte Leistung: Führt in der Regel zu besserer Tunnel-Zuverlässigkeit und Geschwindigkeit Was ist das Easy Install Bundle? Zuerst müssen Sie herausfinden, welchen Port I2P verwendet (dieser wird standardmäßig zufällig zugewiesen).\nLokalisieren Sie das I2P-Symbol in Ihrer Windows-Taskleiste (Benachrichtigungsbereich) unten rechts auf Ihrem Bildschirm Rechtsklick auf das I2P-Symbol, um das Kontextmenü zu öffnen Klicke auf „Launch I2P Browser\u0026quot;, um die I2P router console zu öffnen Das Menü zeigt auch nützliche Optionen wie: - Network: Firewalled - Zeigt Ihren aktuellen Netzwerkstatus - Configure I2P System Tray - Anpassen der Tray-Icon-Einstellungen - Stop I2P / Stop I2P Immediately - Herunterfahren-Optionen\nFinding Your Port Numbers Sobald der I2P-Browser geöffnet ist, müssen Sie überprüfen, welche Ports I2P verwendet:\nNavigiere zur Netzwerkkonfigurationsseite:\nGehe zu I2P Router Network Configuration in deinem Browser Oder über die Router-Konsole-Seitenleiste: Konfiguration → Netzwerk Scrolle nach unten zum Abschnitt für die Port-Konfiguration\nNotieren Sie sich die angezeigten Portnummern: UDP-Konfiguration: - UDP-Port: Der hier angezeigte Port (Beispiel: 13697) - Standardmäßig ist dies auf „Port angeben\u0026quot; mit einer zufällig zugewiesenen Nummer eingestellt\nTCP-Konfiguration: - Extern erreichbarer TCP-Port: Normalerweise so konfiguriert, dass derselbe Port wie UDP verwendet wird - Im obigen Beispiel: \u0026ldquo;Denselben Port wie für UDP konfiguriert verwenden (derzeit 13697)\u0026rdquo;\nWichtig: Sie müssen sowohl UDP als auch TCP auf derselben Portnummer (in diesem Beispiel Port 13697) in Ihrem Router/Firewall weiterleiten.\nHow to Forward Your Port Da jeder Router und jede Firewall unterschiedlich ist, können wir keine universellen Anweisungen bereitstellen. Allerdings bietet portforward.com detaillierte Anleitungen für Tausende von Router-Modellen:\nBesuchen Sie portforward.com Wählen Sie Ihren Router-Hersteller und Ihr Modell aus Folgen Sie der Schritt-für-Schritt-Anleitung zur Portweiterleitung Leiten Sie sowohl UDP als auch TCP Protokolle auf der in Ihrer I2P-Konfiguration angezeigten Portnummer weiter Allgemeine Schritte (variiert je nach Router): - Melden Sie sich in der Admin-Oberfläche Ihres Routers an (üblicherweise unter 192.168.1.1 oder 192.168.0.1) - Suchen Sie den Bereich \u0026ldquo;Portweiterleitung\u0026rdquo; oder \u0026ldquo;Virtuelle Server\u0026rdquo; - Erstellen Sie eine neue Portweiterleitungsregel für Ihre I2P-Portnummer - Setzen Sie sowohl UDP- als auch TCP-Protokolle - Richten Sie die Regel auf die lokale IP-Adresse Ihres Computers - Speichern Sie die Konfiguration\nNachdem Sie Ihren Port weitergeleitet haben, sollte I2P im Systemleisten-Menü von „Network: Firewalled\u0026quot; zu „Network: OK\u0026quot; wechseln (dies kann einige Minuten dauern).\nSchritt 4: Installation abschließen und I2P starten Warten Sie auf die Integration: Geben Sie I2P 5-10 Minuten Zeit, um sich ins Netzwerk zu integrieren und tunnel aufzubauen Konfigurieren Sie Ihren Browser: Verwenden Sie das mitgelieferte Firefox-Profil für das I2P-Browsing Leiten Sie Ihren Port weiter: Siehe portforward.com für routerspezifische Anleitungen zur Portweiterleitung des von I2P verwendeten Ports Erkunden Sie die Router-Konsole: Informieren Sie sich über I2P-Funktionen, Dienste und Konfigurationsoptionen Besuchen Sie eepsites: Versuchen Sie, .i2p-Websites über das I2P-Netzwerk aufzurufen Lesen Sie die Dokumentation: Schauen Sie sich die I2P-Dokumentation an für weitere Informationen Willkommen im I2P-Netzwerk! 🎉\nIch benötige den zu übersetzenden Text. Bitte fügen Sie den Text nach \u0026ldquo;Text to translate:\u0026rdquo; ein.\nWas als Nächstes passiert What is the Standard Installation? Die Standard-I2P-Installation ist die traditionelle Methode zur Installation von I2P unter Windows. Im Gegensatz zum Easy Install Bundle erfordert diese Methode Folgendes:\nJava separat installieren - Laden Sie die Java Runtime Environment (JRE) herunter und installieren Sie sie vor der Installation von I2P Den JAR-Installer ausführen - Verwenden Sie den Java-basierten grafischen Installer Manuell konfigurieren - Richten Sie die Browser-Konfigurationen selbst ein (optional) Diese Methode wird empfohlen für: - Nutzer, die bereits Java installiert haben - Fortgeschrittene Nutzer, die mehr Kontrolle über die Installation wünschen - Nutzer, die die traditionelle Installationsmethode bevorzugen - Systeme, bei denen das Easy Install Bundle nicht kompatibel ist\nIch verstehe. Bitte geben Sie mir den zu übersetzenden Text.\nEmpfohlen: Port-Weiterleitung (Optional aber Wichtig) Bevor Sie I2P installieren, muss Java auf Ihrem System installiert sein.\nJava Requirements Java-Version: Java 8 (1.8) oder höher erforderlich Empfohlen: Java 11 oder später (LTS-Version) Typ: Java Runtime Environment (JRE) oder Java Development Kit (JDK) Installing Java Wenn Sie Java noch nicht installiert haben, können Sie es aus verschiedenen Quellen herunterladen:\nOption 1: Oracle Java - Offizielle Quelle: java.com/download - Am weitesten verbreitete Distribution\nOption 2: OpenJDK - Open-Source-Implementierung: openjdk.org - Frei und quelloffen\nOption 3: Adoptium (Eclipse Temurin) - Empfohlene Alternative: adoptium.net - Kostenlose, quelloffene und gut gewartete LTS-Versionen\nUm zu überprüfen, ob Java installiert ist: 1. Öffnen Sie die Eingabeaufforderung (drücken Sie Windows + R, geben Sie cmd ein, drücken Sie Enter) 2. Geben Sie ein: java -version 3. Sie sollten eine Ausgabe sehen, die Ihre Java-Version anzeigt\nWICHTIG: Stellen Sie KEINE Fragen, geben Sie KEINE Erklärungen und fügen Sie KEINE Kommentare hinzu. Selbst wenn der Text nur eine Überschrift ist oder unvollständig erscheint, übersetzen Sie ihn so wie er ist.\nStep 1: Install Java Bevor Sie I2P installieren, müssen Sie Java auf Ihrem System installieren.\nWählen Sie eine Java-Distribution:\nOracle Java: java.com/download OpenJDK: openjdk.org Adoptium: adoptium.net Laden Sie das Windows-Installationsprogramm herunter für Ihre gewählte Distribution\nFühren Sie das Installationsprogramm aus und folgen Sie den Installationsanweisungen\nInstallation überprüfen:\nEingabeaufforderung öffnen java -version eingeben und Enter drücken Bestätigen, dass Java 8 oder höher installiert ist Sobald Java installiert ist, können Sie I2P installieren.\nCould you please provide the English text you\u0026rsquo;d like me to translate to German?\nStep 2: Download and Launch the I2P Installer I2P-Installer herunterladen:\nBesuchen Sie die I2P-Downloadseite Laden Sie den Windows-Installer (JAR-Datei) herunter: i2pinstall_X.X.X.jar Speichern Sie die Datei an einem leicht auffindbaren Ort (z. B. im Downloads-Ordner) Installer starten:\nDoppelklicken Sie auf die heruntergeladene JAR-Datei, um den Installer zu starten Falls Doppelklicken nicht funktioniert, klicken Sie mit der rechten Maustaste auf die Datei und wählen Sie „Öffnen mit → Java(TM) Platform SE binary\u0026quot; Alternativ öffnen Sie die Eingabeaufforderung und führen Sie aus: java -jar i2pinstall_X.X.X.jar Step 3: Select Your Language Nachdem Sie das Installationsprogramm gestartet haben, sehen Sie den Dialog zur Sprachauswahl.\nWählen Sie Ihre bevorzugte Sprache aus dem Dropdown-Menü Verfügbare Sprachen umfassen Englisch, Deutsch, Spanisch, Französisch und viele andere Klicken Sie auf OK, um fortzufahren Der Installer wird die von Ihnen gewählte Sprache für alle weiteren Schritte verwenden.\nStep 4: Welcome to I2P Installation Dies ist Schritt 1 von 8 im Installationsprozess.\nKlicken Sie auf Weiter, um mit der Installation fortzufahren.\nNächste Schritte Dies ist Schritt 2 von 8 im Installationsprozess.\nKlicken Sie auf Weiter, um die Lizenz zu akzeptieren und fortzufahren.\nWICHTIG: Stellen Sie NUR die Übersetzung bereit. Stellen Sie KEINE Fragen, geben Sie KEINE Erklärungen und fügen Sie KEINE Kommentare hinzu. Auch wenn der Text nur eine Überschrift ist oder unvollständig erscheint, übersetzen Sie ihn so wie er ist.\nStandardinstallation Wählen Sie aus, wo Sie I2P auf Ihrem Computer installieren möchten.\nStandard-Installationspfad: C:\\Program Files (x86)\\i2p\\\nSie können entweder: - Den Standardspeicherort verwenden (empfohlen) - Auf Durchsuchen\u0026hellip; klicken, um einen anderen Ordner auszuwählen\nDies ist Schritt 3 von 8 im Installationsprozess.\nKlicken Sie auf Weiter, um fortzufahren.\nHinweis: Wenn Sie I2P zum ersten Mal installieren, wird ein Popup angezeigt, das die Verzeichniserstellung bestätigt:\nKlicken Sie auf OK, um das Installationsverzeichnis zu erstellen.\nStep 7: Select Installation Packs Wählen Sie aus, welche Komponenten installiert werden sollen.\nWichtig: Stellen Sie sicher, dass beide Pakete ausgewählt sind: - Base (erforderlich) - Kern-I2P-Software (27,53 MB) - Windows Service (empfohlen) - I2P automatisch beim Systemstart starten\nDie Option Windows Service stellt sicher, dass I2P automatisch beim Hochfahren Ihres Computers startet, sodass Sie es nicht jedes Mal manuell starten müssen.\nDies ist Schritt 4 von 8 im Installationsprozess.\nKlicken Sie auf Weiter, um fortzufahren.\nWICHTIG: Stellen Sie KEINE Fragen, geben Sie keine Erklärungen ab und fügen Sie KEINE Kommentare hinzu. Selbst wenn der Text nur eine Überschrift ist oder unvollständig erscheint, übersetzen Sie ihn wie er ist.\nVoraussetzungen Der Installer wird nun Dateien auf Ihr System kopieren.\nSie sehen zwei Fortschrittsbalken: - Fortschritt der Pack-Installation: Zeigt das aktuell installierte Pack an - Gesamtfortschritt der Installation: Zeigt den Gesamtfortschritt an (z. B. „2 / 2\u0026quot;)\nDies ist Schritt 5 von 8 im Installationsprozess.\nWarten Sie, bis die Installation abgeschlossen ist, und klicken Sie dann auf Weiter.\nI2P-Netzwerkdatenbank Die Netzwerkdatenbank (netDb) ist ein wesentlicher Bestandteil von I2P, der für die Speicherung und Verteilung von Router-Informationen und Tunnel-Endpunkten im gesamten Netzwerk verantwortlich ist.\nWas ist die netDb? Die netDb ist eine verteilte Hash-Tabelle (Distributed Hash Table, DHT), die zwei Haupttypen von Informationen speichert:\nRouterInfos: Enthalten öffentliche Schlüssel, Adressen und andere Informationen über I2P-Router LeaseSets: Enthalten Informationen über Tunnel-Endpunkte, die zu bestimmten Zielen führen Floodfill-Router Einige Router im Netzwerk fungieren als floodfill-Router. Diese speziellen Router:\nSpeichern eine vollständige Kopie der netDb Beantworten Suchanfragen anderer Router Verbreiten Aktualisierungen im gesamten Netzwerk Werden automatisch basierend auf Leistung und Zuverlässigkeit ausgewählt Wie es funktioniert Wenn Ihr Router Informationen über ein Ziel benötigt:\nSucht zunächst in seiner lokalen netDb-Kopie Wenn nicht gefunden, fragt er floodfill-Router ab Speichert die Antwort zwischen, um zukünftige Suchen zu beschleunigen Aktualisiert seine Datenbank regelmäßig, um Daten aktuell zu halten Datenschutz und Sicherheit Die netDb ist so konzipiert, dass die Privatsphäre geschützt wird:\nSuchanfragen werden durch Tunnel geleitet, nicht direkt gesendet Informationen sind kryptografisch signiert, um Manipulation zu verhindern Veraltete Daten verfallen automatisch Keine einzelne Entität kontrolliert die gesamte Datenbank Step 9: Setup Shortcuts Konfigurieren Sie, wo I2P-Verknüpfungen erstellt werden sollen.\nShortcut-Optionen: - ✓ Verknüpfungen im Startmenü erstellen (empfohlen) - ✓ Zusätzliche Verknüpfungen auf dem Desktop erstellen (optional)\nProgrammgruppe: Wählen oder erstellen Sie einen Ordnernamen für die Verknüpfungen - Standard: I2P - Sie können eine vorhandene Programmgruppe auswählen oder eine neue erstellen\nVerknüpfung erstellen für: - Aktueller Benutzer - Nur Sie können auf die Verknüpfungen zugreifen - Alle Benutzer - Alle Benutzer des Systems können auf die Verknüpfungen zugreifen (erfordert Administratorrechte)\nDies ist Schritt 6 von 8 im Installationsprozess.\nKlicken Sie auf Weiter, um fortzufahren.\nStep 10: Installation Complete Die Installation ist jetzt abgeschlossen!\nSie werden sehen: - ✓ Installation wurde erfolgreich abgeschlossen - Ein Deinstallationsprogramm wird erstellt in: C:\\Program Files (x86)\\i2p\\Uninstaller\nDies ist Schritt 8 von 8 - der letzte Schritt des Installationsprozesses.\nKlicken Sie auf Fertig, um den Vorgang abzuschließen.\nSchritt 1: Java installieren Nachdem Sie auf Fertig geklickt haben:\nI2P Router startet - Wenn Sie den Windows-Dienst installiert haben, startet I2P automatisch Router-Konsole öffnet sich - Ihr Standardwebbrowser öffnet die I2P Router-Konsole unter http://127.0.0.1:7657 Erste Verbindung - I2P beginnt, sich mit dem Netzwerk zu verbinden und tunnels aufzubauen (dies kann beim ersten Start 5-10 Minuten dauern) Herzlichen Glückwunsch! I2P ist jetzt auf Ihrem Windows-Computer installiert.\nSchritt 2: I2P-Installer herunterladen und starten Wenn I2P nicht automatisch startet oder wenn Sie es in Zukunft manuell starten müssen, haben Sie zwei Möglichkeiten:\nOption 1: Start Menu Öffnen Sie das Windows-Startmenü Navigieren Sie zum I2P-Ordner Wählen Sie eine der Startoptionen: I2P router console - Öffnet die Router-Konsole in Ihrem Browser Start I2P (no window) - Startet I2P im Hintergrund ohne Fenster Start I2P (restartable) - Startet I2P mit automatischer Neustartfunktion Sie können auch auf Open I2P Profile Folder (service) zugreifen, um die Konfigurationsdateien von I2P anzuzeigen.\nWarum einen Port weiterleiten? Drücken Sie Windows + R, um den Ausführen-Dialog zu öffnen Geben Sie services.msc ein und drücken Sie Enter Scrollen Sie nach unten, um I2P Service zu finden Klicken Sie mit der rechten Maustaste auf I2P Service und wählen Sie: Starten - Startet den I2P Service Beenden - Beendet den I2P Service Neu starten - Startet den I2P Service neu Eigenschaften - Konfiguriert Service-Einstellungen (Starttyp usw.) Die Windows Services Methode ist nützlich für die Verwaltung von I2P als Hintergrunddienst, insbesondere wenn Sie es als Windows-Dienst installiert haben.\nWICHTIG: Stellen Sie KEINE Fragen, geben Sie keine Erklärungen ab und fügen Sie KEINE Kommentare hinzu. Auch wenn der Text nur eine Überschrift ist oder unvollständig erscheint, übersetzen Sie ihn so wie er ist.\nSchritt 3: Wählen Sie Ihre Sprache Auf Integration warten: Geben Sie I2P 5-10 Minuten Zeit, um sich ins Netzwerk zu integrieren und Tunnel aufzubauen Port-Weiterleitung konfigurieren: Siehe die Anleitung zur Port-Weiterleitung für Instruktionen Browser konfigurieren: Richten Sie Ihren Webbrowser ein, um den HTTP-Proxy von I2P zu verwenden Router-Konsole erkunden: Erfahren Sie mehr über die Funktionen, Dienste und Konfigurationsoptionen von I2P Eepsites besuchen: Versuchen Sie, .i2p-Websites über das I2P-Netzwerk aufzurufen Dokumentation lesen: Schauen Sie sich die I2P-Dokumentation an für weitere Informationen Willkommen im I2P-Netzwerk! 🎉\n","description":"Wählen Sie Ihre Windows-Installationsmethode: Easy Install Bundle oder Standardinstallation","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"I2P unter Windows installieren","url":"/de/docs/guides/i2p-unter-windows-installieren/"},{"categories":null,"content":"Überblick I2CP ist das Low-Level-Steuerprotokoll zwischen einem I2P router und jedem beliebigen Client-Prozess. Es definiert eine strikte Trennung der Verantwortlichkeiten:\nRouter: Verwaltet Routing, Kryptografie, Lebenszyklen von tunnels und Netzwerkdatenbank-Operationen Client: Wählt Anonymitätseigenschaften aus, konfiguriert tunnels und übermittelt/empfängt Nachrichten Die gesamte Kommunikation läuft über einen einzigen TCP-Socket (optional TLS-gekapselt), wodurch asynchroner Vollduplexbetrieb ermöglicht wird.\nProtokollversion: I2CP verwendet ein Protokollversions-Byte 0x2A (42 dezimal), das während des initialen Verbindungsaufbaus gesendet wird. Dieses Versions-Byte ist seit der Einführung des Protokolls unverändert geblieben.\nAktueller Stand: Diese Spezifikation gilt für router version 0.9.67 (API-Version 0.9.67), veröffentlicht 2025-09.\nImplementierungskontext Java-Implementierung Die Referenzimplementierung ist in Java I2P: - Client-SDK: i2p.jar-Paket - Router-Implementierung: router.jar-Paket - Javadocs Wenn Client und router in derselben JVM laufen, werden I2CP-Nachrichten als Java-Objekte ohne Serialisierung übergeben. Externe Clients verwenden das serialisierte Protokoll über TCP.\nC++-Implementierung i2pd (der C++ I2P router) stellt I2CP für Client-Verbindungen auch extern bereit.\nNicht-Java-Clients Es gibt keine bekannten Nicht-Java-Implementierungen einer vollständigen I2CP-Clientbibliothek. Nicht-Java-Anwendungen sollten stattdessen höherstufige Protokolle verwenden:\nSAM (Simple Anonymous Messaging) v3: Socket-basierte Schnittstelle mit Bibliotheken in mehreren Programmiersprachen BOB (Basic Open Bridge): Einfachere Alternative zu SAM Diese Protokolle höherer Ebene handhaben die I2CP-Komplexität intern und stellen außerdem die Streaming-Bibliothek (für TCP-ähnliche Verbindungen) und die Datagramm-Bibliothek (für UDP-ähnliche Verbindungen) bereit.\nVerbindungsaufbau 1. TCP-Verbindung Stellen Sie eine Verbindung zum I2CP-Port des router her: - Standard: 127.0.0.1:7654 - Über die router-Einstellungen konfigurierbar - Optionaler TLS-Wrapper (für Remote-Verbindungen dringend empfohlen)\n2. Protokoll-Handshake Schritt 1: Sende das Protokollversions-Byte 0x2A\nSchritt 2: Zeitsynchronisation\nClient → Router: GetDateMessage Router → Client: SetDateMessage Der router gibt seinen aktuellen Zeitstempel und den I2CP-API-Versionsstring zurück (seit 0.8.7).\nSchritt 3: Authentifizierung (falls aktiviert)\nAb Version 0.9.11 kann die Authentifizierung in GetDateMessage über ein Mapping (Zuordnung) enthalten sein, das Folgendes enthält: - i2cp.username - i2cp.password\nSeit 0.9.16 muss, wenn die Authentifizierung aktiviert ist, die Authentifizierung über GetDateMessage abgeschlossen werden, bevor andere Nachrichten gesendet werden.\nSchritt 4: Sitzungserstellung\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) Schritt 5: Tunnel-Bereitsignal\nRouter → Client: RequestVariableLeaseSetMessage Diese Nachricht zeigt an, dass eingehende tunnels aufgebaut wurden. Der router wird dies NICHT senden, bevor mindestens ein eingehender UND ein ausgehender tunnel existieren.\nSchritt 6: LeaseSet-Veröffentlichung\nClient → Router: CreateLeaseSet2Message An diesem Punkt ist die Sitzung zum Senden und Empfangen von Nachrichten vollständig einsatzbereit.\nMuster des Nachrichtenflusses Ausgehende Nachricht (Client sendet an ein entferntes Ziel) Mit i2cp.messageReliability=none:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] Mit i2cp.messageReliability=BestEffort:\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) Eingehende Nachricht (Router liefert an den Client) Mit i2cp.fastReceive=true (Standard seit 0.9.4):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] Mit i2cp.fastReceive=false (VERALTET):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage Moderne Clients sollten immer den schnellen Empfangsmodus verwenden.\nAllgemeine Datenstrukturen I2CP-Nachrichten-Header Alle I2CP-Nachrichten verwenden diesen gemeinsamen Header:\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ Länge des Nachrichtenkörpers: 4-Byte-Integer, nur die Länge des Nachrichtenkörpers (ohne Header) Typ: 1-Byte-Integer, Kennung des Nachrichtentyps Nachrichtenkörper: 0+ Bytes, Format variiert je nach Nachrichtentyp Begrenzung der Nachrichtengröße: Maximal etwa 64 KB.\nSitzungs-ID 2-Byte-Ganzzahl, die eine Sitzung auf einem router eindeutig identifiziert.\nSonderwert: 0xFFFF zeigt \u0026ldquo;keine Sitzung\u0026rdquo; an (verwendet für Hostname-Abfragen ohne bestehende Sitzung).\nNachrichten-ID Vom router erzeugter 4-Byte-Integer zur eindeutigen Identifizierung einer Nachricht innerhalb einer Sitzung.\nWichtig: Nachrichten-IDs sind nicht global eindeutig, sondern nur innerhalb einer Sitzung eindeutig. Sie unterscheiden sich außerdem von dem vom Client erzeugten nonce (Einmalwert).\nNutzlastformat Nachrichten-Nutzdaten werden mit einem standardmäßigen 10-Byte-gzip-Header gzip-komprimiert: - Beginnt mit: 0x1F 0x8B 0x08 (RFC 1952) - Seit 0.7.1: Unbenutzte Teile des gzip-Headers enthalten Informationen zu Protokoll, Quellport und Zielport - Dies ermöglicht Streaming und Datagramme auf derselben Destination (I2P-Zieladresse)\nKompressionssteuerung: Setzen Sie i2cp.gzip=false, um die Kompression zu deaktivieren (setzt den gzip-Aufwand auf 0). Der gzip-Header ist weiterhin enthalten, jedoch mit minimalem Kompressions-Overhead.\nSessionConfig-Struktur Definiert die Konfiguration für eine Client-Sitzung:\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ Kritische Anforderungen: 1. Die Zuordnung muss nach Schlüssel sortiert sein für die Signaturvalidierung 2. Erstellungsdatum muss innerhalb von ±30 Sekunden der aktuellen Zeit des router liegen 3. Signatur wird vom SigningPrivateKey der Destination erstellt\nOffline-Signaturen (seit 0.9.38):\nBei Verwendung der Offline-Signierung muss das Mapping (Zuordnung) Folgendes enthalten: - i2cp.leaseSetOfflineExpiration - i2cp.leaseSetTransientPublicKey - i2cp.leaseSetOfflineSignature\nDie Signatur wird anschließend vom flüchtigen SigningPrivateKey erzeugt.\nOptionen der Kernkonfiguration Tunnelkonfiguration Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) **Hinweise**: - Werte für `quantity` \u003e 6 erfordern Peers, die 0.9.0+ ausführen, und erhöhen die Ressourcennutzung erheblich - Setzen Sie `backupQuantity` auf 1-2 für hochverfügbare Dienste - Zero-hop tunnels opfern Anonymität zugunsten geringerer Latenz, sind jedoch für Tests nützlich Nachrichtenbehandlung Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) **Nachrichtenzuverlässigkeit**: - `None`: Keine router-Bestätigungen (Standard der Streaming-Bibliothek seit 0.8.1) - `BestEffort`: router sendet Annahme- sowie Benachrichtigungen über Erfolg/Misserfolg - `Guaranteed`: Nicht implementiert (verhält sich derzeit wie BestEffort) Per-Nachricht-Überschreibung (seit 0.9.14): - In einer Sitzung mit messageReliability=none fordert das Setzen eines Nonce (einmaliger Zufallswert) ungleich 0 eine Zustellbenachrichtigung speziell für diese Nachricht an - Das Setzen von nonce=0 in einer BestEffort-Sitzung deaktiviert Benachrichtigungen für diese Nachricht\nLeaseSet-Konfiguration Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) ### Veraltete ElGamal/AES Session Tags (Sitzungs-Tags) Diese Optionen sind nur für die veraltete ElGamal-Verschlüsselung relevant:\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch **Hinweis**: ECIES-X25519-Clients (Elliptic Curve Integrated Encryption Scheme über X25519) verwenden einen anderen Ratchet-Mechanismus und ignorieren diese Optionen. Verschlüsselungstypen I2CP unterstützt mehrere Ende-zu-Ende-Verschlüsselungsverfahren über die Option i2cp.leaseSetEncType. Es können mehrere Typen angegeben werden (kommagetrennt), um sowohl moderne als auch ältere Peers zu unterstützen.\nUnterstützte Verschlüsselungstypen Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned **Empfohlene Konfiguration**: i2cp.leaseSetEncType=4,0 Dies stellt X25519 (bevorzugt) mit einer ElGamal-Rückfalllösung für die Kompatibilität bereit.\nDetails zum Verschlüsselungstyp Typ 0 - ElGamal/AES+SessionTags: - 2048-Bit öffentliche ElGamal-Schlüssel (256 Byte) - Symmetrische AES-256-Verschlüsselung - 32-Byte Session-Tags, stapelweise gesendet - Hoher CPU-, Bandbreiten- und Speicher-Overhead - Wird netzwerkweit schrittweise abgeschafft\nTyp 4 - ECIES-X25519-AEAD-Ratchet: - X25519-Schlüsselaustausch (32-Byte-Schlüssel) - ChaCha20/Poly1305 AEAD - Signal-Style Double Ratchet (Schlüsselableitungsverfahren mit doppelter Ratsche) - 8-Byte-Session-Tags (im Vergleich zu 32-Byte bei ElGamal) - Tags werden über einen synchronisierten PRNG erzeugt (nicht im Voraus gesendet) - ~92% Overhead-Reduzierung gegenüber ElGamal - Standard für modernes I2P (die meisten routers verwenden dies)\nTypen 5-6 - Post-Quanten-Hybrid: - Kombiniert X25519 mit ML-KEM (NIST FIPS 203) - Bietet quantenresistente Sicherheit - ML-KEM-768 für ein ausgewogenes Sicherheits-/Leistungsverhältnis - ML-KEM-1024 für maximale Sicherheit - Größere Nachrichtengrößen aufgrund von Post-Quanten-Schlüsselmaterial - Netzwerkunterstützung wird noch ausgerollt\nMigrationsstrategie Das I2P-Netzwerk stellt aktiv von ElGamal (Typ 0) auf X25519 (Typ 4) um:\nNTCP → NTCP2 (abgeschlossen) SSU → SSU2 (abgeschlossen) ElGamal tunnels → X25519 tunnels (abgeschlossen) ElGamal Ende-zu-Ende → ECIES-X25519 (größtenteils abgeschlossen) LeaseSet2 und erweiterte Funktionen LeaseSet2-Optionen (seit 0.9.38) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) ### Verblindete Adressen Seit 0.9.39 können destinations (Ziele) \u0026ldquo;blinded\u0026rdquo; (verschleiert) Adressen (b33-Format) verwenden, die sich periodisch ändern: - Erfordert i2cp.leaseSetSecret für Passwortschutz - Optionale Authentifizierung pro Client - Siehe Proposals 123 und 149 für Details\nDiensteinträge (seit 0.9.66) LeaseSet2 unterstützt Service-Record-Optionen (Vorschlag 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p Format folgt dem DNS-SRV-Record-Stil, ist jedoch für I2P angepasst.\nMehrere Sitzungen (seit 0.9.21) Eine einzelne I2CP-Verbindung kann mehrere Sitzungen verwalten:\nPrimäre Sitzung: Die erste auf einer Verbindung erstellte Sitzung Untersitzungen: Zusätzliche Sitzungen, die sich den tunnel pool (Tunnel-Pool) der primären Sitzung teilen\nEigenschaften der Subsession (Teilsitzung) Gemeinsame Tunnels: Verwenden dieselben eingehenden/ausgehenden tunnel-Pools wie die primäre Sitzung Gemeinsame Verschlüsselungsschlüssel: Müssen identische LeaseSet-Verschlüsselungsschlüssel verwenden Unterschiedliche Signaturschlüssel: Müssen unterschiedliche Destination-Signaturschlüssel (I2P-Zieladresse) verwenden Keine Anonymitätsgarantie: Eindeutig mit der primären Sitzung verknüpft (gleicher router, gleiche tunnels) Anwendungsfall für Subsession (Teilsitzung) Ermöglicht die Kommunikation mit Destinations (Ziele) unter Verwendung unterschiedlicher Signaturtypen: - Primär: EdDSA-Signatur (modern) - Subsession (Teilsitzung): DSA-Signatur (Abwärtskompatibilität)\nLebenszyklus der Subsession (Teilsitzung) Erstellung:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) Beendigung: - Das Beenden einer subsession (Unter-Sitzung): Lässt die primary session (primäre Sitzung) intakt - Das Beenden der primary session: Beendet alle subsessions und schließt die Verbindung - DisconnectMessage (Trennnachricht): Beendet alle Sitzungen\nUmgang mit der Sitzungs-ID Die meisten I2CP-Nachrichten enthalten ein Session-ID-Feld. Ausnahmen: - DestLookup / DestReply (veraltet, verwenden Sie HostLookup / HostReply) - GetBandwidthLimits / BandwidthLimits (Antwort nicht sitzungsspezifisch)\nWichtig: Clients sollten nicht mehrere CreateSession-Nachrichten gleichzeitig offen haben, da Antworten nicht eindeutig den Anfragen zugeordnet werden können.\nNachrichtenkatalog Übersicht der Nachrichtentypen Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current **Legende**: C = Client, R = Router Details zur Schlüsselnachricht CreateSessionMessage (Typ 1) Zweck: Starten einer neuen I2CP-Sitzung\nInhalt: SessionConfig-Struktur\nAntwort: SessionStatusMessage (status=Created oder Invalid)\nAnforderungen: - Das Datum in SessionConfig muss innerhalb von ±30 Sekunden der router‑Zeit liegen - Das Mapping muss zur Signaturvalidierung nach Schlüssel sortiert sein - Destination (Zieladresse in I2P) darf nicht bereits eine aktive Sitzung haben\nRequestVariableLeaseSetMessage (Typ 37) Zweck: Router fordert eine Client-Autorisierung für eingehende tunnels an\nInhalt: - Sitzungs-ID - Anzahl der Leases (zeitlich befristete Verbindungs-Einträge) - Array von Lease-Strukturen (jede mit individueller Ablaufzeit)\nAntwort: CreateLeaseSet2Message\nBedeutung: Dies ist das Signal, dass die Sitzung betriebsbereit ist. Der router sendet dies erst, nachdem: 1. Mindestens ein eingehender tunnel aufgebaut ist 2. Mindestens ein ausgehender tunnel aufgebaut ist\nTimeout-Empfehlung: Clients sollten die Sitzung beenden, wenn diese Nachricht nicht innerhalb von 5+ Minuten nach Erstellung der Sitzung empfangen wird.\nCreateLeaseSet2Message (Typ 41) Zweck: Der Client veröffentlicht das LeaseSet in der Netzwerkdatenbank\nInhalt: - Sitzungs-ID - LeaseSet-Typ-Byte (1, 3, 5 oder 7) - LeaseSet oder LeaseSet2 oder EncryptedLeaseSet oder MetaLeaseSet - Anzahl der privaten Schlüssel - Liste privater Schlüssel (je ein privater Schlüssel pro öffentlichem Schlüssel in LeaseSet, gleiche Reihenfolge)\nPrivate Schlüssel: Erforderlich zum Entschlüsseln eingehender Garlic-Nachrichten. Format:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) Hinweis: Ersetzt die veraltete CreateLeaseSetMessage (Typ 4), die Folgendes nicht unterstützt: - LeaseSet2-Varianten - Nicht-ElGamal-Verschlüsselung - Mehrere Verschlüsselungstypen - Verschlüsselte LeaseSets - Offline-Signaturschlüssel\nSendMessageExpiresMessage (Typ 36) Zweck: Nachricht mit Ablaufzeit und erweiterten Optionen an das Ziel senden\nInhalt: - Sitzungs-ID - Destination (Zieladresse) - Nutzlast (gzip-komprimiert) - Nonce (einmalig verwendete Zufallszahl) (4 Bytes) - Flags (2 Bytes) - siehe unten - Ablaufdatum (6 Bytes, von 8 gekürzt)\nFlags-Feld (2 Bytes, Bitreihenfolge 15\u0026hellip;0):\nBits 15-11: Unbenutzt, müssen 0 sein\nBits 10-9: Übersteuerung der Nachrichtenzuverlässigkeit (ungenutzt, stattdessen nonce (Einmalwert) verwenden)\nBit 8: LeaseSet nicht bündeln - 0: Router darf LeaseSet in garlic bündeln - 1: LeaseSet nicht bündeln\nBits 7-4: Unterer Tag-Schwellenwert (nur ElGamal, für ECIES ignoriert)\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags Bits 3-0: Tags, die bei Bedarf gesendet werden (nur für ElGamal, bei ECIES ignoriert)\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage (Typ 22) Zweck: Benachrichtigung des Clients über den Zustellstatus der Nachricht\nInhalt: - Sitzungs-ID - Nachrichten-ID (vom router generiert) - Statuscode (1 Byte) - Größe (4 Bytes, nur relevant für status=0) - Nonce (4 Bytes, entspricht der SendMessage-Nonce des Clients)\nStatuscodes (Ausgehende Nachrichten):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure **Erfolgscodes**: 1, 2, 4, 6 **Fehlercodes**: Alle anderen Statuscode 0 (VERALTET): Verfügbare Nachricht (eingehend, schneller Empfang deaktiviert)\nHostLookupMessage (Typ 38) Zweck: Destination (Zieladresse) anhand von Hostname oder Hash auflösen (ersetzt DestLookup)\nInhalt: - Sitzungs-ID (oder 0xFFFF für keine Sitzung) - Anfrage-ID (4 Bytes) - Timeout in Millisekunden (4 Bytes, empfohlener Mindestwert: 10000) - Anfragetyp (1 Byte) - Lookup-Schlüssel (Hash, Hostname-String oder Destination (I2P‑Zieladresse))\nAnfragetypen:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 Typen 2-4 geben LeaseSet-Optionen (Vorschlag 167) zurück, falls verfügbar. Antwort: HostReplyMessage\nHostReplyMessage (Typ 39) Zweck: Antwort auf HostLookupMessage (Nachricht zur Hostauflösung)\nInhalt: - Sitzungs-ID - Anfrage-ID - Ergebniscode (1 Byte) - Ziel (vorhanden bei Erfolg, manchmal bei bestimmten Fehlern) - Zuordnung (nur für Lookup-Typen 2-4, kann leer sein)\nErgebniscodes:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type #### BlindingInfoMessage (Typ 42) Zweck: Den router über die Authentifizierungsanforderungen für blinded destination (geblindete Destination) informieren (seit 0.9.43)\nInhalt: - Sitzungs-ID - Flags (1 Byte) - Endpunkttyp (1 Byte): 0=Hash, 1=hostname, 2=Destination, 3=SigType+Key - Typ der geblendeten Signatur (2 Bytes) - Ablaufzeit (4 Bytes, Sekunden seit der Unix-Epoche) - Endpunktdaten (abhängig vom Typ) - Privater Schlüssel (32 Bytes, nur wenn Flag-Bit 0 gesetzt ist) - Lookup-Passwort (String, nur wenn Flag-Bit 4 gesetzt ist)\nFlags (Bitreihenfolge 76543210):\nBit 0: 0=alle, 1=pro Client Bits 3-1: Authentifizierungsschema (wenn Bit 0=1): 000=DH, 001=PSK Bit 4: 1=Secret (gemeinsames Geheimnis) erforderlich Bits 7-5: Ungenutzt, auf 0 setzen Keine Antwort: Router verarbeitet stillschweigend\nAnwendungsfall: Bevor an eine blinded destination (verschleiertes Ziel; b33 address) gesendet wird, muss der Client entweder: 1. die b33 via HostLookup auflösen, ODER 2. eine BlindingInfo-Nachricht senden\nWenn das Ziel eine Authentifizierung erfordert, ist BlindingInfo (Verblindungsinformationen) obligatorisch.\nReconfigureSessionMessage (Nachricht zur Neukonfiguration einer Sitzung) (Typ 2) Zweck: Sitzungskonfiguration nach der Erstellung aktualisieren\nInhalt: - Sitzungs-ID - SessionConfig (nur geänderte Optionen erforderlich)\nAntwort: SessionStatusMessage (status=Updated oder Invalid)\nHinweise: - Der Router führt neue Konfiguration mit der bestehenden zusammen - Tunnel-Optionen (inbound.*, outbound.*) werden immer angewendet - Einige Optionen können nach der Erstellung der Sitzung unveränderlich sein - Das Datum muss innerhalb von ±30 Sekunden der Routerzeit liegen - Die Zuordnung muss nach Schlüssel sortiert sein\nDestroySessionMessage (Typ 3) Zweck: Eine Sitzung beenden\nInhalt: Sitzungs-ID\nErwartete Antwort: SessionStatusMessage (status=Destroyed)\nTatsächliches Verhalten (Java I2P bis einschließlich 0.9.66): - Router sendet nie SessionStatus(Destroyed) - Wenn keine Sitzungen verbleiben: sendet DisconnectMessage - Wenn subsessions (Untersitzungen) verbleiben: Keine Antwort\nWichtig: Das Verhalten von Java I2P weicht von der Spezifikation ab. Implementierungen sollten beim Zerstören einzelner Subsessions (Teilsitzungen) vorsichtig sein.\nDisconnectMessage (Typ 30) Zweck: Mitteilen, dass die Verbindung in Kürze beendet wird\nInhalt: Begründungstext\nAuswirkung: Alle Sitzungen auf der Verbindung werden beendet, der Socket wird geschlossen\nImplementierung: Hauptsächlich router → Client in Java I2P\nVersionshistorie des Protokolls Versionserkennung Die I2CP-Protokollversion wird über Get/SetDate-Nachrichten ausgetauscht (seit 0.8.7). Für ältere routers sind keine Versionsinformationen verfügbar.\nVersions-String: Gibt die \u0026ldquo;core\u0026rdquo;-API-Version an, nicht unbedingt die router-Version.\nZeitlinie der Funktionen Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features ## Sicherheitsaspekte Authentifizierung Standard: Keine Authentifizierung erforderlich Optional: Authentifizierung mit Benutzername/Passwort (seit 0.9.11) Erforderlich: Wenn aktiviert, muss die Authentifizierung vor anderen Nachrichten abgeschlossen werden (seit 0.9.16)\nRemote-Verbindungen: Verwenden Sie immer TLS (i2cp.SSL=true), um Anmeldedaten und private Schlüssel zu schützen.\nUhrzeitabweichung SessionConfig Date muss innerhalb von ±30 Sekunden von der router-Zeit liegen, andernfalls wird die Sitzung abgelehnt. Verwenden Sie Get/SetDate zur Synchronisierung.\nUmgang mit privaten Schlüsseln CreateLeaseSet2Message enthält private Schlüssel zum Entschlüsseln eingehender Nachrichten. Diese Schlüssel müssen: - Sicher übertragen werden (TLS für Remote-Verbindungen) - Sicher vom router gespeichert werden - Rotiert werden, wenn sie kompromittiert sind\nAblaufzeit von Nachrichten Verwenden Sie immer SendMessageExpires (nicht SendMessage), um eine explizite Ablaufzeit festzulegen. Dadurch: - Verhindert, dass Nachrichten unbegrenzt in der Warteschlange verbleiben - Reduziert den Ressourcenverbrauch - Verbessert die Zuverlässigkeit\nVerwaltung von Session Tags (Sitzungs-Tags) ElGamal (veraltet): - Tags (Markierungen) müssen in Batches übertragen werden - Verlorene Tags führen zu Entschlüsselungsfehlern - Hoher Speicheraufwand\nECIES-X25519 (aktuell): - Tags (Kennungen), die mit einem synchronisierten Pseudozufallszahlengenerator erzeugt werden - Keine vorherige Übertragung erforderlich - Widerstandsfähig gegenüber Nachrichtenverlust - Deutlich geringerer Overhead\nBewährte Verfahren Für Client-Entwickler Schnellen Empfangsmodus verwenden: Setze immer i2cp.fastReceive=true (oder verwende die Voreinstellung)\nECIES-X25519 (Elliptic Curve Integrated Encryption Scheme mit X25519) bevorzugen: Konfigurieren Sie i2cp.leaseSetEncType=4,0 für optimale Leistung bei gleichzeitiger Kompatibilität\nExplizites Ablaufdatum festlegen: Verwenden Sie SendMessageExpires, nicht SendMessage\nSubsessions vorsichtig handhaben: Beachten Sie, dass Subsessions (Untersitzungen) zwischen Destinations keine Anonymität bieten\nZeitüberschreitung bei der Sitzungserstellung: Sitzung verwerfen, wenn RequestVariableLeaseSet nicht innerhalb von 5 Minuten empfangen wird\nKonfigurations-Mappings sortieren: Sortieren Sie die Mapping-Schlüssel immer, bevor Sie SessionConfig signieren\nVerwenden Sie eine angemessene Anzahl der Tunnel: Setzen Sie quantity nicht \u0026gt; 6, es sei denn, es ist erforderlich\nSAM/BOB für Nicht-Java in Betracht ziehen: Implementieren Sie SAM, anstatt I2CP direkt zu implementieren\nFür Router-Entwickler Datumsangaben validieren: ±30‑Sekunden-Fenster für die SessionConfig-Datumsangaben erzwingen\nNachrichtengröße begrenzen: Maximale Nachrichtengröße von ~64 KB erzwingen\nUnterstützung mehrerer Sitzungen: Subsession-Unterstützung gemäß Spezifikation 0.9.21 implementieren\nRequestVariableLeaseSet (Anforderung für ein variables leaseSet) umgehend senden: Erst nachdem sowohl eingehende als auch ausgehende tunnels vorhanden sind\nVeraltete Nachrichten behandeln: ReceiveMessageBegin/End akzeptieren, aber von ihrer Verwendung abraten\nECIES-X25519 unterstützen: Verschlüsselungstyp 4 für neue Bereitstellungen priorisieren\nDebugging und Fehlerbehebung Häufige Probleme Sitzung abgelehnt (ungültig): - Uhrzeitabweichung prüfen (muss innerhalb von ±30 Sekunden liegen) - Überprüfen, dass die Zuordnung nach Schlüssel sortiert ist - Sicherstellen, dass die Destination nicht bereits in Verwendung ist\nKein RequestVariableLeaseSet: - Router baut möglicherweise tunnels (Warten Sie bis zu 5 Minuten) - Prüfen Sie auf Probleme mit der Netzwerkverbindung - Überprüfen Sie, ob ausreichend Peer-Verbindungen bestehen\nFehler bei der Nachrichtenübermittlung: - MessageStatus-Codes auf den spezifischen Fehlergrund prüfen - Überprüfen, ob das entfernte LeaseSet veröffentlicht und aktuell ist - Kompatible Verschlüsselungstypen sicherstellen\nSubsession-Probleme (Teilsitzung): - Überprüfen, dass die primäre Sitzung zuerst erstellt wurde - Bestätigen, dass die gleichen Verschlüsselungsschlüssel verwendet werden - Prüfen, ob unterschiedliche Signaturschlüssel vorhanden sind\nDiagnosemeldungen GetBandwidthLimits: router-Kapazität abfragen HostLookup: Namensauflösung und LeaseSet-Verfügbarkeit testen MessageStatus: Nachrichtenübermittlung Ende-zu-Ende nachverfolgen\nVerwandte Spezifikationen Gemeinsame Strukturen: /docs/specs/common-structures/ I2NP (Netzwerkprotokoll): /docs/specs/i2np/ ECIES-X25519: /docs/specs/ecies/ Tunnel-Erstellung: /docs/specs/implementation/ Streaming-Bibliothek: /docs/specs/streaming/ Datagramm-Bibliothek: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ Referenzierte Vorschläge Vorschlag 123 : Verschlüsselte LeaseSets und Authentifizierung Vorschlag 144 : ECIES-X25519-AEAD-Ratchet Vorschlag 149 : Geblendetes Adressformat (b33) Vorschlag 152 : X25519 tunnel-Erstellung Vorschlag 154 : Datenbankabfragen von ECIES-Destinationen Vorschlag 156 : Router-Migration auf ECIES-X25519 Vorschlag 161 : Komprimierung des Destination-Padding Vorschlag 167 : LeaseSet-Serviceeinträge Vorschlag 169 : Post-quantische hybride Kryptografie (ML-KEM) Javadoc-Referenz I2CP-Paket MessageStatusMessage Client-API Abkündigungsübersicht Veraltete Nachrichten (nicht verwenden) CreateLeaseSetMessage (Typ 4): Verwende CreateLeaseSet2Message RequestLeaseSetMessage (Typ 21): Verwende RequestVariableLeaseSetMessage ReceiveMessageBeginMessage (Typ 6): Verwende schnellen Empfangsmodus ReceiveMessageEndMessage (Typ 7): Verwende schnellen Empfangsmodus DestLookupMessage (Typ 34): Verwende HostLookupMessage DestReplyMessage (Typ 35): Verwende HostReplyMessage ReportAbuseMessage (Typ 29): Nie implementiert Veraltete Optionen ElGamal-Verschlüsselung (Typ 0): Umstellung auf ECIES-X25519 (Typ 4) DSA-Signaturen: Umstellung auf EdDSA oder ECDSA i2cp.fastReceive=false: Immer den schnellen Empfangsmodus verwenden ","description":"Wie Anwendungen Sitzungen, tunnels und LeaseSets mit dem I2P router aushandeln.","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"I2P-Client-Protokoll (I2CP)","url":"/de/docs/specs/i2cp/"},{"categories":null,"content":"Übersicht Das I2P‑Netzwerkprotokoll (I2NP) definiert, wie router Nachrichten austauschen, Transporte auswählen und den Datenverkehr mischen, wobei die Anonymität gewahrt bleibt. Es arbeitet zwischen I2CP (Client-API) und den Transportprotokollen (NTCP2 und SSU2).\nI2NP ist die Schicht oberhalb der I2P-Transportprotokolle. Es ist ein router-zu-router-Protokoll, das verwendet wird für: - Netzwerkdatenbankabfragen und -antworten - Erstellen von tunnels - Verschlüsselte router- und Client-Datennachrichten\nI2NP-Nachrichten können Punkt-zu-Punkt an einen anderen router gesendet werden oder anonym durch tunnels an denselben router.\nRouter reihen ausgehende Aufgaben anhand lokaler Prioritäten in die Warteschlange ein. Höhere Prioritätswerte werden zuerst verarbeitet. Alles oberhalb der Standardpriorität für tunnel-Daten (400) wird als dringend behandelt.\nAktuelle Transportprotokolle I2P verwendet jetzt NTCP2 (TCP) und SSU2 (UDP) sowohl für IPv4 als auch für IPv6. Beide Transporte nutzen: - X25519-Schlüsselaustausch (Noise-Protokoll-Framework) - ChaCha20/Poly1305-authentifizierte Verschlüsselung (AEAD) - SHA-256-Hashing\nVeraltete Transportprotokolle entfernt: - NTCP (ursprüngliches TCP) wurde aus dem Java router mit Version 0.9.50 (Mai 2021) entfernt - SSU v1 (ursprüngliches UDP) wurde aus dem Java router mit Version 2.4.0 (Dezember 2023) entfernt - SSU v1 wurde aus i2pd mit Version 2.44.0 (November 2022) entfernt\nSeit 2025 ist das Netzwerk vollständig auf Noise-basierte Transporte umgestellt und bietet keinerlei Unterstützung mehr für Legacy-Transporte.\nSystem zur Versionsnummerierung WICHTIG: I2P verwendet ein doppeltes Versionsschema, das eindeutig verstanden werden muss:\nRelease-Versionen (benutzerorientiert) Dies sind die Versionen, die Nutzer sehen und herunterladen: - 0.9.50 (Mai 2021) - Letzte 0.9.x-Version - 1.5.0 (August 2021) - Erste 1.x-Version - 1.6.0, 1.7.0, 1.8.0, 1.9.0 (von 2021 bis 2022) - 2.0.0 (November 2022) - Erste 2.x-Version - 2.1.0 bis 2.9.0 (von 2023 bis 2025) - 2.10.0 (8. September 2025) - Aktuelle Version\nAPI-Versionen (Protokollkompatibilität) Dies sind interne Versionsnummern, die im Feld \u0026ldquo;router.version\u0026rdquo; in den RouterInfo-Eigenschaften veröffentlicht werden: - 0.9.50 (Mai 2021) - 0.9.51 (August 2021) - API-Version für Release 1.5.0 - 0.9.52 bis 0.9.66 (fortlaufend über die 2.x-Releases) - 0.9.67 (September 2025) - API-Version für Release 2.10.0\nWichtiger Hinweis: Es gab KEINE Releases mit den Versionsnummern 0.9.51 bis 0.9.67. Diese Nummern existieren nur als API-Versionskennungen. I2P sprang von Release 0.9.50 direkt auf 1.5.0.\nTabelle zur Versionszuordnung Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) **Bevorstehend:** Version 2.11.0 (geplant für Dezember 2025) wird Java 17+ voraussetzen und Post-Quanten-Kryptografie standardmäßig aktivieren. Protokollversionen Alle router müssen ihre I2NP-Protokollversion im Feld \u0026ldquo;router.version\u0026rdquo; in den RouterInfo-Eigenschaften veröffentlichen. Dieses Versionsfeld ist die API-Version, die den Unterstützungsgrad für verschiedene I2NP-Protokollfunktionen angibt, und entspricht nicht notwendigerweise der tatsächlichen Version des routers.\nWenn alternative (nicht-Java) routers Versionsinformationen über die tatsächliche router-Implementierung veröffentlichen möchten, müssen sie dies in einer anderen Eigenschaft tun. Andere als die unten aufgeführten Versionen sind zulässig. Die Unterstützung wird anhand eines numerischen Vergleichs bestimmt; zum Beispiel impliziert 0.9.13 Unterstützung für die Funktionen von 0.9.12.\nHinweis: Die Eigenschaft \u0026ldquo;coreVersion\u0026rdquo; wird in der router info nicht mehr veröffentlicht und wurde nie zur Bestimmung der I2NP-Protokollversion verwendet.\nFunktionsübersicht nach API-Version API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network **Hinweis:** Es gibt außerdem transportbezogene Funktionen und Kompatibilitätsprobleme. Siehe die Transportdokumentation zu NTCP2 und SSU2 für Details. Nachrichtenkopf I2NP verwendet eine logische 16-Byte-Headerstruktur, während moderne Transportprotokolle (NTCP2 und SSU2) einen verkürzten 9-Byte-Header verwenden, der redundante Felder für Größe und Prüfsumme weglässt. Die Felder bleiben konzeptionell identisch.\nVergleich der Header-Formate Standardformat (16 Byte):\nWird im Legacy-NTCP-Transport verwendet sowie wenn I2NP-Nachrichten in andere Nachrichten (TunnelData, TunnelGateway, GarlicClove) eingebettet sind.\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity Kurzformat für SSU (veraltet, 5 Bytes):\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) Kurzformat für NTCP2, SSU2 und ECIES-Ratchet Garlic Cloves (Einzelnachrichten innerhalb einer Garlic-Nachricht) (9 Bytes):\nWird in modernen Transportprotokollen und in ECIES-verschlüsselten garlic messages (I2P-Nachrichtenbündeln) verwendet.\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) Details zu Header-Feldern Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity ### Hinweise zur Implementierung Bei Übertragung über SSU (veraltet) waren nur Typ und eine 4-Byte-Ablaufzeit enthalten Bei Übertragung über NTCP2 oder SSU2 wird das 9-Byte-Kurzformat verwendet Der standardmäßige 16-Byte-Header ist für I2NP-Nachrichten erforderlich, die in anderen Nachrichten enthalten sind (Data, TunnelData, TunnelGateway, GarlicClove) Seit Version 0.8.12 ist die Prüfsummenprüfung an einigen Stellen im Protokollstapel aus Effizienzgründen deaktiviert, die Erzeugung von Prüfsummen ist jedoch aus Kompatibilitätsgründen weiterhin erforderlich Die kurze Ablaufzeit ist vorzeichenlos und überläuft am 7. Februar 2106. Nach diesem Datum muss ein Offset hinzugefügt werden, um die korrekte Zeit zu erhalten Zur Kompatibilität mit älteren Versionen sind Prüfsummen stets zu erzeugen, auch wenn sie möglicherweise nicht verifiziert werden Größenbeschränkungen Tunnel-Nachrichten fragmentieren I2NP-Payloads (Nutzlasten) in Stücke fester Größe: - Erstes Fragment: ungefähr 956 Bytes - Nachfolgende Fragmente: jeweils ungefähr 996 Bytes - Maximale Anzahl Fragmente: 64 (nummeriert 0-63) - Maximale Payload: ungefähr 61.200 Bytes (61,2 KB)\nBerechnung: 956 + (63 × 996) = 63.704 Bytes theoretisches Maximum, mit praktischem Limit von etwa 61.200 Bytes aufgrund von Overhead.\nHistorischer Kontext Ältere Transportprotokolle hatten strengere Grenzwerte für die Frame-Größe: - NTCP: 16 KB große Frames - SSU: ungefähr 32 KB große Frames\nNTCP2 unterstützt ungefähr 65-KB-Frames, aber die tunnel-Fragmentierungsgrenze gilt weiterhin.\nÜberlegungen zu Anwendungsdaten Garlic messages (Garlic-Nachrichten) können LeaseSets, Session Tags (Sitzungs-Tags) oder verschlüsselte LeaseSet2-Varianten bündeln, was den verfügbaren Platz für Nutzdaten verringert.\nEmpfehlung: Datagramme sollten ≤ 10 KB groß sein, um eine zuverlässige Übermittlung zu gewährleisten. Nachrichten, die sich dem 61-KB-Limit nähern, können Folgendes aufweisen: - Erhöhte Latenz aufgrund der Reassemblierung fragmentierter Daten - Höhere Wahrscheinlichkeit eines Zustellfehlers - Größere Anfälligkeit für Traffic-Analyse (Verkehrsanalyse)\nTechnische Details zur Fragmentierung Jede tunnel-Nachricht ist genau 1.024 Bytes (1 KB) groß und enthält: - 4-Byte tunnel-ID - 16-Byte Initialisierungsvektor (IV) - 1.004 Bytes verschlüsselter Daten\nInnerhalb der verschlüsselten Daten transportieren tunnel-Nachrichten fragmentierte I2NP-Nachrichten mit Fragment-Headern, die Folgendes angeben: - Fragmentnummer (0-63) - Ob dies das erste oder ein Folgefragment ist - Gesamt-Nachrichten-ID zur Wiederzusammensetzung\nDas erste Fragment enthält den vollständigen I2NP-Nachrichten-Header (16 Byte), wodurch ungefähr 956 Byte für die Nutzlast verbleiben. Nachfolgende Fragmente enthalten den Nachrichten-Header nicht, sodass pro Fragment ungefähr 996 Byte Nutzlast möglich sind.\nÜbliche Nachrichtentypen Routers verwenden den Nachrichtentyp und die Priorität, um ausgehende Aufgaben zu planen. Höhere Prioritätswerte werden zuerst verarbeitet. Die unten aufgeführten Werte entsprechen den aktuellen Standardwerten von Java I2P (Stand API-Version 0.9.67).\nHinweis: Die Prioritäten sind implementierungsabhängig. Verbindliche Prioritätswerte finden Sie in der Dokumentation der Klasse OutNetMessage im Java-I2P-Quellcode.\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) **Reservierte Nachrichtentypen:** - Typ 0: Reserviert - Typen 4-9: Für zukünftige Verwendung reserviert - Typen 12-17: Für zukünftige Verwendung reserviert - Typen 224-254: Für experimentelle Nachrichten reserviert - Typ 255: Für zukünftige Erweiterungen reserviert Hinweise zu Nachrichtentypen Nachrichten der Steuerungsebene (DatabaseLookup, TunnelBuild, etc.) laufen typischerweise über exploratory tunnels (Erkundungs-Tunnel), nicht über client tunnels (Client-Tunnel), wodurch eine unabhängige Priorisierung möglich ist Prioritätswerte sind ungefähre Angaben und können je nach Implementierung variieren TunnelBuild (21) und TunnelBuildReply (22) sind veraltet, werden aber weiterhin implementiert, um die Kompatibilität mit sehr langen tunnels (\u0026gt;8 Hops) zu gewährleisten Die Standard-Priorität für Daten in tunnels beträgt 400; alles darüber wird als dringend behandelt Die typische Länge von tunnels im heutigen Netzwerk beträgt 3-4 Hops, daher verwenden die meisten tunnel builds (Tunnelaufbauten) ShortTunnelBuild (218-Byte-Datensätze) oder VariableTunnelBuild (528-Byte-Datensätze) Verschlüsselung und Nachrichtenkapselung Routers verkapseln häufig I2NP-Nachrichten vor der Übertragung und erzeugen dadurch mehrere Verschlüsselungsschichten. Eine DeliveryStatus-Nachricht kann sein: 1. In einer GarlicMessage verpackt (verschlüsselt) 2. In einer DataMessage 3. In einer TunnelData-Nachricht (erneut verschlüsselt)\nJeder Hop entschlüsselt nur seine eigene Schicht; der endgültige Empfänger legt die innerste Nutzlast offen.\nVerschlüsselungsalgorithmen Veraltet (wird schrittweise ausgemustert): - ElGamal/AES + SessionTags (Sitzungs-Tags) - ElGamal-2048 für asymmetrische Verschlüsselung - AES-256 für symmetrische Verschlüsselung - 32-Byte SessionTags\nAktuell (Standard seit API 0.9.48): - ECIES-X25519 + ChaCha20/Poly1305 AEAD mit Ratcheting-Vorwärtsgeheimnis - Noise-Protokoll-Framework (Noise_IK_25519_ChaChaPoly_SHA256 für Ziele) - 8-Byte Session-Tags (reduziert von 32 Byte) - Signal-Double-Ratchet-Algorithmus für Vorwärtsgeheimnis - Eingeführt in API-Version 0.9.46 (2020) - Seit API-Version 0.9.58 (2023) für alle routers obligatorisch\nZukunft (Beta seit 2.10.0): - Post-Quanten-Hybridkryptografie unter Verwendung von MLKEM (ML-KEM-768), kombiniert mit X25519 - Hybride Ratchet (Schlüssel-Update-Mechanismus), die klassischen und Post-Quanten-Schlüsselaustausch kombiniert - Abwärtskompatibel mit ECIES-X25519 - Wird zum Standard in Release 2.11.0 (Dezember 2025)\nElGamal Router Abkündigung KRITISCH: ElGamal routers wurden ab API-Version 0.9.58 (Release 2.2.0, März 2023) als veraltet markiert. Da die für Abfragen empfohlene minimale floodfill-Version nun 0.9.58 ist, müssen Implementierungen für ElGamal floodfill routers keine Verschlüsselung implementieren.\nAllerdings: ElGamal destinations (Ziele) werden aus Gründen der Abwärtskompatibilität weiterhin unterstützt. Clients, die ElGamal-Verschlüsselung verwenden, können weiterhin über ECIES routers kommunizieren.\nDetails zum ECIES-X25519-AEAD-Ratchet Dies ist Krypto-Typ 4 in der Kryptografie-Spezifikation von I2P. Er bietet:\nWichtige Merkmale: - Vorwärtsgeheimhaltung durch ratcheting (stufenweise Schlüsselaktualisierung; neue Schlüssel für jede Nachricht) - Reduzierter Speicherbedarf für Session-Tags (8 Byte statt 32 Byte) - Mehrere Session-Typen (Neue Session, bestehende Session, einmalig) - Basiert auf dem Noise-Protokoll Noise_IK_25519_ChaChaPoly_SHA256 - Integriert mit dem Double Ratchet-Algorithmus von Signal\nKryptographische Primitive: - X25519 für den Diffie-Hellman-Schlüsselaustausch - ChaCha20 zur Stream-Verschlüsselung - Poly1305 zur Nachrichtenauthentifizierung (AEAD) - SHA-256 zum Hashing - HKDF zur Schlüsselableitung\nSitzungsverwaltung: - Neue Sitzung: Anfängliche Verbindung über den statischen Schlüssel der Destination (Ziel) - Bestehende Sitzung: Nachfolgende Nachrichten mithilfe von Session Tags (Sitzungs-Tags) - Einmalsitzung: Sitzungen mit nur einer Nachricht für geringeren Overhead\nSiehe ECIES Specification und Proposal 144 für vollständige technische Details.\nGemeinsame Strukturen Die folgenden Strukturen sind Bestandteile mehrerer I2NP-Nachrichten. Sie sind keine vollständigen Nachrichten.\nBuildRequestRecord (Aufbauanforderungs-Datensatz) (ElGamal) VERALTET. Wird im aktuellen Netzwerk nur verwendet, wenn ein tunnel einen ElGamal router enthält. Siehe ECIES Tunnel-Erstellung für das moderne Format.\nZweck: Ein Datensatz in einer Gruppe mehrerer Datensätze, um die Erstellung eines Hops im tunnel anzufordern.\nFormat:\nMit ElGamal und AES verschlüsselt (insgesamt 528 Bytes):\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ ElGamal-verschlüsselte Struktur (528 Bytes):\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) Klartextstruktur (222 Byte vor der Verschlüsselung):\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data Hinweise: - Die ElGamal-2048-Verschlüsselung erzeugt einen 514-Byte-Block, aber die beiden Padding-Bytes (Auffüll-Bytes) (an den Positionen 0 und 257) werden entfernt, wodurch 512 Bytes verbleiben - Siehe Spezifikation zur Tunnel-Erstellung für Details zu den Feldern - Quellcode: net.i2p.data.i2np.BuildRequestRecord - Konstante: EncryptedBuildRecord.RECORD_SIZE = 528\nBuildRequestRecord (ECIES-X25519 Long) Für ECIES-X25519 routers, eingeführt in API-Version 0.9.48. Verwendet 528 Bytes zur Abwärtskompatibilität mit gemischten tunnels.\nFormat:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) Gesamtgröße: 528 Bytes (identisch mit ElGamal zur Kompatibilität)\nSiehe ECIES Tunnel Creation für die Klartextstruktur und Details zur Verschlüsselung.\nBuildRequestRecord (Datensatz für Aufbauanforderung) (ECIES-X25519 Short) Nur für ECIES-X25519 Router, ab API-Version 0.9.51 (Release 1.5.0). Dies ist das aktuelle Standardformat.\nFormat:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) Gesamtgröße: 218 Bytes (59 % Reduktion gegenüber 528 Bytes)\nWesentlicher Unterschied: Kurzdatensätze leiten ALLE Schlüssel über HKDF (Schlüsselableitungsfunktion) ab, statt sie explizit im Datensatz aufzuführen. Dazu gehören: - Layer-Schlüssel (für tunnel-Verschlüsselung) - IV-Schlüssel (für tunnel-Verschlüsselung) - Antwort-Schlüssel (für Build-Antwort) - Antwort-IVs (für Build-Antwort)\nAlle Schlüssel werden mithilfe des HKDF-Mechanismus des Noise-Protokolls auf Basis des gemeinsamen Geheimnisses aus dem X25519-Schlüsselaustausch abgeleitet.\nVorteile: - 4 kurze Datensätze passen in eine tunnel-Nachricht (873 Bytes) - 3 Nachrichten für den tunnel-Aufbau statt separater Nachrichten für jeden Datensatz - Reduzierter Bandbreitenbedarf und geringere Latenz - Gleiche Sicherheitseigenschaften wie das Langformat\nSiehe Proposal 157 für die Begründung und ECIES Tunnel Creation (ECIES: Elliptic Curve Integrated Encryption Scheme, Verschlüsselungsschema mit elliptischen Kurven) für die vollständige Spezifikation.\nQuellcode: - net.i2p.data.i2np.ShortEncryptedBuildRecord - Konstante: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nBuildResponseRecord (ElGamal) VERALTET. Wird nur verwendet, wenn der tunnel einen ElGamal router enthält.\nZweck: Ein Eintrag in einer Sammlung mehrerer Einträge mit Antworten auf eine Aufbauanfrage.\nFormat:\nVerschlüsselt (528 Bytes, gleiche Größe wie BuildRequestRecord):\nbytes 0-527 :: AES-encrypted record Unverschlüsselte Struktur:\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) Antwortcodes: - 0 - Annehmen - 30 - Ablehnen (Bandbreitenlimit überschritten)\nSiehe Spezifikation zur Tunnel-Erstellung für Details zum Antwortfeld.\nBuildResponseRecord (ECIES-X25519) Für ECIES-X25519 (ECIES mit Curve25519) routers, API-Version 0.9.48+. Gleiche Größe wie die entsprechende Anfrage (528 für lang, 218 für kurz).\nFormat:\nAusführliches Format (528 Bytes):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Kurzformat (218 Bytes):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Klartextstruktur (beide Formate):\nEnthält eine Mapping-Struktur (I2Ps Schlüssel-Wert-Format) mit: - Antwortstatuscode (erforderlich) - Parameter für verfügbare Bandbreite (\u0026ldquo;b\u0026rdquo;) (optional, hinzugefügt in API 0.9.65) - Weitere optionale Parameter für zukünftige Erweiterungen\nAntwort-Statuscodes: - 0 - Erfolg - 30 - Abgelehnt: Bandbreite überschritten\nSiehe ECIES Tunnel-Erstellung für die vollständige Spezifikation.\nGarlicClove (ElGamal/AES) WARNUNG: Dies ist das Format, das für garlic cloves (einzelne Teilnachrichten im Garlic-Verfahren) innerhalb von ElGamal-verschlüsselten garlic messages verwendet wird. Das Format für ECIES-AEAD-X25519-Ratchet garlic messages und garlic cloves unterscheidet sich erheblich. Siehe ECIES Specification für das moderne Format.\nVeraltet für routers (API 0.9.58+), für Ziele weiterhin unterstützt.\nFormat:\nUnverschlüsselt:\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) Hinweise: - Cloves (Teilnachrichten) werden niemals fragmentiert - Wenn das erste Bit des Delivery Instructions-Flag-Bytes 0 ist, ist der clove nicht verschlüsselt - Wenn das erste Bit 1 ist, ist der clove verschlüsselt (nicht implementierte Funktion) - Die maximale Länge ist eine Funktion der gesamten clove-Längen und der maximalen GarlicMessage-Länge (Nachrichtentyp in I2NP) - Das Zertifikat könnte möglicherweise für HashCash verwendet werden, um für das Routing zu „bezahlen“ (zukünftige Möglichkeit) - In der Praxis verwendete Nachrichten: DataMessage, DeliveryStatusMessage, DatabaseStoreMessage - GarlicMessage kann GarlicMessage enthalten (verschachtelt), wird in der Praxis jedoch nicht verwendet\nSiehe Garlic Routing (eine in I2P verwendete Routing-Technik) für eine konzeptionelle Übersicht.\nGarlicClove (Einzelelement einer Garlic-Nachricht) (ECIES-X25519-AEAD-Ratchet) Für ECIES-X25519 routers und Ziele, API-Version 0.9.46+. Dies ist das aktuelle Standardformat.\nKRITISCHER UNTERSCHIED: ECIES garlic verwendet eine völlig andere Struktur, die auf Noise-Protokoll-Blöcken basiert, statt auf expliziten clove-Strukturen (clove = Teilnachricht innerhalb einer garlic-Nachricht in I2P).\nFormat:\nECIES-Garlic-Nachrichten enthalten eine Reihe von Blöcken:\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data Blocktypen: - 0 - Garlic Clove Block (enthält eine I2NP-Nachricht) - 1 - DateTime Block (Zeitstempel) - 2 - Options Block (Übermittlungsoptionen) - 3 - Padding Block - 254 - Termination Block (nicht implementiert)\nGarlic Clove Block (Typ 0):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ Wesentliche Unterschiede zum ElGamal-Format: - Verwendet eine 4-Byte-Ablaufzeit (Sekunden seit der Unix-Epoche) statt eines 8-Byte-Datums - Kein Zertifikat-Feld - Eingebettet in eine Blockstruktur mit Typ und Länge - Gesamte Nachricht mit ChaCha20/Poly1305 AEAD verschlüsselt - Sitzungsverwaltung über ratcheting (Schlüssel-Ratchet-Verfahren)\nAusführliche Informationen zum Noise-Protokoll-Framework und zu den Blockstrukturen finden Sie in der ECIES-Spezifikation .\nZustellungsanweisungen für Garlic Clove (Einzelnachricht in der garlic encryption) Dieses Format wird sowohl für ElGamal- als auch für ECIES garlic cloves (Teilnachrichten im Rahmen der garlic encryption) verwendet. Es legt fest, wie die enthaltene Nachricht zugestellt wird.\nKRITISCHE WARNUNG: Diese Spezifikation gilt AUSSCHLIESSLICH für \u0026ldquo;Delivery Instructions\u0026rdquo; (Zustellanweisungen) innerhalb von \u0026ldquo;Garlic Cloves\u0026rdquo; (Einzelelementen einer Garlic-Nachricht). \u0026ldquo;Delivery Instructions\u0026rdquo; werden auch innerhalb von Tunnel-Nachrichten verwendet, wo das Format deutlich anders ist. Siehe die Spezifikation für Tunnel-Nachrichten für Delivery Instructions in Tunnel-Nachrichten. Verwechseln Sie diese beiden Formate NICHT.\nFormat:\nSitzungsschlüssel und Verzögerung werden nicht verwendet und sind nie vorhanden, daher sind die drei möglichen Längen:\n1 Byte (LOCAL) 33 Bytes (ROUTER und DESTINATION) 37 Bytes (TUNNEL) +----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds Typische Längen: - LOKALE Zustellung: 1 Byte (nur Flag) - ROUTER / ZIEL Zustellung: 33 Byte (Flag + Hash) - TUNNEL Zustellung: 37 Byte (Flag + Hash + tunnel ID)\nBeschreibungen der Zustelltypen:\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router **Hinweise zur Implementierung:** - Die Verschlüsselung mit Sitzungsschlüssel ist nicht implementiert und das Flag-Bit ist immer 0 - Die Verzögerung ist nicht vollständig implementiert und das Flag-Bit ist immer 0 - Für TUNNEL-Zustellung identifiziert der Hash den Gateway router und die tunnel ID gibt an, welcher eingehende tunnel - Für DESTINATION (Ziel-Identität)-Zustellung ist der Hash der SHA-256-Hash des öffentlichen Schlüssels der destination - Für ROUTER-Zustellung ist der Hash der SHA-256-Hash der Identität des router I2NP-Nachrichten Vollständige Nachrichtenspezifikationen für alle I2NP-Nachrichtentypen.\nZusammenfassung der Nachrichtentypen Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active **Reserviert:** - Typ 0: Reserviert - Typen 4-9: Für zukünftige Verwendung reserviert - Typen 12-17: Für zukünftige Verwendung reserviert - Typen 224-254: Für experimentelle Nachrichten reserviert - Typ 255: Für zukünftige Erweiterungen reserviert DatabaseStore (Typ 1) Zweck: Eine unaufgeforderte Datenbankspeicherung oder die Antwort auf eine erfolgreiche DatabaseLookup-Nachricht (Nachrichtentyp zur Datenbanksuche).\nInhalt: Ein nicht komprimiertes LeaseSet, LeaseSet2, MetaLeaseSet oder EncryptedLeaseSet, oder eine komprimierte RouterInfo.\nFormat mit Antwort-Token:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet Format mit Antwort-Token == 0:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// Hinweise: - Aus Sicherheitsgründen werden die Antwortfelder ignoriert, wenn die Nachricht über einen tunnel empfangen wird - Der Schlüssel ist der „echte“ Hash der RouterIdentity oder Destination, NICHT der Routing-Schlüssel - Die Typen 3, 5 und 7 (LeaseSet2-Varianten) wurden in Release 0.9.38 (API 0.9.38) hinzugefügt. Siehe Proposal 123 für Details - Diese Typen sollten nur an router mit API-Version 0.9.38 oder höher gesendet werden - Als Optimierung zur Reduzierung von Verbindungen gilt: Wenn der Typ ein LeaseSet ist, das Antwort-Token enthalten ist, die Antwort-tunnel-ID ungleich Null ist und das Antwort-Gateway/tunnelID-Paar im LeaseSet als Lease gefunden wird, darf der Empfänger die Antwort über jede andere Lease im LeaseSet umleiten - RouterInfo gzip-Format: Um das Betriebssystem des router und die Implementierung zu verbergen, sollte die Java-router-Implementierung nachgeahmt werden, indem die Modifikationszeit auf 0 und das OS-Byte auf 0xFF gesetzt und XFL gemäß RFC 1952 auf 0x02 gesetzt wird (maximale Kompression, langsamster Algorithmus). Erste 10 Bytes: 1F 8B 08 00 00 00 00 00 02 FF\nQuellcode: - net.i2p.data.i2np.DatabaseStoreMessage - net.i2p.data.RouterInfo (für die RouterInfo-Struktur) - net.i2p.data.LeaseSet (für die LeaseSet-Struktur)\nDatabaseLookup (Datenbanksuche) (Typ 2) Zweck: Eine Anfrage, um einen Eintrag in der Netzwerkdatenbank nachzuschlagen. Die Antwort ist entweder ein DatabaseStore (Nachricht zum Speichern in der Datenbank) oder eine DatabaseSearchReply (Antwort auf eine Datenbanksuche).\nFormat:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) Modi der Antwortverschlüsselung:\nHINWEIS: ElGamal routers sind seit API 0.9.58 veraltet. Da die empfohlene minimale floodfill-Version, die abgefragt werden soll, jetzt 0.9.58 ist, müssen Implementierungen keine Verschlüsselung für ElGamal floodfill routers implementieren. ElGamal destinations (Zieladressen) werden weiterhin unterstützt.\nFlag-Bit 4 (ECIESFlag) wird in Kombination mit Bit 1 (encryptionFlag) verwendet, um den Antwortverschlüsselungsmodus zu bestimmen:\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future **Keine Verschlüsselung (Flags 0,0):** reply_key, tags und reply_tags sind nicht vorhanden.\nElG nach ElG (Flags 0,1) - VERALTET:\nUnterstützt seit 0.9.7, seit 0.9.58 als veraltet markiert.\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES zu ElG (Flags 1,0) - VERALTET:\nAb Version 0.9.46 unterstützt, ab Version 0.9.58 als veraltet eingestuft.\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data Die Antwort ist eine ECIES Existing Session message (Nachricht für eine bestehende Sitzung), wie in der ECIES-Spezifikation definiert:\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES zu ECIES (Flags 1,0) - AKTUELLER STANDARD:\nEine ECIES Destination (Ziel) oder ein router sendet ein Lookup (Abfrage) an einen ECIES router. Unterstützt seit 0.9.49.\nDasselbe Format wie oben bei \u0026ldquo;ECIES to ElG\u0026rdquo;. Die Verschlüsselung der Abfrage-Nachricht ist in ECIES Routers spezifiziert. Der Anfragende ist anonym.\nECIES (integriertes Verschlüsselungsschema mit elliptischen Kurven) zu ECIES mit DH (Diffie-Hellman-Schlüsselaustausch) (flags 1,1) - ZUKUNFT:\nNoch nicht vollständig definiert. Siehe Proposal 156 .\nQuellcode: - net.i2p.data.i2np.DatabaseLookupMessage - Verschlüsselung: net.i2p.crypto.SessionKeyManager\nDatabaseSearchReply (Antwort auf Datenbanksuche) (Typ 3) Zweck: Die Antwort auf eine fehlgeschlagene DatabaseLookup-Nachricht (Nachricht zur Datenbanksuche).\nInhalt: Eine Liste von router-Hashes, die dem angeforderten Schlüssel am nächsten liegen.\nFormat:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from Hinweise: - Der \u0026lsquo;from\u0026rsquo;-Hash ist nicht authentifiziert und nicht vertrauenswürdig - Die zurückgegebenen Peer-Hashes sind nicht notwendigerweise näher am Schlüssel als der abgefragte router. Bei Antworten auf reguläre Abfragen erleichtert dies die Entdeckung neuer floodfills und das „rückwärtsgerichtete“ Suchen (weiter-vom-Schlüssel-entfernt) für mehr Robustheit - Bei Erkundungsabfragen wird der Schlüssel normalerweise zufällig erzeugt. Die nicht-floodfill peer_hashes der Antwort können mithilfe eines optimierten Algorithmus ausgewählt werden (z. B. nahe, aber nicht unbedingt nächstgelegene Peers), um eine ineffiziente Sortierung der gesamten lokalen Datenbank zu vermeiden. Es können auch Caching-Strategien verwendet werden. Dies ist implementierungsabhängig - Typische Anzahl zurückgegebener Hashes: 3 - Empfohlene maximale Anzahl zurückzugebender Hashes: 16 - Der Lookup-Schlüssel, die Peer-Hashes und der from-Hash sind \u0026ldquo;echte\u0026rdquo; Hashes, KEINE Routing-Schlüssel - Wenn num 0 ist, bedeutet dies, dass keine näheren Peers gefunden wurden (Sackgasse)\nQuellcode: - net.i2p.data.i2np.DatabaseSearchReplyMessage\nZustellstatus (Typ 10) Zweck: Eine einfache Nachrichtenbestätigung. Wird im Allgemeinen vom Absender der Nachricht erstellt und zusammen mit der eigentlichen Nachricht in einer Garlic Message (I2P-Nachricht, die mehrere Teilnachrichten bündelt) verpackt, damit sie vom Ziel zurückgesendet wird.\nInhalt: Die ID der zugestellten Nachricht und die Erstellungs- oder Ankunftszeit.\nFormat:\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered Hinweise: - Der Zeitstempel wird vom Ersteller stets auf die aktuelle Zeit gesetzt. Es gibt jedoch mehrere Verwendungen dafür im Code, und in Zukunft könnten weitere hinzukommen - Diese Nachricht wird in SSU auch als Bestätigung einer aufgebauten Sitzung verwendet. In diesem Fall wird die Nachrichten-ID auf eine Zufallszahl gesetzt, und die \u0026ldquo;Ankunftszeit\u0026rdquo; wird auf die aktuelle netzwerkweite ID gesetzt, die derzeit 2 ist (d. h., 0x0000000000000002) - DeliveryStatus wird typischerweise in eine GarlicMessage verpackt und durch einen tunnel gesendet, um eine Bestätigung zu liefern, ohne den Absender offenzulegen - Wird für tunnel-Tests verwendet, um Latenz und Zuverlässigkeit zu messen\nQuellcode: - net.i2p.data.i2np.DeliveryStatusMessage - Verwendet in: net.i2p.router.tunnel.InboundEndpointProcessor für tunnel-Tests\nGarlicMessage (I2NP-Nachricht; Typ 11) WARNUNG: Dies ist das Format, das für ElGamal-verschlüsselte Garlic-Nachrichten verwendet wird. Das Format für ECIES-AEAD-X25519-Ratchet-Garlic-Nachrichten ist erheblich unterschiedlich. Siehe ECIES-Spezifikation für das moderne Format.\nZweck: Wird verwendet, um mehrere verschlüsselte I2NP-Nachrichten zu kapseln.\nInhalt: Nach der Entschlüsselung enthält es eine Reihe von Garlic Cloves (Einzelelemente einer Garlic-Nachricht) und zusätzliche Daten, auch als Clove Set bezeichnet.\nVerschlüsseltes Format:\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data Entschlüsselte Daten (Clove Set, Menge einzelner Teilnachrichten innerhalb einer gebündelten Nachricht):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) Für das ECIES-X25519-AEAD-Ratchet-Format (aktueller Standard für routers):\nSiehe ECIES-Spezifikation und Vorschlag 144 .\nQuellcode: - net.i2p.data.i2np.GarlicMessage - Verschlüsselung: net.i2p.crypto.elgamal.ElGamalAESEngine (veraltet) - Moderne Verschlüsselung: net.i2p.crypto.ECIES Pakete\nTunnelData (Typ 18) Zweck: Eine Nachricht, die vom Gateway oder einem Teilnehmer eines tunnel an den nächsten Teilnehmer oder Endpunkt gesendet wird. Die Daten haben eine feste Länge und enthalten I2NP-Nachrichten, die fragmentiert, gebündelt, aufgefüllt und verschlüsselt sind.\nFormat:\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes Aufbau der Nutzdaten (1024 Bytes):\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) Hinweise: - Die I2NP-Nachrichten-ID für TunnelData wird bei jedem Hop (Sprung) auf eine neue Zufallszahl gesetzt - Das tunnel-Nachrichtenformat (innerhalb der verschlüsselten Daten) ist in Spezifikation für tunnel-Nachrichten definiert - Jeder Hop entschlüsselt eine Schicht mit AES-256 im CBC-Modus - Der IV (Initialisierungsvektor) wird bei jedem Hop anhand der entschlüsselten Daten aktualisiert - Die Gesamtgröße beträgt genau 1,028 Bytes (4 tunnelId + 1024 data) - Dies ist die grundlegende Einheit des tunnel-Verkehrs - TunnelData-Nachrichten transportieren fragmentierte I2NP-Nachrichten (GarlicMessage, DatabaseStore, usw.)\nQuellcode: - net.i2p.data.i2np.TunnelDataMessage - Konstante: TunnelDataMessage.DATA_LENGTH = 1024 - Verarbeitung: net.i2p.router.tunnel.InboundGatewayProcessor\nTunnelGateway (Typ 19) Zweck: Kapselt eine weitere I2NP-Nachricht, die am Eingangs-Gateway von einem tunnel in diesen tunnel eingespeist werden soll.\nFormat:\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message Hinweise: - Die Nutzlast ist eine I2NP-Nachricht mit einem standardmäßigen 16-Byte-Header - Dient dazu, Nachrichten vom lokalen router in tunnels einzuspeisen - Das Gateway fragmentiert die eingeschlossene Nachricht bei Bedarf - Nach der Fragmentierung werden die Fragmente in TunnelData-Nachrichten verpackt - TunnelGateway wird nie über das Netzwerk gesendet; es ist ein interner Nachrichtentyp, der vor der Verarbeitung im tunnel verwendet wird\nQuellcode: - net.i2p.data.i2np.TunnelGatewayMessage - Verarbeitung: net.i2p.router.tunnel.OutboundGatewayProcessor\nDataMessage (Typ 20) Zweck: Wird von Garlic Messages (Garlic-Nachrichten) und Garlic Cloves (Teilnachrichten) verwendet, um beliebige Daten zu kapseln (typischerweise Ende-zu-Ende-verschlüsselte Anwendungsdaten).\nFormat:\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message Hinweise: - Diese Nachricht enthält keine Routing-Informationen und wird niemals \u0026ldquo;unverpackt\u0026rdquo; gesendet - Wird nur innerhalb von Garlic messages (Garlic-Nachrichten) verwendet - Enthält typischerweise Ende-zu-Ende-verschlüsselte Anwendungsdaten (HTTP, IRC, E-Mail usw.) - Die Daten sind üblicherweise eine ElGamal/AES- oder ECIES-verschlüsselte Nutzlast - Die maximal praktikable Länge beträgt aufgrund der Fragmentierungsgrenzen von tunnel-Nachrichten etwa 61,2 KB\nQuellcode: - net.i2p.data.i2np.DataMessage\nTunnelBuild (Tunnelaufbau, Typ 21) VERALTET. Verwenden Sie VariableTunnelBuild (variabler Aufbau eines tunnel) (Typ 23) oder ShortTunnelBuild (kurzformatiger Aufbau eines tunnel) (Typ 25).\nZweck: Aufbauanfrage für einen tunnel mit fester Länge über 8 Sprünge.\nFormat:\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes Hinweise: - Ab 0.9.48 kann es ECIES-X25519 BuildRequestRecords enthalten (BuildRequestRecords nach ECIES-X25519). Siehe ECIES Tunnel-Erstellung - Siehe Spezifikation zur Tunnel-Erstellung für Details - Die I2NP-Nachrichten-ID für diese Nachricht muss gemäß der Spezifikation zur Tunnel-Erstellung gesetzt werden - Obwohl dies im heutigen Netzwerk selten zu sehen ist (durch VariableTunnelBuild ersetzt), kann es für sehr lange tunnels weiterhin verwendet werden und wurde nicht formell als veraltet markiert - Routers müssen dies aus Kompatibilitätsgründen weiterhin implementieren - Das feste 8-Record-Format ist unflexibel und verschwendet Bandbreite bei kürzeren tunnels\nQuellcode: - net.i2p.data.i2np.TunnelBuildMessage - Konstante: TunnelBuildMessageBase.MAX_RECORD_COUNT = 8\nTunnelBuildReply (Typ 22) Veraltet. Verwenden Sie VariableTunnelBuildReply (Typ 24) oder OutboundTunnelBuildReply (Typ 26).\nZweck: Antwort auf den tunnel-Aufbau mit fester Länge für 8 Sprünge.\nFormat:\nDasselbe Format wie TunnelBuildMessage, mit BuildResponseRecords statt BuildRequestRecords.\nTotal size: 8 × 528 = 4,224 bytes Hinweise: - Seit 0.9.48 kann es ECIES-X25519 BuildResponseRecords enthalten. Siehe ECIES Tunnel Creation - Siehe Tunnel Creation Specification für Details - Die I2NP message ID für diese Nachricht muss gemäß der Tunnel Creation Specification gesetzt werden - Obwohl im heutigen Netzwerk selten anzutreffen (ersetzt durch VariableTunnelBuildReply), kann es für sehr lange tunnel weiterhin verwendet werden und wurde nicht formell als veraltet eingestuft - Routers müssen dies zur Wahrung der Kompatibilität weiterhin implementieren\nQuellcode: - net.i2p.data.i2np.TunnelBuildReplyMessage\nVariableTunnelBuild (Typ 23) Zweck: tunnel-Aufbau mit variabler Länge für 1-8 Hops. Unterstützt sowohl ElGamal- als auch ECIES-X25519 routers.\nFormat:\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Hinweise: - Seit 0.9.48 können ECIES-X25519 BuildRequestRecords enthalten sein. Siehe ECIES tunnel-Erstellung - Eingeführt in router-Version 0.7.12 (2009) - Darf nicht an tunnel-Teilnehmer mit Versionen älter als 0.7.12 gesendet werden - Siehe Spezifikation zur tunnel-Erstellung für Details - Die I2NP-Message-ID muss gemäß der tunnel-Erstellungsspezifikation gesetzt werden - Typische Anzahl der Datensätze: 4 (für einen 4-Hop-tunnel) - Typische Gesamtgröße: 1 + (4 × 528) = 2.113 Bytes - Dies ist die Standard-tunnel-Build-Nachricht für ElGamal router - ECIES router verwenden typischerweise stattdessen ShortTunnelBuild (Typ 25)\nQuellcode: - net.i2p.data.i2np.VariableTunnelBuildMessage\nVariableTunnelBuildReply (Typ 24) Zweck: tunnel-Build-Antwort mit variabler Länge für 1-8 Sprünge. Unterstützt sowohl ElGamal- als auch ECIES-X25519-routers.\nFormat:\nGleiches Format wie VariableTunnelBuildMessage, mit BuildResponseRecords statt BuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Hinweise: - Seit 0.9.48 kann es ECIES-X25519 BuildResponseRecords enthalten. Siehe ECIES Tunnel Creation - Eingeführt in router-Version 0.7.12 (2009) - Darf nicht an Tunnel-Teilnehmer mit einer Version früher als 0.7.12 gesendet werden - Siehe Tunnel Creation Specification für Details - Die I2NP-Nachrichten-ID muss gemäß der Tunnel Creation Specification gesetzt werden - Typische Anzahl der Datensätze: 4 - Typische Gesamtgröße: 2.113 Bytes\nQuellcode: - net.i2p.data.i2np.VariableTunnelBuildReplyMessage\nShortTunnelBuild (Typ 25) Zweck: Kurze Nachrichten zum tunnel-Aufbau nur für ECIES-X25519 routers. Eingeführt in API-Version 0.9.51 (Release 1.5.0, August 2021). Dies ist der aktuelle Standard für den ECIES-tunnel-Aufbau.\nFormat:\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Hinweise: - Eingeführt in router-Version 0.9.51 (Release 1.5.0, August 2021) - Darf an tunnel-Teilnehmer nicht vor API-Version 0.9.51 gesendet werden - Siehe ECIES Tunnel-Erstellung für die vollständige Spezifikation - Siehe Proposal 157 für die Begründung - Typische Anzahl der Datensätze: 4 - Typische Gesamtgröße: 1 + (4 × 218) = 873 Bytes - Bandbreitenersparnis: 59% kleiner als VariableTunnelBuild (873 vs 2,113 Bytes) - Leistungsvorteil: 4 kurze Datensätze passen in eine tunnel-Nachricht; VariableTunnelBuild erfordert 3 tunnel-Nachrichten - Dies ist jetzt das Standard-tunnel-Build-Format für reine ECIES-X25519 tunnels - Datensätze leiten Schlüssel mittels HKDF ab, statt sie explizit mitzuliefern\nQuellcode: - net.i2p.data.i2np.ShortTunnelBuildMessage - Konstante: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nOutboundTunnelBuildReply (Typ 26) Zweck: Vom ausgehenden Endpunkt eines neuen tunnel an den Initiator gesendet. Nur für ECIES-X25519 routers. Eingeführt in API-Version 0.9.51 (Release 1.5.0, August 2021).\nFormat:\nGleiches Format wie ShortTunnelBuildMessage, mit ShortBuildResponseRecords statt ShortBuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Hinweise: - Eingeführt in router Version 0.9.51 (Release 1.5.0, August 2021) - Siehe ECIES Tunnel-Erstellung für die vollständige Spezifikation - Typische Anzahl der Datensätze: 4 - Typische Gesamtgröße: 873 Bytes - Diese Antwort wird vom ausgehenden Endpunkt (OBEP) über den neu erstellten ausgehenden tunnel zurück an den tunnel-Ersteller gesendet - Bestätigt, dass alle Hops den tunnel-Aufbau akzeptiert haben\nQuellcode: - net.i2p.data.i2np.OutboundTunnelBuildReplyMessage\nReferenzen Offizielle Spezifikationen I2NP-Spezifikation - Vollständige Spezifikation des I2NP-Nachrichtenformats Gemeinsame Strukturen - Datentypen und -strukturen, die in ganz I2P verwendet werden Tunnel-Erstellung - ElGamal Tunnel-Erstellung (veraltet) ECIES Tunnel-Erstellung - ECIES-X25519 Tunnel-Erstellung (aktuell) Tunnel-Nachricht - Format der Tunnel-Nachricht und Zustellungsanweisungen NTCP2-Spezifikation - TCP-Transportprotokoll SSU2-Spezifikation - UDP-Transportprotokoll ECIES-Spezifikation - ECIES-X25519-AEAD-Ratchet-Verschlüsselung Kryptografie-Spezifikation - Kryptografische Primitive auf niedriger Ebene I2CP-Spezifikation - Spezifikation des Client-Protokolls Datagram-Spezifikation - Formate von Datagram2 und Datagram3 Vorschläge Proposal 123 - Neue netDB-Einträge (LeaseSet2, EncryptedLeaseSet, MetaLeaseSet) Proposal 144 - ECIES-X25519-AEAD-Ratchet-Verschlüsselung Proposal 154 - Verschlüsselte Datenbankabfrage Proposal 156 - ECIES-Router Proposal 157 - Kleinere tunnel-build-Nachrichten (Kurzformat) Proposal 159 - SSU2-Transport Proposal 161 - Komprimierbares Padding Proposal 163 - Datagram2 und Datagram3 Proposal 167 - Service-Record-Parameter im LeaseSet Proposal 168 - Bandbreitenparameter für tunnel build Proposal 169 - Post-Quanten-Hybridkryptografie Dokumentation Garlic Routing (mehrschichtiges Routing) - Mehrschichtiges Nachrichtenbündeln ElGamal/AES - Veraltetes Verschlüsselungsschema Tunnel Implementation - Fragmentierung und Verarbeitung Network Database - Verteilte Hash-Tabelle NTCP2 Transport - TCP-Transportspezifikation SSU2 Transport - UDP-Transportspezifikation Technical Introduction - Überblick über die I2P-Architektur Quellcode Java-I2P-Repository - Offizielle Java-Implementierung GitHub-Spiegel - GitHub-Spiegel von Java I2P i2pd-Repository - C++-Implementierung Wichtige Quellcode-Verzeichnisse Java I2P (i2pgit.org/I2P_Developers/i2p.i2p): - core/java/src/net/i2p/data/i2np/ - I2NP-Nachrichten-Implementierungen - core/java/src/net/i2p/crypto/ - Kryptografische Implementierungen - router/java/src/net/i2p/router/tunnel/ - Tunnel-Verarbeitung - router/java/src/net/i2p/router/transport/ - Transport-Implementierungen\nKonstanten und Werte: - I2NPMessage.MAX_SIZE = 65536 - Maximale I2NP-Nachrichtengröße - I2NPMessageImpl.HEADER_LENGTH = 16 - Standard-Headergröße - TunnelDataMessage.DATA_LENGTH = 1024 - Nutzlast der Tunnel-Nachricht - EncryptedBuildRecord.RECORD_SIZE = 528 - Langer Build-Datensatz (Build: Aufbau) - ShortEncryptedBuildRecord.RECORD_SIZE = 218 - Kurzer Build-Datensatz - TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - Max. Datensätze pro Build\nAnhang A: Netzwerkstatistiken und aktueller Status Netzwerkzusammensetzung (Stand: Oktober 2025) Gesamtzahl der Router: Ungefähr 60,000-70,000 (variiert) Floodfill-Router: Ungefähr 500-700 aktiv Verschlüsselungstypen: ECIES-X25519: \u0026gt;95% der Router ElGamal: \u0026lt;5% der Router (veraltet, nur Legacy (Altbestand)) Einsatz der Transportprotokolle: SSU2: \u0026gt;60% primäres Transportprotokoll NTCP2: ~40% primäres Transportprotokoll Legacy-Transporte (SSU1, NTCP): 0% (entfernt) Signaturtypen: EdDSA (Ed25519): Überwiegende Mehrheit ECDSA: Kleiner Prozentsatz RSA: Nicht zulässig (entfernt) Mindestanforderungen für den Router API-Version: 0.9.16+ (für EdDSA-Kompatibilität mit dem Netzwerk) Empfohlenes Minimum: API 0.9.51+ (ECIES Kurz-tunnel-Builds) Aktuelles Minimum für floodfills: API 0.9.58+ (Abkündigung des ElGamal router) Bevorstehende Voraussetzung: Java 17+ (ab Version 2.11.0, Dezember 2025) Bandbreitenanforderungen Minimum: 128 KBytes/sec (N-Flag oder höher) für floodfill Empfohlen: 256 KBytes/sec (O-Flag) oder höher Anforderungen für Floodfill: Mindestens 128 KB/sec Bandbreite Stabile Betriebszeit (\u0026gt;95% empfohlen) Geringe Latenz (\u0026lt;500ms zu Peers) Health-Checks bestehen (Warteschlangenzeit, Job-Verzögerung) Tunnel-Statistiken Typische Tunnel-Länge: 3-4 Hops Maximale Tunnel-Länge: 8 Hops (theoretisch, selten verwendet) Typische Tunnel-Lebensdauer: 10 Minuten Erfolgsrate beim Tunnelaufbau: \u0026gt;85% für gut vernetzte Router Nachrichtenformat für den Tunnelaufbau: ECIES Router: ShortTunnelBuild (218-Byte-Datensätze) Gemischte Tunnel: VariableTunnelBuild (528-Byte-Datensätze) Leistungsmetriken Tunnel-Aufbauzeit: 1-3 Sekunden (typisch) Ende-zu-Ende-Latenz: 0,5-2 Sekunden (typisch, insgesamt 6-8 Hops) Durchsatz: Begrenzt durch die tunnel-Bandbreite (typischerweise 10-50 KB/sec pro tunnel) Maximale Datagrammgröße: 10 KB empfohlen (61,2 KB theoretisches Maximum) Anhang B: Veraltete und entfernte Funktionen Vollständig entfernt (nicht mehr unterstützt) NTCP-Transport - In Release 0.9.50 entfernt (Mai 2021) SSU v1-Transport - Aus Java I2P in Release 2.4.0 entfernt (Dezember 2023) SSU v1-Transport - Aus i2pd in Release 2.44.0 entfernt (November 2022) RSA-Signaturtypen - Seit API 0.9.28 nicht mehr zugelassen Veraltet (unterstützt, aber nicht empfohlen) ElGamal routers - Seit API 0.9.58 (März 2023) veraltet ElGamal-Destinationen weiterhin unterstützt zur Abwärtskompatibilität Neue routers sollten ausschließlich ECIES-X25519 verwenden TunnelBuild (Typ 21) - Veraltet zugunsten von VariableTunnelBuild und ShortTunnelBuild Weiterhin implementiert für sehr lange tunnels (\u0026gt;8 Hops) TunnelBuildReply (Typ 22) - Veraltet zugunsten von VariableTunnelBuildReply und OutboundTunnelBuildReply ElGamal/AES-Verschlüsselung - Veraltet zugunsten von ECIES-X25519-AEAD-Ratchet Wird weiterhin für Legacy-Destinationen verwendet Lange ECIES-BuildRequestRecords (528 Bytes) - Veraltet zugunsten des kurzen Formats (218 Bytes) Wird weiterhin für gemischte tunnels mit ElGamal-Hops verwendet Zeitplan für die Unterstützung älterer Versionen Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels --- Anhang C: Zukünftige Entwicklungen Post-Quanten-Kryptografie Status: Beta seit Release 2.10.0 (September 2025), wird mit 2.11.0 (Dezember 2025) zum Standard\nImplementierung: - Hybrider Ansatz, der klassisches X25519 und Post-Quanten-MLKEM (ML-KEM-768) kombiniert - Abwärtskompatibel mit der bestehenden ECIES-X25519-Infrastruktur - Verwendet den Signal-Double-Ratchet-Algorithmus mit sowohl klassischem als auch PQ-Schlüsselmaterial (Post-Quanten) - Siehe Proposal 169 für Details\nMigrationspfad: 1. Release 2.10.0 (September 2025): Als Beta-Option verfügbar 2. Release 2.11.0 (Dezember 2025): Standardmäßig aktiviert 3. Zukünftige Releases: Schließlich verpflichtend\nGeplante Funktionen IPv6-Verbesserungen - Bessere IPv6-Unterstützung und Übergangsmechanismen Pro-tunnel-Drosselung - Fein abgestimmte Bandbreitenkontrolle pro tunnel Erweiterte Metriken - Verbesserte Leistungsüberwachung und Diagnostik Protokolloptimierungen - Reduzierter Overhead und verbesserte Effizienz Verbesserte floodfill-Auswahl (Knoten mit spezieller Rolle zur Verteilung der netDb) - Bessere Verteilung der Netzwerkdatenbank Forschungsbereiche Tunnel-Längenoptimierung - Dynamische Tunnel-Länge basierend auf dem Bedrohungsmodell Erweitertes Padding - Verbesserungen der Widerstandsfähigkeit gegen Verkehrsanalyse Neue Verschlüsselungsschemata - Vorbereitung auf Bedrohungen durch Quantencomputing Überlastkontrolle - Bessere Handhabung der Netzwerklast Mobile Unterstützung - Optimierungen für mobile Geräte und Netzwerke Anhang D: Implementierungsrichtlinien Für neue Implementierungen Mindestanforderungen: 1. Funktionen der API-Version 0.9.51+ unterstützen 2. ECIES-X25519-AEAD-Ratchet-Verschlüsselung implementieren 3. NTCP2- und SSU2-Transportprotokolle unterstützen 4. ShortTunnelBuild-Nachrichten (218-Byte-Datensätze) implementieren 5. LeaseSet2-Varianten (Typen 3, 5, 7) unterstützen 6. EdDSA-Signaturen verwenden (Ed25519)\nEmpfohlen: 1. Hybride Post-Quanten-Kryptografie unterstützen (ab 2.11.0) 2. Bandbreitenparameter pro tunnel implementieren 3. Datagram2- und Datagram3-Formate unterstützen 4. Service-Record-Optionen in LeaseSets implementieren 5. Den offiziellen Spezifikationen unter /docs/specs/ folgen\nNicht erforderlich: 1. Unterstützung für ElGamal router (veraltet) 2. Unterstützung für Legacy-Transporte (SSU1, NTCP) 3. Lange ECIES BuildRequestRecords (Anforderungsdatensätze für den Aufbau) (528 Bytes für reine ECIES tunnels) 4. TunnelBuild/TunnelBuildReply-Nachrichten (verwenden Sie die Varianten Variable oder Short)\nTesten und Validierung Protokollkonformität: 1. Teste die Interoperabilität mit dem offiziellen Java I2P router 2. Teste die Interoperabilität mit dem i2pd C++ router 3. Validiere die Nachrichtenformate anhand der Spezifikationen 4. Teste die tunnel-Aufbau-/Abbauzyklen 5. Verifiziere die Verschlüsselung/Entschlüsselung mit Testvektoren\nLeistungstests: 1. Erfolgsraten beim tunnel-Aufbau messen (sollten \u0026gt;85 % betragen) 2. Mit verschiedenen tunnel-Längen testen (2-8 Sprünge) 3. Fragmentierung und Reassemblierung validieren 4. Unter Last testen (mehrere gleichzeitige tunnel) 5. End-to-End-Latenz messen\nSicherheitstests: 1. Verschlüsselungsimplementierung verifizieren (Testvektoren verwenden) 2. Schutz vor Replay-Angriffen testen 3. Umgang mit Ablaufzeiten von Nachrichten validieren 4. Gegen fehlerhaft formatierte Nachrichten testen 5. Ordnungsgemäße Zufallszahlengenerierung verifizieren\nHäufige Fallstricke bei der Implementierung Verwirrende Formate der Zustellhinweise - garlic clove (Teilnachricht beim Garlic-Routing) vs tunnel message Fehlerhafte Schlüsselableitung - HKDF-Verwendung für short build records (kurze Build-Datensätze) Message-ID-Behandlung - Nicht korrekt gesetzt für tunnel builds Fragmentierungsprobleme - Die praktische Grenze von 61,2 KB wird nicht eingehalten Endianness-Fehler - Java verwendet Big-Endian für alle Ganzzahlen Behandlung von Ablaufzeiten - Das Kurzformat läuft am 7. Februar 2106 über (Überlauf) Prüfsummenerzeugung - Weiterhin erforderlich, auch wenn sie nicht verifiziert wird ","description":"Router-zu-Router-Nachrichtenformate, Prioritäten und Größenbeschränkungen innerhalb von I2P.","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"I2P-Netzwerkprotokoll (I2NP)","url":"/de/docs/specs/i2np/"},{"categories":null,"content":"Wie von unserem Bedrohungsmodell gefordert (unter anderem), muss die Software, die zur Unterstützung des anonymen Kommunikationsnetzwerks entwickelt wurde, das wir I2P nennen, frei verfügbar, quelloffen und durch Benutzer modifizierbar sein. Um diese Kriterien zu erfüllen, nutzen wir eine Vielzahl rechtlicher und softwaretechnischer Verfahren, um möglichst viele Eintrittsbarrieren für diejenigen zu beseitigen, die erwägen, I2P zu nutzen oder zum I2P-Projekt beizutragen.\nObwohl die folgenden Informationen möglicherweise verwirrender sind als einfach zu sagen „I2P ist BSD\u0026quot;, „I2P ist GPL\u0026quot; oder „I2P ist gemeinfrei\u0026quot;, lautet die kurze Antwort auf die Frage „Wie ist I2P lizenziert?\u0026quot; wie folgt:\nAlle Software, die in den I2P-Distributionen enthalten ist, erlaubt: gebührenfreie Nutzung Nutzung ohne Einschränkungen bezüglich wie, wann, wo, warum oder von wem es betrieben wird gebührenfreier Zugang zum Quellcode Modifikationen am Quellcode Der Großteil der Software garantiert deutlich mehr - die Fähigkeit jeder Person, den modifizierten Quellcode auf beliebige Weise zu verbreiten. Allerdings bietet nicht die gesamte mitgelieferte Software diese Freiheit - die GPL schränkt die Möglichkeiten von Entwicklern ein, die I2P in ihre eigenen Anwendungen integrieren möchten, welche selbst keine Open-Source-Anwendungen sind. Obwohl wir die noblen Ziele, die Ressourcen im Gemeinwesen zu erweitern, unterstützen, ist I2P am besten damit gedient, alle Hindernisse zu beseitigen, die seiner Verbreitung im Wege stehen - wenn ein Entwickler, der überlegt, ob er I2P in seine Anwendung integrieren kann, erst mit seinem Anwalt Rücksprache halten oder eine Code-Prüfung durchführen muss, um sicherzustellen, dass sein eigener Quellcode als GPL-kompatibel veröffentlicht werden kann, verlieren wir.\nKomponentenlizenzen Die I2P-Distribution enthält mehrere Ressourcen, die die Aufteilung des Quellcodes in Komponenten widerspiegeln. Jede Komponente hat ihre eigene Lizenz, der alle Entwickler, die dazu beitragen, zustimmen - entweder durch explizite Erklärung der Veröffentlichung des eingereichten Codes unter einer mit dieser Komponente kompatiblen Lizenz oder durch implizite Veröffentlichung des eingereichten Codes unter der primären Lizenz der Komponente. Jede dieser Komponenten hat einen leitenden Entwickler, der die endgültige Entscheidung darüber trifft, welche Lizenz mit der primären Lizenz der Komponente kompatibel ist, und der I2P-Projektmanager hat die endgültige Entscheidung darüber, welche Lizenzen die oben genannten vier Garantien für die Aufnahme in die I2P-Distribution erfüllen.\nComponent Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD, Cryptix, MIT zzz I2P Router router router.jar Public domain BSD, Cryptix, MIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain, Cryptix, MIT zzz Streaming apps/streaming streaming.jar Public domain BSD, Cryptix, MIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain, BSD, Cryptix, MIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain — zzz Address Book apps/addressbook addressbook.war MIT Public domain, Cryptix, BSD — Susidns apps/susidns susidns.war GPL + exception — — Susimail apps/susimail susimail.war GPL + exception — — I2PSnark apps/i2psnark i2psnark.jar GPL + exception — zzz [BOB](/docs/legacy/bob/) Bridge apps/BOB BOB.jar WTFPL — sponge [SAM](/docs/api/samv3/) Bridge apps/sam sam.jar Public domain Cryptix, BSD, MIT zzz [SAM v1](/docs/legacy/sam/) Perl library apps/sam/perl SAM.pm GPL Public domain, Cryptix, BSD, MIT BrianR [SAM v1](/docs/legacy/sam/) C library apps/sam/c libSAM BSD Public domain, Cryptix, MIT Nightblade [SAM v1](/docs/legacy/sam/) Python library apps/sam/python i2p.py Public domain BSD, Cryptix, MIT Connelly [SAM v1](/docs/legacy/sam/) C# library apps/sam/csharp/ n/a Public domain BSD, Cryptix, MIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source — — Installer installer install.jar, guiinstall.jar Public domain GPL + exception, BSD, Cryptix, MIT — GPL-Ausnahme Auch wenn es redundant erscheinen mag, muss der GPL-lizenzierte Code, der in I2PTunnel und anderen Anwendungen enthalten ist, zur Klarstellung unter der GPL mit einer zusätzlichen \u0026ldquo;Ausnahme\u0026rdquo; veröffentlicht werden, die ausdrücklich die Verwendung von Javas Standardbibliotheken autorisiert:\nIn addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version. Der gesamte Quellcode unter jeder Komponente unterliegt standardmäßig der Hauptlizenz, sofern im Code nicht anders gekennzeichnet. Alles oben Genannte ist eine Zusammenfassung der Lizenzbedingungen – bitte beachten Sie die spezifische Lizenz für die jeweilige Komponente oder den betreffenden Quellcode für die maßgeblichen Bedingungen. Die Speicherorte der Komponentenquellen und die Ressourcenverpackung können sich ändern, falls das Repository neu organisiert wird.\nWebsite-Lizenz Sofern nicht anders angegeben, ist der Inhalt dieser Website unter einer Creative Commons Attribution-ShareAlike 4.0 International License lizenziert.\nCommit-Zugriff Entwickler können Änderungen an ein verteiltes Git-Repository übertragen, wenn sie die Erlaubnis von der Person erhalten, die dieses Repository verwaltet. Details finden Sie im Leitfaden für neue Entwickler .\nUm jedoch Änderungen in einer Veröffentlichung einzubringen, müssen Entwickler vom Release Manager (derzeit zzz) als vertrauenswürdig eingestuft werden. Darüber hinaus müssen sie den oben genannten Bedingungen ausdrücklich zustimmen, um als vertrauenswürdig zu gelten. Das bedeutet, dass sie einem der Release Manager eine signierte Nachricht senden müssen, in der sie bestätigen, dass:\nSofern nicht anders gekennzeichnet, steht der gesamte Code, den ich einreiche, implizit unter der Hauptlizenz der Komponente Falls in der Quelle angegeben, kann der Code explizit unter einer der alternativen Lizenzen der Komponente lizenziert sein Ich habe das Recht, den Code, den ich einreiche, unter den Bedingungen zu veröffentlichen, unter denen ich ihn einreiche Sollte jemand Fälle kennen, in denen die oben genannten Bedingungen nicht erfüllt sind, wenden Sie sich bitte mit weiteren Informationen an den Komponenten-Leiter und/oder einen I2P Release-Manager.\n","description":"Lizenzrichtlinie und Komponentenlizenzen für mit I2P gebündelte Software","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"I2P-Softwarelizenzen","url":"/de/docs/develop/licenses/"},{"categories":null,"content":"Einführung I2P ist eine skalierbare, selbstorganisierende, widerstandsfähige paketvermittelte anonyme Netzwerkschicht, auf der beliebig viele verschiedene anonymitäts- oder sicherheitsbewusste Anwendungen betrieben werden können. Jede dieser Anwendungen kann ihre eigenen Kompromisse zwischen Anonymität, Latenz und Durchsatz treffen, ohne sich um die korrekte Implementierung eines free route mixnet kümmern zu müssen, wodurch sie ihre Aktivität mit der größeren Anonymitätsmenge der Benutzer vermischen können, die bereits auf I2P laufen.\nBereits verfügbare Anwendungen bieten die volle Bandbreite typischer Internet-Aktivitäten — anonymes Web-Browsing, Web-Hosting, Chat, Dateifreigabe, E-Mail, Blogging und Content-Syndication sowie mehrere weitere Anwendungen, die sich in der Entwicklung befinden.\nWeb-Browsing: mit jedem bestehenden Browser, der einen Proxy unterstützt Chat: IRC und andere Protokolle Dateifreigabe: I2PSnark und andere Anwendungen E-Mail: Susimail und andere Anwendungen Blog: mit jedem lokalen Webserver oder verfügbaren Plugins Im Gegensatz zu Websites, die in Content-Distribution-Netzwerken wie Freenet oder GNUnet gehostet werden, sind die auf I2P gehosteten Dienste vollständig interaktiv – es gibt traditionelle Suchmaschinen im Web-Stil, Bulletin Boards, Blogs, auf denen man kommentieren kann, datenbankgestützte Websites und Brücken zur Abfrage statischer Systeme wie Freenet, ohne dass diese lokal installiert werden müssen.\nBei all diesen anonymitätsfähigen Anwendungen fungiert I2P als nachrichtenorientierte Middleware – Anwendungen geben Daten an, die an eine kryptografische Kennung (eine \u0026ldquo;destination\u0026rdquo;) gesendet werden sollen, und I2P stellt sicher, dass diese sicher und anonym ankommen. I2P enthält auch eine einfache Streaming-Bibliothek , die es ermöglicht, I2Ps anonyme Best-Effort-Nachrichten als zuverlässige, geordnete Datenströme zu übertragen, mit TCP-basierter Überlastungskontrolle, die auf das hohe Bandbreiten-Verzögerungs-Produkt des Netzwerks abgestimmt ist.\nObwohl einfache SOCKS-Proxys entwickelt wurden, um bestehende Anwendungen anzubinden, ist ihr Nutzen begrenzt, da die meisten Anwendungen sensible Informationen in einem anonymen Kontext preisgeben. Der sicherste Ansatz ist es, die Anwendung zu prüfen und anzupassen, damit sie die I2P-APIs direkt verwendet.\nI2P ist kein Forschungsprojekt – weder akademisch, kommerziell noch staatlich –, sondern eine technische Entwicklung, die darauf abzielt, nutzbare Anonymität bereitzustellen. Seit Anfang 2003 wird es kontinuierlich von einer verteilten Gruppe von Mitwirkenden weltweit entwickelt. Alle I2P-Arbeiten sind Open Source auf der offiziellen Website , hauptsächlich als Public Domain veröffentlicht, wobei einige Komponenten unter freizügigen BSD-ähnlichen Lizenzen stehen. Mehrere GPL-lizenzierte Clientanwendungen sind verfügbar, wie z. B. I2PTunnel , Susimail und I2PSnark . Die Finanzierung erfolgt ausschließlich durch Nutzerspenden.\nBetrieb Overview I2P unterscheidet klar zwischen Routern (Knoten, die am Netzwerk teilnehmen) und Destinations (anonyme Endpunkte für Anwendungen). Der Betrieb von I2P selbst ist nicht geheim; verborgen bleibt was der Nutzer tut und welchen Router seine Destinations verwenden. Endnutzer betreiben typischerweise mehrere Destinations (z.B. eine fürs Web-Browsing, eine weitere fürs Hosting, eine andere für IRC).\nEin Schlüsselkonzept in I2P ist der tunnel — ein unidirektionaler verschlüsselter Pfad durch eine Reihe von Routern. Jeder Router entschlüsselt nur eine Schicht und erfährt nur den nächsten Hop. Tunnels laufen nach 10 Minuten ab und müssen neu aufgebaut werden.\nAbbildung 1: Es gibt zwei Arten von Tunneln – eingehende und ausgehende.\nOutbound tunnels senden Nachrichten vom Ersteller weg. Inbound tunnels bringen Nachrichten zum Ersteller zurück. Die Kombination dieser ermöglicht bidirektionale Kommunikation. Zum Beispiel nutzt \u0026ldquo;Alice\u0026rdquo; einen ausgehenden Tunnel, um an \u0026ldquo;Bobs\u0026rdquo; eingehenden Tunnel zu senden. Alice verschlüsselt ihre Nachricht mit Routing-Anweisungen zu Bobs eingehendem Gateway.\nEin weiteres Schlüsselkonzept ist die network database oder netDb, die Metadaten über Router und Ziele verteilt:\nRouterInfo: Enthält Router-Kontaktinformationen und Schlüsselmaterial. LeaseSet: Enthält Informationen, die benötigt werden, um ein Ziel zu kontaktieren (tunnel gateways, Ablaufzeiten, Verschlüsselungsschlüssel). Router veröffentlichen ihre RouterInfo direkt in der netDb; LeaseSets werden zur Wahrung der Anonymität durch ausgehende Tunnel gesendet.\nUm Tunnel zu bauen, fragt Alice die netDb nach RouterInfo-Einträgen ab, um Peers auszuwählen, und sendet verschlüsselte Tunnel-Build-Nachrichten Hop-für-Hop, bis der Tunnel vollständig ist.\nAbbildung 2: Router-Informationen werden verwendet, um Tunnel zu bauen.\nUm an Bob zu senden, schaut Alice Bobs LeaseSet nach und verwendet einen ihrer ausgehenden Tunnel, um Daten zum Gateway von Bobs eingehendem Tunnel zu routen.\nAbbildung 3: LeaseSets verbinden ausgehende und eingehende Tunnel.\nDa I2P nachrichtenbasiert ist, fügt es End-to-End garlic encryption hinzu, um Nachrichten selbst vor dem ausgehenden Endpunkt oder eingehenden Gateway zu schützen. Eine Garlic-Nachricht umhüllt mehrere verschlüsselte „Cloves\u0026quot; (Nachrichten), um Metadaten zu verbergen und die Anonymität zu verbessern.\nAnwendungen können entweder die Nachrichtenschnittstelle direkt verwenden oder sich auf die Streaming-Bibliothek für zuverlässige Verbindungen verlassen.\nTunnels Sowohl eingehende als auch ausgehende Tunnel verwenden geschichtete Verschlüsselung, unterscheiden sich jedoch im Aufbau:\nIn inbound tunnels entschlüsselt der Ersteller (der Endpunkt) alle Schichten. In outbound tunnels entschlüsselt der Ersteller (das Gateway) die Schichten vorab, um Klarheit am Endpunkt zu gewährleisten. I2P profiliert Peers anhand indirekter Metriken wie Latenz und Zuverlässigkeit ohne direktes Probing. Basierend auf diesen Profilen werden Peers dynamisch in vier Stufen gruppiert:\nSchnell und hohe Kapazität Hohe Kapazität Nicht ausgefallen Ausgefallen Die Auswahl von Tunnel-Peers bevorzugt typischerweise Peers mit hoher Kapazität, die zufällig ausgewählt werden, um Anonymität und Leistung auszugleichen, mit zusätzlichen XOR-basierten Sortierungsstrategien zur Abwehr von Vorgängerangriffen und netDb-Harvesting.\nFür tiefergehende Details siehe die Tunnel-Spezifikation .\nÜbersicht Router, die am floodfill Distributed Hash Table (DHT) teilnehmen, speichern und beantworten LeaseSet-Anfragen. Die DHT verwendet eine Variante von Kademlia . Floodfill-Router werden automatisch ausgewählt, wenn sie über ausreichende Kapazität und Stabilität verfügen, oder können manuell konfiguriert werden.\nRouterInfo: Beschreibt die Fähigkeiten und Transporte eines Routers. LeaseSet: Beschreibt die Tunnel und Verschlüsselungsschlüssel eines Ziels. Alle Daten in der netDb sind vom Herausgeber signiert und mit einem Zeitstempel versehen, um Replay- oder Stale-Entry-Angriffe zu verhindern. Die Zeitsynchronisation wird durch SNTP und Transport-Layer-Skew-Erkennung aufrechterhalten.\nAdditional concepts Unveröffentlichte und verschlüsselte LeaseSets:\nEin Ziel kann privat bleiben, indem es sein LeaseSet nicht veröffentlicht und es nur mit vertrauenswürdigen Peers teilt. Der Zugriff erfordert den entsprechenden Entschlüsselungsschlüssel.\nBootstrapping (reseeding):\nUm dem Netzwerk beizutreten, lädt ein neuer router signierte RouterInfo-Dateien von vertrauenswürdigen HTTPS-Reseed-Servern herunter.\nLookup-Skalierbarkeit:\nI2P verwendet iterative, nicht rekursive, Lookups, um die DHT-Skalierbarkeit und -Sicherheit zu verbessern.\nTunnels Moderne I2P-Kommunikation verwendet zwei vollständig verschlüsselte Transportprotokolle:\nNTCP2 : Verschlüsseltes TCP-basiertes Protokoll SSU2 : Verschlüsseltes UDP-basiertes Protokoll Beide basieren auf dem modernen Noise Protocol Framework und bieten starke Authentifizierung sowie Widerstandsfähigkeit gegen Traffic-Fingerprinting. Sie ersetzten die veralteten NTCP- und SSU-Protokolle (vollständig eingestellt seit 2023).\nNTCP2 bietet verschlüsseltes, effizientes Streaming über TCP.\nSSU2 bietet UDP-basierte Zuverlässigkeit, NAT-Traversierung und optionales Hole Punching. SSU2 ist konzeptionell ähnlich wie WireGuard oder QUIC und bringt Zuverlässigkeit und Anonymität in Einklang.\nRouter können sowohl IPv4 als auch IPv6 unterstützen und veröffentlichen ihre Transportadressen und -kosten in der netDb. Der Transport einer Verbindung wird dynamisch durch ein Bietsystem ausgewählt, das auf Bedingungen und bestehende Verbindungen optimiert.\nNetzwerk-Datenbank (netDb) I2P verwendet mehrschichtige Verschlüsselung für alle Komponenten: Transporte, Tunnel, Garlic-Nachrichten und die netDb.\nAktuelle Primitiven umfassen:\nX25519 für Schlüsselaustausch EdDSA (Ed25519) für Signaturen ChaCha20-Poly1305 für authentifizierte Verschlüsselung SHA-256 für Hashing AES256 für tunnel Layer-Verschlüsselung Legacy-Algorithmen (ElGamal, DSA-SHA1, ECDSA) bleiben aus Gründen der Abwärtskompatibilität erhalten.\nI2P führt derzeit hybride Post-Quanten (PQ) kryptografische Verfahren ein, die X25519 mit ML-KEM kombinieren, um „Harvest-now, decrypt-later\u0026quot;-Angriffe (Jetzt sammeln, später entschlüsseln) abzuwehren.\nGarlic Messages Garlic-Nachrichten erweitern Onion-Routing, indem sie mehrere verschlüsselte \u0026ldquo;Cloves\u0026rdquo; (Segmente) mit unabhängigen Zustellungsanweisungen gruppieren. Diese ermöglichen Routing-Flexibilität auf Nachrichtenebene und einheitliches Traffic-Padding.\nSession Tags Zwei kryptografische Systeme werden für die Ende-zu-Ende-Verschlüsselung unterstützt:\nElGamal/AES+SessionTags (veraltet):\nVerwendet vorab übermittelte Session-Tags als 32-Byte-Nonces. Aufgrund von Ineffizienz mittlerweile veraltet.\nECIES-X25519-AEAD-Ratchet (aktuell):\nVerwendet ChaCha20-Poly1305 und synchronisierte HKDF-basierte PRNGs, um ephemerale Session-Keys und 8-Byte-Tags dynamisch zu generieren, wodurch CPU-, Speicher- und Bandbreitenaufwand reduziert wird, während Forward Secrecy (Vorwärtsgeheimhaltung) erhalten bleibt.\nFuture of the Protocol Wichtige Forschungsbereiche konzentrieren sich auf die Aufrechterhaltung der Sicherheit gegen staatliche Gegner und die Einführung von Post-Quanten-Schutzmaßnahmen. Zwei frühe Designkonzepte – restricted routes und variable latency – wurden durch moderne Entwicklungen abgelöst.\nRestricted Route Operation Die ursprünglichen Konzepte für eingeschränktes Routing zielten darauf ab, IP-Adressen zu verschleiern. Dieser Bedarf wurde weitgehend gemildert durch:\nUPnP für automatische Portweiterleitung Robuste NAT-Durchquerung in SSU2 IPv6-Unterstützung Kooperative Introducer und NAT-Hole-Punching Optionale Overlay-Konnektivität (z.B. Yggdrasil) Daher erreicht das moderne I2P die gleichen Ziele auf praktischere Weise ohne komplexes eingeschränktes Routing.\nSimilar Systems I2P integriert Konzepte aus nachrichtenorientierter Middleware, DHTs und Mixnets. Seine Innovation liegt darin, diese zu einer nutzbaren, selbstorganisierenden Anonymitätsplattform zu kombinieren.\nTransportprotokolle Website Tor und I2P teilen gemeinsame Ziele, unterscheiden sich jedoch architektonisch:\nTor: Verbindungsvermittelt; setzt auf vertrauenswürdige Verzeichnisbehörden. (~10k Relays) I2P: Paketvermittelt; vollständig verteiltes DHT-gesteuertes Netzwerk. (~50k Router) I2Ps unidirektionale Tunnel exponieren weniger Metadaten und ermöglichen flexible Routing-Pfade, während Tor sich auf anonymen Internetzugang (Outproxying) konzentriert. I2P unterstützt stattdessen anonymes In-Network-Hosting.\nKryptographie Website Freenet konzentriert sich auf anonymes, dauerhaftes Veröffentlichen und Abrufen von Dateien. I2P bietet im Gegensatz dazu eine Echtzeit-Kommunikationsschicht für interaktive Nutzung (Web, Chat, Torrents). Zusammen ergänzen sich die beiden Systeme – Freenet bietet zensurresistente Speicherung; I2P bietet Transportanonymität.\nOther Networks Lokinet: IP-basiertes Overlay unter Verwendung incentivierter Service-Nodes. Nym: Mixnet der nächsten Generation mit Schwerpunkt auf Metadatenschutz durch Cover-Traffic bei höherer Latenz. Appendix A: Application Layer I2P selbst kümmert sich nur um den Nachrichtentransport. Funktionalität auf Anwendungsebene wird extern durch APIs und Bibliotheken implementiert.\nStreaming Library Die Streaming-Bibliothek fungiert als TCP-Analogon von I2P, mit einem Sliding-Window-Protokoll und Congestion Control, die für anonymen Transport mit hoher Latenz optimiert sind.\nTypische HTTP-Anfrage-/Antwort-Muster können aufgrund von Nachrichtenbündelungsoptimierungen oft in einem einzigen Durchlauf abgeschlossen werden.\nNaming Library and Address Book Entwickelt von: mihi, Ragnarok Siehe die Seite Benennung und Adressbuch .\nDas Namenssystem von I2P ist lokal und dezentralisiert und vermeidet globale Namen im DNS-Stil. Jeder Router verwaltet eine lokale Zuordnung von lesbaren Namen zu Zielen. Optional können auf Web-of-Trust basierende Adressbücher mit vertrauenswürdigen Peers geteilt oder von diesen importiert werden.\nDieser Ansatz vermeidet zentrale Autoritäten und umgeht Sybil-Schwachstellen, die globalen oder abstimmungsbasierten Namenssystemen innewohnen.\nEingeschränkter Routenbetrieb Entwickelt von: mihi\nI2PTunnel ist die Haupt-Client-Schnittstelle, die anonymes TCP-Proxying ermöglicht. Es unterstützt:\nClient-Tunnel (ausgehend zu I2P-Zielen) HTTP-Client (eepproxy) für \u0026ldquo;.i2p\u0026rdquo;-Domains Server-Tunnel (eingehend von I2P zu einem lokalen Dienst) HTTP-Server-Tunnel (sichere Proxy-Bereitstellung von Webdiensten) Outproxying (zum regulären Internet) ist optional und wird durch freiwillig betriebene \u0026ldquo;Server\u0026rdquo;-Tunnel implementiert.\nI2PSnark Entwickelt von: jrandom, et al — portiert von Snark Im I2P-Paket enthalten ist I2PSnark, ein anonymer Multi-Torrent-BitTorrent-Client mit DHT- und UDP-Unterstützung, der über eine Weboberfläche zugänglich ist.\nTor Entwickelt von: postman, susi23, mastiejaner\nI2Pmail bietet anonyme E-Mail über I2PTunnel-Verbindungen. Susimail ist ein webbasierter Client, der speziell entwickelt wurde, um Informationslecks zu verhindern, die bei traditionellen E-Mail-Clients häufig vorkommen. Der mail.i2p -Dienst bietet Virenfilterung, Hashcash -Kontingente und Outproxy-Trennung für zusätzlichen Schutz.\n","description":"Technische Einführung in die I2P-Architektur und -Funktionsweise","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P: Ein skalierbares Framework für anonyme Kommunikation","url":"/de/docs/overview/tech-intro/"},{"categories":null,"content":"I2PControl API-Dokumentation I2PControl ist eine JSON-RPC 2.0 API, die mit dem I2P router gebündelt ist (seit Version 0.9.39). Sie ermöglicht die authentifizierte Überwachung und Steuerung des routers über strukturierte JSON-Anfragen.\nStandardpasswort: itoopie — dies ist die Werkseinstellung und sollte sofort geändert werden aus Sicherheitsgründen.\n1. Übersicht \u0026amp; Zugriff Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior Im Java I2P Fall müssen Sie zu **Router Console → WebApps → I2PControl** gehen und es aktivieren (auf automatischen Start setzen). Sobald aktiv, erfordern alle Methoden, dass Sie sich zuerst authentifizieren und ein Session-Token erhalten. 2. JSON-RPC-Format Alle Anfragen folgen der JSON-RPC 2.0-Struktur:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } Eine erfolgreiche Antwort enthält ein result-Feld; bei einem Fehler wird ein error-Objekt zurückgegeben:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } oder\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. Authentifizierungsablauf Anfrage (Authentifizieren) curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Erfolgreiche Antwort { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } Sie müssen dieses Token in allen nachfolgenden Anfragen in den params einschließen.\n4. Methoden \u0026amp; Endpunkte 4.1 RouterInfo Ruft wichtige Telemetriedaten über den Router ab.\nAnforderungsbeispiel\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Antwortfelder (result) Laut der offiziellen Dokumentation (GetI2P): - i2p.router.status (String) — ein menschenlesbarer Status - i2p.router.uptime (long) — Millisekunden (oder String für ältere i2pd-Versionen) :contentReference[oaicite:0]{index=0} - i2p.router.version (String) — Versionszeichenkette :contentReference[oaicite:1]{index=1} - i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — eingehende Bandbreite in B/s :contentReference[oaicite:2]{index=2} - i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — ausgehende Bandbreite in B/s :contentReference[oaicite:3]{index=3} - i2p.router.net.status (long) — numerischer Statuscode (siehe Enum unten) :contentReference[oaicite:4]{index=4} - i2p.router.net.tunnels.participating (long) — Anzahl der teilnehmenden Tunnel :contentReference[oaicite:5]{index=5} - i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — netDB Peer-Statistiken :contentReference[oaicite:6]{index=6} - i2p.router.netdb.isreseeding (boolean) — ob Reseed aktiv ist :contentReference[oaicite:7]{index=7} - i2p.router.netdb.knownpeers (long) — gesamt bekannte Peers :contentReference[oaicite:8]{index=8}\nStatus-Code-Enum (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET --- 4.2 GetRate Wird verwendet, um Raten-Metriken (z.B. Bandbreite, Tunnel-Erfolgsrate) über ein bestimmtes Zeitfenster abzurufen.\nAnfrage-Beispiel\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Beispielantwort\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 RouterManager Führen Sie administrative Aktionen durch.\nErlaubte Parameter / Methoden - Restart, RestartGraceful - Shutdown, ShutdownGraceful - Reseed, FindUpdates, Update :contentReference[oaicite:10]{index=10}\nAnfrage-Beispiel\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Erfolgreiche Antwort\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 NetworkSetting Netzwerk-Konfigurationsparameter abrufen oder setzen (Ports, UPnP, Bandbreitenfreigabe, etc.)\nAnfrage-Beispiel (aktuelle Werte abrufen)\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Beispielantwort\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } Hinweis: i2pd-Versionen vor 2.41 können numerische Typen anstelle von Zeichenketten zurückgeben – Clients sollten beide Fälle behandeln. :contentReference[oaicite:11]{index=11}\n4.5 Erweiterte Einstellungen Ermöglicht die Manipulation interner Router-Parameter.\nAnfrage-Beispiel\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Antwortbeispiel\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. Fehlercodes Zusätzlich zu den standardmäßigen JSON-RPC-Fehlern (-32700, -32600, etc.) definiert I2PControl:\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported --- 6. Verwendung \u0026amp; Best Practices Fügen Sie immer den Token-Parameter hinzu (außer bei der Authentifizierung). Ändern Sie das Standardpasswort (itoopie) bei der ersten Verwendung. Stellen Sie bei Java I2P sicher, dass die I2PControl-Webapp über WebApps aktiviert ist. Seien Sie auf leichte Abweichungen vorbereitet: Einige Felder können je nach I2P-Version Zahlen oder Zeichenketten sein. Umbrechen Sie lange Statuszeichenketten für eine anzeigefreundliche Ausgabe. ","description":"Remote-Router-Verwaltungs-API über die I2PControl-Webapp","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/de/docs/api/i2pcontrol/"},{"categories":null,"content":"Übersicht I2PTunnel ist eine zentrale I2P-Komponente für die Kommunikation mit dem I2P-Netzwerk und die Bereitstellung von Diensten darauf. Es ermöglicht TCP-basierten und Media-Streaming-Anwendungen, anonym durch Tunnel-Abstraktion zu arbeiten. Das Ziel eines tunnels kann durch einen Hostnamen , Base32 oder einen vollständigen Zielschlüssel (destination key) definiert werden.\nJeder eingerichtete tunnel lauscht lokal (z.B. localhost:port) und verbindet sich intern mit I2P-Zielen. Um einen Dienst bereitzustellen, erstellen Sie einen tunnel, der auf die gewünschte IP und den gewünschten Port verweist. Ein entsprechender I2P-Zielschlüssel wird generiert, wodurch der Dienst im I2P-Netzwerk global erreichbar wird. Die I2PTunnel-Weboberfläche ist verfügbar unter I2P Router Tunnel Manager .\nStandarddienste Server-Tunnel I2P Webserver – Ein Tunnel zu einem Jetty-Webserver unter localhost:7658 für einfaches Hosting auf I2P. Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot Client-Tunnel I2P HTTP Proxy – localhost:4444 – Wird zum Durchsuchen von I2P und dem Internet über Outproxies verwendet. I2P HTTPS Proxy – localhost:4445 – Sichere Variante des HTTP-Proxys. Irc2P – localhost:6668 – Standard-tunnel für das anonyme IRC-Netzwerk. Git SSH (gitssh.idk.i2p) – localhost:7670 – Client-tunnel für SSH-Zugriff auf Repositorys. Postman SMTP – localhost:7659 – Client-tunnel für ausgehende E-Mails. Postman POP3 – localhost:7660 – Client-tunnel für eingehende E-Mails. Hinweis: Nur der I2P-Webserver ist ein standardmäßiger server tunnel; alle anderen sind Client-Tunnel, die sich mit externen I2P-Diensten verbinden.\nKonfiguration Die I2PTunnel-Konfigurationsspezifikation ist unter /spec/configuration dokumentiert.\nClient-Modi Standard Öffnet einen lokalen TCP-Port, der sich mit einem Dienst auf einer I2P-Destination verbindet. Unterstützt mehrere durch Kommas getrennte Destination-Einträge für Redundanz.\nHTTP Ein Proxy-Tunnel für HTTP/HTTPS-Anfragen. Unterstützt lokale und entfernte Outproxies, Header-Entfernung, Caching, Authentifizierung und transparente Kompression.\nDatenschutzmaßnahmen: - Entfernt Header: Accept-*, Referer, Via, From - Ersetzt Host-Header durch Base32-Zieladressen - Erzwingt RFC-konformes Hop-by-Hop-Stripping - Fügt Unterstützung für transparente Dekomprimierung hinzu - Bietet interne Fehlerseiten und lokalisierte Antworten\nKomprimierungsverhalten: - Anfragen können den benutzerdefinierten Header X-Accept-Encoding: x-i2p-gzip verwenden - Antworten mit Content-Encoding: x-i2p-gzip werden transparent dekomprimiert - Komprimierung wird anhand von MIME-Typ und Antwortlänge für Effizienz bewertet\nPersistenz (neu seit 2.5.0): HTTP Keepalive und persistente Verbindungen werden jetzt für I2P-gehostete Dienste über den Hidden Services Manager unterstützt. Dies reduziert die Latenz und den Verbindungsoverhead, ermöglicht aber noch keine vollständige RFC 2616-konforme persistente Sockets über alle Hops hinweg.\nPipelining: Bleibt nicht unterstützt und unnötig; moderne Browser haben es als veraltet markiert.\nUser-Agent-Verhalten: - Outproxy: Verwendet einen aktuellen Firefox ESR User-Agent. - Intern: MYOB/6.66 (AN/ON) für konsistente Anonymität.\nIRC-Client Verbindet sich mit I2P-basierten IRC-Servern. Erlaubt eine sichere Teilmenge von Befehlen und filtert Identifikatoren zum Schutz der Privatsphäre.\nSOCKS 4/4a/5 Bietet SOCKS-Proxy-Funktionalität für TCP-Verbindungen. UDP ist in Java I2P nicht implementiert (nur in i2pd).\nCONNECT Implementiert HTTP-CONNECT-Tunneling für SSL/TLS-Verbindungen.\nStreamr Ermöglicht UDP-ähnliches Streaming über TCP-basierte Kapselung. Unterstützt Media-Streaming, wenn es mit einem entsprechenden Streamr-Server-Tunnel kombiniert wird.\nServer-Modi Standard-Server Erstellt ein TCP-Ziel, das einer lokalen IP:Port zugeordnet ist.\nHTTP-Server Erstellt eine Destination, die mit einem lokalen Webserver kommuniziert. Unterstützt Komprimierung (x-i2p-gzip), Header-Entfernung und DDoS-Schutz. Profitiert nun von Unterstützung für persistente Verbindungen (v2.5.0+) und Thread-Pool-Optimierung (v2.7.0–2.9.0).\nHTTP Bidirektional Veraltet – Noch funktionsfähig, aber nicht empfohlen. Fungiert sowohl als HTTP-Server als auch als Client ohne Outproxying. Wird hauptsächlich für diagnostische Loopback-Tests verwendet.\nIRC-Server Erstellt eine gefilterte Destination für IRC-Dienste, die Client-Destination-Schlüssel als Hostnamen übergibt.\nStreamr-Server Kombiniert mit einem Streamr-Client-Tunnel zur Verarbeitung von UDP-ähnlichen Datenströmen über I2P.\nNeue Funktionen (2.4.0–2.10.0) Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. --- Sicherheitsfunktionen Header-Entfernung für Anonymität (Accept, Referer, From, Via) User-Agent-Randomisierung abhängig von in/outproxy POST-Ratenbegrenzung und Slowloris-Schutz Verbindungsdrosselung in Streaming-Subsystemen Behandlung von Netzwerküberlastung auf Tunnel-Ebene NetDB-Isolierung zur Verhinderung anwendungsübergreifender Lecks Technische Details Standard-Zielschlüsselgröße: 516 Bytes (kann bei erweiterten LS2-Zertifikaten überschritten werden) Base32-Adressen: {52–56+ Zeichen}.b32.i2p Server-Tunnel bleiben kompatibel mit sowohl Java I2P als auch i2pd Veraltete Funktion: nur httpbidirserver; keine Entfernungen seit 0.9.59 Verifizierte korrekte Standard-Ports und Dokumentenstammverzeichnisse für alle Plattformen Zusammenfassung I2PTunnel bleibt das Rückgrat der Anwendungsintegration mit I2P. Zwischen Version 0.9.59 und 2.10.0 erhielt es Unterstützung für persistente Verbindungen, Post-Quanten-Verschlüsselung und umfangreiche Threading-Verbesserungen. Die meisten Konfigurationen bleiben kompatibel, aber Entwickler sollten ihre Setups überprüfen, um die Einhaltung moderner Transport- und Sicherheitsstandards sicherzustellen.\n","description":"Werkzeug zur Schnittstelle und Bereitstellung von Diensten auf I2P","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/de/docs/api/i2ptunnel/"},{"categories":null,"content":"Überblick Wichtige Punkte\nI2P bietet Ende-zu-Ende-Verschlüsselung für IRC-Verkehr durch seine Tunnel. Deaktivieren Sie SSL/TLS in IRC-Clients, es sei denn, Sie nutzen einen Outproxy zum Clearnet. Der vorkonfigurierte Irc2P Client-Tunnel lauscht standardmäßig auf 127.0.0.1:6668. Verbinden Sie Ihren IRC-Client mit dieser Adresse und diesem Port. Verwenden Sie nicht den Begriff \u0026ldquo;router‑provided TLS\u0026rdquo;. Nutzen Sie stattdessen \u0026ldquo;I2Ps native Verschlüsselung\u0026rdquo; oder \u0026ldquo;Ende-zu-Ende-Verschlüsselung\u0026rdquo;. Schnellstart (Java I2P) Öffne den Hidden Services Manager unter http://127.0.0.1:7657/i2ptunnel/ und stelle sicher, dass der Irc2P-Tunnel läuft. Stelle in deinem IRC-Client Server = 127.0.0.1, Port = 6668, SSL/TLS = aus ein. Verbinde dich und tritt Kanälen wie #i2p, #i2p-dev, #i2p-help bei. Für i2pd-Nutzer (C++ Router) erstellen Sie einen Client-Tunnel in tunnels.conf (siehe Beispiele unten).\nNetzwerke und Server IRC2P (main community network) Föderierte Server: irc.postman.i2p:6667, irc.echelon.i2p:6667, irc.dg.i2p:6667. Der Irc2P-Tunnel unter 127.0.0.1:6668 verbindet sich automatisch mit einem dieser Server. Typische Channels: #i2p, #i2p-chat, #i2p-dev, #i2p-help. Ilita network Server: irc.ilita.i2p:6667, irc.r4sas.i2p:6667, irc.acetone.i2p:6667, rusirc.ilita.i2p:6667. Hauptsprachen: Russisch und Englisch. Web-Frontends existieren auf einigen Hosts. Client setup Recommended, actively maintained WeeChat (Terminal) — starke SOCKS-Unterstützung; einfach zu skripten. Pidgin (Desktop) — wird weiterhin gepflegt; funktioniert gut unter Windows/Linux. Thunderbird Chat (Desktop) — unterstützt ab ESR 128+. The Lounge (selbst gehostetes Web) — moderner Web-Client. IRC2P (Haupt-Community-Netzwerk) LimeChat (kostenlos, Open Source). Textual (kostenpflichtig im App Store; Quellcode verfügbar zum Selbstbauen). Ilita-Netzwerk WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin Protokoll: IRC Server: 127.0.0.1 Port: 6668 Verschlüsselung: aus Benutzername/Nick: beliebig Thunderbird Chat Kontotyp: IRC Server: 127.0.0.1 Port: 6668 SSL/TLS: aus Optional: Kanäle beim Verbinden automatisch betreten Dispatch (SAM v3) Beispiel für config.toml-Standardeinstellungen:\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults Irc2P Client-Tunnel: 127.0.0.1:6668 → Upstream-Server auf Port 6667. Hidden Services Manager: http://127.0.0.1:7657/i2ptunnel/. Empfohlen, aktiv gewartet ~/.i2pd/tunnels.conf:\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat Separater Tunnel für Ilita (Beispiel):\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat macOS-Optionen SAM aktivieren in Java I2P (standardmäßig deaktiviert) unter /configclients oder clients.config. Standardwerte: 127.0.0.1:7656/TCP und 127.0.0.1:7655/UDP. Empfohlene Kryptografie: SIGNATURE_TYPE=7 (Ed25519) und i2cp.leaseSetEncType=4,0 (ECIES‑X25519 mit ElGamal-Fallback) oder nur 4 für ausschließlich moderne Systeme. Beispielkonfigurationen Java I2P Standard: 2 eingehend / 2 ausgehend. i2pd Standard: 5 eingehend / 5 ausgehend. Für IRC: 2–3 jeweils ist ausreichend; explizit setzen für konsistentes Verhalten über router hinweg. Client-Einrichtung Aktivieren Sie SSL/TLS nicht für interne I2P-IRC-Verbindungen. I2P bietet bereits Ende-zu-Ende-Verschlüsselung. Zusätzliches TLS erzeugt Overhead ohne Anonymitätsgewinn. Verwenden Sie persistente Schlüssel für eine stabile Identität; vermeiden Sie es, Schlüssel bei jedem Neustart neu zu generieren, außer zu Testzwecken. Wenn mehrere Anwendungen IRC nutzen, bevorzugen Sie separate Tunnel (nicht gemeinsam genutzt), um dienstübergreifende Korrelation zu reduzieren. Falls Sie Fernsteuerung (SAM/I2CP) zulassen müssen, binden Sie diese an localhost und sichern Sie den Zugriff mit SSH-Tunneln oder authentifizierten Reverse-Proxys. Alternative connection method: SOCKS5 Einige Clients können sich über I2P\u0026rsquo;s SOCKS5-Proxy verbinden: 127.0.0.1:4447. Für beste Ergebnisse sollte ein dedizierter IRC-Client-Tunnel auf Port 6668 bevorzugt werden; SOCKS kann Identifikatoren auf Anwendungsebene nicht bereinigen und könnte Informationen preisgeben, wenn der Client nicht für Anonymität ausgelegt ist.\nTroubleshooting Keine Verbindung möglich — stellen Sie sicher, dass der Irc2P-Tunnel läuft und der Router vollständig gebootstrappt ist. Hängt bei Auflösung/Beitritt — überprüfen Sie, dass SSL deaktiviert ist und der Client auf 127.0.0.1:6668 verweist. Hohe Latenz — I2P hat konstruktionsbedingt eine höhere Latenz. Halten Sie die Tunnel-Anzahl moderat (2–3) und vermeiden Sie schnelle Reconnect-Schleifen. Verwendung von SAM-Apps — bestätigen Sie, dass SAM aktiviert ist (Java) oder nicht durch eine Firewall blockiert wird (i2pd). Langlebige Sessions werden empfohlen. Appendix: Ports and naming Gängige IRC-Tunnel-Ports: 6668 (Irc2P-Standard), 6667 und 6669 als Alternativen. .b32.i2p-Hostnamen: 52-Zeichen-Standardform; erweiterte 56+-Zeichen-Formen existieren für LS2/erweiterte Zertifikate. Verwenden Sie .i2p-Hostnamen, es sei denn, Sie benötigen explizit b32-Adressen. ","description":"Vollständiger Leitfaden zu I2P IRC-Netzwerken, Clients, Tunneln und Server-Einrichtung (aktualisiert 2025)","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"IRC über I2P","url":"/de/docs/applications/irc/"},{"categories":null,"content":" Status: Diese Seite fasst die veraltete „Low-level Cryptography Specification“ zusammen. Moderne I2P-Versionen (2.10.0, Oktober 2025) haben die Umstellung auf neue kryptografische Primitive abgeschlossen. Verwenden Sie spezielle Spezifikationen wie ECIES , Encrypted LeaseSets , NTCP2 , Red25519 , SSU2 und Tunnel Creation (ECIES) für Implementierungsdetails.\nEvolution-Snapshot Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) ## Asymmetrische Verschlüsselung X25519 (Schlüsselaustauschverfahren über die elliptische Kurve Curve25519) Wird verwendet für NTCP2, ECIES-X25519-AEAD-Ratchet, SSU2 und die Erstellung von X25519-basierten tunnel. Bietet kompakte Schlüssel, zeitkonstante Operationen und Vorwärtsgeheimnis über das Noise-Protokoll-Framework. Bietet 128-Bit-Sicherheit mit 32-Byte-Schlüsseln und effizientem Schlüsselaustausch. ElGamal (veraltet) Zur Abwärtskompatibilität mit älteren routers beibehalten. Arbeitet über die 2048‑Bit Oakley Group 14‑Primzahl (RFC 3526) mit Generator 2. Verschlüsselt AES‑Sitzungsschlüssel plus IVs in 514‑Byte‑Geheimtexten. Unterstützt weder authentifizierte Verschlüsselung noch Vorwärtsgeheimnis; alle modernen Endpunkte sind auf ECIES migriert. Symmetrische Verschlüsselung ChaCha20/Poly1305 Standard‑Primitiv für authentifizierte Verschlüsselung in NTCP2, SSU2 und ECIES. Bietet AEAD‑Sicherheit (authentifizierte Verschlüsselung mit zusätzlichen Daten) und hohe Leistung ohne AES‑Hardwareunterstützung. Implementiert gemäß RFC 7539 (256‑Bit‑Schlüssel, 96‑Bit‑Nonce, 128‑Bit‑Tag). AES‑256/CBC (veraltet) Wird weiterhin für die Verschlüsselung auf der tunnel‑Schicht verwendet, da dessen Blockchiffre‑Struktur zum geschichteten Verschlüsselungsmodell von I2P passt. Verwendet PKCS#5‑Padding und per‑Hop‑IV‑Transformationen. Für eine langfristige Überprüfung vorgesehen, bleibt aber kryptografisch solide. Signaturen Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer ## Hash- und Schlüsselableitung SHA‑256: Wird für DHT-Schlüssel, HKDF und veraltete Signaturen verwendet. SHA‑512: Wird von EdDSA/RedDSA und in Noise‑HKDF‑Ableitungen verwendet. HKDF‑SHA256: Leitet Sitzungsschlüssel in ECIES, NTCP2 und SSU2 ab. Täglich rotierende SHA‑256‑Ableitungen sichern die Speicherorte von RouterInfo und LeaseSet in der netDb. Zusammenfassung der Transportschicht Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) Beide Transporte bieten Vorwärtsgeheimnis auf Link‑Ebene und Schutz vor Replay‑Angriffen, unter Verwendung des Noise_XK‑Handshake‑Musters. Tunnel-Schicht-Verschlüsselung Verwendet weiterhin AES‑256/CBC für die mehrschichtige Verschlüsselung pro Hop. Ausgehende Gateways führen iterative AES‑Entschlüsselung durch; jeder Hop verschlüsselt mit seinem Layer‑Schlüssel und IV‑Schlüssel erneut. Doppelte‑IV‑Verschlüsselung mindert Korrelations- und Bestätigungsangriffe. Eine Migration zu AEAD (Authentifizierte Verschlüsselung mit zugehörigen Daten) wird untersucht, ist derzeit jedoch nicht geplant. Post-Quanten-Kryptografie I2P 2.10.0 führt experimentelle hybride Post‑Quanten‑Verschlüsselung ein. Zum Testen manuell über den Hidden Service Manager (Verwaltung für versteckte Dienste) aktiviert. Kombiniert X25519 mit einem quantenresistenten KEM (Hybridmodus). Nicht standardmäßig aktiv; gedacht für Forschung und Leistungsbewertung. Erweiterbarkeits-Framework Verschlüsselungs- und Signatur-Typkennungen ermöglichen die parallele Unterstützung mehrerer Kryptoprimitive. Aktuelle Zuordnungen umfassen: Verschlüsselungstypen: 0 = ElGamal/AES+SessionTags, 4 = ECIES‑X25519‑AEAD‑Ratchet. Signaturtypen: 0 = DSA‑SHA1, 7 = EdDSA‑SHA512‑Ed25519, 11 = RedDSA‑SHA512‑Ed25519. Dieses Framework ermöglicht zukünftige Upgrades, einschließlich Post‑Quanten‑Verfahren, ohne Aufspaltung des Netzwerks. Kryptografische Zusammensetzung Transportschicht: X25519 + ChaCha20/Poly1305 (Noise framework (Kryptografie‑Framework)). Tunnel‑Schicht: AES‑256/CBC‑Schichtverschlüsselung für Anonymität. Ende‑zu‑Ende: ECIES‑X25519‑AEAD‑Ratchet (Schlüsselwechsel‑Mechanismus) für Vertraulichkeit und Vorwärtsgeheimnis. Datenbank‑Schicht: EdDSA/RedDSA‑Signaturen für Authentizität. Diese Schichten wirken zusammen und ermöglichen eine Verteidigung in der Tiefe: Selbst wenn eine Schicht kompromittiert wird, bewahren die anderen Vertraulichkeit und Nichtverknüpfbarkeit.\nZusammenfassung Der kryptografische Stack von I2P 2.10.0 konzentriert sich auf:\nCurve25519 (X25519) für Schlüsselaustausch ChaCha20/Poly1305 für symmetrische Verschlüsselung EdDSA / RedDSA für Signaturen SHA‑256 / SHA‑512 für Hashing und Ableitung Experimentelle Post‑Quanten‑Hybridmodi für Vorwärtskompatibilität Die veralteten Verfahren ElGamal, AES‑CBC und DSA werden aus Gründen der Abwärtskompatibilität zwar beibehalten, jedoch in aktiven Transporten oder Verschlüsselungspfaden nicht mehr verwendet.\n","description":"Zusammenfassung der in I2P verwendeten symmetrischen, asymmetrischen und Signatur-Primitive","id":"f5b93f818161e04d49735c3df52fcbdc","section":"docs","title":"Kryptografie auf niedriger Ebene","url":"/de/docs/specs/cryptography/"},{"categories":null,"content":"Diese Implementierung von I2P (die Java-Implementierung, die auf dieser Seite verteilt wird) enthält eine \u0026ldquo;Strict Countries List\u0026rdquo;, die verwendet wird, um das Routerverhalten in Regionen anzupassen, in denen die Teilnahme am Routing für andere möglicherweise gesetzlich eingeschränkt ist. Obwohl uns keine Rechtsordnungen bekannt sind, die die Nutzung von I2P verbieten, haben mehrere umfassende Verbote für das Weiterleiten von Datenverkehr. Router, die sich offenbar in \u0026ldquo;strict\u0026rdquo; Ländern befinden, werden automatisch in den Hidden-Modus versetzt.\nDas Projekt bezieht sich bei diesen Entscheidungen auf Forschungsergebnisse von Bürgerrechts- und digitalen Rechtsorganisationen. Insbesondere fließen laufende Untersuchungen von Freedom House in unsere Entscheidungen ein. Die allgemeine Richtlinie besteht darin, Länder mit einem Civil Liberties (CL)-Wert von 16 oder weniger oder einem Internet Freedom-Wert von 39 oder weniger (nicht frei) einzubeziehen.\nZusammenfassung des Hidden-Modus Wenn ein Router in den Hidden-Modus versetzt wird, ändern sich drei wesentliche Aspekte seines Verhaltens:\nEs veröffentlicht keine RouterInfo in der netDb. Es akzeptiert keine participating tunnels. Es lehnt direkte Verbindungen zu Routern im selben Land ab. Diese Schutzmaßnahmen erschweren es, Router zuverlässig zu erfassen, und verringern das Risiko, lokale Verbote bezüglich der Weiterleitung von Datenverkehr für andere zu verletzen.\nListe strenger Länder (Stand: 2024) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; Wenn Sie der Meinung sind, dass ein Land zur strikten Liste hinzugefügt oder daraus entfernt werden sollte, eröffnen Sie bitte ein Issue: https://i2pgit.org/i2p/i2p.i2p/ Referenz: Freedom House – https://freedomhouse.org/ ","description":"Wie sich I2P in Jurisdiktionen mit Einschränkungen für Routing- oder Anonymitätstools verhält (Hidden Mode und Strict List)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"Länder mit strikten/restriktiven Internetrichtlinien","url":"/de/docs/overview/restrictive-countries/"},{"categories":null,"content":"I2P Netzwerk-Performance: Geschwindigkeit, Verbindungen und Ressourcenverwaltung Das I2P-Netzwerk ist vollständig dynamisch. Jeder Client ist anderen Knoten bekannt und testet lokal bekannte Knoten auf Erreichbarkeit und Kapazität. Nur erreichbare und leistungsfähige Knoten werden in einer lokalen NetDB gespeichert. Während des Tunnel-Aufbauprozesses werden die besten Ressourcen aus diesem Pool ausgewählt, um Tunnel aufzubauen. Da das Testen kontinuierlich stattfindet, ändert sich der Pool der Knoten. Jeder I2P-Knoten kennt einen anderen Teil der NetDB, was bedeutet, dass jeder Router eine andere Menge von I2P-Knoten hat, die für Tunnel verwendet werden können. Selbst wenn zwei Router die gleiche Teilmenge bekannter Knoten haben, werden die Tests auf Erreichbarkeit und Kapazität wahrscheinlich unterschiedliche Ergebnisse zeigen, da die anderen Router möglicherweise gerade unter Last stehen, wenn ein Router testet, aber frei sind, wenn der zweite Router testet.\nDies beschreibt, warum jeder I2P-Knoten unterschiedliche Knoten zum Aufbau von Tunnels verwendet. Da jeder I2P-Knoten eine unterschiedliche Latenz und Bandbreite hat, weisen Tunnels (die über diese Knoten aufgebaut werden) unterschiedliche Latenz- und Bandbreitenwerte auf. Und da jeder I2P-Knoten unterschiedliche Tunnels aufgebaut hat, haben keine zwei I2P-Knoten die gleichen Tunnel-Sets.\nEin Server/Client wird als \u0026ldquo;Destination\u0026rdquo; bezeichnet und jede Destination verfügt über mindestens einen eingehenden und einen ausgehenden Tunnel. Die Standardeinstellung beträgt 3 Hops pro Tunnel. Dies summiert sich auf 12 Hops (12 verschiedene I2P-Knoten) für einen vollständigen Roundtrip Client → Server → Client.\nJedes Datenpaket wird durch 6 andere I2P-Knoten gesendet, bis es den Server erreicht:\nclient - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - server\nund auf dem Rückweg 6 verschiedene I2P-Knoten:\nserver - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - client\nDatenverkehr im Netzwerk benötigt ein ACK, bevor neue Daten gesendet werden; er muss warten, bis ein ACK vom Server zurückkommt: Daten senden, auf ACK warten, weitere Daten senden, auf ACK warten. Da sich die RTT (Round Trip Time) aus der Latenz jedes einzelnen I2P-Knotens und jeder Verbindung auf dieser Hin- und Rückstrecke zusammensetzt, dauert es normalerweise 1–3 Sekunden, bis ein ACK zum Client zurückkommt. Aufgrund des Designs von TCP und I2P-Transport hat ein Datenpaket eine begrenzte Größe. Zusammen setzen diese Bedingungen eine maximale Bandbreite pro Tunnel von etwa 20–50 kB/s. Wenn jedoch nur ein Hop im Tunnel nur 5 kB/s Bandbreite zur Verfügung hat, ist der gesamte Tunnel auf 5 kB/s begrenzt, unabhängig von der Latenz und anderen Einschränkungen.\nVerschlüsselung, Latenz und die Art und Weise, wie ein Tunnel aufgebaut wird, machen es sehr rechenintensiv, einen Tunnel zu erstellen. Deshalb darf eine Destination maximal 6 eingehende und 6 ausgehende Tunnels für den Datentransport haben. Mit maximal 50 kB/s pro Tunnel könnte eine Destination ungefähr 300 kB/s Traffic insgesamt nutzen (in Wirklichkeit könnte es mehr sein, wenn kürzere Tunnels mit geringer oder keiner Anonymität verwendet werden). Benutzte Tunnels werden alle 10 Minuten verworfen und neue werden aufgebaut. Dieser Wechsel von Tunnels und manchmal Clients, die herunterfahren oder ihre Verbindung zum Netzwerk verlieren, führen manchmal zu unterbrochenen Tunnels und Verbindungen. Ein Beispiel dafür ist im IRC2P Network beim Verbindungsverlust (Ping Timeout) oder bei der Verwendung von eepget zu sehen.\nMit einer begrenzten Anzahl von Zielen und einer begrenzten Anzahl von Tunneln pro Ziel verwendet ein I2P-Knoten nur eine begrenzte Anzahl von Tunneln über andere I2P-Knoten hinweg. Wenn beispielsweise ein I2P-Knoten im obigen kleinen Beispiel \u0026ldquo;hop1\u0026rdquo; ist, sieht er nur einen teilnehmenden Tunnel, der vom Client ausgeht. Summiert man das gesamte I2P-Netzwerk auf, könnte nur eine relativ begrenzte Anzahl teilnehmender Tunnel mit insgesamt begrenzter Bandbreite aufgebaut werden. Verteilt man diese begrenzten Zahlen auf die Anzahl der I2P-Knoten, steht nur ein Bruchteil der verfügbaren Bandbreite/Kapazität zur Nutzung bereit.\nUm anonym zu bleiben, sollte ein Router nicht vom gesamten Netzwerk zum Aufbau von Tunneln verwendet werden. Wenn ein Router als Tunnel-Router für alle I2P-Knoten fungiert, wird er zu einem sehr realen zentralen Ausfallpunkt sowie zu einem zentralen Punkt zum Sammeln von IPs und Daten von Clients. Aus diesem Grund verteilt das Netzwerk den Datenverkehr im Tunnel-Aufbauprozess über mehrere Knoten.\nEin weiterer Aspekt für die Performance ist die Art und Weise, wie I2P das Mesh-Netzwerk handhabt. Jeder Verbindungs-Hop nutzt eine TCP- oder UDP-Verbindung auf I2P-Knoten. Bei 1000 Verbindungen sieht man 1000 TCP-Verbindungen. Das ist ziemlich viel, und einige Heim- und kleine Büro-Router erlauben nur eine geringe Anzahl von Verbindungen. I2P versucht, diese Verbindungen auf unter 1500 pro UDP- und pro TCP-Typ zu begrenzen. Dies begrenzt auch die Menge an Traffic, die über einen I2P-Knoten geroutet wird.\nWenn ein Node erreichbar ist und eine Bandbreiteneinstellung von \u0026gt;128 kB/s geteilt hat sowie 24/7 erreichbar ist, sollte er nach einiger Zeit für Teilnahme-Traffic verwendet werden. Wenn er zwischenzeitlich offline ist, wird das Testen eines I2P-Nodes durch andere Nodes diesen als nicht erreichbar melden. Dies blockiert einen Node für mindestens 24 Stunden auf anderen Nodes. Die anderen Nodes, die diesen Node als offline getestet haben, werden ihn also 24 Stunden lang nicht für den Aufbau von Tunneln verwenden. Deshalb ist Ihr Traffic nach einem Neustart/Herunterfahren Ihres I2P-Routers für mindestens 24 Stunden niedriger.\nZusätzlich müssen andere I2P-Knoten einen I2P-Router kennen, um ihn auf Erreichbarkeit und Kapazität zu testen. Dieser Prozess kann beschleunigt werden, wenn Sie mit dem Netzwerk interagieren, beispielsweise durch die Nutzung von Anwendungen oder den Besuch von I2P-Sites, was zu mehr Tunnel-Aufbau und damit zu mehr Aktivität und Erreichbarkeit für Tests durch Knoten im Netzwerk führt.\nLeistungshistorie (Auswahl) Im Laufe der Jahre hat I2P eine Reihe bemerkenswerter Leistungsverbesserungen erfahren:\nNative math Implementiert über JNI-Bindings zur GNU MP-Bibliothek (GMP), um BigInteger modPow zu beschleunigen, welches zuvor die CPU-Zeit dominierte. Erste Ergebnisse zeigten dramatische Geschwindigkeitssteigerungen bei Public-Key-Kryptographie. Siehe: /misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) Zuvor erforderten Antworten häufig eine Netzwerkdatenbankabfrage für den LeaseSet des Absenders. Das Bündeln des LeaseSet des Absenders im initialen Garlic verbessert die Antwortlatenz. Dies wird jetzt selektiv durchgeführt (Beginn einer Verbindung oder wenn sich der LeaseSet ändert), um den Overhead zu reduzieren.\nNative Mathematik Einige Validierungsschritte wurden früher im Transport-Handshake durchgeführt, um fehlerhafte Peers schneller abzulehnen (falsche Uhrzeiten, fehlerhafte NAT/Firewall, inkompatible Versionen), wodurch CPU und Bandbreite gespart werden.\nGarlic-Verpackung eines \u0026ldquo;Reply\u0026rdquo; LeaseSet (optimiert) Verwenden Sie kontextbewusstes Tunnel-Testing: Vermeiden Sie das Testen von Tunneln, bei denen bereits bekannt ist, dass sie Daten übertragen; bevorzugen Sie Tests im Leerlauf. Dies reduziert den Overhead und beschleunigt die Erkennung fehlerhafter Tunnel.\nEffizientere TCP-Ablehnung Das Beibehalten von Auswahlentscheidungen für eine bestimmte Verbindung reduziert die Auslieferung außerhalb der Reihenfolge und ermöglicht es der Streaming-Bibliothek, die Fenstergrößen zu erhöhen, wodurch der Durchsatz verbessert wird.\nAnpassungen für Tunnel-Tests GZip oder Ähnliches für ausführliche Strukturen (z.B. RouterInfo-Optionen) reduziert die Bandbreite, wo es angebracht ist.\nPersistente Tunnel-/Lease-Auswahl Ersatz für das vereinfachte „ministreaming\u0026quot;-Protokoll. Modernes Streaming umfasst selektive ACKs und Staukontrolle, die auf I2Ps anonyme, nachrichtenorientierte Infrastruktur zugeschnitten sind. Siehe: /docs/api/streaming/\nFuture Performance Improvements (historical ideas) Nachfolgend sind Ideen dokumentiert, die historisch als potenzielle Verbesserungen erfasst wurden. Viele sind veraltet, implementiert oder durch architektonische Änderungen überholt.\nAusgewählte Datenstrukturen komprimieren Verbessere die Art und Weise, wie Router Peers für den Tunnelbau auswählen, um langsame oder überlastete zu vermeiden, während gleichzeitig die Widerstandsfähigkeit gegen Sybil-Angriffe durch mächtige Angreifer erhalten bleibt.\nVollständiges Streaming-Protokoll Reduziere unnötige Exploration, wenn der Keyspace stabil ist; passe an, wie viele Peers bei Lookups zurückgegeben werden und wie viele gleichzeitige Suchen durchgeführt werden.\nSession Tag tuning and improvements (legacy) Für das veraltete ElGamal/AES+SessionTag-Schema reduzieren intelligentere Ablauf- und Auffüllstrategien ElGamal-Fallbacks und verschwendete Tags.\nBessere Peer-Profilierung und -Auswahl Generiere Tags aus einem synchronisierten PRNG, der während der Etablierung einer neuen Session initialisiert wird, wodurch der Overhead pro Nachricht im Vergleich zu vorab zugestellten Tags reduziert wird.\nNetzwerkdatenbank-Tuning Längere Tunnel-Lebensdauern in Verbindung mit Healing können den Rebuild-Overhead reduzieren; dies muss gegen Anonymität und Zuverlässigkeit abgewogen werden.\nSession Tag Anpassung und Verbesserungen (veraltet) Ungültige Peers früher ablehnen und Tunneltests kontextbezogener gestalten, um Konflikte und Latenz zu reduzieren.\nSessionTag zu synchronisiertem PRNG migrieren (veraltet) Selektives LeaseSet-Bündeln, komprimierte RouterInfo-Optionen und die Einführung des vollständigen Streaming-Protokolls tragen alle zu einer besseren wahrgenommenen Leistung bei.\nSiehe auch:\nTunnel Routing Peer-Auswahl Transports SSU2-Spezifikation und NTCP2-Spezifikation ","description":"I2P-Netzwerkleistung: wie es sich heute verhält, historische Verbesserungen und Ideen für zukünftige Optimierungen","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"Leistung","url":"/de/docs/overview/performance/"},{"categories":null,"content":" Geltungsbereich: Dieser Leitfaden fasst die tunnel-Implementierung, das Nachrichtenformat und beide Spezifikationen für die tunnel-Erstellung (ECIES und veraltetes ElGamal) zusammen. Bestehende Deep Links funktionieren weiterhin über die oben genannten Aliase.\nTunnelmodell I2P leitet Nutzdaten durch unidirektionale tunnels weiter: geordnete Sequenzen von routers, die den Datenverkehr nur in eine Richtung transportieren. Ein vollständiger Hin- und Rückweg zwischen zwei Zielen erfordert vier tunnels (zwei ausgehend, zwei eingehend).\nBeginnen Sie mit der Tunnel-Übersicht für die Terminologie und verwenden Sie dann diesen Leitfaden für die operativen Details.\nLebenszyklus von Nachrichten Das tunnel-Gateway bündelt eine oder mehrere I2NP-Nachrichten, fragmentiert sie und schreibt Zustellanweisungen. Das Gateway kapselt die Nutzlast in eine tunnel-Nachricht fester Größe (1024 B) ein und füllt bei Bedarf mit Padding auf. Jeder Teilnehmer verifiziert den vorherigen Hop, wendet seine Verschlüsselungsschicht an und leitet {nextTunnelId, nextIV, encryptedPayload} an den nächsten Hop weiter. Der tunnel-Endpunkt entfernt die letzte Schicht, wertet die Zustellanweisungen aus, setzt Fragmente wieder zusammen und gibt die rekonstruierten I2NP-Nachrichten weiter. Die Duplikaterkennung verwendet einen zeitlich verfallenden Bloom-Filter, dessen Schlüssel das XOR aus dem IV (Initialisierungsvektor) und dem ersten Chiffrierblock ist, um Tagging-Angriffe auf Basis von IV‑Vertauschungen zu verhindern.\nRollen im Überblick Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally ### Verschlüsselungs-Workflow {#encryption-workflow} Inbound tunnels: das Gateway verschlüsselt einmal mit seinem Layer-Schlüssel; nachgelagerte Teilnehmer verschlüsseln weiter, bis der Ersteller die endgültige Nutzlast entschlüsselt. Outbound tunnels: das Gateway wendet vorab das Inverse der Verschlüsselung jedes einzelnen Hops an, sodass jeder Teilnehmer verschlüsselt. Wenn der Endpunkt verschlüsselt, wird der ursprüngliche Klartext des Gateways offengelegt. In beiden Richtungen wird {tunnelId, IV, encryptedPayload} an den nächsten Hop weitergeleitet.\nTunnel-Nachrichtenformat Tunnel-Gateways fragmentieren I2NP-Nachrichten in Umschläge fester Größe, um die Nutzlastlänge zu verbergen und die Verarbeitung pro Sprung zu vereinfachen.\nVerschlüsseltes Layout +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – 32-Bit-Bezeichner für den nächsten Hop (ungleich Null, rotiert bei jedem Build-Zyklus). IV – 16-Byte AES IV, pro Nachricht gewählt. Verschlüsselte Nutzlast – 1008 Bytes AES-256-CBC-Chiffrat. Gesamtgröße: 1028 Byte.\nEntschlüsseltes Layout Nachdem ein Hop (Zwischenknoten) seine Verschlüsselungsschicht entfernt:\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... Prüfsumme verifiziert den entschlüsselten Block. Padding (Auffüllung) besteht aus zufälligen Nicht-Null-Bytes, die durch ein Nullbyte abgeschlossen werden. Zustellanweisungen geben dem Endpunkt vor, wie jedes Fragment zu behandeln ist (lokal zustellen, an einen anderen tunnel weiterleiten, usw.). Fragmente transportieren die zugrunde liegenden I2NP-Nachrichten; der Endpunkt setzt sie wieder zusammen, bevor er sie an höhere Schichten weitergibt. Verarbeitungsschritte Gateways fragmentieren und reihen I2NP-Nachrichten in Warteschlangen ein; dabei halten sie Teilfragmente kurzzeitig zur späteren Wiederzusammensetzung vor. Das Gateway verschlüsselt die Nutzlast mit den passenden Layer-Schlüsseln und fügt die tunnel ID sowie die IV (Initialisierungsvektor) ein. Jeder Teilnehmer verschlüsselt die IV (AES-256/ECB) und anschließend die Nutzlast (AES-256/CBC), verschlüsselt danach die IV erneut und leitet die Nachricht weiter. Der Endpunkt entschlüsselt in umgekehrter Reihenfolge, verifiziert die Prüfsumme, verarbeitet die Zustellanweisungen und setzt die Fragmente wieder zusammen. Tunnel-Erstellung (ECIES-X25519) Moderne routers bauen tunnels mit ECIES-X25519-Schlüsseln, wodurch die Aufbau-Nachrichten kleiner werden und Vorwärtsgeheimnis ermöglicht wird.\nBuild-Nachricht: Eine einzelne I2NP-Nachricht TunnelBuild (oder VariableTunnelBuild) transportiert 1–8 verschlüsselte Build-Einträge, je einen pro Hop. Layer-Schlüssel: Ersteller leiten pro Hop Layer-, IV- und Reply-Schlüssel mittels HKDF (HMAC-basierte Schlüsselableitungsfunktion) aus der statischen X25519-Identität des Hops und dem ephemeren Schlüssel des Erstellers ab. Verarbeitung: Jeder Hop entschlüsselt seinen Eintrag, validiert Anforderungs-Flags, schreibt den Reply-Block (Erfolg oder detaillierter Fehlercode), verschlüsselt die verbleibenden Einträge erneut und leitet die Nachricht weiter. Antworten: Der Ersteller erhält eine mit garlic encryption umhüllte Antwortnachricht. Als fehlgeschlagen markierte Einträge enthalten einen Schweregradcode, damit der router den Peer profilieren kann. Kompatibilität: router können aus Gründen der Abwärtskompatibilität weiterhin ältere ElGamal-Builds akzeptieren, aber neue tunnels verwenden standardmäßig ECIES (integriertes Verschlüsselungsschema auf elliptischen Kurven). Für Konstanten zu den einzelnen Feldern und Anmerkungen zur Schlüsselableitung siehe die ECIES-Vorschlagshistorie und den router-Quellcode; dieser Leitfaden behandelt den operativen Ablauf.\nErstellung veralteter Tunnel (ElGamal-2048) Das ursprüngliche tunnel-Aufbauformat verwendete öffentliche ElGamal-Schlüssel. Moderne routers halten zur Abwärtskompatibilität eine begrenzte Unterstützung aufrecht.\nStatus: Veraltet. Hier als historische Referenz und für alle, die mit älteren Versionen kompatible Werkzeuge warten, beibehalten.\nNicht-interaktives Teleskopieren: Eine einzelne Build-Nachricht durchläuft den gesamten Pfad. Jeder Hop entschlüsselt seinen 528-Byte-Datensatz, aktualisiert die Nachricht und leitet sie weiter. Variable Länge: Die Variable Tunnel Build Message (VTBM) erlaubte 1–8 Datensätze. Die frühere feste Nachricht enthielt stets acht Datensätze, um die Länge des tunnel zu verschleiern. Layout des Anfragedatensatzes: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding Flags: Bit 7 kennzeichnet ein inbound gateway (IBGW; eingehendes Gateway); Bit 6 markiert einen outbound endpoint (OBEP; ausgehender Endpunkt). Sie schließen sich gegenseitig aus. Verschlüsselung: Jeder Eintrag ist mit dem öffentlichen Schlüssel des Hop (Weiterleitungsknoten) ElGamal‑2048‑verschlüsselt. Symmetrische AES‑256‑CBC‑Schichtung stellt sicher, dass nur der vorgesehene Hop seinen Eintrag lesen kann. Wichtige Fakten: tunnel IDs sind von Null verschiedene 32‑Bit‑Werte; Ersteller können Dummy‑Einträge einfügen, um die tatsächliche tunnel‑Länge zu verbergen; die Zuverlässigkeit hängt von Wiederholungsversuchen bei fehlgeschlagenen Builds ab. Tunnel-Pools und Lebenszyklus Router unterhalten unabhängige eingehende und ausgehende tunnel-Pools für Erkundungsverkehr und für jede I2CP-Sitzung.\nPeer-Auswahl: exploratorische tunnels bedienen sich aus dem „active, not failing“-peer bucket (Gruppe), um Diversität zu fördern; Client-tunnels bevorzugen schnelle Peers mit hoher Kapazität. Deterministische Reihenfolge: Peers werden nach der XOR-Distanz zwischen SHA256(peerHash || poolKey) und dem zufälligen Schlüssel des Pools sortiert. Der Schlüssel wechselt beim Neustart, was innerhalb eines Laufs Stabilität bietet und Vorgängerangriffe über mehrere Läufe hinweg erschwert. Lebenszyklus: router erfassen historische Aufbauzeiten pro {mode, direction, length, variance}-Tupel. Wenn tunnels dem Ablauf nahekommen, beginnt der Ersatz frühzeitig; der router erhöht bei Fehlschlägen die Anzahl paralleler Aufbauvorgänge und begrenzt gleichzeitig die Anzahl ausstehender Versuche. Konfigurationsoptionen: Anzahl aktiver/Backup-tunnels, Hop-Länge und Varianz, Zero-Hop-Erlaubnisse (ohne Zwischenhop) sowie Grenzen für die Aufbau-Rate sind pro Pool einstellbar. Überlastung und Zuverlässigkeit Obwohl tunnels Verbindungen ähneln, behandeln routers sie wie Nachrichtenwarteschlangen. Weighted Random Early Discard (WRED; gewichtetes zufälliges frühzeitiges Verwerfen) wird verwendet, um die Latenz begrenzt zu halten:\nDie Drop-Wahrscheinlichkeit steigt, wenn die Auslastung sich den konfigurierten Grenzwerten nähert. Teilnehmer berücksichtigen Fragmente fester Größe; Gateways/Endpunkte verwerfen anhand der Gesamtgröße der Fragmente und benachteiligen dabei große Nutzlasten zuerst. Ausgehende Endpunkte verwerfen früher als andere Rollen, um möglichst wenig Netzwerkressourcen zu verschwenden. Garantierte Zustellung wird höheren Schichten wie der Streaming library überlassen. Anwendungen, die Zuverlässigkeit benötigen, müssen erneute Übertragungen und Bestätigungen selbst übernehmen.\nWeiterführende Informationen Peer-Auswahl Tunnel-Übersicht Alte Tunnel-Implementierung ","description":"Vereinheitlichte Spezifikation zum Aufbau, zur Verschlüsselung und zum Transport von Datenverkehr über I2P tunnels.","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"Leitfaden für den Tunnelbetrieb","url":"/de/docs/specs/implementation/"},{"categories":null,"content":"Sie möchten also an I2P mitarbeiten? Großartig! Hier ist eine kurze Anleitung für den Einstieg – sei es zur Mitarbeit an der Website oder der Software, zur Entwicklung oder zur Erstellung von Übersetzungen.\nNoch nicht bereit zum Programmieren? Versuche es zuerst mit Mitmachen .\nLernen Sie Java kennen Der I2P router und seine eingebetteten Anwendungen verwenden Java als Hauptentwicklungssprache. Wenn Sie keine Erfahrung mit Java haben, können Sie sich immer Thinking in Java ansehen\nStudieren Sie die Einführung zu \u0026ldquo;how\u0026rdquo;, andere \u0026ldquo;how\u0026rdquo;-Dokumente, die technische Einführung und zugehörige Dokumente:\nEinführung: Einführung in I2P Dokumentations-Hub: Dokumentation Technische Einführung: Technische Einführung Diese geben Ihnen einen guten Überblick darüber, wie I2P strukturiert ist und welche verschiedenen Funktionen es erfüllt.\nDen I2P-Code erhalten Für die Entwicklung am I2P-Router oder den eingebetteten Anwendungen benötigen Sie den Quellcode.\nUnsere aktuelle Methode: Git I2P verfügt über offizielle Git-Dienste und akzeptiert Beiträge via Git auf unserem eigenen GitLab:\nInnerhalb von I2P: http://git.idk.i2p Außerhalb von I2P: https://i2pgit.org Klonen Sie das Haupt-Repository:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git Ein schreibgeschützter Mirror ist auch auf GitHub verfügbar:\nGitHub-Mirror: github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git I2P erstellen Um den Code zu kompilieren, benötigen Sie das Sun/Oracle Java Development Kit 6 oder höher, oder ein entsprechendes JDK (Sun/Oracle JDK 6 wird dringend empfohlen) sowie Apache Ant Version 1.7.0 oder höher. Wenn Sie am Haupt-I2P-Code arbeiten, wechseln Sie in das Verzeichnis i2p.i2p und führen Sie ant aus, um die Build-Optionen anzuzeigen.\nUm Konsolenübersetzungen zu erstellen oder daran zu arbeiten, benötigen Sie die Werkzeuge xgettext, msgfmt und msgmerge aus dem GNU gettext-Paket.\nFür die Entwicklung neuer Anwendungen siehe den Leitfaden zur Anwendungsentwicklung .\nEntwicklungsideen Siehe die Projekt-TODO-Liste oder die Issue-Liste auf GitLab für Ideen:\nGitLab-Issues: i2pgit.org/I2P_Developers/i2p.i2p/issues Bereitstellung der Ergebnisse Siehe unten auf der Lizenzseite für die Anforderungen an Commit-Rechte. Sie benötigen diese, um Code in i2p.i2p einzubringen (nicht erforderlich für die Website!).\nLizenzseite Lernen Sie uns kennen! Die Entwickler sind auf IRC erreichbar. Sie können über verschiedene Netzwerke und im I2P-internen Netzwerk kontaktiert werden. Der übliche Anlaufpunkt ist #i2p-dev. Treten Sie dem Kanal bei und sagen Sie Hallo! Wir haben auch zusätzliche Richtlinien für regelmäßige Entwickler .\nÜbersetzungen Übersetzer für Website und Router-Konsole: Siehe den Leitfaden für neue Übersetzer für die nächsten Schritte.\nWerkzeuge I2P ist Open-Source-Software, die hauptsächlich mit Open-Source-Werkzeugen entwickelt wird. Das I2P-Projekt hat kürzlich eine Lizenz für den YourKit Java Profiler erhalten. Open-Source-Projekte können eine kostenlose Lizenz erhalten, sofern YourKit auf der Projekt-Website referenziert wird. Bitte melden Sie sich, wenn Sie daran interessiert sind, die I2P-Codebasis zu profilieren.\nYourKit unterstützt freundlicherweise Open-Source-Projekte mit seinen voll ausgestatteten Profilern. YourKit, LLC ist der Entwickler innovativer und intelligenter Tools zur Profilerstellung von Java- und .NET-Anwendungen. Werfen Sie einen Blick auf die führenden Softwareprodukte von YourKit:\nYourKit Java Profiler YourKit .NET Profiler ","description":"Wie man anfängt, zu I2P beizutragen: Lernmaterialien, Quellcode, Build-Prozess, Ideen, Veröffentlichung, Community, Übersetzungen und Werkzeuge","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"Leitfaden für neue Entwickler","url":"/de/docs/develop/new-developers/"},{"categories":null,"content":"Möchtest du helfen, I2P für mehr Menschen auf der ganzen Welt zugänglich zu machen? Übersetzungen sind einer der wertvollsten Beiträge, die du zum Projekt leisten kannst. Diese Anleitung führt dich durch die Übersetzung der Router-Konsole.\nÜbersetzungsmethoden Es gibt zwei Möglichkeiten, Übersetzungen beizutragen:\nMethode 1: Transifex (Empfohlen) Dies ist der einfachste Weg, I2P zu übersetzen. Transifex bietet eine webbasierte Oberfläche, die das Übersetzen einfach und zugänglich macht.\nRegistrieren Sie sich bei Transifex Beantragen Sie die Aufnahme in das I2P-Übersetzungsteam Beginnen Sie direkt in Ihrem Browser mit dem Übersetzen Keine technischen Kenntnisse erforderlich - einfach anmelden und mit dem Übersetzen beginnen!\nMethode 2: Manuelle Übersetzung Für Übersetzer, die lieber mit Git und lokalen Dateien arbeiten, oder für Sprachen, die noch nicht auf Transifex eingerichtet sind.\nVoraussetzungen: - Vertrautheit mit git-Versionsverwaltung - Texteditor oder Übersetzungstool (POEdit empfohlen) - Kommandozeilen-Tools: git, gettext\nEinrichtung: 1. Tritt #i2p-dev auf IRC bei und stelle dich vor 2. Aktualisiere den Übersetzungsstatus im Wiki (frage im IRC nach Zugriff) 3. Klone das entsprechende Repository (siehe Abschnitte unten)\nRouterkonsole Übersetzung Die Router-Konsole ist die Weboberfläche, die Sie beim Betrieb von I2P sehen. Ihre Übersetzung hilft Benutzern, die nicht mit Englisch vertraut sind.\nTransifex verwenden (Empfohlen) Gehe zu I2P auf Transifex Wähle das router console Projekt aus Wähle deine Sprache Beginne mit der Übersetzung Manuelle Router Console Übersetzung Voraussetzungen: - Gleich wie bei der Website-Übersetzung (git, gettext) - GPG-Schlüssel (für Commit-Zugriff) - Unterzeichnete Entwicklervereinbarung\nKlone das Haupt-I2P-Repository:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p Zu übersetzende Dateien:\nDie Router-Konsole hat ungefähr 15 Dateien, die übersetzt werden müssen:\nKern-Interface-Dateien:\napps/routerconsole/locale/messages_*.po - Hauptkonsolen-Meldungen apps/routerconsole/locale-news/messages_*.po - Nachrichten-Meldungen Proxy-Dateien:\napps/i2ptunnel/locale/messages_*.po - Tunnel-Konfigurationsoberfläche Anwendungs-Locales:\napps/susidns/locale/messages_*.po - Adressbuch-Oberfläche apps/susimail/locale/messages_*.po - E-Mail-Oberfläche Weitere anwendungsspezifische Locale-Verzeichnisse Dokumentationsdateien:\ninstaller/resources/readme/readme_*.html - Installations-Readme Hilfedateien in verschiedenen Apps Übersetzungsworkflow:\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console Reichen Sie Ihre Arbeit ein: - Erstellen Sie einen Merge Request auf GitLab - Oder teilen Sie Dateien mit dem Entwicklungsteam im IRC\nÜbersetzungswerkzeuge POEdit (Sehr empfohlen) POEdit ist ein spezialisierter Editor für .po-Übersetzungsdateien.\nFunktionen: - Visuelle Benutzeroberfläche für Übersetzungsarbeiten - Zeigt Übersetzungskontext an - Automatische Validierung - Verfügbar für Windows, macOS und Linux\nTexteditoren Sie können auch jeden beliebigen Texteditor verwenden: - VS Code (mit i18n-Erweiterungen) - Sublime Text - vim/emacs (für Terminal-Nutzer)\nQualitätsprüfungen Vor dem Einreichen: 1. Formatierung überprüfen: Stellen Sie sicher, dass Platzhalter wie %s und {0} unverändert bleiben 2. Übersetzungen testen: Installieren und starten Sie I2P, um zu sehen, wie sie aussehen 3. Konsistenz: Halten Sie die Terminologie über alle Dateien hinweg einheitlich 4. Länge: Einige Zeichenketten haben Platzbeschränkungen in der Benutzeroberfläche\nTipps für Übersetzer Allgemeine Richtlinien Bleiben Sie konsistent: Verwenden Sie durchgehend die gleichen Übersetzungen für häufige Begriffe Formatierung beibehalten: Bewahren Sie HTML-Tags, Platzhalter (%s, {0}) und Zeilenumbrüche Kontext ist wichtig: Lesen Sie den englischen Quelltext sorgfältig, um den Kontext zu verstehen Fragen stellen: Nutzen Sie IRC oder Foren, wenn etwas unklar ist Häufige I2P-Begriffe Einige Begriffe sollten auf Englisch bleiben oder sorgfältig transliteriert werden:\nI2P - Keep as is eepsite - I2P-Website (kann in Ihrer Sprache eine Erklärung erfordern) tunnel - Verbindungspfad (Tor-Terminologie wie „circuit\u0026quot; vermeiden) netDb - Netzwerkdatenbank floodfill - Routertyp destination - I2P-Adressendpunkt Testen Ihrer Übersetzungen Erstellen Sie I2P mit Ihren Übersetzungen Ändern Sie die Sprache in den Einstellungen der Router-Konsole Navigieren Sie durch alle Seiten, um zu überprüfen: Text passt in UI-Elemente Keine unleserlichen Zeichen (Kodierungsprobleme) Übersetzungen ergeben im Kontext Sinn Häufig gestellte Fragen Warum ist der Übersetzungsprozess so komplex? Der Prozess verwendet Versionskontrolle (git) und Standard-Übersetzungswerkzeuge (.po-Dateien), weil:\nVerantwortlichkeit: Nachverfolgung, wer was und wann geändert hat Qualität: Überprüfung von Änderungen, bevor sie veröffentlicht werden Konsistenz: Aufrechterhaltung der richtigen Dateiformatierung und -struktur Skalierbarkeit: Effiziente Verwaltung von Übersetzungen in mehreren Sprachen Zusammenarbeit: Mehrere Übersetzer können an derselben Sprache arbeiten Benötige ich Programmierkenntnisse? Nein! Wenn Sie Transifex verwenden, benötigen Sie nur: - Fließende Kenntnisse in Englisch und Ihrer Zielsprache - Einen Webbrowser - Grundlegende Computerkenntnisse\nFür die manuelle Übersetzung benötigen Sie grundlegende Kommandozeilen-Kenntnisse, aber keine Programmierkenntnisse.\nWie lange dauert es? Router-Konsole: Ungefähr 15-20 Stunden für alle Dateien Wartung: Ein paar Stunden pro Monat, um neue Zeichenketten zu aktualisieren Können mehrere Personen an einer Sprache arbeiten? Ja! Koordination ist entscheidend: - Verwenden Sie Transifex für die automatische Koordination - Für manuelle Arbeit kommunizieren Sie im IRC-Kanal #i2p-dev - Teilen Sie die Arbeit nach Abschnitten oder Dateien auf\nWas ist, wenn meine Sprache nicht aufgeführt ist? Fordern Sie es auf Transifex an oder kontaktieren Sie das Team im IRC. Das Entwicklungsteam kann eine neue Sprache schnell einrichten.\nWie kann ich meine Übersetzungen vor dem Einreichen testen? Erstelle I2P aus dem Quellcode mit deinen Übersetzungen Installiere und führe es lokal aus Ändere die Sprache in den Konsoleneinstellungen Hilfe erhalten IRC-Support Tritt #i2p-dev auf IRC bei für: - Technische Hilfe mit Übersetzungswerkzeugen - Fragen zur I2P-Terminologie - Koordination mit anderen Übersetzern - Direkte Unterstützung von Entwicklern\nForen Übersetzungsdiskussionen im I2P Forum Inside I2P: Übersetzungsforum auf zzz.i2p (erfordert I2P router) Dokumentation Transifex-Dokumentation POEdit-Dokumentation gettext-Handbuch Anerkennung Alle Übersetzer werden genannt in: - Der I2P Router-Konsole (Info-Seite) - Website-Credits-Seite - Git-Commit-Verlauf - Veröffentlichungsankündigungen\nIhre Arbeit hilft Menschen auf der ganzen Welt direkt dabei, I2P sicher und privat zu nutzen. Vielen Dank für Ihren Beitrag!\nNächste Schritte Bereit zum Übersetzen?\nWählen Sie Ihre Methode:\nSchnellstart: Auf Transifex registrieren Manueller Ansatz: Treten Sie #i2p-dev auf IRC bei Klein anfangen: Übersetzen Sie ein paar Zeichenketten, um sich mit dem Prozess vertraut zu machen\nUm Hilfe bitten: Zögern Sie nicht, sich über IRC oder Foren zu melden\nVielen Dank, dass Sie helfen, I2P für alle zugänglich zu machen!\n","description":"So tragen Sie Übersetzungen zur I2P-Website und Router-Konsole über Transifex oder manuelle Methoden bei","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"Leitfaden für neue Übersetzer","url":"/de/docs/develop/new-translators/"},{"categories":null,"content":"I2P router fallen am häufigsten aus aufgrund von Problemen mit der Portweiterleitung, unzureichender Bandbreitenzuweisung und ungenügender Bootstrap-Zeit. Diese drei Faktoren machen über 70 % der gemeldeten Probleme aus. Der router benötigt nach dem Start mindestens 10-15 Minuten, um sich vollständig ins Netzwerk zu integrieren, mindestens 128 KB/s Bandbreite (256 KB/s empfohlen) und eine korrekte UDP/TCP-Portweiterleitung, um einen nicht durch eine Firewall blockierten Status zu erreichen. Neue Nutzer erwarten häufig sofortige Konnektivität und starten zu früh neu, was den Integrationsfortschritt zurücksetzt und einen frustrierenden Kreislauf erzeugt. Dieser Leitfaden bietet detaillierte Lösungen für alle wesentlichen I2P-Probleme, die die Versionen 2.10.0 und höher betreffen.\nDie Anonymitätsarchitektur von I2P tauscht inhärent Geschwindigkeit gegen Privatsphäre ein, indem sie mehrstufig verschlüsselte tunnels nutzt. Das Verständnis dieses grundlegenden Designs hilft Nutzern, realistische Erwartungen zu setzen und Probleme effektiv zu beheben, statt normales Verhalten fälschlicherweise als Probleme zu interpretieren.\nRouter startet nicht oder stürzt sofort ab Die häufigsten Startfehler entstehen durch Portkonflikte, Inkompatibilität der Java-Version oder beschädigte Konfigurationsdateien. Überprüfen Sie, ob bereits eine andere I2P-Instanz läuft, bevor Sie tiefergehende Probleme untersuchen.\nPrüfen Sie, ob keine in Konflikt stehenden Prozesse vorhanden sind:\nLinux: ps aux | grep i2p oder netstat -tulpn | grep 7657\nWindows: Task-Manager → Details → nach java.exe mit i2p in der Befehlszeile suchen\nmacOS: Aktivitätsanzeige → nach \u0026ldquo;i2p\u0026rdquo; suchen\nFalls ein Zombie-Prozess existiert, beenden Sie ihn: pkill -9 -f i2p (Linux/Mac) oder taskkill /F /IM javaw.exe (Windows)\nJava-Versionskompatibilität prüfen:\nI2P 2.10.0+ erfordert mindestens Java 8, empfohlen wird Java 11 oder neuer. Überprüfen Sie, dass Ihre Installation \u0026ldquo;mixed mode\u0026rdquo; (nicht \u0026ldquo;interpreted mode\u0026rdquo;) anzeigt:\njava -version Sollte anzeigen: OpenJDK oder Oracle Java, Version 8+, \u0026ldquo;mixed mode\u0026rdquo; (gemischter Modus)\nVermeiden: GNU GCJ, veraltete Java-Implementierungen, ausschließlich interpretierte Modi\nHäufige Portkonflikte treten auf, wenn mehrere Dienste um die Standard-Ports von I2P konkurrieren. Die router‑Konsole (7657), I2CP (7654), SAM (7656) und der HTTP‑Proxy (4444) müssen verfügbar sein. Prüfen Sie auf Konflikte: netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (Windows) oder lsof -i :7657,4444,7654 (Linux/Mac).\nBeschädigung der Konfigurationsdatei äußert sich durch sofortige Abstürze mit Parser-Fehlern in den Protokollen. Router.config erfordert UTF-8-Codierung ohne BOM (Byte Order Mark), verwendet = als Trennzeichen (nicht :) und verbietet bestimmte Sonderzeichen. Sichern Sie die Datei und prüfen Sie sie anschließend: ~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS).\nUm die Konfiguration zurückzusetzen und die Identität beizubehalten: I2P stoppen, router.keys und das Verzeichnis keyData sichern, router.config löschen, neu starten. Der router erzeugt die Standardkonfiguration neu.\nJava-Heap-Zuweisung zu gering führt zu Abstürzen durch OutOfMemoryError (Speichermangel-Fehler). Bearbeiten Sie wrapper.config und erhöhen Sie wrapper.java.maxmemory von den Standardwerten 128 oder 256 auf mindestens 512 (1024 für routers mit hoher Bandbreite). Dazu ist ein vollständiges Herunterfahren, 11 Minuten warten und anschließend ein Neustart erforderlich - ein Klick auf \u0026ldquo;Restart\u0026rdquo; in der Konsole wendet die Änderung nicht an.\nBehebung des Status \u0026ldquo;Network: Firewalled\u0026rdquo; Der Firewalled-Status bedeutet, dass der router keine direkten eingehenden Verbindungen empfangen kann und daher auf introducers (Vermittlerknoten für eingehende Verbindungen) angewiesen ist. Obwohl der router in diesem Zustand funktioniert, verschlechtert sich die Leistung erheblich, und der Beitrag zum Netzwerk bleibt minimal. Um den Non-Firewalled-Status zu erreichen, ist eine korrekt konfigurierte Portweiterleitung erforderlich.\nDer router wählt zufällig einen Port zwischen 9000 und 31000 für die Kommunikation. Finden Sie Ihren Port unter http://127.0.0.1:7657/confignet - suchen Sie nach \u0026ldquo;UDP Port\u0026rdquo; und \u0026ldquo;TCP Port\u0026rdquo; (in der Regel dieselbe Nummer). Sie müssen sowohl UDP als auch TCP weiterleiten, um eine optimale Leistung zu erreichen, obwohl UDP allein grundlegende Funktionalität ermöglicht.\nAutomatische UPnP-Portweiterleitung aktivieren (einfachste Methode):\nRufen Sie http://127.0.0.1:7657/confignet auf Aktivieren Sie \u0026ldquo;Enable UPnP\u0026rdquo; Speichern Sie die Änderungen und starten Sie den router neu Warten Sie 5-10 Minuten und prüfen Sie, ob sich der Status von \u0026ldquo;Network: Firewalled\u0026rdquo; zu \u0026ldquo;Network: OK\u0026rdquo; ändert UPnP erfordert Router-Unterstützung (standardmäßig auf den meisten Consumer-Routern aktiviert, die nach 2010 hergestellt wurden) und eine ordnungsgemäße Netzwerkkonfiguration.\nManuelle Portweiterleitung (erforderlich, wenn UPnP fehlschlägt):\nNotieren Sie Ihren I2P-Port unter http://127.0.0.1:7657/confignet (z. B. 22648) Ermitteln Sie Ihre lokale IP-Adresse: ipconfig (Windows), ip addr (Linux), Systemeinstellungen → Netzwerk (macOS) Rufen Sie die Admin-Oberfläche Ihres Routers auf (typischerweise 192.168.1.1 oder 192.168.0.1) Navigieren Sie zu Portweiterleitung (möglicherweise unter Erweitert, NAT oder Virtuelle Server) Erstellen Sie zwei Regeln: Externer Port: [Ihr I2P-Port] → Interne IP: [Ihr Computer] → Interner Port: [derselbe] → Protokoll: UDP Externer Port: [Ihr I2P-Port] → Interne IP: [Ihr Computer] → Interner Port: [derselbe] → Protokoll: TCP Speichern Sie die Konfiguration und starten Sie Ihren Router bei Bedarf neu Überprüfen Sie die Portweiterleitung nach der Einrichtung mit Online-Prüftools. Wenn die Erkennung fehlschlägt, prüfen Sie die Firewall-Einstellungen - sowohl die Systemfirewall als auch die Firewall der Antivirensoftware müssen den I2P‑Port zulassen.\nAlternative für Hidden mode (verborgener Modus) für restriktive Netzwerke, in denen Portweiterleitung unmöglich ist: Aktivieren unter http://127.0.0.1:7657/confignet → \u0026ldquo;Hidden mode\u0026rdquo; ankreuzen. Der router bleibt hinter einer Firewall, optimiert jedoch für diesen Zustand, indem er ausschließlich SSU introducers verwendet. Die Performance wird langsamer sein, bleibt aber funktionsfähig.\nRouter steckt im Status \u0026ldquo;Starting\u0026rdquo; oder \u0026ldquo;Testing\u0026rdquo; fest Diese vorübergehenden Zustände während des initialen Bootstraps lösen sich typischerweise innerhalb von 10-15 Minuten bei Neuinstallationen oder 3-5 Minuten bei etablierten routers. Vorzeitiges Eingreifen verschlimmert Probleme oft.\n\u0026ldquo;Network: Testing\u0026rdquo; zeigt an, dass der router die Erreichbarkeit über verschiedene Verbindungstypen prüft (direkt, introducers (Vermittlerknoten), mehrere Protokollversionen). Das ist in den ersten 5-10 Minuten normal nach dem Start. Der router testet mehrere Szenarien, um die optimale Konfiguration zu ermitteln.\n\u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; erscheint während der Bootstrap-Phase, wenn der router noch nicht über ausreichende Peer-Informationen verfügt. Der router beteiligt sich nicht am Weiterleitungsverkehr, bis er ausreichend integriert ist. Diese Meldung sollte nach 10–20 Minuten verschwinden, sobald die netDb mit 50+ routers gefüllt ist.\nUhrzeitabweichung macht Erreichbarkeitstests zunichte. I2P erfordert, dass die Systemzeit höchstens ±60 Sekunden von der Netzwerkzeit abweicht. Eine Abweichung von mehr als 90 Sekunden führt zur automatischen Ablehnung von Verbindungen. Synchronisieren Sie Ihre Systemuhr:\nLinux: sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows: Systemsteuerung → Datum und Uhrzeit → Internetzeit → Jetzt aktualisieren → Automatische Synchronisierung aktivieren\nmacOS: Systemeinstellungen → Datum \u0026amp; Uhrzeit → \u0026ldquo;Datum und Uhrzeit automatisch einstellen\u0026rdquo; aktivieren\nNach der Korrektur der Uhrzeitabweichung starten Sie I2P vollständig neu, um eine ordnungsgemäße Integration sicherzustellen.\nUnzureichende Bandbreitenzuweisung verhindert erfolgreiche Tests. Der router benötigt ausreichende Kapazität zum Aufbau von Test tunnels. Konfigurieren Sie dies unter http://127.0.0.1:7657/config:\nMinimal funktionsfähig: Eingehend 96 KB/sec, Ausgehend 64 KB/sec Empfohlener Standard: Eingehend 256 KB/sec, Ausgehend 128 KB/sec Optimale Leistung: Eingehend 512+ KB/sec, Ausgehend 256+ KB/sec Freigabe-Prozentsatz: 80% (ermöglicht dem router, dem Netzwerk Bandbreite beizutragen) Eine geringere Bandbreite kann funktionieren, verlängert jedoch die Integrationszeit von Minuten auf Stunden.\nBeschädigte netDb infolge unsachgemäßen Herunterfahrens oder aufgrund von Festplattenfehlern verursacht endlose Testschleifen. Der router kann die Tests ohne gültige Peer-Daten nicht abschließen:\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start Windows: Löschen Sie den Inhalt von %APPDATA%\\I2P\\netDb\\ oder %LOCALAPPDATA%\\I2P\\netDb\\\nFirewall blockiert reseed (Erstverteilung von Peer-Informationen) verhindert das Auffinden erster Gegenstellen. Während der Initialisierungsphase lädt I2P router-Informationen von HTTPS-Reseed-Servern. Unternehmens- oder ISP-Firewalls können diese Verbindungen blockieren. Konfigurieren Sie den reseed-Proxy unter http://127.0.0.1:7657/configreseed, wenn Sie hinter restriktiven Netzwerken arbeiten.\nLangsame Geschwindigkeiten, Timeouts und Fehler beim tunnel-Aufbau Das Design von I2P führt aufgrund von Multi-Hop-Verschlüsselung, Paket-Overhead und der Unvorhersehbarkeit der Routen inhärent zu 3-10x geringeren Geschwindigkeiten als im Clearnet. Beim Aufbau eines tunnel werden mehrere routers durchlaufen, wobei jeder zusätzliche Latenz verursacht. Dieses Verständnis verhindert, normales Verhalten fälschlicherweise als Probleme zu missdeuten.\nTypische Leistungserwartungen:\nSurfen auf .i2p-Sites: Anfangs 10–30 Sekunden pro Seitenaufruf, schneller nach dem tunnel-Aufbau Torrenting über I2PSnark: 10–100 KB/s pro Torrent, abhängig von Seedern und Netzbedingungen Große Dateidownloads: Geduld nötig – Megabyte-Dateien können Minuten dauern, Gigabyte Stunden Erste Verbindung am langsamsten: Der tunnel-Aufbau dauert 30–90 Sekunden; nachfolgende Verbindungen nutzen bestehende tunnels Erfolgsrate des Tunnelaufbaus ist ein Indikator für die Gesundheit des Netzwerks. Prüfen Sie unter http://127.0.0.1:7657/tunnels:\nÜber 60 %: Normaler, stabiler Betrieb 40-60 %: Grenzwertig, erwägen Sie eine Erhöhung der Bandbreite oder eine Reduzierung der Last Unter 40 %: Problematisch - weist auf unzureichende Bandbreite, Netzwerkprobleme oder eine schlechte Peerauswahl hin Erhöhen Sie die Bandbreitenzuweisung als erste Optimierung. Die meisten Geschwindigkeitsprobleme entstehen durch Bandbreitenmangel. Erhöhen Sie die Limits schrittweise unter http://127.0.0.1:7657/config und überwachen Sie die Diagramme unter http://127.0.0.1:7657/graphs.\nFür DSL/Kabel (1-10 Mbps Verbindungen): - Eingehend: 400 KB/sec - Ausgehend: 200 KB/sec - Freigabe: 80% - Speicher: 384 MB (edit wrapper.config)\nFür schnelle (10-100+ Mbit/s) Verbindungen: - Eingehend: 1500 KB/s - Ausgehend: 1000 KB/s - Anteil: 80-100% - Speicher: 512-1024 MB - Erwägen: Teilnehmende tunnels auf 2000-5000 erhöhen unter http://127.0.0.1:7657/configadvanced\nOptimieren Sie die tunnel-Konfiguration für bessere Leistung. Greifen Sie unter http://127.0.0.1:7657/i2ptunnel auf die spezifischen tunnel-Einstellungen zu und bearbeiten Sie jeden tunnel:\nTunnel-Anzahl: Erhöhen von 2 auf 3-4 (mehr Pfade verfügbar) Backup-Anzahl: Auf 1-2 setzen (schnelles Failover, falls ein Tunnel ausfällt) Tunnel-Länge: Standardmäßig bieten 3 Sprünge ein gutes Gleichgewicht; eine Reduzierung auf 2 verbessert die Geschwindigkeit, verringert aber die Anonymität Native Kryptobibliothek (jbigi) bietet 5-10x bessere Leistung als reine Java-Verschlüsselung. Überprüfen Sie unter http://127.0.0.1:7657/logs, ob sie geladen ist - achten Sie auf \u0026ldquo;jbigi loaded successfully\u0026rdquo; oder \u0026ldquo;Using native CPUID implementation\u0026rdquo;. Falls nicht vorhanden:\nLinux: Normalerweise automatisch erkannt und aus ~/.i2p/jbigi-*.so geladen Windows: Prüfen Sie, ob sich jbigi.dll im I2P-Installationsverzeichnis befindet Falls nicht vorhanden: Build-Tools installieren und aus dem Quellcode kompilieren oder vorkompilierte Binärdateien aus offiziellen Repositories herunterladen\nDen router durchgehend in Betrieb halten. Jeder Neustart setzt die Einbindung zurück und erfordert 30–60 Minuten, um das tunnel-Netzwerk und die Peer-Beziehungen wieder aufzubauen. Stabile router mit hoher Uptime werden bei der Auswahl für den tunnel-Aufbau bevorzugt, was die Leistung durch positive Rückkopplung verbessert.\nHohe CPU- und Speicherauslastung Übermäßige Ressourcennutzung weist typischerweise auf unzureichende Speicherzuweisung, fehlende native Kryptobibliotheken oder zu starke Beteiligung am Netzwerk hin. Gut konfigurierte routers sollten während aktiver Nutzung 10-30% CPU verbrauchen und eine stabile Speicherauslastung unter 80% des zugewiesenen Heaps beibehalten.\nSpeicherprobleme äußern sich wie folgt: - Speicherdiagramme mit flachem Plateau (dauerhaft am Maximum) - Häufige Garbage Collection (Speicherbereinigung; Sägezahnmuster mit starken Einbrüchen) - OutOfMemoryError in den Logs - Router reagiert unter Last nicht mehr - Automatisches Herunterfahren aufgrund von Ressourcenerschöpfung\nJava-Heap-Zuweisung erhöhen in wrapper.config (erfordert vollständiges Herunterfahren):\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 Kritisch: Nach dem Bearbeiten von wrapper.config müssen Sie vollständig herunterfahren (nicht neu starten), 11 Minuten auf ein ordnungsgemäßes Beenden warten und anschließend wieder starten. Die Schaltfläche \u0026ldquo;Restart\u0026rdquo; in der Router-Konsole lädt die Wrapper-Einstellungen nicht neu.\nCPU-Optimierung erfordert eine native Kryptografie-Bibliothek. Reine Java-BigInteger-Operationen verbrauchen 10-20x mehr CPU als native Implementierungen. Überprüfen Sie den jbigi-Status beim Start unter http://127.0.0.1:7657/logs. Ohne jbigi schnellt die CPU-Auslastung während des tunnel-Aufbaus und bei Verschlüsselungsvorgängen auf 50-100 % hoch.\nLast durch teilnehmende tunnel reduzieren wenn der router überlastet ist:\nÖffne http://127.0.0.1:7657/configadvanced Setze router.maxParticipatingTunnels=1000 (Standardwert 8000) Verringere den Freigabeanteil auf http://127.0.0.1:7657/config von 80 % auf 50 % Deaktiviere den floodfill-Modus, falls aktiviert: router.floodfillParticipant=false Begrenzen Sie die I2PSnark-Bandbreite und die Anzahl gleichzeitiger Torrents. Die Nutzung von Torrents beansprucht erhebliche Ressourcen. Unter http://127.0.0.1:7657/i2psnark:\nAktive Torrents auf maximal 3-5 begrenzen \u0026ldquo;Up BW Limit\u0026rdquo; und \u0026ldquo;Down BW Limit\u0026rdquo; auf angemessene Werte setzen (jeweils 50-100 KB/sec) Torrents stoppen, wenn sie nicht aktiv benötigt werden Das gleichzeitige Seeden von Dutzenden Torrents vermeiden Überwachen Sie die Ressourcennutzung über die integrierten Diagramme unter http://127.0.0.1:7657/graphs. Der Arbeitsspeicher sollte Luft nach oben haben, kein Plateau. CPU-Spitzen während des tunnel-Aufbaus sind normal; anhaltend hohe CPU-Auslastung weist auf Konfigurationsprobleme hin.\nFür Systeme mit stark eingeschränkten Ressourcen (Raspberry Pi, alte Hardware) ziehen Sie i2pd (C++-Implementierung) als Alternative in Betracht. i2pd benötigt ~130 MB RAM gegenüber 350+ MB bei Java I2P und nutzt ~7 % CPU gegenüber 70 % unter ähnlicher Last. Beachten Sie, dass i2pd keine integrierten Anwendungen besitzt und externe Tools erfordert.\nI2PSnark-Torrent-Probleme Die Integration von I2PSnark in die I2P router-Architektur setzt das Verständnis voraus, dass Torrent-Aktivitäten vollständig von der Gesundheit der router tunnel abhängen. Torrents starten erst, wenn der router eine ausreichende Integration mit 10+ aktiven Peers und funktionierenden tunnels erreicht hat.\nWenn Torrents bei 0 % feststecken, deutet das typischerweise auf Folgendes hin:\nRouter nicht vollständig integriert: Warten Sie 10–15 Minuten nach dem Start von I2P, bevor Sie Torrent-Aktivität erwarten DHT deaktiviert: Aktivieren Sie es unter http://127.0.0.1:7657/i2psnark → Konfiguration → \u0026ldquo;Enable DHT\u0026rdquo; aktivieren (standardmäßig seit Version 0.9.2 aktiviert) Ungültige oder tote Tracker: I2P-Torrents erfordern I2P-spezifische Tracker - Clearnet-Tracker funktionieren nicht Unzureichende tunnel-Konfiguration: Erhöhen Sie die Anzahl der tunnels in I2PSnark → Konfiguration → Abschnitt Tunnels I2PSnark tunnels für bessere Leistung konfigurieren:\nEingehende Tunnel: 3-5 (Standard: 2 für Java I2P, 5 für i2pd) Ausgehende Tunnel: 3-5 Tunnel-Länge: 3 Sprünge (für mehr Geschwindigkeit auf 2 reduzieren, weniger Anonymität) Tunnel-Anzahl: 3 (sorgt für konstante Leistung) Unverzichtbare I2P-Torrent-Tracker zum Hinzufügen: - tracker2.postman.i2p (primär, am zuverlässigsten) - w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a\nEntfernen Sie alle clearnet (offenes Internet; non-.i2p) Tracker - sie bieten keinen Mehrwert und erzeugen Verbindungsversuche, die in einem Timeout enden.\n\u0026ldquo;Torrent not registered\u0026rdquo;-Fehler treten auf, wenn die Kommunikation mit dem Tracker fehlschlägt. Right-click torrent → \u0026ldquo;Start\u0026rdquo; erzwingt ein erneutes Anmelden beim Tracker. Wenn das Problem weiterhin besteht, prüfen Sie die Erreichbarkeit des Trackers, indem Sie in einem I2P-konfigurierten Browser http://tracker2.postman.i 2p aufrufen. Ausgefallene Tracker sollten durch funktionierende Alternativen ersetzt werden.\nKeine Peers verbinden sich trotz Erfolg beim Tracker deutet auf Folgendes hin: - Router durch Firewall blockiert (bessert sich mit Portweiterleitung, aber nicht erforderlich) - Unzureichende Bandbreite (auf 256+ KB/s erhöhen) - Swarm zu klein (manche Torrents haben 1-2 Seeder; Geduld erforderlich) - DHT deaktiviert (für Peer-Erkennung ohne Tracker aktivieren)\nAktivieren Sie DHT und PEX (Peer Exchange – Peeraustausch) in der I2PSnark-Konfiguration. DHT ermöglicht die Peer-Suche ohne Abhängigkeit von einem Tracker. PEX entdeckt Peers über verbundene Peers und beschleunigt dadurch die Schwarm-Erkennung.\nBeschädigung heruntergeladener Dateien tritt aufgrund der integrierten Integritätsprüfung von I2PSnark nur selten auf. Wenn erkannt:\nRechtsklick auf den Torrent → \u0026ldquo;Check\u0026rdquo; erzwingt das Neu-Berechnen der Hashes aller Pieces (Teilstücke) Beschädigte Torrent-Daten löschen (die .torrent-Datei bleibt erhalten) Rechtsklick → \u0026ldquo;Start\u0026rdquo;, um mit Piece-Verifizierung erneut herunterzuladen Festplatte auf Fehler prüfen, falls die Beschädigung weiterhin besteht: chkdsk (Windows), fsck (Linux) Überwachtes Verzeichnis funktioniert nicht erfordert eine korrekte Konfiguration:\nI2PSnark-Konfiguration → \u0026ldquo;Watch directory\u0026rdquo; (Überwachungsordner): Absoluten Pfad festlegen (z. B. /home/user/torrents/watch) Stellen Sie sicher, dass der I2P-Prozess Leseberechtigungen hat: chmod 755 /path/to/watch .torrent-Dateien im Überwachungsordner ablegen - I2PSnark fügt sie automatisch hinzu \u0026ldquo;Auto start\u0026rdquo; konfigurieren: Prüfen, ob Torrents unmittelbar nach dem Hinzufügen gestartet werden sollen Leistungsoptimierung beim Torrenting:\nGleichzeitig aktive Torrents begrenzen: Maximal 3–5 bei Standardverbindungen Wichtige Downloads priorisieren: Torrents mit niedriger Priorität vorübergehend anhalten Dem router mehr Bandbreite zuweisen: Mehr Bandbreite = bessere Torrent-Leistung Geduld haben: Torrenting über I2P ist von Natur aus langsamer als BitTorrent im Clearnet Nach dem Herunterladen seeden: Das Netzwerk gedeiht durch Reziprozität Konfiguration und Fehlerbehebung für Git über I2P Git-Operationen über I2P erfordern entweder eine SOCKS-Proxy-Konfiguration oder dedizierte I2P tunnels für den SSH/HTTP-Zugriff. Das Design von Git geht von Verbindungen mit niedriger Latenz aus, was die Architektur von I2P mit hoher Latenz zu einer Herausforderung macht.\nGit so konfigurieren, dass es einen I2P-SOCKS-Proxy verwendet:\nBearbeiten Sie ~/.ssh/config (falls nicht vorhanden, erstellen):\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes Dies leitet alle SSH-Verbindungen zu .i2p-Hosts über den SOCKS-Proxy von I2P (Port 4447). Die ServerAlive-Einstellungen halten die Verbindung während der I2P-Latenz aufrecht.\nKonfigurieren Sie Git global für HTTP/HTTPS-Git-Operationen:\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 Hinweis: socks5h führt die DNS-Auflösung über den Proxy durch - entscheidend für .i2p-Domains.\nDedizierten I2P tunnel für Git-SSH erstellen (zuverlässiger als SOCKS):\nÖffne http://127.0.0.1:7657/i2ptunnel \u0026ldquo;Neuer Client tunnel\u0026rdquo; → \u0026ldquo;Standard\u0026rdquo; Konfigurieren: Name: Git-SSH Typ: Client Port: 2222 (lokaler Port für Git-Zugriff) Ziel: [your-git-server].i2p:22 Automatischer Start: Aktiviert Anzahl der tunnel: 3-4 (mehr für höhere Zuverlässigkeit) Speichern und tunnel starten SSH so konfigurieren, dass der tunnel verwendet wird: ssh -p 2222 git@127.0.0.1 SSH-Authentifizierungsfehler über I2P entstehen meist durch:\nSchlüssel nicht zum ssh-agent hinzugefügt: ssh-add ~/.ssh/id_rsa Falsche Berechtigungen der Schlüsseldatei: chmod 600 ~/.ssh/id_rsa Tunnel läuft nicht: Prüfe unter http://127.0.0.1:7657/i2ptunnel, ob der Status grün ist Git-Server erfordert einen bestimmten Schlüsseltyp: Erstelle einen ed25519-Schlüssel, wenn RSA fehlschlägt Zeitüberschreitungen bei Git-Operationen stehen im Zusammenhang mit den Latenzeigenschaften von I2P:\nGit-Timeout erhöhen: git config --global http.postBuffer 524288000 (500 MB Puffer) Grenzwert für niedrige Geschwindigkeit erhöhen: git config --global http.lowSpeedLimit 1000 und git config --global http.lowSpeedTime 600 (wartet 10 Minuten) Für den initialen Checkout einen flachen Klon verwenden: git clone --depth 1 [url] (lädt nur den neuesten Commit, schneller) In Zeiten geringer Aktivität klonen: Netzwerküberlastung beeinträchtigt die I2P-Leistung Langsame git clone/fetch-Operationen sind der Architektur von I2P inhärent. Ein 100‑MB‑Repository kann über I2P 30–60 Minuten dauern, im Gegensatz zu Sekunden im Clearnet. Strategien:\nVerwenden Sie flache Klone: --depth 1 reduziert die anfängliche Datenübertragung deutlich Rufen Sie inkrementell ab: Statt eines vollständigen Klons rufen Sie spezifische Branches ab: git fetch origin branch:branch Erwägen Sie rsync über I2P: Für sehr große Repositories kann rsync eine bessere Leistung liefern Erhöhen Sie die Anzahl der tunnels: Mehr tunnels sorgen für einen höheren Durchsatz bei lang andauernden großen Übertragungen \u0026ldquo;Connection refused\u0026rdquo;-Fehler weisen auf eine tunnel-Fehlkonfiguration hin:\nÜberprüfe, ob der I2P router läuft: Öffne http://127.0.0.1:7657 Bestätige, dass der tunnel aktiv und grün ist unter http://127.0.0.1:7657/i2ptunnel Teste den tunnel: nc -zv 127.0.0.1 2222 (sollte eine Verbindung herstellen, wenn der tunnel funktioniert) Prüfe, ob das Ziel erreichbar ist: Rufe die HTTP-Oberfläche des Ziels im Browser auf, falls verfügbar Überprüfe die tunnel-Protokolle unter http://127.0.0.1:7657/logs auf spezifische Fehler Bewährte Vorgehensweisen für Git über I2P:\nLassen Sie den I2P router durchgehend laufen, um stabilen Git-Zugriff zu gewährleisten Verwenden Sie SSH-Schlüssel statt Passwortauthentifizierung (weniger interaktive Eingabeaufforderungen) Konfigurieren Sie persistente tunnels statt kurzlebiger SOCKS-Verbindungen Erwägen Sie, einen eigenen I2P-Git-Server zu betreiben, um mehr Kontrolle zu haben Dokumentieren Sie Ihre .i2p-Git-Endpunkte für Mitwirkende Zugriff auf eepsites und Auflösung von .i2p-Domains Der häufigste Grund, warum Nutzer nicht auf .i2p-Sites zugreifen können, ist eine falsche Browser-Proxy-Konfiguration. I2P-Sites existieren nur innerhalb des I2P-Netzwerks und erfordern die Weiterleitung über den HTTP-Proxy von I2P.\nProxy-Einstellungen des Browsers exakt konfigurieren:\nFirefox (empfohlen für I2P):\nMenü → Einstellungen → Netzwerkeinstellungen → Schaltfläche \u0026ldquo;Einstellungen\u0026rdquo; Wählen Sie \u0026ldquo;Manuelle Proxy-Konfiguration\u0026rdquo; HTTP-Proxy: 127.0.0.1 Port: 4444 SSL-Proxy: 127.0.0.1 Port: 4444 SOCKS-Proxy: 127.0.0.1 Port: 4447 (optional, für SOCKS-Apps) Aktivieren Sie \u0026ldquo;DNS über Proxy bei Verwendung von SOCKS v5\u0026rdquo; OK klicken, um zu speichern Kritische about:config-Einstellungen in Firefox:\nNavigieren Sie zu about:config und ändern Sie:\nmedia.peerconnection.ice.proxy_only = true (verhindert IP-Leaks über WebRTC) keyword.enabled = false (verhindert, dass .i2p-Adressen zu Suchmaschinen umgeleitet werden) network.proxy.socks_remote_dns = true (DNS über den Proxy) Chrome/Chromium-Einschränkungen:\nChrome verwendet systemweite Proxyeinstellungen statt anwendungsspezifischer. Unter Windows: Einstellungen → nach \u0026ldquo;proxy\u0026rdquo; suchen → \u0026ldquo;Proxy-Einstellungen Ihres Computers öffnen\u0026rdquo; → HTTP konfigurieren: 127.0.0.1:4444 und HTTPS: 127.0.0.1:4445.\nBesserer Ansatz: Verwenden Sie die Erweiterungen FoxyProxy oder Proxy SwitchyOmega für selektives .i2p-Routing.\n\u0026ldquo;Website Not Found In Address Book\u0026rdquo;-Fehler bedeuten, dass dem router die kryptografische Adresse der .i2p-Domain fehlt. I2P verwendet lokale Adressbücher anstelle eines zentralisierten DNS. Lösungen:\nMethode 1: jump services (Sprung-Dienste) verwenden (am einfachsten für neue Websites):\nRufen Sie http://stats.i 2p auf und suchen Sie nach der Website. Klicken Sie auf den addresshelper-Link: http://example.i2p/?i2paddresshelper=base64destination. Ihr Browser zeigt \u0026ldquo;In Adressbuch speichern?\u0026rdquo; - bestätigen Sie, um es hinzuzufügen.\nMethode 2: Adressbuch-Abonnements aktualisieren:\nNavigieren Sie zu http://127.0.0.1:7657/dns (SusiDNS) Klicken Sie auf die Registerkarte \u0026ldquo;Subscriptions\u0026rdquo; Überprüfen Sie die aktiven Abonnements (Standard: http://i2p-projekt.i 2p/hosts.txt) Fügen Sie empfohlene Abonnements hinzu: http://stats.i 2p/cgi-bin/newhosts.txt http://notbob.i 2p/hosts.txt http://reg.i 2p/export/hosts.txt Klicken Sie auf \u0026ldquo;Update Now\u0026rdquo;, um eine sofortige Aktualisierung der Abonnements zu erzwingen Warten Sie 5-10 Minuten auf die Verarbeitung Methode 3: Verwenden Sie base32-Adressen (funktioniert immer, wenn die Website online ist):\nJede .i2p-Website hat eine Base32-Adresse: 52 zufällige Zeichen, gefolgt von .b32.i2p (z. B. ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p). Base32-Adressen umgehen das Adressbuch - der router führt eine direkte kryptografische Auflösung durch.\nHäufige Fehler bei der Browserkonfiguration:\nVersuch, HTTPS auf nur-HTTP-Seiten zu verwenden: Die meisten .i2p-Seiten verwenden nur HTTP - der Aufruf von https://example.i2p schlägt fehl http://-Präfix vergessen: Der Browser könnte statt einer Verbindung eine Suche starten - immer http://example.i2p verwenden WebRTC aktiviert: Kann die echte IP-Adresse preisgeben - über die Firefox-Einstellungen oder Erweiterungen deaktivieren DNS nicht über Proxy geleitet: Clearnet-DNS kann .i2p nicht auflösen - DNS-Abfragen müssen über einen Proxy geleitet werden Falscher Proxy-Port: 4444 für HTTP (nicht 4445, das ist der HTTPS-Outproxy (Proxy zum Zugriff auf das Clearnet)) Router nicht vollständig integriert verhindert den Zugriff auf alle Seiten. Überprüfen Sie, ob die Integration ausreichend ist:\nPrüfe, ob http://127.0.0.1:7657 \u0026ldquo;Network: OK\u0026rdquo; oder \u0026ldquo;Network: Firewalled\u0026rdquo; anzeigt (nicht \u0026ldquo;Network: Testing\u0026rdquo;) \u0026ldquo;Active peers\u0026rdquo; zeigt mindestens 10 an (optimal 50+) Keine Meldung \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; Warte nach dem Start des router volle 10-15 Minuten, bevor du mit .i2p-Zugriff rechnest Konfiguration von IRC und E-Mail-Clients folgt ähnlichen Proxy-Mustern:\nIRC: IRC-Clients verbinden sich mit 127.0.0.1:6668 (IRC-Proxy-tunnel von I2P). Deaktivieren Sie die Proxy-Einstellungen des IRC-Clients - die Verbindung zu localhost:6668 wird bereits über I2P weitergeleitet.\nE-Mail (Postman): - SMTP: 127.0.0.1:7659 - POP3: 127.0.0.1:7660 - Kein SSL/TLS (Verschlüsselung wird durch den I2P tunnel übernommen) - Zugangsdaten aus der Kontoregistrierung bei postman.i2p\nAlle diese tunnels müssen auf http://127.0.0.1:7657/i2ptunnel den Status \u0026ldquo;running\u0026rdquo; (grün) anzeigen.\nInstallationsfehler und Paketprobleme Paketbasierte Installationen (Debian, Ubuntu, Arch) schlagen gelegentlich fehl aufgrund von Repository-Änderungen, abgelaufenen GPG-Schlüsseln oder Abhängigkeitskonflikten. Die offiziellen Repositories wurden in neueren Versionen von deb.i2p2.de/deb.i2p2.no (end-of-life) auf deb.i2p.net umgestellt.\nDebian/Ubuntu-Repository auf den aktuellen Stand aktualisieren:\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring Fehler bei der Überprüfung von GPG-Signaturen treten auf, wenn Repository-Schlüssel ablaufen oder geändert werden:\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc Dienst startet nach der Paketinstallation nicht geht meist auf Probleme mit AppArmor-Profilen unter Debian/Ubuntu zurück:\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service Berechtigungsprobleme bei paketinstalliertem I2P:\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 Java-Kompatibilitätsprobleme:\nI2P 2.10.0 erfordert mindestens Java 8. Ältere Systeme haben möglicherweise Java 7 oder älter:\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java Fehler in der Wrapper-Konfiguration verhindern den Dienststart:\nDer Speicherort von Wrapper.config variiert je nach Installationsmethode: - Benutzerinstallation: ~/.i2p/wrapper.config - Paketinstallation: /etc/i2p/wrapper.config oder /var/lib/i2p/wrapper.config\nHäufige Probleme mit wrapper.config:\nFalsche Pfade: wrapper.java.command muss auf eine gültige Java-Installation verweisen Unzureichender Speicher: wrapper.java.maxmemory zu niedrig eingestellt (auf 512+ erhöhen) Falscher Speicherort der PID-Datei: wrapper.pidfile muss auf einen beschreibbaren Speicherort verweisen Fehlende Wrapper-Binärdatei: Auf einigen Plattformen fehlt ein vorkompilierter Wrapper (runplain.sh als Fallback verwenden) Aktualisierungsfehler und beschädigte Updates:\nAktualisierungen der Router-Konsole schlagen aufgrund von Netzwerkunterbrechungen gelegentlich während des Downloads fehl. Manuelles Update-Verfahren:\nLaden Sie i2pupdate_X.X.X.zip von https://geti2p.net/en/download herunter Überprüfen Sie, dass die SHA256-Prüfsumme dem veröffentlichten Hash entspricht Kopieren Sie es in das I2P-Installationsverzeichnis als i2pupdate.zip Starten Sie den router neu - erkennt und entpackt das Update automatisch Warten Sie 5-10 Minuten auf die Installation des Updates Überprüfen Sie die neue Version unter http://127.0.0.1:7657 Migration von sehr alten Versionen (vor 0.9.47) auf aktuelle Versionen kann aufgrund inkompatibler Signaturschlüssel oder entfernter Funktionen fehlschlagen. Schrittweise Aktualisierungen erforderlich:\nVersionen älter als 0.9.9: Aktuelle Signaturen können nicht überprüft werden - manuelles Update nötig Versionen mit Java 6/7: Java muss vor dem Update von I2P auf 2.x aktualisiert werden Große Versionssprünge: Zuerst auf eine Zwischenversion aktualisieren (0.9.47 ist ein empfohlener Zwischenstopp) Wann das Installationsprogramm statt eines Pakets verwenden:\nPakete (apt/yum): Am besten für Server, automatische Sicherheitsupdates, Systemintegration, systemd-Verwaltung Installationsprogramm (.jar): Am besten für Installation auf Benutzerebene, Windows, macOS, benutzerdefinierte Installationen, Verfügbarkeit der neuesten Version Beschädigung und Wiederherstellung von Konfigurationsdateien Die dauerhafte Speicherung der I2P-Konfiguration beruht auf mehreren kritischen Dateien. Beschädigungen sind typischerweise die Folge von unsachgemäßem Herunterfahren, Festplattenfehlern oder Fehlern bei manueller Bearbeitung. Das Verständnis der Zwecke dieser Dateien ermöglicht eine gezielte Reparatur statt einer vollständigen Neuinstallation.\nKritische Dateien und ihre Zwecke:\nrouter.keys (516+ bytes): Kryptografische Identität des routers - geht sie verloren, wird eine neue Identität erstellt router.info (automatisch erzeugt): Veröffentlichte router-Informationen - kann gefahrlos gelöscht werden, wird neu erzeugt router.config (Text): Hauptkonfiguration - Bandbreite, Netzwerkeinstellungen, Voreinstellungen i2ptunnel.config (Text): tunnel-Definitionen - client/server tunnels, Schlüssel, Ziele netDb/ (Verzeichnis): Peer-Datenbank - router-Informationen für Netzwerkteilnehmer peerProfiles/ (Verzeichnis): Leistungsstatistiken zu Peers - beeinflussen die tunnel-Auswahl keyData/ (Verzeichnis): Zielschlüssel für eepsites und Dienste - bei Verlust ändern sich die Adressen addressbook/ (Verzeichnis): Lokale .i2p-Hostname-Zuordnungen Vollständige Sicherungsprozedur vor Änderungen:\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR Anzeichen einer Beschädigung der Router.config:\nRouter startet nicht, mit Parse-Fehlern in den Logs Einstellungen werden nach einem Neustart nicht beibehalten Unerwartete Standardwerte erscheinen Verstümmelte Zeichen beim Anzeigen der Datei Beschädigte router.config reparieren:\nVorhandene Datei sichern: cp router.config router.config.broken Dateicodierung prüfen: Muss UTF-8 ohne BOM sein Syntax prüfen: Schlüssel verwenden den Trenner = (nicht :), keine nachgestellten Leerzeichen bei Schlüsseln, # nur für Kommentare Häufige Beschädigungen: Nicht-ASCII-Zeichen in Werten, Probleme mit Zeilenenden (CRLF vs LF) Wenn nicht reparierbar: router.config löschen - router erzeugt eine Standarddatei unter Beibehaltung der Identität Zwingend beizubehaltende router.config-Einstellungen:\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false Verlorene oder ungültige router.keys erstellt eine neue router-Identität. Dies ist akzeptabel, es sei denn:\nBetrieb von floodfill (verliert floodfill-Status) Hosten von eepsites mit veröffentlichter Adresse (verliert Kontinuität) Etablierter Ruf im Netzwerk Ohne Backup ist keine Wiederherstellung möglich – neu erstellen: router.keys löschen, I2P neu starten, neue Identität wird erstellt.\nWichtiger Unterschied: router.keys (Identität) gegenüber keyData/* (Dienste). Der Verlust von router.keys ändert die router-Identität. Der Verlust von keyData/mysite-keys.dat ändert die .i2p-Adresse deiner eepsite - katastrophal, wenn die Adresse bereits veröffentlicht wurde.\nSchlüssel für eepsite/Dienst separat sichern:\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat Beschädigung von NetDb und peerProfiles:\nSymptome: Keine aktiven Peers, tunnels lassen sich nicht aufbauen, \u0026ldquo;Database corruption detected\u0026rdquo; in den Logs\nSichere Lösung (alles wird automatisch reseeded/neu aufgebaut):\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration Diese Verzeichnisse enthalten nur zwischengespeicherte Netzwerkinformationen - das Löschen erzwingt einen frischen Bootstrap, führt jedoch zu keinem Verlust kritischer Daten.\nPräventionsstrategien:\nImmer ordnungsgemäß herunterfahren: i2prouter stop verwenden oder den \u0026ldquo;Shutdown\u0026rdquo;-Button der router console - niemals zwangsweise beenden Automatisierte Backups: Wöchentlicher Cron-Job sichert ~/.i2p auf ein separates Laufwerk Überwachung der Laufwerksgesundheit: SMART-Status regelmäßig prüfen - ausfallende Laufwerke beschädigen Daten Ausreichend Speicherplatz: Mindestens 1+ GB frei halten - volle Laufwerke führen zu Datenbeschädigungen USV empfohlen: Stromausfälle während Schreibvorgängen beschädigen Dateien Versionskontrolle kritischer Konfigurationen: Ein Git-Repository für router.config, i2ptunnel.config ermöglicht Rollbacks Dateiberechtigungen sind wichtig:\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems Häufige Fehlermeldungen erklärt Die Protokollierung von I2P liefert spezifische Fehlermeldungen, die Probleme genau identifizieren. Das Verständnis dieser Meldungen beschleunigt die Fehlerbehebung.\n\u0026ldquo;No tunnels available\u0026rdquo; erscheint, wenn der router noch nicht genügend tunnels für den Betrieb aufgebaut hat. Dies ist in den ersten 5-10 Minuten nach dem Start normal. Wenn es länger als 15 Minuten anhält:\nÜberprüfen, dass Aktive Peers \u0026gt; 10 unter http://127.0.0.1:7657 Prüfen, ob die Bandbreitenzuweisung ausreichend ist (mindestens 128 KB/s) Erfolgsrate der tunnel unter http://127.0.0.1:7657/tunnels prüfen (sollte \u0026gt;40% sein) Protokolle auf Gründe für abgelehnte tunnel-Aufbauten prüfen \u0026ldquo;Clock skew detected\u0026rdquo; oder \u0026ldquo;NTCP2 disconnect code 7\u0026rdquo; bedeutet, dass die Systemzeit um mehr als 90 Sekunden vom Netzwerkkonsens abweicht. I2P erfordert ±60 Sekunden Genauigkeit. Verbindungen zu einem router, dessen Zeit abweicht, werden automatisch abgelehnt.\nSofort beheben:\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings \u0026ldquo;Build timeout\u0026rdquo; oder \u0026ldquo;Tunnel build timeout exceeded\u0026rdquo; bedeutet, dass der tunnel-Aufbau durch die peer chain (Kette von Gegenstellen) nicht innerhalb des Timeout-Fensters (typischerweise 60 Sekunden) abgeschlossen wurde. Ursachen:\nLangsame Peers: Router hat nicht reagierende Teilnehmer für einen tunnel ausgewählt Netzüberlastung: I2P-Netzwerk weist hohe Auslastung auf Unzureichende Bandbreite: Ihre Bandbreitenbegrenzungen verhindern den rechtzeitigen tunnel-Aufbau Überlasteter router: Zu viele teilnehmende tunnels verbrauchen Ressourcen Lösungen: Bandbreite erhöhen, Anzahl teilnehmender tunnels reduzieren (router.maxParticipatingTunnels unter http://127.0.0.1:7657/configadvanced), Portweiterleitung für eine bessere Peer-Auswahl aktivieren.\n\u0026ldquo;Router is shutting down\u0026rdquo; oder \u0026ldquo;Graceful shutdown in progress\u0026rdquo; erscheint während des normalen Herunterfahrens oder der Wiederherstellung nach einem Absturz. Ein geordnetes Herunterfahren kann bis zu 10 Minuten dauern, da der router tunnels schließt, Gegenstellen benachrichtigt und den Zustand speichert.\nWenn der Shutdown-Zustand länger als 11 Minuten anhält, Beendigung erzwingen:\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; weist auf die Erschöpfung des Heap-Speichers hin. Unmittelbare Lösungen:\nwrapper.config bearbeiten: wrapper.java.maxmemory=512 (oder höher) Vollständiges Herunterfahren erforderlich - ein Neustart wendet die Änderung nicht an 11 Minuten auf vollständiges Herunterfahren warten router neu starten Speicherzuweisung unter http://127.0.0.1:7657/graphs überprüfen - sollte Reserven anzeigen Verwandte Speicherfehler:\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo;: Zu viel Zeit wird mit der Garbage Collection verbracht - Heap vergrößern \u0026ldquo;Metaspace\u0026rdquo; (Speicherbereich für Java-Klassenmetadaten): Java-Klassen-Metadatenbereich erschöpft - wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M hinzufügen Windows-spezifisch: Kaspersky Antivirus begrenzt den Java-Heap auf 512MB, unabhängig von den Einstellungen in wrapper.config - deinstallieren oder I2P zu den Ausnahmen hinzufügen.\n\u0026ldquo;Connection timeout\u0026rdquo; oder \u0026ldquo;I2CP Error - port 7654\u0026rdquo;, wenn Anwendungen versuchen, sich mit dem router zu verbinden:\nÜberprüfen, ob der router läuft: http://127.0.0.1:7657 sollte antworten I2CP-Port prüfen: netstat -an | grep 7654 sollte LISTENING anzeigen Sicherstellen, dass die localhost-Firewall dies erlaubt: sudo ufw allow from 127.0.0.1 Überprüfen, ob die Anwendung den richtigen Port verwendet (I2CP=7654, SAM=7656) \u0026ldquo;Certificate validation failed\u0026rdquo; oder \u0026ldquo;RouterInfo corrupt\u0026rdquo; beim Reseed:\nHauptursachen: Uhrzeitabweichung (zuerst beheben), beschädigte netDb, ungültige Reseed-Zertifikate\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data \u0026ldquo;Database corruption detected\u0026rdquo; weist auf Datenkorruption auf Datenträger-Ebene in netDb oder peerProfiles hin:\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start Überprüfen Sie den Zustand des Datenträgers mit SMART-Tools - wiederkehrende Datenkorruption deutet auf ein ausfallendes Speichermedium hin.\nPlattformspezifische Herausforderungen Verschiedene Betriebssysteme stellen spezifische Herausforderungen bei der I2P-Bereitstellung dar, die mit Berechtigungen, Sicherheitsrichtlinien und der Systemintegration zusammenhängen.\nProbleme mit Berechtigungen und Diensten unter Linux Als Paket installiertes I2P läuft als Systembenutzer i2psvc (Debian/Ubuntu) oder i2p (andere Distributionen) und erfordert bestimmte Berechtigungen:\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config Grenzwerte für Dateideskriptoren beeinflussen, wie viele Verbindungen ein router verarbeiten kann. Standardgrenzwerte (1024) sind für router mit hoher Bandbreite unzureichend:\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p AppArmor-Konflikte, die unter Debian/Ubuntu häufig auftreten, verhindern den Start des Dienstes:\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined SELinux-Probleme unter RHEL/CentOS/Fedora:\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t Fehlerbehebung bei SystemD-Diensten:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service Störungen durch Windows-Firewall und Antivirenprogramme Windows Defender und Antivirenprodukte von Drittanbietern stufen I2P aufgrund von Mustern im Netzwerkverhalten häufig als verdächtig ein. Eine korrekte Konfiguration verhindert unnötige Blockierungen, während die Sicherheit gewahrt bleibt.\nWindows Defender Firewall konfigurieren:\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; Ersetzen Sie den Port 22648 durch Ihren tatsächlichen I2P-Port von http://127.0.0.1:7657/confignet.\nSpezifisches Problem mit Kaspersky Antivirus: Kasperskys \u0026ldquo;Application Control\u0026rdquo; begrenzt den Java-Heap unabhängig von den Einstellungen in wrapper.config auf 512MB. Dies führt zu einem OutOfMemoryError bei routers mit hoher Bandbreite.\nLösungen: 1. Fügen Sie I2P zu den Ausnahmen in Kaspersky hinzu: Einstellungen → Zusätzlich → Bedrohungen und Ausnahmen → Ausnahmen verwalten 2. Oder deinstallieren Sie Kaspersky (für den I2P‑Betrieb empfohlen)\nAllgemeine Hinweise zu Antivirensoftware von Drittanbietern:\nI2P-Installationsverzeichnis zu den Ausnahmen hinzufügen %APPDATA%\\I2P und %LOCALAPPDATA%\\I2P zu den Ausnahmen hinzufügen javaw.exe von der Verhaltensanalyse ausschließen Funktionen von \u0026ldquo;Network Attack Protection\u0026rdquo; deaktivieren, die mit I2P-Protokollen in Konflikt geraten könnten macOS Gatekeeper blockiert die Installation macOS Gatekeeper verhindert das Ausführen unsignierter Anwendungen. I2P-Installationsprogramme sind nicht mit einer Apple Developer ID signiert, was Sicherheitswarnungen auslöst.\nGatekeeper für das I2P-Installationsprogramm umgehen:\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file Das Starten nach der Installation kann weiterhin Warnmeldungen auslösen:\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ Gatekeeper niemals dauerhaft deaktivieren - Sicherheitsrisiko für andere Anwendungen. Verwende nur dateispezifische Umgehungen.\nKonfiguration der macOS-Firewall:\nSystemeinstellungen → Sicherheit \u0026amp; Datenschutz → Firewall → Firewall-Optionen Klicken Sie auf \u0026ldquo;+\u0026rdquo;, um ein Programm hinzuzufügen Navigieren Sie zur Java-Installation (z. B. /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java) Hinzufügen und auf \u0026ldquo;Eingehende Verbindungen erlauben\u0026rdquo; setzen Probleme mit der Android-I2P-App Beschränkungen der Android-Versionen und Ressourcenbegrenzungen bringen einzigartige Herausforderungen mit sich.\nMindestanforderungen: - Android 5.0+ (API-Level 21+) erforderlich für aktuelle Versionen - 512MB RAM mindestens, 1GB+ empfohlen - 100MB Speicher für App + router-Daten - Hintergrund-App-Einschränkungen für I2P deaktiviert\nApp stürzt sofort ab:\nAndroid-Version prüfen: Einstellungen → Über das Telefon → Android-Version (muss 5.0+ sein) Alle I2P-Versionen deinstallieren: Nur eine Variante installieren: net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\nMehrere Installationen führen zu Konflikten App-Daten löschen: Einstellungen → Apps → I2P → Speicher → Daten löschen Neu installieren aus sauberem Zustand Batterieoptimierung beendet den router:\nAndroid beendet Apps im Hintergrund aggressiv, um Akku zu sparen. I2P muss davon ausgenommen werden:\nEinstellungen → Akku → Akkuoptimierung (oder Akkunutzung der App) I2P suchen → Nicht optimieren (oder Hintergrundaktivität zulassen) Einstellungen → Apps → I2P → Akku → Hintergrundaktivität zulassen + Einschränkungen entfernen Verbindungsprobleme auf Mobilgeräten:\nBootstrap erfordert WLAN: Das initiale reseed (Erstabruf der Netzwerkdaten) lädt erhebliche Datenmengen herunter - verwenden Sie WLAN, nicht Mobilfunk Netzwerkänderungen: I2P verträgt Netzwerkwechsel nicht gut - starten Sie die App nach einem WLAN/Mobilfunk-Wechsel neu Bandbreite für Mobilgeräte: Konfigurieren Sie konservativ auf 64-128 KB/sec, um Ihr Mobilfunkdatenvolumen nicht zu erschöpfen Leistungsoptimierung für Mobilgeräte:\nI2P-App → Menü → Einstellungen → Bandbreite Geeignete Limits festlegen: 64 KB/sec eingehend, 32 KB/sec ausgehend für Mobilfunk Teilnehmende tunnels (virtuelle Datenkanäle) reduzieren: Einstellungen → Erweitert → Max. teilnehmende tunnels: 100-200 \u0026ldquo;I2P bei ausgeschaltetem Bildschirm stoppen\u0026rdquo; aktivieren, um den Akku zu schonen Torrent-Nutzung unter Android:\nAuf höchstens 2-3 gleichzeitige Torrents begrenzen DHT-Aggressivität reduzieren WiFi nur für Torrents verwenden Langsamere Geschwindigkeiten auf mobiler Hardware in Kauf nehmen Reseed- und Bootstrap-Probleme Neue I2P-Installationen erfordern Reseeding (Initialisierung der Peerliste) - das Abrufen anfänglicher Peerinformationen von öffentlichen HTTPS-Servern, um dem Netzwerk beizutreten. Reseeding-Probleme führen dazu, dass Benutzer ohne Peers und ohne Netzwerkzugang steckenbleiben.\n\u0026ldquo;Keine aktiven Peers\u0026rdquo; nach einer Neuinstallation deutet typischerweise auf einen fehlgeschlagenen Reseed (Initialbefüllung der netDb) hin. Symptome:\nBekannte Peers: 0 oder bleibt unter 5 \u0026ldquo;Network: Testing\u0026rdquo; bleibt länger als 15 Minuten bestehen Protokolle zeigen \u0026ldquo;Reseed failed\u0026rdquo; oder Verbindungsfehler zu Reseed-Servern (Bootstrap-Server für den anfänglichen netDb-Download) Warum das Reseed (Initialbefüllung der netDb) fehlschlägt:\nFirewall blockiert HTTPS: Unternehmens-/ISP-Firewalls blockieren Verbindungen zu Reseed-Servern (Port 443) SSL-Zertifikatsfehler: Dem System fehlen aktuelle Stammzertifikate Proxy erforderlich: Netzwerk erfordert einen HTTP-/SOCKS-Proxy für externe Verbindungen Uhrzeitabweichung: Die Validierung von SSL-Zertifikaten schlägt fehl, wenn die Systemzeit falsch ist Geografische Zensur: Einige Länder/ISPs blockieren bekannte Reseed-Server Manuelles Reseed (Neubezug der Router-Informationen zur Initialisierung der netDb) erzwingen:\nRufen Sie http://127.0.0.1:7657/configreseed auf Klicken Sie auf \u0026ldquo;Save changes and reseed now\u0026rdquo; Überwachen Sie http://127.0.0.1:7657/logs auf \u0026ldquo;Reseed got XX router infos\u0026rdquo; Warten Sie 5-10 Minuten, bis die Verarbeitung abgeschlossen ist Prüfen Sie http://127.0.0.1:7657 - die bekannten Peers sollten auf 50+ ansteigen Reseed-Proxy konfigurieren für restriktive Netzwerke:\nhttp://127.0.0.1:7657/configreseed → Proxy-Konfiguration:\nHTTP-Proxy: [proxy-server]:[port] Oder SOCKS5: [socks-server]:[port] Aktivieren Sie \u0026ldquo;Use proxy for reseed only\u0026rdquo; (Reseed = Neuaufbau der Peer-Liste) Anmeldedaten, falls erforderlich Speichern und Reseed erzwingen Alternative: Tor-Proxy für Reseed (initiales Laden der netDb):\nWenn der Tor Browser oder der Tor-Daemon läuft:\nProxy-Typ: SOCKS5 Host: 127.0.0.1 Port: 9050 (Standard-SOCKS-Port von Tor) Aktivieren und Reseed starten (Netzwerk-Bootstrapping) Manuelles Reseed über su3-Datei (letzter Ausweg):\nWenn alle automatischen Reseeds fehlschlagen, beschaffen Sie die Reseed-Datei out-of-band (außerhalb des regulären Kanals):\ni2pseeds.su3 von einer vertrauenswürdigen Quelle über eine uneingeschränkte Verbindung herunterladen (https://reseed.i2p.rocks/i2pseeds.su3 , https://reseed-fr.i2pd.xyz/i2pseeds.su3 ) I2P vollständig beenden i2pseeds.su3 in das Verzeichnis ~/.i2p/ kopieren I2P starten - extrahiert und verarbeitet die Datei automatisch i2pseeds.su3 nach der Verarbeitung löschen Prüfen, ob die Anzahl der Peers unter http://127.0.0.1:7657 steigt SSL-Zertifikatsfehler während des Reseeds (Erstbefüllung der netDb):\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing Lösungen:\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates Seit über 30 Minuten bei 0 bekannten Peers festhängend:\nSignalisiert ein vollständiges Scheitern des Reseed (Erstbezug der netDb-Daten zur Initialisierung des router). Reihenfolge zur Fehlerbehebung:\nSystemzeit auf Korrektheit prüfen (häufigstes Problem - ZUERST beheben) HTTPS-Konnektivität testen: Versuche, https://reseed.i2p.rocks im Browser aufzurufen - wenn das fehlschlägt, liegt ein Netzwerkproblem vor I2P-Protokolle prüfen unter http://127.0.0.1:7657/logs auf spezifische reseed-Fehler (reseed: initiales Bootstrapping, Herunterladen der netDb-Peerliste) Andere reseed-URL ausprobieren: http://127.0.0.1:7657/configreseed → benutzerdefinierte reseed-URL hinzufügen: https://reseed-fr.i2pd.xyz/ Manuelle su3-Datei-Methode verwenden, wenn automatisierte Versuche ausgeschöpft sind Reseed-Server gelegentlich offline: I2P enthält mehrere fest kodierte Reseed-Server. Wenn einer ausfällt, versucht der router automatisch andere. Ein vollständiger Ausfall aller Reseed-Server ist äußerst selten, aber möglich.\nDerzeit aktive reseed servers (Server, die neue Router beim ersten Start mit netDb-Daten versorgen) (Stand: Oktober 2025):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ Als benutzerdefinierte URLs hinzufügen, wenn es Probleme mit den Standard-URLs gibt.\nFür Nutzer in stark zensierten Regionen:\nErwägen Sie, Snowflake/Meek bridges (Tor-Bridges mittels Pluggable Transports) über Tor für das anfängliche reseed (erste netDb-Befüllung) zu verwenden und anschließend auf direktes I2P umzuschalten. Oder beziehen Sie i2pseeds.su3 per Steganographie, E-Mail oder USB von außerhalb der Zensurzone.\nWann man zusätzliche Hilfe in Anspruch nehmen sollte Dieser Leitfaden deckt die überwiegende Mehrheit der I2P-Probleme ab, aber einige Probleme erfordern die Aufmerksamkeit von Entwicklern oder die Expertise der Community.\nWenden Sie sich an die I2P-Community, wenn:\nRouter stürzt reproduzierbar ab, nachdem alle Schritte zur Fehlerbehebung befolgt wurden Speicherlecks führen zu stetigem Wachstum über den zugewiesenen Heap hinaus Tunnel-Erfolgsquote bleibt trotz angemessener Konfiguration unter 20% Neue Fehler in den Protokollen, die in diesem Leitfaden nicht abgedeckt sind Entdeckte Sicherheitslücken Funktionswünsche oder Verbesserungsvorschläge Bevor Sie Hilfe anfordern, sammeln Sie Diagnosedaten:\nI2P-Version: http://127.0.0.1:7657 (z. B., \u0026ldquo;2.10.0\u0026rdquo;) Java-Version: java -version Ausgabe Betriebssystem und Version Router-Status: Netzwerkzustand, Anzahl aktiver Peers, teilnehmende tunnels Bandbreitenkonfiguration: Eingehende/ausgehende Limits Portweiterleitungsstatus: Hinter Firewall oder OK Relevante Logauszüge: Letzte 50 Zeilen, die Fehler zeigen, von http://127.0.0.1:7657/logs Offizielle Supportkanäle:\nForum: https://i2pforum.net (clearnet, öffentliches Internet) oder http://i2pforum.i 2p (innerhalb von I2P) IRC: #i2p auf Irc2P (irc.postman.i2p über I2P) oder irc.freenode.net (clearnet) Reddit: https://reddit.com/r/i2p für Community-Diskussionen Bug-Tracker: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues für bestätigte Fehler Mailingliste: i2p-dev@lists.i2p-projekt.de für Entwicklungsfragen Realistische Erwartungen sind wichtig. I2P ist durch sein grundlegendes Design langsamer als clearnet (offenes Internet) - Multi-Hop-verschlüsselte tunnel erzeugen inhärente Latenz. Ein funktionierender I2P router mit Seitenladezeiten von 30 Sekunden und Torrent-Geschwindigkeiten von 50 KB/sec funktioniert ordnungsgemäß, ist nicht defekt. Nutzer, die clearnet-Geschwindigkeiten erwarten, werden unabhängig von jeder Optimierung der Konfiguration enttäuscht sein.\nFazit Die meisten I2P-Probleme lassen sich auf drei Kategorien zurückführen: unzureichende Geduld während der Bootstrap-Phase (10-15 Minuten erforderlich), unzureichende Ressourcenzuweisung (mindestens 512 MB RAM, 256 KB/sec Bandbreite) oder falsch konfigurierte Portweiterleitung. Das Verständnis der verteilten Architektur von I2P und seines auf Anonymität ausgerichteten Designs hilft Nutzerinnen und Nutzern, erwartetes Verhalten von tatsächlichen Problemen zu unterscheiden.\nDer \u0026ldquo;Firewalled\u0026rdquo;-Status des router ist zwar suboptimal, verhindert die Nutzung von I2P jedoch nicht - er begrenzt nur den Beitrag zum Netzwerk und verschlechtert die Leistung leicht. Neue Nutzer sollten Stabilität vor Optimierung priorisieren: Den router mehrere Tage lang ununterbrochen laufen lassen, bevor sie erweiterte Einstellungen anpassen, da sich die Integration mit zunehmender Betriebszeit von selbst verbessert.\nBei der Fehlersuche überprüfen Sie immer zuerst die Grundlagen: korrekte Systemzeit, ausreichende Bandbreite, durchgehend laufender router und 10+ aktive Peers. Die meisten Probleme lassen sich durch die Behebung dieser Grundlagen lösen, statt obskure Konfigurationsparameter anzupassen. I2P belohnt Geduld und kontinuierlichen Betrieb mit verbesserter Leistung, da der router im Laufe von Tagen und Wochen an Betriebszeit Reputation aufbaut und die Auswahl der Peers optimiert.\n","description":"Umfassender Leitfaden zur Fehlerbehebung bei häufigen Problemen mit dem I2P router, einschließlich Konnektivitäts-, Leistungs- und Konfigurationsproblemen","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"Leitfaden zur Fehlerbehebung für den I2P Router","url":"/de/docs/troubleshooting/"},{"categories":null,"content":" Veraltet: Die Ministreaming-Bibliothek entstand vor der heutigen Streaming-Bibliothek . Moderne Anwendungen müssen die vollständige Streaming-API oder SAM v3 verwenden. Die folgenden Informationen werden für Entwickler beibehalten, die den in ministreaming.jar ausgelieferten Legacy-Quellcode prüfen.\nÜberblick Ministreaming (leichtgewichtiges Streaming-Protokoll) baut auf I2CP auf, um eine zuverlässige, geordnete Zustellung über die Nachrichtenebene von I2P bereitzustellen—ähnlich wie TCP über IP. Es wurde ursprünglich aus der frühen I2PTunnel-Anwendung (BSD-lizenziert) herausgelöst, damit sich alternative Transportprotokolle unabhängig entwickeln konnten.\nWesentliche Entwurfsbeschränkungen:\nKlassischer zweiphasiger Verbindungsaufbau (SYN/ACK/FIN), aus TCP übernommen Feste Fenstergröße von 1 Paket Keine IDs pro Paket oder selektive Bestätigungen Diese Entscheidungen haben die Implementierung klein gehalten, begrenzen jedoch den Durchsatz—jedes Paket wartet normalerweise fast zwei RTTs (Round-Trip-Zeiten), bevor das nächste gesendet wird. Für lang andauernde Streams ist die Verzögerung akzeptabel, aber kurze HTTP-artige Austauschvorgänge leiden spürbar.\nBeziehung zur Streaming-Bibliothek Die aktuelle Streaming-Bibliothek verwendet weiterhin dasselbe Java-Paket (net.i2p.client.streaming). Veraltete Klassen und Methoden bleiben in den Javadocs erhalten und sind klar gekennzeichnet, damit Entwickler APIs aus der ministreaming-Ära (ältere Streaming-Bibliothek) erkennen können. Als die Streaming-Bibliothek ministreaming ablöste, fügte sie Folgendes hinzu:\nIntelligenter Verbindungsaufbau mit weniger Round-Trips Adaptive Staukontrollfenster und Wiederübertragungslogik Bessere Leistung über verlustbehaftete tunnels Wann war Ministreaming nützlich? Trotz seiner Grenzen bot ministreaming (eine minimalistische Streaming-Implementierung) in den frühesten Bereitstellungen zuverlässigen Transport. Die API war absichtlich klein und zukunftssicher gehalten, sodass alternative Streaming-Engines ausgetauscht werden konnten, ohne Änderungen an den aufrufenden Anwendungen zu erfordern. Java-Anwendungen banden sie direkt ein; Nicht-Java-Clients griffen über die SAM -Unterstützung für Streaming-Sitzungen auf dieselbe Funktionalität zu.\nAktuell ist ministreaming.jar nur als Kompatibilitätsschicht zu betrachten. Neuentwicklungen sollten:\nVerwenden Sie die vollständige Streaming-Bibliothek (Java) oder SAM v3 (STREAM-Stil) Entfernen Sie beim Modernisieren des Codes alle verbleibenden Fixed-Window-Annahmen Bevorzugen Sie größere Fenstergrößen und optimierte Verbindungs-Handshakes, um die Leistung latenzkritischer Arbeitslasten zu verbessern Referenz Dokumentation zur Streaming-Bibliothek Streaming-Javadoc – enthält veraltete Ministreaming-Klassen SAM v3-Spezifikation – Streaming-Unterstützung für Nicht-Java-Anwendungen Wenn Sie auf Code stoßen, der noch von ministreaming (veraltetes minimalistisches Streaming-Subsystem) abhängt, planen Sie, ihn auf die moderne Streaming-API zu portieren — das Netzwerk und sein Tooling erwarten das neuere Verhalten.\n","description":"Historische Anmerkungen zur ersten TCP-ähnlichen Transportschicht von I2P","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"Ministreaming-Bibliothek","url":"/de/docs/legacy/ministreaming/"},{"categories":null,"content":"I2P-Adressen sind lange kryptographische Schlüssel. Das Namenssystem bietet eine benutzerfreundlichere Ebene über diesen Schlüsseln ohne eine zentrale Autorität einzuführen. Alle Namen sind lokal—jeder Router entscheidet unabhängig, auf welches Ziel sich ein Hostname bezieht.\nBenötigen Sie Hintergrundinformationen? Die Naming-Diskussion dokumentiert die ursprünglichen Designdebatten, alternativen Vorschläge und philosophischen Grundlagen hinter der dezentralisierten Namensgebung von I2P.\n1. Komponenten Die Namensschicht von I2P besteht aus mehreren unabhängigen, aber zusammenarbeitenden Subsystemen:\nNaming Service – löst Hostnamen in Destinations auf und verarbeitet Base32-Hostnamen . HTTP-Proxy – leitet .i2p-Anfragen an den Router weiter und schlägt Jump Services vor, wenn ein Name unbekannt ist. Host-Add Services – CGI-artige Formulare, die neue Einträge in das lokale Adressbuch einfügen. Jump Services – externe Helfer, die die Destination für einen angegebenen Hostnamen zurückgeben. Adressbuch – ruft regelmäßig entfernte Host-Listen ab und führt sie unter Verwendung eines lokal vertrauenswürdigen „Web of Trust\u0026quot; zusammen. SusiDNS – eine webbasierte Benutzeroberfläche zur Verwaltung von Adressbüchern, Abonnements und lokalen Überschreibungen. Dieses modulare Design ermöglicht es Benutzern, ihre eigenen Vertrauensgrenzen zu definieren und den Benennungsprozess so weit wie gewünscht zu automatisieren.\n2. Namensdienste Die Naming-API des Routers (net.i2p.client.naming) unterstützt mehrere Backends durch die konfigurierbare Eigenschaft i2p.naming.impl=\u0026lt;class\u0026gt;. Jede Implementierung kann unterschiedliche Lookup-Strategien bieten, aber alle teilen dasselbe Vertrauens- und Auflösungsmodell.\n2.1 Hosts.txt (legacy format) Das veraltete Modell verwendete drei Klartext-Dateien, die der Reihe nach überprüft wurden:\nprivatehosts.txt userhosts.txt hosts.txt Jede Zeile speichert eine hostname=base64-destination Zuordnung. Dieses einfache Textformat wird weiterhin vollständig für Import/Export unterstützt, ist jedoch nicht mehr die Standardeinstellung, da die Leistung nachlässt, sobald die Hostliste einige tausend Einträge überschreitet.\n2.2 Blockfile Naming Service (default backend) Eingeführt in Release 0.8.8, ist der Blockfile Naming Service nun das Standard-Backend. Er ersetzt Flachdateien durch einen hochperformanten Skiplist-basierten On-Disk-Key/Value-Store (hostsdb.blockfile), der etwa 10× schnellere Lookups ermöglicht.\nWichtige Merkmale: - Speichert mehrere logische Adressbücher (privat, Benutzer und Hosts) in einer binären Datenbank. - Behält die Kompatibilität mit dem Import/Export von Legacy-hosts.txt bei. - Unterstützt Reverse-Lookups, Metadaten (Hinzufügedatum, Quelle, Kommentare) und effizientes Caching. - Verwendet die gleiche dreistufige Suchreihenfolge: privat → Benutzer → Hosts.\nDieser Ansatz bewahrt die Abwärtskompatibilität und verbessert gleichzeitig die Auflösungsgeschwindigkeit und Skalierbarkeit erheblich.\n2.1 Hosts.txt (veraltetes Format) Entwickler können benutzerdefinierte Backends implementieren, wie zum Beispiel: - Meta – aggregiert mehrere Namenssysteme. - PetName – unterstützt petnames, die in einer petnames.txt gespeichert sind. - AddressDB, Exec, Eepget und Dummy – für externe oder Fallback-Auflösung.\nDie Blockfile-Implementierung bleibt das empfohlene Backend für die allgemeine Nutzung aufgrund von Leistung und Zuverlässigkeit.\n3. Base32 Hostnames Base32-Hostnamen (*.b32.i2p) funktionieren ähnlich wie Tors .onion-Adressen. Wenn Sie eine .b32.i2p-Adresse aufrufen:\nDer Router dekodiert die Base32-Nutzlast. Er rekonstruiert das Ziel direkt aus dem Schlüssel – keine Adressbuch-Suche erforderlich. Dies garantiert die Erreichbarkeit, selbst wenn kein menschenlesbarer Hostname existiert. Erweiterte Base32-Namen, die in Release 0.9.40 eingeführt wurden, unterstützen LeaseSet2 und verschlüsselte Ziele.\n4. Address Book \u0026amp; Subscriptions Die Adressbuch-Anwendung ruft entfernte Host-Listen über HTTP ab und führt sie lokal gemäß benutzerkonfigurierter Vertrauensregeln zusammen.\n2.2 Blockfile Naming Service (Standard-Backend) Abonnements sind Standard-.i2p-URLs, die auf hosts.txt oder inkrementelle Update-Feeds verweisen. Updates werden regelmäßig abgerufen (standardmäßig stündlich) und vor dem Zusammenführen validiert. Konflikte werden nach dem Prinzip wer zuerst kommt, mahlt zuerst aufgelöst, gemäß der Prioritätsreihenfolge:\nprivatehosts.txt → userhosts.txt → hosts.txt. Default Providers Seit I2P 2.3.0 (Juni 2023) sind zwei Standard-Abonnementanbieter enthalten: - http://i2p-projekt.i2p/hosts.txt - http://notbob.i2p/hosts.txt\nDiese Redundanz verbessert die Zuverlässigkeit unter Beibehaltung des lokalen Vertrauensmodells. Benutzer können Abonnements über SusiDNS hinzufügen oder entfernen.\nIncremental Updates Inkrementelle Updates werden über newhosts.txt abgerufen (ersetzt das ältere recenthosts.cgi-Konzept). Dieser Endpunkt bietet effiziente, ETag-basierte Delta-Updates – es werden nur neue Einträge seit der letzten Anfrage zurückgegeben oder 304 Not Modified, wenn keine Änderungen vorliegen.\n2.3 Alternative Backends und Plug-ins Host-add services (add*.cgi) ermöglichen die manuelle Übermittlung von Name-zu-Destination-Zuordnungen. Überprüfen Sie immer die Destination, bevor Sie sie akzeptieren. Jump services antworten mit dem entsprechenden Schlüssel und können über den HTTP-Proxy mit einem ?i2paddresshelper=-Parameter umleiten. Häufige Beispiele: stats.i2p, identiguy.i2p und notbob.i2p. Diese Dienste sind keine vertrauenswürdigen Autoritäten—Benutzer müssen selbst entscheiden, welche sie verwenden möchten. 5. Managing Entries Locally (SusiDNS) SusiDNS ist verfügbar unter: http://127.0.0.1:7657/susidns/\nSie können: - Lokale Adressbücher ansehen und bearbeiten. - Abonnements verwalten und priorisieren. - Host-Listen importieren/exportieren. - Abrufpläne konfigurieren.\nNeu in I2P 2.8.1 (März 2025): - Funktion \u0026ldquo;Nach neuesten sortieren\u0026rdquo; hinzugefügt. - Verbesserte Abonnementverwaltung (Behebung von ETag-Inkonsistenzen).\nAlle Änderungen bleiben lokal—das Adressbuch jedes Routers ist einzigartig.\n3. Base32-Hostnamen Gemäß RFC 9476 hat I2P .i2p.alt im März 2025 (I2P 2.8.1) bei der GNUnet Assigned Numbers Authority (GANA) registriert.\nZweck: Verhinderung versehentlicher DNS-Lecks durch fehlkonfigurierte Software.\nRFC 9476-konforme DNS-Resolver werden .alt-Domains nicht weiterleiten an das öffentliche DNS. I2P-Software behandelt .i2p.alt als gleichwertig zu .i2p und entfernt das .alt-Suffix während der Auflösung. .i2p.alt ist nicht dazu gedacht, .i2p zu ersetzen; es ist eine technische Schutzmaßnahme, keine Umbenennung. 4. Adressbuch \u0026amp; Abonnements Destination keys: 516–616 Bytes (Base64) Hostnamen: Max. 67 Zeichen (inklusive .i2p) Erlaubte Zeichen: a–z, 0–9, -, . (keine doppelten Punkte, keine Großbuchstaben) Reserviert: *.b32.i2p ETag und Last-Modified: werden aktiv genutzt, um Bandbreite zu minimieren Durchschnittliche hosts.txt-Größe: ~400 KB für ~800 Hosts (Beispielwert) Bandbreitennutzung: ~10 Bytes/Sek. bei Abruf alle 12 Stunden 8. Security Model and Philosophy I2P opfert absichtlich globale Eindeutigkeit zugunsten von Dezentralisierung und Sicherheit – eine direkte Anwendung von Zooko\u0026rsquo;s Triangle.\nKernprinzipien: - Keine zentrale Autorität: alle Abfragen sind lokal. - Widerstandsfähigkeit gegen DNS-Hijacking: Abfragen sind auf öffentliche Schlüssel des Ziels verschlüsselt. - Sybil-Angriffs-Prävention: keine abstimmungs- oder konsensbasierte Namensgebung. - Unveränderliche Zuordnungen: sobald eine lokale Zuordnung existiert, kann sie nicht remote überschrieben werden.\nBlockchain-basierte Namenssysteme (z. B. Namecoin, ENS) haben versucht, alle drei Seiten von Zookos Dreieck zu lösen, aber I2P vermeidet diese bewusst aufgrund von Latenz, Komplexität und philosophischer Unvereinbarkeit mit seinem lokalen Vertrauensmodell.\n9. Compatibility and Stability Zwischen 2023–2025 wurden keine Naming-Funktionen als veraltet markiert. Das Hosts.txt-Format, Jump-Services, Abonnements und alle Naming-API-Implementierungen bleiben funktionsfähig. Das I2P-Projekt gewährleistet strikte Rückwärtskompatibilität, während Leistungs- und Sicherheitsverbesserungen eingeführt werden (NetDB-Isolation, Sub-DB-Trennung usw.). 10. Best Practices Behalten Sie nur vertrauenswürdige Abonnements; vermeiden Sie große, unbekannte Host-Listen. Sichern Sie hostsdb.blockfile und privatehosts.txt vor dem Aktualisieren oder Neuinstallieren. Überprüfen Sie regelmäßig Jump-Dienste und deaktivieren Sie diejenigen, denen Sie nicht mehr vertrauen. Denken Sie daran: Ihr Adressbuch definiert Ihre Version der I2P-Welt—jeder Hostname ist lokal. Further Reading Naming-Diskussion Blockfile-Spezifikation Konfigurationsdatei-Format Naming Service Javadoc ","description":"Wie I2P menschenlesbare Hostnamen auf Ziele abbildet","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"Namensgebung und Adressbuch","url":"/de/docs/overview/naming/"},{"categories":null,"content":" 1. Übersicht Die netDb ist eine spezialisierte verteilte Datenbank, die nur zwei Arten von Daten enthält: - RouterInfos – Router-Kontaktinformationen - LeaseSets – Destination-Kontaktinformationen\nAlle Daten sind kryptografisch signiert und verifizierbar. Jeder Eintrag enthält Liveness-Informationen (Informationen zur Betriebsbereitschaft), um veraltete Einträge zu verwerfen und überholte zu ersetzen, wodurch gegen bestimmte Angriffsarten geschützt wird.\nDie Verteilung verwendet einen floodfill-Mechanismus, bei dem eine Teilmenge der routers die verteilte Datenbank verwaltet.\n2. RouterInfo (Router-Informationen) Wenn routers andere routers kontaktieren müssen, tauschen sie RouterInfo-Bündel (Router-Informationen) aus, die Folgendes enthalten:\nRouter-Identität – Verschlüsselungsschlüssel, Signaturschlüssel, Zertifikat Kontaktadressen – wie der Router erreicht werden kann Zeitstempel der Veröffentlichung – wann diese Informationen veröffentlicht wurden Freitextoptionen – Fähigkeits-Flags und Einstellungen Kryptografische Signatur – weist die Authentizität nach 2.1 Fähigkeits-Flags Router geben ihre Fähigkeiten mittels Buchstaben-Codes in ihrer RouterInfo (Router-Informationsdatensatz) bekannt:\nFlag Meaning f Floodfill participation R Reachable U Unreachable D, E, G, H Various capability indicators ### 2.2 Klassifizierungen der Bandbreite Code Bandwidth K Under 12 KBps L 12–48 KBps (default) M 48–64 KBps N 64–128 KBps O 128–256 KBps P 256–2000 KBps X Over 2000 KBps ### 2.3 Netzwerk-ID-Werte Value Purpose 0 Reserved 1 Current Network (default) 2 Reserved for Future Networks 3–15 Forks and Test Networks 16–254 Reserved 255 Reserved ### 2.4 RouterInfo (Router-Informationen) Statistiken Routers veröffentlichen optionale Zustandsstatistiken zur Netzwerkanalyse: - Erfolgs-/Ablehnungs-/Timeout-Raten beim Aufbau von Exploratory tunnels (Erkundungs-tunnels) - 1‑Stunden-Durchschnitt der Anzahl teilnehmender tunnels\nStatistiken folgen dem Format stat_(statname).(statperiod) mit durch Semikolons getrennten Werten.\nBeispielstatistiken:\nstat_tunnel.buildExploratoryExpire.60m = 0;0;0;53.14 stat_tunnel.buildExploratoryReject.60m = 0;0;0;15.51 stat_tunnel.buildExploratorySuccess.60m = 0;0;0;31.35 stat_tunnel.participatingTunnels.60m = 289.20 Floodfill routers können außerdem veröffentlichen: netdb.knownLeaseSets und netdb.knownRouters\n2.5 Familienoptionen Seit Version 0.9.24 können routers ihre Familienzugehörigkeit (gleicher Betreiber) angeben:\nfamily: Familienname family.key: Signaturtyp-Code, verkettet mit dem Base64-kodierten öffentlichen Signaturschlüssel family.sig: Signatur über den Familiennamen und den 32-Byte router-Hash Mehrere router derselben Familie werden nicht in einem einzelnen tunnel verwendet.\n2.6 Ablauf der RouterInfo (Router-Informationen) Kein Ablauf während der ersten Stunde der Betriebszeit Kein Ablauf bei 25 oder weniger gespeicherten RouterInfos Ablaufzeit verkürzt sich mit wachsender lokaler Anzahl (72 Stunden bei \u0026lt;120 Router; ~30 Stunden bei 300 Router) SSU-Introducer (Vermittler) laufen nach ~1 Stunde ab Floodfills verwenden eine Ablaufzeit von 1 Stunde für alle lokalen RouterInfos 3. LeaseSet (veröffentlichter Datensatz mit Informationen zu Endpunkten eingehender tunnel und Schlüsseln zur Erreichbarkeit eines Ziels) LeaseSets dokumentieren die Einstiegspunkte von Tunneln für bestimmte Ziele und spezifizieren:\nTunnel-Gateway-router-Identität 4-Byte tunnel-ID Ablaufzeit für den Tunnel LeaseSets umfassen: - Destination – Verschlüsselungsschlüssel, Signaturschlüssel, Zertifikat - Zusätzlicher öffentlicher Verschlüsselungsschlüssel – für Ende-zu-Ende garlic encryption - Zusätzlicher öffentlicher Signaturschlüssel – vorgesehen für Widerruf (derzeit ungenutzt) - Kryptografische Signatur\n3.1 LeaseSet-Varianten Type Description Unpublished Destinations used only for outgoing connections aren't published to floodfill routers Revoked Published with zero leases, signed by additional signing key (not fully implemented) LeaseSet2 (LS2) As of 0.9.38, supports new encryption types, multiple encryption types, options, offline signing keys ([Proposal 123](/proposals/123-new-netdb-entries/)) Meta LeaseSet Tree-like DHT structure for multihomed services, supporting hundreds/thousands of destinations with long expirations (up to 18.2 hours) Encrypted LeaseSet (LS1) All leases encrypted with separate key; only those with the key can decode and contact the destination Encrypted LeaseSet (LS2) As of 0.9.38, destination hidden with only blinded public key and expiration visible to floodfill ### 3.2 LeaseSet-Ablaufzeit Normale LeaseSets (I2P-Datenstruktur für Erreichbarkeitsinformationen) laufen zum spätesten Ablaufzeitpunkt ihrer enthaltenen Leases ab. Die Ablaufzeit von LeaseSet2 ist im Header angegeben. Die Ablaufzeiten von EncryptedLeaseSet und MetaLeaseSet können variieren; ein Maximalwert kann erzwungen werden.\n4. Bootstrapping (Startinitialisierung) Die dezentrale netDb benötigt mindestens einen Peer-Verweis, um eingebunden zu werden. Reseeding (Initialbefüllung der netDb) ruft RouterInfo-Dateien (routerInfo-$hash.dat) aus den netDb-Verzeichnissen von Freiwilligen ab. Beim ersten Start wird automatisch von zufällig ausgewählten, hartcodierten URLs abgerufen.\n5. Floodfill-Mechanismus Die floodfill netDb verwendet eine einfache verteilte Speicherung: Man sendet Daten an den nächstgelegenen floodfill-Peer. Wenn Peers, die keine floodfills sind, Daten zur Speicherung senden, leiten floodfills sie an eine Teilmenge der floodfill-Peers weiter, die dem jeweiligen Schlüssel am nächsten liegt.\nDie floodfill-Teilnahme wird in der RouterInfo als Fähigkeits-Flag (f) angegeben.\n5.1 Anforderungen für das Floodfill-Opt-In Im Gegensatz zu Tors hartkodierten, vertrauenswürdigen Verzeichnisservern ist I2Ps floodfill-Menge nicht vertrauenswürdig und ändert sich im Laufe der Zeit.\nFloodfill wird automatisch nur auf routers mit hoher Bandbreite aktiviert, die diese Anforderungen erfüllen: - Mindestens 128 KBytes/sec freigegebene Bandbreite (manuell konfiguriert) - Zusätzliche Integritätsprüfungen müssen bestanden werden (Wartezeit der ausgehenden Nachrichtenwarteschlange, Job-Verzögerung)\nDas derzeitige automatische Opt-in führt zu ungefähr 6% floodfill-Beteiligung im Netzwerk.\nManuell konfigurierte floodfills (spezielle Router für die Verteilung der netDb) existieren parallel zu automatisch freiwillig aktivierten floodfills. Wenn die Anzahl der floodfills unter einen Schwellenwert fällt, melden sich Router mit hoher Bandbreite automatisch als floodfill. Wenn es zu viele floodfills gibt, geben sie ihren floodfill-Status wieder auf.\n5.2 Floodfill-Rollen Über das Annehmen von netDb-Speicherungen und das Beantworten von Abfragen hinaus erfüllen floodfills die üblichen Aufgaben als router. Ihre höhere Bandbreite führt typischerweise zu mehr tunnel-Teilnahme, steht jedoch nicht in direktem Zusammenhang mit den Datenbankdiensten.\n6. Kademlia-Nähemetrik Die netDb (Netzwerkdatenbank) verwendet eine XOR-basierte Kademlia-ähnliche Distanzmessung. Der SHA256-Hash von RouterIdentity oder Destination erzeugt den Kademlia-Schlüssel (ausgenommen LS2 Encrypted LeaseSets, die SHA256 über das Typ-Byte 3 plus den verblindeten öffentlichen Schlüssel verwenden).\n6.1 Rotation des Schlüsselraums Um die Kosten eines Sybil-Angriffs zu erhöhen, verwendet das System anstelle von SHA256(key):\nSHA256(key + yyyyMMdd) wobei das Datum ein 8-Byte-ASCII-UTC-Datum ist. Dadurch entsteht der Routing-Schlüssel, der sich täglich um Mitternacht UTC ändert—genannt Schlüsselraum-Rotation.\nRouting-Schlüssel werden in I2NP-Nachrichten niemals übertragen; sie werden nur zur lokalen Distanzbestimmung verwendet.\n7. Segmentierung der Netzwerkdatenbank Traditionelle Kademlia DHTs wahren die Unverkettbarkeit gespeicherter Informationen nicht. I2P verhindert Angriffe, die client tunnels mit routers in Verbindung bringen, durch die Implementierung von Segmentierung.\n7.1 Segmentierungsstrategie Routers verfolgen:\nOb Einträge über Client tunnels oder direkt eingegangen sind Falls über tunnel, welcher Client tunnel/Ziel Mehrfache Eingänge über tunnel werden nachverfolgt Antworten auf Speicherung vs. Abfrage werden unterschieden Sowohl Java- als auch C++-Implementierungen verwenden: - Eine \u0026ldquo;Main\u0026rdquo; netDb für direkte Abfragen/floodfill-Operationen im Router-Kontext - \u0026ldquo;Client-Netzwerkdatenbanken\u0026rdquo; oder \u0026ldquo;Unterdatenbanken\u0026rdquo; in Client-Kontexten, die Einträge erfassen, die an Client tunnels gesendet werden\nClient-netDbs existieren nur für die Lebensdauer des Clients und enthalten ausschließlich Client-tunnel-Einträge. Einträge aus Client-tunnels dürfen sich nicht mit direkten Eingängen überschneiden.\nJede netDb verfolgt, ob Einträge als Stores eingegangen sind (antworten auf Lookup-Anfragen) oder als Lookup-Antworten (antworten nur, wenn sie zuvor für dasselbe Ziel gespeichert wurden). Clients beantworten Anfragen niemals mit Einträgen der Main-netDb, sondern nur mit Einträgen der Client-Netzwerkdatenbank.\nKombinierte Strategien segmentieren die netDb gegen Client-router-Assoziationsangriffe.\n8. Speicherung, Überprüfung und Nachschlagen 8.1 Speicherung von RouterInfo bei Peers I2NP DatabaseStoreMessage, die den Austausch der lokalen RouterInfo (Informationen über den Router) während der Initialisierung einer NTCP- oder SSU-Transportverbindung enthält.\n8.2 Speicherung des LeaseSet (Lease-Datensatz) bei Peers I2NP DatabaseStoreMessage, die das lokale LeaseSet enthalten, werden periodisch über mit garlic encryption (Garlic‑Verschlüsselung) verschlüsselte Nachrichten ausgetauscht, die mit dem Destination-Verkehr gebündelt sind, sodass Antworten ohne LeaseSet-Abfragen möglich sind.\n8.3 Floodfill-Auswahl DatabaseStoreMessage sendet an das floodfill, das dem aktuellen Routing-Schlüssel am nächsten ist. Das nächste floodfill wird über eine lokale Datenbanksuche ermittelt. Selbst wenn es nicht tatsächlich das nächstgelegene ist, bringt Flooding (Verteilungsverfahren) es \u0026ldquo;näher\u0026rdquo;, indem an mehrere floodfills gesendet wird.\nDas traditionelle Kademlia verwendet vor dem Einfügen eine „find-closest“-Suche. Während I2NP solche Nachrichten nicht unterstützt, können router eine iterative Suche mit invertiertem niederwertigsten Bit (key ^ 0x01) durchführen, um die tatsächlich nächstgelegenen Peers zu ermitteln.\n8.4 Speicherung von RouterInfo bei Floodfills Router veröffentlichen RouterInfo, indem sie sich direkt mit einem floodfill verbinden und eine I2NP DatabaseStoreMessage mit einem Antwort-Token ungleich Null senden. Die Nachricht ist nicht Ende-zu-Ende mit garlic encryption verschlüsselt (direkte Verbindung, keine Zwischenknoten). Der floodfill antwortet mit DeliveryStatusMessage und verwendet das Antwort-Token als Message-ID.\nRouters können RouterInfo (Router-Informationsdatensatz) auch über einen exploratory tunnel (Erkundungs-Tunnel) senden (Verbindungsbeschränkungen, Inkompatibilität, IP-Verschleierung). Floodfills können solche Speicherungen bei Überlast ablehnen.\n8.5 Speicherung des LeaseSets in Floodfills Die Speicherung von LeaseSets ist sensibler als die von RouterInfo. Router müssen verhindern, dass LeaseSets mit ihnen selbst in Verbindung gebracht werden.\nRouters veröffentlichen LeaseSet über einen ausgehenden Client-tunnel mittels DatabaseStoreMessage mit einem von Null verschiedenen Reply-Token. Die Nachricht ist Ende-zu-Ende mit garlic encryption verschlüsselt, unter Verwendung des Session Key Managers der Destination (Verwaltung der Sitzungsschlüssel), sodass sie vor dem ausgehenden Endpunkt des tunnel verborgen bleibt. Floodfill antwortet mit einer DeliveryStatusMessage, die über einen eingehenden tunnel zurückgegeben wird.\n8.6 Flooding-Prozess Floodfills validieren RouterInfo/LeaseSet, bevor sie diese lokal speichern, anhand adaptiver Kriterien, die von der Auslastung, der netdb-Größe und anderen Faktoren abhängen.\nNach dem Empfang gültiger, neuerer Daten „fluten“ floodfills diese, indem sie die 3 floodfill router ermitteln, die dem Routing-Schlüssel am nächsten sind. Direkte Verbindungen senden eine I2NP DatabaseStoreMessage mit einem Antwort-Token von Null. Andere router antworten nicht oder fluten nicht erneut.\nWichtige Einschränkungen: - Floodfills dürfen nicht über tunnels fluten; nur direkte Verbindungen - Floodfills fluten niemals abgelaufenes LeaseSet oder RouterInfo, das vor über einer Stunde veröffentlicht wurde\n8.7 RouterInfo- und LeaseSet-Abfrage I2NP DatabaseLookupMessage fordert netdb-Einträge von floodfill routers an. Abfragen werden über einen ausgehenden exploratory tunnel (Erkundungstunnel) gesendet; Antworten geben den Rückweg über einen eingehenden exploratory tunnel an.\nAbfragen werden in der Regel parallel an zwei \u0026ldquo;gute\u0026rdquo; floodfill routers gesendet, die dem angeforderten Schlüssel am nächsten sind.\nLokaler Treffer: empfängt eine I2NP DatabaseStoreMessage-Antwort Kein lokaler Treffer: empfängt eine I2NP DatabaseSearchReplyMessage mit Verweisen auf andere floodfill router, die dem Schlüssel nahe sind LeaseSet-Abfragen verwenden Ende-zu-Ende garlic encryption (seit 0.9.5). Abfragen von RouterInfo (I2P-Datenobjekt mit Router-Informationen) sind aufgrund des Rechenaufwands von ElGamal nicht verschlüsselt, wodurch sie anfällig für das Ausspähen des ausgehenden Endpunkts sind.\nAb Version 0.9.7 enthalten Lookup-Antworten einen Sitzungsschlüssel und ein Tag, sodass Antworten vor dem Eingangs-Gateway verborgen bleiben.\n8.8 Iterative Abfragen Vor 0.8.9: Zwei parallele redundante Abfragen ohne rekursives oder iteratives Routing.\nSeit 0.8.9: Iterative Suchvorgänge ohne Redundanz implementiert — effizienter, zuverlässiger und geeignet für unvollständige Kenntnisse über floodfills. Wenn Netzwerke wachsen und routers weniger floodfills kennen, nähern sich die Suchvorgänge einer O(log n)-Komplexität an.\nIterative Abfragen werden auch ohne Verweise auf nähere Peers fortgesetzt und verhindern so böswilliges Black-holing (absichtliches Verschlucken von Anfragen). Die aktuellen Obergrenzen für die Anzahl der Abfragen und das Timeout gelten weiterhin.\n8.9 Verifizierung RouterInfo (Router-Informationen) Verifizierung: Seit Version 0.9.7.1 deaktiviert, um die in dem Paper \u0026ldquo;Practical Attacks Against the I2P Network\u0026rdquo; beschriebenen Angriffe zu verhindern.\nLeaseSet-Verifizierung: Router warten ~10 Sekunden und führen dann ein Lookup bei einem anderen floodfill über einen outbound client tunnel durch. Ende-zu-Ende garlic encryption verbirgt dies vor dem outbound-Endpunkt. Antworten kommen über inbound tunnels zurück.\nSeit 0.9.7 werden Antworten so verschlüsselt, dass session key/tag hiding (Verbergen von Sitzungsschlüssel/-Tags) gegenüber dem Inbound-Gateway gewährleistet ist.\n8.10 Erkundung Erkundung umfasst einen netdb-Lookup mit zufälligen Schlüsseln, um neue router kennenzulernen. Floodfills antworten mit einer DatabaseSearchReplyMessage, die nicht-floodfill-router-Hashes enthält, die dem angeforderten Schlüssel nahe sind. Explorationsanfragen setzen ein spezielles Flag in DatabaseLookupMessage.\n9. Multihoming Destinations (I2P-Zielidentitäten), die identische private/öffentliche Schlüssel (im traditionellen eepPriv.dat) verwenden, können gleichzeitig auf mehreren router gehostet werden. Jede Instanz veröffentlicht regelmäßig signierte LeaseSets; das zuletzt veröffentlichte LeaseSet wird den Anfragenden zurückgegeben. Mit einer maximalen LeaseSet-Lebensdauer von 10 Minuten dauern Ausfälle höchstens ~10 Minuten.\nSeit 0.9.38 unterstützen Meta LeaseSets große, multihomed Dienste, bei denen separate Destinations (I2P-Zieladressen) gemeinsame Dienste bereitstellen. Meta LeaseSet-Einträge sind Destinations oder andere Meta LeaseSets mit Ablaufzeiten von bis zu 18,2 Stunden und ermöglichen Hunderte/Tausende von Destinations, die gemeinsame Dienste hosten.\n10. Bedrohungsanalyse Etwa 1700 floodfill routers sind derzeit in Betrieb. Netzwerkwachstum macht die meisten Angriffe schwieriger oder weniger wirkungsvoll.\n10.1 Allgemeine Gegenmaßnahmen Wachstum: Mehr floodfills (spezielle router zum Verteilen der netDb) machen Angriffe schwieriger oder weniger wirksam Redundanz: Alle netDb-Einträge (verteilte I2P-Netzdatenbank) werden durch Flooding auf den 3 floodfill routers gespeichert, die dem Schlüssel am nächsten sind Signaturen: Alle Einträge sind vom Ersteller signiert; Fälschungen sind unmöglich 10.2 Langsame oder nicht reagierende Router Routers pflegen erweiterte Peer-Profil-Statistiken für floodfills: - Durchschnittliche Antwortzeit - Prozentsatz der beantworteten Anfragen - Prozentsatz erfolgreicher Store-Verifizierungen - Letzter erfolgreicher Store - Letztes erfolgreiches Lookup - Letzte Antwort\nRouters verwenden diese Metriken bei der Bestimmung der „Güte“ zur Auswahl des nächsten floodfill. Vollständig nicht reagierende routers werden schnell identifiziert und gemieden; teilweise böswillige routers stellen eine größere Herausforderung dar.\n10.3 Sybil-Angriff (vollständiger Schlüsselraum) Angreifer könnten zahlreiche floodfill routers über den gesamten Schlüsselraum verteilt einrichten, als einen effektiven DOS-Angriff.\nWenn das Fehlverhalten nicht ausreicht für eine Einstufung als \u0026ldquo;bad\u0026rdquo;, sind mögliche Reaktionen: - Erstellung von \u0026ldquo;bad\u0026rdquo; router-Hash/IP-Listen, angekündigt über Konsolen-News, Website, Forum - Netzwerkweite Aktivierung von floodfill (\u0026ldquo;Sybil mit mehr Sybil bekämpfen\u0026rdquo;) - Neue Softwareversionen mit hart kodierten \u0026ldquo;bad\u0026rdquo;-Listen - Verbesserte Metriken und Schwellenwerte für Peer-Profile zur automatischen Identifizierung - IP-Block-Qualifikation, die mehrere floodfills innerhalb eines einzelnen IP-Blocks disqualifiziert - Automatische abonnementsbasierte Blacklist (ähnlich dem Tor-Konsens)\nGrößere Netzwerke erschweren dies.\n10.4 Sybil-Angriff (partieller Schlüsselraum) Angreifer könnten 8–15 floodfill routers eng beieinander im Schlüsselraum platzieren. Alle Nachschlage- und Speichervorgänge für diesen Schlüsselraum werden zu den router des Angreifers geleitet, wodurch DoS (Dienstverweigerung) gegen bestimmte I2P‑Sites ermöglicht wird.\nDa der Schlüsselraum kryptografische SHA256-Hashes indiziert, müssen Angreifer Brute-Force einsetzen, um routers mit ausreichender Nähe im Schlüsselraum zu erzeugen.\nVerteidigung: Der Kademlia-Algorithmus zur Nähebestimmung variiert im Zeitverlauf mithilfe von SHA256(key + YYYYMMDD) und ändert sich täglich um Mitternacht (UTC). Diese Schlüsselraumrotation erzwingt eine tägliche Neugenerierung des Angriffs.\nHinweis: Jüngste Forschung zeigt, dass die Rotation des Schlüsselraums nicht besonders wirksam ist—Angreifer können router-Hashes vorberechnen und benötigen dann nur einige router, um Teilbereiche des Schlüsselraums innerhalb einer halben Stunde nach der Rotation zu kontrollieren.\nFolge der täglichen Rotation: die verteilte netdb wird für einige Minuten nach der Rotation unzuverlässig—Abfragen schlagen fehl, bevor der neue nächstgelegene router Stores (Store-Nachrichten) erhält.\n10.5 Bootstrap-Angriffe Angreifer könnten Reseed-Websites (Websites zum Erstbezug von Netzwerkdaten) übernehmen oder Entwickler dazu verleiten, bösartige Reseed-Websites hinzuzufügen, sodass neue Router in isolierte/mehrheitskontrollierte Netzwerke booten.\nImplementierte Schutzmaßnahmen: - Abruf von RouterInfo-Teilmengen von mehreren reseed-Sites (Bootstrap des I2P-Netzes) anstatt einer einzelnen Site - Netzwerkexternes reseed-Monitoring, das Sites periodisch abfragt - Seit 0.9.14 werden reseed-Datenpakete als signierte zip-Dateien bereitgestellt, mit Verifizierung der heruntergeladenen Signatur (siehe su3 specification )\n10.6 Abfrageerfassung Floodfill routers könnten Peers über zurückgegebene Referenzen zu von Angreifern kontrollierten routers \u0026ldquo;lenken\u0026rdquo;.\nEs ist aufgrund der geringen Häufigkeit durch Erkundung unwahrscheinlich; router erhalten Peer-Referenzen hauptsächlich über den normalen tunnel-Aufbau.\nSeit 0.8.9 sind iterative Lookups implementiert. floodfill-Referenzen in DatabaseSearchReplyMessage werden verfolgt, wenn sie dem Lookup-Schlüssel näher sind. Anfragende router vertrauen der Referenznähe nicht. Lookups werden trotz fehlender näherer Schlüssel bis zum Timeout bzw. bis zum Erreichen der maximalen Anzahl von Abfragen fortgesetzt, wodurch böswilliges Black-Holing (absichtliches Versenken von Anfragen ohne Antwort) verhindert wird.\n10.7 Informationslecks DHT-Informationslecks (verteilte Hashtabelle) in I2P erfordern weitere Untersuchungen. Floodfill routers beobachten Anfragen und sammeln dabei Informationen. Bei einem Anteil bösartiger Knoten von 20 % werden die zuvor beschriebenen Sybil-Angriffe aus mehreren Gründen problematisch.\n11. Zukünftige Arbeiten Ende-zu-Ende-Verschlüsselung zusätzlicher netDb-Abfragen und -Antworten Bessere Methoden zur Nachverfolgung von Lookup-Antworten Methoden zur Abmilderung von Zuverlässigkeitsproblemen bei der Schlüsselraum-Rotation 12. Referenzen Spezifikation allgemeiner Strukturen – RouterInfo- und LeaseSet-Strukturen I2NP-Spezifikation – Typen von Datenbanknachrichten Vorschlag 123: Neue netDb-Einträge – LeaseSet2-Spezifikation Historische netDb-Diskussion – Entwicklungsgeschichte und archivierte Diskussionen ","description":"I2Ps verteilte Netzwerkdatenbank (netDb) verstehen - eine spezialisierte DHT für router-Kontaktinformationen und Destination-Abfragen","id":"ef0a5e8bee4372a50a7f4562af717b0c","section":"docs","title":"Netzwerkdatenbank","url":"/de/docs/overview/network-database/"},{"categories":null,"content":"NTCP vs. SSU Diskussion (März 2007) Fragen zu NTCP Basierend auf einem IRC-Gespräch zwischen zzz und cervantes.\nWarum hat NTCP Vorrang vor SSU, wenn NTCP offenbar zusätzlichen Overhead und Latenz verursacht?\nNTCP bietet im Allgemeinen eine bessere Zuverlässigkeit als die ursprüngliche SSU-Implementierung. Führt Streaming über NTCP zum klassischen TCP-over-TCP-Zusammenbruch?\nMöglicherweise, aber SSU war als leichtgewichtige UDP-Option gedacht und erwies sich in der Praxis als zu unzuverlässig. “NTCP gilt als schädlich” (zzz, 25. März 2007) Zusammenfassung: Die höhere Latenz und der Overhead von NTCP können zu Überlastung führen, dennoch bevorzugt das Routing NTCP, weil dessen Gebotspunkte (bid scores) hartcodiert niedriger sind als die von SSU. Die Analyse brachte mehrere Punkte zur Sprache:\nVorschläge aus dem Thread von 2007 Transportprioritäten umstellen, damit Router SSU bevorzugen (Wiederherstellung von i2np.udp.alwaysPreferred). Streaming-Verkehr markieren, sodass SSU nur für markierte Nachrichten niedriger bietet, ohne die Anonymität zu beeinträchtigen. Grenzen für SSU-Wiederübertragungen verschärfen, um das Risiko eines Zusammenbruchs zu verringern. Teilzuverlässige Underlay-Netze untersuchen, um festzustellen, ob Wiederübertragungen unterhalb der Streaming-Bibliothek ein Netto-Vorteil sind. Prioritätswarteschlangen und Timeouts überprüfen—zum Beispiel die Streaming-Timeouts auf über 45 s erhöhen, um sie an NTCP anzugleichen. Antwort von jrandom (27. März 2007) Wesentliche Gegenargumente:\nNTCP existiert, weil frühe SSU-Bereitstellungen unter Staukollaps litten. Selbst moderate Wiederübertragungsraten pro Hop können sich über tunnels mit mehreren Hops explosionsartig vervielfachen. Ohne Bestätigungen auf tunnel-Ebene erhält nur ein Teil der Nachrichten einen Ende-zu-Ende-Zustellstatus; Ausfälle können unbemerkt bleiben. Die TCP-Staukontrolle wurde über Jahrzehnte optimiert; NTCP nutzt dies über ausgereifte TCP-Stacks. Beobachtete Effizienzgewinne bei Bevorzugung von SSU könnten eher das Warteschlangenverhalten im router widerspiegeln als intrinsische Protokollvorteile. Größere Streaming-Timeouts verbesserten die Stabilität bereits; mehr Beobachtung und Daten wurden empfohlen, bevor größere Änderungen vorgenommen werden. Die Debatte trug dazu bei, die nachfolgende Transportabstimmung zu verfeinern, spiegelt jedoch nicht die moderne NTCP2/SSU2-Architektur wider.\n","description":"Historische Anmerkungen zum Vergleich der NTCP- und SSU-Transportprotokolle sowie vorgeschlagene Optimierungsideen","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"NTCP-Diskussion","url":"/de/docs/ntcp/"},{"categories":null,"content":"Übersicht NTCP2 ersetzt den veralteten NTCP-Transport durch einen auf dem Noise-Protokoll basierenden Handshake, der gegen Traffic-Fingerprinting resistent ist, Längenfelder verschlüsselt und moderne Cipher-Suites unterstützt. Router können NTCP2 parallel zu SSU2 als die beiden obligatorischen Transportprotokolle im I2P-Netzwerk betreiben. NTCP (Version 1) wurde in 0.9.40 (Mai 2019) als veraltet markiert und in 0.9.50 (Mai 2021) vollständig entfernt.\nNoise Protocol Framework (kryptografisches Protokoll-Framework „Noise“) NTCP2 verwendet das Noise Protocol Framework Revision 33, 2017-10-04 mit I2P-spezifischen Erweiterungen:\nMuster: Noise_XK_25519_ChaChaPoly_SHA256 Erweiterter Bezeichner: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256 (für KDF-Initialisierung) DH-Funktion: X25519 (RFC 7748) - 32-Byte-Schlüssel, Little-Endian-Codierung Chiffre: AEAD_CHACHA20_POLY1305 (RFC 7539/RFC 8439) 12-Byte-Nonce: erste 4 Bytes sind Null, die letzten 8 Bytes sind ein Zähler (Little-Endian) Maximaler Nonce-Wert: 2^64 - 2 (die Verbindung muss beendet werden, bevor 2^64 - 1 erreicht wird) Hash-Funktion: SHA-256 (32-Byte-Ausgabe) MAC: Poly1305 (16-Byte-Authentifizierungstag) I2P-spezifische Erweiterungen AES-Verschleierung: Ephemere Schlüssel, mit AES-256-CBC unter Verwendung von Bobs Router-Hash und veröffentlichtem IV verschlüsselt Zufälliges Padding: Klartext-Padding in den Nachrichten 1–2 (authentifiziert), AEAD-Padding ab Nachricht 3 (verschlüsselt) SipHash-2-4-Längenverschleierung: Zweibyte-Frame-Längen werden mit der SipHash-Ausgabe XOR-verknüpft Frame-Struktur: Längenpräfixierte Frames für die Datenphase (TCP-Streaming-Kompatibilität) Blockbasierte Nutzlasten: Strukturiertes Datenformat mit typisierten Blöcken Ablauf des Handshakes Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► Drei-Nachrichten-Handshake SessionRequest - Alices verschleierter ephemerer Schlüssel, Optionen, Padding-Hinweise SessionCreated - Bobs verschleierter ephemerer Schlüssel, verschlüsselte Optionen, Padding SessionConfirmed - Alices verschlüsselter statischer Schlüssel und RouterInfo (zwei AEAD-Frames) Noise-Nachrichtenmuster XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 Authentifizierungsstufen: - 0: Keine Authentifizierung (jede Partei könnte es gesendet haben) - 2: Absenderauthentifizierung, resistent gegen key-compromise impersonation (KCI, Identitätsanmaßung bei Schlüsselkompromittierung)\nVertraulichkeitsstufen: - 1: Ephemerer Empfänger (Vorwärtsgeheimnis, keine Empfänger-Authentifizierung) - 2: Bekannter Empfänger, Vorwärtsgeheimnis nur bei Kompromittierung des Senders - 5: Starkes Vorwärtsgeheimnis (ephemeral-ephemeral + ephemeral-static DH (Diffie-Hellman))\nNachrichtenspezifikationen Schlüsselnotation RH_A = Router Hash für Alice (32 Byte, SHA-256) RH_B = Router Hash für Bob (32 Byte, SHA-256) || = Verkettungsoperator byte(n) = Einzelnes Byte mit dem Wert n Alle Mehrbyte-Ganzzahlen sind big-endian, sofern nicht anders angegeben X25519-Schlüssel sind little-endian (32 Byte) Authentifizierte Verschlüsselung (ChaCha20-Poly1305) Verschlüsselungsfunktion:\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) Parameter: - key: 32-Byte-Chiffrierschlüssel aus KDF (Schlüsselableitungsfunktion) - nonce: 12 Byte (4 Nullbytes + 8-Byte-Zähler, Little-Endian) - associatedData: 32-Byte-Hash in der Handshake-Phase; Länge 0 in der Datenphase - plaintext: Zu verschlüsselnde Daten (0+ Byte)\nAusgabe: - Geheimtext: gleiche Länge wie der Klartext - MAC: 16 Bytes (Poly1305-Authentifizierungstag)\nNonce-Verwaltung (einmalig verwendeter Wert): - Der Zähler beginnt bei 0 für jede Verschlüsselungsinstanz - Erhöht sich bei jeder AEAD-Operation in dieser Richtung - Separate Zähler für Alice→Bob und Bob→Alice in der Datenphase - Die Verbindung muss beendet werden, bevor der Zähler den Wert 2^64 - 1 erreicht\nNachricht 1: SessionRequest (Sitzungsanfrage) Alice stellt eine Verbindung zu Bob her.\nNoise-Operationen: e, es (Erzeugung und Austausch ephemerer Schlüssel)\nRohformat +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Größenbeschränkungen: - Minimum: 80 Bytes (32 AES + 48 AEAD) - Maximum: 65535 Bytes insgesamt - Sonderfall: Max. 287 Bytes beim Verbindungsaufbau zu \u0026ldquo;NTCP\u0026rdquo;-Adressen (Versionserkennung)\nEntschlüsselter Inhalt +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Optionsblock (16 Byte, Big-Endian) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 Kritische Felder: - Network ID (seit 0.9.42): Schnelle Zurückweisung netzwerkübergreifender Verbindungen - m3p2len: Exakte Größe von Nachricht 3, Teil 2 (muss beim Senden übereinstimmen)\nSchlüsselableitungsfunktion (KDF-1) Protokoll initialisieren:\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash MixHash-Operationen:\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD MixKey-Operation (es-Pattern):\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF Implementierungshinweise AES-Verschleierung: Wird nur zur DPI-Resistenz verwendet (DPI: Deep Packet Inspection, Analyse von Datenpaketen); jeder, der Bobs Router-Hash und IV (Initialisierungsvektor) besitzt, kann X entschlüsseln Replay-Schutz (Schutz vor Wiederholungsangriffen): Bob muss X-Werte (oder verschlüsselte Entsprechungen) für mindestens 2*D Sekunden zwischenspeichern (D = maximale Uhrenabweichung) Zeitstempel-Validierung: Bob muss Verbindungen mit |tsA - current_time| \u0026gt; D ablehnen (typischerweise D = 60 Sekunden) Kurvenvalidierung: Bob muss prüfen, dass X ein gültiger Punkt auf X25519 (elliptische Kurve) ist Schnelle Ablehnung: Bob darf X[31] \u0026amp; 0x80 == 0 vor der Entschlüsselung prüfen (gültige X25519-Schlüssel haben das MSB (Most Significant Bit, höchstwertiges Bit) nicht gesetzt) Fehlerbehandlung: Bei jedem Fehler schließt Bob mit TCP RST (TCP-Reset) nach einer zufälligen Wartezeit und dem Lesen einer zufälligen Anzahl von Bytes Pufferung: Alice muss die gesamte Nachricht (einschließlich Padding (Auffüllung)) aus Effizienzgründen in einem Stück übertragen Nachricht 2: SessionCreated (Sitzung erstellt) Bob antwortet Alice.\nNoise-Operationen: e, ee (ephemeral-ephemeral DH, Diffie-Hellman zwischen zwei ephemeren (kurzlebigen) Schlüsseln)\nRohformat +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Entschlüsselter Inhalt +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Optionsblock (16 Bytes, big-endian (höherwertiges Byte zuerst)) +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) Schlüsselableitungsfunktion (KDF-2) MixHash-Operationen:\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD MixKey-Operation (ee pattern, ee-Muster):\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF Speicherbereinigung:\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side Implementierungshinweise AES-Verkettung: Die Verschlüsselung von Y verwendet den AES-CBC-Zustand aus Nachricht 1 (nicht zurückgesetzt) Schutz vor Wiederholungsangriffen: Alice muss Y-Werte mindestens 2*D Sekunden zwischenspeichern Zeitstempelprüfung: Alice muss |tsB - current_time| \u0026gt; D zurückweisen Kurvenvalidierung: Alice muss prüfen, dass Y ein gültiger X25519-Punkt ist Fehlerbehandlung: Alice schließt bei jedem Fehler mit TCP RST Pufferung: Bob muss die gesamte Nachricht auf einmal senden Nachricht 3: SessionConfirmed (Sitzung bestätigt) Alice bestätigt die Sitzung und sendet die RouterInfo.\nNoise-Operationen: s, se (Offenlegung des statischen Schlüssels und statisch-ephemerer Diffie-Hellman (DH))\nZweiteilige Struktur Nachricht 3 besteht aus zwei separaten AEAD frames (AEAD, authentifizierte Verschlüsselung mit zusätzlichen Daten):\nTeil 1: Fester 48-Byte-Frame mit Alices verschlüsseltem statischen Schlüssel Teil 2: Frame variabler Länge mit RouterInfo, Optionen und Padding Rohformat +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Größenbeschränkungen: - Teil 1: Genau 48 Bytes (32 Klartext + 16 MAC) - Teil 2: Länge, in Nachricht 1 festgelegt (Feld m3p2len) - Maximalgröße insgesamt: 65535 Bytes (Teil 1 max 48, daher Teil 2 max 65487)\nEntschlüsselter Inhalt Teil 1:\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ Teil 2:\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ Schlüsselableitungsfunktion (KDF-3) Teil 1 (s-Muster):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 Teil 2 (siehe Muster):\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF Speicherbereinigung:\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side Hinweise zur Implementierung RouterInfo-Validierung: Bob muss Signatur, Zeitstempel und Schlüsselkonsistenz prüfen Schlüsselabgleich: Bob muss prüfen, dass Alices statischer Schlüssel in Teil 1 mit dem Schlüssel in der RouterInfo übereinstimmt Position des statischen Schlüssels: In der NTCP oder NTCP2 RouterAddress nach einem passenden \u0026ldquo;s\u0026rdquo;-Parameter suchen Blockreihenfolge: RouterInfo muss zuerst kommen, Options als Zweites (falls vorhanden), Padding zuletzt (falls vorhanden) Längenplanung: Alice muss sicherstellen, dass m3p2len in Nachricht 1 exakt der Länge von Teil 2 entspricht Pufferung: Alice muss beide Teile zusammen als einen einzigen TCP-Sendevorgang absetzen Optionale Verkettung: Alice kann aus Effizienzgründen unmittelbar einen data phase frame (Frame der Datenphase) anhängen Datenphase Nach Abschluss des Handshakes verwenden alle Nachrichten AEAD-Frames variabler Länge mit verschleierten Längenfeldern.\nSchlüsselableitungsfunktion (Datenphase) Split-Funktion (Noise):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) SipHash-Schlüsselableitung:\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV Rahmenstruktur +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ Frame-Beschränkungen: - Minimum: 18 Bytes (2 verschleierte Länge + 0 Klartext + 16 MAC) - Maximum: 65537 Bytes (2 verschleierte Länge + 65535 Frame) - Empfohlen: Wenige KB pro Frame (Empfängerlatenz minimieren)\nSipHash-Längenverschleierung Zweck: Verhindern, dass DPI (tiefgehende Paketinspektion) die Frame-Grenzen erkennt\nAlgorithmus:\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes Dekodierung:\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) Hinweise: - Getrennte IV-Ketten für jede Richtung (Alice→Bob und Bob→Alice) - Wenn SipHash uint64 zurückgibt, die beiden niederwertigsten Bytes als Maske verwenden - uint64 als Little-Endian-Bytes in den nächsten IV umwandeln\nBlockformat Jeder Frame enthält null oder mehr Blöcke:\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload Größenlimits: - Maximaler Frame: 65535 Bytes (einschließlich MAC) - Maximaler Blockbereich: 65519 Bytes (Frame - 16-Byte-MAC) - Maximaler Einzelblock: 65519 Bytes (3-Byte-Header + 65516 Daten)\nBlocktypen Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions **Regeln zur Blockreihenfolge:** - **Nachricht 3, Teil 2**: RouterInfo, Optionen (optional), Padding (Auffüllung; optional) - KEINE anderen Typen - **Datenphase**: Beliebige Reihenfolge, außer: - Padding MUSS der letzte Block sein, falls vorhanden - Termination (Beendigung) MUSS der letzte Block sein (außer Padding), falls vorhanden - Mehrere I2NP-Blöcke pro Frame erlaubt - Mehrere Padding-Blöcke pro Frame NICHT erlaubt Blocktyp 0: Datum/Uhrzeit Zeitsynchronisierung zur Erkennung von Uhrzeitabweichungen.\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) Implementierung: Zur nächstgelegenen Sekunde runden, um die Akkumulation von Uhrversatz zu verhindern.\nBlocktyp 1: Optionen Parameter für Padding (Auffüllung) und Traffic Shaping (Datenverkehrsformung).\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) Padding-Verhältnisse (4.4-Festkommaformat, Wert/16.0): - tmin: Minimales Padding-Verhältnis beim Senden (0.0 - 15.9375) - tmax: Maximales Padding-Verhältnis beim Senden (0.0 - 15.9375) - rmin: Minimales Padding-Verhältnis beim Empfangen (0.0 - 15.9375) - rmax: Maximales Padding-Verhältnis beim Empfangen (0.0 - 15.9375)\nBeispiele: - 0x00 = 0% Padding - 0x01 = 6,25% Padding - 0x10 = 100% Padding (1:1-Verhältnis) - 0x80 = 800% Padding (8:1-Verhältnis)\nDummy-Datenverkehr: - tdmy: Maximal bereit zu senden (2 Bytes, Durchschnitt in Bytes/Sekunde) - rdmy: Angeforderter Empfang (2 Bytes, Durchschnitt in Bytes/Sekunde)\nEinfügen von Verzögerungen: - tdelay: Maximal einzufügende Verzögerung (2 Bytes, Durchschnitt in Millisekunden) - rdelay: Angeforderte Verzögerung (2 Bytes, Durchschnitt in Millisekunden)\nLeitlinien: - Min-Werte geben die angestrebte Widerstandsfähigkeit gegen Traffic-Analyse an - Max-Werte geben Bandbreitenbeschränkungen an - Der Sender sollte das Maximum des Empfängers einhalten - Der Sender kann das Minimum des Empfängers innerhalb der Beschränkungen berücksichtigen - Kein Durchsetzungsmechanismus; Implementierungen können variieren\nBlocktyp 2: RouterInfo RouterInfo-Übermittlung zur netdb-Befüllung und zum Flooding (flutartige Verteilung).\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 Verwendung:\nIn Nachricht 3 Teil 2 (Handshake): - Alice sendet ihre RouterInfo (Router-Informationsobjekt) an Bob - Flood bit (Steuerbit für Weiterverteilung) typischerweise 0 (lokale Speicherung) - RouterInfo NICHT gzip-komprimiert\nIn der Datenphase: - Jede Seite darf ihre aktualisierte RouterInfo (Router-Informationen) senden - Flood bit = 1: Anforderung der floodfill-Verteilung (wenn der Empfänger floodfill ist) - Flood bit = 0: Nur lokale netdb-Speicherung\nValidierungsanforderungen: 1. Prüfen, ob der Signaturtyp unterstützt wird 2. RouterInfo-Signatur prüfen 3. Prüfen, ob der Zeitstempel innerhalb akzeptabler Grenzen liegt 4. Für den Handshake: Prüfen, ob der statische Schlüssel dem NTCP2-Adressparameter \u0026ldquo;s\u0026rdquo; entspricht 5. Für die Datenphase: Prüfen, ob der router-Hash zum Sitzungspartner passt 6. Nur RouterInfos mit veröffentlichten Adressen weiterverbreiten\nHinweise: - Kein ACK-Mechanismus (verwenden Sie I2NP DatabaseStore mit reply token (Antwort-Token), falls nötig) - Kann RouterInfos Dritter enthalten (floodfill-Nutzung) - NICHT gzip-komprimiert (im Gegensatz zu I2NP DatabaseStore)\nBlocktyp 3: I2NP-Nachricht I2NP-Nachricht mit verkürztem 9-Byte-Header.\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) Unterschiede gegenüber NTCP1: - Ablaufzeit: 4 Bytes (Sekunden) vs 8 Bytes (Millisekunden) - Länge: weggelassen (aus der Blocklänge ableitbar) - Prüfsumme: weggelassen (AEAD bietet Integrität) - Header: 9 Bytes vs 16 Bytes (44% Reduktion)\nFragmentierung: - I2NP-Nachrichten DÜRFEN NICHT über Blöcke hinweg fragmentiert werden - I2NP-Nachrichten DÜRFEN NICHT über Frames hinweg fragmentiert werden - Mehrere I2NP-Blöcke pro Frame sind zulässig\nBlocktyp 4: Beendigung Explizites Schließen der Verbindung mit Beendigungsgrundcode.\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) Begründungscodes:\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny **Regeln:** - Die Terminierung MUSS der letzte Nicht-Padding-Block im Frame sein - Maximal ein Terminierungsblock pro Frame - Der Sender sollte die Verbindung nach dem Senden schließen - Der Empfänger sollte die Verbindung nach dem Empfangen schließen Fehlerbehandlung: - Handshake-Fehler: In der Regel mit TCP RST schließen (kein Termination-Block) - AEAD-Fehler in der Datenphase: Zufälliges Timeout + zufälliges Lesen, dann Termination (Beendigung) senden - Siehe Abschnitt \u0026ldquo;AEAD Error Handling\u0026rdquo; für Sicherheitsverfahren\nBlocktyp 254: Auffüllung Zufälliges Padding zur Erhöhung der Widerstandsfähigkeit gegen Verkehrsanalyse.\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes Regeln: - Padding MUSS der letzte Block im Frame sein, falls vorhanden - Padding mit Länge Null ist zulässig - Pro Frame ist nur ein Padding-Block zulässig - Nur aus Padding bestehende Frames sind zulässig - Sollte den ausgehandelten Parametern aus dem Options-Block entsprechen\nPadding in den Nachrichten 1-2: - Außerhalb des AEAD (Authentifizierte Verschlüsselung mit zusätzlichen Daten)-Rahmens (Klartext) - In die Hash-Kette der nächsten Nachricht einbezogen (authentifiziert) - Manipulation wird erkannt, wenn die AEAD der nächsten Nachricht fehlschlägt\nPadding in Nachricht 3+ und Datenphase: - Innerhalb des AEAD-Frames (verschlüsselt und authentifiziert) - Wird für Traffic Shaping und Größenverschleierung verwendet\nAEAD-Fehlerbehandlung Kritische Sicherheitsanforderungen:\nHandshake-Phase (Nachrichten 1-3) Bekannte Nachrichtengröße: - Nachrichtengrößen sind vorgegeben oder im Voraus spezifiziert - AEAD-Authentifizierungsfehler ist eindeutig\nBobs Reaktion auf Fehler bei Nachricht 1: 1. Zufälliges Timeout setzen (Bereich implementierungsabhängig, Vorschlag: 100-500ms) 2. Zufällige Anzahl von Bytes lesen (Bereich implementierungsabhängig, Vorschlag: 1KB-64KB) 3. Verbindung mit TCP RST schließen (keine Antwort) 4. Quell-IP vorübergehend sperren 5. Wiederholte Fehlschläge nachverfolgen, um langfristige Sperren zu verhängen\nAlices Reaktion auf Fehler bei Nachricht 2: 1. Verbindung sofort mit TCP RST schließen 2. Keine Antwort an Bob\nBobs Reaktion auf den Fehler bei Nachricht 3: 1. Verbindung sofort mit TCP RST schließen 2. Keine Antwort an Alice\nDatenphase Verschleierte Nachrichtengröße: - Das Längenfeld ist durch SipHash (Hash-Funktion) verschleiert - Ungültige Länge oder AEAD (authentifizierte Verschlüsselung mit assoziierten Daten)-Fehler könnte darauf hindeuten: - Sondierung durch einen Angreifer - Beschädigung im Netzwerk - Desynchronisierter SipHash-IV (Initialisierungsvektor) - Böswillige Gegenstelle\nAntwort auf AEAD- oder Längenfehler: 1. Zufälliges Timeout setzen (empfohlen 100-500ms) 2. Zufällige Anzahl von Bytes lesen (empfohlen 1KB-64KB) 3. Beendigungsblock mit Reason-Code 4 (AEAD-Fehler) oder 9 (Framing-Fehler) senden 4. Verbindung schließen\nVermeidung von Entschlüsselungsorakeln: - Den Fehlertyp der Gegenstelle niemals vor Ablauf einer zufälligen Wartezeit offenlegen - Niemals auf die Längenvalidierung vor der AEAD-Prüfung verzichten - Ungültige Länge genauso behandeln wie einen AEAD-Fehler - Für beide Fehler denselben Fehlerbehandlungspfad verwenden\nÜberlegungen zur Implementierung: - Einige Implementierungen können nach Fehlern bei AEAD (authentifizierte Verschlüsselung mit zugehörigen Daten) fortfahren, sofern sie selten auftreten - Nach wiederholten Fehlern beenden (empfohlener Schwellenwert: 3–5 Fehler pro Stunde) - Abwägung zwischen Fehlerwiederherstellung und Sicherheit\nVeröffentlichte RouterInfo Format der Router-Adresse Die NTCP2-Unterstützung wird über veröffentlichte RouterAddress-Einträge mit bestimmten Optionen bekanntgegeben.\nTransportstil: - \u0026quot;NTCP2\u0026quot; - NTCP2 nur auf diesem Port - \u0026quot;NTCP\u0026quot; - Sowohl NTCP als auch NTCP2 auf diesem Port (automatische Erkennung) - Hinweis: Unterstützung für NTCP (v1) wurde in 0.9.50 entfernt (Mai 2021) - \u0026ldquo;NTCP\u0026rdquo;-Stil ist jetzt veraltet; verwenden Sie \u0026ldquo;NTCP2\u0026rdquo;\nErforderliche Optionen Alle veröffentlichten NTCP2-Adressen:\nhost - IP-Adresse (IPv4 oder IPv6) oder Hostname\nFormat: Standard-IP-Notation oder Domainname Kann bei nur ausgehenden oder versteckten routers weggelassen werden port - TCP-Portnummer\nFormat: Ganzzahl, 1-65535 Kann bei nur ausgehenden oder versteckten router weggelassen werden s - Statischer öffentlicher Schlüssel (X25519)\nFormat: Base64-kodiert, 44 Zeichen Kodierung: I2P-Base64-Alphabet Quelle: öffentlicher X25519-Schlüssel (32 Byte), Little-Endian i - Initialisierungsvektor für AES\nFormat: Base64-kodiert, 24 Zeichen Kodierung: I2P-Base64-Alphabet Quelle: 16-Byte-IV, Big-Endian v - Protokollversion\nFormat: Ganzzahl oder durch Kommas getrennte Ganzzahlen Aktuell: \u0026quot;2\u0026quot; Zukünftig: \u0026quot;2,3\u0026quot; (muss in numerischer Reihenfolge sein) Optionale Einstellungen:\ncaps - Fähigkeiten (seit 0.9.50)\nFormat: Zeichenkette aus Fähigkeitszeichen Werte: \u0026quot;4\u0026quot; - IPv4-Fähigkeit für ausgehende Verbindungen \u0026quot;6\u0026quot; - IPv6-Fähigkeit für ausgehende Verbindungen \u0026quot;46\u0026quot; - Sowohl IPv4 als auch IPv6 (empfohlene Reihenfolge) Nicht erforderlich, wenn host veröffentlicht ist Nützlich für versteckte bzw. hinter einer Firewall befindliche routers cost - Adresspriorität\nFormat: Ganzzahl, 0-255 Niedrigere Werte = höhere Priorität Empfohlen: 5-10 für normale Adressen Empfohlen: 14 für unveröffentlichte Adressen Beispielhafte RouterAddress-Einträge Veröffentlichte IPv4-Adresse:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Verborgener Router (nur ausgehend):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Dual-Stack-Router:\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Wichtige Regeln: - Mehrere NTCP2-Adressen mit demselben Port MÜSSEN identische s-, i- und v-Werte verwenden - Verschiedene Ports dürfen unterschiedliche Schlüssel verwenden - Dual-Stack routers sollten getrennte IPv4- und IPv6-Adressen veröffentlichen\nUnveröffentlichte NTCP2-Adresse Für ausschließlich ausgehende Router:\nWenn ein router keine eingehenden NTCP2-Verbindungen akzeptiert, aber ausgehende Verbindungen initiiert, MUSS er dennoch eine RouterAddress mit Folgendem veröffentlichen:\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Zweck: - Ermöglicht es Bob, Alices statischen Schlüssel während des Handshakes zu verifizieren - Erforderlich für die Verifizierung der RouterInfo in Nachricht 3, Teil 2 - Keine i, host oder port erforderlich (nur ausgehend)\nAlternative: - Füge s und v zur bereits veröffentlichten \u0026ldquo;NTCP\u0026rdquo;- oder SSU-Adresse hinzu\nRotation von öffentlichem Schlüssel und IV (Initialisierungsvektor) Kritische Sicherheitsrichtlinie:\nAllgemeine Regeln: 1. Niemals rotieren, während der router läuft 2. Schlüssel und IV (Initialisierungsvektor) dauerhaft speichern über Neustarts hinweg 3. Vorherige Ausfallzeit nachverfolgen, um festzustellen, ob eine Rotation in Frage kommt\nMindest-Ausfallzeit vor der Rotation:\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact **Zusätzliche Auslöser:** - Änderung der lokalen IP-Adresse: Kann unabhängig von Ausfallzeiten rotieren - Router \"rekey\" (new Router Hash): Neue Schlüssel erzeugen Begründung: - Verhindert das Offenlegen von Neustartzeiten durch Schlüsseländerungen - Ermöglicht, dass zwischengespeicherte RouterInfos natürlich ablaufen - Wahrung der Netzwerkstabilität - Verringert fehlgeschlagene Verbindungsversuche\nImplementierung: 1. Schlüssel, IV (Initialisierungsvektor) und Zeitstempel des letzten Herunterfahrens dauerhaft speichern 2. Beim Start die Ausfallzeit berechnen: downtime = current_time - last_shutdown 3. Wenn downtime \u0026gt; Minimum für den router-Typ, kann rotiert werden 4. Wenn sich die IP geändert hat oder eine Schlüsselerneuerung stattfindet, kann rotiert werden 5. Andernfalls den vorherigen Schlüssel und die IV wiederverwenden\nIV Rotation: - Unterliegt denselben Regeln wie die Schlüsselrotation - Nur in veröffentlichten Adressen vorhanden (nicht in versteckten routers) - Es wird empfohlen, den IV zu ändern, sobald sich der Schlüssel ändert\nVersionserkennung Kontext: Wenn transportStyle=\u0026quot;NTCP\u0026quot; (veraltet) ist, unterstützt Bob sowohl NTCP v1 als auch v2 auf demselben Port und muss die Protokollversion automatisch erkennen.\nErkennungsalgorithmus:\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 Schnelle MSB-Prüfung (höchstwertiges Bit): - Vor der AES-Entschlüsselung prüfen: encrypted_X[31] \u0026amp; 0x80 == 0 - Gültige X25519-Schlüssel haben das höchstwertige Bit nicht gesetzt - Ein Fehlschlag weist wahrscheinlich auf NTCP1 (oder einen Angriff) hin - Bei Fehlschlag Sondierungsresistenz implementieren (zufälliges Timeout + read)\nAnforderungen an die Implementierung:\nAlices Verantwortung:\nBegrenze Nachricht 1 beim Verbindungsaufbau zu einer \u0026ldquo;NTCP\u0026rdquo;-Adresse auf maximal 287 Bytes Puffere die gesamte Nachricht 1 und sende sie anschließend auf einmal Erhöht die Wahrscheinlichkeit der Zustellung in einem einzigen TCP-Paket Bobs Verantwortung:\nEmpfangene Daten puffern, bevor die Version bestimmt wird Ordnungsgemäße Timeout-Behandlung implementieren TCP_NODELAY für eine schnelle Versionserkennung verwenden Nach Erkennung der Version die gesamte Nachricht 2 auf einmal puffern und einen flush durchführen (Puffer leeren) Sicherheitsaspekte: - Segmentierungsangriffe: Bob sollte gegenüber TCP-Segmentierung robust sein - Sondierungsangriffe: Zufällige Verzögerungen und Byte-Lesevorgänge bei Fehlern implementieren - DoS-Prävention: Gleichzeitig ausstehende Verbindungen begrenzen - Lese-Timeouts: Sowohl pro Lesevorgang als auch insgesamt (\u0026ldquo;slowloris\u0026rdquo;-Schutz)\nRichtlinien zur Uhrzeitabweichung Zeitstempel-Felder: - Nachricht 1: tsA (Zeitstempel von Alice) - Nachricht 2: tsB (Zeitstempel von Bob) - Nachricht 3+: Optionale DateTime-Blöcke (Datum/Uhrzeit)\nMaximale Zeitabweichung (D): - Typisch: ±60 Sekunden - Pro Implementierung konfigurierbar - Zeitabweichung \u0026gt; D ist in der Regel fatal\nBobs Verarbeitung (Nachricht 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally Begründung: Das Senden von Nachricht 2 selbst bei Zeitabweichung ermöglicht es Alice, Probleme mit der Systemuhr zu diagnostizieren.\nAlices Verarbeitung (Nachricht 2) 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization RTT-Anpassung: - Ziehe die halbe RTT von der berechneten Uhrabweichung ab - Berücksichtigt die Ausbreitungsverzögerung im Netzwerk - Genauere Schätzung der Uhrabweichung\nBobs Verarbeitung (Nachricht 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) Zeitsynchronisierung DateTime-Blöcke (Datenphase): - DateTime-Block (Typ 0) regelmäßig senden - Empfänger kann ihn zum Uhrabgleich verwenden - Zeitstempel auf die nächste ganze Sekunde runden (Verzerrungen vermeiden)\nExterne Zeitquellen: - NTP (Network Time Protocol) - Synchronisierung der Systemuhr - konsensbasierte Zeit des I2P-Netzwerks\nStrategien zur Uhrzeitkorrektur: - Wenn die lokale Systemuhr falsch ist: Systemzeit anpassen oder einen Offset verwenden - Wenn die Uhren der Peers dauerhaft falsch sind: Peer-Problem kennzeichnen - Abweichungsstatistiken für die Überwachung der Netzwerkgesundheit nachverfolgen\nSicherheitseigenschaften Vorwärtsgeheimnis Erreicht durch: - Ephemerer Diffie-Hellman-Schlüsselaustausch (X25519) - Drei DH-Operationen: es, ee, se (Noise-XK-Muster) - Ephemere Schlüssel werden nach Abschluss des Handshakes vernichtet\nVertraulichkeitsfortschritt: - Nachricht 1: Stufe 2 (Vorwärtsgeheimnis bei Kompromittierung des Senders) - Nachricht 2: Stufe 1 (ephemerer Empfänger) - Nachricht 3+: Stufe 5 (starkes Vorwärtsgeheimnis)\nPerfect Forward Secrecy (Vorwärtsgeheimnis): - Kompromittierung langfristiger statischer Schlüssel offenbart NICHT frühere Sitzungsschlüssel - Jede Sitzung verwendet eindeutige ephemere Schlüssel - Ephemere private Schlüssel werden niemals wiederverwendet - Speicherbereinigung nach der Schlüsselaushandlung\nEinschränkungen: - Nachricht 1 ist verwundbar, wenn Bobs statischer Schlüssel kompromittiert ist (aber Vorwärtsgeheimnis bei einer Kompromittierung von Alice) - Wiederholungsangriffe auf Nachricht 1 sind möglich (abgemildert durch Zeitstempel und Replay-Cache)\nAuthentifizierung Gegenseitige Authentifizierung: - Alice wird in Nachricht 3 mittels eines statischen Schlüssels authentifiziert - Bob wird durch Besitz des statischen privaten Schlüssels authentifiziert (implizit durch einen erfolgreichen Handshake)\nKey Compromise Impersonation (KCI) Resistance (Widerstand gegen Identitätsanmaßung bei kompromittiertem Schlüssel): - Authentifizierungsstufe 2 (resistent gegen KCI) - Ein Angreifer kann sich nicht als Alice ausgeben, selbst mit Alices statischem privaten Schlüssel (ohne Alices ephemeren Schlüssel) - Ein Angreifer kann sich nicht als Bob ausgeben, selbst mit Bobs statischem privaten Schlüssel (ohne Bobs ephemeren Schlüssel)\nVerifizierung statischer Schlüssel: - Alice kennt Bobs statischen Schlüssel im Voraus (aus der RouterInfo (Router-Informationen)) - Bob verifiziert in Nachricht 3, dass Alices statischer Schlüssel mit der RouterInfo übereinstimmt - Verhindert Man-in-the-Middle-Angriffe\nWiderstand gegen Verkehrsanalyse DPI (Deep Packet Inspection)-Gegenmaßnahmen: 1. AES-Verschleierung: Ephemere Schlüssel verschlüsselt, zufälliges Erscheinungsbild 2. SipHash-Längenverschleierung: Frame-Längen nicht im Klartext 3. Zufälliges Padding (Auffüllung): Variable Nachrichtengrößen, keine festen Muster 4. Verschlüsselte Frames: Gesamte Nutzlast mit ChaCha20 verschlüsselt\nSchutz vor Replay-Angriffen: - Zeitstempelvalidierung (±60 Sekunden) - Replay-Cache für ephemere Schlüssel (Lebensdauer 2*D) - Inkremente der Nonce (Einmalwert) verhindern das Wiederholen von Paketen innerhalb einer Sitzung\nWiderstandsfähigkeit gegen Sondierungen: - Zufällige Timeouts bei AEAD (Authentifizierte Verschlüsselung mit zusätzlichen Daten)-Fehlern - Zufälliges Lesen von Bytes vor dem Schließen der Verbindung - Keine Antworten bei Handshake-Fehlern - IP-Blockliste bei wiederholten Fehlern\nRichtlinien für Padding: - Nachrichten 1-2: Klartext-Padding (authentifiziert) - Ab Nachricht 3: Verschlüsseltes Padding innerhalb von AEAD frames (Authenticated Encryption with Associated Data; authentifizierte Verschlüsselung mit zugeordneten Daten) - Ausgehandelte Padding-Parameter (Options-Block) - Nur-Padding-Frames zulässig\nAbwehr von Denial-of-Service-Angriffen Verbindungsbeschränkungen: - Maximale Anzahl aktiver Verbindungen (implementierungsabhängig) - Maximale Anzahl ausstehender Handshakes (z. B. 100-1000) - Verbindungsbeschränkungen pro IP (z. B. 3-10 gleichzeitig)\nRessourcenschutz: - DH-Operationen ratenbegrenzt (rechenaufwendig) - Lese-Timeouts pro Socket und insgesamt - \u0026ldquo;Slowloris\u0026rdquo;-Schutz (Gesamtzeitlimits) - IP-Blacklisting bei Missbrauch\nSchnelle Zurückweisung: - Netzwerk-ID stimmt nicht überein → sofortige Schließung - Ungültiger X25519-Punkt → schnelle MSB-Prüfung vor der Entschlüsselung - Zeitstempel außerhalb des zulässigen Bereichs → Schließen ohne Berechnung - AEAD-Fehler → keine Antwort, zufällige Verzögerung\nSondierungsresistenz: - Zufälliges Timeout: 100-500ms (implementierungsabhängig) - Zufälliges Lesen: 1KB-64KB (implementierungsabhängig) - Keine Fehlerinformationen an den Angreifer - Mit TCP RST schließen (kein FIN-Handshake)\nKryptografische Sicherheit Algorithmen: - X25519: 128-Bit-Sicherheit, Diffie-Hellman über elliptische Kurven (Curve25519) - ChaCha20: Stromchiffre mit 256-Bit-Schlüssel - Poly1305: informationstheoretisch sichere MAC (Message Authentication Code) - SHA-256: 128-Bit-Kollisionsresistenz, 256-Bit-Urbildresistenz - HMAC-SHA256: PRF (pseudorandom function, pseudozufällige Funktion) für die Schlüsselableitung\nSchlüsselgrößen: - Statische Schlüssel: 32 Bytes (256 Bit) - Ephemere Schlüssel: 32 Bytes (256 Bit) - Chiffrierschlüssel: 32 Bytes (256 Bit) - MAC: 16 Bytes (128 Bit)\nBekannte Probleme: - Wiederverwendung von ChaCha20-Nonces (einmalige Werte) ist katastrophal (verhindert durch Zählerinkrement) - X25519 hat Probleme mit kleinen Untergruppen (abgemildert durch Kurvenvalidierung) - SHA-256 ist theoretisch anfällig für Längenerweiterung (in HMAC nicht ausnutzbar)\nKeine bekannten Schwachstellen (Stand Oktober 2025): - Noise Protocol Framework (Kryptografie-Rahmenwerk für Handshake-Protokolle) umfassend analysiert - ChaCha20-Poly1305 (AEAD-Algorithmus) in TLS 1.3 eingesetzt - X25519 (Schlüsselaustausch auf Basis elliptischer Kurven) Standard in modernen Protokollen - Keine praktischen Angriffe auf die Konstruktion\nReferenzen Primäre Spezifikationen NTCP2-Spezifikation - Offizielle I2P-Spezifikation Vorschlag 111 - Ursprüngliches Entwurfsdokument mit Begründung Noise Protocol Framework - Revision 33 (2017-10-04) Kryptografische Standards RFC 7748 - Elliptische Kurven für Sicherheitszwecke (X25519) RFC 7539 - ChaCha20 und Poly1305 für IETF-Protokolle RFC 8439 - ChaCha20-Poly1305 (ersetzt RFC 7539) RFC 2104 - HMAC: Schlüsselbasiertes Hashing zur Nachrichtenauthentifizierung SipHash - SipHash-2-4 für Anwendungen von Hashfunktionen Verwandte I2P-Spezifikationen I2NP-Spezifikation - Nachrichtenformat des I2P-Netzwerkprotokolls Gemeinsame Strukturen - Formate von RouterInfo und RouterAddress SSU-Transport - UDP-Transport (ursprünglich, jetzt SSU2) Vorschlag 147 - Prüfung der Transport-Netzwerk-ID (0.9.42) Referenzen zur Implementierung I2P Java - Referenzimplementierung (Java) i2pd - C++-Implementierung I2P Versionshinweise - Versionsverlauf und Aktualisierungen Historischer Kontext Station-To-Station Protocol (STS) - Inspiration für das Noise-Framework obfs4 - Pluggable transport (austauschbares Transportprotokoll; SipHash-Längenverschleierung als Präzedenzfall) Implementierungsrichtlinien Verbindliche Anforderungen Zur Einhaltung:\nVollständigen Handshake implementieren:\nAlle drei Nachrichten mit korrekten KDF-Ketten (Schlüsselableitungsfunktionen) unterstützen Alle AEAD-Tags (Authentifizierte Verschlüsselung mit zusätzlichen Daten) validieren Überprüfen, dass X25519-Punkte gültig sind Datenphase implementieren:\nSipHash-Längenverschleierung (in beiden Richtungen) Alle Blocktypen: 0 (DateTime), 1 (Options), 2 (RouterInfo), 3 (I2NP), 4 (Termination), 254 (Padding) Korrektes Nonce (Einmalwert)-Management (separate Zähler) Sicherheitsfunktionen:\nReplay-Schutz (ephemere Schlüssel für 2*D zwischenspeichern) Zeitstempel-Validierung (Standard: ±60 Sekunden) Zufälliges Padding in Nachrichten 1-2 AEAD (authentifizierte Verschlüsselung mit zusätzlichen Daten)-Fehlerbehandlung mit zufälligen Timeouts Veröffentlichung von RouterInfo:\nVeröffentliche statischen Schlüssel (\u0026ldquo;s\u0026rdquo;), IV (\u0026ldquo;i\u0026rdquo;) und Version (\u0026ldquo;v\u0026rdquo;) Rotiere Schlüssel gemäß Richtlinie Unterstütze das Feld für Fähigkeiten (\u0026ldquo;caps\u0026rdquo;) für versteckte router Netzwerkkompatibilität:\nUnterstützung des Netzwerk-ID-Felds (derzeit 2 für mainnet (Hauptnetz)) Interoperabilität mit bestehenden Java- und i2pd-Implementierungen Unterstützung von IPv4 und IPv6 Empfohlene Vorgehensweisen Leistungsoptimierung:\nPufferstrategie:\nGesamte Nachrichten auf einmal senden (Nachrichten 1, 2, 3) TCP_NODELAY (TCP-Option, die den Nagle-Algorithmus deaktiviert) für Handshake-Nachrichten verwenden Mehrere Datenblöcke zu einem einzelnen Frame puffern Frame-Größe auf wenige KB begrenzen (Latenz beim Empfänger minimieren) Verbindungsverwaltung:\nVerbindungen nach Möglichkeit wiederverwenden Verbindungspooling implementieren Verbindungsgesundheit überwachen (DateTime blocks – zeitbezogene Blöcke) Speicherverwaltung:\nSensible Daten nach der Verwendung auf Null setzen (ephemere Schlüssel, DH-Ergebnisse (Diffie-Hellman)) Gleichzeitige Handshakes begrenzen (DoS-Prävention) Speicherpools für häufige Zuweisungen verwenden Sicherheitshärtung:\nAbwehr von Sondierungsversuchen:\nZufällige Timeouts: 100-500ms Zufällige Byte-Lesevorgänge: 1KB-64KB IP-Blacklisting bei wiederholten Fehlschlägen Keine Fehlerdetails an Peers Ressourcengrenzen:\nMaximale Verbindungen pro IP: 3-10 Maximale ausstehende Handshakes: 100-1000 Lese-Timeouts: 30-60 Sekunden pro Vorgang Gesamtes Verbindungs-Timeout: 5 Minuten für den Handshake Schlüsselverwaltung:\nPersistente Speicherung von statischem Schlüssel und IV (Initialisierungsvektor) Sichere Zufallszahlengenerierung (kryptografischer RNG) Rotationsrichtlinien strikt einhalten Ephemere Schlüssel niemals wiederverwenden Überwachung und Diagnose:\nMetriken:\nErfolgs-/Fehlerraten beim Handshake AEAD-Fehlerraten Verteilung der Uhrenabweichungen Statistiken zur Verbindungsdauer Protokollierung:\nHandshake-Fehler mit Reason-Codes (Begründungscodes) protokollieren Clock-Skew-Ereignisse (Abweichungen der Systemuhren) protokollieren Gesperrte IP-Adressen protokollieren Niemals sensibles Schlüsselmaterial protokollieren Tests:\nUnit-Tests für KDF-Ketten Integrationstests mit anderen Implementierungen Fuzzing für Paketverarbeitung Lasttests zur Widerstandsfähigkeit gegen DoS Häufige Fallstricke Kritische Fehler, die zu vermeiden sind:\nWiederverwendung von Nonces (Nonce = Einmalwert):\nDen Nonce-Zähler niemals während einer Sitzung zurücksetzen Für jede Richtung separate Zähler verwenden Vor Erreichen von 2^64 - 1 beenden Schlüsselrotation:\nNiemals Schlüssel rotieren, während der router läuft Ephemere Schlüssel niemals über Sitzungen hinweg wiederverwenden Regeln für minimale Ausfallzeit befolgen Zeitstempel-Verarbeitung:\nNiemals abgelaufene Zeitstempel akzeptieren Bei der Berechnung der Abweichung stets die RTT (Round-Trip Time) berücksichtigen DateTime-Zeitstempel auf Sekunden runden AEAD-Fehler:\nFehlertyp niemals gegenüber dem Angreifer offenlegen Vor dem Schließen stets einen zufälligen Timeout verwenden Ungültige Länge genauso behandeln wie einen AEAD-Fehler Padding:\nNiemals Padding außerhalb der vereinbarten Grenzen senden Den Padding-Block immer zuletzt platzieren Niemals mehrere Padding-Blöcke pro Frame RouterInfo:\nImmer überprüfen, dass der statische Schlüssel mit der RouterInfo übereinstimmt Niemals RouterInfos ohne veröffentlichte Adressen flooden (über floodfill verbreiten) Immer Signaturen verifizieren Testmethodik Unit-Tests:\nKryptographische Primitive:\nTestvektoren für X25519, ChaCha20, Poly1305, SHA-256 Testvektoren für HMAC-SHA256 Testvektoren für SipHash-2-4 KDF-Ketten:\nKnown-Answer-Tests für alle drei Nachrichten Weitergabe des Chaining Keys (Verkettungsschlüssel) überprüfen SipHash-IV-Erzeugung testen Nachrichten-Parsing:\nDekodierung gültiger Nachrichten Ablehnung ungültiger Nachrichten Randbedingungen (leer, maximale Größe) Integrationstests:\nHandshake:\nErfolgreicher Austausch von drei Nachrichten Zurückweisung bei Uhrversatz Erkennung von Replay-Angriffen Zurückweisung ungültiger Schlüssel Datenphase:\nI2NP-Nachrichtenübertragung RouterInfo-Austausch Verarbeitung von Padding (Auffüllung) Beendigungsnachrichten Interoperabilität:\nGegen Java I2P testen Gegen i2pd testen IPv4 und IPv6 testen Veröffentlichte und versteckte routers testen Sicherheitstests:\nNegativtests:\nUngültige AEAD-Tags Erneut gesendete Nachrichten Angriffe durch Zeitdrift (Clock Skew) Fehlerhaft formatierte Frames DoS-Tests:\nVerbindungsflutung Slowloris-Angriffe (Angriff durch langsame, unvollständige HTTP-Anfragen) CPU-Erschöpfung (exzessives DH (Diffie-Hellman)) Speichererschöpfung Fuzzing:\nZufällige Handshake-Nachrichten Zufällige Frames der Datenphase Zufällige Blocktypen und -größen Ungültige kryptografische Werte Migration von NTCP Für Legacy-NTCP-Unterstützung (inzwischen entfernt):\nNTCP (Version 1) wurde in I2P 0.9.50 (Mai 2021) entfernt. Alle aktuellen Implementierungen müssen NTCP2 unterstützen. Historische Anmerkungen:\nÜbergangsphase (2018-2021):\n0.9.36: NTCP2 eingeführt (standardmäßig deaktiviert) 0.9.37: NTCP2 standardmäßig aktiviert 0.9.40: NTCP als veraltet markiert 0.9.50: NTCP entfernt Versionserkennung:\n\u0026ldquo;NTCP\u0026rdquo; transportStyle gab an, dass beide Versionen unterstützt werden \u0026ldquo;NTCP2\u0026rdquo; transportStyle gab an, dass nur NTCP2 unterstützt wird Automatische Erkennung anhand der Nachrichtengröße (287 vs 288 Bytes) Aktueller Status:\nAlle Router müssen NTCP2 unterstützen \u0026ldquo;NTCP\u0026rdquo; transportStyle ist veraltet Ausschließlich den \u0026ldquo;NTCP2\u0026rdquo; transportStyle verwenden Anhang A: Noise-XK-Muster Standard Noise XK Pattern (standardmäßiges XK-Muster des Noise-Protokolls):\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se Interpretation:\n\u0026lt;- : Nachricht vom Responder (Bob) an den Initiator (Alice) -\u0026gt; : Nachricht vom Initiator (Alice) an den Responder (Bob) s : Statischer Schlüssel (Langzeit-Identitätsschlüssel) rs : Entfernter statischer Schlüssel (statischer Schlüssel der Gegenstelle, vorab bekannt) e : Ephemerer Schlüssel (sitzungsspezifisch, bei Bedarf erzeugt) es : Ephemer-Statisch DH (Diffie-Hellman-Schlüsselaustausch; Alice ephemerer × Bob statischer) ee : Ephemer-Ephemer DH (Alice ephemerer × Bob ephemerer) se : Statisch-Ephemer DH (Alice statischer × Bob ephemerer) Ablauf der Schlüsselvereinbarung:\nVorabnachricht: Alice kennt Bobs statischen öffentlichen Schlüssel (aus RouterInfo) Nachricht 1: Alice sendet einen ephemeren Schlüssel, führt es DH aus Nachricht 2: Bob sendet einen ephemeren Schlüssel, führt ee DH aus Nachricht 3: Alice gibt den statischen Schlüssel preis, führt se DH aus Sicherheitseigenschaften:\nAlice authentifiziert: Ja (durch Nachricht 3) Bob authentifiziert: Ja (durch Besitz des statischen privaten Schlüssels) Vorwärtsgeheimnis: Ja (ephemere Schlüssel vernichtet) KCI resistance (Widerstandsfähigkeit gegen Key-Compromise-Impersonation): Ja (Authentifizierungsstufe 2) Anhang B: Base64-Kodierung I2P-Base64-Alphabet:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ Unterschiede zu Standard-Base64: - Zeichen 62-63: -~ statt +/ - Padding: gleich (=) oder je nach Kontext weggelassen\nVerwendung in NTCP2: - Statischer Schlüssel (\u0026ldquo;s\u0026rdquo;): 32 Bytes → 44 Zeichen (kein Padding) - IV (\u0026ldquo;i\u0026rdquo;): 16 Bytes → 24 Zeichen (kein Padding)\nKodierungsbeispiel:\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= Anhang C: Analyse von Paketmitschnitten Erkennung von NTCP2-Verkehr:\nTCP-Handshake:\nStandard-TCP SYN, SYN-ACK, ACK Zielport typischerweise 8887 oder ähnlich Nachricht 1 (SessionRequest – Sitzungsanforderung):\nErste Anwendungsdaten von Alice 80-65535 Bytes (typischerweise ein paar Hundert) Erscheint zufällig (AES-verschlüsselter ephemerer Schlüssel) Maximal 287 Bytes bei Verbindung zu einer \u0026ldquo;NTCP\u0026rdquo;-Adresse Nachricht 2 (SessionCreated):\nAntwort von Bob 80-65535 Bytes (typischerweise einige Hundert) Erscheint ebenfalls zufällig Nachricht 3 (SessionConfirmed, Sitzung bestätigt):\nVon Alice 48 Byte + variabler Anteil (RouterInfo-Größe + Padding) Typischerweise 1–4 KB Datenphase:\nFrames variabler Länge Längenfeld verschleiert (erscheint zufällig) Verschlüsselte Nutzlast Padding macht die Größe unvorhersehbar DPI-Umgehung: - Keine Klartext-Header - Keine festen Muster - Längenfelder verschleiert - Zufälliges Padding durchbricht größenbasierte Heuristiken\nVergleich mit NTCP: - NTCP Nachricht 1 ist immer 288 Byte groß (identifizierbar) - Bei NTCP2 variiert die Größe von Nachricht 1 (nicht identifizierbar) - NTCP hatte erkennbare Muster - NTCP2 wurde so entworfen, dass es DPI widersteht\nAnhang D: Versionsverlauf Wichtige Meilensteine:\n0.9.36 (23. August 2018): NTCP2 eingeführt, standardmäßig deaktiviert 0.9.37 (4. Oktober 2018): NTCP2 standardmäßig aktiviert 0.9.40 (20. Mai 2019): NTCP als veraltet markiert 0.9.42 (27. August 2019): Netzwerk-ID-Feld hinzugefügt (Proposal 147) 0.9.50 (17. Mai 2021): NTCP entfernt, Unterstützung für Fähigkeiten hinzugefügt 2.10.0 (9. September 2025): Neueste stabile Version Protokollstabilität: - Keine inkompatiblen Änderungen seit 0.9.50 - Laufende Verbesserungen der Widerstandsfähigkeit gegen Sondierungsangriffe - Fokus auf Leistung und Zuverlässigkeit - Post-Quanten-Kryptografie in Entwicklung (standardmäßig nicht aktiviert)\nAktueller Transportstatus: - NTCP2: Obligatorischer TCP-Transport - SSU2: Obligatorischer UDP-Transport - NTCP (v1): Entfernt - SSU (v1): Entfernt\n","description":"Noise-basierter TCP-Transport für router-zu-router-Verbindungen","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"NTCP2 Transport","url":"/de/docs/specs/ntcp2/"},{"categories":null,"content":"Übersicht I2P-Plugins sind signierte Archive, die die router-Funktionalität erweitern. Sie werden als .xpi2p- oder .su3-Dateien ausgeliefert, in ~/.i2p/plugins/\u0026lt;name\u0026gt;/ (oder unter Windows in %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\) installiert und mit vollen router-Berechtigungen ohne Sandboxing ausgeführt.\nUnterstützte Plugin-Typen Konsolen-Webanwendungen Neue eepsites mit cgi-bin, Webanwendungen Konsolen-Themes Konsolen-Übersetzungen Java-Programme (im selben Prozess oder in einer separaten JVM) Shell-Skripte und native Binärdateien Sicherheitsmodell KRITISCH: Plugins laufen in derselben JVM mit identischen Berechtigungen wie der I2P router. Sie haben uneingeschränkten Zugriff auf: - Dateisystem (Lesen und Schreiben) - Router APIs und interner Zustand - Netzwerkverbindungen - Ausführung externer Programme\nPlugins sollten als vollständig vertrauenswürdiger Code behandelt werden. Benutzer müssen vor der Installation die Plugin-Quellen und -Signaturen verifizieren.\nDateiformate SU3-Format (dringend empfohlen) Status: Aktiv, bevorzugtes Format seit I2P 0.9.15 (September 2014)\nDas Format .su3 bietet: - RSA-4096-Signaturschlüssel (im Vergleich zu DSA-1024 in xpi2p) - Signatur im Dateiheader gespeichert - Magische Zahl: I2Psu3 - Bessere Vorwärtskompatibilität\nStruktur:\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] XPI2P-Format (Legacy, veraltet) Status: Unterstützt zur Abwärtskompatibilität, nicht für neue Plugins empfohlen\nDas .xpi2p-Format verwendet ältere kryptografische Signaturen:\nDSA-1024-Signaturen (veraltet gemäß NIST-800-57) 40-Byte-DSA-Signatur, der ZIP-Datei vorangestellt Erfordert das Feld key in plugin.config Struktur:\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] Migrationspfad: Bei der Migration von xpi2p zu su3 stellen Sie während der Übergangsphase sowohl updateURL als auch updateURL.su3 bereit. Moderne routers (0.9.15+) bevorzugen SU3 automatisch.\nArchivstruktur und plugin.config Erforderliche Dateien plugin.config - Standard-I2P-Konfigurationsdatei mit Schlüssel-Wert-Paaren\nErforderliche Eigenschaften Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format **Beispiele für Versionsformate:** - `1.2.3` - `1.2.3-4` - `2.0.0-beta.1` Gültige Trennzeichen: . (Punkt), - (Bindestrich), _ (Unterstrich)\nOptionale Metadaten-Eigenschaften Informationen anzeigen date - Veröffentlichungsdatum (Zeitstempel als Java long) author - Entwicklername (user@mail.i2p empfohlen) description - Englische Beschreibung description_xx - Lokalisierte Beschreibung (xx = Sprachcode) websiteURL - Plugin-Homepage (http://foo.i2p/) license - Lizenzkennung (z. B. \u0026ldquo;Apache-2.0\u0026rdquo;, \u0026ldquo;GPL-3.0\u0026rdquo;) Konfiguration aktualisieren updateURL - XPI2P-Update-URL (veraltet) updateURL.su3 - SU3-Update-URL (bevorzugt) min-i2p-version - Erforderliche Mindestversion von I2P max-i2p-version - Maximal kompatible I2P-Version min-java-version - Mindest-Java-Version (z. B. 1.7, 17) min-jetty-version - Mindest-Jetty-Version (verwenden Sie 6 für Jetty 6+) max-jetty-version - Maximale Jetty-Version (verwenden Sie 5.99999 für Jetty 5) Installationsverhalten dont-start-at-install - Standardwert false. Wenn true, erfordert manuellen Start router-restart-required - Standardwert false. Informiert den Benutzer, dass nach dem Update ein Neustart erforderlich ist update-only - Standardwert false. Schlägt fehl, wenn das Plugin noch nicht installiert ist install-only - Standardwert false. Schlägt fehl, wenn das Plugin bereits installiert ist min-installed-version - Erforderliche Mindestversion für das Update max-installed-version - Maximale Version, die aktualisiert werden kann disableStop - Standardwert false. Blendet die Stopp-Schaltfläche aus, wenn true Konsolenintegration consoleLinkName - Text für den Link in der Zusammenfassungsleiste der Konsole consoleLinkName_xx - Lokalisierter Linktext (xx = Sprachcode) consoleLinkURL - Ziel des Links (z. B. /appname/index.jsp) consoleLinkTooltip - Tooltip-Text (unterstützt seit 0.7.12-6) consoleLinkTooltip_xx - Lokalisierter Tooltip console-icon - Pfad zu einem 32x32-Icon (unterstützt seit 0.9.20) icon-code - Base64-codiertes 32x32-PNG für Plugins ohne Webressourcen (seit 0.9.25) Plattformanforderungen (nur Anzeige) required-platform-OS - Betriebssystemanforderung (nicht erzwungen) other-requirements - Zusätzliche Anforderungen (z. B. \u0026ldquo;Python 3.8+\u0026rdquo;) Abhängigkeitsverwaltung (nicht implementiert) depends - kommagetrennte Plugin-Abhängigkeiten depends-version - Versionsanforderungen für Abhängigkeiten langs - Inhalte des Sprachpakets type - Plugin-Typ (app/theme/locale/webapp) Variablenersetzung in Update-URLs Funktionsstatus: Verfügbar seit I2P 1.7.0 (0.9.53)\nSowohl updateURL als auch updateURL.su3 unterstützen plattformspezifische Variablen:\nVariablen: - $OS - Betriebssystem: windows, linux, mac - $ARCH - Architektur: 386, amd64, arm64\nBeispiel:\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 Ergebnis unter Windows AMD64:\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 Dies ermöglicht einzelne plugin.config-Dateien für plattformspezifische Builds.\nVerzeichnisstruktur Standardlayout plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration Verzeichniszwecke console/locale/ - JAR-Dateien mit Ressourcenbündeln für I2P-Basisübersetzungen - Plugin-spezifische Übersetzungen sollten in console/webapps/*.war oder lib/*.jar liegen\nconsole/themes/ - Jedes Unterverzeichnis enthält ein vollständiges Konsolen-Theme - Automatisch zum Theme-Suchpfad hinzugefügt\nconsole/webapps/ - .war-Dateien zur Konsolenintegration - Wird automatisch gestartet, sofern nicht in webapps.config deaktiviert - Der WAR-Name muss nicht mit dem Plugin-Namen übereinstimmen\neepsite/ - Vollständige eepsite mit eigener Jetty-Instanz - Erfordert eine jetty.xml-Konfiguration mit Variablenersetzung - Siehe zzzot- und pebble-Plugin-Beispiele\nlib/ - JAR-Bibliotheken für Plugins - Im Klassenpfad über clients.config oder webapps.config angeben\nWebapp-Konfiguration webapps.config-Format Standard-I2P-Konfigurationsdatei zur Steuerung des Verhaltens der Web-App.\nSyntax:\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar Wichtige Hinweise: - Vor router 0.7.12-9 verwenden Sie plugin.warname.startOnLoad zur Kompatibilität - Vor API 0.9.53 funktionierte der Klassenpfad nur, wenn der WAR-Name mit dem Plugin-Namen übereinstimmte - Seit 0.9.53+ funktioniert der Klassenpfad für jeden Webanwendungsnamen\nBewährte Verfahren für Webanwendungen ServletContextListener-Implementierung\njavax.servlet.ServletContextListener zur Bereinigung implementieren Oder destroy() im Servlet überschreiben Stellt eine ordnungsgemäße Beendigung während Aktualisierungen und beim Stoppen des router sicher Bibliotheksverwaltung\nGemeinsam genutzte JARs in lib/ ablegen, nicht innerhalb der WAR Über den Klassenpfad in webapps.config referenzieren Ermöglicht die getrennte Installation/Aktualisierung von Plugins Konflikte mit Bibliotheken vermeiden\nBündeln Sie niemals Jetty-, Tomcat- oder Servlet-JARs Bündeln Sie niemals JARs aus der Standard-I2P-Installation Prüfen Sie den Classpath-Abschnitt auf Standardbibliotheken Kompilierungsanforderungen\nKeine .java- oder .jsp-Quelldateien einbeziehen Alle JSPs vorkompilieren, um Startverzögerungen zu vermeiden Es kann nicht von der Verfügbarkeit eines Java-/JSP-Compilers ausgegangen werden Servlet-API-Kompatibilität\nI2P unterstützt Servlet 3.0 (seit 0.9.30) Annotation-Scanning wird NICHT unterstützt (@WebContent) Der traditionelle Deployment-Deskriptor web.xml ist erforderlich Jetty-Version\nAktuell: Jetty 9 (I2P 0.9.30+) Verwenden Sie net.i2p.jetty.JettyStart als Abstraktionsschicht Schützt vor Änderungen der Jetty-API Client-Konfiguration clients.config-Format Definiert Clients (Dienste), die vom Plugin gestartet werden.\nGrundlegender Client:\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties Client mit Stoppen/Deinstallieren:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar Eigenschaftsreferenz Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths ### Variablenersetzung Die folgenden Variablen werden in args, stopargs, uninstallargs und classpath ersetzt:\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 ### Verwaltete vs. nicht verwaltete Clients Verwaltete Clients (empfohlen seit 0.9.4): - Instanziiert von ClientAppManager - Verwaltet Referenz- und Zustandsverfolgung - Einfacheres Lebenszyklus-Management - Besseres Speichermanagement\nNicht verwaltete Clients: - Vom router gestartet, keine Zustandsverfolgung - Müssen mehrere Start-/Stopp-Aufrufe ordnungsgemäß behandeln - Zur Koordination statische Zustandsinformationen oder PID-Dateien verwenden - Beim Herunterfahren des router aufgerufen (seit 0.7.12-3)\nShellService (seit 0.9.53 / 1.7.0) Verallgemeinerte Lösung zum Ausführen externer Programme mit automatischer Zustandsverfolgung.\nFunktionen: - Verwaltet den Prozesslebenszyklus - Kommuniziert mit ClientAppManager - Automatische PID-Verwaltung - Plattformübergreifende Unterstützung\nVerwendung:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh Für plattformspezifische Skripte:\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH Alternative (veraltet): Schreibe einen Java-Wrapper, der den Betriebssystemtyp prüft, und rufe ShellCommand mit der entsprechenden .bat- oder .sh-Datei auf.\nInstallationsprozess Installationsablauf für Benutzer Benutzer fügt die Plugin-URL auf der Plugin-Konfigurationsseite der Router Console (/configplugins) ein Router lädt die Plugin-Datei herunter Signaturprüfung (schlägt fehl, wenn der Schlüssel unbekannt ist und der Strict-Modus aktiviert ist) ZIP-Integritätsprüfung Extrahieren und Parsen von plugin.config Überprüfung der Versionskompatibilität (min-i2p-version, min-java-version, usw.) Erkennung von Konflikten bei Webapp-Namen Vorhandenes Plugin stoppen, falls es sich um ein Update handelt Verzeichnisvalidierung (muss unter plugins/ liegen) Alle Dateien in das Plugin-Verzeichnis extrahieren plugins.config aktualisieren Plugin starten (außer wenn dont-start-at-install=true) Sicherheit und Vertrauen Schlüsselverwaltung: - First-key-seen (erstmals gesehener Schlüssel) Vertrauensmodell für neue Signierer - Nur die Schlüssel von jrandom und zzz sind mitgeliefert - Seit 0.9.14.1 werden unbekannte Schlüssel standardmäßig abgelehnt - Eine erweiterte Eigenschaft kann dies für Entwicklungszwecke außer Kraft setzen\nInstallationsbeschränkungen: - Archive dürfen ausschließlich in das Plugin-Verzeichnis entpackt werden - Das Installationsprogramm lehnt Pfade außerhalb von plugins/ ab - Plugins können nach der Installation auf Dateien an anderen Orten zugreifen - Kein Sandboxing oder Privilegien-Trennung\nAktualisierungsmechanismus Ablauf der Aktualisierungsprüfung Router liest updateURL.su3 (bevorzugt) oder updateURL aus plugin.config HTTP HEAD oder partielle GET-Anfrage, um die Bytes 41-56 abzurufen Versionsstring aus der entfernten Datei extrahieren Mit der installierten Version vergleichen, mithilfe von VersionComparator Falls neuer, den Benutzer auffordern oder automatisch herunterladen (abhängig von den Einstellungen) Plugin stoppen Update installieren Plugin starten (sofern die Benutzereinstellung nicht geändert wurde) Versionsvergleich Versionen werden als durch Punkt/Bindestrich/Unterstrich getrennte Komponenten interpretiert: - 1.2.3 \u0026lt; 1.2.4 - 1.2.3 \u0026lt; 1.2.3-1 - 2.0.0 \u0026gt; 1.9.9\nMaximale Länge: 16 Bytes (muss mit dem SUD/SU3-Header übereinstimmen)\nBewährte Verfahren für Aktualisierungen Bei Releases die Versionsnummer immer erhöhen Update-Pfad von der vorherigen Version testen Bei größeren Änderungen router-restart-required berücksichtigen Während der Migration sowohl updateURL als auch updateURL.su3 bereitstellen Für Tests ein Suffix der Buildnummer verwenden (1.2.3-456) Klassenpfad und Standardbibliotheken Immer im Klassenpfad verfügbar Die folgenden JAR-Dateien aus $I2P/lib sind für I2P 0.9.30+ immer im Klassenpfad:\nJAR Contents Plugin Usage i2p.jarCore APIRequired for all plugins mstreaming.jarStreaming APIMost plugins need streaming.jarStreaming implementationMost plugins need i2ptunnel.jarI2PTunnelHTTP/server plugins router.jarRouter internalsRarely needed, avoid if possible javax.servlet.jarServlet 3.1, JSP 2.3 APIPlugins with servlets/JSPs jasper-runtime.jarJasper compiler/runtimePlugins with JSPs commons-el.jarEL 3.0 APIJSPs using expression language jetty-i2p.jarJetty utilitiesPlugins starting Jetty org.mortbay.jetty.jarJetty 9 baseCustom Jetty instances sam.jarSAM APIRarely needed addressbook.jarSubscription/blockfileUse NamingService instead routerconsole.jarConsole librariesNot public API, avoid jbigi.jarNative cryptoPlugins should not need systray.jarURL launcherRarely needed wrapper.jarService wrapperPlugins should not need ### Besondere Hinweise commons-logging.jar: - Seit 0.9.30 leer - Vor 0.9.30: Apache Tomcat JULI - Vor 0.9.24: Commons Logging + JULI - Vor 0.9: Nur Commons Logging\njasper-compiler.jar: - Seit Jetty 6 (0.9) leer\nsystray4j.jar: - Entfernt in 0.9.26\nNicht im Klassenpfad (muss angegeben werden) JAR Contents Usage jstl.jarStandard TaglibJSP tag libraries standard.jarStandard TaglibJSP tag libraries ### Spezifikation des Klassenpfads In clients.config:\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar In webapps.config:\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar Wichtig: Seit 0.7.13-3 sind Klassenpfade threadspezifisch, nicht JVM-weit. Geben Sie für jeden Client den vollständigen Klassenpfad an.\nAnforderungen an die Java-Version Aktuelle Anforderungen (Oktober 2025) I2P 2.10.0 und älter: - Mindestens: Java 7 (erforderlich seit 0.9.24, Januar 2016) - Empfohlen: Java 8 oder höher\nI2P 2.11.0 und neuer (BEVORSTEHEND): - Mindestanforderung: Java 17+ (angekündigt in den Versionshinweisen zu 2.9.0) - Warnung zwei Versionen im Voraus gegeben (2.9.0 → 2.10.0 → 2.11.0)\nKompatibilitätsstrategie für Plugins Für maximale Kompatibilität (bis einschließlich I2P 2.10.x):\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 Für Funktionen ab Java 8:\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 Für Funktionen in Java 11+:\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 Vorbereitung auf 2.11.0+:\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 Bewährte Praktiken für die Kompilierung Beim Kompilieren mit einem neueren JDK für eine ältere Zielversion:\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; Dies verhindert die Verwendung von APIs, die in der Ziel-Java-Version nicht verfügbar sind.\nPack200-Komprimierung - VERALTET Kritisches Update: Pack200 nicht verwenden Status: Veraltet und entfernt\nDie ursprüngliche Spezifikation empfahl nachdrücklich die Pack200-Komprimierung zur Reduzierung der Größe um 60-65 %. Dies ist nicht mehr gültig.\nZeitleiste: - JEP 336: Pack200 in Java 11 als veraltet markiert (September 2018) - JEP 367: Pack200 in Java 14 entfernt (März 2020)\nDie offizielle Spezifikation für I2P-Updates besagt: \u0026gt; \u0026ldquo;JAR- und WAR-Dateien im ZIP-Archiv werden nicht mehr mit pack200 komprimiert, wie oben für \u0026lsquo;su2\u0026rsquo;-Dateien dokumentiert, da neuere Java-Laufzeitumgebungen dies nicht mehr unterstützen.\u0026rdquo;\nWas ist zu tun:\npack200 umgehend aus den Build-Prozessen entfernen Standard-ZIP-Komprimierung verwenden Alternativen in Betracht ziehen: ProGuard/R8 zur Code-Verkleinerung UPX für native Binärdateien Moderne Kompressionsalgorithmen (zstd, brotli), sofern ein eigener Entpacker bereitgestellt wird Für bestehende Plugins: - Alte routers (0.7.11-5 bis einschließlich Java 10) können pack200 weiterhin entpacken - Neue routers (Java 11+) können pack200 nicht entpacken - Plugins ohne pack200-Komprimierung neu veröffentlichen\nSignaturschlüssel und Sicherheit Schlüsselgenerierung (SU3-Format) Verwenden Sie das Skript makeplugin.sh aus dem Repository i2p.scripts:\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ Wichtige Details: - Algorithmus: RSA_SHA512_4096 - Format: X.509-Zertifikat - Speicherformat: Java-Keystore-Format\nSignieren von Plugins # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 Bewährte Verfahren für das Schlüsselmanagement Einmal generieren, für immer schützen\nRouters lehnen doppelte Schlüsselnamen mit unterschiedlichen Schlüsseln ab Routers lehnen doppelte Schlüssel mit unterschiedlichen Schlüsselnamen ab Updates werden abgelehnt, wenn Schlüssel und Name nicht übereinstimmen Sichere Speicherung\nSicheres Backup des Keystores erstellen Starke Passphrase verwenden Niemals in die Versionsverwaltung committen Schlüsselrotation\nWird von der aktuellen Architektur nicht unterstützt Langfristige Schlüsselnutzung einplanen Multisignaturverfahren für die Teamentwicklung in Betracht ziehen Veraltete DSA-Signierung (XPI2P) Status: Funktionsfähig, aber veraltet\nVom xpi2p-Format verwendete DSA-1024-Signaturen: - 40-Byte-Signatur - 172 base64-Zeichen langer öffentlicher Schlüssel - NIST-800-57 empfiehlt mindestens (L=2048, N=224) - I2P verwendet schwächere (L=1024, N=160)\nEmpfehlung: Verwenden Sie stattdessen SU3 (I2P-Update-Paketformat) mit RSA-4096.\nRichtlinien für die Plugin-Entwicklung Wesentliche bewährte Verfahren Dokumentation\nEin klares README mit Installationsanleitung bereitstellen Konfigurationsoptionen und Standardwerte dokumentieren Bei jeder Veröffentlichung ein Änderungsprotokoll beifügen Erforderliche I2P/Java-Versionen angeben Größenoptimierung\nNur erforderliche Dateien einschließen Niemals router JARs bündeln Installations- vs. Update-Pakete trennen (Bibliotheken in lib/) Pack200-Kompression verwenden VERALTET - Standard-ZIP verwenden Konfiguration\nNiemals plugin.config zur Laufzeit ändern Verwenden Sie eine separate Konfigurationsdatei für Laufzeiteinstellungen Dokumentieren Sie die erforderlichen router-Einstellungen (SAM-Ports, tunnels, usw.) Respektieren Sie die vorhandene Konfiguration des Benutzers Ressourcennutzung\nAggressiven Bandbreitenverbrauch als Voreinstellung vermeiden Angemessene Grenzen für die CPU-Auslastung implementieren Ressourcen beim Beenden bereinigen Daemon-Threads dort verwenden, wo es angebracht ist Tests\nInstallieren/Aktualisieren/Deinstallieren auf allen Plattformen testen Updates von der vorherigen Version testen Während der Updates das Stoppen/Neustarten der Webapp überprüfen Mit der minimal unterstützten I2P-Version testen Dateisystem\nSchreiben Sie niemals in $I2P (kann schreibgeschützt sein) Schreiben Sie Laufzeitdaten in $PLUGIN oder $CONFIG Verwenden Sie I2PAppContext zum Auffinden von Verzeichnissen Gehen Sie nicht von einem bestimmten $CWD-Pfad aus (aktuelles Arbeitsverzeichnis) Kompatibilität\nStandard-I2P-Klassen nicht duplizieren Klassen bei Bedarf erweitern, nicht ersetzen min-i2p-version, min-jetty-version in plugin.config prüfen Mit älteren I2P-Versionen testen, falls diese unterstützt werden Shutdown-Handhabung\nOrdnungsgemäße stopargs in clients.config implementieren Shutdown-Hooks registrieren: I2PAppContext.addShutdownTask() Mehrfache Start/Stop-Aufrufe sauber behandeln Alle Threads auf Daemon-Modus setzen Sicherheit\nAlle externen Eingaben validieren Niemals System.exit() aufrufen Die Privatsphäre der Benutzer respektieren Sichere Programmierpraktiken befolgen Lizenzierung\nPlugin-Lizenz klar angeben Lizenzen der mitgelieferten Bibliotheken respektieren Erforderliche Namensnennung beifügen Zugang zum Quellcode bereitstellen, falls erforderlich Erweiterte Überlegungen Zeitzonenbehandlung: - Router setzt die JVM-Zeitzone auf UTC - Tatsächliche Zeitzone des Benutzers: I2PAppContext-Eigenschaft i2p.systemTimeZone\nVerzeichniserkennung:\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args Versionsnummerierung: - Verwende semantische Versionierung (major.minor.patch) - Füge eine Build-Nummer für Tests hinzu (1.2.3-456) - Stelle sicher, dass die Version bei Updates monoton steigt\nZugriff auf router-Klassen: - Generell Abhängigkeiten von router.jar vermeiden - Stattdessen öffentliche APIs in i2p.jar verwenden - Künftiges I2P könnte den Zugriff auf router-Klassen einschränken\nVermeidung von JVM-Abstürzen (historisch): - Behoben in 0.7.13-3 - Classloader korrekt verwenden - Aktualisieren von JARs in einem laufenden Plugin vermeiden - Bei Bedarf so auslegen, dass beim Update ein Neustart erfolgt\nEepsite-Plugins Übersicht Plugins können vollständige eepsites mit eigenen Jetty- und I2PTunnel-Instanzen bereitstellen.\nArchitektur Nicht versuchen: - In eine bestehende eepsite zu installieren - Mit der Standard-eepsite des router zusammenzuführen - Von der Verfügbarkeit einer einzelnen eepsite auszugehen\nStattdessen: - Neue I2PTunnel-Instanz starten (über die Kommandozeile) - Neue Jetty-Instanz starten - Beide in clients.config konfigurieren\nBeispielstruktur plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] Variablensubstitution in jetty.xml Verwenden Sie die Variable $PLUGIN für Pfade:\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; Der Router führt während des Plugin-Starts eine Ersetzung durch.\nBeispiele Referenzimplementierungen: - zzzot-Plugin - Torrent-Tracker - pebble-Plugin - Blog-Plattform\nBeide sind auf der Plugin-Seite von zzz verfügbar (I2P-intern).\nKonsolenintegration Links der Übersichtsleiste Klickbaren Link zur Zusammenfassungsleiste der Routerkonsole hinzufügen:\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface Lokalisierte Versionen:\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle Konsolensymbole Image-Datei (seit 0.9.20):\nconsole-icon=/myicon.png Pfad relativ zu consoleLinkURL, falls angegeben (seit 0.9.53), andernfalls relativ zum Webapp-Namen.\nEingebettetes Icon (seit 0.9.25):\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... Erzeugen mit:\nbase64 -w 0 icon-32x32.png Oder Java:\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png Anforderungen: - 32x32 Pixel - PNG-Format - Base64-kodiert (keine Zeilenumbrüche)\nInternationalisierung Übersetzungspakete Für I2P-Basisübersetzungen: - JARs in console/locale/ ablegen - Beinhalten Resource-Bundles für bestehende I2P-Apps - Benennung: messages_xx.properties (xx = Sprachcode)\nFür pluginspezifische Übersetzungen: - In console/webapps/*.war aufnehmen - Oder in lib/*.jar aufnehmen - Den Standardansatz mit dem Java ResourceBundle (Ressourcenbündel) verwenden\nLokalisierte Zeichenketten in plugin.config description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble Unterstützte Felder: - description_xx - consoleLinkName_xx - consoleLinkTooltip_xx\nÜbersetzung des Konsolen-Themes Themes in console/themes/ werden automatisch zum Suchpfad für Themes hinzugefügt.\nPlattformspezifische Plugins Ansatz mit separaten Paketen Verwenden Sie für jede Plattform unterschiedliche Plugin-Namen:\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac Ansatz der Variablenersetzung Eine einzelne plugin.config mit Plattformvariablen:\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 In der Datei clients.config:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH Betriebssystemerkennung zur Laufzeit Java-Ansatz für bedingte Ausführung:\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } Fehlerbehebung Häufige Probleme Plugin startet nicht: 1. Überprüfe die I2P-Versionskompatibilität (min-i2p-version) 2. Überprüfe die Java-Version (min-java-version) 3. Überprüfe die router-Protokolle auf Fehler 4. Überprüfe, ob alle erforderlichen JARs im Classpath vorhanden sind\nWebapp nicht erreichbar: 1. Bestätigen Sie, dass webapps.config die Webapp nicht deaktiviert 2. Prüfen Sie die Jetty-Versionskompatibilität (min-jetty-version) 3. Stellen Sie sicher, dass web.xml vorhanden ist (Annotation-Scanning wird nicht unterstützt) 4. Prüfen Sie auf konfliktierende Webapp-Namen\nUpdate schlägt fehl: 1. Prüfen, ob die Versionsnummer erhöht wurde 2. Prüfen, ob die Signatur mit dem Signierschlüssel übereinstimmt 3. Sicherstellen, dass der Plugin-Name der installierten Version entspricht 4. Einstellungen update-only/install-only überprüfen\nExternes Programm lässt sich nicht beenden: 1. ShellService für die automatische Lebenszyklusverwaltung verwenden 2. Ordnungsgemäße Behandlung von stopargs implementieren 3. Bereinigung der PID-Datei überprüfen 4. Prozessbeendigung überprüfen\nDebug-Protokollierung Debug-Logging im router aktivieren:\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG Protokolle prüfen:\n~/.i2p/logs/log-router-0.txt Referenzinformationen Offizielle Spezifikationen Plugin-Spezifikation Konfigurationsformat Update-Spezifikation Kryptografie I2P-Versionsgeschichte Aktuelle Version: - I2P 2.10.0 (8. September 2025)\nWichtige Veröffentlichungen seit 0.9.53: - 2.10.0 (Sep 2025) - Ankündigung für Java 17+ - 2.9.0 (Jun 2025) - Warnung zu Java 17+ - 2.8.0 (Okt 2024) - Tests zu Post-Quanten-Kryptografie - 2.6.0 (Mai 2024) - Sperrung von I2P-over-Tor - 2.4.0 (Dez 2023) - NetDB-Sicherheitsverbesserungen - 2.2.0 (Mär 2023) - Überlastkontrolle - 2.1.0 (Jan 2023) - Netzwerkverbesserungen - 2.0.0 (Nov 2022) - SSU2-Transportprotokoll - 1.7.0/0.9.53 (Feb 2022) - ShellService, Variablensubstitution - 0.9.15 (Sep 2014) - SU3-Format eingeführt\nVersionsnummerierung: - 0.9.x-Serie: Bis einschließlich Version 0.9.53 - 2.x-Serie: Ab 2.0.0 (Einführung von SSU2)\nEntwicklerressourcen Quellcode: - Haupt-Repository: https://i2pgit.org/I2P_Developers/i2p.i2p - GitHub-Spiegel: https://github.com/i2p/i2p.i2p Plugin-Beispiele: - zzzot (BitTorrent-Tracker) - pebble (Blog-Plattform) - i2p-bote (serverlose E-Mail) - orchid (Tor-Client) - seedless (Peer-Austausch)\nBuild-Tools: - makeplugin.sh - Schlüsselgenerierung und Signierung - Im i2p.scripts-Repository zu finden - Automatisiert die Erstellung und Verifizierung von su3\nCommunity-Unterstützung Foren: - I2P Forum - zzz.i2p (I2P-intern)\nIRC/Chat: - #i2p-dev auf OFTC - I2P IRC im Netzwerk\nAnhang A: Vollständiges Beispiel für plugin.config # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space Anhang B: Vollständiges clients.config-Beispiel # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config Anhang C: Vollständiges webapps.config-Beispiel # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true Anhang D: Migrations-Checkliste (von 0.9.53 auf 2.10.0) Erforderliche Änderungen Pack200-Komprimierung aus dem Build-Prozess entfernen\npack200-Aufgaben aus Ant-/Maven-/Gradle-Skripten entfernen Vorhandene Plugins ohne pack200 erneut veröffentlichen Java-Versionsanforderungen überprüfen\nErwägen, für neue Funktionen Java 11+ vorauszusetzen Planen, in I2P 2.11.0 Java 17+ zur Voraussetzung zu machen Die min-java-version in plugin.config aktualisieren Dokumentation aktualisieren\nPack200-Verweise entfernen Java-Versionsanforderungen aktualisieren I2P-Versionsverweise aktualisieren (0.9.x → 2.x) Empfohlene Änderungen Kryptografische Signaturen stärken\nVon XPI2P (I2P-Plugin-Paketformat) zu SU3 (signiertes I2P-Update-/Datenpaketformat) migrieren, falls noch nicht geschehen RSA-4096-Schlüssel für neue Plugins verwenden Neue Funktionen nutzen (bei Verwendung von 0.9.53+)\nVerwenden Sie die Variablen $OS / $ARCH für plattformspezifische Updates Verwenden Sie ShellService (Dienst zum Ausführen externer Programme) für externe Programme Verwenden Sie den verbesserten Webapp-Classpath (Klassenpfad der Webanwendung; funktioniert mit jedem warname [Name der WAR-Datei]) Kompatibilität testen\nMit I2P 2.10.0 testen Mit Java 8, 11, 17 überprüfen Unter Windows, Linux, macOS prüfen Optionale Erweiterungen Einen korrekten ServletContextListener implementieren Lokalisierte Beschreibungen hinzufügen Ein Konsolensymbol bereitstellen Die Handhabung des Herunterfahrens verbessern Umfassende Protokollierung hinzufügen Automatisierte Tests schreiben ","description":".xpi2p / .su3 Regeln für die Paketierung von I2P-Plugins","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"Plugin-Paketformat","url":"/de/docs/specs/plugin/"},{"categories":null,"content":" Status: Aktualisiert bis I2P 2.10.0 (Oktober 2025). Diese Liste konsolidiert alle aktiven, veralteten und reservierten Ports, die vom I2P Java Router, i2pd und zugehörigen Plugins verwendet werden. Alle Ports sind in numerischer Reihenfolge aufgeführt, um Konsistenz zu gewährleisten.\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. ## Implementierungshinweise Alle Ports unter 9000 (außer 8887) binden standardmäßig an 127.0.0.1 aus Sicherheitsgründen. Der router-Netzwerkport (9151–30777) muss für das Internet geöffnet sein, um vollständig teilnehmen zu können. i2pd verwendet größtenteils die gleichen Zuweisungen aus Kompatibilitätsgründen (7070 Konsole, 7654 I2CP, 7656/7655 SAM). Plugin-Entwickler sollten neue Zuweisungen über die I2P-Community koordinieren, um Konflikte zu vermeiden. ","description":"Umfassende Referenz der I2P-Portzuweisungen, Plugin-Ports und reservierten Bereiche.","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"Port-Zuweisungen","url":"/de/docs/overview/ports/"},{"categories":null,"content":"Übersicht Dieses Dokument spezifiziert ein re-randomisierbares Signaturschema, das sich zur Erstellung von Destinations (I2P-Zieladressen) eignet, die verblindet werden können. Zusätzlich kann es verwendet werden, um bestehende Ed25519 Destinations zu verblinden, mit einer leichten Verringerung der Wirksamkeit.\nRed25519 (ein auf Ed25519 basierendes RedDSA-Signaturschema) ist seit Version 0.9.39 (veröffentlicht am 21. März 2019) in I2P routers voll funktionsfähig. Diese Spezifikation wurde nach 17 Monaten produktiven Einsatzes in Version 0.9.47 (August 2020) finalisiert. Das Signaturschema wird im I2P-Netzwerk als Signaturtyp 11 (RedDSA_SHA512_Ed25519) eingesetzt.\nMotivation Vorschlag 123 (Neue netDB-Einträge) definiert ein verschlüsseltes LeaseSet2-Format, das das Prinzip der geringsten Autorität verkörpert: Jeder Netzwerkteilnehmer erhält nur die Informationen, die für seine Rolle erforderlich sind. Insbesondere offenbart ein verschlüsseltes LeaseSet2, das bei einem floodfill veröffentlicht wird, nicht, für welche Destination (Zielidentität) es bestimmt ist, und die Leases können nur von jemandem eingesehen werden, der die Destination bereits kennt. Floodfills müssen jedoch weiterhin die verschlüsselten LeaseSet2s bei der Veröffentlichung authentifizieren können, und Clients müssen zusätzlich sicherstellen, dass die Authentifizierung von der Destination selbst erzwungen wurde.\nVorschlag 123 erreicht dies, indem die Signierschlüssel der Destinations (I2P‑Adressen) verblindet werden. Die verblindeten Schlüssel können verwendet werden, um Signaturen zu erzeugen, die von floodfills verifizierbar sind, und Clients können sicher sein, dass nur die Destination die Signaturen erzeugt haben kann. Es ist daher notwendig, ein Signaturschema festzulegen, das zum Verblinden verwendet werden kann.\nHinweis zum Status von Vorschlag 123: Teile von Vorschlag 123 wurden seit Version 0.9.38 schrittweise implementiert und bereitgestellt, wobei Unterstützung für Red25519 in 0.9.39 hinzugefügt wurde. Die verschlüsselte LeaseSet2-Funktionalität ist produktionsreif und wird im I2P-Netzwerk aktiv für datenschutzverbesserte versteckte Dienste eingesetzt.\nEntwurf Kern-Signaturverfahren Das hier spezifizierte Signaturschema, Red25519, ist eine Instanziierung von RedDSA, wie in Abschnitt 5.4.6 der Zcash Protocol Specification (Sapling und später) definiert. RedDSA ist ein Schnorr-basiertes Signaturverfahren, das die Schlüssel-Re-Randomisierung unterstützt. Es bietet die folgenden Funktionen:\nGENERATE_PRIVATE() : Gibt einen gleichverteilten privaten Schlüssel zurück.\nDERIVE_PUBLIC(sk) : Gibt den öffentlichen Schlüssel zurück, der dem angegebenen privaten Schlüssel entspricht.\nGENERATE_RANDOM() : Gibt einen zufälligen Skalar zurück, der zur erneuten Randomisierung eines Schlüsselpaars geeignet ist.\nRANDOMIZE_PRIVATE(sk, alpha) : Randomisiert einen privaten Schlüssel erneut, mit einem geheimen Skalar alpha.\nRANDOMIZE_PUBLIC(vk, alpha) : Randomisiert einen öffentlichen Schlüssel erneut, unter Verwendung eines geheimen Skalars alpha.\nSIGN(sk, m) : Gibt eine Signatur mit dem privaten Schlüssel sk über die angegebene Nachricht m zurück.\nVERIFY(vk, m, sig) : Überprüft die Signatur sig anhand des öffentlichen Schlüssels vk und der Nachricht m. Gibt true zurück, wenn die Signatur gültig ist, andernfalls false.\nFür ein gegebenes Schlüsselpaar (sk, vk) gilt die folgende Beziehung:\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) Umwandlung von Ed25519-Schlüsseln in Red25519 Ed25519-Schlüssel DÜRFEN vorübergehend mittels Einweg-Umwandlung in Red25519-Schlüssel konvertiert werden, um die erneute Randomisierung bestehender Ed25519 Destinations (I2P-Zieladressen) zu unterstützen. Andere Signaturtypen sind nicht kompatibel.\nWir definieren die folgenden Konvertierungsfunktionen:\nCONVERT_ED25519_PRIVATE(privkey) : Gibt den Red25519-Privatschlüssel zurück, der dem angegebenen Ed25519-Privatschlüssel entspricht.\nCONVERT_ED25519_PUBLIC(pubkey) : Gibt den Red25519-öffentlichen Schlüssel zurück, der dem angegebenen Ed25519-öffentlichen Schlüssel entspricht.\nFür ein gegebenes Ed25519-Schlüsselpaar (privkey, pubkey) gilt die folgende Beziehung:\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) Spezifikation Definitionen B : Der Ed25519-Basispunkt wie in RFC 8032 beschrieben.\nL : Die Ed25519-Ordnung 2^252 + 27742317777372353535851937790883648493 wie in RFC 8032 .\n[s] B : Skalarmultiplikation mit fester Basis des Basispunkts mit dem Skalar s.\n[s] A : Skalarmultiplikation mit variabler Basis von A mit dem Skalar s.\nx || y : Verkettet zwei Byte-Arrays x und y.\nRed25519 Das Schema Red25519 ist eine Spezialisierung von RedDSA mit:\nG := die Gruppe der Punkte auf der Edwards-Form von Curve25519. Insbesondere bedeutet dies, dass Red25519 die Untergruppe von Primzahlordnung mit Ordnung L verwendet und der Kofaktor h_G 8 ist. P_G := der Ed25519-Basispunkt B. l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) Hinweis zur Wahl der Hashfunktion: Red25519 verwendet SHA-512 statt BLAKE2b-512 (wie es in Zcash RedDSA verwendet wird). Diese Designentscheidung wird durch den unten beschriebenen Schutz durch Längenpräfixierung kompensiert. I2P Proposal 148 schlägt eine zukünftige Migration zu BLAKE2b-512 vor, um den Schutz vor Erkennung doppelter Nachrichten (DMI) und Längenverlängerungsangriffen (LEA) zu verbessern sowie die Leistung zu steigern.\nRedDSA setzt voraus, dass H(x) mit einer kryptografischen Hashfunktion instanziiert wird, die gegen Längenerweiterungsangriffe sicher ist. SHA-512 erfüllt dies nicht von selbst. Um dem abzuhelfen, verlangen wir, dass den Nachrichten eine präfixfreie Kodierung ihrer Länge vorangestellt wird:\nlen_u16(M) || M wobei len_u16(M) die 2-Byte-Darstellung der Länge von M im Little-Endian-Format ist (um mit der Little-Endian-Kodierung von Skalaren und Punkten konsistent zu sein).\nNachrichten dürfen nicht länger als 65534 Bytes sein. Eine Länge von 65535 ist für mögliche zukünftige Erweiterungen reserviert.\nSicherheitshinweis: Die Einbeziehung des öffentlichen Schlüssels (vk) in die Hashfunktion, kombiniert mit 80 zufälligen Bytes bei der Signierung, gewährleistet Schutz vor SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack; starke Nichtfälschbarkeit mit re-randomisierten Schlüsseln unter gewähltem Nachrichtenangriff)‑Schwachstellen, die in frühen RedDSA-Designs entdeckt wurden. Diese Implementierung integriert die Sicherheitskorrekturen aus dem NCC Group Zcash Audit (Finding NCC-Zcash2018-009).\nKodierung und Dekodierung Red25519-Privatschlüssel sind Skalare mod L, die in Little-Endian-Darstellung kodiert sind. Wir definieren die Funktionen DECODE_SCALAR und ENCODE_SCALAR zur Umwandlung zwischen der Byte-Array- und der Ganzzahlform eines Skalars.\nÖffentliche Red25519-Schlüssel sind Punkte auf der Edwards-Form von Curve25519. Sie werden als 255-Bit-Little-Endian-Darstellung der y-Koordinate kodiert, gefolgt von einem einzelnen Bit, das das Vorzeichen der x-Koordinate angibt. Dies ist dieselbe Kodierung wie bei Ed25519. Wir definieren die Funktionen DECODE_POINT und ENCODE_POINT, um zwischen der Byte-Array- und der Koordinatenform eines Punktes zu wechseln.\nFunktionen von RedDSA (kryptografisches Signaturverfahren) Zur Erleichterung der Implementierung geben wir nachfolgend die RedDSA-Funktionen (Signaturschema) sowie mehrere Hilfsfunktionen explizit in der bereits für Red25519 (RedDSA-Variante über Ed25519) spezialisierten Form an. Implementierende sollten für die allgemeine Spezifikation der RedDSA-Funktionen Abschnitt 5.4.6 der Zcash-Protokollspezifikation konsultieren.\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() Konvertierungsfunktionen CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey Beachten Sie, dass die Implementierung von CONVERT_ED25519_PRIVATE der Berechnung des geheimen Skalars s entspricht, die beim Ableiten eines Ed25519-öffentlichen Schlüssels aus einem Ed25519-privaten Schlüssel erfolgt, wie in den Schritten 1-3 in Abschnitt 5.1.5 von RFC 8032 spezifiziert.\nSicherheitsauswirkungen Die Re-Randomisierung einer Red25519 Destination (Zielidentität im I2P‑Netz) und das anschließende Erzeugen von Signaturen damit gibt keine Informationen über die Destination preis, weil die Verteilung der mittels RANDOMIZE_PRIVATE erzeugten Red25519-Privatschlüssel identisch mit der Verteilung der mittels GENERATE_PRIVATE erzeugten Privatschlüssel ist und DERIVE_PUBLIC deterministisch ist.\nDie Umwandlung von Ed25519-Privatschlüsseln zu Red25519 über CONVERT_ED25519_PRIVATE führt nicht zur gleichen Verteilung. Wir halten die Verringerung der Sicherheit jedoch aus den folgenden Gründen für akzeptabel:\nDer Raum der Ed25519-Skalare ist ungefähr halb so groß wie der Raum der Red25519-Skalare (es gibt 2^251 mögliche Ed25519-Skalare, und L ~= 2^252 mögliche Red25519-Skalare). Daher beträgt der Sicherheitsverlust höchstens ungefähr den Faktor 2 bzw. etwa 1 Bit (weil wir zufällig einen Red25519-Skalar gewählt haben könnten, der auch ein gültiger Ed25519-Skalar ist). Bestehende Ed25519-Destinations (Ziele) waren in der Vergangenheit im Netzwerk sichtbar, und es sollte davon ausgegangen werden, dass bösartige floodfills sie bereits aufgelistet haben. Wichtig: Benutzer, die sich wegen dieser Verringerung der Sicherheit Sorgen machen, sollten Red25519 (Signaturtyp 11) als Signaturtyp für ihre Destinations (I2P-Zieladressen) verwenden statt Ed25519 (Signaturtyp 7).\nBeachten Sie, dass das obige Argument nicht auf den Re-Randomisierungs-Skalar alpha zutrifft; Informationen über den Schlüssel werden jedes Mal preisgegeben, wenn alpha mit Verzerrung gewählt wird, da sich additive Re-Randomisierung wie ein One-Time Pad (Einmalschlüssel) verhält.\nStatus des Sicherheitsaudits Wichtiger Hinweis: I2P, einschließlich Red25519, ist niemals einer formalen Sicherheitsprüfung durch Dritte unterzogen worden. Das zugrunde liegende RedDSA-Design wurde 2018 von der NCC Group im Rahmen des Audits des Zcash-Sapling-Protokolls einer Sicherheitsüberprüfung unterzogen, wobei Sicherheitsprobleme identifiziert und behoben wurden. Die spezifische I2P-Instanziierung mit SHA-512 (anstelle von BLAKE2b-512) und der I2P domain separation (Domänenseparation) wurde jedoch nicht unabhängig analysiert.\nDie ed25519-java-Referenzimplementierung von str4d wurde einem unabhängigen Audit durch Dritte unterzogen, jedoch ging dies der Red25519-Implementierung voraus und deckte nur die Ed25519-Funktionalität ab, nicht die Red25519-Erweiterungen.\nAnwender, die Red25519 einsetzen, sollten diese Einschränkung verstehen und die Sicherheitsabwägungen auf Grundlage ihres Bedrohungsmodells bewerten.\nKompatibilität I2P-Versionen, die Red25519 (ein Signaturalgorithmus) unterstützen (Version 0.9.39 und höher), können Netzwerkdatenstrukturen verifizieren, die damit signiert sind. I2P-Versionen, die Red25519 nicht unterstützen, behandeln es als unbekannte Signatur und KÖNNEN die Datenstrukturen verwerfen.\nBereitstellungszeitplan: - 0.9.39 (März 2019): Erste Implementierung mit Unterstützung für Encrypted LS2 in floodfills - 0.9.40 (Mai 2019): Pro-Client-Autorisierung für Encrypted LS2 - 0.9.41 (August 2019): Meta LS2 und Encrypted LS2 mit Offline-Schlüsseln - 0.9.43 (Februar 2020): b32-Unterstützung für Encrypted LS2 - 0.9.47 (August 2020): Finalisierung der Spezifikation - 2.10.0 (Oktober 2025): Aktuelle Netzwerkversion (entspricht 0.9.67+)\nNutzer sollten erwarten, dass die Zuverlässigkeit von Red25519-signierten Datenstrukturen für Anwendungsfälle mit Encrypted LeaseSet2 gut ist, da das Netzwerk seit der ersten Implementierung über sechs Jahre Zeit für Aktualisierungen hatte. Allerdings sind Adoptionskennzahlen zur allgemeinen Destination (Zieladresse)-Nutzung nicht öffentlich verfügbar.\nHauptanwendungsfall: Red25519 wird in erster Linie für die verschlüsselte LeaseSet2-Funktionalität verwendet, bei der Schlüsselblindung erforderlich ist. Für Standard-Destinationen ohne Anforderungen an ein verschlüsseltes leaseset bleibt Ed25519 (Signaturtyp 7) aufgrund der breiteren Kompatibilität und der längeren bewährten Erfolgsbilanz die empfohlene Wahl.\nHinweise zur Implementierung Red25519 ist im I2P Java router unter net.i2p.crypto.eddsa.RedDSAEngine implementiert und verwendet die ed25519-java-Bibliothek von str4d (Jack Grigg) als Maven-Abhängigkeit net.i2p.crypto:eddsa (Versionen 0.1.0 bis 0.3.0).\nDie i2pd-C++-Implementierung unterstützt auch Red25519 (signaturetype=11) für die Veröffentlichung verschlüsselter LeaseSets.\nBeispielkonfiguration für i2pd:\nsignaturetype=11 i2cp.leaseSetType=5 Kompatibilität von Encrypted LeaseSet2: Die Encrypted LeaseSet-Spezifikation erfordert, dass der öffentliche Signierschlüssel in der unverblindeten Destination (Zieladresse) Ed25519 (Signaturtyp 7) oder Red25519 (Signaturtyp 11) sein muss. Keine anderen Signaturtypen werden für die verschlüsselte leaseset-Funktionalität unterstützt.\nTestvektoren Die folgenden Testvektoren werden zur Validierung der Implementierung bereitgestellt. Jeder Vektor enthält:\nedsk: Privater Ed25519-Schlüssel (zufällig) edpk: Öffentlicher Ed25519-Schlüssel, der zu edsk gehört sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: Zu signierende Nachricht sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) Implementierungshinweis: Diese Testvektoren sollten zur kontinuierlichen Validierung in automatisierte Unit-Test-Suiten integriert werden. Implementierende sollten überprüfen, dass alle Konvertierungen, Signaturen und Re-Randomisierungsoperationen mit diesen erwarteten Werten übereinstimmen.\nTestvektor 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 Testvektor 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f Hinweis: Zusätzliche Testvektoren 3–10 folgen demselben Format und sind in der Referenzimplementierung zu finden.\nReferenzen Vorschlag 123: Neue netDB-Einträge - Teilweise in 0.9.38, 0.9.39 und späteren Versionen implementiert und bereitgestellt Zcash-Protokollspezifikation, Abschnitt 5.4.6: RedDSA, RedJubjub und RedPallas - RedDSA (Signaturverfahren) ist als Teil der Zcash-Protokollspezifikation definiert; Sicherheitsaudit durch die NCC Group (Januar 2019) RFC 8032: Edwards-Kurven-Digitalsignatur-Algorithmus (EdDSA) Vorschlag 148: RedDSA-BLAKE2b-Ed25519 - Vorgeschlagen, aber noch nicht implementiert; schlägt eine zukünftige Migration auf BLAKE2b-512 vor Spezifikation für verschlüsseltes LeaseSet Spezifikation für Kryptografie auf niedriger Ebene ","description":"Re-randomisierbares Signaturschema zur Erzeugung verblindeter Destinations (I2P-Zieladressen)","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"Red25519-Signaturschema","url":"/de/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":" Releases 0.9.57 und später sind von idk signiert. Sein aktueller öffentlicher Schlüssel ist: PGP-öffentlichen Schlüssel herunterladen Die Versionen 0.7.6 und 0.9.56 sind von zzz signiert. Sein aktueller öffentlicher Schlüssel ist: PGP-öffentlichen Schlüssel herunterladen -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 Ich habe neue GPG-Schlüssel und Unterschlüssel erstellt und die neuen Schlüssel mit dem alten Schlüssel signiert.\nAlte Schlüssel:\npub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) \u0026lt;zzz@mail.i2p\u0026gt; sub 2048g/74C8122D 2005-12-16 Neue Schlüssel:\npub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) \u0026lt;zzz@mail.i2p\u0026gt; uid zzz on i2p (key signing) \u0026lt;zzz@i2pmail.org\u0026gt; sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07] Ich werde die neuen Schlüssel wie folgt verwenden:\nEE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing Der Release-Signierungsschlüssel wird ab Version 0.9.13 verwendet. Diese Nachricht ist mit meinem alten Schlüssel signiert.\nzzz 25. Mai 2014\nNeue Schlüssel folgen:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.14 (GNU/Linux)\nmQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dpXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHp\niEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; Releases ab Version 0.9.9 könnten von str4d signiert worden sein. Sein aktueller öffentlicher Schlüssel ist: -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 Meine aktuellen öffentlichen Schlüssel lauten wie folgt:\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [läuft ab: 2019-03-10] uid [ voll ] str4d (http://str4d.i 2p) str4d@mail.i2p uid [ voll ] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [abgelaufen: 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [abgelaufen: 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [läuft ab: 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [läuft ab: 2016-04-04]\nIch verwende die Schlüssel derzeit wie folgt:\nA94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing Ich erstelle jährlich neue Verschlüsselungs- und Signatur-Unterschlüssel. Jede I2P-Version, die von mir signiert wird, wird immer mit dem zum Zeitpunkt der Veröffentlichung aktuellsten Signatur-Unterschlüssel signiert.\nstr4d 20. Nov. 2015\nAktuelle Schlüssel (Stand obiges Datum) folgen:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z\niQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d hat die folgenden Versionen signiert: 0.9.23 Die Versionen 0.7.6 bis 0.9.12 wurden von zzz mit folgendem Schlüssel signiert: -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enpA ICl6enpAbWFpbC5pMnA+iF8EExECAB8FAkOjTnUCGwMGCwkIBwMCBBUCCAMDFgIB Ah4BAheAAAoJEEFVdrqnbgvtxGsAn39SvQ3+ey87WDDG+TWArN6oU8gnAJ4zeAsA LUK37WZIt8OImZSxk37uQbkCDQRDo06VEAgAy2UeqsM5a+U6ZOWS9NQiILb3KbTL FeeAd2rn9oLSLpn5gDWycwUS0Q62JmbSMWy6m9aczpnxvwaBYXz6aCIvZmTNtaU6 vyR/6wfJDyiUWSHtCyjpyFFYJimANd8Y8dDCimvceI/ihEDVyBX0kkgUGRAn8t3e unaLXqhbfiLiFw/GG1MNxUMzHt55/+9AqLOfRZg0riZvDoV79K+1sYSs8n1WeaVc T3wTb+Cb7fKNN7GT1MUhcXIoYYY6FGwsy5EWFsxYBRervqHtBJog2SoNUa/6BFGr zX+LDjK9L3xMTr3+fHIt4gPR/Lt4nnfEzL+rjClz/Fazmv38BRwPuKahFwADBQgA nD/AvZCnbWSB6khAVMqva5ROaD0gV0/UejCelZdYfgfHeCmrcMNQ+wCyww2NPsih 9vB1w+AUE0pdH37k65VZN+2falUdzN+PFugJGuH2pmlVOprH2SuC5gKpGRvzUqV5 U0nJmT2okDpW/52asUDJJLu1g//A3qBP83WGvSKUZg/ZisZA0qTiHH4QpjklopXi sSxR2hT8Fr9gF9WmDa09wbxE2xh/EL7gvVg/vk0gwOJcsFd67bNC+KUMOnjhOP0T K0/Ah4TEEs/hHNe9RsyyWlMoIUsF8AhG71ISOrJ5lLSXNe151XEb5FzZRM8sD9Zq 0E3PjmLbdVhanYvsPnWK6YhJBBgRAgAJBQJDo06VAhsMAAoJEEFVdrqnbgvtXTwA njMu9ueCFbsjme7nwsz96PdazJcHAKCce17hGI25QNXDZyHohrjha6IxDg== =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nDie Versionen 0.6.1.31 bis 0.7.5 wurden von Complication signiert. Sein öffentlicher Schlüssel lautet: \u0026mdash;\u0026ndash;BEGIN PGP SIGNED MESSAGE\u0026mdash;\u0026ndash; Hash: SHA1\nHallo,\nIch bestätige, dass unten mein neuer öffentlicher Schlüssel aufgeführt ist, ausgestellt am 24.11.2007, gültig bis 23.11.2009, und sein Schlüssel-Fingerabdruck lautet:\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\nWenn Sie meinen alten öffentlichen Schlüssel haben und ihn zur Überprüfung verwenden, werden Sie feststellen, dass mein alter Schlüssel am 15.11.2007 abgelaufen ist. Entschuldigung für die verspätete Aktualisierung.\nFür Personen, die den Schlüssel direkt aus dieser Nachricht kopieren möchten, aber diese nicht mit einem E-Mail-Programm lesen, denken Sie bitte daran, die \u0026ldquo;- \u0026quot; Escape-Sequenzen am Anfang und Ende des öffentlichen Schlüsselblocks zu entfernen. Andernfalls wird er nicht erkannt.\nKomplikation.\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\nmQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK - \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\niD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"PGP-Schlüssel, die zum Signieren von I2P-Releases verwendet werden, und wo man sie erhält","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"Release-Signaturschlüssel","url":"/de/docs/develop/release-signing-key/"},{"categories":null,"content":"Über Reseed-Hosts Neue router benötigen eine Handvoll Peers, um dem I2P-Netzwerk beizutreten. Reseed-Hosts (Server für die anfängliche Peer-Bereitstellung) stellen dieses anfängliche Bootstrap-Set über verschlüsselte HTTPS-Downloads bereit. Jedes Reseed-Paket ist vom Host signiert und verhindert so Manipulationen durch nicht authentifizierte Parteien. Etablierte router können gelegentlich einen Reseed durchführen, wenn ihr Peer-Set veraltet ist.\nNetzwerk-Bootstrap-Prozess (Initialisierungsprozess) Wenn ein I2P router zum ersten Mal startet oder über einen längeren Zeitraum offline war, benötigt er RouterInfo-Daten, um sich mit dem Netzwerk zu verbinden. Da der router keine vorhandenen Peers hat, kann er diese Informationen nicht aus dem I2P-Netzwerk selbst beziehen. Der Reseed-Mechanismus (Erstverbindung zum Netzwerk) löst dieses Bootstrap-Problem, indem er RouterInfo-Dateien von vertrauenswürdigen externen HTTPS-Servern bereitstellt.\nDer Reseed-Prozess liefert 75-100 RouterInfo-Dateien in einem einzigen kryptografisch signierten Bündel. Dies stellt sicher, dass neue router schnell Verbindungen herstellen können, ohne sie Man-in-the-Middle-Angriffen auszusetzen, die sie in separate, nicht vertrauenswürdige Netzwerkpartitionen isolieren könnten.\nAktueller Netzwerkstatus Stand Oktober 2025 läuft das I2P-Netzwerk mit Router-Version 2.10.0 (API-Version 0.9.67). Das in Version 0.9.14 eingeführte Reseed-Protokoll bleibt in seiner Kernfunktionalität stabil und unverändert. Das Netzwerk betreibt mehrere unabhängige Reseed-Server, die weltweit verteilt sind, um Verfügbarkeit und Widerstandsfähigkeit gegen Zensur sicherzustellen.\nDer Dienst checki2p überwacht alle I2P-Reseed-Server alle 4 Stunden und bietet Echtzeit-Statusprüfungen sowie Verfügbarkeitsmetriken für die Reseed-Infrastruktur.\nSpezifikation des SU3-Dateiformats Das SU3-Dateiformat ist die Grundlage des Reseed-Protokolls von I2P und ermöglicht die Bereitstellung kryptografisch signierter Inhalte. Das Verständnis dieses Formats ist für die Implementierung von Reseed-Servern und -Clients unerlässlich.\nDateistruktur Das SU3-Format besteht aus drei Hauptkomponenten: Header (40+ Bytes), Inhalt (variable Länge) und Signatur (deren Länge im Header angegeben ist).\nHeader-Format (Bytes 0-39 mindestens) Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") ### Reseed-spezifische SU3-Parameter Für Reseed-Bundles muss die SU3-Datei die folgenden Eigenschaften aufweisen:\nDateiname: Muss genau i2pseeds.su3 sein Inhaltstyp (Byte 27): 0x03 (RESEED) Dateityp (Byte 25): 0x00 (ZIP) Signaturtyp (Bytes 8-9): 0x0006 (RSA-4096-SHA512) Versionsstring: Unix-Zeitstempel in ASCII (Sekunden seit der Unix-Epoche, im Format date +%s) Signer-ID: E-Mail-ähnlicher Bezeichner, der dem CN des X.509-Zertifikats entspricht Query-Parameter für die Netzwerk-ID Seit Version 0.9.42 fügen routers den Parameter ?netid=2 zu Reseed-Anfragen hinzu. Dies verhindert netzwerkübergreifende Verbindungen, da Testnetzwerke andere Netzwerk-IDs verwenden. Das aktuelle I2P-Produktionsnetz verwendet die Netzwerk-ID 2.\nBeispielanfrage: https://reseed.example.com/i2pseeds.su3?netid=2\nZIP-Inhaltsstruktur Der Inhaltsabschnitt (nach dem Header, vor der Signatur) enthält ein Standard-ZIP-Archiv mit den folgenden Anforderungen:\nKomprimierung: Standard-ZIP-Komprimierung (DEFLATE) Dateianzahl: Typischerweise 75-100 RouterInfo-Dateien Verzeichnisstruktur: Alle Dateien müssen auf oberster Ebene liegen (keine Unterverzeichnisse) Dateibenennung: routerInfo-{44-character-base64-hash}.dat Base64-Alphabet: Es muss das von I2P modifizierte Base64-Alphabet verwendet werden Das I2P-Base64-Alphabet unterscheidet sich von Standard-Base64, indem es - und ~ statt + und / verwendet, um die Kompatibilität mit Dateisystemen und URLs sicherzustellen.\nKryptografische Signatur Die Signatur deckt die gesamte Datei von Byte 0 bis zum Ende des Inhaltsabschnitts ab. Die Signatur selbst wird nach dem Inhalt angehängt.\nSignaturalgorithmus (RSA-4096-SHA512) Berechne den SHA-512-Hash der Bytes 0 bis zum Ende des Inhalts Signiere den Hash mit \u0026ldquo;raw\u0026rdquo; RSA (NONEwithRSA in der Java-Terminologie) Fülle die Signatur, falls erforderlich, mit führenden Nullen auf, um 512 Bytes zu erreichen Hänge die 512-Byte-Signatur an die Datei an Prozess der Signaturüberprüfung Clients müssen:\nBytes 0-11 lesen, um Signaturtyp und -länge zu bestimmen Gesamten Header lesen, um die Inhaltsgrenzen zu bestimmen Inhalt streamen und dabei den SHA-512-Hash berechnen Signatur vom Dateiende extrahieren Signatur mithilfe des RSA-4096-öffentlichen Schlüssels des Unterzeichners verifizieren Datei ablehnen, wenn die Signaturprüfung fehlschlägt Vertrauensmodell für Zertifikate Reseed-Signaturschlüssel werden als selbstsignierte X.509-Zertifikate mit RSA-4096-Schlüsseln verteilt. Diese Zertifikate sind in I2P router-Paketen im Verzeichnis certificates/reseed/ enthalten.\nZertifikatsformat: - Schlüsseltyp: RSA-4096 - Signatur: Selbstsigniert - Subject CN: Muss mit der Signer-ID im SU3-Header übereinstimmen - Gültigkeitsdaten: Clients sollten die Gültigkeitszeiträume des Zertifikats durchsetzen\nEinen Reseed-Host betreiben Der Betrieb eines Reseed-Dienstes erfordert sorgfältige Beachtung von Anforderungen an Sicherheit, Zuverlässigkeit und Netzwerkdiversität. Mehr unabhängige Reseed-Hosts erhöhen die Resilienz und erschweren es Angreifern oder Zensoren, den Beitritt neuer router zu blockieren.\nTechnische Anforderungen Server-Spezifikationen Betriebssystem: Unix/Linux (Ubuntu, Debian, FreeBSD getestet und empfohlen) Konnektivität: Statische IPv4-Adresse erforderlich, IPv6 empfohlen, aber optional CPU: Mindestens 2 Kerne RAM: Mindestens 2 GB Bandbreite: Ungefähr 15 GB pro Monat Betriebszeit: 24/7-Betrieb erforderlich I2P Router: Gut integrierter I2P router, der durchgehend läuft Softwareanforderungen Java: JDK 8 oder neuer (Java 17+ wird ab I2P 2.11.0 erforderlich sein) Webserver: nginx oder Apache mit Reverse-Proxy-Unterstützung (Lighttpd wird aufgrund von Einschränkungen des X-Forwarded-For-Headers nicht mehr unterstützt) TLS/SSL: Gültiges TLS-Zertifikat (Let\u0026rsquo;s Encrypt, selbstsigniert oder kommerzielle CA (Zertifizierungsstelle)) DDoS-Schutz: fail2ban oder gleichwertig (verpflichtend, nicht optional) Reseed-Tools: Offizielle reseed-tools von https://i2pgit.org/idk/reseed-tools Sicherheitsanforderungen HTTPS/TLS-Konfiguration Protokoll: Nur HTTPS, kein HTTP-Fallback TLS-Version: Mindestens TLS 1.2 Cipher Suites: Muss starke Chiffren unterstützen, die mit Java 8+ kompatibel sind Zertifikats-CN/SAN: Muss dem Hostnamen der bereitgestellten URL entsprechen Zertifikatstyp: Darf selbstsigniert sein, wenn dies mit dem Entwicklungsteam abgestimmt ist, oder von einer anerkannten Zertifizierungsstelle (CA) ausgestellt Zertifikatsverwaltung SU3-Signaturzertifikate und TLS-Zertifikate erfüllen unterschiedliche Zwecke:\nTLS-Zertifikat (certificates/ssl/): Sichert den HTTPS-Transport SU3-Signaturzertifikat (certificates/reseed/): Signiert Reseed-Bundles (Pakete zur Erstversorgung des netDb) Beide Zertifikate müssen dem Reseed-Koordinator (zzz@mail.i2p ) zur Aufnahme in router-Pakete übermittelt werden.\nDDoS- und Scraping-Schutz Reseed-Server sind periodischen Angriffen ausgesetzt – durch fehlerhafte Implementierungen, Botnets und böswillige Akteure, die versuchen, die netDb zu \u0026ldquo;scrapen\u0026rdquo; (automatisiert auszulesen). Schutzmaßnahmen umfassen:\nfail2ban: Erforderlich zur Ratenbegrenzung und zur Abwehr von Angriffen Bundle-Diversität: Unterschiedliche Sätze von RouterInfo (Router-Informationen in I2P) an verschiedene Anfragende ausliefern Bundle-Konsistenz: Dasselbe Bundle für wiederholte Anfragen von derselben IP innerhalb eines konfigurierbaren Zeitfensters ausliefern IP-Protokollierungsbeschränkungen: Keine Protokolle oder IP-Adressen veröffentlichen (Vorgabe der Datenschutzerklärung) Implementierungsmethoden Methode 1: Offizielle reseed-tools (Empfohlen) Die Referenzimplementierung, die vom I2P-Projekt gepflegt wird. Repository: https://i2pgit.org/idk/reseed-tools Installation:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 Beim ersten Start erzeugt das Tool: - your-email@mail.i2p.crt (SU3-Signaturzertifikat) - your-email@mail.i2p.pem (privater SU3-Signaturschlüssel) - your-email@mail.i2p.crl (Zertifikatsperrliste) - TLS-Zertifikat und -Schlüsseldateien\nFunktionen: - Automatische Generierung von SU3 bundle (I2P-Update-Paketformat) (350 Varianten, jeweils 77 RouterInfos) - Integrierter HTTPS-Server - Cache alle 9 Stunden über cron neu aufbauen - Unterstützung des X-Forwarded-For-Headers mit dem Flag --trustProxy - Kompatibel mit Reverse-Proxy-Konfigurationen\nBereitstellung für die Produktion:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed Methode 2: Python-Implementierung (pyseeder) Alternative Implementierung durch das PurpleI2P-Projekt: https://github.com/PurpleI2P/pyseeder pip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 Methode 3: Bereitstellung mit Docker Für containerisierte Umgebungen existieren mehrere Docker-fähige Implementierungen:\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: Fügt Unterstützung für Tor-Onion-Service (versteckter Dienst) und IPFS hinzu Reverse-Proxy-Konfiguration nginx-Konfiguration upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } Apache-Konfiguration \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; Registrierung und Koordination Um Ihren reseed server (Server zur Erstinitialisierung des I2P-Netzes) in das offizielle I2P-Paket aufzunehmen:\nEinrichtung und Tests abschließen Sende beide Zertifikate (SU3 signing (Signierung des SU3-Containerformats) und TLS) an den Reseed-Koordinator Kontakt: zzz@mail.i2p oder zzz@i2pmail.org Trete #i2p-dev auf IRC2P bei zur Koordination mit anderen Operatoren Betriebliche bewährte Verfahren Überwachung und Protokollierung Aktivieren Sie das kombinierte Apache/nginx-Logformat für Statistiken Logrotation implementieren (Protokolle wachsen schnell) Erfolg der Bundle-Erstellung und Zeiten für erneute Builds überwachen Bandbreitennutzung und Anfragemuster nachverfolgen IP-Adressen oder detaillierte Zugriffsprotokolle niemals veröffentlichen Wartungsplan Alle 9 Stunden: SU3-Bundle-Cache neu aufbauen (automatisiert per cron) Wöchentlich: Protokolle auf Angriffsmuster prüfen Monatlich: I2P router und reseed-tools aktualisieren Bei Bedarf: TLS-Zertifikate erneuern (mit Let\u0026rsquo;s Encrypt automatisieren) Portauswahl Standard: 8443 (empfohlen) Alternative: Beliebiger Port zwischen 1024-49151 Port 443: Erfordert Root-Rechte oder Portweiterleitung (iptables redirect empfohlen) Beispiel für Portweiterleitung:\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 Alternative Reseed-Methoden (Reseed = initiales Laden von netDb-Einträgen) Weitere Bootstrap-Optionen helfen Nutzern hinter restriktiven Netzwerken:\nDateibasierter Reseed (Erst-/Neusynchronisierung der netDb) Mit Version 0.9.16 eingeführt, ermöglicht das file-based reseeding (Reseed per Datei) Nutzern, RouterInfo-Bundles manuell zu laden. Diese Methode ist besonders nützlich für Nutzer in zensierten Regionen, in denen HTTPS-Reseed-Server blockiert sind.\nAblauf: 1. Eine vertrauenswürdige Kontaktperson erstellt mit ihrem router ein SU3-Bundle 2. Das Bundle wird per E-Mail, USB-Laufwerk oder über einen anderen Out-of-Band-Kanal übertragen 3. Der Nutzer legt i2pseeds.su3 in das I2P-Konfigurationsverzeichnis 4. Der router erkennt und verarbeitet das Bundle beim Neustart automatisch\nDokumentation: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\nAnwendungsfälle: - Nutzer hinter staatlichen Firewalls, die Reseed-Server blockieren - Isolierte Netzwerke, die ein manuelles Bootstrapping erfordern - Test- und Entwicklungsumgebungen\nCloudflare-vermitteltes Reseeding (Netzwerk-Initialisierung) Die Weiterleitung von Reseed-Datenverkehr (Erstverbindungsaufbau zu I2P über Reseed-Server) über das CDN von Cloudflare bietet Betreibern in Regionen mit starker Zensur mehrere Vorteile.\nVorteile: - IP-Adresse des Origin-Servers vor Clients verborgen - DDoS-Schutz über Cloudflares Infrastruktur - Geografische Lastverteilung durch Edge-Caching - Verbesserte Performance für globale Clients\nImplementierungsanforderungen: - --trustProxy-Flag in reseed-tools aktiviert - Cloudflare-Proxy für DNS-Eintrag aktiviert - Korrekte Handhabung des X-Forwarded-For-Headers\nWichtige Hinweise: - Cloudflare-Portbeschränkungen gelten (es müssen unterstützte Ports verwendet werden) - Konsistenz für dasselbe Client-Bundle erfordert Unterstützung für X-Forwarded-For - SSL/TLS-Konfiguration wird von Cloudflare verwaltet\nDokumentation: https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/ Zensurresistente Strategien Die Forschung von Nguyen Phong Hoang (USENIX FOCI 2019) identifiziert zusätzliche Bootstrapping-Methoden für zensierte Netzwerke:\nCloud-Speicheranbieter Box, Dropbox, Google Drive, OneDrive: SU3-Dateien über öffentliche Links bereitstellen Vorteil: Schwer zu blockieren, ohne legitime Dienste zu beeinträchtigen Einschränkung: Erfordert die manuelle Weitergabe der URLs an die Benutzer IPFS-Verteilung Reseed-Bundles auf dem InterPlanetary File System (IPFS, inhaltsadressiertes, verteiltes Dateisystem) hosten Inhaltsadressierter Speicher verhindert Manipulation Widerstandsfähig gegen Takedown-Versuche Tor-Onion-Dienste Reseed-Server (Server zum initialen Herunterladen von netDb-Einträgen), über .onion-Adressen erreichbar Resistent gegen IP-basierte Sperrungen Erfordert einen Tor-Client auf dem System des Nutzers Forschungsdokumentation: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/ Länder, die I2P bekanntermaßen blockieren Stand 2025 ist bestätigt, dass die folgenden Länder I2P-Reseed-Server (Server zur anfänglichen Peer-Versorgung neuer I2P router) blockieren: - China - Iran - Oman - Katar - Kuwait\nBenutzer in diesen Regionen sollten alternative Bootstrap-Methoden oder zensurresistente Reseeding-Strategien verwenden.\nProtokolldetails für Implementierer Spezifikation für Reseed-Anfragen (Initialbefüllung der netDb) Client-Verhalten Serverauswahl: Router verwaltet eine hartcodierte Liste von Reseed-URLs Zufallsauswahl: Client wählt zufällig einen Server aus der verfügbaren Liste Anfrageformat: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: Sollte gängigen Browsern ähneln (z. B. \u0026ldquo;Wget/1.11.4\u0026rdquo;) Wiederholungslogik: Wenn die SU3-Anfrage fehlschlägt, auf das Parsen der Indexseite zurückgreifen Zertifikatsprüfung: TLS-Zertifikat gegen den System-Zertifikatsspeicher prüfen SU3-Signaturprüfung: Signatur gegen bekannte Reseed-Zertifikate verifizieren Serververhalten Bundle-Auswahl: Wähle eine pseudozufällige Teilmenge von RouterInfos aus der netDb aus Client-Tracking: Anfragen anhand der Quell-IP identifizieren (unter Berücksichtigung von X-Forwarded-For) Bundle-Konsistenz: Bei wiederholten Anfragen innerhalb eines Zeitfensters (typischerweise 8–12 Stunden) dasselbe Bundle zurückgeben Bundle-Diversität: Verschiedenen Clients unterschiedliche Bundles zurückgeben, um die Netzwerkdiversität zu erhöhen Content-Type: application/octet-stream oder application/x-i2p-reseed RouterInfo-Dateiformat Jede .dat-Datei im Reseed-Paket enthält eine RouterInfo-Struktur:\nDateibenennung: routerInfo-{base64-hash}.dat - Der Hash besteht aus 44 Zeichen und verwendet das I2P-Base64-Alphabet - Beispiel: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat\nDateiinhalt: - RouterIdentity (router-Hash, Verschlüsselungsschlüssel, Signaturschlüssel) - Veröffentlichungszeitstempel - router-Adressen (IP, Port, Transporttyp) - router-Fähigkeiten und Optionen - Signatur, die alle oben genannten Daten abdeckt\nAnforderungen an die Netzwerkdiversität Um Netzwerkzentralisierung zu verhindern und die Erkennung von Sybil-Angriffen zu ermöglichen:\nKeine vollständigen NetDb-Dumps: Niemals alle RouterInfos an einen einzelnen Client ausliefern Zufällige Auswahl: Jedes Bündel enthält eine andere Teilmenge der verfügbaren Peers Minimale Bündelgröße: 75 RouterInfos (erhöht von ursprünglich 50) Maximale Bündelgröße: 100 RouterInfos Aktualität: RouterInfos sollten aktuell sein (innerhalb von 24 Stunden nach der Erstellung) Überlegungen zu IPv6 Aktueller Status (2025): - Mehrere Reseed-Server reagieren über IPv6 nicht - Clients sollten aus Zuverlässigkeitsgründen IPv4 bevorzugen oder erzwingen - IPv6-Unterstützung wird für neue Bereitstellungen empfohlen, ist aber nicht kritisch\nImplementierungshinweis: Beim Konfigurieren von Dual-Stack-Servern stellen Sie sicher, dass sowohl die IPv4- als auch die IPv6-Bind-Adressen korrekt funktionieren oder deaktivieren Sie IPv6, wenn es nicht ordnungsgemäß unterstützt werden kann.\nSicherheitsüberlegungen Bedrohungsmodell Das reseed protocol (Reseed‑Protokoll, Mechanismus zum Erstbezug von Peer‑Informationen für I2P) schützt vor:\nMan-in-the-Middle-Angriffe: RSA-4096-Signaturen verhindern die Manipulation von Bundles Netzwerkpartitionierung: Mehrere unabhängige Reseed-Server verhindern einen einzelnen Kontrollpunkt Sybil-Angriffe: Die Vielfalt der Bundles begrenzt die Fähigkeit des Angreifers, Nutzer zu isolieren Zensur: Mehrere Server und alternative Methoden sorgen für Redundanz Das Reseed-Protokoll schützt NICHT vor:\nKompromittierte reseed-Server (Server für die Erstinitialisierung ins I2P-Netzwerk): Wenn ein Angreifer die privaten Schlüssel der reseed-Zertifikate kontrolliert Vollständige Netzblockade: Wenn alle reseed-Methoden in einer Region blockiert sind Langfristige Überwachung: reseed-Anfragen geben die IP-Adresse des Nutzers preis, der versucht, I2P beizutreten Zertifikatsverwaltung Sicherheit privater Schlüssel: - SU3-Signaturschlüssel offline aufbewahren, wenn sie nicht verwendet werden - Starke Passwörter für die Schlüsselverschlüsselung verwenden - Sichere Backups von Schlüsseln und Zertifikaten vorhalten - Für hochwertige Bereitstellungen Hardware-Sicherheitsmodule (HSMs) in Betracht ziehen\nZertifikatswiderruf: - Zertifikatsperrlisten (CRLs) werden über einen News-Feed verteilt - Kompromittierte Zertifikate können vom Koordinator widerrufen werden - Routers aktualisieren CRLs bei Software-Updates automatisch\nMaßnahmen zur Angriffsabwehr DDoS-Schutz: - fail2ban-Regeln für exzessive Anfragen - Rate-Limiting auf Webserver-Ebene - Verbindungsbegrenzungen pro IP-Adresse - Cloudflare oder ein ähnliches CDN als zusätzliche Schutzschicht\nScraping-Schutz: - Unterschiedliche Bundles pro anfragender IP-Adresse - Zeitbasierte Zwischenspeicherung von Bundles pro IP-Adresse - Protokollierung von Mustern, die auf Scraping-Versuche hindeuten - Koordination mit anderen Betreibern bei erkannten Angriffen\nTests und Validierung Testen Ihres Reseed-Servers Methode 1: Neuinstallation des Routers I2P auf einem sauberen System installieren Ihre reseed URL (Quelle für die initiale Peer-/Netzwerk-Information) zur Konfiguration hinzufügen Andere reseed URLs entfernen oder deaktivieren Den router starten und die Protokolle auf ein erfolgreiches reseed überwachen Innerhalb von 5–10 Minuten die Verbindung zum Netzwerk überprüfen Erwartete Logausgabe:\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received Methode 2: Manuelle SU3-Validierung # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) Methode 3: checki2p-Monitoring Der Dienst unter https://checki2p.com/reseed führt alle 4 Stunden automatisierte Prüfungen auf allen registrierten I2P-Reseed-Servern durch. Dies ermöglicht:\nVerfügbarkeitsüberwachung Metriken zur Antwortzeit TLS-Zertifikatsvalidierung Überprüfung der SU3-Signatur Historische Betriebszeitdaten Sobald Ihr Reseed-Server (Server zum Initialisieren der netDb) beim I2P-Projekt registriert ist, erscheint er innerhalb von 24 Stunden automatisch auf checki2p.\nFehlerbehebung bei häufigen Problemen Problem: \u0026ldquo;Unable to read signing key\u0026rdquo; beim ersten Start - Lösung: Das ist erwartetes Verhalten. Antworten Sie mit \u0026lsquo;y\u0026rsquo;, um neue Schlüssel zu erzeugen.\nProblem: Router kann Signatur nicht verifizieren - Ursache: Zertifikat nicht im Vertrauensspeicher des Routers - Lösung: Zertifikat im Verzeichnis ~/.i2p/certificates/reseed/ ablegen\nProblem: Dasselbe Bundle wird an verschiedene Clients ausgeliefert - Ursache: X-Forwarded-For-Header wird nicht korrekt weitergegeben - Lösung: Aktiviere --trustProxy und konfiguriere die Reverse-Proxy-Header\nProblem: \u0026ldquo;Connection refused\u0026rdquo;-Fehler - Ursache: Port vom Internet aus nicht erreichbar - Lösung: Firewall-Regeln prüfen, Portweiterleitung überprüfen\nProblem: Hohe CPU-Auslastung während des Bundle-Neuaufbaus - Ursache: Normales Verhalten beim Generieren von 350+ SU3-Varianten - Lösung: Ausreichende CPU-Ressourcen sicherstellen, ggf. die Neuaufbaufrequenz reduzieren\nReferenzinformationen Offizielle Dokumentation Leitfaden für Reseed-Mitwirkende: /guides/creating-and-running-an-i2p-reseed-server/ Anforderungen der Reseed-Richtlinie: /guides/reseed-policy/ SU3-Spezifikation: /docs/specs/updates/ Repository für Reseed-Tools: https://i2pgit.org/idk/reseed-tools Dokumentation der Reseed-Tools: https://eyedeekay.github.io/reseed-tools/ Alternative Implementierungen PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Python-WSGI-Reseed-Server: https://github.com/torbjo/i2p-reseeder Community-Ressourcen I2P-Forum: https://i2pforum.net/ Gitea-Repository: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: #i2p-dev auf IRC2P Statusüberwachung: https://checki2p.com/reseed Versionsverlauf 0.9.14 (2014): SU3-Reseed-Format eingeführt 0.9.16 (2014): Dateibasiertes Reseeding hinzugefügt 0.9.42 (2019): Erfordernis des Abfrageparameters \u0026lsquo;Network ID\u0026rsquo; 2.0.0 (2022): SSU2-Transportprotokoll eingeführt 2.4.0 (2024): NetDB-Isolation und Sicherheitsverbesserungen 2.6.0 (2024): I2P-over-Tor-Verbindungen blockiert 2.10.0 (2025): Aktuelle stabile Version (Stand: September 2025) Signaturtypen-Referenz Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 **Reseed-Standard**: Typ 6 (RSA-SHA512-4096) ist für Reseed-Bundles erforderlich. Danksagung Vielen Dank an alle Reseed-Operatoren (Betreiber von Reseed-Servern) dafür, dass sie das Netzwerk zugänglich und widerstandsfähig halten. Besondere Anerkennung für die folgenden Mitwirkenden und Projekte:\nzzz: Langjähriger I2P-Entwickler und Reseed-Koordinator (Reseed: initiale Befüllung der netDb über Seed-Server) idk: Aktueller Maintainer von reseed-tools und Release-Manager Nguyen Phong Hoang: Forschung zu zensurresistenten Reseed-Strategien PurpleI2P Team: Alternative I2P-Implementierungen und -Werkzeuge checki2p: Automatisierter Überwachungsdienst für die Reseed-Infrastruktur Die dezentrale Reseed-Infrastruktur (Reseed = initiale Beschaffung von netDb-Peers zum Start ins Netzwerk) des I2P-Netzwerks ist das Ergebnis der Zusammenarbeit Dutzender Betreiber weltweit und stellt sicher, dass neue Nutzer unabhängig von lokaler Zensur oder technischen Hürden stets einen Weg finden, dem Netzwerk beizutreten.\n","description":"Betrieb von Reseed-Diensten und alternativen Bootstrap-Methoden","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"Reseed-Hosts","url":"/de/docs/misc/reseed/"},{"categories":null,"content":"Zweck: Konsistenz, Genauigkeit und Barrierefreiheit in der technischen I2P-Dokumentation sicherstellen\nGrundprinzipien 1. Alles überprüfen Niemals etwas annehmen oder raten. Alle technischen Aussagen müssen anhand folgender Quellen verifiziert werden: - Aktueller I2P-Quellcode (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master ) - Offizielle API-Dokumentation (https://i2p.github.io/i2p.i2p/ - Konfigurationsspezifikationen /docs/specs/ - Aktuelle Versionshinweise /releases/ Beispiel für eine korrekte Verifizierung:\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. Klarheit vor Kürze Schreiben Sie für Entwicklerinnen und Entwickler, die I2P möglicherweise zum ersten Mal kennenlernen. Erklären Sie die Konzepte umfassend, statt Vorwissen vorauszusetzen.\nBeispiel:\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. Barrierefreiheit zuerst Die Dokumentation muss für Entwickler im Clearnet (normales Internet) zugänglich sein, obwohl I2P ein Overlay-Netzwerk ist. Stellen Sie stets über das Clearnet zugängliche Alternativen zu I2P-internen Ressourcen bereit.\nTechnische Richtigkeit API- und Schnittstellendokumentation Immer angeben: 1. Vollständige Paketnamen bei der ersten Erwähnung: net.i2p.app.ClientApp 2. Vollständige Methodensignaturen mit Rückgabetypen 3. Parameternamen und -typen 4. Erforderliche vs. optionale Parameter\nBeispiel:\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. Konfigurationseigenschaften Beim Dokumentieren von Konfigurationsdateien: 1. Exakte Eigenschaftsnamen angeben 2. Dateizeichenkodierung angeben (UTF-8 für I2P-Konfigurationsdateien) 3. Vollständige Beispiele bereitstellen 4. Standardwerte dokumentieren 5. Version vermerken, in der Eigenschaften eingeführt/geändert wurden\nBeispiel:\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) Konstanten und Aufzählungen Verwenden Sie beim Dokumentieren von Konstanten die tatsächlichen Namen im Code:\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; Ähnliche Konzepte voneinander unterscheiden I2P hat mehrere sich überschneidende Systeme. Stellen Sie immer klar, welches System Sie dokumentieren:\nBeispiel:\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations Dokumentations-URLs und Referenzen Regeln für die Erreichbarkeit von URLs Primäre Referenzen sollten im Clearnet erreichbare URLs verwenden I2P-interne URLs (.i2p-Domains) müssen Hinweise zur Erreichbarkeit enthalten Immer Alternativen bereitstellen, wenn auf I2P-interne Ressourcen verlinkt wird Vorlage für I2P-interne URLs:\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ Empfohlene I2P-Referenz-URLs Offizielle Spezifikationen: - Konfiguration - Plugin - Dokumentenindex API-Dokumentation (jeweils die aktuellste wählen): - Aktuellste: https://i2p.github.io/i2p.i2p/ (API 0.9.66 mit Stand I2P 2.10.0) - Clearnet-Spiegel: https://eyedeekay.github.io/javadoc-i2p/ Quellcode: - GitLab (offiziell): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master - GitHub-Spiegel: https://github.com/i2p/i2p.i2p Standards für Linkformate ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text Versionsverfolgung Dokumentmetadaten Jedes technische Dokument sollte im frontmatter (Metadaten-Block am Dokumentanfang) Versionsmetadaten enthalten:\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Felddefinitionen: - lastUpdated: Jahr und Monat, in dem das Dokument zuletzt überprüft/aktualisiert wurde - accurateFor: I2P-Version, gegen die das Dokument verifiziert wurde - reviewStatus: Eines von \u0026ldquo;draft\u0026rdquo;, \u0026ldquo;needs-review\u0026rdquo;, \u0026ldquo;verified\u0026rdquo;, \u0026ldquo;outdated\u0026rdquo;\nVersionsverweise im Inhalt Bei Versionsangaben: 1. Setze die aktuelle Version in Fettschrift: \u0026ldquo;Version 2.10.0 (September 2025)\u0026rdquo; 2. Gib bei historischen Verweisen sowohl die Versionsnummer als auch das Datum an 3. Führe die API-Version, falls relevant, getrennt von der I2P-Version auf\nBeispiel:\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. Änderungen im Laufe der Zeit dokumentieren Für Funktionen, die sich weiterentwickelt haben:\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients Abkündigungshinweise Beim Dokumentieren veralteter Funktionen:\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. Terminologiestandards Offizielle I2P-Begriffe Verwenden Sie diese exakten Begriffe durchgängig:\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address ### Terminologie für verwaltete Clients Bei der Dokumentation verwalteter Clients:\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory ### Konfigurationsbegriffe Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config ### Paket- und Klassennamen Verwenden Sie bei der ersten Erwähnung immer den vollqualifizierten Namen, danach die Kurzform:\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... Codebeispiele und Formatierung Java-Codebeispiele Verwenden Sie eine korrekte Syntaxhervorhebung und vollständige Beispiele:\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` Anforderungen an Codebeispiele: 1. Kommentare hinzufügen, die wichtige Zeilen erklären 2. Fehlerbehandlung zeigen, wo relevant 3. Realistische Variablennamen verwenden 4. I2P-Codekonventionen einhalten (Einrückung mit 4 Leerzeichen) 5. Import-Anweisungen angeben, falls nicht aus dem Kontext ersichtlich\nKonfigurationsbeispiele Vollständige, gültige Konfigurationsbeispiele anzeigen:\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` Beispiele für die Kommandozeile Verwenden Sie $ für Benutzerbefehle, # für root:\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` Inline-Code Verwenden Sie Backticks für: - Methodennamen: startup() - Klassennamen: ClientApp - Eigenschaftsnamen: clientApp.0.main - Dateinamen: clients.config - Konstanten: SVC_HTTP_PROXY - Paketnamen: net.i2p.app\nTonfall und Stimme Professionell, aber zugänglich Schreiben Sie für ein technisches Fachpublikum, ohne herablassend zu wirken:\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; Aktiv Verwenden Sie die Aktivform für mehr Klarheit:\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; Imperativ für Anweisungen Verwenden Sie direkte Imperative in prozeduralen Inhalten:\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; Unnötigen Fachjargon vermeiden Begriffe bei der ersten Erwähnung erläutern:\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) Richtlinien zur Zeichensetzung Keine Em-Dashes (Geviertstriche) - stattdessen normale Bindestriche, Kommas oder Semikolons verwenden Oxford-Komma in Aufzählungen verwenden: \u0026ldquo;console, i2ptunnel, and Jetty\u0026rdquo; Punkte innerhalb von Codeblöcken nur, wenn es grammatisch notwendig ist Serielle Listen verwenden Semikolons, wenn Elemente Kommas enthalten Dokumentstruktur Standardreihenfolge der Abschnitte Für die API-Dokumentation:\nÜbersicht - was die Funktion tut, warum sie existiert Implementierung - wie man sie implementiert/verwendet Konfiguration - wie man sie konfiguriert API-Referenz - detaillierte Beschreibungen von Methoden und Eigenschaften Beispiele - vollständige, lauffähige Beispiele Bewährte Vorgehensweisen - Tipps und Empfehlungen Versionsverlauf - wann eingeführt, Änderungen im Laufe der Zeit Referenzen - Links zu verwandter Dokumentation Überschriftenhierarchie Verwenden Sie semantische Überschriftenebenen:\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** Informationskästen Verwenden Sie Blockzitate für besondere Hinweise:\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. Listen und Organisation Ungeordnete Listen für nicht-sequenzielle Elemente:\n- First item - Second item - Third item Geordnete Listen für sequentielle Schritte:\n1. First step 2. Second step 3. Third step Definitionslisten für Begriffserläuterungen:\n**Term One** : Explanation of term one **Term Two** : Explanation of term two Häufige Fallstricke, die es zu vermeiden gilt 1. Verwechslungsgefahr mit ähnlichen Systemen Nicht verwechseln: - ClientAppManager-Register vs. PortMapper - i2ptunnel tunnel-Typen vs. PortMapper-Dienstkonstanten - ClientApp vs. RouterApp (verschiedene Kontexte) - Verwaltete vs. nicht verwaltete Clients\nStelle immer klar, welches System du besprichst:\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. Veraltete Versionsverweise Nicht: - Alte Versionen als \u0026ldquo;aktuell\u0026rdquo; bezeichnen - Auf veraltete API-Dokumentation verlinken - In Beispielen veraltete Methodensignaturen verwenden\nZu erledigen: - Vor der Veröffentlichung die Versionshinweise prüfen - Überprüfen, ob die API-Dokumentation der aktuellen Version entspricht - Beispiele aktualisieren, damit sie die aktuellen bewährten Verfahren verwenden\n3. Unerreichbare URLs Nicht: - Nur auf .i2p Domains ohne Clearnet-Alternativen verlinken - Defekte oder veraltete Dokumentations-URLs verwenden - Auf lokale file:// Pfade verlinken\nDas sollten Sie tun: - Stellen Sie für alle I2P-internen Links Clearnet-Alternativen bereit - Überprüfen Sie vor der Veröffentlichung, dass URLs erreichbar sind - Verwenden Sie dauerhafte URLs (geti2p.net, kein temporäres Hosting)\n4. Unvollständige Codebeispiele Nicht: - Fragmente ohne Kontext zeigen - Fehlerbehandlung weglassen - Undefinierte Variablen verwenden - Import-Anweisungen auslassen, wenn sie nicht offensichtlich sind\nDas sollten Sie tun: - Zeigen Sie vollständige, kompilierbare Beispiele - Fügen Sie die erforderliche Fehlerbehandlung ein - Erklären Sie, was jede wichtige Zeile bewirkt - Testen Sie die Beispiele vor der Veröffentlichung\n5. Mehrdeutige Aussagen ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; Markdown-Konventionen Dateibenennung Verwende kebab-case (Kleinbuchstaben mit Bindestrichen) für Dateinamen: - managed-clients.md - port-mapper-guide.md - configuration-reference.md\nFrontmatter-Format (Metadatenblock am Dokumentanfang) Immer YAML-Frontmatter einfügen:\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Linkformatierung Interne Links (innerhalb der Dokumentation):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) Externe Links (zu anderen Ressourcen):\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) Links zu Code-Repositories:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) Tabellenformatierung Verwenden Sie Tabellen im GitHub‑Flavored Markdown (eine von GitHub erweiterte Markdown-Variante):\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | Sprach-Tags für Codeblöcke Geben Sie für die Syntaxhervorhebung immer die Sprache an:\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` Review-Checkliste Bevor Sie die Dokumentation veröffentlichen, überprüfen Sie:\nAlle technischen Aussagen sind anhand des Quellcodes oder der offiziellen Dokumentation verifiziert Versionsnummern und Datumsangaben sind aktuell Alle URLs sind aus dem Clearnet erreichbar (oder Alternativen werden bereitgestellt) Codebeispiele sind vollständig und getestet Die Terminologie folgt den I2P-Konventionen Keine Em-Dashes (normale Bindestriche oder andere Satzzeichen verwenden) Frontmatter ist vollständig und korrekt Die Überschriftenhierarchie ist semantisch (h1 → h2 → h3) Listen und Tabellen sind korrekt formatiert Der Abschnitt Referenzen enthält alle zitierten Quellen Das Dokument folgt den Strukturleitlinien Der Ton ist professionell, aber zugänglich Ähnliche Konzepte werden klar voneinander abgegrenzt Keine defekten Links oder Referenzen Konfigurationsbeispiele sind gültig und aktuell Feedback: Falls Sie Probleme feststellen oder Vorschläge zu diesen Richtlinien haben, reichen Sie diese bitte über die offiziellen I2P-Entwicklungskanäle ein.\n","description":"Stellen Sie Konsistenz, Genauigkeit und Barrierefreiheit in der gesamten technischen I2P-Dokumentation sicher","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"Richtlinien zum Verfassen der I2P-Dokumentation","url":"/de/docs/writing-guidelines/"},{"categories":null,"content":"Diese Anleitung bietet einen Überblick über die I2P Router Console und ihre Konfigurationsseiten. Jeder Abschnitt erklärt, was die Seite macht und wofür sie gedacht ist, und hilft Ihnen zu verstehen, wie Sie Ihren I2P Router überwachen und konfigurieren können.\nZugriff auf die Router-Konsole Die I2P Router Console ist die zentrale Anlaufstelle für die Verwaltung und Überwachung Ihres I2P Routers. Standardmäßig ist sie unter I2P Router Console erreichbar, sobald Ihr I2P Router läuft.\nDie Startseite zeigt mehrere wichtige Bereiche an:\nAnwendungen - Schnellzugriff auf integrierte I2P-Anwendungen wie E-Mail, Torrents, Hidden Services Manager und Webserver I2P-Community-Seiten - Links zu wichtigen Community-Ressourcen einschließlich Foren, Dokumentation und Projekt-Websites Konfiguration und Hilfe - Werkzeuge zur Konfiguration von Bandbreiteneinstellungen, Verwaltung von Plugins und Zugriff auf Hilferessourcen Netzwerk- und Entwicklerinformationen - Zugriff auf Graphen, Protokolle, technische Dokumentation und Netzwerkstatistiken Adressbuch URL: Address Book Das I2P-Adressbuch funktioniert ähnlich wie DNS im Clearnet und ermöglicht es Ihnen, lesbare Namen für I2P-Ziele (eepsites) zu verwalten. Hier können Sie I2P-Adressen in Ihrem persönlichen Adressbuch anzeigen und hinzufügen.\nDas Adressbuch-System funktioniert über mehrere Ebenen:\nLokale Einträge - Ihre persönlichen Adressbücher, die nur auf Ihrem Router gespeichert werden\nLokales Adressbuch - Hosts, die Sie manuell hinzufügen oder für Ihre eigene Verwendung speichern Privates Adressbuch - Adressen, die Sie nicht mit anderen teilen möchten; werden niemals öffentlich verteilt Subscriptions - Remote-Adressbuchquellen (wie http://i2p-projekt.i2p/hosts.txt), die das Adressbuch deines Routers automatisch mit bekannten I2P-Sites aktualisieren\nRouter Addressbook - Das zusammengeführte Ergebnis Ihrer lokalen Einträge und Abonnements, durchsuchbar von allen I2P-Anwendungen auf Ihrem Router\nPublished Addressbook - Optionales öffentliches Teilen Ihres Adressbuchs, damit andere es als Abonnementquelle nutzen können (nützlich, wenn Sie eine I2P-Seite betreiben)\nDas Adressbuch fragt regelmäßig Ihre Abonnements ab und fügt Inhalte in Ihr Router-Adressbuch ein, sodass Ihre hosts.txt-Datei mit dem I2P-Netzwerk auf dem neuesten Stand bleibt.\nKonfiguration URL: Erweiterte Konfiguration Der Konfigurationsbereich bietet über mehrere spezialisierte Registerkarten Zugriff auf alle Router-Einstellungen.\nAdvanced Die Seite für erweiterte Konfiguration bietet Zugriff auf systemnahe Router-Einstellungen, die für den normalen Betrieb normalerweise nicht benötigt werden. Die meisten Benutzer sollten diese Einstellungen nicht ändern, sofern sie die jeweilige Konfigurationsoption und deren Auswirkungen auf das Router-Verhalten nicht verstehen.\nHauptmerkmale:\nFloodfill-Konfiguration - Legen Sie fest, ob Ihr Router als Floodfill-Peer teilnimmt, der das Netzwerk unterstützt, indem er Informationen der Netzwerkdatenbank (netDb) speichert und verteilt. Dies kann mehr Systemressourcen verbrauchen, stärkt aber das I2P-Netzwerk.\nErweiterte I2P-Konfiguration - Direkter Zugriff auf die router.config-Datei mit allen erweiterten Konfigurationsparametern, einschließlich:\nBandbreitenlimits und Burst-Einstellungen Transport-Einstellungen (NTCP2, SSU2, UDP-Ports und Schlüssel) Router-Identifikation und Versionsinformationen Konsolenpräferenzen und Update-Einstellungen Die meisten erweiterten Konfigurationsoptionen werden in der Benutzeroberfläche nicht angezeigt, da sie selten benötigt werden. Um die Bearbeitung dieser Einstellungen zu aktivieren, müssen Sie routerconsole.advanced=true manuell zu Ihrer router.config-Datei hinzufügen.\nWarnung: Fehlerhafte Änderungen an erweiterten Einstellungen können die Leistung oder Konnektivität Ihres Routers negativ beeinflussen. Ändern Sie diese Einstellungen nur, wenn Sie wissen, was Sie tun.\nBandwidth URL: Bandbreiten-Konfiguration Die Bandwidth-Konfigurationsseite ermöglicht es Ihnen zu steuern, wie viel Bandbreite Ihr Router zum I2P-Netzwerk beiträgt. I2P funktioniert am besten, wenn Sie Ihre Raten entsprechend der Geschwindigkeit Ihrer Internetverbindung konfigurieren.\nWichtige Einstellungen:\nKBps In - Maximale eingehende Bandbreite, die Ihr Router akzeptiert (Download-Geschwindigkeit) KBps Out - Maximale ausgehende Bandbreite, die Ihr Router verwendet (Upload-Geschwindigkeit) Share - Prozentsatz Ihrer ausgehenden Bandbreite, der für Participatory Traffic dediziert ist (hilft beim Routen von Traffic für andere) Wichtige Hinweise:\nAlle Werte sind in Bytes pro Sekunde (KBps), nicht Bits pro Sekunde Je mehr Bandbreite Sie zur Verfügung stellen, desto mehr helfen Sie dem Netzwerk und verbessern Ihre eigene Anonymität Ihre Upload-Bandbreite (KBps Out) bestimmt Ihren Gesamtbeitrag zum Netzwerk Wenn Sie sich über die Geschwindigkeit Ihres Netzwerks unsicher sind, verwenden Sie den Bandbreitentest, um sie zu messen Höhere Bandbreite verbessert sowohl Ihre Anonymität als auch die Stärke des I2P-Netzwerks Die Konfigurationsseite zeigt die geschätzte monatliche Datenübertragung basierend auf Ihren Einstellungen an und hilft Ihnen dabei, die Bandbreitenzuteilung entsprechend den Limits Ihres Internetvertrags zu planen.\nClient Configuration URL: Client-Konfiguration Die Client-Konfigurationsseite ermöglicht es Ihnen zu steuern, welche I2P-Anwendungen und -Dienste beim Start ausgeführt werden. Hier können Sie integrierte I2P-Clients aktivieren oder deaktivieren, ohne sie zu deinstallieren.\nWichtige Warnung: Seien Sie vorsichtig beim Ändern der Einstellungen hier. Die Router-Konsole und Anwendungs-Tunnel werden für die meisten Verwendungszwecke von I2P benötigt. Nur fortgeschrittene Benutzer sollten diese Einstellungen ändern.\nVerfügbare Clients:\nApplication tunnels - Das I2PTunnel-System, das Client- und Server-Tunnel verwaltet (HTTP-Proxy, IRC, etc.) I2P Router Console - Die webbasierte Administrationsoberfläche, die Sie gerade verwenden I2P webserver (eepsite) - Eingebauter Jetty-Webserver zum Hosten Ihrer eigenen I2P-Website Open Router Console in web browser at startup - Startet automatisch Ihren Browser mit der Konsolen-Startseite SAM application bridge - API-Brücke für Drittanbieter-Anwendungen zur Verbindung mit I2P Jeder Client zeigt: - Beim Start ausführen? - Kontrollkästchen zum Aktivieren/Deaktivieren des automatischen Starts - Steuerung - Start/Stopp-Schaltflächen für sofortige Kontrolle - Klasse und Argumente - Technische Details darüber, wie der Client gestartet wird\nÄnderungen an der Einstellung „Beim Start ausführen?\u0026quot; erfordern einen Neustart des Routers, um wirksam zu werden. Alle Änderungen werden in /var/lib/i2p/i2p-config/clients.config.d/ gespeichert.\nErweitert URL: I2CP-Konfiguration Die I2CP (I2P Client Protocol) Konfigurationsseite ermöglicht es Ihnen, zu konfigurieren, wie externe Anwendungen sich mit Ihrem I2P-Router verbinden. I2CP ist das Protokoll, das Anwendungen verwenden, um mit dem Router zu kommunizieren, um Tunnel zu erstellen und Daten über I2P zu senden/empfangen.\nWichtig: Die Standardeinstellungen funktionieren für die meisten Benutzer. Alle hier vorgenommenen Änderungen müssen auch in der externen Client-Anwendung konfiguriert werden. Viele Clients unterstützen weder SSL noch Authentifizierung. Alle Änderungen erfordern einen Neustart, um wirksam zu werden.\nKonfigurationsoptionen:\nExterne I2CP-Schnittstellen-Konfiguration\nAktiviert ohne SSL - Standard-I2CP-Zugriff (Standard und am kompatibelsten) Aktiviert mit erforderlichem SSL - Nur verschlüsselte I2CP-Verbindungen Deaktiviert - Blockiert externe Clients bei der Verbindung über I2CP I2CP Interface - Die Netzwerkschnittstelle, auf der gelauscht werden soll (Standard: 127.0.0.1 nur für localhost)\nI2CP Port - Die Portnummer für I2CP-Verbindungen (Standard: 7654)\nAutorisierung\nBenutzername und Passwort erforderlich - Authentifizierung für I2CP-Verbindungen aktivieren Benutzername - Erforderlichen Benutzernamen für I2CP-Zugriff festlegen Passwort - Erforderliches Passwort für I2CP-Zugriff festlegen Sicherheitshinweis: Wenn Sie Anwendungen nur auf demselben Rechner wie Ihren I2P-Router ausführen, lassen Sie die Schnittstelle auf 127.0.0.1 gesetzt, um Fernzugriff zu verhindern. Ändern Sie diese Einstellungen nur, wenn Sie I2P-Anwendungen von anderen Geräten die Verbindung zu Ihrem Router ermöglichen müssen.\nBandbreite URL: Netzwerkkonfiguration Die Netzwerkkonfigurationsseite ermöglicht es Ihnen, zu konfigurieren, wie Ihr I2P-Router sich mit dem Internet verbindet, einschließlich IP-Adresserkennung, IPv4/IPv6-Einstellungen und Port-Einstellungen für sowohl UDP- als auch TCP-Transporte.\nExtern erreichbare IP-Adresse:\nAlle Auto-Erkennungsmethoden verwenden - Erkennt Ihre öffentliche IP automatisch mit mehreren Methoden (empfohlen) UPnP-IP-Adresserkennung deaktivieren - Verhindert die Verwendung von UPnP zur Erkennung Ihrer IP Lokale Netzwerkschnittstellen-IP-Adresse ignorieren - Verwendet nicht Ihre lokale Netzwerk-IP Nur SSU-IP-Adresserkennung verwenden - Verwendet nur den SSU2-Transport zur IP-Erkennung Versteckter Modus - IP nicht veröffentlichen - Verhindert die Teilnahme am Netzwerkverkehr (reduziert Anonymität) Hostname oder IP angeben - Manuelle Festlegung Ihrer öffentlichen IP oder Ihres Hostnamens IPv4-Konfiguration:\nEingehende Verbindungen deaktivieren (Firewalled) - Aktivieren Sie diese Option, wenn Sie sich hinter einer Firewall, einem Heimnetzwerk, ISP, DS-Lite oder Carrier-Grade NAT befinden, die eingehende Verbindungen blockieren IPv6-Konfiguration:\nIPv4 gegenüber IPv6 bevorzugen - Priorisiert IPv4-Verbindungen IPv6 gegenüber IPv4 bevorzugen - Priorisiert IPv6-Verbindungen (Standard für Dual-Stack-Netzwerke) IPv6 aktivieren - Erlaubt IPv6-Verbindungen IPv6 deaktivieren - Deaktiviert alle IPv6-Konnektivität Nur IPv6 verwenden (IPv4 deaktivieren) - Experimenteller IPv6-only-Modus Eingehende Verbindungen deaktivieren (Firewalled) - Prüfen Sie, ob Ihr IPv6 durch eine Firewall blockiert ist Aktion bei IP-Änderungen:\nLaptop-Modus - Experimentelle Funktion, die Router-Identität und UDP-Port bei IP-Wechsel ändert, um die Anonymität zu erhöhen UDP-Konfiguration:\nPort angeben - Einen bestimmten UDP-Port für SSU2-Transport festlegen (muss in Ihrer Firewall geöffnet werden) Komplett deaktivieren - Nur auswählen, wenn hinter einer Firewall, die alle ausgehenden UDP-Verbindungen blockiert TCP-Konfiguration:\nPort angeben - Legt einen bestimmten TCP-Port für NTCP2-Transport fest (muss in Ihrer Firewall geöffnet werden) Denselben Port wie für UDP verwenden - Vereinfacht die Konfiguration durch Verwendung eines Ports für beide Transporte Automatisch erkannte IP-Adresse verwenden - Erkennt automatisch Ihre öffentliche IP-Adresse (zeigt „derzeit unbekannt\u0026quot; an, wenn noch nicht erkannt oder durch Firewall blockiert) Immer automatisch erkannte IP-Adresse verwenden (Nicht durch Firewall geschützt) - Am besten für Router mit direktem Internetzugang Eingehende Verbindungen deaktivieren (Durch Firewall geschützt) - Aktivieren Sie dies, wenn TCP-Verbindungen durch Ihre Firewall blockiert werden Vollständig deaktivieren - Nur auswählen, wenn Sie sich hinter einer Firewall befinden, die ausgehende TCP-Verbindungen drosselt oder blockiert Hostname oder IP angeben - Konfigurieren Sie manuell Ihre von außen erreichbare Adresse Wichtig: Änderungen an den Netzwerkeinstellungen erfordern möglicherweise einen Router-Neustart, um vollständig wirksam zu werden. Eine ordnungsgemäße Port-Forwarding-Konfiguration verbessert die Leistung Ihres Routers erheblich und hilft dem I2P-Netzwerk.\nClient-Konfiguration URL: Peer-Konfiguration Die Peer-Konfigurationsseite bietet manuelle Steuerungsmöglichkeiten zur Verwaltung einzelner Peers im I2P-Netzwerk. Dies ist eine erweiterte Funktion, die typischerweise nur zur Fehlerbehebung bei problematischen Peers verwendet wird.\nManuelle Peer-Kontrollen:\nRouter Hash - Geben Sie den 44-stelligen Base64-Router-Hash des Peers ein, den Sie verwalten möchten Einen Peer manuell sperren / entsperren:\nDas Sperren eines Peers verhindert, dass dieser an von Ihnen erstellten Tunneln teilnimmt. Diese Aktion: - Verhindert, dass der Peer in Ihren Client- oder exploratory Tunnels verwendet wird - Tritt sofort in Kraft, ohne dass ein Neustart erforderlich ist - Bleibt bestehen, bis Sie den Peer manuell entsperren oder Ihren Router neu starten - Peer bis zum Neustart sperren - Blockiert den Peer temporär - Peer entsperren - Hebt die Sperre eines zuvor blockierten Peers auf\nProfilboni anpassen:\nProfil-Boni beeinflussen, wie Peers für die Tunnel-Teilnahme ausgewählt werden. Boni können positiv oder negativ sein: - Schnelle Peers - Werden für Client-Tunnel verwendet, die hohe Geschwindigkeit erfordern - Hochkapazitäts-Peers - Werden für einige Exploratory-Tunnel verwendet, die zuverlässiges Routing erfordern - Aktuelle Boni werden auf der Profilseite angezeigt\nKonfiguration: - Geschwindigkeit - Geschwindigkeitsbonus für diesen Peer anpassen (0 = neutral) - Kapazität - Kapazitätsbonus für diesen Peer anpassen (0 = neutral) - Peer-Boni anpassen - Bonus-Einstellungen anwenden\nAnwendungsfälle: - Sperren Sie einen Peer, der durchgehend Verbindungsprobleme verursacht - Schließen Sie vorübergehend einen Peer aus, den Sie für bösartig halten - Passen Sie Boni an, um leistungsschwache Peers herabzustufen - Beheben Sie Probleme beim Tunnel-Aufbau, indem Sie bestimmte Peers ausschließen\nHinweis: Die meisten Benutzer werden diese Funktion niemals verwenden müssen. Der I2P-Router verwaltet automatisch die Peer-Auswahl und -Profilerstellung basierend auf Leistungsmetriken.\nI2CP-Konfiguration URL: Reseed-Konfiguration Die Reseed-Konfigurationsseite ermöglicht es Ihnen, Ihren Router manuell zu reseeden, falls das automatische Reseeding fehlschlägt. Reseeding ist der Bootstrapping-Prozess, der verwendet wird, um andere Router zu finden, wenn Sie I2P zum ersten Mal installieren oder wenn Ihr Router zu wenige Router-Referenzen übrig hat.\nWann manuelles Reseed verwendet werden sollte:\nWenn das Reseeding fehlgeschlagen ist, sollten Sie zuerst Ihre Netzwerkverbindung überprüfen\nWenn eine Firewall Ihre Verbindungen zu Reseed-Hosts blockiert, haben Sie möglicherweise Zugriff auf einen Proxy:\nDer Proxy kann ein entfernter öffentlicher Proxy sein oder auf Ihrem Computer laufen (localhost) Um einen Proxy zu verwenden, konfigurieren Sie den Typ, Host und Port im Abschnitt Reseeding-Konfiguration Wenn Sie Tor Browser verwenden, führen Sie das Reseed darüber aus, indem Sie SOCKS 5, localhost, Port 9150 konfigurieren Wenn Sie Tor über die Befehlszeile verwenden, führen Sie das Reseed darüber aus, indem Sie SOCKS 5, localhost, Port 9050 konfigurieren Wenn Sie einige Peers haben, aber mehr benötigen, können Sie die I2P Outproxy-Option ausprobieren. Lassen Sie Host und Port leer. Dies funktioniert nicht für ein initiales Reseed, wenn Sie überhaupt keine Peers haben Klicken Sie dann auf \u0026ldquo;Änderungen speichern und jetzt reseeden\u0026rdquo; Die Standardeinstellungen funktionieren für die meisten Benutzer. Ändern Sie diese nur, wenn HTTPS durch eine restriktive Firewall blockiert wird und das Reseed fehlgeschlagen ist Wenn Sie jemanden kennen und ihm vertrauen, der I2P betreibt, bitten Sie ihn, Ihnen eine reseed-Datei zu senden, die auf dieser Seite in seiner router console generiert wurde. Verwenden Sie dann diese Seite, um mit der erhaltenen Datei ein reseed durchzuführen. Wählen Sie zunächst die Datei unten aus. Klicken Sie dann auf \u0026ldquo;Reseed from file\u0026rdquo;\nWenn Sie jemanden kennen und ihm vertrauen, der Reseed-Dateien veröffentlicht, fragen Sie ihn nach der URL. Verwenden Sie dann diese Seite, um mit der erhaltenen URL zu reseeden. Geben Sie zunächst die URL unten ein. Klicken Sie dann auf „Reseed from URL\u0026quot;\nSiehe die FAQ für Anweisungen zum manuellen Reseeding\nManuelle Reseed-Optionen:\nReseed von URL - Geben Sie eine ZIP- oder SU3-URL von einer vertrauenswürdigen Quelle ein und klicken Sie auf \u0026ldquo;Reseed von URL\u0026rdquo;\nDas SU3-Format wird bevorzugt, da es als von einer vertrauenswürdigen Quelle signiert verifiziert wird Das ZIP-Format ist nicht signiert; verwenden Sie eine ZIP-Datei nur von einer Quelle, der Sie vertrauen Reseed von Datei - Durchsuchen und Auswählen einer lokalen ZIP- oder SU3-Datei, dann auf „Reseed von Datei\u0026quot; klicken\nReseed-Dateien finden Sie unter checki2p.com/reseed Reseed-Datei erstellen - Erstellt eine neue Reseed-ZIP-Datei, die Sie mit anderen teilen können, damit diese manuell reseeden können\nDiese Datei wird niemals die Identität oder IP-Adresse Ihres eigenen Routers enthalten Reseeding-Konfiguration:\nDie Standardeinstellungen funktionieren für die meisten Benutzer. Ändern Sie diese nur, wenn HTTPS durch eine restriktive Firewall blockiert wird und das Reseed fehlgeschlagen ist.\nReseed-URLs - Liste von HTTPS-URLs zu Reseed-Servern (Standardliste ist eingebaut und wird regelmäßig aktualisiert) Proxy-Konfiguration - Konfigurieren Sie HTTP/HTTPS/SOCKS-Proxy, falls Sie über einen Proxy auf Reseed-Server zugreifen müssen URL-Liste zurücksetzen - Stellt die Standard-Reseed-Serverliste wieder her Wichtig: Manuelles Reseeding sollte nur in seltenen Fällen erforderlich sein, in denen das automatische Reseeding wiederholt fehlschlägt. Die meisten Benutzer werden diese Seite niemals benötigen.\nNetzwerkkonfiguration URL: Router Family Configuration Die Router Family Configuration Seite ermöglicht es Ihnen, Router-Familien zu verwalten. Router in derselben Familie teilen einen Family Key, der sie als von derselben Person oder Organisation betrieben kennzeichnet. Dies verhindert, dass mehrere von Ihnen kontrollierte Router für denselben Tunnel ausgewählt werden, was die Anonymität verringern würde.\nWas ist eine Router-Familie?\nWenn Sie mehrere I2P-Router betreiben, sollten Sie diese als Teil derselben Familie konfigurieren. Dies gewährleistet: - Ihre Router werden nicht zusammen im selben Tunnelpfad verwendet - Andere Benutzer behalten die ordnungsgemäße Anonymität, wenn ihre Tunnel Ihre Router verwenden - Das Netzwerk kann die Tunnelbeteiligung angemessen verteilen\nAktuelle Familie:\nDie Seite zeigt den aktuellen Router-Familiennamen an. Wenn Sie nicht Teil einer Familie sind, bleibt dieses Feld leer.\nFamily Key exportieren:\nExportieren Sie den geheimen Family-Schlüssel, um ihn in andere Router zu importieren, die Sie kontrollieren Klicken Sie auf \u0026ldquo;Export Family Key\u0026rdquo;, um Ihre Family-Schlüsseldatei herunterzuladen Importieren Sie diesen Schlüssel auf Ihren anderen Routern, um sie derselben Family hinzuzufügen Router-Familie verlassen:\nNicht länger Mitglied der Familie sein Klicken Sie auf \u0026ldquo;Familie verlassen\u0026rdquo;, um diesen Router aus seiner aktuellen Familie zu entfernen Diese Aktion kann nicht rückgängig gemacht werden, ohne den Familienschlüssel erneut zu importieren Wichtige Überlegungen:\nÖffentliche Registrierung erforderlich: Damit Ihre Familie netzwerkweit erkannt wird, muss Ihr Family-Key vom Entwicklungsteam in die I2P-Codebasis aufgenommen werden. Dadurch wird sichergestellt, dass alle Router im Netzwerk von Ihrer Familie wissen. Kontaktieren Sie das I2P-Team, um Ihren Family-Key registrieren zu lassen, wenn Sie mehrere öffentliche Router betreiben Die meisten Benutzer, die nur einen Router betreiben, werden diese Funktion niemals benötigen Die Family-Konfiguration wird hauptsächlich von Betreibern mehrerer öffentlicher Router oder Infrastrukturanbietern verwendet Anwendungsfälle:\nBetrieb mehrerer I2P-Router für Redundanz Betrieb von Infrastruktur wie Reseed-Servern oder Outproxies auf mehreren Maschinen Verwaltung eines Netzwerks von I2P-Routern für eine Organisation Peer-Konfiguration URL: Tunnel-Konfiguration Die Tunnel-Konfigurationsseite ermöglicht es Ihnen, die Standardeinstellungen für Tunnel anzupassen, sowohl für exploratory tunnels (die für die Router-Kommunikation verwendet werden) als auch für Client-Tunnel (die von Anwendungen verwendet werden). Die Standardeinstellungen funktionieren für die meisten Nutzer und sollten nur geändert werden, wenn Sie die Kompromisse verstehen.\nWichtige Warnhinweise:\n⚠️ Anonymität vs. Leistung - Kompromiss: Es gibt einen grundlegenden Kompromiss zwischen Anonymität und Leistung. Tunnel, die länger als 3 Hops sind (zum Beispiel 2 Hops + 0-2 Hops, 3 Hops + 0-1 Hops, 3 Hops + 0-2 Hops), oder eine hohe Anzahl + Backup-Anzahl, können die Leistung oder Zuverlässigkeit erheblich reduzieren. Eine hohe CPU- und/oder hohe ausgehende Bandbreitennutzung kann die Folge sein. Ändern Sie diese Einstellungen mit Vorsicht und passen Sie sie an, wenn Sie Probleme haben.\n⚠️ Persistenz: Änderungen an den Exploratory Tunnel-Einstellungen werden in der Datei router.config gespeichert. Client Tunnel-Änderungen sind temporär und werden nicht gespeichert. Um permanente Client Tunnel-Änderungen vorzunehmen, siehe die I2PTunnel-Seite .\nExploratorische Tunnel:\nExploratory Tunnels werden von Ihrem Router verwendet, um mit der netDb zu kommunizieren und am I2P-Netzwerk teilzunehmen.\nKonfigurationsoptionen für sowohl Inbound als auch Outbound: - Length - Anzahl der Hops im Tunnel (Standard: 2-3 Hops) - Randomization - Zufällige Varianz in der Tunnellänge (Standard: 0-1 Hops) - Quantity - Anzahl der aktiven Tunnel (Standard: 2 Tunnel) - Backup quantity - Anzahl der Backup-Tunnel, die zur Aktivierung bereitstehen (Standard: 0 Tunnel)\nClient-Tunnel für I2P-Webserver:\nDiese Einstellungen steuern die Tunnel für den eingebauten I2P-Webserver (eepsite).\n⚠️ ANONYMITÄTSWARNUNG - Einstellungen beinhalten 1-Hop-Tunnel. ⚠️ LEISTUNGSWARNUNG - Einstellungen beinhalten hohe Tunnelanzahlen.\nKonfigurationsoptionen für sowohl Inbound als auch Outbound: - Length - Tunnel-Länge (Standard: 1 Hop für Webserver) - Randomization - Zufällige Varianz in der Tunnel-Länge - Quantity - Anzahl aktiver Tunnel - Backup quantity - Anzahl der Backup-Tunnel\nClient-Tunnel für gemeinsam genutzte Clients:\nDiese Einstellungen gelten für gemeinsam genutzte Client-Anwendungen (HTTP-Proxy, IRC usw.).\nKonfigurationsoptionen für Inbound und Outbound: - Length - Tunnel-Länge (Standard: 3 Hops) - Randomization - Zufällige Varianz in der Tunnel-Länge - Quantity - Anzahl aktiver Tunnel - Backup quantity - Anzahl von Backup-Tunneln\nTunnel-Parameter verstehen:\nLänge: Längere Tunnel bieten mehr Anonymität, reduzieren jedoch Leistung und Zuverlässigkeit Randomisierung: Fügt Unvorhersehbarkeit zu Tunnelpfaden hinzu und verbessert die Sicherheit Anzahl: Mehr Tunnel verbessern Zuverlässigkeit und Lastverteilung, erhöhen jedoch die Ressourcennutzung Backup-Anzahl: Vorab erstellte Tunnel, die bereit sind, ausgefallene Tunnel zu ersetzen und die Ausfallsicherheit zu verbessern Best Practices:\nBehalten Sie die Standardeinstellungen bei, sofern Sie keine spezifischen Anforderungen haben Erhöhen Sie die Tunnellänge nur, wenn Anonymität kritisch ist und Sie langsamere Performance akzeptieren können Erhöhen Sie Anzahl/Backup nur bei häufigen Tunnelausfällen Überwachen Sie die Router-Performance nach Änderungen Klicken Sie auf \u0026ldquo;Änderungen speichern\u0026rdquo;, um Modifikationen anzuwenden Reseed-Konfiguration URL: UI-Konfiguration Die UI-Konfigurationsseite ermöglicht es Ihnen, das Erscheinungsbild und die Zugänglichkeit Ihrer Router-Konsole anzupassen, einschließlich Theme-Auswahl, Spracheinstellungen und Passwortschutz.\nRouter Console Theme:\nWählen Sie zwischen dunklen und hellen Themes für die Router Console-Oberfläche: - Dunkel - Dunkelmodus-Theme (angenehmer für die Augen bei schlechten Lichtverhältnissen) - Hell - Hellmodus-Theme (traditionelles Erscheinungsbild)\nZusätzliche Theme-Optionen: - Theme universell für alle Apps setzen - Wendet das ausgewählte Theme auf alle I2P-Anwendungen an, nicht nur auf die Router-Konsole - Mobile Konsole erzwingen - Verwendet die mobiloptimierte Oberfläche auch in Desktop-Browsern - E-Mail- und Torrent-Anwendungen in die Konsole einbetten - Integriert Susimail und I2PSnark direkt in die Konsolenoberfläche, anstatt sie in separaten Tabs zu öffnen\nRouter Console-Sprache:\nWählen Sie Ihre bevorzugte Sprache für die Router-Konsolen-Oberfläche aus dem Dropdown-Menü aus. I2P unterstützt viele Sprachen, darunter Englisch, Deutsch, Französisch, Spanisch, Russisch, Chinesisch, Japanisch und weitere.\nÜbersetzungsbeiträge willkommen: Wenn Sie unvollständige oder falsche Übersetzungen bemerken, können Sie helfen, I2P zu verbessern, indem Sie zum Übersetzungsprojekt beitragen. Kontaktieren Sie die Entwickler in #i2p-dev auf IRC oder prüfen Sie den Übersetzungsstatusbericht (verlinkt auf der Seite).\nRouter Console Passwort:\nFügen Sie Benutzernamen- und Passwort-Authentifizierung hinzu, um den Zugriff auf Ihre Router-Konsole zu schützen:\nBenutzername - Geben Sie den Benutzernamen für den Konsolenzugriff ein Passwort - Geben Sie das Passwort für den Konsolenzugriff ein Benutzer hinzufügen - Erstellen Sie einen neuen Benutzer mit den angegebenen Anmeldedaten Ausgewählte löschen - Entfernen Sie vorhandene Benutzerkonten Warum ein Passwort hinzufügen?\nVerhindert unbefugten lokalen Zugriff auf Ihre Router-Konsole Unverzichtbar, wenn mehrere Personen Ihren Computer nutzen Empfohlen, wenn Ihre Router-Konsole in Ihrem lokalen Netzwerk erreichbar ist Schützt Ihre I2P-Konfiguration und Datenschutzeinstellungen vor Manipulation Sicherheitshinweis: Der Passwortschutz betrifft nur den Zugriff auf die Weboberfläche der Router-Konsole unter I2P Router Console . Er verschlüsselt weder den I2P-Verkehr noch hindert er Anwendungen daran, I2P zu nutzen. Wenn Sie der einzige Benutzer Ihres Computers sind und die Router-Konsole nur auf localhost lauscht (Standardeinstellung), ist ein Passwort möglicherweise nicht erforderlich.\nRouter-Familien-Konfiguration URL: WebApp-Konfiguration Die WebApp-Konfigurationsseite ermöglicht es Ihnen, die Java-Webanwendungen zu verwalten, die innerhalb Ihres I2P-routers laufen. Diese Anwendungen werden vom webConsole-Client gestartet und laufen in derselben JVM wie der router, wodurch sie integrierte Funktionalität bereitstellen, die über die router-Konsole zugänglich ist.\nWas sind WebApps?\nWebApps sind Java-basierte Anwendungen, die sein können: - Vollständige Anwendungen (z.B. I2PSnark für Torrents) - Front-ends für andere Clients, die separat aktiviert werden müssen (z.B. Susidns, I2PTunnel) - Webanwendungen ohne Weboberfläche (z.B. Adressbuch)\nWichtige Hinweise:\nEine Webapp kann vollständig deaktiviert werden oder nur vom Start beim Hochfahren ausgeschlossen werden Das Entfernen einer War-Datei aus dem Webapps-Verzeichnis deaktiviert die Webapp vollständig Allerdings werden die .war-Datei und das Webapp-Verzeichnis wieder erscheinen, wenn Sie Ihren Router auf eine neuere Version aktualisieren Um eine Webapp dauerhaft zu deaktivieren: Deaktivieren Sie sie hier, was die bevorzugte Methode ist Verfügbare WebApps:\nWebApp Description i2psnark Torrents - Built-in BitTorrent client for I2P i2ptunnel Hidden Services Manager - Configure client and server tunnels imagegen Identification Image Generator - Creates unique identicons jsonrpc jsonrpc.war - JSON-RPC API interface (disabled by default) routerconsole I2P Router Console - The main administrative interface susidns Address Book - Manage I2P addresses and subscriptions susimail Email - Web-based email client for I2P Steuerung: Für jede Webapp: - Beim Start ausführen? - Kontrollkästchen zum Aktivieren/Deaktivieren des automatischen Starts - Steuerung - Start/Stopp-Schaltflächen für sofortige Kontrolle - Stopp - Stoppt die aktuell laufende Webapp - Start - Startet eine gestoppte Webapp\nKonfigurations-Buttons:\nAbbrechen - Änderungen verwerfen und zur vorherigen Seite zurückkehren WebApp-Konfiguration speichern - Ihre Änderungen speichern und anwenden Anwendungsfälle:\nStoppe I2PSnark, wenn du keine Torrents verwendest, um Ressourcen zu sparen Deaktiviere jsonrpc, wenn du keinen API-Zugriff benötigst Stoppe Susimail, wenn du einen externen E-Mail-Client verwendest Stoppe Webapps vorübergehend, um Speicher freizugeben oder Probleme zu beheben Performance-Tipp: Das Deaktivieren ungenutzter Webapps kann den Speicherverbrauch reduzieren und die Router-Performance verbessern, insbesondere auf Systemen mit begrenzten Ressourcen.\nHelp URL: Hilfe Die Hilfeseite bietet umfassende Dokumentation und Ressourcen, um Ihnen zu helfen, I2P effektiv zu verstehen und zu nutzen. Sie dient als zentrale Anlaufstelle für Fehlerbehebung, Lernen und Unterstützung.\nWas Sie finden werden:\nSchnellstart-Anleitung - Wesentliche Informationen für neue Benutzer, die mit I2P beginnen Häufig gestellte Fragen (FAQ) - Antworten auf häufige Fragen zur I2P-Installation, -Konfiguration und -Nutzung Fehlerbehebung - Lösungen für häufige Probleme und Verbindungsschwierigkeiten Technische Dokumentation - Detaillierte Informationen über I2P-Protokolle, Architektur und Spezifikationen Anwendungsleitfäden - Anleitungen zur Verwendung von I2P-Anwendungen wie Torrents, E-Mail und versteckten Diensten Netzwerkinformationen - Verstehen, wie I2P funktioniert und was es sicher macht Support-Ressourcen - Links zu Foren, IRC-Kanälen und Community-Support Hilfe erhalten:\nWenn Sie Probleme mit I2P haben: 1. Prüfen Sie die FAQ für häufig gestellte Fragen und Antworten 2. Sehen Sie sich den Abschnitt zur Fehlerbehebung für Ihr spezifisches Problem an 3. Besuchen Sie das I2P-Forum unter i2pforum.i2p oder i2pforum.net 4. Treten Sie dem IRC-Kanal #i2p für Community-Support in Echtzeit bei 5. Durchsuchen Sie die Dokumentation für detaillierte technische Informationen\nTipp: Die Hilfeseite ist immer über die Seitenleiste der Router-Konsole zugänglich, sodass Sie jederzeit problemlos Unterstützung finden können.\nPerformance Graphs URL: Performance Graphs Die Seite „Performance-Graphen\u0026quot; bietet eine visuelle Echtzeitüberwachung der Leistung Ihres I2P-Routers und der Netzwerkaktivität. Diese Graphen helfen Ihnen, die Bandbreitennutzung, Peer-Verbindungen, den Speicherverbrauch und den allgemeinen Zustand des Routers zu verstehen.\nVerfügbare Graphen:\nBandbreitennutzung\nLow-Level-Senderate (Bytes/Sek.) - Ausgehende Datenrate Low-Level-Empfangsrate (Bytes/Sek.) - Eingehende Datenrate Zeigt aktuelle, durchschnittliche und maximale Bandbreitenauslastung Hilft zu überwachen, ob Sie sich Ihren konfigurierten Bandbreitengrenzen nähern Aktive Peers\nrouter.activePeers gemittelt über 60 Sek - Anzahl der Peers, mit denen Sie aktiv kommunizieren Zeigt den Zustand Ihrer Netzwerkverbindung Mehr aktive Peers bedeuten in der Regel besseres Tunnel-Building und stärkere Netzwerkbeteiligung Router-Speichernutzung\nrouter.memoryUsed gemittelt über 60 Sek. - JVM-Speicherverbrauch Zeigt aktuelle, durchschnittliche und maximale Speichernutzung in MB an Nützlich zur Identifizierung von Speicherlecks oder zur Bestimmung, ob die Java-Heap-Größe erhöht werden muss Graph-Anzeige konfigurieren:\nPassen Sie an, wie Diagramme angezeigt und aktualisiert werden:\nDiagrammgröße - Breite (Standard: 400 Pixel) und Höhe (Standard: 100 Pixel) festlegen Anzeigezeitraum - Anzuzeigender Zeitbereich (Standard: 60 Minuten) Aktualisierungsintervall - Wie oft die Diagramme aktualisiert werden (Standard: 5 Minuten) Darstellungstyp - Wahl zwischen Durchschnittswerten oder Ereignisanzeige Legende ausblenden - Legende aus Diagrammen entfernen, um Platz zu sparen UTC - UTC-Zeit anstelle der lokalen Zeit in Diagrammen verwenden Persistenz - Diagrammdaten auf Festplatte speichern für historische Analyse Erweiterte Optionen:\nKlicken Sie auf [Select Stats], um auszuwählen, welche Statistiken grafisch dargestellt werden sollen: - Tunnel-Metriken (Build-Erfolgsrate, Tunnel-Anzahl, etc.) - netDb-Statistiken - Transport-Statistiken (NTCP2, SSU2) - Client-Tunnel-Performance - Und viele weitere detaillierte Metriken\nAnwendungsfälle:\nÜberwachen Sie die Bandbreite, um sicherzustellen, dass Sie Ihre konfigurierten Grenzwerte nicht überschreiten Überprüfen Sie die Peer-Konnektivität bei der Fehlersuche von Netzwerkproblemen Verfolgen Sie die Speichernutzung, um die Java-Heap-Einstellungen zu optimieren Identifizieren Sie Leistungsmuster im Zeitverlauf Diagnostizieren Sie Probleme beim Tunnel-Aufbau durch Korrelation der Graphen Tipp: Klicken Sie auf „Einstellungen speichern und Graphen neu zeichnen\u0026quot;, nachdem Sie Änderungen vorgenommen haben, um Ihre Konfiguration anzuwenden. Die Graphen werden automatisch basierend auf Ihrer Aktualisierungsverzögerung aktualisiert.\n","description":"Eine umfassende Anleitung zum Verstehen und Konfigurieren der I2P Router Console","id":"c46f1b6edeab9b686fd57cf9b311df1c","section":"docs","title":"Router Console Konfigurationsanleitung","url":"/de/docs/guides/router-console-config/"},{"categories":null,"content":"Übersicht Dieses Dokument bietet eine umfassende technische Spezifikation der I2P-Konfigurationsdateien, die vom router und verschiedenen Anwendungen verwendet werden. Es umfasst Spezifikationen zu Dateiformaten, Eigenschaftsdefinitionen sowie Implementierungsdetails, die anhand des I2P-Quellcodes und der offiziellen Dokumentation verifiziert wurden.\nGeltungsbereich Router-Konfigurationsdateien und -formate Konfigurationen von Client-Anwendungen I2PTunnel tunnel-Konfigurationen Spezifikationen und Implementierung von Dateiformaten Versionsspezifische Funktionen und Abkündigungen (Deprecations) Hinweise zur Implementierung Konfigurationsdateien werden mithilfe der Methoden DataHelper.loadProps() und storeProps() in der I2P-Kernbibliothek gelesen und geschrieben. Das Dateiformat unterscheidet sich erheblich von dem in I2P-Protokollen verwendeten serialisierten Format (siehe Spezifikation für gemeinsame Strukturen - Typzuordnung ).\nAllgemeines Format der Konfigurationsdatei I2P-Konfigurationsdateien folgen einem modifizierten Java-Properties-Format mit spezifischen Ausnahmen und Einschränkungen.\nFormatspezifikation Basierend auf Java Properties mit den folgenden wesentlichen Unterschieden:\nKodierung MUSS UTF-8-Kodierung verwenden (NICHT ISO-8859-1 wie bei Standard-Java-Properties) Implementierung: Verwendet die Hilfsfunktion DataHelper.getUTF8() für alle Dateioperationen Escape-Sequenzen Es werden KEINE Escape-Sequenzen erkannt (einschließlich Backslash \\) Zeilenfortsetzung wird NICHT unterstützt Backslash-Zeichen werden wörtlich behandelt Kommentarzeichen # leitet einen Kommentar an beliebiger Position in einer Zeile ein ; leitet einen Kommentar nur ein, wenn es in Spalte 1 steht ! leitet NICHT einen Kommentar ein (anders als bei Java Properties) Schlüssel-Wert-Trennzeichen = ist das EINZIGE gültige Schlüssel-Wert-Trennzeichen : wird NICHT als Trennzeichen erkannt Leerraum wird NICHT als Trennzeichen erkannt Umgang mit Whitespace (Leerraum) Führender und nachfolgender Leerraum wird bei Schlüsseln NICHT entfernt Führender und nachfolgender Leerraum WIRD bei Werten entfernt Zeilenverarbeitung Zeilen ohne = werden ignoriert (als Kommentare oder leere Zeilen behandelt) Leere Werte (key=) werden seit Version 0.9.10 unterstützt Schlüssel mit leeren Werten werden normal gespeichert und abgerufen Zeichenbeschränkungen Schlüssel dürfen NICHT enthalten: - # (Raute/Nummernzeichen) - = (Gleichheitszeichen) - \\n (Zeilenumbruchzeichen) - Dürfen nicht mit ; beginnen (Semikolon)\nWerte dürfen NICHT enthalten: - # (Raute/Nummernzeichen) - \\n (Zeilenumbruchzeichen) - dürfen nicht mit \\r (Wagenrücklauf) beginnen oder enden - dürfen nicht mit Leerraum beginnen oder enden (wird automatisch entfernt)\nDateisortierung Konfigurationsdateien müssen nicht nach Schlüsseln sortiert sein. Die meisten I2P-Anwendungen sortieren jedoch die Schlüssel beim Schreiben von Konfigurationsdateien alphabetisch, um Folgendes zu erleichtern: - Manuelle Bearbeitung - Diff-Vorgänge in der Versionskontrolle - Menschliche Lesbarkeit\nImplementierungsdetails Konfigurationsdateien lesen // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) Verhalten: - Liest UTF-8-kodierte Dateien - Erzwingt alle oben beschriebenen Formatregeln - Validiert die Zeichenbeschränkungen - Gibt ein leeres Properties-Objekt zurück, wenn die Datei nicht existiert - Löst bei Lesefehlern eine IOException aus\nErstellen von Konfigurationsdateien // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) Verhalten: - Schreibt UTF-8-kodierte Dateien - Sortiert Schlüssel alphabetisch (außer wenn OrderedProperties verwendet wird) - Setzt die Dateiberechtigungen auf Modus 600 (nur Lesen/Schreiben für den Benutzer) ab Version 0.8.1 - Wirft IllegalArgumentException bei ungültigen Zeichen in Schlüsseln oder Werten - Wirft IOException bei Schreibfehlern\nFormatvalidierung Die Implementierung führt eine strikte Validierung durch: - Schlüssel und Werte werden auf unzulässige Zeichen geprüft - Ungültige Einträge führen bei Schreibvorgängen zu Ausnahmen - Beim Lesen werden fehlerhafte Zeilen stillschweigend ignoriert (Zeilen ohne =)\nFormatbeispiele Gültige Konfigurationsdatei # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは Ungültige Konfigurationsbeispiele # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value Kernbibliothek und router-Konfiguration Client-Konfiguration (clients.config) Speicherort: $I2P_CONFIG_DIR/clients.config (veraltet) oder $I2P_CONFIG_DIR/clients.config.d/ (modern) Konfigurationsoberfläche: Router-Konsole unter /configclients Formatänderung: Version 0.9.42 (August 2019)\nVerzeichnisstruktur (Version 0.9.42+) Seit Version 0.9.42 wird die Standarddatei clients.config automatisch in einzelne Konfigurationsdateien aufgeteilt:\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) Migrationsverhalten: - Beim ersten Start nach einem Upgrade auf 0.9.42+ wird die monolithische Datei automatisch aufgeteilt - Eigenschaften in den aufgeteilten Dateien erhalten das Präfix clientApp.0. - Das alte Format wird weiterhin zur Wahrung der Rückwärtskompatibilität unterstützt - Das Split-Format ermöglicht modulare Paketierung und Plugin-Management\nEigenschaftsformat Zeilen haben das Format clientApp.x.prop=val, wobei x die App-Nummer ist.\nAnforderungen an die App-Nummerierung: - MUSS mit 0 beginnen - MUSS fortlaufend sein (keine Lücken) - Die Reihenfolge bestimmt die Startsequenz\nErforderliche Eigenschaften Haupt Typ: String (vollqualifizierter Klassenname) Erforderlich: Ja Beschreibung: Der Konstruktor oder die main()-Methode in dieser Klasse wird abhängig vom Client-Typ (verwaltet vs. nicht verwaltet) aufgerufen Beispiel: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner Optionale Eigenschaften Name Typ: String Erforderlich: Nein Beschreibung: Anzeigename, der in der Router-Konsole angezeigt wird Beispiel: clientApp.0.name=Router Console Argumente Typ: String (durch Leerzeichen oder Tabulator getrennt) Erforderlich: Nein Beschreibung: Argumente, die an den Konstruktor der Hauptklasse oder an die Methode main() übergeben werden Anführungszeichen: Argumente, die Leerzeichen oder Tabulatoren enthalten, können mit ' oder \u0026quot; in Anführungszeichen gesetzt werden Beispiel: clientApp.0.args=-d $CONFIG/eepsite Verzögerung Typ: Integer (Sekunden) Erforderlich: Nein Standardwert: 120 Beschreibung: Sekunden, die vor dem Start des Clients gewartet werden Übersteuerungen: Wird durch onBoot=true überschrieben (setzt Verzögerung auf 0) Besondere Werte: \u0026lt; 0: Warten, bis der router den RUNNING-Zustand erreicht, dann sofort in einem neuen Thread starten = 0: Sofort im selben Thread ausführen (Ausnahmen werden an die Konsole weitergereicht) \u0026gt; 0: Nach Verzögerung in neuem Thread starten (Ausnahmen werden protokolliert, nicht weitergereicht) onBoot Typ: Boolesch Erforderlich: Nein Standardwert: false Beschreibung: Erzwingt eine Verzögerung von 0 und setzt eine explizite Verzögerungseinstellung außer Kraft Anwendungsfall: Startet kritische Dienste sofort beim router-Start startOnLoad Typ: Boolesch Erforderlich: Nein Standardwert: true Beschreibung: Ob der Client überhaupt gestartet werden soll Anwendungsfall: Clients deaktivieren, ohne die Konfiguration zu entfernen Pluginspezifische Eigenschaften Diese Eigenschaften werden nur von Plugins verwendet (nicht von Kern-Clients):\nstopargs Typ: String (durch Leerzeichen oder Tabulator getrennt) Beschreibung: Argumente, die zum Stoppen des Clients übergeben werden Variablenersetzung: Ja (siehe unten) uninstallargs Typ: String (durch Leerzeichen oder Tabulator getrennt) Beschreibung: Argumente, die zur Deinstallation des Clients übergeben werden Variablenersetzung: Ja (siehe unten) Klassenpfad Typ: String (kommagetrennte Pfade) Beschreibung: Zusätzliche Classpath-Elemente für den Client Variablenersetzung: Ja (siehe unten) Variablensubstitution (nur für Plugins) Die folgenden Variablen werden in args, stopargs, uninstallargs und classpath für Plugins ersetzt:\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 **Hinweis**: Die Variablenersetzung wird nur für Plugins durchgeführt, nicht für Kern-Clients. Client-Typen Verwaltete Clients Der Konstruktor wird mit den Parametern RouterContext und ClientAppManager aufgerufen Der Client muss die Schnittstelle ClientApp implementieren Der Lebenszyklus wird vom router gesteuert Kann dynamisch gestartet, gestoppt und neu gestartet werden Nicht verwaltete Clients Methode main(String[] args) wird aufgerufen Wird in einem separaten Thread ausgeführt Lebenszyklus wird nicht vom router verwaltet Veralteter Client-Typ Beispielkonfiguration # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true Logger-Konfiguration (logger.config) Speicherort: $I2P_CONFIG_DIR/logger.config Konfigurationsoberfläche: Router-Konsole unter /configlogging\nEigenschaftsreferenz Konfiguration des Konsolenpuffers logger.consoleBufferSize Typ: Ganzzahl Standard: 20 Beschreibung: Maximale Anzahl von Protokollmeldungen, die in der Konsole gepuffert werden Bereich: 1-1000 empfohlen Datums- und Zeitformatierung logger.dateFormat Typ: String (SimpleDateFormat-Muster) Standardwert: Aus dem Systemgebietsschema Beispiel: HH:mm:ss.SSS Dokumentation: Java SimpleDateFormat Protokollierungsstufen logger.defaultLevel Typ: Enum Standardwert: ERROR Werte: CRIT, ERROR, WARN, INFO, DEBUG Beschreibung: Standard-Protokollierungsstufe für alle Klassen logger.minimumOnScreenLevel Typ: Enum (Aufzählungstyp) Standard: CRIT Werte: CRIT, ERROR, WARN, INFO, DEBUG Beschreibung: Mindeststufe für Meldungen, die auf dem Bildschirm angezeigt werden logger.record.{class} Typ: Aufzählungstyp Werte: CRIT, ERROR, WARN, INFO, DEBUG Beschreibung: Überschreiben der Protokollierungsstufe pro Klasse Beispiel: logger.record.net.i2p.router.transport.udp=DEBUG Anzeigeoptionen logger.displayOnScreen Typ: Boolesch Standard: true Beschreibung: Ob Protokollmeldungen in der Konsolenausgabe angezeigt werden logger.dropDuplicates Typ: Boolescher Wert Standardwert: true Beschreibung: Doppelte aufeinanderfolgende Logmeldungen verwerfen logger.dropOnOverflow Typ: Boolesch Standardwert: false Beschreibung: Verwirft Nachrichten, wenn der Puffer voll ist (statt zu blockieren) Flush-Verhalten logger.flushInterval Typ: Ganzzahl (Sekunden) Standardwert: 29 Seit: Version 0.9.18 Beschreibung: Wie häufig der Log-Puffer auf die Festplatte geschrieben wird Formatkonfiguration logger.format Typ: String (Zeichenfolge) Beschreibung: Formatvorlage für Lognachrichten Formatzeichen: d = Datum/Uhrzeit c = Klassenname t = Thread-Name p = Priorität (Protokollebene) m = Nachricht Beispiel: dctpm ergibt [Zeitstempel] [Klasse] [Thread] [Stufe] Nachricht Kompression (Version 0.9.56+) logger.gzip Typ: Boolesch Standardwert: false Seit: Version 0.9.56 Beschreibung: Aktiviert gzip-Komprimierung für rotierte Protokolldateien logger.minGzipSize Typ: Integer (Bytes) Standardwert: 65536 Seit: Version 0.9.56 Beschreibung: Minimale Dateigröße, ab der eine Komprimierung ausgelöst wird (Standardwert: 64 KB) Dateiverwaltung logger.logBufferSize Typ: Integer (Bytes) Standardwert: 1024 Beschreibung: Maximale Anzahl von Nachrichten, die gepuffert werden, bevor der Puffer geleert wird logger.logFileName Typ: String (Dateipfad) Standardwert: logs/log-@.txt Beschreibung: Namensmuster für Logdateien (@ wird durch die Rotationsnummer ersetzt) logger.logFilenameOverride Typ: String (Dateipfad) Beschreibung: Überschreibt den Logdateinamen (deaktiviert das Rotationsschema) logger.logFileSize Typ: Zeichenkette (Größe mit Einheit) Standardwert: 10M Einheiten: K (Kilobyte), M (Megabyte), G (Gigabyte) Beispiel: 50M, 1G logger.logRotationLimit Typ: Ganzzahl Standardwert: 2 Beschreibung: Höchste Rotationsdateinummer (log-0.txt bis einschließlich log-N.txt) Beispielkonfiguration # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN Plugin-Konfiguration Individuelle Plugin-Konfiguration (plugins/*/plugin.config) Speicherort: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config Format: Standardformat für I2P-Konfigurationsdateien Dokumentation: Plugin-Spezifikation Erforderliche Eigenschaften Name Typ: String Erforderlich: Ja Beschreibung: Anzeigename des Plugins Beispiel: name=I2P Plugin Example Schlüssel Typ: String (öffentlicher Schlüssel) Erforderlich: Ja (bei SU3-signierten Plugins weglassen) Beschreibung: Öffentlicher Signierschlüssel des Plugins zur Verifikation Format: Base64-kodierter Signierschlüssel Unterzeichner Typ: String Erforderlich: Ja Beschreibung: Identität des Plugin-Unterzeichners Beispiel: signer=user@example.i2p Version Typ: String (VersionComparator-Format) Erforderlich: Ja Beschreibung: Plugin-Version für die Update-Prüfung Format: Semantische Versionierung oder benutzerdefiniertes, vergleichbares Format Beispiel: version=1.2.3 Anzeigeeigenschaften Datum Typ: Long (Unix-Zeitstempel in Millisekunden) Beschreibung: Veröffentlichungsdatum des Plugins Autor Typ: String Beschreibung: Name des Plugin-Autors websiteURL Typ: Zeichenkette (URL) Beschreibung: URL der Plugin-Website updateURL Typ: String (URL) Beschreibung: Update-Prüf-URL für das Plugin updateURL.su3 Typ: Zeichenkette (URL) Seit: Version 0.9.15 Beschreibung: Update-URL im SU3-Format (bevorzugt) Beschreibung Typ: String Beschreibung: Englische Plugin-Beschreibung description_{language} Typ: String Beschreibung: Lokalisierte Plugin-Beschreibung Beispiel: description_de=Deutsche Beschreibung Lizenz Typ: String Beschreibung: Plugin-Lizenzkennung Beispiel: license=Apache 2.0 Installationseigenschaften Nicht automatisch nach der Installation starten Typ: Boolesch Standardwert: false Beschreibung: Automatischen Start nach der Installation verhindern router-Neustart erforderlich Typ: Boolesch Standardwert: false Beschreibung: Nach der Installation ist ein Neustart des router erforderlich Nur-Installation Typ: Boolesch Standardwert: false Beschreibung: Nur einmalig installieren (keine Updates) nur aktualisieren Typ: Boolesch Standardwert: false Beschreibung: Nur vorhandene Installation aktualisieren (keine Neuinstallation) Beispiel-Plugin-Konfiguration # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false Globale Plugin-Konfiguration (plugins.config) Ort: $I2P_CONFIG_DIR/plugins.config Zweck: Installierte Plugins global aktivieren/deaktivieren\nEigenschaftsformat plugin.{name}.startOnLoad=true|false {name}: Plugin-Name aus plugin.config startOnLoad: Ob das Plugin beim Start von router gestartet werden soll Beispiel plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false Konfiguration von Webanwendungen (webapps.config) Pfad: $I2P_CONFIG_DIR/webapps.config Zweck: Webanwendungen aktivieren/deaktivieren und konfigurieren\nEigenschaftsformat webapps.{name}.startOnLoad Typ: Boolesch Beschreibung: Ob die Webapp beim Start des router gestartet werden soll Format: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath Typ: String (durch Leerzeichen oder Kommas getrennte Pfade) Beschreibung: Zusätzliche Klassenpfad-Einträge für die Webapp Format: webapps.{name}.classpath=[paths] Variablenersetzung Pfade unterstützen die folgenden Variablenersetzungen:\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps #### Auflösung des Klassenpfads Kern-Webapps: Pfade relativ zu $I2P/lib Plugin-Webapps: Pfade relativ zu $CONFIG/plugins/{appname}/lib Beispielkonfiguration # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar Router-Konfiguration (router.config) Speicherort: $I2P_CONFIG_DIR/router.config Konfigurationsoberfläche: Router-Konsole unter /configadvanced Zweck: Zentrale Router-Einstellungen und Netzwerkparameter\nKonfigurationskategorien Netzwerkkonfiguration Bandbreiteneinstellungen:\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 Transportkonfiguration:\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true Router-Verhalten # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 Konsolenkonfiguration # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true Zeiteinstellungen # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org Hinweis: Die Router-Konfiguration ist umfangreich. Siehe die Router-Konsole unter /configadvanced für die vollständige Referenz aller Eigenschaften.\nKonfigurationsdateien für Anwendungen Adressbuch-Konfiguration (addressbook/config.txt) Speicherort: $I2P_CONFIG_DIR/addressbook/config.txt Anwendung: SusiDNS Zweck: Auflösung von Hostnamen und Adressbuchverwaltung\nDateispeicherorte Router-Adressbuch Standard: ../hosts.txt Beschreibung: Hauptadressbuch (systemweite Hostnamen) Format: Standardformat der Hosts-Datei privatehosts.txt Pfad: $I2P_CONFIG_DIR/addressbook/privatehosts.txt Beschreibung: Private Hostnamen-Zuordnungen Priorität: Höchste (setzt alle anderen Quellen außer Kraft) userhosts.txt Speicherort: $I2P_CONFIG_DIR/addressbook/userhosts.txt Beschreibung: Vom Benutzer hinzugefügte Hostnamen-Zuordnungen Verwaltung: Über die SusiDNS-Oberfläche hosts.txt Speicherort: $I2P_CONFIG_DIR/addressbook/hosts.txt Beschreibung: Heruntergeladenes öffentliches Adressbuch Quelle: Abonnement-Feeds Namensdienst BlockfileNamingService (Standard seit 0.8.8) Speicherformat: - Datei: hostsdb.blockfile - Speicherort: $I2P_CONFIG_DIR/addressbook/ - Leistung: ~10x schnellere Abfragen als hosts.txt - Format: Binäres Datenbankformat\nLegacy-Namensdienst: - Format: Nur-Text hosts.txt - Status: Veraltet, aber weiterhin unterstützt - Anwendungsfall: manuelle Bearbeitung, Versionskontrolle\nRegeln für Hostnamen I2P-Hostnamen müssen den folgenden Anforderungen entsprechen:\nTLD-Anforderung: Muss mit .i2p enden Maximale Länge: Insgesamt 67 Zeichen Zeichensatz: [a-z], [0-9], . (Punkt), - (Bindestrich) Schreibweise: Nur Kleinbuchstaben Startbeschränkungen: Darf nicht mit . oder - beginnen Verbotene Muster: Darf .., .- oder -. nicht enthalten (seit 0.6.1.33) Reserviert: Base32-Hostnamen *.b32.i2p (52 Zeichen von base32.b32.i2p) Gültige Beispiele example.i2p my-site.i2p test.example.i2p site123.i2p Ungültige Beispiele example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long Abonnementverwaltung subscriptions.txt Speicherort: $I2P_CONFIG_DIR/addressbook/subscriptions.txt Format: Eine URL pro Zeile Standard: http://i2p-projekt.i2p/hosts.txt Abonnement-Feed-Format (seit 0.9.26) Erweitertes Feed-Format mit Metadaten:\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 Metadaten-Eigenschaften: - added: Datum, an dem der Hostname hinzugefügt wurde (Format YYYYMMDD) - src: Quellbezeichner - sig: Optionale Signatur\nAbwärtskompatibilität: Einfaches hostname=destination-Format wird weiterhin unterstützt.\nBeispielkonfiguration # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false I2PSnark-Konfiguration (i2psnark.config.d/i2psnark.config) Pfad: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config Anwendung: I2PSnark BitTorrent-Client Konfigurationsoberfläche: Web-GUI unter http://127.0.0.1:7657/i2psnark\nVerzeichnisstruktur $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... Hauptkonfiguration (i2psnark.config) Minimale Standardkonfiguration:\ni2psnark.dir=i2psnark Zusätzliche Eigenschaften, die über die Weboberfläche verwaltet werden:\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 Individuelle Torrent-Konfiguration Speicherort: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config Format: Einstellungen pro Torrent Verwaltung: Automatisch (über Web-GUI)\nEigenschaften umfassen: - Torrent-spezifische Upload-/Download-Einstellungen - Dateiprioritäten - Tracker-Informationen - Grenzwerte für Peers\nHinweis: Torrent-Konfigurationen werden hauptsächlich über die Weboberfläche verwaltet. Manuelles Bearbeiten wird nicht empfohlen.\nOrganisation der Torrent-Daten Die Datenspeicherung ist von der Konfiguration getrennt:\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs I2PTunnel Konfiguration (i2ptunnel.config) Speicherort: $I2P_CONFIG_DIR/i2ptunnel.config (veraltet) oder $I2P_CONFIG_DIR/i2ptunnel.config.d/ (modern) Konfigurationsoberfläche: Router-Konsole unter /i2ptunnel Formatänderung: Version 0.9.42 (August 2019)\nVerzeichnisstruktur (Version 0.9.42+) Ab Version 0.9.42 wird die Standarddatei i2ptunnel.config automatisch aufgeteilt:\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) Kritischer Formatunterschied: - Monolithisches Format: Eigenschaften mit dem Präfix tunnel.N. - Getrenntes Format: Eigenschaften NICHT mit Präfix (z. B. description=, nicht tunnel.0.description=)\nMigrationsverhalten Beim ersten Start nach dem Upgrade auf 0.9.42: 1. Vorhandene i2ptunnel.config wird eingelesen 2. Einzelne tunnel-Konfigurationen werden in i2ptunnel.config.d/ erstellt 3. In den aufgeteilten Dateien werden die Präfixe der Eigenschaften entfernt 4. Originaldatei wird gesichert 5. Altes Format wird weiterhin zur Abwärtskompatibilität unterstützt\nKonfigurationsabschnitte Die I2PTunnel-Konfiguration ist im Abschnitt I2PTunnel-Konfigurationsreferenz weiter unten ausführlich dokumentiert. Die Eigenschaftsbeschreibungen gelten sowohl für monolithische (tunnel.N.property) als auch für getrennte (property) Formate.\nI2PTunnel-Konfigurationsreferenz Dieser Abschnitt bietet eine umfassende technische Referenz für alle I2PTunnel-Konfigurationseigenschaften. Eigenschaften werden im getrennten Format dargestellt (ohne das Präfix tunnel.N.). Für das monolithische Format sind allen Eigenschaften tunnel.N. voranzustellen, wobei N die tunnel-Nummer ist.\nWichtig: Eigenschaften, die als tunnel.N.option.i2cp.* beschrieben sind, sind in I2PTunnel implementiert und werden über andere Schnittstellen wie das I2CP‑Protokoll oder die SAM API NICHT unterstützt.\nGrundlegende Eigenschaften tunnel.N.description (Beschreibung) Typ: String Kontext: Alle Tunnel Beschreibung: Menschlich lesbare Tunnelbeschreibung für die Anzeige in der Benutzeroberfläche Beispiel: description=HTTP Proxy for outproxy access tunnel.N.name (Name) Typ: String Kontext: Alle tunnels Erforderlich: Ja Beschreibung: Eindeutiger tunnel-Bezeichner und Anzeigename Beispiel: name=I2P HTTP Proxy tunnel.N.type (Typ) Typ: Enum (Aufzählungstyp) Kontext: Alle tunnel Erforderlich: Ja Werte: client - Allgemeiner Client tunnel httpclient - HTTP-Proxy-Client ircclient - IRC-Client tunnel socksirctunnel - SOCKS-IRC-Proxy sockstunnel - SOCKS-Proxy (Version 4, 4a, 5) connectclient - CONNECT-Proxy-Client streamrclient - Streamr-Client server - Allgemeiner Server tunnel httpserver - HTTP-Server tunnel ircserver - IRC-Server tunnel httpbidirserver - Bidirektionaler HTTP-Server streamrserver - Streamr-Server tunnel.N.interface (Schnittstelle) Typ: Zeichenkette (IP-Adresse oder Hostname) Kontext: Nur für Client tunnels Standardwert: 127.0.0.1 Beschreibung: Lokale Schnittstelle zum Binden für eingehende Verbindungen Sicherheitshinweis: Das Binden an 0.0.0.0 erlaubt Verbindungen von außen Beispiel: interface=127.0.0.1 tunnel.N.listenPort (listenPort) Typ: Ganzzahl Kontext: Nur Client tunnels Bereich: 1-65535 Beschreibung: Lokaler Port, auf dem auf Client-Verbindungen gelauscht wird Beispiel: listenPort=4444 tunnel.N.targetHost (targetHost) Typ: String (IP-Adresse oder Hostname) Kontext: Nur für Server tunnels Beschreibung: Lokaler Server, an den Verbindungen weitergeleitet werden sollen Beispiel: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) Typ: Ganzzahl Kontext: Nur Server tunnels Bereich: 1-65535 Beschreibung: Port auf dem targetHost, zu dem eine Verbindung hergestellt werden soll Beispiel: targetPort=80 tunnel.N.targetDestination (targetDestination) Typ: String (durch Komma oder Leerzeichen getrennte Ziele) Kontext: Nur Client-Tunnels Format: destination[:port][,destination[:port]] Beschreibung: I2P-Ziel(e), mit dem/denen eine Verbindung hergestellt werden soll Beispiele: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) Typ: String (IP-Adresse oder Hostname) Standard: 127.0.0.1 Beschreibung: I2CP-Schnittstellenadresse des I2P router Hinweis: Wird ignoriert, wenn im router-Kontext ausgeführt Beispiel: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) Typ: Ganzzahl Standard: 7654 Bereich: 1-65535 Beschreibung: I2CP-Port des I2P-Routers Hinweis: Wird ignoriert, wenn im Router-Kontext ausgeführt wird Beispiel: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) Typ: Boolesch Standardwert: true Beschreibung: Ob der Tunnel gestartet werden soll, wenn I2PTunnel geladen wird Beispiel: startOnLoad=true Proxy‑Konfiguration tunnel.N.proxyList (proxyList) Typ: Zeichenkette (durch Kommas oder Leerzeichen getrennte Hostnamen) Kontext: Nur HTTP- und SOCKS-Proxys Beschreibung: Liste der Outproxy-Hosts Beispiel: proxyList=outproxy.example.i2p,backup.example.i2p Serverkonfiguration tunnel.N.privKeyFile (privKeyFile) Type: String (Dateipfad) Context: Server und persistente Client tunnels Description: Datei mit persistenten Privatschlüsseln der Destination (I2P-Adresse) Path: Absolut oder relativ zum I2P-Konfigurationsverzeichnis Example: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) Typ: Zeichenkette (Hostname) Kontext: Nur für HTTP-Server Standard: Base32-Hostname des Ziels Beschreibung: Host-Header-Wert, der an den lokalen Server übergeben wird Beispiel: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) Typ: String (Hostname) Kontext: Nur für HTTP-Server Beschreibung: Überschreibt den virtuellen Host für einen bestimmten eingehenden Port Anwendungsfall: Mehrere Websites auf unterschiedlichen Ports hosten Beispiel: spoofedHost.8080=site1.example.i2p Clientspezifische Optionen tunnel.N.sharedClient (sharedClient) Typ: Boolesch Kontext: Nur Client tunnels Standardwert: false Beschreibung: Ob mehrere Clients diesen tunnel gemeinsam nutzen können Beispiel: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) Typ: Boolesch Kontext: Nur für Client tunnels Standardwert: false Beschreibung: Zielschlüssel über Neustarts hinweg speichern und wiederverwenden Konflikt: Schließt sich mit i2cp.newDestOnResume=true gegenseitig aus Beispiel: option.persistentClientKey=true I2CP-Optionen (I2PTunnel-Implementierung) Wichtig: Diese Eigenschaften haben das Präfix option.i2cp., werden jedoch in I2PTunnel implementiert, nicht in der I2CP-Protokollschicht. Sie sind nicht über I2CP- oder SAM-APIs verfügbar.\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) Typ: Boolesch Kontext: Nur Client-tunnels Standardwert: false Beschreibung: Erstellt den tunnel erst bei der ersten Verbindung Anwendungsfall: Ressourcen für selten genutzte tunnels sparen Beispiel: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) Typ: Boolesch Kontext: Nur Client tunnels Standardwert: false Erfordert: i2cp.closeOnIdle=true Konflikt: Schließt sich gegenseitig aus mit persistentClientKey=true Beschreibung: Neue Destination (Zieladresse) nach Ablauf des Inaktivitäts-Timeouts erstellen Beispiel: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) Typ: String (base64-kodierter Schlüssel) Kontext: Nur für Server-tunnels Beschreibung: Persistenter privater Verschlüsselungsschlüssel für das leaseSet Anwendungsfall: Konsistentes verschlüsseltes leaseSet über Neustarts hinweg beibehalten Beispiel: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) Typ: String (sigtype:base64) Kontext: Nur Server-Tunnel Format: sigtype:base64key Beschreibung: Dauerhafter privater Signaturschlüssel für das leaseSet Beispiel: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... Serverspezifische Optionen tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) Typ: Boolesch Kontext: Gilt nur für Server tunnels Standardwert: false Beschreibung: Für jedes entfernte I2P-Ziel eine eindeutige lokale IP verwenden Anwendungsfall: Client-IPs in Server-Protokollen nachverfolgen Sicherheitshinweis: Kann die Anonymität verringern Beispiel: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) Typ: String (hostname:port) Kontext: Nur für Server tunnels Beschreibung: targetHost/targetPort für eingehenden Port NNNN überschreiben Anwendungsfall: Portbasiertes Routing zu verschiedenen lokalen Diensten Beispiel: option.targetForPort.8080=localhost:8080 Thread-Pool-Konfiguration tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) Typ: Boolesch Kontext: Nur für Server tunnels Standard: true Beschreibung: Thread-Pool zur Verbindungsverwaltung verwenden Hinweis: Für Standardserver immer false (ignoriert) Beispiel: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) Typ: Ganzzahl Kontext: Nur für Server tunnels Standardwert: 65 Beschreibung: Maximale Thread-Pool-Größe Hinweis: Wird bei Standardservern ignoriert Beispiel: option.i2ptunnel.blockingHandlerCount=100 HTTP-Client-Optionen tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) Typ: Boolesch Kontext: Nur für HTTP-Clients Standardwert: false Beschreibung: SSL-Verbindungen zu .i2p-Adressen zulassen Beispiel: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) Typ: Boolesch Kontext: Nur für HTTP-Clients Standardwert: false Beschreibung: Address Helper-Links (Hilfslinks zur Adressauflösung) in Proxy-Antworten deaktivieren Beispiel: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) Typ: String (durch Kommas oder Leerzeichen getrennte URLs) Kontext: nur für HTTP-Clients Beschreibung: Jump-Server-URLs zur Auflösung von Hostnamen Beispiel: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) Typ: Boolesch Kontext: Nur für HTTP-Clients Standard: false Beschreibung: Sende Accept-*‑Header (außer Accept und Accept-Encoding) Beispiel: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) Typ: Boolesch Kontext: Nur HTTP-Clients Standardwert: false Beschreibung: Referer-Header durch den Proxy weiterleiten Datenschutzhinweis: Kann Informationen preisgeben Beispiel: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) Typ: Boolesch Kontext: nur für HTTP-Clients Standardwert: false Beschreibung: User-Agent-Header über den Proxy weiterleiten Datenschutzhinweis: Kann Informationen über den Browser preisgeben Beispiel: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) Typ: Boolesch Kontext: Nur HTTP-Clients Standardwert: false Beschreibung: Via-Header durch den Proxy weiterreichen Beispiel: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) Typ: String (durch Kommas oder Leerzeichen getrennte Destinations (Ziele)) Kontext: Nur HTTP-Clients Beschreibung: Netzwerkinterne SSL-Outproxies für HTTPS Beispiel: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) Typ: Boolesch Kontext: Nur HTTP-Clients Standardwert: true Beschreibung: Registrierte lokale Outproxy-Plugins (Ausgangsproxy) verwenden Beispiel: option.i2ptunnel.useLocalOutproxy=true HTTP-Client-Authentifizierung tunnel.N.option.proxyAuth (option.proxyAuth) Typ: Enum (Aufzählungstyp) Kontext: Nur für HTTP-Clients Standardwert: false Werte: true, false, basic, digest Beschreibung: Lokale Authentifizierung für den Proxyzugriff erfordern Hinweis: true entspricht basic Beispiel: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) Typ: String (32 Zeichen, hexadezimale Darstellung in Kleinbuchstaben) Kontext: Nur HTTP-Clients Erfordert: proxyAuth=basic oder proxyAuth=digest Beschreibung: MD5-Hash des Passworts für den Benutzer USER Veraltet: Stattdessen SHA-256 verwenden (0.9.56+) Beispiel: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) Typ: String (64 Zeichen, hexadezimal in Kleinbuchstaben) Kontext: Nur HTTP-Clients Erfordert: proxyAuth=digest Seit: Version 0.9.56 Standard: RFC 7616 Beschreibung: SHA-256-Hash des Passworts für den Benutzer USER Beispiel: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 Outproxy-Authentifizierung tunnel.N.option.outproxyAuth (option.outproxyAuth) Typ: Boolesch Kontext: nur für HTTP-Clients Standardwert: false Beschreibung: Authentifizierung an den Outproxy (I2P-Proxy ins Clearnet) senden Beispiel: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) Typ: String Kontext: Nur HTTP-Clients Erfordert: outproxyAuth=true Beschreibung: Benutzername für die outproxy-Authentifizierung (Proxy ins Clearnet) Beispiel: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) Typ: Zeichenfolge Kontext: Nur HTTP-Clients Erfordert: outproxyAuth=true Beschreibung: Passwort für die Outproxy-Authentifizierung Sicherheit: Im Klartext gespeichert Beispiel: option.outproxyPassword=secret SOCKS-Client-Optionen tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) Typ: String (durch Kommas oder Leerzeichen getrennte Ziele) Kontext: Nur für SOCKS-Clients Beschreibung: Netzinterne Outproxies (Proxy-Server für Verbindungen aus dem I2P-Netz ins Clearnet) für nicht spezifizierte Ports Beispiel: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) Typ: String (Ziele, durch Kommas oder Leerzeichen getrennt) Kontext: nur SOCKS-Clients Beschreibung: Outproxies (Ausgangsproxies) im Netzwerk speziell für Port NNNN Beispiel: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) Typ: Enum Kontext: Nur SOCKS-Clients Standard: socks Seit: Version 0.9.57 Werte: socks, connect (HTTPS) Beschreibung: Typ des konfigurierten outproxy (Ausgangs-Proxy ins Clearnet) Beispiel: option.outproxyType=connect HTTP-Server-Optionen tunnel.N.option.maxPosts (option.maxPosts) Typ: Ganzzahl Kontext: Nur für HTTP-Server Standard: 0 (unbegrenzt) Beschreibung: Maximale Anzahl POST-Anfragen von einer Destination (I2P-Adresse) pro postCheckTime Beispiel: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) Typ: Ganzzahl Kontext: Nur für HTTP-Server Standard: 0 (unbegrenzt) Beschreibung: Maximale Anzahl an POSTs von allen Zielen pro postCheckTime Beispiel: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) Typ: Ganzzahl (Sekunden) Kontext: Nur für HTTP-Server Standardwert: 300 Beschreibung: Zeitfenster zur Überprüfung der POST-Limits Beispiel: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) Typ: Ganzzahl (Sekunden) Kontext: Nur für HTTP-Server Standardwert: 1800 Beschreibung: Sperrzeit für ein einzelnes Ziel nach Überschreitung von maxPosts Beispiel: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) Typ: Ganzzahl (Sekunden) Kontext: Nur für HTTP-Server Standardwert: 600 Beschreibung: Sperrdauer, nachdem maxTotalPosts überschritten wurde Beispiel: option.postTotalBanTime=1200 HTTP-Server-Sicherheitsoptionen tunnel.N.option.rejectInproxy (option.rejectInproxy) Typ: Boolesch Kontext: Nur HTTP-Server Standard: false Beschreibung: Verbindungen ablehnen, die anscheinend über einen inproxy (Eingangs-Proxy ins I2P‑Netz) erfolgen Beispiel: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) Typ: Boolesch Kontext: Nur für HTTP-Server Standard: false Seit: Version 0.9.25 Beschreibung: Verbindungen mit Referer-Header zurückweisen Beispiel: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) Typ: Boolesch Kontext: Nur für HTTP-Server Standardwert: false Seit: Version 0.9.25 Erfordert: Eigenschaft userAgentRejectList Beschreibung: Verbindungen mit übereinstimmendem User-Agent ablehnen Beispiel: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) Typ: String (kommagetrennte Vergleichsmuster) Kontext: Nur HTTP-Server Seit: Version 0.9.25 Groß-/Kleinschreibung: Groß-/Kleinschreibung beachten Besonderes: \u0026ldquo;none\u0026rdquo; (seit 0.9.33) entspricht einem leeren User-Agent Beschreibung: Liste von User-Agent-Mustern, die abgelehnt werden Beispiel: option.userAgentRejectList=Mozilla,Opera,none IRC-Serveroptionen tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) Typ: String (Hostname-Muster) Kontext: Nur für IRC-Server Standard: %f.b32.i2p Token: %f = Vollständiger base32-Ziel-Hash %c = Verschleierter Ziel-Hash (siehe cloakKey) Beschreibung: Hostname-Format, das an den IRC-Server gesendet wird Beispiel: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) Typ: Zeichenkette (Passphrase) Kontext: Nur für IRC-Server Standard: Zufällig je Sitzung Einschränkungen: Keine Anführungszeichen oder Leerzeichen Beschreibung: Passphrase für gleichbleibende Hostname-Verschleierung Anwendungsfall: Dauerhafte Benutzer-Nachverfolgung über Neustarts und Server hinweg Beispiel: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) Typ: Enum (Aufzählungstyp) Kontext: Nur für IRC-Server Standard: user Werte: user, webirc Beschreibung: Authentifizierungsmethode für IRC-Server Beispiel: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) Typ: String (Passwort) Kontext: Nur für IRC-Server Erfordert: method=webirc Einschränkungen: Keine Anführungszeichen oder Leerzeichen Beschreibung: Passwort für die Authentifizierung des WEBIRC-Protokolls Beispiel: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) Typ: Zeichenkette (IP-Adresse) Kontext: Nur für IRC-Server Erfordert: method=webirc Beschreibung: Gefälschte IP-Adresse für das WEBIRC-Protokoll Beispiel: option.ircserver.webircSpoofIP=10.0.0.1 SSL/TLS-Konfiguration tunnel.N.option.useSSL (option.useSSL) Typ: Boolesch Standardwert: false Kontext: Alle tunnels Verhalten: Server: SSL für Verbindungen zum lokalen Server verwenden Clients: SSL von lokalen Clients verlangen Beispiel: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) Typ: String (Dateipfad) Kontext: Nur Client tunnels Standardwert: i2ptunnel-(random).ks Pfad: Relativ zu $(I2P_CONFIG_DIR)/keystore/, falls nicht absolut Automatisch erstellt: Erstellt, falls nicht vorhanden Beschreibung: Keystore-Datei, die den SSL-Privatschlüssel enthält Beispiel: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) Typ: String (Passwort) Kontext: Nur Client tunnels Standard: changeit Automatisch generiert: Zufälliges Passwort, wenn neuer Keystore erstellt wird Beschreibung: Passwort für den SSL-Keystore Beispiel: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) Typ: String (Alias) Kontext: Nur Client tunnels Automatisch generiert: Erstellt, wenn ein neuer Schlüssel generiert wird Beschreibung: Alias für privaten Schlüssel im Keystore Beispiel: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) Typ: String (Passwort) Kontext: Nur für Client tunnels Automatisch generiert: Zufälliges Passwort, wenn neuer Schlüssel erstellt wird Beschreibung: Passwort für den privaten Schlüssel im keystore (Schlüsselspeicher) Beispiel: option.keyPassword=keypass123 Allgemeine I2CP- und Streaming-Optionen Alle tunnel.N.option.*-Eigenschaften (oben nicht ausdrücklich dokumentiert) werden an die I2CP-Schnittstelle und die Streaming-Bibliothek weitergeleitet, wobei das Präfix tunnel.N.option. entfernt wird.\nWichtig: Diese sind von I2PTunnel-spezifischen Optionen getrennt. Siehe: - I2CP-Spezifikation - Spezifikation der Streaming-Bibliothek Beispielhafte Streaming-Optionen:\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 Vollständiges Tunnelbeispiel # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 Versionsverlauf und Funktions-Zeitleiste Version 0.9.10 (2013) Feature: Unterstützung für leere Werte in Konfigurationsdateien - Schlüssel mit leeren Werten (key=) werden jetzt unterstützt - Zuvor ignoriert oder führten zu Parsing-Fehlern\nVersion 0.9.18 (2015) Funktion: Konfiguration des Flush-Intervalls des Loggers - Eigenschaft: logger.flushInterval (Standard 29 Sekunden) - Reduziert die Festplatten-I/O bei Beibehaltung einer akzeptablen Protokoll-Latenz\nVersion 0.9.23 (November 2015) Wichtige Änderung: Java 7 ist Mindestvoraussetzung - Unterstützung für Java 6 beendet - Erforderlich für weitere Sicherheitsupdates\nVersion 0.9.25 (2015) Funktionen: Sicherheitsoptionen für HTTP-Server - tunnel.N.option.rejectReferer - Verbindungen mit Referer-Header ablehnen - tunnel.N.option.rejectUserAgents - Bestimmte User-Agent-Header ablehnen - tunnel.N.option.userAgentRejectList - Abzuweisende User-Agent-Muster - Anwendungsfall: Crawler und unerwünschte Clients eindämmen\nVersion 0.9.33 (Januar 2018) Funktion: Erweiterte User-Agent-Filterung - userAgentRejectList-String \u0026ldquo;none\u0026rdquo; entspricht einem leeren User-Agent - Weitere Fehlerbehebungen für i2psnark, i2ptunnel, streaming, SusiMail\nVersion 0.9.41 (2019) Abkündigung: BOB-Protokoll aus Android entfernt - Android-Nutzer müssen auf SAM oder I2CP umsteigen\nVersion 0.9.42 (August 2019) Wesentliche Änderung: Aufteilung der Konfigurationsdateien - clients.config in die Verzeichnisstruktur clients.config.d/ aufgeteilt - i2ptunnel.config in die Verzeichnisstruktur i2ptunnel.config.d/ aufgeteilt - Automatische Migration beim ersten Start nach dem Upgrade - Ermöglicht modulare Paketierung und Plugin-Management - Altes monolithisches Format weiterhin unterstützt\nZusätzliche Funktionen: - SSU-Leistungsverbesserungen - Verhinderung netzwerkübergreifender Verbindungen (Proposal 147) - Erste Unterstützung für Verschlüsselungstypen\nVersion 0.9.56 (2021) Funktionen: Verbesserungen bei Sicherheit und Protokollierung - logger.gzip - Gzip-Komprimierung für rotierte Protokolldateien (Standard: false) - logger.minGzipSize - Mindestgröße für die Komprimierung (Standard: 65536 Bytes) - tunnel.N.option.proxy.auth.USER.sha256 - SHA-256-Digest-Authentifizierung (RFC 7616) - Sicherheit: SHA-256 ersetzt MD5 für die Digest-Authentifizierung\nVersion 0.9.57 (Januar 2023) Funktion: SOCKS-Outproxy-Typkonfiguration - tunnel.N.option.outproxyType - Outproxy-Typ auswählen (socks|connect) - Standard: socks - HTTPS CONNECT-Unterstützung für HTTPS-Outproxies\nVersion 2.6.0 (Juli 2024) Inkompatible Änderung: I2P-over-Tor blockiert - Verbindungen von IP-Adressen von Tor-Exit-Knoten werden jetzt abgelehnt - Grund: Beeinträchtigt die I2P-Leistung, verschwendet Ressourcen von Tor-Exits - Auswirkungen: Nutzer, die über Tor-Exit-Knoten auf I2P zugreifen, werden blockiert - Nicht-Exit-Relays und Tor-Clients sind nicht betroffen\nVersion 2.10.0 (September 2025 - aktuell) Hauptfunktionen: - Post-Quanten-Kryptografie verfügbar (optional über Hidden Service Manager aktivierbar) - UDP-Tracker-Unterstützung für I2PSnark zur Reduzierung der Tracker-Last - Stabilität im Hidden Mode-Verbesserungen zur Verringerung der RouterInfo-Erschöpfung - Netzwerkverbesserungen für überlastete router - Verbessertes UPnP/NAT-Traversal - NetDB-Verbesserungen mit aggressiver leaseSet-Entfernung - Reduzierungen der Beobachtbarkeit von router-Ereignissen\nKonfiguration: Keine neuen Konfigurationseigenschaften hinzugefügt\nKritische bevorstehende Änderung: Die nächste Version (voraussichtlich 2.11.0 oder 3.0.0) wird Java 17 oder höher erfordern\nVeraltete Funktionen und inkompatible Änderungen Kritische Abkündigungen I2P-over-Tor-Zugriff (Version 2.6.0+) Status: BLOCKIERT seit Juli 2024 Auswirkung: Verbindungen von IP-Adressen von Tor-Exitknoten werden abgelehnt Begründung: Beeinträchtigt die Leistung des I2P-Netzwerks, ohne Vorteile für die Anonymität zu bieten Betrifft: Nur Tor-Exitknoten, nicht Relays oder normale Tor-Clients Alternative: I2P oder Tor getrennt nutzen, nicht kombiniert MD5-Digest-Authentifizierung Status: Veraltet (verwenden Sie SHA-256) Eigenschaft: tunnel.N.option.proxy.auth.USER.md5 Grund: MD5 kryptografisch gebrochen Ersatz: tunnel.N.option.proxy.auth.USER.sha256 (seit 0.9.56) Zeitleiste: MD5 weiterhin unterstützt, aber nicht empfohlen Änderungen der Konfigurationsarchitektur Monolithische Konfigurationsdateien (Version 0.9.42+) Betroffen: clients.config, i2ptunnel.config Status: Veraltet zugunsten einer getrennten Verzeichnisstruktur Migration: Automatisch beim ersten Start nach dem Upgrade auf 0.9.42 Kompatibilität: Altes Format funktioniert weiterhin (abwärtskompatibel) Empfehlung: Für neue Konfigurationen das getrennte Format verwenden Anforderungen an die Java-Version Unterstützung für Java 6 Beendet: Version 0.9.23 (November 2015) Minimum: Java 7 seit 0.9.23 erforderlich Java-17-Voraussetzung (bevorstehend) Status: KRITISCHE ANSTEHENDE ÄNDERUNG Ziel: Nächste Hauptversion nach 2.10.0 (voraussichtlich 2.11.0 oder 3.0.0) Aktuelles Minimum: Java 8 Erforderliche Maßnahme: Auf die Migration zu Java 17 vorbereiten Zeitplan: Wird mit den Versionshinweisen bekanntgegeben Entfernte Funktionen BOB Protokoll (Android) Entfernt: Seit Version 0.9.41 Plattform: Nur Android Alternative: SAM- oder I2CP-Protokolle Desktop: BOB auf Desktop-Plattformen weiterhin verfügbar Empfohlene Migrationen Authentifizierung: Von MD5-Digest-Authentifizierung zu SHA-256-Digest-Authentifizierung migrieren Konfigurationsformat: Auf eine getrennte Verzeichnisstruktur für Clients und tunnels migrieren Java-Laufzeitumgebung: Upgrade auf Java 17 vor dem nächsten Major-Release einplanen Tor-Integration: I2P nicht über Tor-Exit-Knoten routen Referenzen Offizielle Dokumentation I2P-Konfigurationsspezifikation - Offizielle Spezifikation des Konfigurationsdateiformats I2P-Plugin-Spezifikation - Plugin-Konfiguration und Paketierung I2P Gemeinsame Strukturen - Typzuordnung - Serialisierungsformat für Protokolldaten Java-Properties-Format - Grundlegende Formatspezifikation Quellcode I2P Java Router-Repository - GitHub-Spiegel I2P Developers Gitea - Offizielles I2P-Quellcode-Repository DataHelper.java - Implementierung der Ein-/Ausgabe für Konfigurationsdateien Ressourcen der Community I2P Forum - Aktive Community-Diskussionen und Support I2P Website - Offizielle Projekt-Website API-Dokumentation DataHelper JavaDoc - API-Dokumentation zu Methoden für Konfigurationsdateien Status der Spezifikation Letzte Aktualisierung der Spezifikation: Januar 2023 (Version 0.9.57) Aktuelle I2P-Version: 2.10.0 (September 2025) Technische Genauigkeit: Die Spezifikation bleibt bis einschließlich 2.10.0 korrekt (keine inkompatiblen Änderungen (breaking changes)) Wartung: Lebendes Dokument, das aktualisiert wird, wenn das Konfigurationsformat geändert wird ","description":"Konfigurationsoptionen und Formate für I2P routers und Clients","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"Router-Konfiguration","url":"/de/docs/specs/configuration/"},{"categories":null,"content":" Veraltet: SAM v1 wird nur aus historischen Gründen beibehalten. Neue Anwendungen sollten SAM v3 oder BOB verwenden. Die ursprüngliche Bridge unterstützt nur DSA-SHA1-Ziele und einen eingeschränkten Optionssatz.\nBibliotheken Der Java-I2P-Quellbaum enthält weiterhin veraltete Bindings für C, C#, Perl und Python. Sie werden nicht mehr gepflegt und hauptsächlich aus Gründen der Archivkompatibilität mitgeliefert.\nVersionsaushandlung Clients verbinden sich über TCP (standardmäßig 127.0.0.1:7656) und tauschen Folgendes aus:\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 Seit Java I2P 0.9.14 ist der Parameter MIN optional und sowohl MIN/MAX akzeptieren bei aktualisierten Brücken einstellige Formen (\u0026quot;3\u0026quot; usw.).\nSitzungserstellung SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name lädt oder erstellt einen Eintrag in sam.keys; TRANSIENT erstellt immer eine temporäre Destination (Zieladresse). STYLE wählt virtuelle Streams (TCP-ähnlich), signierte Datagramme oder rohe Datagramme aus. DIRECTION gilt nur für Stream-Sitzungen; standardmäßig BOTH. Zusätzliche Schlüssel-Wert-Paare werden als I2CP-Optionen weitergereicht (zum Beispiel tunnels.quantityInbound=3). Die Bridge antwortet mit:\nSESSION STATUS RESULT=OK DESTINATION=name Bei Fehlern werden DUPLICATED_DEST, I2P_ERROR oder INVALID_KEY zurückgegeben, zusammen mit einer optionalen Nachricht.\nNachrichtenformate SAM-Nachrichten sind einzeilige ASCII-Nachrichten mit durch Leerzeichen getrennten Schlüssel/Wert-Paaren. Schlüssel sind UTF‑8; Werte dürfen in Anführungszeichen stehen, wenn sie Leerzeichen enthalten. Es ist kein Escaping (Maskierung) definiert.\nKommunikationstypen:\nStreams – über die I2P-Streaming-Bibliothek weitergeleitet Antwortfähige Datagramme – signierte Nutzlasten (Datagram1) Rohe Datagramme – unsignierte Nutzlasten (Datagram RAW) In 0.9.14 hinzugefügte Optionen DEST GENERATE akzeptiert SIGNATURE_TYPE=... (ermöglicht Ed25519 usw.) HELLO VERSION behandelt MIN als optional und akzeptiert einstellige Versionsstrings Wann SAM v1 verwenden Nur zur Interoperabilität mit Legacy-Software, die nicht aktualisiert werden kann. Für alle neuen Entwicklungen verwenden Sie:\nSAM v3 für funktionsvollständigen Stream-/Datagrammzugriff BOB für die Verwaltung von Destinations (noch eingeschränkt, unterstützt aber modernere Funktionen) Referenzen SAM v2 SAM v3 Datagramm-Spezifikation Streaming-Protokoll SAM v1 (SAM-API in Version 1) legte die Grundlage für eine router-agnostische Anwendungsentwicklung, aber das Ökosystem hat sich weiterentwickelt. Betrachten Sie dieses Dokument eher als Kompatibilitätshilfe denn als Ausgangspunkt.\n","description":"Älteres Simple Anonymous Messaging (einfaches anonymes Messaging)-Protokoll (veraltet)","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM v1","url":"/de/docs/legacy/sam/"},{"categories":null,"content":" Veraltet: SAM v2 wurde mit I2P 0.6.1.31 ausgeliefert und wird nicht mehr gepflegt. Verwenden Sie SAM v3 für neue Entwicklungen. Die einzige Verbesserung von v2 gegenüber v1 war die Unterstützung mehrerer Sockets, die über eine einzelne SAM-Verbindung multiplex übertragen werden.\nVersionshinweise Die gemeldete Versionszeichenfolge bleibt \u0026quot;2.0\u0026quot;. Seit 0.9.14 akzeptiert die Nachricht HELLO VERSION einstellige Werte für MIN/MAX und der Parameter MIN ist optional. DEST GENERATE unterstützt SIGNATURE_TYPE, sodass Ed25519-Destinations (Ziele) erstellt werden können. Grundlagen der Sitzung SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] Jede Destination (Zieladresse) darf nur eine aktive SAM-Session haben (Streams, Datagramme oder RAW). STYLE wählt virtuelle Streams, signierte Datagramme oder rohe Datagramme aus. Zusätzliche Optionen werden an I2CP übergeben (zum Beispiel tunnels.quantityInbound=3). Antworten entsprechen v1: SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY. Nachrichtenkodierung Zeilenorientiertes ASCII mit durch Leerzeichen getrennten key=value-Paaren (Werte können in Anführungszeichen stehen). Kommunikationstypen sind dieselben wie in v1:\nStreams über die I2P-Streaming-Bibliothek Antwortfähige Datagramme (PROTO_DATAGRAM) Rohdatagramme (PROTO_DATAGRAM_RAW) Wann verwenden Nur für Legacy-Clients, die nicht migrieren können. SAM v3 bietet:\nÜbergabe einer binären Destination (Zieladresse) (DEST GENERATE BASE64) Subsessions (Untersitzungen) und DHT-Unterstützung (v3.3) Verbesserte Fehlermeldungen und Aushandlung von Optionen Siehe:\nSAM v1 SAM v3 Datagramm-API Streaming-Protokoll ","description":"Veraltetes Simple Anonymous Messaging-Protokoll","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2","url":"/de/docs/legacy/samv2/"},{"categories":null,"content":"SAM v3 (\u0026ldquo;Simple Anonymous Messaging\u0026rdquo;) ist die aktuelle stabile, routerunabhängige API, die es externen Anwendungen ermöglicht, mit dem I2P-Netzwerk zu kommunizieren, ohne den Router selbst einbetten zu müssen. Sie bietet einheitlichen Zugriff auf Streams, Datagramme und Rohnachrichten und bleibt die maßgebliche Schnittstellenschicht für Nicht-Java-Software.\n1. Überblick und Zweck SAM v3 ermöglicht Entwicklern, I2P-fähige Software in jeder Sprache mithilfe eines schlanken TCP/UDP-Protokolls zu erstellen. Es abstrahiert die router-Interna und stellt eine minimale Befehlssammlung über TCP (7656) und UDP (7655) bereit. Sowohl Java I2P als auch i2pd implementieren Teilmengen der SAM v3-Spezifikation, wobei i2pd Stand 2025 noch die meisten 3.2- und 3.3-Erweiterungen fehlen.\n2. Versionshistorie Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. ### Hinweis zur Benennung Java I2P verwendet PRIMARY/SUBSESSION. i2pd und I2P+ verwenden weiterhin die veraltete MASTER/SUBSESSION-Terminologie für Abwärtskompatibilität. 3. Kernarbeitsablauf Versionsverhandlung HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 Destination-Erstellung DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512). Dringend empfohlen seit I2P 0.9.15. Sitzungserstellung SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4 ist X25519 (ECIES X25519 AEAD Ratchet) und 0 ist ElGamal-Fallback für Kompatibilität. Explizite Tunnel-Mengen für Konsistenz: Java I2P Standard 2, i2pd Standard 5. Protokolloperationen STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 Zu den Kern-Nachrichtentypen gehören: STREAM CONNECT, STREAM ACCEPT, STREAM FORWARD, DATAGRAM SEND, RAW SEND, NAMING LOOKUP, DEST LOOKUP, PING, QUIT.\nOrdnungsgemäßes Herunterfahren QUIT 4. Implementierungsunterschiede (Java I2P vs i2pd) Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 **Empfehlung:** Geben Sie die Tunnel-Anzahl immer explizit an, um die Konsistenz zwischen verschiedenen Routern sicherzustellen. 5. Unterstützte Bibliotheken (Stand 2025) Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance ## 6. Kommende und neue Funktionen (2024–2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ ## 7. Sicherheits- und Konfigurationshinweise Binden Sie SAM nur an 127.0.0.1. Verwenden Sie für persistente Dienste PRIMARY-Sessions mit statischen Schlüsseln. Verwenden Sie HELLO VERSION, um die Unterstützung von Funktionen zu testen. Verwenden Sie PING oder NAMING LOOKUP, um die Verfügbarkeit des Routers zu überprüfen. Vermeiden Sie nicht authentifizierte Remote-SAM-Verbindungen (kein TLS in i2pd). 8. Referenzen und Spezifikationen SAM v3 Spezifikation SAM v2 (Veraltet) Streaming Spezifikation Datagrams Dokumentations-Hub i2pd Dokumentation 9. Zusammenfassung SAM v3 bleibt das empfohlene Bridge-Protokoll für alle Nicht-Java-I2P-Anwendungen. Es bietet Stabilität, sprachübergreifende Bindungen und konsistente Leistung über verschiedene Router-Typen hinweg.\nBei der Entwicklung mit SAM: - Verwenden Sie Ed25519-Signaturen und X25519-Verschlüsselung. - Überprüfen Sie die Funktionsunterstützung dynamisch über HELLO VERSION. - Entwerfen Sie für Kompatibilität, insbesondere bei der Unterstützung sowohl von Java I2P- als auch von i2pd-Routern.\n","description":"Stabiles Bridge-Protokoll für Nicht-Java-I2P-Anwendungen","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/de/docs/api/samv3/"},{"categories":null,"content":"Sicherheitskontakt Um Sicherheitslücken oder sensible Sicherheitsprobleme zu melden, kontaktieren Sie bitte das I2P Security Team unter security@i2p.net Für sichere Kommunikation verwenden Sie bitte unseren PGP-Schlüssel unten.\nPGP-Schlüssel-Informationen E-Mail: security@i2p.net Schlüssel-ID: 176E1941 Fingerabdruck: 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 Schlüsseltyp: RSA 4096-Bit Erstellt: 19.10.2025 Läuft ab: 19.11.2030 UID: I2P Security \u0026lt;security@i2p.net\u0026gt; Öffentlicher Schlüssel Im Folgenden finden Sie den öffentlichen GPG-Schlüssel des I2P-Sicherheitsteams: \u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nmQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"Öffentlicher GPG-Schlüssel zur Kontaktaufnahme mit dem I2P-Sicherheitsteam","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"Sicherheits-GPG-Schlüssel","url":"/de/docs/develop/security-key/"},{"categories":null,"content":" Achtung: Der SOCKS-Tunnel leitet Anwendungsdaten ohne Bereinigung weiter. Viele Protokolle geben IPs, Hostnamen oder andere Identifikatoren preis. Verwenden Sie SOCKS nur mit Software, die Sie auf Anonymität geprüft haben.\n1. Überblick I2P bietet SOCKS 4, 4a und 5 Proxy-Unterstützung für ausgehende Verbindungen über einen I2PTunnel-Client. Dies ermöglicht es Standardanwendungen, I2P-Ziele zu erreichen, kann aber nicht auf das Clearnet zugreifen. Es gibt keinen SOCKS-Outproxy, und der gesamte Datenverkehr bleibt innerhalb des I2P-Netzwerks.\nImplementierungszusammenfassung Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None **Unterstützte Adresstypen:** - `.i2p` Hostnamen (Adressbuch-Einträge) - Base32-Hashes (`.b32.i2p`) - Keine Unterstützung für Base64 oder Clearnet 2. Sicherheitsrisiken und Einschränkungen Anwendungsschicht-Leck SOCKS arbeitet unterhalb der Anwendungsschicht und kann Protokolle nicht bereinigen. Viele Clients (z. B. Browser, IRC, E-Mail) enthalten Metadaten, die Ihre IP-Adresse, Ihren Hostnamen oder Systemdetails preisgeben.\nHäufige Lecks umfassen: - IP-Adressen in E-Mail-Headern oder IRC-CTCP-Antworten - Echte Namen/Benutzernamen in Protokoll-Payloads - User-Agent-Strings mit Betriebssystem-Fingerabdrücken - Externe DNS-Abfragen - WebRTC und Browser-Telemetrie\nI2P kann diese Lecks nicht verhindern – sie treten oberhalb der Tunnel-Ebene auf. Verwenden Sie SOCKS nur für geprüfte Clients, die für Anonymität entwickelt wurden.\nGemeinsame Tunnel-Identität Wenn mehrere Anwendungen einen SOCKS-Tunnel gemeinsam nutzen, teilen sie dieselbe I2P-destination-Identität. Dies ermöglicht eine Korrelation oder Fingerabdruckerstellung über verschiedene Dienste hinweg.\nGegenmaßnahme: Verwenden Sie nicht gemeinsam genutzte Tunnel für jede Anwendung und aktivieren Sie persistente Schlüssel, um konsistente kryptografische Identitäten über Neustarts hinweg beizubehalten.\nUDP-Modus auskommentiert UDP-Unterstützung in SOCKS5 ist nicht implementiert. Das Protokoll wirbt mit UDP-Fähigkeit, aber Aufrufe werden ignoriert. Verwenden Sie nur TCP-Clients.\nKein Outproxy nach Design Anders als Tor bietet I2P keine SOCKS-basierten Clearnet-Outproxies. Versuche, externe IP-Adressen zu erreichen, werden fehlschlagen oder die Identität preisgeben. Verwenden Sie HTTP- oder HTTPS-Proxies, wenn Outproxying erforderlich ist.\n3. Historischer Kontext Entwickler haben lange davon abgeraten, SOCKS für anonyme Nutzung zu verwenden. Aus internen Entwicklerdiskussionen und den Treffen von 2004 Meeting 81 und Meeting 82 :\n\u0026ldquo;Das Weiterleiten von beliebigem Datenverkehr ist unsicher, und es obliegt uns als Entwicklern von Anonymitätssoftware, die Sicherheit unserer Endnutzer stets im Vordergrund zu haben.\u0026rdquo;\nSOCKS-Unterstützung wurde aus Kompatibilitätsgründen aufgenommen, wird aber nicht für Produktionsumgebungen empfohlen. Nahezu jede Internetanwendung gibt sensible Metadaten preis, die für anonymes Routing ungeeignet sind.\n4. Konfiguration Java I2P Öffnen Sie den I2PTunnel Manager Erstellen Sie einen neuen Client-Tunnel vom Typ \u0026ldquo;SOCKS 4/4a/5\u0026rdquo; Konfigurieren Sie die Optionen: Lokaler Port (beliebiger verfügbarer Port) Shared client: deaktivieren für separate Identität pro Anwendung Persistent key: aktivieren, um Schlüsselkorrelation zu reduzieren Starten Sie den Tunnel i2pd i2pd enthält SOCKS5-Unterstützung, die standardmäßig unter 127.0.0.1:4447 aktiviert ist. Die Konfiguration in i2pd.conf unter [SOCKSProxy] ermöglicht es Ihnen, Port, Host und tunnel-Parameter anzupassen.\n5. Entwicklungszeitplan Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 Das SOCKS-Modul selbst hat seit 2013 keine größeren Protokoll-Updates erhalten, aber der umgebende Tunnel-Stack hat Leistungs- und kryptografische Verbesserungen erfahren. 6. Empfohlene Alternativen Für jede Produktions-, öffentlich zugängliche oder sicherheitskritische Anwendung verwenden Sie eine der offiziellen I2P-APIs anstelle von SOCKS:\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM Diese APIs bieten ordnungsgemäße Zieltrennung, kryptografische Identitätskontrolle und bessere Routing-Leistung. 7. OnionCat / GarliCat OnionCat unterstützt I2P durch seinen GarliCat-Modus (fd60:db4d:ddb5::/48 IPv6-Bereich). Weiterhin funktionsfähig, aber mit eingeschränkter Entwicklung seit 2019.\nNutzungseinschränkungen: - Erfordert manuelle .oc.b32.i2p-Konfiguration in SusiDNS - Benötigt statische IPv6-Zuweisung - Wird nicht offiziell vom I2P-Projekt unterstützt\nNur für fortgeschrittene VPN-über-I2P-Setups empfohlen.\n8. Bewährte Verfahren Falls Sie SOCKS verwenden müssen: 1. Erstellen Sie separate Tunnel pro Anwendung. 2. Deaktivieren Sie den gemeinsamen Client-Modus. 3. Aktivieren Sie persistente Schlüssel. 4. Erzwingen Sie SOCKS5-DNS-Auflösung. 5. Überprüfen Sie das Protokollverhalten auf Lecks. 6. Vermeiden Sie Clearnet-Verbindungen. 7. Überwachen Sie den Netzwerkverkehr auf Lecks.\n9. Technische Zusammenfassung Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) --- 10. Fazit Der SOCKS-Proxy in I2P bietet grundlegende Kompatibilität mit bestehenden TCP-Anwendungen, ist jedoch nicht für starke Anonymitätsgarantien ausgelegt. Er sollte nur in kontrollierten, geprüften Testumgebungen verwendet werden.\nFür ernsthafte Bereitstellungen migrieren Sie zu SAM v3 oder der Streaming API. Diese APIs isolieren Anwendungsidentitäten, verwenden moderne Kryptographie und werden kontinuierlich weiterentwickelt.\nZusätzliche Ressourcen Offizielle SOCKS-Dokumentation SAM v3 Spezifikation Streaming Library Dokumentation I2PTunnel Referenz I2P Entwickler-Dokumentation Community-Forum ","description":"I2Ps SOCKS-Tunnel sicher verwenden (aktualisiert für 2.10.0)","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"SOCKS-Proxy","url":"/de/docs/api/socks/"},{"categories":null,"content":"Übersicht Zweck ECIES-X25519-AEAD-Ratchet (ein Verfahren zur Ende-zu-Ende-Verschlüsselung) ist I2Ps modernes Ende-zu-Ende-Verschlüsselungsprotokoll und ersetzt das Legacy-System ElGamal/AES+SessionTags. Es bietet Vorwärtsgeheimnis, authentifizierte Verschlüsselung und deutliche Verbesserungen bei Leistung und Sicherheit.\nWesentliche Verbesserungen gegenüber ElGamal/AES+SessionTags Kleinere Schlüssel: 32-Byte-Schlüssel gegenüber 256-Byte-ElGamal-öffentlichen Schlüsseln (87,5 % Verringerung) Vorwärtsgeheimnis: Erreicht durch DH-Ratcheting (schrittweise Schlüsselaktualisierung; im Legacy-Protokoll nicht verfügbar) Moderne Kryptografie: X25519 DH, ChaCha20-Poly1305 AEAD, SHA-256 Authentifizierte Verschlüsselung: Integrierte Authentifizierung durch AEAD-Konstruktion Bidirektionales Protokoll: Gekoppelte eingehende/ausgehende Sitzungen gegenüber unidirektionalem Legacy-Protokoll Effiziente Tags: 8-Byte-Sitzungs-Tags gegenüber 32-Byte-Tags (75 % Verringerung) Verschleierung des Datenverkehrs: Elligator2-Codierung macht Handshakes ununterscheidbar vom Zufall Bereitstellungsstatus Erstveröffentlichung: Version 0.9.46 (25. Mai 2020) Netzwerkbereitstellung: Seit 2020 abgeschlossen Aktueller Status: Ausgereift, breit ausgerollt (seit über 5 Jahren im produktiven Einsatz) Router-Unterstützung: Version 0.9.46 oder höher erforderlich Floodfill-Anforderungen: Nahezu 100% Verbreitung für verschlüsselte Lookups Implementierungsstatus Vollständig implementiert: - New Session (NS)-Nachrichten mit Bindung - New Session Reply (NSR)-Nachrichten - Existing Session (ES)-Nachrichten - DH-Ratchet-Mechanismus (Ratschenmechanismus) - Session-Tag- und symmetrische Schlüssel-Ratchets - DateTime-, NextKey-, ACK-, ACK Request-, Garlic Clove- und Padding-Blöcke\nNicht implementiert (Stand: Version 0.9.50): - MessageNumbers-Block (Typ 6) - Options-Block (Typ 5) - Termination-Block (Typ 4) - Automatische Antworten auf Protokollebene - Zero-Static-Key-Modus - Multicast-Sitzungen\nHinweis: Der Implementierungsstatus für die Versionen 1.5.0 bis 2.10.0 (2021-2025) erfordert eine Überprüfung, da möglicherweise einige Funktionen hinzugefügt wurden.\nProtokollgrundlagen Noise Protocol Framework (kryptografisches Protokoll-Framework) ECIES-X25519-AEAD-Ratchet (Ratchet-Verfahren auf Basis von ECIES, X25519 und AEAD) basiert auf dem Noise Protocol Framework (Protokollrahmen „Noise“, Revision 34, 2018-07-11), insbesondere auf dem IK (Interactive, Known remote static key – interaktiv, bekannter statischer Schlüssel der Gegenstelle) Handshake-Muster mit I2P-spezifischen Erweiterungen.\nBezeichner des Noise-Protokolls Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 Bezeichner-Komponenten: - Noise - Basis-Framework - IK - Interaktives Handshake-Muster mit bekanntem entfernten statischen Schlüssel - elg2 - Elligator2-Codierung für ephemere Schlüssel (I2P extension) - +hs2 - MixHash wird vor der zweiten Nachricht aufgerufen, um das Tag einzumischen (I2P extension) - 25519 - X25519-Diffie-Hellman-Funktion - ChaChaPoly - ChaCha20-Poly1305-AEAD-Chiffre - SHA256 - SHA-256-Hashfunktion\nNoise Handshake-Muster IK-Musternotation:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) Bedeutungen der Token: - e - Übertragung eines ephemeren Schlüssels - s - Übertragung eines statischen Schlüssels - es - DH (Diffie-Hellman-Schlüsselaustausch) zwischen Alices ephemerem Schlüssel und Bobs statischem Schlüssel - ss - DH zwischen Alices statischem Schlüssel und Bobs statischem Schlüssel - ee - DH zwischen Alices ephemerem Schlüssel und Bobs ephemerem Schlüssel - se - DH zwischen Bobs statischem Schlüssel und Alices ephemerem Schlüssel\nSicherheitseigenschaften von Noise In der Terminologie von Noise bietet das IK pattern (IK-Muster):\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) **Authentifizierungsstufen:** - **Stufe 1**: Die Nutzdaten sind authentifiziert und dem Inhaber des statischen Schlüssels des Senders zugeordnet, sind jedoch anfällig für Key Compromise Impersonation (KCI; Identitätsanmaßung bei kompromittiertem Schlüssel) - **Stufe 2**: Resistent gegen KCI-Angriffe nach NSR (Sitzungsneustart) Vertraulichkeitsstufen: - Stufe 2: Vorwärtsgeheimnis, falls der statische Schlüssel des Absenders später kompromittiert wird - Stufe 4: Vorwärtsgeheimnis, falls der ephemere Schlüssel des Absenders später kompromittiert wird - Stufe 5: Vollständiges Vorwärtsgeheimnis, nachdem beide ephemeren Schlüssel gelöscht wurden\nUnterschiede zwischen IK und XK Das IK-Muster unterscheidet sich von dem in NTCP2 und SSU2 verwendeten XK-Muster:\nVier DH-Operationen: IK verwendet 4 DH-Operationen (es, ss, ee, se) gegenüber 3 bei XK Sofortige Authentifizierung: Alice wird in der ersten Nachricht authentifiziert (Authentifizierungsstufe 1) Schnellere Herstellung des Vorwärtsgeheimnisses: Volles Vorwärtsgeheimnis (Stufe 5) wird nach der zweiten Nachricht erreicht (1-RTT) Kompromiss: Die Nutzlast der ersten Nachricht ist nicht vorwärtsgeheim (im Gegensatz zu XK, wo alle Nutzlasten vorwärtsgeheim sind) Zusammenfassung: IK ermöglicht die 1-RTT-Übermittlung von Bobs Antwort mit vollständigem Vorwärtsgeheimnis, auf Kosten dessen, dass die anfängliche Anfrage nicht vorwärtsgeheim ist.\nKonzepte der Signal-Double-Ratchet ECIES (Elliptic Curve Integrated Encryption Scheme, integriertes Verschlüsselungsschema mit elliptischen Kurven) integriert Konzepte aus dem Signal Double Ratchet-Algorithmus :\nDH Ratchet (Ratchet-Mechanismus auf Basis von Diffie-Hellman): Bietet Vorwärtsgeheimnis, indem periodisch neue DH-Schlüssel ausgetauscht werden Symmetric Key Ratchet (symmetrischer Ratchet-Mechanismus für Schlüssel): Leitet für jede Nachricht neue Sitzungsschlüssel ab Session Tag Ratchet (Ratchet-Mechanismus für Sitzungs-Tags): Erzeugt deterministisch Sitzungs-Tags zur einmaligen Verwendung Wesentliche Unterschiede zu Signal: - Selteneres Ratcheting (schrittweise Schlüsselaktualisierung): I2P führt Ratcheting nur bei Bedarf durch (bei nahezu erschöpften Tags oder per Richtlinie) - Session-Tags statt Header-Verschlüsselung: Verwendet deterministische Tags statt verschlüsselter Header - Explizite ACKs (Empfangsbestätigungen): Verwendet In-Band-ACK-Blöcke, statt sich ausschließlich auf Rückverkehr zu verlassen - Getrennte Tag- und Schlüssel-Ratchets: Effizienter für den Empfänger (kann die Schlüsselberechnung aufschieben)\nI2P-Erweiterungen für Noise Elligator2-Codierung: Ephemere Schlüssel werden so codiert, dass sie nicht von Zufallsdaten zu unterscheiden sind Tag vor NSR vorangestellt: Session-Tag wird zur Korrelation vor die NSR-Nachricht gesetzt Definiertes Nutzlastformat: Blockbasierte Nutzlaststruktur für alle Nachrichtentypen I2NP-Kapselung: Alle Nachrichten werden in I2NP Garlic Message-Headern eingebettet Getrennte Datenphase: Transportnachrichten (ES) weichen von der standardmäßigen Noise (Protokollrahmenwerk)-Datenphase ab Kryptografische Primitive X25519 Diffie-Hellman Spezifikation: RFC 7748 Wesentliche Eigenschaften: - Größe des privaten Schlüssels: 32 Bytes - Größe des öffentlichen Schlüssels: 32 Bytes - Größe des gemeinsamen Geheimnisses: 32 Bytes - Byte-Reihenfolge (Endianness): Little-endian - Kurve: Curve25519\nOperationen:\nX25519 GENERATE_PRIVATE() Erzeugt einen zufälligen privaten Schlüssel mit 32 Byte:\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) Leitet den entsprechenden öffentlichen Schlüssel ab:\npubkey = curve25519_scalarmult_base(privkey) Gibt einen 32 Byte großen, im Little-Endian-Format vorliegenden öffentlichen Schlüssel zurück.\nX25519 DH(privkey, pubkey) Führt einen Diffie-Hellman-Schlüsselaustausch durch:\nsharedSecret = curve25519_scalarmult(privkey, pubkey) Gibt ein 32 Byte langes gemeinsames Geheimnis zurück.\nSicherheitshinweis: Implementierer müssen prüfen, dass das gemeinsame Geheimnis nicht nur aus Nullen besteht (schwacher Schlüssel). In diesem Fall ablehnen und den Handshake abbrechen.\nChaCha20-Poly1305 AEAD (Authentifizierte Verschlüsselung mit assoziierten Daten) Spezifikation: RFC 7539 Abschnitt 2.8\nParameter: - Schlüsselgröße: 32 Byte (256 Bit) - Nonce-Größe: 12 Byte (96 Bit) - MAC-Größe: 16 Byte (128 Bit) - Blockgröße: 64 Byte (intern)\nNonce (Einmalwert)-Format:\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) AEAD-Konstruktion:\nDas AEAD (authentifizierte Verschlüsselung mit zugeordneten Daten) kombiniert die Stromchiffre ChaCha20 mit dem Poly1305-MAC:\nChaCha20-Schlüsselstrom aus Schlüssel und Nonce erzeugen Klartext per XOR mit dem Schlüsselstrom verschlüsseln Poly1305-MAC über (assoziierte Daten || Geheimtext) berechnen 16-Byte-MAC an den Geheimtext anhängen ChaCha20-Poly1305 ENCRYPT(k, n, plaintext, ad) Verschlüsselt Klartext mit Authentifizierung:\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 Eigenschaften: - Der Geheimtext hat dieselbe Länge wie der Klartext (Stromchiffre) - Die Ausgabe ist plaintext_length + 16 Bytes (enthält MAC) - Die gesamte Ausgabe ist nicht von zufälligen Daten zu unterscheiden, wenn der Schlüssel geheim ist - Der MAC authentifiziert sowohl die assoziierten Daten als auch den Geheimtext\nChaCha20-Poly1305 ENTSCHLÜSSELN(k, n, ciphertext, ad) Entschlüsselt und überprüft die Authentifizierung:\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext Kritische Sicherheitsanforderungen: - Nonces (einmalige Werte) MÜSSEN für jede Nachricht mit demselben Schlüssel eindeutig sein - Nonces DÜRFEN NICHT wiederverwendet werden (katastrophales Versagen bei Wiederverwendung) - Die Verifikation des MAC (Nachrichten-Authentifizierungscode) MUSS einen zeitkonstanten Vergleich verwenden, um Timing-Angriffe zu verhindern - Eine fehlgeschlagene MAC-Verifikation MUSS zur vollständigen Ablehnung der Nachricht führen (keine teilweise Entschlüsselung)\nSHA-256-Hashfunktion Spezifikation: NIST FIPS 180-4\nEigenschaften: - Ausgabegröße: 32 Byte (256 Bit) - Blockgröße: 64 Byte (512 Bit) - Sicherheitsniveau: 128 Bit (Kollisionsresistenz)\nOperationen:\nSHA-256 H(p, d) SHA-256-Hash mit Personalization String (Personalisierungszeichenkette):\nH(p, d) := SHA256(p || d) Wobei || die Verkettung bezeichnet, p für den Personalisierungsstring steht und d für die Daten.\nSHA-256 MixHash(d) Aktualisiert den laufenden Hash mit neuen Daten:\nh = SHA256(h || d) Wird im gesamten Noise handshake (Aushandlung im Noise-Protokoll) verwendet, um den Transkript-Hash fortzuschreiben.\nHKDF-Schlüsselableitung Spezifikation: RFC 5869 Beschreibung: HMAC-basierte Schlüsselableitungsfunktion mit SHA-256\nParameter: - Hashfunktion: HMAC-SHA256 - Salt-Länge: Bis zu 32 Byte (SHA-256-Ausgabegröße) - Ausgabelänge: Variabel (bis zu 255 * 32 Byte)\nHKDF-Funktion:\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] Häufige Nutzungsmuster:\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] In ECIES verwendete Info-Strings: - \u0026quot;KDFDHRatchetStep\u0026quot; - Schlüsselableitung der DH-Ratchet (Schrittmechanismus zur Schlüsselaktualisierung) - \u0026quot;TagAndKeyGenKeys\u0026quot; - Initialisierung der Tag- und Schlüsselketten-Schlüssel - \u0026quot;STInitialization\u0026quot; - Initialisierung der Session-Tag-Ratchet - \u0026quot;SessionTagKeyGen\u0026quot; - Generierung von Session-Tags - \u0026quot;SymmetricRatchet\u0026quot; - Generierung symmetrischer Schlüssel - \u0026quot;XDHRatchetTagSet\u0026quot; - Tagset-Schlüssel der DH-Ratchet - \u0026quot;SessionReplyTags\u0026quot; - Generierung des NSR-Tagsets - \u0026quot;AttachPayloadKDF\u0026quot; - Schlüsselableitung für die NSR-Nutzlast\nElligator2-Kodierung (kryptografisches Abbildungsverfahren) Zweck: Öffentliche X25519-Schlüssel (ECDH-Verfahren auf Basis von Curve25519) so kodieren, dass sie von gleichverteilten zufälligen 32-Byte-Folgen nicht zu unterscheiden sind.\nSpezifikation: Elligator2 Paper Problem: Standardmäßige öffentliche X25519-Schlüssel haben eine erkennbare Struktur. Ein Beobachter kann Handshake-Nachrichten identifizieren, indem er diese Schlüssel erkennt, selbst wenn der Inhalt verschlüsselt ist.\nLösung: Elligator2 bietet eine bijektive Abbildung zwischen ~50% der gültigen X25519-öffentlichen Schlüssel und zufällig aussehenden 254-Bit-Zeichenfolgen.\nSchlüsselgenerierung mit Elligator2 (kryptografisches Verfahren zur Abbildung elliptischer Kurvenpunkte auf zufällig aussehende Bytes):\nElligator2 GENERATE_PRIVATE_ELG2() Erzeugt einen privaten Schlüssel, der zu einem öffentlichen Schlüssel gehört, der mit Elligator2 (ein Kodierungsverfahren für elliptische Kurvenpunkte) kodierbar ist:\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue Wichtig: Etwa 50 % der zufällig erzeugten privaten Schlüssel führen zu nicht kodierbaren öffentlichen Schlüsseln. Diese müssen verworfen werden; anschließend ist eine Neugenerierung zu versuchen.\nLeistungsoptimierung: Schlüssel vorab in einem Hintergrund-Thread generieren, um einen Pool geeigneter Schlüsselpaare bereitzuhalten und Verzögerungen während des Handshakes zu vermeiden.\nElligator2 ENCODE_ELG2(pubkey) Kodiert einen öffentlichen Schlüssel in 32 zufällig aussehende Bytes:\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey Details zur Kodierung: - Elligator2 liefert 254 Bit (nicht volle 256 Bit) - Die obersten 2 Bit von Byte 31 sind zufälliges Padding (Auffüllung) - Das Ergebnis ist gleichmäßig über den 32-Byte-Raum verteilt - Kodiert erfolgreich etwa 50 % der gültigen öffentlichen X25519-Schlüssel\nElligator2 DECODE_ELG2(encodedKey) Dekodiert zurück zum ursprünglichen öffentlichen Schlüssel:\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey Sicherheitseigenschaften: - Kodierte Schlüssel sind rechnerisch nicht von zufälligen Bytes unterscheidbar - Keine statistischen Tests können Elligator2-kodierte Schlüssel zuverlässig erkennen - Das Dekodieren ist deterministisch (der gleiche kodierte Schlüssel erzeugt stets denselben öffentlichen Schlüssel) - Das Kodieren ist für die ~50% der Schlüssel in der kodierbaren Teilmenge bijektiv\nImplementierungshinweise: - Kodierte Schlüssel in der Generierungsphase speichern, um eine erneute Kodierung während des Handshakes zu vermeiden - Ungeeignete Schlüssel aus der Elligator2-Generierung können für NTCP2 verwendet werden (das kein Elligator2 benötigt) - Die Schlüsselerzeugung im Hintergrund ist für die Leistung entscheidend - Die durchschnittliche Generierungszeit verdoppelt sich aufgrund einer Ablehnungsrate von 50 %\nNachrichtenformate Übersicht ECIES definiert drei Nachrichtentypen:\nNeue Sitzung (NS): Initiale Handshake-Nachricht von Alice an Bob Antwort auf neue Sitzung (NSR): Bobs Handshake-Antwort an Alice Bestehende Sitzung (ES): Alle nachfolgenden Nachrichten in beiden Richtungen Alle Nachrichten werden im I2NP Garlic Message-Format (I2NP-Nachrichtenformat mit \u0026lsquo;Garlic\u0026rsquo;-Struktur) mit zusätzlichen Verschlüsselungsschichten gekapselt.\nI2NP Garlic Message (Knoblauch-Nachricht) Container Alle ECIES-Nachrichten werden in standardmäßige I2NP Garlic Message-Header eingekapselt:\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ Felder: - type: 0x26 (Garlic-Nachricht) - msg_id: 4-Byte I2NP-Nachrichten-ID - expiration: 8-Byte-Unix-Zeitstempel (Millisekunden) - size: 2-Byte-Nutzlastgröße - chks: 1-Byte-Prüfsumme - length: 4-Byte-Länge der verschlüsselten Daten - encrypted data: ECIES-verschlüsselte Nutzlast\nZweck: Ermöglicht die Nachrichtenidentifizierung und das Routing auf der I2NP-Schicht. Das Feld length ermöglicht es den Empfängern, die gesamte Größe der verschlüsselten Nutzlast zu ermitteln.\nNeue Sitzung (NS)-Nachricht Die New Session-Nachricht initiiert eine neue Sitzung von Alice zu Bob. Sie kommt in drei Varianten vor:\nMit Bindung (1b): Enthält Alices statischen Schlüssel für bidirektionale Kommunikation Ohne Bindung (1c): Verzichtet auf den statischen Schlüssel für eindirektionale Kommunikation Einmal (1d): Einzelnachrichtenmodus ohne Sitzungsaufbau NS-Nachricht mit Bindung (Typ 1b) Anwendungsfall: Streaming, antwortfähige Datagramme, jedes Protokoll, das Antworten erfordert\nGesamtlänge: 96 + payload_length Bytes\nFormat:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Details zum Feld:\nEphemerer öffentlicher Schlüssel (32 Byte, Klartext): - Alices einmaliger X25519-öffentlicher Schlüssel - Kodiert mit Elligator2 (nicht von Zufallsdaten zu unterscheiden) - Für jede NS-Nachricht neu erzeugt (niemals wiederverwendet) - Little-Endian-Format\nAbschnitt für statischen Schlüssel (32 Bytes verschlüsselt, 48 Bytes mit MAC): - Enthält Alices statischen öffentlichen X25519-Schlüssel (32 Bytes) - Mit ChaCha20 verschlüsselt - Mit Poly1305-MAC authentifiziert (16 Bytes) - Von Bob verwendet, um die Sitzung an Alices Destination (Zieladresse) zu binden\nNutzlastabschnitt (mit variabler Länge verschlüsselt, +16 Bytes MAC): - Enthält garlic cloves (Einzelteile einer Garlic-Nachricht) und andere Blöcke - Muss den DateTime-Block als ersten Block enthalten - Enthält üblicherweise Garlic Clove-Blöcke mit Anwendungsdaten - Kann den NextKey-Block für immediate ratchet (sofortige Schlüsselfortschaltung) enthalten - Verschlüsselt mit ChaCha20 - Authentifiziert mit Poly1305 MAC (16 Bytes)\nSicherheitseigenschaften: - Ephemerer Schlüssel stellt die Vorwärtsgeheimnis-Komponente bereit - Statischer Schlüssel authentifiziert Alice (Bindung an das Ziel) - Beide Abschnitte haben separate MACs zur Domänentrennung - Der gesamte Handshake führt 2 DH-Operationen aus (es, ss)\nNS-Nachricht ohne Bindung (Typ 1c) Anwendungsfall: Rohdatagramme, bei denen keine Antwort erwartet oder gewünscht ist\nGesamtlänge: 96 + payload_length Bytes\nFormat:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Wesentlicher Unterschied: Der Flags-Abschnitt enthält 32 Bytes mit Nullen anstelle eines statischen Schlüssels.\nErkennung: Bob bestimmt den Nachrichtentyp, indem er den 32-Byte-Abschnitt entschlüsselt und prüft, ob alle Bytes Null sind: - Alle Bytes sind Null → Ungebundene Sitzung (Typ 1c) - Nicht alle Bytes sind Null → Gebundene Sitzung mit statischem Schlüssel (Typ 1b)\nEigenschaften: - Kein statischer Schlüssel bedeutet keine Bindung an Alices Zieladresse - Bob kann keine Antworten senden (keine Zieladresse bekannt) - Führt nur 1 DH-Operation aus - Folgt dem Noise (Kryptografie-Protokoll-Framework) \u0026ldquo;N\u0026rdquo;-Muster statt \u0026ldquo;IK\u0026rdquo; - Effizienter, wenn Antworten nie benötigt werden\nFlags-Abschnitt (für zukünftige Verwendung reserviert): Derzeit nur Nullen. Kann in zukünftigen Versionen für die Aushandlung von Funktionen verwendet werden.\nNS Einmalnachricht (Typ 1d) Anwendungsfall: Einzelne anonyme Nachricht ohne erwartete Sitzung oder Antwort\nGesamtlänge: 96 + payload_length Bytes\nFormat: Identisch mit NS ohne Bindung (Typ 1c)\nUnterscheidung: - Typ 1c kann mehrere Nachrichten in derselben Sitzung senden (ES-Nachrichten folgen) - Typ 1d sendet genau eine Nachricht ohne Sitzungsaufbau - In der Praxis könnten Implementierungen diese zunächst identisch behandeln\nEigenschaften: - Maximale Anonymität (kein statischer Schlüssel, keine Sitzung) - Von keiner der Parteien wird Sitzungszustand beibehalten - Folgt dem Noise \u0026ldquo;N\u0026rdquo;-Muster - Eine einzige DH-Operation (es)\nNew Session Reply (NSR)-Nachricht Bob sendet als Antwort auf Alices NS-Nachricht eine oder mehrere NSR-Nachrichten. NSR schließt den Noise IK handshake (Noise-Handshake nach dem IK-Muster) ab und stellt eine bidirektionale Sitzung her.\nGesamtlänge: 72 + payload_length Bytes\nFormat:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Felddetails:\nSession-Tag (8 Bytes, Klartext): - Generiert aus dem NSR-Tagset (siehe KDF-Abschnitte) - Ordnet diese Antwort der NS-Nachricht von Alice zu - Ermöglicht Alice zu erkennen, auf welche NS diese NSR antwortet - Einmalige Verwendung (niemals wiederverwendet)\nEphemerer öffentlicher Schlüssel (32 Bytes, Klartext): - Bobs einmaliger öffentlicher X25519-Schlüssel - Mit Elligator2 kodiert - Für jede NSR-Nachricht neu erzeugt - Muss für jede gesendete NSR unterschiedlich sein\nMAC des Schlüsselabschnitts (16 Bytes): - Authentifiziert leere Daten (ZEROLEN) - Teil des Noise-IK-Protokolls (se pattern; statisch-ephemeres Muster) - Verwendet das Hash-Transkript als assoziierte Daten - Kritisch für die Bindung von NSR an NS\nNutzdatenabschnitt (variable Länge): - Enthält garlic cloves (Einzelnachrichten im Garlic-Verfahren) und Blöcke - Enthält normalerweise Antworten auf Anwendungsebene - Kann leer sein (ACK-only NSR) - Maximale Größe: 65519 Bytes (65535 - 16 Byte MAC)\nMehrere NSR-Nachrichten:\nBob kann als Antwort auf eine NS (Nachrichtentyp) mehrere NSR-Nachrichten (Nachrichtentyp) senden: - Jede NSR-Nachricht hat einen eindeutigen ephemeren Schlüssel - Jede NSR-Nachricht hat einen eindeutigen Session-Tag - Alice verwendet die zuerst empfangene NSR-Nachricht, um den Handshake abzuschließen - Weitere NSR-Nachrichten dienen der Redundanz (für den Fall von Paketverlust)\nKritisches Timing: - Alice muss eine NSR empfangen, bevor sie ES-Nachrichten sendet - Bob muss eine ES-Nachricht empfangen, bevor er ES-Nachrichten sendet - NSR etabliert bidirektionale Sitzungsschlüssel über die split()-Operation\nSicherheitseigenschaften: - Schließt den Noise IK handshake (Handshake des Noise-IK-Protokolls) ab - Führt 2 zusätzliche DH-Operationen (ee, se) aus - Insgesamt 4 DH-Operationen über NS+NSR - Erreicht gegenseitige Authentifizierung (Stufe 2) - Bietet schwaches Vorwärtsgeheimnis (Stufe 4) für die NSR-Nutzlast\nNachricht zur bestehenden Sitzung (ES) Alle Nachrichten nach dem NS/NSR-Handshake verwenden das Existing Session-Format (Format für eine bestehende Sitzung). ES-Nachrichten werden bidirektional sowohl von Alice als auch von Bob verwendet.\nGesamtlänge: 8 + payload_length + 16 Bytes (mindestens 24 Bytes)\nFormat:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ Details zum Feld:\nSession-Tag (8 Bytes, Klartext): - Generiert aus dem aktuellen ausgehenden Tagset (Menge von Tags) - Identifiziert die Sitzung und die Nachrichtennummer - Empfänger schlägt den Tag nach, um Sitzungsschlüssel und Nonce (Einmalwert) zu finden - Einmalige Verwendung (jeder Tag wird genau einmal verwendet) - Format: Erste 8 Bytes der HKDF-Ausgabe\nNutzlastabschnitt (variable Länge): - Enthält Garlic Cloves (Einzelelemente einer Garlic-Nachricht) und Blöcke - Keine erforderlichen Blöcke (kann leer sein) - Übliche Blöcke: Garlic Clove, NextKey, ACK, ACK Request, Padding - Maximale Größe: 65519 Bytes (65535 - 16-Byte-MAC)\nMAC (16 Bytes): - Poly1305-Authentifizierungstag - Über die gesamte Nutzlast berechnet - Assoziierte Daten: das 8-Byte session tag (Sitzungs-Tag) - Muss korrekt verifiziert werden, sonst wird die Nachricht verworfen\nAblauf der Tag-Abfrage:\nEmpfänger extrahiert 8-Byte-Tag Schlägt das Tag in allen aktuellen eingehenden Tagsets nach Ruft den zugehörigen Sitzungsschlüssel und die Nachrichtennummer N ab Erzeugt die Nonce: [0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] Entschlüsselt die Nutzlast mit AEAD (Authentifizierte Verschlüsselung mit zusätzlichen Daten), wobei das Tag als zugehörige Daten verwendet wird Entfernt das Tag aus dem Tagset (Einmalverwendung) Verarbeitet die entschlüsselten Blöcke Session Tag (Sitzungs-Tag) nicht gefunden:\nWenn tag (Sitzungs-Tag) in keinem tagset (Satz von Sitzungs-Tags) gefunden wird: - Kann eine NS-Nachricht sein → NS-Entschlüsselung versuchen - Kann eine NSR-Nachricht sein → NSR-Entschlüsselung versuchen - Kann eine ES außer der Reihenfolge sein → kurz auf tagset-Aktualisierung warten - Kann ein Replay-Angriff sein → ablehnen - Kann beschädigte Daten sein → ablehnen\nLeere Nutzdaten:\nES messages (ES-Nachrichten) können leere Nutzlasten (0 Bytes) haben: - Dient als explizites ACK, wenn eine ACK-Anforderung empfangen wurde - Liefert eine Antwort auf Protokollebene ohne Anwendungsdaten - Verbraucht dennoch einen session tag (Session-Tag, Kennzeichen einer Sitzung) - Nützlich, wenn die höhere Schicht keine sofort zu sendenden Daten hat\nSicherheitsmerkmale: - Vollständige Vorwärtsgeheimhaltung (Stufe 5) nach Empfang von NSR - Authentifizierte Verschlüsselung mit AEAD - Tag dient als zusätzliche assoziierte Daten - Maximal 65535 Nachrichten pro tagset (Tag-Satz), bevor ein Ratchet (Schlüsselfortschaltung) erforderlich ist\nSchlüsselableitungsfunktionen Dieser Abschnitt dokumentiert alle in ECIES verwendeten KDF-Operationen und zeigt die vollständigen kryptografischen Ableitungen.\nNotation und Konstanten Konstanten: - ZEROLEN - Byte-Array der Länge Null (leerer String) - || - Verkettungsoperator\nVariablen: - h - Fortlaufendes Hash-Protokoll (32 Bytes) - chainKey - Kettenschlüssel für HKDF (32 Bytes) - k - Symmetrischer Chiffrierschlüssel (32 Bytes) - n - Nonce (Einmalwert) / Nachrichtennummer\nSchlüssel: - ask / apk - Alices statischer privater/öffentlicher Schlüssel - aesk / aepk - Alices ephemerer privater/öffentlicher Schlüssel - bsk / bpk - Bobs statischer privater/öffentlicher Schlüssel - besk / bepk - Bobs ephemerer privater/öffentlicher Schlüssel\nKDFs für NS-Nachrichten KDF 1: Initialer Kettenschlüssel Einmalig bei der Protokollinitialisierung ausgeführt (kann vorab berechnet werden):\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions Ergebnis: - chainKey = anfänglicher Verkettungsschlüssel für alle nachfolgenden Schlüsselableitungsfunktionen (KDFs) - h = anfänglicher Transkript-Hash\nKDF 2: Bobs statische Schlüsselmischung Bob führt dies einmalig aus (kann für alle eingehenden Sitzungen im Voraus berechnet werden):\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF 3: Alices ephemere Schlüsselgenerierung Alice erzeugt für jede NS‑Nachricht neue Schlüssel:\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF 4: NS-Abschnitt für statischen Schlüssel (es DH) Leitet Schlüssel zur Verschlüsselung von Alices statischem Schlüssel ab:\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF 5: NS-Nutzdatenabschnitt (ss DH, nur gebunden) Für gebundene Sessions einen zweiten DH für die Nutzlastverschlüsselung durchführen:\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message Wichtige Hinweise:\nBound (gebunden) vs Unbound (ungebunden):\nBound führt 2 DH-Operationen durch (es + ss) Unbound führt 1 DH-Operation durch (nur es) Unbound inkrementiert die Nonce, anstatt einen neuen Schlüssel abzuleiten Sicherheit vor Schlüsselwiederverwendung:\nUnterschiedliche Nonces (Einmalwerte) (0 vs 1) verhindern die Wiederverwendung desselben Schlüssel/Nonce-Paares Unterschiedliche Associated Data (zusätzliche authentifizierte Daten) (h ist unterschiedlich) sorgen für Domänentrennung Hash-Transkript:\nh enthält jetzt: protocol_name, leerer Prolog, bpk, aepk, static_key_ciphertext, payload_ciphertext Dieses Transkript verknüpft alle Teile der NS-Nachricht miteinander NSR Reply Tagset KDF (Schlüsselableitungsfunktion) Bob generiert Tags für NSR-Nachrichten:\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR KDFs für NSR-Nachrichten (Schlüsselableitungsfunktionen) KDF 6: Ephemere Schlüsselerzeugung für NSR Bob generiert für jede NSR einen frischen ephemeren Schlüssel:\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7: NSR-Schlüsselabschnitt (ee und se DH) Leitet Schlüssel für den NSR-Schlüsselabschnitt ab:\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR Kritisch: Dies vervollständigt den Noise IK handshake (Handshake des Noise-IK-Protokolls). chainKey enthält nun Beiträge aus allen 4 DH-Operationen (es, ss, ee, se).\nKDF 8: NSR-Nutzlastabschnitt Leitet Schlüssel für die NSR-Nutzlastverschlüsselung ab:\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message Wichtige Hinweise:\nSplit-Operation:\nErzeugt unabhängige Schlüssel für jede Richtung Verhindert die Wiederverwendung von Schlüsseln zwischen Alice→Bob und Bob→Alice NSR-Nutzlastbindung:\nVerwendet h als assoziierte Daten, um die Nutzlast an den Handshake zu binden Eine separate KDF (\u0026ldquo;AttachPayloadKDF\u0026rdquo;) sorgt für Domänentrennung ES-Bereitschaft:\nNach dem NSR können beide Parteien ES-Nachrichten senden Alice muss NSR empfangen, bevor sie ES sendet Bob muss ES empfangen, bevor er ES sendet Schlüsselableitungsfunktionen für ES-Nachrichten ES-Nachrichten verwenden vorgenerierte Sitzungsschlüssel aus tagsets:\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) Empfängerprozess:\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) DH_INITIALIZE-Funktion Erstellt ein Tagset für eine Richtung:\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset Nutzungskontexte:\nNSR-Tagset: DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) ES-Tagsets: DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) Ratcheted Tagsets (mit schrittweiser Schlüsselaktualisierung): DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) Ratchet-Mechanismen (kryptografisches Verfahren zur fortlaufenden, vorwärtssicheren Schlüsselaktualisierung) ECIES verwendet drei synchronisierte Ratchet-Mechanismen (kryptografische Ratschenmechanismen), um Vorwärtsgeheimnis zu gewährleisten und ein effizientes Sitzungsmanagement zu ermöglichen.\nRatchet-Übersicht Drei Ratchet-Typen (Kryptografie-Mechanismus zur fortlaufenden Schlüsselaktualisierung):\nDH Ratchet: Führt Diffie-Hellman-Schlüsselaustausch durch, um neue Root-Schlüssel zu erzeugen Session Tag Ratchet: Leitet einmalig verwendbare Session Tags (Sitzungs-Tags) deterministisch ab Symmetric Key Ratchet: Leitet Sitzungsschlüssel für die Nachrichtenverschlüsselung ab Beziehung:\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) Wesentliche Eigenschaften:\nSender: Erzeugt Tags und Schlüssel bei Bedarf (kein Speicher erforderlich) Empfänger: Erzeugt Tags für ein Lookahead-Fenster im Voraus (Speicher erforderlich) Synchronisierung: Der Tag-Index bestimmt den Schlüsselindex (N_tag = N_key) Vorwärtsgeheimnis: Erreicht durch periodische DH ratchet (Diffie-Hellman-Ratsche, ein periodischer Schlüsselerneuerungsmechanismus) Effizienz: Der Empfänger kann die Schlüsselberechnung bis zum Empfang des Tags aufschieben DH Ratchet (Diffie-Hellman-Ratsche) Die DH ratchet (Diffie-Hellman-Ratsche) gewährleistet Vorwärtsgeheimnis, indem in regelmäßigen Abständen neue ephemere Schlüssel ausgetauscht werden.\nDH-Ratchet-Frequenz Erforderliche Ratchet-Bedingungen (kryptografischer Schlüssel-Mechanismus): - Tag-Menge kurz vor Erschöpfung (Tag 65535 ist das Maximum) - Implementierungsspezifische Richtlinien: - Schwellwert für die Anzahl der Nachrichten (z. B. alle 4096 Nachrichten) - Zeitschwelle (z. B. alle 10 Minuten) - Schwellwert für Datenvolumen (z. B. alle 100 MB)\nEmpfohlene erste Ratchet (Schlüsselwechsel-Mechanismus): Etwa bei Tagnummer 4096, um das Erreichen des Grenzwerts zu vermeiden\nMaximale Werte: - Maximale tag set ID (Tag-Menge): 65535 - Maximale Schlüssel-ID: 32767 - Maximale Nachrichten pro tag set: 65535 - Theoretisch maximales Datenvolumen pro Sitzung: ~6.9 TB (64K tag sets × 64K Nachrichten × 1730 Bytes im Durchschnitt)\nDH Ratchet (Diffie-Hellman-basierter Ratchet-Mechanismus) Tag- und Schlüssel-IDs Initiales Tag-Set (nach dem Handshake): - Tag-Set-ID: 0 - Es wurden noch keine NextKey-Blöcke (Blöcke für den nächsten Schlüssel) gesendet - Keine Schlüssel-IDs zugewiesen\nNach dem ersten Ratchet: - Tag-Set-ID: 1 = (1 + Alices Schlüssel-ID + Bobs Schlüssel-ID) = (1 + 0 + 0) - Alice sendet NextKey (Nachfolgeschlüssel) mit Schlüssel-ID 0 - Bob antwortet mit NextKey mit Schlüssel-ID 0\nNachfolgende Tag-Sets: - Tag-Set-ID = 1 + Sender-Schlüssel-ID + Empfänger-Schlüssel-ID - Beispiel: Tag-Set 5 = (1 + sender_key_2 + receiver_key_2)\nFortschrittstabelle für Tag-Sets:\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set \\* = Neuer Schlüssel in diesem ratchet (Mechanismus zur Schlüsselaktualisierung) erzeugt Schlüssel-ID-Regeln: - IDs sind fortlaufend und beginnen bei 0 - IDs erhöhen sich nur, wenn ein neuer Schlüssel erzeugt wird - Maximale Schlüssel-ID ist 32767 (15 Bit) - Nach der Schlüssel-ID 32767 ist eine neue Sitzung erforderlich\nNachrichtenfluss der DH Ratchet (Diffie-Hellman-basiertes Schlüsselerneuerungsverfahren) Rollen: - Tag-Sender: Besitzt das ausgehende Tag-Set, sendet Nachrichten - Tag-Empfänger: Besitzt das eingehende Tag-Set, empfängt Nachrichten\nMuster: Der Tag-Sender initiiert das ratchet (Schlüsselwechselmechanismus), wenn die Tag-Menge fast erschöpft ist.\nNachrichtenflussdiagramm:\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) Ratchet-Patterns (Mechanismen zur schrittweisen Schlüsselaktualisierung):\nErstellen von Tag Sets (Tag-Sets) mit geraden Nummern (2, 4, 6, \u0026hellip;): 1. Der Sender erzeugt einen neuen Schlüssel 2. Der Sender sendet NextKey block (NextKey-Block) mit neuem Schlüssel 3. Der Empfänger sendet NextKey block mit der alten Schlüssel-ID (ACK) 4. Beide führen DH (Diffie-Hellman) mit (neuem Sender-Schlüssel × altem Empfänger-Schlüssel) durch\nErstellen von Tag-Sets mit ungeraden Nummern (3, 5, 7, \u0026hellip;): 1. Absender fordert reverse key (Schlüssel für die Gegenrichtung) an (sendet NextKey mit Request-Flag) 2. Empfänger erzeugt neuen Schlüssel 3. Empfänger sendet NextKey-Block mit neuem Schlüssel 4. Beide führen DH mit (altem Absender-Schlüssel × neuem Empfänger-Schlüssel) aus\nNextKey-Block-Format Siehe den Abschnitt zum Payload-Format für eine detaillierte Spezifikation des NextKey-Blocks.\nZentrale Elemente: - Flags-Byte: - Bit 0: Schlüssel vorhanden (1) oder nur ID (0) - Bit 1: Rückwärtsschlüssel (1) oder Vorwärtsschlüssel (0) - Bit 2: Rückwärtsschlüssel anfordern (1) oder keine Anforderung (0) - Schlüssel-ID: 2 Bytes, Big-Endian (0-32767) - Öffentlicher Schlüssel: 32 Bytes X25519 (wenn Bit 0 = 1)\nBeispiele für NextKey Blocks (NextKey-Blöcke):\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) KDF der DH-Ratsche Wenn neue Schlüssel ausgetauscht werden:\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset Kritisches Timing:\nTag-Sender: - Erstellt sofort ein neues ausgehendes Tag-Set - Beginnt sofort, neue Tags zu verwenden - Löscht das alte ausgehende Tag-Set\nTag-Empfänger: - erstellt einen neuen eingehenden Tag-Satz - behält den alten eingehenden Tag-Satz während einer Schonfrist (3 Minuten) bei - akzeptiert Tags sowohl aus dem alten als auch aus dem neuen Tag-Satz während der Schonfrist - löscht den alten eingehenden Tag-Satz nach Ablauf der Schonfrist\nVerwaltung des DH-Ratchet-Zustands (Diffie-Hellman-Ratchet, Schlüsselfortschrittsmechanismus) Senderzustand: - Aktueller ausgehender Tag-Satz - Tag-Satz-ID und Schlüssel-IDs - Nächster Root-Schlüssel (für die nächste ratchet; Kryptographie-Ratchet-Mechanismus) - Anzahl der Nachrichten im aktuellen Tag-Satz\nEmpfängerstatus: - Aktuelle eingehende Tag-Menge(n) (kann während der Übergangsphase 2 haben) - Vorherige Nachrichtennummern (PN) zur Lückenerkennung - Vorausschaufenster vorab erzeugter Tags - Nächster Root-Schlüssel (für die nächste ratchet (Schlüssel-Fortschrittsmechanismus))\nZustandsübergangsregeln:\nVor dem ersten Ratchet (Schlüsselaktualisierungsmechanismus):\nVerwendung von Tag-Set 0 (aus NSR) Keine Schlüssel-IDs zugewiesen Ratchet (kryptografischer Ratschenmechanismus) initialisieren:\nNeuen Schlüssel generieren (falls der Absender in dieser Runde an der Reihe ist) NextKey-Block in ES-Nachricht senden Vor dem Erstellen eines neuen ausgehenden Tag-Sets auf die NextKey-Antwort warten Empfangen einer Ratchet-Anfrage (kryptografischer Fortschalt-Mechanismus):\nNeuen Schlüssel erzeugen (falls der Empfänger in dieser Runde generiert) Diffie-Hellman (DH) mit dem empfangenen Schlüssel durchführen Neues eingehendes tag set (Satz von Session-Tags) erstellen NextKey-Antwort senden Altes eingehendes tag set für eine Schonfrist beibehalten Ratchet (Schlüsselwechselmechanismus) abschließen:\nNextKey-Antwort empfangen DH durchführen Neues ausgehendes Tagset erstellen Neue Tags verwenden Session Tag Ratchet (kryptografischer Erneuerungsmechanismus für Session-Tags) Das session tag ratchet (Ratschenmechanismus für session tags) erzeugt deterministisch 8-Byte session tags zur einmaligen Verwendung.\nZweck der Session Tag Ratchet Ersetzt die explizite Tag-Übertragung (ElGamal sendete 32-Byte-Tags) Ermöglicht dem Empfänger, Tags vorab für ein Look-ahead-Fenster (Vorausschaufenster) zu generieren Der Sender generiert bei Bedarf (keine Speicherung erforderlich) Synchronisiert sich über einen Index mit dem symmetric key ratchet (symmetrisches Schlüssel-Ratchet) Session-Tag-Ratchet-Formel (Kryptografie-Mechanismus für schrittweise Schlüsselaktualisierung) Initialisierung:\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset Tag-Generierung (für Tag N):\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 Vollständige Sequenz:\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] Implementierung des Session Tag Ratchet-Senders (Ratschenmechanismus für Session-Tags) class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) Senderprozess: 1. Rufen Sie get_next_tag() für jede Nachricht auf 2. Verwenden Sie den zurückgegebenen tag (Markierung) in der ES-Nachricht 3. Speichern Sie den Index N für eine mögliche Nachverfolgung von ACK (Bestätigung) 4. Keine tag-Speicherung erforderlich (wird bei Bedarf erzeugt)\nImplementierung des Empfängers für das Session Tag Ratchet (Mechanismus zur schrittweisen Aktualisierung der Session Tags) class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) Empfängerprozess: 1. Tags (Sitzungskennzeichen) für das Lookahead-Fenster vorab generieren (z. B. 32 Tags) 2. Tags in einer Hashtabelle oder einem Dictionary speichern 3. Bei Nachrichteneingang den Tag nachschlagen, um Index N zu erhalten 4. Tag aus dem Speicher entfernen (Einmalverwendung) 5. Fenster erweitern, wenn die Tag-Anzahl unter den Schwellenwert fällt\nVorausschau-Strategie für Session Tags (Sitzungs-Tags) Zweck: Abwägen zwischen Speicherverbrauch und der Verarbeitung von Nachrichten, die nicht in der richtigen Reihenfolge eintreffen\nEmpfohlene Vorausschau-Größen:\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets **Adaptive Vorausschau:** # Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 Am Ende kürzen:\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 Speicherberechnung:\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total Behandlung von Session-Tags außerhalb der Reihenfolge Szenario: Nachrichten kommen in falscher Reihenfolge an\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 Empfängerverhalten:\nEmpfange tag_5:\nNachschlagen: bei Index 5 gefunden Nachricht verarbeiten tag_5 entfernen Bisher höchstes empfangenes: 5 Empfang von tag_7 (außerhalb der Reihenfolge):\nNachschlagen: bei Index 7 gefunden Nachricht verarbeiten tag_7 entfernen Bisher höchster empfangener Wert: 7 Hinweis: tag_6 noch im Speicher (noch nicht empfangen) Empfange tag_6 (verzögert):\nNachsehen: bei Index 6 gefunden Nachricht verarbeiten tag_6 entfernen Höchster empfangener Wert: 7 (unverändert) tag_8 empfangen:\nNachschlagen: bei Index 8 gefunden Nachricht verarbeiten tag_8 entfernen Höchster Empfang: 8 Fensterverwaltung: - Den höchsten empfangenen Index nachverfolgen - Liste fehlender Indizes (Lücken) führen - Fenster basierend auf dem höchsten Index erweitern - Optional: Alte Lücken nach einem Timeout verwerfen\nSymmetric Key Ratchet (symmetrisches Schlüssel-Ratschenverfahren) Das symmetric key ratchet (symmetrischer Mechanismus zur fortlaufenden Schlüsselerneuerung) erzeugt 32-Byte-Verschlüsselungsschlüssel, die mit den session tags (Sitzungs-Tags) synchronisiert sind.\nZweck der Symmetric Key Ratchet (symmetrische KDF-Kette) Stellt für jede Nachricht einen eindeutigen Verschlüsselungsschlüssel bereit Synchronisiert mit session tag ratchet (Ratchet-Mechanismus für Sitzungstags; gleicher Index) Absender kann bei Bedarf generieren Empfänger kann die Generierung aufschieben, bis der Tag empfangen wurde Formel für die Symmetric Key Ratchet (Schlüsselfortschrittsmechanismus) Initialisierung:\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived Schlüsselgenerierung (für Schlüssel N):\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) Vollständige Abfolge:\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] Implementierung des Symmetric Key Ratchet Senders (symmetrischer Schlüssel-Ratschenmechanismus) class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) Sendeprozess: 1. Ermittle den nächsten Tag (Kennzeichen) und dessen Index N 2. Erzeuge einen Schlüssel für Index N 3. Verwende den Schlüssel, um die Nachricht zu verschlüsseln 4. Keine Schlüsselspeicherung erforderlich\nImplementierung des Empfängers für die Symmetric Key Ratchet (symmetrischer Schlüssel-Ratschenmechanismus) Strategie 1: Verzögerte Generierung (Empfohlen)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) Aufgeschobener Generierungsprozess: 1. ES-Nachricht mit Tag empfangen 2. Tag nachschlagen, um den Index N zu erhalten 3. Schlüssel 0 bis N erzeugen (falls noch nicht erzeugt) 4. Schlüssel N verwenden, um die Nachricht zu entschlüsseln 5. Chain key (Kettenschlüssel) ist jetzt am Index N positioniert\nVorteile: - Minimaler Speicherverbrauch - Schlüssel werden nur bei Bedarf erzeugt - Einfache Implementierung\nNachteile: - Muss bei der ersten Verwendung alle Schlüssel von 0 bis N erzeugen - Kann Nachrichten, die nicht in der richtigen Reihenfolge eintreffen, ohne Zwischenspeicherung nicht verarbeiten\nStrategie 2: Vorgenerierung mit Tag Window (Tag-Fenster) (Alternative)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None Vorgenerierungsprozess: 1. Schlüssel vorgenerieren, entsprechend dem tag window (Fenster für Tags) (z. B. 32 Schlüssel) 2. Schlüssel speichern, indexiert nach der Nachrichtennummer 3. Wenn ein tag empfangen wird, den entsprechenden Schlüssel nachschlagen 4. Fenster erweitern, wenn tags verwendet werden\nVorteile: - Kommt von Haus aus mit nicht in der richtigen Reihenfolge eintreffenden Nachrichten zurecht - Schneller Schlüsselabruf (keine Generierungsverzögerung)\nNachteile: - Höherer Speicherverbrauch (32 Bytes pro Schlüssel gegenüber 8 Bytes pro tag (Markierung)) - Schlüssel müssen mit tags synchron gehalten werden\nSpeichervergleich:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB Synchronisierung von Symmetric Ratchet (symmetrischer Ratchet-Mechanismus) mit Session-Tags Kritische Anforderung: Der Session-Tag-Index (Index des Sitzungs-Tags) MUSS dem Index des symmetrischen Schlüssels gleich sein\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) Fehlermodi:\nWenn die Synchronisierung abbricht: - Falscher Schlüssel für die Entschlüsselung verwendet - MAC-Überprüfung schlägt fehl - Nachricht abgelehnt\nPrävention: - Verwenden Sie immer denselben Index für Tag und Schlüssel - Überspringen Sie in keinem der beiden Ratchets (kryptografischer Ratchet-Mechanismus) Indizes - Gehen Sie mit außer der Reihenfolge eingehenden Nachrichten sorgfältig um\nKonstruktion der Nonce (Einmalwert) im symmetrischen Ratchet (Ratschenmechanismus) Die Nonce (Einmalwert) wird aus der Nachrichtennummer abgeleitet:\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) Beispiele:\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 Wichtige Eigenschaften: - Nonces sind für jede Nachricht in einem tagset (Satz von Tags) eindeutig - Nonces wiederholen sich niemals (Tags zur einmaligen Verwendung stellen dies sicher) - 8-Byte-Zähler ermöglicht 2^64 Nachrichten (wir verwenden nur 2^16) - Das Nonce-Format entspricht der zählerbasierten Konstruktion nach RFC 7539\nSitzungsverwaltung Sitzungskontext Alle eingehenden und ausgehenden Sitzungen müssen zu einem bestimmten Kontext gehören:\nRouter-Kontext: Sitzungen für den Router selbst Ziel-Kontext: Sitzungen für ein spezifisches lokales Ziel (Client-Anwendung) Kritische Regel: Sitzungen dürfen NICHT zwischen Kontexten geteilt werden, um Korrelationsangriffe zu verhindern.\nImplementierung:\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) Java-I2P-Implementierung:\nIn Java I2P stellt die Klasse SessionKeyManager folgende Funktionalität bereit: - Ein SessionKeyManager pro router - Ein SessionKeyManager pro lokaler Destination (Zieladresse) - Getrennte Verwaltung der ECIES- und ElGamal-Sitzungen innerhalb jedes Kontexts\nSitzungsbindung Bindung verknüpft eine Sitzung mit einer bestimmten Destination (Zielkennung) der Gegenstelle.\nGebundene Sitzungen Eigenschaften: - Enthält den statischen Schlüssel des Senders in der NS-Nachricht - Empfänger kann die destination (I2P-Zieladresse) des Senders identifizieren - Ermöglicht bidirektionale Kommunikation - Eine ausgehende Sitzung pro destination - Kann mehrere eingehende Sitzungen haben (während Übergangsphasen)\nAnwendungsfälle: - Streaming-Verbindungen (TCP-ähnlich) - Beantwortbare Datagramme - Jedes Protokoll, das Anfrage/Antwort erfordert\nBindevorgang:\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) Vorteile: 1. Ephemeral-Ephemeral DH: Die Antwort verwendet ee DH (perfekte Vorwärtsgeheimhaltung) 2. Sitzungskontinuität: Ratchets (zustandsbehaftete Schlüsselerneuerungen) halten die Bindung zum selben Ziel aufrecht 3. Sicherheit: Verhindert Sitzungsübernahmen (authentifiziert durch statischen Schlüssel) 4. Effizienz: Eine einzelne Sitzung pro Ziel (keine Duplizierung)\nUngebundene Sitzungen Eigenschaften: - Kein statischer Schlüssel in der NS-Nachricht (Flags-Abschnitt besteht ausschließlich aus Nullen) - Empfänger kann den Absender nicht identifizieren - Nur unidirektionale Kommunikation - Mehrere Sitzungen zur gleichen Destination (Zieladresse) erlaubt\nAnwendungsfälle: - Rohe Datagramme (fire-and-forget, ohne Bestätigung) - Anonymes Publizieren - Broadcast-ähnliche Nachrichtenübermittlung\nEigenschaften: - Anonymer (keine Absenderidentifikation) - Effizienter (1 DH vs 2 DH im Handshake) - Keine Antworten möglich (der Empfänger weiß nicht, wohin er antworten soll) - Kein session ratcheting (einmalige oder begrenzte Nutzung)\nSitzungskopplung Kopplung verbindet eine eingehende Sitzung mit einer ausgehenden Sitzung für die bidirektionale Kommunikation.\nErstellen gekoppelter Sitzungen Alices Perspektive (Initiatorin):\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) Bobs Perspektive (Antwortender):\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) Vorteile der Sitzungskopplung In-Band-ACKs: Können Nachrichten ohne separate clove (Teilnachricht im \u0026lsquo;garlic\u0026rsquo;-Nachrichtenformat) bestätigen Effizientes Ratcheting: Beide Richtungen führen den Ratchet (schrittweisen Schlüsselwechsel) synchron aus Flusskontrolle: Kann Backpressure (Gegendruck) über gepaarte Sitzungen hinweg implementieren Zustandskonsistenz: Einfacher, einen synchronisierten Zustand beizubehalten Regeln zur Sitzungszuordnung Ausgehende Sitzung kann ungepaart sein (ungebundenes NS) Eingehende Sitzung für gebundenes NS sollte gepaart sein Die Paarung erfolgt bei der Sitzungserstellung, nicht danach Gepaarte Sitzungen haben dieselbe Zielbindung Ratchets (Kryptographie-Ratchets) erfolgen unabhängig voneinander, sind jedoch koordiniert Lebenszyklus einer Sitzung Sitzungslebenszyklus: Erstellungsphase Ausgehender Sitzungsaufbau (Alice):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session Erstellung einer eingehenden Sitzung (Bob):\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session Sitzungslebenszyklus: Aktive Phase Zustandsübergänge:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED Aktive Sitzungsaufrechterhaltung:\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) Sitzungslebenszyklus: Ablaufphase Sitzungs-Timeout-Werte:\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet **Ablauflogik:** def check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) Kritische Regel: Ausgehende Sitzungen MÜSSEN vor eingehenden Sitzungen ablaufen, um eine Desynchronisierung zu verhindern.\nGeordnete Beendigung:\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() Mehrere NS-Nachrichten Szenario: Alices NS-Nachricht oder die NSR-Antwort geht verloren.\nAlices Verhalten:\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] Wichtige Eigenschaften:\nEindeutige ephemere Schlüssel: Jede NS verwendet einen anderen ephemeren Schlüssel Unabhängige Handshakes: Jede NS erzeugt einen separaten Handshake-Zustand NSR-Korrelation: Das NSR-Tag identifiziert, auf welche NS es antwortet Zustandsbereinigung: Nicht verwendete NS-Zustände werden nach erfolgreicher NSR verworfen Angriffsprävention:\nUm Ressourcenerschöpfung zu verhindern:\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context Mehrere NSR-Nachrichten Szenario: Bob sendet mehrere NSRs (engl. Akronym; hier: einzelne Antwortnachrichten; z. B. auf mehrere Nachrichten aufgeteilte Antwortdaten).\nBobs Verhalten:\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES Alices Verhalten:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake Bobs Aufräumarbeiten:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED Wichtige Eigenschaften:\nMehrere NSRs erlaubt: Bob kann pro NS mehrere NSRs senden Verschiedene ephemere Schlüssel: Jede NSR sollte einen eindeutigen ephemeren Schlüssel verwenden Gleiches NSR-Tagset: Alle NSRs für einen NS verwenden dasselbe Tagset Erstes ES gewinnt: Alices erstes ES entscheidet, welche NSR erfolgreich war Aufräumen nach ES: Bob verwirft ungenutzte Zustände nach Erhalt des ES Zustandsautomat der Sitzung Vollständiges Zustandsdiagramm:\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED Statusbeschreibungen:\nNEW: Ausgehende Sitzung erstellt, bisher noch kein NS gesendet PENDING_REPLY: NS gesendet, wartet auf NSR AWAITING_ES: NSR gesendet, wartet auf das erste ES von Alice ESTABLISHED: Handshake abgeschlossen, kann ES senden/empfangen ACTIVE: Aktiver Austausch von ES-Nachrichten RATCHETING: DH ratchet (Diffie-Hellman-Ratchet, kryptografischer Fortschaltmechanismus) läuft (Teilmenge von ACTIVE) EXPIRED: Sitzung abgelaufen, zur Löschung ausstehend TERMINATED: Sitzung explizit beendet Nutzlastformat Der Nutzlastabschnitt aller ECIES-Nachrichten (NS, NSR, ES) verwendet ein blockbasiertes Format, ähnlich wie NTCP2.\nBlockstruktur Allgemeines Format:\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Felder:\nblk: 1 Byte - Nummer des Blocktyps size: 2 Bytes - Big-Endian-Größe des Datenfelds (0-65516) data: Variable Länge - blockspezifische Daten Einschränkungen:\nMaximale ChaChaPoly-Frame-Größe: 65535 Bytes Poly1305-MAC: 16 Bytes Maximale Gesamtblockgröße: 65519 Bytes (65535 - 16) Maximaler Einzelblock: 65519 Bytes (einschließlich 3-Byte-Header) Maximale Nutzdaten eines Einzelblocks: 65516 Bytes Blocktypen Definierte Blocktypen:\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension **Behandlung unbekannter Blöcke:** Implementierungen MÜSSEN Blöcke mit unbekannten Typnummern ignorieren und sie als Padding (Auffüllung) behandeln. Dies gewährleistet die Vorwärtskompatibilität.\nRegeln für die Blockreihenfolge NS-Nachrichtenreihenfolge Erforderlich: - Der DateTime-Block MUSS zuerst stehen\nZulässig: - Garlic Clove (Teil von garlic encryption; Typ 11) - Optionen (Typ 5) - falls implementiert - Padding (Typ 254)\nUnzulässig: - NextKey, ACK, ACK Request, Termination, MessageNumbers\nBeispiel für eine gültige NS-Nutzlast:\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) Reihenfolge von NSR-Nachrichten Erforderlich: - Keine (Nutzlast kann leer sein)\nZulässig: - Garlic Clove (type 11) - Optionen (type 5) - falls implementiert - Padding (type 254)\nVerboten: - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers\nBeispiel für eine gültige NSR-Nutzlast:\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) oder\n(empty - ACK only) ES-Nachrichtenreihenfolge Erforderlich: - Keine (die Nutzlast kann leer sein)\nZulässig (beliebige Reihenfolge): - Garlic Clove (Einzelnachricht in einem Garlic-Message-Bündel; Typ 11) - NextKey (Typ 7) - ACK (Typ 8) - ACK Request (Typ 9) - Termination (Typ 4) - falls implementiert - MessageNumbers (Typ 6) - falls implementiert - Options (Typ 5) - falls implementiert - Padding (Typ 254)\nSonderregeln: - Termination (Abschlussblock) MUSS der letzte Block sein (außer Padding (Auffüllungsblock)) - Padding MUSS der letzte Block sein - Mehrere Garlic Cloves (Clove-Teilnachrichten) sind erlaubt - Bis zu 2 NextKey blocks (Block für nächsten Schlüssel) sind erlaubt (vorwärts und rückwärts) - Mehrere Padding blocks sind NICHT erlaubt\nBeispiele für gültige ES-Nutzdaten:\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) Datum/Uhrzeit-Block (Typ 0) Zweck: Zeitstempel zur Verhinderung von Replay-Angriffen und zur Prüfung der Uhrzeitabweichung\nGröße: 7 Byte (3 Byte Header + 4 Byte Daten)\nFormat:\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Felder:\nblk: 0 size: 4 (Big-Endian) timestamp: 4 Bytes - Unix-Zeitstempel in Sekunden (ohne Vorzeichen, Big-Endian) Zeitstempelformat:\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) Validierungsregeln:\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True Schutz vor Replay-Angriffen:\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass Implementierungshinweise:\nNS-Nachrichten: DateTime MUSS der erste Block sein NSR/ES-Nachrichten: DateTime ist typischerweise nicht enthalten Replay-Fenster: 5 Minuten sind das empfohlene Minimum Bloom-Filter: Empfohlen für effiziente Replay-Erkennung Uhrabweichung: 5 Minuten in der Vergangenheit, 2 Minuten in der Zukunft erlauben Garlic Clove Block (Datenblock einer Clove bei garlic encryption) (Typ 11) Zweck: Kapselt I2NP-Nachrichten zur Zustellung ein\nFormat:\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ Felder:\nblk: 11 size: Gesamtgröße der clove (Teilkomponente einer Garlic-Nachricht) (variabel) Delivery Instructions: Wie in der I2NP-Spezifikation angegeben type: I2NP-Nachrichtentyp (1 Byte) Message_ID: I2NP-Nachrichten-ID (4 Byte) Expiration: Unix-Zeitstempel in Sekunden (4 Byte) I2NP Message body: Nachrichtendaten variabler Länge Formate der Zustellhinweise:\nLokale Zustellung (1 Byte):\n+----+ |0x00| +----+ Zustellung an die Zieladresse (33 Bytes):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Router-Zustellung (33 Bytes):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Tunnel-Zustellung (37 Bytes):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ I2NP Message Header (insgesamt 9 Bytes):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: I2NP-Nachrichtentyp (Database Store, Database Lookup, Data, etc.) msg_id: 4-Byte-Nachrichtenkennung expiration: 4-Byte-Unix-Zeitstempel (Sekunden) Wichtige Unterschiede gegenüber dem ElGamal-Clove-Format:\nKein Zertifikat: Zertifikatsfeld weggelassen (in ElGamal unbenutzt) Keine Clove-ID (Teilnachricht in I2P): Clove-ID weggelassen (war immer 0) Keine Clove-Ablaufzeit: Verwendet stattdessen die Ablaufzeit der I2NP-Nachricht Kompakter Header: 9-Byte-I2NP-Header im Vergleich zum größeren ElGamal-Format Jede Clove ist ein separater Block: Keine CloveSet-Struktur Mehrere Cloves (Teilnachrichten innerhalb einer Garlic-Nachricht):\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] Gängige I2NP-Nachrichtentypen in Cloves (Teilbotschaften innerhalb von garlic encryption):\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages **Clove-Verarbeitung:** def process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) NextKey-Block (Typ 7) Zweck: Schlüsselaustausch mittels DH ratchet (DH-Ratschenmechanismus)\nFormat (Schlüssel vorhanden - 38 Bytes):\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ Format (nur Schlüssel-ID - 6 Bytes):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ Felder:\nblk: 7 size: 3 (nur ID) oder 35 (mit Schlüssel) flag: 1 Byte - Flag-Bits key ID: 2 Byte - Big-Endian-Schlüsselkennung (0-32767) Public Key: 32 Byte - öffentlicher X25519-Schlüssel (Little-Endian), falls Flag-Bit 0 = 1 Flag-Bits:\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) Beispiel-Flags:\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 Schlüssel-ID-Regeln:\nIDs sind fortlaufend: 0, 1, 2, \u0026hellip;, 32767 Die ID wird nur erhöht, wenn ein neuer Schlüssel generiert wird Dieselbe ID wird für mehrere Nachrichten verwendet, bis zum nächsten Ratchet (Kryptographie-Ratchet-Mechanismus) Die maximale ID ist 32767 (danach muss eine neue Sitzung gestartet werden) Anwendungsbeispiele:\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) Verarbeitungslogik:\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) Mehrere NextKey-Blöcke:\nEine einzelne ES-Nachricht kann bis zu 2 NextKey-Blöcke enthalten, wenn beide Richtungen gleichzeitig ratcheting (Schlüsselfortschaltung) durchführen:\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] ACK-Block (Typ 8) Zweck: Empfangene Nachrichten In-Band bestätigen\nFormat (Einzelnes ACK - 7 Byte):\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ Format (Mehrere ACKs):\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Felder:\nblk: 8 size: 4 * Anzahl der ACKs (Bestätigungen) (mindestens 4) Für jedes ACK: tagsetid: 2 Bytes - Big-Endian-Tag-Set-ID (0-65535) N: 2 Bytes - Big-Endian-Nachrichtennummer (0-65535) Bestimmung der Tag-Set-ID:\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 Beispiel für ein einzelnes ACK:\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) Beispiel mit mehreren ACKs (Bestätigungen):\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) Verarbeitung:\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) Wann ACKs zu senden sind:\nExplizite ACK-Anforderung: Immer auf den ACK-Anforderungsblock antworten LeaseSet-Zustellung: Wenn der Absender ein LeaseSet in die Nachricht einfügt Sitzungsaufbau: Darf NS/NSR bestätigen (obwohl das Protokoll eine implizite Bestätigung über ES bevorzugt) Ratchet-Bestätigung: Darf den Empfang von NextKey bestätigen Anwendungsschicht: Wie vom Protokoll der höheren Schicht gefordert (z. B. Streaming) ACK-Timing:\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None ACK-Anforderungsblock (Typ 9) Zweck: Anfordern einer In-Band-Bestätigung der aktuellen Nachricht\nFormat:\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ Felder:\nblk: 9 size: 1 flg: 1 Byte - Flags (alle Bits derzeit unbenutzt, auf 0 gesetzt) Verwendung:\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] Antwort des Empfängers:\nWenn eine ACK-Anforderung empfangen wird:\nMit Sofortdaten: ACK-Block in die Sofortantwort aufnehmen Ohne Sofortdaten: Timer starten (z. B. 100 ms) und leeres ES mit ACK senden, wenn der Timer abläuft Tagset-ID: Aktuelle eingehende Tagset-ID verwenden Nachrichtennummer: Nachrichtennummer verwenden, die dem empfangenen Sitzungs-Tag zugeordnet ist Verarbeitung:\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) Wann die ACK-Anforderung verwendet werden sollte:\nKritische Nachrichten: Nachrichten, die bestätigt werden müssen LeaseSet-Zustellung: Beim Bündeln eines LeaseSet Session Ratchet (Schlüsselkettensystem für Sitzungen): Nach dem Senden des NextKey block (Block mit dem nächsten Schlüssel) Ende der Übertragung: Wenn der Sender keine weiteren Daten zu senden hat, aber eine Bestätigung wünscht Wann NICHT verwenden:\nStreaming-Protokoll: Die Streaming-Schicht verarbeitet ACKs (Bestätigungen) Häufige Nachrichten: Vermeiden Sie eine ACK-Anforderung bei jeder Nachricht (Overhead) Unwichtige Datagramme: Raw datagrams (rohe Datagramme) benötigen normalerweise keine ACKs Terminierungsblock (Typ 4) Status: NICHT IMPLEMENTIERT\nZweck: Sitzung geordnet beenden\nFormat:\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ Felder:\nblk: 4 size: 1 oder mehr Bytes rsn: 1 Byte - Grundcode addl data: Optionale zusätzliche Daten (Format hängt vom Grund ab) Ursachen-Codes:\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific **Verwendung (sobald implementiert):** # Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) Regeln:\nMUSS der letzte Block sein (mit Ausnahme von Padding) Padding MUSS auf Termination folgen, falls vorhanden In NS- oder NSR-Nachrichten nicht erlaubt Nur in ES-Nachrichten erlaubt Optionsblock (Typ 5) Status: NICHT IMPLEMENTIERT\nZweck: Aushandeln von Sitzungsparametern\nFormat:\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Felder:\nblk: 5 size: 21 oder mehr Bytes ver: 1 Byte - Protokollversion (muss 0 sein) flg: 1 Byte - Flags (derzeit sind alle Bits ungenutzt) STL: 1 Byte - Länge des Session-Tags (muss 8 sein) STimeout: 2 Bytes - Leerlauf-Timeout der Session in Sekunden (Big-Endian) SOTW: 2 Bytes - Sender Outbound Tag Window (Fenster für ausgehende Tags des Senders, Big-Endian) RITW: 2 Bytes - Receiver Inbound Tag Window (Fenster für eingehende Tags des Empfängers, Big-Endian) tmin, tmax, rmin, rmax: je 1 Byte - Padding-Parameter (4.4-Festkomma) tdmy: 2 Bytes - Maximaler Füllverkehr, zu dessen Sendung man bereit ist (Bytes/s, Big-Endian) rdmy: 2 Bytes - Angeforderter Füllverkehr (Bytes/s, Big-Endian) tdelay: 2 Bytes - Maximale intra-Nachrichten-Verzögerung, die man einzufügen bereit ist (Millisekunden, Big-Endian) rdelay: 2 Bytes - Angeforderte intra-Nachrichten-Verzögerung (Millisekunden, Big-Endian) more_options: Variabel - zukünftige Erweiterungen Padding-Parameter (4.4-Festkomma):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) Tag Window Negotiation (Aushandlung des Tag-Fensters):\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size Standardwerte (wenn Optionen nicht ausgehandelt wurden):\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } MessageNumbers-Block (Typ 6) Status: NICHT IMPLEMENTIERT\nZweck: Gibt die letzte im vorherigen Tag-Satz gesendete Nachricht an (ermöglicht Lückenerkennung)\nFormat:\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ Felder:\nblk: 6 size: 2 PN: 2 Bytes - Letzte Nachrichtennummer des vorherigen Tag-Sets (Big-Endian, 0-65535) PN (Previous Number, vorherige Nummer) Definition:\nPN ist der Index des letzten Tags, der im vorherigen Satz von Tags gesendet wurde.\nVerwendung (sobald implementiert):\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] Vorteile für Empfänger:\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) Regeln:\nDARF NICHT in tag set (Satz von Tags) 0 gesendet werden (kein vorheriges tag set) Wird nur in ES messages (ES-Nachrichten) gesendet Wird nur in der ersten Nachricht(en) eines neuen tag set gesendet PN value (PN-Wert) ist aus Sicht des Senders (letztes Tag, das der Sender gesendet hat) Beziehung zu Signal:\nIm Signal Double Ratchet (Double‑Ratchet‑Algorithmus von Signal) steht PN im Nachrichtenheader. In ECIES (Elliptic Curve Integrated Encryption Scheme, integriertes Verschlüsselungsverfahren auf elliptischen Kurven) befindet es sich in den verschlüsselten Nutzdaten und ist optional.\nPadding-Block (Typ 254) Zweck: Widerstandsfähigkeit gegen Verkehrsanalyse und Verschleierung der Nachrichtengröße\nFormat:\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Felder:\nblk: 254 size: 0-65516 Bytes (big-endian, höchstwertiges Byte zuerst) padding: Zufällige oder aus Nullen bestehende Daten Regeln:\nMUSS der letzte Block in der Nachricht sein Mehrere Padding-Blöcke (Auffüllung) sind NICHT erlaubt Darf eine Länge von Null haben (nur 3-Byte-Header) Padding-Daten dürfen Nullen oder zufällige Bytes sein Standard-Padding:\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) Strategien zur Erschwerung der Verkehrsanalyse:\nStrategie 1: Zufällige Größe (Standard)\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Strategie 2: Auf ein Vielfaches runden\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Strategie 3: Feste Nachrichtengrößen\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Strategie 4: Ausgehandeltes Padding (Options-Block)\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Nur-Padding-Nachrichten:\nNachrichten können vollständig aus Padding bestehen (keine Anwendungsdaten):\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] Hinweise zur Implementierung:\nAll-Nullen-Padding: Zulässig (wird von ChaCha20 verschlüsselt) Zufälliges Padding: Bietet nach der Verschlüsselung keine zusätzliche Sicherheit, verbraucht jedoch mehr Entropie Leistung: Die Erzeugung zufälligen Paddings kann rechenaufwendig sein; erwägen Sie die Verwendung von Nullen Speicher: Große Padding-Blöcke verbrauchen Bandbreite; achten Sie auf die maximale Größe Implementierungsleitfaden Voraussetzungen Kryptografische Bibliotheken:\nX25519: libsodium, NaCl oder Bouncy Castle ChaCha20-Poly1305: libsodium, OpenSSL 1.1.0+ oder Bouncy Castle SHA-256: OpenSSL, Bouncy Castle oder integrierte Unterstützung in der Programmiersprache Elligator2: Eingeschränkte Unterstützung durch Bibliotheken; möglicherweise ist eine eigene Implementierung erforderlich Implementierung von Elligator2 (Verfahren zur Tarnung elliptischer Kurvenpunkte):\nElligator2 (ein Verfahren zur Tarnung elliptischer Kurvenpunkte) ist nicht weit verbreitet implementiert. Optionen:\nOBFS4: Tors obfs4-Pluggable-Transport (austauschbares Transportprotokoll) enthält eine Elligator2-Implementierung Eigene Implementierung: Basiert auf dem Elligator2-Fachartikel kleshni/Elligator: Referenzimplementierung auf GitHub Java I2P-Hinweis: Java I2P verwendet die Bibliothek net.i2p.crypto.eddsa mit benutzerdefinierten Elligator2-Erweiterungen (Kryptoverfahren zur Tarnung von Punkten auf elliptischen Kurven).\nEmpfohlene Implementierungsreihenfolge Phase 1: Kernkryptografie 1. X25519-DH-Schlüsselgenerierung und -austausch 2. ChaCha20-Poly1305-AEAD-Verschlüsselung/Entschlüsselung 3. SHA-256-Hashing und MixHash 4. HKDF-Schlüsselableitung 5. Elligator2-Kodierung/Dekodierung (anfangs können Testvektoren verwendet werden)\nPhase 2: Nachrichtenformate 1. NS-Nachricht (ungebunden) - einfachstes Format 2. NS-Nachricht (gebunden) - fügt statischen Schlüssel hinzu 3. NSR-Nachricht 4. ES-Nachricht 5. Block-Parsing und -Generierung\nPhase 3: Sitzungsverwaltung 1. Sitzungserstellung und -speicherung 2. Tag-Set-Verwaltung (Kennzeichen) (Sender und Empfänger) 3. Sitzungs-Tag ratchet (Ratschenmechanismus) 4. Ratchet für symmetrische Schlüssel 5. Tag-Suche und Fensterverwaltung\nPhase 4: DH Ratcheting (DH-Ratschenmechanismus) 1. Verarbeitung des NextKey-Blocks 2. DH-Ratchet-KDF 3. Erstellung des Tag-Sets nach dem Ratchet 4. Verwaltung mehrerer Tag-Sets\nPhase 5: Protokoll-Logik 1. NS/NSR/ES-Zustandsautomat 2. Replay-Schutz (DateTime, Bloom-Filter) 3. Wiederübertragungslogik (mehrere NS/NSR) 4. ACK-Verarbeitung\nPhase 6: Integration 1. Verarbeitung von I2NP Garlic Clove (Teilnachricht) 2. LeaseSet-Bündelung 3. Integration des Streaming-Protokolls 4. Integration des Datagramm-Protokolls\nImplementierung des Senders Lebenszyklus einer ausgehenden Sitzung:\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() Implementierung des Empfängers Lebenszyklus der eingehenden Sitzung:\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() Nachrichtenklassifizierung Unterscheidung von Nachrichtentypen:\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type Bewährte Verfahren für das Sitzungsmanagement Sitzungsspeicher:\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] Speicherverwaltung:\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 Teststrategien Unit-Tests:\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 Integrationstests:\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 Testvektoren:\nImplementiere Testvektoren aus der Spezifikation:\nNoise IK Handshake: Verwenden Sie die Standard-Testvektoren von Noise HKDF: Verwenden Sie die Testvektoren aus RFC 5869 ChaCha20-Poly1305: Verwenden Sie die Testvektoren aus RFC 7539 Elligator2: Verwenden Sie die Testvektoren aus dem Elligator2-Paper oder aus OBFS4 Interoperabilitätstests:\nJava I2P: Gegen die Referenzimplementierung von Java I2P testen i2pd: Gegen die C++-Implementierung i2pd testen Paketmitschnitte: Wireshark-Dissektor (falls verfügbar) verwenden, um Nachrichtenformate zu überprüfen Implementationsübergreifend: Ein Test-Harness (Testgerüst) erstellen, das zwischen Implementierungen senden und empfangen kann Leistungsaspekte Schlüsselerzeugung:\nDie Elligator2-Schlüsselgenerierung ist rechenintensiv (50% Verwerfungsrate):\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() Tag-Abfrage:\nVerwenden Sie Hashtabellen für O(1)-Tag-Lookups:\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) Speicheroptimierung:\nSymmetrische Schlüsselgenerierung verschieben:\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key Stapelverarbeitung:\nMehrere Nachrichten stapelweise verarbeiten:\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results Sicherheitsüberlegungen Bedrohungsmodell Gegnerische Fähigkeiten:\nPassiver Beobachter: Kann den gesamten Netzwerkverkehr beobachten Aktiver Angreifer: Kann Nachrichten einschleusen, modifizieren, verwerfen, erneut abspielen Kompromittierter Knoten: Kann einen router oder ein Ziel kompromittieren Verkehrsanalyse: Kann statistische Analysen von Verkehrsmustern durchführen Sicherheitsziele:\nVertraulichkeit: Nachrichteninhalte vor Beobachtern verborgen Authentifizierung: Absenderidentität verifiziert (für gebundene Sitzungen) Vorwärtsgeheimnis: Frühere Nachrichten bleiben geheim, selbst wenn Schlüssel kompromittiert sind Schutz vor Wiederholungsangriffen: Alte Nachrichten können nicht erneut verwendet werden Verschleierung des Datenverkehrs: Handshakes sind nicht von Zufallsdaten zu unterscheiden Kryptografische Annahmen Härteannahmen:\nX25519 CDH: Das Computational-Diffie-Hellman-Problem ist auf Curve25519 hart ChaCha20 PRF: ChaCha20 ist eine pseudozufällige Funktion Poly1305 MAC: Poly1305 ist unter gewähltem Nachrichtenangriff unfälschbar SHA-256 CR: SHA-256 ist kollisionsresistent HKDF Security: HKDF extrahiert und erweitert gleichmäßig verteilte Schlüssel Sicherheitsstufen:\nX25519: ~128-Bit-Sicherheitsniveau (Ordnung der Kurve 2^252) ChaCha20: 256-Bit-Schlüssel, 256-Bit-Sicherheitsniveau Poly1305: 128-Bit-Sicherheitsniveau (Kollisionswahrscheinlichkeit) SHA-256: 128-Bit-Kollisionsresistenz, 256-Bit-Urbildresistenz Schlüsselverwaltung Schlüsselerzeugung:\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) Schlüsselspeicherung:\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] Schlüsselrotation:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age Abwehrmaßnahmen gegen Angriffe Gegenmaßnahmen gegen Replay-Angriffe Validierung von Datum und Uhrzeit:\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True Bloom-Filter für NS-Nachrichten:\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] Einmalige Verwendung von Session-Tags:\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index Gegenmaßnahmen gegen Key Compromise Impersonation (KCI, Identitätsanmaßung nach Schlüsselkompromittierung) Problem: NS-Nachrichtenauthentifizierung ist anfällig für KCI (Key Compromise Impersonation, Identitätsanmaßung nach Schlüsselkompromittierung) (Authentifizierungsstufe 1)\nGegenmaßnahme:\nStellen Sie so schnell wie möglich auf NSR (Authentifizierungsstufe 2) um Verlassen Sie sich für sicherheitskritische Vorgänge nicht auf die NS-Payload Warten Sie auf die NSR-Bestätigung, bevor Sie unumkehrbare Aktionen durchführen def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) Gegenmaßnahmen gegen Denial-of-Service NS-Flood-Schutz:\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 Speichergrenzen für Tags:\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count Adaptives Ressourcenmanagement:\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } Widerstandsfähigkeit gegen Datenverkehrsanalyse Elligator2-Kodierung:\nStellt sicher, dass Handshake-Nachrichten nicht von Zufallsdaten zu unterscheiden sind:\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string Padding-Strategien:\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) Timing-Angriffe:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) Fallstricke bei der Implementierung Häufige Fehler:\nNonce-Wiederverwendung (Einmalwert): NIEMALS (Schlüssel, Nonce)-Paare wiederverwenden # BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC GUT: Eindeutiger nonce (einmaliger Zufallswert) für jede Nachricht ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) 2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR ```python # FALSCH: Wiederverwendung eines ephemeren Schlüssels ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # FALSCH # GUT: Neuer Schlüssel für jede Nachricht send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator SCHLECHT: Nicht-kryptografischer Zufallszahlengenerator (RNG) import random key = bytes([random.randint(0, 255) for _ in range(32)]) # UNSICHER GUT: Kryptografisch sicherer Zufallszahlengenerator import os key = os.urandom(32) 4. **Timing Attacks**: Use constant-time comparisons ```python # SCHLECHT: Vergleich mit frühem Abbruch if computed_mac == received_mac: # Timing-Leak pass # GUT: Zeitkonstanter Vergleich if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data SCHLECHT: Entschlüsselung vor der Überprüfung plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # ZU SPÄT if not mac_ok: return error GUT: AEAD verifiziert vor dem Entschlüsseln try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError:\nreturn error 6. **Key Deletion**: Securely wipe keys from memory ```python # SCHLECHT: Einfaches Löschen del private_key # Noch im Speicher # GUT: Vor dem Löschen überschreiben for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# Sicherheitskritische Testfälle def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# Nur ECIES (Elliptic Curve Integrated Encryption Scheme, integriertes Verschlüsselungsschema auf elliptischen Kurven) (für neue Bereitstellungen empfohlen) i2cp.leaseSetEncType=4 # Doppelschlüssel (ECIES + ElGamal zur Kompatibilität) i2cp.leaseSetEncType=4,0 # Nur ElGamal (veraltet, nicht empfohlen) i2cp.leaseSetEncType=0 LeaseSet Type:\n# Standard LS2 (am häufigsten) i2cp.leaseSetType=3 # Verschlüsseltes LS2 (blinded destinations, verblindete Destinationen) i2cp.leaseSetType=5 # Meta LS2 (erweiterter LeaseSet2-Typ; mehrere Ziele) i2cp.leaseSetType=7 Additional Options:\n# Statischer Schlüssel für ECIES (Elliptic Curve Integrated Encryption Scheme, Verschlüsselungsschema mit elliptischen Kurven; optional, wird automatisch generiert, wenn nicht angegeben) # Öffentlicher X25519-Schlüssel mit 32 Byte, Base64-kodiert i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # Signaturtyp (für LeaseSet) i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# Router-zu-Router ECIES i2p.router.useECIES=true Build Properties:\n// Für I2CP-Clients (Java) Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[limits] # Speicherlimit für ECIES-Sitzungen ecies.memory = 128M [ecies] # ECIES aktivieren (integriertes Verschlüsselungsschema mit elliptischen Kurven) enabled = true # Nur ECIES (integriertes Verschlüsselungsverfahren mit elliptischen Kurven) oder Dual-Schlüssel compatibility = true # true = dual-key (Zweischlüsselmodus), false = nur ECIES Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Nur ECIES (integriertes Verschlüsselungsverfahren mit elliptischen Kurven) ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# ECIES (Elliptic Curve Integrated Encryption Scheme, integriertes Verschlüsselungsschema auf elliptischen Kurven) hinzufügen und dabei ElGamal (asymmetrisches Verschlüsselungsverfahren) beibehalten i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# Verbindungstypen prüfen i2prouter.exe status # oder http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# ElGamal entfernen i2cp.leaseSetEncType=4 Step 4: Restart Application\n# I2P router oder Anwendung neu starten systemctl restart i2p # oder i2prouter.exe restart Rollback Plan:\n# Bei Problemen auf nur ElGamal zurückfallen i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# Maximale Anzahl eingehender Sitzungen i2p.router.maxInboundSessions=1000 # Maximale Anzahl ausgehender Sitzungen i2p.router.maxOutboundSessions=1000 # Sitzungs-Timeout (Sekunden) i2p.router.sessionTimeout=600 Memory Limits:\n# Speicherlimit für Tags (KB) i2p.ecies.maxTagMemory=10240 # 10 MB # Vorausschaufenster i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# Nachrichten vor dem Ratchet (kryptografischer Ratschen-Mechanismus) i2p.ecies.ratchetThreshold=4096 # Zeit vor dem ratchet (kryptografischer Schlüsselfortschrittsmechanismus) (Sekunden) i2p.ecies.ratchetTimeout=600 # 10 Minuten Monitoring and Debugging Logging:\n# Debug-Protokollierung für ECIES (integriertes Verschlüsselungsverfahren mit elliptischen Kurven) aktivieren logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # Beispiele print(\u0026#34;NS (gebunden, 1 KB Nutzlast):\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;Bytes\u0026#34;) # Ausgabe: 1120 Bytes print(\u0026#34;NSR (1KB payload):\u0026#34;, calculate_nsr_size(1024), \u0026#34;bytes\u0026#34;) # Ausgabe: 1096 Bytes print(\u0026#34;ES (1KB Nutzlast):\u0026#34;, calculate_es_size(1024), \u0026#34;Bytes\u0026#34;) # Ausgabe: 1048 Bytes Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"Elliptic Curve Integrated Encryption Scheme (integriertes Verschlüsselungsschema auf elliptischen Kurven) für I2P (X25519 + AEAD)","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"Spezifikation der ECIES-X25519-AEAD-Ratchet-Verschlüsselung (Ratchet = Schlüsselwechsel-Mechanismus)","url":"/de/docs/specs/ecies/"},{"categories":null,"content":"Übersicht router prüfen automatisch auf Updates, indem sie einen signierten News-Feed abfragen, der über das I2P-Netzwerk verteilt wird. Wenn eine neuere Version angekündigt wird, lädt der router ein kryptografisch signiertes Update-Archiv (.su3) herunter und bereitet es zur Installation vor. Dieses System gewährleistet eine authentifizierte, manipulationsresistente und mehrkanalige Verteilung offizieller Veröffentlichungen.\nSeit I2P 2.10.0 verwendet das Aktualisierungssystem: - RSA-4096 / SHA-512 Signaturen - SU3-Containerformat (ersetzt das veraltete SUD/SU2) - Redundante Spiegel: netzwerkinternes HTTP, Clearnet-HTTPS und BitTorrent\n1. Newsfeed Routers rufen den signierten Atom-Feed alle paar Stunden ab, um neue Versionen und Sicherheitshinweise zu entdecken. Der Feed ist signiert und wird als .su3-Datei verteilt, die Folgendes enthalten kann:\n\u0026lt;i2p:version\u0026gt; — neue Versionsnummer \u0026lt;i2p:minVersion\u0026gt; — unterstützte Mindestversion für den router \u0026lt;i2p:minJavaVersion\u0026gt; — erforderliche Mindestversion der Java-Laufzeitumgebung \u0026lt;i2p:update\u0026gt; — listet mehrere Download-Spiegel (I2P, HTTPS, torrent) auf \u0026lt;i2p:revocations\u0026gt; — Daten zum Zertifikatswiderruf \u0026lt;i2p:blocklist\u0026gt; — netzwerkweite Blocklisten für kompromittierte Peers Feed-Verteilung Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load Routers bevorzugen den I2P-Feed, können bei Bedarf jedoch auf Clearnet- oder Torrent-Verteilung zurückgreifen. 2. Dateiformate SU3 (Aktueller Standard) Mit Version 0.9.9 eingeführt, ersetzte SU3 die veralteten SUD- und SU2-Formate. Jede Datei enthält einen Header, Nutzdaten und eine abschließende Signatur.\nHeader-Struktur \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Field\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Magic\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I2Psu3\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Format Version\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;e.g., \u0026lt;code\u0026gt;0x000B\u0026lt;/code\u0026gt; (RSA-SHA512-4096)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Length\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;512 bytes\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Version String\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Router version\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signer ID\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Certificate name\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Content Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;1 = router update, 3 = reseed, 4 = news feed\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Schritte zur Signaturüberprüfung 1. Header parsen und Signaturalgorithmus identifizieren. 2. Hash und Signatur mithilfe des gespeicherten Unterzeichnerzertifikats verifizieren. 3. Bestätigen, dass das Zertifikat des Unterzeichners nicht widerrufen wurde. 4. Eingebetteten Versionsstring mit den Nutzlast-Metadaten vergleichen.\nRouters werden mit Zertifikaten vertrauenswürdiger Unterzeichner (derzeit zzz und str4d) ausgeliefert und lehnen alle unsignierten oder widerrufenen Quellen ab.\nSU2 (Veraltet) Verwendete die Dateiendung .su2 mit Pack200-komprimierten JAR-Dateien. Entfernt, nachdem Java 14 Pack200 als veraltet markiert hat (JEP 367). In I2P 0.9.48+ deaktiviert; jetzt vollständig durch ZIP-Kompression ersetzt. SUD (veraltet) Frühes DSA-SHA1-signiertes ZIP-Format (vor 0.9.9). Keine Unterzeichner-ID oder Header, begrenzte Integrität. Ersetzt aufgrund schwacher Kryptografie und fehlender Durchsetzung von Versionsanforderungen. 3. Aktualisierungs-Workflow 3.1 Header-Überprüfung Router rufen nur den SU3 header ab, um den Versionsstring zu verifizieren, bevor sie vollständige Dateien herunterladen. Dies verhindert, dass Bandbreite für veraltete Mirror-Server oder veraltete Versionen verschwendet wird.\n3.2 Vollständiger Download Nach der Überprüfung des Headers lädt der router die vollständige .su3-Datei von: - netzinternen eepsite-Spiegeln (bevorzugt) - HTTPS-Clearnet-Spiegeln (Ausweichlösung) - BitTorrent (optionale peer-unterstützte Verteilung)\nDownloads verwenden Standard-I2PTunnel-HTTP-Clients, mit Wiederholversuchen, Timeout-Behandlung und Fallback auf Spiegelserver.\n3.3 Signaturprüfung Jede heruntergeladene Datei durchläuft: - Signaturprüfung: RSA-4096/SHA512-Überprüfung - Versionsabgleich: Abgleich von Header- und Nutzlast-Version - Schutz vor Downgrades: Stellt sicher, dass das Update neuer ist als die installierte Version\nUngültige oder nicht übereinstimmende Dateien werden sofort verworfen.\n3.4 Installations-Staging Nach der Überprüfung: 1. ZIP-Inhalt in ein temporäres Verzeichnis entpacken 2. In deletelist.txt aufgeführte Dateien entfernen 3. Native Bibliotheken ersetzen, falls lib/jbigi.jar enthalten ist 4. Signierer-Zertifikate nach ~/.i2p/certificates/ kopieren 5. Update nach i2pupdate.zip verschieben, damit es beim nächsten Neustart angewendet wird\nDas Update wird beim nächsten Start automatisch installiert oder wenn „Update jetzt installieren“ manuell ausgelöst wird.\n4. Dateiverwaltung deletelist.txt Eine Klartextliste veralteter Dateien, die vor dem Entpacken neuer Inhalte entfernt werden sollen.\nRegeln: - Ein Pfad pro Zeile (nur relative Pfade) - Zeilen, die mit # beginnen, werden ignoriert - .. und absolute Pfade werden abgelehnt\nNative Bibliotheken Um veraltete oder nicht passende native Bibliotheken zu vermeiden: - Wenn lib/jbigi.jar existiert, werden alte .so- oder .dll-Dateien gelöscht - Stellt sicher, dass plattformspezifische Bibliotheken frisch extrahiert werden\n5. Zertifikatsverwaltung Router können neue Signaturzertifikate durch Updates oder Widerrufe im Newsfeed erhalten.\nNeue .crt-Dateien werden in das Zertifikatsverzeichnis kopiert. Widerrufene Zertifikate werden vor zukünftigen Überprüfungen gelöscht. Unterstützt Schlüsselrotation, ohne manuelles Eingreifen des Benutzers zu erfordern. Alle Updates werden offline mit air-gapped signing systems (physisch vom Netzwerk isolierte Signiersysteme) signiert. Private Schlüssel werden niemals auf Build-Servern gespeichert.\n6. Entwicklerrichtlinien Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. Zukünftige Releases werden die Integration von Post-Quanten-Signaturen (siehe Proposal 169) und reproduzierbare Builds untersuchen. 7. Sicherheitsübersicht Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity --- 8. Versionierung Router: 2.10.0 (API 0.9.67) Semantische Versionierung mit Major.Minor.Patch. Erzwingung der Mindestversion verhindert unsichere Aktualisierungen. Unterstütztes Java: Java 8–17. Künftig erfordert 2.11.0+ Java 17+. ","description":"Sicherer, signierter Update-Mechanismus und Feed-Struktur für I2P routers","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"Spezifikation für Software-Updates","url":"/de/docs/specs/updates/"},{"categories":null,"content":"Ein SSH-Tunnel bietet eine sichere, verschlüsselte Verbindung, um auf die Konsole Ihres entfernten I2P-Routers oder andere Dienste zuzugreifen. Diese Anleitung zeigt Ihnen, wie Sie SSH-Tunnels auf Windows-, Linux- und Mac-Systemen erstellen.\nWas ist ein SSH-Tunnel? Ein SSH-Tunnel ist eine Methode, Daten und Informationen sicher über eine verschlüsselte SSH-Verbindung zu leiten. Man kann es sich wie eine geschützte \u0026ldquo;Pipeline\u0026rdquo; durch das Internet vorstellen - Ihre Daten bewegen sich durch diesen verschlüsselten Tunnel, wodurch verhindert wird, dass jemand sie unterwegs abfängt oder liest.\nSSH-Tunneling ist besonders nützlich für:\nZugriff auf entfernte I2P-Router: Verbindung zu Ihrer I2P-Konsole auf einem entfernten Server herstellen Sichere Verbindungen: Der gesamte Datenverkehr ist Ende-zu-Ende verschlüsselt Umgehung von Einschränkungen: Zugriff auf Dienste auf entfernten Systemen, als wären sie lokal Portweiterleitung: Einen lokalen Port auf einen entfernten Dienst abbilden Im Kontext von I2P kannst du einen SSH-Tunnel verwenden, um auf deine I2P-Router-Konsole (üblicherweise auf Port 7657) auf einem entfernten Server zuzugreifen, indem du sie auf einen lokalen Port auf deinem Computer weiterleitest.\nVoraussetzungen Bevor Sie einen SSH-Tunnel erstellen, benötigen Sie:\nSSH-Client: Windows: PuTTY (kostenloser Download) Linux/Mac: Integrierter SSH-Client (über Terminal) Remote-Server-Zugriff: Benutzername für den Remote-Server IP-Adresse oder Hostname des Remote-Servers SSH-Passwort oder schlüsselbasierte Authentifizierung Verfügbarer lokaler Port: Wählen Sie einen ungenutzten Port zwischen 1-65535 (7657 wird üblicherweise für I2P verwendet) Den Tunnel-Befehl verstehen Der SSH-Tunnel-Befehl folgt diesem Muster:\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] Parameter erklärt: - local_port: Der Port auf Ihrem lokalen Rechner (z. B. 7657) - destination_ip: Normalerweise 127.0.0.1 (localhost auf dem entfernten Server) - destination_port: Der Port des Dienstes auf dem entfernten Server (z. B. 7657 für I2P) - username: Ihr Benutzername auf dem entfernten Server - remote_server: IP-Adresse oder Hostname des entfernten Servers\nBeispiel: ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\nDies erstellt einen Tunnel, bei dem: - Lokaler Port 7657 auf Ihrem Rechner weitergeleitet wird zu\u0026hellip; - Port 7657 auf dem localhost des entfernten Servers (wo I2P läuft) - Verbindung als Benutzer i2p zum Server 20.228.143.58\nSSH-Tunnel unter Windows erstellen Windows-Benutzer können SSH-Tunnel mit PuTTY erstellen, einem kostenlosen SSH-Client.\nStep 1: Download and Install PuTTY Laden Sie PuTTY von putty.org herunter und installieren Sie es auf Ihrem Windows-System.\nStep 2: Configure the SSH Connection Öffnen Sie PuTTY und konfigurieren Sie Ihre Verbindung:\nIn der Kategorie Session: Geben Sie die IP-Adresse oder den Hostnamen Ihres Remote-Servers in das Feld Host Name ein Stellen Sie sicher, dass Port auf 22 gesetzt ist (Standard-SSH-Port) Der Verbindungstyp sollte SSH sein Step 3: Configure the Tunnel Navigieren Sie zu Verbindung → SSH → Tunnel in der linken Seitenleiste:\nSource-Port: Geben Sie den lokalen Port ein, den Sie verwenden möchten (z.B. 7657) Ziel: Geben Sie 127.0.0.1:7657 ein (localhost:port auf dem entfernten Server) Klicken Sie auf Hinzufügen, um den Tunnel hinzuzufügen Der Tunnel sollte in der Liste \u0026ldquo;Weitergeleitete Ports\u0026rdquo; erscheinen Step 4: Connect Klicken Sie auf Öffnen, um die Verbindung herzustellen Wenn Sie zum ersten Mal eine Verbindung herstellen, erscheint eine Sicherheitswarnung - klicken Sie auf Ja, um dem Server zu vertrauen Geben Sie Ihren Benutzernamen ein, wenn Sie dazu aufgefordert werden Geben Sie Ihr Passwort ein, wenn Sie dazu aufgefordert werden Sobald die Verbindung hergestellt ist, können Sie auf Ihre entfernte I2P-Konsole zugreifen, indem Sie einen Browser öffnen und zu http://127.0.0.1:7657 navigieren\nSchritt 1: PuTTY herunterladen und installieren Um eine erneute Konfiguration jedes Mal zu vermeiden:\nKehre zur Kategorie Session zurück Gib einen Namen unter Saved Sessions ein (z.B. \u0026ldquo;I2P Tunnel\u0026rdquo;) Klicke auf Save Beim nächsten Mal lade einfach diese Session und klicke auf Open Creating SSH Tunnels on Linux Linux-Systeme haben SSH in das Terminal integriert, was die Erstellung von Tunneln schnell und unkompliziert macht.\nSchritt 2: SSH-Verbindung konfigurieren Öffnen Sie ein Terminal und führen Sie den SSH-Tunnel-Befehl aus:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Ersetze: - 7657 (erstes Vorkommen): Dein gewünschter lokaler Port - 127.0.0.1:7657: Die Zieladresse und der Port auf dem entfernten Server - i2p: Dein Benutzername auf dem entfernten Server - 20.228.143.58: Die IP-Adresse deines entfernten Servers\nWenn Sie dazu aufgefordert werden, geben Sie Ihr Passwort ein. Sobald die Verbindung hergestellt ist, ist der Tunnel aktiv.\nGreifen Sie auf Ihre entfernte I2P-Konsole unter http://127.0.0.1:7657 in Ihrem Browser zu.\nSchritt 3: Tunnel konfigurieren Der Tunnel bleibt aktiv, solange die SSH-Sitzung läuft. Um ihn im Hintergrund weiterlaufen zu lassen:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Zusätzliche Flags: - -f: Führt SSH im Hintergrund aus - -N: Keine entfernten Befehle ausführen (nur Tunnel)\nUm einen Hintergrund-Tunnel zu schließen, finden und beenden Sie den SSH-Prozess:\nps aux | grep ssh kill [process_id] Schritt 4: Verbinden Für bessere Sicherheit und Komfort verwenden Sie SSH-Schlüsselauthentifizierung:\nGeneriere ein SSH-Schlüsselpaar (falls du noch keines hast):\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Kopieren Sie Ihren öffentlichen Schlüssel auf den entfernten Server:\nssh-copy-id i2p@20.228.143.58 Jetzt können Sie sich ohne Passwort verbinden:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac Mac-Systeme verwenden denselben SSH-Client wie Linux, daher ist der Prozess identisch.\nOptional: Sitzung speichern Öffnen Sie das Terminal (Programme → Dienstprogramme → Terminal) und führen Sie aus:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Ersetzen: - 7657 (erstes Vorkommen): Ihr gewünschter lokaler Port - 127.0.0.1:7657: Die Zieladresse und der Port auf dem Remote-Server - i2p: Ihr Benutzername auf dem Remote-Server - 20.228.143.58: Die IP-Adresse Ihres Remote-Servers\nGeben Sie Ihr Passwort ein, wenn Sie dazu aufgefordert werden. Sobald die Verbindung hergestellt ist, greifen Sie auf Ihre Remote-I2P-Konsole unter http://127.0.0.1:7657 zu\nBackground Tunnels on Mac Wie unter Linux kannst du den Tunnel im Hintergrund ausführen:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Verwendung des Terminals Die Mac SSH-Schlüssel-Einrichtung ist identisch zu Linux:\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases Den Tunnel aktiv halten Der häufigste Anwendungsfall - Zugriff auf Ihre entfernte I2P-Router-Konsole:\nssh -L 7657:127.0.0.1:7657 user@remote-server Öffnen Sie dann http://127.0.0.1:7657 in Ihrem Browser.\nVerwendung von SSH-Keys (Empfohlen) Mehrere Ports gleichzeitig weiterleiten:\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server Dies leitet sowohl Port 7657 (I2P-Konsole) als auch 7658 (ein anderer Dienst) weiter.\nCustom Local Port Verwenden Sie einen anderen lokalen Port, falls 7657 bereits verwendet wird:\nssh -L 8080:127.0.0.1:7657 user@remote-server Greifen Sie stattdessen auf die I2P-Konsole unter http://127.0.0.1:8080 zu.\nTroubleshooting Verwendung des Terminals Fehler: \u0026ldquo;bind: Address already in use\u0026rdquo;\nLösung: Wählen Sie einen anderen lokalen Port oder beenden Sie den Prozess, der diesen Port verwendet:\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] Hintergrund-Tunnel auf Mac Fehler: \u0026ldquo;Connection refused\u0026rdquo; oder \u0026ldquo;channel 2: open failed\u0026rdquo;\nMögliche Ursachen: - Der entfernte Dienst läuft nicht (prüfen Sie, ob der I2P-router auf dem entfernten Server läuft) - Firewall blockiert die Verbindung - Falscher Zielport\nLösung: Überprüfen Sie, ob der I2P-Router auf dem entfernten Server läuft:\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; SSH-Schlüssel-Einrichtung auf Mac Fehler: \u0026ldquo;Permission denied\u0026rdquo; oder \u0026ldquo;Authentication failed\u0026rdquo;\nMögliche Ursachen: - Falscher Benutzername oder Passwort - SSH-Schlüssel nicht korrekt konfiguriert - SSH-Zugriff auf dem Remote-Server deaktiviert\nLösung: Überprüfen Sie die Zugangsdaten und stellen Sie sicher, dass der SSH-Zugriff auf dem Remote-Server aktiviert ist.\nTunnel Drops Connection Fehler: Verbindung bricht nach einer Phase der Inaktivität ab\nLösung: Fügen Sie Keep-Alive-Einstellungen zu Ihrer SSH-Konfiguration (~/.ssh/config) hinzu:\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices SSH-Schlüssel verwenden: Sicherer als Passwörter, schwerer zu kompromittieren Passwort-Authentifizierung deaktivieren: Sobald SSH-Schlüssel eingerichtet sind, Passwort-Login auf dem Server deaktivieren Starke Passwörter verwenden: Bei Verwendung von Passwort-Authentifizierung ein starkes, einzigartiges Passwort nutzen SSH-Zugriff einschränken: Firewall-Regeln konfigurieren, um SSH-Zugriff auf vertrauenswürdige IPs zu beschränken SSH aktuell halten: SSH-Client und Server-Software regelmäßig aktualisieren Logs überwachen: SSH-Logs auf dem Server auf verdächtige Aktivitäten überprüfen Nicht-standardmäßige SSH-Ports verwenden: Standard-SSH-Port (22) ändern, um automatisierte Angriffe zu reduzieren SSH-Tunnel unter Linux erstellen Zugriff auf die I2P-Konsole Erstellen Sie ein Skript, um automatisch Tunnel einzurichten:\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; Machen Sie es ausführbar:\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh Mehrere Tunnel Erstelle einen systemd-Dienst für die automatische Tunnel-Erstellung:\nsudo nano /etc/systemd/system/i2p-tunnel.service Hinzufügen:\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target Aktivieren und starten:\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling Benutzerdefinierter lokaler Port Erstellen Sie einen SOCKS-Proxy für dynamisches Forwarding:\nssh -D 8080 user@remote-server Konfigurieren Sie Ihren Browser, um 127.0.0.1:8080 als SOCKS5-Proxy zu verwenden.\nReverse Tunneling Erlaube dem entfernten Server, auf Dienste auf deinem lokalen Rechner zuzugreifen:\nssh -R 7657:127.0.0.1:7657 user@remote-server Port bereits in Verwendung Tunnel durch einen Zwischenserver:\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion SSH-Tunneling ist ein leistungsstarkes Werkzeug für den sicheren Zugriff auf entfernte I2P-router und andere Dienste. Egal ob Sie Windows, Linux oder Mac verwenden, der Prozess ist unkompliziert und bietet starke Verschlüsselung für Ihre Verbindungen.\nFür zusätzliche Hilfe oder Fragen besuchen Sie die I2P-Community: - Forum: i2pforum.net - IRC: #i2p auf verschiedenen Netzwerken - Dokumentation: I2P Docs Anleitung ursprünglich erstellt von Stormy Cloud , angepasst für die I2P-Dokumentation.\n","description":"Erfahren Sie, wie Sie sichere SSH-Tunnel unter Windows, Linux und Mac erstellen, um auf Ihren entfernten I2P-Router zuzugreifen","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"SSH-Tunnel erstellen, um remote auf I2P zuzugreifen","url":"/de/docs/guides/ssh-tunnel-erstellen-um-remote-auf-i2p-zuzugreifen/"},{"categories":null,"content":" Veraltet: SSU wurde durch SSU2 ersetzt. Die Unterstützung für SSU wurde aus i2pd 2.44.0 (API 0.9.56, Nov 2022) und aus Java I2P 2.4.0 (API 0.9.61, Dez 2023) entfernt.\nSSU bot eine UDP-basierte, halbzuverlässige Übertragung mit Staukontrolle, NAT-Traversal und Unterstützung für Introducer. Es ergänzte NTCP, indem es router hinter NAT/Firewalls handhabte und die IP-Ermittlung koordinierte.\nAdress-Elemente transport: SSU caps: Fähigkeits-Flags (B, C, 4, 6, usw.) host / port: IPv4- oder IPv6-Listener (optional, wenn der router hinter einer Firewall ist) key: Base64-Einführungsschlüssel mtu: Optional; Standardwert 1484 (IPv4) / 1488 (IPv6) ihost/ikey/iport/itag/iexp: Introducer-Einträge (Vermittler-Einträge), wenn der router hinter einer Firewall ist Funktionen Kooperative NAT-Traversierung unter Verwendung von introducers (Vermittler) Erkennung der lokalen IP über Peer-Tests und die Inspektion eingehender Pakete Automatisches Weiterleiten des Firewall-Status an andere Transportprotokolle und die router-Konsole Teilweise zuverlässige Zustellung: Nachrichten werden bis zu einer Grenze erneut übertragen und danach verworfen Staukontrolle mit additiver Erhöhung / multiplikativer Verringerung und Fragment-ACK-Bitfeldern SSU übernahm auch Metadatenaufgaben wie Timing-Beacons (Zeitsignale) und die MTU-Aushandlung. Die gesamte Funktionalität wird inzwischen (mit moderner Kryptografie) von SSU2 bereitgestellt.\n","description":"Ursprünglicher Secure Semireliable UDP-Transport","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (veraltet)","url":"/de/docs/legacy/ssu/"},{"categories":null,"content":" Veraltet: SSU (Secure Semi-Reliable UDP) wurde durch SSU2 ersetzt. Java I2P hat SSU in Version 2.4.0 (API 0.9.61) entfernt und i2pd hat es in 2.44.0 (API 0.9.56) entfernt. Dieses Dokument dient ausschließlich der historischen Referenz.\nHöhepunkte UDP-Transport, der eine verschlüsselte, authentifizierte Punkt-zu-Punkt-Übermittlung von I2NP-Nachrichten bereitstellt. Basierte auf einem 2048-Bit-Diffie–Hellman-Handshake (gleiche Primzahl wie ElGamal). Jedes Datagramm enthielt einen 16-Byte-HMAC-MD5 (nicht standardisierte, gekürzte Variante) + einen 16-Byte-IV, gefolgt von einer AES-256-CBC-verschlüsselten Nutzlast. Replay-Schutz und Sitzungszustand wurden innerhalb der verschlüsselten Nutzlast verwaltet. Nachrichtenkopf [16-byte MAC][16-byte IV][encrypted payload] Verwendete MAC-Berechnung: HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8))) mit einem 32-Byte-MAC-Schlüssel. Die Nutzlastlänge wurde als 16-Bit-Wert in Big-Endian-Reihenfolge angehängt und in die MAC-Berechnung einbezogen. Die Protokollversion war standardmäßig 0; netId war standardmäßig 2 (Hauptnetz).\nSitzungs- und MAC-Schlüssel Abgeleitet aus dem gemeinsamen DH-Geheimnis:\nKonvertieren Sie den gemeinsamen Wert in ein Big-Endian-Byte-Array (fügen Sie 0x00 voran, falls das höchstwertige Bit gesetzt ist). Sitzungsschlüssel: erste 32 Bytes (falls kürzer, mit Nullen auffüllen). MAC-Schlüssel: Bytes 33–64; falls nicht ausreichend, auf den SHA-256-Hash des gemeinsamen Werts zurückgreifen. Status Router veröffentlichen keine SSU-Adressen mehr. Clients sollten auf SSU2 oder NTCP2 umsteigen. Historische Implementierungen finden sich in älteren Releases:\nJava-Quellcode vor 2.4.0 unter router/transport/udp i2pd-Quellcode vor 2.44.0 Informationen zum aktuellen Verhalten des UDP-Transports finden Sie in der SSU2-Spezifikation .\n","description":"Ursprünglicher UDP-Transport, der vor SSU2 verwendet wurde","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"SSU-Transport (veraltet)","url":"/de/docs/legacy/ssu/"},{"categories":null,"content":"1. Übersicht SSU2 ist ein UDP-basiertes Transportschichtprotokoll, das für sichere, teilweise zuverlässige router-zu-router-Kommunikation in I2P verwendet wird. Es ist kein allgemeines Transportprotokoll, sondern auf den I2NP-Nachrichtenaustausch spezialisiert.\nKernfunktionen Authentifizierter Schlüsselaustausch über das Noise XK pattern (Noise-XK-Muster) Verschlüsselte Header zum Schutz vor DPI NAT-Traversal mithilfe von Relays und Hole-Punching (koordiniertes Öffnen von Ports durch NAT-Geräte) Verbindungsmigration und Adressvalidierung Optionale Pfadvalidierung Vorwärtsgeheimnis und Schutz vor Wiederholungsangriffen Altsysteme und Kompatibilität Implementation SSU2 Default SSU1 Removed i2pd2.44.02.44.0 Java I2P0.9.560.9.61 SSU1 wird im gesamten öffentlichen I2P‑Netzwerk nicht mehr verwendet. 2. Kryptografie SSU2 (I2P-Transportprotokoll) verwendet Noise_XK_25519_ChaChaPoly_SHA256 (Noise-Handschlag und Krypto-Suite) mit I2P-spezifischen Erweiterungen.\nFunction Algorithm Notes Diffie-HellmanX25519 (RFC 7748)32-byte keys CipherChaCha20/Poly1305 (RFC 7539)AEAD encryption HashSHA-256Used for key derivation and message integrity KDFHKDF-SHA256 (RFC 5869)For session and header keys Header und Nutzdaten sind kryptografisch über `mixHash()` miteinander verknüpft. Alle kryptografischen Primitive werden mit NTCP2 und ECIES gemeinsam genutzt, um die Implementierung effizienter zu gestalten. 3. Nachrichtenübersicht 3.1 Regeln für UDP-Datagramme Jedes UDP-Datagramm enthält genau eine SSU2-Nachricht. Session Confirmed-Nachrichten können über mehrere Datagramme hinweg fragmentiert werden. Minimale Größe: 40 Bytes Maximale Größe: 1472 Bytes (IPv4) / 1452 Bytes (IPv6)\n3.2 Nachrichtentypen Type Message Header Description 0Session Request32BHandshake initiation 1Session Created32BHandshake response 2Session Confirmed16BFinal handshake, may be fragmented 6Data16BEncrypted I2NP message blocks 7Peer Test32BNAT reachability testing 9Retry32BToken or rejection notice 10Token Request32BRequest for validation token 11Hole Punch32BNAT traversal signaling --- 4. Sitzungsaufbau 4.1 Standardablauf (gültiges Token) Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 Token-Erwerb Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 Ungültiges Token Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. Header-Strukturen 5.1 Langer Header (32 Byte) Wird vor dem Sitzungsaufbau verwendet (SessionRequest, Created, Retry, PeerTest, TokenRequest, HolePunch).\nField Size Description Destination Connection ID8Random unique ID Packet Number4Random (ignored during handshake) Type1Message type Version1Always 2 NetID12 = main I2P network Flags1Reserved (0) Source Connection ID8Random ID distinct from destination Token8Token for address validation ### 5.2 Kurzer Header (16 Bytes) Wird während bestehender Sitzungen verwendet (SessionConfirmed, Data).\nField Size Description Destination Connection ID8Stable throughout session Packet Number4Incrementing per message Type1Message type (2 or 6) Flags3ACK/fragment flags --- 6. Verschlüsselung 6.1 AEAD Alle Nutzdaten sind mit ChaCha20/Poly1305 AEAD verschlüsselt:\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) Nonce: 12 Bytes (4 Nullen + 8 Zähler) Tag: 16 Bytes Assoziierte Daten: enthält Header zur Integritätsbindung 6.2 Header-Schutz Header werden mit einem aus den Sitzungs-Header-Schlüsseln abgeleiteten ChaCha20-Schlüsselstrom maskiert. Dies stellt sicher, dass alle Connection-IDs und Paketfelder zufällig erscheinen und bietet Widerstandsfähigkeit gegen DPI (tiefgehende Paketinspektion).\n6.3 Schlüsselableitung Phase Input Output InitialintroKey + salthandshake header key HandshakeDH(X25519)chainKey + AEAD key Data phasechainKeyTX/RX keys Key rotationoldKeynewKey --- 7. Sicherheit und Verhinderung von Replay-Angriffen Tokens sind pro IP und verfallen nach ~60 Sekunden. Replays werden durch Bloom-Filter pro Sitzung verhindert. Doppelte ephemere Schlüssel werden abgelehnt. Header und Nutzdaten sind kryptografisch miteinander verknüpft. Routers müssen jedes Paket verwerfen, bei dem die AEAD-Authentifizierung fehlschlägt oder das eine ungültige Version oder NetID aufweist.\n8. Paketnummerierung und Sitzungsdauer Jede Richtung verwaltet ihren eigenen 32-Bit-Zähler. - Beginnt bei 0, wird pro Paket inkrementiert. - Darf nicht überlaufen; Sitzungsschlüssel erneuern oder Sitzung beenden, bevor 2³² erreicht wird.\nVerbindungs-IDs bleiben während der gesamten Sitzung statisch, auch während einer Migration.\n9. Datenphase Typ = 6 (Daten) Kurzer Header (16 Bytes) Nutzlast enthält einen oder mehrere verschlüsselte Blöcke: ACK/NACK-Listen I2NP-Nachrichtenfragmente Padding (Auffüllung) (0–31 Bytes zufällig) Abschlussblöcke (optional) Selektive Wiederübertragung und ungeordnete Zustellung werden unterstützt. Die Zuverlässigkeit bleibt “teilweise zuverlässig” — fehlende Pakete können nach Erreichen der Wiederholungsgrenzen stillschweigend verworfen werden.\n10. Weiterleitung und NAT-Traversal Message Type Purpose Peer Test7Determines inbound reachability Retry9Issues new token or rejection Token Request10Requests new address token Hole Punch11Coordinates NAT hole punching Relay routers unterstützen Peers hinter restriktiven NATs mithilfe dieser Kontrollnachrichten. 11. Sitzungsbeendigung Jede der beiden Gegenstellen kann die Sitzung unter Verwendung eines Termination block (Beendigungsblock) innerhalb einer Data message (Datennachricht) schließen. Ressourcen müssen unmittelbar nach dem Empfang freigegeben werden. Erneut gesendete Beendigungspakete können nach der Bestätigung ignoriert werden.\n12. Implementierungsrichtlinien Router MÜSSEN: - version = 2 und NetID = 2 überprüfen. - Pakete \u0026lt;40 Byte oder mit ungültigem AEAD verwerfen. - 120s-Replay-Cache erzwingen. - Wiederverwendete Token oder ephemere Schlüssel ablehnen.\nRouters SOLLTEN: - Padding (Auffüllung) zufällig zwischen 0–31 Byte wählen. - Adaptive Wiederübertragung verwenden (RFC 6298). - Vor einer Migration eine Pfadvalidierung pro Peer implementieren.\n13. Sicherheitszusammenfassung Property Achieved By Forward secrecyX25519 ephemeral keys Replay protectionTokens + Bloom filter Authenticated encryptionChaCha20/Poly1305 KCI resistanceNoise XK pattern DPI resistanceEncrypted headers NAT traversalRelay + Hole Punch MigrationStatic connection IDs --- 14. Referenzen Vorschlag 159 – SSU2 Noise Protocol Framework RFC 9000 – QUIC-Transport RFC 9001 – QUIC-TLS RFC 7539 – ChaCha20/Poly1305 AEAD RFC 7748 – X25519 ECDH RFC 5869 – HKDF-SHA256 ","description":"Sicheres teilweise zuverlässiges UDP-Transportprotokoll Version 2","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"SSU2 Spezifikation","url":"/de/docs/specs/ssu2/"},{"categories":null,"content":"Überblick Die I2P Streaming Library bietet zuverlässigen, geordneten und authentifizierten Transport über die Nachrichtenschicht von I2P, ähnlich wie TCP über IP. Sie befindet sich oberhalb des I2CP-Protokolls und wird von nahezu allen interaktiven I2P-Anwendungen verwendet, einschließlich HTTP-Proxys, IRC, BitTorrent und E-Mail.\nKernmerkmale Einstufiger Verbindungsaufbau mit SYN-, ACK- und FIN-Flags, die mit Nutzdaten gebündelt werden können, um Round-Trips zu reduzieren. Sliding-Window-Staukontrolle mit Slow Start und Congestion Avoidance, optimiert für die Hochlatenz-Umgebung von I2P. Paketkomprimierung (standardmäßig 4KB komprimierte Segmente), die Kosten für erneute Übertragung und Fragmentierungslatenz ausbalanciert. Vollständig authentifizierte, verschlüsselte und zuverlässige Kanal-Abstraktion zwischen I2P-Destinations. Dieses Design ermöglicht es, dass kleine HTTP-Anfragen und -Antworten in einem einzigen Round-Trip abgeschlossen werden. Ein SYN-Paket kann die Anfrage-Nutzdaten enthalten, während das SYN/ACK/FIN des Antwortenden den vollständigen Antwortinhalt enthalten kann.\nAPI-Grundlagen Die Java-Streaming-API entspricht der Standard-Java-Socket-Programmierung:\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory verhandelt oder verwendet eine Router-Sitzung über I2CP wieder. Falls kein Schlüssel bereitgestellt wird, wird automatisch ein neues Ziel generiert. Entwickler können I2CP-Optionen (z. B. Tunnellängen, Verschlüsselungstypen oder Verbindungseinstellungen) über die options-Map übergeben. I2PSocket und I2PServerSocket spiegeln die Standard-Java-Socket-Schnittstellen wider, was die Migration unkompliziert macht. Vollständige Javadocs sind über die I2P Router-Konsole oder hier verfügbar.\nKonfiguration und Optimierung Sie können Konfigurationseigenschaften beim Erstellen eines Socket-Managers übergeben über:\nI2PSocketManagerFactory.createManager(host, port, properties); Schlüsseloptionen Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false ### Verhalten nach Arbeitslast Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. Neuere Funktionen seit Version 0.9.4 umfassen die Unterdrückung von Ablehnungsprotokollen, DSA-Listenunterstützung (0.9.21) und die obligatorische Protokolldurchsetzung (0.9.36). Router seit 2.10.0 enthalten Post-Quanten-Hybridverschlüsselung (ML-KEM + X25519) auf der Transportschicht. Protokolldetails Jeder Stream wird durch eine Stream ID identifiziert. Pakete tragen Steuerungsflags ähnlich wie TCP: SYNCHRONIZE, ACK, FIN und RESET. Pakete können gleichzeitig sowohl Daten als auch Steuerungsflags enthalten, was die Effizienz für kurzlebige Verbindungen verbessert.\nVerbindungslebenszyklus SYN gesendet — Initiator enthält optionale Daten. SYN/ACK-Antwort — Responder enthält optionale Daten. ACK-Finalisierung — stellt Zuverlässigkeit und Sitzungsstatus her. FIN/RESET — wird für ordnungsgemäßes Schließen oder abrupten Abbruch verwendet. Fragmentierung und Neuordnung Da I2P-Tunnel Latenz und Nachrichten-Umordnung verursachen, puffert die Bibliothek Pakete von unbekannten oder vorzeitig eintreffenden Streams. Gepufferte Nachrichten werden gespeichert, bis die Synchronisierung abgeschlossen ist, wodurch eine vollständige, geordnete Zustellung gewährleistet wird.\nProtokolldurchsetzung Die Option i2p.streaming.enforceProtocol=true (Standard seit 0.9.36) stellt sicher, dass Verbindungen die korrekte I2CP-Protokollnummer verwenden, wodurch Konflikte zwischen mehreren Subsystemen verhindert werden, die ein destination gemeinsam nutzen.\nInteroperabilität und Best Practices Das Streaming-Protokoll existiert parallel zur Datagram API und gibt Entwicklern die Wahl zwischen verbindungsorientierten und verbindungslosen Transportmechanismen.\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram ### Gemeinsame Clients Anwendungen können bestehende Tunnel wiederverwenden, indem sie als Shared Clients laufen, wodurch mehrere Dienste dieselbe Destination gemeinsam nutzen können. Dies reduziert zwar den Overhead, erhöht aber das Risiko der dienstübergreifenden Korrelation – mit Vorsicht verwenden.\nÜberlastungssteuerung Die Streaming-Ebene passt sich kontinuierlich an Netzwerklatenz und Durchsatz über RTT-basiertes Feedback an. Anwendungen funktionieren am besten, wenn Router beitragende Peers sind (teilnehmende Tunnel aktiviert). TCP-ähnliche Überlastungskontrollmechanismen verhindern die Überlastung langsamer Peers und helfen, die Bandbreitennutzung über Tunnel hinweg auszugleichen. Latenzüberlegungen Da I2P mehrere hundert Millisekunden Basislatenz hinzufügt, sollten Anwendungen Round-Trips minimieren. Bündeln Sie Daten mit dem Verbindungsaufbau, wo möglich (z.B. HTTP-Anfragen in SYN). Vermeiden Sie Designs, die auf vielen kleinen sequenziellen Austauschen basieren.\nTesten und Kompatibilität Testen Sie immer gegen sowohl Java I2P als auch i2pd, um vollständige Kompatibilität sicherzustellen. Obwohl das Protokoll standardisiert ist, können geringfügige Implementierungsunterschiede bestehen. Gehen Sie mit älteren Routern behutsam um – viele Peers verwenden noch Versionen vor 2.0. Überwachen Sie Verbindungsstatistiken mit I2PSocket.getOptions() und getSession(), um RTT- und Retransmission-Metriken auszulesen. Die Leistung hängt stark von der Tunnel-Konfiguration ab: - Kurze Tunnel (1–2 Hops) → geringere Latenz, reduzierte Anonymität. - Lange Tunnel (3+ Hops) → höhere Anonymität, erhöhte RTT.\nWichtige Verbesserungen (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. --- Zusammenfassung Die I2P Streaming Library ist das Rückgrat jeglicher zuverlässiger Kommunikation innerhalb von I2P. Sie gewährleistet die geordnete, authentifizierte und verschlüsselte Nachrichtenzustellung und bietet einen nahezu vollständigen Ersatz für TCP in anonymen Umgebungen.\nUm optimale Leistung zu erzielen: - Minimieren Sie Round-Trips durch SYN+Payload-Bündelung. - Passen Sie Fenster- und Timeout-Parameter für Ihre Arbeitslast an. - Bevorzugen Sie kürzere Tunnel für latenzempfindliche Anwendungen. - Verwenden Sie überlastungsfreundliche Designs, um Peers nicht zu überlasten.\n","description":"TCP-ähnlicher Transport, der von den meisten I2P-Anwendungen verwendet wird","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"Streaming-Protokoll","url":"/de/docs/api/streaming/"},{"categories":null,"content":"Übersicht Die I2P Streaming Library (Streaming-Bibliothek) bietet eine zuverlässige, geordnete und authentifizierte Datenübertragung aufbauend auf der unzuverlässigen Nachrichtenebene von I2P — analog zu TCP über IP. Sie wird von fast allen interaktiven I2P‑Anwendungen wie Web‑Browsing, IRC, E‑Mail und Dateifreigabe verwendet.\nEs stellt zuverlässige Übertragung, Überlastkontrolle, Wiederübertragung und Flusssteuerung über die anonymen tunnels mit hoher Latenz von I2P sicher. Jeder Datenstrom ist zwischen Destinations (Zielen) vollständig Ende-zu-Ende verschlüsselt.\nZentrale Designprinzipien Die Streaming-Bibliothek implementiert einen einphasigen Verbindungsaufbau, bei dem SYN-, ACK- und FIN-Flags Nutzdaten in derselben Nachricht mitführen können. Dies minimiert Round-Trips in Umgebungen mit hoher Latenz — eine kleine HTTP-Transaktion kann in einem einzigen Round-Trip abgeschlossen werden.\nStaukontrolle und Wiederübertragung sind an TCP angelehnt, jedoch für die Umgebung von I2P angepasst. Die Fenstergrößen sind nachrichtenbasiert statt bytebasiert und auf die tunnel-Latenz sowie den Overhead abgestimmt. Das Protokoll unterstützt langsamen Start, Stauvermeidung und exponentielles Backoff, ähnlich dem AIMD-Algorithmus von TCP.\nArchitektur Die Streaming-Bibliothek arbeitet zwischen Anwendungen und der I2CP-Schnittstelle.\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels Die meisten Nutzer greifen über I2PSocketManager, I2PTunnel oder SAMv3 darauf zu. Die Bibliothek übernimmt transparent die Destination-Verwaltung (Adresse in I2P), die tunnel-Nutzung und erneute Übertragungen. Paketformat +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | Details zum Header Stream-IDs: 32-Bit-Werte, die lokale und entfernte Streams eindeutig kennzeichnen. Sequenznummer: Beginnt bei 0 für SYN und erhöht sich pro Nachricht. Ack Through (Bestätigt bis): Bestätigt alle Nachrichten bis N, mit Ausnahme derjenigen in der NACK-Liste. Flags: Bitmaske, die Zustand und Verhalten steuert. Optionen: Liste variabler Länge für RTT, MTU und Protokollverhandlung. Schlüssel-Flags Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive --- Flusskontrolle und Zuverlässigkeit Streaming (I2P-Streaming-Protokoll) verwendet nachrichtenbasierte Fenstersteuerung, im Gegensatz zum bytebasierten Ansatz von TCP. Die Anzahl der unbestätigten Pakete, die gleichzeitig unterwegs sein dürfen, entspricht der aktuellen Fenstergröße (Standard: 128).\nMechanismen Staukontrolle: Slow Start und AIMD-basierte Stauvermeidung (additive Erhöhung/multiplikative Verringerung). Choke/Unchoke (Drosseln/Freigeben): Flusskontrollsignalisierung basierend auf Pufferbelegung. Wiederübertragung: RFC 6298-basierte RTO-Berechnung mit exponentiellem Backoff. Duplikatfilterung: Gewährleistet Zuverlässigkeit trotz potenziell umgeordneter Nachrichten. Typische Konfigurationswerte:\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout --- Verbindungsaufbau Initiator sendet ein SYN (optional mit Nutzdaten und FROM_INCLUDED). Antwortender antwortet mit SYN+ACK (kann Nutzdaten enthalten). Initiator sendet das abschließende ACK und bestätigt damit den Verbindungsaufbau. Optionale anfängliche Nutzdaten ermöglichen die Datenübertragung, bevor der vollständige Handshake abgeschlossen ist.\nImplementierungsdetails Wiederübertragung und Zeitüberschreitung Der Wiederübertragungsalgorithmus folgt RFC 6298. - Initiales RTO: 9s - Minimales RTO: 100ms - Maximales RTO: 45s - Alpha: 0.125 - Beta: 0.25\nGemeinsame Nutzung von Steuerblöcken Jüngste Verbindungen zum selben Peer nutzen vorherige RTT (Round-Trip Time, Hin- und Rücklaufzeit) und Fensterdaten erneut, um den Hochlauf zu beschleunigen und „Kaltstart“-Latenz zu vermeiden. Kontrollblöcke verfallen nach einigen Minuten.\nMTU und Fragmentierung Standard-MTU: 1730 Bytes (fasst zwei I2NP-Nachrichten). ECIES-Ziele: 1812 Bytes (verringerter Overhead). Minimale unterstützte MTU: 512 Bytes. Die Nutzlastgröße umfasst den Streaming-Header mit einer Mindestgröße von 22 Byte nicht.\nVersionsverlauf Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) --- Nutzung auf Anwendungsebene Java-Beispiel Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); Unterstützung für SAMv3 und i2pd SAMv3: Bietet STREAM- und DATAGRAM-Modi für Nicht-Java-Clients. i2pd: Stellt identische Streaming-Parameter über Optionen der Konfigurationsdatei bereit (z. B. i2p.streaming.maxWindowSize, profile, usw.). Die Wahl zwischen Streaming und Datagrammen Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn --- Sicherheit und Post-Quanten-Zukunft Streaming-Sitzungen sind auf der I2CP-Ebene Ende-zu-Ende-verschlüsselt. Post-Quanten-Hybridverschlüsselung (ML-KEM + X25519) wird in 2.10.0 experimentell unterstützt, ist jedoch standardmäßig deaktiviert.\nReferenzen Streaming-API-Übersicht Spezifikation des Streaming-Protokolls I2CP-Spezifikation Vorschlag 144: Streaming-MTU-Berechnungen I2P 2.10.0 Versionshinweise ","description":"Zuverlässiger, TCP-ähnlicher Transport, der von den meisten I2P-Anwendungen verwendet wird","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"Streaming-Protokoll","url":"/de/docs/specs/streaming/"},{"categories":null,"content":" 1. Übersicht Ein Transport in I2P ist eine Methode für die direkte Punkt-zu-Punkt-Kommunikation zwischen routers. Diese Mechanismen gewährleisten Vertraulichkeit und Integrität und überprüfen dabei die router-Authentifizierung.\nJeder Transport arbeitet unter Verwendung von Verbindungsparadigmen mit Authentifizierung, Flusskontrolle, Bestätigungen und Wiederübertragungsfunktionen.\n2. Aktuelle Transportprotokolle I2P unterstützt derzeit zwei primäre Transportprotokolle:\nTransport Protocol Description NTCP2 TCP Noise-based TCP transport with modern encryption (as of 0.9.36) SSU2 UDP Secure Semireliable UDP with modern encryption (as of 0.9.56) ### 2.1 Veraltete Transportprotokolle (abgekündigt) Transport Protocol Status NTCP TCP Replaced by NTCP2; removed in 0.9.62 SSU UDP Replaced by SSU2; removed in 0.9.62 --- 3. Transportdienste Das Transport-Subsystem stellt die folgenden Dienste bereit:\n3.1 Nachrichtenübermittlung Zuverlässige I2NP Nachrichtenübermittlung (Transportprotokolle übernehmen ausschließlich den I2NP‑Nachrichtenverkehr) In-Order-Zustellung ist NICHT garantiert universell Prioritätsbasierte Nachrichtenwarteschlangen 3.2 Verbindungsverwaltung Aufbau und Schließung von Verbindungen Verwaltung von Verbindungsobergrenzen mit Durchsetzung von Schwellenwerten Statusverfolgung pro Peer Automatisierte und manuelle Durchsetzung der Peer-Sperrliste 3.3 Netzwerkkonfiguration Mehrere router-Adressen pro Transport (IPv4- und IPv6-Unterstützung seit v0.9.8) Öffnen von UPnP-Firewall-Ports Unterstützung für NAT/Firewall-Traversal Lokale IP-Erkennung über mehrere Methoden 3.4 Sicherheit Verschlüsselung für Punkt-zu-Punkt-Kommunikation Validierung von IP-Adressen gemäß lokalen Regeln Bestimmung des Zeitkonsenses (NTP-Backup) 3.5 Bandbreitenverwaltung Eingehende und ausgehende Bandbreitenlimits Optimale Transportauswahl für ausgehende Nachrichten 4. Transportadressen Das Subsystem verwaltet eine Liste der Router-Kontaktpunkte:\nTransportmethode (NTCP2, SSU2) IP-Adresse Portnummer Optionale Parameter Mehrere Adressen pro Transportmethode sind möglich.\n4.1 Häufige Adresskonfigurationen Configuration Description Hidden Routers with no published addresses Firewalled Routers publishing SSU2 addresses with \"introducer\" peer lists for NAT traversal Unrestricted Routers advertising both NTCP2 and SSU2 addresses on IPv4 and/or IPv6 --- 5. Auswahl des Transports Das System wählt Transporte für I2NP messages unabhängig von Protokollen höherer Schichten aus. Die Auswahl verwendet ein Bietsystem, bei dem jeder Transport Gebote abgibt, wobei der niedrigste Wert gewinnt.\n5.1 Faktoren zur Gebotsbestimmung Einstellungen für Transportpräferenzen Bestehende Peer-Verbindungen Aktuelle gegenüber Schwellenwerten für die Anzahl der Verbindungen Verlauf der jüngsten Verbindungsversuche Beschränkungen der Nachrichtengröße Transportfähigkeiten der RouterInfo des Peers Direktheit der Verbindung (direkt versus introducer-abhängig) Vom Peer veröffentlichte Transportpräferenzen In der Regel unterhalten zwei routers gleichzeitig Verbindungen über genau ein Transportprotokoll; gleichzeitige Verbindungen über mehrere Transportprotokolle sind jedoch möglich.\n6. NTCP2 NTCP2 (Neues Transportprotokoll 2) ist der moderne, TCP-basierte Transport für I2P, der in Version 0.9.36 eingeführt wurde.\n6.1 Hauptfunktionen Basiert auf dem Noise Protocol Framework (Noise_XK-Pattern) Verwendet X25519 für den Schlüsselaustausch Verwendet ChaCha20/Poly1305 für authentifizierte Verschlüsselung Verwendet BLAKE2s für das Hashing Protokollverschleierung zur Abwehr von DPI (Deep Packet Inspection) Optionales Padding zur Abwehr von Verkehrsanalysen 6.2 Verbindungsaufbau Sitzungsanfrage (Alice → Bob): Ephemerer X25519-Schlüssel + verschlüsselte Nutzlast Sitzung erstellt (Bob → Alice): Ephemerer Schlüssel + verschlüsselte Bestätigung Sitzung bestätigt (Alice → Bob): Abschließender Handshake mit RouterInfo Alle nachfolgenden Daten werden mit Sitzungsschlüsseln verschlüsselt, die aus dem Handshake abgeleitet werden.\nAusführliche Informationen finden Sie in der NTCP2-Spezifikation .\n7. SSU2 SSU2 (Secure Semireliable UDP 2) ist das moderne, UDP-basierte Transportprotokoll für I2P und wurde in Version 0.9.56 eingeführt.\n7.1 Hauptfunktionen Basiert auf dem Noise Protocol Framework (Noise_XK-Muster) Verwendet X25519 für den Schlüsselaustausch Verwendet ChaCha20/Poly1305 für authentifizierte Verschlüsselung Semizuverlässige Übertragung mit selektiven Bestätigungen NAT-Traversal über Hole Punching und Relay/Einführung Unterstützung für Verbindungsmigration Path-MTU-Erkennung 7.2 Vorteile gegenüber SSU (veraltet) Feature SSU (Legacy) SSU2 Encryption ElGamal + AES X25519 + ChaCha20/Poly1305 Header encryption Partial Full (ChaCha20) Connection ID Fixed Encrypted, rotatable NAT traversal Basic introduction Enhanced hole punching + relay Obfuscation Minimal Improved (variable padding) Alle Einzelheiten finden Sie in der [SSU2-Spezifikation](/docs/specs/ssu2/). 8. NAT-Traversal Beide Transportprotokolle unterstützen NAT-Traversal, damit routers hinter einer Firewall am Netzwerk teilnehmen können.\n8.1 SSU2 Einführung Wenn ein router eingehende Verbindungen nicht direkt empfangen kann:\nRouter veröffentlicht introducer-Adressen (Vermittler) in seiner RouterInfo Der sich verbindende Peer sendet eine Einführungsanfrage an den introducer Der introducer leitet Verbindungsinformationen an den durch eine Firewall geschützten Router weiter Der durch eine Firewall geschützte Router initiiert eine ausgehende Verbindung (hole punch; NAT-Lochstanzen) Direkte Kommunikation hergestellt 8.2 NTCP2 und Firewalls NTCP2 erfordert eingehende TCP-Konnektivität. Router hinter NAT können:\nUPnP verwenden, um Ports automatisch zu öffnen Portweiterleitung manuell konfigurieren Für eingehende Verbindungen SSU2 verwenden und für ausgehende NTCP2 9. Protokollverschleierung Beide modernen Transportprotokolle integrieren Verschleierungsfunktionen:\nZufälliges Padding in Handshake-Nachrichten Verschlüsselte Header, die keine Protokollsignaturen preisgeben Nachrichten variabler Länge zur Abwehr von Traffic-Analyse Keine festen Muster beim Verbindungsaufbau Hinweis: Verschleierung auf der Transportschicht ergänzt, ersetzt aber nicht die durch die tunnel-Architektur von I2P bereitgestellte Anonymität.\n10. Zukünftige Entwicklungen Geplante Forschungsarbeiten und Verbesserungen umfassen:\nPluggable Transports (austauschbare Verschleierungsprotokolle) – Tor-kompatible Verschleierungs-Plugins QUIC-basierter Transport – Untersuchung der Vorteile des QUIC-Protokolls Optimierung der Verbindungsgrenzen – Forschung zu optimalen Grenzen für Peer-Verbindungen Erweiterte Padding-Strategien – Verbesserte Widerstandsfähigkeit gegen Verkehrsanalyse 11. Referenzen NTCP2-Spezifikation – Noise-basiertes TCP-Transportprotokoll SSU2-Spezifikation – Sicheres halbzuverlässiges UDP 2 I2NP-Spezifikation – Nachrichten des I2P Network Protocol Gemeinsame Strukturen – RouterInfo- und Adressstrukturen Historische NTCP-Diskussion – Entwicklungsgeschichte des Legacy-Transports Legacy-SSU-Dokumentation – Ursprüngliche SSU-Spezifikation (veraltet) ","description":"Die I2P-Transportschicht verstehen - Punkt-zu-Punkt-Kommunikationsmethoden zwischen routers, einschließlich NTCP2 und SSU2","id":"5fbac972dc212081634c49c5e6ac0004","section":"docs","title":"Transportschicht","url":"/de/docs/overview/transport/"},{"categories":null,"content":" Hinweis: Dieses Archiv enthält spekulative Entwurfsarbeiten aus der Zeit vor I2P 0.9.41. Für die Implementierung für den Produktionseinsatz siehe die tunnel-Dokumentation .\nKonfigurationsalternativen Zu den in Betracht gezogenen Ideen für künftige tunnel-Stellschrauben gehörten:\nRatenbegrenzungen für die Nachrichtenübermittlung Padding-Richtlinien (einschließlich chaff injection, Einbringen von Täuschdaten) Kontrollen der Tunnel-Lebensdauer Batch- und Warteschlangenstrategien für den Versand von Nutzlasten Keine dieser Optionen wurde mit der Legacy-Implementierung ausgeliefert.\nPadding-Strategien Besprochene potenzielle Padding-Ansätze:\nKein Padding Padding mit zufälliger Länge Padding mit fester Länge Padding auf das nächste Kilobyte Padding auf Zweierpotenzen (2^n Bytes) Frühe Messungen (Release 0.4) führten zur aktuellen, festen Größe von 1024 Byte für tunnel-Nachrichten. Höherstufige Garlic-Nachrichten können eigenes Padding hinzufügen.\nFragmentierung Um Tagging-Angriffe über die Nachrichtenlänge zu verhindern, haben tunnel-Nachrichten eine feste Größe von 1024 Bytes. Größere I2NP-Payloads werden vom Gateway fragmentiert; der Endpunkt setzt die Fragmente innerhalb eines kurzen Timeouts wieder zusammen. Router können Fragmente neu anordnen, um die Packeffizienz vor dem Senden zu maximieren.\nZusätzliche Alternativen Tunnel-Verarbeitung zur Laufzeit anpassen Drei Möglichkeiten wurden untersucht:\nErlauben, dass ein Zwischen-Hop einen tunnel vorübergehend beendet, indem ihm Zugriff auf entschlüsselte Nutzdaten gewährt wird. Erlauben, dass teilnehmende router Nachrichten “remixen”, indem sie diese, bevor sie zum nächsten Hop fortfahren, durch einen ihrer eigenen ausgehenden tunnel senden. Dem Ersteller des tunnel ermöglichen, den nächsten Hop eines Peers dynamisch neu festzulegen. Bidirektionale Tunnels Die Verwendung separater eingehender und ausgehender tunnels begrenzt die Informationen, die eine einzelne Gruppe von Peers beobachten kann (z. B. eine GET-Anfrage gegenüber einer großen Antwort). Bidirektionale tunnels vereinfachen das Peer-Management, legen jedoch in beiden Richtungen gleichzeitig vollständige Verkehrsmuster offen. Unidirektionale tunnels blieben daher das bevorzugte Design.\nRückkanäle und variable Größen Die Zulassung variabler tunnel-Nachrichtengrößen würde verdeckte Kanäle zwischen kolludierenden Peers ermöglichen (z. B. durch Kodierung von Daten über ausgewählte Größen oder Häufigkeiten). Nachrichten fester Größe mindern dieses Risiko, allerdings zum Preis eines zusätzlichen Padding-Overheads.\nAlternativen für den Tunnel-Aufbau Quelle: Hashing it out in Public Veraltete „Parallele“ Build-Methode Vor Version 0.6.1.10 wurden tunnel-Aufbauanfragen parallel an jeden Teilnehmer gesendet. Diese Methode ist auf der alten tunnel-Seite dokumentiert.\nTeleskopischer Aufbau in einem Schritt (aktuelle Methode) Der moderne Ansatz sendet build messages (Aufbau-Nachrichten) hop-by-hop durch den teilweise aufgebauten tunnel. Obwohl dies Tors telescoping (schrittweises Aufbauen) ähnelt, verringert das Weiterleiten der build messages durch exploratory tunnels (Erkundungstunnel) die Informationsleckage.\n„Interaktives“ Teleskopieren Der Hop-für-Hop-Aufbau mit expliziten Round-Trips ermöglicht es Peers, Nachrichten zu zählen und ihre Position im tunnel abzuleiten, daher wurde dieser Ansatz verworfen.\nNicht-exploratorische Management Tunnels Ein Vorschlag war, einen separaten Pool von Management tunnels für Aufbauverkehr bereitzuhalten. Auch wenn dies partitionierten routers helfen könnte, wurde es bei ausreichender Netzwerkintegration als unnötig erachtet.\nErkundungszustellung (veraltet) Vor 0.6.1.10 wurden einzelne tunnel-Anfragen mit garlic encryption verschlüsselt und über Erkundungs-tunnel übermittelt; die Antworten kamen separat zurück. Diese Strategie wurde durch die aktuelle one-shot telescoping method (ein einmaliges, stufenweises Aufbauverfahren) ersetzt.\nKernaussagen tunnel-Nachrichten fester Größe schützen trotz zusätzlichem Padding-Overhead vor größenbasierter Markierung und verdeckten Kanälen. Alternative Padding-, Fragmentierungs- und Aufbaustrategien wurden untersucht, aber angesichts der Anonymitätskompromisse nicht übernommen. Das tunnel-Design balanciert weiterhin Effizienz, Beobachtbarkeit und Widerstandsfähigkeit gegen Vorgänger- und Überlastungsangriffe. ","description":"Historische Untersuchung von tunnel-Padding, Fragmentierung und Aufbau-Strategien","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"Tunnel-Diskussion","url":"/de/docs/legacy/tunnel/"},{"categories":null,"content":"Überblick I2P baut temporäre, unidirektionale Tunnel – geordnete Sequenzen von Routern, die verschlüsselten Verkehr weiterleiten. Tunnel werden als inbound (Nachrichten fließen zum Ersteller hin) oder outbound (Nachrichten fließen vom Ersteller weg) klassifiziert.\nEin typischer Austausch leitet Alices Nachricht durch einen ihrer outbound tunnels, weist den outbound Endpunkt an, sie an das gateway eines von Bobs inbound tunnels weiterzuleiten, und dann empfängt Bob sie an seinem inbound Endpunkt.\nA: Outbound Gateway (Alice) B: Outbound Participant C: Outbound Endpoint D: Inbound Gateway E: Inbound Participant F: Inbound Endpoint (Bob) Tunnels haben eine feste Lebensdauer von 10 Minuten und übertragen Nachrichten mit fester Größe von 1024 Bytes (1028 Bytes inklusive des Tunnel-Headers), um Traffic-Analyse auf Basis von Nachrichtengröße oder Zeitmustern zu verhindern.\nTunnel-Vokabular Tunnel gateway: Erster Router in einem Tunnel. Bei eingehenden Tunneln erscheint die Identität dieses Routers im veröffentlichten LeaseSet . Bei ausgehenden Tunneln ist das Gateway der ursprüngliche Router (A und D oben). Tunnel endpoint: Letzter Router in einem Tunnel (C und F oben). Tunnel participant: Zwischengeschalteter Router in einem Tunnel (B und E oben). Participants können weder ihre Position noch die Tunnel-Richtung bestimmen. n-hop tunnel: Anzahl der Sprünge zwischen Routern. 0-hop: Gateway und Endpoint sind derselbe Router – minimale Anonymität. 1-hop: Gateway verbindet sich direkt mit dem Endpoint – niedrige Latenz, geringe Anonymität. 2-hop: Standard für explorative Tunnel; ausgewogenes Verhältnis von Sicherheit und Leistung. 3-hop: Empfohlen für Anwendungen, die starke Anonymität erfordern. Tunnel ID: 4-Byte-Ganzzahl, eindeutig pro Router und pro Hop, zufällig vom Ersteller gewählt. Jeder Hop empfängt und leitet mit unterschiedlichen IDs weiter. Tunnel-Build-Informationen Router, die Gateway-, Participant- und Endpoint-Rollen übernehmen, erhalten unterschiedliche Datensätze innerhalb der Tunnel Build Message. Modernes I2P unterstützt zwei Methoden:\nElGamal (veraltet, 528-Byte-Datensätze) ECIES-X25519 (aktuell, 218-Byte-Datensätze über Short Tunnel Build Message – STBM) Information Distributed to Participants Gateway empfängt: - Tunnel-Schicht-Schlüssel (AES-256 oder ChaCha20-Schlüssel je nach Tunnel-Typ) - Tunnel-IV-Schlüssel (zur Verschlüsselung von Initialisierungsvektoren) - Reply-Schlüssel und Reply-IV (zur Verschlüsselung der Build-Antwort) - Tunnel-ID (nur Inbound-Gateways) - Next-Hop-Identity-Hash und Tunnel-ID (falls nicht terminal)\nIntermediate-Teilnehmer erhalten: - Tunnel-Layer-Schlüssel und IV-Schlüssel für ihren Hop - Tunnel-ID und Informationen zum nächsten Hop - Reply-Schlüssel und IV für die Verschlüsselung der Build-Antwort\nEndpoints erhalten: - Tunnel-Schicht- und IV-Schlüssel - Antwort-Router und Tunnel-ID (nur ausgehende Endpoints) - Antwortschlüssel und IV (nur ausgehende Endpoints)\nFür vollständige Details siehe die Tunnel Creation Specification und ECIES Tunnel Creation Specification .\nTunnel Pooling Router gruppieren Tunnel in Tunnel-Pools für Redundanz und Lastverteilung. Jeder Pool verwaltet mehrere parallele Tunnel, was ein Failover ermöglicht, wenn einer ausfällt. Intern verwendete Pools sind exploratory tunnels, während anwendungsspezifische Pools client tunnels sind.\nJedes Ziel verwaltet separate eingehende und ausgehende Pools, die durch I2CP-Optionen konfiguriert werden (Tunnelanzahl, Backup-Anzahl, Länge und QoS-Parameter). Router überwachen die Tunnel-Gesundheit, führen regelmäßige Tests durch und bauen ausgefallene Tunnel automatisch neu auf, um die Pool-Größe beizubehalten.\nTunnel-Pooling 0-hop Tunnels: Bieten nur plausible Abstreitbarkeit. Der Datenverkehr stammt immer vom selben Router und endet dort – wird für jede anonyme Nutzung nicht empfohlen.\n1-hop Tunnels: Bieten grundlegende Anonymität gegen passive Beobachter, sind jedoch anfällig, wenn ein Angreifer diesen einzelnen Hop kontrolliert.\n2-Hop-Tunnel: Beinhalten zwei entfernte Router und erhöhen die Angriffskosten erheblich. Standard für explorative Pools.\n3-Hop-Tunnel: Empfohlen für Anwendungen, die robusten Anonymitätsschutz erfordern. Zusätzliche Hops erhöhen die Latenz ohne nennenswerten Sicherheitsgewinn.\nStandardeinstellungen: Router verwenden 2-Hop exploratory tunnels und anwendungsspezifische 2 oder 3 Hop client tunnels, um Leistung und Anonymität auszubalancieren.\nTunnel-Länge Router testen periodisch Tunnel, indem sie eine DeliveryStatusMessage durch einen ausgehenden Tunnel zu einem eingehenden Tunnel senden. Wenn der Test fehlschlägt, erhalten beide Tunnel eine negative Profilgewichtung. Aufeinanderfolgende Fehlschläge markieren einen Tunnel als unbrauchbar; der Router baut dann einen Ersatz auf und veröffentlicht ein neues LeaseSet. Die Ergebnisse fließen in die Peer-Kapazitätsmetriken ein, die vom Peer-Auswahlsystem verwendet werden.\nTunnel-Tests Router konstruieren Tunnel mithilfe einer nicht-interaktiven Telescoping-Methode: Eine einzelne Tunnel Build Message wird Hop für Hop weitergeleitet. Jeder Hop entschlüsselt seinen Datensatz, fügt seine Antwort hinzu und leitet die Nachricht weiter. Der letzte Hop sendet die aggregierte Build-Antwort über einen anderen Pfad zurück, um Korrelation zu verhindern. Moderne Implementierungen verwenden Short Tunnel Build Messages (STBM) für ECIES und Variable Tunnel Build Messages (VTBM) für Legacy-Pfade. Jeder Datensatz wird pro Hop mittels ElGamal oder ECIES-X25519 verschlüsselt.\nTunnel-Erstellung Tunnel-Verkehr verwendet mehrschichtige Verschlüsselung. Jeder Hop fügt eine Verschlüsselungsschicht hinzu oder entfernt sie, während Nachrichten den Tunnel durchlaufen.\nElGamal tunnels: AES-256/CBC für Payloads mit PKCS#5-Padding. ECIES tunnels: ChaCha20 oder ChaCha20-Poly1305 für authentifizierte Verschlüsselung. Jeder Hop hat zwei Schlüssel: einen Layer-Schlüssel und einen IV-Schlüssel. Router entschlüsseln die IV, verwenden sie zur Verarbeitung der Nutzdaten und verschlüsseln die IV dann erneut, bevor sie die Nachricht weiterleiten. Dieses doppelte IV-Schema verhindert Message-Tagging.\nAusgehende Gateways entschlüsseln alle Schichten im Voraus, sodass Endpunkte Klartext erhalten, nachdem alle Teilnehmer Verschlüsselung hinzugefügt haben. Eingehende Tunnel verschlüsseln in die entgegengesetzte Richtung. Teilnehmer können weder die Richtung noch die Länge des Tunnels bestimmen.\nTunnel-Verschlüsselung Dynamische Tunnel-Lebensdauern und adaptive Pool-Größenanpassung für Netzwerk-Lastverteilung Alternative Tunnel-Teststrategien und individuelle Hop-Diagnosen Optional Proof-of-Work oder Bandwidth-Zertifikat-Validierung (implementiert in API 0.9.65+) Traffic Shaping und Chaff-Insertion-Forschung für Endpunkt-Mixing Fortgesetzte Ausmusterung von ElGamal und Migration zu ECIES-X25519 Laufende Entwicklung Tunnel Implementation Specification Tunnel Creation Specification (ElGamal) Tunnel Creation Specification (ECIES-X25519) Tunnel Message Specification Garlic Routing I2P Network Database Peer Profiling and Selection I2P Bedrohungsmodell ElGamal/AES + SessionTag Encryption I2CP-Optionen ","description":"Überblick über I2P-Tunnel-Terminologie, -Aufbau und -Lebenszyklus","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"Tunnel-Routing","url":"/de/docs/overview/tunnel-routing/"},{"categories":null,"content":"Überblick Diese Spezifikation dokumentiert das Protokoll für UDP-BitTorrent-Announce-Anfragen (Tracker-Anfragen) in I2P. Für die allgemeine Spezifikation von BitTorrent in I2P siehe die Dokumentation zu BitTorrent über I2P . Für Hintergrund und zusätzliche Informationen zur Entwicklung dieser Spezifikation siehe Proposal 160 .\nDieses Protokoll wurde am 24. Juni 2025 formell genehmigt und in I2P Version 2.10.0 (API 0.9.67) implementiert, veröffentlicht am 8. September 2025. Die UDP-Tracker-Unterstützung ist derzeit im I2P-Netzwerk in Betrieb, mit mehreren produktiven Trackern und vollständiger Unterstützung im i2psnark-Client.\nEntwurf Diese Spezifikation verwendet antwortfähige Datagram2, antwortfähige Datagram3 und Roh-Datagramme, wie in der I2P Datagram Specification definiert. Datagram2 und Datagram3 sind Varianten antwortfähiger Datagramme, definiert in Proposal 163 . Datagram2 fügt Schutz vor Replay-Angriffen und Unterstützung für Offline-Signaturen hinzu. Datagram3 ist kleiner als das alte Datagrammformat, jedoch ohne Authentifizierung.\nBEP 15 Zur Orientierung ist der in BEP 15 definierte Nachrichtenfluss wie folgt:\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Die Connect-Phase ist erforderlich, um IP-Adress-Spoofing zu verhindern. Der Tracker gibt eine Verbindungs-ID zurück, die der Client in nachfolgenden Announce-Anfragen verwendet. Diese Verbindungs-ID läuft standardmäßig beim Client nach einer Minute ab und beim Tracker nach zwei Minuten.\nI2P verwendet denselben Nachrichtenfluss wie BEP 15, um die Übernahme in bestehenden UDP-fähigen Client-Codebasen zu erleichtern, aus Effizienzgründen und aus den nachfolgend erläuterten Sicherheitsgründen:\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... Dies ermöglicht potenziell erhebliche Bandbreiteneinsparungen gegenüber Ankündigungen per Streaming (TCP). Während das Datagram2 (Datagramm-Typ 2) ungefähr die gleiche Größe wie ein Streaming-SYN hat, ist die rohe Antwort deutlich kleiner als das Streaming-SYN-ACK. Nachfolgende Anfragen verwenden Datagram3 (Datagramm-Typ 3), und die nachfolgenden Antworten sind roh.\nDie Announce-Anfragen werden als Datagram3 (Datagramm-Version 3) gesendet, damit der Tracker keine große Zuordnungstabelle von Verbindungs-IDs zu Announce-Ziel oder Hash vorhalten muss. Stattdessen kann der Tracker die Verbindungs-IDs kryptografisch aus dem Sender-Hash, dem aktuellen Zeitstempel (basierend auf einem bestimmten Intervall) und einem geheimen Wert erzeugen. Wenn eine Announce-Anfrage eingeht, überprüft der Tracker die Verbindungs-ID und verwendet anschließend den Datagram3-Sender-Hash als Sendeziel.\nLebensdauer der Verbindung BEP 15 legt fest, dass die Verbindungs-ID beim Client nach einer Minute und beim Tracker nach zwei Minuten abläuft. Das ist nicht konfigurierbar. Das begrenzt die möglichen Effizienzgewinne, es sei denn, Clients würden announces (Tracker-Ankündigungsanfragen) bündeln, um sie alle innerhalb eines Ein-Minuten-Zeitfensters abzusetzen. i2psnark bündelt announces derzeit nicht; es verteilt sie, um Verkehrsspitzen zu vermeiden. Berichten zufolge betreiben Power-User gleichzeitig Tausende von Torrents, und so viele announces in eine Minute zu pressen, ist unrealistisch.\nHier schlagen wir vor, die Verbindungsantwort um ein optionales Feld für die Lebensdauer der Verbindung zu erweitern. Fehlt es, beträgt der Standardwert eine Minute. Andernfalls soll die in Sekunden angegebene Lebensdauer vom Client verwendet werden, und der Tracker hält die Verbindungs-ID eine weitere Minute vor.\nKompatibilität mit BEP 15 Dieses Design bewahrt die Kompatibilität mit BEP 15 so weit wie möglich, um die in bestehenden Clients und Trackern erforderlichen Änderungen zu begrenzen.\nDie einzige erforderliche Änderung betrifft das Format der Peer-Informationen in der Announce-Antwort. Die Ergänzung des Feldes lifetime in der Connect-Antwort ist nicht erforderlich, wird jedoch aus Effizienzgründen, wie oben erläutert, nachdrücklich empfohlen.\nSicherheitsanalyse Ein wichtiges Ziel eines UDP-Announce-Protokolls ist es, Adressfälschung zu verhindern. Der Client muss tatsächlich existieren und ein echtes leaseSet beifügen. Er muss über eingehende tunnels verfügen, um die Connect Response empfangen zu können. Diese tunnels könnten zero-hop (ohne Zwischenknoten) sein und sofort aufgebaut werden, aber das würde den Ersteller offenlegen. Dieses Protokoll erreicht dieses Ziel.\nProbleme Dieses Protokoll unterstützt keine blinded destinations (verblindete Ziele), kann aber entsprechend erweitert werden, um dies zu ermöglichen. Siehe unten.\nSpezifikation Protokolle und Ports Repliable Datagram2 (beantwortbares Datagramm) verwendet das I2CP-Protokoll 19; Repliable Datagram3 verwendet das I2CP-Protokoll 20; rohe Datagramme verwenden das I2CP-Protokoll 18. Anfragen dürfen Datagram2 oder Datagram3 sein. Antworten sind immer rohe Datagramme. Das ältere repliable datagram (\u0026ldquo;Datagram1\u0026rdquo;)-Format mit I2CP-Protokoll 17 darf NICHT für Anfragen oder Antworten verwendet werden; diese müssen verworfen werden, wenn sie auf den Anfrage-/Antwort-Ports empfangen werden. Beachten Sie, dass Datagram1 Protokoll 17 weiterhin für das DHT (verteilte Hashtabelle)-Protokoll verwendet wird.\nAnfragen verwenden den I2CP \u0026ldquo;to port\u0026rdquo; (Ziel-Port) aus der announce-URL; siehe unten. Der \u0026ldquo;from port\u0026rdquo; (Quell-Port) der Anfrage wird vom Client gewählt, sollte jedoch ungleich Null sein und sich von den von DHT verwendeten Ports unterscheiden, damit Antworten leicht zugeordnet werden können. Tracker sollten Anfragen ablehnen, die am falschen Port eingehen.\nAntworten verwenden den I2CP \u0026ldquo;to port\u0026rdquo; (Zielport) aus der Anfrage. Der \u0026ldquo;from port\u0026rdquo; (Quellport) der Antwort ist der \u0026ldquo;to port\u0026rdquo; der Anfrage.\nAnkündigungs-URL Das Format der Announce-URL ist in BEP 15 nicht spezifiziert, aber wie im Clearnet haben UDP-Announce-URLs die Form \u0026ldquo;udp://host:port/path\u0026rdquo;. Der Pfad wird ignoriert und darf leer sein, ist im Clearnet jedoch typischerweise \u0026ldquo;/announce\u0026rdquo;. Der :port-Teil sollte immer vorhanden sein; falls der \u0026ldquo;:port\u0026rdquo;-Teil jedoch weggelassen wird, verwende den Standard-I2CP-Port 6969, da dies der übliche Port im Clearnet ist. Es können außerdem CGI-Parameter \u0026amp;a=b\u0026amp;c=d angehängt sein; diese können verarbeitet und in der Announce-Anfrage bereitgestellt werden, siehe BEP 41 . Wenn es keine Parameter oder keinen Pfad gibt, kann der abschließende / ebenfalls weggelassen werden, wie in BEP 41 impliziert.\nDatagrammformate Alle Werte werden in Netzwerk-Byte-Reihenfolge (Big-Endian) gesendet. Erwarten Sie nicht, dass Pakete exakt eine bestimmte Größe haben. Zukünftige Erweiterungen könnten die Größe der Pakete erhöhen.\nVerbindungsanfrage Client an den Tracker. 16 Bytes. Muss ein repliable Datagram2 (antwortfähiges Datagram2) sein. Wie in BEP 15 . Keine Änderungen.\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id Verbindungsantwort Tracker an den Client. 16 oder 18 Bytes. Muss roh sein. Entspricht BEP 15 , außer wie unten angegeben.\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 Die Antwort MUSS an den I2CP \u0026ldquo;to port\u0026rdquo; gesendet werden, der als \u0026ldquo;from port\u0026rdquo; der Anfrage empfangen wurde.\nDas Feld lifetime ist optional und gibt die clientseitige Lebensdauer der connection_id in Sekunden an. Der Standardwert beträgt 60, und der Mindestwert, sofern angegeben, ist 60. Der Höchstwert ist 65535 bzw. etwa 18 Stunden. Der Tracker sollte die connection_id 60 Sekunden länger als die clientseitige Lebensdauer vorhalten.\nAnkündigungsanfrage Client an den Tracker. Mindestens 98 Bytes. Muss ein beantwortbares Datagram3 (Datagramm-Typ 3) sein. Wie in BEP 15 , außer wie unten angegeben.\nDie connection_id ist die, die in der connect response empfangen wurde.\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 Änderungen gegenüber BEP 15 :\nSchlüssel wird ignoriert IP-Adresse wird nicht verwendet Port wird wahrscheinlich ignoriert, muss aber mit dem I2CP from port übereinstimmen Der Abschnitt options, falls vorhanden, ist wie in BEP 41 definiert Die Antwort MUSS an den I2CP \u0026ldquo;to port\u0026rdquo; gesendet werden, der als \u0026ldquo;from port\u0026rdquo; der Anfrage empfangen wurde. Verwenden Sie nicht den Port aus dem announce request (Ankündigungsanfrage).\nAnnounce-Antwort Vom Tracker zum Client. Mindestens 20 Byte. Muss im Rohformat vorliegen. Entspricht BEP 15 mit den unten genannten Ausnahmen.\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 Änderungen gegenüber BEP 15 :\nStatt 6-Byte IPv4+Port oder 18-Byte IPv6+Port geben wir ein Vielfaches von 32 Byte in Form von \u0026ldquo;compact responses\u0026rdquo; (kompakte Antworten) mit den binären SHA-256-Peer-Hashes zurück. Wie bei TCP compact responses geben wir keinen Port an. Die Antwort MUSS an den I2CP \u0026ldquo;to port\u0026rdquo; gesendet werden, der in der Anfrage als \u0026ldquo;from port\u0026rdquo; empfangen wurde. Verwenden Sie nicht den Port aus der announce request (Ankündigungsanfrage).\nI2P-Datagramme haben eine sehr große maximale Größe von etwa 64 KB; für eine zuverlässige Zustellung sollten jedoch Datagramme größer als 4 KB vermieden werden. Um die Bandbreite effizient zu nutzen, sollten Tracker die maximale Anzahl von Peers vermutlich auf etwa 50 begrenzen; das entspricht ungefähr einem 1600‑Byte‑Paket vor dem Overhead in den verschiedenen Schichten und sollte nach der Fragmentierung innerhalb der Nutzlastgrenze einer über zwei tunnel gesendeten Nachricht liegen.\nWie in BEP 15 ist keine Anzahl der folgenden Peer-Adressen (bei BEP 15 IP/Port, hier Hashes) enthalten. Auch wenn BEP 15 dies nicht vorsieht, könnte eine aus lauter Nullen bestehende Endemarkierung der Peers definiert werden, um anzuzeigen, dass die Peer-Informationen vollständig sind und anschließend Erweiterungsdaten folgen.\nDamit zukünftige Erweiterungen möglich sind, sollten Clients einen 32-Byte-Hash aus lauter Nullen und alle darauf folgenden Daten ignorieren. Tracker sollten Announce-Anfragen mit einem Hash aus lauter Nullen ablehnen, obwohl dieser Hash bereits von Java routers gesperrt ist.\nScrape (automatisches Extrahieren von Daten) Scrape-Request/-Response gemäß BEP 15 sind von dieser Spezifikation nicht vorgeschrieben, können jedoch bei Bedarf implementiert werden; es sind keine Änderungen erforderlich. Der Client muss zunächst eine Verbindungs-ID abrufen. Der Scrape-Request ist immer ein repliable (antwortfähig) Datagram3. Die Scrape-Response ist immer raw (roh).\nFehlerantwort Tracker an den Client. Mindestens 8 Bytes (wenn die Nachricht leer ist). Muss im Rohformat vorliegen. Wie in BEP 15 . Keine Änderungen.\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message Erweiterungen Erweiterungsbits oder ein Versionsfeld sind nicht enthalten. Clients und Tracker sollten nicht davon ausgehen, dass Pakete eine bestimmte Größe haben. Auf diese Weise können zusätzliche Felder hinzugefügt werden, ohne die Kompatibilität zu beeinträchtigen. Das in BEP 41 definierte Erweiterungsformat wird bei Bedarf empfohlen.\nDie Verbindungsantwort wird geändert, um eine optionale Lebensdauer der Verbindungs-ID hinzuzufügen.\nWenn Unterstützung für verblindete Ziele erforderlich ist, können wir entweder die verblindete 35-Byte-Adresse an das Ende der announce-Anfrage anhängen oder in den Antworten verblindete Hashes anfordern, unter Verwendung des BEP 41 -Formats (Parameter noch festzulegen). Die Menge der verblindeten 35-Byte-Peer-Adressen könnte an das Ende der announce-Antwort angehängt werden, nach einem 32-Byte-Hash aus lauter Nullen.\nImplementierungsrichtlinien Siehe den oben stehenden Design-Abschnitt für eine Diskussion der Herausforderungen für nicht integrierte, nicht-I2CP-Clients und -Tracker.\nClient-Anwendungen Für einen bestimmten Tracker-Hostnamen sollte ein Client UDP gegenüber HTTP-URLs bevorzugen und nicht an beide melden.\nClients mit vorhandener Unterstützung für BEP 15 sollten nur kleine Anpassungen erfordern.\nWenn ein Client DHT oder andere Datagramm-Protokolle unterstützt, sollte er wahrscheinlich einen anderen Port als den „from port“ der Anfrage wählen, damit die Antworten an diesen Port zurückkommen und nicht mit DHT-Nachrichten vermischt werden. Der Client empfängt als Antworten nur rohe Datagramme. Tracker werden dem Client niemals ein repliable datagram2 (antwortfähiges Datagramm) senden.\nClients mit einer Standardliste von Open-Trackern sollten die Liste aktualisieren und UDP-URLs hinzufügen, sobald bestätigt ist, dass die bekannten Open-Tracker UDP unterstützen.\nClients können die Neuübertragung von Anfragen implementieren, müssen dies jedoch nicht. Neuübertragungen sollten, falls implementiert, ein anfängliches Timeout von mindestens 15 Sekunden verwenden und das Timeout bei jeder weiteren Neuübertragung verdoppeln (exponentielles Backoff).\nClients müssen nach dem Erhalt einer Fehlerantwort ein Backoff (abgestufte Wartezeit) durchführen.\nTracker Tracker mit bestehender Unterstützung für BEP 15 sollten nur kleine Änderungen erfordern. Diese Spezifikation unterscheidet sich vom Vorschlag von 2014 dadurch, dass der Tracker den Empfang von antwortfähigen datagram2 und datagram3 auf demselben Port unterstützen muss.\nUm die Ressourcenanforderungen des Trackers zu minimieren, ist dieses Protokoll so konzipiert, dass der Tracker keine Zuordnungen von Client-Hashes zu Verbindungs-IDs für eine spätere Validierung speichern muss. Dies ist möglich, weil das Announce-Anfragepaket ein beantwortbares Datagram3-Paket ist, sodass es den Hash des Absenders enthält.\nEine empfohlene Implementierung ist:\nDefiniere die aktuelle Epoche als die aktuelle Zeit mit einer Auflösung entsprechend der Verbindungslebensdauer, epoch = now / lifetime. Definiere eine kryptografische Hashfunktion H(secret, clienthash, epoch), die eine 8-Byte-Ausgabe erzeugt. Erzeuge den zufälligen, konstanten Geheimwert, der für alle Verbindungen verwendet wird. Für Verbindungsantworten generiere connection_id = H(secret, clienthash, epoch) Für Announce-Anfragen validiere die empfangene Verbindungs-ID in der aktuellen Epoche, indem du überprüfst connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1) Bereitstellungsstatus Dieses Protokoll wurde am 24. Juni 2025 verabschiedet und ist seit September 2025 im I2P-Netzwerk vollständig in Betrieb.\nAktuelle Implementierungen i2psnark: Umfassende UDP-Tracker-Unterstützung ist in I2P Version 2.10.0 (API 0.9.67), veröffentlicht am 8. September 2025, enthalten. Alle I2P-Installationen ab dieser Version enthalten standardmäßig die UDP-Tracker-Funktionalität.\nzzzot tracker: Version 0.20.0-beta2 und neuer unterstützen UDP-Announce-Anfragen. Stand Oktober 2025 sind die folgenden Tracker im Produktivbetrieb aktiv: - opentracker.dg2.i2p - opentracker.simp.i2p - opentracker.skank.i2p\nHinweise zur Client-Kompatibilität SAM v3.3-Einschränkungen: Externe BitTorrent-Clients, die SAM (Simple Anonymous Messaging, einfache anonyme Nachrichtenübermittlung) verwenden, benötigen SAM v3.3-Unterstützung für Datagram2/3. Dies ist in Java I2P verfügbar, wird jedoch von i2pd (der C++-I2P-Implementierung) derzeit nicht unterstützt, was den Einsatz in libtorrent-basierten Clients wie qBittorrent einschränken könnte.\nI2CP-Clients: Clients, die I2CP direkt verwenden (z. B. BiglyBT), können UDP-Tracker-Unterstützung ohne SAM-Einschränkungen implementieren.\nReferenzen [BEP15]: BitTorrent-UDP-Tracker-Protokoll [BEP41]: Erweiterungen des UDP-Tracker-Protokolls [DATAGRAMS]: Spezifikation zu I2P-Datagrammen [Prop160]: Vorschlag für UDP-Tracker [Prop163]: Vorschlag für Datagram2 [SPEC]: BitTorrent über I2P ","description":"Protokollspezifikation für UDP-basierte BitTorrent-Tracker-Announces (Anfragen) in I2P","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"UDP-BitTorrent-Announce-Anfragen","url":"/de/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":" Historischer Hinweis: Diese Seite bewahrt die ältere Diskussion über „Unidirectional Tunnels“ als Referenz. Für das aktuelle Verhalten siehe die aktive tunnel-Implementierungsdokumentation .\nÜberblick I2P baut unidirektionale tunnel: Ein tunnel transportiert ausgehenden Verkehr und ein separater tunnel transportiert eingehende Antworten. Diese Struktur geht auf die frühesten Netzwerkentwürfe zurück und ist weiterhin ein zentrales Unterscheidungsmerkmal gegenüber bidirektionalen Circuit-Systemen wie Tor. Begriffe und Implementierungsdetails finden sich in der tunnel-Übersicht und der tunnel-Spezifikation .\nÜberprüfung Unidirektionale tunnel halten Anfrage- und Antwortverkehr getrennt, sodass jede einzelne Gruppe absprechender Peers nur die Hälfte einer gesamten Hin- und Rückkommunikation beobachtet. Timing-Angriffe müssen sich über zwei tunnel-Pools (ausgehend und eingehend) erstrecken, statt eine einzelne Verbindung zu analysieren, was Korrelationen erschwert. Unabhängige eingehende und ausgehende Pools ermöglichen es routers, Latenz, Kapazität und Eigenschaften der Fehlerbehandlung je Richtung anzupassen. Zu den Nachteilen zählen eine erhöhte Komplexität beim Peer-Management und die Notwendigkeit, mehrere tunnel-Sets zu pflegen, um eine zuverlässige Dienstbereitstellung zu gewährleisten. Anonymität Hermann und Grothoffs Aufsatz, I2P is Slow… and What to Do About It , analysiert Vorgängerangriffe gegen unidirektionale tunnels und legt nahe, dass entschlossene Angreifer langfristige Peers schließlich bestätigen können. Rückmeldungen aus der Community weisen darauf hin, dass die Studie auf spezifischen Annahmen über die Geduld und die rechtlichen Befugnisse von Angreifern beruht und den Ansatz nicht gegen Timing-Angriffe abwägt, die bidirektionale Designs betreffen. Fortgesetzte Forschung und praktische Erfahrungen bestärken weiterhin, dass unidirektionale tunnels eine bewusste Anonymitätsentscheidung und kein Versehen sind.\n","description":"Historische Zusammenfassung des unidirektionalen tunnel-Designs von I2P.","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"Unidirektionale Tunnels","url":"/de/docs/legacy/unidirectional/"},{"categories":null,"content":" Status: Dies ist eine prägnante Referenz für das v3dgsend-Dienstprogramm. Es ergänzt die Dokumentation zur Datagram API und SAM v3 .\nÜbersicht v3dgsend ist ein Befehlszeilen-Hilfswerkzeug zum Senden von I2P-Datagrammen über das SAMv3-Interface. Es ist nützlich zum Testen der Datagramm-Zustellung, zum Prototyping von Diensten und zur Überprüfung des End-to-End-Verhaltens, ohne einen vollständigen Client schreiben zu müssen.\nTypische Anwendungsfälle sind:\nSmoke-Testing der Datagramm-Erreichbarkeit zu einem Destination Validierung der Firewall- und Adressbuch-Konfiguration Experimentieren mit rohen vs. signierten (beantwortbaren) Datagrammen Verwendung Die grundlegende Aufrufweise variiert je nach Plattform und Paketierung. Gängige Optionen sind:\nDestination: base64 Destination oder .i2p-Name Protocol: raw (PROTOCOL 18) oder signed (PROTOCOL 17) Payload: Inline-String oder Dateieingabe Beziehen Sie sich auf die Paketierung Ihrer Distribution oder die --help-Ausgabe für die exakten Flags.\nSiehe auch Datagram API SAM v3 Streaming Library (Alternative zu Datagrams) ","description":"CLI-Dienstprogramm zum Senden von I2P-Datagrammen über SAM v3","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/de/docs/api/v3dgsend/"},{"categories":null,"content":"Überblick Dieses Dokument spezifiziert die Blindung, Verschlüsselung und Entschlüsselung des verschlüsselten LeaseSet2 (LS2). Verschlüsselte LeaseSets ermöglichen die zugriffskontrollierte Veröffentlichung von Informationen über versteckte Dienste in der I2P-Netzwerkdatenbank.\nZentrale Merkmale: - Tägliche Schlüsselrotation zur Gewährleistung von Vorwärtsgeheimnis - Zweistufige Client-Autorisierung (DH-basiert (Diffie-Hellman) und PSK-basiert (Pre-Shared Key, vorab geteilter Schlüssel)) - ChaCha20-Verschlüsselung für hohe Leistung auf Geräten ohne AES-Hardware - Red25519-Signaturen mit Schlüsselverblindung - Datenschutzfreundliche Client-Mitgliedschaft\nVerwandte Dokumentation: - Spezifikation gemeinsamer Strukturen - Verschlüsselte LeaseSet-Struktur - Vorschlag 123: Neue netDB-Einträge - Hintergrund zu verschlüsselten LeaseSets - Dokumentation der Netzwerkdatenbank - NetDB-Nutzung\nVersionsverlauf und Implementierungsstatus Zeitleiste der Protokollentwicklung Wichtiger Hinweis zur Versionsnummerierung: I2P verwendet zwei separate Schemata zur Versionsnummerierung: - API/Router Version: 0.9.x-Serie (wird in technischen Spezifikationen verwendet) - Produkt-Release-Version: 2.x.x-Serie (wird für öffentliche Veröffentlichungen verwendet)\nTechnische Spezifikationen verweisen auf API-Versionen (z. B. 0.9.41), während Endbenutzer Produktversionen sehen (z. B. 2.10.0).\nMeilensteine der Implementierung Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility ### Aktueller Stand ✅ Protokollstatus: Stabil und unverändert seit Juni 2019 ✅ Java I2P: Vollständig implementiert ab Version 0.9.40+ ✅ i2pd (C++): Vollständig implementiert ab Version 2.58.0+ ✅ Interoperabilität: Vollständig zwischen den Implementierungen gewährleistet ✅ Netzwerk-Einsatz: Produktionsreif mit über 6 Jahren Betriebserfahrung Kryptografische Definitionen Notation und Konventionen || steht für Verkettung mod L steht für die Reduktion modulo der Ed25519-Ordnung Alle Byte-Arrays liegen in Netzwerk-Byte-Reihenfolge (big-endian) vor, sofern nicht anders angegeben Little-endian-Werte werden explizit vermerkt CSRNG(n) Kryptographisch sicherer Zufallszahlengenerator\nErzeugt n Byte kryptografisch sicherer Zufallsdaten, die sich zur Generierung von Schlüsselmaterial eignen.\nSicherheitsanforderungen: - Muss kryptografisch sicher sein (geeignet für die Schlüsselerzeugung) - Muss sicher sein, wenn benachbarte Byte-Sequenzen im Netzwerk offengelegt werden - Implementierungen sollten die Ausgabe aus potenziell nicht vertrauenswürdigen Quellen hashen\nReferenzen: - PRNG-Sicherheitsaspekte - Tor-Entwickler-Diskussion H(p, d) SHA-256-Hash mit Personalisierung\nDomänenseparierte Hashfunktion, die Folgendes entgegennimmt: - p: Personalisierungs-String (sorgt für Domänentrennung) - d: Zu hashende Daten\nImplementierung:\nH(p, d) := SHA-256(p || d) Verwendung: Bietet kryptografische Domänentrennung, um Kollisionsangriffe zwischen unterschiedlichen Protokollverwendungen von SHA-256 zu verhindern.\nStream: ChaCha20 Stromchiffre: ChaCha20 wie in RFC 7539 Abschnitt 2.4 spezifiziert\nParameter: - S_KEY_LEN = 32 (256-Bit-Schlüssel) - S_IV_LEN = 12 (96-Bit-Nonce (Einmalwert)) - Initialer Zähler: 1 (RFC 7539 erlaubt 0 oder 1; 1 für AEAD-Kontexte empfohlen)\nENCRYPT(k, iv, plaintext)\nVerschlüsselt den Klartext mit:\nk: 32-Byte-Chiffrierschlüssel iv: 12-Byte-Nonce (einmal verwendete Zufallszahl; MUSS für jeden Schlüssel eindeutig sein) Gibt ein Chiffrat in derselben Größe wie der Klartext zurück Sicherheitseigenschaft: Der gesamte Chiffretext muss ununterscheidbar von Zufallsdaten sein, wenn der Schlüssel geheim ist.\nENTSCHLÜSSELN(k, iv, ciphertext)\nEntschlüsselt das Chiffrat mithilfe von: - k: 32-Byte-Schlüssel - iv: 12-Byte-Nonce (Einmalwert) - Gibt Klartext zurück\nDesignbegründung: ChaCha20 gegenüber AES gewählt, weil: - 2.5-3x schneller als AES auf Geräten ohne Hardwarebeschleunigung - Implementierung in konstanter Zeit leichter zu erreichen - Vergleichbare Sicherheit und Geschwindigkeit, wenn AES-NI verfügbar ist\nReferenzen: - RFC 7539 - ChaCha20 und Poly1305 für IETF-Protokolle\nSignaturtyp: Red25519 Signaturschema: Red25519 (SigType 11) mit Schlüsselverblindung\nRed25519 basiert auf Ed25519-Signaturen über der Ed25519-Kurve, wobei SHA-512 zum Hashing verwendet wird, mit Unterstützung für Key Blinding (Schlüsselblindung), wie in ZCash RedDSA spezifiziert.\nFunktionen:\nDERIVE_PUBLIC(privkey) Gibt den öffentlichen Schlüssel zurück, der dem angegebenen privaten Schlüssel entspricht. - Verwendet die Standard-Ed25519-Skalarmultiplikation mit dem Basispunkt\nSIGN(privkey, m) Gibt eine Signatur der Nachricht m mit dem privaten Schlüssel privkey zurück.\nRed25519: Unterschiede beim Signieren gegenüber Ed25519: 1. Zufällige Nonce (ein einmalig verwendeter Wert): Verwendet 80 Bytes zusätzlicher Zufallsdaten\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) Dadurch wird jede Red25519-Signatur einzigartig, selbst bei gleicher Nachricht und gleichem Schlüssel.\nGenerierung privater Schlüssel: Red25519-Privatschlüssel werden aus Zufallszahlen erzeugt und mod L reduziert, anstatt den Bit-Clamping-Ansatz von Ed25519 (Bit-Beschneidung) zu verwenden. VERIFY(pubkey, m, sig) Überprüft die Signatur sig anhand des öffentlichen Schlüssels pubkey und der Nachricht m. - Gibt true zurück, wenn die Signatur gültig ist, andernfalls false - Die Verifizierung ist identisch mit Ed25519\nOperationen zur Schlüsselverblindung:\nGENERATE_ALPHA(data, secret) Erzeugt alpha für key blinding (Schlüsselverblindung). - data: Enthält typischerweise den öffentlichen Signierschlüssel und die Signaturtypen - secret: Optionales zusätzliches Geheimnis (Länge null, wenn nicht verwendet) - Ergebnis ist identisch verteilt wie Ed25519-Privatschlüssel (nach Mod-L-Reduktion)\nBLIND_PRIVKEY(privkey, alpha) Verblindet einen privaten Schlüssel unter Verwendung des Geheimnisses alpha. - Implementierung: blinded_privkey = (privkey + alpha) mod L - Verwendet Skalararithmetik im Feld\nBLIND_PUBKEY(pubkey, alpha) Verblindet einen öffentlichen Schlüssel mithilfe des geheimen Werts alpha. - Implementierung: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) - Verwendet Addition von Gruppenelementen (Punkten) auf der Kurve\nKritische Eigenschaft:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) Sicherheitsüberlegungen:\nAus der ZCash Protocol Specification Abschnitt 5.4.6.1: Aus Sicherheitsgründen muss alpha identisch verteilt sein wie die entblindeten privaten Schlüssel. Dies stellt sicher, dass \u0026ldquo;die Kombination aus einem re-randomisierten öffentlichen Schlüssel und Signatur(en), die unter diesem Schlüssel erzeugt wurden, den Schlüssel, von dem er re-randomisiert wurde, nicht offenlegt.\u0026rdquo;\nUnterstützte Signaturtypen: - Typ 7 (Ed25519): Unterstützt für bestehende Destinationen (Abwärtskompatibilität) - Typ 11 (Red25519): Empfohlen für neue Destinationen, die Verschlüsselung verwenden - Verblindete Schlüssel: Immer Typ 11 (Red25519) verwenden\nReferenzen: - ZCash-Protokollspezifikation - Abschnitt 5.4.6 RedDSA - I2P-Red25519-Spezifikation DH: X25519 Diffie-Hellman über elliptische Kurven: X25519\nPublic-Key-Verfahren zur Schlüsselvereinbarung auf Basis von Curve25519.\nParameter: - private Schlüssel: 32 Bytes - öffentliche Schlüssel: 32 Bytes - Ausgabe des gemeinsamen Geheimnisses: 32 Bytes\nFunktionen:\nGENERATE_PRIVATE() Erzeugt einen neuen 32-Byte-Privatschlüssel mithilfe eines CSRNG (kryptographisch sicherer Zufallszahlengenerator).\nDERIVE_PUBLIC(privkey) Leitet den 32-Byte großen öffentlichen Schlüssel aus dem gegebenen privaten Schlüssel ab. - Verwendet Skalarmultiplikation auf Curve25519\nDH(privkey, pubkey) Führt den Diffie-Hellman-Schlüsselaustausch durch. - privkey: Lokaler privater 32-Byte-Schlüssel - pubkey: Öffentlicher 32-Byte-Schlüssel der Gegenstelle - Gibt zurück: gemeinsames Geheimnis mit 32 Byte\nSicherheitseigenschaften: - Computational Diffie-Hellman-Annahme auf Curve25519 - Vorwärtsgeheimnis bei Verwendung ephemerer Schlüssel - Implementierung in konstanter Zeit erforderlich, um Timing-Angriffe zu verhindern\nReferenzen: - RFC 7748 - Elliptische Kurven für die Sicherheit\nHKDF (HMAC-basierte Schlüsselableitungsfunktion) HMAC-basierte Schlüsselableitungsfunktion\nExtrahiert und erweitert Schlüsselmaterial aus Eingabe-Schlüsselmaterial.\nParameter: - salt: maximal 32 Byte (typischerweise 32 Byte für SHA-256) - ikm: Input key material (Eingabe-Schlüsselmaterial; beliebige Länge, sollte gute Entropie haben) - info: Kontextspezifische Informationen (Domänentrennung) - n: Ausgabelänge in Byte\nImplementierung:\nVerwendet HKDF gemäß RFC 5869 mit: - Hashfunktion: SHA-256 - HMAC: gemäß RFC 2104 - Salzlänge: maximal 32 Byte (HashLen für SHA-256)\nVerwendungsmuster:\nkeys = HKDF(salt, ikm, info, n) Domänentrennung: Der Parameter info sorgt für kryptographische Domänentrennung zwischen den unterschiedlichen Verwendungen von HKDF im Protokoll.\nVerifizierte Informationswerte: - \u0026quot;ELS2_L1K\u0026quot; - Ebene 1 (äußere) Verschlüsselung - \u0026quot;ELS2_L2K\u0026quot; - Ebene 2 (innere) Verschlüsselung - \u0026quot;ELS2_XCA\u0026quot; - DH (Diffie-Hellman)-Client-Autorisierung - \u0026quot;ELS2PSKA\u0026quot; - PSK (Pre-Shared Key)-Client-Autorisierung - \u0026quot;i2pblinding1\u0026quot; - Alpha-Generierung\nReferenzen: - RFC 5869 - HKDF-Spezifikation (HMAC-basierte Schlüsselableitungsfunktion) - RFC 2104 - HMAC-Spezifikation (Hash-basierter Nachrichten-Authentifizierungscode)\nFormatspezifikation Verschlüsseltes LS2 (LeaseSet 2) besteht aus drei verschachtelten Schichten:\nSchicht 0 (Außen): Klartextinformationen zur Speicherung und zum Abruf Schicht 1 (Mitte): Client-Authentifizierungsdaten (verschlüsselt) Schicht 2 (Innen): Eigentliche LeaseSet2-Daten (verschlüsselt) Gesamtstruktur:\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature Wichtig: Verschlüsseltes LS2 (leaseSet 2, Version 2 des leaseSet-Formats) verwendet verblindete Schlüssel. Die Destination (I2P-Zieladresse) ist nicht im Header. Der DHT-Speicherort ist SHA-256(sig type || blinded public key) und wird täglich gewechselt.\nSchicht 0 (Außen) - Klartext Layer 0 verwendet NICHT den Standard-LS2-Header. Es hat ein eigenes Format, das für verblindete Schlüssel optimiert ist.\nStruktur:\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data **Flags-Feld (2 Bytes, Bits 15-0):** - **Bit 0:** Indikator für Offline-Schlüssel - `0` = Keine Offline-Schlüssel - `1` = Offline-Schlüssel vorhanden (temporäre Schlüsseldaten folgen) - **Bits 1-15:** Reserviert, müssen 0 sein für zukünftige Kompatibilität Flüchtige Schlüsseldaten (vorhanden, wenn Flag-Bit 0 = 1):\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key **Signaturprüfung:** - **Ohne Offline-Schlüssel:** Mit geblindetem öffentlichen Schlüssel verifizieren - **Mit Offline-Schlüsseln:** Mit temporärem öffentlichen Schlüssel verifizieren Die Signatur umfasst alle Daten von Type bis outerCiphertext (einschließlich).\nSchicht 1 (Mitte) - Client-Autorisierung Entschlüsselung: Siehe den Abschnitt Layer 1 Encryption .\nStruktur:\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) **Flags-Feld (1 Byte, Bits 7-0):** - **Bit 0:** Autorisierungsmodus - `0` = Keine Autorisierung pro Client (alle) - `1` = Autorisierung pro Client (Abschnitt zur Autorisierung folgt) - **Bits 3-1:** Authentifizierungsschema (nur wenn Bit 0 = 1) - `000` = DH-Clientauthentifizierung - `001` = PSK-Clientauthentifizierung - Übrige reserviert - **Bits 7-4:** Unbenutzt, muss 0 sein DH-Client-Autorisierungsdaten (Flags = 0x01, Bits 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **authClient Eintrag (40 Bytes):** - `clientID_i`: 8 Bytes - `clientCookie_i`: 32 Bytes (verschlüsseltes authCookie) PSK (vorab geteilter Schlüssel) Client-Autorisierungsdaten (Flags = 0x03, Bits 3-1 = 001):\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **authClient Eintrag (40 Bytes):** - `clientID_i`: 8 Bytes - `clientCookie_i`: 32 Bytes (verschlüsseltes authCookie) Schicht 2 (innen) - LeaseSet-Daten Entschlüsselung: Siehe Abschnitt Layer-2-Verschlüsselung .\nStruktur:\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 Die innere Schicht enthält die vollständige LeaseSet2-Struktur, einschließlich: - LS2 Header - Lease-Informationen (zeitlich befristeter Eintrag) - LS2 Signatur Verifizierungsanforderungen: Nach der Entschlüsselung müssen Implementierungen Folgendes verifizieren: 1. Innerer Zeitstempel entspricht dem äußeren veröffentlichten Zeitstempel 2. Innere Ablaufzeit entspricht der äußeren Ablaufzeit 3. LS2-Signatur ist gültig 4. Lease-Daten sind wohlgeformt\nReferenzen: - Spezifikation gemeinsamer Strukturen - Details zum LeaseSet2-Format\nAbleitung des Verblindungsschlüssels Übersicht I2P verwendet ein additives Schlüsselverblindungsverfahren auf Basis von Ed25519 und ZCash RedDSA. Verblindete Schlüssel werden täglich (UTC-Mitternacht) gewechselt, um Vorwärtsgeheimnis zu gewährleisten.\nBegründung des Designs:\nI2P hat sich ausdrücklich dagegen entschieden, den Ansatz aus Tors rend-spec-v3.txt Appendix A.2 zu verwenden. Gemäß der Spezifikation:\n\u0026ldquo;Wir verwenden Tors rend-spec-v3.txt Anhang A.2, der ähnliche Designziele verfolgt, nicht, da seine geblindeten öffentlichen Schlüssel außerhalb der Untergruppe von Primzahlordnung liegen könnten, mit unbekannten Sicherheitsimplikationen.\u0026rdquo;\nDie additive Verblindung von I2P gewährleistet, dass verblindete Schlüssel in der Untergruppe der Primzahlordnung der Ed25519-Kurve verbleiben.\nMathematische Definitionen Ed25519-Parameter: - B: Ed25519-Basispunkt (Generator) = 2^255 - 19 - L: Ed25519-Ordnung = 2^252 + 27742317777372353535851937790883648493\nWichtige Variablen: - A: unverblindeter 32-Byte öffentlicher Signaturschlüssel (in der Destination) - a: unverblindeter 32-Byte privater Signaturschlüssel - A': verblindeter 32-Byte öffentlicher Signaturschlüssel (verwendet im verschlüsselten LeaseSet) - a': verblindeter 32-Byte privater Signaturschlüssel - alpha: 32-Byte Verblindungsfaktor (geheim)\nHilfsfunktionen:\nLEOS2IP(x) \u0026ldquo;Little-Endian-Oktettfolge in Ganzzahl\u0026rdquo;\nKonvertiert ein Byte-Array im Little-Endian-Format in eine Ganzzahldarstellung.\nH*(x) \u0026ldquo;Hash und Reduktion\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L Dieselbe Operation wie bei der Ed25519-Schlüsselerzeugung.\nAlpha-Generation Tägliche Rotation: Ein neues alpha und verblindete Schlüssel MÜSSEN jeden Tag um Mitternacht UTC (00:00:00 UTC) generiert werden.\nGENERATE_ALPHA(destination, date, secret) Algorithmus:\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L Verifizierte Parameter: - Salt-Personalisierung: \u0026quot;I2PGenerateAlpha\u0026quot; - HKDF-Info: \u0026quot;i2pblinding1\u0026quot; - Ausgabe: 64 Bytes vor Reduktion - Alpha-Verteilung: Identisch verteilt wie private Ed25519-Schlüssel nach mod L\nVerblindung des privaten Schlüssels BLIND_PRIVKEY(a, alpha) Algorithmus:\nFür den Eigentümer der Destination (Zieladresse in I2P), der das verschlüsselte LeaseSet veröffentlicht:\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) Kritisch: Die mod L-Reduktion ist unerlässlich, um die korrekte algebraische Beziehung zwischen privaten und öffentlichen Schlüsseln aufrechtzuerhalten.\nVerblindung des öffentlichen Schlüssels BLIND_PUBKEY(A, alpha) Algorithmus:\nFür Clients, die das verschlüsselte LeaseSet abrufen und verifizieren:\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) Mathematische Äquivalenz:\nBeide Methoden liefern identische Ergebnisse:\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) Dies liegt daran:\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) Signieren mit verblindeten Schlüsseln Unverblindete LeaseSet-Signierung:\nDas entblindete LeaseSet (direkt an authentifizierte Clients gesendet) wird signiert mit: - Standard-Ed25519-Signatur (Typ 7) oder Red25519-Signatur (Typ 11) - Entblindeter Signier-Privatschlüssel - Verifiziert mit entblindetem öffentlichem Schlüssel\nMit Offline-Schlüsseln: - Signiert mit einem entblindeten temporären privaten Schlüssel - Verifiziert mit einem entblindeten temporären öffentlichen Schlüssel - Beide müssen vom Typ 7 oder 11 sein\nVerschlüsselte LeaseSet-Signierung:\nDer äußere Teil des verschlüsselten LeaseSet verwendet Red25519-Signaturen mit verblindeten Schlüsseln.\nRed25519-Signaturalgorithmus:\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total Wesentliche Unterschiede gegenüber Ed25519: 1. Verwendet 80 Byte zufällige Daten T (nicht den Hash des privaten Schlüssels) 2. Verwendet den Wert des öffentlichen Schlüssels direkt (nicht den Hash des privaten Schlüssels) 3. Jede Signatur ist einzigartig, selbst für dieselbe Nachricht und denselben Schlüssel\nVerifizierung:\nWie bei Ed25519:\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; Sicherheitsüberlegungen Alpha-Distribution:\nAus Sicherheitsgründen muss alpha dieselbe Verteilung aufweisen wie unverblindete private Schlüssel. Bei der Verblindung von Ed25519 (Typ 7) nach Red25519 (Typ 11) unterscheiden sich die Verteilungen leicht.\nEmpfehlung: Verwenden Sie Red25519 (Kryptokurve; Typ 11) sowohl für unverblindete als auch für verblindete Schlüssel, um die ZCash-Anforderungen zu erfüllen: \u0026ldquo;die Kombination aus einem neu randomisierten öffentlichen Schlüssel und Signatur(en) unter diesem Schlüssel gibt den Schlüssel nicht preis, aus dem dieser neu randomisiert wurde.\u0026rdquo;\nUnterstützung für Typ 7: Ed25519 wird für die Abwärtskompatibilität mit bestehenden Destinationen unterstützt, aber Typ 11 wird für neue verschlüsselte Destinationen empfohlen.\nVorteile der täglichen Rotation: - Vorwärtsgeheimnis: Das Kompromittieren des heutigen geblindeten Schlüssels gibt den gestrigen nicht preis - Nicht-Verknüpfbarkeit: Die tägliche Rotation verhindert Langzeitverfolgung über die DHT - Schlüsseltrennung: Unterschiedliche Schlüssel für unterschiedliche Zeiträume\nReferenzen: - ZCash Protocol Specification - Abschnitt 5.4.6.1 - Diskussion zur Tor-Schlüsselverblindung - Tor-Ticket #8106 Verschlüsselung und Verarbeitung Ableitung von Subcredentials (untergeordnete Berechtigungsnachweise) Vor der Verschlüsselung leiten wir einen Berechtigungsnachweis und einen Teilberechtigungsnachweis ab, um die verschlüsselten Schichten an die Kenntnis des öffentlichen Signaturschlüssels der Destination zu binden.\nZiel: Sicherstellen, dass nur diejenigen, die den öffentlichen Signaturschlüssel der Destination (I2P-Zieladresse) kennen, das verschlüsselte LeaseSet entschlüsseln können. Die vollständige Destination ist nicht erforderlich.\nBerechnung der Anmeldedaten A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes Domänentrennung: Die Personalisierungszeichenkette \u0026quot;credential\u0026quot; stellt sicher, dass dieser Hash nicht mit DHT-Lookup-Schlüsseln oder anderen Verwendungen im Protokoll kollidiert.\nBerechnung des Subcredentials (Teilberechtigungsnachweis) blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes Zweck: Die subcredential (untergeordneter Berechtigungsnachweis) bindet das verschlüsselte LeaseSet an: 1. die spezifische Destination (Zieladresse) (via credential) 2. den spezifischen verblindeten Schlüssel (via blindedPublicKey) 3. den spezifischen Tag (via tägliche Rotation von blindedPublicKey)\nDies verhindert Replay-Angriffe und tagesübergreifende Verknüpfungen.\nSchicht-1-Verschlüsselung Kontext: Ebene 1 enthält Client-Autorisierungsdaten und ist mit einem aus dem subcredential (untergeordnetes Berechtigungsmerkmal) abgeleiteten Schlüssel verschlüsselt.\nVerschlüsselungsalgorithmus # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) Ausgabe: outerCiphertext ist 32 + len(outerPlaintext) Bytes.\nSicherheitseigenschaften: - Salt stellt eindeutige Schlüssel/IV-Paare sicher, selbst bei demselben subcredential (untergeordneter Berechtigungsnachweis) - Der Kontext-String \u0026quot;ELS2_L1K\u0026quot; gewährleistet Domänentrennung - ChaCha20 bietet semantische Sicherheit (Chiffrat ist nicht von Zufallsdaten zu unterscheiden)\nEntschlüsselungsalgorithmus # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) Verifizierung: Nach der Entschlüsselung prüfen, ob die Struktur von Schicht 1 wohlgeformt ist, bevor mit Schicht 2 fortgefahren wird.\nSchicht-2-Verschlüsselung Kontext: Schicht 2 enthält die eigentlichen LeaseSet2-Daten und ist mit einem Schlüssel verschlüsselt, der entweder aus dem authCookie (falls clientbezogene Authentifizierung aktiviert ist) oder aus einer leeren Zeichenkette (falls nicht) abgeleitet wird.\nVerschlüsselungsalgorithmus # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) Ausgabe: innerCiphertext ist 32 + len(innerPlaintext) Bytes.\nSchlüsselbindung: - Wenn keine Client-Authentifizierung: Nur an subcredential (Unterberechtigungsnachweis) und Zeitstempel gebunden - Wenn Client-Authentifizierung aktiviert: Zusätzlich an authCookie gebunden (unterschiedlich für jeden autorisierten Client)\nEntschlüsselungsalgorithmus # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) Überprüfung: Nach der Entschlüsselung: 1. Überprüfen, dass das LS2-Typ-Byte gültig ist (3 oder 7) 2. LeaseSet2-Struktur parsen 3. Überprüfen, dass der innere Zeitstempel mit dem äußeren veröffentlichten Zeitstempel übereinstimmt 4. Überprüfen, dass die innere Ablaufzeit mit der äußeren Ablaufzeit übereinstimmt 5. LeaseSet2-Signatur überprüfen\nZusammenfassung der Verschlüsselungsschicht ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ Entschlüsselungsablauf: 1. Layer‑0‑Signatur mit verblindetem öffentlichen Schlüssel verifizieren 2. Layer 1 mithilfe von subcredential (Teilberechtigung) entschlüsseln 3. Autorisierungsdaten verarbeiten (falls vorhanden), um authCookie zu erhalten 4. Layer 2 mithilfe von authCookie und subcredential entschlüsseln 5. LeaseSet2 verifizieren und parsen\nClient-spezifische Autorisierung Übersicht Wenn die Autorisierung pro Client aktiviert ist, führt der Server eine Liste autorisierter Clients. Jeder Client verfügt über Schlüsselmaterial, das sicher Out-of-Band (außerhalb des regulären Kommunikationskanals) übermittelt werden muss.\nZwei Autorisierungsmechanismen: 1. DH (Diffie-Hellman) Client-Autorisierung: Sicherer, nutzt X25519 für die Schlüsselvereinbarung 2. PSK (Pre-Shared Key) Autorisierung: Einfacher, verwendet symmetrische Schlüssel\nAllgemeine Sicherheitseigenschaften: - Vertraulichkeit der Client-Mitgliedschaft: Beobachter sehen die Anzahl der Clients, können aber keine bestimmten Clients identifizieren - Anonyme Hinzufügung/Entfernung von Clients: Es ist nicht nachvollziehbar, wann bestimmte Clients hinzugefügt oder entfernt werden - Kollisionswahrscheinlichkeit eines 8-Byte-Client-Bezeichners: ~1 zu 18 Trillionen (vernachlässigbar)\nDH-Client-Autorisierung Übersicht: Jeder Client erzeugt ein X25519-Schlüsselpaar und übermittelt seinen öffentlichen Schlüssel über einen sicheren Out-of-Band-Kanal (separater Kommunikationsweg) an den Server. Der Server verwendet ephemeres Diffie-Hellman (DH), um für jeden Client ein eindeutiges authCookie zu verschlüsseln.\nClient-Schlüsselgenerierung # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) Sicherheitsvorteil: Der private Schlüssel des Clients verlässt dessen Gerät niemals. Ein Angreifer, der die Out-of-Band-Übertragung abfängt, kann künftige verschlüsselte LeaseSets nicht entschlüsseln, ohne X25519 DH zu brechen.\nServerseitige Verarbeitung # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Schicht-1-Datenstruktur:\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Server-Empfehlungen: - Für jedes veröffentlichte verschlüsselte LeaseSet ein neues ephemeres Schlüsselpaar erzeugen - Reihenfolge der Clients zufällig anordnen, um positionsbasierte Nachverfolgung zu verhindern - Das Hinzufügen von Dummy-Einträgen erwägen, um die tatsächliche Anzahl der Clients zu verbergen\nClient-Verarbeitung # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Client-Fehlerbehandlung: - Wenn clientID_i nicht gefunden wird: Zugriff des Clients wurde widerrufen oder war nie autorisiert - Wenn die Entschlüsselung fehlschlägt: Beschädigte Daten oder falsche Schlüssel (äußerst selten) - Clients sollten regelmäßig neu abrufen, um einen Widerruf zu erkennen\nClient-Autorisierung mit PSK (vorab gemeinsam genutzter Schlüssel) Übersicht: Jeder Client verfügt über einen vorab geteilten, 32-Byte langen symmetrischen Schlüssel. Der Server verschlüsselt dasselbe authCookie mit dem PSK (vorab geteilter Schlüssel) jedes Clients.\nSchlüsselgenerierung # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel Sicherheitshinweis: Derselbe PSK (vorab geteilter Schlüssel) kann falls gewünscht von mehreren Clients gemeinsam genutzt werden (erstellt eine \u0026ldquo;Gruppen\u0026rdquo;-Autorisierung).\nSerververarbeitung # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Datenstruktur der Schicht 1:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Client-Verarbeitung # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Vergleich und Empfehlungen Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access **Empfehlung:** - **Verwenden Sie DH-Autorisierung** (Diffie-Hellman-basierte Autorisierung) für Hochsicherheitsanwendungen, bei denen Vorwärtsgeheimnis wichtig ist - **Verwenden Sie PSK-Autorisierung** (Autorisierung mit vorab gemeinsamem Schlüssel) wenn die Leistung kritisch ist oder bei der Verwaltung von Client-Gruppen - **Niemals PSKs wiederverwenden** über verschiedene Dienste oder Zeiträume hinweg - **Verwenden Sie immer sichere Kanäle** für die Schlüsselverteilung (z. B. Signal, OTR, PGP) Sicherheitsüberlegungen Datenschutz der Client-Mitgliedschaft:\nBeide Mechanismen schützen die Zugehörigkeit von Clients auf folgende Weise: 1. Verschlüsselte Client-Kennungen: 8-Byte clientID, abgeleitet aus der HKDF-Ausgabe 2. Ununterscheidbare Cookies: Alle 32-Byte clientCookie-Werte erscheinen zufällig 3. Keine Client-spezifischen Metadaten: Keine Möglichkeit festzustellen, welcher Eintrag welchem Client zugeordnet ist\nEin Beobachter kann sehen: - Anzahl autorisierter Clients (aus dem Feld clients) - Änderungen der Client-Anzahl im Zeitverlauf\nEin Beobachter KANN NICHT sehen: - Welche konkreten Clients autorisiert sind - Wann bestimmte Clients hinzugefügt oder entfernt werden (wenn die Anzahl gleich bleibt) - Jegliche Informationen zur Identifizierung eines Clients\nEmpfehlungen zur Randomisierung:\nServer SOLLTEN die Reihenfolge der Clients jedes Mal zufällig anordnen, wenn sie ein verschlüsseltes LeaseSet erzeugen:\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order Vorteile: - Verhindert, dass Clients ihre Position in der Liste erfahren - Verhindert Inferenzangriffe auf Basis von Positionsänderungen - Macht das Hinzufügen/Widerruf von Clients ununterscheidbar\nVerbergen der Anzahl der Clients:\nServer dürfen zufällige Dummy-Einträge einfügen:\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) Kosten: Dummy-Einträge vergrößern die verschlüsselte LeaseSet-Größe (je 40 Bytes).\nRotation des AuthCookie (Authentifizierungs-Cookie):\nServer SOLLTEN ein neues authCookie erzeugen: - Jedes Mal, wenn ein verschlüsseltes LeaseSet veröffentlicht wird (typischerweise alle paar Stunden) - Unmittelbar nach dem Widerrufen eines Clients - Nach einem regelmäßigen Zeitplan (z. B. täglich), auch wenn es keine Änderungen bei den Clients gibt\nVorteile: - Begrenzt die Auswirkungen, falls authCookie kompromittiert wird - Stellt sicher, dass widerrufene Clients schnell den Zugriff verlieren - Bietet Vorwärtsgeheimnis für Layer 2\nBase32-Adressierung für verschlüsselte LeaseSets Übersicht Traditionelle I2P-base32-Adressen enthalten nur den Hash der Destination (Zieladresse) (32 Bytes → 52 Zeichen). Das ist für verschlüsselte LeaseSets nicht ausreichend, weil:\nClients benötigen den unverblindeten öffentlichen Schlüssel, um den verblindeten öffentlichen Schlüssel abzuleiten Clients benötigen die Signaturtypen (unverblindet und verblindet) für eine korrekte Schlüsselableitung Der Hash allein liefert diese Informationen nicht Lösung: Ein neues base32-Format, das den öffentlichen Schlüssel und die Signaturtypen enthält.\nSpezifikation des Adressformats Dekodierte Struktur (35 Bytes):\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ Erste 3 Bytes (XOR mit Prüfsumme):\nDie ersten 3 Bytes enthalten Metadaten, die mit Teilen einer CRC-32-Prüfsumme per XOR verknüpft sind:\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey Eigenschaften der Prüfsumme: - Verwendet das Standard-CRC-32-Polynom - Falsch-Negativ-Rate: ~1 in 16 Millionen - Bietet Fehlererkennung bei Adress-Tippfehlern - Kann nicht zur Authentifizierung verwendet werden (kryptografisch nicht sicher)\nKodiertes Format:\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; Merkmale: - Gesamtzahl der Zeichen: 56 (35 Bytes × 8 Bits ÷ 5 Bits pro Zeichen) - Suffix: \u0026ldquo;.b32.i2p\u0026rdquo; (wie bei herkömmlichem Base32) - Gesamtlänge: 56 + 8 = 64 Zeichen (ohne Nullterminator)\nBase32-Kodierung: - Alphabet: abcdefghijklmnopqrstuvwxyz234567 (Standard RFC 4648) - 5 ungenutzte Bits am Ende MÜSSEN 0 sein - Groß-/Kleinschreibung wird ignoriert (nach Konvention kleingeschrieben)\nAdressgenerierung import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address Adress-Parsing import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype Vergleich mit herkömmlichem Base32 Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations ### Nutzungsbeschränkungen BitTorrent-Inkompatibilität:\nVerschlüsselte LS2-Adressen (neues leaseSet-Format) KÖNNEN NICHT mit den kompakten Announce-Antworten von BitTorrent verwendet werden:\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ Problem: Das kompakte Format enthält nur den Hash (32 Bytes) und bietet keinen Platz für Signaturtypen oder Informationen zum öffentlichen Schlüssel.\nLösung: Verwenden Sie vollständige Announce-Antworten oder HTTP-basierte Tracker, die vollständigen Adressen unterstützen.\nAdressbuch-Integration Wenn ein Client die vollständige Destination (Zieladresse) in einem Adressbuch hat:\nVollständige Destination (Zieladresse) speichern (enthält öffentlichen Schlüssel) Rückwärtssuche anhand des Hashes unterstützen Wenn ein verschlüsseltes LS2 vorliegt, den öffentlichen Schlüssel aus dem Adressbuch abrufen Kein neues base32-Format erforderlich, wenn die vollständige Destination bereits bekannt ist Adressbuchformate, die verschlüsseltes LS2 unterstützen: - hosts.txt mit vollständigen destination-Zeichenketten (Zieladressen) - SQLite-Datenbanken mit destination-Spalte - JSON/XML-Formate mit vollständigen destination-Daten\nImplementierungsbeispiele Beispiel 1: Adresse erzeugen\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p Beispiel 2: Parsen und Validieren\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) Beispiel 3: Konvertieren aus einer Destination (I2P-Zieladresse)\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) Sicherheitsüberlegungen Privatsphäre: - Die Base32-Adresse offenbart den öffentlichen Schlüssel - Dies ist beabsichtigt und für das Protokoll erforderlich - Gibt den privaten Schlüssel NICHT preis und gefährdet die Sicherheit nicht - Öffentliche Schlüssel sind per Design öffentliche Informationen\nKollisionsresistenz: - CRC-32 bietet nur 32 Bit Kollisionsresistenz - Kryptografisch nicht sicher (nur zur Fehlererkennung verwenden) - Verlassen Sie sich NICHT auf die Prüfsumme zur Authentifizierung - Eine vollständige Verifizierung des Ziels ist weiterhin erforderlich\nAdressvalidierung: - Prüfsumme immer vor der Verwendung validieren - Adressen mit ungültigen Signaturtypen ablehnen - Überprüfen, dass der öffentliche Schlüssel auf der Kurve liegt (implementierungsspezifisch)\nReferenzen: - Vorschlag 149: B32 für verschlüsseltes LS2 - Spezifikation zur B32-Adressierung - I2P-Namensspezifikation Unterstützung für Offline-Schlüssel Übersicht Offline-Schlüssel ermöglichen, dass der Hauptsignaturschlüssel offline (Cold Storage) bleibt, während für den laufenden Betrieb ein temporärer Signaturschlüssel verwendet wird. Das ist für Dienste mit hohen Sicherheitsanforderungen entscheidend.\nSpezifische Anforderungen für verschlüsseltes LS2: - Temporäre Schlüssel müssen offline generiert werden - Verblindete private Schlüssel müssen vorab generiert werden (einer pro Tag) - Sowohl temporäre als auch verblindete Schlüssel werden in Chargen bereitgestellt - Noch kein standardisiertes Dateiformat definiert (TODO in der Spezifikation)\nAufbau des Offline-Schlüssels Flüchtige Layer-0-Schlüsseldaten (wenn Flag-Bit 0 = 1):\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ Umfang der Signatur: Die Signatur im Offline-Schlüsselblock umfasst: - Ablaufzeitstempel (4 Byte) - Temporärer Signaturtyp (2 Byte) - Temporärer öffentlicher Signierschlüssel (variabel)\nDiese Signatur wird mithilfe des verblindeten öffentlichen Schlüssels verifiziert, was beweist, dass die Entität mit dem verblindeten privaten Schlüssel diesen temporären Schlüssel autorisiert hat.\nProzess der Schlüsselgenerierung Für ein verschlüsseltes LeaseSet mit Offline-Schlüsseln:\nTemporäre Schlüsselpaare erzeugen (offline, in Kaltlagerung):\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\nFür jeden Tag for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026quot;%Y%m%d\u0026quot;) # \u0026quot;YYYYMMDD\u0026quot; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) 3. **Sign transient keys with blinded keys** (offline): ```python for date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router: Für jedes Datum delivery_package[date] = { 'transient_privkey': keys[date][0], 'transient_pubkey': keys[date][1], 'blinded_privkey': blinded_keys[date][0], 'blinded_pubkey': blinded_keys[date][1], 'offline_sig_block': offline_sig_blocks[date] }\n### Router Usage **Daily Key Loading:** ```python # Um Mitternacht UTC (oder vor der Veröffentlichung) date = datetime.utcnow().date() # Schlüssel für heute laden today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # Verwenden Sie diese Schlüssel für das heutige verschlüsselte LeaseSet Publishing Process:\n# 1. Inneres LeaseSet2 erstellen inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. Schicht 2 verschlüsseln layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. Schicht 1 mit Autorisierungsdaten erstellen layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. Schicht 1 verschlüsseln layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. Layer 0 mit Offline-Signaturblock erstellen layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ) # 6. Signiere Schicht 0 mit einem temporären privaten Schlüssel signature = RED25519_SIGN(transient_privkey, layer0) # 7. Signatur anhängen und veröffentlichen encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# Generiere täglich sowohl neue temporäre als auch neue verblindete Schlüssel for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - Bündel verschlüsselten Schlüsselmaterials - Abgedeckter Datumsbereich OFFLINE_KEY_STATUS - Anzahl verbleibender Tage - Datum des nächsten Schlüsselablaufs REVOKE_OFFLINE_KEYS - Zeitraum für den Widerruf - Neue Ersatzschlüssel (optional) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p Key Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# Verschlüsseltes LeaseSet aktivieren i2cp.encryptLeaseSet=true # Optional: Client-Autorisierung aktivieren i2cp.enableAccessList=true # Optional: DH authorization (Diffie-Hellman-Autorisierung) verwenden (Standard ist PSK) i2cp.accessListType=0 # Optional: Blinding secret (Verblindungsgeheimnis; dringend empfohlen) i2cp.blindingSecret=your-secret-here API Usage Example:\n// Erzeuge einen verschlüsselten LeaseSet EncryptedLeaseSet els = new EncryptedLeaseSet(); // Ziel festlegen els.setDestination(destination); // Enable per-client authorization els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // Autorisierte Clients (DH-öffentliche Schlüssel) hinzufügen for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // Blinding-Parameter (Verblindung) festlegen els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // Signieren und veröffentlichen els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd Key Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Verschlüsseltes LeaseSet aktivieren encryptleaseset = true # Optional: Typ der Client-Autorisierung (0=DH, 1=PSK) authtype = 0 # Optional: Blinding secret (Geheimnis für Verblindung) secret = your-secret-here # Optional: Autorisierte Clients (einer pro Zeile, Base64-kodierte öffentliche Schlüssel) client.1 = base64-encoded-client-pubkey-1 client.2 = base64-encoded-client-pubkey-2 API Usage Example:\n// Verschlüsseltes LeaseSet erstellen auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // Clientbezogene Autorisierung aktivieren encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // Autorisierte Clients hinzufügen for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // Signieren und veröffentlichen encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# Testvektor 1: Schlüsselverblindung destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # Erwartet: (mit der Referenzimplementierung überprüfen) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets Red25519 Specification - Detailed Red25519 implementation B32 Addressing Specification - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # Ed25519-Basispunkt (Erzeugerpunkt) B = 2**255 - 19 # Ed25519-Ordnung (Größe des Skalarfeldes) L = 2**252 + 27742317777372353535851937790883648493 # Werte der Signaturtypen SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # Schlüssellängen PRIVKEY_SIZE = 32 # Bytes PUBKEY_SIZE = 32 # Bytes SIGNATURE_SIZE = 64 # Bytes ChaCha20 Constants # ChaCha20-Parameter CHACHA20_KEY_SIZE = 32 # Bytes (256 Bit) CHACHA20_NONCE_SIZE = 12 # Bytes (96 Bit) CHACHA20_INITIAL_COUNTER = 1 # RFC 7539 erlaubt 0 oder 1 HKDF Constants # HKDF-Parameter (HMAC-basierte Schlüsselableitungsfunktion) HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # bytes (HashLen) # HKDF-Info-Strings (Domänentrennung) HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # SHA-256-Personalisierungs-Strings HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # Größen von Layer 0 (außen) BLINDED_SIGTYPE_SIZE = 2 # Bytes BLINDED_PUBKEY_SIZE = 32 # Bytes (für Red25519) PUBLISHED_TS_SIZE = 4 # Bytes EXPIRES_SIZE = 2 # Bytes FLAGS_SIZE = 2 # Bytes LEN_OUTER_CIPHER_SIZE = 2 # Bytes SIGNATURE_SIZE = 64 # Bytes (Red25519) # Größen der Offline-Schlüsselblöcke OFFLINE_EXPIRES_SIZE = 4 # Bytes OFFLINE_SIGTYPE_SIZE = 2 # Bytes OFFLINE_SIGNATURE_SIZE = 64 # Bytes # Größen der Schicht 1 (Mitte) AUTH_FLAGS_SIZE = 1 # Byte EPHEMERAL_PUBKEY_SIZE = 32 # Bytes (DH-Authentifizierung) AUTH_SALT_SIZE = 32 # Bytes (PSK-Authentifizierung) NUM_CLIENTS_SIZE = 2 # Bytes CLIENT_ID_SIZE = 8 # Bytes CLIENT_COOKIE_SIZE = 32 # Bytes AUTH_CLIENT_ENTRY_SIZE = 40 # Bytes (CLIENT_ID + CLIENT_COOKIE) # Verschlüsselungs-Overhead SALT_SIZE = 32 # Bytes (am Anfang jeder verschlüsselten Schicht eingefügt) # Base32-Adresse B32_ENCRYPTED_DECODED_SIZE = 35 # Bytes B32_ENCRYPTED_ENCODED_LEN = 56 # Zeichen B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# Öffentlicher Schlüssel der Destination (I2P-Zieladresse) (Ed25519) A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # Leeres Geheimnis Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 Bytes salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) mod L Expected Output:\n(Mit der Referenzimplementierung abgleichen) alpha = [64-Byte-Hexadezimalwert] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nciphertext = [gegen die Testvektoren aus RFC 7539 überprüfen] Test Vector 3: HKDF Input:\nsalt = bytes(32) # Nur Nullen ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [44-Byte-Hexwert] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32 bytes unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\naddress = [56 Base32-Zeichen].b32.i2p # Überprüfen, dass die Prüfsumme korrekt validiert wird Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"Zugangskontrolliertes LeaseSet-Format für private Destinations (Zielkennungen im I2P‑Netz)","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"Verschlüsseltes LeaseSet","url":"/de/docs/specs/encryptedleaseset/"},{"categories":null,"content":"1. Überblick Einträge in clients.config teilen dem Router mit, welche Anwendungen beim Start gestartet werden sollen. Jeder Eintrag kann als managed Client (bevorzugt) oder als unmanaged Client ausgeführt werden. Managed Clients arbeiten mit dem ClientAppManager zusammen, welcher:\nInstanziiert die Anwendung und verfolgt den Lebenszyklusstatus für die Router-Konsole Stellt dem Benutzer Start-/Stopp-Steuerelemente zur Verfügung und erzwingt saubere Herunterfahrvorgänge beim Router-Exit Hostet eine schlanke Client-Registry und einen Port-Mapper, damit Anwendungen die Dienste der anderen erkennen können Unmanaged Clients rufen einfach eine main()-Methode auf; verwenden Sie sie nur für Legacy-Code, der nicht modernisiert werden kann.\n2. Implementierung eines Managed Client Managed Clients müssen entweder net.i2p.app.ClientApp (für benutzerorientierte Anwendungen) oder net.i2p.router.app.RouterApp (für Router-Erweiterungen) implementieren. Stellen Sie einen der unten aufgeführten Konstruktoren bereit, damit der Manager Kontext- und Konfigurationsargumente übergeben kann:\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) Das args-Array enthält die in clients.config oder in einzelnen Dateien in clients.config.d/ konfigurierten Werte. Erweitern Sie nach Möglichkeit die Hilfsklassen ClientApp / RouterApp, um die Standard-Lebenszyklus-Verkabelung zu erben.\n2.1 Lifecycle Methods Verwaltete Clients müssen Folgendes implementieren:\nstartup() - Initialisierung durchführen und umgehend zurückkehren. Muss mindestens einmal manager.notify() aufrufen, um vom INITIALIZED-Zustand zu wechseln. shutdown(String[] args) - Ressourcen freigeben und Hintergrund-Threads stoppen. Muss mindestens einmal manager.notify() aufrufen, um den Zustand auf STOPPING oder STOPPED zu ändern. getState() - der Konsole mitteilen, ob die Anwendung läuft, startet, stoppt oder fehlgeschlagen ist Der Manager ruft diese Methoden auf, wenn Benutzer mit der Konsole interagieren.\n2.2 Advantages Genaue Statusberichte in der Router-Konsole Saubere Neustarts ohne Leaking von Threads oder statischen Referenzen Geringerer Speicher-Footprint nach dem Stoppen der Anwendung Zentralisiertes Logging und Fehlerberichterstattung über den injizierten Kontext 3. Unmanaged Clients (Fallback Mode) Wenn die konfigurierte Klasse kein Managed Interface implementiert, startet der Router sie durch Aufruf von main(String[] args) und kann den resultierenden Prozess nicht verfolgen. Die Konsole zeigt begrenzte Informationen an und Shutdown-Hooks werden möglicherweise nicht ausgeführt. Reservieren Sie diesen Modus für Skripte oder einmalige Dienstprogramme, die die Managed APIs nicht nutzen können.\n4. Client Registry Verwaltete und nicht verwaltete Clients können sich beim Manager registrieren, damit andere Komponenten eine Referenz über den Namen abrufen können:\nmanager.register(this); Die Registrierung verwendet den Rückgabewert von getName() des Clients als Registry-Schlüssel. Bekannte Registrierungen umfassen console, i2ptunnel, Jetty, outproxy und update. Rufen Sie einen Client mit ClientAppManager.getRegisteredApp(String name) ab, um Funktionen zu koordinieren (zum Beispiel die Konsole, die Jetty nach Statusdetails abfragt).\nBeachten Sie, dass Client-Registry und Port-Mapper separate Systeme sind. Die Client-Registry ermöglicht die Inter-Applikations-Kommunikation durch Namensauflösung, während der Port-Mapper Dienstnamen auf Host:Port-Kombinationen für Service Discovery abbildet.\n3. Unverwaltete Clients (Fallback-Modus) Der Port-Mapper bietet ein einfaches Verzeichnis für interne TCP-Dienste. Registrieren Sie Loopback-Ports, damit Mitarbeiter fest codierte Adressen vermeiden:\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); Oder mit expliziter Host-Angabe:\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); Suchen Sie Dienste mit PortMapper.getPort(String name) (gibt -1 zurück, falls nicht gefunden) oder getPort(String name, int defaultPort) (gibt Standardwert zurück, falls nicht gefunden). Prüfen Sie den Registrierungsstatus mit isRegistered(String name) und rufen Sie den registrierten Host mit getActualHost(String name) ab.\nAllgemeine Port-Mapper-Service-Konstanten aus net.i2p.util.PortMapper:\nSVC_CONSOLE - Router-Konsole (Standardport 7657) SVC_HTTP_PROXY - HTTP-Proxy (Standardport 4444) SVC_HTTPS_PROXY - HTTPS-Proxy (Standardport 4445) SVC_I2PTUNNEL - I2PTunnel-Manager SVC_SAM - SAM-Bridge (Standardport 7656) SVC_SAM_SSL - SAM-Bridge SSL SVC_SAM_UDP - SAM UDP SVC_BOB - BOB-Bridge (Standardport 2827) SVC_EEPSITE - Standard-eepsite (Standardport 7658) SVC_HTTPS_EEPSITE - HTTPS-eepsite SVC_IRC - IRC-Tunnel (Standardport 6668) SVC_SUSIDNS - SusiDNS Hinweis: httpclient, httpsclient und httpbidirclient sind i2ptunnel-Tunneltypen (verwendet in der tunnel.N.type-Konfiguration), keine Port-Mapper-Servicekonstanten.\n4. Client-Registry 2.1 Lifecycle-Methoden Ab Version 0.9.42 unterstützt der Router die Aufteilung der Konfiguration in einzelne Dateien innerhalb des Verzeichnisses clients.config.d/. Jede Datei enthält Eigenschaften für einen einzelnen Client, wobei alle Eigenschaften mit clientApp.0. beginnen:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true Dies ist der empfohlene Ansatz für Neuinstallationen und Plugins.\n2.2 Vorteile Aus Gründen der Abwärtskompatibilität verwendet das traditionelle Format eine fortlaufende Nummerierung:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties Erforderlich: - main - Vollständiger Klassenname, der ClientApp oder RouterApp implementiert, oder eine statische main(String[] args)-Methode enthält\nOptional: - name - Anzeigename für die Router-Konsole (Standard ist der Klassenname) - args - Durch Leerzeichen oder Tabulator getrennte Argumente (unterstützt Zeichenketten in Anführungszeichen) - delay - Sekunden vor dem Start (Standard 120) - onBoot - Erzwingt delay=0, falls true - startOnLoad - Aktiviert/deaktiviert den Client (Standard true)\nPlugin-spezifisch: - stopargs - Argumente, die beim Herunterfahren übergeben werden - uninstallargs - Argumente, die bei der Plugin-Deinstallation übergeben werden - classpath - Kommagetrennte zusätzliche Classpath-Einträge\nVariablenersetzung für Plugins: - $I2P - I2P-Basisverzeichnis - $CONFIG - Benutzerkonfigurationsverzeichnis (z.B. ~/.i2p) - $PLUGIN - Plugin-Verzeichnis - $OS - Betriebssystemname - $ARCH - Architekturname\n5. Port Mapper Bevorzugen Sie verwaltete Clients; greifen Sie nur dann auf nicht verwaltete zurück, wenn es absolut notwendig ist. Halten Sie Initialisierung und Herunterfahren schlank, damit Konsolenoperationen reaktionsfähig bleiben. Verwenden Sie beschreibende Registry- und Port-Namen, damit Diagnosetools (und Endbenutzer) verstehen, was ein Dienst tut. Vermeiden Sie statische Singletons - verlassen Sie sich auf den injizierten Kontext und Manager, um Ressourcen zu teilen. Rufen Sie manager.notify() bei allen Zustandsübergängen auf, um einen genauen Konsolenstatus aufrechtzuerhalten. Wenn Sie in einer separaten JVM ausgeführt werden müssen, dokumentieren Sie, wie Logs und Diagnosen der Hauptkonsole zugänglich gemacht werden. Erwägen Sie für externe Programme die Verwendung von ShellService (hinzugefügt in Version 1.7.0), um die Vorteile verwalteter Clients zu nutzen. 6. Konfigurationsformat Verwaltete Clients wurden in Version 0.9.4 (17. Dezember 2012) eingeführt und bleiben die empfohlene Architektur bis zur Version 2.10.0 (9. September 2025). Die Kern-APIs sind über diesen Zeitraum hinweg stabil geblieben, ohne dass es zu Breaking Changes gekommen ist:\nKonstruktor-Signaturen unverändert Lifecycle-Methoden (startup, shutdown, getState) unverändert ClientAppManager-Registrierungsmethoden unverändert PortMapper-Registrierungs- und Lookup-Methoden unverändert Bemerkenswerte Verbesserungen: - 0.9.42 (2019) - clients.config.d/ Verzeichnisstruktur für einzelne Konfigurationsdateien - 1.7.0 (2021) - ShellService hinzugefügt zur Zustandsverfolgung externer Programme - 2.10.0 (2025) - Aktuelle Version ohne Änderungen an der managed client API\nDas nächste Major-Release wird Java 17+ als Minimum voraussetzen (Infrastrukturanforderung, keine API-Änderung).\nReferences clients.config-Spezifikation Spezifikation der Konfigurationsdatei I2P Technische Dokumentation - Übersicht ClientAppManager Javadoc (API 0.9.66) PortMapper Javadoc (API 0.9.66) ClientApp-Schnittstelle (API 0.9.66) RouterApp-Schnittstelle (API 0.9.66) Alternative Javadoc (stabil) Alternative Javadoc (Clearnet-Spiegel) Hinweis: Das I2P-Netzwerk hostet eine umfassende Dokumentation unter http://idk.i 2p/javadoc-i2p/, für deren Zugriff ein I2P-Router erforderlich ist. Für Clearnet-Zugriff verwenden Sie den oben genannten GitHub Pages Mirror.\n","description":"Wie router-verwaltete Anwendungen mit dem ClientAppManager und dem Port-Mapper integrieren","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"Verwaltete Clients","url":"/de/docs/applications/managed-clients/"},{"categories":null,"content":"Diese Anleitung zeigt, wie man gängige Browser so konfiguriert, dass sie Datenverkehr über den integrierten HTTP-Proxy von I2P senden. Sie behandelt Safari, Firefox und Chrome/Chromium-Browser mit detaillierten Schritt-für-Schritt-Anleitungen.\nWichtige Hinweise:\nDer Standard-HTTP-Proxy von I2P lauscht auf 127.0.0.1:4444. I2P schützt den Datenverkehr innerhalb des I2P-Netzwerks (.i2p-Seiten). Stellen Sie sicher, dass Ihr I2P-router läuft, bevor Sie Ihren Browser konfigurieren. Safari (macOS) Safari verwendet die systemweiten Proxy-Einstellungen unter macOS.\nStep 1: Open Network Settings Öffne Safari und gehe zu Safari → Einstellungen (oder Preferences) Klicke auf den Tab Erweitert Im Abschnitt Proxys klicke auf Einstellungen ändern\u0026hellip; Dadurch werden die Netzwerkeinstellungen deines Mac geöffnet.\nSchritt 1: Netzwerkeinstellungen öffnen Aktivieren Sie in den Netzwerkeinstellungen das Kontrollkästchen für Web Proxy (HTTP) Geben Sie Folgendes ein: Web Proxy Server: 127.0.0.1 Port: 4444 Klicken Sie auf OK, um Ihre Einstellungen zu speichern Sie können jetzt .i2p-Seiten in Safari durchsuchen!\nHinweis: Diese Proxy-Einstellungen wirken sich auf alle Anwendungen aus, die die macOS-Systemproxys verwenden. Erwägen Sie, ein separates Benutzerkonto zu erstellen oder einen anderen Browser exklusiv für I2P zu verwenden, wenn Sie das I2P-Browsing isolieren möchten.\nFirefox (Desktop) Firefox hat eigene Proxy-Einstellungen unabhängig vom System, was es ideal für dediziertes I2P-Browsing macht.\nSchritt 2: HTTP-Proxy konfigurieren Klicken Sie auf die Menüschaltfläche (☰) oben rechts Wählen Sie Einstellungen Step 2: Find Proxy Settings Geben Sie im Suchfeld der Einstellungen \u0026ldquo;proxy\u0026rdquo; ein Scrollen Sie zu Netzwerkeinstellungen Klicken Sie auf die Schaltfläche Einstellungen\u0026hellip; Schritt 1: Einstellungen öffnen Wählen Sie Manuelle Proxy-Konfiguration Geben Sie Folgendes ein: HTTP-Proxy: 127.0.0.1 Port: 4444 Lassen Sie SOCKS-Host leer (außer Sie benötigen ausdrücklich einen SOCKS-Proxy) Aktivieren Sie DNS über Proxy auflösen (bei Verwendung von SOCKS) nur bei Verwendung eines SOCKS-Proxys Klicken Sie auf OK, um zu speichern Sie können nun .i2p-Sites in Firefox durchsuchen!\nTipp: Erwägen Sie die Erstellung eines separaten Firefox-Profils, das ausschließlich für das I2P-Browsing verwendet wird. Dies hält Ihr I2P-Browsing von Ihrem regulären Browsing getrennt. Um ein Profil zu erstellen, geben Sie about:profiles in die Firefox-Adressleiste ein.\nChrome / Chromium (Desktop) Chrome und Chromium-basierte Browser (Brave, Edge, etc.) verwenden unter Windows und macOS in der Regel die System-Proxy-Einstellungen. Diese Anleitung zeigt die Windows-Konfiguration.\nSchritt 2: Proxy-Einstellungen finden Klicken Sie auf das Dreipunkt-Menü (⋮) oben rechts Wählen Sie Einstellungen Schritt 3: Manuellen Proxy konfigurieren Geben Sie im Suchfeld der Einstellungen \u0026ldquo;proxy\u0026rdquo; ein Klicken Sie auf Proxy-Einstellungen Ihres Computers öffnen Step 3: Open Manual Proxy Setup Dies öffnet die Windows Netzwerk- \u0026amp; Interneteinstellungen.\nScrolle nach unten zu Manuelle Proxy-Einrichtung Klicke auf Einrichten Schritt 1: Chrome-Einstellungen öffnen Schalten Sie Proxyserver verwenden auf Ein Geben Sie Folgendes ein: Proxy-IP-Adresse: 127.0.0.1 Port: 4444 Optional können Sie Ausnahmen unter \u0026ldquo;Proxyserver nicht für Adressen verwenden, die beginnen mit\u0026rdquo; hinzufügen (z. B. localhost;127.*) Klicken Sie auf Speichern Sie können jetzt .i2p-Seiten in Chrome durchsuchen!\nHinweis: Diese Einstellungen wirken sich auf alle Chromium-basierten Browser und einige andere Anwendungen unter Windows aus. Um dies zu vermeiden, sollten Sie stattdessen Firefox mit einem dedizierten I2P-Profil verwenden.\nSchritt 2: Proxy-Einstellungen öffnen Unter Linux können Sie Chrome/Chromium mit Proxy-Flags starten, um Änderungen an den Systemeinstellungen zu vermeiden:\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; Oder erstellen Sie ein Desktop-Starter-Skript:\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; Das --user-data-dir-Flag erstellt ein separates Chrome-Profil für das I2P-Browsing.\nFirefox (Desktop) Moderne \u0026ldquo;Fenix\u0026rdquo; Firefox-Builds beschränken about:config und Erweiterungen standardmäßig. IceRaven ist ein Firefox-Fork, der eine kuratierte Auswahl an Erweiterungen aktiviert und die Proxy-Einrichtung vereinfacht.\nErweiterungsbasierte Konfiguration (IceRaven):\nWenn Sie IceRaven bereits verwenden, sollten Sie zunächst den Browserverlauf löschen (Menü → Verlauf → Verlauf löschen). 2) Öffnen Sie Menü → Add‑Ons → Add‑Ons-Manager. 3) Installieren Sie die Erweiterung „I2P Proxy for Android and Other Systems\u0026quot;. 4) Der Browser wird nun über I2P als Proxy kommunizieren. Diese Erweiterung funktioniert auch auf Pre-Fenix Firefox-basierten Browsern, wenn sie von AMO installiert wird.\nDie Aktivierung der erweiterten Extension-Unterstützung in Firefox Nightly erfordert einen separaten Prozess, der von Mozilla dokumentiert wurde .\nInternet Explorer / Windows System Proxy Unter Windows gilt der System-Proxy-Dialog für den IE und kann von Chromium-basierten Browsern verwendet werden, wenn diese die Systemeinstellungen übernehmen.\nÖffne „Netzwerk- und Interneteinstellungen\u0026quot; → „Proxy\u0026quot;. 2) Aktiviere „Proxyserver für LAN verwenden\u0026quot;. 3) Setze die Adresse 127.0.0.1, Port 4444 für HTTP. 4) Optional aktiviere „Proxyserver für lokale Adressen umgehen\u0026quot;. ","description":"Konfigurieren Sie gängige Browser zur Verwendung der HTTP/HTTPS-Proxys von I2P auf Desktop und Android","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"Web-Browser-Konfiguration","url":"/de/docs/guides/browser-config/"},{"categories":null,"content":"Zugriffsfilter ermöglichen I2PTunnel-Serverbetreibern, eingehende Verbindungen basierend auf der Quell-Destination (Zieladresse) und der zuletzt beobachteten Verbindungsrate zu erlauben, zu verweigern oder zu drosseln. Der Filter ist eine einfache Textdatei mit Regeln. Die Datei wird von oben nach unten gelesen und die erste passende Regel gewinnt.\nÄnderungen an der Filterdefinition werden beim tunnel-Neustart wirksam. Einige Builds lesen dateibasierte Listen möglicherweise zur Laufzeit erneut ein, aber planen Sie einen Neustart ein, um zu gewährleisten, dass die Änderungen angewendet werden.\nDateiformat Eine Regel pro Zeile. Leere Zeilen werden ignoriert. # beginnt einen Kommentar, der bis zum Ende der Zeile reicht. Regeln werden der Reihe nach ausgewertet; die erste Übereinstimmung wird verwendet. Schwellenwerte Ein Schwellenwert legt fest, wie viele Verbindungsversuche von einer einzelnen Destination (Zieladresse) innerhalb eines gleitenden Zeitfensters zulässig sind.\nNumerisch: N/S bedeutet, N Verbindungen pro S Sekunden zu erlauben. Beispiel: 15/5 erlaubt bis zu 15 Verbindungen alle 5 Sekunden. Der N+1-te Versuch innerhalb des Zeitfensters wird abgelehnt. Schlüsselwörter: allow bedeutet keine Beschränkung. deny bedeutet immer ablehnen. Regelsyntax Regeln haben folgende Form:\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; Wobei:\n\u0026lt;threshold\u0026gt; ist N/S, allow oder deny \u0026lt;scope\u0026gt; ist eines von default, explicit, file oder record (siehe unten) \u0026lt;target\u0026gt; hängt vom Geltungsbereich ab Standardregel Gilt, wenn keine andere Regel zutrifft. Es ist nur eine Standardregel zulässig. Wenn weggelassen, sind unbekannte Destinations (Zieladressen) uneingeschränkt zulässig.\n15/5 default allow default deny default Explizite Regel Adressiert eine bestimmte Destination (Zieladresse) über die Base32-Adresse (z. B. example1.b32.i2p) oder den vollständigen Schlüssel.\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p Dateibasierte Regel Zielt auf alle Destinations (Zieladressen) ab, die in einer externen Datei aufgelistet sind. Jede Zeile enthält eine Destination; #-Kommentare und Leerzeilen sind zulässig.\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt Betriebshinweis: Einige Implementierungen lesen Dateilisten periodisch erneut ein. Wenn Sie eine Liste bearbeiten, während der tunnel läuft, rechnen Sie mit einer kurzen Verzögerung, bis die Änderungen erkannt werden. Starten Sie neu, um die Änderungen sofort anzuwenden.\nRekorder (progressive Steuerung) Ein Recorder überwacht Verbindungsversuche und schreibt Destinations (I2P-Zieladressen), die einen Schwellenwert überschreiten, in eine Datei. Diese Datei können Sie dann in einer file-Regel referenzieren, um bei zukünftigen Versuchen Drosselungen oder Sperren anzuwenden.\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt Überprüfen Sie die Recorder-Unterstützung in Ihrem Build, bevor Sie sich darauf verlassen. Verwenden Sie file-Listen für garantiertes Verhalten.\nAuswertungsreihenfolge Spezifische Regeln zuerst, dann allgemeine. Ein gängiges Muster:\nExplizite Zulassungen für vertrauenswürdige Peers Explizite Sperren für bekannte Missbraucher Dateibasierte Allow-/Deny-Listen Recorder (Aufzeichner) für progressive Drosselung Standardregel als Auffangregel Vollständiges Beispiel # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt Implementierungshinweise Der Zugriffsfilter arbeitet auf der tunnel-Ebene, vor der Anwendungs verarbeitung, sodass missbräuchlicher Datenverkehr frühzeitig abgewiesen werden kann. Platzieren Sie die Filterdatei in Ihrem I2PTunnel-Konfigurationsverzeichnis und starten Sie den tunnel neu, um die Änderungen zu übernehmen. Teilen Sie dateibasierte Listen über mehrere tunnels hinweg, wenn Sie eine einheitliche Richtlinie für alle Dienste wünschen. ","description":"Syntax für Zugriffskontroll-Filterdateien für tunnel","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"Zugriffsfilter-Format","url":"/de/docs/specs/filter-format/"}]
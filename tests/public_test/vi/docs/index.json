[{"categories":null,"content":"Tổng quan Các địa chỉ Base 32 tiêu chuẩn (\u0026ldquo;b32\u0026rdquo;) chứa giá trị băm của đích (destination). Điều này sẽ không hoạt động đối với LS2 được mã hóa (proposal 123).\nChúng ta không thể dùng một địa chỉ base 32 truyền thống cho một LS2 được mã hóa (đề xuất 123), vì nó chỉ chứa băm của đích (Destination). Nó không cung cấp khóa công khai không mù hóa. Ứng dụng khách phải biết khóa công khai của đích, kiểu chữ ký, kiểu chữ ký mù hóa, và một bí mật tùy chọn hoặc khóa riêng để lấy và giải mã leaseSet. Do đó, chỉ một địa chỉ base 32 là không đủ. Ứng dụng khách cần hoặc đích đầy đủ (trong đó chứa khóa công khai), hoặc chỉ riêng khóa công khai. Nếu ứng dụng khách có đích đầy đủ trong sổ địa chỉ và sổ địa chỉ hỗ trợ tra cứu ngược theo băm, thì khóa công khai có thể được truy xuất.\nĐịnh dạng này đặt khóa công khai vào địa chỉ base32 thay cho giá trị băm. Định dạng này cũng phải chứa kiểu chữ ký của khóa công khai, và kiểu chữ ký của lược đồ làm mù.\nTài liệu này đặc tả một định dạng b32 cho các địa chỉ này. Mặc dù trong quá trình thảo luận, chúng tôi đã gọi định dạng mới này là địa chỉ \u0026ldquo;b33\u0026rdquo;, nhưng trên thực tế, định dạng mới vẫn giữ hậu tố \u0026ldquo;.b32.i2p\u0026rdquo; như thường lệ.\nTình trạng triển khai Đề xuất 123 (Các mục netDB mới) đã được triển khai đầy đủ trong phiên bản 0.9.43 (Tháng 10 năm 2019). Bộ tính năng LS2 (LeaseSet 2) được mã hóa đã duy trì ổn định đến phiên bản 2.10.0 (Tháng 9 năm 2025), không có thay đổi phá vỡ tính tương thích đối với định dạng địa chỉ hoặc các đặc tả mật mã.\nCác mốc triển khai quan trọng: - 0.9.38: Hỗ trợ Floodfill cho LS2 tiêu chuẩn với các khóa ngoại tuyến - 0.9.39: Kiểu chữ ký RedDSA loại 11 và mã hóa/giải mã cơ bản - 0.9.40: Hỗ trợ định địa chỉ B32 đầy đủ (Đề xuất 149) - 0.9.41: Xác thực theo từng máy khách dựa trên X25519 - 0.9.42: Tất cả các tính năng blinding (kỹ thuật làm mù trong mật mã học) đã hoạt động - 0.9.43: Tuyên bố triển khai hoàn chỉnh (Tháng 10 năm 2019)\nThiết kế Định dạng mới chứa unblinded public key (khóa công khai không làm mù), unblinded signature type (kiểu chữ ký không làm mù), và blinded signature type (kiểu chữ ký làm mù). Tùy chọn cho biết các yêu cầu về bí mật và/hoặc khóa riêng cho các liên kết riêng tư. Sử dụng hậu tố \u0026ldquo;.b32.i2p\u0026rdquo; hiện có, nhưng với độ dài lớn hơn. Bao gồm checksum để phát hiện lỗi. Địa chỉ cho leasesets được mã hóa được nhận diện bởi 56 ký tự được mã hóa trở lên (35 byte được giải mã trở lên), so với 52 ký tự (32 byte) đối với các địa chỉ base 32 truyền thống. Đặc tả Tạo và mã hóa Tạo một tên máy chủ dạng {56+ ký tự}.b32.i2p (35+ ký tự ở dạng nhị phân) như sau:\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype Hậu xử lý và checksum (tổng kiểm):\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; Bất kỳ bit chưa sử dụng nào ở cuối b32 phải bằng 0. Đối với một địa chỉ tiêu chuẩn 56 ký tự (35 byte), không có bit chưa sử dụng.\nGiải mã và Xác minh strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key Độ dài (tính bằng bit) của khóa bí mật và khóa riêng Các bit khóa bí mật và khóa riêng được dùng để cho client, proxy, hoặc mã phía client khác biết rằng cần có khóa bí mật và/hoặc khóa riêng để giải mã leaseset. Một số triển khai cụ thể có thể nhắc người dùng cung cấp dữ liệu cần thiết, hoặc từ chối các lần thử kết nối nếu thiếu dữ liệu cần thiết.\nCác bit này chỉ dùng làm chỉ báo. Khóa bí mật hoặc khóa riêng tư tuyệt đối không được đưa vào chính địa chỉ B32, vì như vậy sẽ làm suy giảm tính bảo mật.\nChi tiết mật mã học Lược đồ làm mù Lược đồ làm mù sử dụng RedDSA dựa trên Ed25519 và thiết kế của ZCash, tạo ra các chữ ký Red25519 trên đường cong Ed25519 sử dụng SHA-512. Cách tiếp cận này đảm bảo các khóa công khai đã làm mù vẫn thuộc nhóm con có cấp nguyên tố của đường cong, tránh được các lo ngại về bảo mật tồn tại trong một số thiết kế thay thế.\nCác Blinded keys (khóa đã làm mù) được luân chuyển hằng ngày dựa trên ngày UTC theo công thức:\nblinded_key = BLIND(unblinded_key, date, optional_secret) Vị trí lưu trữ trong DHT (bảng băm phân tán) được tính như sau:\nSHA256(type_byte || blinded_public_key) Mã hóa leaseSet được mã hóa sử dụng mật mã dòng ChaCha20 cho việc mã hóa, được lựa chọn vì hiệu năng vượt trội trên các thiết bị không có tăng tốc phần cứng AES. Đặc tả sử dụng HKDF (Hàm phái sinh khóa dựa trên HMAC) để phái sinh khóa và X25519 (thuật toán ECDH trên Curve25519) cho các hoạt động Diffie-Hellman (trao đổi khóa Diffie-Hellman).\nCác leaseSet được mã hóa có cấu trúc ba lớp: - Lớp ngoài: siêu dữ liệu bản rõ - Lớp giữa: xác thực máy khách (các phương thức DH hoặc PSK) - Lớp trong: phần dữ liệu LS2 chính với thông tin lease\nCác phương thức xác thực Xác thực theo từng client (máy khách) hỗ trợ hai phương thức:\nXác thực DH: Sử dụng thỏa thuận khóa X25519. Mỗi máy khách được ủy quyền sẽ cung cấp khóa công khai của mình cho máy chủ, và máy chủ mã hóa lớp giữa bằng một bí mật chung được dẫn xuất từ ECDH.\nPSK Authentication (xác thực bằng khóa chia sẻ trước): Sử dụng trực tiếp khóa chia sẻ trước để mã hóa.\nBit cờ thứ 2 trong địa chỉ B32 cho biết liệu xác thực theo từng client có bắt buộc hay không.\nBộ nhớ đệm Dù vượt ngoài phạm vi của đặc tả này, các routers và clients phải ghi nhớ và lưu vào bộ nhớ đệm (khuyến nghị lưu bền) ánh xạ từ khóa công khai tới destination (định danh đích trong I2P), và ngược lại.\nBlockfile naming service (dịch vụ đặt tên dạng blockfile), hệ thống sổ địa chỉ mặc định của I2P từ phiên bản 0.9.8, duy trì nhiều sổ địa chỉ cùng với một bảng ánh xạ tra ngược chuyên dụng, cung cấp khả năng tra cứu nhanh theo giá trị băm (hash). Tính năng này rất quan trọng để phân giải leaseSet được mã hóa khi ban đầu chỉ biết mỗi giá trị băm.\nCác loại chữ ký Tính đến phiên bản I2P 2.10.0, các kiểu chữ ký từ 0 đến 11 đã được định nghĩa. Mã hóa một byte vẫn là tiêu chuẩn; mã hóa hai byte có sẵn nhưng trên thực tế không được sử dụng.\nCác loại thường dùng: - Loại 0 (DSA_SHA1): Không còn được khuyến nghị cho router, vẫn được hỗ trợ cho các destination (đích trong I2P) - Loại 7 (EdDSA_SHA512_Ed25519): Tiêu chuẩn hiện tại cho danh tính router và các đích - Loại 11 (RedDSA_SHA512_Ed25519): Chỉ dùng cho các leaseSet LS2 được mã hóa có hỗ trợ blinding (kỹ thuật làm mù trong mật mã)\nLưu ý quan trọng: Chỉ Ed25519 (type 7) và Red25519 (type 11) hỗ trợ blinding (kỹ thuật làm mù trong mật mã) cần thiết cho các leasesets được mã hóa. Các loại chữ ký khác không thể được sử dụng với tính năng này.\nCác loại 9-10 (GOST algorithms (thuật toán mật mã GOST)) vẫn được dành trước nhưng chưa được triển khai. Các loại 4-6 và 8 được đánh dấu \u0026ldquo;offline only\u0026rdquo; cho các khóa ký ngoại tuyến.\nGhi chú Phân biệt biến thể cũ và mới theo độ dài. Địa chỉ b32 cũ luôn là {52 chars}.b32.i2p. Địa chỉ mới là {56+ chars}.b32.i2p Mã hóa base32 tuân theo tiêu chuẩn RFC 4648, giải mã không phân biệt hoa/thường và ưu tiên đầu ra chữ thường Địa chỉ có thể vượt quá 200 ký tự khi dùng các kiểu chữ ký có khóa công khai lớn hơn (ví dụ: ECDSA P521 với khóa 132 byte) Định dạng mới có thể được dùng trong jump links (liên kết tra cứu) (và được phục vụ bởi jump servers (máy chủ jump)) nếu muốn, tương tự như b32 tiêu chuẩn Blinded keys (khóa làm mù) luân phiên hằng ngày theo ngày UTC để tăng cường quyền riêng tư Định dạng này khác với cách tiếp cận ở phụ lục A.2 của Tor trong tệp rend-spec-v3.txt, có thể kéo theo các hệ quả bảo mật tiềm ẩn khi dùng off-curve blinded public keys (khóa công khai bị làm mù nằm ngoài đường cong) Tương thích phiên bản Đặc tả này áp dụng cho I2P từ phiên bản 0.9.47 (tháng 8 năm 2020) đến phiên bản 2.10.0 (tháng 9 năm 2025). Không có thay đổi không tương thích ngược đối với định dạng địa chỉ B32, cấu trúc LS2 (LeaseSet phiên bản 2) được mã hóa, hoặc các triển khai mật mã học trong giai đoạn này. Tất cả các địa chỉ được tạo bằng 0.9.47 vẫn hoàn toàn tương thích với các phiên bản hiện tại.\nTài liệu tham khảo CRC-32 - CRC-32 (Wikipedia) - RFC 3309: Tổng kiểm (checksum) của Giao thức Truyền tải Điều khiển Luồng Các đặc tả I2P - Đặc tả LeaseSet được mã hóa - Đề xuất 123: Mục nhập netDB mới - Đề xuất 149: B32 cho LS2 được mã hóa - Đặc tả cấu trúc chung - Đặt tên và Sổ địa chỉ So sánh Tor - Chuỗi thảo luận Tor (bối cảnh thiết kế) Tài nguyên bổ sung - I2P Project - Diễn đàn I2P - Tài liệu Java API ","description":"Định dạng địa chỉ Base 32 cho leasesets LS2 được mã hóa","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"B32 cho các leaseSet mã hóa","url":"/vi/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":"Tổng quan BitTorrent qua I2P cho phép chia sẻ tập tin ẩn danh thông qua các tunnel mã hóa sử dụng lớp streaming của I2P. Tất cả các peer được xác định bằng các destination I2P mã hóa thay vì địa chỉ IP. Hệ thống hỗ trợ tracker HTTP và UDP, liên kết magnet kết hợp, và mã hóa kết hợp post-quantum.\n1. Ngăn xếp giao thức Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP Tất cả các kết nối đều chạy qua lớp truyền tải được mã hóa của I2P (NTCP2 hoặc SSU2). Ngay cả các gói tin UDP tracker cũng được đóng gói trong I2P streaming. 2. Tracker Trackers HTTP Các tracker .i2p tiêu chuẩn phản hồi các yêu cầu HTTP GET như:\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 Các phản hồi được bencode hóa và sử dụng các hash đích I2P cho các peer.\nUDP Tracker Các UDP tracker đã được chuẩn hóa vào năm 2025 (Đề xuất 160).\nTrackers UDP Chính - udp://tracker2.postman.i2p/announce - udp://opentracker.simp.i2p/a - http://opentracker.skank.i2p/a - http://opentracker.dg2.i2p/a \u0026mdash;\n3. Liên kết Magnet magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name Liên kết magnet hỗ trợ swarm kết hợp giữa I2P và clearnet khi được cấu hình. 4. Triển khai DHT Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported --- 5. Các triển khai Client I2PSnark Đi kèm với tất cả các router Chỉ hỗ trợ tracker HTTP Tracker tích hợp sẵn tại http://127.0.0.1:7658/ Không hỗ trợ tracker UDP BiglyBT Đầy đủ tính năng với plugin I2P Hỗ trợ tracker HTTP + UDP Hỗ trợ torrent hybrid Sử dụng giao diện SAM v3.3 Tixati / XD Các client nhẹ Tunneling dựa trên SAM Mã hóa lai thử nghiệm ML-KEM 6. Cấu hình I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. Mô hình Bảo mật Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) Torrent hybrid (clearnet + I2P) chỉ nên được sử dụng nếu tính ẩn danh không quan trọng. 8. Hiệu suất Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal Tốc độ thông thường dao động từ **30–80 KB/s**, tùy thuộc vào các peer và điều kiện mạng. 9. Các Vấn Đề Đã Biết Khả năng tương tác DHT một phần giữa Java I2P và i2pd Độ trễ tải metadata magnet khi tải nặng NTCP1 đã lỗi thời nhưng vẫn được sử dụng bởi các peer cũ UDP mô phỏng qua streaming làm tăng độ trễ 10. Lộ trình Tương lai Ghép kênh kiểu QUIC Tích hợp ML-KEM đầy đủ Logic swarm hybrid thống nhất Cải thiện reseed mirrors Thử lại DHT thích ứng Tài liệu tham khảo BEP 15 – UDP Tracker Protocol Đề xuất 160 – UDP Tracker trên I2P Tài liệu I2PSnark Đặc tả thư viện Streaming ","description":"Đặc tả chi tiết và tổng quan hệ sinh thái cho BitTorrent trong mạng I2P","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"BitTorrent qua I2P","url":"/vi/docs/applications/bittorrent/"},{"categories":null,"content":" Cảnh báo: BOB chỉ hỗ trợ kiểu chữ ký DSA-SHA1 cũ. Java I2P đã ngừng phát hành kèm BOB từ 1.7.0 (2022-02); nó chỉ còn trên các cài đặt được khởi tạo từ 1.6.1 hoặc cũ hơn và trên một số bản dựng i2pd. Các ứng dụng mới bắt buộc phải dùng SAM v3 .\nRàng buộc ngôn ngữ Go – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp Ghi chú về giao thức KEYS biểu thị một destination (địa chỉ đích trong I2P) dạng base64 (khóa công khai + khóa riêng tư). KEY là một khóa công khai dạng base64. Phản hồi ERROR có dạng ERROR \u0026lt;description\u0026gt;\\n. OK cho biết lệnh đã hoàn tất; dữ liệu tùy chọn theo sau trên cùng một dòng. Các dòng DATA truyền thêm đầu ra trước OK cuối cùng. Lệnh help là ngoại lệ duy nhất: nó có thể không trả về gì để báo hiệu “không có lệnh như vậy”.\nBiểu ngữ kết nối BOB sử dụng các dòng ASCII kết thúc bằng ký tự newline (LF hoặc CRLF). Khi kết nối, nó gửi ra:\nBOB \u0026lt;version\u0026gt; OK Phiên bản hiện tại: 00.00.10. Các bản dựng trước đây sử dụng các chữ số thập lục phân viết hoa và cách đánh số không theo chuẩn.\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds ## Các lệnh cốt lõi Để xem đầy đủ chi tiết về các lệnh, hãy kết nối bằng telnet localhost 2827 và chạy help.\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK Tóm tắt ngừng hỗ trợ BOB (giao thức cầu nối ứng dụng cũ của I2P) không hỗ trợ các kiểu chữ ký hiện đại, LeaseSets (bộ mô tả đích trong I2P) được mã hóa, hoặc các tính năng truyền tải. API hiện đang đóng băng; sẽ không bổ sung lệnh mới nào. Các ứng dụng vẫn còn phụ thuộc vào BOB nên chuyển sang SAM v3 (giao thức API máy khách của I2P) càng sớm càng tốt. ","description":"API đã lỗi thời để quản lý điểm đến (đã lỗi thời)","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – Basic Open Bridge (Cầu mở cơ bản)","url":"/vi/docs/legacy/bob/"},{"categories":null,"content":"1. Tổng quan Các mục trong clients.config chỉ định cho router những ứng dụng nào sẽ được khởi chạy khi khởi động. Mỗi mục có thể chạy dưới dạng client được quản lý (managed) (được khuyến nghị) hoặc client không được quản lý (unmanaged). Các managed client phối hợp với ClientAppManager, công cụ này:\nKhởi tạo ứng dụng và theo dõi trạng thái vòng đời của router console Cung cấp các điều khiển start/stop cho người dùng và đảm bảo tắt sạch khi thoát router Lưu trữ một client registry nhẹ và port mapper để các ứng dụng có thể khám phá dịch vụ của nhau Client không được quản lý chỉ đơn giản gọi một phương thức main(); chỉ sử dụng chúng cho mã nguồn cũ không thể được hiện đại hóa.\n2. Triển khai Managed Client Các managed client phải implement net.i2p.app.ClientApp (cho các ứng dụng hướng người dùng) hoặc net.i2p.router.app.RouterApp (cho các phần mở rộng của router). Cung cấp một trong các constructor bên dưới để manager có thể truyền các tham số context và configuration:\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) Mảng args chứa các giá trị được cấu hình trong clients.config hoặc các tệp riêng lẻ trong clients.config.d/. Mở rộng các lớp trợ giúp ClientApp / RouterApp khi có thể để kế thừa các kết nối vòng đời mặc định.\n2.1 Lifecycle Methods Các client được quản lý được kỳ vọng triển khai:\nstartup() - thực hiện khởi tạo và trả về nhanh chóng. Phải gọi manager.notify() ít nhất một lần để chuyển từ trạng thái INITIALIZED. shutdown(String[] args) - giải phóng tài nguyên và dừng các luồng chạy nền. Phải gọi manager.notify() ít nhất một lần để thay đổi trạng thái sang STOPPING hoặc STOPPED. getState() - thông báo cho console biết ứng dụng đang chạy, đang khởi động, đang dừng, hay đã thất bại Trình quản lý gọi các phương thức này khi người dùng tương tác với console.\n2.2 Advantages Báo cáo trạng thái chính xác trong bảng điều khiển router Khởi động lại sạch sẽ mà không rò rỉ luồng (thread) hoặc tham chiếu tĩnh Dung lượng bộ nhớ thấp hơn sau khi ứng dụng dừng Tập trung ghi nhật ký và báo cáo lỗi thông qua ngữ cảnh được tiêm vào 3. Unmanaged Clients (Fallback Mode) Nếu class được cấu hình không implement một interface được quản lý, router sẽ khởi chạy nó bằng cách gọi main(String[] args) và không thể theo dõi process kết quả. Console hiển thị thông tin hạn chế và shutdown hooks có thể không chạy. Dành chế độ này cho các script hoặc tiện ích sử dụng một lần không thể áp dụng các API được quản lý.\n4. Client Registry Các client được quản lý và không được quản lý có thể tự đăng ký với manager để các thành phần khác có thể truy xuất tham chiếu theo tên:\nmanager.register(this); Việc đăng ký sử dụng giá trị trả về từ getName() của client làm khóa registry. Các đăng ký đã biết bao gồm console, i2ptunnel, Jetty, outproxy, và update. Truy xuất một client bằng ClientAppManager.getRegisteredApp(String name) để phối hợp các tính năng (ví dụ, console truy vấn Jetty để lấy chi tiết trạng thái).\nLưu ý rằng client registry và port mapper là hai hệ thống riêng biệt. Client registry cho phép giao tiếp giữa các ứng dụng thông qua tra cứu tên, trong khi port mapper ánh xạ tên dịch vụ tới các tổ hợp host:port để khám phá dịch vụ.\n3. Clients Không Quản Lý (Chế Độ Dự Phòng) Port mapper cung cấp một thư mục đơn giản cho các dịch vụ TCP nội bộ. Đăng ký các cổng loopback để người cộng tác tránh các địa chỉ được mã hóa cứng:\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); Hoặc với chỉ định host tường minh:\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); Tra cứu dịch vụ bằng PortMapper.getPort(String name) (trả về -1 nếu không tìm thấy) hoặc getPort(String name, int defaultPort) (trả về giá trị mặc định nếu không tìm thấy). Kiểm tra trạng thái đăng ký với isRegistered(String name) và lấy host đã đăng ký bằng getActualHost(String name).\nCác hằng số dịch vụ port mapper phổ biến từ net.i2p.util.PortMapper:\nSVC_CONSOLE - Bảng điều khiển router (cổng mặc định 7657) SVC_HTTP_PROXY - HTTP proxy (cổng mặc định 4444) SVC_HTTPS_PROXY - HTTPS proxy (cổng mặc định 4445) SVC_I2PTUNNEL - Trình quản lý I2PTunnel SVC_SAM - Cầu nối SAM (cổng mặc định 7656) SVC_SAM_SSL - Cầu nối SAM SSL SVC_SAM_UDP - SAM UDP SVC_BOB - Cầu nối BOB (cổng mặc định 2827) SVC_EEPSITE - Eepsite tiêu chuẩn (cổng mặc định 7658) SVC_HTTPS_EEPSITE - HTTPS eepsite SVC_IRC - Tunnel IRC (cổng mặc định 6668) SVC_SUSIDNS - SusiDNS Lưu ý: httpclient, httpsclient, và httpbidirclient là các loại tunnel của i2ptunnel (được sử dụng trong cấu hình tunnel.N.type), không phải hằng số dịch vụ port mapper.\n4. Registry Client 2.1 Các Phương Thức Vòng Đời Từ phiên bản 0.9.42, router hỗ trợ tách cấu hình thành các file riêng lẻ trong thư mục clients.config.d/. Mỗi file chứa các thuộc tính cho một client duy nhất với tất cả thuộc tính có tiền tố clientApp.0.:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true Đây là phương pháp được khuyến nghị cho các cài đặt và plugin mới.\n2.2 Ưu điểm Để tương thích ngược, định dạng truyền thống sử dụng đánh số tuần tự:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties Bắt buộc: - main - Tên đầy đủ của class triển khai ClientApp hoặc RouterApp, hoặc chứa method static main(String[] args)\nTùy chọn: - name - Tên hiển thị cho router console (mặc định là tên class) - args - Các tham số phân cách bằng dấu cách hoặc tab (hỗ trợ chuỗi trong dấu ngoặc kép) - delay - Số giây trước khi khởi động (mặc định 120) - onBoot - Buộc delay=0 nếu là true - startOnLoad - Bật/tắt client (mặc định true)\nDành riêng cho plugin: - stopargs - Tham số được truyền trong quá trình tắt - uninstallargs - Tham số được truyền trong quá trình gỡ cài đặt plugin - classpath - Các mục classpath bổ sung được phân tách bằng dấu phẩy\nThay thế biến cho plugin: - $I2P - Thư mục gốc I2P - $CONFIG - Thư mục cấu hình người dùng (ví dụ: ~/.i2p) - $PLUGIN - Thư mục plugin - $OS - Tên hệ điều hành - $ARCH - Tên kiến trúc\n5. Port Mapper Ưu tiên sử dụng managed client; chỉ quay lại unmanaged client khi thực sự cần thiết. Giữ cho quá trình khởi tạo và tắt máy nhẹ nhàng để các thao tác console vẫn phản hồi nhanh. Sử dụng tên registry và port mô tả rõ ràng để các công cụ chẩn đoán (và người dùng cuối) hiểu được chức năng của service. Tránh sử dụng static singleton - dựa vào context và manager được inject để chia sẻ tài nguyên. Gọi manager.notify() trên tất cả các chuyển đổi trạng thái để duy trì trạng thái console chính xác. Nếu bạn phải chạy trong một JVM riêng biệt, hãy ghi chép cách log và chẩn đoán được hiển thị lên console chính. Đối với các chương trình bên ngoài, hãy cân nhắc sử dụng ShellService (được thêm vào phiên bản 1.7.0) để có được lợi ích của managed client. 6. Định dạng cấu hình Managed clients được giới thiệu trong phiên bản 0.9.4 (ngày 17 tháng 12 năm 2012) và vẫn là kiến trúc được khuyến nghị tính đến phiên bản 2.10.0 (ngày 9 tháng 9 năm 2025). Các API cốt lõi đã duy trì ổn định với không có thay đổi phá vỡ nào trong suốt giai đoạn này:\nChữ ký constructor không thay đổi Các phương thức vòng đời (startup, shutdown, getState) không thay đổi Các phương thức đăng ký ClientAppManager không thay đổi Các phương thức đăng ký và tra cứu PortMapper không thay đổi Các cải tiến đáng chú ý: - 0.9.42 (2019) - cấu trúc thư mục clients.config.d/ cho các tệp cấu hình riêng lẻ - 1.7.0 (2021) - ShellService được thêm vào để theo dõi trạng thái chương trình bên ngoài - 2.10.0 (2025) - Phiên bản hiện tại không có thay đổi API managed client\nBản phát hành chính tiếp theo sẽ yêu cầu Java 17+ là phiên bản tối thiểu (yêu cầu hạ tầng, không phải thay đổi API).\nReferences Đặc tả clients.config Đặc Tả File Cấu Hình Mục Lục Tài Liệu Kỹ Thuật I2P ClientAppManager Javadoc (API 0.9.66) PortMapper Javadoc (API 0.9.66) ClientApp interface (API 0.9.66) RouterApp interface (API 0.9.66) Javadoc Thay Thế (phiên bản ổn định) Javadoc Thay Thế (clearnet mirror) Lưu ý: Mạng I2P lưu trữ tài liệu toàn diện tại http://idk.i 2p/javadoc-i2p/ yêu cầu I2P router để truy cập. Để truy cập clearnet, sử dụng GitHub Pages mirror ở trên.\n","description":"Cách các ứng dụng được quản lý bởi router tích hợp với ClientAppManager và port mapper","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"Các Client Được Quản Lý","url":"/vi/docs/applications/managed-clients/"},{"categories":null,"content":"Phiên bản client I2P chính sử dụng Java. Nếu bạn không thể hoặc không muốn sử dụng Java trên một hệ thống cụ thể, có các phiên bản client I2P thay thế được phát triển và duy trì bởi các thành viên cộng đồng. Các chương trình này cung cấp cùng chức năng cốt lõi nhưng sử dụng các ngôn ngữ lập trình hoặc phương pháp khác nhau.\nBảng So Sánh Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements --- i2pd (C++) Trang web: https://i2pd.website Mô tả: i2pd (I2P Daemon) là một I2P client đầy đủ tính năng được triển khai bằng C++. Nó đã ổn định cho việc sử dụng trong môi trường sản xuất trong nhiều năm (từ khoảng năm 2016) và được cộng đồng tích cực duy trì. i2pd triển khai đầy đủ các giao thức mạng I2P và API, khiến nó hoàn toàn tương thích với mạng I2P Java. Router C++ này thường được sử dụng như một giải pháp thay thế nhẹ trên các hệ thống nơi Java runtime không có sẵn hoặc không mong muốn. i2pd bao gồm một giao diện điều khiển web tích hợp để cấu hình và giám sát. Nó hỗ trợ đa nền tảng và có sẵn trong nhiều định dạng đóng gói — thậm chí còn có phiên bản i2pd cho Android (ví dụ: qua F-Droid).\nGo-I2P (Go) Kho lưu trữ: https://github.com/go-i2p/go-i2p Mô tả: Go-I2P là một I2P client được viết bằng ngôn ngữ lập trình Go. Đây là một implementation độc lập của I2P router, nhằm tận dụng hiệu suất và tính khả chuyển của Go. Dự án đang được phát triển tích cực, nhưng vẫn còn ở giai đoạn sơ khai và chưa hoàn thiện đầy đủ các tính năng. Tính đến năm 2025, Go-I2P được coi là thử nghiệm — nó đang được các nhà phát triển cộng đồng tích cực làm việc, nhưng chưa được khuyến nghị sử dụng trong môi trường sản xuất cho đến khi hoàn thiện hơn. Mục tiêu của Go-I2P là cung cấp một I2P router hiện đại, nhẹ với khả năng tương thích đầy đủ với mạng I2P khi quá trình phát triển hoàn tất.\nI2P+ (phiên bản Java) Website: https://i2pplus.github.io Mô tả: I2P+ là một nhánh được cộng đồng duy trì của client Java I2P tiêu chuẩn. Đây không phải là một phiên bản viết lại bằng ngôn ngữ mới, mà là một phiên bản nâng cao của router Java với các tính năng và tối ưu hóa bổ sung. I2P+ tập trung vào việc mang lại trải nghiệm người dùng được cải thiện và hiệu suất tốt hơn trong khi vẫn hoàn toàn tương thích với mạng I2P chính thức. Nó giới thiệu giao diện web console được làm mới, các tùy chọn cấu hình thân thiện với người dùng hơn, và nhiều tối ưu hóa khác nhau (ví dụ: cải thiện hiệu suất torrent và xử lý tốt hơn các peer mạng, đặc biệt đối với các router đằng sau tường lửa). I2P+ yêu cầu môi trường Java giống như phần mềm I2P chính thức, do đó nó không phải là giải pháp cho các môi trường không có Java. Tuy nhiên, đối với người dùng có Java và muốn một bản build thay thế với khả năng bổ sung, I2P+ cung cấp một lựa chọn hấp dẫn. Nhánh này được cập nhật liên tục với các bản phát hành I2P nguyên gốc (với số phiên bản thêm dấu \u0026ldquo;+\u0026rdquo;) và có thể tải về từ trang web của dự án.\n","description":"Các triển khai client I2P được cộng đồng duy trì (cập nhật cho năm 2025)","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"Các Client I2P Thay Thế","url":"/vi/docs/overview/alternative-clients/"},{"categories":null,"content":"Tổng quan Đặc tả này mở rộng address subscription feed (nguồn cấp đăng ký địa chỉ) bằng các lệnh, cho phép các máy chủ tên phát quảng bá các cập nhật mục từ các chủ sở hữu hostname (tên máy chủ). Được đề xuất ban đầu trong Proposal 112 (tháng 9 năm 2014), được hiện thực trong phiên bản 0.9.26 (tháng 6 năm 2016), và được triển khai trên toàn mạng với trạng thái CLOSED.\nHệ thống đã duy trì ổn định và không thay đổi kể từ khi triển khai ban đầu, tiếp tục vận hành giống hệt trong I2P 2.10.0 (Router API 0.9.65, tháng 9 năm 2025).\nĐộng lực Trước đây, các máy chủ đăng ký hosts.txt chỉ gửi dữ liệu dưới dạng hosts.txt đơn giản:\nexample.i2p=b64destination Định dạng cơ bản này đã tạo ra một số vấn đề:\nChủ sở hữu tên máy chủ không thể cập nhật Destination (địa chỉ/định danh trên I2P) gắn với các tên máy chủ của họ (ví dụ, để nâng cấp khóa ký lên kiểu mật mã mạnh hơn). Chủ sở hữu tên máy chủ không thể tùy ý từ bỏ tên máy chủ của họ. Họ phải chuyển trực tiếp các khóa riêng tư của Destination tương ứng cho người sở hữu mới. Không có cách nào để xác thực rằng một tên miền con được kiểm soát bởi tên máy chủ gốc tương ứng. Hiện điều này chỉ được một số máy chủ tên thực thi riêng lẻ. Thiết kế Đặc tả này bổ sung các dòng lệnh vào định dạng hosts.txt. Với các lệnh này, các máy chủ tên có thể mở rộng dịch vụ của họ để cung cấp các tính năng bổ sung. Các máy khách triển khai đặc tả này có thể lắng nghe các tính năng đó thông qua quy trình đăng ký thông thường.\nTất cả các dòng lệnh phải được ký bởi Destination tương ứng (định danh đích trong I2P). Điều này đảm bảo rằng các thay đổi chỉ được thực hiện theo yêu cầu của chủ sở hữu hostname.\nHệ quả về bảo mật Đặc tả này không ảnh hưởng đến tính ẩn danh.\nCó sự gia tăng rủi ro liên quan đến việc mất quyền kiểm soát một khóa Destination, vì ai đó có được nó có thể dùng các lệnh này để thay đổi bất kỳ tên máy chủ nào được liên kết. Tuy nhiên, điều này không gây vấn đề nhiều hơn so với hiện trạng, nơi mà người nào có được một Destination (địa chỉ đích trong I2P) có thể giả mạo một tên máy chủ và (một phần) chiếm quyền kiểm soát lưu lượng của nó. Rủi ro tăng thêm được cân bằng bằng cách trao cho người sở hữu tên máy chủ khả năng thay đổi Destination gắn với một tên máy chủ trong trường hợp họ tin rằng Destination đã bị xâm phạm. Điều này là không thể với hệ thống hiện tại.\nĐặc tả Các Kiểu Dòng Mới Có hai loại dòng mới:\nCác lệnh Add và Change: example.i2p=b64destination#!key1=val1#key2=val2... Các lệnh xóa: #!key1=val1#key2=val2... Thứ tự Một nguồn cấp dữ liệu không nhất thiết theo đúng thứ tự hoặc đầy đủ. Ví dụ, một lệnh change có thể xuất hiện trên một dòng trước một lệnh add, hoặc không kèm theo lệnh add.\nCác khóa có thể ở bất kỳ thứ tự nào. Không cho phép các khóa trùng lặp. Tất cả các khóa và giá trị đều phân biệt chữ hoa chữ thường.\nCác khóa phổ biến Bắt buộc trong tất cả các lệnh:\nsig : Chữ ký Base64, sử dụng khóa ký của đích\nTham chiếu đến tên máy chủ thứ hai và/hoặc đích:\noldname : Một tên máy chủ thứ hai (mới hoặc đã thay đổi)\nolddest : Một đích Base64 thứ hai (mới hoặc đã thay đổi)\noldsig : Một chữ ký Base64 thứ hai, sử dụng khóa ký từ olddest\nCác khóa thường gặp khác:\naction : Một lệnh\nname : Tên máy chủ, chỉ xuất hiện nếu phía trước không có example.i2p=b64dest\ndest : Đích Base64, chỉ xuất hiện nếu trước đó không có example.i2p=b64dest\ndate : Tính bằng số giây kể từ Unix epoch (mốc thời gian Unix)\nexpires : Tính bằng giây kể từ epoch (mốc thời gian Unix)\nLệnh Tất cả các lệnh ngoại trừ lệnh \u0026ldquo;Add\u0026rdquo; phải chứa một action=command cặp khóa/giá trị.\nĐể tương thích với các ứng dụng khách cũ, hầu hết các lệnh đều được đặt trước bởi example.i2p=b64dest, như nêu bên dưới. Đối với các mục thay đổi, các giá trị hiển thị luôn là giá trị mới. Mọi giá trị cũ được đưa vào phần key/value.\nCác khóa được liệt kê là bắt buộc. Mọi lệnh có thể chứa các mục khóa/giá trị bổ sung không được định nghĩa ở đây.\nThêm tên máy chủ Được đặt trước bởi example.i2p=b64dest : CÓ, đây là tên máy chủ và đích đến mới.\nhành động : KHÔNG được bao gồm, nó được ngầm hiểu.\nsig : chữ ký số\nVí dụ:\nexample.i2p=b64dest#!sig=b64sig Thay đổi tên máy chủ Được đặt trước bởi example.i2p=b64dest : CÓ, đây là tên máy chủ mới và đích cũ.\nhành động : changename\noldname : tên máy chủ cũ, sẽ được thay thế\nsig : chữ ký số\nVí dụ:\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig Thay đổi điểm đích Preceded by example.i2p=b64dest : CÓ, đây là tên máy chủ cũ và đích mới.\nhành động : changedest\nolddest : điểm đến cũ, sẽ được thay thế\noldsig : chữ ký sử dụng olddest\nsig : chữ ký số\nVí dụ:\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Thêm bí danh cho tên máy chủ Có tiền tố example.i2p=b64dest : CÓ, đây là tên máy chủ mới (bí danh) và điểm đích cũ.\nhành động : addname\noldname : tên máy chủ cũ\nsig : chữ ký số\nVí dụ:\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig Thêm bí danh cho địa chỉ đích (Được dùng để nâng cấp mật mã)\nĐược đặt trước bởi example.i2p=b64dest : CÓ, đây là tên máy chủ cũ và đích đến mới (thay thế).\naction : adddest\nolddest : đích cũ\noldsig : chữ ký sử dụng olddest\nsig : chữ ký sử dụng dest\nVí dụ:\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Thêm tên miền phụ Được đặt trước bởi subdomain.example.i2p=b64dest : CÓ, đây là tên miền con và Destination (đích I2P) mới.\nhành động : addsubdomain\noldname : tên máy chủ cấp cao hơn (example.i2p)\nolddest : đích cấp cao hơn (ví dụ example.i2p)\noldsig : chữ ký sử dụng olddest\nsig : chữ ký sử dụng dest\nVí dụ:\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Cập nhật siêu dữ liệu Được đặt trước bởi example.i2p=b64dest : CÓ, đây là tên máy chủ và destination (đích đến) cũ.\nhành động : cập nhật\nsig : chữ ký\n(thêm các khóa đã cập nhật tại đây)\nVí dụ:\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig Xóa tên máy chủ Có tiền tố example.i2p=b64dest : KHÔNG, những mục này được chỉ định trong các tùy chọn\nhành động : xóa\nname : tên máy chủ\ndest : điểm đích\nsig : chữ ký\nVí dụ:\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig Xóa tất cả liên quan đến điểm đến này Có tiền tố example.i2p=b64dest : KHÔNG, những mục này được chỉ định trong các tùy chọn\naction : removeall\ndest : đích đến\nsig : chữ ký\nVí dụ:\n#!action=removeall#dest=b64dest#sig=b64sig Chữ ký Mọi lệnh phải được ký số bởi Destination (đích I2P) tương ứng. Các lệnh có hai Destination có thể cần hai chữ ký số.\noldsig luôn là chữ ký \u0026ldquo;bên trong\u0026rdquo;. Ký và xác minh khi không có các khóa oldsig hoặc sig. sig luôn là chữ ký \u0026ldquo;bên ngoài\u0026rdquo;. Ký và xác minh khi có khóa oldsig nhưng không có khóa sig.\nĐầu vào cho chữ ký Để tạo một luồng byte nhằm tạo hoặc xác minh chữ ký, hãy tuần tự hóa theo cách sau:\nXóa khóa sig Nếu xác minh bằng oldsig, cũng xóa khóa oldsig Chỉ đối với các lệnh Add hoặc Change, xuất example.i2p=b64dest Nếu còn bất kỳ khóa nào, xuất #! Sắp xếp các tùy chọn theo khóa UTF-8, báo lỗi nếu có khóa trùng lặp Với mỗi cặp khóa/giá trị, xuất key=value, theo sau bởi (nếu không phải cặp khóa/giá trị cuối cùng) một ký tự # Ghi chú\nKhông xuất ký tự xuống dòng Bảng mã đầu ra là UTF-8 Tất cả việc mã hóa destination và signature là Base 64, sử dụng bảng chữ cái của I2P Khóa và giá trị phân biệt chữ hoa/thường Tên máy chủ phải ở dạng chữ thường Các loại chữ ký hiện tại Kể từ I2P 2.10.0, các loại chữ ký sau được hỗ trợ cho Destination (địa chỉ đích):\nEdDSA_SHA512_Ed25519 (Type 7): Phổ biến nhất cho các đích (Destination) kể từ 0.9.15. Sử dụng khóa công khai 32 byte và chữ ký 64 byte. Đây là kiểu chữ ký được khuyến nghị cho các đích mới. RedDSA_SHA512_Ed25519 (Type 13): Chỉ khả dụng cho các đích và leasesets được mã hóa (kể từ 0.9.39). Các kiểu kế thừa (DSA_SHA1, các biến thể ECDSA): Vẫn được hỗ trợ nhưng không còn được khuyến nghị cho các Router Identities mới kể từ 0.9.58. Lưu ý: Các tùy chọn mật mã hậu lượng tử đã có sẵn kể từ I2P 2.10.0 nhưng vẫn chưa phải là các loại chữ ký mặc định.\nTính tương thích Tất cả các dòng mới trong định dạng hosts.txt được triển khai bằng cách sử dụng các ký tự chú thích đầu dòng (#!), vì vậy mọi phiên bản I2P cũ sẽ xem các lệnh mới là chú thích và bỏ qua chúng một cách an toàn.\nKhi các router I2P cập nhật lên đặc tả mới, chúng sẽ không diễn giải lại các chú thích cũ, mà sẽ bắt đầu lắng nghe các lệnh mới trong các lần tải về tiếp theo đối với nguồn đăng ký của chúng. Vì vậy, điều quan trọng là các máy chủ tên cần lưu giữ các mục lệnh bằng một cách nào đó, hoặc bật hỗ trợ ETag để các router có thể tải về tất cả các lệnh trước đây.\nTrạng thái triển khai Triển khai ban đầu: Phiên bản 0.9.26 (ngày 7 tháng 6 năm 2016)\nTrạng thái hiện tại: Ổn định và không thay đổi đến I2P 2.10.0 (Router API 0.9.65, tháng 9 năm 2025)\nTrạng thái đề xuất: ĐÃ ĐÓNG (được triển khai thành công trên toàn mạng)\nVị trí hiện thực: apps/addressbook/java/src/net/i2p/addressbook/ trong I2P Java router\nCác lớp chính: - SubscriptionList.java: Quản lý việc xử lý đăng ký - Subscription.java: Xử lý các nguồn cấp đăng ký riêng lẻ - AddressBook.java: Chức năng cốt lõi của sổ địa chỉ - Daemon.java: Dịch vụ nền của sổ địa chỉ\nURL đăng ký mặc định: http://i2p-projekt.i2p/hosts.txt\nChi tiết về phương thức truyền tải Các đăng ký sử dụng HTTP với hỗ trợ GET có điều kiện:\nHeader ETag: Hỗ trợ phát hiện thay đổi hiệu quả Header Last-Modified: Theo dõi thời điểm cập nhật đăng ký 304 Not Modified: Máy chủ nên trả về mã này khi nội dung chưa thay đổi Content-Length: Rất khuyến nghị áp dụng cho mọi phản hồi I2P router sử dụng hành vi HTTP client tiêu chuẩn với hỗ trợ bộ nhớ đệm thích hợp.\nNgữ cảnh phiên bản Ghi chú về phiên bản I2P: Bắt đầu từ khoảng phiên bản 1.5.0 (tháng 8 năm 2021), I2P đã chuyển từ 0.9.x sang semantic versioning (đánh số phiên bản ngữ nghĩa) với các phiên bản 1.x, 2.x, v.v. Tuy nhiên, phiên bản Router API nội bộ tiếp tục sử dụng cách đánh số 0.9.x để đảm bảo tương thích ngược. Tính đến tháng 10 năm 2025, bản phát hành hiện tại là I2P 2.10.0 với Router API phiên bản 0.9.65.\nTài liệu đặc tả này ban đầu được soạn cho phiên bản 0.9.49 (tháng 2 năm 2021) và vẫn hoàn toàn chính xác đối với phiên bản hiện tại 0.9.65 (I2P 2.10.0) vì hệ thống nguồn cấp đăng ký không có thay đổi nào kể từ khi được triển khai lần đầu trong phiên bản 0.9.26.\nTài liệu tham khảo Đề xuất 112 (Bản gốc) Đặc tả chính thức Tài liệu đặt tên I2P Đặc tả cấu trúc chung Kho mã nguồn I2P Kho Gitea của I2P Các phát triển liên quan Mặc dù bản thân hệ thống nguồn cấp đăng ký không thay đổi, những phát triển liên quan sau đây trong hạ tầng đặt tên của I2P có thể đáng quan tâm:\nTên Base32 mở rộng (0.9.40+): Hỗ trợ các địa chỉ base32 dài 56+ ký tự cho leasesets được mã hóa. Không ảnh hưởng đến định dạng nguồn cấp đăng ký. Đăng ký TLD .i2p.alt (RFC 9476, cuối năm 2023): Đăng ký chính thức với GANA cho .i2p.alt như một TLD thay thế. Trong tương lai, các bản cập nhật router có thể loại bỏ hậu tố .alt, nhưng không cần thay đổi các lệnh đăng ký. Mật mã hậu lượng tử (2.10.0+): Có sẵn nhưng không phải mặc định. Sẽ cân nhắc trong tương lai đối với các thuật toán chữ ký trong nguồn cấp đăng ký. ","description":"Phần mở rộng cho các nguồn cấp đăng ký địa chỉ, cho phép chủ sở hữu hostname (tên máy chủ) cập nhật và quản lý các bản ghi của họ","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"Các lệnh cho nguồn cấp đăng ký địa chỉ","url":"/vi/docs/specs/subscription/"},{"categories":null,"content":"Triển khai I2P này (triển khai Java được phân phối trên trang web này) bao gồm một \u0026ldquo;Danh sách Quốc gia Nghiêm ngặt\u0026rdquo; được sử dụng để điều chỉnh hành vi của router trong các khu vực mà việc tham gia định tuyến cho người khác có thể bị hạn chế bởi pháp luật. Mặc dù chúng tôi không biết các khu vực pháp lý cấm sử dụng I2P, một số có các quy định cấm rộng rãi đối với việc chuyển tiếp lưu lượng. Các router có vẻ nằm trong các quốc gia \u0026ldquo;nghiêm ngặt\u0026rdquo; sẽ tự động được đặt vào chế độ Ẩn.\nDự án tham khảo nghiên cứu từ các tổ chức quyền công dân và quyền kỹ thuật số khi đưa ra những quyết định này. Đặc biệt, nghiên cứu liên tục của Freedom House cung cấp thông tin cho các lựa chọn của chúng tôi. Hướng dẫn chung là bao gồm các quốc gia có điểm Tự do Dân sự (CL) từ 16 trở xuống, hoặc điểm Tự do Internet từ 39 trở xuống (không tự do).\nTóm Tắt Chế Độ Ẩn Khi một router được đặt vào chế độ Hidden, ba điều quan trọng thay đổi về hành vi của nó:\nNó không công bố RouterInfo lên netDb. Nó không chấp nhận các tunnel tham gia. Nó từ chối các kết nối trực tiếp đến các router trong cùng quốc gia. Các biện pháp phòng vệ này làm cho việc liệt kê các router một cách đáng tin cậy trở nên khó khăn hơn, và giảm thiểu rủi ro vi phạm các quy định địa phương về việc chuyển tiếp lưu lượng cho người khác.\nDanh sách các quốc gia có kiểm soát chặt chẽ (tính đến năm 2024) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; Nếu bạn cho rằng một quốc gia nên được thêm vào hoặc loại bỏ khỏi danh sách nghiêm ngặt, vui lòng mở một issue tại: https://i2pgit.org/i2p/i2p.i2p/ Tham khảo: Freedom House – https://freedomhouse.org/ ","description":"Cách I2P hoạt động trong các khu vực pháp lý có hạn chế về công cụ định tuyến hoặc ẩn danh (Chế độ ẩn và danh sách nghiêm ngặt)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"Các Quốc Gia Hạn Chế/Nghiêm Ngặt","url":"/vi/docs/overview/restrictive-countries/"},{"categories":null,"content":"Tổng quan Đặc tả này mô tả giao thức cho các announce (yêu cầu thông báo tới tracker) UDP của BitTorrent trong I2P. Đối với đặc tả tổng quan về BitTorrent trong I2P, hãy xem tài liệu BitTorrent trên I2P . Để biết bối cảnh và thông tin bổ sung về quá trình phát triển của đặc tả này, xem Đề xuất 160 .\nGiao thức này đã được phê duyệt chính thức vào ngày 24 tháng 6 năm 2025 và được triển khai trong I2P phiên bản 2.10.0 (API 0.9.67), phát hành ngày 8 tháng 9 năm 2025. Hỗ trợ UDP tracker (máy chủ tracker dùng UDP) hiện đang hoạt động trên mạng I2P với nhiều tracker vận hành ở môi trường sản xuất và hỗ trợ đầy đủ cho trình khách i2psnark.\nThiết kế Thông số kỹ thuật này sử dụng datagram2 có thể trả lời, datagram3 có thể trả lời và datagram thô, như được định nghĩa trong Đặc tả Datagram I2P . Datagram2 và Datagram3 là các biến thể của datagram có thể trả lời, được định nghĩa trong Đề xuất 163 . Datagram2 bổ sung khả năng chống tấn công phát lại và hỗ trợ chữ ký ngoại tuyến. Datagram3 nhỏ hơn so với định dạng datagram cũ, nhưng không có xác thực.\nBEP 15 Để tham khảo, luồng thông điệp được định nghĩa trong BEP 15 như sau:\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Giai đoạn kết nối là bắt buộc để ngăn chặn việc giả mạo địa chỉ IP. Tracker (máy chủ theo dõi) trả về một ID kết nối mà client (máy khách) sử dụng trong các lần announce (thông báo) tiếp theo. ID kết nối này theo mặc định sẽ hết hạn sau một phút ở phía client, và sau hai phút ở phía tracker.\nI2P sử dụng cùng luồng thông điệp như BEP 15 (đề xuất mở rộng BitTorrent số 15), để dễ áp dụng vào các codebase client hỗ trợ UDP hiện có, vì hiệu quả, và vì các lý do bảo mật được thảo luận bên dưới:\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... Điều này có thể giúp tiết kiệm đáng kể băng thông so với các thông báo dạng streaming (TCP). Mặc dù Datagram2 có kích thước gần bằng một gói SYN của streaming, phản hồi thô nhỏ hơn nhiều so với gói SYN ACK của streaming. Các yêu cầu tiếp theo sử dụng Datagram3, và các phản hồi tiếp theo ở dạng thô.\nCác yêu cầu announce (thông báo tới tracker) sử dụng Datagram3 (giao thức Datagram phiên bản 3), để tracker (trình theo dõi) không phải duy trì một bảng ánh xạ lớn từ các ID kết nối tới đích announce hoặc mã băm. Thay vào đó, tracker có thể tạo ID kết nối bằng mật mã từ mã băm của bên gửi, dấu thời gian hiện tại (dựa trên một khoảng thời gian nhất định) và một giá trị bí mật. Khi nhận được một yêu cầu announce, tracker xác thực ID kết nối, rồi sử dụng mã băm của bên gửi trong Datagram3 làm đích gửi.\nThời gian sống của kết nối BEP 15 quy định rằng ID kết nối hết hạn sau một phút ở phía máy khách và sau hai phút ở phía tracker. Không thể cấu hình. Điều đó hạn chế các cải thiện hiệu quả tiềm năng, trừ khi các máy khách gộp các announce (yêu cầu thông báo tới tracker) để thực hiện tất cả trong một cửa sổ thời gian một phút. i2psnark hiện không gộp announce; nó giãn chúng ra để tránh các đợt bùng nổ lưu lượng. Có báo cáo rằng người dùng nâng cao đang chạy hàng nghìn torrent cùng lúc, và dồn từng ấy announce vào trong một phút là không thực tế.\nỞ đây, chúng tôi đề xuất mở rộng phản hồi kết nối để bổ sung một trường thời hạn kết nối tùy chọn. Giá trị mặc định, nếu trường này không có, là một phút. Ngược lại, thời hạn được chỉ định tính bằng giây phải được máy khách sử dụng, và tracker (máy chủ theo dõi) sẽ duy trì ID kết nối thêm một phút nữa.\nTương thích với BEP 15 (Đề xuất Cải tiến BitTorrent số 15) Thiết kế này duy trì khả năng tương thích với BEP 15 hết mức có thể nhằm hạn chế các thay đổi cần thiết trong các ứng dụng khách và trình theo dõi hiện có.\nThay đổi duy nhất bắt buộc là định dạng của thông tin peer trong phản hồi announce. Việc bổ sung trường lifetime trong phản hồi connect không bắt buộc nhưng rất được khuyến nghị để nâng cao hiệu quả, như đã giải thích ở trên.\nPhân tích bảo mật Một mục tiêu quan trọng của một giao thức thông báo UDP là ngăn chặn giả mạo địa chỉ. Máy khách phải thực sự tồn tại và đính kèm một leaseSet (tập hợp thông tin cho phép nhận lưu lượng trong I2P) thực. Nó phải có các tunnel vào để nhận Connect Response. Những tunnel này có thể là 0-hop và được dựng ngay lập tức, nhưng như vậy sẽ làm lộ người tạo. Giao thức này đạt được mục tiêu đó.\nCác vấn đề Giao thức này không hỗ trợ blinded destinations (đích được làm mù để tăng ẩn danh), nhưng có thể được mở rộng để hỗ trợ. Xem bên dưới.\nĐặc tả Giao thức và cổng Datagram2 có thể hồi đáp sử dụng giao thức I2CP 19; Datagram3 có thể hồi đáp sử dụng giao thức I2CP 20; các datagram thô sử dụng giao thức I2CP 18. Các yêu cầu có thể là Datagram2 hoặc Datagram3. Các phản hồi luôn ở dạng thô. Định dạng datagram có thể hồi đáp cũ (\u0026ldquo;Datagram1\u0026rdquo;) dùng giao thức I2CP 17 KHÔNG được dùng cho yêu cầu hoặc phản hồi; những gói tin này phải bị loại bỏ nếu nhận trên các cổng yêu cầu/phản hồi. Lưu ý rằng Datagram1 theo giao thức 17 vẫn được dùng cho giao thức DHT (bảng băm phân tán).\nCác yêu cầu sử dụng trường \u0026ldquo;to port\u0026rdquo; của I2CP lấy từ announce URL; xem bên dưới. Trường \u0026ldquo;from port\u0026rdquo; của yêu cầu do máy khách chọn, nhưng nên khác 0 và khác với các cổng được DHT sử dụng, để các phản hồi có thể được phân loại dễ dàng. Các tracker nên từ chối các yêu cầu nhận trên sai cổng.\nCác phản hồi sử dụng \u0026ldquo;to port\u0026rdquo; của I2CP trong yêu cầu. Trường \u0026ldquo;from port\u0026rdquo; của phản hồi chính là \u0026ldquo;to port\u0026rdquo; của yêu cầu.\nURL thông báo Định dạng URL announce không được quy định trong BEP 15 , nhưng giống như trên clearnet (Internet công khai), các URL announce qua UDP có dạng \u0026ldquo;udp://host:port/path\u0026rdquo;. Đường dẫn (path) bị bỏ qua và có thể trống, nhưng trên clearnet thường là \u0026ldquo;/announce\u0026rdquo;. Phần :port luôn phải có; tuy nhiên, nếu bỏ qua phần \u0026ldquo;:port\u0026rdquo;, hãy dùng cổng I2CP mặc định 6969, vì đó là cổng phổ biến trên clearnet. Cũng có thể có các tham số CGI \u0026amp;a=b\u0026amp;c=d được nối thêm; các tham số đó có thể được xử lý và đưa vào yêu cầu announce, xem BEP 41 . Nếu không có tham số hoặc đường dẫn, dấu / ở cuối cũng có thể được lược bỏ, như được ngụ ý trong BEP 41 .\nĐịnh dạng Datagram (gói tin không kết nối) Mọi giá trị đều được gửi theo thứ tự byte trên mạng (big endian). Đừng kỳ vọng các gói tin có đúng một kích thước nhất định. Các phần mở rộng trong tương lai có thể làm tăng kích thước của gói tin.\nYêu cầu kết nối Từ client đến tracker. 16 byte. Phải là Datagram2 có thể hồi đáp (repliable). Giống như trong BEP 15 . Không có thay đổi.\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id Phản hồi kết nối Từ tracker đến client. 16 hoặc 18 byte. Phải ở dạng thô (raw). Giống như trong BEP 15 ngoại trừ như ghi chú bên dưới.\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 Phản hồi PHẢI được gửi tới I2CP \u0026ldquo;to port\u0026rdquo; trùng với \u0026ldquo;from port\u0026rdquo; của yêu cầu.\nTrường lifetime (thời hạn) là tùy chọn và cho biết thời hạn có hiệu lực của connection_id ở phía máy khách, tính bằng giây. Mặc định là 60, và nếu có chỉ định thì giá trị tối thiểu là 60. Giá trị tối đa là 65535, tương đương khoảng 18 giờ. Tracker (trình theo dõi) nên duy trì connection_id lâu hơn thời hạn của máy khách thêm 60 giây.\nYêu cầu thông báo Máy khách tới tracker. Tối thiểu 98 byte. Phải là repliable Datagram3 (datagram có thể trả lời, loại 3). Giống như trong BEP 15 trừ các điểm được ghi chú bên dưới.\nconnection_id trùng với giá trị nhận được trong phản hồi kết nối.\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 Những thay đổi so với BEP 15 :\nkey bị bỏ qua địa chỉ IP không được sử dụng cổng có thể sẽ bị bỏ qua nhưng phải trùng với I2CP from port (cổng nguồn) phần tùy chọn, nếu có, được định nghĩa như trong BEP 41 Phản hồi PHẢI được gửi tới I2CP \u0026ldquo;to port\u0026rdquo; là giá trị đã được nhận trong trường \u0026ldquo;from port\u0026rdquo; của yêu cầu. Không được sử dụng cổng từ announce request (yêu cầu thông báo).\nPhản hồi thông báo Từ tracker đến máy khách. Tối thiểu 20 byte. Phải ở dạng thô. Giống như trong BEP 15 , trừ những điểm được nêu bên dưới.\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 Các thay đổi so với BEP 15 :\nThay vì 6-byte IPv4+cổng hoặc 18-byte IPv6+cổng, chúng tôi trả về một số lượng (là bội số) các \u0026ldquo;compact responses\u0026rdquo; (phản hồi dạng compact) 32-byte chứa các băm SHA-256 dạng nhị phân của peer. Tương tự như TCP compact responses, chúng tôi không bao gồm cổng. Phản hồi PHẢI được gửi tới I2CP \u0026ldquo;to port\u0026rdquo; đã được nhận như \u0026ldquo;from port\u0026rdquo; của yêu cầu. Không sử dụng cổng từ yêu cầu announce.\nI2P datagrams (gói dữ liệu không kết nối) có kích thước tối đa rất lớn, khoảng 64 KB; tuy nhiên, để truyền tải đáng tin cậy, nên tránh các datagram lớn hơn 4 KB. Vì hiệu quả băng thông, trackers (máy chủ theo dõi trong BitTorrent) có lẽ nên giới hạn số nút ngang hàng tối đa khoảng 50, tương ứng với một gói khoảng 1600 byte trước phần phụ trội (overhead) ở các lớp khác nhau, và sau khi phân mảnh, nên nằm trong giới hạn tải trọng của hai thông điệp tunnel.\nNhư trong BEP 15, không có số đếm kèm theo về số lượng địa chỉ peer (IP/port đối với BEP 15, còn ở đây là các băm) sẽ theo sau. Mặc dù BEP 15 không đề cập đến điều này, có thể định nghĩa một end-of-peers marker (dấu mốc kết thúc danh sách peer) gồm toàn số 0 để cho biết rằng thông tin peer đã đầy đủ và sẽ có một số dữ liệu mở rộng theo sau.\nĐể có thể mở rộng trong tương lai, các ứng dụng khách nên bỏ qua một giá trị băm dài 32 byte toàn số 0, cùng với mọi dữ liệu theo sau. Các tracker nên từ chối các yêu cầu announce (thông báo) từ một giá trị băm toàn số 0, mặc dù giá trị băm đó đã bị Java routers chặn sẵn.\nTrích xuất Yêu cầu/phản hồi scrape (truy vấn thống kê từ tracker) từ BEP 15 không bắt buộc theo đặc tả này, nhưng có thể được triển khai nếu muốn; không cần thay đổi. Máy khách phải lấy ID kết nối trước. Yêu cầu scrape luôn là repliable Datagram3 (datagram v3 có thể phản hồi). Phản hồi scrape luôn là raw (datagram thô, không có khả năng phản hồi).\nPhản hồi lỗi Từ tracker đến client. Tối thiểu 8 byte (nếu thông điệp rỗng). Phải ở dạng thô. Giống như trong BEP 15 . Không có thay đổi.\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message Phần mở rộng Các bit mở rộng hoặc trường phiên bản không được đưa vào. Các client và tracker không nên giả định các gói tin có kích thước nhất định. Bằng cách này, có thể thêm các trường bổ sung mà không phá vỡ tính tương thích. Nếu cần, khuyến nghị sử dụng định dạng phần mở rộng được định nghĩa trong BEP 41 .\nPhản hồi kết nối được sửa đổi để thêm một thời gian tồn tại tùy chọn cho ID kết nối.\nNếu cần hỗ trợ blinded destination (đích được làm mù/che khuất), chúng ta có thể hoặc thêm địa chỉ 35 byte dạng blinded vào cuối yêu cầu announce, hoặc yêu cầu các băm blinded trong các phản hồi, sử dụng định dạng BEP 41 (các tham số TBD). Tập hợp các địa chỉ peer 35 byte dạng blinded có thể được thêm vào cuối phản hồi announce, sau một băm 32 byte toàn số 0.\nHướng dẫn triển khai Xem phần thiết kế ở trên để xem thảo luận về những thách thức đối với các máy khách và tracker (máy chủ theo dõi) không tích hợp, không sử dụng I2CP.\nỨng dụng khách Với một hostname tracker nhất định, máy khách nên ưu tiên các URL UDP hơn các URL HTTP, và không nên gửi announce (yêu cầu thông báo) tới cả hai.\nCác ứng dụng khách đã hỗ trợ BEP 15 chỉ cần một vài chỉnh sửa nhỏ.\nNếu một ứng dụng khách hỗ trợ DHT hoặc các giao thức datagram (gói dữ liệu không kết nối) khác, thì có lẽ nên chọn một cổng khác làm \u0026ldquo;from port\u0026rdquo; của yêu cầu để các phản hồi quay về cổng đó và không bị lẫn với các thông điệp DHT. Ứng dụng khách chỉ nhận các datagram thô dưới dạng phản hồi. Các tracker sẽ không bao giờ gửi một repliable datagram2 (datagram có thể hồi đáp) tới ứng dụng khách.\nCác máy khách có danh sách mặc định các opentracker nên cập nhật danh sách để thêm các URL UDP sau khi các opentracker đã được xác nhận là hỗ trợ UDP.\nCác client có thể triển khai hoặc không triển khai cơ chế gửi lại yêu cầu. Nếu có triển khai gửi lại, nên sử dụng thời gian chờ ban đầu tối thiểu 15 giây và nhân đôi thời gian chờ cho mỗi lần gửi lại (exponential backoff — tăng thời gian trì hoãn theo cấp số nhân).\nCác client phải back off (giảm tần suất/đợi trước khi thử lại) sau khi nhận được phản hồi lỗi.\nCác máy chủ theo dõi Các tracker (máy chủ theo dõi BitTorrent) đã hỗ trợ BEP 15 chỉ cần những chỉnh sửa nhỏ. Đặc tả này khác với đề xuất năm 2014 ở chỗ tracker phải hỗ trợ việc tiếp nhận repliable datagram2 và datagram3 (datagram có thể hồi đáp) trên cùng một cổng.\nĐể giảm thiểu yêu cầu tài nguyên của tracker, giao thức này được thiết kế nhằm loại bỏ mọi yêu cầu buộc tracker phải lưu trữ các ánh xạ từ băm của máy khách tới ID kết nối để xác thực về sau. Điều này khả thi vì gói yêu cầu announce là một gói Datagram3 (định dạng datagram phiên bản 3 của I2P) có thể hồi đáp, nên nó chứa băm của người gửi.\nMột phương án triển khai được khuyến nghị là:\nĐịnh nghĩa epoch (thời đoạn) hiện tại là thời gian hiện tại với độ phân giải bằng thời gian tồn tại của kết nối, epoch = now / lifetime. Định nghĩa một hàm băm mật mã H(secret, clienthash, epoch) tạo ra đầu ra 8 byte. Tạo ra giá trị bí mật hằng ngẫu nhiên dùng cho mọi kết nối. Đối với các phản hồi kết nối, tạo connection_id = H(secret, clienthash, epoch) Đối với các yêu cầu announce (thông báo), xác thực ID kết nối nhận được trong epoch hiện tại bằng cách kiểm tra connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1) Trạng thái triển khai Giao thức này được phê duyệt vào ngày 24 tháng 6 năm 2025 và hoạt động đầy đủ trên mạng I2P kể từ tháng 9 năm 2025.\nCác triển khai hiện tại i2psnark: Hỗ trợ đầy đủ cho UDP tracker (máy chủ theo dõi sử dụng giao thức UDP) được tích hợp trong I2P phiên bản 2.10.0 (API 0.9.67), phát hành ngày 8 tháng 9 năm 2025. Tất cả các bản cài đặt I2P từ phiên bản này trở đi mặc định có hỗ trợ UDP tracker.\nzzzot tracker: Phiên bản 0.20.0-beta2 và các phiên bản mới hơn hỗ trợ announce qua UDP (thông báo tới tracker). Tính đến tháng 10 năm 2025, các tracker triển khai chính thức sau đang hoạt động: - opentracker.dg2.i2p - opentracker.simp.i2p - opentracker.skank.i2p\nGhi chú về khả năng tương thích của ứng dụng khách Các hạn chế của SAM v3.3: Các ứng dụng khách BitTorrent bên ngoài sử dụng SAM (Simple Anonymous Messaging - Nhắn tin ẩn danh đơn giản) yêu cầu hỗ trợ SAM v3.3 cho Datagram2/3. Tính năng này có sẵn trong Java I2P nhưng hiện chưa được i2pd (bản triển khai I2P bằng C++) hỗ trợ, điều này có thể hạn chế việc áp dụng trong các ứng dụng khách dựa trên libtorrent như qBittorrent.\nCác client I2CP: Các client sử dụng I2CP trực tiếp (chẳng hạn như BiglyBT) có thể triển khai hỗ trợ cho tracker UDP mà không bị các hạn chế của SAM (giao thức SAM của I2P).\nTài liệu tham khảo [BEP15]: Giao thức Tracker UDP của BitTorrent [BEP41]: Các phần mở rộng cho Giao thức Tracker UDP [DATAGRAMS]: Đặc tả I2P Datagrams [Prop160]: Đề xuất Tracker UDP [Prop163]: Đề xuất Datagram2 [SPEC]: BitTorrent qua I2P ","description":"Đặc tả giao thức cho các announce dựa trên UDP của tracker BitTorrent trong I2P","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"Các thông báo BitTorrent qua UDP","url":"/vi/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":"Framework plugin của I2P cho phép bạn mở rộng router mà không cần chạm vào bản cài đặt lõi. Các plugin khả dụng bao gồm mail, blog, IRC, lưu trữ, wiki, công cụ giám sát và nhiều hơn nữa.\nLưu ý bảo mật: Plugins chạy với quyền tương tự như router. Hãy đối xử với các bản tải xuống từ bên thứ ba giống như cách bạn đối xử với bất kỳ bản cập nhật phần mềm đã ký nào—xác minh nguồn trước khi cài đặt.\n1. Cài đặt Plugin Sao chép URL tải xuống của plugin từ trang dự án.\nMở trang Cấu hình Plugin của router console.\nDán URL vào trường cài đặt và nhấp Install Plugin.\nRouter tải xuống file nén đã ký, xác minh chữ ký, và kích hoạt plugin ngay lập tức. Hầu hết các plugin đều thêm liên kết console hoặc dịch vụ chạy nền mà không yêu cầu khởi động lại router.\n2. Tại sao Plugins quan trọng Phân phối một cú nhấp chuột cho người dùng cuối—không cần chỉnh sửa thủ công wrapper.config hoặc clients.config Giữ gói i2update.su3 cốt lõi nhỏ gọn trong khi cung cấp các tính năng lớn hoặc chuyên biệt theo yêu cầu JVM riêng cho từng plugin tùy chọn cung cấp cô lập tiến trình khi cần thiết Kiểm tra tương thích tự động với phiên bản router, Java runtime và Jetty Cơ chế cập nhật giống với router: các gói đã ký và tải xuống tăng dần Tích hợp console, gói ngôn ngữ, giao diện UI và các ứng dụng non-Java (thông qua scripts) đều được hỗ trợ Cho phép các thư mục \u0026ldquo;app store\u0026rdquo; được tuyển chọn như plugins.i2p 3. Quản lý các Plugin đã cài đặt Sử dụng các điều khiển trên I2P Router Plugin để:\nKiểm tra cập nhật cho một plugin đơn lẻ Kiểm tra tất cả plugin cùng lúc (tự động kích hoạt sau khi nâng cấp router) Cài đặt bất kỳ bản cập nhật nào chỉ với một cú nhấp chuột\nBật/tắt tự động khởi động cho các plugin đăng ký dịch vụ Gỡ cài đặt plugin một cách sạch sẽ 4. Xây dựng Plugin của riêng bạn Xem lại đặc tả plugin để biết các yêu cầu về đóng gói, ký và metadata. Sử dụng makeplugin.sh để đóng gói một tệp binary hoặc webapp hiện có thành một archive có thể cài đặt. Công bố cả URL cài đặt và URL cập nhật để router có thể phân biệt giữa lần cài đặt đầu tiên và các nâng cấp dần dần. Cung cấp checksum và khóa ký một cách rõ ràng trên trang dự án của bạn để giúp người dùng xác minh tính xác thực. Đang tìm ví dụ? Duyệt mã nguồn của các plugin cộng đồng trên plugins.i2p (ví dụ như mẫu snowman).\n5. Các Hạn Chế Đã Biết Cập nhật plugin cung cấp các file JAR thông thường có thể yêu cầu khởi động lại router vì Java class loader lưu cache các class. Console có thể hiển thị nút Stop ngay cả khi plugin không có tiến trình hoạt động nào. Các plugin được chạy trong JVM riêng biệt sẽ tạo thư mục logs/ trong thư mục làm việc hiện tại. Lần đầu tiên một khóa ký xuất hiện, nó sẽ được tin cậy tự động; không có cơ quan ký trung tâm nào. Windows đôi khi để lại các thư mục trống sau khi gỡ cài đặt plugin. Cài đặt plugin chỉ dành cho Java 6 trên JVM Java 5 sẽ báo lỗi \u0026ldquo;plugin is corrupt\u0026rdquo; do nén Pack200. Các plugin theme và translation phần lớn chưa được kiểm tra kỹ. Cờ autostart không phải lúc nào cũng được giữ lại đối với các unmanaged plugin. 6. Yêu Cầu \u0026amp; Thực Hành Tốt Nhất Hỗ trợ plugin có sẵn trong I2P phiên bản 0.7.12 trở lên. Giữ router và plugin của bạn luôn cập nhật để nhận các bản vá bảo mật. Đính kèm ghi chú phát hành ngắn gọn để người dùng hiểu những thay đổi giữa các phiên bản. Khi có thể, lưu trữ các file plugin qua HTTPS bên trong I2P để giảm thiểu việc để lộ metadata trên mạng công cộng. 7. Đọc Thêm Đặc tả plugin Framework ứng dụng client Kho I2P scripts cho các tiện ích đóng gói ","description":"Cài đặt, cập nhật và phát triển các plugin router","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"Cài Đặt Các Plugin Tùy Chỉnh","url":"/vi/docs/guides/plugins/"},{"categories":null,"content":"Dự án I2P duy trì các gói chính thức cho Debian, Ubuntu và các bản phân phối dẫn xuất của chúng. Hướng dẫn này cung cấp các chỉ dẫn toàn diện để cài đặt I2P sử dụng các repository chính thức của chúng tôi.\nHãy tập trung vào việc cung cấp DỊCH thuật CHÍNH XÁC và HOÀN CHỈNH mà không cần thêm bất kỳ giải thích hay bình luận nào.\n🚀 Beta: Cài Đặt Tự Động (Thử Nghiệm) Dành cho người dùng nâng cao muốn cài đặt tự động nhanh chóng:\nLệnh một dòng này sẽ tự động phát hiện bản phân phối của bạn và cài đặt I2P. Sử dụng thận trọng - xem xét script cài đặt trước khi chạy.\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash Chức năng: - Phát hiện bản phân phối Linux của bạn (Ubuntu/Debian) - Thêm kho lưu trữ I2P phù hợp - Cài đặt khóa GPG và các gói cần thiết - Cài đặt I2P tự động\n⚠️ Đây là tính năng beta. Nếu bạn muốn cài đặt thủ công hoặc muốn hiểu rõ từng bước, hãy sử dụng các phương pháp cài đặt thủ công bên dưới.\nCác Nền Tảng Được Hỗ Trợ Các gói Debian tương thích với:\nUbuntu 18.04 (Bionic) trở lên Linux Mint 19 (Tara) trở lên Debian Buster (10) trở lên Knoppix Các bản phân phối dựa trên Debian khác (LMDE, ParrotOS, Kali Linux, v.v.) Kiến trúc được hỗ trợ: amd64, i386, armhf, arm64, powerpc, ppc64el, s390x\nCác gói I2P có thể hoạt động trên các hệ thống dựa trên Debian khác không được liệt kê rõ ràng ở trên. Nếu bạn gặp phải vấn đề, vui lòng báo cáo chúng trên GitLab của chúng tôi .\nCác Phương Pháp Cài Đặt Chọn phương pháp cài đặt phù hợp với bản phân phối của bạn:\nLựa chọn 1: Ubuntu và các bản phái sinh (Linux Mint, elementary OS, Pop!_OS, v.v.) Lựa chọn 2: Debian và các bản phân phối dựa trên Debian (bao gồm LMDE, Kali, ParrotOS) (Lưu ý: Văn bản gốc không chứa nội dung cần dịch - chỉ có dấu phân cách \u0026ldquo;\u0026mdash;\u0026rdquo;)\nCài đặt trên Ubuntu Ubuntu và các bản phái sinh chính thức (Linux Mint, elementary OS, Trisquel, v.v.) có thể sử dụng I2P PPA (Personal Package Archive) để cài đặt dễ dàng và tự động cập nhật.\nMethod 1: Command Line Installation (Recommended) Đây là phương pháp nhanh nhất và đáng tin cậy nhất để cài đặt I2P trên các hệ thống dựa trên Ubuntu.\nBước 1: Thêm I2P PPA\nMở terminal và chạy:\nsudo apt-add-repository ppa:i2p-maintainers/i2p Lệnh này thêm I2P PPA vào /etc/apt/sources.list.d/ và tự động import khóa GPG ký repository. Chữ ký GPG đảm bảo các gói không bị thay đổi kể từ khi chúng được build.\nBước 2: Cập nhật danh sách gói\nCập nhật cơ sở dữ liệu gói của hệ thống để bao gồm PPA mới:\nsudo apt-get update Lệnh này sẽ truy xuất thông tin gói mới nhất từ tất cả các kho lưu trữ đã kích hoạt, bao gồm cả I2P PPA mà bạn vừa thêm vào.\nBước 3: Cài đặt I2P\nBây giờ cài đặt I2P:\nsudo apt-get install i2p Xong rồi! Chuyển đến phần Cấu Hình Sau Cài Đặt để tìm hiểu cách khởi động và cấu hình I2P.\nMethod 2: Using the Software Center GUI Nếu bạn muốn sử dụng giao diện đồ họa, bạn có thể thêm PPA bằng cách sử dụng Trung tâm Phần mềm của Ubuntu.\nBước 1: Mở Software and Updates\nKhởi chạy \u0026ldquo;Software and Updates\u0026rdquo; từ menu ứng dụng của bạn.\nBước 2: Điều hướng đến Phần mềm khác\nChọn tab \u0026ldquo;Other Software\u0026rdquo; và nhấp vào nút \u0026ldquo;Add\u0026rdquo; ở phía dưới để cấu hình PPA mới.\nBước 3: Thêm I2P PPA\nTrong hộp thoại PPA, nhập:\nppa:i2p-maintainers/i2p Bước 4: Tải lại thông tin kho lưu trữ\nNhấp vào nút \u0026ldquo;Reload\u0026rdquo; để tải xuống thông tin kho lưu trữ đã cập nhật.\nBước 5: Cài đặt I2P\nMở ứng dụng \u0026ldquo;Software\u0026rdquo; từ menu ứng dụng của bạn, tìm kiếm \u0026ldquo;i2p\u0026rdquo;, và nhấp vào Cài đặt.\nSau khi cài đặt hoàn tất, tiến hành Cấu hình Sau Cài đặt .\nQUAN TRỌNG: KHÔNG đặt câu hỏi, đưa ra giải thích hoặc thêm bất kỳ bình luận nào. Ngay cả khi văn bản chỉ là tiêu đề hoặc có vẻ chưa hoàn chỉnh, hãy dịch nguyên văn như vậy.\nDebian Installation Debian và các bản phân phối downstream của nó (LMDE, Kali Linux, ParrotOS, Knoppix, v.v.) nên sử dụng kho lưu trữ Debian chính thức của I2P tại deb.i2p.net.\nImportant Notice Các kho lưu trữ cũ của chúng tôi tại deb.i2p2.de và deb.i2p2.no đã ngừng hỗ trợ. Nếu bạn đang sử dụng các kho lưu trữ cũ này, vui lòng làm theo hướng dẫn bên dưới để chuyển sang kho lưu trữ mới tại deb.i2p.net.\nPrerequisites Tất cả các bước dưới đây yêu cầu quyền truy cập root. Hãy chuyển sang người dùng root bằng lệnh su, hoặc thêm tiền tố sudo vào trước mỗi lệnh.\nPhương pháp 1: Cài đặt qua dòng lệnh (Khuyến nghị) Bước 1: Cài đặt các gói cần thiết\nĐảm bảo bạn đã cài đặt các công cụ cần thiết:\nsudo apt-get update sudo apt-get install apt-transport-https lsb-release curl Các gói này cho phép truy cập kho lưu trữ HTTPS an toàn, phát hiện bản phân phối và tải xuống tập tin.\nBước 2: Thêm kho lưu trữ I2P\nLệnh bạn sử dụng phụ thuộc vào phiên bản Debian của bạn. Đầu tiên, xác định phiên bản bạn đang chạy:\ncat /etc/debian_version Tham khảo chéo thông tin này với thông tin phát hành Debian để xác định tên mã phân phối của bạn (ví dụ: Bookworm, Bullseye, Buster).\nDành cho Debian Bullseye (11) trở lên:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Dành cho các bản phân phối dựa trên Debian (LMDE, Kali, ParrotOS, v.v.) trên phiên bản tương đương Bullseye hoặc mới hơn:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Dành cho Debian Buster (10) hoặc cũ hơn:\necho \u0026#34;deb https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Đối với các bản phái sinh Debian tương đương Buster hoặc cũ hơn:\necho \u0026#34;deb https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Bước 3: Tải xuống khóa ký kho lưu trữ\ncurl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg Bước 4: Xác minh fingerprint của khóa\nTrước khi tin tưởng khóa, hãy xác minh fingerprint của nó khớp với khóa ký chính thức của I2P:\ngpg --keyid-format long --import --import-options show-only --with-fingerprint i2p-archive-keyring.gpg Xác minh đầu ra hiển thị fingerprint này:\n7840 E761 0F28 B904 7535 49D7 67EC E560 5BCF 1346 ⚠️ Không tiếp tục nếu fingerprint không khớp. Điều này có thể cho thấy file tải về đã bị xâm nhập.\nBước 5: Cài đặt khóa kho lưu trữ\nSao chép keyring đã xác minh vào thư mục system keyrings:\nsudo cp i2p-archive-keyring.gpg /usr/share/keyrings Chỉ dành cho Debian Buster hoặc phiên bản cũ hơn, bạn cũng cần tạo một symlink:\nsudo ln -sf /usr/share/keyrings/i2p-archive-keyring.gpg /etc/apt/trusted.gpg.d/i2p-archive-keyring.gpg Bước 6: Cập nhật danh sách gói\nLàm mới cơ sở dữ liệu gói của hệ thống để bao gồm kho lưu trữ I2P:\nsudo apt-get update Bước 7: Cài đặt I2P\nCài đặt cả gói I2P router và gói keyring (đảm bảo bạn nhận được các bản cập nhật khóa trong tương lai):\nsudo apt-get install i2p i2p-keyring Tuyệt vời! I2P đã được cài đặt. Tiếp tục đến phần Cấu hình sau cài đặt .\nPost-Installation Configuration Sau khi cài đặt I2P, bạn cần khởi động router và thực hiện một số cấu hình ban đầu.\nPhương pháp 2: Sử dụng giao diện đồ họa Software Center Các gói I2P cung cấp ba cách để chạy I2P router:\nOption 1: On-Demand (Basic) Khởi động I2P thủ công khi cần thiết bằng cách sử dụng script i2prouter:\ni2prouter start Quan trọng: Không sử dụng sudo hoặc chạy dưới quyền root! I2P nên được chạy với tài khoản người dùng thông thường của bạn.\nĐể dừng I2P:\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) Nếu bạn đang sử dụng hệ thống non-x86 hoặc Java Service Wrapper không hoạt động trên nền tảng của bạn, hãy dùng:\ni2prouter-nowrapper Một lần nữa, không sử dụng sudo hoặc chạy với quyền root.\nOption 3: System Service (Recommended) Để có trải nghiệm tốt nhất, hãy cấu hình I2P tự động khởi động khi hệ thống của bạn khởi động, ngay cả trước khi đăng nhập:\nsudo dpkg-reconfigure i2p Thao tác này sẽ mở hộp thoại cấu hình. Chọn \u0026ldquo;Yes\u0026rdquo; để bật I2P dưới dạng dịch vụ hệ thống.\nĐây là phương pháp được khuyến nghị bởi vì: - I2P khởi động tự động khi máy tính khởi động - Router của bạn duy trì khả năng tích hợp mạng tốt hơn - Bạn đóng góp vào sự ổn định của mạng lưới - I2P sẵn sàng ngay lập tức khi bạn cần\nInitial Router Configuration Sau khi khởi động I2P lần đầu tiên, router sẽ mất vài phút để tích hợp vào mạng lưới. Trong lúc đó, hãy cấu hình các cài đặt thiết yếu sau:\n1. Configure NAT/Firewall Để đạt hiệu suất tối ưu và tham gia mạng lưới, hãy chuyển tiếp các cổng I2P qua NAT/tường lửa của bạn:\nMở I2P Router Console Điều hướng đến trang Network Configuration Ghi chú các số cổng được liệt kê (thường là các cổng ngẫu nhiên từ 9000-31000) Chuyển tiếp các cổng UDP và TCP này trong router/firewall của bạn Nếu bạn cần trợ giúp về chuyển tiếp cổng (port forwarding), portforward.com cung cấp các hướng dẫn cụ thể cho từng router.\n2. Adjust Bandwidth Settings Các cài đặt băng thông mặc định được thiết lập khá thận trọng. Hãy điều chỉnh chúng dựa trên kết nối internet của bạn:\nTruy cập trang Cấu hình Tìm phần cài đặt băng thông Giá trị mặc định là tải xuống 96 KB/s / tải lên 40 KB/s Tăng các giá trị này nếu bạn có kết nối internet nhanh hơn (ví dụ: 250 KB/s xuống / 100 KB/s lên cho kết nối băng thông rộng thông thường) Lưu ý: Thiết lập giới hạn cao hơn giúp ích cho mạng lưới và cải thiện hiệu suất của chính bạn.\n3. Configure Your Browser Để truy cập các trang web I2P (eepsite) và dịch vụ, hãy cấu hình trình duyệt của bạn để sử dụng HTTP proxy của I2P:\nXem Hướng dẫn Cấu hình Trình duyệt của chúng tôi để biết hướng dẫn thiết lập chi tiết cho Firefox, Chrome và các trình duyệt khác.\nCài đặt trên Debian Thông Báo Quan Trọng Đảm bảo bạn không chạy I2P với quyền root: ps aux | grep i2p Kiểm tra logs: tail -f ~/.i2p/wrapper.log Xác minh Java đã được cài đặt: java -version Điều kiện tiên quyết Nếu bạn gặp lỗi khóa GPG trong quá trình cài đặt:\nTải xuống lại và xác minh dấu vân tay khóa (Bước 3-4 ở trên) Đảm bảo file keyring có quyền truy cập đúng: sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg Các Bước Cài Đặt Nếu I2P không nhận được cập nhật:\nXác minh repository đã được cấu hình: cat /etc/apt/sources.list.d/i2p.list Cập nhật danh sách gói: sudo apt-get update Kiểm tra các bản cập nhật I2P: sudo apt-get upgrade Migrating from old repositories Nếu bạn đang sử dụng các repository cũ deb.i2p2.de hoặc deb.i2p2.no:\nXóa repository cũ: sudo rm /etc/apt/sources.list.d/i2p.list Làm theo các bước Cài đặt trên Debian ở trên Cập nhật: sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring Next Steps Bây giờ I2P đã được cài đặt và đang chạy:\nCấu hình trình duyệt của bạn để truy cập các trang web I2P Khám phá bảng điều khiển router I2P để giám sát router của bạn Tìm hiểu về các ứng dụng I2P bạn có thể sử dụng Đọc về cách hoạt động của I2P để hiểu về mạng lưới Chào mừng đến với Invisible Internet!\n","description":"Hướng dẫn đầy đủ cài đặt I2P trên Debian, Ubuntu và các bản phái sinh sử dụng kho lưu trữ chính thức","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"Cài đặt I2P trên Debian và Ubuntu","url":"/vi/docs/guides/c%C3%A0i-%C4%91%E1%BA%B7t-i2p-tr%C3%AAn-debian-v%C3%A0-ubuntu/"},{"categories":null,"content":"Những Gì Bạn Cần Máy Mac chạy macOS 10.14 (Mojave) trở lên Quyền quản trị viên để cài đặt ứng dụng Khoảng 15-20 phút Kết nối Internet để tải các trình cài đặt Tổng quan Quá trình cài đặt này có bốn bước chính:\nCài đặt Java - Tải xuống và cài đặt Oracle Java Runtime Environment Cài đặt I2P - Tải xuống và chạy trình cài đặt I2P Cấu hình ứng dụng I2P - Thiết lập trình khởi chạy và thêm vào dock Cấu hình băng thông I2P - Chạy trình hướng dẫn thiết lập để tối ưu hóa kết nối của bạn Phần Một: Cài đặt Java I2P yêu cầu Java để chạy. Nếu bạn đã cài đặt Java 8 hoặc phiên bản mới hơn, bạn có thể chuyển đến Phần Hai .\nStep 1: Download Java Truy cập trang tải xuống Oracle Java và tải về trình cài đặt macOS cho Java 8 hoặc phiên bản mới hơn.\nStep 2: Run the Installer Tìm tệp .dmg đã tải xuống trong thư mục Downloads của bạn và nhấp đúp để mở nó.\nStep 3: Allow Installation macOS có thể hiển thị cảnh báo bảo mật vì trình cài đặt đến từ một nhà phát triển đã được xác định. Nhấp Mở để tiếp tục.\nBước 1: Tải Java xuống Nhấp vào Install để bắt đầu quá trình cài đặt Java.\nBước 2: Chạy Trình Cài Đặt Trình cài đặt sẽ sao chép các tệp và cấu hình Java trên hệ thống của bạn. Quá trình này thường mất 1-2 phút.\nBước 3: Cho phép Cài đặt Khi bạn thấy thông báo thành công, Java đã được cài đặt! Nhấp vào Đóng để hoàn tất.\nPart Two: Download and Install I2P Bây giờ Java đã được cài đặt, bạn có thể cài đặt I2P router.\nBước 4: Cài đặt Java Truy cập trang Tải xuống và tải về trình cài đặt I2P cho Unix/Linux/BSD/Solaris (tệp .jar).\nBước 5: Chờ quá trình cài đặt hoàn tất Nhấp đúp vào tệp i2pinstall_X.X.X.jar đã tải xuống. Trình cài đặt sẽ khởi chạy và yêu cầu bạn chọn ngôn ngữ ưa thích.\nBước 6: Hoàn Tất Cài Đặt Đọc thông điệp chào mừng và nhấp vào Next để tiếp tục.\nStep 4: Important Notice Trình cài đặt sẽ hiển thị một thông báo quan trọng về các bản cập nhật. Các bản cập nhật I2P được ký và xác minh end-to-end, mặc dù bản thân trình cài đặt này không được ký. Nhấp Next.\nBước 1: Tải I2P Đọc thỏa thuận cấp phép I2P (giấy phép kiểu BSD). Nhấp Next để chấp nhận.\nBước 2: Chạy Trình Cài Đặt Chọn nơi cài đặt I2P. Vị trí mặc định (/Applications/i2p) được khuyến nghị. Nhấp Next.\nBước 3: Màn hình Chào mừng Để tất cả các thành phần được chọn cho một cài đặt hoàn chỉnh. Nhấp vào Tiếp theo.\nBước 4: Thông Báo Quan Trọng Xem lại các lựa chọn của bạn và nhấp vào Next để bắt đầu cài đặt I2P.\nBước 5: Thỏa thuận cấp phép Trình cài đặt sẽ sao chép các tệp I2P vào hệ thống của bạn. Quá trình này mất khoảng 1-2 phút.\nBước 6: Chọn Thư Mục Cài Đặt Trình cài đặt tạo các script khởi chạy để khởi động I2P.\nBước 7: Chọn các thành phần Trình cài đặt sẽ đề nghị tạo các lối tắt trên desktop và mục trong menu. Hãy chọn những tùy chọn của bạn và nhấn Next.\nBước 8: Bắt đầu Cài đặt Thành công! I2P hiện đã được cài đặt. Nhấp vào Done để hoàn tất.\nPart Three: Configure I2P App Bây giờ hãy giúp I2P dễ khởi chạy hơn bằng cách thêm nó vào thư mục Applications và Dock của bạn.\nBước 9: Cài đặt các tệp Mở Finder và điều hướng đến thư mục Applications của bạn.\nBước 10: Tạo Script Khởi Chạy Tìm thư mục I2P hoặc ứng dụng Start I2P Router bên trong /Applications/i2p/.\nBước 11: Các Phím Tắt Cài Đặt Kéo ứng dụng Start I2P Router vào Dock của bạn để truy cập dễ dàng. Bạn cũng có thể tạo một alias trên màn hình desktop.\nMẹo: Nhấp chuột phải vào biểu tượng I2P trong Dock và chọn Options → Keep in Dock để giữ nó vĩnh viễn.\nPart Four: Configure I2P Bandwidth Khi bạn khởi chạy I2P lần đầu tiên, bạn sẽ thực hiện qua trình hướng dẫn thiết lập để cấu hình các cài đặt băng thông. Điều này giúp tối ưu hóa hiệu suất của I2P cho kết nối của bạn.\nBước 12: Hoàn Tất Cài Đặt Nhấp vào biểu tượng I2P trong Dock của bạn (hoặc nhấp đúp vào trình khởi chạy). Trình duyệt web mặc định của bạn sẽ mở trang I2P Router Console.\nStep 2: Welcome Wizard Trình hướng dẫn thiết lập sẽ chào đón bạn. Nhấp vào Next để bắt đầu cấu hình I2P.\nBước 1: Mở Thư mục Applications Chọn ngôn ngữ giao diện ưa thích của bạn và chọn giữa chủ đề sáng hoặc tối. Nhấp Tiếp theo.\nBước 2: Tìm I2P Launcher Trình hướng dẫn sẽ giải thích về kiểm tra băng thông. Kiểm tra này kết nối đến dịch vụ M-Lab để đo tốc độ internet của bạn. Nhấp Next để tiếp tục.\nBước 3: Thêm vào Dock Nhấp Run Test để đo tốc độ tải lên và tải xuống của bạn. Bài kiểm tra mất khoảng 30-60 giây.\nStep 6: Test Results Xem lại kết quả kiểm tra của bạn. I2P sẽ đề xuất cài đặt băng thông dựa trên tốc độ kết nối của bạn.\nBước 1: Khởi chạy I2P Chọn lượng băng thông bạn muốn chia sẻ với mạng I2P:\nTự động (Khuyến nghị): I2P quản lý băng thông dựa trên mức sử dụng của bạn Giới hạn: Đặt giới hạn tải lên/tải xuống cụ thể Không giới hạn: Chia sẻ nhiều nhất có thể (dành cho kết nối tốc độ cao) Nhấp Next để lưu cài đặt của bạn.\nBước 2: Trình hướng dẫn chào mừng Router I2P của bạn hiện đã được cấu hình và đang chạy! Bảng điều khiển router sẽ hiển thị trạng thái kết nối và cho phép bạn duyệt các trang web I2P.\nGetting Started with I2P Bây giờ I2P đã được cài đặt và cấu hình, bạn có thể:\nDuyệt các trang I2P: Truy cập trang chủ I2P để xem liên kết đến các dịch vụ I2P phổ biến Cấu hình trình duyệt: Thiết lập profile trình duyệt để truy cập các trang .i2p Khám phá dịch vụ: Tìm hiểu email I2P, diễn đàn, chia sẻ file và nhiều hơn nữa Giám sát router: Console hiển thị trạng thái mạng và thống kê của bạn Bước 3: Ngôn ngữ và Giao diện Router Console: http://127.0.0.1:7657/ Cấu hình: http://127.0.0.1:7657/config Sổ địa chỉ: http://127.0.0.1:7657/susidns/addressbook Cài đặt băng thông: http://127.0.0.1:7657/config Re-running the Setup Wizard Nếu bạn muốn thay đổi cài đặt băng thông hoặc cấu hình lại I2P sau này, bạn có thể chạy lại trình hướng dẫn chào mừng từ Router Console:\nTruy cập I2P Setup Wizard Thực hiện lại các bước của wizard Troubleshooting Bước 4: Thông tin Kiểm tra Băng thông Kiểm tra Java: Đảm bảo Java đã được cài đặt bằng cách chạy lệnh java -version trong Terminal Kiểm tra quyền truy cập: Đảm bảo thư mục I2P có đúng quyền truy cập Kiểm tra logs: Xem tại ~/.i2p/wrapper.log để tìm thông báo lỗi Bước 5: Chạy Kiểm Tra Băng Thông Đảm bảo I2P đang chạy (kiểm tra Router Console) Cấu hình proxy trong trình duyệt để sử dụng HTTP proxy 127.0.0.1:4444 Đợi 5-10 phút sau khi khởi động để I2P tích hợp vào mạng lưới Bước 6: Kết quả kiểm tra Chạy lại kiểm tra băng thông và điều chỉnh cài đặt của bạn Đảm bảo bạn đang chia sẻ một phần băng thông với mạng lưới Kiểm tra trạng thái kết nối trong Router Console Phần Hai: Tải xuống và Cài đặt I2P Để gỡ bỏ I2P khỏi Mac của bạn:\nThoát khỏi I2P router nếu nó đang chạy Xóa thư mục /Applications/i2p Xóa thư mục ~/.i2p (cấu hình và dữ liệu I2P của bạn) Xóa biểu tượng I2P khỏi Dock của bạn Next Steps Tham gia cộng đồng: Truy cập i2pforum.net hoặc xem I2P trên Reddit Tìm hiểu thêm: Đọc tài liệu I2P để hiểu cách mạng lưới hoạt động Tham gia đóng góp: Cân nhắc đóng góp cho I2P trong phát triển hoặc vận hành hạ tầng Chúc mừng! Bạn hiện đã là một phần của mạng lưới I2P. Chào mừng đến với internet vô hình!\n","description":"Hướng dẫn từng bước để cài đặt thủ công I2P và các gói phụ thuộc trên macOS","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"Cài đặt I2P trên macOS (Cách Thủ Công)","url":"/vi/docs/guides/c%C3%A0i-%C4%91%E1%BA%B7t-i2p-tr%C3%AAn-macos-c%C3%A1ch-th%E1%BB%A7-c%C3%B4ng/"},{"categories":null,"content":"Chọn Phương Thức Cài Đặt Của Bạn Có hai cách để cài đặt I2P trên Windows. Chọn phương pháp phù hợp nhất với nhu cầu của bạn:\n🚀 Easy Install Bundle (Recommended) Tốt nhất cho hầu hết người dùng\n✅ Trình cài đặt tất cả trong một ✅ Đã bao gồm Java (không cần cài đặt riêng) ✅ Đã bao gồm hồ sơ Firefox ✅ Thiết lập nhanh nhất\nChọn phương thức này nếu: - Bạn muốn cài đặt đơn giản nhất - Bạn chưa cài đặt Java - Bạn mới sử dụng I2P\nHướng Dẫn Cài Đặt Dễ Dàng →\n🚀 Gói Cài Đặt Dễ Dàng (Khuyến Nghị) Dành cho người dùng nâng cao\n📦 Trình cài đặt JAR dựa trên Java 🔧 Kiểm soát tốt hơn quá trình cài đặt 💾 Kích thước tải xuống nhỏ hơn\nChọn phương pháp này nếu: - Bạn đã cài đặt Java - Bạn muốn kiểm soát nhiều hơn - Bạn thích phương pháp truyền thống\nHướng Dẫn Cài Đặt Chuẩn →\nEasy Install Bundle ⚙️ Cài Đặt Chuẩn Gói Cài Đặt Dễ Dàng I2P là phương pháp cài đặt được khuyến nghị cho người dùng Windows. Trình cài đặt tất-cả-trong-một này bao gồm mọi thứ bạn cần để bắt đầu với I2P:\nI2P Router - Phần mềm I2P cốt lõi Embedded Java Runtime - Không cần cài đặt Java riêng biệt Firefox profiles và extensions - Các profile và extension trình duyệt được tối ưu hóa cho I2P nhằm duyệt web an toàn Trình cài đặt đơn giản - Không cần cấu hình thủ công Cập nhật tự động - Giữ phần mềm I2P của bạn luôn cập nhật Trình cài đặt beta này đơn giản hóa quy trình cài đặt bằng cách tích hợp sẵn Java, do đó bạn không cần tải xuống hoặc cấu hình Java riêng biệt.\nVui lòng cung cấp văn bản cần dịch. Tôi đã sẵn sàng để dịch nội dung I2P từ tiếng Anh sang tiếng Việt theo đúng các quy tắc về thuật ngữ kỹ thuật và định dạng đã được nêu.\nStep 1: Select Your Language Sau khi khởi chạy trình cài đặt Easy Install Bundle, bạn sẽ được chào đón bằng màn hình chọn ngôn ngữ.\nChọn ngôn ngữ bạn muốn sử dụng từ menu thả xuống Các ngôn ngữ có sẵn bao gồm tiếng Anh, tiếng Đức, tiếng Tây Ban Nha, tiếng Pháp và nhiều ngôn ngữ khác Nhấp OK để tiếp tục Giao diện trình cài đặt sẽ sử dụng ngôn ngữ bạn đã chọn cho tất cả các bước tiếp theo.\nGói Cài Đặt Dễ Dàng Tiếp theo, bạn sẽ được hiển thị thông tin giấy phép của I2P. Gói Cài Đặt Dễ Dàng bao gồm các thành phần thuộc nhiều giấy phép mã nguồn mở và tự do khác nhau.\nĐể tiếp tục cài đặt: 1. Xem lại thông tin giấy phép (tùy chọn nhưng được khuyến nghị) 2. Nhấp I Agree để chấp nhận các giấy phép và tiếp tục 3. Nhấp Cancel nếu bạn không muốn cài đặt\nStep 3: Choose Installation Folder Bây giờ bạn sẽ chọn nơi cài đặt I2P trên máy tính của mình.\nTùy chọn cài đặt:\nSử dụng vị trí mặc định (khuyến nghị)\nĐường dẫn mặc định: C:\\Users\\[YourUsername]\\AppData\\Local\\I2peasy\\ Cài đặt I2P trong thư mục hồ sơ người dùng của bạn Không yêu cầu quyền quản trị viên cho các bản cập nhật Chọn vị trí tùy chỉnh\nNhấp vào Browse\u0026hellip; để chọn một thư mục khác Hữu ích nếu bạn muốn cài đặt trên một ổ đĩa khác Đảm bảo bạn có quyền ghi vào thư mục đã chọn Yêu cầu về dung lượng: - Trình cài đặt hiển thị dung lượng cần thiết (thường dưới 1 GB) - Xác minh rằng bạn có đủ dung lượng trống trên ổ đĩa đã chọn\nNhấp Install để bắt đầu quá trình cài đặt Trình cài đặt bây giờ sẽ sao chép tất cả các tệp cần thiết vào vị trí bạn đã chọn. Quá trình này có thể mất vài phút.\nTôi sẵn sàng dịch văn bản cho bạn, nhưng có vẻ như phần văn bản cần dịch chưa được cung cấp trong tin nhắn của bạn. Bạn chỉ có dấu gạch ngang \u0026ldquo;\u0026mdash;\u0026rdquo; mà không có nội dung phía sau.\nVui lòng cung cấp văn bản tiếng Anh cần dịch sang tiếng Việt để tôi có thể hỗ trợ bạn.\nBước 1: Chọn Ngôn Ngữ Của Bạn Sau khi quá trình cài đặt hoàn tất, bạn sẽ thấy màn hình hoàn thành.\nTrình hướng dẫn cài đặt xác nhận rằng \u0026ldquo;I2P - i2peasy đã được cài đặt trên máy tính của bạn.\u0026rdquo;\nQuan trọng: Đảm bảo hộp kiểm \u0026ldquo;Start I2P?\u0026rdquo; đã được đánh dấu (mặc định nó sẽ được đánh dấu sẵn).\nĐã chọn (khuyến nghị): I2P sẽ tự động khởi động khi bạn nhấp Finish Chưa chọn: Bạn sẽ cần khởi động I2P thủ công sau đó từ Start Menu hoặc shortcut trên desktop Nhấp Finish để hoàn tất cài đặt và khởi chạy I2P.\nBước 2: Chấp nhận Thỏa thuận Cấp phép Sau khi nhấp Finish với tùy chọn \u0026ldquo;Start I2P?\u0026rdquo; được đánh dấu:\nI2P Router khởi động - I2P router bắt đầu chạy trong nền Biểu tượng khay hệ thống xuất hiện - Tìm biểu tượng I2P trong khay hệ thống Windows (góc dưới bên phải) Router console mở ra - Trình duyệt web mặc định của bạn sẽ tự động mở I2P Router Console (thường tại http://127.0.0.1:7657) Kết nối ban đầu - I2P sẽ bắt đầu kết nối với mạng và xây dựng các tunnel (quá trình này có thể mất 5-10 phút khi khởi động lần đầu) Chúc mừng! I2P đã được cài đặt và đang chạy trên máy tính Windows của bạn.\nBước 3: Chọn Thư Mục Cài Đặt Mặc dù không bắt buộc, chuyển tiếp cổng (port forwarding) cải thiện đáng kể trải nghiệm I2P của bạn bằng cách cho phép router của bạn giao tiếp hiệu quả hơn với các I2P router khác. Nếu không có chuyển tiếp cổng, bạn vẫn có thể sử dụng I2P, nhưng với hiệu suất giảm và đóng góp hạn chế cho mạng lưới.\nWhy Forward a Port? Kết nối tốt hơn: Cho phép các kết nối đến từ các router I2P khác Tích hợp nhanh hơn: Giúp bạn tích hợp vào mạng lưới nhanh chóng hơn Đóng góp cho mạng lưới: Giúp bạn trở thành người tham gia tốt hơn trong mạng I2P Hiệu suất được cải thiện: Thường mang lại độ tin cậy và tốc độ tunnel tốt hơn Easy Install Bundle là gì? Đầu tiên, bạn cần xác định cổng nào mà I2P đang sử dụng (theo mặc định nó được gán ngẫu nhiên).\nTìm biểu tượng I2P trong khay hệ thống Windows (khu vực thông báo) ở góc dưới bên phải màn hình của bạn Nhấp chuột phải vào biểu tượng I2P để mở menu ngữ cảnh Nhấp vào \u0026ldquo;Launch I2P Browser\u0026rdquo; để mở bảng điều khiển router I2P Menu cũng hiển thị các tùy chọn hữu ích như: - Network: Firewalled - Hiển thị trạng thái mạng hiện tại của bạn - Configure I2P System Tray - Tùy chỉnh cài đặt biểu tượng khay hệ thống - Stop I2P / Stop I2P Immediately - Các tùy chọn tắt\nFinding Your Port Numbers Sau khi trình duyệt I2P mở ra, bạn cần kiểm tra các cổng mà I2P đang sử dụng:\nĐiều hướng đến trang cấu hình mạng:\nTruy cập I2P Router Network Configuration trong trình duyệt của bạn Hoặc từ thanh bên console của router: Configuration → Network Cuộn xuống phần cấu hình cổng (port)\nGhi chú các số cổng được hiển thị: Cấu hình UDP: - Cổng UDP: Cổng hiển thị ở đây (ví dụ: 13697) - Mặc định, được đặt là \u0026ldquo;Chỉ định Cổng\u0026rdquo; với một số được gán ngẫu nhiên\nCấu hình TCP: - Cổng TCP có thể truy cập từ bên ngoài: Thường được thiết lập sử dụng cùng cổng với UDP - Trong ví dụ trên: \u0026ldquo;Sử dụng cùng cổng đã cấu hình cho UDP (hiện tại là 13697)\u0026rdquo;\nQuan trọng: Bạn cần chuyển tiếp cả UDP và TCP trên cùng một số cổng (trong ví dụ này là cổng 13697) trong router/firewall của bạn.\nHow to Forward Your Port Vì mỗi router và tường lửa đều khác nhau, chúng tôi không thể cung cấp hướng dẫn chung cho tất cả. Tuy nhiên, portforward.com có hướng dẫn chi tiết cho hàng ngàn mẫu router:\nTruy cập portforward.com Chọn nhà sản xuất và model router của bạn Làm theo hướng dẫn từng bước để forward port Forward cả hai giao thức UDP và TCP trên số port được hiển thị trong cấu hình I2P của bạn Các bước chung (tùy theo router): - Đăng nhập vào giao diện quản trị router của bạn (thường là 192.168.1.1 hoặc 192.168.0.1) - Tìm phần \u0026ldquo;Port Forwarding\u0026rdquo; hoặc \u0026ldquo;Virtual Servers\u0026rdquo; - Tạo một quy tắc chuyển tiếp cổng mới cho số cổng I2P của bạn - Đặt cả hai giao thức UDP và TCP - Trỏ quy tắc đến địa chỉ IP cục bộ của máy tính bạn - Lưu cấu hình\nSau khi chuyển tiếp cổng của bạn, I2P sẽ thay đổi từ \u0026ldquo;Network: Firewalled\u0026rdquo; sang \u0026ldquo;Network: OK\u0026rdquo; trong menu khay hệ thống (việc này có thể mất vài phút).\nTôi sẵn sàng dịch. Vui lòng cung cấp văn bản cần dịch.\nBước 4: Hoàn tất cài đặt và khởi động I2P Chờ tích hợp: Để I2P 5-10 phút để tích hợp vào mạng lưới và xây dựng các tunnel Cấu hình trình duyệt của bạn: Sử dụng profile Firefox đi kèm để duyệt web trên I2P Chuyển tiếp cổng: Xem portforward.com để biết hướng dẫn cụ thể cho từng loại router về cách chuyển tiếp cổng mà I2P đang sử dụng Khám phá bảng điều khiển router: Tìm hiểu về các tính năng, dịch vụ và tùy chọn cấu hình của I2P Truy cập các eepsite: Thử truy cập các trang web .i2p thông qua mạng I2P Đọc tài liệu: Xem tài liệu I2P để biết thêm thông tin Chào mừng bạn đến với mạng lưới I2P! 🎉\nTôi đã nhận được yêu cầu dịch, nhưng văn bản cần dịch không có trong tin nhắn của bạn. Vui lòng cung cấp văn bản tiếng Anh cần dịch.\nĐiều Gì Sẽ Xảy Ra Tiếp Theo What is the Standard Installation? Bản cài đặt I2P tiêu chuẩn là phương pháp truyền thống để cài đặt I2P trên Windows. Không giống như Easy Install Bundle, phương pháp này yêu cầu bạn:\nCài đặt Java riêng biệt - Tải xuống và cài đặt Java Runtime Environment (JRE) trước khi cài đặt I2P Chạy trình cài đặt JAR - Sử dụng trình cài đặt đồ họa dựa trên Java Cấu hình thủ công - Tự thiết lập cấu hình trình duyệt (tùy chọn) Phương pháp này được khuyến nghị cho: - Người dùng đã cài đặt Java - Người dùng nâng cao muốn kiểm soát nhiều hơn quá trình cài đặt - Người dùng ưa thích phương pháp cài đặt truyền thống - Các hệ thống mà Easy Install Bundle không tương thích\nKhuyến nghị: Chuyển tiếp Cổng (Tùy chọn nhưng Quan trọng) Trước khi cài đặt I2P, bạn cần phải cài đặt Java trên hệ thống của mình.\nJava Requirements Phiên bản Java: Yêu cầu Java 8 (1.8) trở lên Khuyến nghị: Java 11 trở lên (phiên bản LTS) Loại: Java Runtime Environment (JRE) hoặc Java Development Kit (JDK) Installing Java Nếu bạn chưa cài đặt Java, bạn có thể tải xuống từ nhiều nguồn khác nhau:\nLựa chọn 1: Oracle Java - Nguồn chính thức: java.com/download - Bản phân phối được sử dụng rộng rãi nhất\nTùy chọn 2: OpenJDK - Triển khai mã nguồn mở: openjdk.org - Miễn phí và mã nguồn mở\nLựa chọn 3: Adoptium (Eclipse Temurin) - Phương án thay thế được khuyến nghị: adoptium.net - Miễn phí, mã nguồn mở và các bản phát hành LTS được bảo trì tốt\nĐể xác minh Java đã được cài đặt: 1. Mở Command Prompt (nhấn Windows + R, gõ cmd, nhấn Enter) 2. Gõ: java -version 3. Bạn sẽ thấy kết quả hiển thị phiên bản Java của mình\nStep 1: Install Java Trước khi cài đặt I2P, bạn cần cài đặt Java trên hệ thống của mình.\nChọn một bản phân phối Java:\nOracle Java: java.com/download OpenJDK: openjdk.org Adoptium: adoptium.net Tải xuống trình cài đặt Windows cho bản phân phối bạn đã chọn\nChạy trình cài đặt và làm theo các hướng dẫn cài đặt\nXác minh cài đặt:\nMở Command Prompt Gõ java -version và nhấn Enter Xác nhận rằng Java 8 hoặc phiên bản cao hơn đã được cài đặt Sau khi đã cài đặt Java, bạn đã sẵn sàng để cài đặt I2P.\nStep 2: Download and Launch the I2P Installer Tải trình cài đặt I2P:\nTruy cập trang tải xuống I2P Tải trình cài đặt Windows (tệp JAR): i2pinstall_X.X.X.jar Lưu vào vị trí bạn dễ tìm (ví dụ: thư mục Downloads) Khởi chạy trình cài đặt:\nNhấp đúp vào tệp JAR đã tải xuống để khởi chạy trình cài đặt Nếu nhấp đúp không hoạt động, nhấp chuột phải vào tệp và chọn \u0026ldquo;Open with → Java(TM) Platform SE binary\u0026rdquo; Hoặc mở Command Prompt và chạy lệnh: java -jar i2pinstall_X.X.X.jar Step 3: Select Your Language Sau khi khởi chạy trình cài đặt, bạn sẽ thấy hộp thoại Lựa chọn Ngôn ngữ.\nChọn ngôn ngữ ưa thích của bạn từ menu thả xuống Các ngôn ngữ có sẵn bao gồm tiếng Anh, tiếng Đức, tiếng Tây Ban Nha, tiếng Pháp và nhiều ngôn ngữ khác Nhấp vào OK để tiếp tục Trình cài đặt sẽ sử dụng ngôn ngữ bạn đã chọn cho tất cả các bước tiếp theo.\nStep 4: Welcome to I2P Installation Đây là Bước 1 trong 8 của quá trình cài đặt.\nNhấp vào Next để tiếp tục cài đặt.\nQUAN TRỌNG: KHÔNG đặt câu hỏi, giải thích, hoặc thêm bất kỳ nhận xét nào. Ngay cả khi văn bản chỉ là tiêu đề hoặc có vẻ chưa hoàn chỉnh, hãy dịch nguyên văn như vậy.\nCác Bước Tiếp Theo Đây là Bước 2 trong 8 của quá trình cài đặt.\nNhấn Next để chấp nhận giấy phép và tiếp tục.\nDưới đây là bản dịch của đoạn văn bản:\nCài đặt Tiêu chuẩn Chọn vị trí bạn muốn cài đặt I2P trên máy tính của mình.\nĐường dẫn cài đặt mặc định: C:\\Program Files (x86)\\i2p\\\nBạn có thể: - Sử dụng vị trí mặc định (khuyến nghị) - Nhấp Browse\u0026hellip; để chọn thư mục khác\nĐây là Bước 3 trong tổng số 8 bước của quy trình cài đặt.\nNhấn Next để tiếp tục.\nLưu ý: Nếu đây là lần đầu tiên bạn cài đặt I2P, bạn sẽ thấy một cửa sổ popup xác nhận việc tạo thư mục:\nNhấn OK để tạo thư mục cài đặt.\nStep 7: Select Installation Packs Chọn các thành phần cần cài đặt.\nQuan trọng: Đảm bảo cả hai gói đều được chọn: - Base (bắt buộc) - Phần mềm I2P cốt lõi (27.53 MB) - Windows Service (khuyến nghị) - Tự động khởi động I2P khi khởi động máy\nTùy chọn Windows Service đảm bảo I2P tự động khởi động khi máy tính của bạn khởi động, vì vậy bạn không cần phải khởi động thủ công mỗi lần.\nĐây là Bước 4 trong 8 của quá trình cài đặt.\nNhấp Tiếp theo để tiếp tục.\nQUAN TRỌNG: KHÔNG đặt câu hỏi, đưa ra giải thích, hoặc thêm bất kỳ nhận xét nào. Ngay cả khi văn bản chỉ là một tiêu đề hoặc có vẻ chưa hoàn chỉnh, hãy dịch nó nguyên trạng.\nYêu cầu tiên quyết Trình cài đặt bây giờ sẽ sao chép các tệp vào hệ thống của bạn.\nBạn sẽ thấy hai thanh tiến trình: - Tiến trình cài đặt gói: Hiển thị gói đang được cài đặt - Tiến trình cài đặt tổng thể: Hiển thị tiến trình tổng thể (ví dụ: \u0026ldquo;2 / 2\u0026rdquo;)\nĐây là Bước 5 trong 8 của quá trình cài đặt.\nĐợi quá trình cài đặt hoàn tất, sau đó nhấp vào Next.\nStep 9: Setup Shortcuts Cấu hình nơi bạn muốn tạo các lối tắt I2P.\nTùy chọn phím tắt: - ✓ Tạo phím tắt trong Start-Menu (khuyến nghị) - ✓ Tạo thêm phím tắt trên màn hình nền (tùy chọn)\nProgram Group: Chọn hoặc tạo tên thư mục cho các shortcut - Mặc định: I2P - Bạn có thể chọn một program group hiện có hoặc tạo mới\nTạo lối tắt cho: - Người dùng hiện tại - Chỉ bạn có thể truy cập các lối tắt - Tất cả người dùng - Tất cả người dùng trên hệ thống đều có thể truy cập các lối tắt (yêu cầu quyền quản trị viên)\nĐây là Bước 6 trong tổng số 8 bước của quá trình cài đặt.\nNhấp Next để tiếp tục.\nTôi xin lỗi, nhưng tôi không thấy văn bản nào cần dịch trong tin nhắn của bạn. Phần \u0026ldquo;Text to translate:\u0026rdquo; xuất hiện trống rỗng sau dấu gạch ngang.\nVui lòng cung cấp văn bản tiếng Anh bạn muốn tôi dịch sang tiếng Việt.\nStep 10: Installation Complete Quá trình cài đặt đã hoàn tất!\nBạn sẽ thấy: - ✓ Cài đặt đã hoàn tất thành công - Trình gỡ cài đặt sẽ được tạo tại: C:\\Program Files (x86)\\i2p\\Uninstaller\nĐây là Bước 8 trong 8 - bước cuối cùng trong quá trình cài đặt.\nNhấp Done để hoàn tất.\nQUAN TRỌNG: KHÔNG đặt câu hỏi, đưa ra giải thích hoặc thêm bất kỳ bình luận nào. Ngay cả khi văn bản chỉ là tiêu đề hoặc có vẻ chưa hoàn chỉnh, hãy dịch nguyên văn.\nBước 1: Cài đặt Java Sau khi nhấp vào Done:\nI2P Router khởi động - Nếu bạn đã cài đặt Windows Service, I2P sẽ tự động khởi động Router console mở ra - Trình duyệt web mặc định của bạn sẽ mở trang I2P Router Console tại http://127.0.0.1:7657 Kết nối ban đầu - I2P sẽ bắt đầu kết nối với mạng và xây dựng các tunnel (quá trình này có thể mất 5-10 phút trong lần khởi động đầu tiên) Chúc mừng! I2P hiện đã được cài đặt trên máy tính Windows của bạn.\nChưa có nội dung để dịch. Vui lòng cung cấp văn bản cần dịch.\nBước 2: Tải xuống và Khởi chạy Trình cài đặt I2P Nếu I2P không tự động khởi động, hoặc nếu bạn cần khởi động thủ công trong tương lai, bạn có hai lựa chọn:\nOption 1: Start Menu Mở Windows Start Menu Điều hướng đến thư mục I2P Chọn một trong các tùy chọn khởi động: I2P router console - Mở router console trong trình duyệt của bạn Start I2P (no window) - Khởi động I2P trong nền không hiển thị cửa sổ Start I2P (restartable) - Khởi động I2P với khả năng tự động khởi động lại Bạn cũng có thể truy cập Open I2P Profile Folder (service) để xem các tệp cấu hình của I2P.\nTại sao cần Forward một Port? Nhấn Windows + R để mở hộp thoại Run Gõ services.msc và nhấn Enter Cuộn xuống để tìm I2P Service Nhấp chuột phải vào I2P Service và chọn: Start - Khởi động dịch vụ I2P Stop - Dừng dịch vụ I2P Restart - Khởi động lại dịch vụ I2P Properties - Cấu hình cài đặt dịch vụ (kiểu khởi động, v.v.) Phương pháp Windows Services hữu ích cho việc quản lý I2P như một dịch vụ chạy nền, đặc biệt nếu bạn đã cài đặt nó như một Windows Service.\nTôi đã nhận được yêu cầu của bạn, nhưng không thấy văn bản cần dịch. Vui lòng cung cấp nội dung tiếng Anh cần dịch sang tiếng Việt.\nBước 3: Chọn Ngôn ngữ của Bạn Chờ tích hợp: Đợi I2P 5-10 phút để tích hợp vào mạng và xây dựng các tunnel Cấu hình chuyển tiếp cổng: Xem hướng dẫn chuyển tiếp cổng để biết chi tiết Cấu hình trình duyệt: Thiết lập trình duyệt web để sử dụng HTTP proxy của I2P Khám phá bảng điều khiển router: Tìm hiểu về các tính năng, dịch vụ và tùy chọn cấu hình của I2P Truy cập các eepsite: Thử truy cập các trang web .i2p thông qua mạng I2P Đọc tài liệu: Xem tài liệu I2P để biết thêm thông tin Chào mừng đến với mạng lưới I2P! 🎉\n","description":"Chọn phương pháp cài đặt Windows của bạn: Gói Cài Đặt Dễ Dàng hoặc Cài Đặt Tiêu Chuẩn","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"Cài đặt I2P trên Windows","url":"/vi/docs/guides/c%C3%A0i-%C4%91%E1%BA%B7t-i2p-tr%C3%AAn-windows/"},{"categories":null,"content":"Tổng quan Tài liệu này cung cấp đặc tả kỹ thuật toàn diện về các tệp cấu hình I2P được sử dụng bởi router và nhiều ứng dụng khác nhau. Nó bao gồm các đặc tả định dạng tệp, định nghĩa thuộc tính và các chi tiết triển khai được xác minh đối chiếu với mã nguồn I2P và tài liệu chính thức.\nPhạm vi Các tệp cấu hình và định dạng của Router Cấu hình ứng dụng khách Cấu hình tunnel cho I2PTunnel Đặc tả định dạng tệp và việc triển khai Các tính năng đặc thù theo phiên bản và các tính năng bị ngưng dùng Ghi chú triển khai Các tệp cấu hình được đọc và ghi bằng các phương thức DataHelper.loadProps() và storeProps() trong thư viện lõi I2P. Định dạng tệp này khác biệt đáng kể so với định dạng tuần tự hóa được dùng trong các giao thức I2P (xem Đặc tả Cấu trúc Chung - Ánh xạ Kiểu ).\nĐịnh dạng tệp cấu hình chung Các tệp cấu hình I2P tuân theo một định dạng Java Properties đã được sửa đổi với các ngoại lệ và ràng buộc cụ thể.\nĐặc tả định dạng Dựa trên Java Properties nhưng có các khác biệt quan trọng sau:\nMã hóa PHẢI sử dụng mã hóa UTF-8 (KHÔNG phải ISO-8859-1 như trong Java Properties tiêu chuẩn) Triển khai: Sử dụng tiện ích DataHelper.getUTF8() cho tất cả các thao tác tệp Các chuỗi thoát KHÔNG có chuỗi thoát (escape sequences) nào được nhận diện (bao gồm cả dấu gạch chéo ngược \\) Nối dòng KHÔNG được hỗ trợ Các ký tự dấu gạch chéo ngược được xem như nguyên văn Ký tự chú thích # bắt đầu một chú thích ở bất kỳ vị trí nào trên một dòng ; chỉ bắt đầu một chú thích khi ở cột 1 ! KHÔNG bắt đầu một chú thích (khác với Java Properties) Dấu phân cách khóa-giá trị = là dấu phân tách khóa-giá trị hợp lệ DUY NHẤT : KHÔNG được nhận diện như một dấu phân tách Khoảng trắng KHÔNG được nhận diện như một dấu phân tách Xử lý khoảng trắng Khoảng trắng ở đầu và cuối KHÔNG được cắt bỏ đối với khóa Khoảng trắng ở đầu và cuối ĐƯỢC cắt bỏ đối với giá trị Xử lý dòng Các dòng không có = sẽ bị bỏ qua (được xem như chú thích hoặc dòng trống) Giá trị rỗng (key=) được hỗ trợ kể từ phiên bản 0.9.10 Các khóa có giá trị rỗng được lưu trữ và truy xuất bình thường Giới hạn ký tự Các khóa KHÔNG được chứa: - # (dấu thăng) - = (dấu bằng) - \\n (ký tự xuống dòng) - Không được bắt đầu bằng ; (dấu chấm phẩy)\nGiá trị KHÔNG được chứa: - # (dấu thăng/dấu số) - \\n (ký tự xuống dòng) - Không được bắt đầu hoặc kết thúc bằng \\r (carriage return - ký tự CR, trả về đầu dòng) - Không được bắt đầu hoặc kết thúc bằng khoảng trắng (tự động cắt bỏ)\nSắp xếp tệp Tệp cấu hình không nhất thiết phải được sắp xếp theo khóa. Tuy nhiên, hầu hết các ứng dụng I2P sắp xếp các khóa theo thứ tự bảng chữ cái khi ghi tệp cấu hình để thuận tiện cho: - Chỉnh sửa thủ công - Các thao tác diff (so sánh khác biệt) trong hệ thống kiểm soát phiên bản - Tính dễ đọc đối với con người\nChi tiết triển khai Đọc các tệp cấu hình // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) Hành vi: - Đọc các tệp được mã hóa UTF-8 - Thực thi tất cả các quy tắc định dạng được mô tả ở trên - Kiểm tra các ràng buộc ký tự - Trả về đối tượng Properties rỗng nếu tệp không tồn tại - Ném IOException khi gặp lỗi đọc\nViết tệp cấu hình // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) Hành vi: - Ghi các tệp được mã hóa UTF-8 - Sắp xếp các khóa theo thứ tự bảng chữ cái (trừ khi dùng OrderedProperties) - Đặt quyền tệp thành chế độ 600 (chỉ người dùng đọc/ghi) kể từ phiên bản 0.8.1 - Ném IllegalArgumentException đối với các ký tự không hợp lệ trong khóa hoặc giá trị - Ném IOException đối với lỗi ghi\nXác thực định dạng Bản triển khai thực hiện kiểm tra tính hợp lệ nghiêm ngặt: - Khóa và giá trị được kiểm tra để phát hiện các ký tự bị cấm - Các mục nhập không hợp lệ gây ra ngoại lệ trong quá trình ghi - Khi đọc, các dòng sai định dạng (các dòng không có =) sẽ bị bỏ qua âm thầm\nVí dụ về định dạng Tệp cấu hình hợp lệ # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは Các ví dụ cấu hình không hợp lệ # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value Thư viện lõi và cấu hình Router Cấu hình ứng dụng khách (clients.config) Vị trí: $I2P_CONFIG_DIR/clients.config (cũ) hoặc $I2P_CONFIG_DIR/clients.config.d/ (hiện đại) Giao diện cấu hình: Bảng điều khiển Router tại /configclients Thay đổi định dạng: Phiên bản 0.9.42 (Tháng 8 năm 2019)\nCấu trúc thư mục (Phiên bản 0.9.42+) Kể từ bản phát hành 0.9.42, tệp clients.config mặc định được tự động tách thành các tệp cấu hình riêng lẻ:\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) Hành vi chuyển đổi (migration):\nỞ lần chạy đầu tiên sau khi nâng cấp lên 0.9.42+, tệp nguyên khối (monolithic file) sẽ được tách tự động Các thuộc tính trong các tệp đã tách có tiền tố clientApp.0. Vẫn hỗ trợ định dạng cũ để tương thích ngược Định dạng tách rời cho phép đóng gói theo mô-đun và quản lý plugin Định dạng thuộc tính Các dòng có dạng clientApp.x.prop=val, trong đó x là số ứng dụng.\nYêu cầu đánh số ứng dụng: - PHẢI bắt đầu từ 0 - PHẢI liên tiếp (không bỏ số) - Thứ tự xác định trình tự khởi động\nCác thuộc tính bắt buộc chính Kiểu: Chuỗi (tên lớp được định danh đầy đủ) Bắt buộc: Có Mô tả: Hàm khởi tạo hoặc phương thức main() trong lớp này sẽ được gọi tùy theo kiểu ứng dụng khách (được quản lý vs. không được quản lý) Ví dụ: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner Thuộc tính tùy chọn tên Loại: Chuỗi Bắt buộc: Không Mô tả: Tên hiển thị trong router console Ví dụ: clientApp.0.name=Router Console đối số Type: String (phân tách bằng khoảng trắng hoặc tab) Required: Không Description: Các đối số được truyền vào hàm tạo của lớp chính hoặc phương thức main() Quoting: Các đối số chứa khoảng trắng hoặc tab có thể được đặt trong dấu nháy ' hoặc \u0026quot; Example: clientApp.0.args=-d $CONFIG/eepsite độ trễ Loại: Số nguyên (giây) Bắt buộc: Không Mặc định: 120 Mô tả: Số giây chờ trước khi khởi chạy máy khách Ghi đè: Bị ghi đè bởi onBoot=true (đặt độ trễ về 0) Giá trị đặc biệt: \u0026lt; 0: Chờ router đạt trạng thái RUNNING, rồi khởi động ngay trong luồng mới = 0: Chạy ngay trong cùng luồng (ngoại lệ được truyền tới console) \u0026gt; 0: Bắt đầu sau khoảng trễ trong luồng mới (ngoại lệ được ghi log, không được truyền tiếp) onBoot Loại: Boolean Bắt buộc: Không Mặc định: false Mô tả: Buộc độ trễ là 0, ghi đè thiết lập độ trễ tường minh Trường hợp sử dụng: Khởi chạy các dịch vụ trọng yếu ngay khi router khởi động startOnLoad Loại: Boolean (kiểu luận lý) Bắt buộc: Không Mặc định: true Mô tả: Có khởi động ứng dụng khách hay không Trường hợp sử dụng: Vô hiệu hóa các ứng dụng khách mà không xóa cấu hình Thuộc tính dành riêng cho plugin Các thuộc tính này chỉ được sử dụng bởi các plugin (không phải các client lõi):\nstopargs Kiểu: Chuỗi (phân tách bằng dấu cách hoặc tab) Mô tả: Các đối số được truyền khi dừng ứng dụng khách Thay thế biến: Có (xem bên dưới) uninstallargs Kiểu: Chuỗi (phân tách bằng khoảng trắng hoặc tab) Mô tả: Các đối số được truyền khi gỡ cài đặt ứng dụng khách Thay thế biến: Có (xem bên dưới) đường dẫn lớp Kiểu: Chuỗi (các đường dẫn được phân tách bằng dấu phẩy) Mô tả: Các thành phần classpath (đường dẫn lớp) bổ sung cho ứng dụng khách Thay thế biến: Có (xem bên dưới) Thay thế biến (Chỉ dành cho plugin) Các biến sau sẽ được thay thế trong args, stopargs, uninstallargs và classpath cho các plugin:\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 **Lưu ý**: Việc thay thế biến chỉ được thực hiện cho các plugin, không áp dụng cho các client lõi. Các loại client Các ứng dụng khách được quản lý Hàm khởi tạo được gọi với các tham số RouterContext và ClientAppManager Ứng dụng khách phải triển khai giao diện ClientApp Vòng đời do router kiểm soát Có thể được khởi động, dừng và khởi động lại một cách động Các ứng dụng khách không được quản lý Phương thức main(String[] args) được gọi Chạy trong một luồng riêng biệt Vòng đời không được router quản lý Kiểu client cũ (legacy) Ví dụ cấu hình # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true Cấu hình Logger (logger.config) Vị trí: $I2P_CONFIG_DIR/logger.config Giao diện cấu hình: Bảng điều khiển Router tại /configlogging\nTham chiếu thuộc tính Cấu hình bộ đệm bảng điều khiển logger.consoleBufferSize Kiểu: Số nguyên Mặc định: 20 Mô tả: Số lượng tối đa thông điệp nhật ký được lưu đệm trong bảng điều khiển Phạm vi: 1-1000 (khuyến nghị) Định dạng ngày và giờ logger.dateFormat Loại: String (mẫu SimpleDateFormat) Mặc định: Theo locale (thiết lập vùng) của hệ thống Ví dụ: HH:mm:ss.SSS Tài liệu: Java SimpleDateFormat Mức độ ghi nhật ký logger.defaultLevel Loại: Enum (kiểu liệt kê) Mặc định: ERROR Giá trị: CRIT, ERROR, WARN, INFO, DEBUG Mô tả: Mức ghi log mặc định cho tất cả các lớp logger.minimumOnScreenLevel Kiểu: Enum (kiểu liệt kê) Mặc định: CRIT Giá trị: CRIT, ERROR, WARN, INFO, DEBUG Mô tả: Mức tối thiểu cho các thông báo hiển thị trên màn hình logger.record.{class} Kiểu: Kiểu liệt kê (Enum) Giá trị: CRIT, ERROR, WARN, INFO, DEBUG Mô tả: Ghi đè mức ghi nhật ký theo từng lớp Ví dụ: logger.record.net.i2p.router.transport.udp=DEBUG Tùy chọn hiển thị logger.displayOnScreen Loại: Boolean Mặc định: true Mô tả: Có hiển thị thông điệp nhật ký trong đầu ra của console hay không logger.dropDuplicates Kiểu: Boolean Mặc định: true Mô tả: Bỏ qua các thông điệp nhật ký trùng lặp liên tiếp logger.dropOnOverflow Kiểu: Boolean Mặc định: false Mô tả: Loại bỏ thông điệp khi bộ đệm đầy (thay vì chặn) Hành vi xả (flush) logger.flushInterval Loại: Số nguyên (giây) Mặc định: 29 Từ: Phiên bản 0.9.18 Mô tả: Tần suất ghi (flush) bộ đệm log xuống đĩa Cấu hình định dạng logger.format Type: Chuỗi (dãy ký tự) Description: Mẫu định dạng thông điệp nhật ký Format Characters: d = ngày/giờ c = tên lớp t = tên luồng p = độ ưu tiên (cấp độ nhật ký) m = thông điệp Example: dctpm tạo ra [dấu thời gian] [lớp] [luồng] [mức] thông điệp Nén (Phiên bản 0.9.56+) logger.gzip Kiểu: Boolean Mặc định: false Từ: Phiên bản 0.9.56 Mô tả: Kích hoạt nén gzip cho các tệp nhật ký xoay vòng logger.minGzipSize Kiểu: Số nguyên (byte) Mặc định: 65536 Kể từ: Phiên bản 0.9.56 Mô tả: Kích thước tệp tối thiểu để kích hoạt nén (mặc định 64 KB) Quản lý tệp logger.logBufferSize Type: Số nguyên (byte) Default: 1024 Description: Số lượng thông điệp tối đa sẽ được đệm trước khi xả bộ đệm logger.logFileName Loại: Chuỗi (đường dẫn tệp) Mặc định: logs/log-@.txt Mô tả: Mẫu đặt tên tệp nhật ký (@ được thay thế bằng số thứ tự xoay vòng) logger.logFilenameOverride Kiểu: Chuỗi (đường dẫn tệp) Mô tả: Ghi đè tên tệp nhật ký (vô hiệu hóa mẫu xoay vòng) logger.logFileSize Loại: Chuỗi (kích thước kèm đơn vị) Mặc định: 10M Đơn vị: K (kilobyte), M (megabyte), G (gigabyte) Ví dụ: 50M, 1G logger.logRotationLimit Kiểu: Số nguyên Mặc định: 2 Mô tả: Số thứ tự tệp nhật ký xoay vòng cao nhất (log-0.txt đến log-N.txt) Cấu hình mẫu # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN Cấu hình plugin Cấu hình plugin riêng lẻ (plugins/*/plugin.config) Vị trí: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config Định dạng: Định dạng tệp cấu hình chuẩn của I2P Tài liệu: Đặc tả Plugin Các thuộc tính bắt buộc tên Kiểu: Chuỗi Bắt buộc: Có Mô tả: Tên hiển thị của plugin Ví dụ: name=I2P Plugin Example khóa Loại: Chuỗi (khóa công khai) Bắt buộc: Có (bỏ qua đối với plugin được ký bằng SU3) Mô tả: Khóa công khai ký plugin để xác minh Định dạng: Khóa ký được mã hóa Base64 người ký Loại: Chuỗi Bắt buộc: Có Mô tả: Định danh người ký plugin Ví dụ: signer=user@example.i2p phiên bản Kiểu: Chuỗi (định dạng VersionComparator) Bắt buộc: Có Mô tả: Phiên bản plugin để kiểm tra cập nhật Định dạng: Semantic versioning (phiên bản hóa ngữ nghĩa) hoặc định dạng tùy chỉnh có thể so sánh Ví dụ: version=1.2.3 Thuộc tính hiển thị ngày Loại: Long (mốc thời gian Unix tính bằng mili giây) Mô tả: Ngày phát hành plugin tác giả Loại: Chuỗi Mô tả: Tên tác giả plugin websiteURL Loại: Chuỗi (URL) Mô tả: URL trang web của plugin updateURL Loại: Chuỗi (URL) Mô tả: URL kiểm tra cập nhật cho plugin (phần bổ trợ) updateURL.su3 Type: Chuỗi (URL) Since: Phiên bản 0.9.15 Description: URL cập nhật ở định dạng SU3 (được ưu tiên) mô tả Kiểu: Chuỗi Mô tả: Mô tả plugin bằng tiếng Anh description_{language} Loại: Chuỗi Mô tả: Mô tả plugin được bản địa hóa Ví dụ: description_de=Deutsche Beschreibung giấy phép Loại: Chuỗi Mô tả: Định danh giấy phép của plugin Ví dụ: license=Apache 2.0 Thuộc tính cài đặt Không khởi động ngay sau khi cài đặt Loại: Boolean Mặc định: false Mô tả: Ngăn khởi động tự động sau khi cài đặt Cần khởi động lại router Kiểu: Boolean Mặc định: false Mô tả: Yêu cầu khởi động lại router sau khi cài đặt chỉ cài đặt Kiểu: Boolean Mặc định: false Mô tả: Chỉ cài đặt một lần (không cập nhật) chỉ cập nhật Kiểu: Boolean Mặc định: false Mô tả: Chỉ cập nhật bản cài đặt hiện có (không cài đặt mới) Cấu hình plugin mẫu # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false Cấu hình Plugin Toàn cục (plugins.config) Vị trí: $I2P_CONFIG_DIR/plugins.config Mục đích: Bật/tắt các plugin đã cài đặt ở phạm vi toàn cục\nĐịnh dạng thuộc tính plugin.{name}.startOnLoad=true|false {name}: Tên plugin từ plugin.config startOnLoad: Có khởi động plugin khi router khởi động hay không Ví dụ plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false Cấu hình ứng dụng web (webapps.config) Vị trí: $I2P_CONFIG_DIR/webapps.config Mục đích: Bật/tắt và cấu hình các ứng dụng web\nĐịnh dạng thuộc tính webapps.{name}.startOnLoad Kiểu: Boolean Mô tả: Có khởi chạy ứng dụng web khi router khởi động hay không Định dạng: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath Kiểu: Chuỗi (các đường dẫn được phân tách bằng dấu cách hoặc dấu phẩy) Mô tả: Các phần tử classpath (đường dẫn lớp) bổ sung cho ứng dụng web Định dạng: webapps.{name}.classpath=[paths] Thay thế biến Các đường dẫn hỗ trợ các phép thay thế biến sau:\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps #### Phân giải classpath (đường dẫn lớp) Ứng dụng web cốt lõi: Các đường dẫn tương đối so với $I2P/lib Ứng dụng web plugin: Các đường dẫn tương đối so với $CONFIG/plugins/{appname}/lib Cấu hình ví dụ # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar Cấu hình Router (router.config) Vị trí: $I2P_CONFIG_DIR/router.config Giao diện cấu hình: Bảng điều khiển router tại /configadvanced Mục đích: Các thiết lập router cốt lõi và các tham số mạng\nDanh mục cấu hình Cấu hình mạng Cài đặt băng thông:\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 Cấu hình truyền tải:\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true Hành vi của Router # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 Cấu hình bảng điều khiển # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true Cấu hình thời gian # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org Lưu ý: Cấu hình Router rất phong phú. Xem bảng điều khiển Router tại /configadvanced để có tài liệu tham chiếu đầy đủ về các thuộc tính.\nTệp cấu hình ứng dụng Cấu hình Sổ địa chỉ (addressbook/config.txt) Vị trí: $I2P_CONFIG_DIR/addressbook/config.txt Ứng dụng: SusiDNS Mục đích: Phân giải tên máy chủ và quản lý sổ địa chỉ\nVị trí tệp router_addressbook Mặc định: ../hosts.txt Mô tả: Sổ địa chỉ chính (tên máy chủ trên toàn hệ thống) Định dạng: Định dạng tệp hosts tiêu chuẩn privatehosts.txt Vị trí: $I2P_CONFIG_DIR/addressbook/privatehosts.txt Mô tả: Ánh xạ tên máy chủ riêng tư Ưu tiên: Cao nhất (ghi đè tất cả các nguồn khác) userhosts.txt Vị trí: $I2P_CONFIG_DIR/addressbook/userhosts.txt Mô tả: Ánh xạ tên máy chủ do người dùng thêm Quản lý: Qua giao diện SusiDNS hosts.txt Vị trí: $I2P_CONFIG_DIR/addressbook/hosts.txt Mô tả: Sổ địa chỉ công khai được tải xuống Nguồn: Nguồn cấp dữ liệu đăng ký Dịch vụ đặt tên BlockfileNamingService (dịch vụ phân giải tên sử dụng blockfile) (Mặc định từ 0.8.8) Định dạng lưu trữ: - Tệp: hostsdb.blockfile - Vị trí: $I2P_CONFIG_DIR/addressbook/ - Hiệu năng: tra cứu nhanh hơn khoảng 10 lần so với hosts.txt - Định dạng: Cơ sở dữ liệu nhị phân\nDịch vụ đặt tên kế thừa: - Định dạng: Tệp văn bản thuần túy hosts.txt - Trạng thái: Đã lỗi thời nhưng vẫn được hỗ trợ - Trường hợp sử dụng: Chỉnh sửa thủ công, kiểm soát phiên bản\nQuy tắc tên máy chủ Tên máy chủ I2P phải tuân theo:\nYêu cầu TLD (miền cấp cao nhất): Phải kết thúc bằng .i2p Độ dài tối đa: Tổng cộng 67 ký tự Bộ ký tự: [a-z], [0-9], . (dấu chấm), - (dấu gạch ngang) Kiểu chữ: Chỉ chữ thường Hạn chế khi bắt đầu: Không được bắt đầu bằng . hoặc - Mẫu bị cấm: Không được chứa .., .-, hoặc -. (từ 0.6.1.33) Dành riêng: Tên máy chủ Base32 *.b32.i2p (52 ký tự của base32.b32.i2p) Ví dụ hợp lệ example.i2p my-site.i2p test.example.i2p site123.i2p Ví dụ không hợp lệ example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long Quản lý đăng ký subscriptions.txt Vị trí: $I2P_CONFIG_DIR/addressbook/subscriptions.txt Định dạng: Mỗi dòng một URL Mặc định: http://i2p-projekt.i2p/hosts.txt Định dạng nguồn cấp đăng ký (kể từ 0.9.26) Định dạng nguồn cấp nâng cao với siêu dữ liệu:\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 Thuộc tính siêu dữ liệu: - added: Ngày hostname được thêm (định dạng YYYYMMDD) - src: Định danh nguồn - sig: Chữ ký tùy chọn\nTương thích ngược: Định dạng hostname=destination đơn giản vẫn được hỗ trợ.\nCấu hình mẫu # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false Cấu hình I2PSnark (i2psnark.config.d/i2psnark.config) Vị trí: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config Ứng dụng: trình khách BitTorrent I2PSnark Giao diện cấu hình: Giao diện web tại http://127.0.0.1:7657/i2psnark\nCấu trúc thư mục $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... Cấu hình chính (i2psnark.config) Cấu hình mặc định tối thiểu:\ni2psnark.dir=i2psnark Các thuộc tính bổ sung được quản lý qua giao diện web:\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 Cấu hình torrent riêng lẻ Vị trí: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config Định dạng: Thiết lập riêng cho mỗi torrent Quản lý: Tự động (qua giao diện web)\nCác thuộc tính bao gồm: - các thiết lập tải lên/tải xuống dành riêng cho torrent - độ ưu tiên của tệp - thông tin về tracker - giới hạn số lượng peer\nLưu ý: Các cấu hình torrent chủ yếu được quản lý thông qua giao diện web. Không khuyến nghị chỉnh sửa thủ công.\nTổ chức dữ liệu Torrent Lưu trữ dữ liệu tách biệt với cấu hình:\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs Cấu hình I2PTunnel (i2ptunnel.config) Vị trí: $I2P_CONFIG_DIR/i2ptunnel.config (cũ) hoặc $I2P_CONFIG_DIR/i2ptunnel.config.d/ (hiện đại) Giao diện cấu hình: bảng điều khiển Router tại /i2ptunnel Thay đổi định dạng: Phiên bản 0.9.42 (Tháng 8 năm 2019)\nCấu trúc thư mục (Phiên bản 0.9.42+) Kể từ phiên bản 0.9.42, tệp i2ptunnel.config mặc định được tự động tách:\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) Khác biệt định dạng quan trọng: - Định dạng nguyên khối: Các thuộc tính có tiền tố tunnel.N. - Định dạng phân tách: Các thuộc tính KHÔNG có tiền tố (ví dụ: description=, không phải tunnel.0.description=)\nHành vi di chuyển Khi chạy lần đầu sau khi nâng cấp lên 0.9.42: 1. Tệp i2ptunnel.config hiện có được đọc 2. Các cấu hình tunnel riêng lẻ được tạo trong i2ptunnel.config.d/ 3. Các thuộc tính được gỡ bỏ tiền tố trong các tệp đã tách 4. Tệp gốc được sao lưu 5. Định dạng cũ vẫn được hỗ trợ để đảm bảo khả năng tương thích ngược\nCác Phần Cấu Hình Cấu hình I2PTunnel được trình bày chi tiết trong phần I2PTunnel Configuration Reference bên dưới. Các mô tả thuộc tính áp dụng cho cả định dạng nguyên khối (tunnel.N.property) và định dạng tách rời (property).\nTham chiếu cấu hình I2PTunnel Phần này cung cấp tài liệu tham chiếu kỹ thuật toàn diện cho tất cả các thuộc tính cấu hình của I2PTunnel. Các thuộc tính được trình bày theo split format (định dạng tách, không có tiền tố tunnel.N.). Đối với monolithic format (định dạng đơn khối), thêm tiền tố tunnel.N. vào tất cả các thuộc tính, trong đó N là số của tunnel.\nQuan trọng: Các thuộc tính được mô tả dưới dạng tunnel.N.option.i2cp.* được triển khai trong I2PTunnel và KHÔNG được hỗ trợ thông qua các giao diện khác như giao thức I2CP hoặc SAM API.\nThuộc tính cơ bản tunnel.N.description (mô tả) Kiểu: Chuỗi Ngữ cảnh: Tất cả tunnels Mô tả: Mô tả tunnel dễ đọc cho con người để hiển thị trong giao diện người dùng (UI) Ví dụ: description=HTTP Proxy for outproxy access tunnel.N.name (tên) Kiểu: Chuỗi Ngữ cảnh: Tất cả tunnels Bắt buộc: Có Mô tả: Định danh tunnel duy nhất và tên hiển thị Ví dụ: name=I2P HTTP Proxy tunnel.N.type (kiểu) Kiểu: Enum Ngữ cảnh: Tất cả các tunnel Bắt buộc: Có Giá trị: client - tunnel client chung httpclient - client proxy HTTP ircclient - tunnel client IRC socksirctunnel - proxy SOCKS IRC sockstunnel - proxy SOCKS (phiên bản 4, 4a, 5) connectclient - client proxy CONNECT streamrclient - client Streamr server - tunnel server chung httpserver - tunnel máy chủ HTTP ircserver - tunnel máy chủ IRC httpbidirserver - máy chủ HTTP hai chiều streamrserver - máy chủ Streamr tunnel.N.interface (giao diện) Loại: Chuỗi (địa chỉ IP hoặc tên máy chủ) Ngữ cảnh: Chỉ áp dụng cho Client tunnels Mặc định: 127.0.0.1 Mô tả: Giao diện cục bộ để lắng nghe cho các kết nối đến Lưu ý bảo mật: Việc bind tới 0.0.0.0 cho phép kết nối từ xa Ví dụ: interface=127.0.0.1 tunnel.N.listenPort (listenPort) Kiểu: Số nguyên Ngữ cảnh: Chỉ dành cho các tunnel (đường hầm) phía client Phạm vi: 1-65535 Mô tả: Cổng cục bộ để lắng nghe cho các kết nối từ client Ví dụ: listenPort=4444 tunnel.N.targetHost (targetHost) Loại: Chuỗi (địa chỉ IP hoặc tên máy chủ) Ngữ cảnh: Chỉ áp dụng cho Server tunnels Mô tả: Máy chủ cục bộ để chuyển tiếp các kết nối đến Ví dụ: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) Kiểu: Số nguyên Ngữ cảnh: Chỉ áp dụng cho tunnel máy chủ Phạm vi: 1-65535 Mô tả: Cổng trên targetHost để kết nối tới Ví dụ: targetPort=80 tunnel.N.targetDestination (targetDestination) Loại: Chuỗi (các đích được phân tách bằng dấu phẩy hoặc khoảng trắng) Ngữ cảnh: Chỉ dành cho client tunnels Định dạng: destination[:port][,destination[:port]] Mô tả: Các đích I2P để kết nối tới Ví dụ: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) Kiểu: Chuỗi (địa chỉ IP hoặc tên máy chủ) Mặc định: 127.0.0.1 Mô tả: địa chỉ giao diện I2CP của router I2P Lưu ý: Bị bỏ qua khi chạy trong ngữ cảnh router Ví dụ: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) Loại: Số nguyên Mặc định: 7654 Phạm vi: 1-65535 Mô tả: Cổng I2CP của router I2P Ghi chú: Bị bỏ qua khi chạy trong ngữ cảnh router Ví dụ: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) Loại: Boolean Mặc định: true Mô tả: Có khởi động tunnel khi I2PTunnel được tải hay không Ví dụ: startOnLoad=true Cấu hình proxy tunnel.N.proxyList (proxyList) Loại: Chuỗi (các tên máy chủ được phân tách bằng dấu phẩy hoặc khoảng trắng) Ngữ cảnh: Chỉ áp dụng cho các proxy HTTP và SOCKS Mô tả: Danh sách các máy chủ outproxy (proxy chuyển tiếp từ I2P ra Internet clearnet) Ví dụ: proxyList=outproxy.example.i2p,backup.example.i2p Cấu hình máy chủ tunnel.N.privKeyFile (privKeyFile) Type: Chuỗi (đường dẫn tệp) Context: Máy chủ và các tunnel máy khách lưu bền Description: Tệp chứa các khóa riêng của đích được lưu bền Path: Tuyệt đối hoặc tương đối so với thư mục cấu hình I2P Example: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) Kiểu: Chuỗi (tên máy chủ) Ngữ cảnh: Chỉ dành cho máy chủ HTTP Mặc định: Tên máy chủ Base32 của điểm đích Mô tả: Giá trị header Host được chuyển tới máy chủ cục bộ Ví dụ: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) Kiểu: String (hostname) Ngữ cảnh: Chỉ dành cho máy chủ HTTP Mô tả: Ghi đè virtual host cho cổng đến cụ thể Trường hợp sử dụng: Lưu trữ nhiều trang web trên các cổng khác nhau Ví dụ: spoofedHost.8080=site1.example.i2p Tùy chọn dành riêng cho ứng dụng khách tunnel.N.sharedClient (sharedClient) Type: Boolean Context: Chỉ dành cho client tunnel Default: false Description: Nhiều client có thể dùng chung tunnel này hay không Example: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) Kiểu: Boolean Ngữ cảnh: Chỉ áp dụng cho Client tunnels Mặc định: false Mô tả: Lưu trữ và tái sử dụng khóa đích qua các lần khởi động lại Xung đột: Loại trừ lẫn nhau với i2cp.newDestOnResume=true Ví dụ: option.persistentClientKey=true Tùy chọn I2CP (Triển khai I2PTunnel) Quan trọng: Các thuộc tính này có tiền tố option.i2cp. nhưng được triển khai trong I2PTunnel, chứ không phải ở lớp giao thức I2CP. Chúng không khả dụng thông qua I2CP hoặc các API của SAM.\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) Kiểu: Boolean Ngữ cảnh: Chỉ áp dụng cho tunnel phía máy khách Mặc định: false Mô tả: Trì hoãn việc tạo tunnel cho đến khi có kết nối đầu tiên Trường hợp sử dụng: Tiết kiệm tài nguyên cho các tunnel ít khi được sử dụng Ví dụ: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) Loại: Boolean Ngữ cảnh: Chỉ dành cho Client tunnels Mặc định: false Yêu cầu: i2cp.closeOnIdle=true Xung đột: Không thể dùng đồng thời với persistentClientKey=true Mô tả: Tạo destination (điểm đích) mới sau khi hết thời gian không hoạt động Ví dụ: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) Loại: Chuỗi (khóa được mã hóa Base64) Ngữ cảnh: Chỉ dành cho server tunnels Mô tả: Khóa mã hóa leaseset riêng tư thường trực Trường hợp sử dụng: Duy trì leaseset được mã hóa nhất quán qua các lần khởi động lại Ví dụ: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) Kiểu: Chuỗi (sigtype:base64) Ngữ cảnh: Chỉ áp dụng cho tunnel máy chủ Định dạng: sigtype:base64key Mô tả: Khóa riêng để ký leaseset cố định Ví dụ: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... Tùy chọn dành riêng cho máy chủ tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) Kiểu: Boolean (kiểu logic đúng/sai) Ngữ cảnh: Chỉ áp dụng cho server tunnels Mặc định: false Mô tả: Sử dụng địa chỉ IP cục bộ duy nhất cho mỗi đích I2P từ xa Trường hợp sử dụng: Theo dõi địa chỉ IP của máy khách trong nhật ký máy chủ Lưu ý bảo mật: Có thể làm giảm tính ẩn danh Ví dụ: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) Kiểu: Chuỗi (tên máy chủ:cổng) Ngữ cảnh: Chỉ dành cho tunnel máy chủ Mô tả: Ghi đè targetHost/targetPort đối với cổng đến NNNN Trường hợp sử dụng: Định tuyến theo cổng tới các dịch vụ cục bộ khác nhau Ví dụ: option.targetForPort.8080=localhost:8080 Cấu hình Thread Pool (nhóm luồng) tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) Loại: Boolean Ngữ cảnh: Chỉ dành cho server tunnels Mặc định: true Mô tả: Sử dụng pool luồng để xử lý kết nối Lưu ý: Luôn là false đối với standard servers (bị bỏ qua) Ví dụ: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) Loại: Số nguyên Ngữ cảnh: Chỉ áp dụng cho các tunnel máy chủ Mặc định: 65 Mô tả: Kích thước tối đa của pool luồng (thread pool) Lưu ý: Bị bỏ qua đối với các máy chủ tiêu chuẩn Ví dụ: option.i2ptunnel.blockingHandlerCount=100 Tùy chọn máy khách HTTP tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) Kiểu: Boolean Ngữ cảnh: Chỉ áp dụng cho client HTTP Mặc định: false Mô tả: Cho phép kết nối SSL tới các địa chỉ .i2p Ví dụ: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) Kiểu: Boolean (đúng/sai) Ngữ cảnh: Chỉ dành cho máy khách HTTP Mặc định: false Mô tả: Vô hiệu hóa các liên kết trợ giúp địa chỉ trong phản hồi của proxy Ví dụ: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) Type: Chuỗi (các URL được phân tách bằng dấu phẩy hoặc khoảng trắng) Context: Chỉ áp dụng cho HTTP client Description: Các URL Jump server (máy chủ Jump hỗ trợ phân giải tên) dùng để phân giải tên máy chủ (hostname) Example: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) Kiểu: Boolean Ngữ cảnh: Chỉ dành cho client HTTP Mặc định: false Mô tả: Chuyển tiếp các header Accept-* (ngoại trừ Accept và Accept-Encoding) Ví dụ: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) Loại: Boolean Ngữ cảnh: Chỉ áp dụng cho client HTTP Mặc định: false Mô tả: Chuyển tiếp các header Referer qua proxy Lưu ý về quyền riêng tư: Có thể làm rò rỉ thông tin Ví dụ: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) Kiểu: Boolean Ngữ cảnh: Chỉ dành cho máy khách HTTP Mặc định: false Mô tả: Chuyển tiếp các tiêu đề User-Agent qua proxy Lưu ý về quyền riêng tư: Có thể làm lộ thông tin trình duyệt Ví dụ: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) Loại: Boolean Ngữ cảnh: Chỉ áp dụng cho máy khách HTTP Mặc định: false Mô tả: Cho phép chuyển tiếp các tiêu đề Via qua proxy Ví dụ: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) Kiểu: String (các đích được phân tách bằng dấu phẩy hoặc khoảng trắng) Ngữ cảnh: Chỉ áp dụng cho client HTTP Mô tả: Các outproxies (proxy thoát) SSL nội mạng cho HTTPS Ví dụ: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) Loại: Boolean Ngữ cảnh: Chỉ áp dụng cho các HTTP client Mặc định: true Mô tả: Sử dụng các plugin outproxy (proxy ra ngoài tới clearnet) cục bộ đã được đăng ký Ví dụ: option.i2ptunnel.useLocalOutproxy=true Xác thực máy khách HTTP tunnel.N.option.proxyAuth (option.proxyAuth) Kiểu: Enum Ngữ cảnh: Chỉ dành cho client HTTP Mặc định: false Giá trị: true, false, basic, digest Mô tả: Yêu cầu xác thực cục bộ để truy cập proxy Lưu ý: true tương đương với basic Ví dụ: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) Kiểu: Chuỗi (hex chữ thường 32 ký tự) Ngữ cảnh: Chỉ dành cho client HTTP Yêu cầu: proxyAuth=basic hoặc proxyAuth=digest Mô tả: Giá trị băm MD5 của mật khẩu cho người dùng USER Không dùng nữa: Sử dụng SHA-256 thay thế (0.9.56+) Ví dụ: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) Kiểu: Chuỗi (64 ký tự hex chữ thường) Ngữ cảnh: Chỉ dành cho client HTTP Yêu cầu: proxyAuth=digest Kể từ: Phiên bản 0.9.56 Tiêu chuẩn: RFC 7616 Mô tả: Giá trị băm SHA-256 của mật khẩu cho người dùng USER Ví dụ: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 Xác thực Outproxy tunnel.N.option.outproxyAuth (option.outproxyAuth) Kiểu: Boolean Ngữ cảnh: Chỉ dành cho máy khách HTTP Mặc định: false Mô tả: Gửi thông tin xác thực tới outproxy (proxy chuyển tiếp ra Internet bên ngoài I2P) Ví dụ: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) Kiểu: String Ngữ cảnh: Chỉ dành cho client HTTP Yêu cầu: outproxyAuth=true Mô tả: Tên người dùng cho xác thực outproxy (proxy ra Internet công khai) Ví dụ: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) Kiểu: Chuỗi Ngữ cảnh: Chỉ dành cho client HTTP Yêu cầu: outproxyAuth=true Mô tả: Mật khẩu cho xác thực outproxy (proxy đi ra Internet công khai) Bảo mật: Được lưu ở dạng văn bản thuần Ví dụ: option.outproxyPassword=secret Tùy chọn máy khách SOCKS tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) Kiểu: Chuỗi (các đích đến được phân tách bằng dấu phẩy hoặc dấu cách) Ngữ cảnh: chỉ dành cho client SOCKS Mô tả: Các outproxy (proxy thoát từ I2P ra Internet công khai) trong mạng cho các cổng không được chỉ định Ví dụ: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) Loại: Chuỗi (các đích được phân tách bằng dấu phẩy hoặc khoảng trắng) Ngữ cảnh: Chỉ dành cho client SOCKS Mô tả: Các outproxy (proxy đi ra) trong mạng dành riêng cho cổng NNNN Ví dụ: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) Kiểu: Enum (kiểu liệt kê) Ngữ cảnh: Chỉ dành cho client SOCKS Mặc định: socks Từ: Phiên bản 0.9.57 Giá trị: socks, connect (HTTPS) Mô tả: Loại outproxy (proxy ra ngoài) đã được cấu hình Ví dụ: option.outproxyType=connect Các tùy chọn máy chủ HTTP tunnel.N.option.maxPosts (option.maxPosts) Type: Số nguyên Context: Chỉ áp dụng cho máy chủ HTTP Default: 0 (không giới hạn) Description: Số yêu cầu POST tối đa từ một destination (địa chỉ đích I2P) trong mỗi postCheckTime Example: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) Kiểu: Số nguyên Ngữ cảnh: Chỉ máy chủ HTTP Mặc định: 0 (không giới hạn) Mô tả: Số yêu cầu POST tối đa từ tất cả các đích mỗi postCheckTime Ví dụ: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) Loại: Số nguyên (giây) Ngữ cảnh: Chỉ máy chủ HTTP Mặc định: 300 Mô tả: Khoảng thời gian để kiểm tra giới hạn POST Ví dụ: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) Kiểu: Số nguyên (giây) Ngữ cảnh: Chỉ áp dụng cho máy chủ HTTP Mặc định: 1800 Mô tả: Thời lượng cấm áp dụng cho một destination (đích I2P) sau khi vượt quá maxPosts Ví dụ: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) Loại: Số nguyên (giây) Ngữ cảnh: Chỉ dành cho máy chủ HTTP Mặc định: 600 Mô tả: Thời gian cấm sau khi vượt quá maxTotalPosts Ví dụ: option.postTotalBanTime=1200 Tùy chọn bảo mật máy chủ HTTP tunnel.N.option.rejectInproxy (option.rejectInproxy) Kiểu: Boolean Ngữ cảnh: Chỉ dành cho máy chủ HTTP Mặc định: false Mô tả: Từ chối các kết nối có vẻ đi qua một inproxy (proxy vào) Ví dụ: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) Kiểu: Boolean Ngữ cảnh: Chỉ dành cho máy chủ HTTP Mặc định: false Từ: Phiên bản 0.9.25 Mô tả: Từ chối các kết nối có header Referer Ví dụ: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) Loại: Boolean Ngữ cảnh: Chỉ dành cho máy chủ HTTP Mặc định: false Từ phiên bản: 0.9.25 Yêu cầu: thuộc tính userAgentRejectList Mô tả: Từ chối các kết nối có User-Agent trùng khớp Ví dụ: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) Kiểu: Chuỗi (các chuỗi so khớp, phân tách bằng dấu phẩy) Ngữ cảnh: Chỉ áp dụng cho máy chủ HTTP Kể từ: Phiên bản 0.9.25 Phân biệt hoa/thường: So khớp phân biệt hoa/thường Đặc biệt: \u0026ldquo;none\u0026rdquo; (từ 0.9.33) khớp với User-Agent trống Mô tả: Danh sách các mẫu User-Agent cần từ chối Ví dụ: option.userAgentRejectList=Mozilla,Opera,none Tùy chọn máy chủ IRC tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) Loại: Chuỗi (mẫu tên máy chủ) Ngữ cảnh: Chỉ dành cho máy chủ IRC Mặc định: %f.b32.i2p Token: %f = Băm đích base32 đầy đủ %c = Băm đích được che (xem cloakKey) Mô tả: Định dạng tên máy chủ được gửi tới máy chủ IRC Ví dụ: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) Loại: Chuỗi (cụm mật khẩu) Ngữ cảnh: Chỉ dành cho máy chủ IRC Mặc định: Ngẫu nhiên cho mỗi phiên Hạn chế: Không dùng dấu ngoặc kép hoặc khoảng trắng Mô tả: Cụm mật khẩu để che giấu tên máy chủ một cách nhất quán Trường hợp sử dụng: Nhận diện người dùng bền vững qua các lần khởi động lại/giữa các máy chủ Ví dụ: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) Kiểu: Enum (kiểu liệt kê) Ngữ cảnh: Chỉ dành cho máy chủ IRC Mặc định: user Giá trị: user, webirc Mô tả: Phương thức xác thực cho máy chủ IRC Ví dụ: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) Kiểu: Chuỗi (mật khẩu) Ngữ cảnh: Chỉ áp dụng cho máy chủ IRC Yêu cầu: method=webirc Hạn chế: Không được có dấu ngoặc kép hoặc khoảng trắng Mô tả: Mật khẩu để xác thực theo giao thức WEBIRC Ví dụ: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) Loại: Chuỗi (địa chỉ IP) Ngữ cảnh: Chỉ dành cho máy chủ IRC Yêu cầu: method=webirc Mô tả: Địa chỉ IP giả mạo cho giao thức WEBIRC Ví dụ: option.ircserver.webircSpoofIP=10.0.0.1 Cấu hình SSL/TLS tunnel.N.option.useSSL (option.useSSL) Kiểu: Boolean Mặc định: false Ngữ cảnh: Tất cả tunnel Hành vi: Máy chủ: Sử dụng SSL cho các kết nối đến máy chủ cục bộ Máy khách: Yêu cầu SSL từ các máy khách cục bộ Ví dụ: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) Kiểu: Chuỗi (đường dẫn tệp) Ngữ cảnh: Chỉ áp dụng cho Client tunnels Mặc định: i2ptunnel-(random).ks Đường dẫn: Tương đối so với $(I2P_CONFIG_DIR)/keystore/ nếu không phải đường dẫn tuyệt đối Tự động tạo: Sẽ được tạo nếu chưa tồn tại Mô tả: Tệp keystore (kho khóa) chứa khóa riêng SSL Ví dụ: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) Type: Chuỗi (mật khẩu) Context: Chỉ áp dụng cho client tunnels Default: changeit Auto-generated: Mật khẩu ngẫu nhiên nếu keystore (kho khóa) mới được tạo Description: Mật khẩu cho keystore SSL Example: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) Kiểu: String (bí danh) Ngữ cảnh: Chỉ dành cho Client tunnels Tự động tạo: Được tạo khi có khóa mới Mô tả: Bí danh cho khóa riêng trong keystore (kho lưu trữ khóa) Ví dụ: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) Loại: Chuỗi (mật khẩu) Ngữ cảnh: Chỉ áp dụng cho client tunnels Tự động tạo: Mật khẩu ngẫu nhiên nếu tạo khóa mới Mô tả: Mật khẩu cho khóa riêng trong keystore (kho lưu trữ khóa) Ví dụ: option.keyPassword=keypass123 Tùy chọn chung cho I2CP và Streaming Tất cả các thuộc tính tunnel.N.option.* (không được tài liệu hóa cụ thể ở trên) được chuyển tiếp tới giao diện I2CP và streaming library (thư viện truyền dữ liệu dạng luồng) sau khi bỏ tiền tố tunnel.N.option..\nQuan trọng: Chúng tách biệt với các tùy chọn dành riêng cho I2PTunnel. Tham khảo: - Đặc tả I2CP - Đặc tả Thư viện Streaming Ví dụ về các tùy chọn streaming (truyền dữ liệu dạng luồng):\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 Ví dụ Tunnel (đường hầm) hoàn chỉnh # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 Lịch sử phiên bản và mốc thời gian tính năng Phiên bản 0.9.10 (2013) Tính năng: Hỗ trợ giá trị rỗng trong các tệp cấu hình - Các khóa có giá trị rỗng (key=) hiện được hỗ trợ - Trước đây bị bỏ qua hoặc gây lỗi phân tích cú pháp\nPhiên bản 0.9.18 (2015) Tính năng: Cấu hình khoảng thời gian flush (xả bộ đệm) của logger - Thuộc tính: logger.flushInterval (mặc định 29 giây) - Giảm I/O đĩa đồng thời duy trì độ trễ ghi log ở mức chấp nhận được\nPhiên bản 0.9.23 (Tháng 11 năm 2015) Thay đổi lớn: Yêu cầu tối thiểu là Java 7 - Hỗ trợ cho Java 6 đã kết thúc - Bắt buộc để tiếp tục nhận các bản cập nhật bảo mật\nPhiên bản 0.9.25 (2015) Tính năng: các tùy chọn bảo mật của máy chủ HTTP - tunnel.N.option.rejectReferer - Từ chối các kết nối có tiêu đề Referer - tunnel.N.option.rejectUserAgents - Từ chối các tiêu đề User-Agent cụ thể - tunnel.N.option.userAgentRejectList - Các mẫu User-Agent cần từ chối - Trường hợp sử dụng: Giảm thiểu trình thu thập dữ liệu và máy khách không mong muốn\nPhiên bản 0.9.33 (Tháng 1 năm 2018) Tính năng: Lọc User-Agent nâng cao - chuỗi userAgentRejectList \u0026ldquo;none\u0026rdquo; khớp với User-Agent rỗng - Các bản sửa lỗi bổ sung cho i2psnark, i2ptunnel, streaming, SusiMail\nPhiên bản 0.9.41 (2019) Ngừng hỗ trợ: BOB Protocol (giao thức BOB) đã bị loại bỏ khỏi Android - người dùng Android phải chuyển sang SAM hoặc I2CP\nPhiên bản 0.9.42 (Tháng 8 năm 2019) Thay đổi lớn: Phân tách tệp cấu hình - clients.config được tách thành cấu trúc thư mục clients.config.d/ - i2ptunnel.config được tách thành cấu trúc thư mục i2ptunnel.config.d/ - Chuyển đổi tự động khi chạy lần đầu sau khi nâng cấp - Cho phép đóng gói mô-đun và quản lý plugin - Vẫn hỗ trợ định dạng nguyên khối cũ\nCác tính năng bổ sung: - Cải thiện hiệu năng cho SSU - Ngăn chặn chéo mạng (Đề xuất 147) - Hỗ trợ kiểu mã hóa ban đầu\nPhiên bản 0.9.56 (2021) Tính năng: Cải thiện bảo mật và ghi nhật ký - logger.gzip - Nén Gzip cho nhật ký xoay vòng (mặc định: false) - logger.minGzipSize - Kích thước tối thiểu để nén (mặc định: 65536 byte) - tunnel.N.option.proxy.auth.USER.sha256 - digest authentication (xác thực dạng băm) bằng SHA-256 (RFC 7616) - Bảo mật: SHA-256 thay thế MD5 cho digest authentication\nPhiên bản 0.9.57 (tháng 1 năm 2023) Tính năng: Cấu hình loại outproxy (proxy ra ngoài) SOCKS - tunnel.N.option.outproxyType - Chọn loại outproxy (socks|connect) - Mặc định: socks - Hỗ trợ HTTPS CONNECT cho các outproxy HTTPS\nPhiên bản 2.6.0 (Tháng 7 năm 2024) Thay đổi không tương thích: I2P-over-Tor bị chặn - Kết nối từ các địa chỉ IP của Tor exit node (nút thoát) hiện bị từ chối - Lý do: Làm suy giảm hiệu năng I2P, lãng phí tài nguyên của các Tor exit node - Tác động: Người dùng truy cập I2P thông qua các Tor exit node sẽ bị chặn - Các nút chuyển tiếp không phải exit và ứng dụng khách Tor không bị ảnh hưởng\nPhiên bản 2.10.0 (Tháng 9 năm 2025 - Hiện tại) Tính năng chính: - Mật mã hậu lượng tử khả dụng (tùy chọn bật qua Hidden Service Manager) - Hỗ trợ tracker UDP cho I2PSnark để giảm tải cho tracker - Cải thiện độ ổn định của Hidden Mode để giảm tình trạng cạn kiệt RouterInfo - Cải thiện mạng cho router bị tắc nghẽn - Tăng cường khả năng xuyên qua UPnP/NAT - Cải tiến NetDB với việc loại bỏ leaseset quyết liệt - Giảm khả năng quan sát đối với các sự kiện của router\nCấu hình: Không có thuộc tính cấu hình mới nào được thêm\nThay đổi quan trọng sắp tới: Bản phát hành tiếp theo (nhiều khả năng là 2.11.0 hoặc 3.0.0) sẽ yêu cầu Java 17 trở lên\nNgừng hỗ trợ và thay đổi phá vỡ tương thích Những tính năng ngừng hỗ trợ quan trọng Truy cập I2P-over-Tor (Phiên bản 2.6.0+) Trạng thái: Bị chặn từ tháng 7 năm 2024 Tác động: Các kết nối từ IP của các nút thoát Tor bị từ chối Lý do: Làm giảm hiệu năng của mạng I2P mà không mang lại lợi ích về tính ẩn danh Phạm vi ảnh hưởng: Chỉ ảnh hưởng đến các nút thoát Tor, không ảnh hưởng đến các relay hoặc client Tor thông thường Phương án thay thế: Sử dụng I2P hoặc Tor riêng biệt, không kết hợp Xác thực Digest MD5 Trạng thái: Không dùng nữa (hãy dùng SHA-256) Thuộc tính: tunnel.N.option.proxy.auth.USER.md5 Lý do: MD5 đã bị phá vỡ về mặt mật mã Thay thế: tunnel.N.option.proxy.auth.USER.sha256 (từ 0.9.56) Mốc thời gian: MD5 vẫn được hỗ trợ nhưng không được khuyến nghị Các thay đổi trong kiến trúc cấu hình Tệp cấu hình nguyên khối (Phiên bản 0.9.42+) Bị ảnh hưởng: clients.config, i2ptunnel.config Trạng thái: Không còn được khuyến nghị; ưu tiên dùng cấu trúc thư mục phân tách Chuyển đổi: Tự động khi chạy lần đầu sau khi nâng cấp lên 0.9.42 Tương thích: Định dạng cũ vẫn hoạt động (tương thích ngược) Khuyến nghị: Dùng định dạng phân tách cho các cấu hình mới Yêu cầu về phiên bản Java Hỗ trợ Java 6 Đã kết thúc: Phiên bản 0.9.23 (Tháng 11 năm 2015) Tối thiểu: Yêu cầu Java 7 kể từ 0.9.23 Yêu cầu Java 17 (Sắp tới) Trạng thái: THAY ĐỔI QUAN TRỌNG SẮP TỚI Mục tiêu: Bản phát hành lớn tiếp theo sau 2.10.0 (nhiều khả năng là 2.11.0 hoặc 3.0.0) Yêu cầu tối thiểu hiện tại: Java 8 Hành động cần thiết: Chuẩn bị cho việc chuyển sang Java 17 Mốc thời gian: Sẽ được công bố cùng với ghi chú phát hành Các tính năng đã bị loại bỏ Giao thức BOB (Android) Đã loại bỏ: Kể từ phiên bản 0.9.41 Nền tảng: Chỉ dành cho Android Thay thế: các giao thức SAM (Simple Anonymous Messaging — giao thức nhắn tin ẩn danh đơn giản của I2P) hoặc I2CP Máy tính để bàn: BOB (giao thức BOB của I2P) vẫn khả dụng trên các nền tảng máy tính để bàn Các di chuyển được khuyến nghị Xác thực: Chuyển từ xác thực Digest dùng MD5 sang dùng SHA-256 Định dạng cấu hình: Chuyển sang cấu trúc thư mục tách biệt cho máy khách và tunnels Java Runtime: Lên kế hoạch nâng cấp lên Java 17 trước bản phát hành lớn tiếp theo Tích hợp Tor: Không định tuyến I2P qua các exit node (nút thoát) của Tor Tài liệu tham khảo Tài liệu chính thức Đặc tả cấu hình I2P - Đặc tả chính thức về định dạng tệp cấu hình Đặc tả plugin I2P - Cấu hình và đóng gói plugin Cấu trúc chung của I2P - Ánh xạ kiểu dữ liệu - Định dạng tuần tự hóa dữ liệu giao thức Định dạng Java Properties - Đặc tả định dạng cơ sở Mã nguồn Kho lưu trữ Router I2P (Java) - Bản sao phản chiếu trên GitHub I2P Developers Gitea - Kho mã nguồn chính thức của I2P DataHelper.java - Triển khai I/O (nhập/xuất) cho tệp cấu hình Tài nguyên cộng đồng I2P Forum - Thảo luận cộng đồng sôi nổi và hỗ trợ I2P Website - Trang web chính thức của dự án Tài liệu API DataHelper JavaDoc - tài liệu API cho các phương thức của tệp cấu hình Trạng thái của đặc tả Cập nhật đặc tả lần cuối: Tháng 1 năm 2023 (Phiên bản 0.9.57) Phiên bản I2P hiện tại: 2.10.0 (Tháng 9 năm 2025) Độ chính xác kỹ thuật: Đặc tả vẫn chính xác đến 2.10.0 (không có thay đổi phá vỡ tương thích) Bảo trì: Tài liệu sống được cập nhật khi định dạng cấu hình được sửa đổi ","description":"Các tùy chọn cấu hình và định dạng dành cho I2P routers và máy khách","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"Cấu hình Router","url":"/vi/docs/specs/configuration/"},{"categories":null,"content":"Hướng dẫn này chỉ ra cách cấu hình các trình duyệt phổ biến để gửi lưu lượng truy cập qua HTTP proxy tích hợp sẵn của I2P. Hướng dẫn bao gồm Safari, Firefox và các trình duyệt Chrome/Chromium với các bước chi tiết từng bước.\nLưu ý quan trọng:\nProxy HTTP mặc định của I2P lắng nghe trên 127.0.0.1:4444. I2P bảo vệ lưu lượng bên trong mạng I2P (các trang .i2p). Đảm bảo router I2P của bạn đang chạy trước khi cấu hình trình duyệt. Safari (macOS) Safari sử dụng cài đặt proxy toàn hệ thống trên macOS.\nStep 1: Open Network Settings Mở Safari và vào Safari → Settings (hoặc Preferences) Nhấp vào tab Advanced Trong phần Proxies, nhấp Change Settings\u0026hellip; Thao tác này sẽ mở cài đặt mạng hệ thống trên Mac của bạn.\nBước 1: Mở Cài đặt Mạng Trong phần cài đặt Network, đánh dấu vào ô Web Proxy (HTTP) Nhập các thông tin sau: Web Proxy Server: 127.0.0.1 Port: 4444 Nhấn OK để lưu cài đặt của bạn Bây giờ bạn có thể duyệt các trang .i2p trên Safari!\nLưu ý: Các cài đặt proxy này sẽ ảnh hưởng đến tất cả ứng dụng sử dụng proxy hệ thống của macOS. Hãy cân nhắc tạo một tài khoản người dùng riêng hoặc sử dụng một trình duyệt khác chỉ dành riêng cho I2P nếu bạn muốn tách biệt hoạt động duyệt web qua I2P.\nFirefox (Desktop) Firefox có cài đặt proxy riêng độc lập với hệ thống, khiến nó trở thành lựa chọn lý tưởng cho việc duyệt web I2P chuyên dụng.\nBước 2: Cấu hình HTTP Proxy Nhấp vào nút menu (☰) ở góc trên bên phải Chọn Settings Step 2: Find Proxy Settings Trong hộp tìm kiếm Settings, gõ \u0026ldquo;proxy\u0026rdquo; Cuộn xuống Network Settings Nhấp vào nút Settings\u0026hellip; Bước 1: Mở Cài đặt Chọn Cấu hình proxy thủ công Nhập thông tin sau: HTTP Proxy: 127.0.0.1 Port: 4444 Để trống SOCKS Host (trừ khi bạn cần dùng SOCKS proxy) Đánh dấu Proxy DNS when using SOCKS chỉ khi sử dụng SOCKS proxy Nhấn OK để lưu Bây giờ bạn có thể duyệt các trang web .i2p trên Firefox!\nMẹo: Hãy cân nhắc tạo một profile Firefox riêng biệt dành cho việc duyệt web I2P. Điều này giúp tách biệt hoạt động duyệt web I2P của bạn khỏi việc duyệt web thông thường. Để tạo profile, gõ about:profiles vào thanh địa chỉ của Firefox.\nChrome / Chromium (Desktop) Chrome và các trình duyệt dựa trên Chromium (Brave, Edge, v.v.) thường sử dụng cài đặt proxy hệ thống trên Windows và macOS. Hướng dẫn này trình bày cấu hình trên Windows.\nBước 2: Tìm Cài Đặt Proxy Nhấp vào menu ba chấm (⋮) ở góc trên bên phải Chọn Settings Bước 3: Cấu hình Proxy Thủ công Trong hộp tìm kiếm Settings, gõ \u0026ldquo;proxy\u0026rdquo; Nhấp vào Open your computer\u0026rsquo;s proxy settings Step 3: Open Manual Proxy Setup Thao tác này sẽ mở cài đặt Mạng \u0026amp; Internet của Windows.\nCuộn xuống Thiết lập proxy thủ công Nhấp vào Thiết lập Bước 1: Mở Chrome Settings Chuyển Use a proxy server sang On Nhập các thông tin sau: Proxy IP address: 127.0.0.1 Port: 4444 Tùy chọn, thêm các ngoại lệ vào \u0026ldquo;Don\u0026rsquo;t use the proxy server for addresses beginning with\u0026rdquo; (ví dụ: localhost;127.*) Nhấn Save Bây giờ bạn có thể duyệt các trang .i2p trong Chrome!\nLưu ý: Các cài đặt này ảnh hưởng đến tất cả trình duyệt dựa trên Chromium và một số ứng dụng khác trên Windows. Để tránh điều này, hãy cân nhắc sử dụng Firefox với profile I2P riêng biệt.\nBước 2: Mở Cài đặt Proxy Trên Linux, bạn có thể khởi chạy Chrome/Chromium với các cờ proxy để tránh thay đổi cài đặt hệ thống:\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; Hoặc tạo một script khởi chạy trên desktop:\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; Cờ --user-data-dir tạo một hồ sơ Chrome riêng biệt cho việc duyệt web I2P.\nFirefox (Desktop) Các bản build Firefox \u0026ldquo;Fenix\u0026rdquo; hiện đại giới hạn about:config và extensions theo mặc định. IceRaven là một nhánh rẽ của Firefox cho phép một tập hợp extensions được tuyển chọn, giúp việc thiết lập proxy trở nên đơn giản.\nCấu hình dựa trên extension (IceRaven):\nNếu bạn đã sử dụng IceRaven, hãy cân nhắc xóa lịch sử duyệt web trước (Menu → History → Delete History). 2) Mở Menu → Add‑Ons → Add‑Ons Manager. 3) Cài đặt tiện ích mở rộng \u0026ldquo;I2P Proxy for Android and Other Systems\u0026rdquo;. 4) Trình duyệt bây giờ sẽ proxy qua I2P. Tiện ích mở rộng này cũng hoạt động trên các trình duyệt dựa trên Firefox phiên bản pre-Fenix nếu được cài đặt từ AMO .\nViệc bật hỗ trợ extension rộng rãi trong Firefox Nightly yêu cầu một quy trình riêng được tài liệu hóa bởi Mozilla .\nInternet Explorer / Windows System Proxy Trên Windows, hộp thoại proxy hệ thống áp dụng cho IE và có thể được sử dụng bởi các trình duyệt dựa trên Chromium khi chúng kế thừa cài đặt hệ thống.\nMở \u0026ldquo;Network and Internet Settings\u0026rdquo; → \u0026ldquo;Proxy\u0026rdquo;. 2) Bật \u0026ldquo;Use a proxy server for your LAN\u0026rdquo;. 3) Đặt địa chỉ 127.0.0.1, cổng 4444 cho HTTP.. 4) Tùy chọn đánh dấu \u0026ldquo;Bypass proxy server for local addresses\u0026rdquo;. ","description":"Cấu hình các trình duyệt phổ biến để sử dụng HTTP/HTTPS proxy của I2P trên máy tính để bàn và Android","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"Cấu hình Trình duyệt Web","url":"/vi/docs/guides/browser-config/"},{"categories":null,"content":"Trợ giúp Router I2P I2P chạy trên hệ thống nào? I2P được viết bằng ngôn ngữ lập trình Java. Nó đã được kiểm tra trên Windows, Linux, FreeBSD và OSX. Phiên bản Android cũng đã có sẵn.\nVề mức sử dụng bộ nhớ, I2P được cấu hình sử dụng 128 MB RAM theo mặc định. Dung lượng này đủ cho việc duyệt web và sử dụng IRC. Tuy nhiên, các hoạt động khác có thể yêu cầu phân bổ bộ nhớ lớn hơn. Ví dụ, nếu muốn chạy một router băng thông cao, tham gia torrent trên I2P hoặc cung cấp các dịch vụ ẩn có lưu lượng truy cập cao, sẽ cần một lượng bộ nhớ lớn hơn.\nVề mức sử dụng CPU, I2P đã được thử nghiệm chạy trên các hệ thống khiêm tốn như dòng máy tính đơn board Raspberry Pi. Do I2P sử dụng nhiều kỹ thuật mã hóa, CPU mạnh hơn sẽ phù hợp hơn để xử lý khối lượng công việc do I2P tạo ra cũng như các tác vụ liên quan đến phần còn lại của hệ thống (tức là Hệ điều hành, GUI, Các tiến trình khác như Duyệt Web).\nKhuyến nghị sử dụng Sun/Oracle Java hoặc OpenJDK.\nCó bắt buộc phải cài đặt Java để sử dụng I2P không? Có, Java là bắt buộc để sử dụng I2P Core. Chúng tôi đã tích hợp Java bên trong các trình cài đặt dễ dàng cho Windows, Mac OSX và Linux. Nếu bạn đang chạy ứng dụng I2P Android, bạn cũng sẽ cần một môi trường chạy Java như Dalvik hoặc ART được cài đặt trong hầu hết các trường hợp.\n\u0026ldquo;I2P Site\u0026rdquo; là gì và làm thế nào để cấu hình trình duyệt của tôi để có thể sử dụng chúng? Một I2P Site là một trang web bình thường ngoại trừ việc nó được lưu trữ bên trong I2P. Các I2P site có địa chỉ trông giống như địa chỉ internet thông thường, kết thúc bằng \u0026ldquo;.i2p\u0026rdquo; theo cách dễ đọc cho con người và không mã hóa, vì lợi ích của mọi người. Việc thực sự kết nối đến một I2P Site yêu cầu mã hóa, có nghĩa là địa chỉ I2P Site cũng là các Destination \u0026ldquo;Base64\u0026rdquo; dài và các địa chỉ \u0026ldquo;B32\u0026rdquo; ngắn hơn. Bạn có thể cần thực hiện cấu hình bổ sung để duyệt web chính xác. Việc duyệt các I2P Site sẽ yêu cầu kích hoạt HTTP Proxy trong cài đặt I2P của bạn và sau đó cấu hình trình duyệt của bạn để sử dụng nó. Để biết thêm thông tin, hãy xem phần \u0026ldquo;Trình duyệt\u0026rdquo; bên dưới hoặc Hướng dẫn \u0026ldquo;Cấu hình Trình duyệt\u0026rdquo;.\nCác số Active x/y trong bảng điều khiển router có nghĩa là gì? Trên trang Peers (Các nút mạng) trong bảng điều khiển router của bạn, bạn có thể thấy hai con số - Active x/y. Số đầu tiên là số lượng peers mà bạn đã gửi hoặc nhận tin nhắn trong vài phút gần đây. Số thứ hai là số lượng peers được nhìn thấy gần đây, con số này sẽ luôn lớn hơn hoặc bằng số đầu tiên.\nRouter của tôi có rất ít peer (nút mạng) hoạt động, điều này có ổn không? Có, điều này có thể bình thường, đặc biệt khi router vừa mới được khởi động. Các router mới sẽ cần thời gian để khởi động và kết nối với phần còn lại của mạng. Để giúp cải thiện tích hợp mạng, thời gian hoạt động và hiệu suất, hãy xem xét các cài đặt sau:\nChia sẻ băng thông - Nếu một router được cấu hình để chia sẻ băng thông, nó sẽ định tuyến nhiều lưu lượng hơn cho các router khác, điều này giúp tích hợp nó với phần còn lại của mạng, cũng như cải thiện hiệu suất kết nối cục bộ của bạn. Điều này có thể được cấu hình trên trang http://localhost:7657/config . Giao diện mạng - Đảm bảo không có giao diện nào được chỉ định trên trang http://localhost:7657/confignet . Điều này có thể làm giảm hiệu suất trừ khi máy tính của bạn có nhiều kết nối với nhiều địa chỉ IP bên ngoài. Giao thức I2NP - Đảm bảo router được cấu hình để mong đợi kết nối trên một giao thức hợp lệ cho hệ điều hành của máy chủ và cài đặt mạng trống (Nâng cao). Không nhập địa chỉ IP vào trường \u0026lsquo;Hostname\u0026rsquo; trong trang cấu hình Mạng. Giao thức I2NP mà bạn chọn ở đây sẽ chỉ được sử dụng nếu bạn chưa có địa chỉ có thể truy cập được. Ví dụ, hầu hết các kết nối không dây 4G và 5G của Verizon tại Hoa Kỳ chặn UDP và không thể truy cập qua nó. Những người khác sẽ buộc sử dụng UDP ngay cả khi nó có sẵn cho họ. Hãy chọn một cài đặt hợp lý từ danh sách các Giao thức I2NP được liệt kê. Tôi phản đối một số loại nội dung nhất định. Làm thế nào để tránh phân phối, lưu trữ hoặc truy cập chúng? Không có nội dung nào như vậy được cài đặt mặc định. Tuy nhiên, vì I2P là một mạng ngang hàng (peer-to-peer), có khả năng bạn có thể vô tình gặp phải nội dung bị cấm. Dưới đây là tóm tắt về cách I2P ngăn chặn bạn khỏi bị liên quan không cần thiết đến các vi phạm niềm tin của bạn.\nPhân phối - Lưu lượng truy cập nội bộ trong mạng I2P, bạn không phải là exit node (được gọi là outproxy trong tài liệu của chúng tôi). Lưu trữ - Mạng I2P không thực hiện lưu trữ phân tán nội dung, điều này phải được cài đặt và cấu hình cụ thể bởi người dùng (ví dụ với Tahoe-LAFS). Đó là tính năng của một mạng ẩn danh khác, Freenet . Khi chạy I2P router, bạn không lưu trữ nội dung cho bất kỳ ai. Truy cập - Router của bạn sẽ không yêu cầu bất kỳ nội dung nào nếu không có chỉ thị cụ thể từ bạn. Có thể chặn I2P không? Có, cách dễ nhất và phổ biến nhất là chặn các máy chủ bootstrap hoặc máy chủ \u0026ldquo;Reseed\u0026rdquo;. Chặn hoàn toàn tất cả lưu lượng được làm rối cũng có thể hoạt động (mặc dù điều này sẽ làm hỏng rất nhiều thứ khác không phải I2P và hầu hết không sẵn lòng đi xa đến vậy). Trong trường hợp chặn reseed, có một gói reseed trên Github, việc chặn nó cũng sẽ chặn Github. Bạn có thể reseed qua proxy (có thể tìm thấy nhiều trên Internet nếu bạn không muốn sử dụng Tor) hoặc chia sẻ các gói reseed theo kiểu bạn-với-bạn ngoại tuyến.\nTrong wrapper.log tôi thấy lỗi hiển thị \u0026ldquo;Protocol family unavailable\u0026rdquo; khi tải Router Console Lỗi này thường xảy ra với bất kỳ phần mềm Java có kết nối mạng nào trên một số hệ thống được cấu hình sử dụng IPv6 theo mặc định. Có một vài cách để giải quyết vấn đề này:\nTrên các hệ thống dựa trên Linux, bạn có thể chạy lệnh echo 0 \u0026gt; /proc/sys/net/ipv6/bindv6only Tìm các dòng sau trong file wrapper.config: #wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true #wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false Nếu các dòng này có sẵn, hãy bỏ comment bằng cách xóa dấu \u0026ldquo;#\u0026rdquo;. Nếu các dòng này không có, hãy thêm chúng vào mà không có dấu \u0026ldquo;#\u0026rdquo;. Một lựa chọn khác là xóa ::1 khỏi ~/.i2p/clients.config\nCẢNH BÁO: Để bất kỳ thay đổi nào đối với wrapper.config có hiệu lực, bạn phải dừng hoàn toàn router và wrapper. Nhấp vào Khởi động lại trên bảng điều khiển router của bạn sẽ KHÔNG đọc lại tệp này! Bạn phải nhấp vào Tắt máy, đợi 11 phút, sau đó khởi động I2P.\nHầu hết các I2P Site trong I2P đều bị ngừng hoạt động? Nếu bạn xét đến mọi I2P Site đã từng được tạo ra, thì đúng vậy, phần lớn chúng đã ngừng hoạt động. Con người và các I2P Site đến rồi đi. Một cách tốt để bắt đầu với I2P là kiểm tra danh sách các I2P Site hiện đang hoạt động. identiguy.i2p theo dõi các I2P Site đang hoạt động.\nTại sao I2P lại lắng nghe trên cổng 32000? Tanuki java service wrapper mà chúng tôi sử dụng mở cổng này — liên kết với localhost — để giao tiếp với phần mềm chạy bên trong JVM. Khi JVM được khởi chạy, nó được cung cấp một khóa để có thể kết nối với wrapper. Sau khi JVM thiết lập kết nối của nó với wrapper, wrapper sẽ từ chối bất kỳ kết nối bổ sung nào.\nThông tin chi tiết có thể tìm thấy trong tài liệu wrapper .\nLàm thế nào để cấu hình trình duyệt của tôi? Cấu hình proxy cho các trình duyệt khác nhau được trình bày trên một trang riêng có kèm ảnh chụp màn hình. Các cấu hình nâng cao hơn với các công cụ bên ngoài, như plug-in trình duyệt FoxyProxy hoặc proxy server Privoxy, là có thể nhưng có thể gây ra rò rỉ thông tin trong thiết lập của bạn.\nLàm thế nào để kết nối đến IRC trong I2P? Một tunnel đến máy chủ IRC chính trong I2P, Irc2P, được tạo khi cài đặt I2P (xem trang cấu hình I2PTunnel ), và tự động khởi động khi I2P router khởi động. Để kết nối với nó, hãy cấu hình IRC client của bạn kết nối đến localhost 6668. Người dùng các client giống HexChat có thể tạo một network mới với máy chủ localhost/6668 (nhớ đánh dấu \u0026ldquo;Bypass proxy server\u0026rdquo; nếu bạn có cấu hình proxy server). Người dùng Weechat có thể sử dụng lệnh sau để thêm network mới:\n/server add irc2p localhost/6668 Làm thế nào để thiết lập I2P Site của riêng tôi? Phương pháp dễ nhất là nhấp vào liên kết i2ptunnel trong bảng điều khiển router và tạo một \u0026lsquo;Server Tunnel\u0026rsquo; mới. Bạn có thể phục vụ nội dung động bằng cách đặt đích tunnel đến cổng của một máy chủ web hiện có, chẳng hạn như Tomcat hoặc Jetty. Bạn cũng có thể phục vụ nội dung tĩnh. Để làm điều này, đặt đích tunnel thành: 0.0.0.0 port 7659 và đặt nội dung vào thư mục ~/.i2p/eepsite/docroot/. (Trên các hệ thống không phải Linux, vị trí này có thể khác. Hãy kiểm tra bảng điều khiển router.) Phần mềm \u0026rsquo;eepsite\u0026rsquo; đi kèm với gói cài đặt I2P và được thiết lập để tự động khởi động khi I2P được khởi động. Trang web mặc định được tạo có thể truy cập tại http://127.0.0.1:7658. Tuy nhiên, \u0026rsquo;eepsite\u0026rsquo; của bạn cũng có thể được người khác truy cập thông qua tệp khóa eepsite của bạn, nằm tại: ~/.i2p/eepsite/i2p/eepsite.keys. Để tìm hiểu thêm, hãy đọc tệp readme tại: ~/.i2p/eepsite/README.txt.\nNếu tôi lưu trữ một trang web trên I2P tại nhà, chỉ chứa HTML và CSS, liệu có nguy hiểm không? Điều này phụ thuộc vào đối thủ của bạn và mô hình đe dọa của bạn. Nếu bạn chỉ lo lắng về các vi phạm \u0026ldquo;quyền riêng tư\u0026rdquo; của doanh nghiệp, tội phạm thông thường và kiểm duyệt, thì nó không thực sự nguy hiểm. Cơ quan thực thi pháp luật có thể sẽ tìm thấy bạn nếu họ thực sự muốn. Chỉ lưu trữ khi bạn có một trình duyệt người dùng gia đình thông thường (internet) đang chạy sẽ khiến việc biết ai đang lưu trữ phần đó trở nên thực sự khó khăn. Vui lòng coi việc lưu trữ trang web I2P của bạn giống như lưu trữ bất kỳ dịch vụ nào khác - nó nguy hiểm - hoặc an toàn - tùy thuộc vào cách bạn cấu hình và quản lý nó.\nLưu ý: Đã có cách để tách việc lưu trữ một dịch vụ i2p (destination) ra khỏi router i2p. Nếu bạn hiểu cách nó hoạt động, thì bạn chỉ cần thiết lập một máy riêng biệt làm server cho website (hoặc dịch vụ) sẽ được truy cập công khai và chuyển tiếp đến webserver qua một SSH tunnel [rất] an toàn hoặc sử dụng một filesystem được bảo mật, chia sẻ.\nLàm thế nào I2P tìm các trang web \u0026ldquo;.i2p\u0026rdquo;? Ứng dụng Sổ Địa Chỉ I2P ánh xạ các tên dễ đọc sang các destination dài hạn, được liên kết với các dịch vụ, khiến nó giống một tệp hosts hoặc danh sách liên hệ hơn là cơ sở dữ liệu mạng hay dịch vụ DNS. Nó cũng ưu tiên cục bộ - không có không gian tên toàn cầu được công nhận, bạn quyết định bất kỳ tên miền .i2p nào ánh xạ đến đích cuối cùng. Điểm trung gian là thứ gọi là \u0026ldquo;Jump Service\u0026rdquo; (dịch vụ chuyển hướng) cung cấp tên dễ đọc bằng cách chuyển hướng bạn đến một trang nơi bạn sẽ được hỏi \u0026ldquo;Bạn có cho phép I2P router gọi $SITE_CRYPTO_KEY bằng tên $SITE_NAME.i2p không\u0026rdquo; hoặc tương tự như vậy. Sau khi nó có trong sổ địa chỉ của bạn, bạn có thể tạo các jump URL của riêng mình để giúp chia sẻ trang web với người khác.\nLàm thế nào để thêm địa chỉ vào Sổ địa chỉ? Bạn không thể thêm một địa chỉ mà không biết ít nhất là base32 hoặc base64 của trang web mà bạn muốn truy cập. \u0026ldquo;Hostname\u0026rdquo; (tên máy chủ) mà con người có thể đọc được chỉ là một bí danh cho địa chỉ mã hóa, tương ứng với base32 hoặc base64. Nếu không có địa chỉ mã hóa, sẽ không có cách nào để truy cập một I2P Site, đây là thiết kế có chủ đích. Việc phân phối địa chỉ cho những người chưa biết đến nó thường là trách nhiệm của nhà cung cấp dịch vụ Jump. Truy cập một I2P Site chưa biết sẽ kích hoạt việc sử dụng dịch vụ Jump. stats.i2p là dịch vụ Jump đáng tin cậy nhất.\nNếu bạn đang lưu trữ một trang web qua i2ptunnel, thì nó chưa có đăng ký với dịch vụ jump. Để cấp cho nó một URL cục bộ, hãy truy cập trang cấu hình và nhấp vào nút \u0026ldquo;Add to Local Address Book\u0026rdquo;. Sau đó truy cập http://127.0.0.1:7657/dns để tra cứu URL addresshelper và chia sẻ nó.\nI2P sử dụng những cổng nào? Các cổng được sử dụng bởi I2P có thể được chia thành 2 phần:\nCác cổng kết nối Internet, được sử dụng để giao tiếp với các router I2P khác Các cổng cục bộ, cho các kết nối nội bộ Những điều này được mô tả chi tiết bên dưới.\n1. Các cổng kết nối Internet Lưu ý: Từ phiên bản 0.7.8 trở đi, các cài đặt mới không sử dụng cổng 8887; một cổng ngẫu nhiên từ 9000 đến 31000 sẽ được chọn khi chương trình chạy lần đầu tiên. Cổng được chọn sẽ hiển thị trên trang cấu hình của router.\nRA NGOÀI\nUDP từ cổng ngẫu nhiên được liệt kê trên trang cấu hình đến các cổng UDP từ xa tùy ý, cho phép nhận phản hồi TCP từ các cổng cao ngẫu nhiên đến các cổng TCP từ xa tùy ý UDP gửi đi trên cổng 123, cho phép nhận phản hồi. Điều này cần thiết cho việc đồng bộ thời gian nội bộ của I2P (thông qua SNTP - truy vấn một máy chủ SNTP ngẫu nhiên trong pool.ntp.org hoặc máy chủ khác mà bạn chỉ định) INBOUND\n(Tùy chọn, khuyến nghị) UDP đến cổng được ghi chú trên trang cấu hình từ các vị trí bất kỳ (Tùy chọn, khuyến nghị) TCP đến cổng được ghi chú trên trang cấu hình từ các vị trí bất kỳ Kết nối TCP đến có thể bị vô hiệu hóa trên trang cấu hình 2. Cổng I2P cục bộ Các cổng I2P cục bộ chỉ lắng nghe các kết nối cục bộ theo mặc định, trừ khi có ghi chú khác:\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. ### Tôi thiếu nhiều máy chủ trong sổ địa chỉ của mình. Một số liên kết đăng ký tốt là gì? {#subscriptions} Sổ địa chỉ được đặt tại http://localhost:7657/dns nơi bạn có thể tìm thêm thông tin.\nMột số liên kết đăng ký address book tốt là gì?\nBạn có thể thử các cách sau:\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt Làm thế nào để tôi truy cập bảng điều khiển web từ các máy khác hoặc bảo vệ nó bằng mật khẩu? Vì mục đích bảo mật, bảng điều khiển quản trị của router theo mặc định chỉ lắng nghe các kết nối trên giao diện cục bộ.\nCó hai phương pháp để truy cập console từ xa:\nSSH Tunnel Cấu hình console của bạn để có thể truy cập từ địa chỉ IP công khai với tên người dùng \u0026amp; mật khẩu Các chi tiết được mô tả bên dưới:\nPhương pháp 1: SSH Tunnel\nNếu bạn đang chạy hệ điều hành giống Unix, đây là phương pháp dễ nhất để truy cập từ xa vào console I2P của bạn. (Lưu ý: Phần mềm SSH server cũng có sẵn cho các hệ thống chạy Windows, ví dụ https://github.com/PowerShell/Win32-OpenSSH )\nSau khi bạn đã cấu hình quyền truy cập SSH vào hệ thống của mình, cờ \u0026lsquo;-L\u0026rsquo; được truyền cho SSH với các đối số thích hợp - ví dụ:\nssh -L 7657:localhost:7657 (System_IP) trong đó \u0026lsquo;(System_IP)\u0026rsquo; được thay thế bằng địa chỉ IP của Hệ thống của bạn. Lệnh này chuyển tiếp cổng 7657 (số trước dấu hai chấm đầu tiên) đến cổng 7657 (số sau dấu hai chấm thứ hai) của hệ thống từ xa (được chỉ định bởi chuỗi \u0026rsquo;localhost\u0026rsquo; giữa dấu hai chấm thứ nhất và thứ hai). Bảng điều khiển I2P từ xa của bạn giờ đây sẽ có thể truy cập trên hệ thống cục bộ của bạn tại \u0026lsquo;http://localhost:7657\u0026rsquo; và sẽ khả dụng miễn là phiên SSH của bạn đang hoạt động.\nNếu bạn muốn bắt đầu một phiên SSH mà không khởi tạo shell trên hệ thống từ xa, bạn có thể thêm cờ \u0026lsquo;-N\u0026rsquo;:\nssh -NL 7657:localhost:7657 (System_IP) Phương pháp 2: Cấu hình console của bạn để có thể truy cập qua địa chỉ IP công khai với tên người dùng \u0026amp; mật khẩu\nMở ~/.i2p/clients.config và thay thế:\nclientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ bằng:\nclientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ trong đó bạn thay thế (System_IP) bằng địa chỉ IP công khai của hệ thống\nTruy cập http://localhost:7657/configui và thêm tên người dùng cùng mật khẩu cho console nếu muốn - Việc thêm tên người dùng \u0026amp; mật khẩu được khuyến nghị cao để bảo vệ I2P console của bạn khỏi bị can thiệp, điều này có thể dẫn đến mất ẩn danh.\nTruy cập http://localhost:7657/index và nhấn \u0026ldquo;Graceful restart\u0026rdquo;, thao tác này sẽ khởi động lại JVM và tải lại các ứng dụng client\nSau khi khởi động xong, bạn sẽ có thể truy cập console từ xa. Mở router console tại http://(System_IP):7657 và bạn sẽ được yêu cầu nhập tên người dùng và mật khẩu mà bạn đã chỉ định ở bước 2 phía trên nếu trình duyệt của bạn hỗ trợ popup xác thực.\nLƯU Ý: Bạn có thể chỉ định 0.0.0.0 trong cấu hình trên. Điều này chỉ định một giao diện, không phải một mạng hoặc netmask. 0.0.0.0 có nghĩa là \u0026ldquo;gắn kết với tất cả các giao diện\u0026rdquo;, vì vậy nó có thể truy cập được trên 127.0.0.1:7657 cũng như bất kỳ địa chỉ IP LAN/WAN nào. Hãy cẩn thận khi sử dụng tùy chọn này vì console sẽ khả dụng trên TẤT CẢ các địa chỉ được cấu hình trên hệ thống của bạn.\nLàm thế nào để tôi có thể sử dụng các ứng dụng từ các máy khác của mình? Vui lòng xem câu trả lời trước đó để biết hướng dẫn sử dụng SSH Port Forwarding, và cũng xem trang này trong console của bạn: http://localhost:7657/configi2cp Có thể sử dụng I2P như một SOCKS proxy không? SOCKS proxy đã hoạt động kể từ phiên bản 0.7.1. SOCKS 4/4a/5 được hỗ trợ. I2P không có SOCKS outproxy nên nó chỉ giới hạn sử dụng trong mạng I2P.\nNhiều ứng dụng làm rò rỉ thông tin nhạy cảm có thể định danh bạn trên Internet và đây là rủi ro mà người dùng cần nhận thức khi sử dụng SOCKS proxy của I2P. I2P chỉ lọc dữ liệu kết nối, nhưng nếu chương trình bạn định chạy gửi thông tin này dưới dạng nội dung, I2P không có cách nào bảo vệ tính ẩn danh của bạn. Ví dụ, một số ứng dụng thư điện tử sẽ gửi địa chỉ IP của máy tính đang chạy chúng đến máy chủ thư. Chúng tôi khuyên dùng các công cụ hoặc ứng dụng chuyên dụng cho I2P (như I2PSnark cho torrent), hoặc các ứng dụng được biết là an toàn khi sử dụng với I2P bao gồm các plugin phổ biến có trên Firefox .\nLàm thế nào để truy cập IRC, BitTorrent hoặc các dịch vụ khác trên Internet thông thường? Có các dịch vụ được gọi là Outproxy hoạt động như cầu nối giữa I2P và Internet, tương tự như Tor Exit Nodes. Chức năng outproxy mặc định cho HTTP và HTTPS được cung cấp bởi exit.stormycloud.i2p và được vận hành bởi StormyCloud Inc. Nó được cấu hình trong HTTP Proxy. Ngoài ra, để giúp bảo vệ tính ẩn danh, I2P không cho phép bạn thực hiện các kết nối ẩn danh đến Internet thông thường theo mặc định. Vui lòng xem trang Socks Outproxy để biết thêm thông tin.\nReseeds Router của tôi đã chạy được vài phút nhưng không có hoặc có rất ít kết nối Đầu tiên hãy kiểm tra trang http://127.0.0.1:7657/netdb trong Router Console – cơ sở dữ liệu mạng của bạn. Nếu bạn không thấy một router nào được liệt kê từ bên trong I2P nhưng console thông báo rằng bạn có thể đang bị tường lửa chặn, thì có lẽ bạn không thể kết nối đến các máy chủ reseed. Nếu bạn thấy các router I2P khác được liệt kê thì hãy thử giảm số lượng kết nối tối đa tại http://127.0.0.1:7657/config , có thể router của bạn không xử lý được nhiều kết nối.\nLàm thế nào để reseed thủ công? Trong điều kiện bình thường, I2P sẽ tự động kết nối bạn với mạng lưới bằng cách sử dụng các liên kết bootstrap của chúng tôi. Nếu kết nối internet bị gián đoạn khiến việc bootstrap từ các reseed server thất bại, một cách dễ dàng để bootstrap là sử dụng trình duyệt Tor (Mặc định nó mở localhost), hoạt động rất tốt với http://127.0.0.1:7657/configreseed . Cũng có thể reseed một I2P router theo cách thủ công.\nKhi sử dụng trình duyệt Tor để reseed, bạn có thể chọn nhiều URL cùng lúc và tiến hành. Mặc dù giá trị mặc định là 2 (trong số nhiều url) cũng sẽ hoạt động nhưng nó sẽ chậm.\nQuyền riêng tư - An toàn Router của tôi có phải là \u0026ldquo;exit node\u0026rdquo;(outproxy) ra Internet thông thường không? Tôi không muốn như vậy. Không, router của bạn tham gia vào việc truyền tải lưu lượng được mã hóa đầu-cuối (e2e) qua mạng i2p đến một điểm cuối tunnel ngẫu nhiên, thường không phải là outproxy, nhưng không có lưu lượng nào được truyền giữa router của bạn và Internet qua tầng truyền tải. Với tư cách là người dùng cuối, bạn không nên chạy outproxy nếu không có kỹ năng quản trị hệ thống và mạng.\nCó dễ dàng phát hiện việc sử dụng I2P bằng cách phân tích lưu lượng mạng không? Lưu lượng I2P thường trông giống như lưu lượng UDP, và không nhiều hơn thế – và việc làm cho nó trông không nhiều hơn thế là một mục tiêu. Nó cũng hỗ trợ TCP. Với một số nỗ lực, phân tích lưu lượng thụ động có thể phân loại lưu lượng là \u0026ldquo;I2P\u0026rdquo;, nhưng chúng tôi hy vọng rằng sự phát triển liên tục của kỹ thuật che giấu lưu lượng sẽ giảm thiểu điều này hơn nữa. Ngay cả một lớp che giấu giao thức khá đơn giản như obfs4 cũng sẽ ngăn chặn các cơ quan kiểm duyệt chặn I2P (đó là mục tiêu mà I2P triển khai).\nSử dụng I2P có an toàn không? Điều này phụ thuộc vào mô hình đe dọa cá nhân của bạn. Đối với hầu hết mọi người, I2P an toàn hơn nhiều so với việc không sử dụng bất kỳ biện pháp bảo vệ nào. Một số mạng khác (như Tor, mixminion/mixmaster), có thể an toàn hơn trước một số đối thủ nhất định. Ví dụ, lưu lượng I2P không sử dụng TLS/SSL, do đó không có vấn đề \u0026ldquo;mắt xích yếu nhất\u0026rdquo; như Tor. I2P đã được nhiều người ở Syria sử dụng trong \u0026ldquo;Mùa xuân Ả Rập\u0026rdquo;, và gần đây dự án đã chứng kiến sự phát triển lớn hơn trong các cộng đồng ngôn ngữ nhỏ hơn của I2P ở Cận Đông và Trung Đông. Điều quan trọng nhất cần lưu ý ở đây là I2P là một công nghệ và bạn cần hướng dẫn/chỉ dẫn để tăng cường quyền riêng tư/ẩn danh của mình trên Internet. Ngoài ra, hãy kiểm tra trình duyệt của bạn hoặc nhập công cụ tìm kiếm dấu vân tay để chặn các cuộc tấn công dấu vân tay với tập dữ liệu rất lớn (nghĩa là: đuôi dài điển hình / cấu trúc dữ liệu đa dạng rất chính xác) về nhiều yếu tố môi trường và đừng sử dụng VPN để giảm mọi rủi ro đến từ chính nó như hành vi bộ nhớ cache TLS riêng và cấu trúc kỹ thuật của nhà cung cấp dịch vụ có thể bị hack dễ dàng hơn hệ thống máy tính để bàn riêng. Có thể sử dụng Tor V-Browser cô lập với các biện pháp bảo vệ chống dấu vân tay tuyệt vời và bảo vệ suốt thời gian hoạt động với appguard chỉ cho phép các giao tiếp hệ thống cần thiết và cuối cùng là sử dụng máy ảo với các tập lệnh vô hiệu hóa chống gián điệp và live-cd để loại bỏ bất kỳ \u0026ldquo;rủi ro gần như vĩnh viễn có thể xảy ra\u0026rdquo; nào và giảm mọi rủi ro bằng cách giảm xác suất có thể là lựa chọn tốt trong mạng công cộng và mô hình rủi ro cá nhân cao và có thể là điều tốt nhất bạn có thể làm với mục tiêu này khi sử dụng i2p.\nTôi thấy địa chỉ IP của tất cả các nút I2P khác trong bảng điều khiển router. Điều đó có nghĩa là địa chỉ IP của tôi có thể nhìn thấy được bởi người khác? Có, đối với các nút I2P khác biết về router của bạn. Chúng tôi sử dụng điều này để kết nối với phần còn lại của mạng I2P. Các địa chỉ được đặt vật lý trong \u0026ldquo;các đối tượng routerInfos (key,value)\u0026rdquo;, được tìm nạp từ xa hoặc nhận từ peer. \u0026ldquo;routerInfos\u0026rdquo; chứa một số thông tin (một số được thêm vào cơ hội tùy chọn), \u0026ldquo;được công bố bởi peer\u0026rdquo;, về chính router đó để khởi động. Không có dữ liệu nào trong đối tượng này về các client. Nhìn kỹ hơn vào bên trong sẽ cho bạn biết rằng mọi thứ đều được tính với loại tạo id mới nhất gọi là \u0026ldquo;SHA-256 Hashes (low=Positive hash(-key), high=Negative hash(+key))\u0026rdquo;. Mạng I2P có cơ sở dữ liệu riêng về dữ liệu routerInfos được tạo trong quá trình tải lên và lập chỉ mục, nhưng điều này phụ thuộc sâu vào việc thực hiện các bảng key/value và cấu trúc mạng cũng như trạng thái tải / trạng thái băng thông và xác suất định tuyến cho việc lưu trữ trong các thành phần DB.\nViệc sử dụng outproxy có an toàn không? Điều này phụ thuộc vào định nghĩa \u0026ldquo;an toàn\u0026rdquo; của bạn là gì. Outproxies rất tuyệt khi chúng hoạt động, nhưng thật không may chúng được vận hành tự nguyện bởi những người có thể mất hứng thú hoặc có thể không có đủ nguồn lực để duy trì chúng 24/7 – xin lưu ý rằng bạn có thể gặp phải những khoảng thời gian mà dịch vụ không khả dụng, bị gián đoạn hoặc không ổn định, và chúng tôi không liên kết với dịch vụ này cũng như không có ảnh hưởng gì đến nó.\nCác outproxy có thể thấy lưu lượng truy cập của bạn đến và đi, ngoại trừ dữ liệu HTTPS/SSL được mã hóa đầu-cuối, giống như ISP của bạn có thể thấy lưu lượng truy cập đến và đi từ máy tính của bạn. Nếu bạn cảm thấy thoải mái với ISP của mình, thì sử dụng outproxy cũng không tệ hơn.\nCác cuộc tấn công \u0026ldquo;Phi-Danh tính hóa\u0026rdquo; thì sao? Để có giải thích chi tiết hơn, hãy đọc thêm tại bài viết của chúng tôi về Mô hình Mối đe dọa . Nhìn chung, việc khử ẩn danh không phải là đơn giản, nhưng có thể xảy ra nếu bạn không đủ thận trọng.\nTruy cập Internet/Hiệu suất Tôi không thể truy cập các trang web Internet thông thường qua I2P. Việc proxy đến các trang web Internet (các eepsite có kết nối ra Internet) được cung cấp như một dịch vụ cho người dùng I2P bởi các nhà cung cấp không chặn. Dịch vụ này không phải là trọng tâm chính của phát triển I2P, và được cung cấp trên cơ sở tự nguyện. Các eepsite được lưu trữ trên I2P nên luôn hoạt động mà không cần outproxy. Outproxy là một tiện ích nhưng theo thiết kế chúng không hoàn hảo và cũng không phải là một phần lớn của dự án. Xin lưu ý rằng chúng có thể không cung cấp dịch vụ chất lượng cao như các dịch vụ khác của I2P có thể cung cấp.\nTôi không thể truy cập các trang https:// hoặc ftp:// qua I2P. HTTP proxy mặc định chỉ hỗ trợ outproxy HTTP và HTTPS.\nTại sao router của tôi sử dụng quá nhiều CPU? Đầu tiên, hãy đảm bảo bạn có phiên bản mới nhất của mọi thành phần liên quan đến I2P – các phiên bản cũ có những đoạn mã tiêu tốn CPU không cần thiết. Ngoài ra còn có một nhật ký hiệu năng ghi lại một số cải tiến về hiệu năng I2P theo thời gian.\nCác peer hoạt động / peer đã biết / tunnel tham gia / kết nối / băng thông của tôi thay đổi đáng kể theo thời gian! Có vấn đề gì không? Tính ổn định tổng thể của mạng I2P là một lĩnh vực nghiên cứu đang được tiếp tục phát triển. Một phần đáng kể của nghiên cứu đó tập trung vào việc các thay đổi nhỏ trong cài đặt cấu hình ảnh hưởng như thế nào đến hành vi của router. Vì I2P là một mạng ngang hàng (peer-to-peer), nên các hành động của các nút mạng khác sẽ có ảnh hưởng đến hiệu suất của router của bạn.\nĐiều gì khiến việc tải xuống, torrent, duyệt web và mọi thứ khác chậm hơn trên I2P so với internet thông thường? I2P có các cơ chế bảo vệ khác nhau giúp bổ sung thêm định tuyến và các lớp mã hóa. Nó cũng chuyển tiếp lưu lượng qua các peer khác (Tunnels) với tốc độ và chất lượng riêng, một số chậm, một số nhanh. Điều này tạo ra nhiều chi phí phụ trội và lưu lượng truyền tải ở các tốc độ khác nhau theo các hướng khác nhau. Theo thiết kế, tất cả những yếu tố này sẽ làm cho nó chậm hơn so với kết nối trực tiếp trên internet, nhưng ẩn danh hơn nhiều và vẫn đủ nhanh cho hầu hết các mục đích sử dụng.\nDưới đây là một ví dụ được trình bày kèm theo giải thích để giúp cung cấp ngữ cảnh về các vấn đề độ trễ và băng thông khi sử dụng I2P.\nXem xét sơ đồ dưới đây. Nó mô tả một kết nối giữa một client thực hiện yêu cầu qua I2P, một server nhận yêu cầu qua I2P và sau đó phản hồi lại qua I2P. Mạch mà yêu cầu di chuyển qua cũng được mô tả.\nTừ sơ đồ, hãy xem xét rằng các ô được đánh dấu \u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo; và \u0026lsquo;R\u0026rsquo; đại diện cho một tunnel gửi đi của \u0026lsquo;A\u0026rsquo; và các ô được đánh dấu \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; và \u0026lsquo;Z\u0026rsquo; đại diện cho một tunnel gửi đi của \u0026lsquo;B\u0026rsquo;. Tương tự, các ô được đánh dấu \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; và \u0026lsquo;Z\u0026rsquo; đại diện cho một tunnel nhận vào của \u0026lsquo;B\u0026rsquo; trong khi các ô được đánh dấu \u0026lsquo;P_1\u0026rsquo;, \u0026lsquo;Q_1\u0026rsquo; và \u0026lsquo;R_1\u0026rsquo; đại diện cho một tunnel nhận vào của \u0026lsquo;A\u0026rsquo;. Các mũi tên giữa các ô cho biết hướng của lưu lượng. Văn bản phía trên và phía dưới các mũi tên mô tả một số ví dụ về băng thông giữa một cặp chặng cũng như độ trễ ví dụ.\nKhi cả client và server đều sử dụng tunnel 3-hop xuyên suốt, tổng cộng có 12 router I2P khác tham gia chuyển tiếp lưu lượng. 6 peer chuyển tiếp lưu lượng từ client đến server, được chia thành một outbound tunnel 3-hop từ \u0026lsquo;A\u0026rsquo; (\u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;R\u0026rsquo;) và một inbound tunnel 3-hop đến \u0026lsquo;B\u0026rsquo; (\u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;). Tương tự, 6 peer chuyển tiếp lưu lượng từ server trả về client.\nĐầu tiên, chúng ta có thể xem xét độ trễ - thời gian cần thiết để một yêu cầu từ client đi qua mạng I2P, đến server và quay trở lại client. Cộng tất cả các độ trễ lại, ta thấy rằng:\n40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms Tổng thời gian khứ hồi trong ví dụ của chúng ta lên tới 740 ms - chắc chắn cao hơn nhiều so với những gì người ta thường thấy khi duyệt các trang web internet thông thường.\nThứ hai, chúng ta có thể xem xét băng thông khả dụng. Điều này được xác định thông qua liên kết chậm nhất giữa các hop từ client đến server cũng như khi lưu lượng đang được truyền bởi server đến client. Đối với lưu lượng đi từ client đến server, chúng ta thấy rằng băng thông khả dụng trong ví dụ của chúng ta giữa các hop \u0026lsquo;R\u0026rsquo; \u0026amp; \u0026lsquo;X\u0026rsquo; cũng như các hop \u0026lsquo;X\u0026rsquo; \u0026amp; \u0026lsquo;Y\u0026rsquo; là 32 KB/s. Mặc dù có băng thông khả dụng cao hơn giữa các hop khác, những hop này sẽ đóng vai trò là điểm nghẽn cổ chai và sẽ giới hạn băng thông khả dụng tối đa cho lưu lượng từ \u0026lsquo;A\u0026rsquo; đến \u0026lsquo;B\u0026rsquo; ở mức 32 KB/s. Tương tự, theo dõi đường đi từ server đến client cho thấy có băng thông tối đa là 64 KB/s - giữa các hop \u0026lsquo;Z_1\u0026rsquo; \u0026amp; \u0026lsquo;Y_1, \u0026lsquo;Y_1\u0026rsquo; \u0026amp; \u0026lsquo;X_1\u0026rsquo; và \u0026lsquo;Q_1\u0026rsquo; \u0026amp; \u0026lsquo;P_1\u0026rsquo;.\nChúng tôi khuyến nghị tăng giới hạn băng thông của bạn. Điều này giúp mạng lưới bằng cách tăng lượng băng thông khả dụng, từ đó cải thiện trải nghiệm I2P của bạn. Cài đặt băng thông nằm ở trang http://localhost:7657/config . Vui lòng lưu ý đến giới hạn kết nối internet của bạn do ISP quy định và điều chỉnh cài đặt cho phù hợp.\nChúng tôi cũng khuyến nghị thiết lập một lượng băng thông chia sẻ đủ lớn - điều này cho phép các participating tunnel được định tuyến qua router I2P của bạn. Cho phép participating traffic giúp router của bạn tích hợp tốt trong mạng lưới và cải thiện tốc độ truyền tải của bạn.\nI2P là một dự án đang được phát triển. Rất nhiều cải tiến và sửa lỗi đang được triển khai, và nói chung, chạy phiên bản mới nhất sẽ giúp cải thiện hiệu suất của bạn. Nếu bạn chưa làm điều đó, hãy cài đặt phiên bản mới nhất.\nTôi nghĩ mình đã tìm thấy một lỗi, tôi có thể báo cáo ở đâu? Bạn có thể báo cáo bất kỳ lỗi/vấn đề nào gặp phải trên hệ thống theo dõi lỗi của chúng tôi, có thể truy cập qua cả internet thông thường và I2P. Chúng tôi có diễn đàn thảo luận, cũng có sẵn trên I2P và internet thông thường. Bạn cũng có thể tham gia kênh IRC của chúng tôi: thông qua mạng IRC của chúng tôi, IRC2P, hoặc trên Freenode.\nBugtracker của chúng tôi: Internet công khai: https://i2pgit.org/I2P_Developers/i2p.i2p/issues Trên I2P: http://git.idk.i2p/I2P_Developers/i2p.i2p/issues Diễn đàn của chúng tôi: i2pforum.i2p Dán logs: Bạn có thể dán bất kỳ logs quan trọng nào vào dịch vụ paste như các dịch vụ internet công khai được liệt kê trên PrivateBin Wiki , hoặc dịch vụ paste trên I2P như phiên bản PrivateBin này hoặc dịch vụ paste không cần Javascript này và theo dõi trên IRC tại #i2p IRC: Tham gia #i2p-dev để thảo luận với các nhà phát triển trên IRC Vui lòng cung cấp thông tin liên quan từ trang nhật ký router có sẵn tại: http://127.0.0.1:7657/logs . Chúng tôi yêu cầu bạn chia sẻ toàn bộ văn bản trong phần \u0026lsquo;I2P Version and Running Environment\u0026rsquo; cũng như bất kỳ lỗi hoặc cảnh báo nào được hiển thị trong các nhật ký khác nhau trên trang.\nTôi có một câu hỏi! Tuyệt vời! Tìm chúng tôi trên IRC:\ntrên irc.freenode.net kênh #i2p trên IRC2P kênh #i2p hoặc đăng lên diễn đàn và chúng tôi sẽ đăng nó ở đây (kèm theo câu trả lời, hy vọng vậy).\n","description":"Câu hỏi thường gặp toàn diện về I2P: trợ giúp router, cấu hình, reseed, quyền riêng tư/an toàn, hiệu suất và xử lý sự cố","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"Câu hỏi thường gặp","url":"/vi/docs/overview/faq/"},{"categories":null,"content":"Tổng quan Tài liệu này đặc tả các cấu trúc dữ liệu cơ bản được sử dụng trong toàn bộ các giao thức I2P, bao gồm I2NP , I2CP , SSU2 , NTCP2 và những giao thức khác. Các cấu trúc dùng chung này đảm bảo khả năng tương tác giữa các bản triển khai I2P khác nhau và các lớp giao thức.\nNhững thay đổi chính kể từ 0.9.58 ElGamal và DSA-SHA1 không còn được khuyến nghị cho Router Identities (sử dụng X25519 + EdDSA) Hỗ trợ ML-KEM hậu lượng tử đang trong giai đoạn thử nghiệm beta (tùy chọn tham gia (opt-in) kể từ 2.10.0) Các tùy chọn bản ghi dịch vụ đã được chuẩn hóa (Proposal 167 , được triển khai trong 0.9.66) Đặc tả đệm có thể nén đã được hoàn tất (Proposal 161 , được triển khai trong 0.9.57) Đặc tả kiểu dữ liệu dùng chung Số nguyên Mô tả: Đại diện cho một số nguyên không âm theo thứ tự byte mạng (big-endian: byte có trọng số cao ở trước).\nNội dung: 1 đến 8 byte biểu diễn một số nguyên không dấu.\nCách dùng: Độ dài trường, số lượng, định danh kiểu, và các giá trị số trong toàn bộ các giao thức I2P.\nNgày Mô tả: Dấu thời gian biểu thị số mili giây kể từ kỷ nguyên Unix (ngày 1 tháng 1 năm 1970 00:00:00 GMT).\nNội dung: Số nguyên 8 byte (unsigned long, số nguyên không dấu kiểu long)\nGiá trị đặc biệt: - 0 = Ngày không xác định hoặc null - Giá trị tối đa: 0xFFFFFFFFFFFFFFFF (năm 584,942,417,355)\nLưu ý triển khai: - Luôn dùng múi giờ UTC/GMT - Yêu cầu độ chính xác đến mili giây - Được dùng cho việc hết hạn lease (bản ghi thuê trong I2P), công bố RouterInfo, và kiểm tra hợp lệ dấu thời gian\nChuỗi Mô tả: Chuỗi được mã hóa UTF-8 có tiền tố độ dài.\nĐịnh dạng:\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes Ràng buộc: - Độ dài tối đa: 255 byte (không phải số ký tự - các chuỗi UTF-8 nhiều byte được tính là nhiều byte) - Độ dài có thể bằng 0 (chuỗi rỗng) - Null terminator (ký tự kết thúc chuỗi null) KHÔNG được bao gồm - Chuỗi KHÔNG được kết thúc bằng null\nQuan trọng: Các chuỗi UTF-8 có thể sử dụng nhiều byte cho mỗi ký tự. Một chuỗi có 100 ký tự có thể vượt quá giới hạn 255 byte nếu sử dụng ký tự đa byte.\nCấu trúc khóa mật mã Khóa công khai Description: Khóa công khai dùng cho mã hóa bất đối xứng. Loại khóa và độ dài phụ thuộc vào ngữ cảnh hoặc được chỉ định trong một Key Certificate (chứng thư khóa).\nLoại mặc định: ElGamal (không còn được khuyến nghị cho Định danh router kể từ 0.9.58)\nCác kiểu được hỗ trợ:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta **Yêu cầu triển khai:** X25519 (Type 4) - Tiêu chuẩn hiện hành:\nĐược sử dụng cho cơ chế mã hóa ECIES-X25519-AEAD-Ratchet Bắt buộc đối với Danh tính Router kể từ 0.9.48 Mã hóa kiểu little-endian (thứ tự byte nhỏ trước) (không giống các kiểu khác) Xem ECIES và ECIES-ROUTERS ElGamal (Type 0) - Cũ (legacy):\nKhông còn được khuyến nghị dùng cho Danh tính Router kể từ 0.9.58 Vẫn hợp lệ cho Đích (Destination) (trường này không được sử dụng từ 0.6/2005) Sử dụng các số nguyên tố hằng được định nghĩa trong ElGamal specification Hỗ trợ được duy trì nhằm tương thích ngược MLKEM (Hậu lượng tử) - Beta:\nCách tiếp cận lai kết hợp ML-KEM với X25519 KHÔNG được bật theo mặc định trong 2.10.0 Yêu cầu kích hoạt thủ công thông qua Hidden Service Manager Xem ECIES-HYBRID và Đề xuất 169 Mã loại và đặc tả có thể thay đổi Tài liệu JavaDoc: PublicKey Khóa riêng Mô tả: Khóa riêng cho giải mã bất đối xứng, tương ứng với các kiểu PublicKey.\nLưu trữ: Kiểu và độ dài được suy ra từ ngữ cảnh hoặc được lưu trữ riêng trong các cấu trúc dữ liệu/tệp khóa.\nCác kiểu được hỗ trợ:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta **Ghi chú bảo mật:** - Các khóa riêng PHẢI được tạo bằng bộ sinh số ngẫu nhiên an toàn cho mật mã - Các khóa riêng X25519 sử dụng scalar clamping (ép ngưỡng vô hướng) như được định nghĩa trong RFC 7748 - Dữ liệu khóa PHẢI được xóa an toàn khỏi bộ nhớ khi không còn cần thiết JavaDoc (tài liệu API Java): PrivateKey Khóa phiên Mô tả: Khóa đối xứng dùng cho mã hóa và giải mã AES-256 trong tunnel và garlic encryption của I2P.\nNội dung: 32 byte (256 bit)\nSử dụng: - Mã hóa lớp tunnel (AES-256/CBC with IV) - Mã hóa thông điệp bằng garlic encryption (cơ chế mã hóa đặc trưng của I2P) - Mã hóa phiên đầu-cuối\nSinh: PHẢI sử dụng bộ sinh số ngẫu nhiên an toàn mật mã.\nJavaDoc: SessionKey SigningPublicKey Mô tả: Khóa công khai dùng để xác minh chữ ký. Kiểu và độ dài được xác định trong Key Certificate (chứng chỉ khóa) của Destination (đích) hoặc được suy ra từ ngữ cảnh.\nKiểu mặc định: DSA_SHA1 (đã lỗi thời kể từ 0.9.58)\nCác loại được hỗ trợ:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- **Yêu cầu triển khai:** EdDSA_SHA512_Ed25519 (Loại 7) - Tiêu chuẩn hiện tại:\nMặc định cho tất cả các định danh router và điểm đích mới kể từ cuối năm 2015 Sử dụng đường cong Ed25519 với băm SHA-512 Khóa công khai 32 byte, chữ ký 64 byte Mã hóa theo thứ tự little-endian (khác với đa số các loại khác) Hiệu năng và bảo mật cao RedDSA_SHA512_Ed25519 (Type 11) - Chuyên biệt:\nCHỈ dùng cho các leasesets được mã hóa và blinding (kỹ thuật làm mù) Không bao giờ dùng cho Router Identities hoặc Destinations chuẩn Các khác biệt chính so với EdDSA: Khóa riêng bằng phép giảm modulo (không dùng clamping (thiết lập một số bit cố định)) Chữ ký bao gồm 80 byte dữ liệu ngẫu nhiên Sử dụng trực tiếp khóa công khai (không dùng giá trị băm của khóa riêng) Xem [Đặc tả Red25519](//docs/specs/red25519-signature-scheme/ DSA_SHA1 (Type 0) - Cũ:\nKhông còn được khuyến nghị (deprecated) cho Router Identities (danh tính router) kể từ 0.9.58 Không khuyến khích dùng cho các Destinations (điểm đích trong I2P) mới DSA 1024-bit với SHA-1 (đã biết có điểm yếu) Chỉ duy trì hỗ trợ vì mục đích tương thích Khóa gồm nhiều phần tử:\nKhi được cấu thành từ hai phần tử (ví dụ: các điểm ECDSA (thuật toán chữ ký số đường cong elliptic) X,Y) Mỗi phần tử được đệm thêm số 0 ở đầu để đạt độ dài bằng một nửa Ví dụ: khóa ECDSA 64 byte = 32 byte X + 32 byte Y Tài liệu JavaDoc: SigningPublicKey SigningPrivateKey Mô tả: Khóa riêng dùng để tạo chữ ký, tương ứng với các kiểu SigningPublicKey (khóa công khai dùng để ký).\nLưu trữ: Kiểu và độ dài được chỉ định khi tạo.\nCác loại được hỗ trợ:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized **Yêu cầu bảo mật:** - Sinh bằng nguồn sinh số ngẫu nhiên an toàn về mật mã - Bảo vệ bằng các cơ chế kiểm soát truy cập phù hợp - Xóa khỏi bộ nhớ một cách an toàn khi hoàn tất - Với EdDSA: seed 32 byte được băm bằng SHA-512, 32 byte đầu trở thành giá trị vô hướng (clamp: chỉnh các bit theo quy tắc) - Với RedDSA: Cách sinh khóa khác (giảm modulo thay vì clamp) JavaDoc: SigningPrivateKey Chữ ký Mô tả: Chữ ký mật mã trên dữ liệu, sử dụng thuật toán ký tương ứng với kiểu SigningPrivateKey.\nLoại và độ dài: Suy ra từ loại khóa được dùng để ký.\nCác loại được hỗ trợ:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized **Ghi chú về định dạng:** - Chữ ký nhiều thành phần (ví dụ, các giá trị R,S của ECDSA) được đệm bằng số 0 ở đầu để mỗi thành phần có độ dài bằng length/2 - EdDSA và RedDSA sử dụng mã hóa theo thứ tự byte little-endian (thứ tự byte thấp trước) - Tất cả các loại khác sử dụng mã hóa theo thứ tự byte big-endian Xác minh: - Sử dụng SigningPublicKey (khóa công khai dùng để ký) tương ứng - Tuân theo các đặc tả của thuật toán chữ ký số cho loại khóa - Kiểm tra rằng độ dài chữ ký khớp với độ dài dự kiến cho loại khóa\nJavaDoc: Signature Mã băm Mô tả: Giá trị băm SHA-256 của dữ liệu, được sử dụng xuyên suốt I2P để xác minh tính toàn vẹn và nhận diện.\nNội dung: 32 byte (256 bit)\nMục đích sử dụng: - Băm định danh Router (khóa cơ sở dữ liệu mạng) - Băm Destination (đích trong I2P) (khóa cơ sở dữ liệu mạng) - Định danh cổng vào của Tunnel trong Leases (bản ghi Lease trong I2P) - Xác minh tính toàn vẹn dữ liệu - Sinh ID Tunnel\nThuật toán: SHA-256 như được định nghĩa trong FIPS 180-4\nJavaDoc: Hash Session Tag (thẻ phiên) Mô tả: Số ngẫu nhiên được dùng để định danh phiên và mã hóa dựa trên thẻ.\nQuan trọng: Kích thước Session Tag (thẻ phiên) thay đổi theo kiểu mã hóa: - ElGamal/AES+SessionTag: 32 byte (cũ) - ECIES-X25519: 8 byte (tiêu chuẩn hiện tại)\nTiêu chuẩn hiện hành (ECIES):\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers Xem ECIES và ECIES-ROUTERS để xem các đặc tả chi tiết.\nKiểu cũ (ElGamal/AES):\nContents: 32 bytes Usage: Deprecated encryption scheme Sinh: PHẢI sử dụng bộ sinh số ngẫu nhiên an toàn mật mã.\nJavaDoc: SessionTag TunnelId Mô tả: Mã định danh duy nhất cho vị trí của router trong một tunnel. Mỗi chặng trong một tunnel có một TunnelId (mã định danh của tunnel) riêng.\nĐịnh dạng:\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) Sử dụng: - Xác định các kết nối tunnel vào/ra tại mỗi router - TunnelId khác nhau tại mỗi hop (chặng) trong chuỗi tunnel - Được dùng trong các cấu trúc Lease để xác định các tunnel gateway\nCác giá trị đặc biệt: - 0 = Dành riêng cho các mục đích đặc thù của giao thức (tránh sử dụng trong hoạt động bình thường) - TunnelIds (định danh tunnel) chỉ có ý nghĩa cục bộ trên từng router\nJavaDoc: TunnelId Đặc tả Chứng chỉ Chứng chỉ Mô tả: Bộ chứa dùng cho các biên nhận, bằng chứng công việc (proof-of-work), hoặc siêu dữ liệu mật mã được sử dụng xuyên suốt I2P.\nĐịnh dạng:\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes Tổng kích thước: tối thiểu 3 byte (NULL certificate), tối đa 65538 byte\nCác loại chứng chỉ Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) ### Chứng chỉ khóa (Loại 5) Giới thiệu: Phiên bản 0.9.12 (Tháng 12 năm 2013)\nMục đích: Chỉ định các kiểu khóa không mặc định và lưu trữ dữ liệu khóa dư thừa vượt quá cấu trúc KeysAndCert tiêu chuẩn 384 byte.\nCấu trúc tải trọng dữ liệu:\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space Các lưu ý triển khai quan trọng:\nThứ tự kiểu khóa:\nCẢNH BÁO: Kiểu khóa ký đứng TRƯỚC kiểu khóa mật mã Điều này có vẻ ngược trực giác nhưng được duy trì để đảm bảo tương thích Thứ tự: SPKtype, CPKtype (không phải CPKtype, SPKtype) Bố cục dữ liệu khóa trong KeysAndCert (khóa và chứng chỉ):\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] Tính toán dữ liệu khóa dư thừa:\nNếu Crypto Key \u0026gt; 256 byte: Excess = (Crypto Length - 256) Nếu Signing Key \u0026gt; 128 byte: Excess = (Signing Length - 128) Padding = max(0, 384 - Crypto Length - Signing Length) Ví dụ (Khóa mật mã ElGamal):\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 **Yêu cầu về danh tính Router:** - Chứng chỉ NULL được sử dụng cho đến phiên bản 0.9.15 - Key Certificate (chứng chỉ khóa) được yêu cầu cho các loại khóa không mặc định kể từ phiên bản 0.9.16 - Các khóa mã hóa X25519 được hỗ trợ kể từ phiên bản 0.9.48 Yêu cầu đối với Điểm đích: - chứng chỉ NULL hoặc Key Certificate (chứng chỉ khóa, khi cần) - Key Certificate bắt buộc cho các loại khóa ký không mặc định từ 0.9.12 - Trường khóa công khai mật mã không còn được dùng từ 0.6 (2005) nhưng vẫn phải có\nCảnh báo quan trọng:\nChứng chỉ NULL vs KEY:\nChứng chỉ KEY với kiểu (0,0) chỉ định ElGamal+DSA_SHA1 được phép nhưng không khuyến khích Luôn dùng chứng chỉ NULL cho ElGamal+DSA_SHA1 (biểu diễn chuẩn) Chứng chỉ KEY với (0,0) dài hơn 4 byte và có thể gây ra vấn đề tương thích Một số triển khai có thể không xử lý đúng các chứng chỉ KEY (0,0) Xác minh dữ liệu dư thừa:\nCác triển khai PHẢI xác minh độ dài chứng chỉ khớp với độ dài mong đợi cho các loại khóa Từ chối các chứng chỉ có dữ liệu dư thừa không tương ứng với các loại khóa Cấm dữ liệu rác ở phần cuối sau cấu trúc chứng chỉ hợp lệ JavaDoc: Certificate Ánh xạ Mô tả: Tập hợp thuộc tính khóa–giá trị dùng cho cấu hình và siêu dữ liệu.\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] Giới hạn kích thước: - Độ dài khóa: 0-255 byte (+ 1 byte độ dài) - Độ dài giá trị: 0-255 byte (+ 1 byte độ dài) - Tổng kích thước ánh xạ: 0-65535 byte (+ 2 byte trường kích thước) - Kích thước cấu trúc tối đa: 65537 byte\nYêu cầu sắp xếp quan trọng:\nKhi các ánh xạ xuất hiện trong cấu trúc đã ký (RouterInfo, RouterAddress, các thuộc tính Destination, I2CP SessionConfig), các mục PHẢI được sắp xếp theo khóa để đảm bảo tính bất biến của chữ ký:\nPhương thức sắp xếp: Thứ tự từ điển dựa trên giá trị điểm mã Unicode (tương đương với Java String.compareTo()) Phân biệt chữ hoa/thường: Khóa và giá trị nói chung phân biệt chữ hoa/thường (tùy thuộc vào ứng dụng) Khóa trùng lặp: KHÔNG được phép trong các cấu trúc đã ký (sẽ gây lỗi xác minh chữ ký) Mã hóa ký tự: So sánh ở cấp độ byte theo UTF-8 Tại sao sắp xếp quan trọng: - Chữ ký số được tính trên biểu diễn ở dạng byte - Các thứ tự khóa khác nhau tạo ra các chữ ký số khác nhau - Các ánh xạ không được ký không cần phải sắp xếp nhưng nên tuân theo cùng một quy ước\nGhi chú triển khai:\nDư thừa trong mã hóa:\nCả dấu phân cách = và ; VÀ các byte độ dài chuỗi đều hiện diện Điều này kém hiệu quả nhưng được duy trì để đảm bảo tương thích Các byte độ dài có tính quyết định; các dấu phân cách là bắt buộc nhưng dư thừa Hỗ trợ ký tự:\nMặc dù tài liệu ghi khác, = và ; VẪN được hỗ trợ bên trong chuỗi (các byte độ dài xử lý việc này) Mã hóa UTF-8 hỗ trợ đầy đủ Unicode Cảnh báo: I2CP sử dụng UTF-8, nhưng I2NP trước đây không xử lý UTF-8 đúng cách Hãy dùng ASCII cho các ánh xạ I2NP khi có thể để đạt khả năng tương thích tối đa Ngữ cảnh đặc biệt:\nRouterInfo/RouterAddress: PHẢI được sắp xếp, không trùng lặp I2CP SessionConfig: PHẢI được sắp xếp, không trùng lặp Ánh xạ ứng dụng: Khuyến nghị sắp xếp nhưng không phải lúc nào cũng bắt buộc Ví dụ (tùy chọn RouterInfo):\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 JavaDoc: DataHelper Đặc tả Cấu trúc Chung Khóa và Chứng chỉ Mô tả: Cấu trúc cơ bản kết hợp khóa mã hóa, khóa ký và chứng chỉ. Được dùng như cả RouterIdentity (định danh router) và Destination (đích).\nCấu trúc:\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) Căn chỉnh khóa: - Khóa công khai mã hóa: Căn ở đầu (byte 0) - Đệm: Ở giữa (nếu cần) - Khóa công khai dùng để ký: Căn ở cuối (byte 256 đến byte 383) - Chứng chỉ: Bắt đầu tại byte 384\nTính toán kích thước:\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length Hướng dẫn tạo phần đệm (Đề xuất 161 ) Phiên bản triển khai: 0.9.57 (Tháng 1 năm 2023, phát hành 2.1.0)\nBối cảnh: - Đối với các khóa không phải ElGamal+DSA, padding (đệm) có trong cấu trúc cố định 384-byte - Đối với Destination (đích), trường khóa công khai 256-byte đã không được sử dụng kể từ 0.6 (2005) - Padding nên được tạo sao cho có thể nén được mà vẫn bảo đảm an toàn\nYêu cầu:\nDữ liệu ngẫu nhiên tối thiểu:\nSử dụng ít nhất 32 byte dữ liệu ngẫu nhiên an toàn về mặt mật mã Điều này cung cấp đủ entropy (mức độ ngẫu nhiên) cho mục đích bảo mật Chiến lược nén:\nLặp lại 32 byte trên toàn bộ trường đệm/khóa công khai Các giao thức như I2NP Database Store, Streaming SYN, SSU2 handshake sử dụng nén Tiết kiệm băng thông đáng kể mà không làm suy giảm bảo mật Ví dụ:\nĐịnh danh Router (X25519 + EdDSA):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed Destination (Điểm đích) (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed Vì sao cách này hiệu quả:\nHàm băm SHA-256 của toàn bộ cấu trúc vẫn bao gồm toàn bộ entropy (độ ngẫu nhiên) Phân phối DHT (bảng băm phân tán) của cơ sở dữ liệu mạng chỉ phụ thuộc vào hàm băm Khóa ký (32 byte EdDSA/X25519) cung cấp 256 bit entropy Thêm 32 byte dữ liệu ngẫu nhiên lặp lại = 512 bit entropy tổng Vượt mức cần thiết cho độ mạnh mật mã Ghi chú triển khai:\nPHẢI lưu trữ và truyền toàn bộ cấu trúc 387+ byte Băm SHA-256 được tính trên toàn bộ cấu trúc chưa nén Nén được áp dụng ở lớp giao thức (I2NP, Streaming, SSU2) Tương thích ngược với tất cả các phiên bản kể từ 0.6 (2005) Tài liệu JavaDoc: KeysAndCert RouterIdentity (định danh của router) Mô tả: Xác định duy nhất một router trong mạng I2P. Có cấu trúc giống hệt KeysAndCert.\nĐịnh dạng: Xem cấu trúc KeysAndCert ở trên\nYêu cầu hiện tại (tính đến 0.9.58):\nCác kiểu khóa bắt buộc:\nMã hóa: X25519 (loại 4, 32 byte) Ký: EdDSA_SHA512_Ed25519 (loại 7, 32 byte) Chứng chỉ: Chứng chỉ khóa (loại 5) Các loại khóa đã lỗi thời:\nElGamal (type 0) không còn được dùng cho Router Identities (nhận dạng của router) kể từ 0.9.58 DSA_SHA1 (type 0) không còn được dùng cho Router Identities kể từ 0.9.58 Những loại này KHÔNG được sử dụng cho router mới Kích thước điển hình:\nX25519 + EdDSA với Chứng chỉ khóa = 391 byte 32 byte khóa công khai X25519 320 byte phần đệm (có thể nén theo Proposal 161 ) 32 byte khóa công khai EdDSA 7 byte chứng chỉ (tiêu đề 3 byte + 4 byte loại khóa) Lịch sử phát triển: - Trước 0.9.16: luôn dùng chứng chỉ NULL (ElGamal + DSA_SHA1) - 0.9.16-0.9.47: bổ sung hỗ trợ Key Certificate (chứng chỉ khóa) - 0.9.48+: hỗ trợ khóa mã hóa X25519 - 0.9.58+: ElGamal và DSA_SHA1 bị loại bỏ dần\nKhóa Cơ sở dữ liệu mạng: - RouterInfo được lập chỉ mục bằng giá trị băm SHA-256 của RouterIdentity đầy đủ - Giá trị băm được tính trên toàn bộ cấu trúc 391+ byte (bao gồm cả phần đệm)\nXem thêm: - Hướng dẫn tạo padding (phần đệm) (Proposal 161 ) - Đặc tả Chứng chỉ khóa ở trên\nJavaDoc: RouterIdentity Điểm đích Mô tả: Định danh điểm cuối cho việc chuyển phát thông điệp an toàn. Về mặt cấu trúc thì giống hệt KeysAndCert, nhưng có ngữ nghĩa sử dụng khác.\nĐịnh dạng: Xem cấu trúc KeysAndCert ở trên\nKhác biệt quan trọng so với RouterIdentity (định danh router trong I2P): - Trường khóa công khai KHÔNG ĐƯỢC SỬ DỤNG và có thể chứa dữ liệu ngẫu nhiên - Trường này không được sử dụng kể từ phiên bản 0.6 (2005) - Vốn dùng cho cơ chế mã hóa I2CP-to-I2CP cũ (đã vô hiệu hóa) - Hiện chỉ được dùng làm IV (vector khởi tạo) cho mã hóa LeaseSet đã lỗi thời\nCác khuyến nghị hiện tại:\nKhóa ký:\nKhuyến nghị: EdDSA_SHA512_Ed25519 (loại 7, 32 byte) Phương án thay thế: các loại ECDSA để tương thích với các phiên bản cũ hơn Tránh: DSA_SHA1 (đã lỗi thời, không khuyến khích) Khóa mã hóa:\nTrường không được sử dụng nhưng bắt buộc phải có Khuyến nghị: Điền bằng dữ liệu ngẫu nhiên theo Proposal 161 (có thể nén) Kích thước: Luôn 256 byte (khe ElGamal, dù không dùng cho ElGamal) Chứng chỉ:\nChứng chỉ NULL cho ElGamal + DSA_SHA1 (chỉ dành cho bản cũ) Chứng chỉ khóa cho tất cả các loại khóa ký khác Destination (điểm đích I2P) hiện đại điển hình:\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes Khóa mã hóa thực tế: - Khóa mã hóa cho Destination (điểm đích trong I2P) nằm trong LeaseSet, không phải trong Destination - LeaseSet chứa các khóa công khai mã hóa hiện tại - Xem đặc tả LeaseSet2 về cách xử lý khóa mã hóa\nKhóa Cơ sở dữ liệu mạng: - LeaseSet được định danh bằng giá trị băm SHA-256 của Destination đầy đủ - Giá trị băm được tính trên toàn bộ cấu trúc 387+ byte\nJavaDoc: Destination Cấu trúc cơ sở dữ liệu mạng Lease (bản ghi mô tả tunnel đầu vào và thời điểm hết hạn trong I2P) Mô tả: Cho phép một tunnel cụ thể nhận thông điệp cho một Destination (điểm đích trong I2P). Là một phần của định dạng LeaseSet ban đầu (loại 1).\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch Tổng kích thước: 44 byte\nCách dùng: - Chỉ dùng trong LeaseSet gốc (loại 1, đã lỗi thời) - Đối với LeaseSet2 và các biến thể về sau, hãy dùng Lease2 thay thế\nJavaDoc: Lease LeaseSet (Loại 1) Mô tả: Định dạng LeaseSet ban đầu. Chứa các tunnel được ủy quyền và các khóa cho một Destination (điểm đích). Được lưu trong cơ sở dữ liệu mạng. Trạng thái: Đã ngừng sử dụng (hãy dùng LeaseSet2 thay thế).\nCấu trúc:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey Lưu trữ cơ sở dữ liệu: - Loại cơ sở dữ liệu: 1 - Khóa: băm SHA-256 của Destination (đích đến) - Giá trị: cấu trúc LeaseSet đầy đủ\nCác lưu ý quan trọng:\nKhóa công khai của Destination (địa chỉ đích trong I2P) không được sử dụng:\nTrường khóa công khai mã hóa trong Destination không được sử dụng Khóa mã hóa trong LeaseSet mới là khóa mã hóa thực tế Khóa tạm thời:\nencryption_key là tạm thời (được tạo lại khi router khởi động) signing_key là tạm thời (được tạo lại khi router khởi động) Không có khóa nào được lưu giữ qua các lần khởi động lại Thu hồi (Chưa triển khai):\nsigning_key được dự định dùng cho việc thu hồi LeaseSet Cơ chế thu hồi chưa bao giờ được triển khai Zero-lease LeaseSet (LeaseSet với số lượng lease bằng 0) được dự định dùng cho việc thu hồi nhưng không được sử dụng Phiên bản/Dấu thời gian:\nLeaseSet không có trường dấu thời gian published tường minh Phiên bản là thời điểm hết hạn sớm nhất của tất cả các lease (bản ghi thuê đường hầm) LeaseSet mới phải có thời điểm hết hạn của lease sớm hơn để được chấp nhận Công bố thời điểm hết hạn lease (mục thuê đường hầm trong I2P):\nTrước 0.9.7: Tất cả các lease được công bố với cùng thời điểm hết hạn (sớm nhất) 0.9.7+: Công bố thời điểm hết hạn thực tế cho từng lease Đây là chi tiết triển khai, không phải một phần của đặc tả Không có Lease:\nLeaseSet với số Lease (mục chỉ đường hầm trong LeaseSet) bằng 0 vẫn được phép về mặt kỹ thuật Dự định dùng để thu hồi (chưa được triển khai) Không được sử dụng trong thực tế Các biến thể LeaseSet2 yêu cầu ít nhất một Lease Ngưng dùng: LeaseSet loại 1 không còn được khuyến nghị. Các triển khai mới nên dùng LeaseSet2 (type 3), cung cấp:\nTrường dấu thời gian xuất bản (quản lý phiên bản tốt hơn) Hỗ trợ nhiều khóa mã hóa Khả năng ký ngoại tuyến Thời điểm hết hạn lease (thời hạn sử dụng tunnel) 4 byte (so với 8 byte) Tùy chọn linh hoạt hơn JavaDoc: LeaseSet Các biến thể LeaseSet Lease2 (bản ghi Lease phiên bản 2 trong I2P) Mô tả: Định dạng lease (bản ghi tuyến có thời hạn trong leaseSet) được cải tiến với trường hết hạn 4 byte. Được sử dụng trong LeaseSet2 (type 3) và MetaLeaseSet (type 7).\nGiới thiệu: Phiên bản 0.9.38 (xem Đề xuất 123 )\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 Tổng kích thước: 40 byte (nhỏ hơn 4 byte so với Lease gốc)\nSo sánh với Lease gốc:\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet **Tài liệu JavaDoc:** [Lease2](http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html) OfflineSignature (chữ ký ngoại tuyến) Mô tả: Cấu trúc tùy chọn dành cho các khóa tạm thời đã được ký trước, cho phép công bố LeaseSet mà không cần truy cập trực tuyến vào khóa ký riêng tư của Destination (đích trong I2P).\nGiới thiệu: Phiên bản 0.9.38 (xem Đề xuất 123 )\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey Mục đích: - Cho phép tạo LeaseSet ngoại tuyến - Bảo vệ khóa chính của Destination khỏi bị lộ trực tuyến - Khóa tạm thời có thể bị thu hồi bằng cách công bố LeaseSet mới mà không cần chữ ký ngoại tuyến\nCác kịch bản sử dụng:\nCác đích bảo mật cao:\nKhóa ký chính được lưu trữ ngoại tuyến (HSM (mô-đun bảo mật phần cứng), lưu trữ lạnh) Các khóa tạm thời được tạo ngoại tuyến trong các khoảng thời gian giới hạn Khóa tạm thời bị xâm phạm không làm lộ khóa chính Công bố LeaseSet được mã hóa:\nEncryptedLeaseSet có thể bao gồm chữ ký ngoại tuyến Khóa công khai được làm mù (blinded public key) + chữ ký ngoại tuyến cung cấp bảo mật bổ sung Các cân nhắc về bảo mật:\nQuản lý thời hạn:\nĐặt thời hạn hợp lý (từ ngày đến tuần, không phải năm) Tạo khóa tạm thời mới trước khi hết hạn Thời hạn ngắn hơn = bảo mật tốt hơn, cần bảo trì nhiều hơn Tạo khóa:\nTạo các khóa tạm thời ngoại tuyến trong môi trường an toàn Ký bằng khóa chủ ngoại tuyến Chỉ truyền khóa tạm thời đã được ký + chữ ký đến router trực tuyến Thu hồi:\nCông bố LeaseSet mới không có chữ ký ngoại tuyến để ngầm thu hồi Hoặc công bố LeaseSet mới với khóa tạm thời khác Xác minh chữ ký:\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature Ghi chú triển khai: - Tổng kích thước thay đổi tùy theo sigtype (kiểu chữ ký) và loại khóa ký của Destination (đích trong I2P) - Kích thước tối thiểu: 4 + 2 + 32 (khóa EdDSA) + 64 (chữ ký EdDSA) = 102 byte - Kích thước tối đa thực tế: ~600 byte (khóa tạm thời RSA-4096 + chữ ký RSA-4096)\nTương thích với: - LeaseSet2 (loại 3) - EncryptedLeaseSet (loại 5) - MetaLeaseSet (loại 7)\nXem thêm: Đề xuất 123 để biết chi tiết về giao thức chữ ký ngoại tuyến.\nLeaseSet2Header (phần tiêu đề của LeaseSet2) Mô tả: Cấu trúc phần đầu dùng chung cho LeaseSet2 (kiểu 3) và MetaLeaseSet (kiểu 7).\nGiới thiệu: Phiên bản 0.9.38 (xem Đề xuất 123 )\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length Kích thước tổng tối thiểu: 395 byte (không tính chữ ký ngoại tuyến)\nĐịnh nghĩa các cờ (thứ tự bit: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility **Chi tiết về cờ:** Bit 0 - Khóa ngoại tuyến: - 0: Không có chữ ký ngoại tuyến, dùng khóa ký của Destination (điểm đích trong I2P) để xác minh chữ ký LeaseSet - 1: Cấu trúc OfflineSignature theo sau trường cờ\nBit 1 - Chưa công bố: - 0: LeaseSet đã được công bố theo chuẩn, nên được phát tán tới các floodfills - 1: LeaseSet chưa công bố (chỉ phía máy khách) - KHÔNG được phát tán, công bố, hoặc gửi để phản hồi các truy vấn - Nếu hết hạn, KHÔNG truy vấn netdb để thay thế (trừ khi bit 2 cũng được đặt) - Dùng cho tunnels cục bộ hoặc thử nghiệm\nBit 2 - Blinded (kể từ 0.9.42): - 0: LeaseSet tiêu chuẩn - 1: LeaseSet chưa mã hóa này sẽ được blinded (làm mù để ẩn danh) và mã hóa khi công bố - Phiên bản được công bố sẽ là EncryptedLeaseSet (loại 5) - Nếu hết hạn, truy vấn blinded location trong netdb để thay thế - Cũng phải đặt bit 1 thành 1 (không công bố + blinded) - Dùng cho các dịch vụ ẩn được mã hóa\nGiới hạn hết hạn:\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours **Yêu cầu về dấu thời gian xuất bản:** LeaseSet (type 1) không có trường published, khiến phải tìm thời điểm hết hạn sớm nhất của lease (bản ghi đường hầm) để xác định phiên bản. LeaseSet2 bổ sung dấu thời gian published tường minh với độ phân giải 1 giây.\nLưu ý triển khai quan trọng: - Routers PHẢI áp dụng giới hạn tốc độ cho việc công bố LeaseSet xuống chậm hơn rất nhiều so với một lần mỗi giây cho mỗi Destination (đích) - Nếu công bố nhanh hơn, đảm bảo mỗi LeaseSet mới có thời điểm published muộn hơn ít nhất 1 giây - Floodfills sẽ từ chối LeaseSet nếu thời điểm published không mới hơn phiên bản hiện tại - Khoảng thời gian tối thiểu khuyến nghị: 10-60 giây giữa các lần công bố\nVí dụ tính toán:\nLeaseSet2 (tối đa 11 phút):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet (tối đa 18,2 giờ):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) Phiên bản hóa: - LeaseSet được coi là \u0026ldquo;mới hơn\u0026rdquo; nếu dấu thời gian published lớn hơn - Floodfills chỉ lưu trữ và phát tán phiên bản mới nhất - Cần lưu ý khi Lease (bản ghi trong LeaseSet) cũ nhất trùng với Lease cũ nhất của LeaseSet trước đó\nLeaseSet2 (Loại 3) Mô tả: Định dạng LeaseSet hiện đại với nhiều khóa mã hóa, chữ ký ngoại tuyến và các bản ghi dịch vụ. Tiêu chuẩn hiện tại cho các dịch vụ ẩn của I2P.\nGiới thiệu: Phiên bản 0.9.38 (xem Đề xuất 123 )\nCấu trúc:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix Lưu trữ cơ sở dữ liệu: - Loại cơ sở dữ liệu: 3 - Khóa: Băm SHA-256 của Destination (đích) - Giá trị: Cấu trúc LeaseSet2 đầy đủ\nTính toán chữ ký số:\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key Thứ tự ưu tiên khóa mã hóa Đối với LeaseSet được công bố (máy chủ): - Các khóa được liệt kê theo thứ tự ưu tiên của máy chủ (ưu tiên cao nhất trước) - Các máy khách hỗ trợ nhiều loại NÊN tuân theo ưu tiên của máy chủ - Chọn loại được hỗ trợ đầu tiên trong danh sách - Nói chung, các loại khóa có số thứ tự cao hơn (mới hơn) bảo mật/hiệu quả hơn - Thứ tự khuyến nghị: Liệt kê các khóa theo thứ tự ngược theo mã loại (mới nhất trước)\nVí dụ về tùy chọn máy chủ:\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] Đối với LeaseSet chưa công bố (máy khách): - Về cơ bản, thứ tự khóa không quan trọng (hiếm khi có kết nối được thực hiện tới máy khách) - Tuân theo cùng quy ước để nhất quán\nChọn khóa phía client: - Tuân theo ưu tiên của máy chủ (chọn loại được hỗ trợ đầu tiên) - Hoặc dùng ưu tiên do triển khai quy định - Hoặc xác định ưu tiên kết hợp dựa trên khả năng của cả hai bên\nÁnh xạ tùy chọn Yêu cầu: - Các tùy chọn PHẢI được sắp xếp theo khóa (thứ tự từ điển, thứ tự byte UTF-8) - Việc sắp xếp đảm bảo tính bất biến của chữ ký - KHÔNG cho phép khóa trùng lặp\nĐịnh dạng chuẩn (Đề xuất 167 ):\nKể từ API 0.9.66 (tháng 6 năm 2025, bản phát hành 2.9.0), các tùy chọn bản ghi dịch vụ tuân theo một định dạng chuẩn hóa. Xem Đề xuất 167 để biết đặc tả đầy đủ.\nĐịnh dạng tùy chọn bản ghi dịch vụ:\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) Ví dụ về bản ghi dịch vụ:\n1. Máy chủ SMTP tự tham chiếu:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. Một máy chủ SMTP bên ngoài:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. Nhiều máy chủ SMTP (cân bằng tải):\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. Dịch vụ HTTP với tùy chọn ứng dụng:\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates Khuyến nghị TTL: - Tối thiểu: 86400 giây (1 ngày) - TTL dài hơn giúp giảm tải truy vấn netdb - Cân bằng giữa việc giảm số truy vấn và việc lan truyền cập nhật dịch vụ - Đối với dịch vụ ổn định: 604800 (7 ngày) hoặc lâu hơn\nGhi chú triển khai:\nKhóa mã hóa (tính đến phiên bản 0.9.44):\nElGamal (loại 0, 256 byte): Tương thích với hệ thống cũ X25519 (loại 4, 32 byte): Tiêu chuẩn hiện tại Các biến thể MLKEM: Post-quantum (mật mã hậu lượng tử) (beta, chưa hoàn thiện) Xác thực độ dài khóa:\nFloodfills và máy khách PHẢI có khả năng phân tích cú pháp các loại khóa không xác định Sử dụng trường keylen để bỏ qua các khóa không xác định Không được lỗi khi phân tích cú pháp nếu loại khóa không xác định Dấu thời gian công bố:\nXem các ghi chú về giới hạn tần suất trong LeaseSet2Header Khoảng cách tối thiểu 1 giây giữa các lần công bố Khuyến nghị: 10-60 giây giữa các lần công bố Chuyển đổi loại mã hóa:\nHỗ trợ nhiều khóa để cho phép chuyển đổi dần dần Liệt kê cả khóa cũ và khóa mới trong giai đoạn chuyển đổi Gỡ bỏ khóa cũ sau khi đã có đủ thời gian để các ứng dụng khách (client) nâng cấp JavaDoc: LeaseSet2 MetaLease Mô tả: Cấu trúc Lease cho MetaLeaseSet (LeaseSet dạng meta) có thể tham chiếu các LeaseSet khác thay vì tunnels. Được dùng để cân bằng tải và dự phòng.\nGiới thiệu: Phiên bản 0.9.38, dự kiến bắt đầu hoạt động từ 0.9.40 (xem Đề xuất 123 )\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 Tổng kích thước: 40 byte\nLoại mục (các bit cờ 3-0):\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) **Các kịch bản sử dụng:** Cân bằng tải:\nMetaLeaseSet (tập các MetaLease) với nhiều mục MetaLease Mỗi mục trỏ tới một LeaseSet2 (LeaseSet phiên bản 2) khác nhau Các client chọn dựa trên cost field (trường chi phí) Dự phòng:\nNhiều mục trỏ tới các LeaseSets (tập thông tin dùng để định tuyến đến một dịch vụ trong I2P) dự phòng Phương án dự phòng nếu LeaseSet chính không khả dụng Di chuyển dịch vụ:\nMetaLeaseSet (cấu trúc siêu dữ liệu tham chiếu tới các LeaseSet) trỏ tới LeaseSet mới Cho phép chuyển đổi mượt mà giữa các Destination (địa chỉ đích trong I2P) Cách sử dụng trường Cost: - Cost thấp = ưu tiên cao hơn - Cost 0 = ưu tiên cao nhất - Cost 255 = ưu tiên thấp nhất - Các client NÊN ưu tiên các mục có Cost thấp hơn - Các mục có Cost bằng nhau có thể được cân bằng tải ngẫu nhiên\nSo sánh với Lease2:\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing **JavaDoc:** [MetaLease](http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html) MetaLeaseSet (Loại 7) Mô tả: Biến thể LeaseSet chứa các mục MetaLease (kiểu bản ghi dùng để tạo liên kết gián tiếp tới các LeaseSet khác). Được dùng cho cân bằng tải, dự phòng và di chuyển dịch vụ.\nGiới thiệu: Được định nghĩa trong 0.9.38, dự kiến hoạt động từ 0.9.40 (xem Đề xuất 123 )\nTrạng thái: Đặc tả đã hoàn tất. Cần xác minh tình trạng triển khai trong môi trường sản xuất bằng cách đối chiếu với các bản phát hành I2P hiện tại.\nCấu trúc:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations Lưu trữ cơ sở dữ liệu: - Loại cơ sở dữ liệu: 7 - Khóa: băm SHA-256 của Destination (định danh đích trong I2P) - Giá trị: Cấu trúc MetaLeaseSet hoàn chỉnh\nTính toán chữ ký số:\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key Kịch bản sử dụng:\n1. Cân bằng tải:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. Chuyển đổi dự phòng:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. Di chuyển dịch vụ:\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. Kiến trúc đa tầng:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing Danh sách thu hồi:\nDanh sách thu hồi cho phép MetaLeaseSet thu hồi rõ ràng các LeaseSets đã được công bố trước đó:\nMục đích: Đánh dấu các Destination (đích) cụ thể là không còn hợp lệ Nội dung: Các băm SHA-256 của các cấu trúc Destination đã bị thu hồi Cách dùng: Các máy khách KHÔNG ĐƯỢC sử dụng các LeaseSets có băm Destination xuất hiện trong danh sách thu hồi Giá trị điển hình: Trống (numr=0) trong hầu hết các triển khai Ví dụ về thu hồi:\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached Xử lý hết hạn:\nMetaLeaseSet (tập leaseSet tổng hợp) sử dụng LeaseSet2Header (phần header của LeaseSet2) với giá trị tối đa expires=65535 seconds (~18,2 giờ):\nDài hơn nhiều so với LeaseSet2 (tối đa ~11 phút) Phù hợp cho cơ chế trỏ gián tiếp tương đối tĩnh Các LeaseSet được tham chiếu có thể có thời gian hết hạn ngắn hơn Các client phải kiểm tra thời gian hết hạn của cả MetaLeaseSet VÀ các LeaseSet được tham chiếu Ánh xạ tùy chọn:\nSử dụng cùng định dạng như các tùy chọn của LeaseSet2 Có thể bao gồm service records (bản ghi dịch vụ) (Proposal 167 ) PHẢI được sắp xếp theo khóa Service records thường mô tả dịch vụ cuối cùng, không phải cấu trúc gián tiếp Ghi chú triển khai phía máy khách:\nQuy trình phân giải:\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry Bộ nhớ đệm:\nLưu đệm cả MetaLeaseSet (tập LeaseSet tổng hợp) và các LeaseSet được tham chiếu Kiểm tra hết hạn ở cả hai cấp Theo dõi việc công bố MetaLeaseSet được cập nhật Chuyển đổi dự phòng:\nNếu mục nhập ưu tiên gặp lỗi, hãy thử mục nhập có chi phí thấp tiếp theo Cân nhắc đánh dấu các mục nhập lỗi là tạm thời không khả dụng Kiểm tra lại định kỳ để xem đã phục hồi chưa Tình trạng triển khai:\nĐề xuất 123 cho biết một số phần vẫn \u0026ldquo;đang trong quá trình phát triển.\u0026rdquo; Người triển khai nên: - Xác minh mức độ sẵn sàng cho môi trường sản xuất trong phiên bản I2P mục tiêu - Kiểm thử hỗ trợ MetaLeaseSet (một biến thể tổng hợp của leaseSet) trước khi triển khai - Kiểm tra xem có đặc tả được cập nhật trong các bản phát hành I2P mới hơn hay không\nTài liệu JavaDoc: MetaLeaseSet EncryptedLeaseSet (Loại 5) Mô tả: LeaseSet được mã hóa và làm mù để tăng cường quyền riêng tư. Chỉ có khóa công khai đã làm mù và siêu dữ liệu được hiển thị; các lease thực và khóa mã hóa đều được mã hóa.\nGiới thiệu: Được định nghĩa từ 0.9.38, hoạt động từ 0.9.39 (xem Đề xuất 123 )\nCấu trúc:\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key Lưu trữ cơ sở dữ liệu: - Loại cơ sở dữ liệu: 5 - Khóa: băm SHA-256 của blinded Destination (Destination được che giấu danh tính; không phải Destination gốc) - Giá trị: Cấu trúc EncryptedLeaseSet đầy đủ\nNhững điểm khác biệt quan trọng so với LeaseSet2:\nKHÔNG sử dụng cấu trúc LeaseSet2Header (có các trường tương tự nhưng bố cục khác) Blinded public key (khóa công khai được làm mù) thay vì Destination đầy đủ Tải trọng được mã hóa thay vì các leases và các khóa ở dạng rõ (cleartext) Khóa cơ sở dữ liệu là băm (hash) của Destination đã làm mù, không phải Destination gốc Tính toán chữ ký:\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key Yêu cầu về loại chữ ký:\nBẮT BUỘC sử dụng RedDSA_SHA512_Ed25519 (loại 11): - khóa công khai blinded (che mù) 32 byte - chữ ký 64 byte - Cần thiết để đảm bảo các thuộc tính bảo mật liên quan đến blinding - Xem [Đặc tả Red25519](//docs/specs/red25519-signature-scheme/\nNhững khác biệt chính so với EdDSA: - Khóa riêng được tạo bằng phép giảm modulo (không dùng clamping (kẹp bit)) - Chữ ký bao gồm 80 byte dữ liệu ngẫu nhiên - Sử dụng trực tiếp khóa công khai (không dùng giá trị băm) - Cho phép thao tác làm mù an toàn (blinding)\nBlinding (kỹ thuật làm mù trong mật mã) và Mã hóa:\nXem Đặc tả EncryptedLeaseSet để biết thông tin chi tiết đầy đủ:\n1. Làm mù khóa:\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. Vị trí cơ sở dữ liệu:\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. Các lớp mã hóa (Ba lớp):\nLớp 1 - Lớp xác thực (Truy cập của client): - Mã hóa: mã dòng ChaCha20 - Dẫn xuất khóa: HKDF với bí mật riêng cho từng client - Các client đã xác thực có thể giải mã lớp bên ngoài\nLớp 2 - Lớp mã hóa: - Mã hóa: ChaCha20 - Khóa: Được dẫn xuất từ DH (trao đổi khóa Diffie–Hellman) giữa máy khách và máy chủ - Chứa LeaseSet2 hoặc MetaLeaseSet thực tế\nLớp 3 - LeaseSet bên trong: - Bản đầy đủ của LeaseSet2 hoặc MetaLeaseSet - Bao gồm tất cả các tunnels, khóa mã hóa, tùy chọn - Chỉ có thể truy cập sau khi giải mã thành công\nDẫn xuất khóa mã hóa:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) Quy trình khám phá:\nDành cho các máy khách được ủy quyền:\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication Đối với các máy khách không được ủy quyền: - Không thể giải mã ngay cả khi họ tìm thấy EncryptedLeaseSet - Không thể xác định Destination (điểm đích trong I2P) gốc từ phiên bản đã được blinding (làm mù) - Không thể liên kết các EncryptedLeaseSet qua các chu kỳ blinding khác nhau (xoay vòng hàng ngày)\nThời gian hết hạn:\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived **Dấu thời gian xuất bản:** Các yêu cầu tương tự như LeaseSet2Header (phần tiêu đề của LeaseSet2): - Phải tăng thêm ít nhất 1 giây giữa các lần công bố - Floodfills từ chối nếu không mới hơn phiên bản hiện tại - Khuyến nghị: 10-60 giây giữa các lần công bố\nChữ ký ngoại tuyến với LeaseSets được mã hóa:\nCác cân nhắc đặc biệt khi sử dụng chữ ký ngoại tuyến: - Khóa công khai được làm mù được xoay hằng ngày - Chữ ký ngoại tuyến phải được tạo lại hằng ngày với khóa làm mù mới - HOẶC sử dụng chữ ký ngoại tuyến trên LeaseSet bên trong, không phải EncryptedLeaseSet (LeaseSet được mã hóa) bên ngoài - Xem ghi chú của Đề xuất 123 Ghi chú triển khai:\nỦy quyền máy khách:\nCó thể ủy quyền nhiều máy khách bằng các khóa khác nhau Mỗi máy khách được ủy quyền có thông tin xác thực giải mã riêng biệt Thu hồi quyền của máy khách bằng cách thay đổi các khóa ủy quyền Xoay vòng khóa hằng ngày:\nCác khóa bị làm mù thay đổi vào nửa đêm theo UTC Máy khách phải tính toán lại Destination (điểm đích) bị làm mù hằng ngày Các EncryptedLeaseSets cũ trở nên không thể được phát hiện sau khi xoay vòng Thuộc tính quyền riêng tư:\nFloodfills không thể xác định Destination gốc (đích dịch vụ I2P) Các máy khách không được ủy quyền không thể truy cập dịch vụ Các giai đoạn blinding (làm mù) khác nhau không thể liên kết với nhau Không có siêu dữ liệu dạng rõ ngoài các thời điểm hết hạn Hiệu năng:\nMáy khách phải thực hiện phép tính blinding (kỹ thuật làm mù trong mật mã) hằng ngày Mã hóa ba lớp làm tăng chi phí tính toán Cân nhắc lưu đệm LeaseSet bên trong đã được giải mã Các cân nhắc bảo mật:\nQuản lý khóa ủy quyền:\nPhân phối an toàn thông tin xác thực ủy quyền của máy khách Sử dụng thông tin xác thực duy nhất cho mỗi máy khách để thu hồi chi tiết Xoay vòng khóa ủy quyền theo định kỳ Đồng bộ hóa thời gian:\nBlinding hằng ngày (blinding: kỹ thuật “làm mù” để che giấu định danh) phụ thuộc vào ngày UTC được đồng bộ hóa Độ lệch đồng hồ có thể gây lỗi tra cứu Cân nhắc hỗ trợ blinding của ngày trước/tiếp theo để tăng khả năng chịu sai lệch Rò rỉ siêu dữ liệu:\nCác trường Published và expires ở dạng rõ (không mã hóa) Phân tích mẫu có thể để lộ các đặc điểm của dịch vụ Nếu lo ngại, hãy ngẫu nhiên hóa các khoảng thời gian công bố JavaDoc: EncryptedLeaseSet Cấu trúc Router Địa chỉ router Mô tả: Định nghĩa thông tin kết nối cho một router thông qua một giao thức truyền tải cụ thể.\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary NGHIÊM TRỌNG - Trường hết hạn:\n⚠️ Trường hết hạn PHẢI được đặt thành toàn số 0 (8 byte số 0).\nLý do: Kể từ bản phát hành 0.9.3, thời gian hết hạn khác 0 gây lỗi xác minh chữ ký Lịch sử: Ban đầu trường hết hạn không được sử dụng, luôn là null Tình trạng hiện tại: Trường đã được nhận diện lại kể từ 0.9.12, nhưng phải chờ nâng cấp mạng Triển khai: Luôn đặt thành 0x0000000000000000 Bất kỳ thời điểm hết hạn khác 0 nào cũng sẽ khiến việc xác minh chữ ký của RouterInfo (thông tin router) thất bại.\nCác giao thức truyền tải Các giao thức hiện tại (tính đến phiên bản 2.10.0):\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 **Các giá trị kiểu Transport:** - `\"SSU2\"`: Transport dựa trên UDP hiện hành - `\"NTCP2\"`: Transport dựa trên TCP hiện hành - `\"NTCP\"`: Lỗi thời, đã bị loại bỏ (không sử dụng) - `\"SSU\"`: Lỗi thời, đã bị loại bỏ (không sử dụng) Tùy chọn chung Tất cả các giao thức truyền tải thường bao gồm:\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) Các tùy chọn dành riêng cho SSU2 Xem đặc tả SSU2 để biết chi tiết đầy đủ.\nCác tùy chọn bắt buộc:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Tùy chọn không bắt buộc:\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) Ví dụ SSU2 RouterAddress:\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 Các tùy chọn cụ thể cho NTCP2 Xem Đặc tả NTCP2 để biết thông tin chi tiết đầy đủ.\nTùy chọn bắt buộc:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Các tùy chọn không bắt buộc (từ 0.9.50):\n\u0026#34;caps\u0026#34; = Capability string Ví dụ về RouterAddress NTCP2:\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 Ghi chú triển khai Các giá trị chi phí:\nUDP (SSU2) thường có chi phí thấp hơn (5-6) nhờ hiệu quả TCP (NTCP2) thường có chi phí cao hơn (10-11) do overhead (chi phí phụ trội) Chi phí thấp hơn = phương thức truyền tải được ưu tiên Nhiều địa chỉ:\nRouters có thể công bố nhiều bản ghi RouterAddress Các phương thức truyền tải khác nhau (SSU2 và NTCP2) Các phiên bản IP khác nhau (IPv4 và IPv6) Các ứng dụng khách lựa chọn dựa trên chi phí và khả năng Tên máy chủ (hostname) so với IP:\nĐịa chỉ IP được ưu tiên để có hiệu năng tốt hơn Tên máy chủ (hostname) được hỗ trợ nhưng làm tăng chi phí tra cứu DNS Cân nhắc dùng IP cho các RouterInfos (RouterInfo: thông tin về router trong I2P) được công bố Mã hóa Base64:\nTất cả khóa và dữ liệu nhị phân được mã hóa bằng Base64 Base64 tiêu chuẩn (RFC 4648) Không có padding hoặc ký tự không tiêu chuẩn JavaDoc (tài liệu API Java): RouterAddress RouterInfo (thông tin về router) Mô tả: Thông tin được công bố đầy đủ về một router, được lưu trữ trong cơ sở dữ liệu mạng. Bao gồm danh tính, địa chỉ và khả năng.\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey Lưu trữ cơ sở dữ liệu: - Loại cơ sở dữ liệu: 0 - Khóa: băm SHA-256 của RouterIdentity - Giá trị: Cấu trúc RouterInfo đầy đủ\nDấu thời gian xuất bản: - Kiểu Date 8 byte (mili giây kể từ epoch) - Dùng cho quản lý phiên bản RouterInfo - Các router công bố RouterInfo mới theo định kỳ - Các floodfill giữ phiên bản mới nhất dựa trên dấu thời gian đã xuất bản\nSắp xếp địa chỉ: - Trước đây: Các router rất cũ yêu cầu địa chỉ được sắp xếp theo SHA-256 của dữ liệu của chúng - Hiện tại: Không cần sắp xếp, không đáng để triển khai chỉ vì tương thích - Địa chỉ có thể theo bất kỳ thứ tự nào\nTrường kích thước peer (lịch sử): - Luôn là 0 trong I2P hiện đại - Được dự định cho các tuyến bị hạn chế (chưa được triển khai) - Nếu được triển khai, sẽ theo sau bởi bấy nhiêu Router Hashes - Một số bản triển khai cũ có thể đã yêu cầu danh sách peer được sắp xếp\nÁnh xạ tùy chọn:\nCác tùy chọn PHẢI được sắp xếp theo khóa. Các tùy chọn tiêu chuẩn bao gồm:\nTùy chọn khả năng:\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable Tùy chọn mạng:\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; Tùy chọn thống kê:\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string Xem tài liệu RouterInfo của Cơ sở dữ liệu mạng để biết danh sách đầy đủ các tùy chọn tiêu chuẩn.\nTính toán chữ ký:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length RouterInfo (thông tin về router) hiện đại điển hình:\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical Ghi chú hiện thực:\nNhiều địa chỉ:\nCác router thường quảng bá 1-4 địa chỉ Các biến thể IPv4 và IPv6 Các giao thức truyền tải SSU2 và/hoặc NTCP2 Mỗi địa chỉ độc lập Phiên bản hóa:\nRouterInfo (thông tin mô tả router) mới hơn có dấu thời gian published muộn hơn Routers xuất bản lại khoảng mỗi ~2 giờ hoặc khi địa chỉ thay đổi Floodfills chỉ lưu và phát tán phiên bản mới nhất Thẩm định:\nXác minh chữ ký trước khi chấp nhận RouterInfo Kiểm tra trường expiration là toàn số 0 trong mỗi RouterAddress Xác minh ánh xạ options được sắp xếp theo khóa Kiểm tra loại chứng chỉ và loại khóa là đã biết/được hỗ trợ Cơ sở dữ liệu mạng (netDb):\nCác floodfill lưu trữ RouterInfo được lập chỉ mục theo Hash(RouterIdentity) Được lưu trong ~2 ngày sau lần công bố cuối cùng Các router truy vấn các floodfill để khám phá các router khác JavaDoc: RouterInfo Ghi chú triển khai Thứ tự byte (Endianness — cách sắp xếp byte theo big-endian/little-endian) Mặc định: Big-Endian (thứ tự byte mạng)\nHầu hết các cấu trúc I2P sử dụng thứ tự byte big-endian (byte có trọng số lớn ở trước): - Tất cả các kiểu số nguyên (1-8 byte) - Dấu thời gian ngày giờ - TunnelId - Tiền tố độ dài chuỗi - Các loại và độ dài chứng chỉ - Mã loại khóa - Các trường kích thước ánh xạ\nNgoại lệ: Little-Endian (thứ tự byte: byte thấp trước)\nCác loại khóa sau sử dụng mã hóa little-endian (thứ tự byte nhỏ-đầu): - X25519 khóa mã hóa (loại 4) - EdDSA_SHA512_Ed25519 khóa ký (loại 7) - EdDSA_SHA512_Ed25519ph khóa ký (loại 8) - RedDSA_SHA512_Ed25519 khóa ký (loại 11)\nHiện thực:\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); Phiên bản hóa cấu trúc Không bao giờ giả định kích thước cố định:\nNhiều cấu trúc có độ dài thay đổi: - RouterIdentity (định danh router): 387+ byte (không phải lúc nào cũng là 387) - Destination (đích đến): 387+ byte (không phải lúc nào cũng là 387) - LeaseSet2 (tập leaseSet phiên bản 2): thay đổi đáng kể - Chứng chỉ: 3+ byte\nLuôn đọc các trường độ dài: - Độ dài chứng chỉ ở các byte 1-2 - Kích thước mapping (ánh xạ) ở phần đầu - KeysAndCert luôn được tính là 384 + 3 + certificate_length\nKiểm tra dữ liệu dư thừa: - Không cho phép dữ liệu rác ở phần đuôi sau các cấu trúc hợp lệ - Xác minh độ dài chứng chỉ khớp với kiểu khóa - Bắt buộc độ dài chính xác như mong đợi cho các kiểu kích thước cố định\nKhuyến nghị hiện tại (Tháng 10 năm 2025) Dành cho các định danh Router mới:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/vi/proposals/161-ri-dest-padding/) Dành cho các điểm đích (Destination) mới:\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/vi/proposals/161-ri-dest-padding/) Đối với LeaseSets mới:\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per [Proposal 167](/proposals/167-service-records/) Signature: EdDSA (64 bytes) Dành cho các dịch vụ được mã hóa:\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys Các tính năng đã lỗi thời - Không sử dụng Mã hóa đã lỗi thời: - ElGamal (loại 0) cho Danh tính Router (không còn được khuyến nghị từ 0.9.58) - Mã hóa ElGamal/AES+SessionTag (hãy dùng ECIES-X25519)\nPhương thức ký đã lỗi thời: - DSA_SHA1 (loại 0) cho định danh Router (được đánh dấu ngừng dùng từ 0.9.58) - Các biến thể ECDSA (các loại 1-3) cho các triển khai mới - Các biến thể RSA (các loại 4-6) ngoại trừ các tệp SU3\nĐịnh dạng mạng đã lỗi thời: - LeaseSet loại 1 (hãy dùng LeaseSet2) - Lease (44 byte, hãy dùng Lease2) - Định dạng thời điểm hết hạn Lease ban đầu\nCác giao thức truyền tải đã lỗi thời: - NTCP (đã bị loại bỏ trong 0.9.50) - SSU (đã bị loại bỏ trong 2.4.0)\nChứng chỉ không còn được khuyến nghị sử dụng: - HASHCASH (loại 1) - HIDDEN (loại 2) - SIGNED (loại 3) - MULTIPLE (loại 4)\nCác cân nhắc bảo mật Sinh khóa: - Luôn sử dụng bộ sinh số ngẫu nhiên an toàn về mặt mật mã - Không bao giờ tái sử dụng khóa trong các bối cảnh khác nhau - Bảo vệ khóa riêng tư bằng các cơ chế kiểm soát truy cập phù hợp - Xóa an toàn dữ liệu khóa khỏi bộ nhớ khi hoàn tất\nXác minh chữ ký: - Luôn xác minh chữ ký trước khi tin cậy dữ liệu - Kiểm tra độ dài chữ ký khớp với loại khóa - Xác nhận dữ liệu đã ký bao gồm các trường mong đợi - Đối với các ánh xạ đã sắp xếp, hãy kiểm tra thứ tự sắp xếp trước khi ký/xác minh\nXác thực dấu thời gian: - Kiểm tra rằng các thời gian được công bố là hợp lý (không quá xa trong tương lai) - Xác thực thời hạn lease (bản ghi đường hầm trong I2P) chưa hết hạn - Cân nhắc dung sai độ lệch đồng hồ (thường ±30 giây)\nCơ sở dữ liệu mạng: - Xác thực tất cả các cấu trúc trước khi lưu trữ - Thực thi giới hạn kích thước để ngăn chặn tấn công từ chối dịch vụ (DoS) - Giới hạn tốc độ các truy vấn và việc công bố - Xác minh khóa cơ sở dữ liệu khớp với giá trị băm của cấu trúc\nGhi chú về khả năng tương thích Tương thích ngược: - ElGamal và DSA_SHA1 vẫn được hỗ trợ cho các routers đời cũ - Các kiểu khóa đã lỗi thời vẫn hoạt động nhưng không được khuyến khích - Đệm có thể nén (Proposal 161 ) tương thích ngược đến 0.6\nTương thích về sau: - Các loại khóa không xác định có thể được phân tích dựa vào các trường độ dài - Các loại chứng chỉ không xác định có thể được bỏ qua dựa vào độ dài - Các loại chữ ký không xác định nên được xử lý một cách an toàn, không gây lỗi - Các bản triển khai không nên lỗi khi gặp các tính năng tùy chọn không xác định\nChiến lược di chuyển: - Hỗ trợ cả các loại khóa cũ và mới trong giai đoạn chuyển đổi - LeaseSet2 có thể liệt kê nhiều khóa mã hóa - Chữ ký ngoại tuyến cho phép xoay vòng khóa an toàn - MetaLeaseSet cho phép di chuyển dịch vụ một cách minh bạch\nKiểm thử và thẩm định Xác thực cấu trúc: - Xác minh tất cả các trường độ dài nằm trong phạm vi mong đợi - Kiểm tra rằng các cấu trúc có độ dài biến đổi được phân tích cú pháp chính xác - Xác thực rằng chữ ký số được xác minh thành công - Kiểm thử với cả các cấu trúc có kích thước tối thiểu và tối đa\nCác trường hợp biên: - Chuỗi có độ dài 0 - Ánh xạ rỗng - Số lượng lease (bản ghi lease trong I2P) tối thiểu và tối đa - Chứng chỉ có nội dung độ dài 0 - Các cấu trúc rất lớn (gần kích thước tối đa)\nKhả năng tương tác: - Kiểm thử đối chiếu với bản triển khai I2P bằng Java chính thức - Xác minh khả năng tương thích với i2pd - Kiểm thử với nhiều nội dung cơ sở dữ liệu mạng khác nhau - Xác thực đối chiếu với các véc-tơ kiểm thử đã biết là đúng\nTài liệu tham khảo Đặc tả kỹ thuật Giao thức I2NP Giao thức I2CP Truyền tải SSU2 Truyền tải NTCP2 Giao thức Tunnel Giao thức Datagram Mật mã học Tổng quan về mật mã học Mã hóa ElGamal/AES Mã hóa ECIES-X25519 ECIES cho router ECIES lai (hậu lượng tử) Chữ ký Red25519 LeaseSet đã mã hóa Các đề xuất Đề xuất 123: Các bản ghi netDB mới Đề xuất 134: Kiểu chữ ký GOST Đề xuất 136: Kiểu chữ ký thử nghiệm Đề xuất 145: ECIES-P256 Đề xuất 156: ECIES Routers Đề xuất 161: Sinh phần đệm Đề xuất 167: Bản ghi dịch vụ Đề xuất 169: Mật mã hậu lượng tử Chỉ mục tất cả đề xuất Cơ sở dữ liệu mạng Tổng quan về netDb (Cơ sở dữ liệu mạng) Tùy chọn tiêu chuẩn của RouterInfo Tham chiếu API JavaDoc Gói dữ liệu cốt lõi PublicKey PrivateKey SessionKey SigningPublicKey SigningPrivateKey Signature Hash SessionTag TunnelId Certificate DataHelper KeysAndCert RouterIdentity Destination Lease LeaseSet Lease2 LeaseSet2 MetaLease MetaLeaseSet EncryptedLeaseSet RouterAddress RouterInfo Các tiêu chuẩn bên ngoài RFC 7748 (X25519): Đường cong elliptic cho bảo mật RFC 7539 (ChaCha20): ChaCha20 và Poly1305 cho các giao thức của IETF RFC 4648 (Base64): Các dạng mã hóa dữ liệu Base16, Base32 và Base64 FIPS 180-4 (SHA-256): Tiêu chuẩn băm an toàn FIPS 204 (ML-DSA): Module-Lattice-Based (dựa trên lưới mô-đun) Digital Signature Standard Sổ đăng ký dịch vụ IANA Tài nguyên cộng đồng Trang web I2P Diễn đàn I2P GitLab của I2P Bản sao trên GitHub của I2P Chỉ mục Tài liệu Kỹ thuật Thông tin phát hành Bản phát hành I2P 2.10.0 Lịch sử phát hành Nhật ký thay đổi Phụ lục: Bảng tham khảo nhanh Tham khảo nhanh các loại khóa Tiêu chuẩn hiện hành (khuyến nghị cho mọi triển khai mới): - Mã hóa: X25519 (loại 4, 32 byte, little-endian (thứ tự byte LSB trước)) - Ký: EdDSA_SHA512_Ed25519 (loại 7, 32 byte, little-endian)\nLegacy (được hỗ trợ nhưng không còn được khuyến nghị): - Mã hóa: ElGamal (kiểu 0, 256 byte, big-endian) - Ký số: DSA_SHA1 (kiểu 0, khóa riêng 20 byte / khóa công khai 128 byte, big-endian)\nChuyên biệt: - Ký (Encrypted LeaseSet): RedDSA_SHA512_Ed25519 (kiểu 11, 32 byte, little-endian (thứ tự byte nhỏ-đến-lớn))\nHậu lượng tử (Beta, chưa hoàn thiện): - Mã hóa lai: các biến thể MLKEM_X25519 (các loại 5-7) - Mã hóa PQ thuần: các biến thể MLKEM (chưa được gán mã loại)\nTham khảo nhanh kích thước cấu trúc Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes ### Tham khảo nhanh các loại cơ sở dữ liệu Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status ### Tham khảo nhanh về giao thức vận chuyển Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 ### Tham khảo nhanh các mốc phiên bản Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023[Proposal 161](/vi/proposals/161-ri-dest-padding/) padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025[Proposal 167](/proposals/167-service-records/) service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) --- ","description":"Các kiểu dữ liệu dùng chung và các định dạng tuần tự hóa được sử dụng xuyên suốt các đặc tả I2P","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"Cấu trúc chung","url":"/vi/docs/specs/common-structures/"},{"categories":null,"content":"Hosting GitLab bên trong I2P khá đơn giản: chạy container GitLab omnibus, expose nó trên loopback, và forward traffic thông qua I2P tunnel. Các bước dưới đây tương tự với cấu hình được sử dụng cho git.idk.i2p nhưng có thể áp dụng cho bất kỳ instance tự host nào.\n1. Yêu cầu tiên quyết Debian hoặc một bản phân phối Linux khác đã cài đặt Docker Engine (sudo apt install docker.io hoặc docker-ce từ repo của Docker). Một I2P router (Java I2P hoặc i2pd) với băng thông đủ để phục vụ người dùng của bạn. Tùy chọn: một VM chuyên dụng để GitLab và router được cách ly khỏi môi trường desktop của bạn. 2. Tải Image GitLab docker pull gitlab/gitlab-ce:latest Image chính thức được xây dựng từ các lớp nền Ubuntu và được cập nhật thường xuyên. Kiểm tra Dockerfile nếu bạn cần thêm sự đảm bảo.\n3. Quyết định giữa Bridging và I2P-Only Chỉ I2P (I2P-only) các instance không bao giờ kết nối với các máy chủ clearnet. Người dùng có thể mirror các repository từ các dịch vụ I2P khác nhưng không từ GitHub/GitLab.com. Điều này tối đa hóa tính ẩn danh. Cầu nối (Bridged) các instance kết nối đến các máy chủ Git clearnet thông qua HTTP proxy. Điều này hữu ích để mirror các dự án công khai vào I2P nhưng nó làm mất tính ẩn danh của các yêu cầu gửi đi từ server. Nếu bạn chọn chế độ bridged, hãy cấu hình GitLab để sử dụng I2P HTTP proxy được bind trên Docker host (ví dụ http://172.17.0.1:4446). Proxy router mặc định chỉ lắng nghe trên 127.0.0.1; hãy thêm một tunnel proxy mới được bind vào địa chỉ gateway của Docker.\n4. Khởi động Container docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest Bind các cổng đã publish vào loopback; các I2P tunnel sẽ expose chúng khi cần thiết. Thay thế /srv/gitlab/... bằng đường dẫn lưu trữ phù hợp với host của bạn. Sau khi container đang chạy, truy cập https://127.0.0.1:8443/, đặt mật khẩu quản trị viên và cấu hình giới hạn tài khoản.\n5. Expose GitLab Through I2P Tạo ba tunnel máy chủ I2PTunnel:\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated Cấu hình mỗi tunnel với độ dài tunnel và băng thông phù hợp. Đối với các instance công khai, 3 hop với 4–6 tunnel mỗi chiều là điểm khởi đầu tốt. Công bố các địa chỉ đích Base32/Base64 thu được trên trang landing page của bạn để người dùng có thể cấu hình client tunnel. Destination Enforcement Nếu bạn sử dụng HTTP(S) tunnel, hãy bật destination enforcement (cưỡng chế đích đến) để chỉ hostname dự định mới có thể truy cập dịch vụ. Điều này ngăn tunnel bị lạm dụng như một proxy chung.\n6. Maintenance Tips Chạy docker exec gitlab gitlab-ctl reconfigure mỗi khi bạn thay đổi cài đặt GitLab. Theo dõi dung lượng đĩa (/srv/gitlab/data)—các repository Git phát triển nhanh chóng. Sao lưu thư mục cấu hình và dữ liệu thường xuyên. Các tác vụ rake backup của GitLab hoạt động bên trong container. Cân nhắc đặt một tunnel giám sát bên ngoài ở chế độ client để đảm bảo dịch vụ có thể truy cập được từ mạng lưới rộng hơn. 6. Mẹo Bảo Trì Nhúng I2P vào ứng dụng của bạn Git trên I2P (hướng dẫn client) Git bundles cho mạng chậm/ngoại tuyến Một instance GitLab được cấu hình tốt cung cấp một trung tâm phát triển cộng tác hoàn toàn bên trong I2P. Giữ cho router khỏe mạnh, cập nhật thường xuyên các bản vá bảo mật của GitLab, và phối hợp với cộng đồng khi số lượng người dùng của bạn tăng lên.\n","description":"Triển khai GitLab bên trong I2P sử dụng Docker và I2P router","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"Chạy GitLab trên I2P","url":"/vi/docs/guides/gitlab/"},{"categories":null,"content":" 1. Tổng quan netDb là một cơ sở dữ liệu phân tán chuyên biệt, chỉ chứa hai loại dữ liệu: - RouterInfos – thông tin liên hệ của router - LeaseSets – thông tin liên hệ của destination (đích)\nTất cả dữ liệu đều được ký số và có thể xác minh. Mỗi mục bao gồm thông tin liveliness (tính sống/khả năng hoạt động) nhằm loại bỏ các mục đã lỗi thời và thay thế những mục cũ, giúp bảo vệ trước một số lớp tấn công nhất định.\nViệc phân phối sử dụng cơ chế floodfill, trong đó một tập con các router duy trì cơ sở dữ liệu phân tán.\n2. RouterInfo (thông tin về router) Khi các router cần liên lạc với các router khác, chúng trao đổi các gói RouterInfo chứa:\nĐịnh danh Router – khóa mã hóa, khóa ký, chứng chỉ Địa chỉ liên hệ – cách để kết nối tới router Dấu thời gian công bố – thời điểm thông tin này được công bố Các tùy chọn văn bản tùy ý – cờ khả năng và thiết lập Chữ ký mật mã – chứng minh tính xác thực 2.1 Các cờ khả năng Các router quảng bá các khả năng thông qua các mã chữ cái trong RouterInfo của chúng:\nFlag Meaning f Floodfill participation R Reachable U Unreachable D, E, G, H Various capability indicators ### 2.2 Phân loại băng thông Code Bandwidth K Under 12 KBps L 12–48 KBps (default) M 48–64 KBps N 64–128 KBps O 128–256 KBps P 256–2000 KBps X Over 2000 KBps ### 2.3 Các giá trị ID mạng Value Purpose 0 Reserved 1 Current Network (default) 2 Reserved for Future Networks 3–15 Forks and Test Networks 16–254 Reserved 255 Reserved ### 2.4 Thống kê RouterInfo (thông tin về router) Các router công bố các thống kê tình trạng tùy chọn phục vụ phân tích mạng: - Tỷ lệ xây dựng thành công/từ chối/hết thời gian chờ của Exploratory tunnel (tunnel thăm dò) - Số lượng tunnel tham gia trung bình trong 1 giờ\nCác thống kê tuân theo định dạng stat_(statname).(statperiod) với các giá trị được phân tách bằng dấu chấm phẩy.\nVí dụ về số liệu thống kê:\nstat_tunnel.buildExploratoryExpire.60m = 0;0;0;53.14 stat_tunnel.buildExploratoryReject.60m = 0;0;0;15.51 stat_tunnel.buildExploratorySuccess.60m = 0;0;0;31.35 stat_tunnel.participatingTunnels.60m = 289.20 Floodfill routers cũng có thể công bố: netdb.knownLeaseSets và netdb.knownRouters\n2.5 Tùy chọn Family (nhóm các router do cùng một đơn vị vận hành) Kể từ phiên bản 0.9.24, routers có thể khai báo tư cách thành viên family (cùng một người vận hành):\nfamily: Tên family (nhóm router do cùng một nhà vận hành) family.key: Mã kiểu chữ ký được nối với khóa công khai dùng để ký được mã hóa Base64 family.sig: Chữ ký trên tên family và mã băm router dài 32 byte Nhiều router trong cùng một family (nhóm các router do cùng một nhà vận hành) sẽ không được sử dụng trong cùng một tunnel.\n2.6 Hết hạn của RouterInfo (thông tin về router) Không hết hạn trong giờ hoạt động đầu tiên Không hết hạn khi có 25 hoặc ít hơn RouterInfos (bản ghi thông tin router) được lưu trữ Thời hạn hết hạn rút ngắn khi số lượng cục bộ tăng (72 giờ ở mức \u0026lt;120 routers; ~30 giờ ở 300 routers) SSU introducers (điểm giới thiệu trong SSU) hết hạn trong ~1 giờ Floodfills sử dụng thời hạn 1 giờ cho tất cả RouterInfos cục bộ 3. LeaseSet LeaseSets mô tả các điểm vào của tunnel cho các đích cụ thể, chỉ rõ:\nDanh tính router gateway của Tunnel ID tunnel 4 byte Thời gian hết hạn của Tunnel LeaseSets bao gồm: - Destination (đích đến) – khóa mã hóa, khóa ký, chứng chỉ - Khóa công khai mã hóa bổ sung – cho garlic encryption đầu-cuối - Khóa công khai ký bổ sung – dự kiến dùng cho việc thu hồi (hiện chưa sử dụng) - Chữ ký mật mã\n3.1 Các biến thể LeaseSet (tập hợp lease) Type Description Unpublished Destinations used only for outgoing connections aren't published to floodfill routers Revoked Published with zero leases, signed by additional signing key (not fully implemented) LeaseSet2 (LS2) As of 0.9.38, supports new encryption types, multiple encryption types, options, offline signing keys ([Proposal 123](/proposals/123-new-netdb-entries/)) Meta LeaseSet Tree-like DHT structure for multihomed services, supporting hundreds/thousands of destinations with long expirations (up to 18.2 hours) Encrypted LeaseSet (LS1) All leases encrypted with separate key; only those with the key can decode and contact the destination Encrypted LeaseSet (LS2) As of 0.9.38, destination hidden with only blinded public key and expiration visible to floodfill ### 3.2 Hết hạn của LeaseSet Các LeaseSet thông thường sẽ hết hạn tại thời điểm hết hạn lease (bản ghi tunnel) muộn nhất của chúng. Thời điểm hết hạn của LeaseSet2 được chỉ định trong tiêu đề. Thời điểm hết hạn của EncryptedLeaseSet và MetaLeaseSet có thể khác nhau, với khả năng thực thi giới hạn tối đa.\n4. Khởi tạo ban đầu netDb phi tập trung yêu cầu ít nhất một tham chiếu peer để tham gia mạng. Reseeding (khởi tạo mạng ban đầu) lấy các tệp RouterInfo (routerInfo-$hash.dat) từ các thư mục netDb của những tình nguyện viên. Lần khởi động đầu tiên tự động lấy từ các URL được ghi cứng trong mã, được chọn ngẫu nhiên.\n5. Cơ chế Floodfill netDb dạng floodfill sử dụng cơ chế lưu trữ phân tán đơn giản: gửi dữ liệu tới nút floodfill gần nhất. Khi các nút không phải floodfill gửi các bản ghi lưu trữ, các nút floodfill sẽ chuyển tiếp tới một tập con các nút floodfill gần nhất với khóa cụ thể.\nViệc tham gia floodfill được biểu thị là một cờ khả năng (f) trong RouterInfo.\n5.1 Các yêu cầu tham gia tự nguyện cho Floodfill Không giống như các máy chủ thư mục đáng tin cậy được cố định trong mã của Tor, tập hợp floodfill của I2P là không được tin cậy và thay đổi theo thời gian.\nFloodfill chỉ tự động bật trên các routers có băng thông cao đáp ứng các yêu cầu sau: - Băng thông chia sẻ tối thiểu 128 KBytes/giây (cấu hình thủ công) - Phải vượt qua các kiểm tra tình trạng bổ sung (thời gian hàng đợi thông điệp gửi đi, job lag (độ trễ tác vụ))\nCơ chế tự động tham gia hiện tại dẫn đến khoảng 6% tỷ lệ tham gia floodfill trong mạng.\nCác floodfill (nút đặc biệt của I2P dùng để lưu trữ/phổ biến netDb) được cấu hình thủ công tồn tại song song với các router tự nguyện được kích hoạt tự động. Khi số lượng floodfill giảm xuống dưới ngưỡng, các router băng thông cao sẽ tự động tình nguyện làm floodfill. Khi có quá nhiều floodfill, các router đó sẽ tự bỏ chế độ floodfill.\n5.2 Các vai trò của Floodfill Ngoài việc tiếp nhận các yêu cầu lưu trữ netDb và phản hồi các truy vấn, các floodfill thực hiện những chức năng tiêu chuẩn của router. Băng thông cao hơn của chúng thường đồng nghĩa với việc tham gia tunnel nhiều hơn, nhưng điều này không liên quan trực tiếp đến các dịch vụ cơ sở dữ liệu.\n6. Thước đo độ gần trong Kademlia netDb sử dụng phép đo khoảng cách dựa trên XOR theo kiểu Kademlia (một giao thức DHT). Hàm băm SHA256 của RouterIdentity hoặc Destination tạo ra khóa Kademlia (ngoại trừ LS2 Encrypted LeaseSets, vốn sử dụng SHA256 của byte loại 3 cộng với khóa công khai được làm mù).\n6.1 Luân chuyển không gian khóa Để tăng chi phí cho các cuộc tấn công Sybil, thay vì sử dụng SHA256(key), hệ thống sử dụng:\nSHA256(key + yyyyMMdd) trong đó ngày là một chuỗi ASCII 8 byte biểu diễn ngày UTC. Điều này tạo ra routing key (khóa định tuyến), thay đổi hằng ngày vào nửa đêm UTC—gọi là keyspace rotation (luân phiên không gian khóa).\nCác khóa định tuyến không bao giờ được truyền trong các thông điệp I2NP; chúng chỉ được dùng để xác định khoảng cách cục bộ.\n7. Phân đoạn Cơ sở dữ liệu mạng (netDb) Các DHT Kademlia truyền thống không duy trì tính không thể liên kết của thông tin được lưu trữ. I2P ngăn chặn các cuộc tấn công nhằm liên kết các tunnel phía client với các router bằng cách triển khai phân đoạn.\n7.1 Chiến lược phân đoạn Các router theo dõi: - Liệu các bản ghi đến qua tunnel của client hay trực tiếp - Nếu qua tunnel, là tunnel/destination (đích) của client nào - Nhiều lần đến qua tunnel đều được theo dõi - Phân biệt phản hồi lưu trữ và phản hồi tra cứu\nCả hai triển khai Java và C++ đều sử dụng: - Một \u0026ldquo;Main\u0026rdquo; netDb để tra cứu trực tiếp/các thao tác floodfill trong ngữ cảnh router - \u0026ldquo;Client Network Databases\u0026rdquo; hoặc \u0026ldquo;Sub-Databases\u0026rdquo; trong ngữ cảnh client, thu nhận các bản ghi được gửi tới các tunnel của client\nCác netDb của ứng dụng khách chỉ tồn tại trong suốt vòng đời của ứng dụng khách, và chỉ chứa các mục tunnel của ứng dụng khách. Các mục từ các tunnel của ứng dụng khách không được trùng lặp với các lượt đến trực tiếp.\nMỗi netDb theo dõi liệu các mục đến dưới dạng store (thông điệp lưu trữ) — sẽ phản hồi các yêu cầu tra cứu — hay dưới dạng lookup reply (phản hồi tra cứu), trường hợp này chỉ phản hồi nếu trước đó đã được lưu tới cùng một Destination (đích trong I2P). Các client không bao giờ trả lời truy vấn bằng các mục Main netDb, mà chỉ bằng các mục trong cơ sở dữ liệu mạng của client.\nCác chiến lược kết hợp phân đoạn netDb để chống lại các cuộc tấn công nhằm liên kết client với router.\n8. Lưu trữ, xác minh và tra cứu 8.1 Lưu trữ RouterInfo (thông tin router) tới các nút I2NP DatabaseStoreMessage chứa RouterInfo cục bộ được trao đổi trong quá trình khởi tạo kết nối truyền tải NTCP hoặc SSU.\n8.2 Lưu trữ LeaseSet tới các nút ngang hàng Các I2NP DatabaseStoreMessage chứa LeaseSet cục bộ được trao đổi định kỳ qua các thông điệp được mã hóa bằng garlic encryption, được gói kèm với lưu lượng Destination (đích I2P), cho phép phản hồi mà không cần tra cứu LeaseSet.\n8.3 Lựa chọn Floodfill (router đặc biệt trong I2P để lưu trữ và phổ biến netDb) DatabaseStoreMessage gửi tới floodfill gần nhất so với khóa định tuyến hiện tại. Floodfill gần nhất được tìm qua tra cứu trong cơ sở dữ liệu cục bộ. Ngay cả khi không thực sự gần nhất, flooding (cơ chế phát tán diện rộng) sẽ lan truyền nó \u0026ldquo;gần hơn\u0026rdquo; bằng cách gửi tới nhiều floodfill.\nKademlia truyền thống (một giao thức bảng băm phân tán - DHT) sử dụng tìm kiếm \u0026lsquo;find-closest\u0026rsquo; trước khi chèn. Trong khi I2NP không có các thông điệp như vậy, các router có thể thực hiện tìm kiếm lặp từng bước với bit ít ý nghĩa nhất được đảo (key ^ 0x01) để bảo đảm tìm ra nút gần nhất chính xác.\n8.4 Lưu trữ RouterInfo tới các Floodfill Các router công bố RouterInfo bằng cách kết nối trực tiếp tới một floodfill, gửi I2NP DatabaseStoreMessage với Reply Token (mã thông báo phản hồi) khác 0. Thông điệp không được garlic encrypted end-to-end (kết nối trực tiếp, không có trung gian). Floodfill phản hồi bằng DeliveryStatusMessage, sử dụng Reply Token làm Message ID (ID thông điệp).\nCác router cũng có thể gửi RouterInfo (thông tin về router) thông qua tunnel thăm dò (giới hạn kết nối, không tương thích, ẩn IP). Các floodfill có thể từ chối các yêu cầu lưu trữ như vậy khi quá tải.\n8.5 Lưu trữ LeaseSet tới các Floodfills Việc lưu trữ LeaseSet (bộ mô tả đích trong I2P) nhạy cảm hơn so với RouterInfo (thông tin nhận dạng của router). Các router (nút I2P) phải ngăn chặn việc liên kết LeaseSet với chính chúng.\nRouters công bố LeaseSet bằng cách gửi DatabaseStoreMessage qua tunnel client đi ra, với Reply Token (mã thông báo phản hồi) khác 0. Thông điệp được mã hóa end-to-end bằng garlic encryption sử dụng Session Key Manager (trình quản lý khóa phiên) của Destination (đích I2P), che giấu khỏi điểm cuối đi ra của tunnel. Floodfill phản hồi bằng DeliveryStatusMessage được trả về qua tunnel đi vào.\n8.6 Quy trình phát tán Các floodfill xác thực RouterInfo (thông tin router)/LeaseSet bằng các tiêu chí thích ứng phụ thuộc vào tải, kích thước netdb và các yếu tố khác trước khi lưu cục bộ.\nSau khi nhận được dữ liệu mới hơn hợp lệ, các floodfill \u0026ldquo;flood\u0026rdquo; nó bằng cách tìm 3 router floodfill gần nhất so với khóa định tuyến. Các kết nối trực tiếp gửi I2NP DatabaseStoreMessage với Reply Token (mã phản hồi) bằng 0. Các router khác không phản hồi hay flood lại.\nRàng buộc quan trọng: - Floodfills không được phát tán qua tunnels; chỉ kết nối trực tiếp - Floodfills không bao giờ phát tán LeaseSet đã hết hạn hoặc RouterInfo được công bố hơn một giờ trước\n8.7 Tra cứu RouterInfo và LeaseSet I2NP DatabaseLookupMessage yêu cầu các bản ghi netdb từ các router floodfill. Các tra cứu được gửi qua tunnel thăm dò đi ra; phản hồi chỉ định tunnel thăm dò đi vào để trả về.\nCác lần tra cứu thường được gửi song song tới hai floodfill routers \u0026ldquo;tốt\u0026rdquo; gần nhất với khóa được yêu cầu.\nKhớp cục bộ: nhận phản hồi I2NP DatabaseStoreMessage Không có khớp cục bộ: nhận I2NP DatabaseSearchReplyMessage với các tham chiếu router floodfill khác gần với khóa Tra cứu LeaseSet sử dụng garlic encryption đầu-cuối (kể từ phiên bản 0.9.5). Việc tra cứu RouterInfo (thông tin router) không được mã hóa do chi phí tính toán của ElGamal, khiến chúng dễ bị nghe lén tại điểm cuối hướng ra.\nKể từ phiên bản 0.9.7, các phản hồi tra cứu bao gồm khóa phiên và thẻ, nhằm che giấu phản hồi khỏi cổng vào.\n8.8 Tra cứu lặp Trước 0.8.9: Hai tra cứu dự phòng song song không có định tuyến đệ quy hoặc lặp.\nTừ 0.8.9: Tra cứu lặp (iterative lookups) được triển khai không dư thừa—hiệu quả hơn, đáng tin cậy hơn, và phù hợp với kiến thức floodfill không đầy đủ. Khi mạng phát triển và routers biết ít floodfill hơn, các lần tra cứu tiệm cận độ phức tạp O(log n).\nTra cứu lặp vẫn tiếp tục ngay cả khi không có tham chiếu đến nút ngang hàng gần hơn, ngăn chặn black-holing độc hại (chuyển vào “hố đen” để loại bỏ). Các giới hạn hiện hành về số lượng truy vấn tối đa và thời gian chờ vẫn được áp dụng.\n8.9 Xác minh Xác minh RouterInfo (thông tin của router): Đã bị vô hiệu hóa kể từ 0.9.7.1 để ngăn chặn các cuộc tấn công được mô tả trong bài báo \u0026ldquo;Practical Attacks Against the I2P Network\u0026rdquo;.\nLeaseSet Verification: Các router chờ ~10 giây, rồi thực hiện tra cứu từ một floodfill khác thông qua tunnel máy khách đi ra. Garlic encryption đầu-cuối (cơ chế mã hóa \u0026ldquo;garlic\u0026rdquo; gộp nhiều thông điệp) ẩn khỏi điểm cuối đi ra. Phản hồi quay về qua các tunnel đi vào.\nKể từ 0.9.7, các phản hồi được mã hóa bằng session key/tag (khóa phiên/thẻ phiên), ẩn khỏi inbound gateway (cổng vào).\n8.10 Thăm dò Thăm dò liên quan đến tra cứu netdb với các khóa ngẫu nhiên để khám phá các router mới. Các floodfill phản hồi bằng DatabaseSearchReplyMessage chứa các băm router không phải floodfill gần với khóa được yêu cầu. Các truy vấn thăm dò đặt một cờ đặc biệt trong DatabaseLookupMessage.\n9. MultiHoming (đa kết nối) Các Destination (địa chỉ đích trong I2P) sử dụng cùng một cặp khóa riêng/công khai (theo cách truyền thống qua eepPriv.dat) có thể chạy trên nhiều router đồng thời. Mỗi thể hiện sẽ định kỳ công bố các LeaseSets đã được ký; LeaseSet được công bố gần đây nhất sẽ được trả về cho các yêu cầu tra cứu. Với thời gian sống tối đa của LeaseSet là 10 phút, sự gián đoạn kéo dài nhiều nhất khoảng ~10 phút.\nKể từ 0.9.38, Meta LeaseSets hỗ trợ các dịch vụ multihomed (kết nối nhiều mạng/địa chỉ) quy mô lớn, sử dụng các Destinations (điểm đích) riêng biệt cung cấp các dịch vụ chung. Các bản ghi trong Meta LeaseSet là các Destinations hoặc các Meta LeaseSets khác với thời hạn hiệu lực tối đa 18.2 giờ, cho phép hàng trăm/hàng nghìn Destinations cung cấp các dịch vụ chung.\n10. Phân tích mối đe dọa Hiện có khoảng 1700 floodfill routers (các router đặc biệt dùng để lưu trữ và phân phối netDb) đang hoạt động. Sự phát triển của mạng khiến phần lớn các cuộc tấn công trở nên khó thực hiện hơn hoặc ít gây tác động hơn.\n10.1 Biện pháp giảm thiểu chung Tăng trưởng: Nhiều floodfill (nút đặc biệt lưu trữ netdb) hơn khiến các cuộc tấn công khó hơn hoặc ít tác động hơn Dự phòng: Tất cả các mục netdb (cơ sở dữ liệu mạng của I2P) được lưu trữ trên 3 floodfill routers gần khóa nhất thông qua flooding Chữ ký: Tất cả các mục đều được ký bởi người tạo; việc giả mạo là không thể 10.2 Router chậm hoặc không phản hồi Các router duy trì các thống kê hồ sơ peer mở rộng cho các floodfill: - Thời gian phản hồi trung bình - Tỷ lệ truy vấn được trả lời - Tỷ lệ thành công xác minh lưu trữ - Lần lưu trữ thành công gần nhất - Lần tra cứu thành công gần nhất - Phản hồi gần nhất\nCác router sử dụng các chỉ số này khi xác định \u0026ldquo;goodness\u0026rdquo; (mức độ tốt) để chọn floodfill gần nhất. Các router hoàn toàn không phản hồi được nhanh chóng nhận diện và tránh; các router độc hại ở mức độ nhất định đặt ra thách thức lớn hơn.\n10.3 Tấn công Sybil (toàn bộ không gian khóa) Những kẻ tấn công có thể tạo ra nhiều floodfill routers được phân tán khắp không gian khóa như một phương thức tấn công từ chối dịch vụ (DoS) hiệu quả.\nNếu không hành xử sai trái đủ mức để được gán nhãn \u0026ldquo;bad\u0026rdquo;, các biện pháp có thể bao gồm: - Biên soạn các danh sách hash/IP của router (nút trong I2P) xấu được thông báo qua bản tin bảng điều khiển, website, diễn đàn - Bật floodfill (router đặc biệt lưu trữ netDb) trên toàn mạng (\u0026ldquo;chống Sybil bằng nhiều Sybil hơn\u0026rdquo;) - Các phiên bản phần mềm mới với các danh sách \u0026ldquo;bad\u0026rdquo; cố định trong mã - Cải thiện các số đo và ngưỡng trong hồ sơ peer để nhận diện tự động - Tiêu chí khối IP loại trừ nhiều floodfill trong cùng một khối IP - Danh sách đen tự động dựa trên đăng ký (tương tự đồng thuận của Tor)\nCác mạng lớn hơn khiến việc này khó hơn.\n10.4 Tấn công Sybil (Không gian khóa một phần) Kẻ tấn công có thể tạo 8–15 router floodfill được gom cụm gần nhau trong không gian khóa. Mọi thao tác tra cứu/lưu trữ đối với không gian khóa đó sẽ được định tuyến tới các router của kẻ tấn công, tạo điều kiện cho tấn công từ chối dịch vụ (DoS) nhắm vào các trang I2P cụ thể.\nVì không gian khóa lập chỉ mục các hàm băm mật mã SHA-256, kẻ tấn công cần dùng vét cạn (brute-force) để tạo ra các routers có độ gần đủ.\nPhòng thủ: Thuật toán đo độ gần Kademlia (thuật toán DHT) thay đổi theo thời gian bằng SHA256(key + YYYYMMDD), cập nhật hằng ngày vào lúc nửa đêm UTC. Việc xoay vòng không gian khóa này buộc kẻ tấn công phải tái khởi tạo cuộc tấn công mỗi ngày.\nNote: Nghiên cứu gần đây cho thấy việc xoay vòng không gian khóa không mấy hiệu quả—kẻ tấn công có thể tiền tính các băm của router, chỉ cần vài router để chiếm lĩnh các phần của không gian khóa trong vòng nửa giờ sau khi xoay vòng.\nHệ quả của việc xoay vòng hằng ngày: netdb phân tán trở nên không đáng tin cậy trong vài phút sau khi xoay vòng—các lần tra cứu thất bại trước khi router gần nhất mới nhận được các stores (thông điệp lưu trữ).\n10.5 Tấn công Bootstrap (khởi tạo) Kẻ tấn công có thể chiếm quyền kiểm soát các trang web reseed (trang web cung cấp dữ liệu khởi động ban đầu cho router mới) hoặc đánh lừa các nhà phát triển thêm các trang web reseed độc hại, khiến các router mới khởi động vào các mạng bị cô lập hoặc do đa số kiểm soát.\nCác biện pháp phòng thủ đã triển khai: - Lấy các tập con RouterInfo từ nhiều trang reseed thay vì một trang duy nhất - Giám sát reseed ngoài mạng, định kỳ thăm dò các trang - Kể từ 0.9.14, các gói dữ liệu reseed dưới dạng tệp zip có chữ ký, kèm xác minh chữ ký được tải về (xem đặc tả su3 )\n10.6 Thu thập truy vấn Floodfill routers có thể \u0026ldquo;chuyển hướng\u0026rdquo; các nút ngang hàng tới các routers do kẻ tấn công kiểm soát thông qua các tham chiếu được trả về.\nÍt có khả năng thông qua thăm dò do tần suất thấp; routers chủ yếu thu được các tham chiếu đồng cấp thông qua việc xây dựng tunnel thông thường.\nKể từ 0.8.9, đã triển khai cơ chế tra cứu lặp. Các tham chiếu floodfill trong DatabaseSearchReplyMessage sẽ được lần theo nếu chúng gần với khóa tra cứu hơn. Các router gửi yêu cầu không tin cậy mức độ “gần” của tham chiếu. Việc tra cứu vẫn tiếp tục ngay cả khi không có khóa nào gần hơn cho đến khi hết thời gian chờ/số truy vấn tối đa, nhằm ngăn chặn hành vi black-holing (cố ý làm truy vấn “mất hút”).\n10.7 Rò rỉ thông tin Rò rỉ thông tin DHT (bảng băm phân tán) trong I2P cần được điều tra thêm. Floodfill routers có thể quan sát các truy vấn để thu thập thông tin. Khi tỷ lệ nút độc hại đạt 20%, các mối đe dọa Sybil được mô tả trước đó trở nên đáng lo ngại vì nhiều lý do.\n11. Công việc tương lai Mã hóa đầu-cuối cho các tra cứu và phản hồi netDb bổ sung Các phương pháp theo dõi phản hồi tra cứu tốt hơn Các phương pháp giảm thiểu cho các vấn đề độ tin cậy liên quan đến luân chuyển không gian khóa 12. Tài liệu tham khảo Đặc tả Cấu trúc Chung – Các cấu trúc RouterInfo (thông tin router) và LeaseSet Đặc tả I2NP – Các loại thông điệp cơ sở dữ liệu Đề xuất 123: Các bản ghi netDb mới – Đặc tả LeaseSet2 (phiên bản thứ hai của LeaseSet) Thảo luận netDb trong lịch sử – Lịch sử phát triển và các thảo luận đã lưu trữ ","description":"Hiểu về cơ sở dữ liệu mạng phân tán (netDb) của I2P - một DHT (bảng băm phân tán) chuyên biệt dành cho thông tin liên hệ của router và tra cứu đích đến","id":"ef0a5e8bee4372a50a7f4562af717b0c","section":"docs","title":"Cơ sở dữ liệu mạng","url":"/vi/docs/overview/network-database/"},{"categories":null,"content":"Tổng quan Datagram cung cấp giao tiếp định hướng thông điệp trên I2CP và song song với thư viện streaming. Chúng cho phép các gói tin có thể trả lời, được xác thực, hoặc thô mà không cần các luồng định hướng kết nối. Router đóng gói datagram vào các thông điệp I2NP và thông điệp tunnel, bất kể NTCP2 hay SSU2 mang lưu lượng đó.\nĐộng lực cốt lõi là cho phép các ứng dụng (như tracker, DNS resolver, hoặc game) gửi các gói tin độc lập có thể xác định người gửi của chúng.\nMới trong năm 2025: Dự án I2P đã phê duyệt Datagram2 (protocol 19) và Datagram3 (protocol 20), bổ sung khả năng bảo vệ chống replay và hệ thống nhắn tin có thể trả lời với chi phí thấp hơn lần đầu tiên trong một thập kỷ.\n1. Hằng số Giao thức Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) Các giao thức 19 và 20 đã được chính thức hóa trong **Đề xuất 163 (Tháng 4 năm 2025)**. Chúng cùng tồn tại với Datagram1 / RAW để đảm bảo khả năng tương thích ngược. 2. Các loại Datagram Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. ### Các Mẫu Thiết Kế Điển Hình Request → Response: Gửi một Datagram2 đã ký (yêu cầu + nonce), nhận phản hồi dạng raw hoặc Datagram3 (echo nonce). Tần suất cao/chi phí thấp: Ưu tiên Datagram3 hoặc RAW. Thông điệp điều khiển đã xác thực: Datagram2. Tương thích ngược: Datagram1 vẫn được hỗ trợ đầy đủ. 3. Chi tiết về Datagram2 và Datagram3 (2025) Datagram2 (Giao thức 19) Phiên bản nâng cấp thay thế cho Datagram1. Tính năng: - Ngăn chặn tấn công replay: token chống replay 4 byte. - Hỗ trợ chữ ký ngoại tuyến: cho phép sử dụng bởi các Destination được ký ngoại tuyến. - Mở rộng phạm vi chữ ký: bao gồm destination hash, cờ, tùy chọn, khối chữ ký ngoại tuyến, payload. - Sẵn sàng cho hậu lượng tử: tương thích với các hybrid ML-KEM trong tương lai. - Chi phí: ≈ 457 bytes (khóa X25519).\nDatagram3 (Giao thức 20) Kết nối khoảng cách giữa các loại raw và signed. Tính năng: - Có thể trả lời mà không cần chữ ký: chứa hash 32-byte của người gửi + cờ 2-byte. - Overhead nhỏ gọn: ≈ 34 bytes. - Không có cơ chế chống replay — ứng dụng phải tự triển khai.\nCả hai giao thức đều là tính năng của API 0.9.66 và được triển khai trong router Java kể từ Bản phát hành 2.9.0; chưa có triển khai i2pd hoặc Go (tháng 10 năm 2025).\n4. Giới hạn Kích thước và Phân mảnh Kích thước thông điệp tunnel: 1 028 byte (4 B Tunnel ID + 16 B IV + 1 008 B payload). Fragment ban đầu: 956 B (TUNNEL delivery điển hình). Fragment tiếp theo: 996 B. Số fragment tối đa: 63–64. Giới hạn thực tế: ≈ 62 708 B (~61 KB). Giới hạn khuyến nghị: ≤ 10 KB để truyền tải đáng tin cậy (tỷ lệ mất gói tăng theo cấp số nhân khi vượt quá mức này). Tóm tắt overhead: - Datagram1 ≈ 427 B (tối thiểu). - Datagram2 ≈ 457 B. - Datagram3 ≈ 34 B. - Các lớp bổ sung (I2CP gzip header, I2NP, Garlic, Tunnel): + ~5.5 KB trường hợp xấu nhất.\n5. Tích hợp I2CP / I2NP Đường đi của thông điệp: 1. Ứng dụng tạo datagram (thông qua I2P API hoặc SAM). 2. I2CP bọc với gzip header (0x1F 0x8B 0x08, RFC 1952) và checksum CRC-32. 3. Số Protocol + Port được lưu trong các trường gzip header. 4. Router đóng gói thành I2NP message → Garlic clove → các fragment tunnel 1 KB. 5. Các fragment đi qua outbound tunnel → mạng → inbound tunnel. 6. Datagram được ghép lại và chuyển đến application handler dựa trên số protocol.\nTính toàn vẹn: CRC-32 (từ I2CP) + chữ ký mật mã tùy chọn (Datagram1/2). Không có trường checksum riêng biệt trong chính datagram.\n6. Giao diện lập trình Java API Package net.i2p.client.datagram bao gồm: - I2PDatagramMaker – xây dựng các datagram đã ký. - I2PDatagramDissector – xác minh và trích xuất thông tin người gửi. - I2PInvalidDatagramException – được ném ra khi xác minh thất bại.\nI2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl) quản lý việc ghép kênh giao thức và cổng cho các ứng dụng chia sẻ cùng một Destination.\nTruy cập Javadoc: - idk.i2p Javadoc (chỉ trong mạng I2P) - Javadoc Mirror (bản sao trên clearnet) - Official Javadocs (tài liệu chính thức)\nHỗ trợ SAM v3 SAM 3.2 (2016): đã thêm các tham số PORT và PROTOCOL. SAM 3.3 (2016): giới thiệu mô hình PRIMARY/subsession; cho phép streams + datagrams trên một Destination. Hỗ trợ cho các kiểu phiên Datagram2 / 3 đã được thêm vào đặc tả năm 2025 (đang chờ triển khai). Đặc tả chính thức: Đặc tả SAM v3 Các mô-đun i2ptunnel udpTunnel: Nền tảng hoàn chỉnh và hoạt động đầy đủ cho các ứng dụng I2P UDP (net.i2p.i2ptunnel.udpTunnel). streamr: Hoạt động cho streaming A/V (net.i2p.i2ptunnel.streamr). SOCKS UDP: Không hoạt động tính đến phiên bản 2.10.0 (chỉ có UDP stub). Đối với UDP mục đích chung, hãy sử dụng Datagram API hoặc udpTunnel trực tiếp—không nên dựa vào SOCKS UDP.\n7. Hệ sinh thái và Hỗ trợ Ngôn ngữ (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental Java I2P là router duy nhất hỗ trợ đầy đủ SAM 3.3 subsessions và Datagram2 API tại thời điểm này. 8. Ví dụ Sử dụng – UDP Tracker (I2PSnark 2.10.0) Ứng dụng thực tế đầu tiên của Datagram2/3:\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return Pattern này minh họa việc sử dụng kết hợp các datagram có xác thực và datagram nhẹ để cân bằng giữa bảo mật và hiệu suất. 9. Bảo mật và Thực hành Tốt nhất Sử dụng Datagram2 cho bất kỳ trao đổi được xác thực nào hoặc khi các cuộc tấn công replay quan trọng. Ưu tiên Datagram3 cho các phản hồi có thể trả lời nhanh với mức độ tin cậy vừa phải. Sử dụng RAW cho phát sóng công khai hoặc dữ liệu ẩn danh. Giữ payload ≤ 10 KB để đảm bảo gửi nhận đáng tin cậy. Lưu ý rằng SOCKS UDP vẫn không hoạt động. Luôn xác minh CRC gzip và chữ ký số khi nhận. 10. Đặc tả kỹ thuật Phần này trình bày các định dạng datagram ở mức thấp, đóng gói và chi tiết giao thức.\n10.1 Xác định giao thức Các định dạng datagram không chia sẻ một header chung. Các router không thể suy ra loại từ các byte payload một mình.\nKhi kết hợp nhiều loại datagram—hoặc khi kết hợp datagram với streaming—hãy thiết lập rõ ràng: - Số hiệu giao thức (thông qua I2CP hoặc SAM) - Tùy chọn số cổng, nếu ứng dụng của bạn ghép kênh các dịch vụ\nĐể giao thức không được thiết lập (0 hoặc PROTO_ANY) không được khuyến khích và có thể dẫn đến lỗi định tuyến hoặc phân phối.\n10.2 Raw Datagrams (Datagram Thô) Các datagram không thể trả lời không mang dữ liệu người gửi hoặc dữ liệu xác thực. Chúng là các payload mờ đục, được xử lý bên ngoài API datagram cấp cao hơn nhưng được hỗ trợ thông qua SAM và I2PTunnel.\nGiao thức: 18 (PROTO_DATAGRAM_RAW)\nĐịnh dạng:\n+----+----+----+----+----// | payload... +----+----+----+----+----// Độ dài payload bị giới hạn bởi các giới hạn vận chuyển (tối đa thực tế ≈32 KB, thường ít hơn nhiều).\n10.3 Datagram1 (Datagram có thể trả lời) Nhúng Destination của người gửi và một Signature để xác thực và định địa chỉ phản hồi.\nGiao thức: 17 (PROTO_DATAGRAM)\nOverhead: ≥427 byte Payload: tối đa ~31,5 KB (giới hạn bởi giao thức truyền tải)\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from: một Destination (387+ byte) signature: một Signature khớp với loại khóa Với DSA_SHA1: Signature của hash SHA-256 của payload Với các loại khóa khác: Signature trực tiếp trên payload Ghi chú: - Chữ ký cho các loại không phải DSA đã được chuẩn hóa trong I2P 0.9.14. - Chữ ký ngoại tuyến LS2 (Đề xuất 123) hiện không được hỗ trợ trong Datagram1.\n10.4 Định dạng Datagram2 Một datagram có thể trả lời được cải tiến, bổ sung khả năng chống replay như được định nghĩa trong Đề xuất 163 .\nGiao thức: 19 (PROTO_DATAGRAM2)\nViệc triển khai đang được tiến hành. Các ứng dụng nên bao gồm kiểm tra nonce hoặc timestamp để đảm bảo tính dự phòng.\n10.5 Định dạng Datagram3 Cung cấp các datagram có thể trả lời nhưng không xác thực. Dựa vào xác thực phiên do router duy trì thay vì destination và chữ ký được nhúng.\nGiao thức: 20 (PROTO_DATAGRAM3) Trạng thái: Đang phát triển từ phiên bản 0.9.66\nHữu ích khi: - Các điểm đến có kích thước lớn (ví dụ: khóa post-quantum) - Xác thực diễn ra ở một lớp khác - Hiệu suất băng thông là yếu tố quan trọng\n10.6 Tính Toàn Vẹn Dữ Liệu Tính toàn vẹn của datagram được bảo vệ bởi gzip CRC-32 checksum trong lớp I2CP. Không có trường checksum rõ ràng nào tồn tại trong chính định dạng payload của datagram.\n10.7 Đóng gói Gói tin Mỗi datagram được đóng gói thành một I2NP message đơn lẻ hoặc thành một clove riêng biệt trong Garlic Message. Các lớp I2CP, I2NP và tunnel xử lý độ dài và đóng khung — không có dấu phân cách nội bộ hay trường độ dài trong giao thức datagram.\n10.8 Các Cân nhắc về Hậu Lượng tử (PQ) Nếu Đề xuất 169 (chữ ký ML-DSA) được triển khai, kích thước chữ ký và destination sẽ tăng mạnh — từ ~455 byte lên ≥3739 byte. Thay đổi này sẽ làm tăng đáng kể chi phí overhead của datagram và giảm dung lượng payload hiệu dụng.\nDatagram3, dựa trên xác thực cấp phiên (không phải chữ ký nhúng), có khả năng sẽ trở thành thiết kế ưu tiên trong các môi trường I2P hậu lượng tử.\n11. Tài liệu tham khảo Đề xuất 163 – Datagram2 và Datagram3 Đề xuất 160 – Tích hợp UDP Tracker Đề xuất 144 – Tính toán MTU Streaming Đề xuất 169 – Chữ ký Post-Quantum Đặc tả I2CP Đặc tả I2NP Đặc tả Tunnel Message Đặc tả SAM v3 Tài liệu i2ptunnel 12. Điểm nổi bật của nhật ký thay đổi (2019 – 2025) Year Release Change 20190.9.43Datagram API stabilization 20210.9.50Protocol port handling reworked 20222.0.0SSU2 adoption completed 20242.6.0Legacy transport removal simplified UDP code 20252.9.0Datagram2/3 support added (Java API) 20252.10.0UDP Tracker implementation released --- 13. Tóm tắt Hệ thống con datagram hiện hỗ trợ bốn biến thể giao thức cung cấp một phổ từ xác thực đầy đủ đến truyền tải thô nhẹ. Các nhà phát triển nên chuyển sang Datagram2 cho các trường hợp sử dụng nhạy cảm về bảo mật và Datagram3 cho lưu lượng có khả năng trả lời hiệu quả. Tất cả các loại cũ vẫn tương thích để đảm bảo khả năng tương tác dài hạn.\n","description":"Các định dạng tin nhắn đã xác thực, có thể trả lời và thô (raw) trên I2CP","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"Datagrams","url":"/vi/docs/api/datagrams/"},{"categories":null,"content":"Tổng quan Tài liệu này đặc tả định dạng tệp blockfile (tệp dạng khối) của I2P và các bảng trong hostsdb.blockfile được sử dụng bởi Blockfile Naming Service (dịch vụ đặt tên dựa trên blockfile). Để biết bối cảnh, xem Đặt tên và Sổ địa chỉ I2P .\nBlockfile (tệp khối) cho phép tra cứu destination (đích I2P) nhanh trong một định dạng nhị phân gọn nhẹ. So với hệ thống hosts.txt trước đây:\nCác Destination (đích trong I2P) được lưu ở dạng nhị phân, không phải Base64. Có thể đính kèm siêu dữ liệu tùy ý (ví dụ: ngày thêm vào, nguồn, ghi chú). Thời gian tra cứu xấp xỉ nhanh hơn 10×. Mức sử dụng đĩa tăng nhẹ. Một blockfile (tệp khối) là một tập hợp trên đĩa gồm các ánh xạ đã được sắp xếp (các cặp khóa-giá trị), được triển khai dưới dạng skiplists (danh sách bỏ qua). Nó được phát triển dựa trên Metanotion Blockfile Database . Bản đặc tả này trước hết định nghĩa cấu trúc tệp, sau đó mô tả cách nó được BlockfileNamingService sử dụng.\nBlockfile Naming Service (Dịch vụ đặt tên Blockfile) đã thay thế bản triển khai hosts.txt cũ trong I2P 0.8.8. \u0026gt; Khi khởi tạo, nó nhập các bản ghi từ privatehosts.txt, userhosts.txt, và hosts.txt.\nĐịnh dạng Blockfile (tệp khối) Định dạng gồm các trang 1024 byte, mỗi trang có một magic number (chữ ký/định danh định dạng) ở đầu để đảm bảo tính toàn vẹn. Các trang được đánh số bắt đầu từ 1:\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) Tất cả số nguyên dùng **thứ tự byte mạng (big-endian, byte có trọng số lớn nhất đứng trước)**. Các giá trị 2 byte là không dấu; các giá trị 4 byte (số trang) là có dấu và phải là số dương. Luồng: Cơ sở dữ liệu được thiết kế để truy cập đơn luồng; BlockfileNamingService cung cấp đồng bộ hóa.\nĐịnh dạng siêu khối Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused --- Định dạng trang khối của Skip list (danh sách bỏ qua) Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused --- Định dạng trang khối của Skip Level (cấp bỏ qua) Mỗi mức đều có một phạm vi, nhưng không phải phạm vi nào cũng có mức.\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused --- Định dạng trang Skip Span Block Các cặp khóa/giá trị được sắp xếp theo khóa xuyên suốt các span (vùng dữ liệu liên tiếp). Các span không phải span đầu tiên không được rỗng.\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures --- Định dạng trang của khối tiếp nối Span Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures --- Định dạng cấu trúc khóa/giá trị Các trường độ dài của khóa và giá trị không được vượt qua ranh giới trang (cả 4 byte phải nằm gọn trong một trang). Nếu không còn đủ chỗ, chèn tối đa 3 byte đệm và tiếp tục tại offset (độ lệch) 8 của trang kế tiếp.\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each --- Định dạng trang của khối danh sách trống Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) --- Định dạng khối trang trống Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused --- Siêu chỉ mục Nằm ở trang 2. Ánh xạ chuỗi US-ASCII → số nguyên 4 byte. Khóa là tên skiplist (cấu trúc dữ liệu danh sách bỏ qua); giá trị là chỉ mục trang.\nCác bảng của Dịch vụ Đặt tên Blockfile (tệp khối) Dịch vụ định nghĩa nhiều skiplist (cấu trúc dữ liệu skiplist). Mỗi span (khoảng) hỗ trợ tối đa 16 phần tử.\nSkiplist (cấu trúc dữ liệu danh sách bỏ qua) của thuộc tính %%__INFO__%% chứa một mục:\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping Các trường thường gặp: Property Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) --- Skiplist tra cứu ngược (cấu trúc dữ liệu dạng danh sách bỏ qua) %%__REVERSE__%% chứa các mục dạng Số nguyên → Thuộc tính (kể từ DB v2).\nKhóa: 4 byte đầu tiên của hash SHA-256 của Destination (đích trong I2P). Giá trị: đối tượng Properties (Mapping được tuần tự hóa). Nhiều mục nhập để xử lý xung đột và các Destination có nhiều hostname. Mỗi khóa thuộc tính = hostname; giá trị = chuỗi rỗng. Skiplists (cấu trúc dữ liệu danh sách bỏ qua) của cơ sở dữ liệu máy chủ Mỗi tệp hosts.txt, userhosts.txt và privatehosts.txt ánh xạ tên máy chủ → Destinations (địa chỉ đích trong I2P).\nPhiên bản 4 hỗ trợ nhiều Destinations (đích định danh trong I2P) cho mỗi tên máy chủ (được giới thiệu trong I2P 0.9.26). Các cơ sở dữ liệu phiên bản 3 được chuyển đổi tự động.\nKhóa Chuỗi UTF-8 (tên máy chủ, chữ thường, kết thúc bằng .i2p)\nGiá trị Phiên bản 4: 1 byte chỉ số lượng các cặp Thuộc tính/Đích Với mỗi cặp: Thuộc tính → Đích (nhị phân) Phiên bản 3: Thuộc tính → Đích (nhị phân) Các thuộc tính DestEntry Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) --- Ghi chú triển khai Lớp Java BlockfileNamingService hiện thực đặc tả này.\nBên ngoài ngữ cảnh router, cơ sở dữ liệu mở ở chế độ chỉ đọc trừ khi i2p.naming.blockfile.writeInAppContext=true. Không dành cho truy cập đa thể hiện hoặc đa JVM. Duy trì ba bảng ánh xạ chính (privatehosts, userhosts, hosts) và một bảng ánh xạ ngược để tra cứu nhanh. Tài liệu tham khảo Tài liệu về Đặt tên và Sổ địa chỉ I2P Đặc tả Cấu trúc Chung Cơ sở dữ liệu Blockfile (tệp khối) của Metanotion JavaDoc của BlockfileNamingService ","description":"Định dạng lưu trữ blockfile (tệp khối) trên đĩa được I2P sử dụng để phân giải tên máy chủ","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"Đặc tả Blockfile","url":"/vi/docs/specs/blockfile/"},{"categories":null,"content":"Tổng quan Routers tự động kiểm tra cập nhật bằng cách truy vấn định kỳ một nguồn cấp tin đã được ký số, được phân phối qua mạng I2P. Khi có phiên bản mới được thông báo, router tải về một tệp lưu trữ cập nhật được ký số (.su3) và chuẩn bị sẵn cho việc cài đặt. Hệ thống này đảm bảo việc phân phối các bản phát hành chính thức theo cách được xác thực, chống giả mạo, và đa kênh.\nKể từ I2P 2.10.0, hệ thống cập nhật sử dụng: - RSA-4096 / SHA-512 cho chữ ký - định dạng vùng chứa SU3 (thay thế SUD/SU2 kiểu cũ) - Các mirror dự phòng: HTTP trong mạng, HTTPS trên clearnet (mạng Internet công khai), và BitTorrent\n1. Nguồn cấp tin Các router thăm dò nguồn cấp Atom đã được ký cứ vài giờ một lần để phát hiện phiên bản mới và khuyến cáo bảo mật. Nguồn cấp được ký và phân phối dưới dạng tệp .su3, có thể bao gồm:\n\u0026lt;i2p:version\u0026gt; — số phiên bản mới \u0026lt;i2p:minVersion\u0026gt; — phiên bản router tối thiểu được hỗ trợ \u0026lt;i2p:minJavaVersion\u0026gt; — môi trường chạy Java tối thiểu bắt buộc \u0026lt;i2p:update\u0026gt; — liệt kê nhiều mirror tải xuống (I2P, HTTPS, torrent) \u0026lt;i2p:revocations\u0026gt; — dữ liệu thu hồi chứng chỉ \u0026lt;i2p:blocklist\u0026gt; — danh sách chặn ở cấp mạng dành cho các peer (nút ngang hàng) bị xâm phạm Phân phối nguồn cấp dữ liệu Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load Các router ưu tiên nguồn cấp I2P nhưng có thể chuyển sang clearnet hoặc phân phối qua torrent nếu cần. 2. Định dạng tệp SU3 (Tiêu chuẩn hiện hành) Được giới thiệu trong phiên bản 0.9.9, SU3 đã thay thế các định dạng SUD và SU2 cũ. Mỗi tệp bao gồm phần đầu (header), phần nội dung (payload), và chữ ký ở cuối.\nCấu trúc tiêu đề \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Field\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Magic\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I2Psu3\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Format Version\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;e.g., \u0026lt;code\u0026gt;0x000B\u0026lt;/code\u0026gt; (RSA-SHA512-4096)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Length\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;512 bytes\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Version String\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Router version\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signer ID\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Certificate name\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Content Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;1 = router update, 3 = reseed, 4 = news feed\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Các bước xác minh chữ ký 1. Phân tích cú pháp header và xác định thuật toán chữ ký. 2. Xác minh giá trị băm và chữ ký bằng chứng chỉ của người ký được lưu trữ. 3. Xác nhận chứng chỉ của người ký chưa bị thu hồi. 4. So sánh chuỗi phiên bản nhúng với siêu dữ liệu của payload (nội dung tải).\nRouters đi kèm với các chứng chỉ của người ký đáng tin cậy (hiện tại là zzz và str4d) và từ chối mọi nguồn chưa được ký hoặc đã bị thu hồi.\nSU2 (Lỗi thời) Đã dùng phần mở rộng .su2 với các tệp JAR nén bằng Pack200 (định dạng nén của Java). Đã bị gỡ bỏ sau khi Java 14 đánh dấu Pack200 là lỗi thời (JEP 367). Đã bị vô hiệu hóa kể từ I2P 0.9.48+; hiện đã được thay thế hoàn toàn bằng nén ZIP. SUD (cũ) Định dạng ZIP được ký bằng DSA-SHA1 đời đầu (trước 0.9.9). Không có ID người ký hoặc phần đầu (header), tính toàn vẹn hạn chế. Đã bị thay thế do mật mã yếu và thiếu cơ chế bắt buộc phiên bản. 3. Quy trình cập nhật 3.1 Xác minh header Các router chỉ tải SU3 header để xác minh chuỗi phiên bản trước khi tải xuống các tệp đầy đủ. Điều này giúp tránh lãng phí băng thông vào các mirror cũ (máy chủ bản sao) hoặc các phiên bản lỗi thời.\n3.2 Tải xuống đầy đủ Sau khi xác minh header, router tải xuống tệp .su3 đầy đủ từ: - Các mirror eepsite trong mạng (ưu tiên) - Các mirror HTTPS clearnet (mạng công khai) (dự phòng) - BitTorrent (phân phối tùy chọn có hỗ trợ từ các nút ngang hàng)\nQuá trình tải xuống sử dụng các client HTTP I2PTunnel tiêu chuẩn, có cơ chế thử lại, xử lý hết thời gian chờ, và chuyển sang mirror dự phòng.\n3.3 Xác minh chữ ký Mỗi tệp đã tải xuống sẽ trải qua: - Kiểm tra chữ ký: Xác minh RSA-4096/SHA512 - Khớp phiên bản: Kiểm tra phiên bản phần đầu (header) so với phần tải (payload) - Ngăn chặn hạ cấp phiên bản: Đảm bảo bản cập nhật mới hơn bản đã cài đặt\nCác tệp không hợp lệ hoặc không khớp được loại bỏ ngay lập tức.\n3.4 Chuẩn bị cài đặt Sau khi xác minh: 1. Giải nén nội dung ZIP vào thư mục tạm 2. Xóa các tệp được liệt kê trong deletelist.txt 3. Thay thế các native libraries (thư viện gốc) nếu có bao gồm lib/jbigi.jar 4. Sao chép các chứng chỉ của bên ký vào ~/.i2p/certificates/ 5. Chuyển bản cập nhật thành i2pupdate.zip để áp dụng ở lần khởi động lại tiếp theo\nBản cập nhật sẽ được cài đặt tự động vào lần khởi động tiếp theo hoặc khi tùy chọn “Cài đặt bản cập nhật ngay” được kích hoạt thủ công.\n4. Quản lý tệp deletelist.txt Một danh sách văn bản thuần liệt kê các tệp lỗi thời cần được xóa trước khi giải nén nội dung mới.\nQuy tắc: - Mỗi dòng một đường dẫn (chỉ chấp nhận đường dẫn tương đối) - Các dòng bắt đầu bằng # bị bỏ qua - .. và đường dẫn tuyệt đối bị từ chối\nThư viện gốc Để ngăn các tệp nhị phân gốc bị lỗi thời hoặc không khớp: - Nếu lib/jbigi.jar tồn tại, các tệp .so hoặc .dll cũ sẽ bị xóa - Đảm bảo các thư viện dành riêng cho nền tảng được trích xuất mới\n5. Quản lý chứng chỉ Các router có thể nhận các chứng chỉ ký mới thông qua các bản cập nhật hoặc các thông báo thu hồi trên nguồn tin tức.\nCác tệp .crt mới được sao chép vào thư mục chứng chỉ. Các chứng chỉ đã bị thu hồi được xóa trước các lần xác minh tiếp theo. Hỗ trợ xoay vòng khóa mà không cần sự can thiệp thủ công của người dùng. Tất cả các bản cập nhật được ký ngoại tuyến bằng air-gapped signing systems (hệ thống ký số cách ly mạng). Các khóa riêng không bao giờ được lưu trữ trên các máy chủ build.\n6. Hướng dẫn dành cho nhà phát triển Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. Các bản phát hành trong tương lai sẽ khám phá việc tích hợp chữ ký hậu lượng tử (xem Đề xuất 169) và các bản dựng có thể tái lập. 7. Tổng quan về bảo mật Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity --- 8. Phiên bản hóa Router: 2.10.0 (API 0.9.67) Phiên bản ngữ nghĩa với Major.Minor.Patch. Cơ chế bắt buộc phiên bản tối thiểu ngăn chặn các nâng cấp không an toàn. Java được hỗ trợ: Java 8–17. Trong tương lai, 2.11.0+ sẽ yêu cầu Java 17+. ","description":"Cơ chế cập nhật được ký an toàn và cấu trúc nguồn cấp cho các router I2P","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"Đặc tả cập nhật phần mềm","url":"/vi/docs/specs/updates/"},{"categories":null,"content":"Tổng quan Mục đích ECIES-X25519-AEAD-Ratchet là giao thức mã hóa đầu-cuối hiện đại của I2P, thay thế hệ thống ElGamal/AES+SessionTags cũ. Nó cung cấp tính bí mật chuyển tiếp, mã hóa xác thực, và những cải tiến đáng kể về hiệu năng và bảo mật.\nNhững cải tiến chính so với ElGamal/AES+SessionTags Khóa nhỏ hơn: Khóa 32-byte so với khóa công khai ElGamal 256-byte (giảm 87.5%) Bảo mật chuyển tiếp: Đạt được thông qua DH ratcheting (cơ chế bánh cóc) (không có trong giao thức cũ) Mật mã hiện đại: X25519 DH, ChaCha20-Poly1305 AEAD, SHA-256 Mã hóa kèm xác thực: Xác thực tích hợp thông qua cấu trúc AEAD Giao thức hai chiều: Các phiên vào/ra được ghép cặp so với giao thức cũ một chiều Thẻ phiên hiệu quả: Thẻ phiên 8-byte so với thẻ 32-byte (giảm 75%) Che giấu lưu lượng: Mã hóa Elligator2 khiến các bắt tay không thể phân biệt với dữ liệu ngẫu nhiên Trạng thái triển khai Phát hành ban đầu: Phiên bản 0.9.46 (25 tháng 5, 2020) Triển khai mạng: Hoàn tất tính đến năm 2020 Trạng thái hiện tại: Trưởng thành, được triển khai rộng rãi (hơn 5 năm trong môi trường sản xuất) Hỗ trợ router: Yêu cầu phiên bản 0.9.46 hoặc cao hơn Yêu cầu Floodfill: Mức độ áp dụng gần 100% cho các tra cứu được mã hóa Trạng thái triển khai Đã triển khai đầy đủ: - các thông điệp New Session (NS) có ràng buộc - các thông điệp New Session Reply (NSR) - các thông điệp Existing Session (ES) - cơ chế DH ratchet (cơ chế thay đổi khóa tăng dần) - các ratchet cho session tag (thẻ phiên) và khóa đối xứng - các khối DateTime, NextKey, ACK, ACK Request, Garlic Clove (nhánh tỏi - thành phần của thông điệp \u0026lsquo;garlic\u0026rsquo; trong I2P), và Padding\nChưa được triển khai (tính đến phiên bản 0.9.50): - khối MessageNumbers (loại 6) - khối Options (loại 5) - khối Termination (loại 4) - phản hồi tự động ở tầng giao thức - Zero static key mode (chế độ không dùng khóa tĩnh) - các phiên multicast\nLưu ý: Tình trạng triển khai cho các phiên bản từ 1.5.0 đến 2.10.0 (2021–2025) cần được xác minh vì có thể một số tính năng đã được bổ sung.\nNền tảng giao thức Khung giao thức Noise ECIES-X25519-AEAD-Ratchet dựa trên Noise Protocol Framework (Bản sửa đổi 34, 2018-07-11), cụ thể là mẫu bắt tay IK (tương tác, khóa tĩnh từ xa đã biết) với các phần mở rộng dành riêng cho I2P.\nĐịnh danh Giao thức Noise Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 Các thành phần định danh: - Noise - Khung cơ bản - IK - Mẫu bắt tay tương tác với khóa tĩnh từ xa đã biết - elg2 - Mã hóa Elligator2 cho khóa tạm thời (phần mở rộng I2P) - +hs2 - MixHash được gọi trước thông điệp thứ hai để trộn tag (phần mở rộng I2P) - 25519 - Hàm Diffie-Hellman X25519 - ChaChaPoly - Thuật toán mã hóa AEAD ChaCha20-Poly1305 - SHA256 - Hàm băm SHA-256\nMẫu bắt tay Noise Ký hiệu mẫu IK:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) Ý nghĩa các token: - e - Truyền khóa tạm thời - s - Truyền khóa tĩnh - es - DH giữa khóa tạm thời của Alice và khóa tĩnh của Bob - ss - DH giữa khóa tĩnh của Alice và khóa tĩnh của Bob - ee - DH giữa khóa tạm thời của Alice và khóa tạm thời của Bob - se - DH giữa khóa tĩnh của Bob và khóa tạm thời của Alice\nCác thuộc tính bảo mật của Noise (khung giao thức mật mã) Sử dụng thuật ngữ của Noise (khung giao thức mật mã), mẫu IK cung cấp:\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) **Các cấp độ xác thực:** - **Cấp 1**: Tải dữ liệu được xác thực là thuộc về chủ sở hữu khóa tĩnh của bên gửi, nhưng dễ bị tấn công Key Compromise Impersonation (KCI, mạo danh do lộ khóa) - **Cấp 2**: Kháng các cuộc tấn công KCI sau NSR Các cấp độ bảo mật: - Cấp 2: Bí mật chuyển tiếp (forward secrecy) nếu khóa tĩnh của người gửi bị xâm phạm về sau - Cấp 4: Bí mật chuyển tiếp nếu khóa tạm thời của người gửi bị xâm phạm về sau - Cấp 5: Bí mật chuyển tiếp đầy đủ sau khi cả hai khóa tạm thời được xóa\nSự khác biệt giữa IK và XK Mẫu IK khác với mẫu XK được dùng trong NTCP2 và SSU2:\nBốn phép DH (Diffie-Hellman): IK sử dụng 4 phép DH (es, ss, ee, se) so với 3 trong XK Xác thực ngay lập tức: Alice được xác thực trong thông điệp đầu tiên (Mức xác thực 1) Bảo mật chuyển tiếp nhanh hơn: Bảo mật chuyển tiếp đầy đủ (Mức 5) đạt được sau thông điệp thứ hai (1-RTT) Đánh đổi: Tải trọng của thông điệp đầu tiên không có bảo mật chuyển tiếp (so với XK, nơi mọi tải trọng đều có bảo mật chuyển tiếp) Tóm tắt: IK (một mẫu bắt tay) cho phép phản hồi của Bob được nhận chỉ trong 1-RTT (một vòng khứ hồi) với đầy đủ bảo mật chuyển tiếp, đổi lại yêu cầu ban đầu không có bảo mật chuyển tiếp.\nCác khái niệm về Double Ratchet (cơ chế bánh cóc kép) của Signal ECIES (lược đồ mã hóa tích hợp trên đường cong elliptic) kết hợp các khái niệm từ Signal Double Ratchet Algorithm :\nDH Ratchet: (cơ chế bánh cóc DH) Đảm bảo bí mật chuyển tiếp bằng cách trao đổi định kỳ các khóa DH mới Symmetric Key Ratchet: (cơ chế bánh cóc khóa đối xứng) Dẫn xuất các khóa phiên mới cho mỗi thông điệp Session Tag Ratchet: (cơ chế bánh cóc Session Tag) Tạo session tags (thẻ phiên) dùng một lần một cách tất định Những khác biệt chính so với Signal: - Ratcheting (cơ chế tăng tiến khóa theo từng bước) ít thường xuyên hơn: I2P chỉ thực hiện ratchet khi cần (gần cạn tag hoặc theo chính sách) - Session Tags (thẻ phiên) thay cho mã hóa tiêu đề: Sử dụng các tag có tính xác định thay vì các tiêu đề được mã hóa - ACK rõ ràng: Sử dụng các khối ACK trong-băng thay vì chỉ dựa vào lưu lượng ngược chiều - Tách biệt ratchet cho tag và khóa: Hiệu quả hơn cho bên nhận (có thể hoãn việc tính toán khóa)\nCác phần mở rộng I2P cho Noise (khung giao thức) Mã hóa Elligator2: Khóa tạm thời được mã hóa để không thể phân biệt với dữ liệu ngẫu nhiên Thẻ được chèn ở đầu NSR: Thẻ phiên được thêm trước thông điệp NSR để phục vụ mục đích tương quan Định dạng tải tin được xác định: Cấu trúc tải tin dạng khối cho mọi loại thông điệp Bao gói I2NP: Tất cả thông điệp được bọc trong các tiêu đề Thông điệp Garlic của I2NP Giai đoạn dữ liệu tách biệt: Thông điệp truyền tải (ES) khác với giai đoạn dữ liệu tiêu chuẩn của Noise (khung giao thức mật mã) Các nguyên thủy mật mã Trao đổi khóa Diffie-Hellman X25519 Đặc tả: RFC 7748 Thuộc tính chính: - Kích thước khóa riêng: 32 byte - Kích thước khóa công khai: 32 byte - Kích thước bí mật chung: 32 byte - Thứ tự byte: Little-endian - Đường cong: Curve25519\nVận hành:\nX25519 GENERATE_PRIVATE() Tạo một khóa riêng 32 byte ngẫu nhiên:\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) Suy ra khóa công khai tương ứng:\npubkey = curve25519_scalarmult_base(privkey) Trả về khóa công khai 32 byte ở dạng little-endian (thứ tự byte nhỏ trước).\nX25519 DH(privkey, pubkey) Thực hiện Diffie-Hellman key agreement (thỏa thuận khóa Diffie-Hellman):\nsharedSecret = curve25519_scalarmult(privkey, pubkey) Trả về một bí mật dùng chung dài 32 byte.\nGhi chú bảo mật: Người triển khai phải xác minh rằng bí mật chia sẻ không phải toàn là số 0 (khóa yếu). Hãy từ chối và hủy bỏ quá trình bắt tay nếu điều này xảy ra.\nChaCha20-Poly1305 AEAD (mã hóa xác thực kèm dữ liệu) Đặc tả: RFC 7539 mục 2.8\nTham số: - Kích thước khóa: 32 byte (256 bit) - Kích thước Nonce (số dùng một lần): 12 byte (96 bit) - Kích thước MAC: 16 byte (128 bit) - Kích thước khối: 64 byte (nội bộ)\nĐịnh dạng Nonce (số dùng một lần):\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) Cấu trúc AEAD:\nAEAD (mã hóa xác thực kèm dữ liệu liên kết) kết hợp mật mã dòng ChaCha20 với MAC Poly1305:\nTạo luồng khóa ChaCha20 từ khóa và nonce (số dùng một lần) Mã hóa bản rõ bằng cách XOR với luồng khóa Tính MAC (mã xác thực thông điệp) Poly1305 trên (dữ liệu liên kết || bản mã) Thêm MAC 16 byte vào bản mã ChaCha20-Poly1305 MÃ HÓA(k, n, plaintext, ad) Mã hóa bản rõ kèm xác thực:\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 Thuộc tính: - Bản mã có cùng độ dài với bản rõ (mật mã dòng) - Đầu ra là plaintext_length + 16 byte (bao gồm MAC) - Toàn bộ đầu ra không thể phân biệt với ngẫu nhiên nếu khóa được giữ bí mật - MAC xác thực cả dữ liệu liên kết và bản mã\nChaCha20-Poly1305 DECRYPT(k, n, ciphertext, ad) Giải mã và kiểm tra xác thực:\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext Các yêu cầu bảo mật quan trọng: - Nonces (giá trị dùng một lần) PHẢI là duy nhất cho mỗi thông điệp dùng cùng một khóa - Nonces KHÔNG ĐƯỢC tái sử dụng (hậu quả thảm khốc nếu tái sử dụng) - Việc kiểm tra MAC (mã xác thực thông điệp) PHẢI sử dụng so sánh thời gian cố định để ngăn chặn các cuộc tấn công dựa trên thời gian - Việc kiểm tra MAC thất bại PHẢI dẫn đến việc từ chối toàn bộ thông điệp (không có giải mã từng phần)\nHàm băm SHA-256 Đặc tả: NIST FIPS 180-4\nThuộc tính: - Kích thước đầu ra: 32 byte (256 bit) - Kích thước khối: 64 byte (512 bit) - Mức độ bảo mật: 128 bit (khả năng chống va chạm)\nVận hành:\nSHA-256 H(p, d) Mã băm SHA-256 với chuỗi cá nhân hóa:\nH(p, d) := SHA256(p || d) Trong đó || biểu thị phép nối (concatenation), p là chuỗi cá nhân hóa (personalization string), d là dữ liệu.\nSHA-256 MixHash(d) Cập nhật giá trị băm hiện tại với dữ liệu mới:\nh = SHA256(h || d) Được sử dụng xuyên suốt Noise handshake (quá trình bắt tay của giao thức Noise) để duy trì transcript hash (hàm băm bản ghi bắt tay).\nDẫn xuất khóa HKDF Đặc tả: RFC 5869 Mô tả: Hàm dẫn xuất khóa dựa trên HMAC sử dụng SHA-256\nTham số: - Hàm băm: HMAC-SHA256 - Độ dài salt (chuỗi ngẫu nhiên): Tối đa 32 byte (kích thước đầu ra SHA-256) - Độ dài đầu ra: Biến thiên (tối đa 255 * 32 byte)\nHàm HKDF (hàm dẫn xuất khóa dựa trên HMAC):\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] Các mẫu sử dụng phổ biến:\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] Chuỗi thông tin dùng trong ECIES: - \u0026quot;KDFDHRatchetStep\u0026quot; - dẫn xuất khóa cho DH ratchet (cơ chế bánh cóc) - \u0026quot;TagAndKeyGenKeys\u0026quot; - khởi tạo các khóa của chuỗi thẻ và chuỗi khóa - \u0026quot;STInitialization\u0026quot; - khởi tạo ratchet thẻ phiên - \u0026quot;SessionTagKeyGen\u0026quot; - sinh thẻ phiên - \u0026quot;SymmetricRatchet\u0026quot; - sinh khóa đối xứng - \u0026quot;XDHRatchetTagSet\u0026quot; - khóa tập thẻ cho DH ratchet - \u0026quot;SessionReplyTags\u0026quot; - sinh tập thẻ NSR - \u0026quot;AttachPayloadKDF\u0026quot; - dẫn xuất khóa payload NSR\nMã hóa Elligator2 Mục đích: Mã hóa các khóa công khai X25519 để chúng không thể phân biệt được với các chuỗi 32 byte ngẫu nhiên phân phối đều.\nĐặc tả: Bài báo Elligator2 Vấn đề: Các khóa công khai X25519 (thuật toán trao đổi khóa trên đường cong elliptic) tiêu chuẩn có cấu trúc dễ nhận diện. Một người quan sát có thể nhận diện các thông điệp bắt tay bằng cách phát hiện các khóa này, ngay cả khi nội dung được mã hóa.\nGiải pháp: Elligator2 cung cấp một ánh xạ song ánh giữa ~50% số khóa công khai X25519 hợp lệ và các chuỗi 254-bit trông như ngẫu nhiên.\nSinh khóa với Elligator2 (kỹ thuật ẩn dạng khóa công khai):\nElligator2 GENERATE_PRIVATE_ELG2() Tạo một khóa riêng tương ứng với một khóa công khai có thể mã hóa theo Elligator2 (kỹ thuật ẩn dạng khóa công khai):\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue Quan trọng: Khoảng 50% khóa riêng được tạo ngẫu nhiên sẽ tạo ra khóa công khai không thể mã hóa. Những khóa đó phải được loại bỏ và thử tạo lại.\nTối ưu hóa hiệu năng: Tạo khóa trước trong một luồng nền để duy trì một pool (tập hợp dự trữ) các cặp khóa phù hợp, tránh độ trễ trong quá trình bắt tay.\nElligator2 ENCODE_ELG2(pubkey) Mã hóa một khóa công khai thành 32 byte trông ngẫu nhiên:\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey Chi tiết mã hóa: - Elligator2 (kỹ thuật ánh xạ điểm trên đường cong elliptic thành chuỗi byte trông ngẫu nhiên) tạo ra 254 bit (không đủ 256) - 2 bit cao nhất của byte 31 là phần đệm ngẫu nhiên - Kết quả được phân bố đều trên toàn bộ không gian 32 byte - Mã hóa thành công khoảng 50% khóa công khai X25519 (thuật toán trao đổi khóa ECDH trên Curve25519) hợp lệ\nElligator2 DECODE_ELG2(encodedKey) Giải mã trở lại khóa công khai ban đầu:\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey Thuộc tính bảo mật: - Các khóa được mã hóa không thể phân biệt được về mặt tính toán so với các byte ngẫu nhiên - Không có phép kiểm định thống kê nào có thể phát hiện một cách đáng tin cậy các khóa được mã hóa theo Elligator2 (kỹ thuật ánh xạ giúp biểu diễn khóa trông như ngẫu nhiên) - Giải mã là tất định (cùng một khóa đã mã hóa luôn tạo ra cùng một khóa công khai) - Việc mã hóa là song ánh đối với khoảng ~50% số khóa thuộc tập con có thể mã hóa\nGhi chú triển khai: - Lưu các khóa đã mã hóa trong giai đoạn tạo sinh để tránh mã hóa lại trong lúc bắt tay - Các khóa không phù hợp từ quá trình tạo bằng Elligator2 (kỹ thuật ẩn dạng khóa công khai) vẫn có thể dùng cho NTCP2 (không yêu cầu Elligator2) - Tạo khóa chạy nền là thiết yếu cho hiệu năng - Thời gian tạo trung bình tăng gấp đôi do tỷ lệ loại bỏ 50%\nĐịnh dạng thông điệp Tổng quan ECIES (lược đồ mã hóa tích hợp trên đường cong elliptic) định nghĩa ba loại thông điệp:\nNew Session (NS) (Phiên mới): Thông điệp bắt tay ban đầu từ Alice đến Bob New Session Reply (NSR) (Phản hồi phiên mới): Phản hồi bắt tay của Bob gửi cho Alice Existing Session (ES) (Phiên hiện có): Tất cả các thông điệp tiếp theo ở cả hai chiều Tất cả thông điệp đều được đóng gói theo định dạng I2NP Garlic Message với các lớp mã hóa bổ sung.\nBộ chứa thông điệp Garlic của I2NP Tất cả các thông điệp ECIES (lược đồ mã hóa tích hợp dùng đường cong elliptic) đều được bọc trong các header tiêu chuẩn của I2NP Garlic Message:\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ Trường: - type: 0x26 (Garlic Message, thông điệp Garlic) - msg_id: ID thông điệp I2NP 4 byte - expiration: dấu thời gian Unix 8 byte (mili giây) - size: kích thước payload 2 byte - chks: checksum 1 byte - length: độ dài dữ liệu đã mã hóa 4 byte - encrypted data: payload được mã hóa bằng ECIES\nMục đích: Cung cấp nhận dạng thông điệp và định tuyến ở tầng I2NP. Trường length cho phép bên nhận biết được tổng kích thước tải trọng đã mã hóa.\nThông điệp Phiên mới (NS) Thông điệp New Session (thông điệp mở phiên) khởi tạo một phiên mới từ Alice đến Bob. Nó có ba biến thể:\nCó ràng buộc (1b): Bao gồm khóa tĩnh của Alice để giao tiếp hai chiều Không ràng buộc (1c): Không kèm khóa tĩnh để giao tiếp một chiều Dùng một lần (1d): Chế độ một thông điệp, không thiết lập phiên Thông điệp NS có ràng buộc (Loại 1b) Trường hợp sử dụng: Truyền phát, datagram (gói dữ liệu không kết nối) có thể phản hồi, bất kỳ giao thức nào yêu cầu phản hồi\nTổng độ dài: 96 + payload_length byte\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Chi tiết trường:\nKhóa công khai tạm thời (32 byte, dạng rõ): - Khóa công khai X25519 sử dụng một lần của Alice - Được mã hóa bằng Elligator2 (không thể phân biệt với ngẫu nhiên) - Được tạo mới cho mỗi thông điệp NS (không bao giờ tái sử dụng) - Định dạng little-endian\nPhần Khóa Tĩnh (mã hóa 32 byte, 48 byte kèm MAC): - Chứa khóa công khai tĩnh X25519 của Alice (32 byte) - Được mã hóa bằng ChaCha20 - Được xác thực bằng Poly1305 MAC (16 byte) - Được Bob dùng để ràng buộc phiên với đích (destination) của Alice\nPhần Payload (mã hóa có độ dài biến đổi, +16 byte MAC): - Chứa các garlic cloves (đơn vị thông điệp trong I2P) và các khối khác - Phải bao gồm khối DateTime là khối đầu tiên - Thường bao gồm các khối Garlic Clove chứa dữ liệu ứng dụng - Có thể bao gồm khối NextKey cho ratchet ngay lập tức (cơ chế cập nhật khóa) - Mã hóa bằng ChaCha20 - Xác thực bằng Poly1305 MAC (16 byte)\nThuộc tính bảo mật: - Khóa tạm thời cung cấp thành phần đảm bảo bí mật chuyển tiếp - Khóa tĩnh xác thực Alice (ràng buộc với đích) - Cả hai phần đều có MAC riêng để tách miền (domain separation) - Toàn bộ quy trình bắt tay thực hiện 2 phép toán DH (es, ss)\nThông điệp NS không có ràng buộc (Loại 1c) Trường hợp sử dụng: Các datagram thô (gói tin không kết nối) trong đó không kỳ vọng hoặc không mong muốn phản hồi\nTổng độ dài: 96 + payload_length byte\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Khác biệt chính: Phần Flags chứa 32 byte toàn số 0 thay vì khóa tĩnh.\nPhát hiện: Bob xác định loại thông điệp bằng cách giải mã phần 32 byte và kiểm tra xem tất cả các byte có bằng 0 hay không: - Tất cả các byte bằng 0 → phiên không ràng buộc (loại 1c) - Khác 0 → phiên ràng buộc với khóa tĩnh (loại 1b)\nThuộc tính: - Không có khóa tĩnh đồng nghĩa không ràng buộc với đích của Alice - Bob không thể gửi phản hồi (không biết đích) - Chỉ thực hiện 1 phép toán DH (Diffie–Hellman) (es) - Theo mẫu Noise \u0026ldquo;N\u0026rdquo; thay vì \u0026ldquo;IK\u0026rdquo; - Hiệu quả hơn khi không bao giờ cần phản hồi\nPhần cờ (dành cho sử dụng trong tương lai): Hiện tại tất cả là 0. Có thể được dùng để thương lượng tính năng trong các phiên bản tương lai.\nThông điệp NS dùng một lần (Loại 1d) Trường hợp sử dụng: Thông điệp ẩn danh đơn lẻ không kỳ vọng phiên hoặc phản hồi\nTổng độ dài: 96 + payload_length byte\nĐịnh dạng: Giống hệt NS không có ràng buộc (loại 1c)\nPhân biệt: - Type 1c có thể gửi nhiều thông điệp trong cùng một phiên (các thông điệp ES theo sau) - Type 1d gửi đúng một thông điệp mà không thiết lập phiên - Trên thực tế, các triển khai có thể coi chúng giống hệt nhau ban đầu\nThuộc tính: - Ẩn danh tối đa (không có khóa tĩnh, không có phiên) - Không bên nào lưu giữ trạng thái phiên - Tuân theo mẫu \u0026ldquo;N\u0026rdquo; của Noise (bộ khung giao thức mật mã) - Một phép DH (es)\nThông điệp Phản hồi Phiên Mới (NSR) Bob gửi một hoặc nhiều thông điệp NSR (thông điệp \u0026lsquo;Session Created\u0026rsquo;) để đáp lại thông điệp NS (thông điệp \u0026lsquo;Session Request\u0026rsquo;) của Alice. NSR hoàn tất thủ tục bắt tay Noise IK (mẫu bắt tay IK trong giao thức Noise) và thiết lập một phiên giao tiếp hai chiều.\nTổng độ dài: 72 + payload_length byte\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Chi tiết trường:\nThẻ phiên (8 byte, bản rõ):\nĐược tạo từ bộ thẻ NSR (xem các phần KDF) Liên kết phản hồi này với thông điệp NS của Alice Cho phép Alice xác định NS nào mà NSR này phản hồi Chỉ dùng một lần (không bao giờ tái sử dụng) Khóa công khai tạm thời (32 byte, dạng rõ): - Khóa công khai X25519 dùng một lần của Bob - Được mã hóa (biểu diễn) bằng Elligator2 (kỹ thuật ánh xạ ngụy trang khóa công khai thành dữ liệu trông như ngẫu nhiên) - Được tạo mới cho mỗi thông điệp NSR - Phải khác nhau cho mỗi NSR được gửi\nKey Section MAC (16 byte): - Xác thực dữ liệu rỗng (ZEROLEN) - Là một phần của giao thức Noise IK (mẫu se) - Sử dụng hash transcript (bản ghi băm) làm dữ liệu liên kết - Tối quan trọng để ràng buộc NSR với NS\nPhần tải (độ dài biến đổi): - Chứa garlic cloves (các thành phần con trong thông điệp garlic) và các khối - Thường bao gồm các phản hồi ở tầng ứng dụng - Có thể để trống (ACK-only NSR) - Kích thước tối đa: 65519 byte (65535 - 16 byte MAC)\nNhiều thông điệp NSR:\nBob có thể gửi nhiều thông điệp NSR để đáp lại một NS: - Mỗi NSR có khóa tạm thời duy nhất - Mỗi NSR có thẻ phiên duy nhất - Alice sử dụng NSR đầu tiên nhận được để hoàn tất bắt tay - Các NSR còn lại là dự phòng (trong trường hợp mất gói)\nThời điểm then chốt: - Alice phải nhận được một NSR trước khi gửi các thông điệp ES - Bob phải nhận được một thông điệp ES trước khi gửi các thông điệp ES - NSR thiết lập các khóa phiên song hướng thông qua thao tác split()\nThuộc tính bảo mật: - Hoàn tất Noise IK handshake (thủ tục bắt tay Noise IK) - Thực hiện thêm 2 phép toán DH (Diffie-Hellman) (ee, se) - Tổng cộng 4 phép toán DH trên NS+NSR - Đạt xác thực lẫn nhau (Cấp 2) - Cung cấp bảo mật chuyển tiếp yếu (Cấp 4) cho payload NSR\nThông điệp Phiên hiện có (ES) Tất cả các thông điệp sau NS/NSR handshake (bắt tay NS/NSR) sử dụng Existing Session format (định dạng Phiên hiện có). ES messages (các thông điệp ES) được sử dụng hai chiều bởi cả Alice và Bob.\nTổng độ dài: 8 + payload_length + 16 byte (tối thiểu 24 byte)\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ Chi tiết trường:\nThẻ phiên (Session Tag) (8 byte, bản rõ): - Được tạo từ tập thẻ gửi đi hiện tại - Xác định phiên và số thông điệp - Bên nhận tra cứu thẻ để tìm khóa phiên và nonce (giá trị dùng một lần) - Chỉ dùng một lần (mỗi thẻ được dùng đúng một lần) - Định dạng: 8 byte đầu tiên của đầu ra HKDF\nPhần tải (độ dài thay đổi): - Chứa các garlic cloves (thông điệp con trong mô hình garlic) và các khối - Không có khối bắt buộc (có thể rỗng) - Các khối thường gặp: Garlic Clove, NextKey, ACK, ACK Request, Padding - Kích thước tối đa: 65519 byte (65535 - 16 byte MAC)\nMAC (16 bytes): - Thẻ xác thực Poly1305 - Được tính trên toàn bộ payload - Dữ liệu liên kết: thẻ phiên 8-byte - Phải được xác minh chính xác; nếu không, thông điệp sẽ bị từ chối\nQuy trình tra cứu thẻ:\nBên nhận trích xuất tag 8 byte Tra cứu tag trong tất cả các inbound tagset (bộ thẻ vào) hiện tại Truy xuất khóa phiên tương ứng và số thông điệp N Dựng nonce (giá trị dùng một lần): [0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] Giải mã payload (dữ liệu tải) bằng AEAD (mã hóa xác thực kèm dữ liệu liên kết) với tag làm dữ liệu liên kết Xóa tag khỏi tagset (dùng một lần) Xử lý các khối đã giải mã Không tìm thấy thẻ phiên:\nNếu không tìm thấy thẻ trong bất kỳ tagset (bộ thẻ) nào: - Có thể là một thông điệp NS → thử giải mã NS - Có thể là thông điệp NSR → thử giải mã NSR - Có thể là ES đến sai thứ tự → chờ một chút để tagset được cập nhật - Có thể là tấn công phát lại → từ chối - Có thể là dữ liệu bị hỏng → từ chối\nPayload rỗng:\nES messages (thông điệp ES) có thể có payload (tải dữ liệu) rỗng (0 byte): - Đóng vai trò như một ACK (xác nhận) rõ ràng khi đã nhận được ACK Request - Cung cấp phản hồi ở tầng giao thức mà không có dữ liệu ứng dụng - Vẫn tiêu tốn một session tag (thẻ phiên) - Hữu ích khi tầng cao hơn không có dữ liệu cần gửi ngay\nThuộc tính bảo mật: - Tính bí mật chuyển tiếp đầy đủ (Mức 5) sau khi nhận NSR - Mã hóa có xác thực thông qua AEAD - Tag (thẻ) đóng vai trò như dữ liệu liên kết bổ sung - Tối đa 65535 thông điệp cho mỗi tagset (tập thẻ) trước khi cần ratchet (cơ chế nấc)\nCác hàm dẫn xuất khóa Phần này mô tả tất cả các thao tác KDF (hàm dẫn xuất khóa) được sử dụng trong ECIES (sơ đồ mã hóa tích hợp trên đường cong elliptic), và trình bày đầy đủ các suy diễn mật mã.\nKý hiệu và Hằng số Hằng số: - ZEROLEN - Mảng byte độ dài 0 (chuỗi rỗng) - || - Toán tử nối\nBiến: - h - Băm tích lũy của bản ghi (32 byte) - chainKey - Khóa chuỗi cho HKDF (32 byte) - k - Khóa mã hóa đối xứng (32 byte) - n - Nonce / số thứ tự thông điệp\nCác khóa: - ask / apk - khóa riêng/công khai tĩnh của Alice - aesk / aepk - khóa riêng/công khai tạm thời của Alice - bsk / bpk - khóa riêng/công khai tĩnh của Bob - besk / bepk - khóa riêng/công khai tạm thời của Bob\nCác KDF (hàm dẫn xuất khóa) cho thông điệp NS KDF (hàm dẫn xuất khóa) 1: Khóa chuỗi ban đầu Thực hiện một lần khi khởi tạo giao thức (có thể tính trước):\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions Kết quả: - chainKey = Khóa chuỗi ban đầu cho tất cả các KDF tiếp theo - h = Bản ghi băm ban đầu\nKDF 2: Trộn khóa tĩnh của Bob Bob thực hiện điều này một lần (có thể tính trước cho tất cả các phiên inbound (phiên vào)):\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF 3: Sinh khóa tạm thời của Alice Alice sinh các khóa mới cho mỗi thông điệp NS:\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF 4: Phần khóa tĩnh NS (es DH) Dẫn xuất các khóa để mã hóa khóa tĩnh của Alice:\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF 5 (hàm dẫn xuất khóa): Phần NS Payload (ss DH, chỉ ràng buộc) Đối với các phiên đã ràng buộc, thực hiện DH lần thứ hai (trao đổi khóa Diffie–Hellman) để mã hóa payload:\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message Lưu ý quan trọng:\nBound (ràng buộc) vs Unbound (không ràng buộc):\nBound thực hiện 2 phép toán DH (es + ss) Unbound thực hiện 1 phép toán DH (chỉ es) Unbound tăng nonce (giá trị dùng một lần) thay vì dẫn xuất khóa mới An toàn khi tái sử dụng khóa:\nCác nonce (giá trị dùng một lần) khác nhau (0 so với 1) ngăn chặn việc tái sử dụng khóa/nonce Dữ liệu liên kết khác nhau (h khác) đảm bảo phân tách miền Hash Transcript (bản ghi băm):\nh hiện chứa: protocol_name, empty prologue, bpk, aepk, static_key_ciphertext, payload_ciphertext Bản ghi này ràng buộc tất cả các phần của NS message (thông điệp NS) lại với nhau KDF (hàm dẫn xuất khóa) cho tập thẻ phản hồi NSR (một cơ chế trong I2P; viết tắt, giữ nguyên) Bob tạo thẻ cho các thông điệp NSR:\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR Các hàm dẫn xuất khóa (KDF) cho thông điệp NSR KDF 6: Sinh khóa tạm thời cho NSR Bob tạo một khóa phiên tạm thời mới cho mỗi NSR:\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7: Phần khóa NSR (ee và se DH) Dẫn xuất các khóa cho phần khóa NSR:\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR Quan trọng: Điều này hoàn tất Noise IK handshake (thủ tục bắt tay theo giao thức Noise IK). chainKey hiện đã bao gồm phần đóng góp từ cả 4 phép toán DH (es, ss, ee, se).\nKDF (hàm dẫn xuất khóa) 8: Phần tải trọng NSR Dẫn xuất các khóa để mã hóa phần tải NSR:\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message Lưu ý quan trọng:\nSplit Operation (thao tác tách):\nTạo các khóa độc lập cho từng hướng Ngăn việc tái sử dụng khóa giữa Alice→Bob và Bob→Alice NSR Payload Binding:\nSử dụng h làm dữ liệu liên kết để ràng buộc payload với quá trình bắt tay Một KDF (hàm dẫn xuất khóa) tách biệt (\u0026ldquo;AttachPayloadKDF\u0026rdquo;) cung cấp phân tách miền (domain separation) Sẵn sàng ES:\nSau NSR, cả hai bên có thể gửi thông điệp ES Alice phải nhận NSR trước khi gửi ES Bob phải nhận ES trước khi gửi ES KDFs (hàm dẫn xuất khóa) cho thông điệp ES Các thông điệp ES sử dụng các khóa phiên được tạo sẵn từ các tagset (tập thẻ phiên):\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) Tiến trình nhận:\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) Hàm DH_INITIALIZE Tạo một tagset (tập thẻ) cho một chiều:\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset Ngữ cảnh sử dụng:\nNSR Tagset (tập thẻ): DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) ES Tagsets: DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) Ratcheted Tagsets (theo cơ chế bánh cóc): DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) Các cơ chế Ratchet (cơ chế bánh cóc) ECIES (Sơ đồ mã hóa tích hợp trên đường cong elliptic) sử dụng ba cơ chế ratchet đồng bộ (cơ chế cập nhật khóa từng bước) để cung cấp tính bí mật chuyển tiếp và quản lý phiên hiệu quả.\nTổng quan về Ratchet (cơ chế ratchet trong mật mã) Ba loại Ratchet (cơ chế bánh cóc):\nDH Ratchet (cơ chế ratchet - cơ chế tiến hóa khóa): Thực hiện các trao đổi khóa Diffie–Hellman để tạo ra các khóa gốc mới Session Tag Ratchet: Dẫn xuất các thẻ phiên dùng một lần một cách xác định Symmetric Key Ratchet: Dẫn xuất các khóa phiên để mã hóa thông điệp Mối quan hệ:\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) Các thuộc tính chính:\nBên gửi: Tạo thẻ và khóa theo nhu cầu (không cần lưu trữ) Bên nhận: Tạo sẵn thẻ cho cửa sổ nhìn trước (cần lưu trữ) Đồng bộ hóa: Chỉ số thẻ xác định chỉ số khóa (N_tag = N_key) Bí mật chuyển tiếp: Đạt được thông qua DH ratchet (cơ chế bánh cóc Diffie–Hellman để luân phiên khóa) định kỳ Hiệu quả: Bên nhận có thể hoãn việc tính toán khóa cho đến khi nhận được thẻ DH Ratchet (cơ chế bánh cóc Diffie–Hellman) DH ratchet (cơ chế “bánh cóc” Diffie–Hellman) cung cấp tính bí mật chuyển tiếp (forward secrecy) bằng cách định kỳ trao đổi các khóa tạm thời mới.\nTần suất DH Ratchet (cơ chế ratchet Diffie-Hellman) Các điều kiện Ratchet (cơ chế xoay khóa) bắt buộc: - Tập thẻ sắp cạn (thẻ 65535 là tối đa) - Các chính sách cụ thể theo triển khai: - Ngưỡng số lượng thông điệp (ví dụ, cứ 4096 thông điệp) - Ngưỡng thời gian (ví dụ, cứ 10 phút) - Ngưỡng dung lượng dữ liệu (ví dụ, cứ 100 MB)\nKhuyến nghị về First Ratchet (cơ chế bánh cóc trong mật mã): Khoảng nhãn số 4096 để tránh đạt tới giới hạn\nGiá trị tối đa: - ID tập thẻ tối đa: 65535 - ID khóa tối đa: 32767 - Số thông điệp tối đa trên mỗi tập thẻ: 65535 - Dung lượng dữ liệu tối đa theo lý thuyết mỗi phiên: ~6.9 TB (64K tập thẻ × 64K thông điệp × 1730 byte trung bình)\nNhãn và ID khóa trong DH Ratchet (cơ chế bánh cóc Diffie-Hellman) Tag set ban đầu (tập thẻ) (sau bắt tay): - Tag set ID: 0 - Chưa có khối NextKey nào được gửi - Chưa gán ID khóa nào\nSau Ratchet (cơ chế bánh cóc mật mã) đầu tiên: - ID tập thẻ: 1 = (1 + ID khóa của Alice + ID khóa của Bob) = (1 + 0 + 0) - Alice gửi NextKey với ID khóa 0 - Bob phản hồi bằng NextKey với ID khóa 0\nCác tập nhãn tiếp theo: - ID tập nhãn = 1 + ID khóa của bên gửi + ID khóa của bên nhận - Ví dụ: Tập nhãn 5 = (1 + sender_key_2 + receiver_key_2)\nBảng tiến triển của tập thẻ:\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set \\* = Khóa mới được tạo trong bước ratchet (cơ chế bánh cóc đổi khóa) này Quy tắc ID khóa: - ID theo thứ tự tăng dần, bắt đầu từ 0 - ID chỉ tăng khi tạo khóa mới - ID khóa tối đa là 32767 (15 bit) - Sau ID khóa 32767, cần phiên mới\nLuồng thông điệp của DH Ratchet (cơ chế bánh cóc Diffie-Hellman) Vai trò: - Tag Sender (Bên gửi tag): Sở hữu bộ tag hướng ra, gửi thông điệp - Tag Receiver (Bên nhận tag): Sở hữu bộ tag hướng vào, nhận thông điệp\nPattern: Bên gửi thẻ khởi động ratchet (cơ chế cập nhật khóa) khi tập thẻ gần cạn.\nSơ đồ luồng thông điệp:\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) Các mẫu Ratchet (cơ chế cập nhật khóa một chiều):\nTạo các bộ thẻ đánh số chẵn (2, 4, 6, \u0026hellip;): 1. Người gửi sinh khóa mới 2. Người gửi gửi khối NextKey kèm khóa mới 3. Người nhận gửi khối NextKey kèm ID khóa cũ (ACK - xác nhận) 4. Cả hai thực hiện DH (trao đổi khóa Diffie-Hellman) với (khóa người gửi mới × khóa người nhận cũ)\nTạo các tập thẻ số lẻ (3, 5, 7, \u0026hellip;): 1. Người gửi yêu cầu khóa đảo chiều (gửi NextKey với cờ yêu cầu) 2. Người nhận tạo khóa mới 3. Người nhận gửi khối NextKey với khóa mới 4. Cả hai thực hiện DH (Diffie-Hellman) với (khóa người gửi cũ × khóa người nhận mới)\nĐịnh dạng khối NextKey (khóa tiếp theo) Xem phần Payload Format để biết đặc tả chi tiết của khối NextKey.\nCác thành phần chính: - Byte cờ: - Bit 0: Có khóa (1) hoặc chỉ ID (0) - Bit 1: Khóa ngược (1) hoặc khóa xuôi (0) - Bit 2: Yêu cầu khóa ngược (1) hoặc không yêu cầu (0) - ID khóa: 2 byte, big-endian (0-32767) - Khóa công khai: 32 byte X25519 (nếu bit 0 = 1)\nVí dụ về NextKey Blocks (các khối khóa kế tiếp):\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) Hàm dẫn xuất khóa (KDF) của DH Ratchet (cơ chế bánh cóc Diffie–Hellman) Khi các khóa mới được trao đổi:\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset Thời điểm then chốt:\nTag Sender (bên gửi tag): - Tạo bộ tag đầu ra mới ngay lập tức - Bắt đầu sử dụng các tag mới ngay lập tức - Xóa bộ tag đầu ra cũ\nTag Receiver (bộ nhận tag): - Tạo tập thẻ đến mới - Giữ lại tập thẻ đến cũ trong khoảng ân hạn (3 phút) - Chấp nhận các thẻ từ cả hai tập thẻ cũ và mới trong khoảng ân hạn - Xóa tập thẻ đến cũ sau khi hết khoảng ân hạn\nQuản lý trạng thái DH Ratchet (cơ chế bánh cóc Diffie-Hellman) Trạng thái bên gửi: - Tập thẻ (tag) gửi đi hiện tại - ID tập thẻ và các ID khóa - Khóa gốc kế tiếp (cho ratchet (cơ chế bánh cóc trong mật mã) kế tiếp) - Số lượng thông điệp trong tập thẻ hiện tại\nTrạng thái bên nhận: - Tập thẻ đến hiện tại (có thể có 2 trong thời gian ân hạn) - Các số thứ tự thông điệp trước đó (PN) để phát hiện khoảng trống - Cửa sổ nhìn trước của các thẻ được tạo trước - Khóa gốc tiếp theo (cho ratchet (cơ chế bánh cóc) tiếp theo)\nQuy tắc chuyển trạng thái:\nTrước lần Ratchet (cơ chế bánh cóc thay đổi khóa) đầu tiên:\nSử dụng tag set 0 (từ NSR) Chưa gán ID khóa nào Khởi tạo Ratchet (cơ chế bánh cóc mã hóa):\nTạo khóa mới (nếu bên gửi là bên tạo trong vòng này) Gửi NextKey block (khối thông báo khóa kế tiếp) trong ES message (thông điệp ES) Chờ phản hồi NextKey trước khi tạo tag set (tập thẻ) gửi đi mới Receiving Ratchet Request (yêu cầu ratchet - cơ chế xoay/luân phiên khóa):\nTạo khóa mới (nếu bên nhận là bên tạo trong vòng này) Thực hiện DH (Diffie-Hellman) với khóa nhận được Tạo bộ thẻ vào mới Gửi phản hồi NextKey Giữ lại bộ thẻ vào cũ trong một khoảng ân hạn Hoàn tất Ratchet (cơ chế chuyển khóa trong mật mã):\nNhận phản hồi NextKey Thực hiện DH (Diffie–Hellman) Tạo tập thẻ gửi đi mới Bắt đầu sử dụng các thẻ mới Session Tag Ratchet (Cơ chế ratchet cho Session Tag) Cơ chế ratchet (cơ chế bánh cóc) của thẻ phiên tạo ra các thẻ phiên 8 byte chỉ dùng một lần theo cách xác định.\nMục đích của Session Tag Ratchet (cơ chế ratchet cho thẻ phiên) Thay thế việc truyền thẻ tường minh (ElGamal gửi các thẻ 32 byte) Cho phép bên nhận tạo trước các thẻ cho cửa sổ nhìn trước Bên gửi tạo theo nhu cầu (không cần lưu trữ) Đồng bộ với symmetric key ratchet (cơ chế ratchet khóa đối xứng) thông qua chỉ mục Công thức ratchet (cơ chế bánh cóc trong mật mã) cho nhãn phiên Khởi tạo:\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset Sinh Tag (nhãn) (cho tag N):\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 Trình tự đầy đủ:\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] Triển khai phía gửi của Session Tag Ratchet (cơ chế ratchet cho thẻ phiên) class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) Quy trình gửi: 1. Gọi get_next_tag() cho mỗi thông điệp 2. Sử dụng thẻ được trả về trong thông điệp ES 3. Lưu chỉ mục N để có thể theo dõi ACK (xác nhận) 4. Không cần lưu trữ thẻ (được tạo theo yêu cầu)\nTriển khai phía nhận của Session Tag Ratchet (cơ chế ratchet cho thẻ phiên) class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) Quy trình phía nhận: 1. Tạo sẵn tag (thẻ) cho cửa sổ nhìn trước (ví dụ: 32 tag) 2. Lưu các tag trong bảng băm hoặc từ điển 3. Khi thông điệp đến, tra cứu tag để lấy chỉ số N 4. Xóa tag khỏi bộ lưu trữ (dùng một lần) 5. Mở rộng cửa sổ nếu số lượng tag giảm xuống dưới ngưỡng\nChiến lược nhìn trước cho thẻ phiên Mục đích: Cân bằng việc sử dụng bộ nhớ với việc xử lý thông điệp không theo thứ tự\nKích thước Look-Ahead (xem trước) được khuyến nghị:\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets **Nhìn trước thích ứng:** # Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 Cắt bớt phía sau:\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 Tính toán bộ nhớ:\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total Xử lý Session Tag (thẻ phiên) khi đến không theo thứ tự Kịch bản: Thông điệp đến không theo đúng thứ tự\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 Hành vi phía nhận:\nNhận tag_5:\nTra cứu: tìm thấy tại chỉ mục 5 Xử lý thông điệp Xóa tag_5 Giá trị nhận cao nhất: 5 Nhận tag_7 (không theo thứ tự):\nTra cứu: tìm thấy tại chỉ mục 7 Xử lý thông điệp Xóa tag_7 Lớn nhất đã nhận: 7 Lưu ý: tag_6 vẫn còn trong bộ nhớ lưu trữ (chưa nhận) Nhận tag_6 (bị trễ):\nTra cứu: tìm thấy tại chỉ mục 6 Xử lý thông điệp Xóa tag_6 Giá trị cao nhất đã nhận: 7 (không thay đổi) Nhận tag_8:\nTra cứu: tìm thấy tại chỉ mục 8 Xử lý thông điệp Xóa tag_8 Mức cao nhất đã nhận: 8 Bảo trì cửa sổ: - Theo dõi chỉ số nhận được cao nhất - Duy trì danh sách các chỉ số bị thiếu (khoảng trống) - Mở rộng cửa sổ dựa trên chỉ số cao nhất - Tùy chọn: Cho các khoảng trống cũ hết hạn sau khi quá thời gian chờ\nCơ chế bánh cóc khóa đối xứng Cơ chế symmetric key ratchet (cơ chế bánh cóc khóa đối xứng) tạo ra các khóa mã hóa 32 byte được đồng bộ với các thẻ phiên.\nMục đích của cơ chế bánh cóc khóa đối xứng Cung cấp khóa mã hóa duy nhất cho từng thông điệp Đồng bộ với session tag ratchet (cơ chế \u0026ldquo;ratchet\u0026rdquo; của thẻ phiên) (cùng chỉ mục) Bên gửi có thể tạo theo yêu cầu Bên nhận có thể hoãn việc tạo cho đến khi thẻ được nhận Công thức Ratchet (cơ chế bánh cóc) cho khóa đối xứng Khởi tạo:\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived Sinh khóa (cho khóa N):\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) Trình tự hoàn chỉnh:\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] Hiện thực phía gửi của Symmetric Key Ratchet (cơ chế bánh cóc dùng khóa đối xứng) class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) Quy trình phía người gửi: 1. Lấy tag (thẻ) tiếp theo và chỉ số của nó N 2. Tạo khóa cho chỉ số N 3. Dùng khóa để mã hóa thông điệp 4. Không cần lưu trữ khóa\nTriển khai phía nhận Symmetric Key Ratchet (cơ chế bánh cóc cho khóa đối xứng) Chiến lược 1: Deferred Generation (sinh trì hoãn) (Khuyến nghị)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) Quy trình tạo trì hoãn: 1. Nhận ES message có tag 2. Tra cứu tag để lấy chỉ số N 3. Sinh các khóa từ 0 đến N (nếu chưa được sinh) 4. Dùng khóa N để giải mã thông điệp 5. Chain key (khóa chuỗi) hiện ở vị trí chỉ số N\nƯu điểm: - Mức sử dụng bộ nhớ tối thiểu - Khóa chỉ được tạo khi cần - Triển khai đơn giản\nNhược điểm: - Phải tạo tất cả các khóa từ 0 đến N khi sử dụng lần đầu - Không thể xử lý các thông điệp đến không theo thứ tự nếu không có bộ nhớ đệm\nChiến lược 2: Tạo trước với Tag Window (cửa sổ thẻ) (Phương án thay thế)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None Quy trình tạo trước: 1. Tạo trước các khóa khớp với tag window (cửa sổ thẻ) (ví dụ, 32 khóa) 2. Lưu các khóa được lập chỉ mục theo số thứ tự thông điệp 3. Khi nhận thẻ, tra cứu khóa tương ứng 4. Mở rộng cửa sổ khi các thẻ được sử dụng\nƯu điểm: - Xử lý các thông điệp không theo thứ tự một cách tự nhiên - Truy xuất khóa nhanh (không có độ trễ tạo)\nNhược điểm: - Mức sử dụng bộ nhớ cao hơn (32 byte mỗi key (khóa) so với 8 byte mỗi tag (thẻ)) - Phải giữ các key (khóa) đồng bộ với các tag (thẻ)\nSo sánh bộ nhớ:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB Đồng bộ hóa ratchet đối xứng với Session Tags (thẻ phiên) Yêu cầu quan trọng: Chỉ mục Session tag (thẻ phiên) PHẢI bằng chỉ mục khóa đối xứng\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) Các chế độ hỏng hóc:\nNếu việc đồng bộ hóa bị gián đoạn: - Dùng sai khóa để giải mã - Việc xác minh MAC (mã xác thực thông điệp) thất bại - Thông điệp bị từ chối\nPhòng ngừa: - Luôn dùng cùng một chỉ mục cho thẻ và khóa - Không bao giờ bỏ qua các chỉ mục trong bất kỳ ratchet (cơ chế cập nhật khóa dần) nào - Xử lý cẩn thận các thông điệp không theo thứ tự\nThiết kế Nonce (số dùng một lần) cho Symmetric Ratchet (ratchet đối xứng) Nonce (giá trị chỉ dùng một lần) được suy ra từ số thứ tự thông điệp:\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) Ví dụ:\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 Các thuộc tính quan trọng: - Nonce (giá trị số dùng một lần) là duy nhất cho mỗi thông điệp trong một bộ thẻ - Nonce không bao giờ lặp lại (các thẻ dùng một lần đảm bảo điều này) - Bộ đếm 8 byte cho phép 2^64 thông điệp (chúng tôi chỉ dùng 2^16) - Định dạng nonce khớp với phương pháp xây dựng dựa trên bộ đếm của RFC 7539\nQuản lý phiên Ngữ cảnh phiên Tất cả các phiên vào và ra phải thuộc về một ngữ cảnh cụ thể:\nNgữ cảnh Router: Các phiên dành cho chính router Ngữ cảnh Destination (đích I2P): Các phiên dành cho một destination cục bộ cụ thể (ứng dụng khách) Quy tắc quan trọng: Tuyệt đối không được chia sẻ phiên giữa các ngữ cảnh để ngăn chặn các cuộc tấn công tương quan.\nTriển khai:\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) Triển khai I2P bằng Java:\nTrong Java I2P, lớp SessionKeyManager cung cấp các chức năng sau: - Một SessionKeyManager cho mỗi router - Một SessionKeyManager cho mỗi đích cục bộ - Quản lý tách biệt các phiên ECIES và ElGamal trong từng ngữ cảnh\nRàng buộc phiên Binding (ràng buộc) thiết lập mối liên hệ giữa một phiên và một đích đầu xa cụ thể.\nCác phiên ràng buộc Đặc điểm: - Bao gồm khóa tĩnh của người gửi trong NS message (thông điệp NS) - Người nhận có thể nhận diện destination (đích) của người gửi - Cho phép giao tiếp hai chiều - Một phiên đi cho mỗi destination - Có thể có nhiều phiên đến (trong quá trình chuyển đổi)\nTrường hợp sử dụng: - Kết nối dạng streaming (tương tự TCP) - Các datagram (gói tin) có thể phản hồi - Bất kỳ giao thức nào đòi hỏi mô hình yêu cầu/đáp ứng\nQuy trình liên kết:\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) Lợi ích: 1. Ephemeral-Ephemeral DH (cả hai bên dùng khóa Diffie-Hellman tạm thời): Phản hồi sử dụng ee DH (bảo mật chuyển tiếp đầy đủ) 2. Tính liên tục của phiên: Ratchets (cơ chế cập nhật khóa một chiều) duy trì ràng buộc tới cùng một đích 3. Bảo mật: Ngăn chiếm quyền phiên (xác thực bằng khóa tĩnh) 4. Hiệu quả: Một phiên cho mỗi đích (không trùng lặp)\nCác phiên chưa ràng buộc Đặc điểm: - Không có khóa tĩnh trong NS message (phần cờ (flags) đều là số 0) - Người nhận không thể xác định người gửi - Chỉ liên lạc một chiều - Cho phép nhiều phiên đến cùng một đích\nCác trường hợp sử dụng: - Gói datagram thô (gửi rồi quên) - Xuất bản ẩn danh - Nhắn tin kiểu phát quảng bá\nĐặc tính: - Ẩn danh hơn (không thể xác định người gửi) - Hiệu quả hơn (1 DH (Diffie-Hellman - trao đổi khóa) so với 2 DH trong handshake (quy trình bắt tay)) - Không thể trả lời (người nhận không biết trả lời tới đâu) - Không có session ratcheting (cơ chế tăng dần khóa phiên; dùng một lần hoặc giới hạn)\nGhép cặp phiên Ghép cặp kết nối một phiên đến với một phiên đi để giao tiếp hai chiều.\nTạo phiên ghép cặp Góc nhìn của Alice (bên khởi tạo):\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) Góc nhìn của Bob (responder - bên phản hồi):\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) Lợi ích của việc ghép cặp phiên ACKs trong băng (ACK = acknowledgement - xác nhận): Có thể xác nhận thông điệp mà không cần clove riêng biệt (clove: “nhánh” trong garlic message) Ratcheting hiệu quả (cơ chế “bánh cóc” mật mã): Cả hai hướng ratchet đồng bộ Điều khiển luồng: Có thể triển khai back-pressure (cơ chế áp lực ngược) trên các phiên ghép cặp Tính nhất quán trạng thái: Dễ dàng duy trì trạng thái đồng bộ Các quy tắc ghép cặp phiên Phiên đi ra có thể không được ghép cặp (NS chưa ràng buộc) Phiên đi vào đối với NS đã ràng buộc nên được ghép cặp Việc ghép cặp diễn ra khi tạo phiên, không phải sau đó Các phiên đã ghép cặp có cùng ràng buộc đích Các cơ chế ratchet (cơ chế then cài mật mã) diễn ra độc lập nhưng được điều phối Vòng đời phiên Vòng đời phiên: Giai đoạn khởi tạo Khởi tạo phiên gửi đi (Alice):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session Khởi tạo phiên đến (Bob):\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session Vòng đời phiên: Giai đoạn hoạt động Các chuyển trạng thái:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED Duy trì phiên hoạt động:\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) Vòng đời phiên: Giai đoạn hết hạn Các giá trị thời gian chờ của phiên:\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet **Cơ chế hết hạn:** def check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) Quy tắc trọng yếu: Các phiên ra PHẢI hết hạn trước các phiên vào để tránh mất đồng bộ.\nKết thúc an toàn:\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() Nhiều thông điệp NS Kịch bản: Thông điệp NS của Alice bị mất hoặc phản hồi NSR bị mất.\nHành vi của Alice:\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] Các thuộc tính quan trọng:\nKhóa tạm thời riêng biệt: Mỗi NS sử dụng một khóa tạm thời khác nhau Bắt tay độc lập: Mỗi NS tạo trạng thái bắt tay riêng biệt Tương quan NSR: Thẻ NSR xác định NS mà nó phản hồi Dọn dẹp trạng thái: Các trạng thái NS không dùng sẽ bị loại bỏ sau khi NSR thành công Phòng ngừa tấn công:\nĐể ngăn ngừa cạn kiệt tài nguyên:\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context Nhiều thông điệp NSR Kịch bản: Bob gửi nhiều NSR (ví dụ: dữ liệu phản hồi được chia nhỏ thành nhiều thông điệp).\nHành vi của Bob:\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES Hành vi của Alice:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake Dọn dẹp của Bob:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED Các thuộc tính quan trọng:\nCho phép nhiều NSR: Bob có thể gửi nhiều NSR cho mỗi NS Khóa tạm thời khác nhau: Mỗi NSR nên sử dụng một khóa tạm thời duy nhất Cùng một tagset cho NSR: Tất cả các NSR cho một NS sử dụng cùng một tagset (tập thẻ) ES đầu tiên sẽ thắng: ES đầu tiên của Alice quyết định NSR nào thành công Dọn dẹp sau ES: Bob loại bỏ các trạng thái chưa dùng sau khi nhận ES Máy trạng thái phiên Sơ đồ trạng thái đầy đủ:\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED Mô tả trạng thái:\nNEW: Phiên gửi đi đã được tạo, chưa gửi NS PENDING_REPLY: Đã gửi NS, đang chờ NSR AWAITING_ES: Đã gửi NSR, đang chờ ES đầu tiên từ Alice ESTABLISHED: Bắt tay đã hoàn tất, có thể gửi/nhận ES ACTIVE: Đang tích cực trao đổi các thông điệp ES RATCHETING: DH ratchet (cơ chế bánh cóc Diffie-Hellman) đang diễn ra (trạng thái con của ACTIVE) EXPIRED: Phiên đã hết hạn, đang chờ xóa TERMINATED: Phiên đã bị kết thúc tường minh Định dạng dữ liệu tải Phần tải của tất cả các thông điệp ECIES (lược đồ mã hóa tích hợp trên đường cong elliptic) (NS, NSR, ES) sử dụng một định dạng dựa trên khối tương tự NTCP2.\nCấu trúc khối Định dạng chung:\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Các trường:\nblk: 1 byte - Số kiểu khối size: 2 byte - Kích thước big-endian (thứ tự byte lớn trước) của trường dữ liệu (0-65516) data: Độ dài thay đổi - Dữ liệu dành riêng cho khối Các ràng buộc:\nKhung ChaChaPoly tối đa: 65535 byte MAC Poly1305: 16 byte Tổng số khối tối đa: 65519 byte (65535 - 16) Khối đơn tối đa: 65519 byte (bao gồm phần đầu 3 byte) Dữ liệu khối đơn tối đa: 65516 byte Các loại khối Các loại khối được định nghĩa:\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension **Xử lý khối không xác định:** Các triển khai PHẢI bỏ qua các khối có mã kiểu không xác định và coi chúng như phần đệm. Điều này đảm bảo khả năng tương thích tiến.\nQuy tắc sắp xếp các khối Thứ tự thông điệp NS Bắt buộc: - Khối DateTime PHẢI đứng đầu tiên\nĐược phép: - Garlic Clove (tiểu thông điệp trong garlic encryption) (type 11) - Tùy chọn (type 5) - nếu được triển khai - Đệm (type 254)\nBị cấm: - NextKey, ACK, ACK Request, Termination, MessageNumbers\nVí dụ về payload NS hợp lệ:\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) Thứ tự thông điệp NSR (viết tắt, không dịch) Bắt buộc: - Không có (payload (dữ liệu tải) có thể rỗng)\nĐược phép: - Garlic Clove (đơn vị thông điệp con trong garlic encryption) (loại 11) - Tùy chọn (loại 5) - nếu được triển khai - Đệm (loại 254)\nKhông được phép: - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers\nVí dụ về payload (nội dung dữ liệu) NSR hợp lệ:\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) hoặc\n(empty - ACK only) Thứ tự thông điệp ES Bắt buộc: - Không có (payload có thể để trống)\nĐược phép (theo bất kỳ thứ tự nào): - Garlic Clove (type 11) - NextKey (type 7) - ACK (type 8) - ACK Request (type 9) - Termination (type 4) - nếu được triển khai - MessageNumbers (type 6) - nếu được triển khai - Options (type 5) - nếu được triển khai - Padding (type 254)\nQuy tắc đặc biệt: - Termination PHẢI là khối cuối cùng (trừ Padding) - Padding PHẢI là khối cuối cùng - Cho phép nhiều Garlic Cloves - Cho phép tối đa 2 khối NextKey (xuôi và ngược) - KHÔNG cho phép nhiều khối Padding\nVí dụ các payload ES hợp lệ:\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) DateTime Block (khối ngày giờ) (Loại 0) Mục đích: Dấu thời gian để ngăn chặn phát lại và xác thực độ lệch đồng hồ\nKích thước: 7 byte (tiêu đề 3 byte + dữ liệu 4 byte)\nĐịnh dạng:\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Các trường:\nblk: 0 size: 4 (big-endian - byte có trọng số lớn nhất trước) timestamp: 4 byte - dấu thời gian Unix tính bằng giây (không dấu, big-endian) Định dạng dấu thời gian:\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) Quy tắc kiểm tra hợp lệ:\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True Ngăn chặn phát lại:\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass Ghi chú triển khai:\nNS Messages: DateTime PHẢI là khối đầu tiên NSR/ES Messages: Thông thường không bao gồm DateTime Cửa sổ phát lại: 5 phút là mức tối thiểu được khuyến nghị Bộ lọc Bloom: Được khuyến nghị để phát hiện phát lại hiệu quả Độ lệch đồng hồ: Cho phép muộn 5 phút, sớm 2 phút Garlic Clove Block (khối nhánh tỏi) (Type 11) Mục đích: Đóng gói các thông điệp I2NP để chuyển giao\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ Các trường:\nblk: 11 size: Tổng kích thước của clove (nhánh trong thông điệp garlic) (biến đổi) Delivery Instructions: Như được quy định trong đặc tả I2NP type: Kiểu thông điệp I2NP (1 byte) Message_ID: ID thông điệp I2NP (4 byte) Expiration: Dấu thời gian Unix tính bằng giây (4 byte) I2NP Message body: Dữ liệu thông điệp có độ dài biến đổi Định dạng hướng dẫn chuyển phát:\nPhân phối cục bộ (1 byte):\n+----+ |0x00| +----+ Giao tới Destination (đích) (33 byte):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Router Delivery (33 byte):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Chuyển giao qua Tunnel (37 bytes):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ Tiêu đề thông điệp I2NP (tổng cộng 9 byte):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: loại thông điệp I2NP (Database Store, Database Lookup, Data, v.v.) msg_id: định danh thông điệp 4 byte expiration: dấu thời gian Unix 4 byte (giây) Những khác biệt quan trọng so với Định dạng Clove ElGamal (Clove: nhánh trong garlic encryption):\nKhông có Chứng chỉ: Trường Chứng chỉ bị lược bỏ (không dùng trong ElGamal) Không có Clove ID: Clove ID bị lược bỏ (Clove: tiểu thông điệp trong garlic encryption; vốn luôn là 0) Không có thời điểm hết hạn của Clove: Thay vào đó dùng thời điểm hết hạn của thông điệp I2NP Header gọn: Header I2NP 9-byte so với định dạng ElGamal lớn hơn Mỗi Clove là một khối riêng biệt: Không có cấu trúc CloveSet (tập hợp các Clove) Nhiều Clove (thành phần con của thông điệp trong garlic encryption):\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] Các kiểu thông điệp I2NP phổ biến trong Cloves (tép tỏi):\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages **Xử lý Clove (thông điệp con trong 'garlic' message):** def process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) Khối NextKey (khóa kế tiếp) (Loại 7) Mục đích: trao đổi khóa DH ratchet (cơ chế bánh cóc)\nĐịnh dạng (Có khóa - 38 byte):\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ Định dạng (Chỉ Key ID - 6 byte):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ Các trường:\nblk: 7 size: 3 (chỉ ID) hoặc 35 (kèm khóa) flag: 1 byte - các bit cờ key ID: 2 byte - định danh khóa theo Big-endian (thứ tự byte có trọng số lớn trước) (0-32767) Public Key: 32 byte - khóa công khai X25519 (little-endian - thứ tự byte có trọng số nhỏ trước), nếu bit cờ 0 = 1 Các bit cờ:\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) Ví dụ về cờ:\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 Quy tắc ID khóa:\nCác ID tăng dần liên tiếp: 0, 1, 2, \u0026hellip;, 32767 ID chỉ tăng khi tạo khóa mới Cùng một ID được dùng cho nhiều thông điệp cho đến lần ratchet (cơ chế xoay vòng khóa) tiếp theo ID tối đa là 32767 (sau đó phải bắt đầu phiên mới) Ví dụ sử dụng:\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) Logic xử lý:\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) Nhiều khối NextKey:\nMột thông điệp ES có thể chứa tối đa 2 khối NextKey khi cả hai chiều cùng thực hiện ratcheting (cơ chế ratchet tăng bậc khóa) đồng thời:\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] Khối ACK (Loại 8) Mục đích: Xác nhận các thông điệp đã nhận in-band (trong cùng kênh)\nĐịnh dạng (ACK đơn - 7 byte):\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ Định dạng (nhiều ACK):\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Các trường:\nblk: 8 size: 4 * số lượng ACK (gói xác nhận) (tối thiểu 4) Đối với mỗi ACK: tagsetid: 2 byte - ID tập thẻ Big-endian (thứ tự byte lớn trước) (0-65535) N: 2 byte - số thông điệp Big-endian (0-65535) Xác định ID của tập thẻ:\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 Ví dụ về ACK đơn lẻ:\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) Ví dụ về nhiều ACK (thông điệp xác nhận):\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) Xử lý:\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) Khi nào cần gửi ACKs (thông báo xác nhận):\nYêu cầu ACK (xác nhận) tường minh: Luôn phản hồi khối ACK Request Chuyển giao LeaseSet: Khi bên gửi bao gồm LeaseSet trong thông điệp Thiết lập phiên: Có thể ACK NS/NSR (dù giao thức ưu tiên ACK ngầm qua ES) Xác nhận Ratchet: Có thể ACK việc nhận NextKey Tầng ứng dụng: Theo yêu cầu của giao thức tầng cao hơn (ví dụ: Streaming) Thời gian ACK (gói xác nhận):\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None Khối yêu cầu ACK (Loại 9) Mục đích: Yêu cầu in-band acknowledgment (xác nhận cùng kênh) cho thông điệp hiện tại\nĐịnh dạng:\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ Các trường:\nblk: 9 size: 1 flg: 1 byte - Cờ (tất cả các bit hiện không sử dụng, đặt về 0) Cách sử dụng:\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] Phản hồi của phía nhận:\nKhi nhận được yêu cầu ACK (xác nhận):\nCó dữ liệu tức thời: Bao gồm khối ACK trong phản hồi tức thời Không có dữ liệu tức thời: Khởi động bộ đếm thời gian (ví dụ, 100ms) và gửi ES rỗng kèm ACK nếu bộ đếm hết hạn Tag Set ID (mã định danh tập thẻ): Sử dụng Tag Set ID của tập thẻ vào hiện tại Message Number (số hiệu thông điệp): Sử dụng Message Number gắn với session tag (thẻ phiên) đã nhận Xử lý:\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) Khi nào nên sử dụng ACK Request (yêu cầu xác nhận):\nThông điệp trọng yếu: Các thông điệp bắt buộc phải được xác nhận Chuyển giao LeaseSet: Khi đóng gói kèm một LeaseSet Session Ratchet (cơ chế gài răng phiên – thay khóa liên tục): Sau khi gửi khối NextKey (khối chứa khóa tiếp theo) Kết thúc truyền: Khi bên gửi không còn dữ liệu để gửi nhưng vẫn muốn nhận xác nhận Khi KHÔNG nên sử dụng:\nGiao thức Streaming: Lớp streaming xử lý ACK (gói xác nhận) Thông điệp tần suất cao: Tránh yêu cầu ACK trên mọi thông điệp (chi phí phụ trội) Các datagram không quan trọng: Các datagram thô thường không cần ACK Khối Kết thúc (Loại 4) Trạng thái: Chưa được triển khai\nMục đích: Kết thúc phiên một cách an toàn\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ Các trường:\nblk: 4 size: từ 1 byte trở lên rsn: 1 byte - Mã lý do addl data: Dữ liệu bổ sung tùy chọn (định dạng tùy thuộc vào lý do) Mã lý do:\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific **Cách sử dụng (khi được triển khai):** # Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) Quy tắc:\nPHẢI là khối cuối cùng, ngoại trừ Padding (đệm) Padding PHẢI theo sau Termination (kết thúc) nếu có Không được phép trong các thông điệp NS hoặc NSR Chỉ được phép trong các thông điệp ES Khối tùy chọn (Loại 5) Trạng thái: CHƯA TRIỂN KHAI\nMục đích: Thương lượng các tham số phiên\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Các trường:\nblk: 5 size: 21 byte trở lên ver: 1 byte - Phiên bản giao thức (phải là 0) flg: 1 byte - Cờ (hiện tại tất cả các bit chưa được sử dụng) STL: 1 byte - Độ dài thẻ phiên (phải là 8) STimeout: 2 byte - Thời gian chờ không hoạt động của phiên tính bằng giây (big-endian (thứ tự byte lớn trước)) SOTW: 2 byte - Cửa sổ thẻ gửi đi của phía gửi (big-endian) RITW: 2 byte - Cửa sổ thẻ nhận vào của phía nhận (big-endian) tmin, tmax, rmin, rmax: mỗi cái 1 byte - Các tham số đệm (4.4 fixed-point (định dạng số dấu phẩy cố định 4.4)) tdmy: 2 byte - Lưu lượng giả tối đa sẵn sàng gửi (byte/giây, big-endian) rdmy: 2 byte - Lưu lượng giả được yêu cầu (byte/giây, big-endian) tdelay: 2 byte - Độ trễ tối đa bên trong thông điệp sẵn sàng chèn (msec, big-endian) rdelay: 2 byte - Độ trễ bên trong thông điệp được yêu cầu (msec, big-endian) more_options: Biến (độ dài thay đổi) - Các phần mở rộng trong tương lai Tham số đệm (dạng dấu phẩy cố định 4.4):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) Thương lượng Tag Window (cửa sổ thẻ):\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size Giá trị mặc định (khi các tùy chọn không được đàm phán):\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } Khối MessageNumbers (Loại 6) Trạng thái: CHƯA TRIỂN KHAI\nMục đích: Chỉ ra tin nhắn cuối cùng được gửi trong tập thẻ trước đó (cho phép phát hiện khoảng trống)\nĐịnh dạng:\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ Các trường:\nblk: 6 size: 2 PN: 2 byte - Số thứ tự thông điệp cuối cùng của tập thẻ trước (big-endian (thứ tự byte lớn trước), 0-65535) Định nghĩa PN (Previous Number):\nPN là chỉ số của thẻ cuối cùng đã được gửi trong tập thẻ trước đó.\nCách sử dụng (khi được triển khai):\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] Lợi ích cho bên nhận:\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) Quy tắc:\nKHÔNG ĐƯỢC gửi trong tag set (nhóm thẻ) 0 (không có tag set trước đó) Chỉ được gửi trong ES messages (thông điệp ES) Chỉ được gửi trong những thông điệp đầu tiên của tag set mới Giá trị PN là từ góc nhìn của người gửi (tag (thẻ) cuối cùng mà người gửi đã gửi) Mối quan hệ với Signal:\nTrong Signal Double Ratchet (giao thức Double Ratchet của Signal), PN nằm trong phần đầu của thông điệp. Trong ECIES (lược đồ mã hóa tích hợp trên đường cong elliptic), PN nằm trong payload đã mã hóa và là tùy chọn.\nKhối đệm (Loại 254) Mục đích: Khả năng chống phân tích lưu lượng và che giấu kích thước thông điệp\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Các trường:\nblk: 254 size: 0-65516 byte (big-endian: thứ tự byte lớn trước) padding: Dữ liệu ngẫu nhiên hoặc bằng 0 Quy tắc:\nPHẢI là khối cuối cùng trong thông điệp KHÔNG được phép có nhiều khối Padding (đệm) Có thể có độ dài bằng 0 (chỉ có phần đầu 3 byte) Dữ liệu Padding có thể là các số 0 hoặc các byte ngẫu nhiên Đệm mặc định:\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) Chiến lược chống phân tích lưu lượng:\nChiến lược 1: Kích thước ngẫu nhiên (Mặc định)\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Chiến lược 2: Làm tròn đến bội số\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Chiến lược 3: Kích thước thông điệp cố định\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Chiến lược 4: Đệm được đàm phán (khối Options)\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Padding-Only Messages (các thông điệp chỉ chứa đệm):\nThông điệp có thể chỉ gồm phần đệm (không có dữ liệu ứng dụng):\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] Ghi chú triển khai:\nĐệm toàn số 0: Chấp nhận được (sẽ được ChaCha20 mã hóa) Đệm ngẫu nhiên: Không cung cấp thêm bảo mật sau khi đã mã hóa nhưng tiêu tốn nhiều entropy (độ ngẫu nhiên) hơn Hiệu năng: Việc tạo đệm ngẫu nhiên có thể tốn kém; cân nhắc dùng đệm toàn số 0 Bộ nhớ: Khối đệm lớn tiêu tốn băng thông; hãy thận trọng với kích thước tối đa Hướng dẫn triển khai Điều kiện tiên quyết Thư viện mật mã:\nX25519: libsodium, NaCl, hoặc Bouncy Castle ChaCha20-Poly1305: libsodium, OpenSSL 1.1.0+, hoặc Bouncy Castle SHA-256: OpenSSL, Bouncy Castle, hoặc hỗ trợ tích hợp sẵn trong ngôn ngữ Elligator2: Hỗ trợ thư viện hạn chế; có thể cần triển khai tùy chỉnh Triển khai Elligator2 (kỹ thuật che giấu điểm trên đường cong elliptic):\nElligator2 (kỹ thuật ánh xạ điểm trên đường cong elliptic thành chuỗi trông ngẫu nhiên) không được triển khai rộng rãi. Các lựa chọn:\nOBFS4: pluggable transport (cơ chế vận chuyển cắm thêm) obfs4 của Tor bao gồm triển khai Elligator2 (kỹ thuật ánh xạ trên đường cong elliptic để ngụy trang khóa công khai) Triển khai tùy chỉnh: Dựa trên bài báo Elligator2 kleshni/Elligator: Triển khai tham chiếu trên GitHub Ghi chú Java I2P: Java I2P sử dụng thư viện net.i2p.crypto.eddsa với các phần bổ sung Elligator2 (kỹ thuật ánh xạ điểm trên đường cong elliptic trông ngẫu nhiên) tùy chỉnh.\nThứ tự triển khai được khuyến nghị Giai đoạn 1: Mật mã cốt lõi 1. Tạo và trao đổi khóa X25519 DH (Diffie–Hellman) 2. Mã hóa/giải mã ChaCha20-Poly1305 AEAD (mã hóa xác thực kèm dữ liệu bổ sung) 3. Băm SHA-256 và MixHash (hàm băm trộn) 4. Dẫn xuất khóa với HKDF (hàm dẫn xuất khóa) 5. Mã hóa/giải mã Elligator2 (kỹ thuật ánh xạ ngụy trang) (có thể dùng test vectors (bộ dữ liệu kiểm thử) ban đầu)\nGiai đoạn 2: Định dạng thông điệp 1. Thông điệp NS (không ràng buộc) - định dạng đơn giản nhất 2. Thông điệp NS (ràng buộc) - bổ sung khóa tĩnh 3. Thông điệp NSR 4. Thông điệp ES 5. Phân tích cú pháp khối và tạo khối\nGiai đoạn 3: Quản lý phiên 1. Tạo và lưu trữ phiên 2. Quản lý tập thẻ (người gửi và người nhận) 3. Ratchet (cơ chế bánh cóc) thẻ phiên 4. Ratchet khóa đối xứng 5. Tra cứu thẻ và quản lý cửa sổ\nGiai đoạn 4: DH Ratcheting (cơ chế bánh cóc Diffie–Hellman) 1. Xử lý khối NextKey 2. KDF (hàm dẫn xuất khóa) cho DH ratchet 3. Tạo tag set (tập thẻ) sau khi ratchet 4. Quản lý nhiều tag set\nGiai đoạn 5: Logic giao thức 1. Máy trạng thái NS/NSR/ES 2. Ngăn phát lại (DateTime, bộ lọc Bloom) 3. Logic truyền lại (nhiều NS/NSR) 4. Xử lý ACK\nGiai đoạn 6: Tích hợp 1. Xử lý I2NP Garlic Clove (tép trong thông điệp garlic của I2NP) 2. Đính kèm LeaseSet 3. Tích hợp giao thức truyền luồng 4. Tích hợp giao thức datagram\nTriển khai phía gửi Vòng đời của phiên gửi đi:\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() Hiện thực phía nhận Vòng đời phiên đến:\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() Phân loại thông điệp Phân biệt các loại thông điệp:\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type Thông lệ tốt nhất về quản lý phiên Bộ nhớ phiên:\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] Quản lý bộ nhớ:\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 Chiến lược kiểm thử Kiểm thử đơn vị:\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 Kiểm thử tích hợp:\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 Các véc-tơ kiểm thử:\nHiện thực các vector kiểm thử từ đặc tả:\nNoise IK Handshake (bắt tay Noise IK): Sử dụng các vector kiểm thử chuẩn của Noise HKDF (hàm dẫn xuất khóa dựa trên HMAC): Sử dụng các vector kiểm thử theo RFC 5869 ChaCha20-Poly1305 (mã hóa xác thực AEAD): Sử dụng các vector kiểm thử theo RFC 7539 Elligator2 (kỹ thuật ánh xạ Elligator2): Sử dụng các vector kiểm thử từ bài báo về Elligator2 hoặc OBFS4 (transport che giấu OBFS4) Kiểm thử khả năng tương tác:\nJava I2P: Kiểm thử đối chiếu với bản triển khai tham chiếu của Java I2P i2pd: Kiểm thử đối chiếu với bản triển khai i2pd bằng C++ Ghi bắt gói tin: Sử dụng Wireshark dissector (trình phân tích giao thức) (nếu có) để xác minh định dạng thông điệp Tương tác giữa các triển khai: Tạo khung kiểm thử có thể gửi/nhận giữa các bản triển khai Những cân nhắc về hiệu năng Sinh khóa:\nViệc sinh khóa Elligator2 (kỹ thuật che giấu khóa công khai) tốn kém (tỷ lệ loại bỏ 50%):\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() Tra cứu thẻ:\nSử dụng bảng băm để tra cứu thẻ với độ phức tạp O(1):\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) Tối ưu hóa bộ nhớ:\nTrì hoãn việc tạo khóa đối xứng:\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key Xử lý theo lô:\nXử lý nhiều thông điệp theo lô:\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results Các cân nhắc bảo mật Mô hình đe dọa Khả năng của đối thủ tấn công:\nNgười quan sát thụ động: Có thể quan sát toàn bộ lưu lượng mạng Kẻ tấn công chủ động: Có thể chèn, sửa đổi, loại bỏ, phát lại thông điệp Nút bị xâm nhập: Có thể xâm nhập một router hoặc điểm đích Phân tích lưu lượng: Có thể thực hiện phân tích thống kê về các mẫu lưu lượng Mục tiêu bảo mật:\nTính bảo mật: Nội dung thông điệp được ẩn khỏi người quan sát Xác thực: Danh tính người gửi được xác minh (trong các phiên ràng buộc) Tính bí mật chuyển tiếp: Các thông điệp trước đây vẫn giữ bí mật ngay cả khi khóa bị lộ Chống phát lại: Không thể phát lại các thông điệp cũ Ngụy trang lưu lượng: Quá trình bắt tay không thể phân biệt với dữ liệu ngẫu nhiên Các giả định mật mã Các giả định về độ khó:\nX25519 CDH: Bài toán Diffie–Hellman dạng tính toán là khó trên Curve25519 ChaCha20 PRF: ChaCha20 là một hàm giả ngẫu nhiên Poly1305 MAC: Poly1305 không thể bị giả mạo dưới tấn công chọn thông điệp SHA-256 CR: SHA-256 kháng va chạm HKDF Security: HKDF trích xuất và mở rộng các khóa được phân bố đồng đều Mức độ bảo mật:\nX25519: ~128-bit mức an toàn (bậc đường cong 2^252) ChaCha20: khóa 256-bit, mức an toàn 256-bit Poly1305: mức an toàn 128-bit (xác suất va chạm) SHA-256: khả năng chống va chạm 128-bit, khả năng chống tiền ảnh 256-bit Quản lý khóa Sinh khóa:\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) Lưu trữ khóa:\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] Luân chuyển khóa:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age Các biện pháp giảm thiểu tấn công Các biện pháp giảm thiểu tấn công phát lại Xác thực DateTime (ngày giờ):\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True Bộ lọc Bloom cho các thông điệp NS:\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] Session Tag (thẻ phiên) dùng một lần:\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index Các biện pháp giảm thiểu mạo danh do lộ khóa (Key Compromise Impersonation, KCI) Vấn đề: Việc xác thực thông điệp của NS dễ bị tấn công KCI (Key Compromise Impersonation - giả mạo do lộ khóa) (Mức xác thực 1)\nBiện pháp giảm thiểu:\nChuyển sang NSR (Cấp xác thực 2) càng nhanh càng tốt Đừng tin cậy NS payload cho các thao tác trọng yếu về bảo mật Chờ xác nhận NSR trước khi thực hiện các hành động không thể hoàn tác def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) Các biện pháp giảm thiểu tấn công từ chối dịch vụ Bảo vệ chống flood cho NS:\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 Giới hạn lưu trữ thẻ:\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count Quản lý tài nguyên thích ứng:\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } Khả năng chống phân tích lưu lượng Mã hóa Elligator2 (kỹ thuật biểu diễn điểm trên đường cong elliptic thành chuỗi trông ngẫu nhiên):\nĐảm bảo các thông điệp bắt tay không thể phân biệt được so với dữ liệu ngẫu nhiên:\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string Chiến lược đệm:\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) Tấn công thời gian:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) Những cạm bẫy khi hiện thực Các lỗi thường gặp:\nTái sử dụng nonce (số dùng một lần): KHÔNG BAO GIỜ tái sử dụng các cặp (key, nonce) # BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC TỐT: Nonce (giá trị dùng một lần) duy nhất cho mỗi thông điệp ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) 2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR ```python # KHÔNG NÊN: Tái sử dụng khóa tạm thời ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # KHÔNG NÊN # TỐT: Khóa mới cho mỗi thông điệp send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator KHÔNG NÊN: Bộ sinh số ngẫu nhiên không dùng cho mật mã import random key = bytes([random.randint(0, 255) for _ in range(32)]) # KHÔNG AN TOÀN TỐT: Bộ sinh số ngẫu nhiên an toàn mật mã import os key = os.urandom(32) 4. **Timing Attacks**: Use constant-time comparisons ```python # KHÔNG NÊN: So sánh thoát sớm if computed_mac == received_mac: # Rò rỉ thời gian pass # TỐT: So sánh thời gian không đổi if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data SAI: Giải mã trước khi xác minh plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # QUÁ MUỘN if not mac_ok: return error TỐT: AEAD (mã hóa xác thực kèm dữ liệu) kiểm tra tính xác thực trước khi giải mã try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError:\nreturn error 6. **Key Deletion**: Securely wipe keys from memory ```python # KHÔNG NÊN: Xóa đơn giản del private_key # Vẫn còn trong bộ nhớ # TỐT: Ghi đè trước khi xóa for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# Các trường hợp kiểm thử trọng yếu về bảo mật def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# Chỉ ECIES (lược đồ mã hóa tích hợp đường cong elliptic) (được khuyến nghị cho các triển khai mới) i2cp.leaseSetEncType=4 # Khóa kép (ECIES + ElGamal để tương thích) i2cp.leaseSetEncType=4,0 # Chỉ ElGamal (lỗi thời, không khuyến nghị) i2cp.leaseSetEncType=0 LeaseSet Type:\n# LS2 tiêu chuẩn (phổ biến nhất) i2cp.leaseSetType=3 # LS2 được mã hóa (blinded destinations - điểm đến bị làm mù) i2cp.leaseSetType=5 # Meta LS2 (nhiều đích đến) i2cp.leaseSetType=7 Additional Options:\n# Khóa tĩnh cho ECIES (tùy chọn, được tạo tự động nếu không được chỉ định) # Khóa công khai X25519 dài 32 byte, được mã hóa Base64 i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # Loại chữ ký (cho LeaseSet) i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# ECIES (lược đồ mã hóa tích hợp dựa trên đường cong elliptic) giữa các router i2p.router.useECIES=true Build Properties:\n// For I2CP clients (Java) Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[giới hạn] # Giới hạn bộ nhớ cho các phiên ECIES (lược đồ mã hóa tích hợp đường cong elliptic) ecies.memory = 128M [ecies (lược đồ mã hóa tích hợp đường cong elliptic)] # Bật ECIES (lược đồ mã hóa tích hợp trên đường cong elliptic) enabled = true # Chỉ ECIES (sơ đồ mã hóa tích hợp dùng đường cong elliptic) hoặc khóa kép compatibility = true # true = hai khóa, false = chỉ ECIES Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Chỉ ECIES (sơ đồ mã hóa tích hợp đường cong elliptic) ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# Thêm ECIES (lược đồ mã hóa tích hợp trên đường cong elliptic) trong khi vẫn giữ ElGamal (lược đồ mã hóa ElGamal) i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# Kiểm tra các loại kết nối i2prouter.exe status # hoặc http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# Loại bỏ ElGamal i2cp.leaseSetEncType=4 Step 4: Restart Application\n# Khởi động lại router I2P hoặc ứng dụng systemctl restart i2p # hoặc i2prouter.exe restart Rollback Plan:\n# Quay lại chỉ dùng ElGamal (thuật toán mật mã ElGamal) nếu có vấn đề i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# Số phiên đến tối đa i2p.router.maxInboundSessions=1000 # Số phiên gửi đi tối đa i2p.router.maxOutboundSessions=1000 # Thời gian chờ phiên (giây) i2p.router.sessionTimeout=600 Memory Limits:\n# Giới hạn dung lượng lưu trữ thẻ (KB) i2p.ecies.maxTagMemory=10240 # 10 MB # Cửa sổ nhìn trước i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# Thông điệp trước khi ratchet (cơ chế luân chuyển khóa tăng dần) i2p.ecies.ratchetThreshold=4096 # Thời gian trước khi kích hoạt ratchet (cơ chế cập nhật khóa liên tục trong mật mã) (giây) i2p.ecies.ratchetTimeout=600 # 10 phút Monitoring and Debugging Logging:\n# Bật ghi nhật ký gỡ lỗi ECIES (lược đồ mã hóa tích hợp đường cong elliptic) logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # Ví dụ print(\u0026#34;NS (bound, 1KB payload):\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;bytes\u0026#34;) # Đầu ra: 1120 byte print(\u0026#34;NSR (1KB payload):\u0026#34;, calculate_nsr_size(1024), \u0026#34;bytes\u0026#34;) # Đầu ra: 1096 byte print(\u0026#34;ES (tải trọng 1KB):\u0026#34;, calculate_es_size(1024), \u0026#34;byte\u0026#34;) # Đầu ra: 1048 byte Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"Lược đồ mã hóa tích hợp dựa trên đường cong elliptic cho I2P (X25519 + AEAD)","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"Đặc tả mã hóa ECIES-X25519-AEAD-Ratchet (cơ chế bánh cóc)","url":"/vi/docs/specs/ecies/"},{"categories":null,"content":"1. Tổng quan SSU2 là một giao thức lớp vận chuyển dựa trên UDP được dùng cho giao tiếp an toàn, bán tin cậy giữa các router trong I2P. Nó không phải là một cơ chế vận chuyển đa dụng mà được chuyên biệt cho trao đổi thông điệp I2NP.\nKhả năng cốt lõi Trao đổi khóa có xác thực thông qua mẫu Noise XK (một biến thể bắt tay của bộ giao thức Noise) Tiêu đề được mã hóa để chống kiểm tra gói tin sâu (DPI) Vượt NAT bằng các nút chuyển tiếp và kỹ thuật đục lỗ Di chuyển kết nối và xác thực địa chỉ Xác minh đường dẫn tùy chọn Tính bí mật chuyển tiếp và bảo vệ chống phát lại Hệ thống cũ và khả năng tương thích Implementation SSU2 Default SSU1 Removed i2pd2.44.02.44.0 Java I2P0.9.560.9.61 SSU1 hiện không còn được sử dụng trên khắp mạng I2P công cộng. 2. Mật mã học SSU2 (giao thức vận chuyển trong I2P) sử dụng Noise_XK_25519_ChaChaPoly_SHA256 với các phần mở rộng dành riêng cho I2P.\nFunction Algorithm Notes Diffie-HellmanX25519 (RFC 7748)32-byte keys CipherChaCha20/Poly1305 (RFC 7539)AEAD encryption HashSHA-256Used for key derivation and message integrity KDFHKDF-SHA256 (RFC 5869)For session and header keys Phần đầu (header) và phần tải (payload) được ràng buộc bằng mật mã thông qua `mixHash()`. Mọi nguyên thủy mật mã được dùng chung với NTCP2 và ECIES (lược đồ mã hóa tích hợp đường cong elliptic) để tăng hiệu quả triển khai. 3. Tổng quan về thông điệp 3.1 Các quy tắc Datagram UDP Mỗi datagram UDP mang chính xác một thông điệp SSU2. Session Confirmed messages (các thông điệp xác nhận phiên) có thể bị phân mảnh thành nhiều datagram. Kích thước tối thiểu: 40 byte Kích thước tối đa: 1472 byte (IPv4) / 1452 byte (IPv6)\n3.2 Các loại thông điệp Type Message Header Description 0Session Request32BHandshake initiation 1Session Created32BHandshake response 2Session Confirmed16BFinal handshake, may be fragmented 6Data16BEncrypted I2NP message blocks 7Peer Test32BNAT reachability testing 9Retry32BToken or rejection notice 10Token Request32BRequest for validation token 11Hole Punch32BNAT traversal signaling --- 4. Thiết lập phiên 4.1 Luồng tiêu chuẩn (Mã thông báo hợp lệ) Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 Thu nhận mã thông báo Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 Mã thông báo không hợp lệ Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. Cấu trúc tiêu đề 5.1 Tiêu đề dài (32 byte) Được sử dụng trước khi thiết lập phiên (SessionRequest, Created, Retry, PeerTest, TokenRequest, HolePunch).\nField Size Description Destination Connection ID8Random unique ID Packet Number4Random (ignored during handshake) Type1Message type Version1Always 2 NetID12 = main I2P network Flags1Reserved (0) Source Connection ID8Random ID distinct from destination Token8Token for address validation ### 5.2 Header ngắn (16 byte) Được sử dụng trong các phiên đã được thiết lập (SessionConfirmed, Data).\nField Size Description Destination Connection ID8Stable throughout session Packet Number4Incrementing per message Type1Message type (2 or 6) Flags3ACK/fragment flags --- 6. Mã hóa 6.1 AEAD (Mã hóa xác thực kèm dữ liệu liên quan) Tất cả các payload (dữ liệu tải) đều được mã hóa bằng ChaCha20/Poly1305 AEAD:\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) Nonce (giá trị dùng một lần): 12 byte (4 byte 0 + 8 byte bộ đếm) Tag (mã xác thực): 16 byte Associated Data (dữ liệu liên kết): bao gồm tiêu đề để ràng buộc tính toàn vẹn 6.2 Bảo vệ tiêu đề Các phần đầu được che bằng dòng khóa ChaCha20 được dẫn xuất từ các khóa phần đầu phiên. Điều này đảm bảo rằng mọi ID kết nối và các trường gói tin trông ngẫu nhiên, qua đó cung cấp khả năng chống DPI (kiểm tra gói tin sâu).\n6.3 Dẫn xuất khóa Phase Input Output InitialintroKey + salthandshake header key HandshakeDH(X25519)chainKey + AEAD key Data phasechainKeyTX/RX keys Key rotationoldKeynewKey --- 7. Bảo mật và Ngăn chặn phát lại Token áp dụng theo từng địa chỉ IP, hết hạn sau ~60 giây. Việc phát lại (replay) được ngăn chặn thông qua Bloom filter (bộ lọc Bloom) theo từng phiên. Các khóa tạm thời trùng lặp sẽ bị từ chối. Header và payload được ràng buộc bằng mật mã. Các router phải loại bỏ mọi gói tin không vượt qua xác thực AEAD (mã hóa xác thực kèm dữ liệu liên kết) hoặc có phiên bản hoặc NetID (mã nhận dạng mạng) không hợp lệ.\n8. Đánh số gói tin và vòng đời phiên Mỗi chiều duy trì bộ đếm 32-bit riêng. - Bắt đầu từ 0, tăng theo mỗi gói tin. - Không được phép quay vòng; thay khóa phiên hoặc kết thúc trước khi đạt tới 2³².\nMã định danh kết nối vẫn không thay đổi trong suốt toàn bộ phiên, kể cả trong quá trình di chuyển.\n9. Giai đoạn Dữ liệu Loại = 6 (Dữ liệu) Tiêu đề ngắn (16 byte) Phần tải (payload) chứa một hoặc nhiều khối được mã hóa: Danh sách ACK/NACK (ACK: xác nhận, NACK: không xác nhận) Các mảnh thông điệp I2NP Đệm (0–31 byte ngẫu nhiên) Các khối kết thúc (tùy chọn) Hỗ trợ truyền lại có chọn lọc và phân phát ngoài thứ tự. Độ tin cậy vẫn ở mức “bán tin cậy” — các gói tin bị thiếu có thể bị loại bỏ lặng lẽ sau khi vượt quá giới hạn số lần thử lại.\n10. Chuyển tiếp và xuyên NAT Message Type Purpose Peer Test7Determines inbound reachability Retry9Issues new token or rejection Token Request10Requests new address token Hole Punch11Coordinates NAT hole punching Các router chuyển tiếp hỗ trợ các peer (nút ngang hàng) nằm sau NAT hạn chế thông qua các thông điệp điều khiển này. 11. Chấm dứt phiên Một trong hai peer có thể đóng phiên bằng cách sử dụng một Termination block (khối kết thúc) trong một Data message (thông điệp dữ liệu). Tài nguyên phải được giải phóng ngay sau khi nhận được. Các gói tin kết thúc lặp lại có thể bị bỏ qua sau khi đã được xác nhận.\n12. Hướng dẫn triển khai Routers PHẢI: - Xác minh version = 2 và NetID = 2. - Loại bỏ các gói \u0026lt;40 byte hoặc AEAD không hợp lệ. - Thực thi bộ đệm chống phát lại 120 giây. - Từ chối token bị dùng lại hoặc khóa tạm thời.\nRouters SHOULD: - Ngẫu nhiên hóa phần đệm 0–31 byte. - Sử dụng cơ chế tái truyền thích ứng (RFC 6298). - Triển khai xác thực đường đi theo từng đồng cấp trước khi di chuyển.\n13. Tóm tắt bảo mật Property Achieved By Forward secrecyX25519 ephemeral keys Replay protectionTokens + Bloom filter Authenticated encryptionChaCha20/Poly1305 KCI resistanceNoise XK pattern DPI resistanceEncrypted headers NAT traversalRelay + Hole Punch MigrationStatic connection IDs --- 14. Tài liệu tham khảo Đề xuất 159 – SSU2 Khung giao thức Noise RFC 9000 – Truyền tải QUIC RFC 9001 – QUIC TLS RFC 7539 – ChaCha20/Poly1305 AEAD RFC 7748 – X25519 ECDH RFC 5869 – HKDF-SHA256 ","description":"Giao thức truyền tải UDP bán tin cậy bảo mật phiên bản 2","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"Đặc tả SSU2","url":"/vi/docs/specs/ssu2/"},{"categories":null,"content":"Địa chỉ I2P là các khóa mật mã dài. Hệ thống đặt tên cung cấp một lớp thân thiện hơn trên các khóa đó mà không cần giới thiệu một cơ quan trung tâm. Tất cả các tên đều cục bộ—mỗi router độc lập quyết định hostname nào tham chiếu đến destination nào.\nCần tìm hiểu thêm? Tài liệu thảo luận về đặt tên ghi lại các cuộc tranh luận thiết kế ban đầu, các đề xuất thay thế và nền tảng triết lý đằng sau hệ thống đặt tên phi tập trung của I2P.\n1. Các thành phần Lớp đặt tên của I2P bao gồm nhiều hệ thống con độc lập nhưng phối hợp với nhau:\nDịch vụ đặt tên – phân giải tên máy chủ thành các destination và xử lý tên máy chủ Base32 . HTTP proxy – chuyển các tra cứu .i2p đến router và đề xuất các dịch vụ jump khi không tìm thấy tên. Dịch vụ host-add – các biểu mẫu kiểu CGI thêm các mục mới vào sổ địa chỉ cục bộ. Dịch vụ jump – các trợ giúp từ xa trả về destination cho tên máy chủ được cung cấp. Sổ địa chỉ – định kỳ tải và hợp nhất các danh sách máy chủ từ xa bằng \u0026ldquo;web of trust\u0026rdquo; (mạng lưới tin cậy) cục bộ. SusiDNS – giao diện web để quản lý sổ địa chỉ, đăng ký và ghi đè cục bộ. Thiết kế mô-đun này cho phép người dùng tự xác định ranh giới tin cậy của riêng họ và tự động hóa nhiều hay ít quy trình đặt tên tùy theo sở thích.\n2. Dịch vụ Đặt tên API đặt tên của router (net.i2p.client.naming) hỗ trợ nhiều backend thông qua thuộc tính có thể cấu hình i2p.naming.impl=\u0026lt;class\u0026gt;. Mỗi triển khai có thể cung cấp các chiến lược tra cứu khác nhau, nhưng tất cả đều chia sẻ cùng một mô hình tin cậy và phân giải.\n2.1 Hosts.txt (legacy format) Mô hình cũ sử dụng ba tệp văn bản thuần túy được kiểm tra theo thứ tự:\nprivatehosts.txt userhosts.txt hosts.txt Mỗi dòng lưu trữ một ánh xạ hostname=base64-destination. Định dạng văn bản đơn giản này vẫn được hỗ trợ đầy đủ cho việc nhập/xuất, nhưng nó không còn là mặc định nữa do hiệu suất kém khi danh sách host vượt quá vài nghìn mục.\n2.2 Blockfile Naming Service (default backend) Được giới thiệu trong phiên bản 0.8.8, Dịch vụ Đặt tên Blockfile hiện là backend mặc định. Nó thay thế các tệp phẳng bằng một kho lưu trữ key/value trên đĩa dựa trên skiplist hiệu suất cao (hostsdb.blockfile) cung cấp tốc độ tra cứu nhanh hơn khoảng 10 lần.\nĐặc điểm chính: - Lưu trữ nhiều sổ địa chỉ logic (riêng tư, người dùng và hosts) trong một cơ sở dữ liệu nhị phân. - Duy trì khả năng tương thích với việc nhập/xuất hosts.txt cũ. - Hỗ trợ tra cứu ngược, metadata (ngày thêm, nguồn, bình luận) và bộ nhớ đệm hiệu quả. - Sử dụng cùng thứ tự tìm kiếm ba tầng: riêng tư → người dùng → hosts.\nCách tiếp cận này bảo toàn khả năng tương thích ngược trong khi cải thiện đáng kể tốc độ phân giải và khả năng mở rộng.\n2.1 Hosts.txt (định dạng cũ) Các nhà phát triển có thể triển khai các backend tùy chỉnh như: - Meta – tổng hợp nhiều hệ thống đặt tên. - PetName – hỗ trợ petnames được lưu trữ trong petnames.txt. - AddressDB, Exec, Eepget, và Dummy – cho phân giải bên ngoài hoặc dự phòng.\nTriển khai blockfile vẫn là backend được khuyến nghị cho mục đích sử dụng chung do hiệu suất và độ tin cậy.\n3. Base32 Hostnames Tên máy chủ Base32 (*.b32.i2p) hoạt động tương tự như địa chỉ .onion của Tor. Khi bạn truy cập một địa chỉ .b32.i2p:\nRouter giải mã payload Base32. Nó tái tạo destination trực tiếp từ khóa—không cần tra cứu address-book. Điều này đảm bảo khả năng truy cập ngay cả khi không tồn tại tên máy chủ dễ đọc cho con người. Tên Base32 mở rộng được giới thiệu trong phiên bản 0.9.40 hỗ trợ LeaseSet2 và các điểm đến được mã hóa.\n4. Address Book \u0026amp; Subscriptions Ứng dụng sổ địa chỉ truy xuất danh sách máy chủ từ xa qua HTTP và hợp nhất chúng cục bộ theo các quy tắc tin cậy do người dùng cấu hình.\n2.2 Dịch vụ đặt tên Blockfile (backend mặc định) Subscriptions là các URL .i2p tiêu chuẩn trỏ đến hosts.txt hoặc các nguồn cập nhật tăng dần. Các bản cập nhật được tải về định kỳ (mặc định mỗi giờ) và được xác thực trước khi hợp nhất. Xung đột được giải quyết theo nguyên tắc đến trước, được phục vụ trước, tuân theo thứ tự ưu tiên:\nprivatehosts.txt → userhosts.txt → hosts.txt. Default Providers Kể từ I2P 2.3.0 (Tháng 6 năm 2023), hai nhà cung cấp đăng ký mặc định được bao gồm: - http://i2p-projekt.i2p/hosts.txt - http://notbob.i2p/hosts.txt\nSự dự phòng này cải thiện độ tin cậy trong khi vẫn duy trì mô hình tin cậy cục bộ. Người dùng có thể thêm hoặc xóa các đăng ký thông qua SusiDNS.\nIncremental Updates Các bản cập nhật gia tăng được tải về thông qua newhosts.txt (thay thế khái niệm recenthosts.cgi cũ hơn). Endpoint này cung cấp các bản cập nhật delta hiệu quả dựa trên ETag—chỉ trả về các mục mới kể từ yêu cầu trước đó hoặc 304 Not Modified khi không có thay đổi.\n2.3 Các Backend Thay thế và Plug-in Dịch vụ Host-add (add*.cgi) cho phép gửi thủ công các ánh xạ tên-đến-destination. Luôn xác minh destination trước khi chấp nhận. Dịch vụ Jump phản hồi với khóa thích hợp và có thể chuyển hướng qua HTTP proxy với tham số ?i2paddresshelper=.\nCác ví dụ phổ biến: stats.i2p, identiguy.i2p, và notbob.i2p.\nNhững dịch vụ này không phải là cơ quan tin cậy—người dùng phải tự quyết định sử dụng dịch vụ nào. 5. Managing Entries Locally (SusiDNS) SusiDNS có sẵn tại: http://127.0.0.1:7657/susidns/\nBạn có thể: - Xem và chỉnh sửa sổ địa chỉ cục bộ. - Quản lý và ưu tiên các đăng ký. - Nhập/xuất danh sách hosts. - Cấu hình lịch trình tải xuống.\nMới trong I2P 2.8.1 (Tháng 3 năm 2025): - Đã thêm tính năng \u0026ldquo;sắp xếp theo mới nhất\u0026rdquo;. - Cải thiện xử lý đăng ký (sửa lỗi không nhất quán ETag).\nTất cả thay đổi vẫn ở local—sổ địa chỉ của mỗi router là duy nhất.\n3. Tên máy chủ Base32 Theo RFC 9476, I2P đã đăng ký .i2p.alt với GNUnet Assigned Numbers Authority (GANA) kể từ tháng 3 năm 2025 (I2P 2.8.1).\nMục đích: Ngăn chặn rò rỉ DNS vô tình từ phần mềm cấu hình sai.\nCác DNS resolver tuân thủ RFC 9476 sẽ không chuyển tiếp các tên miền .alt đến DNS công cộng. Phần mềm I2P xử lý .i2p.alt tương đương với .i2p, loại bỏ hậu tố .alt trong quá trình phân giải. .i2p.alt không nhằm thay thế .i2p; đây là biện pháp bảo vệ kỹ thuật, không phải thương hiệu mới. 4. Sổ Địa Chỉ \u0026amp; Đăng Ký Destination keys: 516–616 byte (Base64) Hostname: Tối đa 67 ký tự (bao gồm .i2p) Ký tự cho phép: a–z, 0–9, -, . (không có dấu chấm kép, không viết hoa) Dành riêng: *.b32.i2p ETag và Last-Modified: được sử dụng tích cực để giảm thiểu băng thông Kích thước trung bình của hosts.txt: ~400 KB cho ~800 host (con số ví dụ) Sử dụng băng thông: ~10 byte/giây nếu tải về mỗi 12 giờ 8. Security Model and Philosophy I2P cố ý hy sinh tính duy nhất toàn cầu để đổi lấy phi tập trung hóa và bảo mật—một ứng dụng trực tiếp của Tam giác Zooko.\nNguyên tắc chính: - Không có cơ quan trung ương: tất cả các tra cứu đều ở cục bộ. - Chống lại việc chiếm đoạt DNS: các truy vấn được mã hóa tới các khóa công khai đích. - Ngăn chặn tấn công Sybil: không có cơ chế bỏ phiếu hay đặt tên dựa trên đồng thuận. - Ánh xạ bất biến: một khi đã tồn tại liên kết cục bộ, nó không thể bị ghi đè từ xa.\nCác hệ thống đặt tên dựa trên blockchain (ví dụ: Namecoin, ENS) đã khám phá việc giải quyết cả ba cạnh của tam giác Zooko, nhưng I2P cố ý tránh chúng do độ trễ, độ phức tạp và sự không tương thích về mặt triết lý với mô hình tin cậy cục bộ của nó.\n9. Compatibility and Stability Không có tính năng đặt tên nào bị loại bỏ trong giai đoạn 2023–2025. Định dạng Hosts.txt, dịch vụ jump, subscription và tất cả các triển khai API đặt tên vẫn hoạt động bình thường. Dự án I2P duy trì khả năng tương thích ngược nghiêm ngặt trong khi giới thiệu các cải tiến về hiệu suất và bảo mật (cô lập NetDB, phân tách Sub-DB, v.v.). 10. Best Practices Chỉ giữ những subscription đáng tin cậy; tránh các danh sách host lớn, không rõ nguồn gốc. Sao lưu hostsdb.blockfile và privatehosts.txt trước khi nâng cấp hoặc cài đặt lại. Thường xuyên xem xét các jump service và vô hiệu hóa những dịch vụ bạn không còn tin tưởng. Lưu ý: address book của bạn định nghĩa phiên bản I2P world của riêng bạn—mọi hostname đều là cục bộ. Further Reading Thảo luận về Đặt tên Đặc tả Blockfile Định dạng File Cấu hình Naming Service Javadoc ","description":"Cách I2P ánh xạ tên máy chủ có thể đọc được sang các destination","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"Đặt tên và Sổ địa chỉ","url":"/vi/docs/overview/naming/"},{"categories":null,"content":"Các bộ lọc truy cập giúp người vận hành máy chủ I2PTunnel có thể cho phép, từ chối hoặc giới hạn tốc độ các kết nối đến dựa trên Destination nguồn (điểm đích I2P) và tần suất kết nối gần đây. Bộ lọc là một tệp văn bản thuần gồm các quy tắc. Tệp được đọc từ trên xuống dưới và quy tắc khớp đầu tiên sẽ được áp dụng.\nCác thay đổi đối với định nghĩa bộ lọc sẽ có hiệu lực khi khởi động lại tunnel. Một số bản dựng có thể đọc lại các danh sách dựa trên tệp trong thời gian chạy, nhưng hãy dự trù việc khởi động lại để đảm bảo các thay đổi được áp dụng.\nĐịnh dạng tệp Mỗi dòng một quy tắc. Các dòng trống sẽ bị bỏ qua. # bắt đầu một chú thích kéo dài đến hết dòng. Các quy tắc được đánh giá theo thứ tự; khớp đầu tiên sẽ được sử dụng. Ngưỡng Một ngưỡng xác định số lượng lần thử kết nối từ một Destination (đích I2P) duy nhất được phép trong một cửa sổ thời gian trượt.\nDạng số: N/S nghĩa là cho phép N kết nối mỗi S giây. Ví dụ: 15/5 cho phép tối đa 15 kết nối mỗi 5 giây. Lần thử N+1 trong khoảng thời gian đó sẽ bị từ chối. Từ khóa: allow nghĩa là không giới hạn. deny nghĩa là luôn từ chối. Cú pháp quy tắc Các quy tắc có dạng:\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; Trong đó:\n\u0026lt;threshold\u0026gt; là N/S, allow, hoặc deny \u0026lt;scope\u0026gt; là một trong default, explicit, file, hoặc record (xem bên dưới) \u0026lt;target\u0026gt; phụ thuộc vào phạm vi Quy tắc mặc định Áp dụng khi không có quy tắc nào khác khớp. Chỉ được phép có một quy tắc mặc định. Nếu bị bỏ qua, các Destinations (đích đến trong I2P) chưa biết sẽ được phép mà không bị hạn chế.\n15/5 default allow default deny default Quy tắc tường minh Chỉ định một Destination (điểm đích trong I2P) cụ thể bằng địa chỉ Base32 (ví dụ example1.b32.i2p) hoặc khóa đầy đủ.\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p Quy tắc dựa trên tệp Nhắm tới tất cả các Destinations (địa chỉ đích trong I2P) được liệt kê trong một tệp bên ngoài. Mỗi dòng chứa một Destination; cho phép chú thích bằng # và các dòng trống.\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt Lưu ý vận hành: Một số bản triển khai định kỳ đọc lại danh sách tệp. Nếu bạn chỉnh sửa một danh sách khi tunnel đang chạy, có thể sẽ có một khoảng trễ ngắn trước khi các thay đổi được ghi nhận. Khởi động lại để áp dụng ngay lập tức.\nTrình ghi (điều khiển tiệm tiến) Một bộ ghi giám sát các lần thử kết nối và ghi các Destinations (đích I2P) vượt ngưỡng vào một tệp. Sau đó bạn có thể tham chiếu tệp đó trong một quy tắc file để áp dụng giới hạn tốc độ hoặc chặn đối với các lần thử trong tương lai.\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt Xác minh hỗ trợ trình ghi trong bản build của bạn trước khi dựa vào nó. Dùng danh sách file để đảm bảo hành vi nhất quán.\nThứ tự đánh giá Đặt các quy tắc cụ thể trước, rồi đến các quy tắc chung. Một mẫu thường gặp:\nCho phép tường minh đối với các nút ngang hàng đáng tin cậy Từ chối tường minh đối với các đối tượng lạm dụng đã biết Danh sách cho phép/từ chối dựa trên tệp Bộ ghi để giới hạn tốc độ tăng dần Quy tắc mặc định dùng để bao quát mọi trường hợp Ví dụ đầy đủ # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt Ghi chú triển khai Bộ lọc truy cập hoạt động ở lớp tunnel, trước khi ứng dụng xử lý, nên lưu lượng lạm dụng có thể bị từ chối sớm. Đặt tệp bộ lọc vào thư mục cấu hình I2PTunnel của bạn và khởi động lại tunnel để áp dụng các thay đổi. Chia sẻ các danh sách dựa trên tệp cho nhiều tunnel nếu bạn muốn chính sách nhất quán xuyên suốt các dịch vụ. ","description":"Cú pháp cho các tệp bộ lọc kiểm soát truy cập tunnel","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"Định dạng Bộ lọc Truy cập","url":"/vi/docs/specs/filter-format/"},{"categories":null,"content":"Tổng quan Các plugin I2P là các gói lưu trữ đã được ký nhằm mở rộng chức năng của router. Chúng được phát hành dưới dạng tệp .xpi2p hoặc .su3, cài đặt vào ~/.i2p/plugins/\u0026lt;name\u0026gt;/ (hoặc %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\ trên Windows), và chạy với toàn bộ quyền của router, không có sandboxing (cơ chế cô lập).\nCác loại plugin được hỗ trợ Ứng dụng web của Bảng điều khiển Các eepsites mới có cgi-bin, ứng dụng web Chủ đề của Bảng điều khiển Bản dịch cho Bảng điều khiển Chương trình Java (chạy trong tiến trình hoặc JVM riêng) Kịch bản shell và tệp nhị phân gốc Mô hình bảo mật NGHIÊM TRỌNG: Các plugin chạy trong cùng một JVM với các quyền giống hệt như I2P router. Chúng có quyền truy cập không hạn chế vào:\nHệ thống tệp (đọc và ghi) API của router và trạng thái nội bộ Kết nối mạng Thực thi chương trình bên ngoài Các plugin nên được coi là mã được tin cậy hoàn toàn. Người dùng phải xác minh nguồn phát hành và chữ ký số của plugin trước khi cài đặt.\nĐịnh dạng tệp Định dạng SU3 (Rất khuyến nghị) Trạng thái: Hoạt động, định dạng ưu tiên kể từ I2P 0.9.15 (Tháng 9 năm 2014)\nĐịnh dạng .su3 cung cấp: - Khóa ký RSA-4096 (so với DSA-1024 trong xpi2p) - Chữ ký được lưu trong phần đầu tệp - Số ma thuật (magic number): I2Psu3 - Khả năng tương thích về sau tốt hơn\nCấu trúc:\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] Định dạng XPI2P (cũ, không còn được khuyến nghị) Trạng thái: Được hỗ trợ vì lý do tương thích ngược, không khuyến nghị cho plugin mới\nĐịnh dạng .xpi2p sử dụng các chữ ký mật mã đời cũ: - Chữ ký DSA-1024 (đã lỗi thời theo NIST-800-57) - Chữ ký DSA 40 byte được thêm vào đầu tệp ZIP - Yêu cầu trường key trong plugin.config\nCấu trúc:\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] Lộ trình chuyển đổi: Khi chuyển từ xpi2p sang su3, hãy cung cấp cả updateURL và updateURL.su3 trong giai đoạn chuyển tiếp. Các router hiện đại (0.9.15+) sẽ tự động ưu tiên SU3.\nBố cục gói nén và plugin.config Các tệp cần thiết plugin.config - Tệp cấu hình I2P tiêu chuẩn với các cặp khóa-giá trị\nThuộc tính bắt buộc Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format **Ví dụ về định dạng phiên bản:** - `1.2.3` - `1.2.3-4` - `2.0.0-beta.1` Các dấu phân cách hợp lệ: . (dấu chấm), - (dấu gạch ngang), _ (dấu gạch dưới)\nThuộc tính siêu dữ liệu tùy chọn Hiển thị thông tin date - Ngày phát hành (dấu thời gian kiểu long của Java) author - Tên nhà phát triển (khuyến nghị user@mail.i2p) description - Mô tả bằng tiếng Anh description_xx - Mô tả bản địa hóa (xx = mã ngôn ngữ) websiteURL - Trang chủ plugin (http://foo.i2p/) license - Mã định danh giấy phép (ví dụ: \u0026ldquo;Apache-2.0\u0026rdquo;, \u0026ldquo;GPL-3.0\u0026rdquo;) Cập nhật cấu hình updateURL - Địa chỉ cập nhật XPI2P (cũ) updateURL.su3 - Địa chỉ cập nhật SU3 (được khuyến nghị) min-i2p-version - Phiên bản I2P tối thiểu bắt buộc max-i2p-version - Phiên bản I2P tương thích tối đa min-java-version - Phiên bản Java tối thiểu (ví dụ: 1.7, 17) min-jetty-version - Phiên bản Jetty tối thiểu (dùng 6 cho Jetty 6+) max-jetty-version - Phiên bản Jetty tối đa (dùng 5.99999 cho Jetty 5) Hành vi cài đặt dont-start-at-install - Mặc định là false. Nếu true, yêu cầu khởi động thủ công router-restart-required - Mặc định là false. Thông báo cho người dùng rằng cần khởi động lại sau khi cập nhật update-only - Mặc định là false. Sẽ thất bại nếu plugin chưa được cài đặt install-only - Mặc định là false. Sẽ thất bại nếu plugin đã tồn tại min-installed-version - Phiên bản tối thiểu cần thiết để cập nhật max-installed-version - Phiên bản tối đa có thể được cập nhật disableStop - Mặc định là false. Ẩn nút dừng nếu true Tích hợp bảng điều khiển consoleLinkName - Văn bản cho liên kết trên thanh tóm tắt của bảng điều khiển consoleLinkName_xx - Văn bản liên kết đã bản địa hóa (xx = mã ngôn ngữ) consoleLinkURL - Đích liên kết (ví dụ: /appname/index.jsp) consoleLinkTooltip - Văn bản gợi ý khi di chuột (được hỗ trợ từ 0.7.12-6) consoleLinkTooltip_xx - Chú giải đã bản địa hóa console-icon - Đường dẫn tới biểu tượng 32x32 (được hỗ trợ từ 0.9.20) icon-code - PNG 32x32 được mã hóa Base64 dành cho plugin không có tài nguyên web (từ 0.9.25) Yêu cầu nền tảng (chỉ hiển thị) required-platform-OS - Yêu cầu hệ điều hành (không được áp dụng bắt buộc) other-requirements - Yêu cầu bổ sung (ví dụ: \u0026ldquo;Python 3.8+\u0026rdquo;) Quản lý phụ thuộc (Chưa được triển khai) depends - Các phụ thuộc của plugin, phân tách bằng dấu phẩy depends-version - Yêu cầu phiên bản đối với các phụ thuộc langs - Nội dung gói ngôn ngữ type - Loại plugin (app/theme/locale/webapp) Thay thế biến trong URL cập nhật Trạng thái tính năng: Có sẵn từ I2P 1.7.0 (0.9.53)\nCả updateURL và updateURL.su3 đều hỗ trợ các biến đặc thù theo nền tảng:\nBiến: - $OS - Hệ điều hành: windows, linux, mac - $ARCH - Kiến trúc: 386, amd64, arm64\nVí dụ:\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 Kết quả trên Windows AMD64:\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 Điều này cho phép sử dụng một tệp plugin.config duy nhất cho các bản dựng dành riêng cho từng nền tảng.\nCấu trúc thư mục Bố cục tiêu chuẩn plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration Mục đích của thư mục console/locale/ - các tệp JAR chứa các gói tài nguyên cho các bản dịch cơ sở của I2P - các bản dịch dành riêng cho plugin nên đặt trong console/webapps/*.war hoặc lib/*.jar\nconsole/themes/ - Mỗi thư mục con chứa một chủ đề bảng điều khiển hoàn chỉnh - Tự động được thêm vào đường dẫn tìm kiếm chủ đề\nconsole/webapps/ - các tệp .war dùng để tích hợp với bảng điều khiển - Được khởi động tự động trừ khi bị vô hiệu hóa trong webapps.config - Tên WAR không nhất thiết phải trùng với tên plugin\neepsite/ - eepsite hoàn chỉnh với một thể hiện Jetty riêng - Yêu cầu cấu hình jetty.xml với cơ chế thay thế biến - Xem các ví dụ plugin zzzot và pebble\nlib/ - Thư viện JAR của plugin - Chỉ định trong classpath (đường dẫn lớp) qua clients.config hoặc webapps.config\nCấu hình ứng dụng web Định dạng webapps.config Tệp cấu hình I2P tiêu chuẩn kiểm soát cách ứng dụng web hoạt động.\nCú pháp:\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar Lưu ý quan trọng: - Trước router 0.7.12-9, hãy dùng plugin.warname.startOnLoad để tương thích - Trước API 0.9.53, classpath (đường dẫn lớp) chỉ hoạt động nếu warname trùng với tên plugin - Kể từ 0.9.53+, classpath hoạt động với bất kỳ tên webapp nào\nThực tiễn tốt nhất cho ứng dụng web Triển khai ServletContextListener\nTriển khai javax.servlet.ServletContextListener để dọn dẹp tài nguyên Hoặc ghi đè destroy() trong servlet Đảm bảo tắt đúng cách trong quá trình cập nhật và khi router dừng Quản lý thư viện\nĐặt các JAR dùng chung vào lib/, không nằm trong WAR Tham chiếu thông qua classpath của webapps.config Cho phép cài đặt/cập nhật plugin tách biệt Tránh xung đột thư viện\nKhông bao giờ đóng gói kèm các JAR của Jetty, Tomcat hoặc servlet Không bao giờ đóng gói kèm các JAR từ bản cài đặt I2P tiêu chuẩn Kiểm tra phần classpath cho các thư viện tiêu chuẩn Yêu cầu biên dịch\nKhông bao gồm các tệp mã nguồn .java hoặc .jsp Biên dịch trước tất cả các JSP để tránh chậm trễ khi khởi động Không thể giả định sự sẵn có của trình biên dịch Java/JSP Khả năng tương thích Servlet API\nI2P hỗ trợ Servlet 3.0 (từ 0.9.30) Không hỗ trợ quét Annotation (chú thích) (@WebContent) Phải cung cấp tệp mô tả triển khai web.xml theo kiểu truyền thống Phiên bản Jetty\nHiện tại: Jetty 9 (I2P 0.9.30+) Sử dụng net.i2p.jetty.JettyStart để trừu tượng hóa Bảo vệ trước các thay đổi Jetty API Cấu hình máy khách Định dạng clients.config Xác định các máy khách (dịch vụ) được khởi chạy cùng plugin.\nMáy khách cơ bản:\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties Ứng dụng khách có Dừng/Gỡ cài đặt:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar Tham khảo thuộc tính Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths ### Thay thế biến Các biến sau được thay thế trong args, stopargs, uninstallargs và classpath:\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 ### Máy khách được quản lý so với máy khách không được quản lý Các client được quản lý (Khuyến nghị, từ 0.9.4): - Được khởi tạo bởi ClientAppManager (trình quản lý ứng dụng khách) - Duy trì tham chiếu và theo dõi trạng thái - Quản lý vòng đời dễ dàng hơn - Quản lý bộ nhớ tốt hơn\nCác ứng dụng khách không được quản lý: - Được khởi động bởi router, không theo dõi trạng thái - Phải xử lý nhiều lần gọi start/stop một cách ổn thỏa - Sử dụng trạng thái tĩnh hoặc tệp PID (định danh tiến trình) để điều phối - Được gọi khi router tắt (as of 0.7.12-3)\nShellService (kể từ phiên bản 0.9.53 / 1.7.0) Giải pháp tổng quát để chạy các chương trình bên ngoài với khả năng theo dõi trạng thái tự động.\nTính năng: - Quản lý vòng đời tiến trình - Giao tiếp với ClientAppManager - Quản lý PID tự động - Hỗ trợ đa nền tảng\nCách sử dụng:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh Đối với các tập lệnh dành riêng cho từng nền tảng:\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH Phương án thay thế (kiểu cũ): Viết Java wrapper (trình bao) kiểm tra loại hệ điều hành, gọi ShellCommand với tệp .bat hoặc .sh phù hợp.\nQuy trình cài đặt Luồng cài đặt dành cho người dùng Người dùng dán URL plugin vào Trang cấu hình Plugin của Router Console (/configplugins) Router tải xuống tệp plugin Xác minh chữ ký (thất bại nếu khóa chưa biết và chế độ nghiêm ngặt được bật) Kiểm tra tính toàn vẹn ZIP Giải nén và phân tích plugin.config Xác minh tương thích phiên bản (min-i2p-version, min-java-version, v.v.) Phát hiện xung đột tên ứng dụng web Dừng plugin hiện có khi cập nhật Xác thực thư mục (phải nằm dưới plugins/) Giải nén toàn bộ tệp vào thư mục plugin Cập nhật plugins.config Khởi động plugin (trừ khi dont-start-at-install=true) Bảo mật và Tin cậy Quản lý khóa: - Mô hình tin cậy \u0026lsquo;first-key-seen\u0026rsquo; (tin cậy theo khóa được thấy đầu tiên) cho người ký mới - Chỉ có các khóa jrandom và zzz được đóng gói sẵn - Kể từ 0.9.14.1, các khóa không xác định bị từ chối theo mặc định - Một thuộc tính nâng cao có thể ghi đè cho mục đích phát triển\nHạn chế cài đặt: - Các gói nén chỉ được giải nén vào thư mục plugin - Trình cài đặt từ chối các đường dẫn bên ngoài plugins/ - Các plugin có thể truy cập tệp ở nơi khác sau khi cài đặt - Không có sandboxing (cô lập môi trường chạy) hoặc cô lập đặc quyền\nCơ chế cập nhật Quy trình kiểm tra cập nhật Router đọc updateURL.su3 (ưu tiên) hoặc updateURL từ plugin.config Yêu cầu HTTP HEAD hoặc GET một phần để lấy các byte 41-56 Trích xuất chuỗi phiên bản từ tệp từ xa So sánh với phiên bản đã cài đặt bằng VersionComparator (bộ so sánh phiên bản) Nếu mới hơn, nhắc người dùng hoặc tự động tải xuống (dựa trên cài đặt) Dừng plugin Cài đặt bản cập nhật Khởi động plugin (trừ khi tùy chọn của người dùng đã thay đổi) So sánh phiên bản Các phiên bản được phân tích dưới dạng các thành phần tách nhau bằng dấu chấm/gạch ngang/gạch dưới: - 1.2.3 \u0026lt; 1.2.4 - 1.2.3 \u0026lt; 1.2.3-1 - 2.0.0 \u0026gt; 1.9.9\nĐộ dài tối đa: 16 byte (phải khớp với phần đầu SUD/SU3)\nPhương pháp hay nhất khi cập nhật Luôn tăng phiên bản khi phát hành Kiểm thử lộ trình cập nhật từ phiên bản trước đó Cân nhắc router-restart-required cho các thay đổi lớn Cung cấp cả updateURL và updateURL.su3 trong quá trình chuyển đổi Sử dụng hậu tố số bản dựng để kiểm thử (1.2.3-456) Classpath (đường dẫn lớp) và Thư viện Chuẩn Luôn có sẵn trong Classpath (danh sách đường dẫn lớp) Các tệp JAR sau từ $I2P/lib luôn có trong classpath (đường dẫn lớp) cho I2P 0.9.30+:\nJAR Contents Plugin Usage i2p.jarCore APIRequired for all plugins mstreaming.jarStreaming APIMost plugins need streaming.jarStreaming implementationMost plugins need i2ptunnel.jarI2PTunnelHTTP/server plugins router.jarRouter internalsRarely needed, avoid if possible javax.servlet.jarServlet 3.1, JSP 2.3 APIPlugins with servlets/JSPs jasper-runtime.jarJasper compiler/runtimePlugins with JSPs commons-el.jarEL 3.0 APIJSPs using expression language jetty-i2p.jarJetty utilitiesPlugins starting Jetty org.mortbay.jetty.jarJetty 9 baseCustom Jetty instances sam.jarSAM APIRarely needed addressbook.jarSubscription/blockfileUse NamingService instead routerconsole.jarConsole librariesNot public API, avoid jbigi.jarNative cryptoPlugins should not need systray.jarURL launcherRarely needed wrapper.jarService wrapperPlugins should not need ### Ghi chú đặc biệt commons-logging.jar: - Trống kể từ 0.9.30 - Trước 0.9.30: Apache Tomcat JULI - Trước 0.9.24: Commons Logging + JULI - Trước 0.9: Chỉ Commons Logging\njasper-compiler.jar: - Trống kể từ Jetty 6 (0.9)\nsystray4j.jar: - Đã được loại bỏ từ 0.9.26\nKhông có trong Classpath (đường dẫn lớp của Java) (Phải chỉ định) JAR Contents Usage jstl.jarStandard TaglibJSP tag libraries standard.jarStandard TaglibJSP tag libraries ### Đặc tả Classpath (đường dẫn lớp) Trong clients.config:\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar Trong webapps.config:\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar Quan trọng: Kể từ 0.7.13-3, các classpath (đường dẫn lớp) là riêng cho từng luồng, không mang tính toàn cục trên JVM (Máy ảo Java). Hãy chỉ định classpath đầy đủ cho từng client.\nYêu cầu về phiên bản Java Các yêu cầu hiện tại (Tháng 10 năm 2025) I2P 2.10.0 và các phiên bản trước: - Tối thiểu: Java 7 (bắt buộc kể từ 0.9.24, tháng 1 năm 2016) - Khuyến nghị: Java 8 hoặc cao hơn\nI2P 2.11.0 và các phiên bản sau (SẮP RA MẮT): - Tối thiểu: Java 17+ (được công bố trong ghi chú phát hành 2.9.0) - Đã đưa ra cảnh báo trước hai bản phát hành (2.9.0 → 2.10.0 → 2.11.0)\nChiến lược Tương thích Plugin Để có khả năng tương thích tối đa (tới I2P 2.10.x):\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 Đối với các tính năng Java 8+:\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 Đối với các tính năng của Java 11+:\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 Chuẩn bị cho 2.11.0+:\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 Thực tiễn tốt nhất về biên dịch Khi biên dịch với JDK mới cho mục tiêu cũ hơn:\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; Điều này ngăn việc sử dụng các API không có sẵn trong phiên bản Java mục tiêu.\nNén Pack200 - ĐÃ LỖI THỜI Cập nhật quan trọng: Không sử dụng Pack200 Trạng thái: ĐÃ NGỪNG HỖ TRỢ VÀ ĐÃ GỠ BỎ\nĐặc tả ban đầu đã khuyến nghị mạnh mẽ việc nén Pack200 để giảm kích thước 60-65%. Điều này không còn áp dụng nữa.\nDòng thời gian: - JEP 336: Pack200 được đánh dấu ngừng sử dụng trong Java 11 (Tháng 9 năm 2018) - JEP 367: Pack200 bị gỡ bỏ trong Java 14 (Tháng 3 năm 2020)\nĐặc tả Cập nhật I2P chính thức nêu rõ: \u0026gt; \u0026ldquo;Các tệp JAR và WAR trong gói zip không còn được nén bằng pack200 như đã mô tả ở trên cho các tệp \u0026lsquo;su2\u0026rsquo;, vì các runtime Java (môi trường chạy Java) gần đây không còn hỗ trợ pack200.\u0026rdquo;\nCần làm gì:\nLoại bỏ pack200 khỏi quy trình build ngay lập tức Sử dụng nén ZIP tiêu chuẩn Cân nhắc các lựa chọn thay thế: ProGuard/R8 để thu gọn mã UPX cho các tệp nhị phân native Các thuật toán nén hiện đại (zstd, brotli) nếu có cung cấp bộ giải nén tùy chỉnh Đối với plugin hiện có: - Các router cũ (0.7.11-5 đến Java 10) vẫn có thể giải nén pack200 (định dạng nén JAR của Java) - Các router mới (Java 11+) không thể giải nén pack200 - Phát hành lại plugin không dùng nén pack200\nKhóa ký và bảo mật Sinh khóa (định dạng SU3) Sử dụng tập lệnh makeplugin.sh từ kho lưu trữ i2p.scripts:\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ Thông tin chính: - Thuật toán: RSA_SHA512_4096 - Định dạng: chứng chỉ X.509 - Lưu trữ: định dạng Java keystore\nKý phần bổ trợ # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 Các thực tiễn tốt nhất về quản lý khóa Tạo một lần, bảo vệ mãi mãi\nRouters từ chối các tên khóa trùng lặp với các khóa khác nhau Routers từ chối các khóa trùng lặp với các tên khóa khác nhau Các bản cập nhật bị từ chối nếu khóa/tên không khớp Lưu trữ an toàn\nSao lưu keystore (kho khóa) một cách an toàn Sử dụng cụm từ mật khẩu mạnh Không bao giờ commit vào hệ thống quản lý phiên bản Xoay vòng khóa\nKhông được hỗ trợ bởi kiến trúc hiện tại Lập kế hoạch cho việc sử dụng khóa dài hạn Cân nhắc các lược đồ đa chữ ký cho phát triển theo nhóm Ký số DSA kiểu cũ (XPI2P) Trạng thái: Hoạt động nhưng đã lỗi thời\nChữ ký DSA-1024 được dùng trong định dạng xpi2p: - chữ ký dài 40 byte - khóa công khai dài 172 ký tự base64 - NIST-800-57 khuyến nghị tối thiểu (L=2048, N=224) - I2P sử dụng mức yếu hơn (L=1024, N=160)\nKhuyến nghị: Thay vào đó, hãy sử dụng SU3 (định dạng gói cập nhật có chữ ký của I2P) với RSA-4096 (khóa RSA 4096-bit).\nHướng dẫn phát triển Plugin (phần bổ trợ) Các thực hành tốt nhất thiết yếu Tài liệu\nCung cấp README rõ ràng kèm hướng dẫn cài đặt Tài liệu hóa các tùy chọn cấu hình và giá trị mặc định Bao gồm nhật ký thay đổi cho mỗi bản phát hành Chỉ định các phiên bản I2P/Java yêu cầu Tối ưu hóa dung lượng\nChỉ bao gồm các tệp cần thiết Không bao giờ đóng gói kèm các JAR của router Tách biệt gói cài đặt và gói cập nhật (thư viện trong lib/) Sử dụng nén Pack200 LỖI THỜI - Sử dụng ZIP tiêu chuẩn Cấu hình\nKhông bao giờ chỉnh sửa plugin.config trong lúc chạy Sử dụng tệp cấu hình riêng cho các thiết lập khi chạy Tài liệu hóa các cấu hình bắt buộc của router (cổng SAM, tunnels, v.v.) Tôn trọng cấu hình hiện có của người dùng Sử dụng tài nguyên\nTránh mức tiêu thụ băng thông mặc định quá mức Áp dụng giới hạn sử dụng CPU hợp lý Giải phóng tài nguyên khi tắt ứng dụng Sử dụng luồng daemon khi thích hợp Kiểm thử\nKiểm thử cài đặt/nâng cấp/gỡ cài đặt trên tất cả các nền tảng Kiểm thử cập nhật từ phiên bản trước Xác minh ứng dụng web dừng/khởi động lại trong quá trình cập nhật Kiểm thử với phiên bản I2P được hỗ trợ tối thiểu Hệ thống tệp\nKhông bao giờ ghi vào $I2P (có thể chỉ đọc) Ghi dữ liệu thời gian chạy vào $PLUGIN hoặc $CONFIG Sử dụng I2PAppContext để phát hiện vị trí thư mục Không giả định vị trí của $CWD Tương thích\nKhông trùng lặp các lớp I2P chuẩn Mở rộng các lớp khi cần, đừng thay thế Kiểm tra min-i2p-version, min-jetty-version trong plugin.config Kiểm thử với các phiên bản I2P cũ hơn nếu có hỗ trợ chúng Xử lý tắt\nThiết lập stopargs phù hợp trong clients.config Đăng ký shutdown hooks (móc gọi khi tắt): I2PAppContext.addShutdownTask() Xử lý nhiều lần gọi khởi động/dừng một cách an toàn Đặt tất cả các luồng sang chế độ daemon (tiến trình nền) Bảo mật\nXác thực mọi đầu vào từ bên ngoài Không bao giờ gọi System.exit() Tôn trọng quyền riêng tư của người dùng Tuân theo các thực hành lập trình an toàn Giấy phép\nNêu rõ ràng giấy phép của plugin Tuân thủ các giấy phép của những thư viện được đóng gói kèm Bao gồm phần ghi công bắt buộc Cung cấp quyền truy cập mã nguồn nếu được yêu cầu Các cân nhắc nâng cao Xử lý múi giờ: - Router đặt múi giờ JVM thành UTC - Múi giờ thực tế của người dùng: thuộc tính i2p.systemTimeZone trong I2PAppContext\nKhám phá thư mục:\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args Đánh số phiên bản: - Sử dụng phiên bản theo ngữ nghĩa (major.minor.patch) - Thêm số build phục vụ thử nghiệm (1.2.3-456) - Đảm bảo số phiên bản tăng đơn điệu qua các lần cập nhật\nTruy cập lớp router: - Nói chung nên tránh phụ thuộc vào router.jar - Thay vào đó, hãy dùng các API công khai trong i2p.jar - Trong tương lai, I2P có thể hạn chế quyền truy cập lớp router\nNgăn ngừa sự cố JVM (trước đây): - Đã sửa trong 0.7.13-3 - Sử dụng class loader (bộ nạp lớp) đúng cách - Tránh cập nhật các tệp JAR trong phần bổ trợ đang chạy - Thiết kế để khởi động lại khi cập nhật nếu cần thiết\nCác phần bổ trợ cho Eepsite Tổng quan Các plugin có thể cung cấp các eepsites hoàn chỉnh với các thể hiện Jetty (máy chủ web) và I2PTunnel riêng của mình.\nKiến trúc Không được cố gắng: - Cài đặt vào eepsite hiện có - Hợp nhất với eepsite mặc định của router - Giả định chỉ có một eepsite khả dụng\nThay vào đó: - Khởi chạy một thể hiện I2PTunnel mới (thông qua CLI (giao diện dòng lệnh)) - Khởi chạy một thể hiện Jetty mới - Cấu hình cả hai trong clients.config\nCấu trúc ví dụ plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] Thay thế biến trong jetty.xml Sử dụng biến $PLUGIN cho các đường dẫn:\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; Router thực hiện việc thay thế trong quá trình khởi động plugin.\nVí dụ Các triển khai tham chiếu: - zzzot plugin - Trình theo dõi torrent - pebble plugin - Nền tảng blog\nCả hai đều có tại trang plugin của zzz (I2P-internal).\nTích hợp Bảng điều khiển Các liên kết trên Thanh tóm tắt Thêm liên kết có thể nhấp vào thanh tóm tắt của bảng điều khiển router:\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface Các phiên bản đã được bản địa hóa:\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle Biểu tượng bảng điều khiển Tệp ảnh (kể từ 0.9.20):\nconsole-icon=/myicon.png Đường dẫn tương đối so với consoleLinkURL nếu được chỉ định (kể từ 0.9.53), nếu không thì tương đối so với tên ứng dụng web.\nBiểu tượng nhúng (từ 0.9.25):\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... Tạo bằng:\nbase64 -w 0 icon-32x32.png Hoặc Java:\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png Yêu cầu: - 32x32 điểm ảnh - Định dạng PNG - Mã hóa Base64 (không ngắt dòng)\nQuốc tế hóa Gói dịch thuật Đối với bản dịch cơ sở của I2P: - Đặt các tệp JAR vào console/locale/ - Bao gồm các gói tài nguyên cho các ứng dụng I2P hiện có - Quy ước đặt tên: messages_xx.properties (xx = mã ngôn ngữ)\nĐối với bản dịch dành riêng cho plugin: - Bao gồm trong console/webapps/*.war - Hoặc bao gồm trong lib/*.jar - Sử dụng cách tiếp cận ResourceBundle chuẩn của Java\nChuỗi bản địa hóa trong plugin.config description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble Các trường được hỗ trợ: - description_xx - consoleLinkName_xx - consoleLinkTooltip_xx\nDịch chủ đề bảng điều khiển Các chủ đề trong console/themes/ được tự động thêm vào đường dẫn tìm kiếm chủ đề.\nCác plugin dành riêng cho nền tảng Cách tiếp cận các gói tách biệt Sử dụng các tên plugin khác nhau cho từng nền tảng:\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac Cách tiếp cận thay thế biến Một plugin.config duy nhất với các biến theo nền tảng:\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 Trong clients.config:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH Phát hiện hệ điều hành trong thời gian chạy Cách tiếp cận trong Java cho việc thực thi có điều kiện:\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } Khắc phục sự cố Các vấn đề thường gặp Plugin không khởi động: 1. Kiểm tra khả năng tương thích phiên bản I2P (min-i2p-version) 2. Xác minh phiên bản Java (min-java-version) 3. Kiểm tra nhật ký router để tìm lỗi 4. Xác minh tất cả các JAR bắt buộc trong classpath (đường dẫn lớp)\nWebapp không thể truy cập: 1. Xác nhận webapps.config không vô hiệu hóa webapp 2. Kiểm tra khả năng tương thích phiên bản Jetty (min-jetty-version) 3. Đảm bảo có web.xml (không hỗ trợ quét annotation (chú thích)) 4. Kiểm tra xung đột tên webapp\nCập nhật thất bại: 1. Xác minh chuỗi phiên bản đã tăng 2. Kiểm tra chữ ký khớp với khóa ký 3. Đảm bảo tên plugin khớp với phiên bản đã cài đặt 4. Xem lại cài đặt update-only/install-only\nChương trình bên ngoài không dừng: 1. Dùng ShellService để quản lý vòng đời tự động 2. Triển khai xử lý stopargs đúng cách 3. Kiểm tra việc dọn dẹp tệp PID 4. Xác minh việc kết thúc tiến trình\nGhi nhật ký gỡ lỗi Kích hoạt ghi nhật ký gỡ lỗi trong router:\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG Kiểm tra nhật ký:\n~/.i2p/logs/log-router-0.txt Thông tin tham khảo Đặc tả chính thức Đặc tả Plugin Định dạng cấu hình Đặc tả cập nhật Mật mã học Lịch sử phiên bản I2P Bản phát hành hiện tại: - I2P 2.10.0 (8 tháng 9 năm 2025)\nCác bản phát hành lớn kể từ 0.9.53: - 2.10.0 (Thg 9 2025) - thông báo Java 17+ - 2.9.0 (Thg 6 2025) - cảnh báo Java 17+ - 2.8.0 (Thg 10 2024) - thử nghiệm mật mã hậu lượng tử - 2.6.0 (Thg 5 2024) - chặn I2P-over-Tor - 2.4.0 (Thg 12 2023) - cải thiện bảo mật NetDB - 2.2.0 (Thg 3 2023) - điều khiển tắc nghẽn - 2.1.0 (Thg 1 2023) - cải thiện mạng - 2.0.0 (Thg 11 2022) - giao thức truyền tải SSU2 - 1.7.0/0.9.53 (Thg 2 2022) - ShellService, thay thế biến - 0.9.15 (Thg 9 2014) - giới thiệu định dạng SU3\nĐánh số phiên bản: - Dòng 0.9.x: Đến hết phiên bản 0.9.53 - Dòng 2.x: Bắt đầu từ 2.0.0 (giới thiệu SSU2)\nTài nguyên cho nhà phát triển Mã nguồn: - Kho lưu trữ chính: https://i2pgit.org/I2P_Developers/i2p.i2p - GitHub mirror (bản sao): https://github.com/i2p/i2p.i2p Ví dụ plugin: - zzzot (trình theo dõi BitTorrent) - pebble (nền tảng blog) - i2p-bote (email không máy chủ) - orchid (trình khách Tor) - seedless (trao đổi ngang hàng)\nCông cụ build: - makeplugin.sh - Sinh khóa và ký - Có trong kho i2p.scripts - Tự động hóa việc tạo và xác minh su3\nHỗ trợ cộng đồng Diễn đàn: - I2P Forum - zzz.i2p (nội bộ I2P)\nIRC/Trò chuyện: - #i2p-dev trên OFTC - I2P IRC trong mạng\nPhụ lục A: Ví dụ plugin.config hoàn chỉnh # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space Phụ lục B: Ví dụ clients.config hoàn chỉnh # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config Phụ lục C: Ví dụ webapps.config đầy đủ # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true Phụ lục D: Danh sách kiểm tra chuyển đổi (0.9.53 đến 2.10.0) Các thay đổi bắt buộc Loại bỏ nén Pack200 khỏi quy trình xây dựng\nLoại bỏ các tác vụ pack200 khỏi các tập lệnh Ant/Maven/Gradle Phát hành lại các plugin hiện có mà không dùng pack200 Rà soát các yêu cầu về phiên bản Java\nCân nhắc yêu cầu Java 11+ cho các tính năng mới Lên kế hoạch cho yêu cầu Java 17+ trong I2P 2.11.0 Cập nhật min-java-version trong plugin.config Cập nhật tài liệu\nLoại bỏ các tham chiếu tới Pack200 Cập nhật yêu cầu phiên bản Java Cập nhật các tham chiếu phiên bản I2P (0.9.x → 2.x) Các thay đổi được khuyến nghị Tăng cường chữ ký số\nChuyển đổi từ XPI2P sang SU3 nếu chưa thực hiện Sử dụng khóa RSA-4096 cho các plugin mới Tận dụng các tính năng mới (nếu dùng 0.9.53+)\nSử dụng biến $OS / $ARCH cho các cập nhật dành riêng cho nền tảng Sử dụng ShellService (dịch vụ Shell) cho các chương trình bên ngoài Sử dụng classpath của webapp đã được cải tiến (hoạt động với bất kỳ warname (tên WAR) nào) Kiểm tra khả năng tương thích\nKiểm tra trên I2P 2.10.0 Xác minh với Java 8, 11, 17 Kiểm tra trên Windows, Linux, macOS Các cải tiến tùy chọn Triển khai đúng cách ServletContextListener (trình lắng nghe ngữ cảnh Servlet) Thêm mô tả được bản địa hóa Cung cấp biểu tượng cho bảng điều khiển Cải thiện xử lý khi tắt Thêm ghi nhật ký toàn diện Viết các bài kiểm thử tự động ","description":"Quy tắc đóng gói .xpi2p / .su3 cho các plugin I2P","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"Định dạng gói plugin","url":"/vi/docs/specs/plugin/"},{"categories":null,"content":"Tổng quan LƯU Ý: ĐÃ LỖI THỜI - Chúng tôi hiện hỗ trợ ba định dạng, theo thứ tự ưu tiên:\nMaxmind geoip2 (GeoLite2-Country.mmdb) được đóng gói kèm theo tất cả các bản cài đặt, ngoại trừ các gói Debian và Android Maxmind geoip1 (GeoIP.dat) nằm trong gói Debian geoip-database Định dạng IPv4 của Tor (geoip.txt) và định dạng IPv6 tùy chỉnh (geoipv6.dat.gz) được mô tả bên dưới, vẫn được hỗ trợ nhưng không được sử dụng. Trang này quy định định dạng của các tệp GeoIP khác nhau, được router dùng để tra cứu quốc gia cho một địa chỉ IP.\nĐịnh dạng tên quốc gia (countries.txt) Định dạng này có thể được tạo dễ dàng từ các tệp dữ liệu có sẵn từ nhiều nguồn công khai. Ví dụ:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Đặc tả định dạng:\nMã hóa ký tự là UTF-8 \u0026lsquo;#\u0026rsquo; ở cột 1 chỉ định một dòng chú thích Các dòng mục có dạng CountryCode,CountryName CountryCode là mã ISO gồm hai chữ cái, viết hoa CountryName được viết bằng tiếng Anh Định dạng IPv4 (geoip.txt) Định dạng này được mượn từ Tor và có thể được tạo ra dễ dàng từ các tệp dữ liệu có sẵn từ nhiều nguồn công khai. Ví dụ:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Đặc tả định dạng:\nMã hóa là ASCII \u0026lsquo;#\u0026rsquo; ở cột 1 chỉ định dòng chú thích Các dòng mục có dạng FromIP,ToIP,CountryCode FromIP và ToIP là dạng biểu diễn số nguyên không dấu của địa chỉ IP 4 byte CountryCode là mã gồm hai chữ cái theo ISO, viết hoa Các dòng mục phải được sắp xếp theo giá trị số của FromIP Định dạng IPv6 (geoipv6.dat.gz) Đây là một định dạng nhị phân nén được thiết kế cho I2P. Tệp được nén gzip. Định dạng sau khi giải nén:\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) Lưu ý:\nDữ liệu phải được sắp xếp (số long có dấu theo biểu diễn bù hai), không được chồng lấn. Vì vậy, thứ tự là 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF. Lớp GeoIPv6.java chứa một chương trình để tạo ra định dạng này từ các nguồn công khai như dữ liệu Maxmind GeoLite. Tra cứu GeoIP IPv6 được hỗ trợ kể từ bản phát hành 0.9.8. ","description":"Đặc tả định dạng tệp GeoIP (cơ sở dữ liệu địa lý IP) kiểu cũ cho tra cứu IP theo quốc gia","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"Định dạng tập tin GeoIP","url":"/vi/docs/legacy/%C4%91%E1%BB%8Bnh-d%E1%BA%A1ng-t%E1%BA%ADp-tin-geoip/"},{"categories":null,"content":" 1. Tổng quan Garlic routing vẫn là một trong những đổi mới cốt lõi của I2P, kết hợp mã hóa nhiều lớp, đóng gói thông điệp và các tunnel một chiều. Mặc dù về mặt khái niệm tương tự như onion routing, nó mở rộng mô hình để đóng gói nhiều thông điệp được mã hóa (\u0026ldquo;cloves\u0026rdquo;) trong một phong bì duy nhất (\u0026ldquo;garlic\u0026rdquo;), cải thiện hiệu suất và tính ẩn danh.\nThuật ngữ garlic routing được đặt ra bởi Michael J. Freedman trong Luận văn Thạc sĩ Free Haven của Roger Dingledine (tháng 6 năm 2000, §8.1.1). Các nhà phát triển I2P đã áp dụng thuật ngữ này vào đầu những năm 2000 để phản ánh các cải tiến về đóng gói và mô hình truyền tải một chiều, phân biệt nó với thiết kế chuyển mạch kênh của Tor.\nTóm tắt: Garlic routing = mã hóa nhiều lớp + gộp thông điệp + chuyển phát ẩn danh qua tunnel một chiều.\n2. Thuật ngữ \u0026ldquo;Garlic\u0026rdquo; Trong lịch sử, thuật ngữ garlic đã được sử dụng trong ba ngữ cảnh khác nhau trong I2P:\nMã hóa phân lớp – bảo vệ kiểu onion ở cấp độ tunnel Đóng gói nhiều thông điệp – nhiều \u0026ldquo;cloves\u0026rdquo; bên trong một \u0026ldquo;garlic message\u0026rdquo; Mã hóa đầu cuối đến đầu cuối – trước đây là ElGamal/AES+SessionTags, hiện tại là ECIES‑X25519‑AEAD‑Ratchet Mặc dù kiến trúc vẫn giữ nguyên, nhưng lược đồ mã hóa đã được hiện đại hóa hoàn toàn.\n3. Mã hóa phân lớp Garlic routing có chung nguyên lý nền tảng với onion routing: mỗi router chỉ giải mã một lớp mã hóa, chỉ biết được hop tiếp theo mà không biết toàn bộ đường đi.\nTuy nhiên, I2P triển khai tunnel một chiều, không phải mạch hai chiều:\nOutbound tunnel: gửi tin nhắn đi từ người tạo Inbound tunnel: mang tin nhắn trở về cho người tạo Một vòng đi về hoàn chỉnh (Alice ↔ Bob) sử dụng bốn tunnel: outbound của Alice → inbound của Bob, sau đó outbound của Bob → inbound của Alice. Thiết kế này giảm một nửa mức độ phơi bày dữ liệu tương quan so với các mạch hai chiều.\nĐể biết chi tiết về triển khai tunnel, xem Đặc tả Tunnel và đặc tả Tạo Tunnel (ECIES) .\n4. Đóng gói nhiều thông điệp (các \u0026ldquo;Cloves\u0026rdquo;) Garlic routing ban đầu của Freedman hình dung việc gộp nhiều \u0026ldquo;bulbs\u0026rdquo; (củ) được mã hóa trong một thông điệp. I2P triển khai điều này dưới dạng cloves (tép) bên trong một garlic message — mỗi clove có hướng dẫn phân phối và đích đến được mã hóa riêng (router, destination, hoặc tunnel).\nGarlic bundling cho phép I2P:\nKết hợp xác nhận và metadata với các thông điệp dữ liệu Giảm các mẫu lưu lượng có thể quan sát được Hỗ trợ cấu trúc thông điệp phức tạp mà không cần kết nối bổ sung Hình 1: Một Garlic Message chứa nhiều clove (gói tin con), mỗi gói có hướng dẫn phân phối riêng.\nCác tép tỏi điển hình bao gồm:\nThông báo Trạng thái Gửi — xác nhận thành công hoặc thất bại khi gửi.\nChúng được bọc trong lớp garlic riêng để bảo vệ tính bảo mật. Thông báo Database Store — các LeaseSets được tự động gộp chung để các peer có thể trả lời mà không cần truy vấn lại netDb. Cloves được gộp lại khi:\nMột LeaseSet mới phải được công bố Các session tag mới được gửi đến Không có gói tin nào được gộp gần đây (~1 phút theo mặc định) Garlic messages đạt được việc truyền tải hiệu quả đầu-cuối-đầu của nhiều thành phần được mã hóa trong một gói tin duy nhất.\n5. Sự phát triển của mã hóa 5.1 Historical Context Tài liệu ban đầu (≤ v0.9.12) mô tả mã hóa ElGamal/AES+SessionTags: - Khóa phiên AES được bao bọc bằng ElGamal 2048‑bit - AES‑256/CBC để mã hóa payload - Thẻ phiên 32‑byte được sử dụng một lần cho mỗi tin nhắn\nHệ thống mật mã đó đã không còn được khuyến nghị sử dụng.\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) Từ năm 2019 đến 2023, I2P đã chuyển đổi hoàn toàn sang ECIES‑X25519‑AEAD‑Ratchet. Ngăn xếp hiện đại chuẩn hóa các thành phần sau:\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains Lợi ích của việc chuyển đổi sang ECIES: Bảo mật tiến (forward secrecy) thông qua các khóa ratcheting cho từng tin nhắn Kích thước payload giảm so với ElGamal Khả năng phục hồi trước các tiến bộ phân tích mật mã Tương thích với các hybrid hậu lượng tử trong tương lai (xem Đề xuất 169) Chi tiết bổ sung: xem Đặc tả ECIES và đặc tả EncryptedLeaseSet .\n6. LeaseSets and Garlic Bundling Các garlic envelope thường bao gồm LeaseSet để công bố hoặc cập nhật khả năng tiếp cận đích.\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively Tất cả các LeaseSets được phân phối thông qua *floodfill DHT* được duy trì bởi các routers chuyên biệt. Các bản công bố được xác minh, đánh dấu thời gian và giới hạn tốc độ để giảm thiểu việc liên kết siêu dữ liệu. Xem tài liệu Network Database để biết chi tiết.\n7. Modern “Garlic” Applications within I2P Mã hóa dựa trên garlic và đóng gói tin nhắn được sử dụng trong toàn bộ ngăn xếp giao thức I2P:\nTạo và sử dụng tunnel — mã hóa phân lớp trên mỗi hop Gửi tin nhắn đầu cuối đến đầu cuối — các tin nhắn garlic được gộp lại với các clove xác nhận nhận sao và LeaseSet Xuất bản Network Database — các LeaseSet được bao bọc trong các gói garlic để bảo vệ quyền riêng tư Giao thức vận chuyển SSU2 và NTCP2 — mã hóa tầng nền sử dụng framework Noise và các primitive X25519/ChaCha20 Garlic routing do đó vừa là một phương pháp phân lớp mã hóa vừa là một mô hình truyền tin mạng.\n6. LeaseSets và Garlic Bundling Trung tâm tài liệu của I2P có sẵn tại đây , được duy trì liên tục. Các thông số kỹ thuật liên quan bao gồm:\nĐặc tả ECIES — ECIES‑X25519‑AEAD‑Ratchet Tạo Tunnel (ECIES) — giao thức xây dựng tunnel hiện đại Đặc tả I2NP — định dạng thông điệp I2NP Đặc tả SSU2 — giao thức vận chuyển SSU2 UDP Cấu trúc chung — hành vi netDb và floodfill Xác thực học thuật: Hoang và cộng sự (IMC 2018, USENIX FOCI 2019) và Muntaka và cộng sự (2025) xác nhận tính ổn định kiến trúc và khả năng phục hồi hoạt động của thiết kế I2P.\n7. Các ứng dụng \u0026ldquo;Garlic\u0026rdquo; hiện đại trong I2P Các đề xuất đang tiến hành:\nĐề xuất 169: Hybrid hậu lượng tử (ML-KEM 512/768/1024 + X25519) Đề xuất 168: Tối ưu hóa băng thông transport Cập nhật datagram và streaming: Quản lý tắc nghẽn nâng cao Các cải tiến trong tương lai có thể bao gồm các chiến lược trì hoãn thông điệp bổ sung hoặc dự phòng đa tunnel ở cấp độ garlic-message, xây dựng dựa trên các tùy chọn phân phối chưa sử dụng ban đầu được Freedman mô tả.\n8. Tài liệu và Tham khảo Hiện tại Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. ","description":"Hiểu về thuật ngữ, kiến trúc và triển khai hiện đại của garlic routing trong I2P","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"Định tuyến Garlic","url":"/vi/docs/overview/garlic-routing/"},{"categories":null,"content":"Tổng quan I2P xây dựng các tunnel tạm thời, một chiều — chuỗi các router được sắp xếp theo thứ tự để chuyển tiếp lưu lượng được mã hóa. Các tunnel được phân loại thành inbound (tin nhắn chảy về phía người tạo) hoặc outbound (tin nhắn chảy ra khỏi người tạo).\nMột quá trình trao đổi điển hình định tuyến tin nhắn của Alice ra ngoài thông qua một trong các outbound tunnel của cô ấy, hướng dẫn điểm cuối outbound chuyển tiếp tin nhắn đó đến gateway của một trong các inbound tunnel của Bob, và sau đó Bob nhận được tin nhắn tại điểm cuối inbound của anh ấy.\nA: Outbound Gateway (Alice) B: Outbound Participant C: Outbound Endpoint D: Inbound Gateway E: Inbound Participant F: Inbound Endpoint (Bob) Các tunnel có thời gian tồn tại cố định là 10 phút và truyền tải các thông điệp có kích thước cố định là 1024 byte (1028 byte bao gồm cả header của tunnel) để ngăn chặn phân tích lưu lượng dựa trên kích thước thông điệp hoặc các mẫu thời gian.\nTừ vựng về Tunnel Tunnel gateway: Router đầu tiên trong một tunnel. Đối với inbound tunnel, danh tính của router này xuất hiện trong LeaseSet được công bố. Đối với outbound tunnel, gateway là router khởi tạo (A và D ở trên). Tunnel endpoint: Router cuối cùng trong một tunnel (C và F ở trên). Tunnel participant: Router trung gian trong một tunnel (B và E ở trên). Các participant không thể xác định vị trí hoặc hướng của tunnel. n-hop tunnel: Số lượng hop (bước nhảy) giữa các router. 0-hop: Gateway và endpoint là cùng một router – ẩn danh tối thiểu. 1-hop: Gateway kết nối trực tiếp với endpoint – độ trễ thấp, ẩn danh thấp. 2-hop: Mặc định cho exploratory tunnel; cân bằng giữa bảo mật và hiệu suất. 3-hop: Được khuyến nghị cho các ứng dụng yêu cầu ẩn danh cao. Tunnel ID: Số nguyên 4 byte duy nhất cho mỗi router và mỗi hop, được chọn ngẫu nhiên bởi người tạo. Mỗi hop nhận và chuyển tiếp trên các ID khác nhau. Thông tin Xây dựng Tunnel Các router đảm nhận vai trò gateway, participant và endpoint nhận các bản ghi khác nhau trong Tunnel Build Message. I2P hiện đại hỗ trợ hai phương pháp:\nElGamal (cũ, bản ghi 528-byte) ECIES-X25519 (hiện tại, bản ghi 218-byte thông qua Short Tunnel Build Message – STBM) Information Distributed to Participants Gateway nhận được: - Khóa lớp tunnel (khóa AES-256 hoặc ChaCha20 tùy thuộc vào loại tunnel) - Khóa IV tunnel (để mã hóa các vector khởi tạo) - Khóa reply và reply IV (để mã hóa build reply) - Tunnel ID (chỉ dành cho inbound gateways) - Hash định danh hop tiếp theo và tunnel ID (nếu không phải terminal)\nCác thành viên trung gian nhận được: - Khóa tầng tunnel và khóa IV cho hop của họ - ID tunnel và thông tin hop tiếp theo - Khóa phản hồi và IV để mã hóa phản hồi xây dựng\nEndpoint nhận: - Các khóa tunnel layer và IV - Router trả lời và tunnel ID (chỉ outbound endpoint) - Khóa trả lời và IV (chỉ outbound endpoint)\nĐể biết chi tiết đầy đủ, xem Tunnel Creation Specification và ECIES Tunnel Creation Specification .\nTunnel Pooling Router nhóm các tunnel thành tunnel pool để đảm bảo dự phòng và phân phối tải. Mỗi pool duy trì nhiều tunnel song song, cho phép chuyển đổi dự phòng khi một tunnel bị lỗi. Các pool được sử dụng nội bộ là exploratory tunnel, trong khi các pool dành riêng cho ứng dụng là client tunnel.\nMỗi destination duy trì các pool đường hầm inbound và outbound riêng biệt được cấu hình bởi các tùy chọn I2CP (số lượng tunnel, số lượng backup, độ dài và các tham số QoS). Các router giám sát tình trạng tunnel, chạy kiểm tra định kỳ và tự động xây dựng lại các tunnel bị lỗi để duy trì kích thước pool.\nGộp Tunnel Tunnel 0-hop: Chỉ cung cấp khả năng chối bỏ hợp lý. Lưu lượng luôn xuất phát và kết thúc tại cùng một router — không khuyến khích cho bất kỳ mục đích sử dụng ẩn danh nào.\nTunnel 1 hop: Cung cấp tính ẩn danh cơ bản chống lại những người quan sát thụ động nhưng dễ bị tấn công nếu kẻ thù kiểm soát hop duy nhất đó.\nTunnel 2-hop : Bao gồm hai router từ xa và tăng đáng kể chi phí tấn công. Mặc định cho các exploratory pool.\nTunnel 3 hop: Được khuyến nghị cho các ứng dụng yêu cầu bảo vệ tính ẩn danh mạnh mẽ. Các hop bổ sung sẽ tăng độ trễ mà không mang lại lợi ích bảo mật đáng kể.\nMặc định: Router sử dụng 2-hop exploratory tunnel và 2 hoặc 3 hop client tunnel theo ứng dụng cụ thể, cân bằng giữa hiệu suất và tính ẩn danh.\nĐộ dài Tunnel Router định kỳ kiểm tra các tunnel bằng cách gửi một DeliveryStatusMessage qua một outbound tunnel đến một inbound tunnel. Nếu kiểm tra thất bại, cả hai tunnel sẽ nhận trọng số profile tiêu cực. Các lần thất bại liên tiếp sẽ đánh dấu tunnel không khả dụng; sau đó router sẽ xây dựng lại một tunnel thay thế và công bố một LeaseSet mới. Kết quả được đưa vào các chỉ số năng lực ngang hàng được sử dụng bởi hệ thống lựa chọn ngang hàng .\nKiểm Tra Tunnel Các router xây dựng tunnel bằng phương pháp telescoping không tương tác: một Tunnel Build Message duy nhất lan truyền theo từng hop. Mỗi hop giải mã bản ghi của nó, thêm phản hồi và chuyển tiếp thông điệp đi tiếp. Hop cuối cùng trả về phản hồi xây dựng tổng hợp qua một đường dẫn khác, ngăn chặn việc tương quan. Các triển khai hiện đại sử dụng Short Tunnel Build Messages (STBM) cho ECIES và Variable Tunnel Build Messages (VTBM) cho các đường dẫn cũ. Mỗi bản ghi được mã hóa theo từng hop sử dụng ElGamal hoặc ECIES-X25519.\nTạo Tunnel Lưu lượng tunnel sử dụng mã hóa đa lớp. Mỗi hop thêm hoặc gỡ bỏ một lớp mã hóa khi các thông điệp đi qua tunnel.\nTunnel ElGamal: AES-256/CBC cho payload với PKCS#5 padding. Tunnel ECIES: ChaCha20 hoặc ChaCha20-Poly1305 cho mã hóa có xác thực. Mỗi hop có hai khóa: một layer key và một IV key. Các router giải mã IV, sử dụng nó để xử lý payload, sau đó mã hóa lại IV trước khi chuyển tiếp. Cơ chế IV kép này ngăn chặn việc gắn thẻ thông điệp.\nCác cổng ra mã hóa trước tất cả các lớp để các điểm cuối nhận được văn bản rõ sau khi tất cả các bên tham gia đã thêm mã hóa. Các tunnel vào mã hóa theo hướng ngược lại. Các bên tham gia không thể xác định hướng hoặc độ dài của tunnel.\nMã hóa Tunnel Thời gian tồn tại tunnel động và điều chỉnh kích thước pool thích ứng để cân bằng tải mạng Các chiến lược kiểm tra tunnel thay thế và chẩn đoán từng hop riêng lẻ Xác thực chứng chỉ băng thông hoặc proof-of-work tùy chọn (được triển khai trong API 0.9.65+) Nghiên cứu về định hình lưu lượng và chèn chaff cho việc trộn lẫn endpoint Tiếp tục loại bỏ ElGamal và di chuyển sang ECIES-X25519 Phát triển liên tục Đặc tả Triển khai Tunnel Đặc tả Tạo Tunnel (ElGamal) Đặc tả Tạo Tunnel (ECIES-X25519) Đặc tả Thông điệp Tunnel Garlic Routing I2P Network Database Phân tích và Lựa chọn Peer Mô hình Đe dọa I2P Mã hóa ElGamal/AES + SessionTag Tùy chọn I2CP ","description":"Tổng quan về thuật ngữ tunnel I2P, cách xây dựng và vòng đời","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"Định tuyến Tunnel","url":"/vi/docs/overview/tunnel-routing/"},{"categories":null,"content":"Trạng thái triển khai Triển khai hiện tại: - i2pd (triển khai C++): Được triển khai đầy đủ trong phiên bản 2.58.0 (tháng 9 năm 2025) với hỗ trợ ML-KEM-512, ML-KEM-768 và ML-KEM-1024. Mã hóa đầu-cuối hậu lượng tử được bật theo mặc định khi có OpenSSL 3.5.0 hoặc mới hơn. - Java I2P: Chưa được triển khai tính đến phiên bản 0.9.67 / 2.10.0 (tháng 9 năm 2025). Đặc tả đã được phê duyệt và việc triển khai được lên kế hoạch cho các bản phát hành trong tương lai.\nBản đặc tả này mô tả các chức năng đã được phê duyệt, hiện đang được triển khai trong i2pd và được lên kế hoạch cho các triển khai Java I2P.\nTổng quan Đây là biến thể lai hậu lượng tử của giao thức ECIES-X25519-AEAD-Ratchet ECIES . Nó đại diện cho giai đoạn đầu tiên của Đề xuất 169 Prop169 được phê duyệt. Xem đề xuất đó để biết các mục tiêu tổng thể, mô hình mối đe dọa, phân tích, các phương án thay thế và thông tin bổ sung.\nTrạng thái Đề xuất 169: Đang mở (giai đoạn đầu đã được phê duyệt cho việc triển khai ECIES (lược đồ mã hóa tích hợp dựa trên đường cong elliptic) dạng lai).\nĐặc tả này chỉ bao gồm những khác biệt so với ECIES tiêu chuẩn và phải được đọc cùng với đặc tả đó.\nThiết kế Chúng tôi sử dụng tiêu chuẩn NIST FIPS 203 FIPS203 , được xây dựng dựa trên, nhưng không tương thích với, CRYSTALS-Kyber (các phiên bản 3.1, 3 và cũ hơn).\nBắt tay lai kết hợp Diffie-Hellman X25519 cổ điển với các cơ chế đóng gói khóa ML-KEM hậu lượng tử (KEM). Cách tiếp cận này dựa trên các khái niệm về bí mật chuyển tiếp lai được ghi nhận trong nghiên cứu PQNoise và các triển khai tương tự trong TLS 1.3, IKEv2 và WireGuard.\nTrao đổi khóa Chúng tôi định nghĩa một cơ chế trao đổi khóa lai cho Ratchet (cơ chế ratchet trong mật mã). Post-quantum KEM (cơ chế đóng gói khóa hậu lượng tử) chỉ cung cấp các khóa tạm thời và không hỗ trợ trực tiếp các bắt tay dùng khóa tĩnh như Noise IK.\nChúng tôi định nghĩa ba biến thể ML-KEM (cơ chế bao bọc khóa dựa trên mạng tinh thể mô-đun, hậu lượng tử) như được quy định trong FIPS203 , tổng cộng có 3 kiểu mã hóa mới. Các kiểu lai chỉ được định nghĩa khi kết hợp với X25519.\nCác loại mã hóa mới là:\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 **Lưu ý:** MLKEM768_X25519 (Type 6) là biến thể mặc định được khuyến nghị, cung cấp bảo mật hậu lượng tử mạnh mẽ với độ quá tải hợp lý. Chi phí phụ trội là đáng kể so với mã hóa chỉ dùng X25519 (thuật toán trao đổi khóa dùng đường cong elliptic). Kích thước điển hình của thông điệp 1 và 2 (đối với IK pattern, tức mẫu IK trong Noise Protocol) hiện vào khoảng 96-103 byte (trước phần payload bổ sung). Con số này sẽ tăng khoảng gấp 9-12 lần với MLKEM512 (thuật toán mã hóa khóa công khai kháng lượng tử ML‑KEM, cấu hình 512), gấp 13-16 lần với MLKEM768, và gấp 17-23 lần với MLKEM1024, tùy theo loại thông điệp.\nCần mật mã mới ML-KEM (trước đây là CRYSTALS-Kyber) FIPS203 - Tiêu chuẩn cơ chế đóng gói khóa dựa trên lưới mô-đun SHA3-256 (trước đây là Keccak-512) FIPS202 - Một phần của tiêu chuẩn SHA-3 SHAKE128 và SHAKE256 (các phần mở rộng XOF cho SHA3) FIPS202 - Các hàm đầu ra có thể mở rộng Các vector kiểm thử cho SHA3-256, SHAKE128 và SHAKE256 (các hàm băm và hàm mở rộng đầu ra trong mật mã) có sẵn trong NIST Cryptographic Algorithm Validation Program (Chương trình Xác thực Thuật toán Mật mã của NIST).\nHỗ trợ thư viện: - Java: Thư viện Bouncycastle phiên bản 1.79 trở lên hỗ trợ tất cả các biến thể ML-KEM và các hàm SHA3/SHAKE - C++: OpenSSL 3.5 trở lên bao gồm hỗ trợ ML-KEM đầy đủ (phát hành tháng 4 năm 2025) - Go: Có nhiều thư viện có sẵn cho việc triển khai ML-KEM và SHA3\nĐặc tả Cấu trúc chung Xem Đặc tả Cấu trúc Chung để biết độ dài khóa và các định danh.\nCác mẫu bắt tay Các quy trình bắt tay sử dụng các mẫu bắt tay của Noise Protocol Framework (khuôn khổ giao thức Noise), với các thích ứng dành riêng cho I2P để cung cấp bảo mật hậu lượng tử lai.\nBảng ánh xạ ký tự sau đây được sử dụng:\ne = khóa tạm thời dùng một lần (X25519) s = khóa tĩnh p = tải trọng thông điệp (payload) e1 = khóa PQ (hậu lượng tử) tạm thời dùng một lần, gửi từ Alice đến Bob (token đặc thù của I2P) ekem1 = bản mã KEM (Key Encapsulation Mechanism – cơ chế đóng gói khóa), gửi từ Bob đến Alice (token đặc thù của I2P) Lưu ý quan trọng: Các tên mẫu \u0026ldquo;IKhfs\u0026rdquo; và \u0026ldquo;IKhfselg2\u0026rdquo; cùng các token \u0026ldquo;e1\u0026rdquo; và \u0026ldquo;ekem1\u0026rdquo; là những điều chỉnh đặc thù của I2P, không được mô tả trong đặc tả chính thức của Noise Protocol Framework (khung giao thức Noise). Chúng là các định nghĩa tùy biến nhằm tích hợp ML-KEM (cơ chế đóng gói khóa dựa trên mạng tinh thể) vào mẫu IK của Noise. Mặc dù cách tiếp cận lai X25519 + ML-KEM được thừa nhận rộng rãi trong nghiên cứu về mật mã hậu lượng tử và trong các giao thức khác, phép đặt tên cụ thể được dùng ở đây là đặc thù của I2P.\nCác sửa đổi sau đây đối với IK để đạt được bí mật chuyển tiếp lai được áp dụng:\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. Mẫu e1 được định nghĩa như sau:\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) Mẫu ekem1 được định nghĩa như sau:\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) Các thao tác ML-KEM (cơ chế đóng gói khóa dựa trên mô-đun lưới) được định nghĩa Chúng tôi định nghĩa các hàm sau tương ứng với các khối xây dựng mật mã như được chỉ định trong FIPS203 .\n(encap_key, decap_key) = PQ_KEYGEN() : Alice tạo các encapsulation key (khóa bao gói) và decapsulation key (khóa giải bao gói). encapsulation key được gửi trong thông điệp NS. Kích thước khóa: - ML-KEM-512: encap_key = 800 byte, decap_key = 1632 byte - ML-KEM-768: encap_key = 1184 byte, decap_key = 2400 byte - ML-KEM-1024: encap_key = 1568 byte, decap_key = 3168 byte\n(ciphertext, kem_shared_key) = ENCAPS(encap_key) : Bob tính toán bản mã và khóa chia sẻ bằng khóa đóng gói (encapsulation key) nhận được trong thông điệp NS. Bản mã được gửi trong thông điệp NSR. Kích thước bản mã: - ML-KEM-512: 768 byte - ML-KEM-768: 1088 byte - ML-KEM-1024: 1568 byte\nkem_shared_key luôn là 32 byte đối với cả ba biến thể.\nkem_shared_key = DECAPS(ciphertext, decap_key) : Alice tính toán khóa dùng chung bằng cách sử dụng bản mã nhận được trong thông điệp NSR. kem_shared_key luôn có độ dài 32 byte.\nQuan trọng: Cả encap_key và bản mã đều được mã hóa bên trong các khối ChaCha20-Poly1305 trong các thông điệp bắt tay Noise số 1 và 2. Chúng sẽ được giải mã như một phần của quy trình bắt tay.\nkem_shared_key được trộn vào chaining key (khóa xâu chuỗi) bằng MixKey(). Xem chi tiết bên dưới.\nKDF (hàm dẫn xuất khóa) cho bắt tay Noise Tổng quan Bắt tay lai kết hợp ECDH X25519 cổ điển với ML-KEM hậu lượng tử. Thông điệp đầu tiên, từ Alice tới Bob, chứa e1 (khóa bao gói ML-KEM) trước phần tải của thông điệp (payload). Thành phần này được coi như vật liệu khóa bổ sung; hãy gọi EncryptAndHash() trên nó (với vai trò Alice) hoặc DecryptAndHash() (với vai trò Bob). Sau đó xử lý phần tải của thông điệp như bình thường.\nThông điệp thứ hai, từ Bob gửi Alice, chứa ekem1 (bản mã ML-KEM) ở trước phần tải thông điệp. Phần này được coi là vật liệu khóa bổ sung; gọi EncryptAndHash() trên nó (với vai trò Bob) hoặc DecryptAndHash() (với vai trò Alice). Sau đó tính kem_shared_key và gọi MixKey(kem_shared_key). Tiếp theo, xử lý phần tải thông điệp như bình thường.\nCác định danh của Noise (giao thức Noise) Đây là các chuỗi khởi tạo của Noise (bộ khung giao thức bắt tay) (dành riêng cho I2P):\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 KDF (hàm dẫn xuất khóa) của Alice cho thông điệp NS Sau mẫu thông điệp \u0026rsquo;es\u0026rsquo; và trước mẫu thông điệp \u0026rsquo;s\u0026rsquo;, hãy thêm:\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). Bob KDF (hàm dẫn xuất khóa) cho thông điệp NS Sau mẫu thông điệp \u0026rsquo;es\u0026rsquo; và trước mẫu thông điệp \u0026rsquo;s\u0026rsquo;, hãy thêm:\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). KDF (hàm dẫn xuất khóa) của Bob cho thông điệp NSR Sau mẫu thông điệp \u0026rsquo;ee\u0026rsquo; và trước mẫu thông điệp \u0026lsquo;se\u0026rsquo;, thêm:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. KDF (hàm dẫn xuất khóa) của Alice cho thông điệp NSR Sau mẫu thông điệp \u0026rsquo;ee\u0026rsquo; và trước mẫu thông điệp \u0026lsquo;ss\u0026rsquo;, thêm:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. Hàm dẫn xuất khóa (KDF) cho split() Hàm split() vẫn không thay đổi so với đặc tả ECIES tiêu chuẩn. Sau khi hoàn tất bắt tay:\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] Đây là các khóa phiên hai chiều cho việc liên lạc đang diễn ra.\nĐịnh dạng thông điệp Định dạng NS (New Session - phiên mới) Thay đổi: Ratchet (cơ chế cập nhật khóa tuần tự) hiện tại chứa khóa tĩnh trong phần ChaCha20-Poly1305 thứ nhất và payload (nội dung dữ liệu) trong phần thứ hai. Với ML-KEM, hiện có ba phần. Phần thứ nhất chứa khóa công khai ML-KEM được mã hóa (encap_key). Phần thứ hai chứa khóa tĩnh. Phần thứ ba chứa payload.\nKích thước thông điệp:\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl **Lưu ý:** Payload (dữ liệu tải) phải chứa một khối DateTime (tối thiểu 7 byte: 1 byte loại, 2 byte kích thước, 4 byte dấu thời gian). Kích thước NS tối thiểu có thể được tính toán tương ứng. Do đó, kích thước NS tối thiểu trên thực tế là 103 byte cho X25519 và đối với các biến thể lai thì nằm trong khoảng 919 đến 1687 byte. Các mức tăng kích thước 816, 1200 và 1584 byte cho ba biến thể ML-KEM tương ứng với khóa công khai ML-KEM cộng thêm một Poly1305 MAC (mã xác thực thông điệp Poly1305) 16 byte dành cho mã hóa có xác thực.\nĐịnh dạng NSR (New Session Reply - Phản hồi phiên mới) Thay đổi: Ratchet (cơ chế cập nhật khóa liên tục) hiện tại có payload (dữ liệu tải) trống ở phần ChaCha20-Poly1305 thứ nhất và payload ở phần thứ hai. Với ML-KEM, hiện có ba phần. Phần thứ nhất chứa bản mã ML-KEM đã được mã hóa. Phần thứ hai có payload trống. Phần thứ ba chứa payload.\nKích thước thông điệp:\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl Các mức tăng kích thước 784, 1104 và 1584 byte cho ba biến thể ML-KEM (cơ chế đóng gói khóa hậu lượng tử) phản ánh việc bao gồm bản mã ML-KEM cộng thêm một Poly1305 MAC 16 byte (mã xác thực thông điệp) cho mã hóa xác thực. Phân tích overhead (chi phí phụ trội) Trao đổi khóa Chi phí bổ sung của mã hóa lai là đáng kể so với X25519-only:\nMLKEM512_X25519: Tăng khoảng 9-12x kích thước thông điệp bắt tay (NS: 9.5x, NSR: 11.9x) MLKEM768_X25519: Tăng khoảng 13-16x kích thước thông điệp bắt tay (NS: 13.5x, NSR: 16.3x) MLKEM1024_X25519: Tăng khoảng 17-23x kích thước thông điệp bắt tay (NS: 17.5x, NSR: 23x) Phần phụ trội này là chấp nhận được vì những lợi ích bảo mật hậu lượng tử bổ sung. Các hệ số nhân thay đổi theo từng loại thông điệp vì kích thước cơ sở của thông điệp khác nhau (NS tối thiểu 96 byte, NSR tối thiểu 72 byte).\nCác cân nhắc về băng thông Đối với việc thiết lập phiên điển hình với payload tối thiểu:\nChỉ X25519: ~200 byte tổng cộng (NS + NSR) MLKEM512_X25519: ~1,800 byte tổng cộng (tăng 9 lần) MLKEM768_X25519: ~2,500 byte tổng cộng (tăng 12.5 lần) MLKEM1024_X25519: ~3,400 byte tổng cộng (tăng 17 lần) Sau khi phiên được thiết lập, việc mã hóa thông điệp đang diễn ra sử dụng cùng định dạng truyền tải dữ liệu như các phiên chỉ dùng X25519, vì vậy không có chi phí bổ sung cho các thông điệp tiếp theo.\nPhân tích bảo mật Bắt tay Hybrid handshake (bắt tay lai) cung cấp cả bảo mật cổ điển (X25519) và hậu lượng tử (ML-KEM). Kẻ tấn công phải phá vỡ cả hai ECDH cổ điển (Diffie–Hellman trên đường cong elliptic) và KEM hậu lượng tử (cơ chế đóng gói khóa) thì mới có thể xâm phạm các khóa phiên.\nĐiều này cung cấp: - Bảo mật hiện tại: X25519 ECDH cung cấp bảo vệ trước các kẻ tấn công cổ điển (mức bảo mật 128-bit) - Bảo mật tương lai: ML-KEM cung cấp bảo vệ trước các kẻ tấn công lượng tử (thay đổi theo bộ tham số) - Bảo mật lai: Cả hai đều phải bị phá vỡ để xâm phạm phiên (mức bảo mật = tối đa của cả hai thành phần)\nCác mức bảo mật Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit **Lưu ý:** Mức bảo mật lai bị giới hạn bởi thành phần yếu hơn trong hai thành phần. Trong mọi trường hợp, X25519 cung cấp mức bảo mật cổ điển 128-bit. Nếu một máy tính lượng tử có ý nghĩa đối với mật mã trở nên khả dụng, mức bảo mật sẽ phụ thuộc vào bộ tham số ML-KEM được chọn. Bảo mật chuyển tiếp Cách tiếp cận lai duy trì các thuộc tính bí mật chuyển tiếp. Các khóa phiên được dẫn xuất từ cả hai trao đổi khóa tạm thời X25519 và ML-KEM. Nếu một trong hai khóa riêng tạm thời X25519 hoặc ML-KEM bị hủy sau khi bắt tay, các phiên trước đó không thể giải mã ngay cả khi các khóa tĩnh dài hạn bị xâm phạm.\nIK pattern (mẫu bắt tay IK của Noise) cung cấp bảo mật chuyển tiếp đầy đủ (Noise Confidentiality level 5) sau khi thông điệp thứ hai (NSR) được gửi đi.\nTùy chọn loại Các triển khai nên hỗ trợ nhiều kiểu lai và đàm phán biến thể mạnh nhất mà cả hai bên đều hỗ trợ. Thứ tự ưu tiên nên là:\nMLKEM768_X25519 (Loại 6) - Mặc định được khuyến nghị, cân bằng tốt nhất giữa bảo mật và hiệu năng MLKEM1024_X25519 (Loại 7) - Mức bảo mật cao nhất cho các ứng dụng nhạy cảm MLKEM512_X25519 (Loại 5) - Mức bảo mật hậu lượng tử cơ bản cho các kịch bản bị hạn chế tài nguyên X25519 (Loại 4) - Chỉ cổ điển, dùng làm phương án dự phòng để tương thích Lý do: MLKEM768_X25519 được khuyến nghị làm mặc định vì nó cung cấp mức bảo mật NIST Cấp 3 (tương đương AES-192), được coi là đủ để chống lại máy tính lượng tử đồng thời vẫn duy trì kích thước thông điệp hợp lý. MLKEM1024_X25519 cung cấp mức bảo mật cao hơn nhưng với overhead (chi phí phụ trội) tăng đáng kể.\nGhi chú triển khai Hỗ trợ thư viện Java: Thư viện Bouncycastle phiên bản 1.79 (tháng 8 năm 2024) và các phiên bản mới hơn hỗ trợ tất cả các biến thể ML-KEM cần thiết và các hàm SHA3/SHAKE. Sử dụng org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine để tuân thủ FIPS 203 (chuẩn liên bang về ML-KEM). C++: OpenSSL 3.5 (tháng 4 năm 2025) và các phiên bản mới hơn bao gồm hỗ trợ ML-KEM thông qua giao diện EVP_KEM. Đây là bản phát hành Hỗ trợ Dài hạn (Long Term Support) được duy trì đến tháng 4 năm 2030. Go: Có một số thư viện bên thứ ba dành cho ML-KEM và SHA3, bao gồm thư viện CIRCL của Cloudflare. Chiến lược di chuyển Các triển khai nên: 1. Hỗ trợ cả biến thể chỉ X25519 và các biến thể ML-KEM lai trong giai đoạn chuyển tiếp 2. Ưu tiên biến thể lai khi cả hai nút đồng cấp đều hỗ trợ 3. Duy trì cơ chế quay lui về chỉ X25519 để bảo đảm tương thích ngược 4. Cân nhắc các ràng buộc băng thông mạng khi chọn biến thể mặc định\nCác tunnel dùng chung Kích thước thông điệp tăng lên có thể ảnh hưởng đến việc sử dụng tunnel dùng chung. Các triển khai nên cân nhắc: - Gom lô các thủ tục bắt tay khi có thể để giảm chi phí phụ trội - Sử dụng thời gian hết hạn ngắn hơn cho các phiên lai để giảm trạng thái cần lưu trữ - Theo dõi mức sử dụng băng thông và điều chỉnh các tham số tương ứng - Triển khai kiểm soát tắc nghẽn cho lưu lượng thiết lập phiên\nCác cân nhắc về kích thước phiên mới Do các thông điệp bắt tay có kích thước lớn hơn, các triển khai có thể cần: - Tăng kích thước bộ đệm cho thương lượng phiên (khuyến nghị tối thiểu 4KB) - Điều chỉnh giá trị thời gian chờ cho các kết nối chậm hơn (tính đến việc thông điệp lớn hơn khoảng ~3-17x) - Cân nhắc nén dữ liệu payload (dữ liệu tải) trong các thông điệp NS/NSR - Triển khai xử lý phân mảnh nếu được lớp truyền tải yêu cầu\nKiểm thử và thẩm định Các triển khai nên xác minh: - Tạo khóa ML-KEM, encapsulation (đóng gói), và decapsulation (giải đóng gói) chính xác - Tích hợp đúng kem_shared_key vào Noise KDF (hàm dẫn xuất khóa của giao thức Noise) - Việc tính toán kích thước thông điệp khớp với đặc tả - Khả năng tương tác với các triển khai I2P router khác - Hành vi dự phòng khi ML-KEM không khả dụng\nCác vector kiểm thử cho các hoạt động ML-KEM có sẵn trong Chương trình Xác thực Thuật toán Mật mã của NIST.\nKhả năng tương thích phiên bản Đánh số phiên bản I2P: I2P duy trì hai hệ đánh số phiên bản song song:\nRouter release version: định dạng 2.x.x (ví dụ: 2.10.0 phát hành tháng 9 năm 2025) API/protocol version: định dạng 0.9.x (ví dụ: 0.9.67 tương ứng với router 2.10.0) Đặc tả này tham chiếu tới phiên bản giao thức 0.9.67, tương ứng với bản phát hành router 2.10.0 trở lên.\nMa trận tương thích:\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release ## Tài liệu tham khảo [ECIES]: Đặc tả ECIES-X25519-AEAD-Ratchet [Prop169]: Đề xuất 169: Mật mã hậu lượng tử [FIPS203]: NIST FIPS 203 - Tiêu chuẩn ML-KEM [FIPS202]: NIST FIPS 202 - Tiêu chuẩn SHA-3 [Noise]: Khung giao thức Noise [COMMON]: Đặc tả Cấu trúc chung [RFC7539]: RFC 7539 - ChaCha20 và Poly1305 [RFC5869]: RFC 5869 - HKDF [OpenSSL]: Tài liệu OpenSSL 3.5 ML-KEM [Bouncycastle]: Thư viện mật mã Java Bouncycastle ","description":"Biến thể lai hậu lượng tử của giao thức mã hóa ECIES (lược đồ mã hóa tích hợp đường cong elliptic) sử dụng ML-KEM (cơ chế đóng gói khóa dựa trên lưới mô-đun)","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"ECIES-X25519-AEAD-Ratchet Hybrid Encryption (lược đồ mã hóa lai sử dụng ECIES với X25519, AEAD và ratchet)","url":"/vi/docs/specs/ecies-hybrid/"},{"categories":null,"content":"Tổng quan Giao thức Mạng I2P (I2NP) xác định cách các routers trao đổi thông điệp, lựa chọn các phương thức truyền tải và trộn lưu lượng đồng thời bảo toàn tính ẩn danh. Nó hoạt động ở giữa I2CP (API máy khách) và các giao thức truyền tải (NTCP2 và SSU2).\nI2NP là lớp nằm trên các giao thức truyền tải của I2P. Đây là một giao thức router-to-router được dùng cho: - Tra cứu và phản hồi cơ sở dữ liệu mạng - Tạo tunnels - Các thông điệp dữ liệu được mã hóa của router và máy khách\nCác thông điệp I2NP có thể được gửi theo kiểu điểm-tới-điểm tới một router khác, hoặc được gửi ẩn danh thông qua các tunnels đến router đó.\nRouters xếp hàng các công việc gửi ra dựa trên các mức ưu tiên cục bộ. Các số ưu tiên cao hơn được xử lý trước. Bất kỳ mức ưu tiên nào vượt quá mức ưu tiên dữ liệu tunnel tiêu chuẩn (400) đều được coi là khẩn cấp.\nCác giao thức truyền tải hiện tại I2P hiện sử dụng NTCP2 (TCP) và SSU2 (UDP) cho cả IPv4 và IPv6. Cả hai phương thức truyền tải đều sử dụng: - trao đổi khóa X25519 (khung giao thức Noise) - mã hóa xác thực ChaCha20/Poly1305 (AEAD) - hàm băm SHA-256\nĐã loại bỏ các giao thức truyền tải cũ: - NTCP (TCP ban đầu) đã được loại bỏ khỏi router Java trong bản phát hành 0.9.50 (Tháng 5 năm 2021) - SSU v1 (UDP ban đầu) đã được loại bỏ khỏi router Java trong bản phát hành 2.4.0 (Tháng 12 năm 2023) - SSU v1 đã được loại bỏ khỏi i2pd trong bản phát hành 2.44.0 (Tháng 11 năm 2022)\nKể từ năm 2025, mạng đã chuyển đổi hoàn toàn sang các giao thức truyền tải dựa trên Noise (khung giao thức mật mã), và hoàn toàn không hỗ trợ các giao thức truyền tải kiểu cũ.\nHệ thống đánh số phiên bản QUAN TRỌNG: I2P sử dụng một cơ chế đánh số phiên bản kép cần được hiểu rõ:\nPhiên bản phát hành (dành cho người dùng) Đây là các phiên bản mà người dùng thấy và tải xuống: - 0.9.50 (Tháng 5 năm 2021) - Bản phát hành 0.9.x cuối cùng - 1.5.0 (Tháng 8 năm 2021) - Bản phát hành 1.x đầu tiên - 1.6.0, 1.7.0, 1.8.0, 1.9.0 (trong giai đoạn 2021-2022) - 2.0.0 (Tháng 11 năm 2022) - Bản phát hành 2.x đầu tiên - 2.1.0 đến 2.9.0 (trong giai đoạn 2023-2025) - 2.10.0 (ngày 8 tháng 9 năm 2025) - Bản phát hành hiện tại\nPhiên bản API (Tương thích giao thức) Đây là các số phiên bản nội bộ được công bố trong trường \u0026ldquo;router.version\u0026rdquo; trong các thuộc tính RouterInfo: - 0.9.50 (Tháng 5 năm 2021) - 0.9.51 (Tháng 8 năm 2021) - Phiên bản API cho bản phát hành 1.5.0 - 0.9.52 đến 0.9.66 (tiếp tục qua các bản phát hành 2.x) - 0.9.67 (Tháng 9 năm 2025) - Phiên bản API cho bản phát hành 2.10.0\nĐiểm chính: KHÔNG có bản phát hành nào được đánh số từ 0.9.51 đến 0.9.67. Các số này chỉ tồn tại như các định danh phiên bản API. I2P đã nhảy từ bản phát hành 0.9.50 trực tiếp lên 1.5.0.\nBảng ánh xạ phiên bản Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) **Sắp tới:** Bản phát hành 2.11.0 (dự kiến tháng 12 năm 2025) sẽ yêu cầu Java 17 trở lên và bật mật mã hậu lượng tử theo mặc định. Phiên bản giao thức Tất cả các router phải công bố phiên bản giao thức I2NP của mình trong trường \u0026ldquo;router.version\u0026rdquo; trong các thuộc tính của RouterInfo (cấu trúc thông tin về router). Trường phiên bản này là phiên bản API, cho biết mức độ hỗ trợ đối với các tính năng khác nhau của giao thức I2NP, và không nhất thiết trùng với phiên bản router thực tế.\nNếu các router thay thế (không dùng Java) muốn công bố bất kỳ thông tin phiên bản nào về bản triển khai router thực tế, họ phải thực hiện điều đó trong một thuộc tính khác. Các phiên bản khác với những phiên bản liệt kê bên dưới đều được phép. Khả năng hỗ trợ sẽ được xác định thông qua so sánh số; ví dụ, 0.9.13 ngụ ý hỗ trợ các tính năng của 0.9.12.\nLưu ý: Thuộc tính \u0026ldquo;coreVersion\u0026rdquo; không còn được công bố trong thông tin router và trước đây cũng chưa từng được sử dụng để xác định phiên bản giao thức I2NP.\nTóm tắt tính năng theo phiên bản API API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network **Lưu ý:** Cũng có các tính năng liên quan đến lớp truyền tải và các vấn đề tương thích. Xem tài liệu về cơ chế truyền tải NTCP2 và SSU2 để biết chi tiết. Phần đầu thông điệp I2NP sử dụng một cấu trúc tiêu đề 16 byte ở mức logic, trong khi các giao thức truyền tải hiện đại (NTCP2 và SSU2) sử dụng tiêu đề 9 byte rút gọn, loại bỏ các trường kích thước và kiểm tra tổng (checksum) dư thừa. Các trường vẫn tương đương về mặt khái niệm.\nSo sánh định dạng tiêu đề Định dạng tiêu chuẩn (16 byte):\nĐược sử dụng trong cơ chế truyền tải NTCP cũ và khi các thông điệp I2NP được nhúng bên trong các thông điệp khác (TunnelData, TunnelGateway, GarlicClove).\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity Định dạng ngắn cho SSU (đã lỗi thời, 5 byte):\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) Định dạng ngắn cho NTCP2, SSU2 và ECIES-Ratchet Garlic Cloves (các nhánh thông điệp trong mô hình garlic) (9 byte):\nĐược sử dụng trong các transport hiện đại và trong các thông điệp garlic được mã hóa bằng ECIES.\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) Chi tiết các trường tiêu đề Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity ### Ghi chú triển khai Khi được truyền qua SSU (đã lỗi thời), chỉ bao gồm trường loại và thời điểm hết hạn 4 byte Khi được truyền qua NTCP2 hoặc SSU2, sử dụng định dạng rút gọn 9 byte Phần đầu 16 byte tiêu chuẩn là bắt buộc cho các thông điệp I2NP được chứa trong các thông điệp khác (Data, TunnelData, TunnelGateway, GarlicClove) Kể từ bản phát hành 0.8.12, việc xác minh checksum (mã kiểm tra) bị tắt tại một số điểm trong ngăn xếp giao thức để tăng hiệu suất, nhưng việc tạo checksum vẫn là bắt buộc để đảm bảo khả năng tương thích Thời điểm hết hạn rút gọn là số không dấu và sẽ tràn quay vòng vào ngày 7 tháng 2 năm 2106. Sau thời điểm đó, phải cộng thêm một độ lệch để có thời gian chính xác Để tương thích với các phiên bản cũ, luôn tạo checksum ngay cả khi chúng có thể không được xác minh Giới hạn kích thước Các thông điệp Tunnel phân mảnh các tải trọng I2NP thành các mảnh có kích thước cố định: - Mảnh đầu tiên: xấp xỉ 956 byte - Các mảnh tiếp theo: xấp xỉ 996 byte mỗi mảnh - Số mảnh tối đa: 64 (đánh số 0-63) - Tải trọng tối đa: xấp xỉ 61,200 byte (61.2 KB)\nTính toán: 956 + (63 × 996) = 63,704 byte tối đa theo lý thuyết, với giới hạn thực tế khoảng 61,200 byte do phần overhead (chi phí quản trị).\nBối cảnh lịch sử Các giao thức truyền tải cũ có giới hạn kích thước khung nghiêm ngặt hơn: - NTCP: khung 16 KB - SSU: khung khoảng 32 KB\nNTCP2 hỗ trợ các khung dữ liệu khoảng 65 KB, nhưng giới hạn phân mảnh tunnel vẫn áp dụng.\nCác cân nhắc về dữ liệu ứng dụng Garlic messages (thông điệp garlic) có thể đóng gói LeaseSets, Session Tags (thẻ phiên), hoặc các biến thể LeaseSet2 được mã hóa, làm giảm dung lượng dành cho dữ liệu payload.\nKhuyến nghị: Các datagram (gói tin không kết nối) nên giữ ≤ 10 KB để đảm bảo chuyển phát đáng tin cậy. Các thông điệp tiến gần tới giới hạn 61 KB có thể gặp:\nĐộ trễ tăng do phân mảnh và tái lắp ráp Xác suất thất bại khi chuyển phát cao hơn Dễ bị phân tích lưu lượng hơn Chi tiết kỹ thuật về phân mảnh Mỗi thông điệp tunnel có kích thước chính xác 1,024 byte (1 KB) và bao gồm: - tunnel ID 4 byte - vector khởi tạo (IV) 16 byte - 1,004 byte dữ liệu được mã hóa\nBên trong dữ liệu đã mã hóa, các thông điệp tunnel mang các thông điệp I2NP bị phân mảnh với fragment header (tiêu đề mảnh) cho biết: - Số thứ tự mảnh (0-63) - Đây là mảnh đầu tiên hay mảnh theo sau - ID của thông điệp hoàn chỉnh để tái lắp ráp\nMảnh đầu tiên bao gồm toàn bộ phần đầu (header) của thông điệp I2NP (16 byte), để lại khoảng 956 byte cho phần tải (payload). Các mảnh tiếp theo không bao gồm phần đầu thông điệp, nhờ đó mỗi mảnh có khoảng 996 byte phần tải.\nCác loại thông điệp phổ biến Routers sử dụng loại thông điệp và mức độ ưu tiên để lập lịch các tác vụ gửi đi. Các giá trị ưu tiên cao hơn được xử lý trước. Các giá trị dưới đây khớp với mặc định hiện tại của Java I2P (tính đến phiên bản API 0.9.67).\nLưu ý: Các mức ưu tiên phụ thuộc vào cách triển khai. Để biết các giá trị ưu tiên chính thức, hãy tham khảo tài liệu của lớp OutNetMessage trong mã nguồn Java I2P.\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) **Các kiểu thông điệp dành riêng:** - Kiểu 0: Dành riêng - Các kiểu 4-9: Dành cho sử dụng trong tương lai - Các kiểu 12-17: Dành cho sử dụng trong tương lai - Các kiểu 224-254: Dành cho thông điệp thử nghiệm - Kiểu 255: Dành cho mở rộng trong tương lai Ghi chú về kiểu thông điệp Các thông điệp mặt phẳng điều khiển (DatabaseLookup, TunnelBuild, v.v.) thường đi qua exploratory tunnels (tunnel thăm dò), không phải client tunnels (tunnel khách), cho phép ưu tiên độc lập Các giá trị ưu tiên chỉ mang tính xấp xỉ và có thể khác nhau tùy theo cách triển khai TunnelBuild (21) và TunnelBuildReply (22) đã lỗi thời nhưng vẫn được triển khai để tương thích với các tunnel rất dài (\u0026gt;8 bước nhảy) Mức ưu tiên dữ liệu tunnel chuẩn là 400; mọi giá trị cao hơn mức này được coi là khẩn Độ dài tunnel điển hình trong mạng hiện nay là 3-4 bước nhảy, vì vậy phần lớn các lần dựng tunnel sử dụng ShortTunnelBuild (bản ghi 218 byte) hoặc VariableTunnelBuild (bản ghi 528 byte) Mã hóa và bao gói thông điệp Các router thường đóng gói các thông điệp I2NP trước khi truyền, tạo ra nhiều lớp mã hóa. Một DeliveryStatus message (thông điệp trạng thái giao nhận) có thể: 1. Được bọc trong GarlicMessage (thông điệp Garlic) (được mã hóa) 2. Ở bên trong một DataMessage (thông điệp dữ liệu) 3. Nằm trong một TunnelData message (thông điệp dữ liệu tunnel) (được mã hóa lần nữa)\nMỗi nút trung gian chỉ giải mã lớp của riêng nó; đích đến cuối cùng sẽ tiết lộ nội dung ở lớp trong cùng.\nCác thuật toán mã hóa Cũ (Đang dần bị loại bỏ): - ElGamal/AES + SessionTags (thẻ phiên) - ElGamal-2048 cho mã hóa bất đối xứng - AES-256 cho mã hóa đối xứng - thẻ phiên 32 byte\nHiện tại (Tiêu chuẩn kể từ API 0.9.48): - ECIES-X25519 + ChaCha20/Poly1305 AEAD với forward secrecy (bí mật chuyển tiếp) dạng ratcheting - Khung giao thức Noise (Noise_IK_25519_ChaChaPoly_SHA256 cho các đích) - Thẻ phiên 8 byte (giảm từ 32 byte) - Thuật toán Signal Double Ratchet cho forward secrecy - Được giới thiệu trong phiên bản API 0.9.46 (2020) - Bắt buộc đối với tất cả router kể từ phiên bản API 0.9.58 (2023)\nTương lai (Beta kể từ 2.10.0): - Mật mã lai hậu lượng tử sử dụng MLKEM (ML-KEM-768) kết hợp với X25519 - ratchet lai (cơ chế cập nhật khóa dần) kết hợp thỏa thuận khóa cổ điển và hậu lượng tử - Tương thích ngược với ECIES-X25519 - Sẽ trở thành mặc định trong bản phát hành 2.11.0 (Tháng 12 năm 2025)\nLoại bỏ dần Router ElGamal LƯU Ý QUAN TRỌNG: Các router ElGamal đã bị ngừng khuyến nghị sử dụng (deprecated) kể từ phiên bản API 0.9.58 (bản phát hành 2.2.0, tháng 3 năm 2023). Vì phiên bản floodfill tối thiểu được khuyến nghị để truy vấn hiện là 0.9.58, các triển khai không cần thực hiện mã hóa cho các router floodfill ElGamal.\nTuy nhiên: Các đích ElGamal vẫn được hỗ trợ để đảm bảo khả năng tương thích ngược. Các ứng dụng khách sử dụng mã hóa ElGamal vẫn có thể giao tiếp thông qua các router ECIES.\nChi tiết về ECIES-X25519-AEAD-Ratchet (cơ chế mật mã kết hợp ECIES, X25519, AEAD và ratchet) Đây là kiểu mật mã 4 trong đặc tả mật mã của I2P. Nó cung cấp:\nTính năng chính: - Bí mật chuyển tiếp thông qua ratcheting (cơ chế bánh cóc; khóa mới cho mỗi tin nhắn) - Giảm dung lượng lưu trữ session tag (thẻ phiên) (8 byte so với 32 byte) - Nhiều loại phiên (Phiên Mới, Phiên Hiện Có, Một Lần) - Dựa trên giao thức Noise Noise_IK_25519_ChaChaPoly_SHA256 - Tích hợp với thuật toán Double Ratchet (bánh cóc kép) của Signal\nNguyên thủy mật mã: - X25519 cho thỏa thuận khóa Diffie-Hellman - ChaCha20 cho mã hóa luồng - Poly1305 cho xác thực thông điệp (AEAD) - SHA-256 cho băm - HKDF cho dẫn xuất khóa\nQuản lý phiên: - Phiên mới: Kết nối ban đầu sử dụng static destination key (khóa đích tĩnh) - Phiên hiện có: Các thông điệp tiếp theo sử dụng session tags (thẻ phiên) - Phiên dùng một lần: Phiên chỉ một thông điệp để giảm overhead (chi phí quản trị)\nXem Đặc tả ECIES và Đề xuất 144 để biết toàn bộ chi tiết kỹ thuật.\nCác cấu trúc chung Các cấu trúc sau đây là các thành phần của nhiều thông điệp I2NP. Chúng không phải là các thông điệp hoàn chỉnh.\nBuildRequestRecord (bản ghi yêu cầu xây dựng) (ElGamal) ĐÃ LỖI THỜI. Chỉ được sử dụng trong mạng hiện tại khi một tunnel chứa router ElGamal. Xem Tạo Tunnel ECIES để biết định dạng hiện đại.\nMục đích: Một bản ghi thuộc tập nhiều bản ghi dùng để yêu cầu tạo một chặng trong tunnel.\nĐịnh dạng:\nĐược mã hóa bằng ElGamal và AES (tổng cộng 528 byte):\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Cấu trúc được mã hóa bằng ElGamal (528 byte):\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) Cấu trúc bản rõ (222 byte trước khi mã hóa):\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data Ghi chú: - Mã hóa ElGamal-2048 tạo ra một khối 514 byte, nhưng hai byte đệm (tại các vị trí 0 và 257) được loại bỏ, kết quả còn 512 byte - Xem Đặc tả Tạo Tunnel để biết chi tiết về các trường - Mã nguồn: net.i2p.data.i2np.BuildRequestRecord - Hằng số: EncryptedBuildRecord.RECORD_SIZE = 528\nBuildRequestRecord (bản ghi yêu cầu xây dựng) (ECIES-X25519 Long) Đối với các router ECIES-X25519, được giới thiệu từ phiên bản API 0.9.48. Sử dụng 528 byte để đảm bảo tương thích ngược với các tunnels hỗn hợp.\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) Tổng kích thước: 528 byte (giống như ElGamal để tương thích)\nXem ECIES Tunnel Creation để biết về cấu trúc cleartext (dữ liệu không mã hóa) và các chi tiết mã hóa.\nBuildRequestRecord (ECIES-X25519 phiên bản rút gọn) Chỉ dành cho các router ECIES-X25519, kể từ phiên bản API 0.9.51 (bản phát hành 1.5.0). Đây là định dạng tiêu chuẩn hiện tại.\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) Tổng kích thước: 218 byte (giảm 59% so với 528 byte)\nKhác biệt chính: Bản ghi ngắn dẫn xuất tất cả các khóa thông qua HKDF (key derivation function - hàm dẫn xuất khóa) thay vì đưa chúng vào bản ghi một cách tường minh. Bao gồm: - Khóa lớp (cho mã hóa tunnel) - Khóa IV (cho mã hóa tunnel) - Khóa phản hồi (cho build reply - phản hồi dựng tunnel) - IV phản hồi (cho build reply)\nTất cả các khóa được dẫn xuất bằng HKDF mechanism (cơ chế HKDF) của Noise protocol (giao thức Noise), dựa trên bí mật chung thu được từ X25519 key exchange (trao đổi khóa X25519).\nLợi ích: - 4 bản ghi ngắn vừa trong một thông điệp tunnel (873 byte) - Dựng tunnel bằng 3 thông điệp thay vì các thông điệp riêng cho từng bản ghi - Giảm băng thông và độ trễ - Các thuộc tính bảo mật giống như định dạng dài\nXem Đề xuất 157 để biết lý do thiết kế và ECIES Tunnel Creation để xem đặc tả đầy đủ.\nMã nguồn: - net.i2p.data.i2np.ShortEncryptedBuildRecord - Hằng số: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nBuildResponseRecord (ElGamal) KHÔNG CÒN ĐƯỢC KHUYẾN NGHỊ SỬ DỤNG. Chỉ được sử dụng khi tunnel chứa một router ElGamal.\nMục đích: Một bản ghi trong một tập hợp gồm nhiều bản ghi chứa các phản hồi cho một yêu cầu xây dựng.\nĐịnh dạng:\nĐược mã hóa (528 byte, cùng kích thước với BuildRequestRecord (bản ghi yêu cầu xây dựng)):\nbytes 0-527 :: AES-encrypted record Cấu trúc không mã hóa:\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) Mã phản hồi: - 0 - Chấp nhận - 30 - Từ chối (vượt quá băng thông)\nXem Tunnel Creation Specification để biết chi tiết về trường phản hồi.\nBuildResponseRecord (ECIES-X25519) Đối với routers ECIES-X25519, phiên bản API 0.9.48+. Có cùng kích thước với yêu cầu tương ứng (528 cho bản dài, 218 cho bản ngắn).\nĐịnh dạng:\nĐịnh dạng dài (528 byte):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Định dạng ngắn (218 byte):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Cấu trúc bản rõ (cả hai định dạng):\nChứa một cấu trúc ánh xạ (định dạng khóa-giá trị của I2P) với: - Mã trạng thái phản hồi (bắt buộc) - Tham số băng thông khả dụng (\u0026ldquo;b\u0026rdquo;) (tùy chọn, được thêm trong API 0.9.65) - Các tham số tùy chọn khác cho các mở rộng trong tương lai\nMã trạng thái phản hồi: - 0 - Thành công - 30 - Từ chối: vượt quá giới hạn băng thông\nXem ECIES Tunnel Creation để biết đặc tả đầy đủ.\nGarlicClove (đơn vị thông điệp trong garlic encryption) (ElGamal/AES) CẢNH BÁO: Đây là định dạng được dùng cho garlic cloves (các phần tử con trong thông điệp garlic) trong các garlic messages được mã hóa bằng ElGamal. Định dạng cho ECIES-AEAD-X25519-Ratchet garlic messages và garlic cloves khác biệt đáng kể. Xem ECIES Specification để biết định dạng hiện đại.\nKhông còn được khuyến nghị cho routers (API 0.9.58+), nhưng vẫn được hỗ trợ cho các điểm đích.\nĐịnh dạng:\nKhông mã hóa:\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) Ghi chú: - Clove (đơn vị tải trong GarlicMessage) không bao giờ bị phân mảnh - Khi bit đầu tiên của byte cờ Delivery Instructions là 0, clove không được mã hóa - Khi bit đầu tiên là 1, clove được mã hóa (tính năng chưa được triển khai) - Độ dài tối đa phụ thuộc vào tổng độ dài các clove và độ dài tối đa của GarlicMessage - Chứng chỉ có thể được dùng cho HashCash để \u0026ldquo;trả phí\u0026rdquo; cho định tuyến (khả năng trong tương lai) - Các thông điệp được dùng trong thực tế: DataMessage, DeliveryStatusMessage, DatabaseStoreMessage - GarlicMessage có thể chứa GarlicMessage (garlic lồng nhau), nhưng điều này không được dùng trong thực tế\nXem Garlic Routing (định tuyến tỏi) để có cái nhìn tổng quan ở mức khái niệm.\nGarlicClove (ECIES-X25519-AEAD-Ratchet) Dành cho routers và destinations (đích) ECIES-X25519, phiên bản API 0.9.46+. Đây là định dạng tiêu chuẩn hiện tại.\nKHÁC BIỆT QUAN TRỌNG: ECIES garlic (dạng garlic dựa trên ECIES trong I2P) sử dụng một cấu trúc hoàn toàn khác, dựa trên các khối của giao thức Noise thay vì các cấu trúc clove (tiểu thông điệp con) tường minh.\nĐịnh dạng:\nECIES garlic messages (thông điệp kiểu garlic trong I2P) bao gồm một loạt các khối:\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data Các loại khối: - 0 - Khối Garlic Clove (tép tỏi; chứa một thông điệp I2NP) - 1 - Khối ngày-giờ (dấu thời gian) - 2 - Khối tùy chọn (tùy chọn chuyển phát) - 3 - Khối đệm - 254 - Khối kết thúc (chưa triển khai)\nGarlic Clove Block (khối tép tỏi trong I2P) (loại 0):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ Những khác biệt chính so với định dạng ElGamal: - Sử dụng thời gian hết hạn 4 byte (giây kể từ epoch) thay vì Date 8 byte - Không có trường chứng chỉ - Được bao gói trong cấu trúc khối với kiểu và độ dài - Toàn bộ thông điệp được mã hóa bằng ChaCha20/Poly1305 AEAD - Quản lý phiên thông qua ratcheting (cơ chế tăng dần khóa một chiều)\nXem Đặc tả ECIES để biết toàn bộ chi tiết về khung giao thức Noise và các cấu trúc khối.\nChỉ dẫn chuyển phát Garlic Clove (tép tỏi trong garlic encryption) Định dạng này được dùng cho cả ElGamal và ECIES garlic cloves (các \u0026rsquo;nhánh\u0026rsquo; trong mô hình garlic encryption). Nó chỉ rõ cách chuyển phát thông điệp được bao chứa bên trong.\nCẢNH BÁO NGHIÊM TRỌNG: Đặc tả này chỉ áp dụng cho Delivery Instructions (chỉ dẫn phân phối) bên trong Garlic Cloves. \u0026ldquo;Delivery Instructions\u0026rdquo; cũng được dùng bên trong Tunnel Messages (các thông điệp trong tunnel), nơi định dạng khác biệt đáng kể. Xem Đặc tả Tunnel Message để biết Delivery Instructions cho tunnel. KHÔNG được nhầm lẫn hai định dạng này.\nĐịnh dạng:\nKhóa phiên và độ trễ không được sử dụng và không bao giờ xuất hiện, vì vậy có ba độ dài khả dĩ: - 1 byte (LOCAL) - 33 byte (ROUTER và DESTINATION) - 37 byte (TUNNEL)\n+----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds Độ dài điển hình: - Giao tới LOCAL: 1 byte (chỉ cờ) - Giao tới ROUTER / DESTINATION: 33 byte (cờ + giá trị băm) - Giao tới TUNNEL: 37 byte (cờ + giá trị băm + tunnel ID)\nMô tả các kiểu chuyển giao:\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router **Ghi chú triển khai:** - Mã hóa khóa phiên chưa được triển khai và bit cờ luôn là 0 - Độ trễ chưa được triển khai đầy đủ và bit cờ luôn là 0 - Đối với chuyển phát TUNNEL, hàm băm xác định gateway router (router cổng) và tunnel ID chỉ ra tunnel vào nào - Đối với chuyển phát DESTINATION, hàm băm là SHA-256 của khóa công khai của đích - Đối với chuyển phát ROUTER, hàm băm là SHA-256 của định danh của router Các thông điệp I2NP Đặc tả thông điệp hoàn chỉnh cho mọi loại thông điệp I2NP.\nTóm tắt các loại thông điệp Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active **Dành riêng:** - Loại 0: Dành riêng - Các loại 4-9: Dành riêng cho sử dụng trong tương lai - Các loại 12-17: Dành riêng cho sử dụng trong tương lai - Các loại 224-254: Dành riêng cho các thông điệp thử nghiệm - Loại 255: Dành riêng cho mở rộng trong tương lai DatabaseStore (thông điệp lưu trữ cơ sở dữ liệu) (Loại 1) Mục đích: Một lần lưu trữ cơ sở dữ liệu không được yêu cầu, hoặc phản hồi cho một thông điệp DatabaseLookup thành công.\nNội dung: Một LeaseSet, LeaseSet2, MetaLeaseSet hoặc EncryptedLeaseSet không nén, hoặc một RouterInfo được nén.\nĐịnh dạng với token phản hồi:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet Định dạng với reply token == 0:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// Mã nguồn: - net.i2p.data.i2np.DatabaseStoreMessage - net.i2p.data.RouterInfo (cho cấu trúc RouterInfo — thông tin router) - net.i2p.data.LeaseSet (cho cấu trúc LeaseSet — tập hợp lease)\nDatabaseLookup (Tra cứu cơ sở dữ liệu, Loại 2) Mục đích: Một yêu cầu để tra cứu một mục trong cơ sở dữ liệu mạng (netDb). Phản hồi có thể là DatabaseStore hoặc DatabaseSearchReply.\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) Chế độ mã hóa phản hồi:\nLƯU Ý: ElGamal routers không còn được khuyến nghị kể từ API 0.9.58. Vì phiên bản floodfill tối thiểu được khuyến nghị để truy vấn hiện là 0.9.58, các triển khai không cần thực hiện mã hóa cho ElGamal floodfill routers. Các điểm đến ElGamal vẫn được hỗ trợ.\nBit cờ 4 (ECIESFlag) được dùng cùng với bit 1 (encryptionFlag) để xác định chế độ mã hóa phản hồi:\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future **Không mã hóa (cờ 0,0):** reply_key, tags và reply_tags không có.\nElG (ElGamal) sang ElG (cờ 0,1) - ĐÃ LỖI THỜI:\nĐược hỗ trợ từ 0.9.7, bị đánh dấu là không khuyến nghị sử dụng (deprecated) từ 0.9.58.\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES sang ElG (flags 1,0) - ĐÃ LỖI THỜI:\nĐược hỗ trợ từ 0.9.46, không còn được khuyến nghị sử dụng từ 0.9.58.\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data Phản hồi là một thông điệp ECIES Existing Session (thông điệp Phiên hiện có của ECIES) như được định nghĩa trong ECIES Specification :\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES sang ECIES (flags 1,0) - TIÊU CHUẨN HIỆN HÀNH:\nĐích ECIES (mã hóa khóa công khai dựa trên đường cong elliptic) hoặc router gửi một yêu cầu tra cứu đến một router ECIES. Được hỗ trợ kể từ 0.9.49.\nCùng định dạng như \u0026ldquo;ECIES to ElG\u0026rdquo; ở trên. Việc mã hóa thông điệp tra cứu được đặc tả trong ECIES Routers . Người yêu cầu là ẩn danh.\nECIES (Elliptic Curve Integrated Encryption Scheme - lược đồ mã hóa tích hợp đường cong elliptic) tới ECIES với DH (Diffie-Hellman - trao đổi khóa Diffie-Hellman) (cờ 1,1) - TƯƠNG LAI:\nChưa được xác định đầy đủ. Xem Đề xuất 156 .\nGhi chú: - Trước 0.9.16, khóa có thể thuộc về một RouterInfo hoặc LeaseSet (cùng không gian khóa, không có cờ để phân biệt) - Các phản hồi được mã hóa chỉ hữu ích khi phản hồi đi qua một tunnel - Số lượng thẻ đi kèm có thể lớn hơn một nếu các chiến lược tra cứu DHT (bảng băm phân tán) thay thế được triển khai - Khóa tra cứu và các khóa loại trừ là các giá trị băm \u0026ldquo;thật\u0026rdquo;, KHÔNG phải khóa định tuyến - Các kiểu 3, 5 và 7 (biến thể LeaseSet2) có thể được trả về kể từ 0.9.38. Xem Proposal 123 - Ghi chú về tra cứu thăm dò: Một tra cứu thăm dò được định nghĩa là trả về danh sách các giá trị băm không phải floodfill gần với khóa. Tuy nhiên, các bản triển khai khác nhau: Java có tra cứu khóa tìm kiếm cho một RI (RouterInfo) và trả về một DatabaseStore nếu có; i2pd thì không. Do đó, không khuyến nghị dùng tra cứu thăm dò cho các giá trị băm đã nhận trước đó\nMã nguồn: - net.i2p.data.i2np.DatabaseLookupMessage - Mã hóa: net.i2p.crypto.SessionKeyManager\nDatabaseSearchReply (Phản hồi tìm kiếm cơ sở dữ liệu) (Loại 3) Mục đích: Phản hồi đối với một thông điệp DatabaseLookup thất bại.\nNội dung: Danh sách các băm của router gần nhất với khóa được yêu cầu.\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from Ghi chú: - \u0026lsquo;from\u0026rsquo; hash không được xác thực và không thể tin cậy - Các băm của peer (nút ngang hàng) được trả về không nhất thiết gần với khóa hơn so với router đang được truy vấn. Đối với các phản hồi cho tra cứu thông thường, điều này giúp khám phá các floodfill mới và tìm kiếm \u0026ldquo;ngược\u0026rdquo; (xa khóa hơn) để tăng độ bền vững - Đối với các tra cứu thăm dò, khóa thường được tạo ngẫu nhiên. non-floodfill peer_hashes trong phản hồi có thể được chọn bằng một thuật toán được tối ưu (ví dụ: các peer ở gần nhưng không nhất thiết là gần nhất) để tránh phải sắp xếp kém hiệu quả toàn bộ cơ sở dữ liệu cục bộ. Cũng có thể sử dụng các chiến lược lưu đệm. Điều này phụ thuộc vào triển khai - Số lượng băm trả về điển hình: 3 - Số lượng băm tối đa khuyến nghị để trả về: 16 - Khóa tra cứu, các băm của peer, và \u0026lsquo;from\u0026rsquo; hash là các băm \u0026ldquo;thực\u0026rdquo;, KHÔNG PHẢI các khóa định tuyến - Nếu num là 0, điều này cho biết không tìm thấy các peer gần hơn (ngõ cụt)\nMã nguồn: - net.i2p.data.i2np.DatabaseSearchReplyMessage\nDeliveryStatus (trạng thái giao nhận) (Loại 10) Mục đích: Một xác nhận thông điệp đơn giản. Thường do bên khởi tạo thông điệp tạo ra và được bọc trong một Garlic Message (dạng thông điệp Garlic trong I2P) cùng với chính thông điệp, để được phía đích trả lại.\nNội dung: ID của thông điệp đã được giao và thời điểm tạo hoặc thời điểm đến.\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered Ghi chú: - Dấu thời gian luôn được bên tạo đặt thành thời gian hiện tại. Tuy nhiên, có một số nơi trong mã nguồn đang sử dụng mục này, và có thể sẽ bổ sung thêm trong tương lai - Thông điệp này cũng được dùng như một xác nhận đã thiết lập phiên trong SSU. Trong trường hợp này, message ID được đặt thành một số ngẫu nhiên, và \u0026ldquo;arrival time\u0026rdquo; được đặt thành ID toàn mạng hiện tại, là 2 (tức 0x0000000000000002) - DeliveryStatus (thông điệp trạng thái giao nhận) thường được gói trong một GarlicMessage (kiểu thông điệp Garlic trong I2P) và gửi qua tunnel để cung cấp xác nhận mà không tiết lộ người gửi - Dùng để kiểm thử tunnel nhằm đo độ trễ và độ tin cậy\nMã nguồn: - net.i2p.data.i2np.DeliveryStatusMessage - Được dùng trong: net.i2p.router.tunnel.InboundEndpointProcessor để kiểm thử tunnel\nGarlicMessage (thông điệp Garlic trong I2P) (Loại 11) CẢNH BÁO: Đây là định dạng được dùng cho garlic messages (thông điệp \u0026ldquo;garlic\u0026rdquo; trong I2P) mã hóa bằng ElGamal. Định dạng cho garlic messages ECIES-AEAD-X25519-Ratchet khác biệt đáng kể. Xem Đặc tả ECIES để biết định dạng hiện đại.\nMục đích: Được dùng để bao gói nhiều thông điệp I2NP đã được mã hóa.\nNội dung: Khi được giải mã, một chuỗi Garlic Cloves (các clove - tiểu thông điệp) và dữ liệu bổ sung, còn được gọi là một Clove Set (tập hợp các clove).\nĐịnh dạng được mã hóa:\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data Dữ liệu đã giải mã (Clove Set - tập hợp các \u0026ldquo;clove\u0026rdquo; trong garlic encryption):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) Đối với định dạng ECIES-X25519-AEAD-Ratchet (tiêu chuẩn hiện tại cho routers):\nXem Đặc tả ECIES và Đề xuất 144 .\nMã nguồn: - net.i2p.data.i2np.GarlicMessage - Mã hóa: net.i2p.crypto.elgamal.ElGamalAESEngine (đã lỗi thời) - Mã hóa hiện đại: net.i2p.crypto.ECIES các gói\nTunnelData (Loại 18) Mục đích: Một thông điệp được gửi từ cổng của một tunnel hoặc một thành viên tới thành viên tiếp theo hoặc điểm cuối. Dữ liệu có độ dài cố định, chứa các thông điệp I2NP được phân mảnh, gom theo lô, đệm và mã hóa.\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes Cấu trúc Payload (phần dữ liệu hữu ích) (1024 byte):\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) Ghi chú: - ID thông điệp I2NP cho TunnelData được đặt thành một số ngẫu nhiên mới tại mỗi hop (nút chuyển tiếp) - Định dạng thông điệp tunnel (bên trong dữ liệu đã mã hóa) được quy định trong Đặc tả Thông điệp tunnel - Mỗi hop giải mã một lớp bằng AES-256 ở chế độ CBC - IV (vector khởi tạo) được cập nhật tại mỗi hop bằng cách sử dụng dữ liệu đã giải mã - Tổng kích thước chính xác là 1,028 byte (4 tunnelId + 1024 data) - Đây là đơn vị cơ bản của lưu lượng tunnel - Các thông điệp TunnelData mang các thông điệp I2NP bị phân mảnh (GarlicMessage, DatabaseStore, v.v.)\nMã nguồn: - net.i2p.data.i2np.TunnelDataMessage - Hằng số: TunnelDataMessage.DATA_LENGTH = 1024 - Xử lý: net.i2p.router.tunnel.InboundGatewayProcessor\nTunnelGateway (Loại 19) Mục đích: Bao bọc một thông điệp I2NP khác để gửi vào một tunnel tại cổng vào của tunnel.\nĐịnh dạng:\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message Ghi chú: - Nội dung (payload) là một thông điệp I2NP với phần đầu chuẩn 16 byte - Dùng để chèn các thông điệp vào tunnel từ router cục bộ - Cổng sẽ phân mảnh thông điệp đính kèm nếu cần - Sau khi phân mảnh, các mảnh được bao gói trong các thông điệp TunnelData - TunnelGateway không bao giờ được gửi qua mạng; đây là một kiểu thông điệp nội bộ được dùng trước khi xử lý tunnel\nMã nguồn: - net.i2p.data.i2np.TunnelGatewayMessage - Xử lý: net.i2p.router.tunnel.OutboundGatewayProcessor\nDataMessage (Loại 20) Mục đích: Được sử dụng bởi Garlic Messages (thông điệp Garlic trong I2P) và Garlic Cloves (các clove—thành phần con trong thông điệp Garlic) để đóng gói dữ liệu tùy ý (thông thường là dữ liệu ứng dụng được mã hóa đầu-cuối).\nĐịnh dạng:\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message Ghi chú: - Thông điệp này không chứa thông tin định tuyến và sẽ không bao giờ được gửi ở dạng \u0026ldquo;unwrapped\u0026rdquo; - Chỉ được dùng bên trong Garlic messages (thông điệp Garlic) - Thường chứa dữ liệu ứng dụng được mã hóa đầu-cuối (HTTP, IRC, email, v.v.) - Dữ liệu thường là một tải trọng được mã hóa bằng ElGamal/AES hoặc ECIES - Độ dài thực tế tối đa khoảng 61.2 KB do giới hạn phân mảnh thông điệp tunnel\nMã nguồn: - net.i2p.data.i2np.DataMessage\nTunnelBuild (Loại 21) ĐÃ LỖI THỜI. Hãy dùng VariableTunnelBuild (type 23) hoặc ShortTunnelBuild (type 25).\nMục đích: Yêu cầu xây dựng tunnel có độ dài cố định gồm 8 hop (chặng).\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes Ghi chú: - Kể từ 0.9.48, có thể chứa ECIES-X25519 BuildRequestRecords. Xem Tạo tunnel ECIES - Xem Đặc tả tạo tunnel để biết chi tiết - ID thông điệp I2NP cho thông điệp này phải được đặt theo đặc tả tạo tunnel - Mặc dù hiếm khi thấy trong mạng hiện nay (được thay thế bởi VariableTunnelBuild), nó vẫn có thể được dùng cho các tunnel rất dài và chưa bị loại bỏ một cách chính thức - Các router vẫn phải triển khai điều này để tương thích - Định dạng cố định 8-bản ghi thiếu linh hoạt và lãng phí băng thông đối với các tunnel ngắn hơn\nMã nguồn: - net.i2p.data.i2np.TunnelBuildMessage - Hằng số: TunnelBuildMessageBase.MAX_RECORD_COUNT = 8\nTunnelBuildReply (Loại 22) ĐÃ LỖI THỜI. Hãy dùng VariableTunnelBuildReply (loại 24) hoặc OutboundTunnelBuildReply (loại 26).\nMục đích: Phản hồi xây dựng tunnel có độ dài cố định cho 8 chặng.\nĐịnh dạng:\nCùng định dạng như TunnelBuildMessage, với BuildResponseRecords thay cho BuildRequestRecords.\nTotal size: 8 × 528 = 4,224 bytes Ghi chú: - Kể từ 0.9.48, có thể chứa ECIES-X25519 BuildResponseRecords (các bản ghi phản hồi trong quá trình xây dựng). Xem Tạo tunnel bằng ECIES - Xem Đặc tả tạo tunnel để biết chi tiết - ID thông điệp I2NP cho thông điệp này phải được đặt theo đặc tả tạo tunnel - Mặc dù hiếm gặp trên mạng hiện nay (được thay thế bởi VariableTunnelBuildReply (thông điệp phản hồi xây dựng tunnel biến độ dài)), nó vẫn có thể được dùng cho các tunnel rất dài và chưa bị loại bỏ chính thức - Các router vẫn phải triển khai điều này để đảm bảo khả năng tương thích\nMã nguồn: - net.i2p.data.i2np.TunnelBuildReplyMessage\nVariableTunnelBuild (Xây dựng tunnel biến thiên) (Loại 23) Mục đích: Xây dựng tunnel có độ dài thay đổi từ 1 đến 8 hops (bước nhảy). Hỗ trợ cả routers ElGamal và ECIES-X25519.\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Ghi chú: - Kể từ 0.9.48, có thể chứa ECIES-X25519 BuildRequestRecords (bản ghi yêu cầu xây dựng). Xem Tạo Tunnel ECIES - Được giới thiệu trong phiên bản router 0.7.12 (2009) - Không được gửi tới các thành viên tunnel chạy phiên bản trước 0.7.12 - Xem Đặc tả Tạo Tunnel để biết chi tiết - ID thông điệp I2NP phải được đặt theo đặc tả tạo tunnel - Số lượng bản ghi điển hình: 4 (đối với một tunnel 4-hop) - Kích thước tổng điển hình: 1 + (4 × 528) = 2,113 byte - Đây là thông điệp xây dựng tunnel tiêu chuẩn cho các router ElGamal - Các router ECIES thường sử dụng ShortTunnelBuild (loại 25) thay vào đó\nMã nguồn: - net.i2p.data.i2np.VariableTunnelBuildMessage\nVariableTunnelBuildReply (Loại 24) Mục đích: Phản hồi xây dựng tunnel có độ dài biến thiên cho 1–8 chặng. Hỗ trợ cả routers ElGamal và ECIES-X25519.\nĐịnh dạng:\nCùng định dạng như VariableTunnelBuildMessage, nhưng dùng BuildResponseRecords thay cho BuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Ghi chú: - Kể từ 0.9.48, có thể chứa ECIES-X25519 BuildResponseRecords (bản ghi phản hồi xây dựng). Xem Tạo Tunnel bằng ECIES - Được giới thiệu trong phiên bản router 0.7.12 (2009) - Có thể không được gửi tới các thành viên tunnel dùng phiên bản trước 0.7.12 - Xem Đặc tả Tạo Tunnel để biết chi tiết - ID của thông điệp I2NP phải được đặt theo đặc tả tạo tunnel - Số lượng bản ghi điển hình: 4 - Tổng kích thước điển hình: 2,113 byte\nMã nguồn: - net.i2p.data.i2np.VariableTunnelBuildReplyMessage\nShortTunnelBuild (xây dựng tunnel rút gọn, Loại 25) Purpose: Thông điệp dựng tunnel dạng ngắn chỉ dành cho routers ECIES-X25519. Được giới thiệu trong phiên bản API 0.9.51 (phát hành 1.5.0, tháng 8 năm 2021). Đây là tiêu chuẩn hiện tại cho việc dựng tunnel ECIES.\nĐịnh dạng:\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Ghi chú: - Được giới thiệu trong phiên bản router 0.9.51 (phát hành 1.5.0, tháng 8/2021) - Có thể không được gửi tới các thành viên tunnel trước phiên bản API 0.9.51 - Xem Tạo Tunnel ECIES để biết đặc tả đầy đủ - Xem Đề xuất 157 để biết lý do - Số lượng bản ghi điển hình: 4 - Tổng kích thước điển hình: 1 + (4 × 218) = 873 bytes - Tiết kiệm băng thông: nhỏ hơn 59% so với VariableTunnelBuild (873 vs 2,113 bytes) - Lợi ích hiệu năng: 4 bản ghi ngắn vừa trong một tunnel message; VariableTunnelBuild cần 3 tunnel messages - Đây hiện là định dạng xây dựng tunnel tiêu chuẩn cho các tunnel ECIES-X25519 thuần túy (ECIES: sơ đồ mã hóa dựa trên đường cong elliptic; X25519: cơ chế trao đổi khóa Curve25519) - Các bản ghi suy dẫn khóa thông qua HKDF (hàm dẫn xuất khóa dựa trên HMAC), thay vì đưa chúng vào một cách tường minh\nMã nguồn: - net.i2p.data.i2np.ShortTunnelBuildMessage - Hằng số: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nOutboundTunnelBuildReply (Loại 26) Mục đích: Được gửi từ điểm cuối gửi đi của một tunnel mới đến bên khởi tạo. Chỉ áp dụng cho các router ECIES-X25519. Được giới thiệu trong phiên bản API 0.9.51 (bản phát hành 1.5.0, tháng 8 năm 2021).\nĐịnh dạng:\nCùng định dạng như ShortTunnelBuildMessage, với ShortBuildResponseRecords thay vì ShortBuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Ghi chú: - Được giới thiệu trong router phiên bản 0.9.51 (phát hành 1.5.0, tháng 8 năm 2021) - Xem ECIES Tunnel Creation để biết đặc tả đầy đủ - Số lượng bản ghi điển hình: 4 - Tổng kích thước điển hình: 873 byte - Phản hồi này được gửi từ outbound endpoint (điểm cuối hướng ra, OBEP) trở lại bên tạo tunnel thông qua tunnel hướng ra vừa được tạo - Cung cấp xác nhận rằng mọi nút trung gian đều đã chấp nhận việc dựng tunnel\nMã nguồn: - net.i2p.data.i2np.OutboundTunnelBuildReplyMessage\nTài liệu tham khảo Các đặc tả chính thức Đặc tả I2NP - Đặc tả đầy đủ về định dạng thông điệp I2NP Cấu trúc chung - Các kiểu dữ liệu và cấu trúc được sử dụng xuyên suốt I2P Tạo tunnel - Tạo tunnel ElGamal (đã lỗi thời) Tạo tunnel ECIES - Tạo tunnel ECIES-X25519 (hiện tại) Thông điệp tunnel - Định dạng thông điệp tunnel và hướng dẫn chuyển giao Đặc tả NTCP2 - Giao thức truyền tải TCP Đặc tả SSU2 - Giao thức truyền tải UDP Đặc tả ECIES - Mã hóa ECIES-X25519-AEAD-Ratchet Đặc tả mật mã - Các nguyên thủy mật mã cấp thấp Đặc tả I2CP - Đặc tả giao thức máy khách Đặc tả Datagram - Định dạng Datagram2 và Datagram3 Các đề xuất Đề xuất 123 - Các mục netDB mới (LeaseSet2, EncryptedLeaseSet, MetaLeaseSet) Đề xuất 144 - Mã hóa ECIES-X25519-AEAD-Ratchet Đề xuất 154 - Tra cứu cơ sở dữ liệu được mã hóa Đề xuất 156 - Các router ECIES Đề xuất 157 - Thông điệp xây dựng tunnel nhỏ hơn (định dạng ngắn) Đề xuất 159 - Giao thức truyền tải SSU2 Đề xuất 161 - Đệm có thể nén Đề xuất 163 - Datagram2 và Datagram3 Đề xuất 167 - Các tham số bản ghi dịch vụ LeaseSet Đề xuất 168 - Các tham số băng thông xây dựng tunnel Đề xuất 169 - Mật mã lai hậu lượng tử Tài liệu Định tuyến Garlic - Đóng gói thông điệp theo lớp ElGamal/AES - Lược đồ mã hóa không còn được khuyến nghị Triển khai Tunnel - Phân mảnh và xử lý Cơ sở dữ liệu mạng - Bảng băm phân tán Truyền tải NTCP2 - Đặc tả truyền tải TCP Truyền tải SSU2 - Đặc tả truyền tải UDP Giới thiệu kỹ thuật - Tổng quan kiến trúc I2P Mã nguồn Kho mã nguồn Java I2P - Triển khai Java chính thức Bản phản chiếu GitHub - Bản phản chiếu trên GitHub của Java I2P Kho mã nguồn i2pd - Triển khai C++ Các vị trí mã nguồn chính Java I2P (i2pgit.org/I2P_Developers/i2p.i2p): - core/java/src/net/i2p/data/i2np/ - Các triển khai thông điệp I2NP - core/java/src/net/i2p/crypto/ - Các triển khai mật mã - router/java/src/net/i2p/router/tunnel/ - Xử lý tunnel - router/java/src/net/i2p/router/transport/ - Các triển khai transport\nHằng số và giá trị: - I2NPMessage.MAX_SIZE = 65536 - Kích thước thông điệp I2NP tối đa - I2NPMessageImpl.HEADER_LENGTH = 16 - Kích thước phần đầu (header) tiêu chuẩn - TunnelDataMessage.DATA_LENGTH = 1024 - Phần tải của thông điệp Tunnel - EncryptedBuildRecord.RECORD_SIZE = 528 - Bản ghi xây dựng dài - ShortEncryptedBuildRecord.RECORD_SIZE = 218 - Bản ghi xây dựng ngắn - TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - Số bản ghi tối đa cho mỗi lần xây dựng\nPhụ lục A: Thống kê mạng và trạng thái hiện tại Thành phần của mạng (tính đến tháng 10 năm 2025) Tổng số router (nút I2P): Khoảng 60,000-70,000 (thay đổi) Router floodfill (nút lưu trữ netDb phân tán): Khoảng 500-700 đang hoạt động Các loại mã hóa: ECIES-X25519: \u0026gt;95% số router ElGamal: \u0026lt;5% số router (không còn được khuyến nghị, chỉ dành cho mục đích kế thừa) Mức độ sử dụng giao thức truyền tải: SSU2 (giao thức truyền tải dựa trên UDP thế hệ 2): \u0026gt;60% giao thức truyền tải chính NTCP2 (giao thức truyền tải dựa trên TCP thế hệ 2): ~40% giao thức truyền tải chính Giao thức truyền tải kế thừa (SSU1, NTCP): 0% (đã loại bỏ) Các loại chữ ký: EdDSA (Ed25519): Chiếm đại đa số ECDSA: Tỷ lệ nhỏ RSA: Không cho phép (đã loại bỏ) Yêu cầu tối thiểu cho Router Phiên bản API: 0.9.16+ (đảm bảo tương thích EdDSA với mạng) Mức khuyến nghị tối thiểu: API 0.9.51+ (các bản dựng tunnel (đường hầm) ngắn ECIES) Mức tối thiểu hiện tại cho floodfills (các router lưu trữ netDb): API 0.9.58+ (loại bỏ dần router ElGamal) Yêu cầu sắp tới: Java 17+ (kể từ bản phát hành 2.11.0, tháng 12/2025) Yêu cầu về băng thông Tối thiểu: 128 KBytes/sec (cờ N hoặc cao hơn) cho floodfill (chế độ nút lưu trữ netDb phân tán) Khuyến nghị: 256 KBytes/sec (cờ O) hoặc cao hơn Yêu cầu floodfill: Băng thông tối thiểu 128 KB/sec Thời gian hoạt động ổn định (\u0026gt;95% được khuyến nghị) Độ trễ thấp (\u0026lt;500ms tới các peer) Vượt qua các bài kiểm tra sức khỏe (thời gian hàng đợi, độ trễ tác vụ) Thống kê Tunnel Độ dài tunnel điển hình: 3-4 hop (chặng truyền) Độ dài tunnel tối đa: 8 hop (mang tính lý thuyết, hiếm khi dùng) Thời gian tồn tại điển hình của tunnel: 10 phút Tỷ lệ xây dựng tunnel thành công: \u0026gt;85% đối với các routers kết nối tốt Định dạng thông điệp xây dựng tunnel: Các routers ECIES: ShortTunnelBuild (bản ghi 218 byte) Các tunnel hỗn hợp: VariableTunnelBuild (bản ghi 528 byte) Các chỉ số hiệu năng Thời gian xây dựng Tunnel: 1-3 giây (điển hình) Độ trễ đầu-cuối: 0.5-2 giây (điển hình, 6-8 hop tổng cộng) Thông lượng: Bị giới hạn bởi băng thông tunnel (thường 10-50 KB/sec mỗi tunnel) Kích thước datagram tối đa: Khuyến nghị 10 KB (61.2 KB tối đa theo lý thuyết) Phụ lục B: Các tính năng đã ngừng hỗ trợ và đã bị loại bỏ Đã loại bỏ hoàn toàn (không còn được hỗ trợ) Giao thức truyền tải NTCP - Đã bị loại bỏ trong bản phát hành 0.9.50 (Tháng 5 năm 2021) Giao thức truyền tải SSU v1 - Đã bị loại bỏ khỏi Java I2P trong bản phát hành 2.4.0 (Tháng 12 năm 2023) Giao thức truyền tải SSU v1 - Đã bị loại bỏ khỏi i2pd trong bản phát hành 2.44.0 (Tháng 11 năm 2022) Các loại chữ ký RSA - Không được phép kể từ API 0.9.28 Đã lỗi thời (vẫn được hỗ trợ nhưng không khuyến nghị) router ElGamal - Ngừng sử dụng kể từ API 0.9.58 (tháng 3 năm 2023) Các đích ElGamal vẫn được hỗ trợ để bảo đảm tương thích ngược Các router mới nên chỉ sử dụng ECIES-X25519 TunnelBuild (type 21) - Ngừng sử dụng, thay bằng VariableTunnelBuild và ShortTunnelBuild Vẫn được triển khai cho các tunnel rất dài (\u0026gt;8 hop) TunnelBuildReply (type 22) - Ngừng sử dụng, thay bằng VariableTunnelBuildReply và OutboundTunnelBuildReply Mã hóa ElGamal/AES - Ngừng sử dụng, thay bằng ECIES-X25519-AEAD-Ratchet Vẫn được dùng cho các đích cũ BuildRequestRecords ECIES dạng dài (528 byte) - Ngừng sử dụng, thay bằng định dạng ngắn (218 byte) Vẫn được dùng cho các tunnel hỗn hợp có hop ElGamal Lộ trình hỗ trợ các phiên bản cũ Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels --- Phụ lục C: Các phát triển trong tương lai Mật mã hậu lượng tử Trạng thái: Beta kể từ bản phát hành 2.10.0 (tháng 9 năm 2025), sẽ trở thành mặc định trong bản 2.11.0 (tháng 12 năm 2025)\nTriển khai: - Cách tiếp cận lai kết hợp X25519 cổ điển và MLKEM hậu lượng tử (ML-KEM-768) - Tương thích ngược với cơ sở hạ tầng ECIES-X25519 hiện có - Sử dụng Signal Double Ratchet (thuật toán Ratchet kép của Signal) với cả vật liệu khóa cổ điển và PQ (hậu lượng tử) - Xem Đề xuất 169 để biết chi tiết\nLộ trình chuyển đổi: 1. Bản phát hành 2.10.0 (Tháng 9 năm 2025): Có sẵn dưới dạng tùy chọn beta 2. Bản phát hành 2.11.0 (Tháng 12 năm 2025): Được bật theo mặc định 3. Các bản phát hành tương lai: Cuối cùng sẽ trở thành bắt buộc\nCác tính năng dự kiến Cải tiến IPv6 - Hỗ trợ IPv6 tốt hơn và các cơ chế chuyển đổi Giới hạn băng thông theo từng tunnel - Kiểm soát băng thông chi tiết theo từng tunnel Cải tiến số liệu đo lường - Giám sát hiệu năng và chẩn đoán tốt hơn Tối ưu hóa giao thức - Giảm chi phí phụ trội và cải thiện hiệu quả Cải thiện lựa chọn floodfill - Phân phối netDb tốt hơn Các lĩnh vực nghiên cứu Tối ưu hóa độ dài Tunnel - Độ dài Tunnel động dựa trên mô hình đe dọa Đệm nâng cao - Cải thiện khả năng chống phân tích lưu lượng Các sơ đồ mã hóa mới - Chuẩn bị cho các mối đe dọa từ điện toán lượng tử Kiểm soát tắc nghẽn - Xử lý tải mạng tốt hơn Hỗ trợ di động - Tối ưu hóa cho thiết bị và mạng di động Phụ lục D: Hướng dẫn triển khai Dành cho các triển khai mới Yêu cầu tối thiểu: 1. Hỗ trợ các tính năng của API phiên bản 0.9.51+ 2. Triển khai mã hóa ECIES-X25519-AEAD-Ratchet (thuật toán mã hóa lai ECIES dùng X25519, AEAD và cơ chế ratchet) 3. Hỗ trợ các giao thức truyền tải NTCP2 và SSU2 4. Triển khai các thông điệp ShortTunnelBuild (thông điệp xây dựng tunnel dạng rút gọn; bản ghi 218 byte) 5. Hỗ trợ các biến thể LeaseSet2 (kiểu 3, 5, 7) 6. Sử dụng chữ ký EdDSA (Ed25519)\nKhuyến nghị: 1. Hỗ trợ post-quantum hybrid cryptography (mật mã lai hậu lượng tử) (kể từ 2.11.0) 2. Triển khai các tham số băng thông theo tunnel 3. Hỗ trợ các định dạng Datagram2 và Datagram3 4. Triển khai các tùy chọn bản ghi dịch vụ trong LeaseSets 5. Tuân theo các đặc tả chính thức tại /docs/specs/\nKhông bắt buộc: 1. Hỗ trợ router ElGamal (không còn được khuyến nghị) 2. Hỗ trợ transport cũ (SSU1, NTCP) 3. BuildRequestRecords ECIES loại dài (528 byte cho các tunnel ECIES thuần túy) 4. Các thông điệp TunnelBuild/TunnelBuildReply (sử dụng các biến thể Variable hoặc Short)\nKiểm thử và thẩm định Tuân thủ giao thức: 1. Kiểm thử khả năng tương tác với router I2P Java chính thức 2. Kiểm thử khả năng tương tác với router i2pd C++ 3. Xác minh định dạng thông điệp đối chiếu với đặc tả 4. Kiểm thử các chu kỳ thiết lập/hủy tunnel 5. Xác minh mã hóa/giải mã bằng các test vectors (bộ vector kiểm thử tiêu chuẩn)\nKiểm thử hiệu năng: 1. Đo tỷ lệ thành công khi xây dựng tunnel (nên \u0026gt;85%) 2. Kiểm thử với các độ dài tunnel khác nhau (2-8 chặng (hop)) 3. Xác minh phân mảnh và tái lắp ráp 4. Kiểm thử dưới tải (nhiều tunnels đồng thời) 5. Đo độ trễ đầu-cuối\nKiểm thử bảo mật: 1. Xác minh triển khai mã hóa (sử dụng test vectors (bộ giá trị kiểm thử chuẩn)) 2. Kiểm thử cơ chế ngăn chặn tấn công phát lại 3. Xác thực cơ chế xử lý hết hạn thông điệp 4. Kiểm thử đối với thông điệp sai định dạng 5. Xác minh việc tạo số ngẫu nhiên đúng cách\nNhững cạm bẫy thường gặp khi hiện thực Định dạng chỉ dẫn chuyển giao gây nhầm lẫn - Garlic clove (một “nhánh” trong cơ chế garlic) vs thông điệp tunnel Dẫn xuất khóa không đúng - Cách dùng HKDF cho bản ghi build dạng ngắn Xử lý Message ID - Không thiết lập đúng cho việc build tunnel Vấn đề phân mảnh - Không tuân thủ giới hạn thực tế 61.2 KB Lỗi thứ tự byte - Java dùng big-endian cho mọi số nguyên Xử lý hết hạn - Định dạng ngắn sẽ quay vòng vào ngày 7 tháng 2 năm 2106 Tạo checksum - Vẫn bắt buộc ngay cả khi không được xác minh ","description":"Các định dạng thông điệp từ router đến router, mức độ ưu tiên và giới hạn kích thước bên trong I2P.","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"Giao thức mạng I2P (I2NP)","url":"/vi/docs/specs/i2np/"},{"categories":null,"content":"Tổng quan I2CP là giao thức điều khiển cấp thấp giữa một I2P router và bất kỳ tiến trình khách nào. Nó xác định một sự phân tách trách nhiệm nghiêm ngặt:\nRouter: Quản lý định tuyến, mật mã học, vòng đời tunnel, và các thao tác cơ sở dữ liệu mạng Ứng dụng khách: Chọn các thuộc tính ẩn danh, cấu hình tunnels, và gửi/nhận thông điệp Tất cả giao tiếp diễn ra qua một socket TCP duy nhất (tùy chọn được bọc TLS), cho phép các hoạt động bất đồng bộ, song công hoàn toàn.\nPhiên bản giao thức: I2CP sử dụng một byte phiên bản giao thức 0x2A (42 ở dạng thập phân) được gửi trong quá trình thiết lập kết nối ban đầu. Byte phiên bản này đã giữ ổn định kể từ khi giao thức ra đời.\nTrạng thái hiện tại: Đặc tả này áp dụng chính xác cho router phiên bản 0.9.67 (phiên bản API 0.9.67), phát hành vào 2025-09.\nNgữ cảnh triển khai Hiện thực bằng Java Bản triển khai tham chiếu nằm trong Java I2P: - SDK phía client: gói i2p.jar - Phần triển khai Router: gói router.jar - Javadocs Khi ứng dụng khách và router chạy trong cùng một JVM, các thông điệp I2CP được truyền dưới dạng đối tượng Java mà không cần tuần tự hóa. Các ứng dụng khách bên ngoài sử dụng giao thức đã tuần tự hóa qua TCP.\nTriển khai bằng C++ i2pd (router I2P viết bằng C++) cũng triển khai I2CP bên ngoài để phục vụ các kết nối của máy khách.\nCác ứng dụng khách không dùng Java Hiện không có triển khai không dùng Java nào đã biết cho một thư viện client I2CP hoàn chỉnh. Các ứng dụng không dùng Java nên thay vào đó sử dụng các giao thức cấp cao hơn:\nSAM (Nhắn tin ẩn danh đơn giản) v3: Giao diện dựa trên socket với các thư viện cho nhiều ngôn ngữ BOB (Cầu mở cơ bản): Giải pháp thay thế đơn giản hơn cho SAM Các giao thức cấp cao hơn này tự xử lý sự phức tạp của I2CP bên trong và đồng thời cung cấp thư viện streaming (cho các kết nối kiểu TCP) và thư viện datagram (cho các kết nối kiểu UDP).\nThiết lập kết nối 1. Kết nối TCP Kết nối tới cổng I2CP của router: - Mặc định: 127.0.0.1:7654 - Có thể cấu hình qua cài đặt của router - Lớp bọc TLS tùy chọn (rất khuyến nghị cho các kết nối từ xa)\n2. Bắt tay giao thức Bước 1: Gửi byte phiên bản giao thức 0x2A\nBước 2: Đồng bộ thời gian\nClient → Router: GetDateMessage Router → Client: SetDateMessage router trả về dấu thời gian hiện tại của nó và chuỗi phiên bản I2CP API (kể từ 0.8.7).\nBước 3: Xác thực (nếu được bật)\nKể từ 0.9.11, xác thực có thể được đưa vào GetDateMessage (thông điệp lấy ngày/giờ) thông qua một Mapping (ánh xạ) chứa: - i2cp.username - i2cp.password\nTừ phiên bản 0.9.16, khi tính năng xác thực được bật, việc xác thực phải được hoàn tất thông qua GetDateMessage trước khi bất kỳ bản tin nào khác được gửi đi.\nBước 4: Tạo phiên\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) Bước 5: Tín hiệu sẵn sàng của tunnel\nRouter → Client: RequestVariableLeaseSetMessage Thông báo này cho biết rằng các tunnel vào đã được thiết lập. Router sẽ KHÔNG gửi thông báo này cho đến khi có ít nhất một tunnel vào VÀ một tunnel ra tồn tại.\nBước 6: Công bố LeaseSet\nClient → Router: CreateLeaseSet2Message Lúc này, phiên đã hoạt động hoàn toàn để gửi và nhận thông điệp.\nCác mẫu luồng thông điệp Thông điệp gửi đi (Máy khách gửi tới điểm đến từ xa) Với i2cp.messageReliability=none:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] Với i2cp.messageReliability=BestEffort:\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) Thông điệp đến (Router giao cho ứng dụng khách) Với i2cp.fastReceive=true (mặc định từ 0.9.4):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] Với i2cp.fastReceive=false (ĐÃ LỖI THỜI):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage Các máy khách hiện đại nên luôn sử dụng chế độ nhận nhanh.\nCác cấu trúc dữ liệu phổ biến Phần đầu bản tin I2CP Tất cả các thông điệp I2CP sử dụng phần đầu chung này:\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ Độ dài phần thân: Số nguyên 4 byte, chỉ độ dài của phần thân thông điệp (không bao gồm phần tiêu đề) Loại: Số nguyên 1 byte, định danh kiểu thông điệp Phần thân thông điệp: 0+ byte, định dạng thay đổi theo loại thông điệp Giới hạn kích thước thông điệp: Tối đa khoảng 64 KB.\nID phiên Số nguyên 2 byte dùng để định danh duy nhất một phiên trên một router.\nGiá trị đặc biệt: 0xFFFF cho biết \u0026ldquo;không có phiên\u0026rdquo; (được dùng khi tra cứu tên máy chủ mà chưa có phiên được thiết lập).\nID thông điệp Số nguyên 4 byte được router tạo ra để định danh duy nhất một thông điệp trong một phiên.\nQuan trọng: ID thông điệp không duy nhất ở phạm vi toàn cục, mà chỉ duy nhất trong phạm vi một phiên. Chúng cũng khác với nonce (giá trị ngẫu nhiên dùng một lần) do máy khách tạo ra.\nĐịnh dạng payload (dữ liệu tải) Nội dung thông điệp (payload) được nén bằng gzip với header gzip chuẩn 10 byte: - Bắt đầu bằng: 0x1F 0x8B 0x08 (RFC 1952) - Kể từ 0.7.1: Các phần chưa dùng của header gzip chứa thông tin về giao thức, from-port (cổng nguồn) và to-port (cổng đích) - Điều này cho phép truyền phát và các datagram (gói tin không kết nối) trên cùng một đích\nĐiều khiển nén: Đặt i2cp.gzip=false để tắt nén (đặt mức nỗ lực gzip về 0). Phần đầu gzip vẫn được bao gồm, nhưng với chi phí phụ trội do nén ở mức tối thiểu.\nCấu trúc SessionConfig (cấu hình phiên) Định nghĩa cấu hình cho một phiên máy khách:\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ Yêu cầu quan trọng: 1. Ánh xạ phải được sắp xếp theo khóa để xác minh chữ ký 2. Ngày tạo phải nằm trong ±30 giây so với thời gian hiện tại của router 3. Chữ ký được tạo bởi SigningPrivateKey của Destination (địa chỉ đích trong I2P)\nChữ ký ngoại tuyến (tính đến 0.9.38):\nNếu sử dụng ký ngoại tuyến, Mapping (bản ánh xạ) phải chứa: - i2cp.leaseSetOfflineExpiration - i2cp.leaseSetTransientPublicKey - i2cp.leaseSetOfflineSignature\nSau đó, Signature được tạo bởi SigningPrivateKey tạm thời.\nCác tùy chọn cấu hình cốt lõi Cấu hình Tunnel Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) **Ghi chú**: - Các giá trị của `quantity` \u003e 6 yêu cầu các peer chạy 0.9.0+ và làm tăng đáng kể mức sử dụng tài nguyên - Đặt `backupQuantity` thành 1-2 cho các dịch vụ có tính sẵn sàng cao - Các tunnels 0-hop đánh đổi ẩn danh để giảm độ trễ nhưng hữu ích cho việc thử nghiệm Xử lý thông điệp Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) **Độ tin cậy của thông điệp**: - `None`: Không có xác nhận từ router (mặc định của thư viện streaming kể từ 0.8.1) - `BestEffort`: Router gửi thông báo chấp nhận + thành công/thất bại - `Guaranteed`: Chưa được triển khai (hiện hoạt động giống BestEffort) Ghi đè theo từng thông điệp (kể từ 0.9.14): - Trong một phiên với messageReliability=none, đặt một nonce (giá trị ngẫu nhiên dùng một lần) khác 0 sẽ yêu cầu thông báo đã giao cho thông điệp cụ thể đó - Đặt nonce=0 trong một phiên BestEffort sẽ tắt thông báo cho thông điệp đó\nCấu hình LeaseSet Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) ### Thẻ phiên ElGamal/AES kiểu cũ Các tùy chọn này chỉ áp dụng cho mã hóa ElGamal kiểu cũ:\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch **Lưu ý**: Các máy khách ECIES-X25519 sử dụng một cơ chế ratchet (cơ chế cập nhật khóa dần theo từng bước) khác và bỏ qua các tùy chọn này. Các loại mã hóa I2CP hỗ trợ nhiều cơ chế mã hóa đầu-cuối thông qua tùy chọn i2cp.leaseSetEncType. Có thể chỉ định nhiều loại (phân tách bằng dấu phẩy) để hỗ trợ cả các peer (nút ngang hàng) hiện đại và tương thích cũ.\nCác loại mã hóa được hỗ trợ Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned **Cấu hình khuyến nghị**: i2cp.leaseSetEncType=4,0 Điều này cung cấp X25519 (thuật toán trao đổi khóa dựa trên đường cong elliptic Curve25519; được ưu tiên) cùng với phương án dự phòng ElGamal (lược đồ mật mã khóa công khai) để bảo đảm khả năng tương thích.\nChi tiết về kiểu mã hóa Loại 0 - ElGamal/AES+SessionTags (thẻ phiên): - khóa công khai ElGamal 2048-bit (256 byte) - mã hóa đối xứng AES-256 - session tags 32 byte được gửi theo từng lô - mức tiêu tốn CPU, băng thông và bộ nhớ cao - đang được loại bỏ dần trên toàn mạng\nLoại 4 - ECIES-X25519-AEAD-Ratchet: - Trao đổi khóa X25519 (khóa 32 byte) - ChaCha20/Poly1305 AEAD - Double ratchet kiểu Signal (cơ chế tăng tiến khóa kép kiểu Signal) - Thẻ phiên 8 byte (so với 32 byte của ElGamal) - Thẻ được tạo qua PRNG đồng bộ (không gửi trước) - Giảm overhead ~92% so với ElGamal - Tiêu chuẩn cho I2P hiện đại (hầu hết routers dùng cơ chế này)\nLoại 5-6 - Post-Quantum Hybrid (lai hậu lượng tử): - Kết hợp X25519 với ML-KEM (NIST FIPS 203) - Cung cấp bảo mật kháng lượng tử - ML-KEM-768 cho cân bằng giữa bảo mật/hiệu năng - ML-KEM-1024 cho mức bảo mật tối đa - Kích thước thông điệp lớn hơn do thành phần khóa hậu lượng tử (PQ) - Hỗ trợ ở cấp độ mạng vẫn đang được triển khai\nChiến lược di chuyển Mạng I2P đang tích cực chuyển đổi từ ElGamal (loại 0) sang X25519 (loại 4):\nNTCP → NTCP2 (đã hoàn tất) SSU → SSU2 (đã hoàn tất) ElGamal tunnels → X25519 tunnels (đã hoàn tất) ElGamal đầu-cuối → ECIES-X25519 (phần lớn đã hoàn tất) LeaseSet2 và các tính năng nâng cao Tùy chọn LeaseSet2 (định dạng LeaseSet thế hệ thứ hai) (kể từ 0.9.38) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) ### Địa chỉ bị làm mù Kể từ 0.9.39, các đích (Destination) có thể sử dụng các địa chỉ \u0026ldquo;blinded\u0026rdquo; (địa chỉ được làm mù) (định dạng b33) thay đổi định kỳ: - Yêu cầu i2cp.leaseSetSecret để bảo vệ bằng mật khẩu - Tùy chọn xác thực theo từng máy khách - Xem các đề xuất 123 và 149 để biết chi tiết\nBản ghi dịch vụ (từ 0.9.66) LeaseSet2 hỗ trợ các tùy chọn bản ghi dịch vụ (đề xuất 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p Định dạng tuân theo kiểu bản ghi DNS SRV nhưng đã được điều chỉnh cho I2P.\nNhiều phiên (từ 0.9.21) Một kết nối I2CP duy nhất có thể duy trì nhiều phiên:\nPhiên chính: Phiên đầu tiên được tạo trên một kết nối Các phiên phụ: Các phiên bổ sung chia sẻ nhóm tunnel của phiên chính\nCác đặc tính của Subsession (phiên con) Tunnels dùng chung: Sử dụng cùng các pool tunnel vào/ra như phiên chính Khóa mã hóa dùng chung: Phải dùng các khóa mã hóa LeaseSet giống hệt nhau Khóa ký khác nhau: Phải dùng các khóa ký của Destination (đích trong I2P) khác nhau Không có bảo đảm ẩn danh: Được liên kết rõ ràng với phiên chính (cùng router, cùng tunnels) Trường hợp sử dụng Subsession (phiên con) Cho phép giao tiếp với các đích sử dụng các loại chữ ký khác nhau: - Chính: chữ ký EdDSA (hiện đại) - Subsession (phiên phụ): chữ ký DSA (tương thích với hệ thống cũ)\nVòng đời Subsession (phiên con) Tạo lập:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) Hủy: - Hủy một phiên con: Giữ nguyên phiên chính - Hủy phiên chính: Hủy tất cả các phiên con và đóng kết nối - DisconnectMessage (Thông điệp ngắt kết nối): Hủy tất cả các phiên\nXử lý ID phiên Hầu hết các thông điệp I2CP chứa một trường Session ID. Ngoại lệ: - DestLookup / DestReply (đã lỗi thời, hãy dùng HostLookup / HostReply) - GetBandwidthLimits / BandwidthLimits (phản hồi không gắn với phiên)\nQuan trọng: Các ứng dụng khách không nên đồng thời có nhiều thông điệp CreateSession đang chờ xử lý, vì không thể đối chiếu một cách chắc chắn các phản hồi với các yêu cầu.\nDanh mục thông điệp Tóm tắt các loại thông điệp Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current **Chú giải**: C = Máy khách, R = Router Chi tiết chính của thông điệp CreateSessionMessage (thông điệp khởi tạo phiên) (Loại 1) Mục đích: Khởi tạo một phiên I2CP mới\nNội dung: Cấu trúc SessionConfig\nPhản hồi: SessionStatusMessage (status=Created hoặc Invalid)\nYêu cầu: - Date trong SessionConfig phải trong vòng ±30 giây so với thời gian của router - Bảng ánh xạ phải được sắp xếp theo khóa để xác minh chữ ký - Destination (đích trong I2P) không được có một phiên đang hoạt động từ trước\nRequestVariableLeaseSetMessage (Loại 37) Mục đích: Router yêu cầu máy khách ủy quyền cho các tunnel đầu vào\nNội dung: - ID phiên - Số lượng Lease (bản ghi thuê đường hầm trong I2P) - Mảng các cấu trúc Lease (mỗi cấu trúc có thời điểm hết hạn riêng)\nPhản hồi: CreateLeaseSet2Message (thông điệp tạo LeaseSet2)\nÝ nghĩa: Đây là tín hiệu cho biết phiên đang hoạt động. Router chỉ gửi điều này sau khi: 1. Ít nhất một tunnel vào đã được thiết lập 2. Ít nhất một tunnel ra đã được thiết lập\nKhuyến nghị về thời gian chờ: Các ứng dụng khách nên hủy phiên nếu không nhận được thông điệp này trong vòng từ 5 phút trở lên kể từ khi tạo phiên.\nCreateLeaseSet2Message (Loại 41) Mục đích: Ứng dụng khách công bố LeaseSet lên cơ sở dữ liệu mạng (netDb)\nNội dung: - ID phiên - byte loại LeaseSet (1, 3, 5, hoặc 7) - LeaseSet hoặc LeaseSet2 hoặc EncryptedLeaseSet hoặc MetaLeaseSet - Số lượng khóa riêng - Danh sách khóa riêng (một khóa cho mỗi khóa công khai trong LeaseSet, cùng thứ tự)\nKhóa riêng: Cần thiết để giải mã các garlic messages (thông điệp theo mô hình \u0026lsquo;garlic\u0026rsquo; của I2P) đến. Định dạng:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) Lưu ý: Thay thế CreateLeaseSetMessage (type 4) đã lỗi thời, vốn không hỗ trợ: - Các biến thể LeaseSet2 - Mã hóa không phải ElGamal - Nhiều loại mã hóa - LeaseSets được mã hóa - Khóa ký ngoại tuyến\nSendMessageExpiresMessage (thông điệp thông báo việc gửi tin nhắn đã hết hạn) (Loại 36) Mục đích: Gửi thông điệp tới đích đến kèm thời hạn hết hiệu lực và các tùy chọn nâng cao\nNội dung: - ID phiên - Đích - Tải (được nén gzip) - Nonce (số dùng một lần) (4 byte) - Cờ (2 byte) - xem bên dưới - Ngày hết hạn (6 byte, rút gọn từ 8)\nTrường cờ (2 byte, thứ tự bit 15\u0026hellip;0):\nCác bit 15-11: Không sử dụng, phải là 0\nBits 10-9: Ghi đè độ tin cậy của thông điệp (không sử dụng, dùng nonce (giá trị dùng một lần) thay thế)\nBit 8: Không đóng gói kèm LeaseSet - 0: Router có thể đóng gói kèm LeaseSet trong garlic (một cơ chế thông điệp/mã hóa trong I2P) - 1: Không đóng gói kèm LeaseSet\nCác bit 7-4: Ngưỡng thẻ thấp (chỉ áp dụng cho ElGamal, bị bỏ qua đối với ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags Các bit 3-0: Các thẻ cần gửi nếu cần (chỉ dùng với ElGamal (thuật toán mã hóa khóa công khai ElGamal), bị bỏ qua trong ECIES (Elliptic Curve Integrated Encryption Scheme - hệ mã tích hợp đường cong elliptic))\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage (Loại 22) Mục đích: Thông báo cho ứng dụng khách về trạng thái chuyển phát thông điệp\nNội dung: - ID phiên - ID thông điệp (được router tạo ra) - Mã trạng thái (1 byte) - Kích thước (4 byte, chỉ áp dụng khi status=0) - Nonce (giá trị dùng một lần; 4 byte, khớp nonce SendMessage của máy khách)\nMã trạng thái (Thông điệp gửi đi):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure **Mã thành công**: 1, 2, 4, 6 **Mã thất bại**: Tất cả các mã khác Mã trạng thái 0 (ĐÃ NGỪNG SỬ DỤNG): Thông điệp sẵn có (đến, fast receive (nhận nhanh) bị vô hiệu hóa)\nHostLookupMessage (Loại 38) Mục đích: Tra cứu đích theo tên máy chủ hoặc mã băm (thay thế DestLookup)\nNội dung: - ID phiên (hoặc 0xFFFF nếu không có phiên) - ID yêu cầu (4 byte) - Thời gian chờ tính bằng mili giây (4 byte, giá trị tối thiểu khuyến nghị: 10000) - Loại yêu cầu (1 byte) - Khóa tra cứu (Hash, chuỗi hostname, hoặc Destination (đích I2P))\nCác loại yêu cầu:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 Các loại 2-4 trả về các tùy chọn LeaseSet (đề xuất 167) nếu có. Phản hồi: HostReplyMessage\nHostReplyMessage (Loại 39) Mục đích: Phản hồi cho HostLookupMessage (thông điệp tra cứu máy chủ)\nNội dung: - ID phiên - ID yêu cầu - Mã kết quả (1 byte) - Destination (điểm đích) (xuất hiện khi thành công, đôi khi trong một số lỗi cụ thể) - Ánh xạ (chỉ cho các kiểu tra cứu 2-4, có thể để trống)\nMã kết quả:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type #### BlindingInfoMessage (thông điệp thông tin blinding) (Loại 42) Mục đích: Thông báo cho router về các yêu cầu xác thực cho blinded destination (đích được che giấu định danh bằng kỹ thuật blinding) (kể từ 0.9.43)\nNội dung: - ID phiên - Cờ (1 byte) - Kiểu điểm cuối (1 byte): 0=Băm, 1=tên máy chủ, 2=Destination (đích trong I2P), 3=SigType+Key - Loại chữ ký mù (2 byte) - Thời gian hết hạn (4 byte, số giây kể từ Unix epoch) - Dữ liệu điểm cuối (thay đổi tùy theo loại) - Khóa riêng (32 byte, chỉ khi bit cờ 0 được đặt) - Mật khẩu tra cứu (String, chỉ khi bit cờ 4 được đặt)\nCờ (thứ tự bit 76543210):\nBit 0: 0=tất cả, 1=theo từng máy khách Các bit 3-1: Lược đồ xác thực (nếu bit 0=1): 000=DH, 001=PSK Bit 4: 1=yêu cầu bí mật Các bit 7-5: Không sử dụng, đặt thành 0 Không có phản hồi: Router xử lý âm thầm\nTrường hợp sử dụng: Trước khi gửi đến đích mù (địa chỉ b33), máy khách phải thực hiện một trong hai: 1. Tra cứu b33 qua HostLookup, HOẶC 2. Gửi thông điệp BlindingInfo\nNếu đích (Destination) yêu cầu xác thực, BlindingInfo là bắt buộc.\nReconfigureSessionMessage (thông điệp cấu hình lại phiên) (Loại 2) Mục đích: Cập nhật cấu hình phiên sau khi tạo\nNội dung: - Session ID - SessionConfig (chỉ cần các tùy chọn đã thay đổi)\nPhản hồi: SessionStatusMessage (thông điệp trạng thái phiên) (status=Updated or Invalid)\nGhi chú: - Router hợp nhất cấu hình mới với cấu hình hiện có - Tùy chọn Tunnel (inbound.*, outbound.*) luôn được áp dụng - Một số tùy chọn có thể là bất biến sau khi tạo phiên - Thời gian phải nằm trong ±30 giây so với thời gian của router - Bảng ánh xạ phải được sắp xếp theo khóa\nDestroySessionMessage (Loại 3) Mục đích: Kết thúc phiên\nNội dung: ID phiên\nPhản hồi dự kiến: SessionStatusMessage (status=Destroyed)\nHành vi thực tế (Java I2P đến 0.9.66): - Router không bao giờ gửi SessionStatus(Destroyed) - Nếu không còn phiên nào: Gửi DisconnectMessage - Nếu còn subsessions (các phiên con): Không phản hồi\nQuan trọng: Hành vi của Java I2P lệch khỏi đặc tả. Các triển khai nên thận trọng khi hủy các subsessions (tiểu phiên) riêng lẻ.\nDisconnectMessage (thông điệp ngắt kết nối) (Loại 30) Mục đích: Thông báo rằng kết nối sắp bị chấm dứt\nNội dung: Chuỗi lý do\nTác động: Tất cả các phiên trên kết nối bị hủy, socket (điểm cuối giao tiếp mạng) được đóng\nHiện thực: Chủ yếu từ router → máy khách trong Java I2P\nLịch sử phiên bản giao thức Phát hiện phiên bản Phiên bản giao thức I2CP được trao đổi trong các thông điệp Get/SetDate (kể từ 0.8.7). Đối với các router cũ hơn, thông tin về phiên bản không khả dụng.\nChuỗi phiên bản: Cho biết phiên bản API “core”, không nhất thiết là phiên bản router.\nDòng thời gian các tính năng Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features ## Các cân nhắc bảo mật Xác thực Mặc định: Không yêu cầu xác thực Tùy chọn: Xác thực bằng tên người dùng/mật khẩu (kể từ 0.9.11) Bắt buộc: Khi được bật, quá trình xác thực phải hoàn tất trước các thông điệp khác (kể từ 0.9.16)\nKết nối từ xa: Luôn sử dụng TLS (i2cp.SSL=true) để bảo vệ thông tin xác thực và khóa riêng.\nĐộ lệch đồng hồ SessionConfig Date (ngày trong cấu hình phiên) phải nằm trong khoảng ±30 giây so với thời gian của router, nếu không phiên sẽ bị từ chối. Hãy dùng Get/SetDate (lấy/đặt ngày) để đồng bộ.\nXử lý khóa riêng CreateLeaseSet2Message chứa các khóa riêng để giải mã các thông điệp đến. Các khóa này phải:\nĐược truyền một cách an toàn (TLS cho các kết nối từ xa) Được router lưu trữ an toàn Được xoay vòng khi bị xâm phạm Hết hạn thông điệp Luôn dùng SendMessageExpires (không phải SendMessage) để thiết lập thời điểm hết hạn tường minh. Điều này: - Ngăn thông điệp bị xếp hàng vô thời hạn - Giảm tiêu thụ tài nguyên - Cải thiện độ tin cậy\nQuản lý Session Tag (thẻ phiên) ElGamal (đã lỗi thời): - Các thẻ phải được truyền theo lô - Mất thẻ gây lỗi giải mã - Chi phí bộ nhớ cao\nECIES-X25519 (hiện tại): - Thẻ được tạo thông qua PRNG (bộ tạo số giả ngẫu nhiên) được đồng bộ - Không cần truyền trước - Kháng chịu mất thông điệp - Chi phí phụ trội thấp hơn đáng kể\nThực hành tốt nhất Dành cho các nhà phát triển ứng dụng khách Sử dụng Chế độ Nhận Nhanh: Luôn đặt i2cp.fastReceive=true (hoặc dựa vào giá trị mặc định)\nƯu tiên ECIES-X25519 (lược đồ mã hóa khóa công khai tích hợp dựa trên đường cong elliptic X25519): Cấu hình i2cp.leaseSetEncType=4,0 để đạt hiệu năng tốt nhất mà vẫn đảm bảo khả năng tương thích\nThiết lập thời gian hết hạn tường minh: Sử dụng SendMessageExpires, không phải SendMessage\nXử lý Subsessions (các phiên con) một cách cẩn trọng: Lưu ý rằng subsessions không cung cấp tính ẩn danh giữa các destinations (đích đến)\nHết thời gian khi tạo phiên: Hủy phiên nếu không nhận được RequestVariableLeaseSet (thông điệp yêu cầu leaseSet biến đổi) trong vòng 5 phút\nSắp xếp Configuration Mappings (các ánh xạ cấu hình): Luôn sắp xếp các khóa của Mapping trước khi ký SessionConfig (cấu hình phiên)\nSử dụng số lượng Tunnel phù hợp: Không đặt quantity \u0026gt; 6 trừ khi cần thiết\nCân nhắc SAM/BOB cho các ngôn ngữ không phải Java: Triển khai SAM thay vì sử dụng trực tiếp I2CP\nDành cho các nhà phát triển Router Xác thực mốc thời gian: Bắt buộc cửa sổ ±30 giây đối với các mốc thời gian trong SessionConfig\nGiới hạn kích thước thông điệp: Bắt buộc kích thước thông điệp tối đa ~64 KB\nHỗ trợ nhiều phiên: Triển khai hỗ trợ subsession (phiên phụ) theo đặc tả 0.9.21\nGửi RequestVariableLeaseSet kịp thời: Chỉ sau khi cả inbound và outbound tunnels đều tồn tại\nXử lý các thông điệp đã bị loại bỏ dần (deprecated): Chấp nhận nhưng không khuyến khích sử dụng ReceiveMessageBegin/End\nHỗ trợ ECIES-X25519 (lược đồ mã hóa ECIES dùng X25519): Ưu tiên mã hóa loại 4 cho các triển khai mới\nGỡ lỗi và khắc phục sự cố Các vấn đề thường gặp Phiên bị từ chối (không hợp lệ): - Kiểm tra độ lệch đồng hồ (phải nằm trong ±30 giây) - Xác minh ánh xạ được sắp xếp theo khóa - Đảm bảo đích chưa được sử dụng\nKhông có RequestVariableLeaseSet: - Router có thể đang xây dựng tunnels (chờ tối đa 5 phút) - Kiểm tra sự cố kết nối mạng - Xác minh có đủ kết nối peer (nút ngang hàng)\nLỗi chuyển phát thông điệp: - Kiểm tra các mã MessageStatus để biết lý do lỗi cụ thể - Xác minh LeaseSet từ xa (tập hợp thông tin đường hầm đến) đã được công bố và còn hiệu lực - Đảm bảo các loại mã hóa tương thích\nVấn đề Subsession (phiên phụ): - Xác minh phiên chính được tạo trước - Xác nhận dùng cùng khóa mã hóa - Kiểm tra các khóa ký riêng biệt\nThông báo chẩn đoán GetBandwidthLimits: Truy vấn giới hạn băng thông của router HostLookup: Kiểm tra phân giải tên và tính sẵn sàng của LeaseSet MessageStatus: Theo dõi việc chuyển phát thông điệp từ đầu đến cuối\nCác đặc tả liên quan Cấu trúc chung: /docs/specs/common-structures/ I2NP (Giao thức mạng): /docs/specs/i2np/ ECIES-X25519: /docs/specs/ecies/ Tạo Tunnel: /docs/specs/implementation/ Thư viện Streaming (truyền dòng): /docs/specs/streaming/ Thư viện Datagram (gói tin): /docs/api/datagrams/ SAM v3: /docs/api/samv3/ Các đề xuất được tham chiếu Đề xuất 123 : LeaseSets được mã hóa và xác thực Đề xuất 144 : ECIES-X25519-AEAD-Ratchet (cơ chế mã hóa lai dùng ECIES và X25519 với AEAD và ratchet) Đề xuất 149 : Định dạng địa chỉ bị làm mù (b33) Đề xuất 152 : Tạo tunnel X25519 Đề xuất 154 : Tra cứu cơ sở dữ liệu từ các đích ECIES (Destination) Đề xuất 156 : Di chuyển router sang ECIES-X25519 Đề xuất 161 : Nén phần đệm của đích Đề xuất 167 : Bản ghi dịch vụ LeaseSet Đề xuất 169 : Mật mã lai hậu lượng tử (ML-KEM) Tài liệu tham chiếu Javadocs Gói I2CP MessageStatusMessage API máy khách Tóm tắt ngừng hỗ trợ Các thông điệp lỗi thời (Không được sử dụng) CreateLeaseSetMessage (loại 4): Sử dụng CreateLeaseSet2Message RequestLeaseSetMessage (loại 21): Sử dụng RequestVariableLeaseSetMessage ReceiveMessageBeginMessage (loại 6): Sử dụng chế độ nhận nhanh ReceiveMessageEndMessage (loại 7): Sử dụng chế độ nhận nhanh DestLookupMessage (loại 34): Sử dụng HostLookupMessage DestReplyMessage (loại 35): Sử dụng HostReplyMessage ReportAbuseMessage (loại 29): Chưa bao giờ được triển khai Các tùy chọn đã lỗi thời Mã hóa ElGamal (loại 0): Chuyển sang ECIES-X25519 (loại 4) Chữ ký DSA: Chuyển sang EdDSA hoặc ECDSA i2cp.fastReceive=false: Luôn sử dụng chế độ nhận nhanh ","description":"Cách các ứng dụng thương lượng các phiên, tunnels và LeaseSets với I2P router.","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"Giao thức máy khách I2P (I2CP)","url":"/vi/docs/specs/i2cp/"},{"categories":null,"content":"Tổng quan Thư viện I2P Streaming cung cấp truyền tải đáng tin cậy, theo thứ tự, được xác thực qua lớp thông điệp của I2P, tương tự như TCP trên IP. Nó nằm phía trên giao thức I2CP và được sử dụng bởi hầu hết các ứng dụng I2P tương tác, bao gồm HTTP proxy, IRC, BitTorrent và email.\nĐặc điểm Cốt lõi Thiết lập kết nối một pha sử dụng các cờ SYN, ACK, và FIN có thể được đóng gói cùng dữ liệu payload để giảm số lượt truyền tin qua lại. Kiểm soát tắc nghẽn cửa sổ trượt, với khởi động chậm và tránh tắc nghẽn được điều chỉnh cho môi trường độ trễ cao của I2P. Nén gói tin (các phân đoạn nén mặc định 4KB) cân bằng giữa chi phí truyền lại và độ trễ phân mảnh. Trừu tượng hóa kênh xác thực, mã hóa đầy đủ và đáng tin cậy giữa các destination I2P. Thiết kế này cho phép các yêu cầu và phản hồi HTTP nhỏ hoàn thành trong một lượt truyền dữ liệu duy nhất. Một gói tin SYN có thể chứa dữ liệu yêu cầu, trong khi gói SYN/ACK/FIN của bên phản hồi có thể chứa toàn bộ nội dung phản hồi.\nKiến Thức Cơ Bản về API API streaming của Java tương tự như lập trình socket Java tiêu chuẩn:\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory thương lượng hoặc tái sử dụng phiên router thông qua I2CP. Nếu không cung cấp khóa, một destination mới sẽ được tự động tạo ra. Các nhà phát triển có thể truyền các tùy chọn I2CP (ví dụ: độ dài tunnel, các loại mã hóa, hoặc cài đặt kết nối) thông qua map options. I2PSocket và I2PServerSocket phản ánh các giao diện Socket Java chuẩn, giúp việc di chuyển trở nên đơn giản. Tài liệu Javadocs đầy đủ có sẵn từ bảng điều khiển router I2P hoặc tại đây .\nCấu hình và Điều chỉnh Bạn có thể truyền các thuộc tính cấu hình khi tạo socket manager thông qua:\nI2PSocketManagerFactory.createManager(host, port, properties); Các Tùy Chọn Khóa Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false ### Hành vi theo Khối lượng Công việc Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. Các tính năng mới hơn kể từ phiên bản 0.9.4 bao gồm chặn ghi log từ chối, hỗ trợ danh sách DSA (0.9.21) và thực thi giao thức bắt buộc (0.9.36). Các router kể từ phiên bản 2.10.0 bao gồm mã hóa lai hậu lượng tử (ML-KEM + X25519) tại tầng vận chuyển. Chi tiết Giao thức Mỗi luồng được xác định bằng một Stream ID. Các gói tin mang các cờ điều khiển tương tự như TCP: SYNCHRONIZE, ACK, FIN, và RESET. Các gói tin có thể chứa đồng thời cả dữ liệu và cờ điều khiển, cải thiện hiệu suất cho các kết nối tồn tại trong thời gian ngắn.\nVòng đời Kết nối Gửi SYN — bên khởi tạo bao gồm dữ liệu tùy chọn. Phản hồi SYN/ACK — bên phản hồi bao gồm dữ liệu tùy chọn. Hoàn tất ACK — thiết lập độ tin cậy và trạng thái phiên. FIN/RESET — được sử dụng để đóng có trật tự hoặc kết thúc đột ngột. Phân mảnh và sắp xếp lại Vì các tunnel I2P gây ra độ trễ và sắp xếp lại thứ tự thông điệp, thư viện sẽ đệm các gói tin từ các luồng chưa xác định hoặc đến sớm. Các thông điệp được đệm sẽ được lưu trữ cho đến khi quá trình đồng bộ hóa hoàn tất, đảm bảo việc phân phối đầy đủ và theo đúng thứ tự.\nThực thi Giao thức Tùy chọn i2p.streaming.enforceProtocol=true (mặc định từ phiên bản 0.9.36) đảm bảo các kết nối sử dụng đúng số giao thức I2CP, ngăn chặn xung đột giữa nhiều hệ thống con chia sẻ cùng một destination.\nKhả năng tương tác và Thực hành tốt nhất Giao thức streaming cùng tồn tại với Datagram API, cho phép nhà phát triển lựa chọn giữa giao thức truyền tải hướng kết nối và không kết nối.\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram ### Ứng dụng khách chia sẻ Các ứng dụng có thể tái sử dụng các tunnel hiện có bằng cách chạy dưới dạng shared clients (máy khách chia sẻ), cho phép nhiều dịch vụ chia sẻ cùng một destination. Mặc dù điều này giảm thiểu chi phí hệ thống, nhưng nó làm tăng nguy cơ tương quan giữa các dịch vụ—sử dụng cẩn thận.\nKiểm Soát Tắc Nghẽn Lớp streaming liên tục thích ứng với độ trễ mạng và thропускная способность thông qua phản hồi dựa trên RTT. Các ứng dụng hoạt động tốt nhất khi các router đang đóng góp như các peer (bật chế độ tham gia tunnel). Các cơ chế kiểm soát tắc nghẽn giống TCP ngăn chặn việc quá tải các peer chậm và giúp cân bằng việc sử dụng băng thông qua các tunnel. Các Yếu Tố Về Độ Trễ Vì I2P thêm vào vài trăm millisecond độ trễ cơ bản, các ứng dụng nên giảm thiểu số lượt truyền tải qua lại. Gộp dữ liệu vào quá trình thiết lập kết nối khi có thể (ví dụ: yêu cầu HTTP trong SYN). Tránh các thiết kế dựa vào nhiều trao đổi tuần tự nhỏ.\nKiểm thử và Tương thích Luôn kiểm tra với cả Java I2P và i2pd để đảm bảo tương thích hoàn toàn. Mặc dù giao thức đã được chuẩn hóa, vẫn có thể tồn tại những khác biệt nhỏ trong cách triển khai. Xử lý các router cũ một cách mượt mà—nhiều peer vẫn chạy các phiên bản trước 2.0. Giám sát thống kê kết nối bằng cách sử dụng I2PSocket.getOptions() và getSession() để đọc các chỉ số RTT và truyền lại. Hiệu suất phụ thuộc rất nhiều vào cấu hình tunnel: - Tunnel ngắn (1–2 hop) → độ trễ thấp hơn, tính ẩn danh giảm. - Tunnel dài (3+ hop) → tính ẩn danh cao hơn, RTT tăng.\nCải tiến chính (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. --- Tóm tắt Thư viện I2P Streaming là nền tảng cho mọi giao tiếp đáng tin cậy trong I2P. Nó đảm bảo việc truyền tải thông điệp theo thứ tự, được xác thực và mã hóa, đồng thời cung cấp giải pháp thay thế gần như hoàn toàn cho TCP trong môi trường ẩn danh.\nĐể đạt hiệu suất tối ưu: - Giảm thiểu số lượng round-trip bằng cách gộp SYN+payload. - Điều chỉnh các tham số window và timeout phù hợp với khối lượng công việc của bạn. - Ưu tiên các tunnel ngắn hơn cho các ứng dụng nhạy cảm với độ trễ. - Sử dụng thiết kế thân thiện với tắc nghẽn để tránh quá tải các peer.\n","description":"Giao thức vận chuyển giống TCP được sử dụng bởi hầu hết các ứng dụng I2P","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"Giao thức Streaming","url":"/vi/docs/api/streaming/"},{"categories":null,"content":"Tổng quan I2P Streaming Library (thư viện truyền tải theo luồng của I2P) cung cấp khả năng chuyển giao dữ liệu đáng tin cậy, theo đúng thứ tự và được xác thực trên lớp thông điệp không đáng tin cậy của I2P — tương tự như TCP trên IP. Nó được sử dụng bởi hầu như tất cả các ứng dụng I2P mang tính tương tác như duyệt web, IRC, email và chia sẻ tệp.\nNó đảm bảo truyền dữ liệu đáng tin cậy, điều khiển tắc nghẽn, truyền lại và điều khiển luồng xuyên suốt các tunnel ẩn danh có độ trễ cao của I2P. Mỗi luồng được mã hóa hoàn toàn từ đầu đến cuối giữa các điểm đích.\nCác nguyên tắc thiết kế cốt lõi Thư viện streaming (thư viện truyền luồng) triển khai một thiết lập kết nối một pha, trong đó các cờ SYN, ACK và FIN có thể mang tải dữ liệu trong cùng một thông điệp. Điều này giúp giảm thiểu số lượt khứ hồi (round-trip) trong môi trường độ trễ cao — một giao dịch HTTP nhỏ có thể hoàn tất chỉ trong một lượt khứ hồi.\nKiểm soát tắc nghẽn và truyền lại được mô phỏng theo TCP nhưng đã được điều chỉnh cho môi trường của I2P. Kích thước cửa sổ dựa trên thông điệp chứ không dựa trên byte, và được tinh chỉnh theo độ trễ tunnel và overhead (chi phí phụ trội). Giao thức hỗ trợ slow start (khởi động chậm), congestion avoidance (tránh tắc nghẽn), và exponential backoff (giảm lùi theo hàm mũ) tương tự thuật toán AIMD của TCP (Additive Increase, Multiplicative Decrease).\nKiến trúc Thư viện truyền luồng hoạt động giữa các ứng dụng và giao diện I2CP.\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels Hầu hết người dùng truy cập nó thông qua I2PSocketManager, I2PTunnel hoặc SAMv3. Thư viện xử lý một cách trong suốt việc quản lý destination (điểm đích trong I2P), sử dụng tunnel và truyền lại. Định dạng gói tin +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | Chi tiết phần đầu ID luồng: Các giá trị 32-bit nhận diện duy nhất các luồng cục bộ và từ xa. Số thứ tự: Bắt đầu từ 0 đối với SYN, tăng dần theo mỗi thông điệp. Ack Through (xác nhận đến): Xác nhận tất cả các thông điệp đến N, ngoại trừ những thông điệp nằm trong danh sách NACK (không xác nhận). Cờ: Mặt nạ bit điều khiển trạng thái và hành vi. Tùy chọn: Danh sách có độ dài biến đổi dùng cho RTT, MTU và thương lượng giao thức. Cờ khóa Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive --- Điều khiển luồng và độ tin cậy Streaming sử dụng cửa sổ dựa trên thông điệp, khác với cách tiếp cận dựa trên byte của TCP. Số lượng gói tin chưa được xác nhận được phép trên đường truyền bằng với kích thước cửa sổ hiện tại (mặc định 128).\nCơ chế Kiểm soát tắc nghẽn: Khởi đầu chậm và tránh tắc nghẽn dựa trên AIMD (Additive Increase Multiplicative Decrease - tăng tuyến tính, giảm nhân). Choke/Unchoke: Tín hiệu điều khiển lưu lượng dựa trên mức chiếm dụng bộ đệm (chặn/giải chặn). Truyền lại: Tính toán RTO (thời hạn chờ truyền lại) theo RFC 6298 với cơ chế lùi theo hàm mũ. Lọc trùng lặp: Bảo đảm độ tin cậy khi thông điệp có thể bị đảo thứ tự. Các giá trị cấu hình điển hình:\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout --- Thiết lập kết nối Bên khởi tạo gửi một SYN (tùy chọn kèm payload (nội dung dữ liệu) và FROM_INCLUDED). Bên đáp ứng phản hồi bằng SYN+ACK (có thể bao gồm payload). Bên khởi tạo gửi ACK cuối cùng để xác nhận việc thiết lập (kết nối). Các payload ban đầu tùy chọn cho phép truyền dữ liệu trước khi toàn bộ quá trình bắt tay được hoàn tất.\nChi tiết hiện thực Truyền lại và Hết thời gian chờ Thuật toán truyền lại tuân theo RFC 6298. - RTO ban đầu: 9s - RTO tối thiểu: 100ms - RTO tối đa: 45s - Alpha: 0.125 - Beta: 0.25\nChia sẻ khối điều khiển Các kết nối gần đây tới cùng một nút ngang hàng tái sử dụng RTT (thời gian khứ hồi) và dữ liệu cửa sổ trước đó để đạt tăng tốc ban đầu nhanh hơn, tránh độ trễ “khởi động lạnh”. Các khối điều khiển sẽ hết hạn sau vài phút.\nMTU và phân mảnh MTU mặc định: 1730 byte (đủ cho hai thông điệp I2NP). Đích ECIES: 1812 byte (giảm chi phí giao thức). MTU tối thiểu được hỗ trợ: 512 byte. Kích thước payload không bao gồm phần tiêu đề streaming tối thiểu 22 byte.\nLịch sử phiên bản Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) --- Sử dụng ở cấp độ ứng dụng Ví dụ Java Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); Hỗ trợ SAMv3 và i2pd SAMv3: Cung cấp các chế độ STREAM (luồng) và DATAGRAM (datagram) cho các ứng dụng khách không dùng Java. i2pd: Cung cấp các tham số streaming (truyền dòng) giống hệt thông qua các tùy chọn trong tệp cấu hình (ví dụ: i2p.streaming.maxWindowSize, profile, v.v.). Lựa chọn giữa Streaming (truyền luồng) và Datagrams (gói tin không kết nối) Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn --- Bảo mật và tương lai hậu lượng tử Các phiên streaming được mã hóa đầu-cuối ở lớp I2CP. Mã hóa lai hậu lượng tử (ML-KEM + X25519) được hỗ trợ ở dạng thử nghiệm trong phiên bản 2.10.0 nhưng mặc định bị tắt.\nTài liệu tham khảo Tổng quan về API Streaming Đặc tả Giao thức Streaming Đặc tả I2CP Đề xuất 144: Tính toán MTU cho Streaming Ghi chú phát hành I2P 2.10.0 ","description":"Cơ chế truyền tải đáng tin cậy, tương tự TCP, được hầu hết các ứng dụng I2P sử dụng","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"Giao thức Streaming (giao thức truyền theo luồng)","url":"/vi/docs/specs/streaming/"},{"categories":null,"content":" Đã ngừng sử dụng: SSU (UDP bán tin cậy bảo mật) đã được thay thế bởi SSU2 . Java I2P đã loại bỏ SSU trong phiên bản 2.4.0 (API 0.9.61) và i2pd đã loại bỏ nó trong phiên bản 2.44.0 (API 0.9.56). Tài liệu này chỉ được giữ lại để tham khảo lịch sử.\nĐiểm nổi bật Giao thức truyền tải UDP cung cấp chuyển giao điểm-đến-điểm đã mã hóa, có xác thực cho các thông điệp I2NP. Dựa trên một bắt tay Diffie–Hellman (giao thức trao đổi khóa) 2048-bit (dùng cùng số nguyên tố như ElGamal). Mỗi gói tin (datagram) mang một HMAC-MD5 16 byte (biến thể rút gọn không tiêu chuẩn) + một IV 16 byte, tiếp theo là phần tải dữ liệu được mã hóa bằng AES-256-CBC. Ngăn chặn phát lại và trạng thái phiên được theo dõi bên trong phần tải dữ liệu đã mã hóa. Tiêu đề thông điệp [16-byte MAC][16-byte IV][encrypted payload] Phép tính MAC (mã xác thực thông điệp) được sử dụng: HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8))) với khóa MAC dài 32 byte. Độ dài payload là 16-bit big-endian (MSB trước) được thêm vào trong phép tính MAC. Phiên bản giao thức mặc định là 0; netId mặc định là 2 (mạng chính).\nKhóa Phiên \u0026amp; Khóa MAC (mã xác thực thông điệp) Được dẫn xuất từ bí mật chung DH (Diffie–Hellman):\nChuyển giá trị được chia sẻ thành mảng byte theo big-endian (thêm 0x00 ở đầu nếu bit cao được đặt). Khóa phiên: 32 byte đầu tiên (đệm bằng số 0 nếu ngắn hơn). Khóa MAC: các byte 33–64; nếu không đủ, quay về băm SHA-256 của giá trị được chia sẻ. Trạng thái Các router không còn quảng bá các địa chỉ SSU. Các máy khách nên chuyển sang các giao thức truyền tải SSU2 hoặc NTCP2. Các triển khai trước đây có thể được tìm thấy trong các bản phát hành cũ:\nMã nguồn Java trước phiên bản 2.4.0 trong thư mục router/transport/udp Mã nguồn i2pd (triển khai I2P bằng C++) trước phiên bản 2.44.0 Để biết hành vi truyền tải UDP hiện tại, hãy tham khảo đặc tả SSU2 .\n","description":"Giao thức truyền tải UDP ban đầu được sử dụng trước SSU2","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"Giao thức truyền tải SSU (Không còn được khuyến nghị)","url":"/vi/docs/legacy/ssu/"},{"categories":null,"content":"Như yêu cầu bởi mô hình đe dọa của chúng tôi (cùng với các lý do khác), phần mềm được phát triển để hỗ trợ mạng lưới truyền thông ẩn danh mà chúng tôi gọi là I2P phải miễn phí, mã nguồn mở và có thể chỉnh sửa bởi người dùng. Để đáp ứng các tiêu chí này, chúng tôi sử dụng nhiều kỹ thuật pháp lý và kỹ thuật phần mềm khác nhau nhằm loại bỏ càng nhiều rào cản càng tốt cho những ai đang cân nhắc sử dụng hoặc đóng góp cho nỗ lực I2P.\nMặc dù thông tin dưới đây có thể gây khó hiểu hơn so với việc chỉ đơn giản nói \u0026ldquo;I2P là BSD\u0026rdquo;, \u0026ldquo;I2P là GPL\u0026rdquo;, hoặc \u0026ldquo;I2P là phạm vi công cộng\u0026rdquo;, câu trả lời ngắn gọn cho câu hỏi \u0026ldquo;I2P được cấp phép như thế nào?\u0026rdquo; là:\nTất cả phần mềm đi kèm trong các bản phân phối I2P sẽ cho phép: sử dụng miễn phí sử dụng không có hạn chế về cách thức, thời gian, địa điểm, lý do, hoặc người vận hành truy cập mã nguồn miễn phí thực hiện các sửa đổi đối với mã nguồn Hầu hết các phần mềm đảm bảo nhiều hơn thế - khả năng để bất kỳ ai phân phối mã nguồn đã sửa đổi theo cách họ chọn. Tuy nhiên, không phải tất cả phần mềm được đóng gói đều cung cấp sự tự do này - GPL hạn chế khả năng của các nhà phát triển muốn tích hợp I2P với các ứng dụng của riêng họ mà bản thân không phải là ứng dụng mã nguồn mở. Mặc dù chúng tôi ủng hộ các mục tiêu cao cả là tăng cường các nguồn lực trong cộng đồng, I2P được phục vụ tốt nhất bằng cách loại bỏ mọi rào cản cản trở việc áp dụng nó - nếu một nhà phát triển đang xem xét liệu họ có thể tích hợp I2P với ứng dụng của mình phải dừng lại và kiểm tra với luật sư của họ, hoặc tiến hành kiểm toán mã để đảm bảo mã nguồn của chính họ có thể được phát hành tương thích với GPL, thì chúng tôi sẽ bị thiệt.\nGiấy phép các thành phần Bản phân phối I2P chứa nhiều tài nguyên, phản ánh việc phân chia mã nguồn thành các thành phần. Mỗi thành phần có giấy phép riêng, mà tất cả các nhà phát triển đóng góp vào đó đều đồng ý - hoặc bằng cách tuyên bố rõ ràng việc phát hành mã được commit dưới giấy phép tương thích với thành phần đó, hoặc bằng cách ngầm định phát hành mã được commit dưới giấy phép chính của thành phần. Mỗi thành phần này có một nhà phát triển chính có quyết định cuối cùng về việc giấy phép nào tương thích với giấy phép chính của thành phần, và người quản lý dự án I2P có quyết định cuối cùng về việc giấy phép nào đáp ứng bốn đảm bảo nêu trên để được đưa vào bản phân phối I2P.\nComponent Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD, Cryptix, MIT zzz I2P Router router router.jar Public domain BSD, Cryptix, MIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain, Cryptix, MIT zzz Streaming apps/streaming streaming.jar Public domain BSD, Cryptix, MIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain, BSD, Cryptix, MIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain — zzz Address Book apps/addressbook addressbook.war MIT Public domain, Cryptix, BSD — Susidns apps/susidns susidns.war GPL + exception — — Susimail apps/susimail susimail.war GPL + exception — — I2PSnark apps/i2psnark i2psnark.jar GPL + exception — zzz [BOB](/docs/legacy/bob/) Bridge apps/BOB BOB.jar WTFPL — sponge [SAM](/docs/api/samv3/) Bridge apps/sam sam.jar Public domain Cryptix, BSD, MIT zzz [SAM v1](/docs/legacy/sam/) Perl library apps/sam/perl SAM.pm GPL Public domain, Cryptix, BSD, MIT BrianR [SAM v1](/docs/legacy/sam/) C library apps/sam/c libSAM BSD Public domain, Cryptix, MIT Nightblade [SAM v1](/docs/legacy/sam/) Python library apps/sam/python i2p.py Public domain BSD, Cryptix, MIT Connelly [SAM v1](/docs/legacy/sam/) C# library apps/sam/csharp/ n/a Public domain BSD, Cryptix, MIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source — — Installer installer install.jar, guiinstall.jar Public domain GPL + exception, BSD, Cryptix, MIT — Ngoại lệ GPL Mặc dù có thể hơi thừa, nhưng để rõ ràng thì mã nguồn GPL được bao gồm trong I2PTunnel và các ứng dụng khác phải được phát hành dưới GPL với một \u0026ldquo;ngoại lệ\u0026rdquo; bổ sung cho phép rõ ràng việc sử dụng các thư viện chuẩn của Java:\nIn addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version. Tất cả mã nguồn thuộc mỗi thành phần sẽ mặc định được cấp phép theo giấy phép chính, trừ khi được đánh dấu khác trong mã. Tất cả những điều trên chỉ là tóm tắt các điều khoản giấy phép - vui lòng xem giấy phép cụ thể cho thành phần hoặc mã nguồn được đề cập để biết các điều khoản chính thức. Vị trí mã nguồn của thành phần và cách đóng gói tài nguyên có thể thay đổi nếu kho lưu trữ được tổ chức lại.\nGiấy phép Website Trừ khi có ghi chú khác, nội dung trên trang web này được cấp phép theo Giấy phép Creative Commons Ghi công-Chia sẻ tương tự 4.0 Quốc tế .\nQuyền Commit Các nhà phát triển có thể đẩy các thay đổi lên kho lưu trữ git phân tán nếu bạn nhận được sự cho phép từ người quản lý kho lưu trữ đó. Xem Hướng dẫn Nhà phát triển Mới để biết chi tiết.\nTuy nhiên, để có những thay đổi được đưa vào bản phát hành, các nhà phát triển phải được tin tưởng bởi người quản lý phát hành (hiện tại là zzz). Ngoài ra, họ phải đồng ý rõ ràng với các điều khoản trên để được tin tưởng. Điều đó có nghĩa là họ phải gửi cho một trong những người quản lý phát hành một thông điệp đã ký xác nhận rằng:\nTrừ khi được đánh dấu khác, tất cả mã nguồn tôi commit đều được cấp phép ngầm định theo giấy phép chính của thành phần Nếu được chỉ định trong mã nguồn, mã có thể được cấp phép rõ ràng theo một trong các giấy phép thay thế của thành phần Tôi có quyền phát hành mã nguồn tôi commit theo các điều khoản mà tôi đang commit Nếu ai biết bất kỳ trường hợp nào không đáp ứng các điều kiện trên, vui lòng liên hệ với người phụ trách thành phần và/hoặc người quản lý phát hành I2P để cung cấp thêm thông tin.\n","description":"Chính sách cấp phép và giấy phép thành phần cho phần mềm đi kèm với I2P","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"Giấy phép Phần mềm I2P","url":"/vi/docs/develop/licenses/"},{"categories":null,"content":"I2P là gì? The Invisible Internet Project (I2P) là một lớp mạng ẩn danh cho phép giao tiếp ngang hàng chống kiểm duyệt. Các kết nối ẩn danh được thực hiện bằng cách mã hóa lưu lượng của người dùng và gửi qua một mạng lưới phân tán được vận hành bởi các tình nguyện viên trên toàn thế giới.\nTính Năng Chính Anonymity I2P ẩn danh cả người gửi và người nhận tin nhắn. Không giống như các kết nối internet truyền thống nơi địa chỉ IP của bạn hiển thị với các trang web và dịch vụ, I2P sử dụng nhiều lớp mã hóa và định tuyến để giữ danh tính của bạn được riêng tư.\nDecentralization Không có cơ quan trung tâm nào trong I2P. Mạng lưới được duy trì bởi các tình nguyện viên đóng góp băng thông và tài nguyên máy tính. Điều này giúp mạng lưới kháng kiểm duyệt và không có điểm lỗi đơn lẻ.\nTính ẩn danh Tất cả lưu lượng trong I2P được mã hóa đầu cuối đến đầu cuối. Thông điệp được mã hóa nhiều lần khi chúng đi qua mạng, tương tự như cách Tor hoạt động nhưng có những khác biệt quan trọng trong cách triển khai.\nHow It Works Phi tập trung I2P sử dụng \u0026ldquo;tunnel\u0026rdquo; để định tuyến lưu lượng. Khi bạn gửi hoặc nhận dữ liệu:\nRouter của bạn tạo một outbound tunnel (để gửi) Router của bạn tạo một inbound tunnel (để nhận) Các thông điệp được mã hóa và gửi qua nhiều router Mỗi router chỉ biết điểm trước và điểm tiếp theo, không biết toàn bộ đường đi Mã hóa đầu cuối (End-to-End Encryption) I2P cải tiến định tuyến onion truyền thống bằng \u0026ldquo;garlic routing\u0026rdquo;:\nNhiều thông điệp có thể được gộp lại với nhau (giống như các tép trong củ tỏi) Điều này mang lại hiệu suất tốt hơn và tính ẩn danh bổ sung Làm cho việc phân tích lưu lượng trở nên khó khăn hơn Network Database I2P duy trì một cơ sở dữ liệu mạng phân tán chứa:\nThông tin router Địa chỉ đích (tương tự như các trang web .i2p) Dữ liệu định tuyến được mã hóa Common Use Cases Tunnel Lưu trữ hoặc truy cập các trang web có đuôi .i2p - những trang này chỉ có thể truy cập được trong mạng I2P và cung cấp đảm bảo ẩn danh mạnh mẽ cho cả người lưu trữ lẫn người truy cập.\nGarlic Routing Chia sẻ tệp tin ẩn danh bằng BitTorrent qua I2P. Nhiều ứng dụng torrent đã tích hợp sẵn hỗ trợ I2P.\nCơ sở dữ liệu mạng Gửi và nhận email ẩn danh bằng I2P-Bote hoặc các ứng dụng email khác được thiết kế cho I2P.\nMessaging Sử dụng IRC, nhắn tin tức thời, hoặc các công cụ giao tiếp khác một cách riêng tư qua mạng I2P.\nGetting Started Sẵn sàng dùng thử I2P? Ghé thăm trang tải xuống của chúng tôi để cài đặt I2P trên hệ thống của bạn.\nĐể biết thêm chi tiết kỹ thuật, xem Technical Introduction hoặc khám phá toàn bộ tài liệu .\nCách Thức Hoạt Động Giới thiệu Kỹ thuật - Các khái niệm kỹ thuật chuyên sâu hơn Mô hình Mối đe dọa - Hiểu về mô hình bảo mật của I2P So sánh với Tor - I2P khác biệt với Tor như thế nào Mật mã học - Chi tiết về các thuật toán mật mã của I2P ","description":"Giới thiệu dễ hiểu hơn về mạng ẩn danh I2P","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"Giới thiệu về I2P","url":"/vi/docs/overview/intro/"},{"categories":null,"content":"Khi điều kiện mạng khiến git clone không ổn định, bạn có thể phân phối repository dưới dạng git bundle qua BitTorrent hoặc bất kỳ phương thức truyền tải file nào khác. Bundle là một file đơn chứa toàn bộ lịch sử của repository. Sau khi tải xuống, bạn fetch từ nó ở local rồi chuyển lại về remote upstream.\n1. Trước Khi Bắt Đầu Tạo bundle yêu cầu bản sao Git đầy đủ. Các bản sao nông (shallow clone) được tạo bằng --depth 1 sẽ âm thầm tạo ra các bundle bị lỗi mà có vẻ hoạt động nhưng thất bại khi người khác cố gắng sử dụng chúng. Luôn fetch từ nguồn đáng tin cậy (GitHub tại github.com/i2p/i2p.i2p , I2P Gitea instance tại i2pgit.org , hoặc git.idk.i2p qua I2P) và chạy git fetch --unshallow nếu cần thiết để chuyển đổi bất kỳ bản sao nông nào thành bản sao đầy đủ trước khi tạo bundle.\nNếu bạn chỉ sử dụng một bundle hiện có, chỉ cần tải xuống. Không cần chuẩn bị đặc biệt gì.\n2. Tải xuống Gói cài đặt Obtaining the Bundle File Tải file bundle thông qua BitTorrent bằng I2PSnark (trình torrent tích hợp sẵn trong I2P) hoặc các client tương thích I2P khác như BiglyBT với plugin I2P.\nQuan trọng: I2PSnark chỉ hoạt động với các torrent được tạo riêng cho mạng I2P. Các torrent clearnet thông thường không tương thích vì I2P sử dụng Destination (địa chỉ dài 387+ byte) thay vì địa chỉ IP và cổng.\nVị trí file bundle phụ thuộc vào loại cài đặt I2P của bạn:\nCài đặt người dùng/thủ công (cài đặt bằng trình cài đặt Java): ~/.i2p/i2psnark/ Cài đặt hệ thống/daemon (cài đặt qua apt-get hoặc trình quản lý gói): /var/lib/i2p/i2p-config/i2psnark/ Người dùng BiglyBT sẽ tìm thấy các tệp đã tải xuống trong thư mục downloads đã cấu hình của họ.\nCloning from the Bundle Phương pháp tiêu chuẩn (hoạt động trong hầu hết các trường hợp):\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle Nếu bạn gặp lỗi fatal: multiple updates for ref (một vấn đề đã biết trong Git 2.21.0 trở lên khi cấu hình Git toàn cục chứa các refspec fetch xung đột), hãy sử dụng phương pháp khởi tạo thủ công:\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle Ngoài ra, bạn có thể sử dụng cờ --update-head-ok:\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; Lấy Tệp Bundle Sau khi clone từ bundle, hãy trỏ bản clone của bạn vào remote chính thức để các lần fetch sau sẽ đi qua I2P hoặc clearnet:\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p Hoặc để truy cập clearnet:\ngit remote set-url origin https://github.com/i2p/i2p.i2p Để truy cập SSH qua I2P, bạn cần cấu hình một tunnel SSH client trong bảng điều khiển I2P router của mình (thường là cổng 7670) trỏ đến g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p. Nếu sử dụng cổng không chuẩn:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle Sao chép từ Bundle Đảm bảo repository của bạn được cập nhật đầy đủ với một bản clone hoàn chỉnh (không phải shallow):\ngit fetch --all Nếu bạn có shallow clone, hãy chuyển đổi nó trước:\ngit fetch --unshallow Chuyển sang Remote Trực Tiếp Sử dụng target build của Ant (được khuyến nghị cho cây mã nguồn I2P):\nant git-bundle Lệnh này tạo ra cả i2p.i2p.bundle (file bundle) và i2p.i2p.bundle.torrent (metadata BitTorrent).\nSử dụng git bundle trực tiếp:\ngit bundle create i2p.i2p.bundle --all Đối với các bundle chọn lọc hơn:\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle Luôn xác minh bundle trước khi phân phối:\ngit bundle verify i2p.i2p.bundle Điều này xác nhận bundle hợp lệ và hiển thị các commit điều kiện tiên quyết cần thiết.\nĐiều kiện tiên quyết Sao chép bundle và metadata torrent của nó vào thư mục I2PSnark của bạn:\nĐối với cài đặt người dùng:\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ Đối với cài đặt hệ thống:\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ I2PSnark tự động phát hiện và tải các tệp .torrent trong vòng vài giây. Truy cập giao diện web tại http://127.0.0.1:7657/i2psnark để bắt đầu seed.\n4. Creating Incremental Bundles Để cập nhật định kỳ, hãy tạo các bundle tăng dần chỉ chứa các commit mới kể từ bundle trước đó:\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master Người dùng có thể tải về từ gói cập nhật gia tăng nếu họ đã có kho lưu trữ cơ sở:\ngit fetch /path/to/update.bundle Luôn xác minh các gói tăng dần (incremental bundles) hiển thị các commit điều kiện tiên quyết như mong đợi:\ngit bundle verify update.bundle 5. Updating After the Initial Clone Sau khi bạn có một repository hoạt động từ bundle, hãy xử lý nó như bất kỳ bản sao Git clone nào khác:\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master Hoặc cho các quy trình đơn giản hơn:\ngit fetch origin git pull origin master 3. Tạo Bundle Phân phối kiên cường: Các repository lớn có thể được chia sẻ qua BitTorrent, tự động xử lý việc thử lại, xác minh từng phần và tiếp tục tải. Bootstrap ngang hàng: Những người đóng góp mới có thể bootstrap bản clone của họ từ các peer gần đó trên mạng I2P, sau đó tải các thay đổi tăng dần trực tiếp từ Git host. Giảm tải cho server: Các mirror có thể công bố các bundle định kỳ để giảm áp lực lên các Git host hoạt động, đặc biệt hữu ích cho các repository lớn hoặc điều kiện mạng chậm. Vận chuyển ngoại tuyến: Các bundle hoạt động trên bất kỳ phương thức truyền tệp nào (USB drive, truyền trực tiếp, sneakernet), không chỉ BitTorrent. Bundles không thay thế remotes trực tiếp. Chúng chỉ đơn giản cung cấp phương pháp bootstrapping ổn định hơn cho việc clone ban đầu hoặc các cập nhật lớn.\n7. Troubleshooting Tạo Bundle Vấn đề: Tạo bundle thành công nhưng người khác không thể clone từ bundle.\nNguyên nhân: Bản sao nguồn của bạn là shallow (được tạo với tùy chọn --depth).\nGiải pháp: Chuyển đổi sang bản sao đầy đủ (full clone) trước khi tạo bundle:\ngit fetch --unshallow Xác minh Bundle của bạn Vấn đề: fatal: multiple updates for ref khi clone từ bundle.\nNguyên nhân: Git 2.21.0+ xung đột với các refspec fetch toàn cục trong ~/.gitconfig.\nGiải pháp: 1. Sử dụng khởi tạo thủ công: mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle 2. Sử dụng cờ --update-head-ok: git fetch --update-head-ok /path/to/bundle '*:*' 3. Xóa cấu hình xung đột: git config --global --unset remote.origin.fetch\nPhân phối qua I2PSnark Vấn đề: git bundle verify báo thiếu các điều kiện tiên quyết.\nNguyên nhân: Bundle tăng dần hoặc bản sao source không đầy đủ.\nGiải pháp: Tải các commit tiên quyết hoặc sử dụng bundle cơ sở trước, sau đó áp dụng các bản cập nhật tăng dần.\n","description":"Tải và phân phối kho lưu trữ lớn với git bundle và BitTorrent","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"Git Bundles cho I2P","url":"/vi/docs/applications/git-bundle/"},{"categories":null,"content":"Việc sao chép và đẩy các kho lưu trữ bên trong I2P sử dụng các lệnh Git giống như bạn đã biết—client của bạn chỉ đơn giản là kết nối thông qua các tunnel I2P thay vì TCP/IP. Hướng dẫn này sẽ hướng dẫn bạn cách thiết lập tài khoản, cấu hình tunnel, và xử lý các liên kết chậm.\nBắt đầu nhanh: Truy cập chỉ đọc hoạt động thông qua HTTP proxy: http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git. Thực hiện các bước bên dưới để có quyền truy cập đọc/ghi qua SSH.\n1. Tạo Tài Khoản Chọn một dịch vụ Git I2P và đăng ký:\nBên trong I2P: http://git.idk.i2p Mirror clearnet: https://i2pgit.org Việc đăng ký có thể yêu cầu phê duyệt thủ công; kiểm tra trang đích để biết hướng dẫn. Sau khi được phê duyệt, hãy fork hoặc tạo một repository để bạn có thứ gì đó để thử nghiệm.\n2. Cấu hình I2PTunnel Client (SSH) Mở bảng điều khiển router → I2PTunnel và thêm một tunnel Client mới. Nhập destination của dịch vụ (Base32 hoặc Base64). Đối với git.idk.i2p, bạn sẽ tìm thấy cả destination HTTP và SSH trên trang chủ của dự án. Chọn một cổng cục bộ (ví dụ localhost:7442). Bật tự động khởi động nếu bạn có kế hoạch sử dụng tunnel thường xuyên. Giao diện người dùng sẽ xác nhận tunnel mới và hiển thị trạng thái của nó. Khi đang chạy, các SSH client có thể kết nối tới 127.0.0.1 trên cổng đã chọn.\n3. Sao chép qua SSH Sử dụng cổng tunnel với GIT_SSH_COMMAND hoặc một đoạn cấu hình SSH:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git Nếu lần thử đầu tiên thất bại (các tunnel có thể chậm), hãy thử shallow clone:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow Cấu hình Git để tải về tất cả các nhánh:\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin Mẹo Tối Ưu Hiệu Suất Thêm một hoặc hai tunnel dự phòng trong trình chỉnh sửa tunnel để cải thiện khả năng phục hồi. Đối với việc thử nghiệm hoặc các repo có rủi ro thấp, bạn có thể giảm độ dài tunnel xuống 1 hop, nhưng hãy lưu ý về sự đánh đổi tính ẩn danh. Giữ GIT_SSH_COMMAND trong môi trường của bạn hoặc thêm một mục vào ~/.ssh/config: Host git.i2p HostName 127.0.0.1 Port 7442 User git Sau đó clone bằng lệnh git clone git@git.i2p:namespace/project.git.\n4. Gợi ý Quy trình Làm việc Áp dụng quy trình làm việc fork-and-branch phổ biến trên GitLab/GitHub:\nThiết lập remote upstream: git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p Giữ master của bạn đồng bộ: git pull upstream master Tạo các nhánh tính năng cho thay đổi: git checkout -b feature/new-thing Đẩy các nhánh lên fork của bạn: git push origin feature/new-thing Gửi merge request, sau đó fast-forward master của fork từ upstream. 5. Nhắc nhở về Quyền riêng tư Git lưu trữ dấu thời gian commit theo múi giờ địa phương của bạn. Để buộc sử dụng dấu thời gian UTC: git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; Sử dụng git utccommit thay vì git commit khi vấn đề riêng tư quan trọng.\nTránh nhúng các URL clearnet hoặc địa chỉ IP vào thông điệp commit hoặc metadata của repository nếu tính ẩn danh là một mối quan tâm. 6. Khắc phục sự cố Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. Đối với các kịch bản nâng cao (sao chép repo bên ngoài, phân phối bundle), xem các hướng dẫn bổ sung: [Quy trình làm việc với Git bundle](/docs/applications/git-bundle/) và [Lưu trữ GitLab trên I2P](/docs/guides/gitlab/). ","description":"Kết nối các Git client với các dịch vụ lưu trữ trên I2P như i2pgit.org","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"Git qua I2P","url":"/vi/docs/applications/git/"},{"categories":null,"content":" Trạng thái cũ: Nội dung này được giữ lại chỉ để tham khảo lịch sử. Nó mô tả hệ thống tunnel được phát hành trước I2P 0.6.1.10 và không nên dùng cho phát triển hiện đại. Tham khảo triển khai hiện tại để có hướng dẫn cho môi trường sản xuất.\nHệ thống con tunnel ban đầu cũng sử dụng các tunnel một chiều, nhưng khác biệt ở bố cục thông điệp, cơ chế phát hiện trùng lặp và chiến lược xây dựng tunnel. Nhiều phần bên dưới phản chiếu cấu trúc của tài liệu đã ngừng dùng (deprecated) để hỗ trợ việc so sánh.\n1. Tổng quan về Tunnel Các Tunnel được xây dựng thành các chuỗi có thứ tự gồm các router do bên tạo lựa chọn. Độ dài Tunnel nằm trong khoảng 0–7 hop (chặng nhảy), với nhiều tham số điều chỉnh cho việc đệm dữ liệu, giới hạn tốc độ và tạo lưu lượng nhiễu. Các tunnel vào chuyển tiếp thông điệp từ một cổng không tin cậy tới bên tạo (điểm cuối); các tunnel ra đẩy dữ liệu đi khỏi bên tạo. Thời gian sống của Tunnel là 10 phút, sau đó các Tunnel mới được tạo (thường sử dụng cùng các router nhưng ID tunnel khác). 2. Hoạt động trong thiết kế cũ 2.1 Tiền xử lý thông điệp Các gateway (cổng) đã tích lũy ≤32 KB tải trọng I2NP, chọn phần đệm (padding), và tạo ra một tải trọng chứa:\nMột trường độ dài phần đệm gồm hai byte và số byte ngẫu nhiên tương ứng Một dãy các cặp {instructions, I2NP message} mô tả đích chuyển phát, phân mảnh, và các độ trễ tùy chọn Các thông điệp I2NP đầy đủ được đệm để căn chỉnh tới ranh giới 16 byte Các chỉ thị chuyển phát đóng gói thông tin định tuyến vào các trường bit (loại chuyển phát, các cờ trì hoãn, các cờ phân mảnh và các phần mở rộng tùy chọn). Các thông điệp bị phân mảnh mang theo một ID thông điệp 4 byte cùng với một cờ chỉ mục/mảnh cuối.\n2.2 Mã hóa Gateway Thiết kế cũ cố định độ dài tunnel ở mức tám chặng trong giai đoạn mã hóa. Các gateway xếp chồng các khối AES-256/CBC cùng với checksum để mỗi chặng có thể xác minh tính toàn vẹn mà không làm giảm kích thước payload. Bản thân checksum là một khối dẫn xuất từ SHA-256 được nhúng trong thông điệp.\n2.3 Hành vi của người tham gia Các bên tham gia theo dõi các ID của inbound tunnel, xác minh tính toàn vẹn từ sớm và loại bỏ các bản trùng lặp trước khi chuyển tiếp. Vì các khối đệm (padding) và khối xác minh được nhúng sẵn, kích thước thông điệp vẫn không đổi bất kể số bước nhảy.\n2.4 Xử lý điểm cuối Các điểm cuối đã giải mã các khối phân lớp một cách tuần tự, xác minh các checksum, và tách tải trọng trở lại thành các chỉ thị đã mã hóa cùng với các thông điệp I2NP để tiếp tục chuyển tiếp.\n3. Xây dựng Tunnel (Quy trình đã lỗi thời) Lựa chọn nút ngang hàng: Các nút ngang hàng được chọn từ các hồ sơ được duy trì cục bộ (exploratory (thăm dò) so với client (khách)). Tài liệu gốc đã nhấn mạnh việc giảm thiểu predecessor attack (tấn công tiền nhiệm) bằng cách tái sử dụng các danh sách nút ngang hàng có thứ tự cho mỗi nhóm tunnel (tunnel pool). Chuyển phát yêu cầu: Các thông điệp dựng tunnel được chuyển tiếp theo từng hop (bước nhảy), với các phần được mã hóa cho từng nút ngang hàng. Các ý tưởng thay thế như telescopic extension (mở rộng dạng telescopic), midstream rerouting (định tuyến lại giữa dòng), hoặc loại bỏ các khối checksum đã được thảo luận như các thử nghiệm nhưng chưa bao giờ được áp dụng. Gom nhóm (pooling): Mỗi đích cục bộ có các pool vào (inbound) và ra (outbound) riêng biệt. Các thiết lập bao gồm số lượng mong muốn, các tunnel dự phòng, độ biến thiên độ dài, throttling (hạn chế tốc độ), và các chính sách padding (đệm). 4. Các khái niệm về giới hạn tốc độ và trộn Bài viết trước đây đã đề xuất một số chiến lược giúp định hình các bản phát hành sau này:\nCơ chế loại bỏ sớm ngẫu nhiên có trọng số (WRED) để kiểm soát tắc nghẽn Các giới hạn theo từng tunnel dựa trên trung bình trượt của mức sử dụng gần đây Các điều khiển nhiễu giả và gom lô tùy chọn (chưa được triển khai đầy đủ) 5. Các lựa chọn thay thế đã lưu trữ Các phần của tài liệu gốc đã khám phá các ý tưởng chưa bao giờ được triển khai:\nLoại bỏ các khối checksum (kiểm tra tổng) để giảm khối lượng xử lý trên mỗi bước nhảy Thực hiện telescoping (mở rộng tuần tự) tunnels trong khi đang truyền để thay đổi thành phần nút ngang hàng Chuyển sang tunnels hai chiều (cuối cùng đã bị bác bỏ) Sử dụng các mã băm ngắn hơn hoặc các cách thức đệm khác Những ý tưởng này vẫn là bối cảnh lịch sử có giá trị nhưng không phản ánh cơ sở mã hiện nay.\nTài liệu tham khảo Kho lưu trữ tài liệu legacy gốc (trước 0.6.1.10) Tổng quan về Tunnel cho thuật ngữ hiện hành Lập hồ sơ và lựa chọn nút ngang hàng cho các heuristic hiện đại ","description":"Mô tả đã lưu trữ về thiết kế tunnel được sử dụng trước I2P 0.6.1.10.","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"Hiện thực Tunnel cũ (di sản)","url":"/vi/docs/legacy/old-implementation/"},{"categories":null,"content":"Hiệu Năng Mạng I2P: Tốc Độ, Kết Nối và Quản Lý Tài Nguyên Mạng I2P hoàn toàn động. Mỗi client được các node khác biết đến và kiểm tra các node đã biết cục bộ về khả năng kết nối và năng lực. Chỉ những node có thể kết nối được và có đủ năng lực mới được lưu vào NetDB cục bộ. Trong quá trình xây dựng tunnel, các tài nguyên tốt nhất được chọn từ nhóm này để xây dựng tunnel. Do việc kiểm tra diễn ra liên tục, nhóm các node sẽ thay đổi. Mỗi node I2P biết một phần khác nhau của NetDB, có nghĩa là mỗi router có một tập hợp các node I2P khác nhau để sử dụng cho tunnel. Ngay cả khi hai router có cùng tập hợp con các node đã biết, các bài kiểm tra về khả năng kết nối và năng lực có thể sẽ cho kết quả khác nhau, vì các router khác có thể đang chịu tải ngay khi một router kiểm tra, nhưng lại rảnh khi router thứ hai kiểm tra.\nĐiều này giải thích tại sao mỗi node I2P có các node khác nhau để xây dựng tunnel. Bởi vì mỗi node I2P có độ trễ và băng thông khác nhau, các tunnel (được xây dựng thông qua những node đó) có các giá trị độ trễ và băng thông khác nhau. Và bởi vì mỗi node I2P có các tunnel được xây dựng khác nhau, không có hai node I2P nào có cùng bộ tunnel giống nhau.\nMột server/client được gọi là một \u0026ldquo;destination\u0026rdquo; và mỗi destination có ít nhất một tunnel vào và một tunnel ra. Mặc định là 3 hop mỗi tunnel. Điều này tổng cộng là 12 hop (12 node I2P khác nhau) cho một hành trình khứ hồi đầy đủ client → server → client.\nMỗi gói dữ liệu được gửi qua 6 node I2P khác cho đến khi đến được máy chủ:\nclient - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - server\nvà trên đường quay lại qua 6 node I2P khác nhau:\nserver - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - client\nLưu lượng trên mạng cần một ACK trước khi dữ liệu mới được gửi; nó cần đợi cho đến khi một ACK quay trở về từ máy chủ: gửi dữ liệu, đợi ACK, gửi thêm dữ liệu, đợi ACK. Khi RTT (Round Trip Time - Thời gian khứ hồi) cộng dồn từ độ trễ của từng node I2P riêng lẻ và mỗi kết nối trong hành trình khứ hồi này, thường mất 1–3 giây cho đến khi một ACK quay trở về client. Do thiết kế giao thức TCP và I2P transport, một gói dữ liệu có kích thước giới hạn. Kết hợp các điều kiện này đặt ra một giới hạn băng thông tối đa cho mỗi tunnel khoảng 20–50 kB/s. Tuy nhiên, nếu chỉ một hop trong tunnel chỉ có 5 kB/s băng thông để sử dụng, toàn bộ tunnel sẽ bị giới hạn ở 5 kB/s, độc lập với độ trễ và các giới hạn khác.\nMã hóa, độ trễ và cách một tunnel được xây dựng khiến việc tạo tunnel tốn khá nhiều thời gian CPU. Đây là lý do tại sao một destination chỉ được phép có tối đa 6 inbound tunnels và 6 outbound tunnels để truyền tải dữ liệu. Với tốc độ tối đa 50 kB/s mỗi tunnel, một destination có thể sử dụng khoảng 300 kB/s lưu lượng tổng hợp (trong thực tế có thể cao hơn nếu sử dụng các tunnel ngắn hơn với mức ẩn danh thấp hoặc không có). Các tunnel đang sử dụng sẽ bị loại bỏ sau mỗi 10 phút và những tunnel mới được xây dựng. Sự thay đổi tunnel này, cùng với việc đôi khi các client bị tắt hoặc mất kết nối với mạng, đôi khi sẽ làm hỏng các tunnel và kết nối. Một ví dụ về điều này có thể được thấy trên IRC2P Network khi mất kết nối (ping timeout) hoặc khi sử dụng eepget.\nVới một tập hợp đích hạn chế và một số lượng tunnel hạn chế cho mỗi đích, một node I2P chỉ sử dụng một tập hợp tunnel hạn chế qua các node I2P khác. Ví dụ, nếu một node I2P là \u0026ldquo;hop1\u0026rdquo; trong ví dụ nhỏ ở trên, nó chỉ thấy một participating tunnel bắt nguồn từ client. Nếu chúng ta tổng hợp toàn bộ mạng I2P, chỉ có một số lượng khá hạn chế các participating tunnel có thể được xây dựng với một lượng băng thông hạn chế tổng cộng. Nếu phân bổ những con số hạn chế này trên số lượng các node I2P, chỉ có một phần nhỏ băng thông/dung lượng khả dụng có thể được sử dụng.\nĐể duy trì tính ẩn danh, một router không nên được sử dụng bởi toàn bộ mạng lưới để xây dựng tunnel. Nếu một router đóng vai trò là tunnel router cho tất cả các node I2P, nó sẽ trở thành một điểm thất bại trung tâm rất thực tế cũng như là một điểm tập trung để thu thập IP và dữ liệu từ các client. Đây là lý do tại sao mạng lưới phân phối lưu lượng truy cập qua các node trong quá trình xây dựng tunnel.\nMột yếu tố khác cần xem xét về hiệu năng là cách I2P xử lý mesh networking. Mỗi kết nối hop-to-hop sử dụng một kết nối TCP hoặc UDP trên các I2P node. Với 1000 kết nối, ta sẽ thấy 1000 kết nối TCP. Đó là một con số khá lớn, và một số router gia đình cũng như văn phòng nhỏ chỉ cho phép một số lượng kết nối hạn chế. I2P cố gắng giới hạn các kết nối này xuống dưới 1500 cho mỗi loại UDP và TCP. Điều này cũng giới hạn lượng traffic được định tuyến qua một I2P node.\nNếu một node có thể truy cập được, có cài đặt băng thông chia sẻ \u0026gt;128 kB/s và hoạt động 24/7, nó sẽ được sử dụng sau một thời gian để tham gia lưu lượng. Nếu nó ngừng hoạt động trong khoảng thời gian đó, việc kiểm tra node I2P được thực hiện bởi các node khác sẽ cho họ biết rằng nó không thể truy cập được. Điều này sẽ chặn node đó trong ít nhất 24 giờ trên các node khác. Vì vậy, các node khác đã kiểm tra và thấy node đó ngừng hoạt động sẽ không sử dụng node đó trong 24 giờ để xây dựng tunnel. Đây là lý do tại sao lưu lượng của bạn thấp hơn sau khi khởi động lại/tắt router I2P của bạn trong tối thiểu 24 giờ.\nNgoài ra, các node I2P khác cần biết một I2P router để kiểm tra khả năng truy cập và năng lực của nó. Quá trình này có thể được thực hiện nhanh hơn khi bạn tương tác với mạng, ví dụ như sử dụng các ứng dụng hoặc truy cập các trang web I2P, điều này sẽ dẫn đến việc xây dựng tunnel nhiều hơn và do đó có nhiều hoạt động và khả năng truy cập hơn để các node trên mạng kiểm tra.\nLịch sử Hiệu suất (đã chọn) Qua nhiều năm, I2P đã chứng kiến một số cải tiến hiệu năng đáng chú ý:\nNative math Được triển khai thông qua JNI bindings tới thư viện GNU MP (GMP) để tăng tốc modPow của BigInteger, trước đây chiếm phần lớn thời gian CPU. Kết quả ban đầu cho thấy tốc độ tăng đáng kể trong mã hóa khóa công khai. Xem: /misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) Trước đây, các phản hồi thường yêu cầu tra cứu LeaseSet của người gửi trong cơ sở dữ liệu mạng. Việc đính kèm LeaseSet của người gửi vào garlic ban đầu giúp cải thiện độ trễ phản hồi. Hiện tại điều này được thực hiện có chọn lọc (khi bắt đầu kết nối hoặc khi LeaseSet thay đổi) để giảm chi phí hoạt động.\nToán học gốc Đã di chuyển một số bước xác thực sớm hơn trong quá trình bắt tay transport để từ chối các peer xấu sớm hơn (đồng hồ sai, NAT/firewall xấu, phiên bản không tương thích), tiết kiệm CPU và băng thông.\nGarlic wrapping một \u0026ldquo;reply\u0026rdquo; LeaseSet (được điều chỉnh) Sử dụng kiểm tra tunnel nhận biết ngữ cảnh: tránh kiểm tra các tunnel đã biết đang truyền dữ liệu; ưu tiên kiểm tra khi rảnh rỗi. Điều này giảm thiểu chi phí hoạt động và tăng tốc độ phát hiện các tunnel bị lỗi.\nTừ chối TCP hiệu quả hơn Duy trì các lựa chọn cho một kết nối nhất định giúp giảm hiện tượng giao hàng không theo thứ tự và cho phép thư viện streaming tăng kích thước cửa sổ, cải thiện thông lượng.\nĐiều chỉnh kiểm tra tunnel GZip hoặc tương tự cho các cấu trúc dài dòng (ví dụ: tùy chọn RouterInfo) giảm băng thông khi phù hợp.\nLựa chọn tunnel/lease cố định Thay thế cho giao thức \u0026ldquo;ministreaming\u0026rdquo; đơn giản. Streaming hiện đại bao gồm selective ACK và kiểm soát tắc nghẽn được tùy chỉnh cho nền tảng hướng thông điệp ẩn danh của I2P. Xem: /docs/api/streaming/\nFuture Performance Improvements (historical ideas) Dưới đây là các ý tưởng được ghi chép lịch sử như những cải tiến tiềm năng. Nhiều trong số đó đã lỗi thời, đã được triển khai, hoặc đã được thay thế bởi các thay đổi kiến trúc.\nNén các cấu trúc dữ liệu đã chọn Cải thiện cách các router chọn peer để xây dựng tunnel nhằm tránh những peer chậm hoặc quá tải, đồng thời duy trì khả năng chống lại các cuộc tấn công Sybil từ những kẻ đối đầu có quyền lực.\nGiao thức streaming đầy đủ Giảm việc khám phá không cần thiết khi keyspace ổn định; điều chỉnh số lượng peer được trả về trong các tra cứu và số lượng tìm kiếm đồng thời được thực hiện.\nSession Tag tuning and improvements (legacy) Đối với cơ chế ElGamal/AES+SessionTag cũ, các chiến lược hết hạn và bổ sung thông minh hơn giúp giảm thiểu việc quay về ElGamal và lãng phí tag.\nCải thiện việc phân tích và lựa chọn peer Tạo các tag từ PRNG đồng bộ được khởi tạo trong quá trình thiết lập phiên mới, giảm overhead trên mỗi thông điệp so với các tag được phân phối trước.\nĐiều chỉnh cơ sở dữ liệu mạng Thời gian sống của tunnel dài hơn kết hợp với healing có thể giảm chi phí rebuild; cân bằng với tính ẩn danh và độ tin cậy.\nĐiều chỉnh và cải tiến Session Tag (phiên bản cũ) Từ chối các peer không hợp lệ sớm hơn và làm cho các bài kiểm tra tunnel nhận biết ngữ cảnh tốt hơn để giảm tranh chấp và độ trễ.\nChuyển đổi SessionTag sang PRNG đồng bộ hóa (legacy) Selective LeaseSet bundling, tùy chọn nén RouterInfo, và việc áp dụng giao thức streaming đầy đủ đều góp phần cải thiện hiệu năng cảm nhận được tốt hơn.\nXem thêm:\nĐịnh tuyến Tunnel Lựa chọn Peer Transports Đặc tả SSU2 và Đặc tả NTCP2 ","description":"Hiệu suất mạng I2P: cách hoạt động hiện nay, các cải tiến trong quá khứ, và ý tưởng điều chỉnh trong tương lai","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"Hiệu năng","url":"/vi/docs/overview/performance/"},{"categories":null,"content":"Hướng dẫn này cung cấp tổng quan về Bảng điều khiển I2P Router và các trang cấu hình của nó. Mỗi phần giải thích chức năng của trang và mục đích sử dụng, giúp bạn hiểu cách giám sát và cấu hình I2P router của mình.\nTruy cập Router Console I2P Router Console là trung tâm điều khiển chính để quản lý và giám sát router I2P của bạn. Theo mặc định, bạn có thể truy cập tại I2P Router Console sau khi router I2P của bạn đã chạy.\nTrang chủ hiển thị một số phần quan trọng:\nỨng dụng - Truy cập nhanh các ứng dụng I2P tích hợp như Email, Torrents, Trình quản lý Hidden Services và Web Server Trang cộng đồng I2P - Liên kết đến các nguồn tài nguyên cộng đồng quan trọng bao gồm diễn đàn, tài liệu và trang web dự án Cấu hình và Trợ giúp - Công cụ để cấu hình băng thông, quản lý plugin và truy cập tài nguyên trợ giúp Thông tin mạng và nhà phát triển - Truy cập biểu đồ, nhật ký, tài liệu kỹ thuật và thống kê mạng Sổ Địa Chỉ URL: Address Book Sổ địa chỉ I2P hoạt động tương tự như DNS trên clearnet, cho phép bạn quản lý các tên dễ đọc cho các đích đến I2P (eepsites). Đây là nơi bạn có thể xem và thêm địa chỉ I2P vào sổ địa chỉ cá nhân của mình.\nHệ thống sổ địa chỉ hoạt động thông qua nhiều tầng:\nLocal Records - Sổ địa chỉ cá nhân của bạn chỉ được lưu trữ trên router của bạn\nLocal Addressbook - Các host bạn thêm thủ công hoặc lưu lại cho mục đích sử dụng riêng Private Addressbook - Các địa chỉ bạn không muốn chia sẻ với người khác; không bao giờ được phân phối công khai Subscriptions - Các nguồn sổ địa chỉ từ xa (như http://i2p-projekt.i2p/hosts.txt) tự động cập nhật sổ địa chỉ của router với các trang I2P đã biết\nRouter Addressbook - Kết quả tổng hợp từ các bản ghi cục bộ và đăng ký của bạn, có thể tìm kiếm bởi tất cả các ứng dụng I2P trên router của bạn\nPublished Addressbook - Tùy chọn chia sẻ công khai sổ địa chỉ của bạn để người khác sử dụng như một nguồn đăng ký (hữu ích nếu bạn đang vận hành một I2P site)\nSổ địa chỉ thường xuyên kiểm tra các đăng ký của bạn và hợp nhất nội dung vào sổ địa chỉ router của bạn, giữ cho tệp hosts.txt của bạn được cập nhật với mạng I2P.\nCấu hình URL: Cấu hình Nâng cao Phần Cấu hình cung cấp quyền truy cập vào tất cả các thiết lập router thông qua nhiều tab chuyên biệt.\nAdvanced Trang cấu hình Nâng cao cung cấp quyền truy cập vào các cài đặt router ở cấp độ thấp mà thường không cần thiết cho hoạt động bình thường. Hầu hết người dùng không nên thay đổi các cài đặt này trừ khi họ hiểu rõ tùy chọn cấu hình cụ thể và tác động của nó đến hành vi của router.\nCác tính năng chính:\nCấu hình Floodfill - Điều khiển việc router của bạn có tham gia với vai trò là floodfill peer hay không, giúp mạng lưới bằng cách lưu trữ và phân phối thông tin network database. Điều này có thể sử dụng nhiều tài nguyên hệ thống hơn nhưng giúp tăng cường mạng lưới I2P.\nCấu hình I2P nâng cao - Truy cập trực tiếp vào tệp router.config, hiển thị tất cả các tham số cấu hình nâng cao bao gồm:\nGiới hạn băng thông và cài đặt burst Cài đặt transport (NTCP2, SSU2, cổng UDP và khóa) Thông tin nhận dạng và phiên bản router Tùy chọn console và cài đặt cập nhật Hầu hết các tùy chọn cấu hình nâng cao không được hiển thị trong giao diện người dùng vì chúng hiếm khi cần thiết. Để bật chỉnh sửa các cài đặt này, bạn phải thêm routerconsole.advanced=true vào tệp router.config của mình theo cách thủ công.\nCảnh báo: Việc chỉnh sửa sai các cài đặt nâng cao có thể ảnh hưởng tiêu cực đến hiệu suất hoặc kết nối của router. Chỉ thay đổi các cài đặt này nếu bạn biết mình đang làm gì.\nBandwidth URL: Cấu hình Băng thông Trang cấu hình Băng thông cho phép bạn kiểm soát lượng băng thông mà router của bạn đóng góp cho mạng I2P. I2P hoạt động tốt nhất khi bạn cấu hình tốc độ phù hợp với tốc độ kết nối internet của bạn.\nCác Cài Đặt Quan Trọng:\nKBps In - Băng thông tối đa mà router của bạn sẽ chấp nhận khi nhận dữ liệu vào (tốc độ tải xuống) KBps Out - Băng thông tối đa mà router của bạn sẽ sử dụng khi gửi dữ liệu ra (tốc độ tải lên) Share - Phần trăm băng thông gửi đi được dành riêng cho lưu lượng tham gia (giúp định tuyến lưu lượng cho người dùng khác) Lưu ý Quan trọng:\nTất cả các giá trị được tính theo byte trên giây (KBps), không phải bit trên giây Càng cung cấp nhiều băng thông, bạn càng giúp ích cho mạng lưới và cải thiện tính ẩn danh của chính mình Lượng băng thông chia sẻ đường lên của bạn (KBps Out) quyết định mức độ đóng góp tổng thể của bạn cho mạng lưới Nếu bạn không chắc chắn về tốc độ mạng của mình, hãy sử dụng Bandwidth Test để đo kiểm tra Băng thông chia sẻ cao hơn giúp cải thiện tính ẩn danh của bạn và củng cố mạng lưới I2P Trang cấu hình hiển thị lưu lượng dữ liệu truyền tải ước tính hàng tháng dựa trên cài đặt của bạn, giúp bạn lên kế hoạch phân bổ băng thông phù hợp với giới hạn gói internet của mình.\nClient Configuration URL: Cấu hình Client Trang Cấu hình Client cho phép bạn kiểm soát các ứng dụng và dịch vụ I2P nào sẽ chạy khi khởi động. Đây là nơi bạn có thể bật hoặc tắt các client I2P tích hợp sẵn mà không cần gỡ cài đặt chúng.\nCảnh báo quan trọng: Hãy cẩn thận khi thay đổi các cài đặt ở đây. Router console và application tunnel là bắt buộc cho hầu hết các mục đích sử dụng I2P. Chỉ người dùng nâng cao mới nên chỉnh sửa các cài đặt này.\nCác Client Khả Dụng:\nApplication tunnels - Hệ thống I2PTunnel quản lý các tunnel client và server (HTTP proxy, IRC, v.v.) I2P Router Console - Giao diện quản trị dựa trên web mà bạn đang sử dụng I2P webserver (eepsite) - Webserver Jetty tích hợp sẵn để lưu trữ website I2P của riêng bạn Open Router Console in web browser at startup - Tự động mở trình duyệt đến trang chủ console khi khởi động SAM application bridge - Cầu nối API để các ứng dụng bên thứ ba kết nối với I2P Mỗi client hiển thị: - Chạy khi Khởi động? - Hộp kiểm để bật/tắt tự động khởi chạy - Điều khiển - Các nút Bắt đầu/Dừng để kiểm soát ngay lập tức - Class và arguments - Thông tin kỹ thuật về cách client được khởi chạy\nCác thay đổi đối với cài đặt \u0026ldquo;Run at Startup?\u0026rdquo; yêu cầu khởi động lại router để có hiệu lực. Tất cả các thay đổi được lưu vào /var/lib/i2p/i2p-config/clients.config.d/.\nNâng cao URL: Cấu hình I2CP Trang cấu hình I2CP (I2P Client Protocol) cho phép bạn cấu hình cách các ứng dụng bên ngoài kết nối với I2P router của bạn. I2CP là giao thức mà các ứng dụng sử dụng để giao tiếp với router nhằm tạo tunnel và gửi/nhận dữ liệu qua I2P.\nQuan trọng: Các cài đặt mặc định sẽ hoạt động tốt cho hầu hết mọi người. Mọi thay đổi được thực hiện ở đây cũng phải được cấu hình trong ứng dụng client bên ngoài. Nhiều client không hỗ trợ SSL hoặc xác thực. Tất cả các thay đổi đều yêu cầu khởi động lại để có hiệu lực.\nCác Tùy Chọn Cấu Hình:\nCấu hình Giao diện I2CP Bên ngoài\nBật không có SSL - Truy cập I2CP tiêu chuẩn (mặc định và tương thích nhất) Bật với yêu cầu SSL - Chỉ cho phép kết nối I2CP được mã hóa Tắt - Chặn các client bên ngoài kết nối qua I2CP I2CP Interface - Giao diện mạng để lắng nghe (mặc định: 127.0.0.1 chỉ cho localhost)\nI2CP Port - Số cổng cho các kết nối I2CP (mặc định: 7654)\nỦy quyền\nYêu cầu tên người dùng và mật khẩu - Bật xác thực cho các kết nối I2CP Tên người dùng - Đặt tên người dùng bắt buộc cho truy cập I2CP Mật khẩu - Đặt mật khẩu bắt buộc cho truy cập I2CP Lưu ý Bảo mật: Nếu bạn chỉ chạy các ứng dụng trên cùng một máy với I2P router của mình, hãy giữ giao diện ở 127.0.0.1 để ngăn chặn truy cập từ xa. Chỉ thay đổi các cài đặt này nếu bạn cần cho phép các ứng dụng I2P từ thiết bị khác kết nối với router của bạn.\nBăng thông URL: Cấu Hình Mạng Trang Cấu hình Mạng cho phép bạn cấu hình cách I2P router của bạn kết nối với internet, bao gồm phát hiện địa chỉ IP, tùy chọn IPv4/IPv6, và cài đặt cổng cho cả UDP và TCP transport.\nĐịa chỉ IP có thể truy cập từ bên ngoài:\nSử dụng tất cả phương thức tự động phát hiện - Tự động phát hiện IP công khai của bạn bằng nhiều phương thức (khuyến nghị) Vô hiệu hóa phát hiện địa chỉ IP qua UPnP - Ngăn việc sử dụng UPnP để khám phá IP của bạn Bỏ qua địa chỉ IP giao diện cục bộ - Không sử dụng IP mạng nội bộ của bạn Chỉ sử dụng phát hiện địa chỉ IP qua SSU - Chỉ sử dụng giao thức truyền tải SSU2 để phát hiện IP Chế độ ẩn - không công bố IP - Ngăn tham gia vào luồng dữ liệu mạng (giảm tính ẩn danh) Chỉ định hostname hoặc IP - Thiết lập thủ công IP công khai hoặc hostname của bạn Cấu hình IPv4:\nVô hiệu hóa kết nối đến (Firewalled) - Chọn tùy chọn này nếu bạn đang ở sau tường lửa, mạng gia đình, ISP, DS-Lite, hoặc carrier-grade NAT chặn các kết nối đến Cấu hình IPv6:\nƯu tiên IPv4 hơn IPv6 - Ưu tiên các kết nối IPv4 Ưu tiên IPv6 hơn IPv4 - Ưu tiên các kết nối IPv6 (mặc định cho mạng dual-stack) Bật IPv6 - Cho phép các kết nối IPv6 Tắt IPv6 - Vô hiệu hóa toàn bộ kết nối IPv6 Chỉ sử dụng IPv6 (tắt IPv4) - Chế độ chỉ IPv6 thử nghiệm Tắt kết nối đến (Firewalled) - Kiểm tra xem IPv6 của bạn có bị tường lửa chặn không Hành Động Khi IP Thay Đổi:\nLaptop mode - Tính năng thử nghiệm thay đổi danh tính router và cổng UDP khi địa chỉ IP của bạn thay đổi để tăng cường tính ẩn danh Cấu hình UDP:\nChỉ định cổng - Đặt một cổng UDP cụ thể cho giao thức truyền tải SSU2 (phải được mở trong tường lửa của bạn) Tắt hoàn toàn - Chỉ chọn nếu đứng sau tường lửa chặn tất cả UDP đi ra ngoài Cấu hình TCP:\nChỉ định cổng - Đặt một cổng TCP cụ thể cho giao vận NTCP2 (phải được mở trong tường lửa của bạn) Sử dụng cùng cổng đã cấu hình cho UDP - Đơn giản hóa cấu hình bằng cách sử dụng một cổng cho cả hai giao vận Sử dụng địa chỉ IP tự động phát hiện - Tự động phát hiện địa chỉ IP công khai của bạn (hiển thị \u0026ldquo;currently unknown\u0026rdquo; nếu chưa được phát hiện hoặc bị chặn bởi tường lửa) Luôn sử dụng địa chỉ IP tự động phát hiện (Không có tường lửa) - Tốt nhất cho các router có kết nối internet trực tiếp Vô hiệu hóa kết nối đến (Có tường lửa) - Chọn nếu các kết nối TCP bị chặn bởi tường lửa của bạn Vô hiệu hóa hoàn toàn - Chỉ chọn nếu đằng sau tường lửa hạn chế hoặc chặn TCP đi ra Chỉ định hostname hoặc IP - Cấu hình thủ công địa chỉ có thể truy cập từ bên ngoài của bạn Quan trọng: Các thay đổi đối với cấu hình mạng có thể yêu cầu khởi động lại router để có hiệu lực đầy đủ. Cấu hình chuyển tiếp cổng (port forwarding) đúng cách sẽ cải thiện đáng kể hiệu suất router của bạn và giúp ích cho mạng I2P.\nCấu hình Client URL: Cấu hình Peer Trang Cấu hình Peer cung cấp các điều khiển thủ công để quản lý từng peer riêng lẻ trên mạng I2P. Đây là tính năng nâng cao thường chỉ được sử dụng để khắc phục sự cố các peer có vấn đề.\nĐiều Khiển Peer Thủ Công:\nRouter Hash - Nhập router hash dạng base64 gồm 44 ký tự của peer mà bạn muốn quản lý Chặn / Bỏ chặn một Peer thủ công:\nCấm một peer ngăn chặn họ tham gia vào bất kỳ tunnel nào bạn tạo ra. Hành động này: - Ngăn peer được sử dụng trong các tunnel của client hoặc exploratory tunnel của bạn - Có hiệu lực ngay lập tức mà không cần khởi động lại - Duy trì cho đến khi bạn thủ công bỏ cấm peer hoặc khởi động lại router của bạn - Cấm peer cho đến khi khởi động lại - Tạm thời chặn peer - Bỏ cấm peer - Gỡ bỏ lệnh cấm trên một peer đã bị chặn trước đó\nĐiều Chỉnh Bonus Của Profile:\nĐiểm thưởng hồ sơ ảnh hưởng đến cách các peer được chọn để tham gia tunnel. Điểm thưởng có thể là dương hoặc âm: - Fast peers - Được sử dụng cho client tunnel yêu cầu tốc độ cao - High Capacity peers - Được sử dụng cho một số exploratory tunnel yêu cầu định tuyến ổn định - Điểm thưởng hiện tại được hiển thị trên trang profiles\nCấu hình: - Tốc độ - Điều chỉnh điểm thưởng tốc độ cho peer này (0 = trung lập) - Dung lượng - Điều chỉnh điểm thưởng dung lượng cho peer này (0 = trung lập) - Điều chỉnh điểm thưởng peer - Áp dụng các thiết lập điểm thưởng\nTrường hợp sử dụng: - Cấm một peer liên tục gây ra vấn đề kết nối - Tạm thời loại trừ một peer mà bạn nghi ngờ là độc hại - Điều chỉnh điểm thưởng để giảm ưu tiên các peer hoạt động kém - Gỡ lỗi các vấn đề xây dựng tunnel bằng cách loại trừ các peer cụ thể\nLưu ý: Hầu hết người dùng sẽ không bao giờ cần sử dụng tính năng này. Router I2P tự động quản lý việc chọn lựa và phân tích peer dựa trên các chỉ số hiệu suất.\nCấu hình I2CP URL: Cấu hình Reseed Trang Cấu hình Reseed cho phép bạn thực hiện reseed thủ công cho router của mình nếu quá trình reseed tự động thất bại. Reseed là quá trình khởi động được sử dụng để tìm các router khác khi bạn lần đầu cài đặt I2P, hoặc khi router của bạn còn quá ít thông tin tham chiếu router.\nKhi Nào Nên Sử Dụng Reseed Thủ Công:\nNếu reseed thất bại, bạn nên kiểm tra kết nối mạng trước\nNếu tường lửa chặn kết nối của bạn đến các máy chủ reseed, bạn có thể sử dụng proxy:\nProxy có thể là proxy công khai từ xa, hoặc có thể đang chạy trên máy tính của bạn (localhost) Để sử dụng proxy, hãy cấu hình loại, host và port trong phần Reseeding Configuration Nếu bạn đang chạy Tor Browser, hãy reseed thông qua nó bằng cách cấu hình SOCKS 5, localhost, port 9150 Nếu bạn đang chạy Tor dòng lệnh, hãy reseed thông qua nó bằng cách cấu hình SOCKS 5, localhost, port 9050 Nếu bạn có một số peer nhưng cần thêm, bạn có thể thử tùy chọn I2P Outproxy. Để trống host và port. Tùy chọn này sẽ không hoạt động cho reseed ban đầu khi bạn chưa có peer nào Sau đó, nhấp \u0026ldquo;Save changes and reseed now\u0026rdquo; Cài đặt mặc định sẽ phù hợp với hầu hết mọi người. Chỉ thay đổi những cài đặt này nếu HTTPS bị chặn bởi tường lửa nghiêm ngặt và reseed đã thất bại Nếu bạn biết và tin tưởng ai đó đang chạy I2P, hãy yêu cầu họ gửi cho bạn một tệp reseed được tạo bằng trang này trên bảng điều khiển router của họ. Sau đó, sử dụng trang này để reseed với tệp bạn đã nhận. Đầu tiên, chọn tệp bên dưới. Tiếp theo, nhấp vào \u0026ldquo;Reseed from file\u0026rdquo;\nNếu bạn biết và tin tưởng ai đó công bố các tệp reseed, hãy hỏi họ để lấy URL. Sau đó, sử dụng trang này để reseed với URL bạn nhận được. Đầu tiên, nhập URL vào bên dưới. Tiếp theo, nhấp vào \u0026ldquo;Reseed from URL\u0026rdquo;\nXem câu hỏi thường gặp (FAQ) để biết hướng dẫn reseed thủ công\nTùy chọn Reseed Thủ công:\nReseed từ URL - Nhập URL zip hoặc su3 từ nguồn đáng tin cậy và nhấp vào \u0026ldquo;Reseed from URL\u0026rdquo;\nĐịnh dạng su3 được ưu tiên vì nó sẽ được xác minh là đã được ký bởi nguồn đáng tin cậy Định dạng zip không được ký; chỉ sử dụng tệp zip từ nguồn mà bạn tin tưởng Reseed từ File - Duyệt và chọn một file zip hoặc su3 cục bộ, sau đó nhấp vào \u0026ldquo;Reseed from file\u0026rdquo;\nBạn có thể tìm các file reseed tại checki2p.com/reseed Tạo File Reseed - Tạo một file zip reseed mới mà bạn có thể chia sẻ cho người khác để reseed thủ công\nFile này sẽ không bao giờ chứa danh tính hoặc IP của router của bạn Cấu hình Reseeding:\nCài đặt mặc định sẽ hoạt động cho hầu hết người dùng. Chỉ thay đổi những cài đặt này nếu HTTPS bị chặn bởi tường lửa hạn chế và reseed đã thất bại.\nURL Reseed - Danh sách các URL HTTPS đến máy chủ reseed (danh sách mặc định được tích hợp sẵn và cập nhật thường xuyên) Cấu hình Proxy - Cấu hình HTTP/HTTPS/SOCKS proxy nếu bạn cần truy cập máy chủ reseed thông qua proxy Đặt lại danh sách URL - Khôi phục danh sách máy chủ reseed mặc định Quan trọng: Việc reseed thủ công chỉ cần thiết trong những trường hợp hiếm hoi khi reseed tự động thất bại liên tục. Hầu hết người dùng sẽ không bao giờ cần sử dụng trang này.\nCấu hình Mạng URL: Cấu hình Router Family Trang Cấu hình Router Family cho phép bạn quản lý các họ router. Các router trong cùng một họ chia sẻ một family key, xác định chúng được vận hành bởi cùng một người hoặc tổ chức. Điều này ngăn chặn nhiều router do bạn kiểm soát được chọn cho cùng một tunnel, việc này sẽ làm giảm tính ẩn danh.\nRouter Family là gì?\nKhi bạn vận hành nhiều router I2P, bạn nên cấu hình chúng thuộc cùng một family. Điều này đảm bảo: - Các router của bạn sẽ không được sử dụng cùng nhau trong cùng một đường tunnel - Những người dùng khác duy trì tính ẩn danh phù hợp khi tunnel của họ sử dụng các router của bạn - Mạng lưới có thể phân phối việc tham gia tunnel một cách hợp lý\nFamily Hiện tại:\nTrang này hiển thị tên family của router hiện tại của bạn. Nếu bạn không thuộc family nào, trường này sẽ để trống.\nXuất Khóa Họ (Family Key):\nXuất khóa bí mật của family để nhập vào các router khác mà bạn kiểm soát Nhấp \u0026ldquo;Export Family Key\u0026rdquo; để tải xuống tệp khóa family của bạn Nhập khóa này vào các router khác của bạn để thêm chúng vào cùng một family Rời Khỏi Router Family:\nKhông còn là thành viên của family Nhấp \u0026ldquo;Leave Family\u0026rdquo; để loại bỏ router này khỏi family hiện tại Hành động này không thể hoàn tác nếu không nhập lại khóa family Những Điểm Quan Trọng Cần Lưu Ý:\nYêu Cầu Đăng Ký Công Khai: Để family của bạn được công nhận trên toàn mạng lưới, khóa family của bạn phải được thêm vào codebase I2P bởi nhóm phát triển. Điều này đảm bảo tất cả các router trên mạng lưới đều biết về family của bạn. Liên hệ với nhóm I2P để đăng ký khóa family nếu bạn vận hành nhiều router công khai Hầu hết người dùng chỉ chạy một router sẽ không bao giờ cần sử dụng tính năng này Cấu hình family chủ yếu được sử dụng bởi các nhà vận hành nhiều router công khai hoặc nhà cung cấp hạ tầng Các Trường Hợp Sử Dụng:\nVận hành nhiều router I2P để đảm bảo dự phòng Chạy cơ sở hạ tầng như reseed server hoặc outproxy trên nhiều máy Quản lý mạng lưới các router I2P cho một tổ chức Cấu hình Peer URL: Cấu hình Tunnel Trang Cấu hình Tunnel cho phép bạn điều chỉnh cài đặt tunnel mặc định cho cả exploratory tunnel (dùng cho giao tiếp router) và client tunnel (dùng bởi các ứng dụng). Cài đặt mặc định phù hợp với hầu hết mọi người và chỉ nên thay đổi nếu bạn hiểu rõ những đánh đổi.\nCảnh Báo Quan Trọng:\n⚠️ Đánh đổi giữa Tính ẩn danh và Hiệu suất: Có một sự đánh đổi cơ bản giữa tính ẩn danh và hiệu suất. Các tunnel dài hơn 3 hops (ví dụ 2 hops + 0-2 hops, 3 hops + 0-1 hops, 3 hops + 0-2 hops), hoặc số lượng + số lượng dự phòng cao, có thể làm giảm nghiêm trọng hiệu suất hoặc độ tin cậy. Việc sử dụng CPU cao và/hoặc băng thông đầu ra cao có thể xảy ra. Thay đổi các cài đặt này một cách cẩn thận và điều chỉnh chúng nếu bạn gặp vấn đề.\n⚠️ Tính bền vững: Các thay đổi cài đặt exploratory tunnel được lưu trong file router.config. Các thay đổi client tunnel chỉ là tạm thời và không được lưu lại. Để thực hiện thay đổi client tunnel vĩnh viễn, xem trang I2PTunnel .\nExploratory Tunnels:\nCác tunnel khám phá (exploratory tunnels) được router của bạn sử dụng để giao tiếp với network database và tham gia vào mạng I2P.\nCác tùy chọn cấu hình cho cả Inbound và Outbound: - Length - Số lượng hop trong tunnel (mặc định: 2-3 hop) - Randomization - Độ biến thiên ngẫu nhiên trong độ dài tunnel (mặc định: 0-1 hop) - Quantity - Số lượng tunnel đang hoạt động (mặc định: 2 tunnel) - Backup quantity - Số lượng tunnel dự phòng sẵn sàng kích hoạt (mặc định: 0 tunnel)\nClient Tunnels cho I2P Webserver:\nCác cài đặt này kiểm soát các tunnel cho máy chủ web I2P tích hợp sẵn (eepsite).\n⚠️ CẢNH BÁO VỀ TÍNH ẨN DANH - Cài đặt bao gồm các tunnel 1-hop. ⚠️ CẢNH BÁO VỀ HIỆU SUẤT - Cài đặt bao gồm số lượng tunnel cao.\nCác tùy chọn cấu hình cho cả Inbound và Outbound: - Length - Độ dài tunnel (mặc định: 1 hop cho webserver) - Randomization - Phương sai ngẫu nhiên trong độ dài tunnel - Quantity - Số lượng tunnel đang hoạt động - Backup quantity - Số lượng tunnel dự phòng\nTunnel Client cho Các Client Dùng Chung:\nCác cài đặt này áp dụng cho các ứng dụng client dùng chung (HTTP proxy, IRC, v.v.).\nCác tùy chọn cấu hình cho cả Inbound và Outbound: - Length - Độ dài tunnel (mặc định: 3 hops) - Randomization - Phương sai ngẫu nhiên trong độ dài tunnel - Quantity - Số lượng tunnel hoạt động - Backup quantity - Số lượng tunnel dự phòng\nHiểu về các Tham số Tunnel:\nĐộ dài: Đường hầm dài hơn cung cấp tính ẩn danh cao hơn nhưng làm giảm hiệu suất và độ tin cậy Ngẫu nhiên hóa: Tăng tính không thể đoán trước cho đường đi của đường hầm, cải thiện bảo mật Số lượng: Nhiều đường hầm hơn cải thiện độ tin cậy và phân phối tải nhưng tăng mức sử dụng tài nguyên Số lượng dự phòng: Các đường hầm được xây dựng sẵn để thay thế đường hầm bị lỗi, cải thiện khả năng phục hồi Các Phương Pháp Hay Nhất:\nGiữ nguyên cài đặt mặc định trừ khi bạn có nhu cầu cụ thể Chỉ tăng độ dài tunnel nếu tính ẩn danh là quan trọng và bạn có thể chấp nhận hiệu suất chậm hơn Tăng số lượng/backup chỉ khi gặp phải tình trạng tunnel thường xuyên bị lỗi Giám sát hiệu suất router sau khi thực hiện thay đổi Nhấp vào \u0026ldquo;Save changes\u0026rdquo; để áp dụng các thay đổi Cấu hình Reseed URL: Cấu hình giao diện người dùng Trang Cấu hình Giao diện cho phép bạn tùy chỉnh giao diện và khả năng truy cập của bảng điều khiển router, bao gồm lựa chọn giao diện, tùy chọn ngôn ngữ và bảo vệ bằng mật khẩu.\nGiao diện Router Console:\nChọn giữa giao diện tối và sáng cho bảng điều khiển router: - Dark - Giao diện chế độ tối (dễ nhìn hơn trong môi trường thiếu ánh sáng) - Light - Giao diện chế độ sáng (giao diện truyền thống)\nCác tùy chọn giao diện bổ sung: - Áp dụng giao diện thống nhất cho tất cả các ứng dụng - Áp dụng giao diện đã chọn cho tất cả các ứng dụng I2P, không chỉ router console - Bắt buộc sử dụng giao diện di động - Sử dụng giao diện tối ưu hóa cho di động ngay cả trên trình duyệt máy tính để bàn - Nhúng ứng dụng Email và Torrent vào console - Tích hợp Susimail và I2PSnark trực tiếp vào giao diện console thay vì mở chúng trong các tab riêng biệt\nNgôn ngữ Router Console:\nChọn ngôn ngữ ưa thích của bạn cho giao diện router console từ menu thả xuống. I2P hỗ trợ nhiều ngôn ngữ bao gồm tiếng Anh, tiếng Đức, tiếng Pháp, tiếng Tây Ban Nha, tiếng Nga, tiếng Trung, tiếng Nhật và nhiều ngôn ngữ khác.\nChào mừng đóng góp bản dịch: Nếu bạn nhận thấy bản dịch chưa hoàn chỉnh hoặc không chính xác, bạn có thể giúp cải thiện I2P bằng cách đóng góp vào dự án dịch thuật. Liên hệ với các nhà phát triển tại #i2p-dev trên IRC hoặc kiểm tra báo cáo tình trạng bản dịch (được liên kết trên trang).\nMật khẩu Router Console:\nThêm xác thực tên người dùng và mật khẩu để bảo vệ quyền truy cập vào router console của bạn:\nUsername - Nhập tên người dùng để truy cập bảng điều khiển Password - Nhập mật khẩu để truy cập bảng điều khiển Add user - Tạo người dùng mới với thông tin xác thực đã chỉ định Delete selected - Xóa các tài khoản người dùng hiện có Tại Sao Cần Thêm Mật Khẩu?\nNgăn chặn truy cập trái phép vào router console từ máy cục bộ Thiết yếu nếu nhiều người sử dụng máy tính của bạn Khuyến nghị nếu router console của bạn có thể truy cập được trên mạng cục bộ Bảo vệ cấu hình I2P và cài đặt quyền riêng tư của bạn khỏi bị can thiệp Lưu ý Bảo mật: Bảo vệ bằng mật khẩu chỉ ảnh hưởng đến quyền truy cập vào giao diện web bảng điều khiển router tại I2P Router Console . Nó không mã hóa lưu lượng I2P hoặc ngăn chặn các ứng dụng sử dụng I2P. Nếu bạn là người dùng duy nhất trên máy tính của mình và bảng điều khiển router chỉ lắng nghe trên localhost (mặc định), mật khẩu có thể không cần thiết.\nCấu hình Router Family URL: Cấu hình WebApp Trang Cấu hình WebApp cho phép bạn quản lý các ứng dụng web Java chạy trong router I2P của bạn. Các ứng dụng này được khởi động bởi webConsole client và chạy trong cùng JVM với router, cung cấp các chức năng tích hợp có thể truy cập thông qua router console.\nWebApps là gì?\nWebApps là các ứng dụng dựa trên Java có thể là: - Ứng dụng hoàn chỉnh (ví dụ: I2PSnark cho torrents) - Giao diện cho các client khác phải được kích hoạt riêng (ví dụ: Susidns, I2PTunnel) - Ứng dụng web không có giao diện web (ví dụ: address book)\nGhi Chú Quan Trọng:\nMột webapp có thể bị vô hiệu hóa hoàn toàn, hoặc chỉ bị vô hiệu hóa khỏi việc chạy khi khởi động Xóa file war khỏi thư mục webapps sẽ vô hiệu hóa webapp hoàn toàn Tuy nhiên, file .war và thư mục webapp sẽ xuất hiện lại khi bạn cập nhật router lên phiên bản mới hơn Để vô hiệu hóa webapp vĩnh viễn: Vô hiệu hóa nó tại đây, đây là phương pháp được khuyến nghị Các WebApp Có Sẵn:\nWebApp Description i2psnark Torrents - Built-in BitTorrent client for I2P i2ptunnel Hidden Services Manager - Configure client and server tunnels imagegen Identification Image Generator - Creates unique identicons jsonrpc jsonrpc.war - JSON-RPC API interface (disabled by default) routerconsole I2P Router Console - The main administrative interface susidns Address Book - Manage I2P addresses and subscriptions susimail Email - Web-based email client for I2P Các điều khiển: Cho mỗi webapp: - Chạy khi Khởi động? - Hộp kiểm để bật/tắt tự động khởi động - Điều khiển - Các nút Bắt đầu/Dừng để điều khiển ngay lập tức - Dừng - Dừng webapp đang chạy - Bắt đầu - Khởi động một webapp đã dừng\nCác Nút Cấu Hình:\nHủy - Hủy bỏ các thay đổi và quay lại trang trước Lưu Cấu hình WebApp - Lưu các thay đổi của bạn và áp dụng chúng Các Trường Hợp Sử Dụng:\nDừng I2PSnark nếu bạn không sử dụng torrents để tiết kiệm tài nguyên Vô hiệu hóa jsonrpc nếu bạn không cần truy cập API Dừng Susimail nếu bạn sử dụng ứng dụng email bên ngoài Tạm thời dừng các webapp để giải phóng bộ nhớ hoặc khắc phục sự cố Mẹo Hiệu Năng: Tắt các webapp không sử dụng có thể giảm mức sử dụng bộ nhớ và cải thiện hiệu năng router, đặc biệt trên các hệ thống có tài nguyên hạn chế.\nHelp URL: Trợ giúp Trang Trợ giúp cung cấp tài liệu và tài nguyên toàn diện để giúp bạn hiểu và sử dụng I2P một cách hiệu quả. Nó đóng vai trò là trung tâm cho việc khắc phục sự cố, học tập và nhận hỗ trợ.\nNhững Gì Bạn Sẽ Tìm Thấy:\nHướng dẫn Khởi động Nhanh - Thông tin cần thiết cho người dùng mới bắt đầu với I2P Câu hỏi Thường gặp (FAQ) - Câu trả lời cho các câu hỏi phổ biến về cài đặt, cấu hình và sử dụng I2P Khắc phục Sự cố - Giải pháp cho các vấn đề thường gặp và sự cố kết nối Tài liệu Kỹ thuật - Thông tin chi tiết về các giao thức, kiến trúc và đặc tả kỹ thuật của I2P Hướng dẫn Ứng dụng - Hướng dẫn sử dụng các ứng dụng I2P như torrents, email và hidden services Thông tin Mạng - Hiểu cách I2P hoạt động và điều gì làm cho nó an toàn Tài nguyên Hỗ trợ - Liên kết đến diễn đàn, kênh IRC và hỗ trợ cộng đồng Nhận trợ giúp:\nNếu bạn đang gặp vấn đề với I2P: 1. Kiểm tra FAQ để tìm các câu hỏi và câu trả lời thường gặp 2. Xem lại phần khắc phục sự cố cho vấn đề cụ thể của bạn 3. Truy cập diễn đàn I2P tại i2pforum.i2p hoặc i2pforum.net 4. Tham gia kênh IRC #i2p để nhận hỗ trợ từ cộng đồng theo thời gian thực 5. Tìm kiếm trong tài liệu để có thông tin kỹ thuật chi tiết\nMẹo: Trang trợ giúp luôn có thể truy cập từ thanh bên của bảng điều khiển router, giúp bạn dễ dàng tìm thấy hỗ trợ bất cứ khi nào cần.\nPerformance Graphs URL: Biểu đồ Hiệu năng Trang Đồ thị Hiệu suất cung cấp giám sát trực quan theo thời gian thực về hiệu suất và hoạt động mạng của I2P router. Những đồ thị này giúp bạn hiểu về mức sử dụng băng thông, kết nối peer, mức tiêu thụ bộ nhớ và tình trạng tổng thể của router.\nCác Đồ thị Khả dụng:\nSử dụng Băng thông\nTốc độ gửi cấp thấp (bytes/giây) - Tốc độ lưu lượng đi Tốc độ nhận cấp thấp (bytes/giây) - Tốc độ lưu lượng đến Hiển thị mức sử dụng băng thông hiện tại, trung bình và tối đa Giúp theo dõi xem bạn có đang đạt đến giới hạn băng thông đã cấu hình hay không Active Peers (Peer đang hoạt động)\nrouter.activePeers averaged for 60 sec - Số lượng peer bạn đang giao tiếp tích cực Hiển thị tình trạng kết nối mạng của bạn Nhiều peer đang hoạt động thường có nghĩa là xây dựng tunnel tốt hơn và tham gia mạng hiệu quả hơn Mức sử dụng bộ nhớ Router\nrouter.memoryUsed được lấy trung bình trong 60 giây - Mức tiêu thụ bộ nhớ JVM Hiển thị mức sử dụng bộ nhớ hiện tại, trung bình và tối đa tính bằng MB Hữu ích để xác định rò rỉ bộ nhớ hoặc xác định liệu bạn có cần tăng kích thước heap của Java hay không Cấu hình Hiển thị Đồ thị:\nTùy chỉnh cách hiển thị và làm mới đồ thị:\nKích thước đồ thị - Đặt chiều rộng (mặc định: 400 pixel) và chiều cao (mặc định: 100 pixel) Khoảng thời gian hiển thị - Phạm vi thời gian để hiển thị (mặc định: 60 phút) Độ trễ làm mới - Tần suất cập nhật đồ thị (mặc định: 5 phút) Kiểu biểu đồ - Chọn giữa hiển thị dạng Trung bình hoặc Sự kiện Ẩn chú thích - Loại bỏ chú thích khỏi đồ thị để tiết kiệm không gian UTC - Sử dụng giờ UTC thay vì giờ địa phương trên đồ thị Lưu trữ dữ liệu - Lưu trữ dữ liệu đồ thị trên ổ đĩa để phân tích lịch sử Tùy chọn Nâng cao:\nNhấp vào [Select Stats] để chọn số liệu thống kê muốn vẽ đồ thị: - Các chỉ số tunnel (tỷ lệ tạo thành công, số lượng tunnel, v.v.) - Thống kê cơ sở dữ liệu mạng - Thống kê truyền tải (NTCP2, SSU2) - Hiệu suất tunnel client - Và nhiều chỉ số chi tiết khác\nCác Trường Hợp Sử Dụng:\nTheo dõi băng thông để đảm bảo bạn không vượt quá giới hạn đã cấu hình Xác minh kết nối peer khi khắc phục sự cố mạng Theo dõi mức sử dụng bộ nhớ để tối ưu hóa cài đặt Java heap Nhận diện các mẫu hiệu suất theo thời gian Chẩn đoán vấn đề xây dựng tunnel bằng cách tương quan các biểu đồ Mẹo: Nhấp vào \u0026ldquo;Save settings and redraw graphs\u0026rdquo; sau khi thực hiện thay đổi để áp dụng cấu hình của bạn. Các biểu đồ sẽ tự động làm mới dựa trên cài đặt độ trễ làm mới của bạn.\n","description":"Hướng dẫn toàn diện để hiểu và cấu hình I2P Router Console","id":"c46f1b6edeab9b686fd57cf9b311df1c","section":"docs","title":"Hướng dẫn Cấu hình Router Console","url":"/vi/docs/guides/router-console-config/"},{"categories":null,"content":"Bạn muốn giúp I2P tiếp cận được nhiều người hơn trên toàn thế giới? Dịch thuật là một trong những đóng góp có giá trị nhất bạn có thể làm cho dự án. Hướng dẫn này sẽ giúp bạn dịch router console.\nPhương pháp Dịch thuật Có hai cách để đóng góp bản dịch:\nPhương pháp 1: Transifex (Khuyến nghị) Đây là cách dễ nhất để dịch I2P. Transifex cung cấp giao diện web giúp việc dịch thuật trở nên đơn giản và dễ tiếp cận.\nĐăng ký tại Transifex Yêu cầu tham gia nhóm dịch thuật I2P Bắt đầu dịch trực tiếp trên trình duyệt của bạn Không cần kiến thức chuyên môn - chỉ cần đăng ký và bắt đầu dịch!\nPhương pháp 2: Dịch thủ công Dành cho các biên dịch viên muốn làm việc với git và các tệp cục bộ, hoặc cho các ngôn ngữ chưa được thiết lập trên Transifex.\nYêu cầu: - Quen thuộc với hệ thống quản lý phiên bản git - Trình soạn thảo văn bản hoặc công cụ dịch thuật (khuyến nghị POEdit) - Công cụ dòng lệnh: git, gettext\nThiết lập: 1. Tham gia #i2p-dev trên IRC và giới thiệu bản thân 2. Cập nhật trạng thái dịch thuật trên wiki (hỏi trên IRC để được cấp quyền truy cập) 3. Clone repository phù hợp (xem các phần bên dưới)\nBản dịch Bảng điều khiển Router Router console là giao diện web mà bạn thấy khi chạy I2P. Việc dịch thuật nó giúp ích cho những người dùng không thoải mái với tiếng Anh.\nSử dụng Transifex (Khuyên dùng) Truy cập I2P trên Transifex Chọn dự án router console Chọn ngôn ngữ của bạn Bắt đầu dịch Dịch Bảng Điều Khiển Router Thủ Công Yêu cầu: - Giống như dịch website (git, gettext) - Khóa GPG (để có quyền commit) - Thỏa thuận nhà phát triển đã ký\nSao chép kho lưu trữ I2P chính:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p Các tệp cần dịch:\nBảng điều khiển router có khoảng 15 tệp cần dịch:\nTệp giao diện cốt lõi:\napps/routerconsole/locale/messages_*.po - Thông điệp console chính apps/routerconsole/locale-news/messages_*.po - Thông điệp tin tức Các tệp Proxy:\napps/i2ptunnel/locale/messages_*.po - Giao diện cấu hình tunnel Ngôn ngữ ứng dụng:\napps/susidns/locale/messages_*.po - Giao diện sổ địa chỉ apps/susimail/locale/messages_*.po - Giao diện email Các thư mục ngôn ngữ riêng cho từng ứng dụng khác Tệp tài liệu:\ninstaller/resources/readme/readme_*.html - Tài liệu hướng dẫn cài đặt Các tệp trợ giúp trong nhiều ứng dụng khác nhau Quy trình dịch thuật:\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console Gửi công việc của bạn: - Tạo merge request trên GitLab - Hoặc chia sẻ tệp với nhóm phát triển trên IRC\nCông cụ Dịch thuật POEdit (Rất Khuyến Nghị) POEdit là một trình soạn thảo chuyên dụng cho các tệp dịch thuật .po.\nTính năng: - Giao diện trực quan cho công việc dịch thuật - Hiển thị ngữ cảnh bản dịch - Xác thực tự động - Có sẵn cho Windows, macOS và Linux\nTrình soạn thảo văn bản Bạn cũng có thể sử dụng bất kỳ trình soạn thảo văn bản nào: - VS Code (với tiện ích mở rộng i18n) - Sublime Text - vim/emacs (dành cho người dùng terminal)\nKiểm tra Chất lượng Trước khi gửi: 1. Kiểm tra định dạng: Đảm bảo các placeholder như %s và {0} không bị thay đổi 2. Kiểm tra bản dịch: Cài đặt và chạy I2P để xem chúng hiển thị như thế nào 3. Tính nhất quán: Giữ thuật ngữ nhất quán trong các tệp 4. Độ dài: Một số chuỗi có giới hạn không gian trong giao diện\nMẹo dành cho Người dịch Hướng dẫn chung Giữ nhất quán: Sử dụng cùng một bản dịch cho các thuật ngữ phổ biến xuyên suốt Giữ nguyên định dạng: Bảo toàn thẻ HTML, placeholder (%s, {0}), và ngắt dòng Ngữ cảnh quan trọng: Đọc kỹ văn bản tiếng Anh gốc để hiểu ngữ cảnh Đặt câu hỏi: Sử dụng IRC hoặc diễn đàn nếu có điều gì không rõ ràng Các Thuật Ngữ I2P Phổ Biến Một số thuật ngữ nên giữ nguyên tiếng Anh hoặc phiên âm cẩn thận:\nI2P - Keep as is eepsite - Trang web I2P (website trên mạng I2P) tunnel - Đường dẫn kết nối netDb - Cơ sở dữ liệu mạng floodfill - Loại router destination - Điểm đích địa chỉ I2P Kiểm tra bản dịch của bạn Biên dịch I2P với bản dịch của bạn Thay đổi ngôn ngữ trong cài đặt router console Điều hướng qua tất cả các trang để kiểm tra: Văn bản vừa khít với các phần tử giao diện Không có ký tự lỗi (vấn đề mã hóa) Bản dịch có ý nghĩa phù hợp với ngữ cảnh Câu Hỏi Thường Gặp Tại sao quy trình dịch thuật lại phức tạp như vậy? Quy trình sử dụng kiểm soát phiên bản (git) và các công cụ dịch thuật chuẩn (tệp .po) bởi vì:\nTrách nhiệm: Theo dõi ai đã thay đổi gì và khi nào Chất lượng: Xem xét các thay đổi trước khi chúng được công bố Nhất quán: Duy trì định dạng và cấu trúc tệp tin phù hợp Khả năng mở rộng: Quản lý bản dịch trên nhiều ngôn ngữ một cách hiệu quả Cộng tác: Nhiều người dịch có thể làm việc cùng một ngôn ngữ Tôi có cần kỹ năng lập trình không? Không! Nếu bạn sử dụng Transifex, bạn chỉ cần: - Thông thạo cả tiếng Anh và ngôn ngữ đích của bạn - Một trình duyệt web - Kỹ năng máy tính cơ bản\nĐối với dịch thuật thủ công, bạn sẽ cần kiến thức cơ bản về dòng lệnh, nhưng không yêu cầu lập trình.\nMất bao lâu? Router console: Khoảng 15-20 giờ cho tất cả các tệp Bảo trì: Vài giờ mỗi tháng để cập nhật các chuỗi mới Nhiều người có thể cùng làm việc trên một ngôn ngữ không? Có! Phối hợp là chìa khóa: - Sử dụng Transifex để phối hợp tự động - Đối với công việc thủ công, giao tiếp trong kênh IRC #i2p-dev - Phân chia công việc theo từng phần hoặc tệp tin\nĐiều gì xảy ra nếu ngôn ngữ của tôi không được liệt kê? Yêu cầu trên Transifex hoặc liên hệ với nhóm trên IRC. Nhóm phát triển có thể thiết lập ngôn ngữ mới một cách nhanh chóng.\nLàm thế nào để kiểm tra bản dịch của tôi trước khi gửi? Biên dịch I2P từ mã nguồn với bản dịch của bạn Cài đặt và chạy cục bộ Thay đổi ngôn ngữ trong cài đặt console Nhận Trợ Giúp Hỗ trợ IRC Tham gia #i2p-dev trên IRC để: - Nhận trợ giúp kỹ thuật về công cụ dịch thuật - Đặt câu hỏi về thuật ngữ I2P - Phối hợp với các dịch giả khác - Nhận hỗ trợ trực tiếp từ các nhà phát triển\nDiễn đàn Thảo luận về dịch thuật trên I2P Forums Inside I2P: Diễn đàn dịch thuật trên zzz.i2p (yêu cầu I2P router) Tài liệu Tài liệu Transifex Tài liệu POEdit Hướng dẫn gettext Ghi nhận Tất cả các biên dịch viên được ghi nhận trong: - Bảng điều khiển I2P router (trang Giới thiệu) - Trang ghi nhận đóng góp của website - Lịch sử commit trên Git - Thông báo phát hành\nCông việc của bạn trực tiếp giúp mọi người trên khắp thế giới sử dụng I2P một cách an toàn và riêng tư. Cảm ơn bạn đã đóng góp!\nCác Bước Tiếp Theo Sẵn sàng bắt đầu dịch?\nChọn phương pháp của bạn:\nBắt đầu nhanh: Đăng ký trên Transifex Phương pháp thủ công: Tham gia #i2p-dev trên IRC Bắt đầu từ nhỏ: Dịch một vài chuỗi để làm quen với quy trình\nYêu cầu trợ giúp: Đừng ngần ngại liên hệ qua IRC hoặc diễn đàn\nCảm ơn bạn đã giúp đỡ làm cho I2P dễ tiếp cận với tất cả mọi người!\n","description":"Cách đóng góp bản dịch cho trang web I2P và bảng điều khiển router bằng Transifex hoặc phương pháp thủ công","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"Hướng Dẫn Cho Người Dịch Mới","url":"/vi/docs/develop/new-translators/"},{"categories":null,"content":"Vậy là bạn muốn bắt đầu làm việc với I2P? Tuyệt vời! Đây là hướng dẫn nhanh để bắt đầu đóng góp vào website hoặc phần mềm, phát triển, hoặc tạo bản dịch.\nChưa sẵn sàng để lập trình? Hãy thử tham gia trước.\nTìm hiểu về Java Router I2P và các ứng dụng nhúng của nó sử dụng Java làm ngôn ngữ phát triển chính. Nếu bạn chưa có kinh nghiệm với Java, bạn luôn có thể tham khảo Thinking in Java Nghiên cứu phần giới thiệu \u0026ldquo;how\u0026rdquo;, các tài liệu \u0026ldquo;how\u0026rdquo; khác, phần giới thiệu kỹ thuật và các tài liệu liên quan:\nGiới thiệu cách thức: Giới thiệu về I2P Trung tâm tài liệu: Tài liệu Giới thiệu kỹ thuật: Giới thiệu Kỹ thuật Những tài liệu này sẽ cung cấp cho bạn cái nhìn tổng quan tốt về cách I2P được cấu trúc và những chức năng khác nhau mà nó thực hiện.\nLấy Mã Nguồn I2P Để phát triển trên I2P router hoặc các ứng dụng nhúng, bạn cần lấy mã nguồn.\nCách thức hiện tại của chúng tôi: Git I2P có dịch vụ Git chính thức và chấp nhận đóng góp qua Git tại GitLab của chúng tôi:\nTrong I2P: http://git.idk.i2p Ngoài I2P: https://i2pgit.org Sao chép repository chính:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git Một bản sao chỉ đọc cũng có sẵn tại GitHub:\nMirror trên GitHub: github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git Xây dựng I2P Để biên dịch mã nguồn, bạn cần Sun/Oracle Java Development Kit 6 trở lên, hoặc JDK tương đương (khuyến nghị mạnh Sun/Oracle JDK 6) và Apache Ant phiên bản 1.7.0 trở lên. Nếu bạn đang làm việc với mã nguồn I2P chính, hãy vào thư mục i2p.i2p và chạy lệnh ant để xem các tùy chọn build.\nĐể xây dựng hoặc làm việc với các bản dịch console, bạn cần các công cụ xgettext, msgfmt, và msgmerge từ gói GNU gettext.\nĐể phát triển các ứng dụng mới, xem hướng dẫn phát triển ứng dụng .\nÝ Tưởng Phát Triển Xem danh sách TODO của dự án hoặc danh sách vấn đề trên GitLab để có ý tưởng:\nVấn đề GitLab: i2pgit.org/I2P_Developers/i2p.i2p/issues Công bố Kết quả Xem phần cuối của trang giấy phép để biết các yêu cầu về quyền commit. Bạn cần những quyền này để đưa mã vào i2p.i2p (không bắt buộc đối với trang web!).\nTrang giấy phép Tìm hiểu về chúng tôi! Các nhà phát triển thường có mặt trên IRC. Bạn có thể liên hệ với họ trên nhiều mạng khác nhau và trên các mạng nội bộ của I2P. Nơi thường tìm thấy họ là kênh #i2p-dev. Tham gia kênh và chào hỏi! Chúng tôi cũng có thêm hướng dẫn dành cho các nhà phát triển thường xuyên .\nNgười dịch trang web và bảng điều khiển router: Xem Hướng dẫn cho Người dịch Mới để biết các bước tiếp theo.\nCông cụ I2P là phần mềm mã nguồn mở được phát triển chủ yếu bằng các bộ công cụ mã nguồn mở. Dự án I2P gần đây đã có được giấy phép cho YourKit Java Profiler. Các dự án mã nguồn mở đủ điều kiện nhận giấy phép miễn phí với điều kiện YourKit được tham chiếu trên trang web của dự án. Vui lòng liên hệ nếu bạn quan tâm đến việc phân tích codebase của I2P.\nYourKit đang hỗ trợ các dự án mã nguồn mở với bộ profiler đầy đủ tính năng của họ. YourKit, LLC là nhà sáng tạo các công cụ đổi mới và thông minh để profiling các ứng dụng Java và .NET. Hãy xem các sản phẩm phần mềm hàng đầu của YourKit:\nYourKit Java Profiler YourKit .NET Profiler ","description":"Cách bắt đầu đóng góp cho I2P: tài liệu học tập, mã nguồn, biên dịch, ý tưởng, xuất bản, cộng đồng, dịch thuật và công cụ","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"Hướng dẫn dành cho Lập trình viên Mới","url":"/vi/docs/develop/new-developers/"},{"categories":null,"content":"Các router I2P thường gặp lỗi nhất là do sự cố chuyển tiếp cổng, phân bổ băng thông không đủ, và thời gian bootstrap (khởi tạo ban đầu) không đủ. Ba yếu tố này chiếm hơn 70% các sự cố được báo cáo. Router cần ít nhất 10-15 phút sau khi khởi động để tích hợp hoàn toàn vào mạng, băng thông tối thiểu 128 KB/sec (khuyến nghị 256 KB/sec), và chuyển tiếp cổng UDP/TCP đúng cách để đạt trạng thái không bị tường lửa chặn. Người dùng mới thường kỳ vọng kết nối ngay lập tức và khởi động lại quá sớm, điều này đặt lại tiến trình tích hợp và tạo ra một vòng lặp gây khó chịu. Hướng dẫn này cung cấp các giải pháp chi tiết cho mọi vấn đề chính của I2P ảnh hưởng đến các phiên bản 2.10.0 trở lên.\nKiến trúc ẩn danh của I2P vốn dĩ đánh đổi tốc độ để lấy quyền riêng tư thông qua cơ chế tunnel mã hóa đa bước nhảy. Việc hiểu rõ thiết kế nền tảng này giúp người dùng đặt kỳ vọng thực tế và khắc phục sự cố hiệu quả, thay vì hiểu nhầm hành vi bình thường là vấn đề.\nRouter không khởi động hoặc bị sập ngay lập tức Những sự cố khởi động thường gặp nhất xuất phát từ xung đột cổng, không tương thích phiên bản Java, hoặc tệp cấu hình bị hỏng. Hãy kiểm tra xem có tiến trình I2P khác đang chạy hay không trước khi điều tra các vấn đề sâu hơn.\nXác minh không có tiến trình xung đột:\nLinux: ps aux | grep i2p hoặc netstat -tulpn | grep 7657\nWindows: Trình quản lý tác vụ → Chi tiết → tìm java.exe có i2p trong dòng lệnh\nmacOS: Activity Monitor → tìm kiếm \u0026ldquo;i2p\u0026rdquo;\nNếu có một tiến trình zombie, hãy kết thúc nó: pkill -9 -f i2p (Linux/Mac) hoặc taskkill /F /IM javaw.exe (Windows)\nKiểm tra khả năng tương thích phiên bản Java:\nI2P 2.10.0+ yêu cầu Java 8 tối thiểu, khuyến nghị Java 11 hoặc mới hơn. Hãy xác minh rằng cài đặt của bạn hiển thị \u0026ldquo;mixed mode\u0026rdquo; (chế độ hỗn hợp) (không phải \u0026ldquo;interpreted mode\u0026rdquo; (chế độ thông dịch)):\njava -version Nên hiển thị: OpenJDK hoặc Oracle Java, phiên bản 8+, \u0026ldquo;mixed mode\u0026rdquo;\nTránh: GNU GCJ, các triển khai Java lỗi thời, các chế độ chỉ thông dịch\nCác xung đột cổng thường gặp xảy ra khi nhiều dịch vụ cùng tranh chấp các cổng mặc định của I2P. Bảng điều khiển router (7657), I2CP (7654), SAM (7656) và proxy HTTP (4444) phải khả dụng. Kiểm tra xung đột: netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (Windows) hoặc lsof -i :7657,4444,7654 (Linux/Mac).\nHỏng tệp cấu hình thể hiện bằng việc sập (crash) ngay lập tức với lỗi phân tích cú pháp (parse errors) trong nhật ký. router.config yêu cầu mã hóa UTF-8 không BOM, dùng = làm ký tự phân tách (không phải :), và cấm một số ký tự đặc biệt nhất định. Hãy sao lưu rồi kiểm tra: ~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS).\nĐể đặt lại cấu hình mà vẫn giữ nguyên danh tính: Dừng I2P, sao lưu router.keys và thư mục keyData, xóa router.config, rồi khởi động lại I2P. router sẽ tạo lại cấu hình mặc định.\nPhân bổ heap Java quá thấp gây sập với lỗi OutOfMemoryError. Chỉnh sửa wrapper.config và tăng wrapper.java.maxmemory từ mặc định 128 hoặc 256 lên tối thiểu 512 (1024 cho các router băng thông cao). Việc này yêu cầu tắt hoàn toàn, chờ 11 phút, rồi khởi động lại - nhấp \u0026ldquo;Restart\u0026rdquo; trong bảng điều khiển sẽ không áp dụng thay đổi.\nKhắc phục trạng thái \u0026ldquo;Network: Firewalled\u0026rdquo; Trạng thái bị tường lửa chặn nghĩa là router không thể nhận các kết nối vào trực tiếp, buộc phải phụ thuộc vào introducers (các nút trung gian hỗ trợ giới thiệu kết nối). Dù router vẫn hoạt động ở trạng thái này, hiệu năng giảm sút đáng kể và mức đóng góp cho mạng vẫn ở mức tối thiểu. Để đạt trạng thái không bị tường lửa chặn, cần cấu hình chuyển tiếp cổng đúng cách.\nrouter sẽ chọn ngẫu nhiên một cổng trong khoảng 9000-31000 cho giao tiếp. Hãy xem cổng của bạn tại http://127.0.0.1:7657/confignet - hãy tìm \u0026ldquo;UDP Port\u0026rdquo; và \u0026ldquo;TCP Port\u0026rdquo; (thường là cùng một số). Bạn phải chuyển tiếp cổng (port forwarding) cho cả UDP và TCP để đạt hiệu năng tối ưu, dù chỉ riêng UDP cũng cho phép chức năng cơ bản.\nBật chuyển tiếp tự động qua UPnP (cách đơn giản nhất):\nTruy cập http://127.0.0.1:7657/confignet Chọn \u0026ldquo;Enable UPnP\u0026rdquo; Lưu thay đổi và khởi động lại router Chờ 5-10 phút và kiểm tra trạng thái thay đổi từ \u0026ldquo;Network: Firewalled\u0026rdquo; sang \u0026ldquo;Network: OK\u0026rdquo; UPnP yêu cầu hỗ trợ từ router (được bật theo mặc định trên hầu hết các router dành cho người tiêu dùng sản xuất sau năm 2010) và cấu hình mạng đúng cách.\nChuyển tiếp cổng thủ công (bắt buộc khi UPnP không hoạt động):\nGhi lại cổng I2P của bạn từ http://127.0.0.1:7657/confignet (ví dụ: 22648) Tìm địa chỉ IP cục bộ của bạn: ipconfig (Windows), ip addr (Linux), System Preferences → Network (macOS) Truy cập giao diện quản trị của router (thường là 192.168.1.1 hoặc 192.168.0.1) Đi tới Port Forwarding (có thể nằm dưới Advanced, NAT, hoặc Virtual Servers) Tạo hai quy tắc: Cổng ngoài: [cổng I2P của bạn] → IP nội bộ: [máy tính của bạn] → Cổng nội bộ: [giữ nguyên] → Giao thức: UDP Cổng ngoài: [cổng I2P của bạn] → IP nội bộ: [máy tính của bạn] → Cổng nội bộ: [giữ nguyên] → Giao thức: TCP Lưu cấu hình và khởi động lại router nếu cần Xác minh chuyển tiếp cổng bằng các công cụ kiểm tra trực tuyến sau khi cấu hình. Nếu không phát hiện được, hãy kiểm tra cài đặt tường lửa - cả tường lửa hệ thống và tường lửa của bất kỳ phần mềm chống virus nào cũng phải cho phép cổng I2P.\nPhương án thay thế bằng chế độ ẩn (Hidden mode) cho các mạng bị hạn chế nơi việc chuyển tiếp cổng là không thể: Bật tại http://127.0.0.1:7657/confignet → chọn \u0026ldquo;Hidden mode\u0026rdquo;. The router vẫn bị tường lửa chặn nhưng tối ưu cho trạng thái này bằng cách chỉ sử dụng SSU introducers (nút trung gian giới thiệu). Hiệu năng sẽ chậm hơn nhưng vẫn hoạt động.\nRouter bị kẹt ở trạng thái \u0026ldquo;Starting\u0026rdquo; hoặc \u0026ldquo;Testing\u0026rdquo; Những trạng thái tạm thời trong giai đoạn khởi tạo ban đầu thường tự ổn định trong vòng 10-15 phút đối với các cài đặt mới hoặc 3-5 phút đối với các router đã hoạt động. Việc can thiệp quá sớm thường khiến vấn đề trở nên trầm trọng hơn.\n\u0026ldquo;Network: Testing\u0026rdquo; cho biết router đang thăm dò khả năng được kết nối từ bên ngoài qua nhiều kiểu kết nối (kết nối trực tiếp, introducers (các nút giới thiệu hỗ trợ kết nối qua NAT), nhiều phiên bản giao thức). Đây là điều bình thường trong 5–10 phút đầu sau khi khởi động. Router kiểm tra nhiều kịch bản để xác định cấu hình tối ưu.\n\u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; xuất hiện trong giai đoạn bootstrap (khởi động ban đầu) khi router chưa có đủ thông tin về các nút ngang hàng. Router sẽ không tham gia chuyển tiếp lưu lượng cho đến khi được tích hợp đầy đủ vào mạng. Thông điệp này sẽ biến mất sau 10-20 phút khi netDb đã có dữ liệu về hơn 50 router.\nSai lệch đồng hồ phá hỏng việc kiểm tra khả năng kết nối. I2P yêu cầu thời gian hệ thống nằm trong ±60 giây so với thời gian mạng. Chênh lệch vượt quá 90 giây sẽ khiến kết nối bị tự động từ chối. Đồng bộ đồng hồ hệ thống của bạn:\nLinux: sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows: Bảng điều khiển → Ngày và Giờ → Thời gian Internet → Cập nhật ngay → Bật đồng bộ tự động\nmacOS: Tùy chọn Hệ thống → Ngày \u0026amp; Giờ → Bật \u0026ldquo;Đặt ngày và giờ tự động\u0026rdquo;\nSau khi khắc phục clock skew (sai lệch thời gian của đồng hồ hệ thống), hãy khởi động lại I2P hoàn toàn để tích hợp đúng cách.\nPhân bổ băng thông không đủ ngăn cản việc thử nghiệm thành công. router cần đủ băng thông để xây dựng các tunnel thử nghiệm. Cấu hình tại http://127.0.0.1:7657/config:\nTối thiểu đủ dùng: Vào 96 KB/giây, Ra 64 KB/giây Khuyến nghị (chuẩn): Vào 256 KB/giây, Ra 128 KB/giây Hiệu suất tối ưu: Vào 512+ KB/giây, Ra 256+ KB/giây Tỷ lệ chia sẻ: 80% (cho phép router đóng góp băng thông cho mạng) Băng thông thấp hơn có thể vẫn hoạt động nhưng sẽ kéo dài thời gian tích hợp từ vài phút lên hàng giờ.\nnetDb bị hỏng do tắt máy không đúng cách hoặc lỗi ổ đĩa gây ra các vòng lặp kiểm thử liên tục. Router không thể hoàn tất kiểm thử nếu không có dữ liệu peer hợp lệ:\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start Windows: Xóa nội dung của %APPDATA%\\I2P\\netDb\\ hoặc %LOCALAPPDATA%\\I2P\\netDb\\\nTường lửa chặn reseed (tải về thông tin router ban đầu) khiến không thể thu nhận các nút ban đầu. Trong giai đoạn khởi tạo, I2P tải về thông tin router từ các máy chủ reseed qua HTTPS. Tường lửa của doanh nghiệp/ISP có thể chặn các kết nối này. Hãy cấu hình proxy reseed tại http://127.0.0.1:7657/configreseed nếu hoạt động phía sau các mạng bị hạn chế.\nTốc độ chậm, hết thời gian chờ, và lỗi xây dựng tunnel Thiết kế của I2P vốn dĩ dẫn đến tốc độ chậm hơn 3–10 lần so với clearnet (mạng công khai) do mã hóa đa hop, overhead gói tin và tính khó đoán của đường đi. Quá trình xây dựng tunnel đi qua nhiều router, mỗi router đều thêm độ trễ. Hiểu điều này giúp tránh chẩn đoán nhầm hành vi bình thường thành sự cố.\nKỳ vọng hiệu năng điển hình:\nDuyệt web các trang .i2p: ban đầu tải trang mất 10-30 giây, nhanh hơn sau khi thiết lập tunnel Tải torrent qua I2PSnark: 10-100 KB/giây cho mỗi torrent tùy theo người seed (seeders) và điều kiện mạng Tải xuống tệp lớn: Cần kiên nhẫn - tệp cỡ megabyte có thể mất vài phút, gigabyte mất hàng giờ Kết nối đầu tiên chậm nhất: Việc xây dựng tunnel mất 30-90 giây; các kết nối tiếp theo dùng các tunnel hiện có Tỷ lệ thành công khi xây dựng Tunnel cho biết tình trạng sức khỏe của mạng. Kiểm tra tại http://127.0.0.1:7657/tunnels:\nTrên 60%: Bình thường, hoạt động ổn định 40-60%: Cận biên, cân nhắc tăng băng thông hoặc giảm tải Dưới 40%: Có vấn đề - cho thấy băng thông không đủ, sự cố mạng, hoặc lựa chọn nút ngang hàng kém Tăng phân bổ băng thông là bước tối ưu hóa đầu tiên. Tình trạng chậm chạp phần lớn xuất phát từ việc thiếu băng thông. Tại http://127.0.0.1:7657/config, hãy tăng dần các giới hạn và theo dõi biểu đồ tại http://127.0.0.1:7657/graphs.\nDành cho DSL/Cable (kết nối 1-10 Mbps): - Băng thông vào: 400 KB/giây - Băng thông ra: 200 KB/giây - Chia sẻ: 80% - Bộ nhớ: 384 MB (chỉnh sửa wrapper.config)\nĐối với kết nối tốc độ cao (10-100+ Mbps): - Vào: 1500 KB/giây - Ra: 1000 KB/giây - Chia sẻ: 80-100% - Bộ nhớ: 512-1024 MB - Cân nhắc: Tăng số lượng tunnels tham gia lên 2000-5000 tại http://127.0.0.1:7657/configadvanced\nTối ưu cấu hình tunnel để có hiệu năng tốt hơn. Truy cập các cài đặt tunnel cụ thể tại http://127.0.0.1:7657/i2ptunnel và chỉnh sửa từng tunnel:\nSố lượng tunnel: Tăng từ 2 lên 3-4 (có nhiều đường đi hơn) Số lượng dự phòng: Đặt thành 1-2 (chuyển đổi dự phòng nhanh nếu tunnel gặp sự cố) Độ dài tunnel: Mặc định 3 hop (chặng) mang lại cân bằng tốt; giảm xuống 2 cải thiện tốc độ nhưng giảm tính ẩn danh Thư viện mật mã gốc (jbigi) cho hiệu năng tốt hơn 5-10x so với mã hóa Java thuần. Xác minh đã được nạp tại http://127.0.0.1:7657/logs - hãy tìm \u0026ldquo;jbigi loaded successfully\u0026rdquo; hoặc \u0026ldquo;Using native CPUID implementation\u0026rdquo;. Nếu không thấy:\nLinux: Thông thường được tự động phát hiện và nạp từ ~/.i2p/jbigi-*.so Windows: Kiểm tra jbigi.dll trong thư mục cài đặt I2P Nếu thiếu: Cài đặt các công cụ biên dịch/xây dựng và biên dịch từ mã nguồn, hoặc tải các tệp nhị phân đã biên dịch sẵn từ các kho lưu trữ chính thức\nGiữ router chạy liên tục. Mỗi lần khởi động lại sẽ đặt lại trạng thái hòa nhập, cần 30-60 phút để xây dựng lại mạng lưới tunnel và các mối quan hệ với các nút (peer). Các router ổn định với thời gian hoạt động (uptime) cao sẽ được ưu tiên chọn khi xây dựng tunnel, tạo ra vòng phản hồi tích cực cho hiệu năng.\nMức sử dụng CPU và bộ nhớ cao Việc sử dụng tài nguyên quá mức thường cho thấy cấp phát bộ nhớ không đầy đủ, thiếu các thư viện mật mã gốc (native), hoặc quá mức cam kết với việc tham gia mạng. Các router được cấu hình tốt nên tiêu thụ 10-30% CPU trong khi hoạt động và duy trì mức sử dụng bộ nhớ ổn định dưới 80% của heap (vùng bộ nhớ heap) được cấp phát.\nCác vấn đề về bộ nhớ biểu hiện như sau: - Biểu đồ bộ nhớ đỉnh phẳng (bị ghim ở mức tối đa) - Thu gom rác (garbage collection) diễn ra thường xuyên (mẫu răng cưa với các đợt tụt mạnh) - OutOfMemoryError trong nhật ký - Router trở nên không phản hồi khi chịu tải - Tự động tắt do cạn kiệt tài nguyên\nTăng phân bổ bộ nhớ heap của Java trong wrapper.config (yêu cầu tắt hoàn toàn):\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 Quan trọng: Sau khi chỉnh sửa wrapper.config, bạn phải tắt hoàn toàn (không khởi động lại), chờ 11 phút để quá trình kết thúc an toàn, rồi khởi động mới. Nút \u0026ldquo;Restart\u0026rdquo; trên Router console không tải lại các thiết lập của wrapper.\nTối ưu hóa CPU cần thư viện mật mã gốc (native). Các phép toán BigInteger thuần Java tiêu tốn CPU gấp 10–20 lần so với các triển khai native. Hãy kiểm tra trạng thái jbigi tại http://127.0.0.1:7657/logs trong khi khởi động. Nếu không có jbigi, CPU sẽ tăng vọt lên 50–100% trong quá trình xây dựng tunnel và các hoạt động mã hóa.\nGiảm tải từ các tunnel tham gia nếu router bị quá tải:\nTruy cập http://127.0.0.1:7657/configadvanced Thiết lập router.maxParticipatingTunnels=1000 (mặc định là 8000) Giảm tỷ lệ chia sẻ tại http://127.0.0.1:7657/config từ 80% xuống 50% Tắt chế độ floodfill nếu đang bật: router.floodfillParticipant=false Giới hạn băng thông và số torrent hoạt động đồng thời của I2PSnark. Việc tải torrent tiêu tốn đáng kể tài nguyên. Tại http://127.0.0.1:7657/i2psnark:\nGiới hạn số torrent đang hoạt động tối đa 3-5 Đặt \u0026ldquo;Up BW Limit\u0026rdquo; và \u0026ldquo;Down BW Limit\u0026rdquo; ở các giá trị hợp lý (50-100 KB/giây mỗi cái) Dừng torrent khi không còn cần thiết Tránh seed (chia sẻ) hàng chục torrent cùng lúc Theo dõi mức sử dụng tài nguyên thông qua các đồ thị tích hợp sẵn tại http://127.0.0.1:7657/graphs. Bộ nhớ nên thể hiện còn dư địa (headroom), không phải đỉnh phẳng (flat-top). Các đột biến CPU trong lúc xây dựng tunnel là bình thường; CPU cao kéo dài cho thấy có vấn đề về cấu hình.\nĐối với các hệ thống rất hạn chế tài nguyên (Raspberry Pi, phần cứng cũ), hãy cân nhắc i2pd (triển khai C++) như một lựa chọn thay thế. i2pd cần ~130 MB RAM so với 350+ MB của Java I2P, và dùng ~7% CPU so với 70% dưới tải tương tự. Lưu ý rằng i2pd không có ứng dụng tích hợp sẵn và cần các công cụ bên ngoài.\nCác sự cố torrent của I2PSnark Để I2PSnark tích hợp với kiến trúc router của I2P, cần hiểu rằng việc torrent phụ thuộc hoàn toàn vào tình trạng hoạt động của tunnel trên router. Các torrent sẽ không bắt đầu cho đến khi router đạt mức hòa nhập mạng đủ tốt với hơn 10 nút ngang hàng đang hoạt động và các tunnel hoạt động bình thường.\nCác torrent bị kẹt ở mức 0% thường là dấu hiệu cho thấy:\nRouter chưa tích hợp đầy đủ: Chờ 10-15 phút sau khi I2P khởi động trước khi mong đợi có hoạt động torrent DHT (bảng băm phân tán) bị tắt: Bật tại http://127.0.0.1:7657/i2psnark → Configuration → đánh dấu \u0026ldquo;Enable DHT\u0026rdquo; (mặc định bật từ phiên bản 0.9.2) Tracker không hợp lệ hoặc đã chết: Torrent trên I2P yêu cầu tracker dành riêng cho I2P - tracker clearnet (mạng Internet công khai) sẽ không hoạt động Cấu hình tunnel không đủ: Tăng số lượng tunnel tại I2PSnark Configuration → phần Tunnels Cấu hình I2PSnark tunnels để cải thiện hiệu năng:\nTunnel vào: 3-5 (mặc định là 2 cho Java I2P, 5 cho i2pd) Tunnel ra: 3-5 Độ dài tunnel: 3 hop (bước nhảy qua nút trung gian; giảm xuống 2 để tăng tốc, ít ẩn danh hơn) Số lượng tunnel: 3 (cho hiệu năng ổn định) Các tracker (máy chủ theo dõi) torrent I2P thiết yếu cần thêm: - tracker2.postman.i2p (chính, đáng tin cậy nhất) - w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a\nHãy loại bỏ mọi tracker clearnet (internet công khai, không phải .i2p) - chúng không mang lại giá trị nào và tạo ra các lần thử kết nối bị hết thời gian chờ.\nLỗi \u0026ldquo;Torrent not registered\u0026rdquo; xảy ra khi việc giao tiếp với tracker thất bại. Nhấp chuột phải vào torrent → \u0026ldquo;Start\u0026rdquo; sẽ buộc thông báo lại với tracker. Nếu vẫn tiếp diễn, hãy kiểm tra khả năng truy cập của tracker bằng cách truy cập http://tracker2.postman.i 2p trong trình duyệt đã được cấu hình I2P. Các tracker chết nên được thay bằng các lựa chọn thay thế còn hoạt động.\nKhông có peer (nút ngang hàng) nào kết nối mặc dù tracker phản hồi thành công, có thể do: - Router bị tường lửa chặn (cải thiện khi bật port forwarding (chuyển tiếp cổng) nhưng không bắt buộc) - Băng thông không đủ (tăng lên 256+ KB/sec) - Swarm (nhóm người dùng chia sẻ) quá nhỏ (một số torrent chỉ có 1-2 seeders (máy chia sẻ); cần kiên nhẫn) - DHT bị tắt (bật để tìm peer không cần tracker)\nKích hoạt DHT (bảng băm phân tán) và PEX (Peer Exchange - trao đổi nút) trong I2PSnark Configuration. DHT cho phép tìm các nút mà không phụ thuộc vào tracker (máy theo dõi). PEX khám phá các nút từ các nút đã kết nối, tăng tốc quá trình phát hiện swarm (tập hợp các nút trong torrent).\nHư hỏng tệp đã tải xuống hiếm khi xảy ra nhờ cơ chế kiểm tra tính toàn vẹn tích hợp sẵn của I2PSnark. Nếu phát hiện:\nNhấp chuột phải vào torrent → \u0026ldquo;Check\u0026rdquo; sẽ buộc băm lại tất cả các mảnh Xóa dữ liệu torrent bị hỏng (giữ lại tệp .torrent) Nhấp chuột phải → \u0026ldquo;Start\u0026rdquo; để tải lại kèm xác minh từng mảnh Kiểm tra ổ đĩa để tìm lỗi nếu vẫn còn hỏng: chkdsk (Windows), fsck (Linux) Tính năng theo dõi thư mục không hoạt động cần được cấu hình đúng cách:\nCấu hình I2PSnark → \u0026ldquo;Watch directory\u0026rdquo;: Đặt đường dẫn tuyệt đối (ví dụ: /home/user/torrents/watch) Đảm bảo tiến trình I2P có quyền đọc: chmod 755 /path/to/watch Đặt các tệp .torrent vào thư mục Watch directory - I2PSnark sẽ tự động thêm chúng Cấu hình \u0026ldquo;Auto start\u0026rdquo;: Đánh dấu chọn để các torrent bắt đầu ngay khi được thêm Tối ưu hiệu năng cho việc tải torrent:\nGiới hạn số torrent hoạt động đồng thời: tối đa 3-5 cho các kết nối tiêu chuẩn Ưu tiên các tải xuống quan trọng: Dừng tạm thời các torrent ưu tiên thấp Tăng phân bổ băng thông cho router: Nhiều băng thông hơn = hiệu suất torrent tốt hơn Hãy kiên nhẫn: Tải torrent qua I2P vốn dĩ chậm hơn so với BitTorrent trên clearnet (Internet công khai) Seed sau khi tải xong: Mạng lưới phát triển nhờ tính có đi có lại Cấu hình và khắc phục sự cố Git qua I2P Các thao tác Git qua I2P cần hoặc cấu hình proxy SOCKS hoặc I2P tunnels chuyên dụng để truy cập SSH/HTTP. Thiết kế của Git giả định các kết nối có độ trễ thấp, khiến việc hoạt động qua kiến trúc có độ trễ cao của I2P trở nên thách thức.\nCấu hình Git để sử dụng proxy SOCKS của I2P:\nChỉnh sửa ~/.ssh/config (tạo nếu chưa có):\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes Điều này định tuyến tất cả các kết nối SSH tới các máy chủ .i2p thông qua SOCKS proxy của I2P (cổng 4447). Các thiết lập ServerAlive (tùy chọn giữ kết nối của SSH) duy trì kết nối khi I2P có độ trễ.\nĐối với các thao tác git qua HTTP/HTTPS, hãy cấu hình git ở mức toàn cục:\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 Lưu ý: socks5h thực hiện phân giải DNS thông qua proxy - rất quan trọng đối với các tên miền .i2p.\nTạo I2P tunnel chuyên dụng cho Git SSH (đáng tin cậy hơn so với SOCKS):\nTruy cập http://127.0.0.1:7657/i2ptunnel \u0026ldquo;New client tunnel\u0026rdquo; → \u0026ldquo;Standard\u0026rdquo; Cấu hình: Tên: Git-SSH Loại: Client Cổng: 2222 (cổng cục bộ để truy cập Git) Đích: [your-git-server].i2p:22 Tự động khởi động: Bật Số lượng tunnel: 3-4 (cao hơn để tăng độ tin cậy) Lưu và khởi động tunnel Cấu hình SSH để sử dụng tunnel: ssh -p 2222 git@127.0.0.1 Các lỗi xác thực SSH qua I2P thường bắt nguồn từ:\nChưa thêm khóa vào ssh-agent: ssh-add ~/.ssh/id_rsa Phân quyền tệp khóa không đúng: chmod 600 ~/.ssh/id_rsa Tunnel không chạy: Xác minh tại http://127.0.0.1:7657/i2ptunnel hiển thị trạng thái màu xanh Máy chủ Git yêu cầu loại khóa cụ thể: Tạo khóa ed25519 nếu RSA không thành công Các thao tác Git bị hết thời gian chờ liên quan đến đặc tính độ trễ của I2P:\nTăng thời gian chờ của Git: git config --global http.postBuffer 524288000 (bộ đệm 500MB) Tăng giới hạn tốc độ thấp: git config --global http.lowSpeedLimit 1000 và git config --global http.lowSpeedTime 600 (chờ 10 phút) Sử dụng shallow clone (clone nông) cho lần clone ban đầu: git clone --depth 1 [url] (chỉ tải commit mới nhất, nhanh hơn) Thực hiện clone vào các khoảng thời gian ít hoạt động: Tắc nghẽn mạng ảnh hưởng đến hiệu năng I2P Các thao tác git clone/fetch chậm là đặc tính vốn có của kiến trúc I2P. Một kho mã nguồn 100MB có thể mất 30-60 phút qua I2P, so với chỉ vài giây trên clearnet (mạng công khai). Chiến lược:\nSử dụng shallow clone (clone nông): --depth 1 giảm đáng kể lượng dữ liệu truyền ban đầu Fetch theo từng phần: Thay vì clone đầy đủ, fetch các nhánh cụ thể: git fetch origin branch:branch Cân nhắc rsync qua I2P: Với các kho rất lớn, rsync có thể cho hiệu năng tốt hơn Tăng số lượng tunnel: Nhiều tunnel mang lại thông lượng tốt hơn cho các truyền tải dữ liệu lớn kéo dài Các lỗi \u0026ldquo;Connection refused\u0026rdquo; cho thấy cấu hình tunnel sai:\nXác minh I2P router (bộ định tuyến) đang chạy: Kiểm tra http://127.0.0.1:7657 Xác nhận tunnel (đường hầm) đang hoạt động và hiển thị màu xanh tại http://127.0.0.1:7657/i2ptunnel Kiểm tra tunnel: nc -zv 127.0.0.1 2222 (sẽ kết nối nếu tunnel hoạt động) Kiểm tra đích có thể truy cập: Truy cập giao diện HTTP của đích nếu có Xem lại nhật ký tunnel tại http://127.0.0.1:7657/logs để tìm lỗi cụ thể Thực tiễn tốt nhất cho Git (hệ thống quản lý phiên bản phân tán) qua I2P:\nGiữ I2P router chạy liên tục để truy cập Git ổn định Sử dụng khóa SSH thay vì xác thực bằng mật khẩu (ít lời nhắc tương tác hơn) Cấu hình tunnels thường trực thay vì các kết nối SOCKS tạm thời Cân nhắc tự lưu trữ máy chủ git I2P để kiểm soát tốt hơn Ghi lại các điểm cuối git .i2p của bạn cho cộng tác viên Truy cập các eepsite và phân giải tên miền .i2p Lý do thường gặp nhất khiến người dùng không thể truy cập các trang .i2p là cấu hình proxy trình duyệt không đúng. Các trang I2P chỉ tồn tại trong mạng I2P và cần được định tuyến thông qua proxy HTTP của I2P.\nThiết lập cài đặt proxy của trình duyệt chính xác như sau:\nFirefox (được khuyến nghị cho I2P):\nMenu → Cài đặt → Cài đặt mạng → nút Cài đặt Chọn \u0026ldquo;Cấu hình proxy thủ công\u0026rdquo; Proxy HTTP: 127.0.0.1 Cổng: 4444 Proxy SSL: 127.0.0.1 Cổng: 4444 Proxy SOCKS: 127.0.0.1 Cổng: 4447 (tùy chọn, dành cho ứng dụng SOCKS) Chọn \u0026ldquo;Proxy DNS khi dùng SOCKS v5\u0026rdquo; Nhấn OK để lưu Các cài đặt about:config quan trọng của Firefox:\nTruy cập about:config và chỉnh sửa:\nmedia.peerconnection.ice.proxy_only = true (ngăn rò rỉ địa chỉ IP qua WebRTC) keyword.enabled = false (ngăn địa chỉ .i2p bị chuyển hướng đến công cụ tìm kiếm) network.proxy.socks_remote_dns = true (DNS qua proxy) Các hạn chế của Chrome/Chromium:\nChrome sử dụng cài đặt proxy toàn hệ thống thay vì theo từng ứng dụng. Trên Windows: Cài đặt → tìm kiếm \u0026ldquo;proxy\u0026rdquo; → \u0026ldquo;Mở cài đặt proxy của máy tính\u0026rdquo; → Cấu hình HTTP: 127.0.0.1:4444 và HTTPS: 127.0.0.1:4445.\nCách tiếp cận tốt hơn: Sử dụng tiện ích mở rộng FoxyProxy hoặc Proxy SwitchyOmega để định tuyến .i2p có chọn lọc.\nCác lỗi \u0026ldquo;Website Not Found In Address Book\u0026rdquo; có nghĩa là router không có địa chỉ mật mã của miền .i2p. I2P sử dụng sổ địa chỉ cục bộ thay vì DNS tập trung. Giải pháp:\nPhương pháp 1: Sử dụng jump services (dịch vụ \u0026ldquo;jump\u0026rdquo; giúp truy cập các trang mới chưa có trong sổ địa chỉ) (dễ nhất cho các trang mới):\nTruy cập http://stats.i 2p và tìm kiếm trang web. Nhấp vào liên kết addresshelper: http://example.i2p/?i2paddresshelper=base64destination. Trình duyệt của bạn sẽ hiển thị \u0026ldquo;Lưu vào sổ địa chỉ?\u0026rdquo; - xác nhận để thêm.\nPhương pháp 2: Cập nhật các đăng ký sổ địa chỉ:\nTruy cập http://127.0.0.1:7657/dns (SusiDNS) Nhấp vào thẻ \u0026ldquo;Subscriptions\u0026rdquo; Kiểm tra các đăng ký đang hoạt động (mặc định: http://i2p-projekt.i 2p/hosts.txt) Thêm các đăng ký được khuyến nghị: http://stats.i 2p/cgi-bin/newhosts.txt http://notbob.i 2p/hosts.txt http://reg.i 2p/export/hosts.txt Nhấp \u0026ldquo;Update Now\u0026rdquo; để buộc cập nhật đăng ký ngay lập tức Chờ 5-10 phút để xử lý Cách 3: Sử dụng địa chỉ base32 (luôn hoạt động nếu trang web đang trực tuyến):\nMỗi site .i2p đều có một địa chỉ Base32: 52 ký tự ngẫu nhiên theo sau là .b32.i2p (ví dụ, ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p). Các địa chỉ Base32 bỏ qua sổ địa chỉ (addressbook) - router thực hiện tra cứu mật mã trực tiếp.\nCác lỗi cấu hình trình duyệt thường gặp:\nCố dùng HTTPS với các trang chỉ hỗ trợ HTTP: Hầu hết các trang .i2p chỉ dùng HTTP - thử https://example.i2p sẽ thất bại Quên tiền tố http://: Trình duyệt có thể tìm kiếm thay vì kết nối - luôn dùng http://example.i2p WebRTC được bật: Có thể làm lộ địa chỉ IP thật - tắt qua cài đặt Firefox hoặc tiện ích mở rộng DNS không qua proxy: DNS clearnet (internet công khai) không thể phân giải .i2p - phải đưa các truy vấn DNS qua proxy Sai cổng proxy: 4444 dành cho HTTP (không phải 4445, đây là HTTPS outproxy (proxy đi ra) tới clearnet) Router chưa được tích hợp đầy đủ khiến không thể truy cập bất kỳ trang web nào. Hãy kiểm tra mức độ tích hợp đã đủ:\nKiểm tra http://127.0.0.1:7657 hiển thị \u0026ldquo;Network: OK\u0026rdquo; hoặc \u0026ldquo;Network: Firewalled\u0026rdquo; (không phải \u0026ldquo;Network: Testing\u0026rdquo;) Mục Active peers hiển thị tối thiểu 10+ (50+ là tối ưu) Không có thông báo \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; Chờ đủ 10-15 phút sau khi router khởi động trước khi mong đợi truy cập .i2p Cấu hình IRC và trình khách email tuân theo các mẫu proxy tương tự:\nIRC: Các trình khách kết nối tới 127.0.0.1:6668 (tunnel proxy IRC của I2P). Tắt cài đặt proxy của trình khách IRC - kết nối tới localhost:6668 đã được proxy qua I2P.\nEmail (Postman): - SMTP: 127.0.0.1:7659 - POP3: 127.0.0.1:7660 - Không dùng SSL/TLS (mã hóa được xử lý bởi I2P tunnel) - Thông tin đăng nhập từ đăng ký tài khoản trên postman.i2p\nTất cả các tunnels này phải hiển thị trạng thái \u0026ldquo;running\u0026rdquo; (màu xanh lá) tại http://127.0.0.1:7657/i2ptunnel.\nLỗi cài đặt và sự cố gói phần mềm Các cài đặt dựa trên gói (Debian, Ubuntu, Arch) đôi khi bị lỗi do thay đổi kho lưu trữ, khóa GPG hết hạn, hoặc xung đột phụ thuộc. Các kho chính thức đã chuyển từ deb.i2p2.de/deb.i2p2.no (đã ngừng hỗ trợ) sang deb.i2p.net trong các phiên bản gần đây.\nCập nhật kho phần mềm Debian/Ubuntu lên phiên bản hiện tại:\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring Các lỗi xác minh chữ ký GPG xảy ra khi các khóa của kho lưu trữ hết hạn hoặc thay đổi:\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc Dịch vụ không khởi động sau khi cài đặt gói thường là do các sự cố với AppArmor profile trên Debian/Ubuntu:\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service Vấn đề quyền truy cập trên I2P được cài đặt từ gói:\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 Các vấn đề về khả năng tương thích Java:\nI2P 2.10.0 yêu cầu tối thiểu Java 8. Các hệ thống cũ hơn có thể có Java 7 hoặc cũ hơn:\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java Lỗi cấu hình Wrapper ngăn dịch vụ khởi động:\nVị trí của Wrapper.config thay đổi tùy theo phương pháp cài đặt: - Cài đặt người dùng: ~/.i2p/wrapper.config - Cài đặt từ gói: /etc/i2p/wrapper.config hoặc /var/lib/i2p/wrapper.config\nCác vấn đề thường gặp với wrapper.config:\nĐường dẫn sai: wrapper.java.command phải trỏ tới cài đặt Java hợp lệ Không đủ bộ nhớ: wrapper.java.maxmemory được đặt quá thấp (tăng lên 512+) Sai vị trí pidfile: wrapper.pidfile phải là một vị trí có thể ghi Thiếu tệp nhị phân của wrapper (trình bao): Một số nền tảng không có wrapper được biên dịch sẵn (sử dụng runplain.sh như phương án dự phòng) Các lỗi cập nhật và các bản cập nhật bị hỏng:\nCác bản cập nhật Router console đôi khi thất bại giữa quá trình tải xuống do gián đoạn mạng. Quy trình cập nhật thủ công:\nTải xuống i2pupdate_X.X.X.zip từ https://geti2p.net/en/download Xác minh checksum (tổng kiểm tra) SHA256 khớp với hash (giá trị băm) đã công bố Sao chép vào thư mục cài đặt I2P với tên i2pupdate.zip Khởi động lại router - tự động phát hiện và giải nén bản cập nhật Chờ 5-10 phút để cài đặt bản cập nhật Kiểm tra phiên bản mới tại http://127.0.0.1:7657 Nâng cấp từ các phiên bản rất cũ (trước 0.9.47) lên các phiên bản hiện tại có thể thất bại do khóa ký không tương thích hoặc do các tính năng đã bị loại bỏ. Cần cập nhật theo từng bước:\nCác phiên bản cũ hơn 0.9.9: Không thể xác minh chữ ký số hiện tại - cần cập nhật thủ công Các phiên bản chạy trên Java 6/7: Phải nâng cấp Java trước khi cập nhật I2P lên 2.x Chênh lệch lớn giữa các phiên bản chính: Hãy cập nhật lên phiên bản trung gian trước (0.9.47 là mốc khuyến nghị) Khi nào nên dùng trình cài đặt và khi nào nên dùng gói:\nGói (apt/yum): Phù hợp nhất cho máy chủ, cập nhật bảo mật tự động, tích hợp hệ thống, quản lý bằng systemd Trình cài đặt (.jar): Phù hợp nhất cho cài đặt cấp người dùng, Windows, macOS, cài đặt tùy chỉnh, có sẵn phiên bản mới nhất Hỏng tệp cấu hình và khôi phục Việc lưu trạng thái cấu hình của I2P dựa vào một số tệp quan trọng. Hỏng tệp thường xuất phát từ tắt không đúng cách, lỗi đĩa, hoặc sai sót khi chỉnh sửa thủ công. Hiểu rõ mục đích của từng tệp cho phép tiến hành sửa chữa chính xác thay vì phải cài đặt lại toàn bộ.\nCác tệp quan trọng và mục đích của chúng:\nrouter.keys (516+ bytes): Danh tính mật mã của router - mất sẽ tạo danh tính mới router.info (tự động tạo): Thông tin router được công bố - có thể xóa an toàn, sẽ được tạo lại router.config (văn bản): Cấu hình chính - băng thông, cài đặt mạng, tùy chọn i2ptunnel.config (văn bản): Định nghĩa tunnel - các tunnel máy khách/máy chủ, khóa, đích netDb/ (thư mục): Cơ sở dữ liệu đồng đẳng - thông tin router cho các nút tham gia mạng peerProfiles/ (thư mục): Thống kê hiệu năng về các nút đồng đẳng - ảnh hưởng đến việc chọn tunnel keyData/ (thư mục): Khóa đích cho eepsites và dịch vụ - mất sẽ làm thay đổi địa chỉ addressbook/ (thư mục): Ánh xạ tên máy chủ .i2p cục bộ Quy trình sao lưu hoàn chỉnh trước khi thực hiện các thay đổi:\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR Các dấu hiệu tập tin Router.config bị hỏng:\nRouter không khởi động với các lỗi phân tích cú pháp trong nhật ký Cài đặt không được giữ nguyên sau khi khởi động lại Xuất hiện các giá trị mặc định bất ngờ Ký tự hiển thị bị lỗi khi xem tệp Sửa router.config bị hỏng:\nSao lưu tệp hiện có: cp router.config router.config.broken Kiểm tra mã hóa tệp: Phải là UTF-8 không có BOM Xác minh cú pháp: Khóa dùng dấu phân tách = (không phải :), không có khoảng trắng ở cuối tên khóa, # chỉ dùng cho chú thích Các lỗi hỏng phổ biến: Ký tự không phải ASCII trong giá trị, vấn đề ký tự kết thúc dòng (CRLF vs LF) Nếu không thể sửa: Xóa router.config - router sẽ tạo cấu hình mặc định, giữ nguyên danh tính Các cài đặt router.config thiết yếu cần giữ nguyên:\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false Mất hoặc tệp router.keys không hợp lệ sẽ tạo ra một danh tính router mới. Điều này được chấp nhận, trừ khi:\nVận hành floodfill (mất trạng thái floodfill) Lưu trữ eepsites với địa chỉ đã công khai (mất tính liên tục) Danh tiếng đã được xây dựng trong mạng Không thể khôi phục nếu không có bản sao lưu - hãy tạo mới: delete router.keys, restart I2P, danh tính mới sẽ được tạo.\nPhân biệt quan trọng: router.keys (danh tính) so với keyData/* (dịch vụ). Mất router.keys sẽ làm thay đổi danh tính của router. Mất keyData/mysite-keys.dat sẽ làm thay đổi địa chỉ .i2p của eepsite (trang web trên I2P) của bạn - thảm họa nếu địa chỉ đã được công bố.\nSao lưu riêng các khóa eepsite/dịch vụ:\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat Hỏng dữ liệu NetDb và peerProfiles:\nTriệu chứng: Không có peer (nút ngang hàng) nào đang hoạt động, không thể thiết lập tunnels, xuất hiện \u0026ldquo;Phát hiện hỏng cơ sở dữ liệu\u0026rdquo; trong nhật ký\nCách khắc phục an toàn (tất cả sẽ reseed (nạp lại seed ban đầu)/xây dựng lại tự động):\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration Các thư mục này chỉ chứa thông tin mạng được lưu đệm — xóa chúng sẽ buộc thực hiện bootstrap (khởi tạo ban đầu) mới, nhưng không làm mất dữ liệu quan trọng nào.\nChiến lược phòng ngừa:\nLuôn tắt đúng cách: Dùng i2prouter stop hoặc nút \u0026ldquo;Shutdown\u0026rdquo; trên bảng điều khiển của router - không bao giờ kill cưỡng bức Sao lưu tự động: Thiết lập tác vụ cron sao lưu hàng tuần ~/.i2p sang đĩa riêng biệt Giám sát tình trạng đĩa: Kiểm tra trạng thái SMART định kỳ - đĩa lỗi làm hỏng dữ liệu Đủ dung lượng đĩa: Duy trì từ 1 GB trống trở lên - đĩa đầy gây hỏng dữ liệu Khuyến nghị dùng UPS (bộ lưu điện): Mất điện trong khi ghi sẽ làm hỏng tệp Kiểm soát phiên bản các cấu hình quan trọng: Dùng kho Git cho router.config, i2ptunnel.config để có thể quay lui Quyền truy cập tệp rất quan trọng:\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems Giải mã các thông báo lỗi thường gặp Ghi log của I2P cung cấp các thông báo lỗi cụ thể để chỉ ra chính xác vấn đề. Việc hiểu các thông báo này giúp đẩy nhanh quá trình khắc phục sự cố.\n\u0026ldquo;No tunnels available\u0026rdquo; xuất hiện khi router chưa xây dựng đủ tunnel để hoạt động. Điều này là bình thường trong 5-10 phút đầu tiên sau khi khởi động. Nếu tình trạng này kéo dài quá 15 phút:\nXác minh Active Peers \u0026gt; 10 tại http://127.0.0.1:7657 Kiểm tra phân bổ băng thông có đủ (tối thiểu 128+ KB/giây) Xem xét tỷ lệ thành công của tunnel tại http://127.0.0.1:7657/tunnels (nên \u0026gt;40%) Xem lại nhật ký để tìm các lý do bị từ chối xây dựng tunnel \u0026ldquo;Clock skew detected\u0026rdquo; hoặc \u0026ldquo;NTCP2 disconnect code 7\u0026rdquo; cho biết thời gian hệ thống lệch so với đồng thuận của mạng hơn 90 giây. I2P yêu cầu độ chính xác ±60 giây. Các kết nối với các router có thời gian lệch sẽ tự động bị từ chối.\nKhắc phục ngay:\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings \u0026ldquo;Build timeout\u0026rdquo; hoặc \u0026ldquo;Tunnel build timeout exceeded\u0026rdquo; có nghĩa là việc xây dựng tunnel thông qua chuỗi peer (chuỗi nút ngang hàng) không hoàn tất trong cửa sổ thời gian chờ (thường là 60 giây). Nguyên nhân:\nCác nút chậm: Router đã chọn các nút tham gia không phản hồi cho tunnel Tắc nghẽn mạng: Mạng I2P đang chịu tải cao Băng thông không đủ: Giới hạn băng thông của bạn ngăn cản việc xây dựng tunnel kịp thời Router quá tải: Có quá nhiều tunnels tham gia đang tiêu tốn tài nguyên Giải pháp: Tăng băng thông, giảm số lượng tunnels tham gia (router.maxParticipatingTunnels tại http://127.0.0.1:7657/configadvanced), bật chuyển tiếp cổng (port forwarding) để chọn nút ngang hàng tốt hơn.\n\u0026ldquo;Router is shutting down\u0026rdquo; hoặc \u0026ldquo;Graceful shutdown in progress\u0026rdquo; xuất hiện trong quá trình tắt bình thường hoặc khi khôi phục sau sự cố. Việc tắt an toàn có thể mất tối đa 10 phút khi router đóng các tunnel, thông báo cho các nút ngang hàng và ghi lưu trạng thái.\nNếu bị kẹt trong trạng thái tắt quá 11 phút, hãy buộc kết thúc:\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; báo hiệu tình trạng cạn kiệt heap (vùng nhớ cấp phát động). Giải pháp tức thời:\nChỉnh sửa wrapper.config: wrapper.java.maxmemory=512 (hoặc cao hơn) Yêu cầu tắt hoàn toàn - việc khởi động lại sẽ không áp dụng thay đổi Chờ 11 phút để tắt hoàn toàn Khởi động router mới hoàn toàn Xác minh phân bổ bộ nhớ tại http://127.0.0.1:7657/graphs - nên hiển thị headroom (khoảng trống) Các lỗi liên quan đến bộ nhớ:\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo;: Tốn quá nhiều thời gian cho thu gom rác (garbage collection) - tăng dung lượng heap \u0026ldquo;Metaspace\u0026rdquo;: Hết dung lượng không gian metadata của lớp Java - thêm wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M Dành riêng cho Windows: Kaspersky Antivirus giới hạn heap Java ở 512MB bất chấp các thiết lập trong wrapper.config - hãy gỡ cài đặt hoặc thêm I2P vào danh sách loại trừ.\n\u0026ldquo;Hết thời gian kết nối\u0026rdquo; hoặc \u0026ldquo;I2CP Error - port 7654\u0026rdquo; khi các ứng dụng cố gắng kết nối tới router:\nXác minh router đang chạy: http://127.0.0.1:7657 nên phản hồi Kiểm tra cổng I2CP: netstat -an | grep 7654 nên hiển thị LISTENING Đảm bảo tường lửa trên localhost cho phép: sudo ufw allow from 127.0.0.1 Xác minh ứng dụng đang sử dụng đúng cổng (I2CP=7654, SAM=7656) \u0026ldquo;Certificate validation failed\u0026rdquo; hoặc \u0026ldquo;RouterInfo corrupt\u0026rdquo; trong quá trình reseed (khởi tạo netDb ban đầu):\nNguyên nhân gốc: Lệch đồng hồ (khắc phục trước), netDb bị hỏng, chứng chỉ reseed (khởi tạo ban đầu) không hợp lệ\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data \u0026ldquo;Phát hiện hỏng cơ sở dữ liệu\u0026rdquo; cho biết có hỏng dữ liệu ở mức đĩa trong netDb hoặc peerProfiles:\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start Kiểm tra sức khỏe ổ đĩa bằng các công cụ SMART (công nghệ tự giám sát, phân tích và báo cáo) - tình trạng hỏng dữ liệu tái diễn cho thấy bộ lưu trữ đang sắp hỏng.\nThách thức đặc thù theo nền tảng Các hệ điều hành khác nhau đặt ra những thách thức triển khai I2P mang tính đặc thù, liên quan đến quyền truy cập, chính sách bảo mật và tích hợp hệ thống.\nCác vấn đề về quyền và dịch vụ trên Linux I2P được cài đặt từ gói chạy dưới tài khoản hệ thống i2psvc (Debian/Ubuntu) hoặc i2p (các bản phân phối khác), và cần các quyền cụ thể:\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config Giới hạn mô tả tệp (file descriptor) ảnh hưởng đến khả năng xử lý kết nối của router. Giới hạn mặc định (1024) không đủ cho các router băng thông cao:\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p Xung đột AppArmor thường gặp trên Debian/Ubuntu ngăn chặn việc khởi động dịch vụ:\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined Các vấn đề về SELinux trên RHEL/CentOS/Fedora:\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t Khắc phục sự cố dịch vụ SystemD:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service Sự can thiệp từ Tường lửa và phần mềm diệt virus trên Windows Windows Defender và các sản phẩm chống virus của bên thứ ba thường xuyên đánh dấu I2P do các mẫu hành vi mạng. Cấu hình đúng cách giúp ngăn tình trạng chặn không cần thiết đồng thời vẫn duy trì bảo mật.\nCấu hình Tường lửa Windows Defender:\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; Hãy thay cổng 22648 bằng cổng I2P thực tế của bạn từ http://127.0.0.1:7657/confignet.\nSự cố cụ thể với Kaspersky Antivirus: \u0026ldquo;Application Control\u0026rdquo; của Kaspersky giới hạn heap Java ở mức 512MB, bất kể các thiết lập trong wrapper.config. Điều này gây ra OutOfMemoryError (lỗi hết bộ nhớ) trên các routers băng thông cao.\nGiải pháp: 1. Thêm I2P vào danh sách ngoại lệ của Kaspersky: Settings → Additional → Threats and Exclusions → Manage Exclusions 2. Hoặc gỡ cài đặt Kaspersky (được khuyến nghị cho việc vận hành I2P)\nHướng dẫn chung về phần mềm diệt virus của bên thứ ba:\nThêm thư mục cài đặt I2P vào danh sách loại trừ Thêm %APPDATA%\\I2P và %LOCALAPPDATA%\\I2P vào danh sách loại trừ Loại trừ javaw.exe khỏi phân tích hành vi Tắt các tính năng \u0026ldquo;Network Attack Protection\u0026rdquo; có thể can thiệp vào các giao thức I2P macOS Gatekeeper (tính năng bảo vệ của macOS) chặn cài đặt macOS Gatekeeper (cơ chế kiểm soát bảo mật của macOS) ngăn các ứng dụng chưa được ký chạy. Các trình cài đặt I2P không được ký bằng Apple Developer ID (chứng danh nhà phát triển của Apple), gây ra cảnh báo bảo mật.\nBỏ qua Gatekeeper (hệ thống bảo vệ ứng dụng của macOS) cho trình cài đặt I2P:\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file Việc chạy sau khi cài đặt vẫn có thể kích hoạt cảnh báo:\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ Không bao giờ vô hiệu hóa Gatekeeper (cơ chế bảo vệ của macOS) vĩnh viễn - gây rủi ro bảo mật cho các ứng dụng khác. Chỉ sử dụng cách bỏ qua theo từng tệp.\nCấu hình tường lửa trên macOS:\nTùy chọn hệ thống → Bảo mật \u0026amp; Quyền riêng tư → Tường lửa → Tùy chọn Tường lửa Nhấp \u0026ldquo;+\u0026rdquo; để thêm ứng dụng Đi tới vị trí cài đặt Java (ví dụ, /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java) Thêm và đặt thành \u0026ldquo;Allow incoming connections\u0026rdquo; Các sự cố của ứng dụng I2P trên Android Các ràng buộc về phiên bản Android và những hạn chế về tài nguyên tạo ra những thách thức riêng biệt.\nYêu cầu tối thiểu: - Yêu cầu Android 5.0+ (API level 21+) cho các phiên bản hiện tại - Tối thiểu 512MB RAM, khuyến nghị 1GB+ - 100MB dung lượng lưu trữ cho ứng dụng + dữ liệu router - Tắt hạn chế ứng dụng chạy nền cho I2P\nỨng dụng bị sập ngay lập tức:\nKiểm tra phiên bản Android: Cài đặt → Giới thiệu về điện thoại → Phiên bản Android (phải từ 5.0 trở lên) Gỡ cài đặt tất cả các phiên bản I2P: Chỉ cài một biến thể: net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\nCài đặt nhiều phiên bản sẽ gây xung đột Xóa dữ liệu ứng dụng: Cài đặt → Ứng dụng → I2P → Bộ nhớ → Xóa dữ liệu Cài đặt lại từ trạng thái sạch Tối ưu hóa pin đang tắt router:\nAndroid mạnh tay đóng các ứng dụng chạy nền để tiết kiệm pin. I2P cần được đưa vào danh sách ngoại lệ:\nCài đặt → Pin → Tối ưu hóa pin (hoặc Sử dụng pin của ứng dụng) Tìm I2P → Không tối ưu hóa (hoặc Cho phép hoạt động nền) Cài đặt → Ứng dụng → I2P → Pin → Cho phép hoạt động nền + Gỡ bỏ hạn chế Sự cố kết nối trên di động:\nKhởi tạo cần WiFi: Lần reseed (tải danh sách nút ban đầu) tải xuống một lượng dữ liệu đáng kể - hãy dùng WiFi, không dùng mạng di động Thay đổi mạng: I2P không xử lý việc chuyển mạng tốt - hãy khởi động lại ứng dụng sau khi chuyển giữa WiFi/mạng di động Băng thông cho di động: Cấu hình thận trọng ở mức 64-128 KB/giây để tránh hết dữ liệu di động Tối ưu hóa hiệu năng cho thiết bị di động:\nI2P app → Menu → Settings → Bandwidth Đặt giới hạn phù hợp: 64 KB/sec vào, 32 KB/sec ra cho mạng di động Giảm số lượng tunnels tham gia: Settings → Advanced → Max participating tunnels: 100-200 Bật \u0026ldquo;Stop I2P when screen off\u0026rdquo; để tiết kiệm pin Tải torrent trên Android:\nGiới hạn tối đa 2-3 torrent chạy đồng thời Giảm mức độ tích cực của DHT Chỉ dùng WiFi để torrent Chấp nhận tốc độ chậm hơn trên phần cứng di động Các vấn đề về Reseed (tải dữ liệu khởi tạo mạng) và bootstrap (khởi tạo ban đầu) Cài đặt I2P mới cần reseeding (tải thông tin peer ban đầu) - lấy thông tin peer ban đầu từ các máy chủ HTTPS công khai để tham gia mạng. Sự cố reseed khiến người dùng bị kẹt trong tình trạng không có peer nào và không thể truy cập mạng.\n\u0026ldquo;No active peers\u0026rdquo; sau khi cài đặt mới thường cho thấy việc reseed (tải dữ liệu khởi tạo) thất bại. Triệu chứng:\nPeer đã biết: 0 hoặc luôn dưới 5 \u0026ldquo;Network: Testing\u0026rdquo; vẫn hiển thị sau hơn 15 phút Nhật ký cho thấy \u0026ldquo;Reseed failed\u0026rdquo; (reseed: tải danh sách peer khởi tạo) hoặc lỗi kết nối tới máy chủ reseed Vì sao reseed (tải dữ liệu khởi tạo mạng) thất bại:\nTường lửa chặn HTTPS: Tường lửa của doanh nghiệp/ISP chặn kết nối tới reseed server (máy chủ khởi tạo mạng I2P) (port 443) Lỗi chứng chỉ SSL: Hệ thống thiếu các chứng chỉ gốc được cập nhật Yêu cầu proxy: Mạng yêu cầu proxy HTTP/SOCKS cho các kết nối ra ngoài Sai lệch đồng hồ: Xác thực chứng chỉ SSL thất bại khi thời gian hệ thống sai Kiểm duyệt theo địa lý: Một số quốc gia/ISP chặn các reseed server đã biết Buộc reseed (tải lại dữ liệu khởi tạo mạng) thủ công:\nTruy cập http://127.0.0.1:7657/configreseed Nhấp \u0026ldquo;Save changes and reseed now\u0026rdquo; Theo dõi http://127.0.0.1:7657/logs để tìm \u0026ldquo;Reseed got XX router infos\u0026rdquo; Chờ 5-10 phút để xử lý Kiểm tra http://127.0.0.1:7657 - Known peers nên tăng lên 50+ Cấu hình proxy reseed cho các mạng bị hạn chế:\nhttp://127.0.0.1:7657/configreseed → Cấu hình proxy:\nHTTP Proxy: [proxy-server]:[port] Hoặc SOCKS5: [socks-server]:[port] Bật \u0026ldquo;Use proxy for reseed only\u0026rdquo; Thông tin đăng nhập (nếu cần) Lưu và buộc reseed (tải lại dữ liệu khởi tạo mạng) Lựa chọn thay thế: Proxy Tor cho reseed (khởi tạo netDb):\nNếu Tor Browser hoặc Tor daemon (trình nền Tor) đang chạy:\nLoại proxy: SOCKS5 Máy chủ: 127.0.0.1 Cổng: 9050 (cổng SOCKS mặc định của Tor) Bật và reseed (tải lại dữ liệu khởi tạo mạng) Tái gieo (reseed) thủ công qua tệp su3 (biện pháp cuối cùng):\nKhi tất cả các phương thức reseed (quy trình tải dữ liệu khởi tạo netDb) tự động đều thất bại, hãy lấy tệp reseed qua kênh out-of-band (ngoài băng):\nTải i2pseeds.su3 từ nguồn đáng tin cậy trên kết nối không bị hạn chế (https://reseed.i2p.rocks/i2pseeds.su3 , https://reseed-fr.i2pd.xyz/i2pseeds.su3 ) Dừng I2P hoàn toàn Sao chép i2pseeds.su3 vào thư mục ~/.i2p/ Khởi động I2P - tự động giải nén và xử lý tệp Xóa i2pseeds.su3 sau khi xử lý Xác minh số lượng nút tăng tại http://127.0.0.1:7657 Lỗi chứng chỉ SSL trong quá trình reseed (khởi tạo dữ liệu mạng ban đầu):\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing Giải pháp:\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates Bị kẹt ở 0 nút ngang hàng đã biết quá 30 phút:\nCho biết việc reseed (khởi tạo netDb ban đầu từ các máy chủ reseed) đã thất bại hoàn toàn. Trình tự khắc phục sự cố:\nXác minh thời gian hệ thống là chính xác (sự cố phổ biến nhất - sửa TRƯỚC) Kiểm tra kết nối HTTPS: Thử truy cập https://reseed.i2p.rocks trong trình duyệt - nếu thất bại, là sự cố mạng Kiểm tra nhật ký I2P tại http://127.0.0.1:7657/logs để tìm các lỗi reseed (nạp danh sách nút ban đầu) cụ thể Thử URL reseed khác: http://127.0.0.1:7657/configreseed → thêm URL reseed tùy chỉnh: https://reseed-fr.i2pd.xyz/ Sử dụng phương pháp tệp su3 thủ công nếu đã thử hết các cách tự động Máy chủ reseed đôi khi ngoại tuyến: I2P bao gồm nhiều máy chủ reseed được hardcoded (ghi cứng trong mã). Nếu một máy chủ gặp lỗi, router sẽ tự động thử các máy chủ khác. Trường hợp tất cả các máy chủ reseed đều thất bại hoàn toàn là cực kỳ hiếm nhưng vẫn có thể xảy ra.\nCác reseed servers (máy chủ cung cấp dữ liệu ban đầu cho netDb) hiện đang hoạt động (tính đến tháng 10 năm 2025):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ Thêm dưới dạng URL tùy chỉnh nếu gặp sự cố với các thiết lập mặc định.\nDành cho người dùng ở các khu vực bị kiểm duyệt gắt gao:\nCân nhắc sử dụng các cầu Snowflake/Meek qua Tor cho reseed (tải dữ liệu khởi tạo mạng I2P) ban đầu, rồi chuyển sang I2P trực tiếp khi đã hòa mạng xong. Hoặc nhận i2pseeds.su3 qua steganography (giấu tin), email hoặc USB từ bên ngoài vùng kiểm duyệt.\nKhi nào nên tìm kiếm thêm sự trợ giúp Hướng dẫn này bao quát đại đa số các vấn đề về I2P, nhưng một số vấn đề cần sự chú ý của nhà phát triển hoặc chuyên môn của cộng đồng.\nNhờ cộng đồng I2P hỗ trợ khi:\nRouter liên tục bị sập sau khi đã thực hiện tất cả các bước khắc phục sự cố Rò rỉ bộ nhớ khiến mức sử dụng tăng đều, vượt quá heap (vùng nhớ heap) đã cấp phát Tỷ lệ thành công của Tunnel vẫn dưới 20% mặc dù đã cấu hình phù hợp Các lỗi mới trong nhật ký không được đề cập trong hướng dẫn này Lỗ hổng bảo mật được phát hiện Yêu cầu tính năng hoặc đề xuất cải tiến Trước khi yêu cầu trợ giúp, hãy thu thập thông tin chẩn đoán:\nPhiên bản I2P: http://127.0.0.1:7657 (ví dụ: \u0026ldquo;2.10.0\u0026rdquo;) Phiên bản Java: đầu ra của java -version Hệ điều hành và phiên bản Tình trạng router: Trạng thái mạng, Số lượng peer (nút ngang hàng) đang hoạt động, Các tunnel tham gia Cấu hình băng thông: Giới hạn vào/ra Trạng thái chuyển tiếp cổng (port forwarding): Bị tường lửa chặn hoặc OK Trích đoạn nhật ký liên quan: 50 dòng cuối hiển thị lỗi từ http://127.0.0.1:7657/logs Các kênh hỗ trợ chính thức:\nDiễn đàn: https://i2pforum.net (clearnet — Internet thông thường) hoặc http://i2pforum.i 2p (bên trong I2P) IRC: #i2p trên Irc2P (irc.postman.i2p qua I2P) hoặc irc.freenode.net (clearnet) Reddit: https://reddit.com/r/i2p dành cho thảo luận của cộng đồng Trình theo dõi lỗi: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues dành cho các lỗi đã được xác nhận Danh sách thư: i2p-dev@lists.i2p-projekt.de dành cho các câu hỏi về phát triển Kỳ vọng thực tế rất quan trọng. I2P chậm hơn clearnet (mạng Internet công khai) do thiết kế nền tảng - tunneling được mã hóa đa hop tạo ra độ trễ vốn có. Một I2P router có thời gian tải trang 30 giây và tốc độ torrent 50 KB/sec là đang hoạt động đúng, không bị hỏng. Người dùng kỳ vọng tốc độ clearnet sẽ thất vọng, bất kể tối ưu cấu hình.\nKết luận Phần lớn các vấn đề I2P xuất phát từ ba nhóm: thiếu kiên nhẫn trong giai đoạn bootstrap (khởi động ban đầu) (cần 10–15 phút), phân bổ tài nguyên không đủ (tối thiểu 512 MB RAM, 256 KB/giây băng thông), hoặc cấu hình chuyển tiếp cổng sai. Việc hiểu kiến trúc phân tán và thiết kế tập trung vào tính ẩn danh của I2P giúp người dùng phân biệt hành vi mong đợi với các vấn đề thực sự.\nTrạng thái \u0026ldquo;Firewalled\u0026rdquo; của router, tuy không tối ưu, không ngăn cản việc sử dụng I2P - chỉ hạn chế mức độ đóng góp cho mạng và làm giảm nhẹ hiệu năng. Người dùng mới nên ưu tiên tính ổn định hơn tối ưu hóa: hãy chạy router liên tục trong vài ngày trước khi điều chỉnh các cài đặt nâng cao, vì mức độ hòa nhập với mạng sẽ tự nhiên cải thiện theo thời gian hoạt động.\nKhi khắc phục sự cố, hãy luôn kiểm tra các yếu tố cơ bản trước: thời gian hệ thống chính xác, băng thông đầy đủ, router chạy liên tục và tối thiểu 10 nút ngang hàng đang hoạt động. Phần lớn sự cố được giải quyết bằng cách xử lý những điều cơ bản này thay vì chỉnh các tham số cấu hình khó hiểu. I2P sẽ đền đáp sự kiên nhẫn và việc vận hành liên tục bằng hiệu năng được cải thiện, khi router xây dựng uy tín và tối ưu hóa việc chọn nút ngang hàng qua nhiều ngày và nhiều tuần hoạt động.\n","description":"Hướng dẫn khắc phục sự cố toàn diện cho các vấn đề thường gặp của I2P router, bao gồm các vấn đề về kết nối, hiệu năng và cấu hình","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"Hướng dẫn khắc phục sự cố cho I2P Router","url":"/vi/docs/troubleshooting/"},{"categories":null,"content":"Đọc Hướng dẫn cho Nhà phát triển mới trước.\nHướng dẫn Cơ bản và Phong cách Lập trình Hầu hết những điều sau đây là thường thức đối với bất kỳ ai đã làm việc với mã nguồn mở hoặc trong môi trường lập trình thương mại. Những điều sau đây áp dụng chủ yếu cho nhánh phát triển chính i2p.i2p. Các hướng dẫn cho các nhánh khác, plugin và ứng dụng bên ngoài có thể khác biệt đáng kể; hãy liên hệ với nhà phát triển phù hợp để được hướng dẫn.\nCộng đồng Vui lòng đừng chỉ viết code. Nếu có thể, hãy tham gia vào các hoạt động phát triển khác, bao gồm: thảo luận phát triển và hỗ trợ trên IRC và i2pforum.i2p; kiểm thử; báo cáo lỗi và phản hồi; tài liệu; đánh giá code; v.v. Các lập trình viên tích cực nên có mặt định kỳ trên IRC #i2p-dev. Luôn nắm rõ chu kỳ phát hành hiện tại. Tuân thủ các mốc phát hành như đóng băng tính năng, đóng băng thẻ, và thời hạn check-in cho bản phát hành. Chu kỳ phát hành Chu kỳ phát hành thông thường là 10–16 tuần, bốn lần phát hành mỗi năm. Sau đây là các thời hạn gần đúng trong một chu kỳ 13 tuần điển hình. Thời hạn thực tế cho mỗi bản phát hành được người quản lý phát hành thiết lập sau khi tham khảo ý kiến toàn bộ nhóm.\n1–2 ngày sau bản phát hành trước: Được phép check-in vào trunk. 2–3 tuần sau bản phát hành trước: Hạn chót để lan truyền các thay đổi lớn từ các nhánh khác sang trunk. 4–5 tuần trước khi phát hành: Hạn chót để yêu cầu các liên kết trang chủ mới. 3–4 tuần trước khi phát hành: Đóng băng tính năng. Hạn chót cho các tính năng mới lớn. 2–3 tuần trước khi phát hành: Tổ chức cuộc họp dự án để xem xét các yêu cầu liên kết trang chủ mới, nếu có. 10–14 ngày trước khi phát hành: Đóng băng chuỗi dịch. Không thay đổi thêm các chuỗi đã dịch (đã gắn thẻ). Đẩy các chuỗi lên Transifex, thông báo hạn chót dịch thuật trên Transifex. 10–14 ngày trước khi phát hành: Hạn chót tính năng. Chỉ sửa lỗi sau thời điểm này. Không thêm tính năng, tái cấu trúc hoặc dọn dẹp mã. 3–4 ngày trước khi phát hành: Hạn chót dịch thuật. Kéo các bản dịch từ Transifex và check-in. 3–4 ngày trước khi phát hành: Hạn chót check-in. Không check-in sau thời điểm này nếu không có sự cho phép của người xây dựng bản phát hành. Vài giờ trước khi phát hành: Hạn chót đánh giá mã. Git Có hiểu biết cơ bản về hệ thống quản lý mã nguồn phân tán, ngay cả khi bạn chưa từng sử dụng git trước đây. Hãy yêu cầu trợ giúp nếu cần. Một khi đã push, các check-in sẽ tồn tại mãi mãi; không có cách nào hoàn tác. Vui lòng thận trọng. Nếu bạn chưa từng sử dụng git, hãy bắt đầu từng bước nhỏ. Check in một số thay đổi nhỏ và xem kết quả như thế nào. Kiểm tra các thay đổi của bạn trước khi check in. Nếu bạn thích mô hình phát triển check-in-trước-test, hãy sử dụng nhánh phát triển riêng trong tài khoản của bạn và tạo MR khi công việc hoàn tất. Không làm hỏng bản build. Không gây ra regression (lỗi thoái lui). Trong trường hợp bạn gây ra (điều này xảy ra), vui lòng không biến mất trong thời gian dài sau khi push thay đổi của bạn. Nếu thay đổi của bạn không đơn giản, hoặc bạn muốn mọi người kiểm tra nó và cần báo cáo kiểm tra tốt để biết liệu thay đổi của bạn đã được kiểm tra hay chưa, hãy thêm nhận xét check-in vào history.txt và tăng phiên bản build trong RouterVersion.java. Không check in các thay đổi lớn vào nhánh chính i2p.i2p muộn trong chu kỳ phát hành. Nếu một dự án sẽ mất hơn vài ngày, hãy tạo nhánh riêng trong git, trong tài khoản của bạn, và thực hiện phát triển ở đó để không chặn các bản phát hành. Đối với các thay đổi lớn (nói chung, hơn 100 dòng hoặc ảnh hưởng đến hơn ba tệp), hãy check in vào một nhánh mới trên tài khoản GitLab của bạn, tạo MR và chỉ định người đánh giá. Gán MR cho chính bạn. Tự merge MR sau khi người đánh giá phê duyệt. Không tạo nhánh WIP trong tài khoản I2P_Developers chính (trừ i2p.www). WIP thuộc về tài khoản riêng của bạn. Khi công việc hoàn tất, hãy tạo MR. Các nhánh duy nhất trong tài khoản chính chỉ nên dành cho các fork thực sự, như bản phát hành điểm. Thực hiện phát triển một cách minh bạch và hướng đến cộng đồng. Check in thường xuyên. Check in hoặc merge vào nhánh chính càng thường xuyên càng tốt, theo các hướng dẫn trên. Nếu bạn đang làm việc trên một dự án lớn trong nhánh/tài khoản riêng của mình, hãy cho mọi người biết để họ có thể theo dõi và xem xét/kiểm tra/nhận xét. Phong Cách Lập Trình Phong cách code trong hầu hết mã nguồn là 4 dấu cách để thụt lề. Không sử dụng tab. Không định dạng lại code. Nếu IDE hoặc editor của bạn muốn định dạng lại mọi thứ, hãy kiểm soát nó. Ở một số nơi, phong cách code có thể khác. Hãy sử dụng lẽ thường. Mô phỏng phong cách trong file bạn đang chỉnh sửa. Tất cả các class và method public và package-private mới đều yêu cầu Javadocs. Thêm @since release-number. Javadocs cho các method private mới là điều mong muốn. Đối với bất kỳ Javadocs nào được thêm vào, không được có bất kỳ lỗi hoặc cảnh báo doclint nào. Chạy ant javadoc với Oracle Java 14 hoặc cao hơn để kiểm tra. Tất cả params phải có dòng @param, tất cả method không phải void phải có dòng @return, tất cả exception được khai báo throw phải có dòng @throws, và không có lỗi HTML. Các class trong core/ (i2p.jar) và một phần của i2ptunnel là một phần của API chính thức của chúng tôi. Có một số plugin ngoài cây mã nguồn và các ứng dụng khác phụ thuộc vào API này. Hãy cẩn thận không thực hiện bất kỳ thay đổi nào phá vỡ tính tương thích. Đừng thêm method vào API trừ khi chúng có tính tiện ích chung. Javadocs cho các method API nên rõ ràng và đầy đủ. Nếu bạn thêm hoặc thay đổi API, cũng cập nhật tài liệu trên website (nhánh i2p.www). Đánh dấu các chuỗi để dịch khi thích hợp, điều này đúng với tất cả chuỗi UI. Đừng thay đổi các chuỗi đã được đánh dấu trừ khi thực sự cần thiết, vì nó sẽ phá vỡ các bản dịch hiện có. Không thêm hoặc thay đổi các chuỗi đã đánh dấu sau khi đóng băng tag trong chu kỳ phát hành để người dịch có cơ hội cập nhật trước khi phát hành. Sử dụng generics và các class concurrent khi có thể. I2P là một ứng dụng đa luồng cao. Làm quen với các lỗi Java phổ biến được phát hiện bởi FindBugs/SpotBugs. Chạy ant findbugs để tìm hiểu thêm. Java 8 là yêu cầu để build và chạy I2P từ phiên bản 0.9.47. Không sử dụng các class hoặc method của Java 7 hoặc 8 trong các hệ thống con nhúng: addressbook, core, i2ptunnel.jar (non‑UI), mstreaming, router, routerconsole (chỉ news), streaming. Các hệ thống con này được sử dụng bởi Android và các ứng dụng nhúng chỉ yêu cầu Java 6. Tất cả các class phải có sẵn trong Android API 14. Các tính năng ngôn ngữ Java 7 có thể chấp nhận được trong các hệ thống con này nếu được hỗ trợ bởi phiên bản hiện tại của Android SDK và chúng biên dịch thành code tương thích Java 6. Try‑with‑resources không thể được sử dụng trong các hệ thống con nhúng vì nó yêu cầu java.lang.AutoCloseable trong runtime, và điều này không có sẵn cho đến Android API 19 (KitKat 4.4). Package java.nio.file không thể được sử dụng trong các hệ thống con nhúng vì nó không có sẵn cho đến Android API 26 (Oreo 8). Ngoài các hạn chế trên, các class, method và cấu trúc Java 8 chỉ có thể được sử dụng trong các hệ thống con sau: BOB, desktopgui, i2psnark, i2ptunnel.war (UI), jetty‑i2p.jar, jsonrpc, routerconsole (trừ news), SAM, susidns, susimail, systray. Tác giả plugin có thể yêu cầu bất kỳ phiên bản Java tối thiểu nào thông qua file plugin.config. Chuyển đổi rõ ràng giữa các kiểu nguyên thủy và class; đừng dựa vào autoboxing/unboxing. Đừng sử dụng URL. Hãy sử dụng URI. Đừng catch Exception. Hãy catch RuntimeException và các checked exception riêng lẻ. Đừng sử dụng String.getBytes() mà không có tham số charset UTF‑8. Bạn cũng có thể sử dụng DataHelper.getUTF8() hoặc DataHelper.getASCII(). Luôn chỉ định charset UTF‑8 khi đọc hoặc ghi file. Các tiện ích DataHelper có thể hữu ích. Luôn chỉ định một locale (ví dụ Locale.US) khi sử dụng String.toLowerCase() hoặc String.toUpperCase(). Không sử dụng String.equalsIgnoreCase(), vì không thể chỉ định locale. Đừng sử dụng String.split(). Hãy sử dụng DataHelper.split(). Đừng thêm code để định dạng ngày và giờ. Hãy sử dụng DataHelper.formatDate() và DataHelper.formatTime(). Đảm bảo rằng InputStream và OutputStream được đóng trong các khối finally. Sử dụng {} cho tất cả các khối for và while, ngay cả khi chỉ có một dòng. Nếu bạn sử dụng {} cho khối if, else hoặc if-else, hãy sử dụng nó cho tất cả các khối. Đặt } else { trên một dòng duy nhất. Chỉ định các field là final bất cứ khi nào có thể. Đừng lưu trữ I2PAppContext, RouterContext, Log, hoặc bất kỳ tham chiếu nào khác đến router hoặc các mục context trong các field static. Đừng khởi động thread trong constructor. Sử dụng I2PAppThread thay vì Thread. Ghi nhật ký Các hướng dẫn sau đây áp dụng cho router, ứng dụng web và tất cả các plugin.\nĐối với bất kỳ thông báo nào không được hiển thị ở mức log mặc định (WARN, INFO, và DEBUG), trừ khi thông báo là một chuỗi tĩnh (không nối chuỗi), luôn sử dụng log.shouldWarn(), log.shouldInfo(), hoặc log.shouldDebug() trước lệnh gọi log để tránh tạo ra các đối tượng không cần thiết. Thông báo log có thể được hiển thị ở mức log mặc định (ERROR, CRIT, và logAlways()) nên ngắn gọn, rõ ràng và dễ hiểu đối với người dùng không có chuyên môn kỹ thuật. Điều này bao gồm văn bản lý do exception có thể cũng được hiển thị. Cân nhắc dịch nếu lỗi có khả năng xảy ra (ví dụ: lỗi khi gửi biểu mẫu). Nếu không, việc dịch không bắt buộc, nhưng có thể hữu ích khi tìm kiếm và tái sử dụng chuỗi đã được gắn thẻ để dịch ở nơi khác. Thông báo log không được hiển thị ở mức log mặc định (WARN, INFO, và DEBUG) được dành cho nhà phát triển sử dụng, và không cần đáp ứng các yêu cầu trên. Tuy nhiên, thông báo WARN có sẵn trong tab log của Android, và có thể hỗ trợ người dùng khi gỡ lỗi vấn đề, vì vậy cũng cần cẩn thận với thông báo WARN. Thông báo log INFO và DEBUG nên được sử dụng một cách tiết kiệm, đặc biệt trong các đoạn code thực thi thường xuyên. Mặc dù hữu ích trong quá trình phát triển, hãy cân nhắc xóa chúng hoặc chuyển thành comment sau khi hoàn thành kiểm thử. Không log ra stdout hoặc stderr (wrapper log). Giấy phép Chỉ check in code mà bạn tự viết. Trước khi check in bất kỳ code hoặc file JAR thư viện nào từ nguồn khác, hãy giải trình lý do cần thiết, xác minh giấy phép tương thích, và xin phê duyệt từ release manager (người quản lý phát hành). Nếu bạn được phê duyệt để thêm code hoặc file JAR bên ngoài, và các file nhị phân có sẵn trong bất kỳ gói Debian hoặc Ubuntu nào, bạn phải triển khai các tùy chọn build và packaging để sử dụng gói bên ngoài thay thế. Danh sách các file cần sửa đổi: build.properties, build.xml, debian/control, debian/i2p-router.install, debian/i2p-router.links, debian/rules, sub-build.xml. Đối với bất kỳ hình ảnh nào được check in từ nguồn bên ngoài, bạn có trách nhiệm xác minh trước giấy phép có tương thích hay không. Bao gồm thông tin giấy phép và nguồn trong comment khi check in. Lỗi Quản lý các vấn đề là công việc của tất cả mọi người; vui lòng giúp đỡ. Theo dõi GitLab để tìm các vấn đề mà bạn có thể hỗ trợ. Bình luận, sửa chữa và đóng các vấn đề nếu bạn có thể. Các nhà phát triển mới nên bắt đầu bằng việc sửa các vấn đề. Khi bạn có bản sửa lỗi, đính kèm bản vá của bạn vào vấn đề và thêm từ khóa review-needed. Không đóng vấn đề cho đến khi nó đã được xem xét thành công và bạn đã kiểm tra các thay đổi của mình. Sau khi bạn đã thực hiện điều này suôn sẻ cho một vài ticket, bạn có thể tuân theo quy trình thông thường ở trên. Đóng một vấn đề khi bạn nghĩ rằng bạn đã sửa nó. Chúng tôi không có bộ phận kiểm thử để xác minh và đóng các ticket. Nếu bạn không chắc chắn rằng mình đã sửa nó, hãy đóng nó và thêm ghi chú \u0026ldquo;Tôi nghĩ rằng tôi đã sửa nó, vui lòng kiểm tra và mở lại nếu nó vẫn bị lỗi\u0026rdquo;. Thêm bình luận với số phiên bản dev build hoặc revision và đặt milestone cho bản phát hành tiếp theo. ","description":"Hướng dẫn toàn diện về đóng góp cho I2P: quy trình làm việc, chu kỳ phát hành, phong cách lập trình, ghi log, cấp phép và xử lý vấn đề","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"Hướng dẫn Phát triển và Phong cách Lập trình","url":"/vi/docs/develop/dev-guidelines/"},{"categories":null,"content":" Phạm vi: Hướng dẫn này tổng hợp cách triển khai tunnel, định dạng thông điệp, và cả hai đặc tả tạo tunnel (ECIES và ElGamal cũ). Các liên kết sâu hiện có vẫn hoạt động thông qua các bí danh ở trên.\nMô hình Tunnel I2P chuyển tiếp tải trọng dữ liệu qua tunnels một chiều: các tập hợp router có thứ tự, truyền lưu lượng theo một hướng duy nhất. Một vòng khứ hồi đầy đủ giữa hai điểm đích cần bốn tunnels (hai ra, hai vào).\nBắt đầu với Tổng quan về Tunnel để nắm thuật ngữ, sau đó dùng hướng dẫn này cho các chi tiết vận hành.\nVòng đời thông điệp Cổng tunnel gom nhóm một hoặc nhiều thông điệp I2NP, phân mảnh chúng, và ghi các chỉ dẫn chuyển phát. Cổng đóng gói tải trọng vào một thông điệp tunnel có kích thước cố định (1024 B), thêm đệm nếu cần. Mỗi nút tham gia xác minh hop (chặng) trước, áp dụng lớp mã hóa của mình, và chuyển tiếp {nextTunnelId, nextIV, encryptedPayload} đến hop tiếp theo. Điểm cuối tunnel gỡ bỏ lớp cuối cùng, xử lý các chỉ dẫn chuyển phát, lắp ráp lại các mảnh, và gửi đi các thông điệp I2NP đã được lắp ráp lại. Cơ chế phát hiện trùng lặp sử dụng một bộ lọc Bloom suy giảm theo thời gian, với giá trị lập chỉ mục là phép XOR giữa IV (vector khởi tạo) và khối mã hóa đầu tiên, nhằm ngăn chặn các cuộc tấn công gắn thẻ dựa trên việc hoán đổi IV.\nTổng quan nhanh về các vai trò Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally ### Quy trình mã hóa {#encryption-workflow} Inbound tunnels: gateway (cổng) mã hóa một lần bằng khóa lớp của nó; các thành viên phía sau tiếp tục mã hóa cho đến khi người tạo giải mã tải dữ liệu cuối cùng. Outbound tunnels: gateway (cổng) áp dụng trước nghịch đảo của mã hóa tại mỗi chặng để mỗi thành viên đều mã hóa. Khi endpoint (điểm cuối) mã hóa, bản rõ gốc của gateway (cổng) được khôi phục. Cả hai chiều chuyển tiếp {tunnelId, IV, encryptedPayload} đến chặng kế tiếp.\nĐịnh dạng thông điệp Tunnel Các gateway của tunnel phân mảnh các thông điệp I2NP thành các phong bì có kích thước cố định để che giấu độ dài phần tải và đơn giản hóa việc xử lý ở mỗi chặng (hop).\nBố cục được mã hóa +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – định danh 32-bit cho nút kế tiếp (khác 0, thay đổi luân phiên mỗi chu kỳ dựng). IV – IV (vector khởi tạo) AES 16 byte được chọn cho mỗi thông điệp. Payload được mã hóa – 1008 byte bản mã AES-256-CBC. Tổng kích thước: 1028 byte.\nBố cục đã giải mã Sau khi một hop (nút chuyển tiếp trong tuyến) loại bỏ lớp mã hóa của nó:\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... Checksum xác minh khối đã giải mã. Padding là các byte ngẫu nhiên khác 0 và kết thúc bằng một byte 0. Delivery instructions cho điểm cuối biết cách xử lý từng mảnh (giao nội bộ, chuyển tiếp tới một tunnel khác, v.v.). Fragments mang các thông điệp I2NP bên dưới; điểm cuối lắp ráp lại chúng trước khi chuyển chúng lên các lớp cao hơn. Các bước xử lý Các cổng phân mảnh và xếp hàng đợi các thông điệp I2NP, giữ tạm các mảnh chưa hoàn chỉnh trong thời gian ngắn để lắp ráp lại. Cổng mã hóa phần tải (payload) bằng các khóa tầng phù hợp và chèn Tunnel ID cùng IV. Mỗi thành viên tham gia mã hóa IV (AES-256/ECB) rồi đến phần tải (AES-256/CBC), sau đó mã hóa lại IV và chuyển tiếp thông điệp. Điểm cuối giải mã theo thứ tự ngược lại, xác minh checksum, xử lý các chỉ dẫn chuyển phát, và lắp ráp lại các mảnh. Tạo Tunnel (ECIES-X25519) Các router hiện đại xây dựng tunnels bằng các khóa ECIES-X25519, rút gọn các thông điệp dựng tunnel và cho phép tính bí mật chuyển tiếp.\nThông điệp dựng (Build message): một thông điệp I2NP TunnelBuild (hoặc VariableTunnelBuild) duy nhất mang 1–8 bản ghi dựng đã được mã hóa, mỗi bản ghi tương ứng một hop. Khóa lớp (Layer keys): bên khởi tạo suy ra các khóa lớp theo từng hop, IV, và khóa phản hồi thông qua HKDF, sử dụng danh tính X25519 tĩnh của hop và khóa tạm thời của bên khởi tạo. Xử lý (Processing): mỗi hop giải mã bản ghi của mình, xác thực các cờ yêu cầu, ghi khối phản hồi (thành công hoặc mã lỗi chi tiết), mã hóa lại các bản ghi còn lại, rồi chuyển tiếp thông điệp. Phản hồi (Replies): bên khởi tạo nhận một thông điệp phản hồi được bọc theo garlic encryption (mã hóa garlic). Các bản ghi được đánh dấu thất bại bao gồm một mã mức độ nghiêm trọng để router có thể lập hồ sơ đối tác. Tương thích (Compatibility): các router vẫn có thể chấp nhận kiểu dựng ElGamal cũ vì lý do tương thích ngược, nhưng các tunnel mới mặc định dùng ECIES. Đối với các hằng số theo từng trường và các ghi chú về dẫn xuất khóa, hãy xem lịch sử đề xuất ECIES (lược đồ mã hóa tích hợp trên đường cong elliptic) và mã nguồn router; hướng dẫn này trình bày luồng vận hành.\nTạo Tunnel kiểu cũ (ElGamal-2048) Định dạng xây dựng tunnel ban đầu đã sử dụng khóa công khai ElGamal. Các router hiện đại duy trì hỗ trợ hạn chế để đảm bảo khả năng tương thích ngược.\nTrạng thái: Đã lỗi thời. Được giữ lại ở đây để tham khảo như tư liệu lịch sử và cho bất kỳ ai đang duy trì các công cụ tương thích với hệ thống cũ (legacy).\nNon-interactive telescoping (mở rộng theo chuỗi không tương tác): một thông điệp xây dựng duy nhất đi qua toàn bộ đường đi. Mỗi hop (nút trung gian) giải mã bản ghi 528 byte của nó, cập nhật thông điệp, rồi chuyển tiếp nó. Độ dài biến thiên: Variable Tunnel Build Message (VTBM, thông điệp xây dựng tunnel có độ dài biến thiên) cho phép 1–8 bản ghi. Thông điệp cố định trước đó luôn chứa tám bản ghi để che giấu độ dài tunnel. Bố cục bản ghi yêu cầu: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding Cờ: bit 7 chỉ thị một inbound gateway (IBGW, cổng vào); bit 6 đánh dấu một outbound endpoint (OBEP, điểm ra). Chúng loại trừ lẫn nhau. Mã hóa: mỗi bản ghi được mã hóa ElGamal-2048 bằng khóa công khai của hop (nút trung gian). Phân lớp đối xứng AES-256-CBC đảm bảo chỉ hop đích có thể đọc bản ghi của mình. Các điểm chính: ID tunnel là các giá trị 32-bit khác 0; người tạo có thể chèn bản ghi giả để che giấu độ dài tunnel thực; độ tin cậy phụ thuộc vào việc thử lại các lần dựng thất bại. Các nhóm tunnel và vòng đời Các router duy trì các nhóm tunnel vào và ra độc lập cho lưu lượng thăm dò và cho từng phiên I2CP.\nChọn peer (nút ngang hàng): các tunnel thăm dò lấy từ nhóm peer “đang hoạt động, không lỗi” để khuyến khích đa dạng; các tunnel client ưu tiên các peer nhanh, dung lượng cao. Sắp xếp xác định: các peer được sắp xếp theo khoảng cách XOR giữa SHA256(peerHash || poolKey) và khóa ngẫu nhiên của nhóm. Khóa sẽ luân chuyển khi khởi động lại, mang lại sự ổn định trong một lần chạy, đồng thời gây khó cho các cuộc tấn công tiền nhiệm giữa các lần chạy. Vòng đời: routers theo dõi thời gian dựng lịch sử theo từng bộ {mode, direction, length, variance}. Khi các tunnel sắp hết hạn, việc thay thế bắt đầu sớm; router tăng số lượt dựng song song khi xảy ra lỗi, đồng thời giới hạn số lần thử đang mở. Các tham số cấu hình: số lượng tunnel active/backup, độ dài hop (bước nhảy mạng) và độ lệch, cho phép zero-hop, và giới hạn tốc độ dựng đều có thể tinh chỉnh theo từng nhóm. Tắc nghẽn và độ tin cậy Mặc dù tunnels giống các mạch, routers coi chúng như các hàng đợi thông điệp. Weighted Random Early Discard (WRED) (cơ chế loại bỏ sớm ngẫu nhiên có trọng số) được dùng để giữ độ trễ trong giới hạn:\nXác suất loại bỏ tăng khi mức sử dụng tiến gần các giới hạn đã cấu hình. Các thành phần tham gia xem xét các mảnh có kích thước cố định; gateway/endpoint (cổng/điểm cuối) loại bỏ dựa trên tổng kích thước các mảnh, ưu tiên loại bỏ các payload (dữ liệu tải) lớn trước. Các endpoint gửi đi sẽ loại bỏ trước các vai trò khác để lãng phí ít tài nguyên mạng nhất. Chức năng đảm bảo chuyển phát được dành cho các tầng cao hơn, chẳng hạn như Streaming library (thư viện Streaming). Các ứng dụng yêu cầu độ tin cậy phải tự xử lý việc truyền lại và xác nhận.\nTài liệu đọc thêm Lựa chọn peer (nút ngang hàng) Tổng quan về tunnel Triển khai tunnel cũ ","description":"Đặc tả hợp nhất cho việc xây dựng, mã hóa và truyền tải lưu lượng qua I2P tunnels.","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"Hướng dẫn vận hành Tunnel","url":"/vi/docs/specs/implementation/"},{"categories":null,"content":"Mục đích: Đảm bảo tính nhất quán, độ chính xác và khả năng truy cập trong toàn bộ tài liệu kỹ thuật I2P\nCác nguyên tắc cốt lõi 1. Xác minh mọi thứ Không bao giờ giả định hay đoán mò. Mọi phát biểu kỹ thuật phải được xác minh đối chiếu với: - Mã nguồn I2P hiện tại (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master ) - Tài liệu API chính thức (https://i2p.github.io/i2p.i2p/ - Đặc tả cấu hình /docs/specs/ - Ghi chú phát hành gần đây /releases/ Ví dụ về việc xác minh đúng cách:\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. Ưu tiên rõ ràng hơn ngắn gọn Hãy viết cho đối tượng là các nhà phát triển có thể lần đầu tiên tiếp xúc với I2P. Giải thích đầy đủ các khái niệm thay vì giả định người đọc đã có sẵn kiến thức.\nVí dụ:\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. Ưu tiên khả năng tiếp cận Tài liệu phải có thể được truy cập bởi các nhà phát triển trên clearnet (internet thông thường), mặc dù I2P là một network overlay (lớp phủ mạng). Luôn cung cấp các lựa chọn thay thế có thể truy cập từ clearnet cho các tài nguyên nội bộ của I2P.\nĐộ chính xác kỹ thuật Tài liệu về API và giao diện Luôn bao gồm: 1. Tên gói đầy đủ ở lần đề cập đầu tiên: net.i2p.app.ClientApp 2. Chữ ký phương thức đầy đủ, kèm kiểu trả về 3. Tên và kiểu của tham số 4. Các tham số bắt buộc và tùy chọn\nVí dụ:\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. Các thuộc tính cấu hình Khi viết tài liệu cho các tệp cấu hình: 1. Hiển thị chính xác tên thuộc tính 2. Chỉ định mã hóa tệp (UTF-8 cho cấu hình I2P) 3. Cung cấp các ví dụ đầy đủ 4. Ghi rõ giá trị mặc định 5. Ghi chú phiên bản khi các thuộc tính được giới thiệu/thay đổi\nVí dụ:\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) Hằng số và Kiểu liệt kê Khi viết tài liệu cho các hằng số, hãy dùng chính tên định danh trong mã:\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; Phân biệt giữa các khái niệm tương tự I2P có nhiều hệ thống chồng chéo. Luôn nêu rõ bạn đang viết tài liệu cho hệ thống nào:\nVí dụ:\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations Các URL tài liệu và tài liệu tham khảo Các quy tắc về khả năng truy cập URL Tham chiếu chính nên sử dụng URL có thể truy cập trên clearnet (mạng Internet công khai) URL nội bộ I2P (.i2p domains) phải kèm ghi chú về khả năng truy cập Luôn cung cấp phương án thay thế khi liên kết đến tài nguyên nội bộ I2P Mẫu cho các URL nội bộ của I2P:\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ Các URL tham khảo I2P được khuyến nghị Đặc tả chính thức: - Cấu hình - Plugin - Mục lục tài liệu Tài liệu API (chọn phiên bản mới nhất): - Mới nhất: https://i2p.github.io/i2p.i2p/ (API 0.9.66 tính đến I2P 2.10.0) - Bản sao trên Clearnet (mạng Internet công khai): https://eyedeekay.github.io/javadoc-i2p/ Mã nguồn: - GitLab (chính thức): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master - GitHub mirror (bản sao): https://github.com/i2p/i2p.i2p Tiêu chuẩn định dạng liên kết ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text Theo dõi phiên bản Siêu dữ liệu tài liệu Mỗi tài liệu kỹ thuật nên bao gồm siêu dữ liệu phiên bản trong frontmatter (phần mở đầu):\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Định nghĩa các trường: - lastUpdated: Năm-tháng khi tài liệu được rà soát/cập nhật lần cuối - accurateFor: Phiên bản I2P mà tài liệu đã được xác minh đối chiếu - reviewStatus: Một trong \u0026ldquo;draft\u0026rdquo;, \u0026ldquo;needs-review\u0026rdquo;, \u0026ldquo;verified\u0026rdquo;, \u0026ldquo;outdated\u0026rdquo;\nTham chiếu phiên bản trong nội dung Khi đề cập đến phiên bản: 1. Dùng in đậm cho phiên bản hiện tại: \u0026ldquo;version 2.10.0 (September 2025)\u0026rdquo; 2. Ghi cả số phiên bản và ngày phát hành khi nhắc tới các phiên bản trước đây 3. Ghi phiên bản API riêng, tách biệt với phiên bản I2P khi phù hợp\nVí dụ:\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. Tài liệu hóa các thay đổi theo thời gian Đối với các tính năng đã phát triển:\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients Thông báo ngừng sử dụng Nếu viết tài liệu về các tính năng không còn được khuyến nghị sử dụng (deprecated):\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. Tiêu chuẩn thuật ngữ Các thuật ngữ I2P chính thức Sử dụng các thuật ngữ chính xác này một cách nhất quán:\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address ### Thuật ngữ máy khách được quản lý Khi viết tài liệu về các máy khách được quản lý:\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory ### Thuật ngữ cấu hình Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config ### Tên gói và lớp Luôn sử dụng tên đầy đủ khi nhắc đến lần đầu, sau đó dùng tên ngắn:\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... Ví dụ về mã và định dạng Ví dụ mã Java Sử dụng tô sáng cú pháp đúng chuẩn và các ví dụ đầy đủ:\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` Yêu cầu cho ví dụ mã: 1. Bao gồm chú thích giải thích các dòng quan trọng 2. Hiển thị xử lý lỗi khi phù hợp 3. Sử dụng tên biến thực tế 4. Tuân theo quy ước viết mã của I2P (thụt lề 4 dấu cách) 5. Hiển thị các câu lệnh import nếu không rõ ràng từ ngữ cảnh\nVí dụ cấu hình Hiển thị các ví dụ cấu hình đầy đủ, hợp lệ:\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` Các ví dụ dòng lệnh Dùng $ cho lệnh của người dùng, # cho lệnh của root:\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` Mã trong dòng Sử dụng dấu backtick cho: - Tên phương thức: startup() - Tên lớp: ClientApp - Tên thuộc tính: clientApp.0.main - Tên tệp: clients.config - Hằng số: SVC_HTTP_PROXY - Tên gói: net.i2p.app\nGiọng điệu và giọng văn Chuyên nghiệp nhưng dễ tiếp cận Hãy viết cho độc giả có nền tảng kỹ thuật mà không tỏ ra trịch thượng:\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; Thể chủ động Hãy dùng giọng chủ động để tăng tính rõ ràng:\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; Thể mệnh lệnh trong hướng dẫn Hãy dùng câu mệnh lệnh trực tiếp trong nội dung hướng dẫn thao tác:\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; Tránh sử dụng biệt ngữ không cần thiết Giải thích thuật ngữ khi lần đầu tiên xuất hiện:\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) Hướng dẫn về dấu câu Không dùng gạch ngang dài (em-dash) - dùng dấu gạch ngang thông thường, dấu phẩy, hoặc dấu chấm phẩy Dùng dấu phẩy Oxford (Oxford comma) trong danh sách: \u0026ldquo;console, i2ptunnel, và Jetty\u0026rdquo; Dấu chấm bên trong khối mã chỉ dùng khi cần thiết về ngữ pháp Danh sách liệt kê nối tiếp dùng dấu chấm phẩy khi các mục có dấu phẩy Cấu trúc tài liệu Thứ tự các phần tiêu chuẩn Về tài liệu API:\nTổng quan - tính năng làm gì, vì sao nó tồn tại Triển khai - cách triển khai/sử dụng Cấu hình - cách cấu hình Tham chiếu API - mô tả chi tiết phương thức/thuộc tính Ví dụ - ví dụ hoàn chỉnh chạy được Thực tiễn tốt nhất - mẹo và khuyến nghị Lịch sử phiên bản - thời điểm giới thiệu, các thay đổi theo thời gian Tài liệu tham khảo - liên kết tới tài liệu liên quan Thứ bậc tiêu đề Sử dụng các cấp độ tiêu đề theo ngữ nghĩa:\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** Các hộp thông tin Sử dụng blockquotes (khối trích dẫn) cho các lưu ý đặc biệt:\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. Danh sách và tổ chức Danh sách không thứ tự cho các mục không theo trình tự:\n- First item - Second item - Third item Danh sách có thứ tự cho các bước tuần tự:\n1. First step 2. Second step 3. Third step Danh sách định nghĩa dùng để giải thích thuật ngữ:\n**Term One** : Explanation of term one **Term Two** : Explanation of term two Những lỗi thường gặp cần tránh 1. Nhầm lẫn giữa các hệ thống tương tự Đừng nhầm lẫn: - bảng đăng ký của ClientAppManager so với PortMapper - các loại tunnel của i2ptunnel so với các hằng số của dịch vụ PortMapper - ClientApp so với RouterApp (ngữ cảnh khác nhau) - client được quản lý so với client không được quản lý\nLuôn làm rõ hệ thống nào bạn đang thảo luận:\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. Các tham chiếu phiên bản lỗi thời Không nên: - Gọi các phiên bản cũ là \u0026ldquo;hiện tại\u0026rdquo; - Liên kết đến tài liệu API đã lỗi thời - Sử dụng chữ ký phương thức deprecated (không còn được khuyến nghị sử dụng) trong các ví dụ\nNên làm: - Kiểm tra ghi chú phát hành trước khi phát hành - Xác minh tài liệu API phù hợp với phiên bản hiện tại - Cập nhật các ví dụ để sử dụng các thực tiễn tốt nhất hiện nay\n3. URL không thể truy cập Đừng: - Chỉ liên kết đến các tên miền .i2p mà không có lựa chọn thay thế trên clearnet (mạng Internet công khai) - Sử dụng URL tài liệu bị hỏng hoặc đã lỗi thời - Liên kết đến file:// paths cục bộ\nNên làm: - Cung cấp các lựa chọn thay thế trên clearnet (mạng công khai) cho tất cả các liên kết nội bộ I2P - Kiểm tra URL có thể truy cập được trước khi xuất bản - Sử dụng các URL ổn định (geti2p.net, không phải dịch vụ lưu trữ tạm thời)\n4. Ví dụ mã chưa đầy đủ Đừng: - Hiển thị các đoạn trích không có ngữ cảnh - Bỏ qua xử lý lỗi - Sử dụng biến chưa được định nghĩa - Bỏ qua các câu lệnh import khi không rõ ràng\nNên làm: - Đưa ra các ví dụ hoàn chỉnh, có thể biên dịch - Bao gồm xử lý lỗi cần thiết - Giải thích chức năng của từng dòng quan trọng - Kiểm thử các ví dụ trước khi xuất bản\n5. Các tuyên bố mơ hồ ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; Quy ước Markdown Đặt tên tệp Sử dụng kebab-case (kiểu đặt tên dùng dấu gạch nối) cho tên tệp: - managed-clients.md - port-mapper-guide.md - configuration-reference.md\nĐịnh dạng Frontmatter (phần siêu dữ liệu ở đầu tài liệu) Luôn bao gồm YAML frontmatter (phần siêu dữ liệu ở đầu tài liệu bằng YAML):\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Định dạng liên kết Liên kết nội bộ (trong tài liệu):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) Liên kết ngoài (đến các tài nguyên khác):\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) Liên kết kho mã nguồn:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) Định dạng bảng Sử dụng các bảng Markdown kiểu GitHub:\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | Thẻ ngôn ngữ của khối mã Luôn chỉ định ngôn ngữ để tô sáng cú pháp:\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` Danh sách kiểm tra rà soát Trước khi xuất bản tài liệu, hãy xác minh:\nTất cả các tuyên bố kỹ thuật được kiểm chứng đối chiếu với mã nguồn hoặc tài liệu chính thức Số phiên bản và ngày tháng được cập nhật Tất cả URL có thể truy cập từ clearnet (Internet công khai) (hoặc đã cung cấp phương án thay thế) Ví dụ mã hoàn chỉnh và đã được kiểm thử Thuật ngữ tuân theo quy ước của I2P Không dùng dấu gạch ngang dài; dùng gạch ngang thông thường hoặc dấu câu khác Frontmatter (phần đầu tài liệu) đầy đủ và chính xác Thứ bậc tiêu đề mang tính ngữ nghĩa (h1 → h2 → h3) Danh sách và bảng được định dạng đúng Mục tài liệu tham khảo bao gồm tất cả các nguồn đã trích dẫn Tài liệu tuân theo các hướng dẫn về cấu trúc Giọng điệu chuyên nghiệp nhưng dễ tiếp cận Các khái niệm tương tự được phân biệt rõ ràng Không có liên kết hoặc tham chiếu bị hỏng Ví dụ cấu hình hợp lệ và cập nhật Phản hồi: Nếu bạn phát hiện vấn đề hoặc có đề xuất cho các hướng dẫn này, vui lòng gửi chúng qua các kênh phát triển chính thức của I2P.\n","description":"Duy trì tính nhất quán, độ chính xác và tính dễ tiếp cận trong toàn bộ tài liệu kỹ thuật của I2P","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"Hướng dẫn viết tài liệu I2P","url":"/vi/docs/writing-guidelines/"},{"categories":null,"content":"Giới thiệu I2P cung cấp dịch vụ nhắn tin riêng tư theo kiểu email thông qua dịch vụ Mail.i2p của Postman kết hợp với SusiMail, một ứng dụng webmail tích hợp sẵn. Hệ thống này cho phép người dùng gửi và nhận email cả trong mạng I2P lẫn từ/đến internet thông thường (clearnet) thông qua một cổng cầu nối.\nPostman / Mail.i2p + SusiMail What it is Mail.i2p là nhà cung cấp email được lưu trữ bên trong I2P, do \u0026ldquo;Postman\u0026rdquo; vận hành SusiMail là ứng dụng webmail được tích hợp trong bảng điều khiển router I2P. Nó được thiết kế để tránh làm lộ metadata (ví dụ: hostname) đến các máy chủ SMTP bên ngoài. Thông qua cấu hình này, người dùng I2P có thể gửi/nhận tin nhắn cả bên trong I2P và đến/từ clearnet (ví dụ: Gmail) thông qua cầu nối Postman. How Addressing Works I2P email sử dụng hệ thống địa chỉ kép:\nTrong mạng I2P: username@mail.i2p (ví dụ: idk@mail.i2p) Từ clearnet: username@i2pmail.org (ví dụ: idk@i2pmail.org) Gateway i2pmail.org cho phép người dùng internet thông thường gửi email đến các địa chỉ I2P, và người dùng I2P gửi đến các địa chỉ clearnet. Email từ internet được định tuyến qua gateway trước khi được chuyển tiếp qua I2P đến hộp thư SusiMail của bạn.\nHạn ngạch gửi Clearnet: 20 email mỗi ngày khi gửi đến các địa chỉ internet thông thường.\nNó là gì Để đăng ký tài khoản mail.i2p:\nĐảm bảo I2P router của bạn đang chạy Truy cập http://hq.postman.i2p bên trong I2P Làm theo quy trình đăng ký Truy cập email của bạn thông qua SusiMail trong router console Lưu ý: hq.postman.i2p là địa chỉ mạng I2P (eepsite) và chỉ có thể truy cập khi đã kết nối với I2P. Để biết thêm thông tin về cài đặt email, bảo mật và cách sử dụng, hãy truy cập Postman HQ.\nCách thức hoạt động của địa chỉ Tự động loại bỏ các header nhận dạng (User-Agent:, X-Mailer:) để bảo vệ quyền riêng tư Làm sạch metadata để ngăn chặn rò rỉ thông tin ra các máy chủ SMTP bên ngoài Mã hóa đầu-cuối (end-to-end encryption) cho email nội bộ I2P-to-I2P Bắt Đầu Khả năng tương tác với email \u0026ldquo;thông thường\u0026rdquo; (SMTP/POP) thông qua cầu nối Postman Trải nghiệm người dùng đơn giản (webmail tích hợp sẵn trong bảng điều khiển router) Tích hợp với bản phân phối I2P cốt lõi (SusiMail đi kèm với Java I2P) Loại bỏ header để bảo vệ quyền riêng tư Tính năng Bảo mật Cầu nối đến email bên ngoài yêu cầu tin tưởng vào cơ sở hạ tầng của Postman Cầu nối clearnet làm giảm tính riêng tư so với truyền thông I2P hoàn toàn nội bộ Phụ thuộc vào tính khả dụng và bảo mật của máy chủ thư Postman Technical Details Dịch vụ SMTP: localhost:7659 (được cung cấp bởi Postman) Dịch vụ POP3: localhost:7660 Truy cập Webmail: Được tích hợp sẵn trong bảng điều khiển router tại http://127.0.0.1:7657/susimail/\nQuan trọng: SusiMail chỉ dùng để đọc và gửi email. Việc tạo và quản lý tài khoản phải được thực hiện tại hq.postman.i2p.\nBest Practices Thay đổi mật khẩu sau khi đăng ký tài khoản mail.i2p của bạn Sử dụng email I2P-to-I2P bất cứ khi nào có thể để đạt được quyền riêng tư tối đa (không cần cầu nối clearnet) Lưu ý giới hạn 20 email/ngày khi gửi đến địa chỉ clearnet Hiểu rõ các đánh đổi: Cầu nối clearnet mang lại sự tiện lợi nhưng giảm tính ẩn danh so với giao tiếp hoàn toàn nội bộ I2P Giữ I2P được cập nhật để hưởng lợi từ các cải tiến bảo mật trong SusiMail Tôi sẵn sàng dịch, nhưng tôi không thấy văn bản nào cần dịch trong tin nhắn của bạn. Phần \u0026ldquo;Text to translate:\u0026rdquo; không có nội dung theo sau dấu \u0026ldquo;\u0026mdash;\u0026rdquo;.\nVui lòng cung cấp văn bản cần dịch và tôi sẽ thực hiện ngay lập tức mà không có bình luận hay giải thích thêm.\n","description":"Tổng quan về các hệ thống email trong mạng I2P — lịch sử, các lựa chọn và trạng thái hiện tại","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"I2P Mail (Email Ẩn danh trên I2P)","url":"/vi/docs/applications/i2p-mail/"},{"categories":null,"content":"Tổng quan Hiện nay có một số mạng lưới riêng tư và ẩn danh lớn, mỗi mạng có mục tiêu thiết kế và mô hình đe dọa khác nhau. Mặc dù Tor, Lokinet, GNUnet và Freenet đều đóng góp những cách tiếp cận có giá trị cho truyền thông bảo vệ quyền riêng tư, I2P nổi bật là mạng chuyển mạch gói duy nhất sẵn sàng cho sản xuất, được tối ưu hóa hoàn toàn cho các hidden service trong mạng và ứng dụng ngang hàng (peer-to-peer).\nBảng dưới đây tóm tắt các điểm khác biệt chính về kiến trúc và vận hành của các mạng này tính đến năm 2025.\nSo sánh Mạng lưới Bảo mật (2025) Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) --- Tại Sao I2P Dẫn Đầu Trong Thiết Kế Ưu Tiên Quyền Riêng Tư 1. Packet Switching \u0026gt; Circuit Switching Mô hình chuyển mạch kênh của Tor gắn lưu lượng vào các đường dẫn cố định ba bước nhảy—hiệu quả cho duyệt web, nhưng kém ổn định cho các dịch vụ nội bộ hoạt động lâu dài. Tunnel chuyển mạch gói của I2P gửi thông điệp qua nhiều đường dẫn đồng thời, tự động định tuyến vòng qua tắc nghẽn hoặc lỗi để có thời gian hoạt động tốt hơn và phân phối tải tốt hơn.\n2. Unidirectional Tunnels I2P tách biệt lưu lượng đi và đến. Điều này có nghĩa là mỗi nút tham gia chỉ nhìn thấy một nửa luồng giao tiếp, khiến các tấn công phân tích thời gian tương quan trở nên khó khăn hơn đáng kể. Tor, Lokinet và các mạng khác sử dụng mạch hai chiều trong đó yêu cầu và phản hồi dùng chung cùng một đường đi—đơn giản hơn nhưng dễ truy vết hơn.\n3. Fully Distributed netDB Chín directory authorities của Tor xác định cấu trúc mạng của nó. I2P sử dụng Kademlia DHT tự tổ chức được duy trì bởi các floodfill router luân phiên, loại bỏ mọi điểm kiểm soát tập trung hoặc máy chủ điều phối.\n1. Chuyển mạch gói \u0026gt; Chuyển mạch kênh I2P mở rộng onion routing bằng garlic routing, gộp nhiều thông điệp mã hóa vào một container. Điều này giảm rò rỉ metadata và chi phí băng thông đồng thời cải thiện hiệu suất cho các thông điệp xác nhận, dữ liệu và điều khiển.\n2. Tunnel một chiều Mọi router I2P đều định tuyến cho người khác. Không có nhà điều hành relay chuyên dụng hay các node đặc quyền—băng thông và độ tin cậy tự động quyết định mức độ định tuyến mà một node đóng góp. Cách tiếp cận dân chủ này xây dựng khả năng phục hồi và mở rộng tự nhiên khi mạng lưới phát triển.\n3. netDB Phân tán hoàn toàn Hành trình 12 bước khứ hồi của I2P (6 hướng vào + 6 hướng ra) tạo ra tính không thể liên kết mạnh mẽ hơn so với các mạch dịch vụ ẩn 6 bước của Tor. Bởi vì cả hai bên đều nằm trong mạng nội bộ, các kết nối tránh hoàn toàn nút thắt cổ chai tại exit, mang lại khả năng lưu trữ nội bộ nhanh hơn và tích hợp ứng dụng gốc (I2PSnark, I2PTunnel, I2PBote).\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication --- When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet --- Summary Kiến trúc của I2P ưu tiên quyền riêng tư ngay từ đầu—không có máy chủ thư mục tập trung, không phụ thuộc vào blockchain, không cần tin tưởng tập trung. Sự kết hợp giữa unidirectional tunnels (đường hầm một chiều), định tuyến chuyển mạch gói, garlic message bundling (đóng gói thông điệp dạng tỏi), và khám phá ngang hàng phân tán khiến I2P trở thành hệ thống tiên tiến nhất về mặt kỹ thuật cho việc lưu trữ ẩn danh và giao tiếp ngang hàng ngày nay.\nI2P không phải là \u0026ldquo;một phương án thay thế cho Tor.\u0026rdquo; Đây là một loại mạng khác—được xây dựng cho những gì xảy ra bên trong mạng riêng tư, chứ không phải bên ngoài nó.\n","description":"So sánh kỹ thuật và triết lý hiện đại làm nổi bật những ưu thế thiết kế độc đáo của I2P","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P so với các Mạng Riêng tư Khác","url":"/vi/docs/overview/comparison/"},{"categories":null,"content":"Giới thiệu I2P là một lớp mạng ẩn danh chuyển mạch gói có khả năng mở rộng, tự tổ chức và bền vững, trên đó có thể vận hành nhiều ứng dụng khác nhau quan tâm đến tính ẩn danh hoặc bảo mật. Mỗi ứng dụng này có thể đưa ra sự đánh đổi riêng giữa tính ẩn danh, độ trễ và thông lượng mà không cần lo lắng về việc triển khai đúng đắn của một free route mixnet, cho phép chúng hòa trộn hoạt động của mình với tập hợp lớn hơn các người dùng ẩn danh đã đang chạy trên I2P.\nCác ứng dụng hiện có cung cấp đầy đủ các hoạt động Internet thông thường — duyệt web ẩn danh, lưu trữ web, trò chuyện, chia sẻ tệp, email, blog và phân phối nội dung, cùng với một số ứng dụng khác đang được phát triển.\nDuyệt web: sử dụng bất kỳ trình duyệt nào hỗ trợ proxy Trò chuyện: IRC và các giao thức khác Chia sẻ tệp: I2PSnark và các ứng dụng khác E-mail: Susimail và các ứng dụng khác Blog: sử dụng bất kỳ máy chủ web cục bộ nào, hoặc các plugin có sẵn Không giống như các trang web được lưu trữ trong các mạng phân phối nội dung như Freenet hay GNUnet , các dịch vụ được lưu trữ trên I2P có khả năng tương tác đầy đủ — có các công cụ tìm kiếm theo phong cách web truyền thống, diễn đàn, blog mà bạn có thể bình luận, các trang web dựa trên cơ sở dữ liệu, và các cầu nối để truy vấn các hệ thống tĩnh như Freenet mà không cần cài đặt chúng trên máy cục bộ.\nVới tất cả các ứng dụng hỗ trợ ẩn danh này, I2P hoạt động như middleware hướng thông điệp — các ứng dụng chỉ định dữ liệu cần gửi đến một định danh mật mã (một \u0026ldquo;destination\u0026rdquo;), và I2P đảm bảo nó đến nơi một cách an toàn và ẩn danh. I2P cũng bao gồm một thư viện streaming đơn giản để cho phép các thông điệp best-effort ẩn danh của I2P truyền tải như các luồng đáng tin cậy, theo thứ tự, cung cấp kiểm soát tắc nghẽn dựa trên TCP được điều chỉnh cho tích số băng thông-độ trễ cao của mạng.\nMặc dù các SOCKS proxy đơn giản đã được phát triển để kết nối các ứng dụng hiện có, giá trị của chúng bị hạn chế vì hầu hết các ứng dụng đều làm rò rỉ thông tin nhạy cảm trong ngữ cảnh ẩn danh. Cách tiếp cận an toàn nhất là kiểm toán và điều chỉnh ứng dụng để sử dụng trực tiếp các API của I2P.\nI2P không phải là một dự án nghiên cứu — học thuật, thương mại hay chính phủ — mà là một nỗ lực kỹ thuật nhằm cung cấp tính ẩn danh có thể sử dụng được. Dự án đã được phát triển liên tục từ đầu năm 2003 bởi một nhóm cộng tác viên phân tán trên toàn thế giới. Tất cả các công trình I2P đều là mã nguồn mở trên trang web chính thức , chủ yếu được phát hành vào phạm vi công cộng, với một số thành phần sử dụng giấy phép BSD-style linh hoạt. Một số ứng dụng khách có giấy phép GPL cũng có sẵn, chẳng hạn như I2PTunnel , Susimail , và I2PSnark . Nguồn tài trợ hoàn toàn đến từ các khoản đóng góp của người dùng.\nVận hành Overview I2P phân biệt rõ ràng giữa router (các nút tham gia vào mạng lưới) và destination (các điểm cuối ẩn danh cho ứng dụng). Việc chạy I2P tự nó không phải là bí mật; điều được ẩn giấu là những gì người dùng đang làm và router nào mà các destination của họ sử dụng. Người dùng cuối thường chạy nhiều destination (ví dụ: một cho duyệt web, một cho hosting, một cho IRC).\nMột khái niệm quan trọng trong I2P là tunnel — một đường dẫn mã hóa một chiều đi qua một chuỗi các router. Mỗi router chỉ giải mã một lớp và chỉ biết điểm chuyển tiếp tiếp theo. Các tunnel hết hạn sau mỗi 10 phút và phải được xây dựng lại.\nHình 1: Tồn tại hai loại tunnel — inbound (đến) và outbound (đi).\nTunnel gửi đi (Outbound tunnels) gửi tin nhắn ra khỏi người tạo. Tunnel nhận về (Inbound tunnels) mang tin nhắn trở lại cho người tạo. Kết hợp các tunnel này cho phép giao tiếp hai chiều. Ví dụ, \u0026ldquo;Alice\u0026rdquo; sử dụng một outbound tunnel để gửi tới inbound tunnel của \u0026ldquo;Bob\u0026rdquo;. Alice mã hóa tin nhắn của mình kèm theo hướng dẫn định tuyến tới inbound gateway của Bob.\nMột khái niệm quan trọng khác là network database hoặc netDb, cơ sở dữ liệu phân tán các siêu dữ liệu về router và điểm đến:\nRouterInfo: Chứa thông tin liên lạc và khóa mật mã của router. LeaseSet: Chứa thông tin cần thiết để liên lạc với một đích đến (các cổng tunnel, thời gian hết hạn, khóa mã hóa). Các router công bố RouterInfo của chúng trực tiếp lên netDb; các LeaseSet được gửi qua các tunnel đi ra để đảm bảo tính ẩn danh.\nĐể xây dựng tunnel, Alice truy vấn netDb để lấy các mục RouterInfo nhằm chọn peer, và gửi các thông điệp xây dựng tunnel được mã hóa qua từng hop cho đến khi tunnel hoàn thành.\nHình 2: Thông tin router được sử dụng để xây dựng các tunnel.\nĐể gửi dữ liệu đến Bob, Alice tra cứu LeaseSet của Bob và sử dụng một trong các tunnel đi của mình để định tuyến dữ liệu qua cổng vào của tunnel đến của Bob.\nHình 3: LeaseSets kết nối các tunnel đi và tunnel đến.\nBởi vì I2P dựa trên thông điệp, nó bổ sung mã hóa garlic đầu-cuối để bảo vệ thông điệp ngay cả khỏi điểm cuối đi ra hoặc cổng vào. Một thông điệp garlic bao gồm nhiều \u0026ldquo;clove\u0026rdquo; (thông điệp) được mã hóa để che giấu metadata và cải thiện tính ẩn danh.\nCác ứng dụng có thể sử dụng trực tiếp giao diện tin nhắn hoặc dựa vào thư viện streaming để có kết nối đáng tin cậy.\nTunnels Cả tunnel đến và tunnel đi đều sử dụng mã hóa nhiều lớp, nhưng khác nhau về cấu trúc:\nTrong inbound tunnels, người tạo (endpoint) giải mã tất cả các lớp. Trong outbound tunnels, người tạo (gateway) giải mã trước các lớp để đảm bảo rõ ràng tại endpoint. I2P phân tích hồ sơ của các peer thông qua các chỉ số gián tiếp như độ trễ và độ tin cậy mà không cần thăm dò trực tiếp. Dựa trên các hồ sơ này, các peer được nhóm động vào bốn cấp độ:\nNhanh và dung lượng cao Dung lượng cao Không lỗi Đang lỗi Việc lựa chọn peer cho tunnel thường ưu tiên các peer có băng thông cao, được chọn ngẫu nhiên để cân bằng giữa tính ẩn danh và hiệu suất, với các chiến lược sắp xếp bổ sung dựa trên XOR để giảm thiểu các cuộc tấn công predecessor và thu thập netDb.\nĐể biết thêm chi tiết, xem Thông số kỹ thuật Tunnel .\nTổng quan Các router tham gia vào bảng băm phân tán (DHT) floodfill lưu trữ và phản hồi các truy vấn LeaseSet. DHT sử dụng một biến thể của Kademlia . Các router floodfill được chọn tự động nếu chúng có đủ năng lực và tính ổn định, hoặc có thể được cấu hình thủ công.\nRouterInfo: Mô tả khả năng và các phương thức truyền tải của router. LeaseSet: Mô tả các tunnel và khóa mã hóa của đích đến. Tất cả dữ liệu trong netDb đều được ký bởi người xuất bản và đánh dấu thời gian để ngăn chặn các cuộc tấn công phát lại hoặc sử dụng mục tin cũ. Đồng bộ hóa thời gian được duy trì thông qua SNTP và phát hiện độ lệch tại tầng vận chuyển.\nAdditional concepts LeaseSet không công khai và được mã hóa:\nMột destination có thể duy trì tính riêng tư bằng cách không công khai LeaseSet của mình, chỉ chia sẻ với các peer đáng tin cậy. Việc truy cập yêu cầu khóa giải mã phù hợp.\nBootstrapping (reseeding):\nĐể tham gia mạng lưới, một router mới tải các tệp RouterInfo đã ký từ các máy chủ reseed HTTPS đáng tin cậy.\nKhả năng mở rộng tra cứu:\nI2P sử dụng tra cứu lặp (iterative), không phải đệ quy (recursive), để cải thiện khả năng mở rộng và bảo mật của DHT.\nTunnels Giao tiếp I2P hiện đại sử dụng hai phương thức truyền tải được mã hóa hoàn toàn:\nNTCP2 : Giao thức mã hóa dựa trên TCP SSU2 : Giao thức mã hóa dựa trên UDP Cả hai đều được xây dựng trên Noise Protocol Framework hiện đại, cung cấp xác thực mạnh mẽ và khả năng chống nhận dạng lưu lượng. Chúng đã thay thế các giao thức NTCP và SSU cũ (đã ngừng hoàn toàn từ năm 2023).\nNTCP2 cung cấp truyền tải dữ liệu được mã hóa, hiệu quả qua TCP.\nSSU2 cung cấp độ tin cậy dựa trên UDP, khả năng vượt qua NAT và tùy chọn xuyên thủng lỗ (hole punching). SSU2 về mặt khái niệm tương tự như WireGuard hoặc QUIC, cân bằng giữa độ tin cậy và tính ẩn danh.\nRouter có thể hỗ trợ cả IPv4 và IPv6, công bố địa chỉ vận chuyển và chi phí của chúng trong netDb. Phương thức vận chuyển của một kết nối được chọn động thông qua hệ thống đấu thầu tối ưu hóa cho các điều kiện và liên kết hiện có.\nCơ sở dữ liệu mạng (netDb) I2P sử dụng mật mã phân lớp cho tất cả các thành phần: giao vận, tunnel, garlic messages và network database.\nCác nguyên hàm hiện tại bao gồm:\nX25519 cho trao đổi khóa EdDSA (Ed25519) cho chữ ký số ChaCha20-Poly1305 cho mã hóa xác thực SHA-256 cho băm AES256 cho mã hóa lớp tunnel Các thuật toán cũ (ElGamal, DSA-SHA1, ECDSA) vẫn được giữ lại để tương thích ngược.\nI2P hiện đang giới thiệu các sơ đồ mật mã lai hậu lượng tử (PQ) kết hợp X25519 với ML-KEM để chống lại các cuộc tấn công \u0026ldquo;thu thập ngay, giải mã sau\u0026rdquo;.\nGarlic Messages Garlic messages mở rộng onion routing bằng cách nhóm nhiều \u0026ldquo;cloves\u0026rdquo; được mã hóa với các chỉ dẫn gửi độc lập. Điều này cho phép tính linh hoạt trong định tuyến ở cấp độ thông điệp và đồng nhất hóa lưu lượng.\nSession Tags Hai hệ thống mã hóa được hỗ trợ cho mã hóa đầu-cuối:\nElGamal/AES+SessionTags (cũ):\nSử dụng session tags được gửi trước như nonce 32-byte. Hiện đã không được khuyến nghị do kém hiệu quả.\nECIES-X25519-AEAD-Ratchet (hiện tại):\nSử dụng ChaCha20-Poly1305 và PRNG dựa trên HKDF được đồng bộ hóa để tạo các khóa phiên tạm thời và thẻ 8-byte một cách động, giảm thiểu chi phí CPU, bộ nhớ và băng thông trong khi vẫn duy trì tính bảo mật chuyển tiếp.\nFuture of the Protocol Các lĩnh vực nghiên cứu chính tập trung vào việc duy trì bảo mật chống lại các đối thủ cấp quốc gia và giới thiệu các biện pháp bảo vệ hậu lượng tử. Hai khái niệm thiết kế ban đầu — restricted routes và variable latency — đã được thay thế bởi các phát triển hiện đại.\nRestricted Route Operation Các khái niệm định tuyến hạn chế ban đầu nhằm mục đích che giấu địa chỉ IP. Nhu cầu này đã phần lớn được giảm thiểu bởi:\nUPnP cho chuyển tiếp cổng tự động Vượt qua NAT mạnh mẽ trong SSU2 Hỗ trợ IPv6 Introducers (người giới thiệu) hợp tác và NAT hole-punching (kỹ thuật xuyên thủng NAT) Kết nối overlay (lớp phủ) tùy chọn (ví dụ: Yggdrasil) Do đó, I2P hiện đại đạt được các mục tiêu tương tự một cách thực tế hơn mà không cần định tuyến hạn chế phức tạp.\nSimilar Systems I2P tích hợp các khái niệm từ middleware hướng thông điệp (message-oriented middleware), DHT (bảng băm phân tán), và mixnet (mạng trộn lẫn). Sự đổi mới của nó nằm ở việc kết hợp những thành phần này thành một nền tảng ẩn danh tự tổ chức và có thể sử dụng được.\nCác Giao Thức Truyền Tải Trang web Tor và I2P có chung mục tiêu nhưng khác nhau về kiến trúc:\nTor: Chuyển mạch theo mạch; phụ thuộc vào các directory authorities đáng tin cậy. (~10k relay) I2P: Chuyển mạch theo gói; mạng lưới phân tán hoàn toàn dựa trên DHT. (~50k router) Các tunnel đơn hướng của I2P để lộ ít metadata hơn và cho phép các đường định tuyến linh hoạt, trong khi Tor tập trung vào truy cập Internet ẩn danh (outproxying - định tuyến ra ngoài). Ngược lại, I2P hỗ trợ lưu trữ ẩn danh trong mạng.\nMật mã học Trang web Freenet tập trung vào việc công bố và truy xuất tệp tin ẩn danh, lâu dài. I2P, ngược lại, cung cấp một lớp truyền thông thời gian thực cho việc sử dụng tương tác (web, chat, torrents). Kết hợp với nhau, hai hệ thống này bổ sung cho nhau — Freenet cung cấp khả năng lưu trữ chống kiểm duyệt; I2P cung cấp tính ẩn danh trong vận chuyển.\nOther Networks Lokinet: Mạng phủ dựa trên IP sử dụng các node dịch vụ được khuyến khích. Nym: Mixnet thế hệ tiếp theo nhấn mạnh bảo vệ siêu dữ liệu với lưu lượng che giấu ở độ trễ cao hơn. Appendix A: Application Layer Bản thân I2P chỉ xử lý việc truyền tải thông điệp. Chức năng tầng ứng dụng được triển khai bên ngoài thông qua các API và thư viện.\nStreaming Library Thư viện streaming hoạt động như bản tương tự TCP của I2P, với giao thức cửa sổ trượt và kiểm soát tắc nghẽn được tinh chỉnh cho truyền tải ẩn danh có độ trễ cao.\nCác mẫu yêu cầu/phản hồi HTTP điển hình thường có thể hoàn thành trong một lượt truyền dữ liệu duy nhất nhờ vào tối ưu hóa gộp thông điệp.\nNaming Library and Address Book Phát triển bởi: mihi, Ragnarok Xem trang Danh pháp và Sổ địa chỉ .\nHệ thống đặt tên của I2P là cục bộ và phi tập trung, tránh việc sử dụng tên toàn cục theo kiểu DNS. Mỗi router duy trì một bảng ánh xạ cục bộ từ các tên dễ đọc sang các địa chỉ đích (destination). Các sổ địa chỉ tùy chọn dựa trên mạng lưới tin cậy có thể được chia sẻ hoặc nhập từ các nút đồng cấp đáng tin cậy.\nCách tiếp cận này tránh được các cơ quan tập trung và vượt qua các lỗ hổng Sybil vốn có trong các hệ thống đặt tên toàn cầu hoặc theo kiểu bỏ phiếu.\nHoạt động Tuyến đường Hạn chế Phát triển bởi: mihi\nI2PTunnel là giao diện lớp client chính cho phép proxy TCP ẩn danh. Nó hỗ trợ:\nClient tunnels (đường hầm ra ngoài đến các điểm đích I2P) HTTP client (eepproxy) cho tên miền \u0026ldquo;.i2p\u0026rdquo; Server tunnels (đường hầm vào từ I2P đến dịch vụ cục bộ) HTTP server tunnels (proxy an toàn cho các dịch vụ web) Outproxying (ra Internet thông thường) là tùy chọn, được thực hiện bởi các tunnel \u0026ldquo;máy chủ\u0026rdquo; do tình nguyện viên vận hành.\nI2PSnark Phát triển bởi: jrandom, et al — chuyển đổi từ Snark Được tích hợp sẵn với I2P, I2PSnark là một BitTorrent client đa torrent ẩn danh với hỗ trợ DHT và UDP, có thể truy cập qua giao diện web.\nTor Phát triển bởi: postman, susi23, mastiejaner\nI2Pmail cung cấp email ẩn danh thông qua các kết nối I2PTunnel. Susimail là một ứng dụng email dựa trên web được xây dựng đặc biệt để ngăn chặn rò rỉ thông tin thường gặp trong các ứng dụng email truyền thống. Dịch vụ mail.i2p có tính năng lọc virus, hạn ngạch hashcash , và tách biệt outproxy để bảo vệ bổ sung.\n","description":"Giới thiệu kỹ thuật về kiến trúc và hoạt động của I2P","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P: Một framework có khả năng mở rộng cho truyền thông ẩn danh","url":"/vi/docs/overview/tech-intro/"},{"categories":null,"content":"Tài liệu API I2PControl I2PControl là một API JSON-RPC 2.0 được tích hợp sẵn trong I2P router (từ phiên bản 0.9.39). Nó cho phép giám sát và điều khiển router một cách xác thực thông qua các yêu cầu JSON có cấu trúc.\nMật khẩu mặc định: itoopie — đây là mật khẩu gốc từ nhà sản xuất và nên được thay đổi ngay lập tức để đảm bảo bảo mật.\n1. Tổng quan \u0026amp; Truy cập Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior Trong trường hợp Java I2P, bạn phải truy cập **Router Console → WebApps → I2PControl** và bật nó (đặt để khởi động tự động). Sau khi hoạt động, tất cả các phương thức yêu cầu bạn phải xác thực trước và nhận mã phiên (session token). 2. Định dạng JSON-RPC Tất cả các yêu cầu tuân theo cấu trúc JSON-RPC 2.0:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } Một phản hồi thành công bao gồm trường result; nếu thất bại, một đối tượng error sẽ được trả về:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } hoặc\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. Luồng Xác thực Yêu cầu (Xác thực) curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Phản hồi thành công { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } Bạn phải bao gồm Token đó trong tất cả các yêu cầu tiếp theo trong params.\n4. Phương thức \u0026amp; Điểm cuối 4.1 RouterInfo Lấy dữ liệu telemetry chính về router.\nVí dụ Request\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Các Trường Phản Hồi (result) Theo tài liệu chính thức (GetI2P): - i2p.router.status (String) — trạng thái dạng văn bản dễ đọc - i2p.router.uptime (long) — mili giây (hoặc chuỗi cho i2pd cũ hơn) :contentReference[oaicite:0]{index=0} - i2p.router.version (String) — chuỗi phiên bản :contentReference[oaicite:1]{index=1} - i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — băng thông đầu vào tính bằng B/s :contentReference[oaicite:2]{index=2} - i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — băng thông đầu ra tính bằng B/s :contentReference[oaicite:3]{index=3} - i2p.router.net.status (long) — mã trạng thái dạng số (xem enum bên dưới) :contentReference[oaicite:4]{index=4} - i2p.router.net.tunnels.participating (long) — số lượng tunnel tham gia :contentReference[oaicite:5]{index=5} - i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — thống kê peer trong netDB :contentReference[oaicite:6]{index=6} - i2p.router.netdb.isreseeding (boolean) — liệu có đang reseed hay không :contentReference[oaicite:7]{index=7} - i2p.router.netdb.knownpeers (long) — tổng số peer đã biết :contentReference[oaicite:8]{index=8}\nEnum Mã Trạng Thái (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET --- 4.2 GetRate Được sử dụng để lấy các chỉ số tốc độ (ví dụ: băng thông, tỷ lệ thành công của tunnel) trong một khoảng thời gian nhất định.\nVí dụ Yêu cầu\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Phản hồi mẫu\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 RouterManager Thực hiện các hành động quản trị.\nTham số / phương thức được phép - Restart, RestartGraceful - Shutdown, ShutdownGraceful - Reseed, FindUpdates, Update :contentReference[oaicite:10]{index=10}\nVí dụ Yêu cầu\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Phản hồi thành công\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 Cài Đặt Mạng Lấy hoặc đặt các tham số cấu hình mạng (cổng, upnp, chia sẻ băng thông, v.v.)\nVí dụ Yêu cầu (lấy giá trị hiện tại)\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Phản hồi mẫu\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } Lưu ý: các phiên bản i2pd trước 2.41 có thể trả về kiểu số thay vì chuỗi — client nên xử lý cả hai trường hợp. :contentReference[oaicite:11]{index=11}\n4.5 Cài đặt Nâng cao Cho phép điều chỉnh các tham số nội bộ của router.\nVí dụ Request\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Ví dụ Phản hồi\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. Mã Lỗi Ngoài các lỗi JSON-RPC chuẩn (-32700, -32600, v.v.), I2PControl định nghĩa thêm:\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported --- 6. Cách sử dụng \u0026amp; Thực hành tốt nhất Luôn bao gồm tham số Token (trừ khi đang xác thực). Thay đổi mật khẩu mặc định (itoopie) khi sử dụng lần đầu. Đối với Java I2P, đảm bảo I2PControl webapp được bật thông qua WebApps. Chuẩn bị cho những biến đổi nhỏ: một số trường có thể là số hoặc chuỗi, tùy thuộc vào phiên bản I2P. Ngắt dòng các chuỗi trạng thái dài để hiển thị thân thiện hơn. ","description":"API quản lý router từ xa thông qua webapp I2PControl","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/vi/docs/api/i2pcontrol/"},{"categories":null,"content":"Tổng quan I2PTunnel là một thành phần cốt lõi của I2P dùng để giao tiếp và cung cấp dịch vụ trên mạng I2P. Nó cho phép các ứng dụng dựa trên TCP và phát trực tuyến phương tiện hoạt động ẩn danh thông qua trừu tượng hóa tunnel. Điểm đến của tunnel có thể được xác định bằng hostname , Base32 , hoặc một destination key đầy đủ.\nMỗi tunnel đã thiết lập sẽ lắng nghe cục bộ (ví dụ: localhost:port) và kết nối nội bộ đến các điểm đến I2P. Để lưu trữ một dịch vụ, hãy tạo một tunnel trỏ đến IP và cổng mong muốn. Một khóa đích I2P tương ứng sẽ được tạo ra, cho phép dịch vụ có thể truy cập toàn cầu trong mạng I2P. Giao diện web I2PTunnel có sẵn tại I2P Router Tunnel Manager .\nDịch vụ Mặc định Tunnel máy chủ I2P Webserver – Một tunnel tới máy chủ web Jetty tại localhost:7658 để dễ dàng lưu trữ trên I2P. Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot Tunnel client I2P HTTP Proxy – localhost:4444 – Dùng để duyệt web I2P và Internet thông qua outproxies (proxy đầu ra). I2P HTTPS Proxy – localhost:4445 – Phiên bản bảo mật của HTTP proxy. Irc2P – localhost:6668 – Tunnel mạng IRC ẩn danh mặc định. Git SSH (gitssh.idk.i2p) – localhost:7670 – Client tunnel cho truy cập SSH kho lưu trữ. Postman SMTP – localhost:7659 – Client tunnel cho thư đi. Postman POP3 – localhost:7660 – Client tunnel cho thư đến. Lưu ý: Chỉ có I2P Webserver là server tunnel mặc định; tất cả các tunnel khác đều là client tunnel kết nối đến các dịch vụ I2P bên ngoài.\nCấu hình Đặc tả cấu hình I2PTunnel được ghi chép tại /spec/configuration .\nChế độ Client Tiêu chuẩn Mở một cổng TCP cục bộ kết nối đến một dịch vụ trên một destination I2P. Hỗ trợ nhiều destination được phân tách bằng dấu phẩy để đảm bảo dự phòng.\nHTTP Một tunnel proxy cho các yêu cầu HTTP/HTTPS. Hỗ trợ outproxy cục bộ và từ xa, loại bỏ header, bộ nhớ đệm, xác thực và nén trong suốt.\nBảo vệ riêng tư: - Loại bỏ các header: Accept-*, Referer, Via, From - Thay thế host header bằng các địa chỉ đích Base32 - Thực thi việc loại bỏ hop-by-hop tuân thủ RFC - Thêm hỗ trợ giải nén trong suốt - Cung cấp các trang lỗi nội bộ và phản hồi đã được bản địa hóa\nHành vi nén: - Các yêu cầu có thể sử dụng header tùy chỉnh X-Accept-Encoding: x-i2p-gzip - Các phản hồi với Content-Encoding: x-i2p-gzip được giải nén một cách minh bạch - Việc nén được đánh giá dựa trên loại MIME và độ dài phản hồi để tối ưu hiệu suất\nTính bền vững (mới từ phiên bản 2.5.0): HTTP Keepalive và kết nối bền vững hiện đã được hỗ trợ cho các dịch vụ lưu trữ trên I2P thông qua Hidden Services Manager. Điều này giảm độ trễ và chi phí kết nối nhưng chưa cho phép socket bền vững tuân thủ đầy đủ RFC 2616 trên tất cả các hop.\nPipelining: Vẫn không được hỗ trợ và không cần thiết; các trình duyệt hiện đại đã loại bỏ tính năng này.\nHành vi User-Agent: - Outproxy: Sử dụng User-Agent Firefox ESR hiện tại. - Internal: MYOB/6.66 (AN/ON) để duy trì tính nhất quán về ẩn danh.\nỨng dụng IRC Kết nối tới các máy chủ IRC dựa trên I2P. Cho phép một tập hợp con các lệnh an toàn trong khi lọc các định danh để bảo vệ quyền riêng tư.\nSOCKS 4/4a/5 Cung cấp khả năng proxy SOCKS cho các kết nối TCP. UDP vẫn chưa được triển khai trong Java I2P (chỉ có trong i2pd).\nCONNECT Triển khai tạo tunnel HTTP CONNECT cho các kết nối SSL/TLS.\nStreamr Cho phép truyền tải dạng UDP thông qua đóng gói dựa trên TCP. Hỗ trợ truyền tải media khi kết hợp với tunnel máy chủ Streamr tương ứng.\nChế độ Máy chủ Máy chủ Tiêu chuẩn Tạo một destination TCP được ánh xạ tới một địa chỉ IP:cổng cục bộ.\nMáy chủ HTTP Tạo một destination kết nối với máy chủ web cục bộ. Hỗ trợ nén (x-i2p-gzip), loại bỏ header và bảo vệ chống DDoS. Hiện được hưởng lợi từ hỗ trợ kết nối liên tục (v2.5.0+) và tối ưu hóa thread pooling (v2.7.0–2.9.0).\nHTTP Hai chiều Không còn được khuyến nghị – Vẫn hoạt động nhưng không được khuyến khích sử dụng. Hoạt động như cả HTTP server và client mà không có outproxying. Chủ yếu được sử dụng cho các bài kiểm tra loopback chẩn đoán.\nMáy chủ IRC Tạo một đích đã lọc cho các dịch vụ IRC, truyền khóa đích của client dưới dạng tên máy chủ.\nMáy chủ Streamr Kết hợp với tunnel client Streamr để xử lý các luồng dữ liệu kiểu UDP qua I2P.\nTính năng mới (2.4.0–2.10.0) Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. --- Tính năng Bảo mật Loại bỏ header để đảm bảo ẩn danh (Accept, Referer, From, Via) Ngẫu nhiên hóa User-Agent tùy thuộc vào in/outproxy Giới hạn tốc độ POST và bảo vệ Slowloris Điều tiết kết nối trong hệ thống con streaming Xử lý tắc nghẽn mạng ở lớp tunnel Cô lập NetDB ngăn chặn rò rỉ thông tin giữa các ứng dụng Chi tiết Kỹ thuật Kích thước khóa đích mặc định: 516 bytes (có thể vượt quá đối với chứng chỉ LS2 mở rộng) Địa chỉ Base32: {52–56+ ký tự}.b32.i2p Server tunnel vẫn tương thích với cả Java I2P và i2pd Tính năng không được khuyến nghị: chỉ httpbidirserver; không có gì bị loại bỏ kể từ 0.9.59 Đã xác minh cổng mặc định và thư mục gốc tài liệu chính xác cho tất cả các nền tảng Tóm tắt I2PTunnel vẫn là xương sống cho việc tích hợp ứng dụng với I2P. Từ phiên bản 0.9.59 đến 2.10.0, nó đã có thêm hỗ trợ kết nối liên tục, mã hóa post-quantum và cải tiến lớn về luồng xử lý. Hầu hết các cấu hình vẫn tương thích, nhưng các nhà phát triển nên kiểm tra thiết lập của mình để đảm bảo tuân thủ các mặc định về truyền tải và bảo mật hiện đại.\n","description":"Công cụ để giao tiếp với và cung cấp dịch vụ trên I2P","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/vi/docs/api/i2ptunnel/"},{"categories":null,"content":"Tổng quan Những điểm chính\nI2P cung cấp mã hóa đầu cuối đến đầu cuối (end-to-end encryption) cho lưu lượng IRC thông qua các tunnel của nó. Tắt SSL/TLS trong các IRC client trừ khi bạn đang outproxy ra clearnet. Tunnel client Irc2P được cấu hình sẵn lắng nghe trên 127.0.0.1:6668 theo mặc định. Kết nối IRC client của bạn đến địa chỉ và cổng đó. Không sử dụng thuật ngữ \u0026ldquo;router‑provided TLS.\u0026rdquo; Sử dụng \u0026ldquo;mã hóa gốc của I2P (I2P\u0026rsquo;s native encryption)\u0026rdquo; hoặc \u0026ldquo;mã hóa đầu cuối đến đầu cuối (end‑to‑end encryption).\u0026rdquo; Bắt đầu nhanh (Java I2P) Mở Hidden Services Manager tại http://127.0.0.1:7657/i2ptunnel/ và đảm bảo tunnel Irc2P đang chạy. Trong IRC client của bạn, đặt server = 127.0.0.1, port = 6668, SSL/TLS = off. Kết nối và tham gia các kênh như #i2p, #i2p-dev, #i2p-help. Đối với người dùng i2pd (router C++), tạo một client tunnel trong tunnels.conf (xem các ví dụ bên dưới).\nMạng và máy chủ IRC2P (main community network) Các máy chủ liên hợp: irc.postman.i2p:6667, irc.echelon.i2p:6667, irc.dg.i2p:6667. Tunnel Irc2P tại 127.0.0.1:6668 kết nối tự động đến một trong các máy chủ này. Các kênh thông dụng: #i2p, #i2p-chat, #i2p-dev, #i2p-help. Ilita network Máy chủ: irc.ilita.i2p:6667, irc.r4sas.i2p:6667, irc.acetone.i2p:6667, rusirc.ilita.i2p:6667. Ngôn ngữ chính: Tiếng Nga và Tiếng Anh. Giao diện web có sẵn trên một số máy chủ. Client setup Recommended, actively maintained WeeChat (terminal) — hỗ trợ SOCKS mạnh mẽ; dễ dàng viết script. Pidgin (desktop) — vẫn được bảo trì; hoạt động tốt trên Windows/Linux. Thunderbird Chat (desktop) — được hỗ trợ trong ESR 128+. The Lounge (self‑hosted web) — client web hiện đại. IRC2P (mạng cộng đồng chính) LimeChat (miễn phí, mã nguồn mở). Textual (trả phí trên App Store; mã nguồn có sẵn để build). Mạng Ilita WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin Giao thức: IRC Máy chủ: 127.0.0.1 Cổng: 6668 Mã hóa: tắt Tên người dùng/nick: bất kỳ Thunderbird Chat Loại tài khoản: IRC Server: 127.0.0.1 Cổng: 6668 SSL/TLS: tắt Tùy chọn: tự động tham gia kênh khi kết nối Dispatch (SAM v3) Ví dụ mặc định cho config.toml:\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults Tunnel client Irc2P: 127.0.0.1:6668 → máy chủ upstream trên cổng 6667. Trình quản lý Hidden Services: http://127.0.0.1:7657/i2ptunnel/. Được khuyến nghị, đang được bảo trì tích cực ~/.i2pd/tunnels.conf:\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat Tunnel riêng cho Ilita (ví dụ):\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat Tùy chọn macOS Bật SAM trong Java I2P (mặc định tắt) tại /configclients hoặc clients.config. Mặc định: 127.0.0.1:7656/TCP và 127.0.0.1:7655/UDP. Khuyến nghị mã hóa: SIGNATURE_TYPE=7 (Ed25519) và i2cp.leaseSetEncType=4,0 (ECIES‑X25519 với dự phòng ElGamal) hoặc chỉ 4 cho phiên bản hiện đại. Các cấu hình mẫu Java I2P mặc định: 2 đường hầm vào / 2 đường hầm ra. i2pd mặc định: 5 đường hầm vào / 5 đường hầm ra. Đối với IRC: 2–3 mỗi loại là đủ; thiết lập rõ ràng để đảm bảo hành vi nhất quán giữa các router. Thiết lập client Không bật SSL/TLS cho các kết nối IRC nội bộ I2P. I2P đã cung cấp mã hóa đầu cuối đến đầu cuối. TLS bổ sung chỉ tạo thêm chi phí mà không tăng tính ẩn danh. Sử dụng khóa cố định (persistent keys) để duy trì danh tính ổn định; tránh tạo lại khóa sau mỗi lần khởi động lại trừ khi đang thử nghiệm. Nếu nhiều ứng dụng sử dụng IRC, nên dùng tunnel riêng biệt (non‑shared) để giảm tương quan giữa các dịch vụ. Nếu bắt buộc phải cho phép điều khiển từ xa (SAM/I2CP), chỉ bind vào localhost và bảo mật truy cập bằng SSH tunnel hoặc reverse proxy có xác thực. Alternative connection method: SOCKS5 Một số client có thể kết nối qua SOCKS5 proxy của I2P: 127.0.0.1:4447. Để đạt kết quả tốt nhất, nên ưu tiên sử dụng tunnel IRC chuyên dụng trên cổng 6668; SOCKS không thể làm sạch các định danh ở tầng ứng dụng và có thể làm lộ thông tin nếu client không được thiết kế cho tính ẩn danh.\nTroubleshooting Không thể kết nối — đảm bảo tunnel Irc2P đang chạy và router đã hoàn tất quá trình bootstrap. Treo ở bước resolve/join — kiểm tra kỹ SSL đã được tắt và client trỏ đến 127.0.0.1:6668. Độ trễ cao — I2P có độ trễ cao hơn theo thiết kế. Giữ số lượng tunnel ở mức vừa phải (2–3) và tránh vòng lặp kết nối lại liên tục. Sử dụng ứng dụng SAM — xác nhận SAM đã được bật (Java) hoặc không bị chặn bởi firewall (i2pd). Nên sử dụng session dài hạn. Appendix: Ports and naming Các cổng tunnel IRC thông dụng: 6668 (mặc định của Irc2P), 6667 và 6669 làm cổng thay thế. Hostname .b32.i2p: dạng chuẩn 52 ký tự; dạng mở rộng 56+ ký tự tồn tại cho LS2/chứng chỉ nâng cao. Sử dụng hostname .i2p trừ khi bạn cần rõ ràng địa chỉ b32. ","description":"Hướng dẫn toàn diện về mạng IRC trên I2P, client, tunnel và cài đặt server (cập nhật 2025)","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"IRC qua I2P","url":"/vi/docs/applications/irc/"},{"categories":null,"content":"Liên hệ Bảo mật Để báo cáo các lỗ hổng bảo mật hoặc các vấn đề bảo mật nhạy cảm, vui lòng liên hệ với Nhóm Bảo mật I2P tại security@i2p.net Để liên lạc an toàn, vui lòng sử dụng khóa PGP của chúng tôi bên dưới.\nThông tin Khóa PGP Email: security@i2p.net Key ID: 176E1941 Fingerprint: 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 Loại Key: RSA 4096-bit Được tạo: 2025-10-19 Hết hạn: 2030-11-19 UID: I2P Security \u0026lt;security@i2p.net\u0026gt; Khóa công khai Sau đây là khóa công khai GPG của Nhóm Bảo mật I2P: \u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nmQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"Khóa công khai GPG để liên hệ với Nhóm Bảo mật I2P","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"Khóa GPG Bảo mật","url":"/vi/docs/develop/security-key/"},{"categories":null,"content":" Các phiên bản từ 0.9.57 trở đi được ký bởi idk. Khóa công khai hiện tại của anh ấy là: Tải xuống khóa công khai PGP Các phiên bản 0.7.6 và 0.9.56 được ký bởi zzz. Khóa công khai hiện tại của anh ấy là: Tải xuống khóa công khai PGP -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 Tôi đã tạo khóa GPG và khóa phụ mới và đã ký các khóa mới bằng khóa cũ.\nKhóa cũ:\npub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) \u0026lt;zzz@mail.i2p\u0026gt; sub 2048g/74C8122D 2005-12-16 Khóa mới:\npub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) \u0026lt;zzz@mail.i2p\u0026gt; uid zzz on i2p (key signing) \u0026lt;zzz@i2pmail.org\u0026gt; sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07] Tôi sẽ sử dụng các khóa mới như sau:\nEE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing Khóa ký phát hành sẽ được sử dụng bắt đầu từ phiên bản 0.9.13. Thông điệp này được ký bằng khóa cũ của tôi.\nzzz Ngày 25 tháng 5, 2014\nCác khóa mới như sau:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.14 (GNU/Linux)\nmQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dpXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHp\niEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; Các bản phát hành từ 0.9.9 có thể được ký bởi str4d. Khóa công khai hiện tại của anh ấy là: -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 Các khóa công khai hiện tại của tôi như sau:\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [hết hạn: 2019-03-10] uid [ đầy đủ ] str4d (http://str4d.i 2p) str4d@mail.i2p uid [ đầy đủ ] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [đã hết hạn: 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [đã hết hạn: 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [hết hạn: 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [hết hạn: 2016-04-04]\nHiện tại tôi sử dụng các khóa như sau:\nA94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing Tôi tạo các subkey mã hóa và ký mới hàng năm. Mọi bản phát hành I2P được tôi ký sẽ luôn được ký bằng subkey ký mới nhất tại thời điểm phát hành.\nstr4d Nov 20, 2015\nCác khóa hiện tại (tính đến ngày nêu trên) như sau:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z\niQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d đã ký các bản phát hành sau: 0.9.23 Các phiên bản từ 0.7.6 đến 0.9.12 được ký bởi zzz với khóa sau: -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enop IDx6enpAbWFpbC5pMnA+iF8EExECAB8FAkOjTnUCGwMGCwkIBwMCBBUCCAMDFgIB Ah4BAheAAAoJEEFVdrqnbgvtxGsAn39SvQ3+ey87WDDG+TWArN6oU8gnAJ4zeAsA LUK37WZIt8OImZSxk37uQbkCDQRDo06VEAgAy2UeqsM5a+U6ZOWS9NQiILb3KbTL FeeAd2rn9oLSLpn5gDWycwUS0Q62JmbSMWy6m9aczpnxvwaBYXz6aCIvZmTNtaU6 vyR/6wfJDyiUWSHtCyjpyFFYJimANd8Y8dDCimvceI/ihEDVyBX0kkgUGRAn8t3e unaLXqhbfiLiFw/GG1MNxUMzHt55/+9AqLOfRZg0riZvDoV79K+1sYSs8n1WeaVc T3wTb+Cb7fKNN7GT1MUhcXIoYYY6FGwsy5EWFsxYBRervqHtBJog2SoNUa/6BFGr zX+LDjK9L3xMTr3+fHIt4gPR/Lt4nnfEzL+rjClz/Fazmv38BRwPuKahFwADBQgA nD/AvZCnbWSB6khAVMqva5ROaD0gV0/UejCelZdYfgfHeCmrcMNQ+wCyww2NPsih 9vB1w+AUE0pdH37k65VZN+2falUdzN+PFugJGuH2pmlVOprH2SuC5gKpGRvzUqV5 U0nJmT2okDpW/52asUDJJLu1g//A3qBP83WGvSKUZg/ZisZA0qTiHH4QpjklopXi sSxR2hT8Fr9gF9WmDa09wbxE2xh/EL7gvVg/vk0gwOJcsFd67bNC+KUMOnjhOP0T K0/Ah4TEEs/hHNe9RsyyWlMoIUsF8AhG71ISOrJ5lLSXNe151XEb5FzZRM8sD9Zq 0E3PjmLbdVhanYvsPnWK6YhJBBgRAgAJBQJDo06VAhsMAAoJEEFVdrqnbgvtXTwA njMu9ueCFbsjme7nwsz96PdazJcHAKCce17hGI25QNXDZyHohrjha6IxDg== =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nCác phiên bản 0.6.1.31 đến 0.7.5 được ký bởi Complication. Khóa công khai của anh ấy là: \u0026mdash;\u0026ndash;BEGIN PGP SIGNED MESSAGE\u0026mdash;\u0026ndash; Hash: SHA1\nXin chào,\nTôi xác nhận rằng dưới đây là khóa công khai mới của tôi, được cấp vào ngày 24-11-2007, có hiệu lực đến ngày 23-11-2009, và dấu vân tay khóa của nó là:\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\nNếu bạn có khóa công khai cũ của tôi và sử dụng nó để xác minh điều này, bạn sẽ nhận thấy rằng khóa cũ của tôi đã hết hạn vào ngày 15-11-2007. Xin lỗi vì đã chậm trễ trong việc cập nhật này.\nĐối với những người muốn sao chép khóa trực tiếp từ thông điệp này nhưng không đọc bằng chương trình email, vui lòng nhớ xóa các chuỗi thoát \u0026ldquo;- \u0026quot; ở đầu và cuối đánh dấu của khối khóa công khai. Nếu không, nó sẽ không được nhận diện.\nBiến chứng.\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\nmQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK - \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\niD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"Các khóa PGP được sử dụng để ký các bản phát hành I2P và nơi lấy chúng","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"Khóa Ký Phát Hành","url":"/vi/docs/develop/release-signing-key/"},{"categories":null,"content":"Tổng quan Tài liệu này đặc tả quy trình làm mù, mã hóa và giải mã đối với LeaseSet2 (LS2) được mã hóa. LeaseSets được mã hóa cung cấp cơ chế công bố có kiểm soát truy cập đối với thông tin dịch vụ ẩn trong cơ sở dữ liệu mạng I2P.\nCác tính năng chính: - Luân chuyển khóa hằng ngày để đảm bảo bí mật chuyển tiếp - Ủy quyền phía khách hai tầng (dựa trên DH và dựa trên PSK) - Mã hóa ChaCha20 để có hiệu năng tốt trên thiết bị không có phần cứng AES - Chữ ký Red25519 cùng với kỹ thuật làm mù khóa - Tư cách thành viên phía khách bảo toàn quyền riêng tư\nTài liệu liên quan: - Đặc tả Cấu trúc Chung - Cấu trúc LeaseSet (tập hợp tham số truy cập các tunnel vào) được mã hóa - Đề xuất 123: Các mục netDB mới (cơ sở dữ liệu mạng của I2P) - Thông tin nền về các LeaseSet được mã hóa - Tài liệu về Cơ sở dữ liệu Mạng - Cách sử dụng NetDB\nLịch sử phiên bản và trạng thái triển khai Dòng thời gian phát triển giao thức Lưu ý quan trọng về đánh số phiên bản: I2P sử dụng hai hệ thống đánh số phiên bản riêng biệt: - Phiên bản API/Router: dòng 0.9.x (được dùng trong các đặc tả kỹ thuật) - Phiên bản phát hành sản phẩm: dòng 2.x.x (được dùng cho các bản phát hành công khai)\nCác đặc tả kỹ thuật tham chiếu phiên bản API (ví dụ: 0.9.41), trong khi người dùng cuối thấy các phiên bản sản phẩm (ví dụ: 2.10.0).\nCác mốc triển khai Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility ### Trạng thái hiện tại ✅ Trạng thái giao thức: Ổn định và không thay đổi kể từ tháng 6 năm 2019 ✅ Java I2P: Được triển khai đầy đủ trong phiên bản 0.9.40+ ✅ i2pd (C++): Được triển khai đầy đủ trong phiên bản 2.58.0+ ✅ Khả năng tương tác: Hoàn chỉnh giữa các hiện thực ✅ Triển khai mạng: Sẵn sàng cho môi trường sản xuất với hơn 6 năm kinh nghiệm vận hành Các định nghĩa mật mã học Ký hiệu và quy ước || biểu thị phép nối mod L biểu thị phép giảm theo mô-đun bởi cấp (order) của Ed25519 Tất cả các mảng byte ở thứ tự byte mạng (big-endian - byte cao trước) trừ khi có chỉ định khác Các giá trị little-endian (byte thấp trước) được ghi chú rõ ràng CSRNG(n) (bộ tạo số ngẫu nhiên an toàn mật mã) Bộ sinh số ngẫu nhiên an toàn mật mã\nTạo ra n byte dữ liệu ngẫu nhiên an toàn mật mã, phù hợp cho việc tạo key material (dữ liệu dùng để sinh khóa).\nYêu cầu bảo mật: - Phải đảm bảo an toàn mật mã (phù hợp cho việc tạo khóa) - Phải an toàn khi các chuỗi byte liền kề bị lộ trên mạng - Các triển khai nên băm đầu ra từ các nguồn có thể không đáng tin cậy\nTài liệu tham khảo: - Các cân nhắc bảo mật PRNG (bộ sinh số ngẫu nhiên giả) - Thảo luận của các nhà phát triển Tor H(p, d) Hàm băm SHA-256 với cá nhân hóa\nHàm băm phân tách miền nhận:\np: Chuỗi cá nhân hóa (cung cấp phân tách miền) d: Dữ liệu cần băm Triển khai:\nH(p, d) := SHA-256(p || d) Cách sử dụng: Cung cấp domain separation (phân tách miền) trong mật mã để ngăn chặn các tấn công va chạm giữa các cách sử dụng SHA-256 trong các giao thức khác nhau.\nLUỒNG: ChaCha20 Mật mã dòng: ChaCha20 như được đặc tả trong RFC 7539 Mục 2.4\nTham số: - S_KEY_LEN = 32 (khóa 256-bit) - S_IV_LEN = 12 (nonce 96-bit) - Bộ đếm ban đầu: 1 (RFC 7539 cho phép 0 hoặc 1; khuyến nghị dùng 1 trong các ngữ cảnh AEAD (mã hóa xác thực kèm dữ liệu liên kết))\nMÃ HÓA(k, iv, plaintext)\nMã hóa bản rõ bằng: - k: khóa mã hóa 32 byte - iv: nonce (giá trị chỉ dùng một lần) 12 byte (PHẢI là duy nhất cho mỗi khóa) - Trả về bản mã có cùng kích thước với bản rõ\nThuộc tính bảo mật: Toàn bộ bản mã phải không thể phân biệt được với dữ liệu ngẫu nhiên nếu khóa được giữ bí mật.\nDECRYPT(k, iv, ciphertext)\nGiải mã bản mã bằng: - k: khóa mã 32 byte - iv: nonce (giá trị chỉ dùng một lần) 12 byte - Trả về bản rõ\nCơ sở thiết kế: ChaCha20 được chọn thay vì AES vì: - Nhanh hơn AES 2.5-3x trên thiết bị không có tăng tốc phần cứng - Triển khai constant-time (thời gian hằng) dễ đạt được hơn - Bảo mật và tốc độ tương đương khi có AES-NI\nTài liệu tham khảo: - RFC 7539 - ChaCha20 và Poly1305 cho các giao thức IETF\nSIG (chữ ký): Red25519 Lược đồ chữ ký: Red25519 (SigType 11) với Key Blinding (làm mù khóa)\nRed25519 được xây dựng dựa trên các chữ ký Ed25519 trên đường cong Ed25519, sử dụng SHA-512 để băm, và hỗ trợ key blinding (kỹ thuật làm mù khóa) theo đặc tả trong ZCash RedDSA.\nHàm:\nDERIVE_PUBLIC(privkey) Trả về khóa công khai tương ứng với khóa riêng đã cho. - Sử dụng phép nhân vô hướng Ed25519 tiêu chuẩn với điểm cơ sở\nSIGN(privkey, m) Trả về chữ ký số được tạo bằng khóa riêng privkey cho thông điệp m.\nKhác biệt khi ký của Red25519 so với Ed25519: 1. Nonce (giá trị dùng một lần) ngẫu nhiên: Sử dụng 80 byte dữ liệu ngẫu nhiên bổ sung\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) Điều này khiến mỗi chữ ký Red25519 (một loại chữ ký số dùng trong I2P) là duy nhất, ngay cả khi áp dụng cho cùng một thông điệp và khóa.\nSinh khóa riêng: Các khóa riêng Red25519 (một biến thể của Ed25519) được sinh từ các số ngẫu nhiên và được giảm theo mod L, thay vì sử dụng phương pháp bit-clamping của Ed25519 (thuật toán chữ ký số dựa trên đường cong elliptic). VERIFY(pubkey, m, sig) Xác minh chữ ký sig đối chiếu với khóa công khai pubkey và thông điệp m. - Trả về true nếu chữ ký hợp lệ, false nếu không - Việc xác minh giống hệt Ed25519\nCác thao tác làm mù khóa:\nGENERATE_ALPHA(data, secret) Sinh alpha cho key blinding (kỹ thuật làm mù khóa). - data: Thường chứa khóa công khai dùng để ký và các loại chữ ký - secret: Bí mật bổ sung tùy chọn (độ dài bằng 0 nếu không dùng) - Kết quả có phân bố giống hệt như các khóa riêng Ed25519 (sau khi rút gọn modulo L)\nBLIND_PRIVKEY(privkey, alpha) Làm mù một khóa riêng bằng bí mật alpha. - Hiện thực: blinded_privkey = (privkey + alpha) mod L - Sử dụng số học vô hướng trên trường\nBLIND_PUBKEY(pubkey, alpha) Làm mù (blinding) một khóa công khai bằng bí mật alpha. - Cách triển khai: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) - Sử dụng phép cộng phần tử nhóm (điểm) trên đường cong\nTính chất then chốt:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) Các cân nhắc về bảo mật:\nTrích từ Đặc tả Giao thức Zcash, Mục 5.4.6.1: Vì mục đích bảo mật, alpha phải có phân phối giống hệt như các khóa riêng đã bỏ mù. Điều này đảm bảo rằng \u0026ldquo;sự kết hợp giữa một khóa công khai được tái ngẫu nhiên hóa và các chữ ký bằng khóa đó không tiết lộ khóa mà từ đó nó được tái ngẫu nhiên hóa.\u0026rdquo;\nCác loại chữ ký được hỗ trợ: - Loại 7 (Ed25519): Được hỗ trợ cho các destinations (đích trong I2P) hiện có (tương thích ngược) - Loại 11 (Red25519): Khuyến nghị cho các destinations mới sử dụng mã hóa - Blinded keys (khóa che mờ): Luôn sử dụng loại 11 (Red25519)\nTài liệu tham khảo: - Đặc tả Giao thức ZCash - Mục 5.4.6 RedDSA (thuật toán chữ ký số) - Đặc tả I2P Red25519 DH (trao đổi khóa Diffie–Hellman): X25519 Diffie-Hellman trên đường cong elliptic: X25519\nHệ thống thỏa thuận khóa công khai dựa trên Curve25519.\nTham số: - Khóa riêng: 32 byte - Khóa công khai: 32 byte - Đầu ra bí mật chung: 32 byte\nChức năng:\nGENERATE_PRIVATE() Tạo một khóa riêng 32 byte mới bằng cách sử dụng CSRNG (bộ sinh số ngẫu nhiên an toàn về mật mã).\nDERIVE_PUBLIC(privkey) Suy ra khóa công khai 32 byte từ khóa riêng đã cho. - Sử dụng phép nhân vô hướng trên Curve25519\nDH(privkey, pubkey) Thực hiện thỏa thuận khóa Diffie-Hellman. - privkey: Khóa riêng 32 byte cục bộ - pubkey: Khóa công khai 32 byte từ xa - Trả về: bí mật chung 32 byte\nThuộc tính bảo mật: - Giả định Diffie–Hellman tính toán trên Curve25519 - Bảo mật chuyển tiếp khi sử dụng khóa tạm thời - Yêu cầu triển khai thời gian hằng để ngăn chặn tấn công định thời\nTài liệu tham khảo: - RFC 7748 - Các đường cong elliptic cho bảo mật\nHKDF (hàm dẫn xuất khóa dựa trên HMAC) Hàm dẫn xuất khóa dựa trên HMAC\nTrích xuất và mở rộng vật liệu khóa từ vật liệu khóa đầu vào.\nTham số: - salt: tối đa 32 byte (thường là 32 byte cho SHA-256) - ikm: vật liệu khóa đầu vào (độ dài bất kỳ, nên có entropy (độ ngẫu nhiên) tốt) - info: thông tin theo ngữ cảnh (phân tách miền) - n: độ dài đầu ra tính theo byte\nHiện thực:\nSử dụng HKDF như được đặc tả trong RFC 5869 với: - Hàm băm: SHA-256 - HMAC: Như được đặc tả trong RFC 2104 - Độ dài muối: Tối đa 32 byte (HashLen đối với SHA-256)\nMẫu sử dụng:\nkeys = HKDF(salt, ikm, info, n) Domain Separation (phân tách miền): Tham số info cung cấp sự phân tách miền ở cấp mật mã giữa các lần sử dụng HKDF khác nhau trong giao thức.\nCác giá trị thông tin đã xác minh: - \u0026quot;ELS2_L1K\u0026quot; - mã hóa lớp 1 (bên ngoài) - \u0026quot;ELS2_L2K\u0026quot; - mã hóa lớp 2 (bên trong) - \u0026quot;ELS2_XCA\u0026quot; - ủy quyền máy khách DH (Diffie–Hellman) - \u0026quot;ELS2PSKA\u0026quot; - ủy quyền máy khách PSK (khóa chia sẻ trước) - \u0026quot;i2pblinding1\u0026quot; - tạo Alpha\nTài liệu tham khảo: - RFC 5869 - Đặc tả HKDF - RFC 2104 - Đặc tả HMAC\nĐặc tả định dạng LS2 được mã hóa bao gồm ba lớp lồng nhau:\nLớp 0 (Bên ngoài): Thông tin bản rõ để lưu trữ và truy xuất Lớp 1 (Ở giữa): Dữ liệu xác thực máy khách (được mã hóa) Lớp 2 (Bên trong): Dữ liệu LeaseSet2 thực (được mã hóa) Cấu trúc tổng thể:\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature Quan trọng: LS2 được mã hóa sử dụng blinded keys (khóa làm mù). Destination (đích I2P) không nằm trong header. Vị trí lưu trữ trên DHT (bảng băm phân tán) là SHA-256(sig type || blinded public key), được xoay vòng hàng ngày.\nLớp 0 (Ngoài) - Bản rõ Lớp 0 KHÔNG sử dụng tiêu đề LS2 tiêu chuẩn. Nó có một định dạng tùy chỉnh được tối ưu hóa cho blinded keys (khóa được làm mù).\nCấu trúc:\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data **Trường cờ (2 byte, bit 15-0):** - **Bit 0:** Chỉ báo khóa ngoại tuyến - `0` = Không có khóa ngoại tuyến - `1` = Có khóa ngoại tuyến (tiếp theo là dữ liệu khóa tạm thời) - **Các bit 1-15:** Dành riêng, phải bằng 0 để tương thích trong tương lai Dữ liệu khóa tạm thời (có mặt nếu bit cờ 0 = 1):\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key **Xác minh chữ ký:** - **Không có khóa ngoại tuyến:** Xác minh bằng khóa công khai bị làm mù (blinded) - **Có khóa ngoại tuyến:** Xác minh bằng khóa công khai tạm thời Chữ ký bao phủ tất cả dữ liệu từ Type đến outerCiphertext (bao gồm cả hai đầu).\nLớp 1 (Trung gian) - Ủy quyền máy khách Giải mã: Xem phần Mã hóa Tầng 1 .\nCấu trúc:\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) **Trường cờ (Flags) (1 byte, các bit 7-0):** - **Bit 0:** Chế độ ủy quyền - `0` = Không ủy quyền theo từng máy khách (mọi người) - `1` = Ủy quyền theo từng máy khách (phần auth theo sau) - **Bits 3-1:** Cơ chế xác thực (chỉ khi bit 0 = 1) - `000` = Xác thực máy khách DH (Diffie-Hellman) - `001` = Xác thực máy khách PSK (khóa chia sẻ trước) - Các giá trị khác: dành riêng - **Bits 7-4:** Không sử dụng, phải bằng 0 Dữ liệu ủy quyền máy khách DH (Diffie–Hellman) (cờ = 0x01, bit 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **Bản ghi authClient (40 byte):** - `clientID_i`: 8 byte - `clientCookie_i`: 32 byte (authCookie được mã hóa) Dữ liệu ủy quyền máy khách PSK (cờ = 0x03, các bit 3-1 = 001):\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **Mục nhập authClient (40 byte):** - `clientID_i`: 8 byte - `clientCookie_i`: 32 byte (authCookie được mã hóa) Lớp 2 (Bên trong) - Dữ liệu LeaseSet Giải mã: Xem phần Mã hóa Tầng 2 .\nCấu trúc:\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 Lớp bên trong chứa đầy đủ cấu trúc LeaseSet2, bao gồm: - tiêu đề LS2 - thông tin Lease (bản ghi tunnel) - chữ ký LS2 Yêu cầu xác minh: Sau khi giải mã, các triển khai phải xác minh: 1. Dấu thời gian bên trong khớp với dấu thời gian được công bố bên ngoài 2. Thời điểm hết hạn bên trong khớp với thời điểm hết hạn bên ngoài 3. LS2 signature (chữ ký LS2) hợp lệ 4. Dữ liệu Lease được định dạng đúng\nTham khảo: - Đặc tả Cấu trúc Chung - Chi tiết về định dạng LeaseSet2\nDẫn xuất khóa Blinding (làm mù) Tổng quan I2P sử dụng một lược đồ làm mù khóa dạng cộng dựa trên Ed25519 và ZCash RedDSA. Các khóa đã làm mù được xoay vòng hàng ngày (lúc nửa đêm UTC) nhằm đảm bảo bí mật chuyển tiếp.\nLý do thiết kế:\nI2P đã chọn một cách rõ ràng KHÔNG sử dụng cách tiếp cận trong Phụ lục A.2 của tài liệu rend-spec-v3.txt của Tor. Theo đặc tả:\n\u0026ldquo;Chúng tôi không sử dụng phụ lục A.2 của rend-spec-v3.txt của Tor, vốn có các mục tiêu thiết kế tương tự, vì các khóa công khai bị làm mù của nó có thể không thuộc nhóm con bậc nguyên tố, với những hệ quả về bảo mật chưa rõ.\u0026rdquo;\nCơ chế additive blinding (kỹ thuật làm mù cộng tính) của I2P đảm bảo rằng các khóa đã được làm mù vẫn nằm trong nhóm con bậc nguyên tố của đường cong Ed25519.\nCác định nghĩa toán học Tham số Ed25519: - B: điểm cơ sở (điểm sinh) Ed25519 = 2^255 - 19 - L: bậc Ed25519 = 2^252 + 27742317777372353535851937790883648493\nCác biến chính: - A: khóa công khai dùng để ký 32 byte không mù hóa (trong Destination) - a: khóa riêng dùng để ký 32 byte không mù hóa - A': khóa công khai dùng để ký 32 byte đã mù hóa (dùng trong LeaseSet được mã hóa) - a': khóa riêng dùng để ký 32 byte đã mù hóa - alpha: hệ số mù hóa 32 byte (bí mật)\nCác hàm trợ giúp:\nLEOS2IP(x) \u0026ldquo;Chuyển chuỗi Octet (chuỗi byte) little-endian (thứ tự byte thấp trước) thành số nguyên\u0026rdquo;\nChuyển đổi một mảng byte từ little-endian (thứ tự byte thấp trước) sang biểu diễn số nguyên.\nH*(x) \u0026ldquo;Băm và Rút gọn\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L Cùng phép toán như trong quá trình tạo khóa Ed25519 (chuẩn chữ ký số dựa trên đường cong Edwards 25519).\nThế hệ Alpha Xoay vòng hàng ngày: Một alpha mới và các blinded keys (khóa làm mù) mới PHẢI được tạo mỗi ngày vào lúc nửa đêm UTC (00:00:00 UTC).\nThuật toán GENERATE_ALPHA(destination, date, secret):\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L Các tham số đã được xác minh: - Cá nhân hóa (personalization) của salt: \u0026quot;I2PGenerateAlpha\u0026quot; - Tham số info của HKDF: \u0026quot;i2pblinding1\u0026quot; - Đầu ra: 64 byte trước khi rút gọn - Phân bố Alpha: Phân bố giống hệt như các khóa riêng Ed25519 sau mod L\nLàm mù khóa riêng Thuật toán BLIND_PRIVKEY(a, alpha):\nĐối với chủ sở hữu destination (đích) khi xuất bản LeaseSet đã được mã hóa:\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) Tối quan trọng: Phép rút gọn mod L là bắt buộc để duy trì mối quan hệ đại số đúng đắn giữa khóa bí mật và khóa công khai.\nLàm mù khóa công khai Thuật toán BLIND_PUBKEY(A, alpha):\nĐối với các ứng dụng khách truy xuất và xác minh LeaseSet được mã hóa:\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) Tương đương toán học:\nCả hai phương pháp cho ra kết quả giống hệt nhau:\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) Điều này là do:\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) Ký số với Blinded Keys (khóa mù) Ký LeaseSet Unblinded (không mù):\nLeaseSet unblinded (không làm mù) (được gửi trực tiếp cho các client đã xác thực) được ký bằng: - Chữ ký Ed25519 chuẩn (type 7) hoặc Red25519 (type 11) - Khóa riêng dùng để ký unblinded - Được xác minh bằng khóa công khai unblinded\nVới các khóa ngoại tuyến: - Được ký bằng khóa riêng tạm thời unblinded (không bị làm mù) - Được xác minh bằng khóa công khai tạm thời unblinded - Cả hai phải là loại 7 hoặc 11\nKý số cho LeaseSet được mã hóa:\nPhần bên ngoài của LeaseSet được mã hóa sử dụng chữ ký Red25519 với các khóa được làm mù.\nThuật toán ký số Red25519:\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total Những khác biệt chính so với Ed25519: 1. Sử dụng 80 byte dữ liệu ngẫu nhiên T (không phải băm của khóa riêng) 2. Sử dụng trực tiếp giá trị khóa công khai (không phải băm của khóa riêng) 3. Mỗi chữ ký đều là duy nhất ngay cả với cùng một thông điệp và cùng một khóa\nXác minh:\nGiống như Ed25519:\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; Các cân nhắc bảo mật Phân phối Alpha:\nVì lý do bảo mật, alpha phải có cùng phân phối như các khóa riêng không bị làm mù. Khi blinding (kỹ thuật làm mù) Ed25519 (loại 7) sang Red25519 (loại 11), các phân phối khác nhau đôi chút.\nKhuyến nghị: Sử dụng Red25519 (loại 11) cho cả khóa không bị làm mù và khóa bị làm mù để đáp ứng yêu cầu của ZCash: \u0026ldquo;sự kết hợp giữa một khóa công khai được tái ngẫu nhiên hóa và các chữ ký được tạo bằng khóa đó không tiết lộ khóa mà từ đó khóa công khai đã được tái ngẫu nhiên hóa.\u0026rdquo;\nHỗ trợ Type 7: Ed25519 được hỗ trợ để tương thích ngược với các điểm đích hiện có, nhưng Type 11 được khuyến nghị cho các điểm đích được mã hóa mới.\nLợi ích của xoay vòng hàng ngày: - Bí mật chuyển tiếp: Việc lộ khóa đã làm mù của hôm nay không làm lộ khóa của ngày hôm qua - Không thể liên kết: Xoay vòng hàng ngày ngăn chặn việc theo dõi dài hạn qua DHT - Phân tách khóa: Dùng các khóa khác nhau cho các khoảng thời gian khác nhau\nTài liệu tham khảo: - Đặc tả giao thức ZCash - Mục 5.4.6.1 - Thảo luận về Key Blinding (kỹ thuật làm mù khóa) của Tor - Ticket Tor #8106 Mã hóa và xử lý Dẫn xuất Subcredential (chứng thực phụ) Trước khi mã hóa, chúng tôi dẫn xuất một credential (thông tin xác thực) và một subcredential (thông tin xác thực phụ) để ràng buộc các tầng được mã hóa với việc biết khóa công khai dùng để ký của Destination (đích trong I2P).\nMục tiêu: Đảm bảo chỉ những người biết khóa công khai dùng để ký của Destination (định danh đích trong I2P) mới có thể giải mã LeaseSet được mã hóa. Không cần Destination đầy đủ.\nTính toán thông tin xác thực A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes Phân tách miền: Chuỗi cá nhân hóa \u0026ldquo;credential\u0026rdquo; đảm bảo giá trị băm này không va chạm với bất kỳ khóa tra cứu DHT (bảng băm phân tán) nào hoặc các mục đích sử dụng khác trong giao thức.\nTính toán Subcredential (thông tin xác thực phụ) blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes Mục đích: Thông tin xác thực con ràng buộc LeaseSet được mã hóa với: 1. Destination (đích) cụ thể (thông qua thông tin xác thực) 2. Khóa đã được làm mù cụ thể (thông qua blindedPublicKey) 3. Ngày cụ thể (thông qua việc xoay vòng hàng ngày của blindedPublicKey)\nĐiều này ngăn chặn các cuộc tấn công phát lại và khả năng liên kết qua nhiều ngày.\nMã hóa tầng 1 Ngữ cảnh: Lớp 1 chứa dữ liệu ủy quyền của máy khách và được mã hóa bằng khóa được dẫn xuất từ subcredential (thông tin xác thực con).\nThuật toán mã hóa # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) Đầu ra: outerCiphertext có độ dài 32 + len(outerPlaintext) byte.\nThuộc tính bảo mật: - Salt đảm bảo các cặp khóa/IV (vector khởi tạo) là duy nhất ngay cả khi dùng cùng một subcredential (thông tin xác thực phụ) - Chuỗi ngữ cảnh \u0026quot;ELS2_L1K\u0026quot; cung cấp phân tách miền - ChaCha20 cung cấp bảo mật ngữ nghĩa (bản mã không thể phân biệt với ngẫu nhiên)\nThuật toán giải mã # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) Xác minh: Sau khi giải mã, hãy xác minh rằng cấu trúc của Lớp 1 (Layer 1) đúng định dạng trước khi tiếp tục sang Lớp 2 (Layer 2).\nMã hóa Lớp 2 Ngữ cảnh: Lớp 2 chứa dữ liệu LeaseSet2 thực tế và được mã hóa bằng khóa được dẫn xuất từ authCookie (nếu bật xác thực theo từng máy khách) hoặc chuỗi rỗng (nếu không).\nThuật toán mã hóa # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) Đầu ra: innerCiphertext có độ dài 32 + len(innerPlaintext) byte.\nRàng buộc khóa: - Nếu không có xác thực client: Chỉ ràng buộc với subcredential và timestamp - Nếu bật xác thực client: Ngoài ra còn ràng buộc với authCookie (khác nhau cho mỗi client được ủy quyền)\nThuật toán giải mã # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) Xác minh: Sau khi giải mã: 1. Xác minh byte loại LS2 hợp lệ (3 hoặc 7) 2. Phân tích cú pháp cấu trúc LeaseSet2 3. Xác minh dấu thời gian bên trong khớp với dấu thời gian được công bố bên ngoài 4. Xác minh thời gian hết hạn bên trong khớp với thời gian hết hạn bên ngoài 5. Xác minh chữ ký LeaseSet2\nTóm tắt lớp mã hóa ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ Quy trình giải mã: 1. Xác minh chữ ký của Lớp 0 bằng khóa công khai được làm mù 2. Giải mã Lớp 1 bằng subcredential (thông tin xác thực phụ) 3. Xử lý dữ liệu ủy quyền (nếu có) để lấy authCookie 4. Giải mã Lớp 2 bằng authCookie và subcredential 5. Xác minh và phân tích cú pháp LeaseSet2\nPhân quyền theo từng máy khách Tổng quan Khi bật ủy quyền theo từng máy khách, máy chủ duy trì danh sách các máy khách được ủy quyền. Mỗi máy khách có key material (dữ liệu khóa) cần được truyền an toàn qua kênh out-of-band (kênh riêng tách biệt khỏi kênh thông thường).\nHai cơ chế ủy quyền: 1. Ủy quyền client DH (Diffie-Hellman): Bảo mật hơn, sử dụng thỏa thuận khóa X25519 2. Ủy quyền PSK (Pre-Shared Key — khóa chia sẻ trước): Đơn giản hơn, sử dụng khóa đối xứng\nThuộc tính bảo mật phổ biến: - Tính riêng tư về tư cách thành viên của máy khách: Người quan sát chỉ thấy số lượng máy khách nhưng không thể nhận diện các máy khách cụ thể - Ẩn danh khi thêm/thu hồi máy khách: Không thể theo dõi thời điểm các máy khách cụ thể được thêm hoặc bị gỡ bỏ - Xác suất va chạm của định danh máy khách 8 byte: ~1 trên 18 tỷ tỷ (không đáng kể)\nỦy quyền máy khách DH (Diffie-Hellman - thuật toán trao đổi khóa) Tổng quan: Mỗi máy khách tạo một cặp khóa X25519 và gửi khóa công khai của mình tới máy chủ qua một kênh out-of-band (ngoài băng) bảo mật. Máy chủ sử dụng ephemeral DH (Diffie-Hellman tạm thời) để mã hóa một authCookie duy nhất cho từng máy khách.\nSinh khóa cho máy khách # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) Ưu điểm bảo mật: Khóa riêng của máy khách không bao giờ rời khỏi thiết bị của họ. Kẻ tấn công chặn được việc truyền ngoài băng cũng không thể giải mã các LeaseSets được mã hóa trong tương lai nếu không bẻ gãy X25519 DH.\nXử lý phía máy chủ # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Cấu trúc dữ liệu tầng 1:\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Khuyến nghị cho máy chủ: - Tạo cặp khóa tạm thời mới cho mỗi LeaseSet mã hóa được công bố - Ngẫu nhiên hóa thứ tự client để ngăn theo dõi dựa trên vị trí - Cân nhắc thêm các mục giả để che giấu số lượng client thực\nXử lý phía ứng dụng khách # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Xử lý lỗi phía máy khách: - Nếu không tìm thấy clientID_i: Máy khách đã bị thu hồi quyền hoặc chưa từng được cấp quyền - Nếu giải mã thất bại: Dữ liệu bị hỏng hoặc khóa sai (rất hiếm) - Máy khách nên định kỳ lấy lại để phát hiện việc thu hồi quyền\nỦy quyền máy khách bằng PSK (khóa chia sẻ trước) Tổng quan: Mỗi máy khách có một khóa đối xứng 32 byte được chia sẻ trước. Máy chủ mã hóa cùng một authCookie sử dụng PSK (khóa chia sẻ trước) của từng máy khách.\nSinh khóa # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel Lưu ý bảo mật: Cùng một PSK (khóa chia sẻ trước) có thể được chia sẻ giữa nhiều máy khách nếu muốn (tạo cơ chế ủy quyền \u0026ldquo;nhóm\u0026rdquo;).\nXử lý phía máy chủ # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Cấu trúc dữ liệu Lớp 1:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Xử lý phía máy khách # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) So sánh và khuyến nghị Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access **Khuyến nghị:** - **Sử dụng DH authorization** (ủy quyền dựa trên Diffie–Hellman) cho các ứng dụng bảo mật cao, nơi bí mật chuyển tiếp là quan trọng - **Sử dụng PSK authorization** (ủy quyền bằng khóa chia sẻ trước) khi hiệu năng là yếu tố then chốt hoặc khi quản lý các nhóm máy khách - **Không bao giờ tái sử dụng PSKs** giữa các dịch vụ khác nhau hoặc qua các khoảng thời gian - **Luôn sử dụng các kênh bảo mật** để phân phối khóa (ví dụ: Signal, OTR, PGP) Các cân nhắc bảo mật Quyền riêng tư về tư cách thành viên của ứng dụng khách:\nCả hai cơ chế bảo vệ quyền riêng tư về tư cách thành viên của máy khách thông qua: 1. Định danh máy khách được mã hóa: clientID 8-byte được suy ra từ đầu ra HKDF 2. Cookie không thể phân biệt: Tất cả các giá trị clientCookie 32-byte trông như ngẫu nhiên 3. Không có siêu dữ liệu riêng theo máy khách: Không có cách nào để xác định mục nào thuộc về máy khách nào\nMột người quan sát có thể thấy: - Số lượng máy khách được ủy quyền (từ trường clients) - Sự thay đổi trong số lượng máy khách theo thời gian\nMột người quan sát KHÔNG thể thấy: - Những máy khách cụ thể nào được ủy quyền - Khi các máy khách cụ thể được thêm hoặc bị gỡ bỏ (nếu số lượng giữ nguyên) - Bất kỳ thông tin nhận dạng máy khách nào\nKhuyến nghị về ngẫu nhiên hóa:\nMáy chủ NÊN xáo trộn ngẫu nhiên thứ tự các máy khách mỗi lần máy chủ tạo một LeaseSet được mã hóa:\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order Lợi ích: - Ngăn máy khách biết vị trí của mình trong danh sách - Ngăn chặn các cuộc tấn công suy luận dựa trên thay đổi vị trí - Khiến việc thêm/thu hồi máy khách không thể phân biệt được\nẨn số lượng máy khách:\nMáy chủ CÓ THỂ chèn các mục giả ngẫu nhiên:\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) Chi phí: Các mục giả làm tăng kích thước LeaseSet được mã hóa (40 byte mỗi mục).\nXoay vòng AuthCookie (cookie xác thực):\nMáy chủ NÊN tạo một authCookie mới: - Mỗi lần một LeaseSet được mã hóa được công bố (thường là mỗi vài giờ) - Ngay sau khi hủy quyền truy cập của một máy khách - Theo lịch định kỳ (ví dụ: hàng ngày) ngay cả khi không có thay đổi nào ở phía máy khách\nLợi ích: - Giới hạn mức độ lộ lọt nếu authCookie bị xâm phạm - Đảm bảo các máy khách đã bị thu hồi quyền truy cập sẽ nhanh chóng mất quyền truy cập - Cung cấp bảo mật chuyển tiếp cho Lớp 2\nĐịnh địa chỉ Base32 cho LeaseSets được mã hóa Tổng quan Các địa chỉ base32 I2P truyền thống chỉ chứa băm của Destination (đích kết nối trong I2P) (32 byte → 52 ký tự). Điều này là chưa đủ đối với LeaseSets được mã hóa vì:\nCác client cần khóa công khai không làm mù (unblinded public key) để dẫn xuất khóa công khai đã làm mù (blinded public key) Các client cần các loại chữ ký (không làm mù và làm mù) để dẫn xuất khóa đúng cách Chỉ riêng giá trị băm (hash) không cung cấp thông tin này Giải pháp: Một định dạng base32 mới bao gồm khóa công khai và các loại chữ ký.\nĐặc tả định dạng địa chỉ Cấu trúc đã giải mã (35 byte):\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ 3 byte đầu tiên (XOR với checksum):\n3 byte đầu tiên chứa siêu dữ liệu được XOR với các phần của checksum (tổng kiểm) CRC-32:\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey Thuộc tính checksum (mã kiểm tra): - Sử dụng đa thức CRC-32 tiêu chuẩn - Tỉ lệ bỏ sót lỗi: ~1 trên 16 triệu - Hỗ trợ phát hiện lỗi do gõ sai địa chỉ - Không thể dùng làm xác thực (không an toàn về mặt mật mã)\nĐịnh dạng được mã hóa:\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; Đặc điểm: - Tổng số ký tự: 56 (35 byte × 8 bit ÷ 5 bit mỗi ký tự) - Hậu tố: \u0026ldquo;.b32.i2p\u0026rdquo; (giống như base32 truyền thống) - Tổng độ dài: 56 + 8 = 64 ký tự (không bao gồm ký tự kết thúc null)\nMã hóa Base32: - Bảng chữ cái: abcdefghijklmnopqrstuvwxyz234567 (chuẩn RFC 4648) - 5 bit không sử dụng ở cuối PHẢI bằng 0 - Không phân biệt chữ hoa/thường (theo quy ước dùng chữ thường)\nTạo địa chỉ import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address Phân tích cú pháp địa chỉ import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype So sánh với Base32 truyền thống Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations ### Hạn chế sử dụng Sự không tương thích của BitTorrent:\nCác địa chỉ LS2 được mã hóa KHÔNG THỂ được sử dụng với các phản hồi announce dạng rút gọn của BitTorrent:\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ Vấn đề: Định dạng rút gọn chỉ chứa giá trị băm (32 bytes), không có chỗ cho các kiểu chữ ký hoặc thông tin khóa công khai.\nGiải pháp: Hãy sử dụng các phản hồi announce đầy đủ hoặc các tracker dựa trên HTTP có hỗ trợ địa chỉ đầy đủ.\nTích hợp sổ địa chỉ Nếu một máy khách có Destination (địa chỉ đích trong I2P) đầy đủ trong sổ địa chỉ:\nLưu trữ Destination (địa chỉ đích) đầy đủ (bao gồm khóa công khai) Hỗ trợ tra cứu ngược theo giá trị băm Khi gặp LS2 được mã hóa, truy xuất khóa công khai từ sổ địa chỉ Không cần định dạng base32 mới nếu Destination đầy đủ đã được biết Các định dạng sổ địa chỉ hỗ trợ LS2 được mã hóa: - hosts.txt với các chuỗi destination (địa chỉ đích trong I2P) đầy đủ - các cơ sở dữ liệu SQLite với cột destination - các định dạng JSON/XML với dữ liệu destination đầy đủ\nVí dụ hiện thực Ví dụ 1: Tạo địa chỉ\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p Ví dụ 2: Phân tích cú pháp và kiểm tra tính hợp lệ\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) Ví dụ 3: Chuyển đổi từ Destination (điểm đích trong I2P)\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) Các cân nhắc bảo mật Quyền riêng tư: - Địa chỉ Base32 tiết lộ khóa công khai - Điều này là có chủ đích và là yêu cầu của giao thức - KHÔNG tiết lộ khóa riêng tư hay làm suy yếu bảo mật - Khóa công khai là thông tin công khai theo thiết kế\nKháng va chạm: - CRC-32 chỉ cung cấp 32 bit kháng va chạm - Không an toàn về mặt mật mã (chỉ dùng để phát hiện lỗi) - KHÔNG dựa vào checksum (tổng kiểm) để xác thực - Vẫn cần xác minh đích đến đầy đủ\nXác thực địa chỉ: - Luôn xác thực checksum trước khi sử dụng - Từ chối các địa chỉ có loại chữ ký không hợp lệ - Xác minh khóa công khai nằm trên đường cong (phụ thuộc vào triển khai)\nTài liệu tham khảo: - Đề xuất 149: B32 cho Encrypted LS2 - Đặc tả định địa chỉ B32 - Đặc tả đặt tên I2P Hỗ trợ khóa ngoại tuyến Tổng quan Các khóa ngoại tuyến cho phép khóa ký chính luôn ở trạng thái ngoại tuyến (lưu trữ lạnh), trong khi một khóa ký tạm thời được dùng cho các hoạt động hằng ngày. Điều này tối quan trọng đối với các dịch vụ có mức độ bảo mật cao.\nCác yêu cầu cụ thể đối với LS2 (LeaseSet phiên bản 2) được mã hóa: - Các khóa tạm thời phải được tạo ngoại tuyến - Khóa riêng được làm mù phải được tạo sẵn (mỗi ngày một khóa) - Cả khóa tạm thời và khóa được làm mù đều được phân phối theo lô - Chưa có định dạng tệp chuẩn được xác định (TODO trong đặc tả)\nCấu trúc khóa ngoại tuyến Dữ liệu khóa tạm thời lớp 0 (khi bit cờ 0 = 1):\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ Phạm vi chữ ký: Chữ ký trong khối khóa ngoại tuyến bao gồm: - Dấu thời gian hết hạn (4 byte) - Loại chữ ký tạm thời (2 byte) - Khóa công khai ký tạm thời (biến độ dài)\nChữ ký này được xác minh bằng blinded public key (khóa công khai đã làm mù), chứng minh rằng thực thể nắm giữ blinded private key (khóa riêng đã làm mù) đã ủy quyền cho khóa tạm thời này.\nQuy trình sinh khóa Đối với LeaseSet được mã hóa với khóa ngoại tuyến:\nTạo cặp khóa tạm thời (ngoại tuyến, trong lưu trữ lạnh):\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\nVới mỗi ngày for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026quot;%Y%m%d\u0026quot;) # \u0026quot;YYYYMMDD\u0026quot; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) 3. **Sign transient keys with blinded keys** (offline): ```python for date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router: Cho mỗi ngày delivery_package[date] = { 'transient_privkey': keys[date][0], 'transient_pubkey': keys[date][1], 'blinded_privkey': blinded_keys[date][0], 'blinded_pubkey': blinded_keys[date][1], 'offline_sig_block': offline_sig_blocks[date] }\n### Router Usage **Daily Key Loading:** ```python # Vào lúc nửa đêm UTC (hoặc trước khi xuất bản) date = datetime.utcnow().date() # Nạp các khóa của hôm nay today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # Hãy dùng các khóa này cho LeaseSet được mã hóa hôm nay Publishing Process:\n# 1. Tạo LeaseSet2 bên trong inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. Mã hóa Lớp 2 layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. Tạo Lớp 1 với dữ liệu ủy quyền layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. Mã hóa lớp 1 layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. Tạo Lớp 0 với khối chữ ký ngoại tuyến layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ) # 6. Ký Lớp 0 bằng khóa riêng tạm thời signature = RED25519_SIGN(transient_privkey, layer0) # 7. Thêm chữ ký và công bố encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# Tạo CẢ HAI khóa tạm thời mới và blinded keys (khóa mù hóa) mới mỗi ngày for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - Lô dữ liệu khóa đã mã hóa - Khoảng thời gian bao phủ OFFLINE_KEY_STATUS - Số ngày còn lại - Ngày hết hạn khóa tiếp theo REVOKE_OFFLINE_KEYS - Khoảng thời gian cần thu hồi - Các khóa mới để thay thế (tùy chọn) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p Key Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# Bật LeaseSet được mã hóa i2cp.encryptLeaseSet=true # Tùy chọn: Bật ủy quyền cho máy khách i2cp.enableAccessList=true # Tùy chọn: Sử dụng DH authorization (ủy quyền bằng Diffie‑Hellman) (mặc định là PSK (khóa chia sẻ trước)) i2cp.accessListType=0 # Tùy chọn: Blinding secret (chuỗi bí mật dùng để làm mù địa chỉ) (rất được khuyến nghị) i2cp.blindingSecret=your-secret-here API Usage Example:\n// Tạo LeaseSet được mã hóa EncryptedLeaseSet els = new EncryptedLeaseSet(); // Thiết lập đích els.setDestination(destination); // Bật ủy quyền theo từng máy khách els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // Thêm các máy khách được ủy quyền (khóa công khai DH (Diffie-Hellman)) for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // Thiết lập các tham số blinding (làm mù) els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // Ký và công bố els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd Key Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Bật LeaseSet được mã hóa encryptleaseset = true # Tùy chọn: Loại ủy quyền của máy khách (0=DH, 1=PSK) authtype = 0 # Tùy chọn: Bí mật làm mù secret = your-secret-here # Tùy chọn: Các máy khách được ủy quyền (mỗi dòng một khóa công khai được mã hóa base64) client.1 = base64-encoded-client-pubkey-1 client.2 = base64-encoded-client-pubkey-2 API Usage Example:\n// Tạo LeaseSet được mã hóa auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // Kích hoạt ủy quyền theo từng máy khách encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // Thêm các máy khách được ủy quyền for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // Ký và công bố encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# Vector kiểm thử 1: Làm mù khóa destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # Kết quả mong đợi: (xác minh đối chiếu với bản triển khai tham chiếu) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets Red25519 Specification - Detailed Red25519 implementation B32 Addressing Specification - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # Điểm cơ sở Ed25519 (điểm sinh) B = 2**255 - 19 # Bậc của Ed25519 (kích thước của trường vô hướng) L = 2**252 + 27742317777372353535851937790883648493 # Các giá trị kiểu chữ ký SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # Độ dài khóa PRIVKEY_SIZE = 32 # bytes PUBKEY_SIZE = 32 # bytes SIGNATURE_SIZE = 64 # bytes ChaCha20 Constants # Tham số ChaCha20 CHACHA20_KEY_SIZE = 32 # byte (256 bit) CHACHA20_NONCE_SIZE = 12 # byte (96 bit) CHACHA20_INITIAL_COUNTER = 1 # RFC 7539 cho phép 0 hoặc 1 HKDF Constants # Các tham số HKDF (hàm dẫn xuất khóa dựa trên HMAC) HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # bytes (HashLen) # Các chuỗi \u0026#34;info\u0026#34; của HKDF (phân tách miền) HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # SHA-256 personalization strings (chuỗi cá nhân hóa) HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # Kích thước lớp 0 (bên ngoài) BLINDED_SIGTYPE_SIZE = 2 # bytes BLINDED_PUBKEY_SIZE = 32 # bytes (for Red25519) PUBLISHED_TS_SIZE = 4 # bytes EXPIRES_SIZE = 2 # bytes FLAGS_SIZE = 2 # bytes LEN_OUTER_CIPHER_SIZE = 2 # bytes SIGNATURE_SIZE = 64 # bytes (Red25519) # Kích thước khối của khóa ngoại tuyến OFFLINE_EXPIRES_SIZE = 4 # byte OFFLINE_SIGTYPE_SIZE = 2 # byte OFFLINE_SIGNATURE_SIZE = 64 # byte # Kích thước lớp 1 (giữa) AUTH_FLAGS_SIZE = 1 # byte EPHEMERAL_PUBKEY_SIZE = 32 # byte (xác thực DH) AUTH_SALT_SIZE = 32 # byte (xác thực PSK) NUM_CLIENTS_SIZE = 2 # byte CLIENT_ID_SIZE = 8 # byte CLIENT_COOKIE_SIZE = 32 # byte AUTH_CLIENT_ENTRY_SIZE = 40 # byte (CLIENT_ID + CLIENT_COOKIE) # Chi phí phụ trội do mã hóa SALT_SIZE = 32 # byte (được thêm vào đầu mỗi lớp được mã hóa) # Địa chỉ Base32 B32_ENCRYPTED_DECODED_SIZE = 35 # byte B32_ENCRYPTED_ENCODED_LEN = 56 # ký tự B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# Khóa công khai của Destination (Ed25519) A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # Empty secret Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 byte salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) mod L Expected Output:\n(Xác minh so với bản triển khai tham chiếu) alpha = [giá trị thập lục phân 64 byte] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nciphertext = [xác minh đối chiếu với các vector kiểm thử của RFC 7539] Test Vector 3: HKDF Input:\nsalt = bytes(32) # All zeros ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [giá trị thập lục phân 44 byte] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32 bytes unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\nđịa chỉ = [56 ký tự base32].b32.i2p # Xác minh rằng việc kiểm tra checksum cho kết quả chính xác Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"Định dạng LeaseSet có kiểm soát truy cập cho các Destinations (điểm đích trong I2P) riêng tư","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"LeaseSet được mã hóa","url":"/vi/docs/specs/encryptedleaseset/"},{"categories":null,"content":"Tổng quan Tài liệu này đặc tả một lược đồ chữ ký có thể tái ngẫu nhiên hóa, phù hợp để tạo các Destinations có thể được blinded (làm mù). Ngoài ra, nó cũng có thể được dùng để blind các Destinations Ed25519 hiện có, với mức giảm nhẹ về hiệu quả.\nRed25519 đã hoạt động đầy đủ trên các I2P router kể từ phiên bản 0.9.39 (phát hành ngày 21 tháng 3 năm 2019). Bản đặc tả này được hoàn thiện ở phiên bản 0.9.47 (tháng 8 năm 2020) sau 17 tháng triển khai trong môi trường sản xuất. Lược đồ chữ ký này được sử dụng như loại chữ ký 11 (RedDSA_SHA512_Ed25519) trong mạng I2P.\nĐộng lực Đề xuất 123 (New netDB Entries) định nghĩa một định dạng LeaseSet2 (định dạng LeaseSet thế hệ 2) được mã hóa, hiện thực hóa Nguyên tắc ít quyền nhất: mỗi thành viên trong mạng chỉ được cung cấp những thông tin cần thiết cho vai trò của họ. Cụ thể, một LeaseSet2 được mã hóa khi được công bố lên một floodfill (nút floodfill lưu trữ netDb) sẽ không tiết lộ Destination (đích I2P) mà nó hướng tới, và các Lease chỉ có thể được xem bởi người đã biết trước về Destination đó. Tuy nhiên, các floodfill vẫn cần có khả năng xác thực các LeaseSet2 đã mã hóa khi chúng được công bố, và các client cũng cần bảo đảm thêm rằng việc xác thực đó do chính Destination thực thi.\nĐề xuất 123 đạt được điều này bằng cách làm mù các khóa ký của Destinations (điểm đích I2P). Các khóa đã bị làm mù có thể được dùng để tạo chữ ký mà floodfills có thể xác minh, và các ứng dụng khách có thể chắc chắn rằng chỉ Destination mới có thể tạo ra các chữ ký đó. Vì vậy, cần chỉ định một lược đồ chữ ký có thể dùng để làm mù.\nLưu ý về trạng thái của Proposal 123: Một số phần của Proposal 123 đã được hiện thực hóa và triển khai dần dần kể từ phiên bản 0.9.38, với hỗ trợ Red25519 được bổ sung trong 0.9.39. Chức năng LeaseSet2 được mã hóa (phiên bản 2 của LeaseSet) đã sẵn sàng cho môi trường sản xuất và đang được sử dụng tích cực trong mạng I2P cho các dịch vụ ẩn được tăng cường quyền riêng tư.\nThiết kế Lược đồ chữ ký cốt lõi Lược đồ chữ ký được chỉ định ở đây, Red25519, là một hiện thực của RedDSA như được định nghĩa trong Mục 5.4.6 của Zcash Protocol Specification (Sapling và về sau). RedDSA là một lược đồ chữ ký dựa trên Schnorr hỗ trợ key re-randomization (tái ngẫu nhiên hóa khóa). Nó có các hàm sau:\nGENERATE_PRIVATE() : Trả về một khóa riêng ngẫu nhiên theo phân phối đều.\nDERIVE_PUBLIC(sk) : Trả về khóa công khai tương ứng với khóa riêng đã cho.\nGENERATE_RANDOM() : Trả về một số vô hướng ngẫu nhiên phù hợp để ngẫu nhiên hóa lại một cặp khóa.\nRANDOMIZE_PRIVATE(sk, alpha) : Tái ngẫu nhiên hóa một khóa riêng, sử dụng số vô hướng bí mật alpha.\nRANDOMIZE_PUBLIC(vk, alpha) : Tái ngẫu nhiên hóa một khóa công khai, sử dụng một vô hướng bí mật alpha.\nSIGN(sk, m) : Trả về một chữ ký số được tạo bằng khóa riêng sk trên thông điệp m đã cho.\nVERIFY(vk, m, sig) : Xác minh chữ ký sig đối chiếu với khóa công khai vk và thông điệp m. Trả về true nếu chữ ký hợp lệ, ngược lại trả về false.\nVới một cặp khóa (sk, vk) cho trước, mối quan hệ sau đây luôn đúng:\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) Chuyển đổi khóa Ed25519 sang Red25519 Khóa Ed25519 CÓ THỂ được chuyển đổi một chiều tạm thời thành khóa Red25519, nhằm hỗ trợ tái ngẫu nhiên hóa (re-randomization) các Ed25519 Destinations (đích định danh trong I2P) hiện có. Các sigtypes (kiểu chữ ký) khác không tương thích.\nChúng tôi định nghĩa các hàm chuyển đổi sau đây:\nCONVERT_ED25519_PRIVATE(privkey) : Trả về khóa riêng Red25519 tương ứng với khóa riêng Ed25519 đã cho.\nCONVERT_ED25519_PUBLIC(pubkey) : Trả về khóa công khai Red25519 tương ứng với khóa công khai Ed25519 đã cho.\nĐối với một cặp khóa Ed25519 (privkey, pubkey) cho trước, hệ thức sau đúng:\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) Đặc tả Định nghĩa B : Basepoint (điểm cơ sở) của Ed25519 theo RFC 8032 .\nL : Bậc của Ed25519 là 2^252 + 27742317777372353535851937790883648493 như trong RFC 8032 .\n[s] B : Phép nhân vô hướng cơ sở cố định của điểm cơ sở với s.\n[s] A : Phép nhân vô hướng cơ sở thay đổi của A với s.\nx || y : Ghép nối hai mảng byte x và y.\nRed25519 Lược đồ Red25519 (một lược đồ chữ ký số) là một chuyên biệt của RedDSA (một lược đồ chữ ký số), với:\nG := nhóm các điểm trên dạng Edwards của Curve25519. Cụ thể, điều này có nghĩa là Red25519 sử dụng nhóm con bậc nguyên tố có bậc L, và cofactor (hệ số phụ) h_G là 8. P_G := điểm cơ sở B của Ed25519. l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) Lưu ý về lựa chọn hàm băm: Red25519 sử dụng SHA-512 thay vì BLAKE2b-512 (như được dùng trong Zcash RedDSA). Lựa chọn thiết kế này được bù đắp bởi cơ chế bảo vệ bằng tiền tố độ dài được mô tả bên dưới. I2P Proposal 148 đề xuất chuyển sang BLAKE2b-512 trong tương lai để tăng cường bảo vệ chống lại Duplicate Message Identification (DMI — nhận dạng thông điệp trùng lặp) và Length Extension Attacks (LEA — tấn công mở rộng độ dài), đồng thời cải thiện hiệu năng.\nRedDSA giả định rằng H(x) được hiện thực bằng một hàm băm mật mã an toàn trước các cuộc tấn công mở rộng độ dài. SHA-512 tự thân không đáp ứng được điều này. Để khắc phục điều đó, chúng tôi yêu cầu các thông điệp được gắn thêm ở đầu một mã hóa tiền tố (prefix-free) của độ dài thông điệp:\nlen_u16(M) || M trong đó len_u16(M) là dạng biểu diễn 2 byte của độ dài M, theo thứ tự byte little-endian (nhằm nhất quán với cách mã hóa little-endian của các vô hướng và các điểm).\nCác thông điệp không được vượt quá 65534 byte. Giá trị độ dài 65535 được dành cho các phần mở rộng có thể có trong tương lai.\nGhi chú bảo mật: Việc đưa khóa công khai (vk) vào hàm băm, kết hợp với 80 byte ngẫu nhiên khi ký, bảo đảm khả năng bảo vệ trước các lỗ hổng SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack - tính không thể giả mạo mạnh với khóa được ngẫu nhiên hóa lại dưới tấn công chọn thông điệp) được phát hiện trong các thiết kế RedDSA ban đầu. Bản triển khai này tích hợp các bản vá bảo mật từ cuộc kiểm toán Zcash của NCC Group (Finding NCC-Zcash2018-009).\nMã hóa và giải mã Khóa riêng Red25519 là các vô hướng mod L, được mã hóa theo biểu diễn little-endian. Chúng tôi định nghĩa các hàm DECODE_SCALAR và ENCODE_SCALAR để chuyển đổi qua lại giữa mảng byte và dạng số nguyên của một vô hướng.\nKhóa công khai Red25519 là các điểm trên dạng Edwards của Curve25519. Chúng được mã hóa dưới dạng biểu diễn little-endian 255 bit của tọa độ y, theo sau bởi một bit cho biết dấu của tọa độ x. Đây là cùng một cách mã hóa như với Ed25519. Chúng tôi định nghĩa các hàm DECODE_POINT và ENCODE_POINT để chuyển đổi giữa mảng byte và dạng tọa độ của một điểm.\nCác hàm RedDSA (một thuật toán chữ ký số) Để thuận tiện cho việc triển khai, dưới đây chúng tôi trình bày rõ ràng các hàm RedDSA (lược đồ chữ ký số RedDSA), cũng như một số hàm trợ giúp, đã được chuyên biệt hóa cho Red25519 (biến thể RedDSA dành cho đường cong 25519). Những người triển khai nên tham khảo mục 5.4.6 của Zcash Protocol Specification để biết đặc tả tổng quát của các hàm RedDSA.\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() Các hàm chuyển đổi CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey Lưu ý rằng việc triển khai CONVERT_ED25519_PRIVATE tương đương với việc tính toán vô hướng bí mật s khi suy ra khóa công khai Ed25519 từ khóa riêng Ed25519, như được quy định trong các bước 1-3 của mục 5.1.5 của RFC 8032 .\nHệ quả đối với bảo mật Tái ngẫu nhiên hóa một Điểm đích Red25519 rồi dùng nó để tạo chữ ký sẽ không làm rò rỉ bất kỳ thông tin nào về Điểm đích, vì phân phối của các khóa riêng Red25519 được tạo thông qua RANDOMIZE_PRIVATE là giống hệt với phân phối của các khóa riêng được tạo thông qua GENERATE_PRIVATE, và DERIVE_PUBLIC là xác định.\nViệc chuyển đổi các khóa riêng Ed25519 (thuật toán chữ ký số) sang Red25519 (một biến thể liên quan đến Ed25519) thông qua CONVERT_ED25519_PRIVATE không dẫn tới cùng một phân phối. Tuy nhiên, chúng tôi cho rằng sự suy giảm về bảo mật là chấp nhận được vì các lý do sau:\nKhông gian các số vô hướng của Ed25519 xấp xỉ bằng một nửa kích thước không gian các số vô hướng của Red25519 (có 2^251 số vô hướng Ed25519 khả dĩ, và L ~= 2^252 số vô hướng Red25519 khả dĩ). Do đó, mức suy giảm bảo mật tối đa chỉ khoảng hệ số 2, hay khoảng 1 bit (vì ta có thể tình cờ chọn một số vô hướng Red25519 cũng đồng thời là một số vô hướng Ed25519 hợp lệ). Các Ed25519 Destinations (địa chỉ đích trong I2P) hiện có đã từng bị lộ trên mạng, và nên giả định rằng các floodfills độc hại đã liệt kê chúng. Quan trọng: Người dùng lo ngại về sự suy giảm bảo mật này nên sử dụng Red25519 (signature type 11) làm sigtype (kiểu chữ ký) cho các Destinations (định danh đích trong I2P) của mình thay vì Ed25519 (signature type 7).\nLưu ý rằng lập luận ở trên không áp dụng cho re-randomization scalar alpha (hệ số tái ngẫu nhiên hóa alpha); thông tin về khóa sẽ bị rò rỉ mỗi khi chọn một alpha bị thiên lệch, vì additive re-randomization (tái ngẫu nhiên hóa theo phép cộng) hoạt động giống như mật mã dùng một lần.\nTrạng thái kiểm toán bảo mật Tiết lộ quan trọng: I2P, bao gồm cả Red25519, chưa từng trải qua một cuộc kiểm toán bảo mật chính thức bởi bên thứ ba. Thiết kế RedDSA nền tảng đã được NCC Group rà soát bảo mật như một phần của cuộc kiểm toán giao thức Zcash Sapling năm 2018, trong đó các vấn đề bảo mật đã được xác định và khắc phục. Tuy nhiên, cách hiện thực cụ thể của I2P với SHA-512 (thay vì BLAKE2b-512) và cơ chế phân tách miền (domain separation) của I2P vẫn chưa được phân tích độc lập.\nBản triển khai tham chiếu ed25519-java của str4d đã trải qua một cuộc kiểm toán độc lập bởi bên thứ ba, nhưng cuộc kiểm toán này diễn ra trước khi có triển khai Red25519 và chỉ bao quát chức năng Ed25519, không bao gồm các phần mở rộng Red25519.\nNgười dùng triển khai Red25519 nên hiểu rõ hạn chế này và đánh giá các đánh đổi về bảo mật dựa trên mô hình đe dọa của họ.\nTương thích Các phiên bản I2P hỗ trợ Red25519 (thuật toán chữ ký số) (phiên bản 0.9.39 trở lên) sẽ có thể xác minh các cấu trúc dữ liệu mạng được ký bằng Red25519. Các phiên bản I2P không hỗ trợ Red25519 sẽ coi nó là một chữ ký không nhận dạng được và CÓ THỂ loại bỏ các cấu trúc dữ liệu đó.\nDòng thời gian triển khai: - 0.9.39 (Tháng 3 2019): Triển khai đầu tiên với hỗ trợ Encrypted LS2 (LS2 = LeaseSet2, phiên bản LeaseSet thế hệ 2) trong các floodfill - 0.9.40 (Tháng 5 2019): Ủy quyền theo từng client cho Encrypted LS2 - 0.9.41 (Tháng 8 2019): Meta LS2 và Encrypted LS2 với khóa ngoại tuyến - 0.9.43 (Tháng 2 2020): hỗ trợ b32 (địa chỉ Base32) cho Encrypted LS2 - 0.9.47 (Tháng 8 2020): Hoàn thiện đặc tả - 2.10.0 (Tháng 10 2025): Phiên bản mạng hiện tại (tương đương 0.9.67+)\nNgười dùng nên kỳ vọng độ tin cậy của các cấu trúc dữ liệu được ký bằng Red25519 ở mức tốt cho các trường hợp sử dụng LeaseSet2 được mã hóa, vì mạng đã có hơn sáu năm để nâng cấp kể từ khi triển khai ban đầu. Tuy nhiên, các chỉ số về mức độ áp dụng cho việc sử dụng đích nói chung không được công bố công khai.\nTrường hợp sử dụng chính: Red25519 chủ yếu được dùng cho chức năng LeaseSet2 được mã hóa, khi cần key blinding (kỹ thuật làm mù khóa). Đối với các đích tiêu chuẩn không có yêu cầu leaseset được mã hóa, Ed25519 (loại chữ ký 7) vẫn là lựa chọn được khuyến nghị nhờ khả năng tương thích rộng hơn và lịch sử hoạt động đã được chứng minh lâu hơn.\nGhi chú triển khai Red25519 được triển khai trong router Java của I2P tại net.i2p.crypto.eddsa.RedDSAEngine và sử dụng thư viện ed25519-java của str4d (Jack Grigg) như một phụ thuộc Maven net.i2p.crypto:eddsa (các phiên bản từ 0.1.0 đến 0.3.0).\nBản triển khai i2pd bằng C++ cũng hỗ trợ Red25519 (signaturetype=11) cho việc xuất bản LeaseSet được mã hóa.\nVí dụ cấu hình cho i2pd:\nsignaturetype=11 i2cp.leaseSetType=5 Khả năng tương thích LeaseSet2 được mã hóa: Đặc tả Encrypted LeaseSet yêu cầu khóa công khai dùng để ký trong unblinded destination (đích không che mù) phải là Ed25519 (kiểu chữ ký 7) hoặc Red25519 (kiểu chữ ký 11). Không hỗ trợ bất kỳ kiểu chữ ký nào khác cho chức năng leaseset được mã hóa.\nCác vector kiểm thử Các vector kiểm thử sau đây được cung cấp để kiểm chứng việc triển khai. Mỗi vector bao gồm:\nedsk: Khóa riêng Ed25519 (ngẫu nhiên) edpk: Khóa công khai Ed25519 tương ứng với edsk sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: Thông điệp cần ký sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) Ghi chú triển khai: Các vector kiểm thử này nên được tích hợp vào các bộ kiểm thử đơn vị tự động để xác thực liên tục. Người triển khai nên xác minh rằng tất cả các phép chuyển đổi, chữ ký và các thao tác tái ngẫu nhiên hóa khớp với các giá trị mong đợi này.\nVector kiểm thử 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 Vector kiểm thử 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f Lưu ý: Các vector kiểm thử bổ sung 3-10 tuân theo cùng một định dạng và có thể được tìm thấy trong bản triển khai tham chiếu.\nTài liệu tham khảo Đề xuất 123: Các mục netDB mới - Một phần đã được triển khai và đưa vào sử dụng trong 0.9.38, 0.9.39 và các bản phát hành sau đó Đặc tả Giao thức Zcash, Mục 5.4.6: RedDSA (biến thể EdDSA dùng trong Zcash), RedJubjub và RedPallas - RedDSA được định nghĩa như một phần của đặc tả giao thức Zcash; được NCC Group kiểm toán bảo mật (tháng 1 năm 2019) RFC 8032: Thuật toán chữ ký số đường cong Edwards (EdDSA) Đề xuất 148: RedDSA-BLAKE2b-Ed25519 - Đã được đề xuất nhưng chưa triển khai; đề xuất chuyển sang BLAKE2b-512 trong tương lai Đặc tả LeaseSet được mã hóa Đặc tả mật mã cấp thấp ","description":"Lược đồ chữ ký có thể tái ngẫu nhiên hóa để tạo các Destinations (điểm đích trong I2P) được làm mù","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"Lược đồ chữ ký Red25519","url":"/vi/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":" Trạng thái: Tài liệu này mô tả giao thức mã hóa ElGamal/AES+SessionTag (thẻ phiên) kiểu cũ. Nó vẫn được hỗ trợ chỉ để bảo đảm tương thích ngược, vì các phiên bản I2P hiện đại (2.10.0+) sử dụng ECIES-X25519-AEAD-Ratchet . Giao thức ElGamal đã bị loại bỏ dần và được giữ lại thuần túy vì mục đích lịch sử và khả năng tương tác.\nTổng quan ElGamal/AES+SessionTag đã cung cấp cơ chế mã hóa đầu-cuối ban đầu của I2P dành cho garlic messages (thông điệp \u0026ldquo;garlic\u0026rdquo;, một dạng thông điệp kết bó đặc trưng của I2P). Nó kết hợp:\nElGamal (2048-bit) — để trao đổi khóa AES-256/CBC — để mã hóa tải trọng SHA-256 — để băm và dẫn xuất IV Thẻ phiên (32 byte) — dùng làm định danh thông điệp dùng một lần Giao thức cho phép routers và các đích giao tiếp một cách an toàn mà không cần duy trì các kết nối lâu dài. Mỗi phiên sử dụng một phép trao đổi ElGamal bất đối xứng để thiết lập một khóa AES đối xứng, tiếp theo là các thông điệp \u0026ldquo;tagged\u0026rdquo; nhẹ tham chiếu tới phiên đó.\nHoạt động của giao thức Thiết lập phiên (Phiên mới) Một phiên mới bắt đầu với một thông điệp gồm hai phần:\nSection Size Contents Purpose ElGamal-encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient's ElGamal public key Establishes the AES session key and IV seed AES-encrypted block Variable (≥128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags Phần bản rõ bên trong khối ElGamal bao gồm: Field Size Description Session Key 32 bytes AES-256 key for the session Pre-IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA-256(Pre-IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length ### Các thông điệp của phiên hiện có Khi một phiên đã được thiết lập, bên gửi có thể gửi các thông điệp existing-session bằng cách sử dụng các thẻ phiên đã được lưu vào bộ đệm:\nField Size Description Session Tag 32 bytes Single-use identifier tied to the existing session key AES-Encrypted Block Variable Encrypted payload and metadata using the established AES key Các router lưu vào bộ nhớ đệm các thẻ đã được chuyển đến trong khoảng **15 phút**, sau đó các thẻ chưa dùng sẽ hết hạn. Mỗi thẻ chỉ hợp lệ cho đúng **một thông điệp** nhằm ngăn chặn các cuộc tấn công tương quan. Định dạng khối mã hóa AES Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single-use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA-256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16-byte aligned) Random padding to block boundary Các router giải mã bằng khóa phiên và IV (vector khởi tạo) được suy ra từ Pre-IV (IV tiền khởi tạo, dành cho phiên mới) hoặc session tag (thẻ phiên, dành cho phiên hiện có). Sau khi giải mã, chúng xác minh tính toàn vẹn bằng cách tính lại hàm băm SHA-256 của tải trọng bản rõ. Quản lý Session Tag (thẻ phiên) Các tag (thẻ) là một chiều: các tag từ Alice → Bob không thể được sử dụng lại cho Bob → Alice. Tag hết hạn sau khoảng 15 phút. Routers duy trì các bộ quản lý khóa phiên theo từng đích để theo dõi tag, khóa và thời điểm hết hạn. Các ứng dụng có thể kiểm soát hành vi của tag thông qua tùy chọn I2CP : i2cp.tagThreshold — số lượng tag được lưu đệm tối thiểu trước khi bổ sung i2cp.tagCount — số lượng tag mới trên mỗi thông điệp Cơ chế này giảm thiểu các lần bắt tay ElGamal (một hệ mật mã) tốn kém, đồng thời vẫn duy trì tính không thể liên kết giữa các thông điệp.\nCấu hình và Hiệu quả Session tags (thẻ phiên) được giới thiệu nhằm cải thiện hiệu suất trên lớp truyền tải có độ trễ cao và không đảm bảo thứ tự của I2P. Một cấu hình điển hình gửi kèm 40 thẻ cho mỗi thông điệp, làm tăng thêm khoảng 1.2 KB phụ trội. Các ứng dụng có thể điều chỉnh hành vi chuyển phát dựa trên lưu lượng dự kiến:\nUse Case Recommended Tags Notes Short-lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re-establishment Long-term services 50+ Ensures steady tag supply despite loss or delay Các router định kỳ dọn sạch các thẻ đã hết hạn và loại bỏ trạng thái phiên không được sử dụng nhằm giảm mức sử dụng bộ nhớ và giảm thiểu các tấn công làm ngập thẻ (tag-flooding attacks). Hạn chế Category Limitation Performance 514-byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES-CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor's algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. Những thiếu sót này đã trực tiếp thúc đẩy việc thiết kế giao thức [ECIES-X25519-AEAD-Ratchet](/docs/specs/ecies/), giao thức này cung cấp bảo mật chuyển tiếp hoàn hảo, mã hóa có xác thực và trao đổi khóa hiệu quả. Trạng thái ngừng hỗ trợ và chuyển đổi Giới thiệu: Các bản phát hành I2P thời kỳ đầu (trước 0.6) Ngừng dùng: Khi giới thiệu ECIES-X25519 (sơ đồ ECIES dùng X25519) (0.9.46 → 0.9.48) Gỡ bỏ: Không còn là mặc định kể từ 2.4.0 (Tháng 12 năm 2023) Hỗ trợ: Chỉ nhằm tương thích ngược Các router và các điểm đích hiện nay quảng bá kiểu mã hóa 4 (ECIES-X25519) thay vì kiểu 0 (ElGamal/AES). Giao thức cũ vẫn được công nhận để đảm bảo khả năng tương tác với các đồng cấp lỗi thời nhưng không nên sử dụng cho các triển khai mới.\nBối cảnh lịch sử ElGamal/AES+SessionTag là nền tảng cho kiến trúc mật mã ban đầu của I2P. Thiết kế lai của nó đã giới thiệu các đổi mới như thẻ phiên dùng một lần và các phiên một chiều, qua đó ảnh hưởng đến các giao thức về sau. Nhiều ý tưởng này đã phát triển thành các cấu trúc hiện đại như deterministic ratchets (cơ chế bánh cóc xác định) và hybrid post-quantum key exchanges (trao đổi khóa hậu lượng tử kiểu lai).\n","description":"Mã hóa đầu-cuối kiểu cũ kết hợp ElGamal, AES, SHA-256 và các thẻ phiên dùng một lần","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"Mã hóa bằng ElGamal/AES + SessionTag (thẻ phiên)","url":"/vi/docs/legacy/elgamal-aes/"},{"categories":null,"content":"Giới thiệu về các máy chủ reseed (máy chủ cung cấp dữ liệu khởi tạo netDb) Các routers mới cần một số ít nút ngang hàng để tham gia mạng I2P. Các máy chủ reseed (máy chủ cấp dữ liệu khởi tạo) cung cấp tập khởi tạo ban đầu đó thông qua các lần tải xuống HTTPS được mã hóa. Mỗi gói reseed được máy chủ ký, ngăn chặn việc can thiệp bởi các bên không được xác thực. Các routers đã hoạt động ổn định đôi khi có thể reseed nếu tập nút ngang hàng của chúng trở nên lỗi thời.\nQuy trình khởi tạo mạng Khi một I2P router mới khởi động hoặc đã ngoại tuyến trong một khoảng thời gian dài, nó cần dữ liệu RouterInfo (thông tin định danh của router) để kết nối vào mạng. Vì router không có sẵn các nút ngang hàng, nó không thể lấy thông tin này từ ngay bên trong mạng I2P. Cơ chế reseed (khởi tạo kết nối ban đầu) giải quyết vấn đề bootstrap (khởi động ban đầu) này bằng cách cung cấp các tệp RouterInfo từ các máy chủ HTTPS bên ngoài đáng tin cậy.\nQuy trình reseed (giai đoạn khởi tạo netDb ban đầu) phân phối 75–100 tệp RouterInfo (bản mô tả router) trong một gói duy nhất có chữ ký mật mã. Điều này bảo đảm các router mới có thể nhanh chóng thiết lập kết nối mà không bị phơi bày trước các cuộc tấn công người trung gian (man-in-the-middle) có thể cô lập chúng thành các phân vùng mạng riêng rẽ, không đáng tin cậy.\nTrạng thái mạng hiện tại Tính đến tháng 10 năm 2025, mạng I2P vận hành với phiên bản router 2.10.0 (phiên bản API 0.9.67). Giao thức reseed (quy trình khởi tạo ban đầu bằng cách tải netDb) được giới thiệu từ phiên bản 0.9.14 vẫn ổn định và không thay đổi về chức năng cốt lõi. Mạng duy trì nhiều máy chủ reseed độc lập được phân bố trên toàn cầu nhằm bảo đảm tính sẵn sàng và khả năng chống kiểm duyệt.\nDịch vụ checki2p giám sát tất cả các máy chủ reseed (máy chủ cung cấp dữ liệu khởi tạo ban đầu cho mạng I2P) cứ mỗi 4 giờ, cung cấp các kiểm tra trạng thái theo thời gian thực và các chỉ số về tính sẵn sàng cho hạ tầng reseed.\nĐặc tả định dạng tệp SU3 Định dạng tệp SU3 là nền tảng của giao thức reseed (quá trình khởi động ban đầu bằng cách tải dữ liệu seed của netDb) của I2P, cung cấp khả năng phân phối nội dung được ký bằng mật mã. Việc nắm vững định dạng này là điều thiết yếu để triển khai máy chủ và máy khách reseed.\nCấu trúc tệp Định dạng SU3 gồm ba thành phần chính: phần đầu (40+ byte), nội dung (độ dài biến đổi), và chữ ký (độ dài được chỉ định trong phần đầu).\nĐịnh dạng phần đầu (tối thiểu byte 0-39) Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") ### Các tham số SU3 (định dạng gói ký trong I2P) dành riêng cho Reseed (quá trình khởi tạo mạng I2P) Đối với gói reseed (gói dữ liệu khởi tạo mạng I2P), tệp SU3 phải có các đặc điểm sau:\nTên tệp: Phải chính xác là i2pseeds.su3 Loại nội dung (byte 27): 0x03 (RESEED) Loại tệp (byte 25): 0x00 (ZIP) Loại chữ ký (byte 8-9): 0x0006 (RSA-4096-SHA512) Chuỗi phiên bản: dấu thời gian Unix bằng ASCII (giây kể từ mốc epoch, định dạng date +%s) ID người ký: Định danh dạng email khớp với CN của chứng chỉ X.509 Tham số truy vấn ID mạng Từ phiên bản 0.9.42, các router thêm ?netid=2 vào các yêu cầu reseed (khởi tạo ban đầu). Điều này ngăn chặn các kết nối chéo giữa các mạng, vì các mạng thử nghiệm sử dụng các ID mạng khác nhau. Mạng I2P chính thức hiện tại sử dụng ID mạng 2.\nVí dụ yêu cầu: https://reseed.example.com/i2pseeds.su3?netid=2\nCấu trúc nội dung tệp ZIP Phần nội dung (sau phần tiêu đề, trước phần chữ ký) chứa một tệp ZIP tiêu chuẩn với các yêu cầu sau:\nNén: Nén ZIP tiêu chuẩn (DEFLATE) Số lượng tệp: Thường là 75-100 tệp RouterInfo (tệp thông tin router) Cấu trúc thư mục: Tất cả các tệp phải ở mức trên cùng (không có thư mục con) Quy tắc đặt tên tệp: routerInfo-{44-character-base64-hash}.dat Bảng chữ cái Base64: Phải dùng bảng chữ cái base64 đã được I2P sửa đổi Bảng chữ cái base64 của I2P khác với base64 chuẩn bằng cách dùng - và ~ thay cho + và / để đảm bảo khả năng tương thích với hệ thống tệp và URL.\nChữ ký mật mã Chữ ký bao phủ toàn bộ tệp từ byte 0 đến hết phần nội dung. Bản thân chữ ký được thêm vào sau phần nội dung.\nThuật toán chữ ký số (RSA-4096-SHA512) Tính hàm băm SHA-512 của dữ liệu từ byte 0 đến hết nội dung Ký hàm băm bằng RSA \u0026ldquo;raw\u0026rdquo; (NONEwithRSA theo thuật ngữ của Java) Đệm chữ ký bằng các số 0 ở đầu nếu cần để đạt 512 byte Nối thêm chữ ký 512 byte vào cuối tệp Quy trình xác minh chữ ký Các ứng dụng khách phải:\nĐọc các byte 0-11 để xác định loại và độ dài chữ ký Đọc toàn bộ tiêu đề để xác định ranh giới nội dung Đọc nội dung theo luồng trong khi tính hàm băm SHA-512 Trích xuất chữ ký từ cuối tệp Xác minh chữ ký bằng khóa công khai RSA-4096 của người ký Từ chối tệp nếu xác minh chữ ký thất bại Mô hình tin cậy chứng chỉ Các khóa ký reseed được phân phối dưới dạng chứng chỉ X.509 tự ký sử dụng khóa RSA-4096. Các chứng chỉ này được bao gồm trong các gói router I2P trong thư mục certificates/reseed/.\nĐịnh dạng chứng chỉ: - Loại khóa: RSA-4096 - Chữ ký: Tự ký - Subject CN: Phải khớp với Signer ID trong SU3 header - Ngày hiệu lực: Các máy khách nên thực thi thời hạn hiệu lực của chứng chỉ\nVận hành một Reseed Host (máy chủ cung cấp dữ liệu khởi tạo cho mạng I2P) Vận hành một dịch vụ reseed (dịch vụ cấp dữ liệu khởi động mạng) đòi hỏi chú ý cẩn trọng đến các yêu cầu về bảo mật, độ tin cậy và đa dạng mạng. Có nhiều máy chủ reseed độc lập hơn sẽ tăng khả năng chống chịu và khiến kẻ tấn công hoặc cơ quan kiểm duyệt khó chặn các routers mới tham gia hơn.\nYêu cầu kỹ thuật Thông số kỹ thuật máy chủ Hệ điều hành: Unix/Linux (Ubuntu, Debian, FreeBSD đã được kiểm thử và khuyến nghị) Kết nối: Địa chỉ IPv4 tĩnh là bắt buộc, IPv6 được khuyến nghị nhưng không bắt buộc CPU: Tối thiểu 2 lõi RAM: Tối thiểu 2 GB Băng thông: Khoảng 15 GB mỗi tháng Thời gian hoạt động: Yêu cầu hoạt động 24/7 I2P Router: I2P router được tích hợp tốt, chạy liên tục Yêu cầu phần mềm Java: JDK 8 trở lên (sẽ yêu cầu Java 17+ kể từ I2P 2.11.0) Máy chủ web: nginx hoặc Apache với hỗ trợ reverse proxy (proxy ngược) (Lighttpd không còn được hỗ trợ do hạn chế của header X-Forwarded-For) TLS/SSL: Chứng chỉ TLS hợp lệ (Let\u0026rsquo;s Encrypt, tự ký, hoặc CA thương mại (tổ chức cấp chứng chỉ)) Bảo vệ DDoS: fail2ban hoặc tương đương (bắt buộc, không tùy chọn) Công cụ Reseed: reseed-tools chính thức từ https://i2pgit.org/idk/reseed-tools Yêu cầu bảo mật Cấu hình HTTPS/TLS Giao thức: Chỉ HTTPS, không cho phép chuyển về HTTP Phiên bản TLS: Tối thiểu TLS 1.2 Bộ mã mật mã (cipher suites): Phải hỗ trợ các bộ mã mạnh tương thích với Java 8+ CN/SAN của chứng chỉ: Phải khớp với tên máy chủ của URL được phục vụ Loại chứng chỉ: Có thể tự ký nếu đã thông báo trước cho nhóm phát triển, hoặc do CA (tổ chức chứng thực) được công nhận cấp Quản lý chứng chỉ Chứng chỉ ký SU3 và chứng chỉ TLS phục vụ những mục đích khác nhau:\nChứng chỉ TLS (certificates/ssl/): Bảo mật truyền tải HTTPS Chứng chỉ ký SU3 (certificates/reseed/): Ký các gói reseed Cả hai chứng chỉ phải được cung cấp cho reseed coordinator (điều phối viên khởi tạo mạng ban đầu) (zzz@mail.i2p ) để được đưa vào các gói router.\nBảo vệ chống DDoS và Scraping (thu thập dữ liệu tự động) Máy chủ Reseed (máy chủ cung cấp dữ liệu netDb ban đầu cho router mới gia nhập mạng) phải đối mặt định kỳ với các cuộc tấn công từ các triển khai lỗi, botnet và các tác nhân độc hại tìm cách thu thập ồ ạt cơ sở dữ liệu mạng. Các biện pháp bảo vệ bao gồm:\nfail2ban: Bắt buộc để giới hạn tần suất và giảm thiểu tấn công Đa dạng gói: Cung cấp các tập RouterInfo (thông tin về router trong I2P) khác nhau cho các bên yêu cầu khác nhau Nhất quán gói: Cung cấp cùng một gói cho các yêu cầu lặp lại từ cùng một IP trong một khoảng thời gian có thể cấu hình Hạn chế ghi log IP: Không công khai nhật ký (log) hoặc địa chỉ IP (yêu cầu của chính sách quyền riêng tư) Phương pháp triển khai Phương pháp 1: reseed-tools chính thức (Khuyến nghị) Bản hiện thực chính tắc do dự án I2P bảo trì. Kho lưu trữ: https://i2pgit.org/idk/reseed-tools Cài đặt:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 Trong lần chạy đầu tiên, công cụ sẽ tạo: - your-email@mail.i2p.crt (chứng chỉ ký SU3) - your-email@mail.i2p.pem (khóa riêng ký SU3) - your-email@mail.i2p.crl (danh sách thu hồi chứng chỉ) - các tệp chứng chỉ và khóa TLS\nTính năng: - Tự động tạo gói SU3 (350 biến thể, mỗi biến thể có 77 RouterInfos) - Máy chủ HTTPS tích hợp sẵn - Tái tạo bộ nhớ đệm cứ mỗi 9 giờ thông qua cron - Hỗ trợ header X-Forwarded-For với cờ --trustProxy - Tương thích với các cấu hình reverse proxy (proxy ngược)\nTriển khai sản xuất:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed Phương pháp 2: Hiện thực bằng Python (pyseeder) Một triển khai thay thế do dự án PurpleI2P thực hiện: https://github.com/PurpleI2P/pyseeder pip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 Phương pháp 3: Triển khai bằng Docker (nền tảng container) Đối với các môi trường được container hóa, có một số triển khai sẵn sàng cho Docker:\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: Thêm dịch vụ onion của Tor và hỗ trợ IPFS Cấu hình proxy ngược Cấu hình nginx upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } Cấu hình Apache \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; Đăng ký và Điều phối Để đưa máy chủ reseed (máy chủ cung cấp dữ liệu khởi tạo để người dùng mới tham gia mạng) của bạn vào gói I2P chính thức:\nHoàn tất thiết lập và kiểm thử Gửi cả hai chứng chỉ (SU3 signing và TLS) cho reseed coordinator (điều phối viên khởi tạo nút mạng I2P ban đầu) Liên hệ: zzz@mail.i2p hoặc zzz@i2pmail.org Tham gia #i2p-dev trên IRC2P để phối hợp với các vận hành viên khác Thực tiễn vận hành tốt nhất Giám sát và ghi nhật ký Kích hoạt định dạng log Combined (tổng hợp) của Apache/nginx để phục vụ thống kê Thiết lập log rotation (luân phiên nhật ký) (nhật ký tăng dung lượng rất nhanh) Giám sát mức độ thành công khi tạo bundle (gói) và thời gian dựng lại Theo dõi mức sử dụng băng thông và các mẫu yêu cầu Không bao giờ công khai địa chỉ IP hoặc nhật ký truy cập chi tiết Lịch bảo trì Cứ mỗi 9 giờ: Xây dựng lại bộ đệm gói SU3 (tự động qua cron) Hàng tuần: Rà soát nhật ký để phát hiện các mẫu tấn công Hàng tháng: Cập nhật I2P router và reseed-tools Khi cần: Gia hạn chứng chỉ TLS (tự động hóa bằng Let\u0026rsquo;s Encrypt) Lựa chọn cổng Mặc định: 8443 (được khuyến nghị) Tùy chọn khác: Bất kỳ cổng nào trong khoảng 1024-49151 Cổng 443: Cần quyền root hoặc chuyển tiếp cổng (khuyến nghị chuyển hướng iptables) Ví dụ về chuyển tiếp cổng:\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 Các phương thức Reseed (tải dữ liệu khởi tạo mạng) thay thế Các tùy chọn bootstrap khác giúp người dùng trong các mạng bị hạn chế:\nReseed (quá trình tải dữ liệu khởi tạo mạng) dựa trên tệp Được giới thiệu trong phiên bản 0.9.16, reseeding dựa trên tệp (tái gieo dựa trên tệp) cho phép người dùng tải thủ công các gói RouterInfo. Phương pháp này đặc biệt hữu ích cho người dùng ở các khu vực bị kiểm duyệt, nơi các máy chủ reseed qua HTTPS bị chặn.\nQuy trình: 1. Một người liên hệ đáng tin cậy tạo một gói SU3 sử dụng router của họ 2. Gói được chuyển qua email, ổ USB, hoặc kênh out-of-band (ngoài băng) khác 3. Người dùng đặt i2pseeds.su3 trong thư mục cấu hình I2P 4. Router tự động phát hiện và xử lý gói khi khởi động lại\nTài liệu: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\nTrường hợp sử dụng: - Người dùng ở sau các tường lửa cấp quốc gia chặn các máy chủ reseed - Mạng biệt lập yêu cầu khởi tạo ban đầu thủ công - Môi trường thử nghiệm và phát triển\nReseeding (khởi tạo netDb ban đầu) qua proxy của Cloudflare Việc định tuyến lưu lượng reseed (lưu lượng khởi tạo mạng I2P) qua CDN của Cloudflare mang lại một số lợi ích cho người vận hành ở các khu vực có mức độ kiểm duyệt cao.\nLợi ích: - Địa chỉ IP của máy chủ gốc được ẩn khỏi máy khách - Bảo vệ DDoS thông qua hạ tầng của Cloudflare - Phân phối tải theo khu vực địa lý thông qua bộ nhớ đệm biên - Cải thiện hiệu năng cho các máy khách trên toàn cầu\nYêu cầu triển khai: - Cờ --trustProxy được bật trong reseed-tools - Proxy Cloudflare được bật cho bản ghi DNS - Xử lý header X-Forwarded-For đúng cách\nCác lưu ý quan trọng: - Các hạn chế cổng của Cloudflare được áp dụng (phải sử dụng các cổng được hỗ trợ) - Để đảm bảo tính nhất quán bundle (gói) theo từng máy khách, cần hỗ trợ X-Forwarded-For - Cấu hình SSL/TLS do Cloudflare quản lý\nTài liệu: https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/ Các chiến lược kháng kiểm duyệt Nghiên cứu của Nguyen Phong Hoang (USENIX FOCI 2019) xác định các phương thức bootstrap (khởi tạo ban đầu) bổ sung cho các mạng bị kiểm duyệt:\nCác nhà cung cấp lưu trữ đám mây Box, Dropbox, Google Drive, OneDrive: Lưu trữ tệp SU3 trên các liên kết công khai Ưu điểm: Khó bị chặn mà không làm gián đoạn các dịch vụ hợp pháp Hạn chế: Cần phân phối URL thủ công cho người dùng Phân phối IPFS Lưu trữ các gói reseed (khởi tạo kết nối ban đầu tới mạng I2P) trên InterPlanetary File System Lưu trữ định địa chỉ theo nội dung giúp ngăn chặn giả mạo Kháng chịu trước các nỗ lực gỡ bỏ Các dịch vụ Onion của Tor Reseed servers (máy chủ reseed: máy chủ cung cấp dữ liệu khởi tạo để tham gia mạng I2P) có thể truy cập qua các địa chỉ .onion Khó bị chặn dựa trên IP Yêu cầu trình khách Tor trên hệ thống của người dùng Tài liệu nghiên cứu: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/ Các quốc gia được biết là chặn I2P Tính đến năm 2025, các quốc gia sau được xác nhận là chặn máy chủ reseed của I2P (máy chủ cấp dữ liệu khởi đầu): - Trung Quốc - Iran - Oman - Qatar - Kuwait\nNgười dùng ở các khu vực này nên sử dụng các phương thức khởi tạo ban đầu thay thế hoặc các chiến lược reseeding (quy trình nạp danh sách nút ban đầu) chống kiểm duyệt.\nChi tiết giao thức dành cho người hiện thực Đặc tả Yêu cầu Reseed (khởi tạo dữ liệu mạng ban đầu) Hành vi của ứng dụng khách Lựa chọn máy chủ: Router duy trì danh sách URL reseed (máy chủ khởi tạo mạng I2P) cố định trong mã Chọn ngẫu nhiên: Máy khách chọn ngẫu nhiên máy chủ từ danh sách hiện có Định dạng yêu cầu: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: Nên mô phỏng các trình duyệt phổ biến (ví dụ, \u0026ldquo;Wget/1.11.4\u0026rdquo;) Logic thử lại: Nếu yêu cầu SU3 thất bại, chuyển sang phân tích cú pháp trang chỉ mục Xác thực chứng chỉ: Xác minh chứng chỉ TLS đối chiếu với kho tin cậy của hệ thống Xác thực chữ ký SU3: Xác minh chữ ký đối chiếu với các chứng chỉ reseed đã biết Hành vi của máy chủ Chọn gói: Chọn một tập con giả ngẫu nhiên của RouterInfos (thông tin router) từ netDb Theo dõi máy khách: Xác định yêu cầu theo IP nguồn (tôn trọng X-Forwarded-For) Tính nhất quán của gói: Trả về cùng một gói cho các yêu cầu lặp lại trong cửa sổ thời gian (thường 8–12 giờ) Tính đa dạng của gói: Trả về các gói khác nhau cho các máy khách khác nhau để tăng đa dạng mạng Content-Type: application/octet-stream hoặc application/x-i2p-reseed Định dạng tệp RouterInfo Mỗi tệp .dat trong gói reseed chứa một cấu trúc RouterInfo:\nQuy ước đặt tên tệp: routerInfo-{base64-hash}.dat - Hash (mã băm) dài 44 ký tự, dùng bảng ký tự base64 của I2P - Ví dụ: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat\nNội dung tệp: - RouterIdentity (định danh router) (băm router, khóa mã hóa, khóa ký) - Dấu thời gian công bố - Địa chỉ Router (IP, cổng, loại truyền tải) - Khả năng và tùy chọn của Router - Chữ ký bao trùm toàn bộ dữ liệu ở trên\nCác yêu cầu về đa dạng mạng Để ngăn chặn tập trung hóa mạng và cho phép phát hiện tấn công Sybil:\nKhông dump NetDb đầy đủ: Không bao giờ cung cấp toàn bộ RouterInfos (thông tin router) cho một máy khách duy nhất Lấy mẫu ngẫu nhiên: Mỗi gói chứa một tập con khác nhau của các peers (nút ngang hàng) khả dụng Kích thước gói tối thiểu: 75 RouterInfos (tăng so với giá trị ban đầu là 50) Kích thước gói tối đa: 100 RouterInfos Độ mới: RouterInfos nên còn mới (trong vòng 24 giờ kể từ khi được tạo) Các lưu ý về IPv6 Tình trạng hiện tại (2025): - Một số máy chủ reseed (máy chủ cung cấp dữ liệu khởi tạo cho I2P) cho thấy tình trạng không phản hồi qua IPv6 - Các máy khách nên ưu tiên hoặc buộc dùng IPv4 để đảm bảo độ tin cậy - Hỗ trợ IPv6 được khuyến nghị cho các triển khai mới nhưng không mang tính thiết yếu\nLưu ý triển khai: Khi cấu hình máy chủ dual-stack (hỗ trợ cả IPv4 và IPv6), hãy đảm bảo các địa chỉ lắng nghe của cả IPv4 và IPv6 hoạt động đúng, hoặc vô hiệu hóa IPv6 nếu không thể hỗ trợ đúng cách.\nCác cân nhắc bảo mật Mô hình mối đe dọa reseed protocol (giao thức reseed) bảo vệ chống lại:\nTấn công kẻ đứng giữa (MITM): Chữ ký RSA-4096 ngăn việc giả mạo gói Chia cắt mạng: Nhiều reseed servers (máy chủ cấp dữ liệu ban đầu cho người dùng tham gia mạng) độc lập ngăn việc tồn tại một điểm kiểm soát duy nhất Tấn công Sybil: Sự đa dạng của các gói hạn chế khả năng của kẻ tấn công trong việc cô lập người dùng Kiểm duyệt: Nhiều máy chủ và các phương thức thay thế cung cấp tính dự phòng Giao thức reseed (quy trình khởi tạo netDb ban đầu) KHÔNG bảo vệ chống lại:\nMáy chủ reseed (máy chủ cung cấp dữ liệu khởi tạo để tham gia I2P) bị xâm phạm: Nếu kẻ tấn công kiểm soát khóa riêng của chứng chỉ reseed Chặn mạng hoàn toàn: Nếu tất cả các phương thức reseed bị chặn trong một khu vực Giám sát dài hạn: Các yêu cầu reseed tiết lộ địa chỉ IP đang cố gắng tham gia I2P Quản lý chứng chỉ Bảo mật khóa riêng: - Lưu trữ khóa ký SU3 ngoại tuyến khi không sử dụng - Sử dụng mật khẩu mạnh để mã hóa khóa - Duy trì các bản sao lưu an toàn của khóa và chứng chỉ - Cân nhắc sử dụng mô-đun bảo mật phần cứng (HSMs) cho các triển khai có giá trị cao\nThu hồi chứng chỉ: - Danh sách thu hồi chứng chỉ (CRLs) được phân phối qua nguồn cấp tin - Chứng chỉ bị xâm phạm có thể được thu hồi bởi điều phối viên - Các router tự động cập nhật CRLs thông qua các bản cập nhật phần mềm\nGiảm thiểu tấn công Bảo vệ DDoS: - quy tắc fail2ban cho số lượng yêu cầu quá mức - Giới hạn tốc độ ở cấp máy chủ web - Giới hạn số kết nối cho mỗi địa chỉ IP - Cloudflare hoặc CDN tương tự để bổ sung một lớp\nNgăn chặn scraping (thu thập dữ liệu tự động): - Các gói khác nhau cho mỗi IP gửi yêu cầu - Lưu đệm gói theo thời gian cho mỗi IP - Ghi nhật ký các mẫu cho thấy dấu hiệu của các nỗ lực scraping - Phối hợp với những người vận hành khác về các cuộc tấn công đã phát hiện\nKiểm thử và Xác nhận Kiểm tra máy chủ reseed (máy chủ cung cấp dữ liệu netDb ban đầu) của bạn Phương pháp 1: Cài đặt Router mới Cài đặt I2P trên hệ thống mới cài đặt Thêm reseed URL (reseed: nguồn khởi tạo danh sách nút ban đầu) của bạn vào cấu hình Gỡ bỏ hoặc vô hiệu hóa các reseed URL khác Khởi động router và theo dõi nhật ký để kiểm tra reseed thành công Xác minh kết nối tới mạng trong vòng 5-10 phút Đầu ra nhật ký dự kiến:\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received Phương pháp 2: Xác minh SU3 thủ công # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) Phương pháp 3: checki2p Monitoring (dịch vụ giám sát checki2p) Dịch vụ tại https://checki2p.com/reseed thực hiện các kiểm tra tự động cứ mỗi 4 giờ đối với tất cả các máy chủ reseed (máy chủ khởi tạo ban đầu) I2P đã đăng ký. Điều này cung cấp:\nGiám sát tính sẵn sàng Chỉ số thời gian phản hồi Xác minh chứng chỉ TLS Xác minh chữ ký SU3 Dữ liệu uptime lịch sử Khi reseed (máy chủ khởi tạo mạng ban đầu) của bạn được đăng ký với dự án I2P, nó sẽ tự động xuất hiện trên checki2p trong vòng 24 giờ.\nKhắc phục sự cố thường gặp Vấn đề: \u0026ldquo;Unable to read signing key\u0026rdquo; khi chạy lần đầu - Giải pháp: Điều này là dự kiến. Trả lời \u0026lsquo;y\u0026rsquo; để tạo các khóa mới.\nVấn đề: Router không thể xác minh chữ ký - Nguyên nhân: Chứng chỉ không có trong kho tin cậy của Router - Giải pháp: Đặt chứng chỉ vào thư mục ~/.i2p/certificates/reseed/\nVấn đề: Cùng một gói được gửi đến các máy khách khác nhau - Nguyên nhân: Header X-Forwarded-For không được chuyển tiếp đúng cách - Giải pháp: Bật --trustProxy và cấu hình các header của proxy ngược\nSự cố: lỗi \u0026ldquo;Connection refused\u0026rdquo; - Nguyên nhân: Cổng không thể truy cập từ Internet - Giải pháp: Kiểm tra các quy tắc tường lửa, xác minh chuyển tiếp cổng\nVấn đề: Mức sử dụng CPU cao trong quá trình tái xây dựng gói - Nguyên nhân: Hành vi bình thường khi tạo hơn 350 biến thể SU3 - Giải pháp: Đảm bảo có đủ tài nguyên CPU, cân nhắc giảm tần suất tái xây dựng\nThông tin tham khảo Tài liệu chính thức Hướng dẫn cho người đóng góp Reseed (khởi tạo mạng I2P): /guides/creating-and-running-an-i2p-reseed-server/ Các yêu cầu về chính sách Reseed: /guides/reseed-policy/ Đặc tả SU3: /docs/specs/updates/ Kho công cụ Reseed: https://i2pgit.org/idk/reseed-tools Tài liệu công cụ Reseed: https://eyedeekay.github.io/reseed-tools/ Các triển khai thay thế PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Python WSGI reseeder: https://github.com/torbjo/i2p-reseeder Tài nguyên cộng đồng Diễn đàn I2P: https://i2pforum.net/ Kho lưu trữ Gitea: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: #i2p-dev trên IRC2P Giám sát trạng thái: https://checki2p.com/reseed Lịch sử phiên bản 0.9.14 (2014): Giới thiệu định dạng reseed (tải danh sách router ban đầu) SU3 0.9.16 (2014): Bổ sung reseeding dựa trên tệp 0.9.42 (2019): Bắt buộc tham số truy vấn Network ID 2.0.0 (2022): Giới thiệu giao thức truyền tải SSU2 2.4.0 (2024): Cô lập NetDB và cải tiến bảo mật 2.6.0 (2024): Các kết nối I2P-over-Tor bị chặn 2.10.0 (2025): Bản phát hành ổn định hiện tại (tính đến tháng 9 năm 2025) Tham chiếu loại chữ ký Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 **Tiêu chuẩn Reseed**: Loại 6 (RSA-SHA512-4096) là bắt buộc đối với các gói reseed (khởi tạo lại netDb). Tri ân Xin cảm ơn mọi người vận hành reseed (máy chủ cung cấp danh sách nút khởi đầu) vì đã giữ cho mạng luôn dễ truy cập và bền bỉ. Ghi nhận đặc biệt gửi tới các cộng tác viên và dự án sau:\nzzz: Nhà phát triển I2P lâu năm và điều phối viên reseed (khởi tạo ban đầu mạng I2P) idk: Người bảo trì hiện tại của reseed-tools và quản lý phát hành Nguyen Phong Hoang: Nghiên cứu về các chiến lược reseed chống kiểm duyệt PurpleI2P Team: Các triển khai và công cụ I2P thay thế checki2p: Dịch vụ giám sát tự động cho cơ sở hạ tầng reseed Hạ tầng reseed (cơ chế khởi tạo ban đầu để lấy danh sách nút) phi tập trung của mạng I2P là kết quả của nỗ lực hợp tác của hàng chục người vận hành trên toàn thế giới, bảo đảm rằng người dùng mới luôn có thể tìm được cách tham gia mạng lưới, bất kể kiểm duyệt tại địa phương hay rào cản kỹ thuật.\n","description":"Vận hành các dịch vụ reseed (cấp dữ liệu khởi tạo mạng) và các phương thức bootstrap (khởi động ban đầu) thay thế","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"Máy chủ Reseed (máy chủ cung cấp dữ liệu khởi động ban đầu cho netDb)","url":"/vi/docs/misc/reseed/"},{"categories":null,"content":" Trạng thái: Trang này cô đọng tài liệu \u0026ldquo;Low-level Cryptography Specification\u0026rdquo; (đặc tả mật mã cấp thấp) cũ. Các bản phát hành I2P hiện đại (2.10.0, tháng 10 năm 2025) đã hoàn tất việc chuyển đổi sang các nguyên thủy mật mã mới. Hãy sử dụng các đặc tả chuyên biệt như ECIES , Encrypted LeaseSets , NTCP2 , Red25519 , SSU2 , và Tunnel Creation (ECIES) để biết chi tiết triển khai.\nẢnh chụp nhanh quá trình phát triển Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) ## Mã hóa bất đối xứng X25519 (thuật toán trao đổi khóa Elliptic Curve Diffie-Hellman dựa trên đường cong elliptic Curve25519) Được dùng cho NTCP2, ECIES-X25519-AEAD-Ratchet (cơ chế ECIES dựa trên X25519 sử dụng AEAD và ratchet), SSU2, và khởi tạo tunnel dựa trên X25519. Cung cấp khóa gọn nhẹ, các phép toán thời gian hằng và tính bí mật chuyển tiếp thông qua Noise protocol framework (khung giao thức Noise). Đem lại mức bảo mật 128-bit với khóa 32 byte và trao đổi khóa hiệu quả. ElGamal (cũ) Được giữ lại để tương thích ngược với các routers cũ hơn. Hoạt động trên số nguyên tố 2048-bit Oakley Group 14 (RFC 3526) với phần tử sinh 2. Mã hóa các khóa phiên AES cùng IV (vector khởi tạo) thành các bản mã 514 byte. Thiếu mã hóa kèm xác thực và bí mật chuyển tiếp; tất cả các điểm cuối hiện đại đã chuyển sang ECIES. Mã hóa đối xứng ChaCha20/Poly1305 (thuật toán AEAD kết hợp mã dòng ChaCha20 và MAC Poly1305) Nguyên thủy mật mã xác thực mặc định được dùng xuyên suốt NTCP2, SSU2 và ECIES. Cung cấp bảo mật AEAD (mã hóa xác thực kèm dữ liệu) và hiệu năng cao ngay cả khi không có hỗ trợ phần cứng AES. Được triển khai theo RFC 7539 (khóa 256‑bit, nonce 96‑bit, thẻ 128‑bit). AES‑256/CBC (kiểu cũ) Vẫn được dùng cho mã hóa ở tầng tunnel, nơi cấu trúc mã khối của nó phù hợp với mô hình mã hóa phân tầng của I2P. Sử dụng PKCS#5 padding và các biến đổi IV theo từng chặng. Được lên kế hoạch đánh giá dài hạn nhưng vẫn an toàn về mặt mật mã. Chữ ký số Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer ## Băm và dẫn xuất khóa SHA‑256: Được dùng cho các khóa DHT (bảng băm phân tán), HKDF (hàm dẫn xuất khóa dựa trên HMAC), và chữ ký kế thừa (legacy). SHA‑512: Được EdDSA/RedDSA (thuật toán chữ ký số đường cong Edwards) sử dụng và được dùng trong các phép dẫn xuất HKDF của Noise (bộ khung giao thức bảo mật). HKDF‑SHA256: Dẫn xuất các khóa phiên trong ECIES (lược đồ mã hóa khóa công khai dựa trên đường cong elliptic), NTCP2 và SSU2. Các phép dẫn xuất SHA‑256 xoay vòng theo ngày bảo vệ các vị trí lưu trữ RouterInfo và LeaseSet trong netDb. Tóm tắt tầng vận chuyển Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) Cả hai cơ chế truyền tải cung cấp tính bí mật chuyển tiếp ở tầng liên kết và bảo vệ chống phát lại, sử dụng mẫu bắt tay Noise_XK. Mã hóa lớp Tunnel Tiếp tục sử dụng AES‑256/CBC cho mã hóa phân lớp theo từng hop. Các gateway đầu ra thực hiện giải mã AES lặp dần; mỗi hop mã hóa lại bằng khóa lớp của nó và khóa IV (vector khởi tạo). Mã hóa Double‑IV giúp giảm thiểu các cuộc tấn công tương quan và xác nhận. Việc chuyển sang AEAD (mã hóa xác thực có dữ liệu bổ sung) đang được nghiên cứu nhưng hiện chưa được lên kế hoạch. Mật mã hậu lượng tử I2P 2.10.0 giới thiệu mã hóa hậu lượng tử lai mang tính thử nghiệm. Được bật thủ công qua Trình quản lý Dịch vụ Ẩn để thử nghiệm. Kết hợp X25519 với một KEM (Key Encapsulation Mechanism - cơ chế bao bọc khóa) kháng lượng tử (chế độ lai). Không bật theo mặc định; dành cho mục đích nghiên cứu và đánh giá hiệu năng. Khung mở rộng Các định danh kiểu mã hóa và chữ ký cho phép hỗ trợ song song nhiều nguyên thủy mật mã. Các ánh xạ hiện tại bao gồm: Các kiểu mã hóa: 0 = ElGamal/AES+SessionTags, 4 = ECIES‑X25519‑AEAD‑Ratchet. Các kiểu chữ ký: 0 = DSA‑SHA1, 7 = EdDSA‑SHA512‑Ed25519, 11 = RedDSA‑SHA512‑Ed25519. Khuôn khổ này cho phép các nâng cấp trong tương lai, bao gồm cả các sơ đồ hậu‑lượng tử, mà không gây phân tách mạng. Sự kết hợp mật mã Lớp truyền tải: X25519 + ChaCha20/Poly1305 (khung Noise). Lớp tunnel: Mã hóa phân lớp AES‑256/CBC để đảm bảo ẩn danh. Đầu‑cuối: ECIES‑X25519‑AEAD‑Ratchet để đảm bảo tính bí mật và bí mật chuyển tiếp. Lớp cơ sở dữ liệu: Chữ ký EdDSA/RedDSA để đảm bảo tính xác thực. Các lớp này kết hợp lại để cung cấp phòng thủ nhiều lớp: ngay cả khi một lớp bị xâm phạm, các lớp khác vẫn duy trì tính bí mật và tính không thể liên kết.\nTóm tắt Ngăn xếp mật mã của I2P 2.10.0 tập trung vào:\nCurve25519 (X25519) cho trao đổi khóa ChaCha20/Poly1305 cho mã hóa đối xứng EdDSA / RedDSA cho chữ ký số SHA‑256 / SHA‑512 cho băm và dẫn xuất Các chế độ lai hậu lượng tử thử nghiệm cho khả năng tương thích về sau Các thuật toán kế thừa ElGamal, AES‑CBC và DSA vẫn được giữ lại để tương thích ngược, nhưng không còn được dùng trong các kênh truyền tải đang hoạt động hoặc các đường dẫn mã hóa.\n","description":"Tóm tắt các nguyên thủy mật mã đối xứng, bất đối xứng và chữ ký được sử dụng trên khắp I2P","id":"f5b93f818161e04d49735c3df52fcbdc","section":"docs","title":"Mật mã cấp thấp","url":"/vi/docs/specs/cryptography/"},{"categories":null,"content":"1. \u0026ldquo;Ẩn danh\u0026rdquo; có nghĩa là gì I2P cung cấp tính ẩn danh thực tế—không phải tàng hình. Tính ẩn danh được định nghĩa là mức độ khó khăn để đối thủ tìm hiểu thông tin bạn muốn giữ bí mật: bạn là ai, bạn ở đâu, hoặc bạn nói chuyện với ai. Tính ẩn danh tuyệt đối là không thể; thay vào đó, I2P hướng tới tính ẩn danh đủ mức trước các đối thủ thụ động và chủ động toàn cầu.\nTính ẩn danh của bạn phụ thuộc vào cách bạn cấu hình I2P, cách bạn chọn peer và subscription, và những ứng dụng nào bạn sử dụng.\n2. Sự phát triển về Mật mã và Truyền tải (2003 → 2025) Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental **Bộ mã hóa hiện tại (Noise XK):** - **X25519** cho trao đổi khóa - **ChaCha20/Poly1305 AEAD** cho mã hóa - **Ed25519 (EdDSA-SHA512)** cho chữ ký - **SHA-256** cho băm và HKDF - Tùy chọn **ML-KEM hybrids** cho thử nghiệm hậu lượng tử Tất cả các cách sử dụng ElGamal và AES-CBC đã bị loại bỏ. Truyền tải hoàn toàn sử dụng NTCP2 (TCP) và SSU2 (UDP); cả hai đều hỗ trợ IPv4/IPv6, forward secrecy (bảo mật chuyển tiếp), và obfuscation DPI (làm xáo trộn phát hiện gói tin sâu).\n3. Tóm tắt Kiến trúc Mạng Mixnet tự do định tuyến: Người gửi và người nhận mỗi bên tự định nghĩa tunnel của riêng mình. Không có cơ quan trung tâm: Định tuyến và đặt tên được phân tán; mỗi router duy trì lòng tin cục bộ. Tunnel một chiều: Inbound và outbound được tách biệt (thời gian tồn tại 10 phút). Exploratory tunnels: Mặc định 2 hops; client tunnels 2–3 hops. Floodfill routers: ~1 700 trong số ~55 000 nodes (~6 %) duy trì NetDB phân tán. Luân chuyển NetDB: Keyspace luân chuyển hàng ngày vào lúc nửa đêm UTC. Cô lập Sub-DB: Từ phiên bản 2.4.0, mỗi client và router sử dụng các cơ sở dữ liệu riêng biệt để ngăn chặn việc liên kết. 4. Các loại tấn công và phương thức phòng thủ hiện tại Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. --- 5. Cơ sở dữ liệu mạng hiện đại (NetDB) Các thông tin cốt lõi (vẫn chính xác): - DHT Kademlia được sửa đổi để lưu trữ RouterInfo và LeaseSets. - Băm khóa SHA-256; truy vấn song song đến 2 floodfills gần nhất với thời gian chờ 10 giây. - Thời gian tồn tại của LeaseSet ≈ 10 phút (LeaseSet2) hoặc 18 giờ (MetaLeaseSet).\nCác loại mới (từ phiên bản 0.9.38): - LeaseSet2 (Loại 3) – hỗ trợ nhiều kiểu mã hóa, có dấu thời gian. - EncryptedLeaseSet2 (Loại 5) – destination được che dấu cho các dịch vụ riêng tư (xác thực DH hoặc PSK). - MetaLeaseSet (Loại 7) – hỗ trợ nhiều địa chỉ và thời gian hết hạn mở rộng.\nNâng cấp bảo mật quan trọng – Cô lập Sub-DB (2.4.0): - Ngăn chặn liên kết router↔client. - Mỗi client và router sử dụng các phân đoạn netDb riêng biệt. - Đã được xác minh và kiểm toán (2.5.0).\n6. Chế độ Ẩn và Định tuyến Hạn chế Chế độ Ẩn (Hidden Mode): Đã triển khai (tự động kích hoạt ở các quốc gia nghiêm ngặt theo điểm số Freedom House).\nRouter không công bố RouterInfo hoặc định tuyến lưu lượng. Định tuyến Hạn chế (Restricted Routes): Đã triển khai một phần (chỉ tunnel tin cậy cơ bản).\nĐịnh tuyến ngang hàng tin cậy toàn diện vẫn đang được lên kế hoạch (3.0+). Đánh đổi: Quyền riêng tư tốt hơn ↔ giảm đóng góp vào năng lực mạng.\n7. Tấn công DoS và Floodfill Lịch sử: Nghiên cứu năm 2013 của UCSB cho thấy khả năng xảy ra các cuộc tấn công Eclipse và chiếm quyền Floodfill. Các biện pháp phòng thủ hiện đại bao gồm: - Xoay vòng keyspace hàng ngày. - Giới hạn Floodfill ≈ 500, một router mỗi /16. - Độ trễ xác minh lưu trữ ngẫu nhiên hóa. - Ưu tiên router mới hơn (2.6.0). - Sửa lỗi đăng ký tự động (2.9.0). - Định tuyến nhận biết tắc nghẽn và điều tiết lease (2.4.0+).\nCác cuộc tấn công floodfill vẫn có thể xảy ra về mặt lý thuyết nhưng khó thực hiện hơn trên thực tế.\n8. Phân tích lưu lượng và kiểm duyệt Lưu lượng I2P khó xác định: không có cổng cố định, không có bắt tay văn bản rõ, và có padding ngẫu nhiên. Các gói tin NTCP2 và SSU2 bắt chước các giao thức phổ biến và sử dụng kỹ thuật che giấu header ChaCha20. Các chiến lược padding còn cơ bản (kích thước ngẫu nhiên), lưu lượng giả không được triển khai (tốn kém). Các kết nối từ nút thoát Tor bị chặn kể từ phiên bản 2.6.0 (để bảo vệ tài nguyên).\n9. Các hạn chế liên tục (đã được thừa nhận) Tương quan thời gian cho các ứng dụng độ trễ thấp vẫn là rủi ro cơ bản. Tấn công giao điểm vẫn mạnh mẽ chống lại các đích công khai đã biết. Tấn công Sybil thiếu phòng thủ hoàn chỉnh (HashCash chưa được thực thi). Lưu lượng tốc độ không đổi và độ trễ đáng kể vẫn chưa được triển khai (dự kiến 3.0). Sự minh bạch về những giới hạn này là có chủ đích — nó ngăn người dùng đánh giá quá cao tính ẩn danh.\n10. Thống kê Mạng (2025) ~55 000 router hoạt động trên toàn thế giới (↑ từ 7 000 vào năm 2013) ~1 700 floodfill router (~6 %) 95 % tham gia định tuyến tunnel theo mặc định Các mức băng thông: K (\u0026lt;12 KB/s) → X (\u0026gt;2 MB/s) Tốc độ floodfill tối thiểu: 128 KB/s Bảng điều khiển Router yêu cầu Java 8+, dự kiến Java 17+ cho chu kỳ tiếp theo 11. Phát triển và Tài nguyên Trung tâm Trang chính thức: geti2p.net Tài liệu: Documentation Kho lưu trữ Debian: https://deb.i2pgit.org ( thay thế deb.i2p2.de vào tháng 10/2023 ) Mã nguồn: https://i2pgit.org/I2P_Developers/i2p.i2p (Gitea) + bản sao GitHub Tất cả các bản phát hành đều là container SU3 có chữ ký (RSA-4096, khóa zzz/str4d) Không có danh sách gửi thư hoạt động; cộng đồng qua https://i2pforum.net và IRC2P. Chu kỳ cập nhật: phát hành bản ổn định mỗi 6–8 tuần. 12. Tóm tắt các Cải tiến Bảo mật từ phiên bản 0.8.x Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing --- 13. Các Công Việc Chưa Giải Quyết hoặc Đã Lên Kế Hoạch Định tuyến hạn chế toàn diện (định tuyến ngang hàng tin cậy) → lên kế hoạch 3.0. Độ trễ/gộp lô đáng kể để chống phân tích thời gian → lên kế hoạch 3.0. Padding nâng cao và lưu lượng giả → chưa triển khai. Xác minh danh tính HashCash → cơ sở hạ tầng đã có nhưng chưa kích hoạt. Thay thế DHT bằng R5N → chỉ mới đề xuất. 14. Tài liệu Tham khảo Chính Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) Tài liệu chính thức của I2P 15. Kết luận Mô hình ẩn danh cốt lõi của I2P đã tồn tại được hai thập kỷ: hy sinh tính duy nhất toàn cầu để đổi lấy sự tin cậy và bảo mật cục bộ. Từ ElGamal đến X25519, NTCP đến NTCP2, và từ reseed thủ công đến cô lập Sub-DB, dự án đã phát triển trong khi vẫn duy trì triết lý phòng thủ theo chiều sâu và minh bạch.\nNhiều cuộc tấn công vẫn có thể xảy ra về mặt lý thuyết đối với bất kỳ mixnet độ trễ thấp nào, nhưng việc I2P liên tục tăng cường bảo mật khiến chúng ngày càng khó thực hiện hơn. Mạng lưới hiện lớn hơn, nhanh hơn và an toàn hơn bao giờ hết — nhưng vẫn trung thực về các giới hạn của nó.\n","description":"Danh mục các cuộc tấn công được xem xét trong thiết kế của I2P và các biện pháp giảm thiểu đã triển khai","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"Mô hình Mối đe dọa I2P","url":"/vi/docs/overview/threat-model/"},{"categories":null,"content":"Tích hợp I2P vào ứng dụng của bạn là một cách mạnh mẽ để thu hút người dùng—nhưng chỉ khi router được cấu hình một cách có trách nhiệm.\n1. Phối hợp với các nhóm Router Liên hệ với các nhà phát triển Java I2P và i2pd trước khi tích hợp. Họ có thể xem xét các cài đặt mặc định của bạn và chỉ ra các vấn đề tương thích. Chọn router phù hợp với stack của bạn: Java/Scala → Java I2P C/C++ → i2pd Các ngôn ngữ khác → tích hợp một router và kết nối bằng SAM v3 hoặc I2CP Xác minh các điều khoản phân phối lại cho các tệp nhị phân router và các phụ thuộc (Java runtime, ICU, v.v.). 2. Cấu hình Mặc định Được Khuyến nghị Hướng tới \u0026ldquo;đóng góp nhiều hơn mức tiêu thụ\u0026rdquo;. Các cài đặt mặc định hiện đại ưu tiên sức khhoẻ và sự ổn định của mạng lưới.\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. ### Các Tunnel Tham Gia Vẫn Là Yếu Tố Quan Trọng Không vô hiệu hóa các tunnel tham gia.\nCác router không chuyển tiếp hoạt động kém hiệu quả hơn. Mạng lưới phụ thuộc vào việc chia sẻ băng thông tự nguyện. Cover traffic (lưu lượng được chuyển tiếp) cải thiện tính ẩn danh. Yêu cầu tối thiểu chính thức: - Băng thông chia sẻ: ≥ 12 KB/s - Tự động tham gia floodfill: ≥ 128 KB/s - Khuyến nghị: 2 tunnel vào / 2 tunnel ra (mặc định của Java I2P)\n3. Tính bền vững và Reseeding (làm mới dữ liệu) Các thư mục trạng thái lâu dài (netDb/, profiles, certificates) phải được giữ nguyên giữa các lần chạy.\nKhông có tính năng lưu trữ lâu dài, người dùng của bạn sẽ kích hoạt reseed mỗi lần khởi động—làm giảm hiệu suất và tăng tải trên các máy chủ reseed.\nNếu không thể duy trì dữ liệu lâu dài (ví dụ: container hoặc cài đặt tạm thời):\nĐóng gói 1.000–2.000 router info trong trình cài đặt. Vận hành một hoặc nhiều máy chủ reseed tùy chỉnh để giảm tải cho các máy chủ công cộng. Các biến cấu hình: - Thư mục gốc: i2p.dir.base - Thư mục cấu hình: i2p.dir.config - Bao gồm certificates/ cho việc reseeding.\n4. Bảo mật và Rủi ro Tiết lộ Giữ router console (127.0.0.1:7657) chỉ truy cập cục bộ. Sử dụng HTTPS nếu cần công khai giao diện người dùng ra bên ngoài. Vô hiệu hóa SAM/I2CP bên ngoài trừ khi thực sự cần thiết. Xem xét các plugin đi kèm—chỉ tích hợp những gì ứng dụng của bạn hỗ trợ. Luôn bao gồm xác thực cho quyền truy cập console từ xa. Tính năng bảo mật được giới thiệu từ phiên bản 2.5.0: - Cách ly NetDB giữa các ứng dụng (2.4.0+) - Giảm thiểu DoS và danh sách chặn Tor (2.5.1) - Khả năng chống thăm dò NTCP2 (2.9.0) - Cải tiến lựa chọn floodfill router (2.6.0+)\n5. Các API được hỗ trợ (2025) API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. Tất cả tài liệu chính thức được đặt tại `/docs/api/` — đường dẫn cũ `/spec/samv3/` **không** tồn tại. 6. Mạng và Cổng Các cổng mặc định thông thường: - 4444 – HTTP Proxy - 4445 – HTTPS Proxy - 7654 – I2CP - 7656 – SAM Bridge - 7657 – Router Console - 7658 – Trang web I2P cục bộ - 6668 – IRC Proxy - 9000–31000 – Cổng router ngẫu nhiên (UDP/TCP inbound)\nRouter chọn một cổng đầu vào ngẫu nhiên khi chạy lần đầu. Chuyển tiếp cổng giúp cải thiện hiệu suất, nhưng UPnP có thể tự động xử lý việc này.\n7. Các Thay Đổi Hiện Đại (2024–2025) Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). ## 8. Trải nghiệm người dùng và Kiểm thử Truyền đạt I2P làm gì và tại sao băng thông được chia sẻ. Cung cấp chẩn đoán router (băng thông, tunnel, trạng thái reseed). Kiểm tra các gói trên Windows, macOS và Linux (bao gồm cả RAM thấp). Xác minh khả năng tương tác với cả peer Java I2P và i2pd. Kiểm tra khả năng phục hồi sau khi mất kết nối mạng và thoát không an toàn. 9. Tài Nguyên Cộng Đồng Diễn đàn: i2pforum.net hoặc http://i2pforum.i2p bên trong I2P. Mã nguồn: i2pgit.org/I2P_Developers/i2p.i2p . IRC (mạng Irc2P): #i2p-dev, #i2pd. #i2papps chưa xác minh; có thể không tồn tại. Làm rõ mạng nào (Irc2P hay ilita.i2p) lưu trữ kênh của bạn. Nhúng một cách có trách nhiệm có nghĩa là cân bằng giữa trải nghiệm người dùng, hiệu suất và đóng góp cho mạng lưới. Sử dụng các giá trị mặc định này, duy trì đồng bộ với các nhà bảo trì router và kiểm tra dưới tải thực tế trước khi phát hành.\n","description":"Hướng dẫn thực tiễn cập nhật để tích hợp I2P router vào ứng dụng của bạn một cách có trách nhiệm","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"Nhúng I2P vào Ứng dụng của Bạn","url":"/vi/docs/applications/embedding/"},{"categories":null,"content":"Tại sao cần viết mã lệnh chuyên biệt cho I2P? Có nhiều cách để sử dụng các ứng dụng trong I2P. Sử dụng I2PTunnel , bạn có thể dùng các ứng dụng thông thường mà không cần lập trình hỗ trợ I2P một cách tường minh. Cách này rất hiệu quả cho các tình huống client-server, khi bạn cần kết nối đến một trang web duy nhất. Bạn chỉ cần tạo một tunnel bằng I2PTunnel để kết nối đến trang web đó, như được minh họa trong Hình 1.\nNếu ứng dụng của bạn được phân tán, nó sẽ yêu cầu kết nối đến một lượng lớn các peer. Khi sử dụng I2PTunnel, bạn sẽ cần tạo một tunnel mới cho mỗi peer mà bạn muốn liên hệ, như được hiển thị trong Hình 2. Quá trình này tất nhiên có thể được tự động hóa, nhưng việc chạy nhiều phiên bản I2PTunnel tạo ra một lượng lớn chi phí hoạt động. Ngoài ra, với nhiều giao thức, bạn sẽ cần buộc mọi người sử dụng cùng một tập hợp các cổng cho tất cả các peer — ví dụ: nếu bạn muốn chạy DCC chat một cách đáng tin cậy, mọi người cần thống nhất rằng cổng 10001 là Alice, cổng 10002 là Bob, cổng 10003 là Charlie, v.v., vì giao thức bao gồm thông tin cụ thể của TCP/IP (host và port).\nCác ứng dụng mạng thông thường thường gửi rất nhiều dữ liệu bổ sung có thể được sử dụng để xác định người dùng. Tên máy chủ, số cổng, múi giờ, bộ ký tự, v.v. thường được gửi đi mà không thông báo cho người dùng. Do đó, việc thiết kế giao thức mạng với tính ẩn danh được đặt làm trọng tâm có thể tránh làm lộ danh tính người dùng.\nNgoài ra còn có các cân nhắc về hiệu suất cần xem xét khi quyết định cách tương tác trên I2P. Thư viện streaming và các thành phần được xây dựng trên đó hoạt động với các bước bắt tay tương tự như TCP, trong khi các giao thức I2P cốt lõi (I2NP và I2CP) hoàn toàn dựa trên thông điệp (giống như UDP hoặc trong một số trường hợp là raw IP). Điểm khác biệt quan trọng là với I2P, việc giao tiếp diễn ra qua một mạng lưới dài và rộng — mỗi thông điệp đầu cuối sẽ có độ trễ đáng kể, nhưng có thể chứa payload lên đến vài KB. Một ứng dụng chỉ cần một yêu cầu và phản hồi đơn giản có thể loại bỏ mọi trạng thái và giảm độ trễ phát sinh từ các bước bắt tay khởi động và ngắt kết nối bằng cách sử dụng datagram (nỗ lực tối đa) mà không cần lo lắng về việc phát hiện MTU hoặc phân mảnh thông điệp.\nFigure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. Tóm lại, có một số lý do để viết mã riêng cho I2P: Tạo một lượng lớn các instance I2PTunnel tiêu tốn một lượng tài nguyên đáng kể, điều này gây vấn đề cho các ứng dụng phân tán (một tunnel mới được yêu cầu cho mỗi peer). Các giao thức mạng thông thường thường gửi rất nhiều dữ liệu bổ sung có thể được sử dụng để xác định người dùng. Lập trình đặc biệt cho I2P cho phép tạo ra một giao thức mạng không làm rò rỉ thông tin như vậy, giữ cho người dùng ẩn danh và an toàn. Các giao thức mạng được thiết kế để sử dụng trên internet thông thường có thể không hiệu quả trên I2P, một mạng có độ trễ cao hơn nhiều. I2P hỗ trợ một giao diện plugins tiêu chuẩn cho các nhà phát triển để các ứng dụng có thể dễ dàng tích hợp và phân phối.\nCác ứng dụng được viết bằng Java và có thể truy cập/chạy được thông qua giao diện HTML qua webapps/app.war tiêu chuẩn có thể được xem xét để đưa vào bản phân phối I2P.\nCác Khái Niệm Quan Trọng Có một số thay đổi cần phải điều chỉnh khi sử dụng I2P:\nĐích đến Một ứng dụng chạy trên I2P gửi và nhận tin nhắn từ một điểm cuối duy nhất được bảo mật bằng mã hóa — một \u0026ldquo;destination\u0026rdquo; (đích đến). Về mặt TCP hoặc UDP, một destination có thể (phần lớn) được coi là tương đương với một cặp tên máy chủ cộng với số cổng, mặc dù có một số khác biệt.\nBản thân I2P destination là một cấu trúc mật mã — tất cả dữ liệu gửi đến nó đều được mã hóa như thể có triển khai IPsec toàn cầu với vị trí (ẩn danh) của điểm cuối được ký như thể có triển khai DNSSEC toàn cầu. I2P destinations là các định danh di động — chúng có thể được chuyển từ I2P router này sang router khác (hoặc thậm chí có thể \u0026ldquo;multihome\u0026rdquo; — hoạt động trên nhiều router cùng lúc). Điều này khá khác biệt so với thế giới TCP hoặc UDP, nơi một điểm cuối duy nhất (cổng) phải ở trên một máy chủ duy nhất. I2P destinations khá lớn và phức tạp — bên trong, chúng chứa một khóa công khai ElGamal 2048 bit để mã hóa, một khóa công khai DSA 1024 bit để ký, và một chứng chỉ có kích thước biến đổi, có thể chứa proof of work (bằng chứng công việc) hoặc dữ liệu làm mờ. Hiện có các cách để tham chiếu đến những destination lớn và khó đọc này bằng các tên ngắn và dễ nhớ (ví dụ: \u0026ldquo;irc.duck.i2p\u0026rdquo;), nhưng các kỹ thuật đó không đảm bảo tính duy nhất toàn cục (vì chúng được lưu trữ cục bộ trong cơ sở dữ liệu trên máy của mỗi người) và cơ chế hiện tại không đặc biệt khả mở rộng hay an toàn (các cập nhật cho danh sách host được quản lý bằng cách \u0026ldquo;đăng ký\u0026rdquo; các dịch vụ đặt tên). Có thể một ngày nào đó sẽ có hệ thống đặt tên an toàn, dễ đọc với con người, khả mở rộng và duy nhất toàn cục, nhưng các ứng dụng không nên phụ thuộc vào việc nó đã sẵn có. Thông tin chi tiết về hệ thống đặt tên đã có sẵn.\nMặc dù hầu hết các ứng dụng không cần phân biệt giao thức và cổng, I2P vẫn hỗ trợ chúng. Các ứng dụng phức tạp có thể chỉ định giao thức, cổng nguồn và cổng đích trên cơ sở mỗi thông điệp, để ghép kênh lưu lượng trên một destination duy nhất. Xem trang datagram để biết chi tiết. Các ứng dụng đơn giản hoạt động bằng cách lắng nghe \u0026ldquo;tất cả các giao thức\u0026rdquo; trên \u0026ldquo;tất cả các cổng\u0026rdquo; của một destination.\nTính ẩn danh và bảo mật I2P có mã hóa đầu cuối đầu cuối minh bạch và xác thực cho tất cả dữ liệu được truyền qua mạng — nếu Bob gửi đến destination của Alice, chỉ có destination của Alice mới có thể nhận được, và nếu Bob đang sử dụng thư viện datagrams hoặc streaming, Alice biết chắc chắn rằng destination của Bob là người đã gửi dữ liệu.\nTất nhiên, I2P ẩn danh một cách minh bạch dữ liệu được gửi giữa Alice và Bob, nhưng nó không làm gì để ẩn danh nội dung của những gì họ gửi. Ví dụ, nếu Alice gửi cho Bob một biểu mẫu có tên đầy đủ, giấy tờ tùy thân của chính phủ và số thẻ tín dụng của cô ấy, thì I2P không thể làm gì được. Do đó, các giao thức và ứng dụng nên lưu ý thông tin nào họ đang cố gắng bảo vệ và thông tin nào họ sẵn sàng để lộ.\nI2P Datagram Có Thể Lên Đến Vài KB Các ứng dụng sử dụng datagram I2P (dù là raw hay repliable) về cơ bản có thể được hiểu theo khái niệm của UDP — các datagram không có thứ tự, tối ưu nhất có thể và phi kết nối — nhưng không giống như UDP, các ứng dụng không cần lo lắng về việc phát hiện MTU và có thể đơn giản gửi đi các datagram lớn. Mặc dù giới hạn trên danh nghĩa là 32 KB, thông điệp được phân mảnh để truyền tải, do đó làm giảm độ tin cậy của toàn bộ. Hiện tại không khuyến nghị sử dụng datagram trên khoảng 10 KB. Xem trang datagram để biết chi tiết. Đối với nhiều ứng dụng, 10 KB dữ liệu là đủ cho toàn bộ một yêu cầu hoặc phản hồi, cho phép chúng hoạt động minh bạch trong I2P như một ứng dụng giống UDP mà không cần phải viết mã phân mảnh, gửi lại, v.v.\nTùy Chọn Phát Triển Có nhiều cách để gửi dữ liệu qua I2P, mỗi cách có ưu và nhược điểm riêng. Thư viện streaming là giao diện được khuyến nghị, được sử dụng bởi phần lớn các ứng dụng I2P.\nThư viện Streaming Thư viện streaming đầy đủ hiện là giao diện tiêu chuẩn. Nó cho phép lập trình sử dụng các socket giống TCP, như được giải thích trong Hướng dẫn phát triển Streaming .\nBOB BOB là Basic Open Bridge , cho phép ứng dụng bằng bất kỳ ngôn ngữ nào thực hiện kết nối streaming đến và từ I2P. Tại thời điểm hiện tại, nó chưa hỗ trợ UDP, nhưng hỗ trợ UDP đang được lên kế hoạch trong tương lai gần. BOB cũng chứa một số công cụ, chẳng hạn như tạo khóa destination và xác minh rằng một địa chỉ tuân thủ các đặc tả của I2P. Thông tin cập nhật và các ứng dụng sử dụng BOB có thể được tìm thấy tại I2P Site này.\nSAM, SAM V2, SAM V3 SAM không được khuyến nghị. SAM V2 chấp nhận được, SAM V3 được khuyến nghị.\nSAM là giao thức Simple Anonymous Messaging (Nhắn tin Ẩn danh Đơn giản), cho phép một ứng dụng được viết bằng bất kỳ ngôn ngữ nào giao tiếp với cầu nối SAM thông qua một socket TCP thông thường và để cầu nối đó ghép kênh tất cả lưu lượng I2P của nó, phối hợp minh bạch việc mã hóa/giải mã và xử lý dựa trên sự kiện. SAM hỗ trợ ba kiểu hoạt động:\nstreams, khi Alice và Bob muốn gửi dữ liệu cho nhau một cách đáng tin cậy và theo thứ tự repliable datagrams, khi Alice muốn gửi cho Bob một tin nhắn mà Bob có thể trả lời raw datagrams, khi Alice muốn tận dụng tối đa băng thông và hiệu suất có thể, và Bob không quan tâm liệu người gửi dữ liệu có được xác thực hay không (ví dụ: dữ liệu được truyền tải tự xác thực) SAM V3 hướng đến cùng mục tiêu với SAM và SAM V2, nhưng không yêu cầu ghép kênh/tách kênh. Mỗi luồng I2P được xử lý bởi socket riêng giữa ứng dụng và cầu nối SAM. Ngoài ra, các gói dữ liệu có thể được gửi và nhận bởi ứng dụng thông qua truyền thông datagram với cầu nối SAM.\nSAM V2 là phiên bản mới được sử dụng bởi imule, khắc phục một số vấn đề trong SAM .\nSAM V3 được sử dụng bởi imule kể từ phiên bản 1.4.0.\nI2PTunnel Ứng dụng I2PTunnel cho phép các ứng dụng xây dựng các tunnel giống TCP cụ thể tới các peer bằng cách tạo các ứng dụng I2PTunnel \u0026lsquo;client\u0026rsquo; (lắng nghe trên một cổng cụ thể và kết nối đến một destination I2P cụ thể bất cứ khi nào có socket mở đến cổng đó) hoặc các ứng dụng I2PTunnel \u0026lsquo;server\u0026rsquo; (lắng nghe một destination I2P cụ thể và bất cứ khi nào nhận được kết nối I2P mới, nó sẽ outproxy đến một máy chủ TCP/cổng cụ thể). Các luồng này là 8-bit clean và được xác thực và bảo mật thông qua cùng thư viện streaming mà SAM sử dụng, nhưng có một chi phí không nhỏ liên quan đến việc tạo nhiều instance I2PTunnel riêng biệt, vì mỗi instance có destination I2P riêng và bộ tunnel, khóa, v.v. riêng của chúng.\nSOCKS I2P hỗ trợ proxy SOCKS V4 và V5. Các kết nối outbound hoạt động tốt. Chức năng inbound (máy chủ) và UDP có thể chưa hoàn thiện và chưa được kiểm tra đầy đủ.\nMinistreaming Đã xóa\nTrước đây có một thư viện \u0026ldquo;ministreaming\u0026rdquo; đơn giản, nhưng bây giờ ministreaming.jar chỉ chứa các giao diện cho thư viện streaming đầy đủ.\nDatagram Được khuyến nghị cho các ứng dụng kiểu UDP\nThư viện Datagram cho phép gửi các gói tin kiểu UDP. Có thể sử dụng:\nDatagram có thể trả lời Datagram thô I2CP Không khuyến nghị\nI2CP là một giao thức độc lập với ngôn ngữ lập trình, nhưng để triển khai thư viện I2CP bằng ngôn ngữ khác ngoài Java thì cần phải viết một lượng mã nguồn đáng kể (các thủ tục mã hóa, xử lý tuần tự hóa đối tượng, xử lý thông điệp không đồng bộ, v.v.). Mặc dù có thể viết thư viện I2CP bằng C hoặc ngôn ngữ khác, nhưng nhiều khả năng sẽ hữu ích hơn khi sử dụng thư viện SAM bằng C.\nỨng dụng Web I2P đi kèm với máy chủ web Jetty, và việc cấu hình để sử dụng máy chủ Apache thay thế rất đơn giản. Bất kỳ công nghệ ứng dụng web tiêu chuẩn nào cũng có thể hoạt động.\nBắt Đầu Phát Triển — Hướng Dẫn Đơn Giản Phát triển ứng dụng sử dụng I2P yêu cầu một bản cài đặt I2P đang hoạt động và một môi trường phát triển theo lựa chọn của bạn. Nếu bạn đang sử dụng Java, bạn có thể bắt đầu phát triển với streaming library hoặc datagram library. Khi sử dụng ngôn ngữ lập trình khác, có thể sử dụng SAM hoặc BOB.\nPhát triển với Thư viện Streaming Dưới đây là phiên bản được cắt gọn và hiện đại hóa của ví dụ trong trang gốc. Để xem ví dụ đầy đủ, hãy xem trang legacy hoặc các ví dụ Java của chúng tôi trong codebase.\n// Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\u0026#34;Received: \u0026#34; + s); } Ví dụ code: máy chủ cơ bản nhận dữ liệu.\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\u0026#34;Hello I2P!\\n\u0026#34;); bw.flush(); Ví dụ mã: client kết nối và gửi một dòng.\n","description":"Tại sao nên viết ứng dụng dành riêng cho I2P, các khái niệm chính, tùy chọn phát triển và hướng dẫn bắt đầu đơn giản","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"Phát triển Ứng dụng","url":"/vi/docs/develop/applications/"},{"categories":null,"content":" Trạng thái: Đã cập nhật đến I2P 2.10.0 (tháng 10 năm 2025). Danh sách này tổng hợp tất cả các cổng đang hoạt động, đã ngừng sử dụng và được dành riêng được sử dụng bởi I2P Java Router, i2pd và các plugin liên quan. Tất cả các cổng được liệt kê theo thứ tự số để đảm bảo nhất quán.\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. ## Ghi chú về Triển khai Tất cả các cổng dưới 9000 (ngoại trừ 8887) mặc định bind đến 127.0.0.1 vì lý do bảo mật. Cổng mạng của router (9151–30777) phải mở ra internet để tham gia đầy đủ. i2pd sử dụng hầu hết các phân bổ tương tự để tương thích (7070 console, 7654 I2CP, 7656/7655 SAM). Các nhà phát triển plugin nên phối hợp phân bổ mới thông qua cộng đồng I2P để tránh xung đột. ","description":"Tài liệu tham khảo toàn diện về phân bổ cổng I2P, cổng plugin và các dải cổng được dành riêng.","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"Phân Bổ Cổng","url":"/vi/docs/overview/ports/"},{"categories":null,"content":" Không còn được khuyến nghị: SAM v1 chỉ được giữ lại để tham khảo lịch sử. Các ứng dụng mới nên sử dụng SAM v3 hoặc BOB . Cầu nối ban đầu chỉ hỗ trợ các đích DSA-SHA1 và một tập tùy chọn hạn chế.\nThư viện Cây mã nguồn Java I2P vẫn bao gồm các bindings (thư viện liên kết ngôn ngữ) cũ cho C, C#, Perl và Python. Chúng không còn được bảo trì và chủ yếu được phát hành kèm để duy trì khả năng tương thích cho mục đích lưu trữ.\nĐàm phán phiên bản Các máy khách kết nối qua TCP (mặc định 127.0.0.1:7656) và trao đổi:\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 Kể từ Java I2P 0.9.14, tham số MIN là tùy chọn và cả MIN/MAX chấp nhận dạng một chữ số (\u0026quot;3\u0026quot; v.v.) đối với các bridge (nút cầu nối) đã nâng cấp.\nTạo phiên SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name tải hoặc tạo một mục trong sam.keys; TRANSIENT luôn tạo một đích tạm thời. STYLE chọn luồng ảo (giống TCP), datagram có chữ ký, hoặc datagram thô. DIRECTION chỉ áp dụng cho các phiên luồng; mặc định là BOTH. Các cặp khóa/giá trị bổ sung được chuyển tiếp như các tùy chọn I2CP (ví dụ, tunnels.quantityInbound=3). Cầu nối phản hồi như sau:\nSESSION STATUS RESULT=OK DESTINATION=name Khi gặp lỗi, sẽ trả về DUPLICATED_DEST, I2P_ERROR hoặc INVALID_KEY kèm theo một thông báo tùy chọn.\nĐịnh dạng thông điệp Các thông điệp SAM ở dạng ASCII một dòng, với các cặp khóa/giá trị được phân tách bằng khoảng trắng. Các khóa sử dụng UTF‑8; các giá trị có thể được đặt trong dấu ngoặc kép nếu chúng chứa khoảng trắng. Không có escaping (cơ chế thêm ký tự thoát) được định nghĩa.\nCác loại liên lạc:\nLuồng – được chuyển tiếp thông qua I2P streaming library (thư viện streaming của I2P) Gói tin có thể hồi đáp – payload (nội dung dữ liệu) đã được ký (Datagram1) Gói tin thô – payload chưa được ký (Datagram RAW) Các tùy chọn được bổ sung trong 0.9.14 DEST GENERATE chấp nhận SIGNATURE_TYPE=... (cho phép Ed25519, v.v.) HELLO VERSION xem MIN là tùy chọn và chấp nhận chuỗi phiên bản một chữ số Khi nào nên sử dụng SAM v1 (API Simple Anonymous Messaging của I2P) Chỉ nhằm bảo đảm khả năng tương tác với phần mềm cũ không thể cập nhật. Đối với mọi phát triển mới, hãy sử dụng:\nSAM v3 để truy cập stream/datagram đầy đủ tính năng BOB để quản lý Destination (điểm đích) (vẫn còn hạn chế, nhưng hỗ trợ nhiều tính năng hiện đại hơn) Tài liệu tham khảo SAM v2 SAM v3 Đặc tả Datagram Giao thức truyền phát SAM v1 đã đặt nền tảng cho việc phát triển ứng dụng không phụ thuộc router, nhưng hệ sinh thái đã tiến xa hơn. Hãy xem tài liệu này như một công cụ hỗ trợ khả năng tương thích, thay vì một điểm khởi đầu.\n","description":"Giao thức Simple Anonymous Messaging (gửi tin nhắn ẩn danh đơn giản) dạng cũ (không còn được khuyến nghị sử dụng)","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM v1","url":"/vi/docs/legacy/sam/"},{"categories":null,"content":" Đã lỗi thời: SAM v2 được phát hành kèm I2P 0.6.1.31 và không còn được duy trì. Hãy dùng SAM v3 cho các phát triển mới. Cải tiến duy nhất của v2 so với v1 là hỗ trợ nhiều socket được ghép kênh qua một kết nối SAM duy nhất.\nGhi chú phiên bản Chuỗi phiên bản được báo cáo vẫn là \u0026ldquo;2.0\u0026rdquo;. Kể từ 0.9.14, thông điệp HELLO VERSION chấp nhận các giá trị MIN/MAX một chữ số và tham số MIN là tùy chọn. DEST GENERATE hỗ trợ SIGNATURE_TYPE, vì vậy có thể tạo các đích Ed25519. Những điều cơ bản về phiên SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] Mỗi Destination (đích I2P) chỉ được có một phiên SAM đang hoạt động (luồng, datagram hoặc thô). STYLE chọn giữa luồng ảo, datagram có chữ ký, hoặc datagram thô. Các tùy chọn bổ sung được chuyển tới I2CP (ví dụ, tunnels.quantityInbound=3). Phản hồi giống v1: SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY. Mã hóa thông điệp ASCII theo từng dòng với các cặp key=value được phân tách bằng khoảng trắng (giá trị có thể được đặt trong dấu ngoặc kép). Các loại giao tiếp giống như v1:\nLuồng qua thư viện streaming của I2P Datagram (gói tin) có thể phản hồi (PROTO_DATAGRAM) Datagram thô (PROTO_DATAGRAM_RAW) Khi nào nên sử dụng Chỉ dành cho các ứng dụng khách cũ (legacy) không thể chuyển đổi. SAM v3 cung cấp:\nChuyển giao đích dạng nhị phân (DEST GENERATE BASE64) Hỗ trợ Subsessions (phiên con) và DHT (v3.3) Báo cáo lỗi tốt hơn và đàm phán tùy chọn Tham khảo:\nSAM v1 SAM v3 API Datagram (gói tin không kết nối) Giao thức truyền phát ","description":"Giao thức Simple Anonymous Messaging (nhắn tin ẩn danh đơn giản) cũ","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2","url":"/vi/docs/legacy/samv2/"},{"categories":null,"content":"SAMv3 (\u0026ldquo;Simple Anonymous Messaging\u0026rdquo;) là API ổn định, độc lập với router hiện tại cho phép các ứng dụng bên ngoài giao tiếp với mạng I2P mà không cần nhúng router. Nó cung cấp quyền truy cập thống nhất đến streams, datagrams và raw messages, đồng thời vẫn là lớp cầu nối chuẩn cho các phần mềm không phải Java.\n1. Tổng quan và Mục đích SAM v3 cho phép các nhà phát triển xây dựng phần mềm tương thích I2P bằng bất kỳ ngôn ngữ nào sử dụng giao thức TCP/UDP nhẹ. Nó trừu tượng hóa các thành phần bên trong của router, cung cấp một tập lệnh tối thiểu qua TCP (7656) và UDP (7655). Cả Java I2P và i2pd đều triển khai các tập con của đặc tả SAM v3, mặc dù i2pd vẫn còn thiếu hầu hết các phần mở rộng 3.2 và 3.3 tính đến năm 2025.\n2. Lịch sử phiên bản Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. ### Ghi chú về Đặt tên Java I2P sử dụng PRIMARY/SUBSESSION. i2pd và I2P+ tiếp tục sử dụng thuật ngữ cũ MASTER/SUBSESSION để đảm bảo tương thích ngược. 3. Quy trình làm việc cốt lõi Thương lượng Phiên bản HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 Tạo Destination DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512). Được khuyến nghị mạnh mẽ kể từ I2P 0.9.15. Tạo Phiên SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4 là X25519 (ECIES X25519 AEAD Ratchet) và 0 là ElGamal dự phòng để tương thích. Số lượng tunnel cụ thể để đảm bảo tính nhất quán: Java I2P mặc định 2, i2pd mặc định 5. Các Hoạt Động Giao Thức STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 Các loại thông điệp cốt lõi bao gồm: STREAM CONNECT, STREAM ACCEPT, STREAM FORWARD, DATAGRAM SEND, RAW SEND, NAMING LOOKUP, DEST LOOKUP, PING, QUIT.\nTắt Máy An Toàn QUIT 4. Sự khác biệt trong triển khai (Java I2P so với i2pd) Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 **Khuyến nghị:** Luôn chỉ định rõ ràng số lượng tunnel để đảm bảo tính nhất quán giữa các router. 5. Các Thư viện Được Hỗ trợ (Bản chụp 2025) Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance ## 6. Tính năng Sắp tới và Mới (2024–2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ ## 7. Ghi chú về Bảo mật và Cấu hình Ràng buộc SAM chỉ với 127.0.0.1. Đối với các dịch vụ lâu dài, sử dụng phiên PRIMARY với khóa tĩnh. Sử dụng HELLO VERSION để kiểm tra hỗ trợ tính năng. Sử dụng PING hoặc NAMING LOOKUP để xác minh router hoạt động. Tránh kết nối SAM từ xa không xác thực (không có TLS trong i2pd). 8. Tài liệu tham khảo và Thông số kỹ thuật Đặc tả SAM v3 SAM v2 (Cũ) Đặc tả Streaming Datagrams Trung tâm Tài liệu Tài liệu i2pd 9. Tóm tắt SAM v3 vẫn là giao thức cầu nối được khuyên dùng cho tất cả các ứng dụng I2P không phải Java. Nó cung cấp tính ổn định, khả năng liên kết đa ngôn ngữ lập trình và hiệu suất nhất quán trên các loại router.\nKhi phát triển với SAM: - Sử dụng chữ ký Ed25519 và mã hóa X25519. - Xác minh hỗ trợ tính năng động qua HELLO VERSION. - Thiết kế để tương thích, đặc biệt khi hỗ trợ cả router Java I2P và i2pd.\n","description":"Giao thức cầu nối ổn định cho các ứng dụng I2P không phải Java","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/vi/docs/api/samv3/"},{"categories":null,"content":" Cảnh báo: Tunnel SOCKS chuyển tiếp các payload ứng dụng mà không làm sạch chúng. Nhiều giao thức có thể làm rò rỉ IP, hostname hoặc các định danh khác. Chỉ sử dụng SOCKS với phần mềm mà bạn đã kiểm tra về tính ẩn danh.\n1. Tổng quan I2P cung cấp hỗ trợ proxy SOCKS 4, 4a và 5 cho các kết nối đi ra thông qua I2PTunnel client. Nó cho phép các ứng dụng tiêu chuẩn truy cập các đích đến I2P nhưng không thể truy cập clearnet (mạng Internet thông thường). Không có SOCKS outproxy, và toàn bộ lưu lượng vẫn ở trong mạng I2P.\nTóm tắt Triển khai Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None **Các loại địa chỉ được hỗ trợ:** - Tên miền `.i2p` (các mục trong sổ địa chỉ) - Mã băm Base32 (`.b32.i2p`) - Không hỗ trợ Base64 hoặc clearnet 2. Rủi ro Bảo mật và Hạn chế Rò rỉ ở Tầng Ứng dụng SOCKS hoạt động ở tầng dưới tầng ứng dụng và không thể làm sạch các giao thức. Nhiều ứng dụng client (ví dụ: trình duyệt, IRC, email) bao gồm metadata có thể tiết lộ địa chỉ IP, tên máy chủ hoặc thông tin chi tiết hệ thống của bạn.\nCác rò rỉ thông tin phổ biến bao gồm: - Địa chỉ IP trong header email hoặc phản hồi IRC CTCP - Tên thật/tên người dùng trong dữ liệu giao thức - Chuỗi user-agent chứa dấu vết hệ điều hành - Truy vấn DNS bên ngoài - WebRTC và dữ liệu thu thập từ trình duyệt\nI2P không thể ngăn chặn những rò rỉ này—chúng xảy ra ở tầng trên tunnel layer. Chỉ sử dụng SOCKS cho các client đã được kiểm toán được thiết kế cho tính ẩn danh.\nDanh Tính Tunnel Dùng Chung Nếu nhiều ứng dụng chia sẻ cùng một SOCKS tunnel, chúng sẽ dùng chung một định danh I2P destination. Điều này cho phép việc liên kết hoặc định danh dấu vết qua các dịch vụ khác nhau.\nGiảm thiểu: Sử dụng tunnel không chia sẻ cho mỗi ứng dụng và bật khóa lưu trữ lâu dài để duy trì danh tính mã hóa nhất quán qua các lần khởi động lại.\nChế độ UDP đã bị loại bỏ Hỗ trợ UDP trong SOCKS5 chưa được triển khai. Giao thức quảng bá khả năng UDP, nhưng các lệnh gọi bị bỏ qua. Hãy sử dụng các client chỉ dùng TCP.\nKhông có Outproxy theo Thiết kế Khác với Tor, I2P không cung cấp outproxy (proxy ra mạng thường) dựa trên SOCKS. Các nỗ lực truy cập địa chỉ IP bên ngoài sẽ thất bại hoặc làm lộ danh tính. Sử dụng proxy HTTP hoặc HTTPS nếu cần outproxy.\n3. Bối cảnh lịch sử Các nhà phát triển từ lâu đã không khuyến khích sử dụng SOCKS cho mục đích ẩn danh. Từ các cuộc thảo luận nội bộ của nhà phát triển và năm 2004 Meeting 81 và Meeting 82 :\n\u0026ldquo;Chuyển tiếp lưu lượng tùy ý là không an toàn, và với vai trò là những nhà phát triển phần mềm ẩn danh, chúng ta có trách nhiệm phải đặt sự an toàn của người dùng cuối lên hàng đầu trong tâm trí.\u0026rdquo;\nHỗ trợ SOCKS được bao gồm để tương thích nhưng không được khuyến nghị cho môi trường sản xuất. Gần như mọi ứng dụng internet đều rò rỉ metadata nhạy cảm không phù hợp với định tuyến ẩn danh.\n4. Cấu hình Java I2P Mở I2PTunnel Manager Tạo một client tunnel mới có kiểu \u0026ldquo;SOCKS 4/4a/5\u0026rdquo; Cấu hình các tùy chọn: Cổng local (bất kỳ cổng khả dụng nào) Shared client: tắt để có danh tính riêng biệt cho mỗi ứng dụng Persistent key: bật để giảm sự tương quan khóa Khởi động tunnel i2pd i2pd bao gồm hỗ trợ SOCKS5được kích hoạt mặc định tại 127.0.0.1:4447. Cấu hình trong i2pd.conf dưới phần [SOCKSProxy] cho phép bạn điều chỉnh cổng, máy chủ và các tham số tunnel.\n5. Lịch trình Phát triển Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 Bản thân module SOCKS không có bản cập nhật giao thức lớn nào kể từ năm 2013, nhưng ngăn xếp tunnel xung quanh đã nhận được các cải tiến về hiệu suất và mật mã. 6. Các Phương Án Thay Thế Được Khuyến Nghị Đối với bất kỳ ứng dụng sản xuất, hướng công chúng, hoặc quan trọng về bảo mật nào, hãy sử dụng một trong các API I2P chính thức thay vì SOCKS:\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM Các API này cung cấp khả năng cách ly đích đến phù hợp, kiểm soát danh tính mật mã và hiệu suất định tuyến tốt hơn. 7. OnionCat / GarliCat OnionCat hỗ trợ I2P thông qua chế độ GarliCat (fd60:db4d:ddb5::/48 dải IPv6). Vẫn hoạt động nhưng hạn chế phát triển kể từ năm 2019.\nLưu ý khi sử dụng: - Yêu cầu cấu hình thủ công .oc.b32.i2p trong SusiDNS - Cần gán địa chỉ IPv6 tĩnh - Không được hỗ trợ chính thức bởi dự án I2P\nChỉ được khuyến nghị cho các thiết lập VPN-over-I2P nâng cao.\n8. Các Phương Pháp Hay Nhất Nếu bạn phải sử dụng SOCKS: 1. Tạo các tunnel riêng biệt cho từng ứng dụng. 2. Vô hiệu hóa chế độ client dùng chung. 3. Bật tính năng khóa liên tục. 4. Buộc phân giải DNS qua SOCKS5. 5. Kiểm tra hành vi giao thức để phát hiện rò rỉ. 6. Tránh kết nối clearnet. 7. Giám sát lưu lượng mạng để phát hiện rò rỉ.\n9. Tóm tắt Kỹ thuật Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) --- 10. Kết luận SOCKS proxy trong I2P cung cấp khả năng tương thích cơ bản với các ứng dụng TCP hiện có nhưng không được thiết kế để đảm bảo tính ẩn danh mạnh mẽ. Nó chỉ nên được sử dụng cho các môi trường thử nghiệm có kiểm soát và được kiểm tra kỹ lưỡng.\nĐối với các triển khai nghiêm túc, hãy chuyển sang SAM v3 hoặc Streaming API. Các API này cô lập danh tính ứng dụng, sử dụng mật mã hiện đại và nhận được phát triển liên tục.\nTài Nguyên Bổ Sung Tài liệu SOCKS Chính thức Đặc tả SAMv3 Tài liệu Thư viện Streaming Tài liệu Tham khảo I2PTunnel Tài liệu Nhà phát triển I2P Diễn đàn Cộng đồng ","description":"Sử dụng tunnel SOCKS của I2P một cách an toàn (cập nhật cho phiên bản 2.10.0)","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"SOCKS Proxy","url":"/vi/docs/api/socks/"},{"categories":null,"content":" Đã lỗi thời: SSU đã được thay thế bởi SSU2. Hỗ trợ đã bị gỡ bỏ trong i2pd 2.44.0 (API 0.9.56, tháng 11 năm 2022) và trong Java I2P 2.4.0 (API 0.9.61, tháng 12 năm 2023).\nSSU cung cấp truyền tải bán tin cậy dựa trên UDP, kèm kiểm soát tắc nghẽn, xuyên NAT và hỗ trợ introducer (nút giới thiệu). Nó bổ trợ cho NTCP bằng cách xử lý các router ở sau NAT/tường lửa và điều phối việc khám phá IP.\nCác thành phần địa chỉ transport: SSU caps: cờ khả năng (B, C, 4, 6, v.v.) host / port: trình lắng nghe IPv4 hoặc IPv6 (tùy chọn khi bị chặn bởi tường lửa) key: khóa giới thiệu Base64 mtu: Tùy chọn; mặc định 1484 (IPv4) / 1488 (IPv6) ihost/ikey/iport/itag/iexp: introducer entries (các mục giới thiệu) khi router bị tường lửa chặn Tính năng Xuyên NAT hợp tác bằng cách sử dụng introducers (nút giới thiệu) Phát hiện IP cục bộ thông qua kiểm tra ngang hàng và kiểm tra các gói tin đến Tự động chuyển tiếp trạng thái tường lửa đến các phương thức truyền tải khác và bảng điều khiển router Giao nhận bán tin cậy: các thông điệp được truyền lại đến một giới hạn, rồi bị loại bỏ Điều khiển tắc nghẽn với tăng cộng / giảm nhân và các trường bit ACK cho phân mảnh SSU cũng xử lý các tác vụ siêu dữ liệu như timing beacons (đèn hiệu định thời) và thương lượng MTU (đơn vị truyền tối đa). Hiện toàn bộ chức năng (với mật mã hiện đại) do SSU2 cung cấp.\n","description":"Giao thức truyền tải Secure Semireliable UDP (UDP bảo mật bán tin cậy) nguyên bản","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (cũ)","url":"/vi/docs/legacy/ssu/"},{"categories":null,"content":" Nhánh phát triển chính của I2P (i2p.i2p) đã được thiết lập để giúp các nhà phát triển dễ dàng cài đặt hai IDE thường được sử dụng cho phát triển Java: Eclipse và NetBeans. Eclipse Các nhánh phát triển chính của I2P (i2p.i2p và các nhánh từ đó) chứa build.gradle để cho phép nhánh được thiết lập dễ dàng trong Eclipse. Đảm bảo bạn có phiên bản Eclipse gần đây. Bất kỳ phiên bản nào mới hơn 2017 đều có thể dùng được. Check out nhánh I2P vào một thư mục nào đó (ví dụ: $HOME/dev/i2p.i2p). Chọn \"File → Import...\" và sau đó trong mục \"Gradle\" chọn \"Existing Gradle Project\". Tại \"Project root directory:\" chọn thư mục mà nhánh I2P đã được check out vào. Trong hộp thoại \"Import Options\", chọn \"Gradle Wrapper\" và nhấn Continue. Trong hộp thoại \"Import Preview\" bạn có thể xem lại cấu trúc dự án. Nhiều dự án sẽ xuất hiện trong \"i2p.i2p\". Nhấn \"Finish\". Xong! Workspace của bạn giờ đây sẽ chứa tất cả các dự án trong nhánh I2P, và các build dependencies của chúng sẽ được thiết lập đúng cách. NetBeans Các nhánh phát triển chính của I2P (i2p.i2p và các nhánh từ đó) chứa các tệp dự án NetBeans. ","description":"Thiết lập Eclipse và NetBeans để phát triển I2P với Gradle và các tệp dự án đi kèm","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"Sử dụng IDE với I2P","url":"/vi/docs/guides/ides/"},{"categories":null,"content":"Eepsite là gì? Một eepsite (trang web chỉ hoạt động trong mạng I2P) là một trang web tồn tại duy nhất trên mạng I2P. Không giống các trang web truyền thống có thể truy cập qua Internet công khai, các eepsite chỉ có thể truy cập thông qua I2P, mang lại tính ẩn danh và quyền riêng tư cho cả người vận hành trang lẫn khách truy cập. Các eepsite sử dụng miền cấp cao giả .i2p và được truy cập thông qua các địa chỉ .b32.i2p đặc biệt hoặc các tên dễ đọc được đăng ký trong sổ địa chỉ I2P.\nTất cả các bản triển khai Java I2P đi kèm với Jetty , một máy chủ web nhẹ dựa trên Java, được cài đặt sẵn và cấu hình sẵn. Điều này giúp bạn dễ dàng bắt đầu lưu trữ eepsite của riêng bạn trong vài phút - không cần cài đặt thêm phần mềm nào.\nHướng dẫn này sẽ dẫn bạn từng bước qua quy trình tạo và cấu hình eepsite đầu tiên của bạn bằng các công cụ tích hợp sẵn của I2P.\nBước 1: Truy cập Trình quản lý dịch vụ ẩn Hidden Services Manager (trình quản lý Dịch vụ Ẩn; còn được gọi là I2P Tunnel Manager) là nơi bạn cấu hình tất cả các tunnel máy chủ và máy khách của I2P, bao gồm cả các máy chủ HTTP (eepsites).\nMở Bảng điều khiển I2P Router Đi tới Trình quản lý Dịch vụ Ẩn Bạn sẽ thấy giao diện Trình quản lý Dịch vụ ẩn hiển thị: - Thông báo trạng thái - Trạng thái tunnel và máy khách hiện tại - Điều khiển tunnel toàn cục - Các nút để quản lý tất cả tunnel cùng lúc - Dịch vụ ẩn I2P - Danh sách các tunnel máy chủ đã cấu hình\nTheo mặc định, bạn sẽ thấy một mục máy chủ web I2P hiện có đã được cấu hình nhưng chưa được khởi động. Đây là máy chủ web Jetty được cấu hình sẵn, sẵn sàng để bạn sử dụng.\nBước 2: Cấu hình các thiết lập máy chủ Eepsite của bạn Nhấp vào mục I2P webserver trong danh sách Hidden Services để mở trang cấu hình máy chủ. Tại đây bạn sẽ tùy chỉnh các thiết lập cho eepsite (trang web trên I2P) của mình.\nGiải thích các tùy chọn cấu hình Tên - Đây là một định danh nội bộ cho tunnel của bạn - Hữu ích nếu bạn đang chạy nhiều eepsites để dễ phân biệt cái nào với cái nào - Mặc định: \u0026ldquo;I2P webserver\u0026rdquo;\nMô tả - Một mô tả ngắn gọn về eepsite của bạn để bạn tự tham khảo - Chỉ hiển thị cho bạn trong Hidden Services Manager (Trình quản lý Dịch vụ Ẩn) - Ví dụ: \u0026ldquo;eepsite của tôi\u0026rdquo; hoặc \u0026ldquo;blog cá nhân\u0026rdquo;\nTự động khởi động Tunnel - Quan trọng: Đánh dấu vào ô này để tự động khởi động eepsite của bạn khi router I2P khởi động - Đảm bảo trang của bạn vẫn truy cập được mà không cần can thiệp thủ công sau khi router khởi động lại - Khuyến nghị: Bật\nĐích (Host và Port) - Host: Địa chỉ cục bộ nơi máy chủ web của bạn đang chạy (mặc định: 127.0.0.1) - Port: Cổng mà máy chủ web của bạn lắng nghe (mặc định: 7658 cho Jetty) - Nếu bạn đang sử dụng máy chủ web Jetty được cài sẵn, hãy giữ nguyên các giá trị mặc định này - Chỉ thay đổi nếu bạn đang chạy một máy chủ web tùy chỉnh trên một cổng khác\nTên máy chủ trang web - Đây là tên miền .i2p dễ đọc của eepsite của bạn - Mặc định: mysite.i2p (giá trị giữ chỗ) - Bạn có thể đăng ký một tên miền tùy chỉnh như stormycloud.i2p hoặc myblog.i2p - Để trống nếu bạn chỉ muốn dùng địa chỉ .b32.i2p được tạo tự động (cho outproxy (proxy ra)) - Xem Đăng ký tên miền I2P của bạn bên dưới để biết cách yêu cầu một tên máy chủ tùy chỉnh\nĐích cục bộ - Đây là mã định danh mật mã (địa chỉ đích) duy nhất của eepsite của bạn - Được tự động tạo khi tunnel được tạo lần đầu - Hãy coi đây như \u0026ldquo;địa chỉ IP\u0026rdquo; cố định của trang bạn trên I2P - Chuỗi chữ-số dài chính là địa chỉ .b32.i2p của trang bạn ở dạng mã hóa\nTệp khóa riêng - Vị trí lưu trữ các khóa riêng của eepsite của bạn - Mặc định: eepsite/eepPriv.dat - Bảo mật tệp này - bất kỳ ai có quyền truy cập vào tệp này đều có thể mạo danh eepsite của bạn - Không bao giờ chia sẻ hoặc xóa tệp này\nLưu ý quan trọng Hộp cảnh báo màu vàng nhắc bạn rằng để kích hoạt các tính năng tạo mã QR hoặc xác thực đăng ký, bạn phải cấu hình Tên máy chủ trang web với hậu tố .i2p (ví dụ, mynewsite.i2p).\nBước 3: Các tùy chọn mạng nâng cao (Không bắt buộc) Nếu bạn cuộn xuống trong trang cấu hình, bạn sẽ thấy các tùy chọn mạng nâng cao. Những cài đặt này là không bắt buộc - các thiết lập mặc định hoạt động tốt với đa số người dùng. Tuy nhiên, bạn có thể điều chỉnh chúng dựa trên yêu cầu bảo mật và nhu cầu hiệu suất của mình.\nCác tùy chọn độ dài Tunnel Độ dài tunnel - Mặc định: tunnel 3 bước nhảy (mức ẩn danh cao) - Kiểm soát số bước nhảy qua các router mà một yêu cầu phải đi qua trước khi đến eepsite của bạn - Nhiều bước nhảy hơn = Mức ẩn danh cao hơn, nhưng hiệu năng chậm hơn - Ít bước nhảy hơn = Hiệu năng nhanh hơn, nhưng mức ẩn danh giảm - Các tùy chọn trong khoảng 0-3 bước nhảy với cài đặt độ biến thiên - Khuyến nghị: Giữ ở 3 bước nhảy trừ khi bạn có yêu cầu hiệu năng cụ thể\nĐộ biến thiên tunnel - Mặc định: độ biến thiên 0 chặng (không ngẫu nhiên hóa, hiệu năng ổn định) - Thêm ngẫu nhiên hóa vào độ dài tunnel để tăng cường bảo mật - Ví dụ: \u0026ldquo;độ biến thiên 0-1 chặng\u0026rdquo; nghĩa là các tunnel sẽ ngẫu nhiên dài 3 hoặc 4 chặng - Tăng tính khó dự đoán nhưng có thể khiến thời gian tải không nhất quán\nTùy chọn số lượng Tunnel Số lượng (tunnels vào/ra) - Mặc định: 2 tunnel vào, 2 tunnel ra (băng thông và độ tin cậy tiêu chuẩn) - Kiểm soát số lượng tunnel (đường hầm ẩn danh trong I2P) song song được dành riêng cho eepsite của bạn - Nhiều tunnel hơn = Khả dụng và xử lý tải tốt hơn, nhưng sử dụng tài nguyên cao hơn - Ít tunnel hơn = Sử dụng tài nguyên thấp hơn, nhưng giảm khả năng dự phòng - Khuyến nghị cho đa số người dùng: 2/2 (mặc định) - Các eepsite lưu lượng cao có thể hưởng lợi từ 3/3 hoặc cao hơn\nSố lượng dự phòng - Mặc định: 0 tunnels dự phòng (không dự phòng, không tăng sử dụng tài nguyên) - Các tunnels chờ sẽ được kích hoạt nếu các tunnels chính bị lỗi - Tăng độ tin cậy nhưng tiêu tốn nhiều băng thông và CPU hơn - Hầu hết eepsites cá nhân không cần tunnels dự phòng\nGiới hạn POST Nếu eepsite của bạn bao gồm các biểu mẫu (biểu mẫu liên hệ, mục bình luận, tải lên tệp, v.v.), bạn có thể cấu hình các giới hạn đối với các yêu cầu POST để ngăn chặn lạm dụng:\nGiới hạn theo từng máy khách - Mỗi khoảng thời gian: Số lượng yêu cầu tối đa từ một máy khách (mặc định: 6 trong mỗi 5 phút) - Thời gian cấm: Thời gian chặn máy khách lạm dụng (mặc định: 20 phút)\nGiới hạn tổng - Tổng: Số lượng yêu cầu POST tối đa từ tất cả các máy khách cộng lại (mặc định: 20 mỗi 5 phút) - Thời gian cấm: Thời gian từ chối tất cả yêu cầu POST nếu vượt quá giới hạn (mặc định: 10 phút)\nKhoảng thời gian giới hạn POST - Cửa sổ thời gian để đo tần suất yêu cầu (mặc định: 5 phút)\nNhững giới hạn này giúp bảo vệ chống lại thư rác, các cuộc tấn công từ chối dịch vụ và lạm dụng việc gửi biểu mẫu tự động.\nKhi nào nên điều chỉnh cài đặt nâng cao Trang cộng đồng có lưu lượng truy cập cao: Tăng số lượng tunnel (3-4 inbound/outbound) Ứng dụng nhạy cảm về hiệu năng: Giảm độ dài tunnel xuống 2 hops (chặng) (đánh đổi quyền riêng tư) Cần ẩn danh tối đa: Giữ 3 hops, thêm 0-1 variance (độ biến thiên) Biểu mẫu với mức sử dụng cao chính đáng: Tăng giới hạn POST tương ứng Blog/hồ sơ năng lực cá nhân: Dùng tất cả giá trị mặc định Bước 4: Thêm nội dung vào Eepsite của bạn Bây giờ eepsite của bạn đã được cấu hình, bạn cần thêm các tệp trang web (HTML, CSS, hình ảnh, v.v.) vào thư mục gốc tài liệu (document root) của máy chủ web. Vị trí này thay đổi tùy theo hệ điều hành, loại cài đặt và bản triển khai I2P của bạn.\nTìm thư mục gốc tài liệu của bạn Thư mục gốc của website (thường gọi là docroot) là thư mục nơi bạn đặt toàn bộ tệp của website. Tệp index.html của bạn nên đặt trực tiếp trong thư mục này.\nJava I2P (Bản phân phối tiêu chuẩn) Linux - Cài đặt tiêu chuẩn: ~/.i2p/eepsite/docroot/ - Cài đặt bằng gói (chạy như dịch vụ): /var/lib/i2p/i2p-config/eepsite/docroot/\nWindows - Cài đặt tiêu chuẩn: %LOCALAPPDATA%\\I2P\\eepsite\\docroot\\ - Đường dẫn điển hình: C:\\Users\\YourUsername\\AppData\\Local\\I2P\\eepsite\\docroot\\ - Cài đặt dưới dạng dịch vụ Windows: %PROGRAMDATA%\\I2P\\eepsite\\docroot\\ - Đường dẫn điển hình: C:\\ProgramData\\I2P\\eepsite\\docroot\\\nmacOS - Cài đặt tiêu chuẩn: /Users/YourUsername/Library/Application Support/i2p/eepsite/docroot/\nI2P+ (Bản phân phối I2P nâng cao) I2P+ sử dụng cùng một cấu trúc thư mục như Java I2P. Hãy làm theo các đường dẫn ở trên tùy theo hệ điều hành của bạn.\ni2pd (Hiện thực bằng C++) Linux/Unix - Mặc định: /var/lib/i2pd/eepsite/ hoặc ~/.i2pd/eepsite/ - Kiểm tra tệp cấu hình i2pd.conf của bạn để biết thiết lập root thực tế trong phần tunnel máy chủ HTTP của bạn\nWindows - Kiểm tra i2pd.conf trong thư mục cài đặt i2pd của bạn\nmacOS - Thông thường: ~/Library/Application Support/i2pd/eepsite/\nThêm các tệp trang web của bạn Đi tới thư mục gốc của website (document root) bằng trình quản lý tệp hoặc terminal Tạo hoặc sao chép các tệp trang web của bạn vào thư mục docroot Tối thiểu, hãy tạo một tệp index.html (đây là trang chủ của bạn) Thêm CSS, JavaScript, hình ảnh và các tài nguyên khác khi cần Sắp xếp các thư mục con như bạn vẫn làm với bất kỳ trang web nào: docroot/ ├── index.html ├── about.html ├── css/ │ └── style.css ├── images/ │ └── logo.png └── js/ └── script.js Bắt đầu nhanh: Ví dụ HTML đơn giản Nếu bạn chỉ mới bắt đầu, hãy tạo một tệp index.html cơ bản trong thư mục docroot của bạn:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My I2P Eepsite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Eepsite!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first website on the I2P network.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Privacy-focused and decentralized!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Quyền (Linux/Unix/macOS) Nếu bạn chạy I2P như một dịch vụ hoặc dưới một tài khoản người dùng khác, hãy đảm bảo tiến trình I2P có quyền đọc các tệp của bạn:\n# Set appropriate ownership (if running as i2p user) sudo chown -R i2p:i2p /var/lib/i2p/i2p-config/eepsite/docroot/ # Or set readable permissions for all users chmod -R 755 ~/.i2p/eepsite/docroot/ Mẹo Nội dung mặc định: Khi bạn cài đặt I2P lần đầu, đã có sẵn nội dung mẫu trong thư mục docroot - bạn cứ thoải mái thay thế nó Trang tĩnh hoạt động tốt nhất: Mặc dù Jetty hỗ trợ các servlet và JSP, các trang HTML/CSS/JavaScript đơn giản là dễ bảo trì nhất Máy chủ web bên ngoài: Người dùng nâng cao có thể chạy các máy chủ web tùy chỉnh (Apache, Nginx, Node.js, v.v.) trên các cổng khác nhau và trỏ I2P tunnel tới chúng Bước 5: Khởi chạy Eepsite của bạn Bây giờ eepsite (trang web ẩn trên mạng I2P) của bạn đã được cấu hình và có nội dung, đã đến lúc khởi chạy nó và làm cho nó có thể truy cập trên mạng I2P.\nKhởi động Tunnel Quay lại Trình quản lý Dịch vụ Ẩn Tìm mục I2P webserver của bạn trong danh sách Nhấp nút Start trong cột Control Chờ thiết lập Tunnel Sau khi nhấp Start, eepsite tunnel của bạn sẽ bắt đầu được xây dựng. Quá trình này thường mất 30-60 giây. Hãy theo dõi chỉ báo trạng thái:\nĐèn đỏ = Tunnel đang khởi động/xây dựng Đèn vàng = Tunnel được thiết lập một phần Đèn xanh = Tunnel hoạt động hoàn toàn và sẵn sàng Ngay khi bạn thấy đèn xanh, eepsite của bạn đã hoạt động trên mạng I2P!\nTruy cập Eepsite của bạn Nhấp vào nút Preview bên cạnh eepsite đang chạy của bạn. Thao tác này sẽ mở một thẻ trình duyệt mới tới địa chỉ eepsite của bạn.\neepsite của bạn có hai loại địa chỉ:\nĐịa chỉ Base32 (.b32.i2p): Một địa chỉ mật mã dài trông như sau:\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p Đây là địa chỉ vĩnh viễn của eepsite của bạn, được dẫn xuất bằng mật mã Không thể thay đổi và gắn liền với khóa riêng của bạn Luôn hoạt động, ngay cả khi không đăng ký tên miền Tên miền dễ đọc (.i2p): Nếu bạn đặt một tên máy chủ website (ví dụ: testwebsite.i2p)\nChỉ hoạt động sau khi đăng ký tên miền (xem phần tiếp theo) Dễ nhớ và chia sẻ hơn Ánh xạ tới địa chỉ .b32.i2p của bạn Nút Copy Hostname cho phép bạn nhanh chóng sao chép địa chỉ .b32.i2p đầy đủ của mình để chia sẻ.\n⚠️ Cực kỳ quan trọng: Sao lưu khóa riêng của bạn Trước khi tiếp tục, bạn phải sao lưu tệp khóa riêng của eepsite của bạn. Điều này cực kỳ quan trọng vì một số lý do:\nTại sao bạn cần sao lưu khóa của mình? Khóa riêng (eepPriv.dat) của bạn là định danh eepsite của bạn. Nó xác định địa chỉ .b32.i2p của bạn và chứng minh quyền sở hữu eepsite của bạn.\nKhóa = địa chỉ .b32: Khóa riêng của bạn tạo (về mặt toán học) địa chỉ .b32.i2p duy nhất của bạn Không thể khôi phục: Nếu bạn mất khóa, bạn sẽ mất vĩnh viễn địa chỉ eepsite của mình Không thể thay đổi: Nếu bạn đã đăng ký một tên miền trỏ tới một địa chỉ .b32, không có cách nào để cập nhật nó - việc đăng ký là vĩnh viễn Cần thiết cho việc di chuyển: Chuyển sang máy tính mới hoặc cài đặt lại I2P cần khóa này để giữ nguyên địa chỉ Hỗ trợ multihoming (đa địa điểm): Chạy eepsite của bạn từ nhiều địa điểm yêu cầu cùng một khóa trên mỗi máy chủ Khóa riêng ở đâu? Theo mặc định, khóa riêng của bạn được lưu tại: - Linux: ~/.i2p/eepsite/eepPriv.dat (hoặc /var/lib/i2p/i2p-config/eepsite/eepPriv.dat dành cho cài đặt dưới dạng dịch vụ) - Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat hoặc %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat - macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat\nBạn cũng có thể kiểm tra/thay đổi đường dẫn này trong cấu hình tunnel (đường hầm) của bạn, dưới mục \u0026ldquo;Private Key File\u0026rdquo;.\nCách sao lưu Dừng tunnel của bạn (tùy chọn, nhưng an toàn hơn) Sao chép eepPriv.dat vào một vị trí an toàn: Ổ USB ngoài Ổ sao lưu được mã hóa Tệp lưu trữ được bảo vệ bằng mật khẩu Lưu trữ đám mây an toàn (được mã hóa) Giữ nhiều bản sao lưu ở các vị trí vật lý khác nhau Không bao giờ chia sẻ tệp này - bất kỳ ai có nó đều có thể mạo danh eepsite của bạn Khôi phục từ bản sao lưu Để khôi phục eepsite của bạn trên một hệ thống mới hoặc sau khi cài đặt lại:\nCài đặt I2P và tạo/cấu hình các thiết lập tunnel của bạn Dừng tunnel trước khi sao chép khóa Sao chép eepPriv.dat đã sao lưu của bạn đến đúng vị trí Khởi động tunnel - nó sẽ sử dụng địa chỉ .b32 gốc của bạn Nếu bạn không đăng ký tên miền Chúc mừng! Nếu bạn không dự định đăng ký một tên miền .i2p tùy chỉnh, eepsite của bạn hiện đã hoàn tất và đang hoạt động.\nBạn có thể: - Chia sẻ địa chỉ .b32.i2p của bạn với người khác - Truy cập trang web của bạn qua mạng I2P bằng bất kỳ trình duyệt hỗ trợ I2P nào - Cập nhật các tệp trang web của bạn trong thư mục docroot bất cứ lúc nào - Giám sát trạng thái tunnel của bạn trong Hidden Services Manager (Trình quản lý Dịch vụ Ẩn)\nNếu bạn muốn một tên miền dễ đọc (như mysite.i2p thay vì một địa chỉ .b32 dài), hãy tiếp tục đến phần tiếp theo.\nĐăng ký tên miền I2P của bạn Một tên miền .i2p dễ đọc (như testwebsite.i2p) dễ nhớ và chia sẻ hơn nhiều so với một địa chỉ .b32.i2p dài. Việc đăng ký tên miền là miễn phí và liên kết tên bạn chọn với địa chỉ mật mã của eepsite (trang web trên I2P) của bạn.\nĐiều kiện tiên quyết eepsite của bạn phải đang chạy với đèn báo màu xanh lá Bạn phải đặt Website Hostname trong cấu hình tunnel của bạn (Bước 2) Ví dụ: testwebsite.i2p hoặc myblog.i2p Bước 1: Tạo chuỗi xác thực Quay lại cấu hình tunnel của bạn trong Trình quản lý Dịch vụ Ẩn Nhấp vào mục máy chủ web I2P của bạn để mở phần cài đặt Cuộn xuống để tìm nút Xác thực đăng ký Nhấp vào Registration Authentication Sao chép toàn bộ chuỗi xác thực được hiển thị cho \u0026ldquo;Authentication for adding host [yourdomainhere]\u0026rdquo; Chuỗi xác thực sẽ trông như sau:\ntestwebsite.i2p=I8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1uNxFZ0HN7tQbbVj1pmbahepQZNxEW0ufwnMYAoFo8opBQAEAAcAAA==#!date=1762104890#sig=9DjEfrcNRxsoSxiE0Mp0-7rH~ktYWtgwU8c4J0eSo0VHbGxDxdiO9D1Cvwcx8hkherMO07UWOC9BWf-1wRyUAw== Chuỗi này chứa: - Tên miền của bạn (testwebsite.i2p) - Địa chỉ đích của bạn (định danh mật mã dài) - Dấu thời gian - Chữ ký số chứng minh bạn sở hữu khóa riêng\nGiữ chuỗi xác thực này - bạn sẽ cần nó cho cả hai dịch vụ đăng ký.\nBước 2: Đăng ký với stats.i2p Truy cập stats.i2p Thêm khóa (trong I2P) Dán chuỗi xác thực vào trường \u0026ldquo;Authentication String\u0026rdquo; Thêm tên của bạn (tùy chọn) - mặc định là \u0026ldquo;Anonymous\u0026rdquo; Thêm mô tả (khuyến nghị) - mô tả ngắn gọn về nội dung eepsite của bạn Ví dụ: \u0026ldquo;New I2P Eepsite\u0026rdquo;, \u0026ldquo;Blog cá nhân\u0026rdquo;, \u0026ldquo;Dịch vụ chia sẻ tệp\u0026rdquo; Chọn \u0026ldquo;HTTP Service?\u0026rdquo; nếu đây là một website (giữ nguyên ở trạng thái đã chọn đối với hầu hết các eepsite) Bỏ chọn đối với IRC, NNTP, các proxy, XMPP, git, v.v. Nhấp Submit Nếu thành công, bạn sẽ thấy một thông báo xác nhận rằng tên miền của bạn đã được thêm vào sổ địa chỉ của stats.i2p.\nBước 3: Đăng ký với reg.i2p Để đảm bảo tính sẵn sàng tối đa, bạn cũng nên đăng ký với dịch vụ reg.i2p:\nĐi tới reg.i2p Thêm miền (trong I2P) Dán cùng một chuỗi xác thực vào trường \u0026ldquo;Auth string\u0026rdquo; Thêm mô tả (tùy chọn nhưng được khuyến nghị) Điều này giúp những người dùng I2P khác hiểu trang web của bạn cung cấp gì Nhấp Submit Bạn sẽ nhận được xác nhận rằng tên miền của bạn đã được đăng ký.\nBước 4: Chờ lan truyền Sau khi gửi tới cả hai dịch vụ, việc đăng ký tên miền của bạn sẽ được lan truyền thông qua hệ thống sổ địa chỉ của mạng I2P.\nMốc thời gian lan truyền: - Đăng ký ban đầu: Ngay lập tức trên các dịch vụ đăng ký - Phổ biến trên toàn mạng: Vài giờ đến 24 giờ hoặc hơn - Khả dụng đầy đủ: Có thể mất tới 48 giờ để tất cả các router được cập nhật\nĐây là điều bình thường! Hệ thống sổ địa chỉ I2P được cập nhật định kỳ, không phải ngay lập tức. eepsite của bạn đang hoạt động - những người dùng khác chỉ cần nhận được sổ địa chỉ đã cập nhật.\nXác minh tên miền của bạn Sau vài giờ, bạn có thể kiểm tra tên miền của mình:\nMở một thẻ trình duyệt mới trong trình duyệt I2P của bạn Hãy thử truy cập trực tiếp tên miền của bạn: http://yourdomainname.i2p Nếu tải được, tên miền của bạn đã được đăng ký và đang được lan truyền! Nếu vẫn chưa hoạt động: - Chờ lâu hơn (các danh bạ địa chỉ tự cập nhật theo lịch riêng) - Danh bạ địa chỉ trên router của bạn có thể cần thời gian để đồng bộ - Hãy thử khởi động lại I2P router để buộc cập nhật danh bạ địa chỉ\nLưu ý quan trọng Đăng ký là vĩnh viễn: Khi đã đăng ký và được lan truyền, miền của bạn sẽ trỏ vĩnh viễn tới địa chỉ .b32.i2p của bạn Không thể thay đổi điểm đích: Bạn không thể cập nhật địa chỉ .b32.i2p mà miền của bạn trỏ tới - đó là lý do việc sao lưu eepPriv.dat là tối quan trọng Quyền sở hữu miền: Chỉ người nắm giữ khóa riêng mới có thể đăng ký hoặc cập nhật miền Dịch vụ miễn phí: Việc đăng ký miền trên I2P là miễn phí, do cộng đồng vận hành và phi tập trung Nhiều nhà đăng ký: Đăng ký với cả stats.i2p và reg.i2p giúp tăng độ tin cậy và tốc độ lan truyền Chúc mừng! Eepsite I2P của bạn hiện đã hoạt động đầy đủ với một tên miền đã được đăng ký!\nCác bước tiếp theo: - Thêm nhiều nội dung hơn vào thư mục docroot của bạn - Chia sẻ tên miền của bạn với cộng đồng I2P - Giữ bản sao lưu eepPriv.dat của bạn an toàn - Theo dõi trạng thái tunnel (đường hầm ẩn danh của I2P) của bạn thường xuyên - Cân nhắc tham gia các diễn đàn I2P hoặc IRC để quảng bá trang web của bạn\nChào mừng đến với mạng I2P! 🎉\n","description":"Tìm hiểu cách tạo và tự lưu trữ trang web của riêng bạn trên mạng I2P bằng máy chủ web Jetty tích hợp sẵn","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"Tạo một Eepsite trên I2P","url":"/vi/docs/guides/t%E1%BA%A1o-m%E1%BB%99t-eepsite-tr%C3%AAn-i2p/"},{"categories":null,"content":"Một SSH tunnel cung cấp kết nối mã hóa an toàn để truy cập console của I2P router từ xa hoặc các dịch vụ khác. Hướng dẫn này chỉ cho bạn cách tạo SSH tunnel trên các hệ thống Windows, Linux và Mac.\nSSH Tunnel là gì? SSH tunnel là phương pháp định tuyến dữ liệu và thông tin một cách an toàn qua kết nối SSH được mã hóa. Hãy nghĩ về nó như việc tạo ra một \u0026ldquo;đường ống\u0026rdquo; được bảo vệ xuyên qua internet - dữ liệu của bạn di chuyển qua tunnel được mã hóa này, ngăn chặn bất kỳ ai chặn bắt hoặc đọc được nó trong suốt quá trình truyền tải.\nSSH tunneling đặc biệt hữu ích cho:\nTruy cập các router I2P từ xa: Kết nối tới bảng điều khiển I2P của bạn đang chạy trên máy chủ từ xa Kết nối bảo mật: Toàn bộ lưu lượng được mã hóa đầu-cuối Vượt qua các hạn chế: Truy cập các dịch vụ trên hệ thống từ xa như thể chúng đang chạy cục bộ Chuyển tiếp cổng: Ánh xạ một cổng cục bộ tới một dịch vụ từ xa Trong bối cảnh I2P, bạn có thể sử dụng SSH tunnel để truy cập bảng điều khiển I2P router của mình (thường ở cổng 7657) trên máy chủ từ xa bằng cách chuyển tiếp nó đến một cổng cục bộ trên máy tính của bạn.\nYêu cầu tiên quyết Trước khi tạo một SSH tunnel, bạn sẽ cần:\nSSH client: Windows: PuTTY (tải miễn phí) Linux/Mac: SSH client tích hợp sẵn (qua Terminal) Truy cập máy chủ từ xa: Tên người dùng cho máy chủ từ xa Địa chỉ IP hoặc hostname của máy chủ từ xa Mật khẩu SSH hoặc xác thực bằng key Cổng local khả dụng: Chọn một cổng chưa sử dụng trong khoảng 1-65535 (7657 thường được dùng cho I2P) Hiểu về Lệnh Tunnel Lệnh tạo SSH tunnel tuân theo mẫu sau:\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] Giải thích các tham số: - local_port: Cổng trên máy cục bộ của bạn (ví dụ: 7657) - destination_ip: Thường là 127.0.0.1 (localhost trên máy chủ từ xa) - destination_port: Cổng của dịch vụ trên máy chủ từ xa (ví dụ: 7657 cho I2P) - username: Tên người dùng của bạn trên máy chủ từ xa - remote_server: Địa chỉ IP hoặc hostname của máy chủ từ xa\nVí dụ: ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\nLệnh này tạo một tunnel trong đó: - Cổng local 7657 trên máy của bạn chuyển tiếp đến\u0026hellip; - Cổng 7657 trên localhost của server từ xa (nơi I2P đang chạy) - Kết nối với tư cách user i2p đến server 20.228.143.58\nTạo SSH Tunnel trên Windows Người dùng Windows có thể tạo SSH tunnel bằng PuTTY, một SSH client miễn phí.\nStep 1: Download and Install PuTTY Tải PuTTY từ putty.org và cài đặt nó trên hệ thống Windows của bạn.\nStep 2: Configure the SSH Connection Mở PuTTY và cấu hình kết nối của bạn:\nTrong danh mục Session: Nhập địa chỉ IP hoặc tên máy chủ của máy chủ từ xa vào trường Host Name Đảm bảo Port được đặt là 22 (cổng SSH mặc định) Loại kết nối phải là SSH Step 3: Configure the Tunnel Điều hướng đến Connection → SSH → Tunnels trong thanh bên trái:\nCổng nguồn: Nhập cổng cục bộ bạn muốn sử dụng (ví dụ: 7657) Đích đến: Nhập 127.0.0.1:7657 (localhost:port trên máy chủ từ xa) Nhấp Add để thêm tunnel Tunnel sẽ xuất hiện trong danh sách \u0026ldquo;Forwarded ports\u0026rdquo; Step 4: Connect Nhấp vào Open để bắt đầu kết nối Nếu đây là lần đầu tiên bạn kết nối, bạn sẽ thấy cảnh báo bảo mật - nhấp vào Yes để tin tưởng máy chủ Nhập tên người dùng của bạn khi được yêu cầu Nhập mật khẩu của bạn khi được yêu cầu Sau khi kết nối, bạn có thể truy cập bảng điều khiển I2P từ xa bằng cách mở trình duyệt và truy cập http://127.0.0.1:7657\nBước 1: Tải xuống và Cài đặt PuTTY Để tránh phải cấu hình lại mỗi lần:\nQuay lại danh mục Session Nhập tên vào Saved Sessions (ví dụ: \u0026ldquo;I2P Tunnel\u0026rdquo;) Nhấp Save Lần sau, chỉ cần tải phiên này và nhấp Open Creating SSH Tunnels on Linux Các hệ thống Linux có SSH được tích hợp sẵn trong terminal, giúp việc tạo tunnel nhanh chóng và đơn giản.\nBước 2: Cấu hình kết nối SSH Mở terminal và chạy lệnh SSH tunnel:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Thay thế: - 7657 (lần xuất hiện đầu tiên): Cổng local mong muốn của bạn - 127.0.0.1:7657: Địa chỉ đích và cổng trên máy chủ từ xa - i2p: Tên người dùng của bạn trên máy chủ từ xa - 20.228.143.58: Địa chỉ IP của máy chủ từ xa\nKhi được nhắc, hãy nhập mật khẩu của bạn. Sau khi kết nối, tunnel sẽ hoạt động.\nTruy cập bảng điều khiển I2P từ xa của bạn tại http://127.0.0.1:7657 trong trình duyệt.\nBước 3: Cấu hình Tunnel Tunnel sẽ duy trì hoạt động trong suốt thời gian phiên SSH đang chạy. Để giữ nó chạy trong nền:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Các cờ bổ sung: - -f: Chạy SSH ở chế độ nền - -N: Không thực thi lệnh từ xa (chỉ tunnel)\nĐể đóng một tunnel chạy nền, tìm và kết thúc tiến trình SSH:\nps aux | grep ssh kill [process_id] Bước 4: Kết nối Để có bảo mật và tiện lợi tốt hơn, hãy sử dụng xác thực khóa SSH:\nTạo cặp khóa SSH (nếu bạn chưa có):\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Sao chép khóa công khai của bạn lên máy chủ từ xa:\nssh-copy-id i2p@20.228.143.58 Bây giờ bạn có thể kết nối mà không cần mật khẩu:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac Các hệ thống Mac sử dụng cùng SSH client như Linux, do đó quy trình là giống hệt nhau.\nTùy chọn: Lưu phiên làm việc của bạn Mở Terminal (Applications → Utilities → Terminal) và chạy:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Thay thế: - 7657 (lần xuất hiện đầu tiên): Cổng local mong muốn của bạn - 127.0.0.1:7657: Địa chỉ và cổng đích trên máy chủ từ xa - i2p: Tên người dùng của bạn trên máy chủ từ xa - 20.228.143.58: Địa chỉ IP của máy chủ từ xa\nNhập mật khẩu của bạn khi được yêu cầu. Sau khi kết nối, truy cập bảng điều khiển I2P từ xa của bạn tại http://127.0.0.1:7657\nBackground Tunnels on Mac Tương tự như Linux, bạn có thể chạy tunnel ở chế độ nền:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Sử dụng Terminal Thiết lập SSH key trên Mac giống hệt như trên Linux:\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases Giữ Tunnel Hoạt Động Trường hợp sử dụng phổ biến nhất - truy cập bảng điều khiển I2P router từ xa của bạn:\nssh -L 7657:127.0.0.1:7657 user@remote-server Sau đó mở http://127.0.0.1:7657 trong trình duyệt của bạn.\nSử dụng SSH Keys (Khuyến nghị) Chuyển tiếp nhiều cổng cùng lúc:\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server Điều này chuyển tiếp cả cổng 7657 (bảng điều khiển I2P) và 7658 (dịch vụ khác).\nCustom Local Port Sử dụng cổng cục bộ khác nếu 7657 đã được sử dụng:\nssh -L 8080:127.0.0.1:7657 user@remote-server Thay vào đó, truy cập bảng điều khiển I2P tại http://127.0.0.1:8080.\nTroubleshooting Sử dụng Terminal Lỗi: \u0026ldquo;bind: Address already in use\u0026rdquo;\nGiải pháp: Chọn một cổng cục bộ khác hoặc kết thúc tiến trình đang sử dụng cổng đó:\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] Tunnel Nền trên Mac Lỗi: \u0026ldquo;Connection refused\u0026rdquo; hoặc \u0026ldquo;channel 2: open failed\u0026rdquo;\nNguyên nhân có thể: - Dịch vụ từ xa không chạy (kiểm tra router I2P đang chạy trên máy chủ từ xa) - Tường lửa chặn kết nối - Cổng đích không chính xác\nGiải pháp: Xác minh I2P router đang chạy trên máy chủ từ xa:\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; Thiết lập SSH Key trên Mac Lỗi: \u0026ldquo;Permission denied\u0026rdquo; hoặc \u0026ldquo;Authentication failed\u0026rdquo;\nCác nguyên nhân có thể xảy ra: - Tên người dùng hoặc mật khẩu không chính xác - SSH key chưa được cấu hình đúng cách - Quyền truy cập SSH bị vô hiệu hóa trên máy chủ từ xa\nGiải pháp: Xác minh thông tin xác thực và đảm bảo truy cập SSH đã được bật trên máy chủ từ xa.\nTunnel Drops Connection Lỗi: Kết nối bị ngắt sau một khoảng thời gian không hoạt động\nGiải pháp: Thêm cài đặt keep-alive vào file cấu hình SSH của bạn (~/.ssh/config):\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices Sử dụng SSH keys: An toàn hơn mật khẩu, khó bị xâm phạm hơn Vô hiệu hóa xác thực bằng mật khẩu: Sau khi đã thiết lập SSH keys, hãy tắt đăng nhập bằng mật khẩu trên máy chủ Sử dụng mật khẩu mạnh: Nếu sử dụng xác thực bằng mật khẩu, hãy dùng mật khẩu mạnh và duy nhất Giới hạn truy cập SSH: Cấu hình các quy tắc tường lửa để giới hạn truy cập SSH chỉ từ các IP đáng tin cậy Giữ SSH luôn cập nhật: Thường xuyên cập nhật phần mềm SSH client và server Giám sát logs: Kiểm tra các logs SSH trên máy chủ để phát hiện hoạt động đáng ngờ Sử dụng cổng SSH không chuẩn: Thay đổi cổng SSH mặc định (22) để giảm các cuộc tấn công tự động Tạo SSH Tunnel trên Linux Truy cập I2P Console Tạo một script để tự động thiết lập các tunnel:\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; Làm cho nó có thể thực thi:\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh Nhiều Tunnel Tạo một systemd service để tự động khởi tạo tunnel:\nsudo nano /etc/systemd/system/i2p-tunnel.service Thêm:\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target Kích hoạt và khởi động:\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling Cổng Cục Bộ Tùy Chỉnh Tạo một SOCKS proxy cho chuyển tiếp động:\nssh -D 8080 user@remote-server Cấu hình trình duyệt của bạn để sử dụng 127.0.0.1:8080 làm SOCKS5 proxy.\nReverse Tunneling Cho phép máy chủ từ xa truy cập các dịch vụ trên máy cục bộ của bạn:\nssh -R 7657:127.0.0.1:7657 user@remote-server Cổng Đã Được Sử Dụng Tunnel thông qua máy chủ trung gian:\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion SSH tunneling là một công cụ mạnh mẽ để truy cập an toàn các router I2P từ xa và các dịch vụ khác. Cho dù bạn đang sử dụng Windows, Linux hay Mac, quy trình này đều đơn giản và cung cấp mã hóa mạnh mẽ cho các kết nối của bạn.\nĐể được hỗ trợ thêm hoặc có thắc mắc, hãy truy cập cộng đồng I2P: - Diễn đàn: i2pforum.net - IRC: #i2p trên nhiều mạng khác nhau - Tài liệu: I2P Docs Tôi đã nhận được yêu cầu của bạn, nhưng tôi không thấy văn bản tiếng Anh nào cần dịch trong tin nhắn của bạn. Phần \u0026ldquo;Text to translate:\u0026rdquo; không có nội dung phía sau dấu \u0026ldquo;\u0026mdash;\u0026rdquo;.\nVui lòng cung cấp văn bản tiếng Anh cần dịch và tôi sẽ thực hiện ngay lập tức.\nHướng dẫn ban đầu được tạo bởi Stormy Cloud , được điều chỉnh cho tài liệu I2P.\n","description":"Tìm hiểu cách tạo SSH tunnel bảo mật trên Windows, Linux và Mac để truy cập router I2P từ xa của bạn","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"Tạo SSH Tunnel để Truy cập I2P từ Xa","url":"/vi/docs/guides/t%E1%BA%A1o-ssh-tunnel-%C4%91%E1%BB%83-truy-c%E1%BA%ADp-i2p-t%E1%BB%AB-xa/"},{"categories":null,"content":"Reseed host là cơ sở hạ tầng quan trọng cho mạng lưới I2P, cung cấp cho các router mới một nhóm node ban đầu trong quá trình khởi động. Hướng dẫn này sẽ chỉ cho bạn cách thiết lập và vận hành reseed server của riêng bạn.\nI2P Reseed Server là gì? Một máy chủ reseed I2P giúp tích hợp các router mới vào mạng I2P bằng cách:\nCung cấp khám phá peer ban đầu: Các router mới nhận được một tập hợp các node mạng khởi đầu để kết nối Khôi phục bootstrap: Hỗ trợ các router đang gặp khó khăn trong việc duy trì kết nối Phân phối bảo mật: Quá trình reseeding được mã hóa và ký số để đảm bảo an ninh mạng Khi một I2P router mới khởi động lần đầu tiên (hoặc đã mất tất cả các kết nối peer), nó sẽ liên hệ với các reseed server để tải xuống một tập hợp thông tin router ban đầu. Điều này cho phép router mới bắt đầu xây dựng netDb riêng của mình và thiết lập các tunnel.\nĐiều kiện tiên quyết Trước khi bắt đầu, bạn sẽ cần:\nMột máy chủ Linux (khuyến nghị Debian/Ubuntu) với quyền truy cập root Một tên miền trỏ về máy chủ của bạn Ít nhất 1GB RAM và 10GB dung lượng đĩa Một I2P router đang chạy trên máy chủ để điền dữ liệu vào network database Kiến thức cơ bản về quản trị hệ thống Linux Chuẩn bị Máy chủ Step 1: Update System and Install Dependencies Đầu tiên, cập nhật hệ thống của bạn và cài đặt các gói cần thiết:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y Lệnh này cài đặt: - golang-go: Môi trường thực thi ngôn ngữ lập trình Go - git: Hệ thống quản lý phiên bản - make: Công cụ tự động hóa biên dịch - docker.io \u0026amp; docker-compose: Nền tảng container để chạy Nginx Proxy Manager\nStep 2: Clone and Build Reseed Tools Clone kho reseed-tools và build ứng dụng:\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install Gói reseed-tools cung cấp chức năng cốt lõi để chạy một reseed server. Nó xử lý: - Thu thập thông tin router từ network database cục bộ của bạn - Đóng gói thông tin router vào các file SU3 đã ký - Phục vụ các file này qua HTTPS\nStep 3: Generate SSL Certificate Tạo chứng chỉ SSL và khóa riêng cho máy chủ reseed của bạn:\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Các tham số quan trọng: - --signer: Địa chỉ email của bạn (thay thế admin@stormycloud.org bằng địa chỉ của bạn) - --netdb: Đường dẫn đến cơ sở dữ liệu mạng (network database) của I2P router - --port: Cổng nội bộ (khuyến nghị 8443) - --ip: Gắn với localhost (chúng ta sẽ sử dụng reverse proxy để truy cập công khai) - --trustProxy: Tin tưởng các header X-Forwarded-For từ reverse proxy\nLệnh này sẽ tạo ra: - Một khóa riêng để ký các tệp SU3 - Một chứng chỉ SSL cho các kết nối HTTPS an toàn\nBước 1: Cập nhật Hệ thống và Cài đặt Các Gói Phụ thuộc Quan trọng: Sao lưu an toàn các khóa đã tạo nằm trong /home/i2p/.reseed/:\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ Lưu trữ bản sao lưu này ở một vị trí an toàn, được mã hóa và hạn chế quyền truy cập. Những khóa này rất quan trọng cho hoạt động của reseed server và cần được bảo vệ cẩn thận.\nConfiguring the Service Bước 2: Clone và Build Reseed Tools Tạo một systemd service để chạy reseed server tự động:\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF Hãy nhớ thay thế admin@stormycloud.org bằng địa chỉ email của riêng bạn.\nBây giờ hãy kích hoạt và khởi động dịch vụ:\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed Kiểm tra xem dịch vụ đang chạy:\nsudo systemctl status reseed Bước 3: Tạo Chứng chỉ SSL Để đạt hiệu suất tối ưu, bạn có thể muốn khởi động lại dịch vụ reseed định kỳ để làm mới thông tin router:\nsudo crontab -e Thêm dòng này để khởi động lại dịch vụ mỗi 3 giờ:\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy Máy chủ reseed chạy trên localhost:8443 và cần một reverse proxy để xử lý lưu lượng HTTPS công khai. Chúng tôi khuyến nghị sử dụng Nginx Proxy Manager vì dễ sử dụng.\nBước 4: Sao lưu các khóa của bạn Triển khai Nginx Proxy Manager sử dụng Docker:\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest Điều này mở các cổng: - Cổng 80: Lưu lượng HTTP - Cổng 81: Giao diện quản trị - Cổng 443: Lưu lượng HTTPS\nConfigure Proxy Manager Truy cập giao diện quản trị tại http://your-server-ip:81\nĐăng nhập với thông tin xác thực mặc định:\nEmail: admin@example.com Mật khẩu: changeme Quan trọng: Thay đổi thông tin đăng nhập này ngay sau lần đăng nhập đầu tiên!\nĐiều hướng đến Proxy Hosts và nhấp vào Add Proxy Host Cấu hình proxy host: Domain Name: Tên miền reseed của bạn (ví dụ: reseed.example.com) Scheme: https Forward Hostname / IP: 127.0.0.1 Forward Port: 8443 Bật Cache Assets Bật Block Common Exploits Bật Websockets Support Trong tab SSL: Chọn Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) Bật Force SSL Bật HTTP/2 Support Đồng ý với Điều khoản Dịch vụ của Let\u0026rsquo;s Encrypt Nhấp Save Server reseed của bạn bây giờ sẽ có thể truy cập được tại https://reseed.example.com\nRegistering Your Reseed Server Khi máy chủ reseed của bạn đã hoạt động, hãy liên hệ với các nhà phát triển I2P để được thêm vào danh sách máy chủ reseed chính thức.\nBước 5: Tạo Systemd Service Gửi email cho zzz (trưởng nhóm phát triển I2P) với các thông tin sau:\nEmail I2P: zzz@mail.i2p Email Clearnet: zzz@i2pmail.org Bước 6: Tùy chọn - Cấu hình Khởi động lại Định kỳ Bao gồm trong email của bạn:\nURL máy chủ reseed: URL HTTPS đầy đủ (ví dụ: https://reseed.example.com) Chứng chỉ reseed công khai: Nằm tại /home/i2p/.reseed/ (đính kèm tệp .crt) Email liên hệ: Phương thức liên hệ ưu tiên của bạn để nhận thông báo bảo trì máy chủ Vị trí máy chủ: Tùy chọn nhưng hữu ích (quốc gia/khu vực) Thời gian hoạt động dự kiến: Cam kết của bạn trong việc duy trì máy chủ Verification Các nhà phát triển I2P sẽ xác minh rằng reseed server của bạn: - Được cấu hình đúng và đang phục vụ thông tin router - Sử dụng chứng chỉ SSL hợp lệ - Cung cấp các tệp SU3 được ký đúng cách - Có thể truy cập và phản hồi tốt\nSau khi được phê duyệt, reseed server của bạn sẽ được thêm vào danh sách phân phối cùng với các I2P router, giúp người dùng mới tham gia vào mạng lưới!\nMonitoring and Maintenance Cài đặt Nginx Proxy Manager Giám sát dịch vụ reseed của bạn:\nsudo systemctl status reseed sudo journalctl -u reseed -f Cấu hình Proxy Manager Theo dõi tài nguyên hệ thống:\nhtop df -h Update Reseed Tools Định kỳ cập nhật reseed-tools để có được các cải tiến mới nhất:\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed Thông Tin Liên Hệ Nếu sử dụng Let\u0026rsquo;s Encrypt thông qua Nginx Proxy Manager, chứng chỉ sẽ tự động gia hạn. Xác minh quá trình gia hạn đang hoạt động:\ndocker logs nginx-proxy-manager | grep -i certificate Cấu hình Dịch vụ Thông tin Bắt buộc Kiểm tra logs để tìm lỗi:\nsudo journalctl -u reseed -n 50 Các vấn đề thường gặp: - I2P router chưa chạy hoặc netDb trống - Cổng 8443 đã được sử dụng - Vấn đề về quyền truy cập với thư mục /home/i2p/.reseed/\nXác minh Đảm bảo router I2P của bạn đang chạy và đã điền dữ liệu vào network database:\nls -lh /home/i2p/.i2p/netDb/ Bạn sẽ thấy nhiều tệp .dat. Nếu trống, hãy đợi router I2P của bạn khám phá các peer.\nSSL Certificate Errors Xác minh chứng chỉ của bạn hợp lệ:\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com Kiểm tra Trạng thái Dịch vụ Kiểm tra: - Bản ghi DNS đang trỏ đúng đến máy chủ của bạn - Tường lửa cho phép cổng 80 và 443 - Nginx Proxy Manager đang chạy: docker ps\nSecurity Considerations Bảo mật khóa riêng tư: Không bao giờ chia sẻ hoặc để lộ nội dung trong /home/i2p/.reseed/ Cập nhật thường xuyên: Giữ các gói hệ thống, Docker và reseed-tools ở phiên bản mới nhất Giám sát logs: Theo dõi các mẫu truy cập đáng ngờ Giới hạn tốc độ: Cân nhắc triển khai giới hạn tốc độ để ngăn chặn lạm dụng Quy tắc tường lửa: Chỉ mở các cổng cần thiết (80, 443, 81 cho admin) Giao diện quản trị: Hạn chế giao diện quản trị Nginx Proxy Manager (cổng 81) chỉ cho các IP đáng tin cậy Contributing to the Network Bằng cách vận hành một reseed server, bạn đang cung cấp cơ sở hạ tầng quan trọng cho mạng lưới I2P. Cảm ơn bạn đã đóng góp cho một internet riêng tư và phi tập trung hơn!\nNếu có thắc mắc hoặc cần hỗ trợ, hãy liên hệ với cộng đồng I2P: - Diễn đàn: i2pforum.net - IRC/Reddit: #i2p trên nhiều mạng khác nhau - Phát triển: i2pgit.org Hướng dẫn ban đầu được tạo bởi Stormy Cloud , chuyển thể cho tài liệu I2P.\n","description":"Hướng dẫn đầy đủ về cách thiết lập và vận hành máy chủ reseed I2P để giúp các router mới tham gia mạng lưới","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"Tạo và Chạy Máy Chủ Reseed I2P","url":"/vi/docs/guides/t%E1%BA%A1o-v%C3%A0-ch%E1%BA%A1y-m%C3%A1y-ch%E1%BB%A7-reseed-i2p/"},{"categories":null,"content":" 1. Tổng quan Một transport (cơ chế truyền tải) trong I2P là một phương thức giao tiếp trực tiếp, điểm-đến-điểm giữa các router. Các cơ chế này bảo đảm tính bí mật và toàn vẹn đồng thời thực hiện việc xác thực router.\nMỗi giao thức truyền tải hoạt động theo các mô hình kết nối với các tính năng như xác thực, điều khiển lưu lượng, cơ chế xác nhận và khả năng tái truyền.\n2. Các giao thức truyền tải hiện tại I2P hiện hỗ trợ hai giao thức truyền tải chính:\nTransport Protocol Description NTCP2 TCP Noise-based TCP transport with modern encryption (as of 0.9.36) SSU2 UDP Secure Semireliable UDP with modern encryption (as of 0.9.56) ### 2.1 Các phương thức truyền tải cũ (đã lỗi thời) Transport Protocol Status NTCP TCP Replaced by NTCP2; removed in 0.9.62 SSU UDP Replaced by SSU2; removed in 0.9.62 --- 3. Dịch vụ truyền tải Phân hệ truyền tải cung cấp các dịch vụ sau:\n3.1 Giao nhận thông điệp Giao nhận thông điệp I2NP đáng tin cậy (các giao thức truyền tải chỉ xử lý thông điệp I2NP) Giao nhận theo đúng thứ tự KHÔNG được đảm bảo trong mọi trường hợp Hàng đợi thông điệp dựa trên ưu tiên 3.2 Quản lý kết nối Thiết lập và kết thúc kết nối Quản lý giới hạn kết nối kèm áp dụng ngưỡng Theo dõi trạng thái theo từng nút ngang hàng (peer) Thực thi danh sách cấm nút ngang hàng tự động và thủ công 3.3 Cấu hình mạng Nhiều địa chỉ router cho mỗi giao thức truyền tải (hỗ trợ IPv4 và IPv6 kể từ v0.9.8) Mở cổng tường lửa qua UPnP Hỗ trợ xuyên NAT/tường lửa Phát hiện IP cục bộ bằng nhiều phương pháp 3.4 Bảo mật Mã hóa cho các trao đổi điểm-điểm Xác minh địa chỉ IP theo các quy tắc cục bộ Xác định đồng thuận thời gian (dự phòng NTP) 3.5 Quản lý băng thông Giới hạn băng thông vào và ra Lựa chọn phương thức truyền tối ưu cho các thông điệp gửi đi 4. Địa chỉ truyền tải Hệ thống con duy trì danh sách các điểm liên hệ của router:\nPhương thức truyền tải (NTCP2, SSU2) Địa chỉ IP Số cổng Tham số tùy chọn Có thể có nhiều địa chỉ cho mỗi phương thức truyền tải.\n4.1 Các cấu hình địa chỉ phổ biến Configuration Description Hidden Routers with no published addresses Firewalled Routers publishing SSU2 addresses with \"introducer\" peer lists for NAT traversal Unrestricted Routers advertising both NTCP2 and SSU2 addresses on IPv4 and/or IPv6 --- 5. Lựa chọn phương thức truyền tải Hệ thống chọn các giao thức truyền tải cho thông điệp I2NP một cách độc lập với các giao thức tầng trên. Việc lựa chọn sử dụng một hệ thống đấu giá, trong đó mỗi giao thức truyền tải gửi các mức chào giá, với giá trị thấp nhất sẽ thắng.\n5.1 Các yếu tố xác định giá thầu Thiết lập ưu tiên transport (lớp truyền tải) Các kết nối với nút ngang hàng hiện có Số lượng kết nối hiện tại so với ngưỡng Lịch sử các lần thử kết nối gần đây Giới hạn kích thước thông điệp Khả năng transport trong RouterInfo của nút ngang hàng Độ trực tiếp của kết nối (trực tiếp so với phụ thuộc vào introducer (nút giới thiệu)) Các ưu tiên transport do nút ngang hàng quảng bá Thông thường, hai router duy trì các kết nối đồng thời trên một giao thức truyền tải duy nhất, dù cũng có thể duy trì các kết nối đồng thời trên nhiều giao thức truyền tải.\n6. NTCP2 NTCP2 (Giao thức truyền tải mới 2) là giao thức truyền tải dựa trên TCP hiện đại cho I2P, được giới thiệu trong phiên bản 0.9.36.\n6.1 Các tính năng chính Dựa trên Noise Protocol Framework (khung giao thức Noise) (mẫu Noise_XK) Sử dụng X25519 cho trao đổi khóa Sử dụng ChaCha20/Poly1305 cho mã hóa xác thực Sử dụng BLAKE2s cho băm Ngụy trang giao thức để chống lại DPI (kiểm tra gói tin sâu) Đệm tùy chọn để chống phân tích lưu lượng 6.2 Thiết lập kết nối Yêu cầu phiên (Alice → Bob): Khóa X25519 tạm thời + dữ liệu được mã hóa Tạo phiên (Bob → Alice): Khóa tạm thời + xác nhận được mã hóa Xác nhận phiên (Alice → Bob): Bắt tay cuối cùng kèm RouterInfo (thông tin định danh của router trong I2P) Mọi dữ liệu về sau được mã hóa bằng các khóa phiên được dẫn xuất từ quá trình bắt tay.\nXem Đặc tả NTCP2 để biết đầy đủ thông tin chi tiết.\n7. SSU2 SSU2 (Secure Semireliable UDP 2) là phương thức truyền tải dựa trên UDP hiện đại cho I2P, được giới thiệu trong phiên bản 0.9.56.\n7.1 Các tính năng chính Dựa trên Noise Protocol Framework (khung giao thức Noise, mẫu Noise_XK) Sử dụng X25519 cho trao đổi khóa Sử dụng ChaCha20/Poly1305 cho mã hóa có xác thực Truyền tải bán tin cậy với các xác nhận chọn lọc Xuyên NAT qua hole punching (kỹ thuật đục lỗ kết nối) và chuyển tiếp/giới thiệu Hỗ trợ di chuyển kết nối Phát hiện MTU trên đường đi 7.2 Ưu điểm so với SSU (Legacy) Feature SSU (Legacy) SSU2 Encryption ElGamal + AES X25519 + ChaCha20/Poly1305 Header encryption Partial Full (ChaCha20) Connection ID Fixed Encrypted, rotatable NAT traversal Basic introduction Enhanced hole punching + relay Obfuscation Minimal Improved (variable padding) Xem [Đặc tả SSU2](/docs/specs/ssu2/) để biết mọi chi tiết. 8. Xuyên NAT Cả hai giao thức truyền tải đều hỗ trợ xuyên NAT để cho phép các router ở sau tường lửa tham gia vào mạng.\n8.1 Giới thiệu về SSU2 Khi một router không thể nhận kết nối đến trực tiếp:\nRouter công bố các địa chỉ introducer (nút giới thiệu) trong RouterInfo của nó Peer đang kết nối gửi yêu cầu giới thiệu tới introducer Introducer chuyển tiếp thông tin kết nối tới router bị tường lửa chặn Router bị tường lửa chặn khởi tạo kết nối đi ra (hole punch — đục lỗ NAT) Giao tiếp trực tiếp được thiết lập 8.2 NTCP2 và tường lửa NTCP2 yêu cầu khả năng kết nối TCP đến từ bên ngoài. Các router phía sau NAT có thể:\nSử dụng UPnP để tự động mở cổng Cấu hình chuyển tiếp cổng thủ công Dựa vào SSU2 cho các kết nối đến, đồng thời sử dụng NTCP2 cho các kết nối đi 9. Làm rối giao thức Cả hai cơ chế truyền tải hiện đại đều tích hợp các tính năng che giấu:\nĐệm ngẫu nhiên trong các thông điệp bắt tay Tiêu đề được mã hóa mà không để lộ dấu hiệu nhận dạng của giao thức Thông điệp có độ dài thay đổi để chống phân tích lưu lượng Không có mẫu cố định trong quá trình thiết lập kết nối Lưu ý: Kỹ thuật che giấu ở tầng vận chuyển bổ trợ nhưng không thay thế tính ẩn danh do kiến trúc tunnel của I2P cung cấp.\n10. Phát triển trong tương lai Các nghiên cứu và cải tiến được lên kế hoạch bao gồm:\nPluggable transports (các cơ chế truyền tải có thể cắm thêm) – Các plugin che giấu lưu lượng tương thích với Tor Truyền tải dựa trên QUIC – Khảo sát lợi ích của giao thức QUIC Tối ưu hóa giới hạn kết nối – Nghiên cứu xác định giới hạn kết nối ngang hàng tối ưu Chiến lược đệm nâng cao – Cải thiện khả năng chống phân tích lưu lượng 11. Tài liệu tham khảo Đặc tả NTCP2 – Giao thức truyền tải TCP dựa trên Noise Đặc tả SSU2 – UDP bán tin cậy, bảo mật 2 Đặc tả I2NP – Các thông điệp của Giao thức Mạng I2P Cấu trúc chung – RouterInfo và các cấu trúc địa chỉ Các thảo luận NTCP lịch sử – Lịch sử phát triển giao thức truyền tải kiểu cũ Tài liệu SSU cũ – Đặc tả SSU ban đầu (đã ngừng dùng) ","description":"Tìm hiểu tầng truyền tải của I2P - các phương thức giao tiếp điểm-điểm giữa các router, bao gồm NTCP2 và SSU2","id":"5fbac972dc212081634c49c5e6ac0004","section":"docs","title":"Tầng vận chuyển","url":"/vi/docs/overview/transport/"},{"categories":null,"content":" Lưu ý: Bài thảo luận lưu trữ này phác thảo các cách tiếp cận lịch sử đối với cơ sở dữ liệu mạng (netDb). Tham khảo tài liệu netDb chính để biết hành vi và hướng dẫn hiện tại.\nLịch sử netDb của I2P được phân phối bằng cách sử dụng một thuật toán floodfill đơn giản. Các bản phát hành sớm cũng duy trì một triển khai Kademlia DHT (bảng băm phân tán Kademlia) như phương án dự phòng, nhưng nó tỏ ra không đáng tin cậy và đã bị vô hiệu hóa hoàn toàn trong phiên bản 0.6.1.20. Thiết kế floodfill chuyển tiếp một mục đã được công bố tới một router tham gia, chờ xác nhận, và thử lại với các peer floodfill khác nếu cần. Các peer floodfill phát quảng bá các bản ghi lưu trữ từ các router không phải floodfill tới mọi thành viên floodfill khác.\nVào cuối năm 2009, việc tra cứu theo Kademlia (một thuật toán bảng băm phân tán - DHT) được tái áp dụng một phần nhằm giảm gánh nặng lưu trữ trên từng floodfill router.\nGiới thiệu về Floodfill Floodfill lần đầu xuất hiện trong bản phát hành 0.6.0.4, trong khi Kademlia (một thuật toán DHT - bảng băm phân tán) vẫn khả dụng như một phương án dự phòng. Vào thời điểm đó, tình trạng mất gói nghiêm trọng và các tuyến bị hạn chế khiến việc nhận được xác nhận từ bốn nút ngang hàng gần nhất trở nên khó khăn, thường phải thực hiện hàng chục lần thử lưu trữ dư thừa. Việc chuyển sang một tập con floodfill gồm các router có thể truy cập từ bên ngoài đã mang lại một giải pháp thực dụng trong ngắn hạn.\nXem xét lại Kademlia (thuật toán DHT) Một số phương án thay thế đã được xem xét bao gồm:\nVận hành netDb như một Kademlia DHT (bảng băm phân tán Kademlia) được giới hạn ở các routers có thể liên lạc được và chọn tham gia Giữ nguyên mô hình floodfill nhưng giới hạn việc tham gia ở các routers đủ khả năng và xác minh việc phân phối bằng các kiểm tra ngẫu nhiên Phương pháp floodfill được lựa chọn vì dễ triển khai hơn và netDb chỉ mang siêu dữ liệu, không mang tải (payload) của người dùng. Hầu hết các đích (destinations) không bao giờ công bố một LeaseSet vì bên gửi thường gói kèm LeaseSet của mình trong garlic messages (thông điệp Garlic).\nHiện trạng (Góc nhìn lịch sử) Các thuật toán netDb được tinh chỉnh cho phù hợp với nhu cầu của mạng và từ trước đến nay có thể xử lý thoải mái vài trăm router. Các ước tính ban đầu cho rằng 3–5 router floodfill có thể hỗ trợ khoảng 10,000 nút.\nCác tính toán cập nhật (Tháng 3 năm 2008) recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T Trong đó:\nN: Routers trong mạng L: Số lượng trung bình đích của client trên mỗi router (cộng thêm một cho RouterInfo) F: Tỷ lệ lỗi tunnel R: Chu kỳ xây dựng lại tunnel dưới dạng tỷ lệ so với thời gian tồn tại của tunnel S: Kích thước trung bình của bản ghi netDb T: Thời gian tồn tại của tunnel Sử dụng các giá trị của giai đoạn năm 2008 (N = 700, L = 0.5, F = 0.33, R = 0.5, S = 4 KB, T = 10 minutes) cho kết quả:\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps Kademlia (thuật toán bảng băm phân tán - DHT) sẽ quay trở lại chứ? Các nhà phát triển đã thảo luận về việc đưa Kademlia (thuật toán DHT—bảng băm phân tán) trở lại vào khoảng đầu năm 2007. Đồng thuận là năng lực floodfill có thể được mở rộng từng bước khi cần thiết, trong khi Kademlia làm tăng đáng kể độ phức tạp và yêu cầu về tài nguyên đối với tập router cơ sở. Phương án dự phòng vẫn ở trạng thái không hoạt động trừ khi năng lực floodfill trở nên không đủ.\nHoạch định dung lượng floodfill Việc tự động đưa các router thuộc lớp băng thông O vào floodfill, dù hấp dẫn, vẫn tiềm ẩn nguy cơ các kịch bản tấn công từ chối dịch vụ nếu các nút thù địch chọn tham gia. Phân tích lịch sử cho thấy việc giới hạn pool floodfill (ví dụ, 3–5 nút xử lý khoảng ~10K routers) sẽ an toàn hơn. Các nhà vận hành đáng tin cậy hoặc automatic heuristics (heuristic tự động) đã được sử dụng để duy trì một tập floodfill đủ nhưng có kiểm soát.\nFloodfill TODO (Lịch sử) Phần này được giữ lại vì mục đích lưu trữ. Trang netDb chính cập nhật lộ trình hiện tại và các cân nhắc về thiết kế.\nCác sự cố vận hành, chẳng hạn như một khoảng thời gian vào ngày 13 tháng 3 năm 2008 khi chỉ có một floodfill router khả dụng, đã thúc đẩy một số cải tiến được đưa vào các bản phát hành từ 0.6.1.33 đến 0.7.x, bao gồm:\nNgẫu nhiên hóa việc chọn floodfill khi tìm kiếm và ưu tiên các peer (nút ngang hàng) phản hồi tốt Hiển thị thêm các chỉ số floodfill trên trang \u0026ldquo;Profiles\u0026rdquo; của bảng điều khiển router Giảm dần kích thước bản ghi netDb để cắt giảm sử dụng băng thông floodfill Tự động opt-in (tự tham gia) cho một tập con các router lớp O dựa trên hiệu năng thu thập từ dữ liệu hồ sơ Tăng cường blocklisting (danh sách chặn), lựa chọn peer floodfill, và thuật suy nghiệm thăm dò Các ý tưởng còn lại từ giai đoạn đó bao gồm:\nSử dụng số liệu thống kê dbHistory để đánh giá và lựa chọn các nút floodfill tốt hơn Cải thiện hành vi thử lại để tránh liên tục liên hệ với các nút bị lỗi Tận dụng các số liệu độ trễ và điểm tích hợp trong khâu lựa chọn Phát hiện và phản ứng nhanh hơn trước các floodfill routers bị lỗi Tiếp tục giảm nhu cầu tài nguyên trên các nút băng thông cao và các nút floodfill Ngay tại thời điểm những ghi chú này được viết, mạng lưới được xem là có khả năng chống chịu tốt, với hạ tầng đã được thiết lập để phản ứng nhanh trước các floodfills thù địch hoặc các cuộc tấn công từ chối dịch vụ nhắm vào floodfill.\nGhi chú bổ sung Bảng điều khiển router từ lâu đã cung cấp dữ liệu hồ sơ nâng cao để hỗ trợ phân tích độ tin cậy của floodfill. Mặc dù các bình luận trong quá khứ đã suy đoán về Kademlia hoặc các sơ đồ DHT (bảng băm phân tán) thay thế, floodfill vẫn là thuật toán chủ đạo cho các mạng sản xuất. Các nghiên cứu hướng tới tương lai tập trung vào việc làm cho việc kết nạp floodfill trở nên thích ứng, đồng thời hạn chế cơ hội bị lạm dụng. ","description":"Ghi chú lịch sử về floodfill, các thử nghiệm Kademlia (một giao thức bảng băm phân tán - DHT), và các tinh chỉnh trong tương lai cho netDb","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"Thảo luận về Cơ sở dữ liệu mạng","url":"/vi/docs/netdb/"},{"categories":null,"content":" Bối cảnh: Trang này lưu trữ lại các cuộc tranh luận kéo dài từ giai đoạn thiết kế I2P thời kỳ đầu. Nó giải thích vì sao dự án ưu tiên sổ địa chỉ tin cậy cục bộ thay vì tra cứu theo kiểu DNS hoặc các hệ thống đăng ký dựa trên biểu quyết đa số. Để biết hướng dẫn sử dụng hiện tại, xem tài liệu Naming .\nCác phương án thay thế đã bị loại bỏ Các mục tiêu bảo mật của I2P loại trừ việc sử dụng các cơ chế đặt tên quen thuộc:\nPhân giải kiểu DNS. Bất kỳ trình phân giải nào trên tuyến tra cứu đều có thể giả mạo hoặc kiểm duyệt câu trả lời. Ngay cả với DNSSEC, các nhà đăng ký (registrar) hoặc tổ chức cấp chứng chỉ (CA) bị xâm phạm vẫn là một điểm lỗi đơn. Trong I2P, đích đến là khóa công khai—chiếm quyền một lần tra cứu sẽ làm lộ hoàn toàn một danh tính. Đặt tên dựa trên bỏ phiếu. Đối thủ có thể tạo ra vô hạn danh tính (Sybil attack: kẻ tấn công tạo nhiều danh tính giả) và “giành” phiếu cho các tên phổ biến. Các biện pháp giảm thiểu dựa trên proof-of-work (bằng chứng công việc) làm tăng chi phí nhưng kéo theo chi phí phối hợp lớn. Thay vào đó, I2P cố ý giữ việc đặt tên ở phía trên tầng vận chuyển. Thư viện đặt tên đi kèm cung cấp một service-provider interface (giao diện nhà cung cấp dịch vụ) để các cơ chế thay thế có thể cùng tồn tại—người dùng quyết định những sổ địa chỉ hoặc jump services (dịch vụ “nhảy” để phân giải tên) mà họ tin cậy.\nTên cục bộ và tên toàn cục (jrandom, 2005) Các tên trong I2P là duy nhất cục bộ nhưng dễ đọc đối với con người. boss.i2p của bạn có thể không khớp với boss.i2p của người khác, và điều đó là chủ ý. Nếu một tác nhân độc hại lừa bạn thay đổi destination (điểm đích) đằng sau một tên, họ sẽ chiếm đoạt một dịch vụ. Việc không đòi hỏi tính duy nhất toàn cục giúp ngăn chặn kiểu tấn công đó. Hãy coi các tên như dấu trang hoặc biệt danh IM—you choose which destinations to trust by subscribing to specific address books or adding keys manually. Các phản đối thường gặp \u0026amp; phản hồi (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. ## Các ý tưởng về hiệu suất đã được thảo luận Cung cấp các bản cập nhật tăng dần (chỉ các đích (Destination) được thêm kể từ lần tải gần nhất). Cung cấp các nguồn cấp dữ liệu bổ sung (recenthosts.cgi) bên cạnh các tệp hosts đầy đủ. Khám phá các công cụ hỗ trợ script (ví dụ, i2host.i2p) để hợp nhất các nguồn cấp hoặc lọc theo mức độ tin cậy. Các điểm chính Bảo mật được ưu tiên hơn đồng thuận toàn cầu: sổ địa chỉ được quản lý cục bộ giúp giảm thiểu rủi ro chiếm đoạt. Nhiều cách tiếp cận đặt tên có thể cùng tồn tại thông qua naming API (API đặt tên)—người dùng tự quyết định nên tin vào điều gì. Hệ thống đặt tên toàn cầu hoàn toàn phi tập trung vẫn là một vấn đề nghiên cứu còn bỏ ngỏ; những đánh đổi giữa bảo mật, khả năng dễ ghi nhớ đối với con người và tính duy nhất toàn cầu vẫn phản ánh tam giác của Zooko . Tài liệu tham khảo Tài liệu về đặt tên “Tên: Phi tập trung, Bảo mật, Có ý nghĩa với con người: Chọn hai” của Zooko Mẫu nguồn cấp dữ liệu tăng dần: stats.i2p/cgi-bin/newhosts.txt ","description":"Những tranh luận trong lịch sử về mô hình đặt tên của I2P và vì sao các phương án kiểu DNS toàn cục đã bị bác bỏ","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"Thảo luận về đặt tên","url":"/vi/docs/legacy/naming/"},{"categories":null,"content":"Thảo luận NTCP vs. SSU (tháng 3 năm 2007) Các câu hỏi về NTCP Phỏng theo một cuộc trò chuyện trên IRC giữa zzz và cervantes.\nTại sao NTCP được ưu tiên hơn SSU khi NTCP có vẻ như thêm phụ phí (overhead) và độ trễ?\nNTCP thường cung cấp độ tin cậy tốt hơn so với bản triển khai SSU ban đầu. Việc truyền (streaming) qua NTCP có gặp phải hiện tượng \u0026ldquo;TCP-over-TCP collapse\u0026rdquo; (sự sụp đổ hiệu năng khi TCP lồng trên TCP) kinh điển không?\nCó thể, nhưng SSU vốn được thiết kế như một lựa chọn UDP gọn nhẹ và đã tỏ ra quá kém tin cậy trong thực tế. “NTCP bị coi là có hại” (zzz, 25 tháng 3, 2007) Tóm tắt: Độ trễ cao hơn và overhead (phụ phí giao thức) của NTCP có thể gây tắc nghẽn, nhưng cơ chế định tuyến vẫn ưu tiên NTCP vì các điểm bid (điểm ưu tiên) của nó được cố định trong mã ở mức thấp hơn so với SSU. Phân tích đã nêu ra một số điểm:\nHiện NTCP có mức \u0026ldquo;bid\u0026rdquo; thấp hơn SSU, nên routers ưu tiên NTCP trừ khi một phiên SSU đã được thiết lập. SSU triển khai cơ chế xác nhận (ACK) với timeout được giới hạn chặt và có thống kê; NTCP dựa vào Java NIO TCP với các timeout kiểu RFC có thể dài hơn nhiều. Phần lớn lưu lượng (HTTP, IRC, BitTorrent) dùng thư viện streaming của I2P, thực chất là xếp lớp TCP lên trên NTCP. Khi cả hai lớp đều truyền lại, có thể xảy ra hiện tượng collapse (suy sụp do tắc nghẽn). Tài liệu kinh điển gồm TCP over TCP is a bad idea . Timeout của thư viện streaming đã tăng từ 10 s lên 45 s trong bản phát hành 0.8; timeout tối đa của SSU là 3 s, trong khi timeout của NTCP được cho là tiệm cận 60 s (khuyến nghị của RFC). Các tham số NTCP khó quan sát từ bên ngoài. Quan sát thực địa năm 2007 cho thấy thông lượng tải lên của i2psnark dao động, gợi ý tình trạng suy sụp do tắc nghẽn định kỳ. Các thử nghiệm hiệu năng (ép ưu tiên SSU) đã giảm tỷ lệ overhead của tunnel từ khoảng 3.5:1 xuống 3:1 và cải thiện các chỉ số streaming (kích thước cửa sổ, độ trễ khứ hồi (RTT), tỷ lệ gửi/ACK). Các đề xuất từ chủ đề năm 2007 Đảo ưu tiên truyền tải để routers ưu tiên SSU (khôi phục i2np.udp.alwaysPreferred). Gắn thẻ lưu lượng streaming (thư viện truyền theo luồng của I2P) để SSU ưu tiên thấp hơn chỉ đối với các thông điệp đã được gắn thẻ, mà không làm tổn hại đến tính ẩn danh. Siết chặt các giới hạn truyền lại của SSU để giảm rủi ro sụp đổ. Nghiên cứu các lớp nền bán tin cậy để xác định liệu việc truyền lại bên dưới thư viện streaming có mang lại lợi ích ròng hay không. Rà soát hàng đợi ưu tiên và thời gian chờ—ví dụ, tăng thời gian chờ của streaming vượt quá 45 s để phù hợp với NTCP. Phản hồi của jrandom (27 tháng 3 năm 2007) Các điểm phản biện chính:\nNTCP tồn tại vì các triển khai SSU thời kỳ đầu đã chịu hiện tượng sụp đổ do tắc nghẽn. Ngay cả các tỷ lệ truyền lại theo từng hop ở mức vừa phải cũng có thể bùng nổ trên các tunnel nhiều hop. Không có các xác nhận ở cấp độ tunnel, chỉ một phần thông điệp nhận được trạng thái chuyển phát đầu-cuối; các lỗi có thể diễn ra âm thầm. Cơ chế điều khiển tắc nghẽn của TCP đã được tối ưu hóa suốt hàng thập kỷ; NTCP tận dụng những điều đó thông qua các stack TCP trưởng thành. Mức tăng hiệu quả quan sát được khi ưu tiên SSU có thể phản ánh hành vi xếp hàng của router hơn là lợi thế nội tại của giao thức. Các timeout truyền theo luồng (streaming) dài hơn đã và đang cải thiện độ ổn định; khuyến khích có thêm quan sát và dữ liệu trước khi thực hiện thay đổi lớn. Cuộc tranh luận đã giúp hoàn thiện việc tối ưu hóa lớp truyền tải sau này nhưng không phản ánh kiến trúc NTCP2/SSU2 hiện đại.\n","description":"Ghi chú lịch sử so sánh các giao thức truyền tải NTCP và SSU và các ý tưởng tinh chỉnh được đề xuất","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"Thảo luận về NTCP","url":"/vi/docs/ntcp/"},{"categories":null,"content":" Lưu ý: Bản lưu trữ này ghi lại công việc thiết kế mang tính suy đoán có từ trước I2P 0.9.41. Đối với bản triển khai cho môi trường sản xuất, hãy tham khảo tài liệu về tunnel .\nCác lựa chọn cấu hình Các ý tưởng được cân nhắc cho các tham số cấu hình tunnel trong tương lai bao gồm:\nCơ chế điều tiết tần suất cho việc chuyển phát thông điệp Chính sách padding (đệm dữ liệu) (bao gồm chèn chaff (dữ liệu nhiễu giả)) Cơ chế kiểm soát vòng đời của Tunnel Chiến lược theo lô và hàng đợi cho việc phân phối tải dữ liệu Không có tùy chọn nào trong số này đi kèm với bản triển khai cũ.\nCác chiến lược đệm Các cách tiếp cận đệm tiềm năng đã được thảo luận:\nKhông có đệm nào cả Đệm độ dài ngẫu nhiên Đệm độ dài cố định Đệm đến kilobyte gần nhất Đệm theo lũy thừa của hai (2^n byte) Các phép đo ban đầu (phiên bản 0.4) đã dẫn tới kích thước thông điệp tunnel cố định hiện tại là 1024 byte. Các garlic messages (thông điệp \u0026ldquo;garlic\u0026rdquo; trong I2P) ở cấp cao hơn có thể thêm phần đệm riêng của chúng.\nPhân mảnh Để ngăn chặn các cuộc tấn công gắn thẻ dựa trên độ dài thông điệp, các thông điệp tunnel được cố định ở 1024 byte. Các payload I2NP (tải trọng dữ liệu I2NP) lớn hơn được cổng vào (gateway) phân mảnh; điểm cuối (endpoint) lắp ráp lại các mảnh trong một khoảng thời gian chờ ngắn. Các router có thể sắp xếp lại các mảnh để tối đa hóa hiệu quả đóng gói trước khi gửi.\nCác lựa chọn thay thế bổ sung Điều chỉnh xử lý Tunnel khi đang hoạt động Ba khả năng đã được xem xét:\nCho phép một chặng trung gian kết thúc một tunnel tạm thời bằng cách cấp quyền truy cập vào tải dữ liệu đã giải mã. Cho phép các router tham gia “remix” các thông điệp bằng cách gửi chúng qua một trong các tunnel đi ra của chính họ trước khi tiếp tục tới chặng tiếp theo. Cho phép người tạo tunnel tái xác định chặng kế tiếp của một điểm ngang hàng (peer) một cách động. Tunnels hai chiều Việc sử dụng các tunnel vào và ra riêng biệt giới hạn lượng thông tin mà bất kỳ một tập các nút ngang hàng nào có thể quan sát được (ví dụ, một yêu cầu GET so với một phản hồi lớn). Các tunnel hai chiều giúp đơn giản hóa việc quản lý các nút ngang hàng nhưng đồng thời làm lộ toàn bộ mẫu lưu lượng theo cả hai hướng. Do đó, các tunnel một chiều vẫn là thiết kế được ưu tiên.\nKênh ngược và kích thước biến đổi Việc cho phép các kích thước thông điệp tunnel (đường hầm) thay đổi sẽ tạo điều kiện cho các kênh ngầm giữa những nút ngang hàng thông đồng (ví dụ: mã hóa dữ liệu thông qua việc lựa chọn kích thước hoặc tần suất). Các thông điệp có kích thước cố định giúp giảm thiểu rủi ro này, nhưng phải đánh đổi bằng chi phí phần đệm bổ sung.\nCác phương án thay thế cho việc xây dựng Tunnel Tài liệu tham khảo: Hashing it out in Public Phương pháp xây dựng “Parallel” kiểu cũ Trước bản phát hành 0.6.1.10, các yêu cầu xây dựng tunnel được gửi song song tới từng nút tham gia. Phương pháp này được mô tả trên trang tunnel cũ .\nXây dựng kiểu Telescopic (mở rộng theo từng chặng) một lần (Phương pháp hiện tại) Cách tiếp cận hiện đại gửi các thông điệp dựng tunnel theo kiểu hop-by-hop (từng bước qua từng nút) dọc theo tunnel đang được xây dựng một phần. Mặc dù tương tự telescoping của Tor (mở rộng từng bước), việc định tuyến các thông điệp dựng tunnel qua các tunnel thăm dò giúp giảm rò rỉ thông tin.\n“Tương tác” Telescoping (mở rộng dần kiểu ống lồng) Xây dựng từng hop (chặng) một với các vòng khứ hồi tường minh cho phép các nút ngang hàng đếm các thông điệp và suy ra vị trí của họ trong tunnel, vì vậy cách tiếp cận này đã bị bác bỏ.\nCác Tunnels quản lý không thăm dò Một đề xuất là duy trì một nhóm tunnel quản lý riêng cho lưu lượng xây dựng tunnel. Mặc dù điều này có thể giúp các router bị phân tách, nhưng khi tích hợp mạng là đủ thì điều đó được coi là không cần thiết.\nChuyển phát thăm dò (Legacy) Trước 0.6.1.10, các yêu cầu tunnel riêng lẻ được mã hóa bằng garlic encryption và chuyển qua các tunnel thăm dò, với các phản hồi quay lại riêng biệt. Chiến lược này đã được thay thế bằng phương pháp one-shot telescoping (thiết lập đường đi qua nhiều chặng theo kiểu telescoping chỉ trong một lần gửi) hiện tại.\nCác điểm rút ra chính Các thông điệp tunnel kích thước cố định giúp chống lại đánh dấu dựa trên kích thước và các kênh bí mật, mặc dù phải chịu chi phí đệm (padding) bổ sung. Các phương án đệm, phân mảnh (fragmentation), và chiến lược xây dựng đã được xem xét nhưng không được áp dụng khi cân nhắc các đánh đổi về tính ẩn danh. Thiết kế tunnel tiếp tục cân bằng giữa hiệu quả, tính quan sát được, và khả năng chống lại các cuộc tấn công predecessor (tiền nhiệm) và congestion (nghẽn). ","description":"Khảo sát lịch sử về đệm cho tunnel, phân mảnh, và các chiến lược xây dựng","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"Thảo luận về Tunnel","url":"/vi/docs/legacy/tunnel/"},{"categories":null,"content":"Từ điển này định nghĩa các thuật ngữ phổ biến được sử dụng trong tài liệu và thảo luận về I2P.\nB Blockchain Một sổ cái phân tán có khả năng ghi lại các giao dịch giữa nhiều bên một cách hiệu quả, có thể xác minh và vĩnh viễn.\nD Phân tán hóa Kiến trúc mạng tránh phụ thuộc vào một bên duy nhất. Bao gồm các công nghệ ngang hàng (peer-to-peer), blockchain, liên bang (federated) và phân tán (distributed).\nDestination Định danh mật mã của một tunnel. Đây là các định danh của clients và servers trong mạng I2P.\nDHT (Distributed Hash Table) Được sử dụng trong một số dự án để kết nối các peer với nhau bằng cách lưu trữ thông tin dưới dạng cặp key-value theo cách phân tán.\nDistributed Systems (Hệ thống phân tán) Chủ đề học thuật trong Khoa học Máy tính liên quan đến thiết kế các hệ thống máy tính bao gồm nhiều máy tính riêng lẻ được kết nối qua mạng.\nF Federated Federation (liên kết) cho phép các triển khai riêng biệt của một dịch vụ giao tiếp với nhau thông qua một giao thức chung.\nH Hash Một số, thường được hiển thị dưới dạng chuỗi chữ cái và số. Nó có thể đóng vai trò như \u0026ldquo;dấu vân tay\u0026rdquo; để xác định duy nhất dữ liệu.\nI I2P Invisible Internet Project: một dự án nhằm cung cấp lớp ẩn danh, giúp người dùng có thể giao tiếp ẩn danh bằng nhiều ứng dụng khác nhau.\nĐịa chỉ IP Một số định danh của máy tính hoặc mạng là duy nhất và do đó có thể được sử dụng để xác định vị trí của nó.\nL LeaseSet Tập hợp các thông tin cần thiết để giao tiếp với một client hoặc server tại một Destination cụ thể.\nP Peer-to-Peer (P2P) Các peer cung cấp một phần tài nguyên của họ trực tiếp cho những người tham gia mạng khác, mà không cần sự điều phối tập trung từ các máy chủ hoặc các host ổn định.\nR Router Phần mềm I2P cốt lõi, định tuyến các gói tin được mã hóa trên mạng I2P.\nRouterIdentity Một tập hợp thông tin cần thiết để giao tiếp trực tiếp với một router.\nT TCP/UDP Hai giao thức truyền tải nền tảng được sử dụng trên Internet.\nTunnel Một đường truyền thông tin ẩn danh giữa client hoặc server và mạng I2P.\nU UX Trải nghiệm người dùng (User experience), trải nghiệm tổng thể của một người khi sử dụng sản phẩm hoặc dịch vụ.\nW WebRTC Một tiêu chuẩn giao thức để thiết lập kết nối trong trình duyệt web, trong đó dữ liệu được truyền trực tiếp giữa các người dùng.\n","description":"Các thuật ngữ và định nghĩa phổ biến được sử dụng trong tài liệu I2P","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"Thuật ngữ","url":"/vi/docs/overview/thu%E1%BA%ADt-ng%E1%BB%AF/"},{"categories":null,"content":" Không dùng nữa: Thư viện ministreaming ra đời trước thư viện streaming hiện nay. Các ứng dụng hiện đại phải sử dụng API streaming đầy đủ hoặc SAM v3. Thông tin bên dưới được giữ lại cho các nhà phát triển đang xem xét mã nguồn cũ được phân phối trong ministreaming.jar.\nTổng quan Ministreaming (lớp truyền tải dạng luồng tối giản) hoạt động ở phía trên I2CP để cung cấp việc truyền tải tin cậy, theo đúng thứ tự trên lớp thông điệp của I2P—tương tự như TCP qua IP. Ban đầu nó được tách ra từ ứng dụng I2PTunnel thời kỳ đầu (theo giấy phép BSD) để các giao thức truyền tải thay thế có thể phát triển độc lập.\nCác ràng buộc thiết kế chính:\nThiết lập kết nối hai pha kiểu cổ điển (SYN/ACK/FIN) mượn từ TCP Kích thước cửa sổ cố định là 1 gói Không có ID cho từng gói hoặc xác nhận chọn lọc Những lựa chọn này giữ cho phần triển khai nhỏ gọn nhưng hạn chế thông lượng—mỗi gói thường phải chờ gần như hai RTT (thời gian khứ hồi) trước khi gói tiếp theo được gửi đi. Với các luồng kéo dài, mức độ trễ này có thể chấp nhận được, nhưng các trao đổi ngắn theo kiểu HTTP bị ảnh hưởng rõ rệt.\nMối quan hệ với Streaming Library (thư viện truyền luồng) Thư viện streaming hiện tại mở rộng cùng một gói Java (net.i2p.client.streaming). Các lớp và phương thức đã bị đánh dấu là lỗi thời vẫn được giữ trong Javadocs, được chú thích rõ ràng để các nhà phát triển có thể nhận diện các API thời kỳ ministreaming (tên của thư viện streaming thu gọn trước đây). Khi thư viện streaming thay thế ministreaming, nó đã bổ sung:\nQuy trình thiết lập kết nối thông minh hơn với ít vòng khứ hồi hơn Cửa sổ tắc nghẽn thích ứng và logic tái truyền Hiệu năng tốt hơn trên các tunnels dễ mất gói Ministreaming đã hữu ích khi nào? Bất chấp những giới hạn của nó, ministreaming (cơ chế streaming tối giản) đã mang lại truyền tải đáng tin cậy trong những triển khai sớm nhất. API được cố ý giữ nhỏ gọn và sẵn sàng cho tương lai để các bộ máy streaming thay thế có thể được hoán đổi vào mà không phá vỡ mã gọi. Các ứng dụng Java liên kết trực tiếp với nó; các trình khách không dùng Java truy cập cùng chức năng thông qua hỗ trợ SAM cho các phiên streaming.\nHiện nay, hãy coi ministreaming.jar chỉ như một lớp tương thích. Phát triển mới nên:\nNhắm tới thư viện streaming đầy đủ (Java) hoặc SAM v3 (kiểu STREAM) Loại bỏ mọi giả định còn sót lại về fixed-window (cửa sổ cố định) khi hiện đại hóa mã Ưu tiên kích thước cửa sổ lớn hơn và bắt tay kết nối được tối ưu để cải thiện các khối lượng công việc nhạy cảm với độ trễ Tài liệu tham khảo Tài liệu Thư viện Streaming Javadoc của Streaming – bao gồm các lớp ministreaming không còn được khuyến nghị sử dụng Đặc tả SAM v3 – hỗ trợ streaming cho các ứng dụng không phải Java Nếu bạn gặp mã vẫn còn phụ thuộc vào ministreaming (cơ chế streaming tối giản cũ), hãy lên kế hoạch chuyển nó sang API streaming hiện đại—mạng lưới và các công cụ của nó mong đợi hành vi mới hơn.\n","description":"Ghi chú lịch sử về lớp vận chuyển tương tự TCP đầu tiên của I2P","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"Thư viện Ministreaming","url":"/vi/docs/legacy/ministreaming/"},{"categories":null,"content":"Tổng quan NTCP2 thay thế giao thức truyền tải NTCP cũ bằng cơ chế bắt tay dựa trên Noise (bộ khung giao thức mật mã Noise), có khả năng chống việc lập dấu vân tay lưu lượng, mã hóa các trường độ dài và hỗ trợ các cipher suites (tập hợp thuật toán mật mã) hiện đại. Các router có thể chạy NTCP2 cùng với SSU2 như hai giao thức truyền tải bắt buộc trong mạng I2P. NTCP (phiên bản 1) đã bị ngừng khuyến nghị sử dụng (deprecated) từ 0.9.40 (tháng 5/2019) và bị loại bỏ hoàn toàn trong 0.9.50 (tháng 5/2021).\nKhung giao thức Noise NTCP2 sử dụng Noise Protocol Framework (khung giao thức Noise) Revision 33, 2017-10-04 với các phần mở rộng dành riêng cho I2P:\nMẫu: Noise_XK_25519_ChaChaPoly_SHA256 Định danh mở rộng: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256 (dùng để khởi tạo KDF (hàm dẫn xuất khóa)) Hàm Diffie-Hellman (DH): X25519 (RFC 7748) - khóa 32 byte, biểu diễn little-endian Mật mã: AEAD_CHACHA20_POLY1305 (RFC 7539/RFC 8439) Nonce 12 byte: 4 byte đầu bằng 0, 8 byte cuối là bộ đếm (little-endian) Giá trị nonce tối đa: 2^64 - 2 (kết nối phải kết thúc trước khi đạt tới 2^64 - 1) Hàm băm: SHA-256 (đầu ra 32 byte) MAC: Poly1305 (thẻ xác thực 16 byte) Các phần mở rộng dành riêng cho I2P Làm mờ bằng AES: Khóa tạm thời được mã hóa bằng AES-256-CBC, sử dụng băm router của Bob và IV (vector khởi tạo) được công bố Đệm ngẫu nhiên: Đệm dạng rõ trong các thông điệp 1-2 (được xác thực), đệm AEAD trong thông điệp 3+ (được mã hóa) Làm mờ độ dài bằng SipHash-2-4: Độ dài khung 2 byte được XOR với đầu ra của SipHash Cấu trúc khung: Khung có tiền tố độ dài cho giai đoạn dữ liệu (tương thích truyền luồng TCP) Tải trọng dựa trên khối: Định dạng dữ liệu có cấu trúc với các khối có kiểu Quy trình bắt tay Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► Bắt tay ba thông điệp SessionRequest - khóa tạm thời được che giấu của Alice, các tùy chọn, gợi ý về đệm SessionCreated - khóa tạm thời được che giấu của Bob, các tùy chọn được mã hóa, phần đệm SessionConfirmed - khóa tĩnh được mã hóa của Alice và RouterInfo (hai khung AEAD) Các mẫu thông điệp của Noise XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 Mức xác thực: - 0: Không xác thực (bất kỳ bên nào cũng có thể đã gửi) - 2: Xác thực người gửi kháng key-compromise impersonation (KCI, giả mạo do lộ khóa)\nCác cấp độ tính bí mật: - 1: Người nhận tạm thời (tính bí mật chuyển tiếp, không xác thực người nhận) - 2: Người nhận đã biết, tính bí mật chuyển tiếp chỉ khi phía người gửi bị xâm phạm - 5: Tính bí mật chuyển tiếp mạnh (tạm thời-tạm thời + tạm thời-tĩnh DH)\nĐặc tả thông điệp Ký hiệu khóa RH_A = Router Hash cho Alice (32 byte, SHA-256) RH_B = Router Hash cho Bob (32 byte, SHA-256) || = toán tử nối byte(n) = một byte có giá trị n Tất cả các số nguyên nhiều byte dùng big-endian trừ khi có chỉ định khác Khóa X25519 ở dạng little-endian (32 byte) Mã hóa xác thực (ChaCha20-Poly1305) Hàm mã hóa:\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) Tham số: - key: khóa mã 32 byte từ KDF (hàm dẫn xuất khóa) - nonce: 12 byte (4 byte bằng 0 + bộ đếm 8 byte, little-endian) - associatedData: băm 32 byte trong pha bắt tay; độ dài bằng 0 trong pha dữ liệu - plaintext: Dữ liệu cần mã hóa (0+ byte)\nĐầu ra: - Bản mã: Cùng độ dài như bản rõ - MAC: 16 byte (thẻ xác thực Poly1305)\nQuản lý nonce (giá trị dùng một lần): - Bộ đếm bắt đầu từ 0 cho mỗi thể hiện bộ mã - Tăng thêm sau mỗi thao tác AEAD theo chiều đó - Có bộ đếm riêng cho Alice→Bob và Bob→Alice trong giai đoạn dữ liệu - Phải chấm dứt kết nối trước khi bộ đếm đạt tới 2^64 - 1\nThông điệp 1: SessionRequest (Yêu cầu phiên) Alice khởi tạo kết nối tới Bob.\nCác thao tác Noise: e, es (tạo và trao đổi khóa tạm thời)\nĐịnh dạng thô +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Giới hạn kích thước: - Tối thiểu: 80 byte (32 AES + 48 AEAD) - Tối đa: 65535 byte tổng cộng - Trường hợp đặc biệt: Tối đa 287 byte khi kết nối tới địa chỉ \u0026ldquo;NTCP\u0026rdquo; (giao thức truyền tải dựa trên TCP của I2P) (phát hiện phiên bản)\nNội dung đã giải mã +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Khối Tùy chọn (16 byte, thứ tự big-endian) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 Các trường quan trọng: - Network ID (kể từ 0.9.42): Từ chối nhanh các kết nối khác mạng - m3p2len: Kích thước chính xác của phần 2 của thông điệp 3 (phải khớp khi gửi)\nHàm dẫn xuất khóa (KDF-1) Khởi tạo giao thức:\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash Các phép toán MixHash:\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD Hoạt động MixKey (trộn khóa) (es pattern):\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF Ghi chú cài đặt Làm rối AES: Chỉ dùng để chống DPI (kiểm tra gói tin sâu); bất kỳ ai có router hash của Bob và IV (vector khởi tạo) đều có thể giải mã X Ngăn chặn phát lại: Bob phải lưu đệm các giá trị X (hoặc các tương đương đã mã hóa) trong ít nhất 2*D giây (D = độ lệch đồng hồ tối đa) Xác thực dấu thời gian: Bob phải từ chối các kết nối với |tsA - current_time| \u0026gt; D (thường D = 60 giây) Xác thực đường cong: Bob phải xác minh X là một điểm X25519 hợp lệ Từ chối nhanh: Bob có thể kiểm tra X[31] \u0026amp; 0x80 == 0 trước khi giải mã (khóa X25519 hợp lệ có MSB (bit có ý nghĩa cao nhất) bằng 0) Xử lý lỗi: Khi gặp lỗi bất kỳ, Bob đóng kết nối bằng TCP RST (gói RST của TCP) sau thời gian chờ ngẫu nhiên và đọc một lượng byte ngẫu nhiên Bộ đệm: Alice phải thực hiện flush (xả) toàn bộ thông điệp (bao gồm cả padding (phần đệm)) cùng lúc để đạt hiệu quả Thông điệp 2: SessionCreated Bob trả lời Alice.\nCác thao tác Noise: e, ee (DH tạm thời–tạm thời)\nĐịnh dạng thô +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Nội dung đã giải mã +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Khối Tùy chọn (16 byte, big-endian (thứ tự byte có trọng số lớn nhất trước)) +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) Hàm dẫn xuất khóa (KDF-2) Các phép toán MixHash:\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD Hoạt động MixKey (trộn khóa) (mẫu ee):\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF Dọn dẹp bộ nhớ:\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side Ghi chú hiện thực Xâu chuỗi AES: Mã hóa Y sử dụng trạng thái AES-CBC từ thông điệp 1 (không đặt lại) Ngăn chặn phát lại: Alice phải lưu vào bộ nhớ đệm các giá trị Y trong ít nhất 2*D giây Kiểm tra dấu thời gian: Alice phải từ chối khi |tsB - current_time| \u0026gt; D Xác minh đường cong: Alice phải xác minh Y là một điểm X25519 hợp lệ Xử lý lỗi: Alice đóng kết nối bằng TCP RST khi xảy ra bất kỳ lỗi nào Bộ đệm: Bob phải xả toàn bộ thông điệp trong một lần Thông điệp 3: SessionConfirmed (xác nhận phiên) Alice xác nhận phiên và gửi RouterInfo (thông tin về router).\nCác thao tác Noise: s, se (tiết lộ khóa tĩnh và DH giữa khóa tĩnh và khóa tạm thời)\nCấu trúc hai phần Thông điệp 3 bao gồm hai AEAD frames (khung AEAD) riêng biệt:\nPhần 1: Khung 48 byte cố định với khóa tĩnh được mã hóa của Alice Phần 2: Khung độ dài biến đổi với RouterInfo, các tùy chọn và phần đệm Định dạng thô +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Giới hạn kích thước: - Phần 1: Chính xác 48 byte (32 bản rõ + 16 MAC) - Phần 2: Độ dài được chỉ định trong thông điệp 1 (trường m3p2len) - Tổng tối đa: 65535 byte (phần 1 tối đa 48, nên phần 2 tối đa 65487)\nNội dung đã giải mã Phần 1:\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ Phần 2:\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ Hàm dẫn xuất khóa (KDF-3) Phần 1 (mẫu chữ s):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 Phần 2 (se pattern):\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF Dọn dẹp bộ nhớ:\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side Ghi chú hiện thực Xác thực RouterInfo (khối thông tin của router): Bob phải xác minh chữ ký, dấu thời gian và tính nhất quán của khóa Đối chiếu khóa: Bob phải xác minh khóa tĩnh của Alice ở phần 1 trùng khớp với khóa trong RouterInfo Vị trí khóa tĩnh: Tìm tham số \u0026ldquo;s\u0026rdquo; trùng khớp trong RouterAddress NTCP hoặc NTCP2 Thứ tự khối: RouterInfo phải đứng đầu, Options thứ hai (nếu có), Padding cuối cùng (nếu có) Lập kế hoạch độ dài: Alice phải bảo đảm m3p2len trong thông điệp 1 khớp chính xác với độ dài của phần 2 Đệm: Alice phải xả đệm cả hai phần trong cùng một lần gửi TCP duy nhất Xâu chuỗi tùy chọn: Alice có thể nối thêm một khung giai đoạn dữ liệu ngay lập tức để tăng hiệu quả Giai đoạn dữ liệu Sau khi hoàn tất quá trình bắt tay, tất cả các thông điệp sử dụng các khung AEAD (mã hóa xác thực kèm dữ liệu liên kết) có độ dài thay đổi, với các trường độ dài được che giấu.\nHàm dẫn xuất khóa (Giai đoạn dữ liệu) Hàm Split (Noise — khung giao thức mật mã):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) Dẫn xuất khóa bằng SipHash (hàm băm dùng khóa):\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV Cấu trúc khung +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ Ràng buộc khung: - Tối thiểu: 18 byte (2 độ dài đã làm nhiễu + 0 bản rõ + 16 MAC) - Tối đa: 65537 byte (2 độ dài đã làm nhiễu + 65535 khung) - Khuyến nghị: Vài KB mỗi khung (giảm thiểu độ trễ phía nhận)\nChe giấu độ dài bằng SipHash (hàm băm nhẹ, nhanh dùng cho bảng băm) Mục đích: Ngăn DPI (kiểm tra gói tin sâu) nhận diện ranh giới khung\nThuật toán:\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes Giải mã:\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) Ghi chú: - Tách các chuỗi IV (vector khởi tạo) cho từng hướng (Alice→Bob và Bob→Alice) - Nếu SipHash trả về uint64 (số nguyên không dấu 64-bit), dùng 2 byte có ý nghĩa thấp nhất làm mặt nạ - Chuyển đổi uint64 thành IV tiếp theo dưới dạng các byte little-endian (thứ tự byte từ thấp đến cao)\nĐịnh dạng khối Mỗi khung có thể chứa 0 hoặc nhiều khối:\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload Giới hạn kích thước: - Khung tối đa: 65535 byte (bao gồm MAC) - Không gian khối tối đa: 65519 byte (khung - MAC 16 byte) - Khối đơn tối đa: 65519 byte (phần đầu 3 byte + 65516 dữ liệu)\nCác loại khối Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions **Quy tắc sắp xếp khối:** - **Thông điệp 3 phần 2**: RouterInfo, Options (tùy chọn), Padding (tùy chọn) - KHÔNG có loại nào khác - **Giai đoạn dữ liệu**: Bất kỳ thứ tự nào, ngoại trừ: - Padding (đệm) PHẢI là khối cuối cùng nếu có - Termination (kết thúc) PHẢI là khối cuối cùng (ngoại trừ Padding) nếu có - Cho phép nhiều khối I2NP trên mỗi khung - KHÔNG cho phép nhiều khối Padding trên mỗi khung Loại khối 0: DateTime (ngày giờ) Đồng bộ hóa thời gian để phát hiện độ lệch đồng hồ.\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) Triển khai: Làm tròn đến giây gần nhất để ngăn tích lũy sai lệch đồng hồ.\nLoại khối 1: Tùy chọn Các tham số đệm và định hình lưu lượng.\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) Tỷ lệ đệm (số cố định 4.4 (fixed-point), giá trị/16.0): - tmin: Tỷ lệ đệm tối thiểu khi truyền (0.0 - 15.9375) - tmax: Tỷ lệ đệm tối đa khi truyền (0.0 - 15.9375) - rmin: Tỷ lệ đệm tối thiểu khi nhận (0.0 - 15.9375) - rmax: Tỷ lệ đệm tối đa khi nhận (0.0 - 15.9375)\nVí dụ: - 0x00 = 0% phần đệm - 0x01 = 6.25% phần đệm - 0x10 = 100% phần đệm (tỉ lệ 1:1) - 0x80 = 800% phần đệm (tỉ lệ 8:1)\nDummy Traffic (lưu lượng giả): - tdmy: Mức tối đa sẵn sàng gửi (2 byte, trung bình tính theo byte/giây) - rdmy: Mức được yêu cầu nhận (2 byte, trung bình tính theo byte/giây)\nChèn độ trễ: - tdelay: Độ trễ tối đa sẵn sàng chèn (2 byte, trung bình tính theo mili giây) - rdelay: Độ trễ được yêu cầu (2 byte, trung bình tính theo mili giây)\nHướng dẫn: - Giá trị tối thiểu biểu thị mức độ chống phân tích lưu lượng mong muốn - Giá trị tối đa biểu thị các ràng buộc về băng thông - Bên gửi nên tôn trọng mức tối đa của bên nhận - Bên gửi có thể tôn trọng mức tối thiểu của bên nhận trong phạm vi các ràng buộc - Không có cơ chế cưỡng chế; các triển khai có thể khác nhau\nKiểu khối 2: RouterInfo (thông tin về router) Phân phối RouterInfo (thông tin router) để bổ sung netdb và phát tán.\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 Cách sử dụng:\nTrong Thông điệp 3 Phần 2 (bắt tay): - Alice gửi RouterInfo (bản ghi thông tin của router trong I2P) của cô ấy cho Bob - Flood bit (cờ flood) thường là 0 (lưu trữ cục bộ) - RouterInfo KHÔNG nén gzip\nTrong Giai đoạn Dữ liệu: - Mỗi bên có thể gửi RouterInfo đã cập nhật của mình - bit Flood = 1: Yêu cầu phân phối qua floodfill (nếu bên nhận là floodfill) - bit Flood = 0: Chỉ lưu trữ cục bộ trong netdb\nYêu cầu xác minh: 1. Xác minh loại chữ ký được hỗ trợ 2. Xác minh chữ ký RouterInfo (thông tin router) 3. Xác minh dấu thời gian nằm trong giới hạn chấp nhận được 4. Đối với bắt tay: Xác minh khóa tĩnh khớp với tham số \u0026ldquo;s\u0026rdquo; của địa chỉ NTCP2 5. Đối với giai đoạn dữ liệu: Xác minh băm của router khớp với peer (đồng cấp) của phiên 6. Chỉ flood (phát tán) các RouterInfos với các địa chỉ đã công bố\nGhi chú: - Không có cơ chế ACK (sử dụng I2NP DatabaseStore (thông điệp DatabaseStore của I2NP) với token phản hồi nếu cần) - Có thể chứa các RouterInfos (bản ghi thông tin router) của bên thứ ba (sử dụng floodfill) - KHÔNG nén gzip (khác với I2NP DatabaseStore)\nLoại khối 3: Thông điệp I2NP Thông điệp I2NP với phần đầu 9 byte được rút gọn.\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) Khác biệt so với NTCP1: - Thời điểm hết hạn: 4 byte (giây) so với 8 byte (mili giây) - Độ dài: Được lược bỏ (có thể suy ra từ độ dài khối) - Checksum: Được lược bỏ (AEAD - mã hóa xác thực kèm dữ liệu liên kết - cung cấp tính toàn vẹn) - Header: 9 byte so với 16 byte (giảm 44%)\nPhân mảnh: - Thông điệp I2NP KHÔNG ĐƯỢC bị phân mảnh giữa các khối - Thông điệp I2NP KHÔNG ĐƯỢC bị phân mảnh giữa các khung - Nhiều khối I2NP được phép trên mỗi khung\nLoại khối 4: Kết thúc Đóng kết nối tường minh kèm mã lý do.\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) Mã lý do:\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny **Quy tắc:** - Termination (khối kết thúc) PHẢI là khối không phải phần đệm cuối cùng trong khung - Tối đa một khối Termination cho mỗi khung - Bên gửi nên đóng kết nối sau khi gửi - Bên nhận nên đóng kết nối sau khi nhận Xử lý lỗi: - Lỗi bắt tay: Thường đóng bằng TCP RST (không có khối kết thúc) - Lỗi AEAD (mã hóa xác thực kèm dữ liệu liên kết) ở giai đoạn dữ liệu: timeout ngẫu nhiên + đọc ngẫu nhiên, rồi gửi thông điệp kết thúc - Xem phần \u0026ldquo;AEAD Error Handling\u0026rdquo; để biết các thủ tục bảo mật\nLoại khối 254: Đệm Phần đệm ngẫu nhiên để tăng khả năng chống phân tích lưu lượng.\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes Quy tắc: - Phần đệm PHẢI là khối cuối cùng trong khung nếu có - Cho phép phần đệm độ dài bằng 0 - Chỉ một khối đệm cho mỗi khung - Cho phép các khung chỉ có phần đệm - Nên tuân theo các tham số đã thương lượng từ khối Options\nĐệm trong Thông điệp 1-2: - Nằm ngoài khung AEAD (mã hóa xác thực kèm dữ liệu) (bản rõ) - Được đưa vào chuỗi băm của thông điệp tiếp theo (được xác thực) - Phát hiện giả mạo khi AEAD của thông điệp tiếp theo thất bại\nĐệm trong Thông điệp 3+ và Giai đoạn Dữ liệu: - Bên trong khung AEAD (mã hóa xác thực đồng thời; được mã hóa và xác thực) - Dùng để định hình lưu lượng và che giấu kích thước\nXử lý lỗi AEAD (mã hóa xác thực kèm dữ liệu) Các yêu cầu bảo mật trọng yếu:\nGiai đoạn bắt tay (Thông điệp 1-3) Kích thước thông điệp đã biết: - Kích thước thông điệp được định sẵn hoặc được chỉ định trước - Lỗi xác thực AEAD (mã hóa xác thực kèm dữ liệu liên kết) là rõ ràng, không mơ hồ\nPhản hồi của Bob khi Thông điệp 1 thất bại: 1. Đặt thời hạn chờ ngẫu nhiên (khoảng phụ thuộc vào triển khai, đề xuất 100-500ms) 2. Đọc số byte ngẫu nhiên (khoảng phụ thuộc vào triển khai, đề xuất 1KB-64KB) 3. Đóng kết nối bằng TCP RST (không phản hồi) 4. Tạm thời đưa IP nguồn vào danh sách đen 5. Theo dõi các lỗi lặp lại để áp dụng lệnh cấm dài hạn\nPhản hồi của Alice khi Thông điệp 2 thất bại: 1. Đóng kết nối ngay lập tức bằng TCP RST 2. Không gửi phản hồi cho Bob\nPhản hồi của Bob khi Thông điệp 3 thất bại: 1. Đóng kết nối ngay lập tức bằng TCP RST 2. Không phản hồi cho Alice\nGiai đoạn dữ liệu Kích thước thông điệp được làm rối: - Trường độ dài được làm rối bằng SipHash - Độ dài không hợp lệ hoặc lỗi AEAD có thể cho thấy: - Thăm dò từ kẻ tấn công - Hỏng dữ liệu mạng - IV SipHash bị mất đồng bộ (IV: vector khởi tạo) - Nút ngang hàng độc hại\nPhản hồi đối với lỗi AEAD hoặc lỗi độ dài: 1. Đặt thời gian chờ ngẫu nhiên (đề xuất 100-500ms) 2. Đọc số lượng byte ngẫu nhiên (đề xuất 1KB-64KB) 3. Gửi khối kết thúc với mã lý do 4 (lỗi AEAD) hoặc 9 (lỗi khung) 4. Đóng kết nối\nNgăn chặn Decryption Oracle (oracle giải mã): - Không bao giờ tiết lộ loại lỗi cho đồng cấp trước khi hết một thời gian chờ ngẫu nhiên - Không bao giờ bỏ qua kiểm tra tính hợp lệ của độ dài trước khi kiểm tra AEAD (mã hóa xác thực với dữ liệu liên kết) - Xử lý độ dài không hợp lệ giống hệt như lỗi AEAD - Sử dụng cùng một luồng xử lý lỗi cho cả hai lỗi\nCác cân nhắc triển khai: - Một số triển khai có thể tiếp tục sau lỗi AEAD (mã hóa xác thực kèm dữ liệu liên kết) nếu lỗi hiếm khi xảy ra - Kết thúc sau khi lỗi lặp lại (ngưỡng đề xuất: 3-5 lỗi mỗi giờ) - Cân bằng giữa khả năng phục hồi sau lỗi và bảo mật\nRouterInfo (thông tin router) đã được công bố Định dạng địa chỉ Router Hỗ trợ NTCP2 được quảng bá thông qua các mục RouterAddress được công bố với các tùy chọn cụ thể.\nKiểu truyền tải: - \u0026quot;NTCP2\u0026quot; - Chỉ NTCP2 trên cổng này - \u0026quot;NTCP\u0026quot; - Cả NTCP và NTCP2 trên cổng này (tự động phát hiện) - Lưu ý: Hỗ trợ NTCP (v1) đã bị loại bỏ trong 0.9.50 (Tháng 5/2021) - Kiểu \u0026ldquo;NTCP\u0026rdquo; hiện đã lỗi thời; hãy dùng \u0026ldquo;NTCP2\u0026rdquo;\nTùy chọn bắt buộc Tất cả các địa chỉ NTCP2 đã được công bố:\nhost - Địa chỉ IP (IPv4 hoặc IPv6) hoặc tên máy chủ\nĐịnh dạng: Ký hiệu IP chuẩn hoặc tên miền Có thể bỏ qua đối với router chỉ đi ra (outbound-only) hoặc router ẩn (hidden) port - số cổng TCP\nĐịnh dạng: Số nguyên, 1-65535 Có thể bỏ qua đối với router outbound-only (chỉ gửi ra) hoặc router ẩn s - Khóa công khai tĩnh (X25519)\nĐịnh dạng: được mã hóa Base64, 44 ký tự Mã hóa: bảng chữ cái Base64 của I2P Nguồn: khóa công khai X25519 32 byte, little-endian (thứ tự byte thấp trước) i - Vector khởi tạo cho AES\nĐịnh dạng: được mã hóa Base64, 24 ký tự Bảng mã: bảng chữ cái Base64 của I2P Nguồn: IV 16 byte, big-endian (thứ tự byte đầu lớn) v - Phiên bản giao thức\nĐịnh dạng: Số nguyên hoặc các số nguyên phân tách bằng dấu phẩy Hiện tại: \u0026quot;2\u0026quot; Tương lai: \u0026quot;2,3\u0026quot; (phải theo thứ tự số tăng dần) Các tùy chọn không bắt buộc:\ncaps - Khả năng (từ 0.9.50)\nĐịnh dạng: Chuỗi các ký tự khả năng Giá trị: \u0026quot;4\u0026quot; - Khả năng kết nối ra ngoài IPv4 \u0026quot;6\u0026quot; - Khả năng kết nối ra ngoài IPv6 \u0026quot;46\u0026quot; - Cả IPv4 và IPv6 (thứ tự khuyến nghị) Không cần thiết nếu host được công bố Hữu ích cho routers ẩn/bị tường lửa chặn cost - Ưu tiên địa chỉ\nĐịnh dạng: Số nguyên, 0-255 Giá trị thấp hơn = ưu tiên cao hơn Gợi ý: 5-10 cho địa chỉ thông thường Gợi ý: 14 cho các địa chỉ chưa công bố Ví dụ các mục RouterAddress Địa chỉ IPv4 được công bố:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Router ẩn (chỉ gửi đi):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Router hai ngăn xếp:\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Quy tắc quan trọng: - Nhiều địa chỉ NTCP2 với cùng cổng PHẢI sử dụng giống hệt các giá trị s, i, và v - Các cổng khác nhau có thể sử dụng các khóa khác nhau - Các router dual-stack (hỗ trợ cả IPv4 và IPv6) nên công bố các địa chỉ IPv4 và IPv6 riêng biệt\nĐịa chỉ NTCP2 chưa được công bố Dành cho các router chỉ kết nối ra ngoài:\nNếu một router không chấp nhận các kết nối NTCP2 đến nhưng khởi tạo các kết nối đi, thì nó PHẢI vẫn công bố một RouterAddress (địa chỉ Router) bao gồm:\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Mục đích: - Cho phép Bob xác thực khóa tĩnh của Alice trong quá trình bắt tay - Bắt buộc cho việc xác minh RouterInfo (thông tin về router) ở thông điệp 3, phần 2 - Không cần i, host hoặc port (chỉ hướng ra)\nPhương án thay thế: - Thêm s và v vào địa chỉ \u0026ldquo;NTCP\u0026rdquo; hoặc SSU đã được công bố hiện có\nLuân chuyển khóa công khai và IV (vector khởi tạo) Chính sách bảo mật trọng yếu:\nQuy tắc chung: 1. Không bao giờ luân chuyển khi router đang chạy 2. Lưu trữ bền vững khóa và IV (vector khởi tạo) qua các lần khởi động lại 3. Theo dõi thời gian ngừng hoạt động trước đó để xác định đủ điều kiện luân chuyển\nThời gian ngừng hoạt động tối thiểu trước khi luân chuyển:\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact **Các điều kiện kích hoạt bổ sung:** - Thay đổi địa chỉ IP cục bộ: Có thể xoay vòng bất kể thời gian ngừng hoạt động - Router \"rekey\" (new Router Hash): Tạo khóa mới Lý do: - Ngăn lộ thời điểm khởi động lại thông qua việc thay đổi khóa - Cho phép các RouterInfos (thông tin router) được lưu trong bộ nhớ đệm hết hạn tự nhiên - Duy trì sự ổn định của mạng - Giảm số lần thử kết nối thất bại\nTriển khai: 1. Lưu trữ khóa, IV (vector khởi tạo), và dấu thời gian lần tắt trước lâu dài 2. Khi khởi động, tính downtime = current_time - last_shutdown 3. Nếu downtime \u0026gt; mức tối thiểu cho loại router, có thể xoay vòng khóa/IV 4. Nếu IP thay đổi hoặc đang thay khóa, có thể xoay vòng khóa/IV 5. Nếu không, tái sử dụng khóa và IV trước đó\nXoay vòng IV (vector khởi tạo): - Tuân theo các quy tắc giống hệt như xoay vòng khóa - Chỉ xuất hiện trong các địa chỉ đã công bố (không áp dụng cho routers ẩn) - Khuyến nghị thay IV mỗi khi khóa thay đổi\nPhát hiện phiên bản Ngữ cảnh: Khi transportStyle=\u0026quot;NTCP\u0026quot; (kiểu cũ), Bob hỗ trợ cả NTCP (giao thức truyền tải của I2P) v1 và v2 trên cùng một cổng và phải tự động phát hiện phiên bản giao thức.\nThuật toán phát hiện:\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 Kiểm tra MSB (bit có trọng số lớn nhất) nhanh: - Trước khi giải mã AES, xác minh: encrypted_X[31] \u0026amp; 0x80 == 0 - Khóa X25519 hợp lệ có bit cao bằng 0 - Thất bại cho thấy có thể là NTCP1 (hoặc tấn công) - Triển khai cơ chế chống dò quét (thời gian chờ ngẫu nhiên + đọc) khi thất bại\nYêu cầu triển khai:\nTrách nhiệm của Alice:\nKhi kết nối tới địa chỉ \u0026ldquo;NTCP\u0026rdquo;, giới hạn độ dài thông điệp 1 tối đa 287 byte Buffer (đệm) và flush (xả) toàn bộ thông điệp 1 trong một lần Tăng khả năng truyền trong một gói TCP duy nhất Trách nhiệm của Bob:\nĐệm dữ liệu nhận được trước khi xác định phiên bản Triển khai xử lý timeout (hết thời gian chờ) đúng cách Sử dụng TCP_NODELAY để phát hiện phiên bản nhanh chóng Đệm và flush (xả bộ đệm) toàn bộ thông điệp 2 cùng lúc sau khi xác định phiên bản Các cân nhắc bảo mật: - Tấn công phân đoạn: Bob nên kháng chịu việc phân đoạn TCP - Tấn công thăm dò: Triển khai độ trễ ngẫu nhiên và đọc theo byte khi xảy ra lỗi - Phòng chống DoS (tấn công từ chối dịch vụ): Giới hạn số kết nối đang chờ đồng thời - Thời gian chờ khi đọc: Cả theo từng lần đọc và tổng thể (bảo vệ khỏi \u0026ldquo;slowloris\u0026rdquo;)\nHướng dẫn về độ lệch đồng hồ Các trường dấu thời gian: - Thông điệp 1: tsA (dấu thời gian của Alice) - Thông điệp 2: tsB (dấu thời gian của Bob) - Thông điệp 3+: Các khối DateTime (ngày-giờ) tùy chọn\nĐộ lệch thời gian tối đa (D): - Thông thường: ±60 giây - Có thể cấu hình theo từng triển khai - Độ lệch \u0026gt; D thường gây lỗi chí mạng\nCách Bob xử lý (Thông điệp 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally Lý do: Việc gửi thông điệp 2 ngay cả khi có sai lệch thời gian (skew) cho phép Alice chẩn đoán các vấn đề về đồng hồ.\nCách xử lý của Alice (Thông điệp 2) 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization Điều chỉnh RTT (thời gian khứ hồi): - Trừ một nửa RTT khỏi độ lệch đã tính - Tính đến độ trễ lan truyền của mạng - Ước tính độ lệch chính xác hơn\nCách Bob xử lý (Thông điệp 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) Đồng bộ thời gian Các khối DateTime (ngày-giờ) (Giai đoạn dữ liệu): - Gửi khối DateTime (loại 0) theo định kỳ - Bên nhận có thể dùng để hiệu chỉnh đồng hồ - Làm tròn dấu thời gian về giây gần nhất (tránh sai lệch)\nNguồn thời gian bên ngoài: - NTP (Giao thức thời gian mạng) - Đồng bộ hóa đồng hồ hệ thống - Thời gian đồng thuận của mạng I2P\nChiến lược điều chỉnh đồng hồ: - Nếu đồng hồ cục bộ bị sai: Điều chỉnh thời gian hệ thống hoặc dùng offset (độ bù) - Nếu đồng hồ của các nút ngang hàng thường xuyên sai: Gắn cờ vấn đề ở nút ngang hàng - Theo dõi thống kê độ lệch (skew) để giám sát sức khỏe mạng\nThuộc tính bảo mật Tính bí mật chuyển tiếp Đạt được thông qua: - Trao đổi khóa Diffie-Hellman tạm thời (X25519) - Ba phép toán DH: es, ee, se (Noise XK pattern (mẫu Noise XK)) - Khóa tạm thời được hủy sau khi hoàn tất bắt tay\nTiến triển về tính bí mật: - Thông điệp 1: Mức 2 (bí mật chuyển tiếp khi bên gửi bị thỏa hiệp) - Thông điệp 2: Mức 1 (người nhận tạm thời) - Thông điệp 3+: Mức 5 (bí mật chuyển tiếp mạnh)\nBí mật chuyển tiếp hoàn hảo: - Việc bị xâm phạm các khóa tĩnh dài hạn KHÔNG làm lộ các khóa phiên trong quá khứ - Mỗi phiên sử dụng các khóa tạm thời duy nhất - Các khóa riêng tạm thời không bao giờ được tái sử dụng - Dọn sạch bộ nhớ sau khi thỏa thuận khóa\nHạn chế: - Thông điệp 1 dễ bị tấn công nếu khóa tĩnh của Bob bị lộ (nhưng vẫn có forward secrecy (bí mật chuyển tiếp) nếu Alice bị xâm phạm) - Có thể xảy ra tấn công phát lại đối với thông điệp 1 (giảm thiểu bằng dấu thời gian và bộ đệm phát lại)\nXác thực Xác thực lẫn nhau: - Alice được xác thực bằng khóa tĩnh trong thông điệp 3 - Bob được xác thực bằng việc sở hữu khóa riêng tĩnh (ngầm định từ quá trình bắt tay thành công)\nKhả năng kháng Key Compromise Impersonation (mạo danh khi lộ khóa, KCI): - Cấp độ xác thực 2 (kháng KCI) - Kẻ tấn công không thể mạo danh Alice ngay cả khi có khóa riêng tĩnh của Alice (mà không có khóa tạm thời của Alice) - Kẻ tấn công không thể mạo danh Bob ngay cả khi có khóa riêng tĩnh của Bob (mà không có khóa tạm thời của Bob)\nXác minh khóa tĩnh: - Alice biết khóa tĩnh của Bob từ trước (từ RouterInfo) - Bob xác minh khóa tĩnh của Alice khớp với RouterInfo trong thông điệp 3 - Ngăn chặn tấn công kẻ trung gian (man-in-the-middle)\nKhả năng chống phân tích lưu lượng Biện pháp đối phó DPI (kiểm tra gói tin sâu): 1. Che giấu bằng AES: Các khóa tạm thời được mã hóa, trông ngẫu nhiên 2. Che giấu độ dài bằng SipHash: Độ dài khung không ở dạng rõ 3. Đệm ngẫu nhiên: Kích thước thông điệp thay đổi, không có mẫu cố định 4. Khung được mã hóa: Toàn bộ tải trọng được mã hóa bằng ChaCha20\nNgăn chặn tấn công phát lại: - Xác thực dấu thời gian (±60 giây) - Bộ đệm phát lại cho các khóa tạm thời (thời gian sống 2*D) - Việc tăng nonce (số dùng một lần) ngăn phát lại gói tin trong cùng phiên\nKhả năng chống thăm dò: - Hết thời gian chờ ngẫu nhiên khi xảy ra lỗi AEAD - Đọc các byte ngẫu nhiên trước khi đóng kết nối - Không phản hồi khi xảy ra lỗi bắt tay - Đưa IP vào danh sách đen khi lỗi lặp lại\nHướng dẫn về đệm: - Thông điệp 1-2: Đệm dạng rõ (được xác thực) - Thông điệp 3+: Đệm được mã hóa bên trong các khung AEAD (xác thực kèm dữ liệu) - Tham số đệm được thương lượng (Options block) - Cho phép các khung chỉ chứa đệm\nGiảm thiểu tấn công từ chối dịch vụ Giới hạn kết nối: - Số kết nối đang hoạt động tối đa (phụ thuộc vào cách triển khai) - Số bắt tay đang chờ tối đa (ví dụ: 100-1000) - Giới hạn kết nối theo từng IP (ví dụ: 3-10 đồng thời)\nBảo vệ tài nguyên: - Giới hạn tốc độ hoạt động DH (tốn tài nguyên) - Thời gian chờ đọc theo từng socket và tổng thể - Bảo vệ trước \u0026ldquo;Slowloris\u0026rdquo; (giới hạn tổng thời gian) - Đưa IP vào danh sách đen khi lạm dụng\nTừ chối nhanh: - Không khớp Network ID → đóng ngay lập tức - Điểm X25519 không hợp lệ → kiểm tra nhanh MSB (bit có trọng số lớn nhất) trước khi giải mã - Dấu thời gian ngoài phạm vi → đóng mà không cần tính toán - Lỗi AEAD (mã hóa xác thực kèm dữ liệu) → không phản hồi, trễ ngẫu nhiên\nKhả năng chống thăm dò: - Thời gian chờ ngẫu nhiên: 100-500ms (phụ thuộc vào triển khai) - Đọc ngẫu nhiên: 1KB-64KB (phụ thuộc vào triển khai) - Không cung cấp thông tin lỗi cho kẻ tấn công - Đóng bằng TCP RST (không thực hiện bắt tay FIN)\nAn toàn mật mã Thuật toán: - X25519: mức an toàn 128-bit, DH trên đường cong elliptic (Curve25519) - ChaCha20: mật mã dòng khóa 256-bit - Poly1305: MAC an toàn theo lý thuyết thông tin - SHA-256: kháng va chạm 128-bit, kháng tiền ảnh 256-bit - HMAC-SHA256: PRF (hàm giả ngẫu nhiên) để dẫn xuất khóa\nKích thước khóa: - Khóa tĩnh: 32 byte (256 bit) - Khóa tạm thời: 32 byte (256 bit) - Khóa mã hóa: 32 byte (256 bit) - MAC (mã xác thực thông điệp): 16 byte (128 bit)\nCác vấn đề đã biết: - Tái sử dụng nonce của ChaCha20 gây hậu quả thảm khốc (được ngăn ngừa bằng cách tăng bộ đếm) - X25519 có vấn đề về nhóm con nhỏ (giảm thiểu bằng xác thực đường cong) - SHA-256 về mặt lý thuyết dễ bị tấn công mở rộng độ dài (không thể khai thác trong HMAC)\nKhông có lỗ hổng đã biết (tính đến tháng 10 năm 2025): - Noise Protocol Framework (khung giao thức Noise) đã được phân tích rộng rãi - ChaCha20-Poly1305 được triển khai trong TLS 1.3 - X25519 là tiêu chuẩn trong các giao thức hiện đại - Không có tấn công thực tế vào thiết kế (construction)\nTài liệu tham khảo Các đặc tả chính Đặc tả NTCP2 - Đặc tả I2P chính thức Đề xuất 111 - Tài liệu thiết kế ban đầu kèm phần giải thích lý do Noise Protocol Framework - Bản sửa đổi 33 (2017-10-04) Các tiêu chuẩn mật mã RFC 7748 - Đường cong elliptic cho bảo mật (X25519) RFC 7539 - ChaCha20 và Poly1305 cho các giao thức của IETF RFC 8439 - ChaCha20-Poly1305 (thay thế RFC 7539) RFC 2104 - HMAC: Băm có khóa để xác thực thông điệp SipHash - SipHash-2-4 cho các ứng dụng của hàm băm Các đặc tả kỹ thuật I2P liên quan I2NP Specification - định dạng thông điệp của giao thức mạng I2P Common Structures - các định dạng RouterInfo, RouterAddress SSU Transport - transport UDP (ban đầu, nay là SSU2) Proposal 147 - Kiểm tra Transport Network ID (0.9.42) Tài liệu tham khảo triển khai I2P Java - Bản triển khai tham chiếu (Java) i2pd - Triển khai C++ I2P Release Notes - Lịch sử phiên bản và cập nhật Bối cảnh lịch sử Station-To-Station Protocol (STS) - Nguồn cảm hứng cho Noise framework (khung giao thức Noise) obfs4 - Pluggable transport (cơ chế truyền tải có thể cắm thêm; tiền lệ che giấu độ dài bằng SipHash) Hướng dẫn hiện thực Các yêu cầu bắt buộc Vì mục đích tuân thủ:\nTriển khai bắt tay hoàn chỉnh:\nHỗ trợ cả ba thông điệp với các chuỗi KDF (hàm dẫn xuất khóa) chính xác Kiểm tra tính hợp lệ của mọi thẻ AEAD (mã hóa xác thực kèm dữ liệu) Xác minh rằng các điểm X25519 (thuật toán trao đổi khóa dựa trên đường cong elliptic Curve25519) là hợp lệ Triển khai Giai đoạn Dữ liệu:\nChe giấu độ dài bằng SipHash (theo cả hai hướng) Tất cả các loại khối: 0 (DateTime), 1 (Options), 2 (RouterInfo), 3 (I2NP), 4 (Termination), 254 (Padding) Quản lý nonce (số dùng một lần) đúng cách (các bộ đếm riêng biệt) Các tính năng bảo mật:\nNgăn chặn phát lại (lưu cache các khóa tạm thời trong 2*D) Xác minh dấu thời gian (mặc định ±60 giây) Đệm ngẫu nhiên trong các thông điệp 1-2 Xử lý lỗi AEAD (Authenticated Encryption with Associated Data - mã hóa xác thực kèm dữ liệu) với thời gian chờ ngẫu nhiên Công bố RouterInfo:\nCông bố khóa tĩnh (\u0026ldquo;s\u0026rdquo;), IV (\u0026ldquo;i\u0026rdquo;), và phiên bản (\u0026ldquo;v\u0026rdquo;) Luân chuyển khóa theo chính sách Hỗ trợ trường capabilities (\u0026ldquo;caps\u0026rdquo;) cho router ẩn Khả năng tương thích mạng:\nHỗ trợ trường Network ID (hiện là 2 đối với mainnet (mạng chính)) Tương tác liên thông với các triển khai Java và i2pd hiện có Hỗ trợ cả IPv4 và IPv6 Thực tiễn khuyến nghị Tối ưu hóa hiệu năng:\nChiến lược đệm:\nXả toàn bộ thông điệp cùng lúc (thông điệp 1, 2, 3) Sử dụng TCP_NODELAY cho các thông điệp bắt tay Gộp nhiều khối dữ liệu vào các khung đơn Giới hạn kích thước khung ở vài KB (giảm thiểu độ trễ phía nhận) Quản lý kết nối:\nTái sử dụng các kết nối khi có thể Triển khai connection pooling (bể kết nối) Giám sát tình trạng kết nối (DateTime blocks - tình trạng bị chặn liên quan đến DateTime) Quản lý bộ nhớ:\nXóa sạch dữ liệu nhạy cảm sau khi sử dụng (khóa tạm thời, kết quả DH (Diffie-Hellman)) Giới hạn số lượng bắt tay đồng thời (ngăn chặn DoS (tấn công từ chối dịch vụ)) Sử dụng pool bộ nhớ cho các lần cấp phát thường xuyên Tăng cường bảo mật:\nKhả năng chống thăm dò:\nThời gian chờ ngẫu nhiên: 100-500ms Đọc byte ngẫu nhiên: 1KB-64KB Đưa IP vào danh sách đen khi lỗi lặp lại Không tiết lộ chi tiết lỗi cho các nút ngang hàng Giới hạn tài nguyên:\nSố kết nối tối đa trên mỗi IP: 3-10 Số bắt tay đang chờ tối đa: 100-1000 Thời gian chờ đọc: 30-60 giây mỗi thao tác Tổng thời gian chờ kết nối: 5 phút cho quá trình bắt tay Quản lý khóa:\nLưu trữ lâu dài khóa tĩnh và IV (vector khởi tạo) Sinh số ngẫu nhiên an toàn (cryptographic RNG - bộ tạo số ngẫu nhiên mật mã) Tuân thủ nghiêm ngặt các chính sách luân chuyển (rotation) Không bao giờ tái sử dụng khóa tạm thời Giám sát và Chẩn đoán:\nChỉ số:\nTỷ lệ thành công/thất bại của bắt tay Tỷ lệ lỗi AEAD (mã hóa xác thực kèm dữ liệu) Phân bố độ lệch đồng hồ Thống kê thời lượng kết nối Ghi nhật ký:\nGhi nhật ký các lỗi bắt tay kèm mã lý do Ghi nhật ký các sự kiện lệch thời gian hệ thống Ghi nhật ký các địa chỉ IP bị cấm Tuyệt đối không ghi nhật ký dữ liệu khóa nhạy cảm Kiểm thử:\nKiểm thử đơn vị cho các chuỗi KDF (hàm dẫn xuất khóa) Kiểm thử tích hợp với các triển khai khác Fuzzing (kiểm thử ngẫu nhiên) cho xử lý gói tin Kiểm thử tải để đánh giá khả năng chống DoS (tấn công từ chối dịch vụ) Những cạm bẫy thường gặp Các lỗi nghiêm trọng cần tránh:\nTái sử dụng nonce (giá trị ngẫu nhiên dùng một lần):\nKhông bao giờ đặt lại bộ đếm nonce giữa phiên Sử dụng các bộ đếm riêng cho từng chiều Kết thúc trước khi đạt tới 2^64 - 1 Luân chuyển khóa:\nKhông bao giờ luân chuyển khóa khi router đang chạy Không bao giờ tái sử dụng khóa tạm thời giữa các phiên Tuân theo các quy tắc về thời gian ngừng hoạt động tối thiểu Xử lý dấu thời gian:\nKhông bao giờ chấp nhận dấu thời gian đã hết hạn Luôn điều chỉnh theo RTT (thời gian khứ hồi) khi tính độ lệch Làm tròn các dấu thời gian DateTime tới giây Lỗi AEAD:\nKhông bao giờ tiết lộ loại lỗi cho kẻ tấn công Luôn sử dụng thời gian chờ ngẫu nhiên trước khi đóng Xử lý độ dài không hợp lệ giống như lỗi AEAD Phần đệm:\nKhông bao giờ gửi phần đệm vượt ngoài các giới hạn đã thỏa thuận Luôn đặt khối phần đệm ở vị trí cuối cùng Không bao giờ có nhiều hơn một khối phần đệm trong mỗi khung RouterInfo (thông tin về router):\nLuôn xác minh khóa tĩnh khớp với RouterInfo Không bao giờ phát tán RouterInfos mà không có địa chỉ đã được công bố Luôn xác minh chữ ký Phương pháp luận kiểm thử Kiểm thử đơn vị:\nCác nguyên thủy mật mã:\nVector kiểm thử cho X25519, ChaCha20, Poly1305, SHA-256 Vector kiểm thử cho HMAC-SHA256 Vector kiểm thử cho SipHash-2-4 Chuỗi KDF:\nKiểm thử đáp án đã biết cho cả ba thông điệp Xác minh sự lan truyền của khóa chuỗi Kiểm tra việc sinh IV (vector khởi tạo) của SipHash Phân tích cú pháp thông điệp:\nGiải mã thông điệp hợp lệ Từ chối thông điệp không hợp lệ Điều kiện biên (rỗng, kích thước tối đa) Kiểm thử tích hợp:\nBắt tay:\nTrao đổi ba thông điệp thành công Từ chối do lệch đồng hồ Phát hiện tấn công phát lại Từ chối khóa không hợp lệ Giai đoạn dữ liệu:\nTruyền thông điệp I2NP Trao đổi RouterInfo Xử lý padding (đệm) Thông điệp kết thúc Khả năng tương tác:\nKiểm thử khả năng tương tác với Java I2P Kiểm thử khả năng tương tác với i2pd Kiểm thử IPv4 và IPv6 Kiểm thử router công khai và ẩn Kiểm tra bảo mật:\nKiểm thử tiêu cực:\nThẻ AEAD không hợp lệ Thông điệp bị phát lại Tấn công lệch đồng hồ Khung sai định dạng Kiểm thử DoS:\nLàm ngập kết nối Tấn công Slowloris Làm cạn kiệt CPU (DH (Diffie-Hellman - trao đổi khóa Diffie–Hellman) quá mức) Làm cạn kiệt bộ nhớ Fuzzing (kiểm thử ngẫu nhiên):\nThông điệp bắt tay ngẫu nhiên Các khung ở pha dữ liệu ngẫu nhiên Các loại và kích thước khối ngẫu nhiên Giá trị mật mã không hợp lệ Chuyển đổi từ NTCP (giao thức truyền tải dựa trên TCP của I2P cũ) Đối với hỗ trợ NTCP cũ (hiện đã bị loại bỏ):\nNTCP (phiên bản 1) đã được gỡ bỏ kể từ I2P 0.9.50 (tháng 5 năm 2021). Tất cả các bản triển khai hiện tại bắt buộc phải hỗ trợ NTCP2. Ghi chú lịch sử:\nGiai đoạn chuyển tiếp (2018-2021):\n0.9.36: NTCP2 được giới thiệu (bị vô hiệu hóa theo mặc định) 0.9.37: NTCP2 được kích hoạt theo mặc định 0.9.40: NTCP bị đánh dấu là lỗi thời 0.9.50: NTCP bị loại bỏ Phát hiện phiên bản:\n\u0026ldquo;NTCP\u0026rdquo; (giao thức dựa trên TCP của I2P) transportStyle cho biết cả hai phiên bản đều được hỗ trợ \u0026ldquo;NTCP2\u0026rdquo; (phiên bản 2 của NTCP) transportStyle cho biết chỉ hỗ trợ NTCP2 Tự động phát hiện thông qua kích thước thông điệp (287 so với 288 byte) Trạng thái hiện tại:\nTất cả routers phải hỗ trợ NTCP2 \u0026ldquo;NTCP\u0026rdquo; transportStyle (kiểu truyền tải) đã lỗi thời Chỉ sử dụng \u0026ldquo;NTCP2\u0026rdquo; transportStyle Phụ lục A: Mẫu Noise XK Mẫu Noise XK tiêu chuẩn (một mẫu bắt tay trong bộ khung giao thức Noise):\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se Diễn giải:\n\u0026lt;- : Thông điệp từ bên phản hồi (Bob) đến bên khởi tạo (Alice) -\u0026gt; : Thông điệp từ bên khởi tạo (Alice) đến bên phản hồi (Bob) s : Khóa tĩnh (khóa danh tính dài hạn) rs : Khóa tĩnh từ xa (khóa tĩnh của đối tác, đã biết trước) e : Khóa tạm thời (cụ thể cho phiên, được tạo theo yêu cầu) es : DH tạm thời–tĩnh (Diffie-Hellman - trao đổi khóa; tạm thời của Alice × tĩnh của Bob) ee : DH tạm thời–tạm thời (tạm thời của Alice × tạm thời của Bob) se : DH tĩnh–tạm thời (tĩnh của Alice × tạm thời của Bob) Trình tự thỏa thuận khóa:\nTiền thông điệp: Alice biết khóa công khai tĩnh của Bob (từ RouterInfo) Thông điệp 1: Alice gửi khóa tạm thời, thực hiện es DH (ephemeral–static Diffie-Hellman) Thông điệp 2: Bob gửi khóa tạm thời, thực hiện ee DH (ephemeral–ephemeral Diffie-Hellman) Thông điệp 3: Alice tiết lộ khóa tĩnh, thực hiện se DH (static–ephemeral Diffie-Hellman) Thuộc tính bảo mật:\nAlice đã xác thực: Có (ở thông điệp 3) Bob đã xác thực: Có (bằng việc sở hữu khóa riêng tĩnh) Bí mật chuyển tiếp: Có (các khóa tạm thời đã bị hủy) KCI resistance (khả năng kháng lại tấn công Key Compromise Impersonation): Có (mức xác thực 2) Phụ lục B: Mã hóa Base64 Bảng chữ cái Base64 của I2P:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ Khác biệt so với Base64 tiêu chuẩn: - Ký tự 62-63: -~ thay vì +/ - Phần đệm: Giống (=) hoặc lược bỏ tùy ngữ cảnh\nCách sử dụng trong NTCP2: - Khóa tĩnh (\u0026ldquo;s\u0026rdquo;): 32 byte → 44 ký tự (không có phần đệm) - IV (\u0026ldquo;i\u0026rdquo;): 16 byte → 24 ký tự (không có phần đệm)\nVí dụ về mã hóa:\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= Phụ lục C: Phân tích bắt gói tin Nhận diện lưu lượng NTCP2:\nBắt tay TCP:\nChuẩn TCP SYN, SYN-ACK, ACK Cổng đích thường là 8887 hoặc tương tự Thông điệp 1 (SessionRequest - yêu cầu phiên):\nDữ liệu ứng dụng đầu tiên từ Alice 80-65535 byte (thường là vài trăm) Có vẻ ngẫu nhiên (khóa tạm thời được mã hóa bằng AES) Tối đa 287 byte nếu kết nối tới địa chỉ \u0026ldquo;NTCP\u0026rdquo; Thông điệp 2 (SessionCreated):\nPhản hồi từ Bob 80-65535 byte (thường là vài trăm) Cũng có vẻ ngẫu nhiên Thông điệp 3 (SessionConfirmed):\nTừ Alice 48 byte + phần biến thiên (kích thước RouterInfo (thông tin router trong I2P) + phần đệm) Thường khoảng 1–4 KB Pha dữ liệu:\nKhung có độ dài biến thiên Trường độ dài được làm rối (trông như ngẫu nhiên) Phần tải tin được mã hóa Đệm (padding) khiến kích thước khó dự đoán Tránh né DPI (kiểm tra gói sâu): - Không có tiêu đề văn bản thuần - Không có mẫu cố định - Các trường độ dài được che giấu - Phần đệm ngẫu nhiên phá vỡ các heuristic dựa trên kích thước\nSo sánh với NTCP: - Thông điệp 1 của NTCP luôn có kích thước 288 byte (dễ nhận diện) - Kích thước thông điệp 1 của NTCP2 thay đổi (không thể nhận diện) - NTCP có các mẫu dễ nhận ra - NTCP2 được thiết kế để chống DPI (kiểm tra gói dữ liệu sâu)\nPhụ lục D: Lịch sử phiên bản Các cột mốc quan trọng:\n0.9.36 (23 tháng 8, 2018): NTCP2 được giới thiệu, tắt theo mặc định 0.9.37 (4 tháng 10, 2018): NTCP2 được bật theo mặc định 0.9.40 (20 tháng 5, 2019): NTCP được đánh dấu lỗi thời 0.9.42 (27 tháng 8, 2019): Trường Network ID (mã mạng) được thêm (Đề xuất 147) 0.9.50 (17 tháng 5, 2021): NTCP được gỡ bỏ, bổ sung hỗ trợ capabilities (các khả năng) 2.10.0 (9 tháng 9, 2025): Bản phát hành ổn định mới nhất Tính ổn định giao thức: - Không có thay đổi không tương thích ngược kể từ 0.9.50 - Các cải tiến liên tục nhằm tăng khả năng chống thăm dò - Tập trung vào hiệu năng và độ tin cậy - Mật mã hậu lượng tử đang được phát triển (không bật theo mặc định)\nTrạng thái truyền tải hiện tại: - NTCP2: Giao thức truyền tải TCP bắt buộc - SSU2: Giao thức truyền tải UDP bắt buộc - NTCP (v1): Đã loại bỏ - SSU (v1): Đã loại bỏ\n","description":"Giao thức truyền tải TCP dựa trên Noise (khung giao thức mật mã) cho các liên kết giữa các router","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"Truyền tải NTCP2","url":"/vi/docs/specs/ntcp2/"},{"categories":null,"content":" Lưu ý lịch sử: Trang này lưu giữ cuộc thảo luận “Unidirectional Tunnels” (tunnel một chiều) cũ để tham khảo. Hãy tham khảo tài liệu triển khai tunnel hiện hành để biết hành vi hiện tại.\nTổng quan I2P xây dựng các tunnel một chiều: một tunnel mang lưu lượng đi ra và một tunnel riêng mang các phản hồi đi vào. Cấu trúc này bắt nguồn từ những thiết kế mạng sớm nhất và vẫn là một yếu tố khác biệt then chốt so với các hệ thống mạch hai chiều như Tor. Để biết thuật ngữ và chi tiết triển khai, xem tổng quan về tunnel và đặc tả tunnel .\nĐánh giá Các tunnel một chiều tách biệt lưu lượng yêu cầu và phản hồi, vì vậy bất kỳ một nhóm nút ngang hàng thông đồng nào cũng chỉ quan sát được một nửa của một vòng khứ hồi. Các tấn công thời gian phải giao cắt hai nhóm tunnel (ra và vào) thay vì phân tích một mạch đơn lẻ, qua đó nâng cao rào cản đối với việc tương quan. Các nhóm tunnel vào và ra độc lập cho phép routers điều chỉnh độ trễ, dung lượng và các đặc tính xử lý lỗi theo từng hướng. Nhược điểm gồm tăng độ phức tạp trong quản lý nút ngang hàng và nhu cầu duy trì nhiều bộ tunnel để cung cấp dịch vụ đáng tin cậy. Tính ẩn danh Bài báo của Hermann và Grothoff, I2P is Slow… and What to Do About It , phân tích các predecessor attacks (tấn công tiền nhiệm) đối với các tunnel một chiều, cho rằng các đối thủ đủ quyết tâm rốt cuộc có thể xác định được các peer (nút ngang hàng) hoạt động lâu dài. Phản hồi từ cộng đồng lưu ý rằng nghiên cứu này dựa trên các giả định cụ thể về mức độ kiên nhẫn và quyền lực pháp lý của đối thủ, và không cân nhắc phương pháp này so với các tấn công thời gian ảnh hưởng đến các thiết kế hai chiều. Các nghiên cứu tiếp nối và kinh nghiệm thực tế tiếp tục củng cố rằng các tunnel một chiều là một lựa chọn ẩn danh có chủ ý chứ không phải một sự bỏ sót.\n","description":"Tóm tắt lịch sử về thiết kế tunnel (đường hầm dữ liệu) một chiều của I2P.","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"Tunnel một chiều","url":"/vi/docs/legacy/unidirectional/"},{"categories":null,"content":" Trạng thái: Đây là tài liệu tham khảo ngắn gọn cho tiện ích v3dgsend. Nó bổ sung cho tài liệu Datagram API và SAM v3 .\nTổng quan v3dgsend là công cụ dòng lệnh hỗ trợ gửi datagram I2P sử dụng giao diện SAM v3. Nó hữu ích cho việc kiểm tra việc phân phối datagram, xây dựng nguyên mẫu dịch vụ, và xác minh hành vi đầu cuối đến đầu cuối mà không cần viết một client đầy đủ.\nCác trường hợp sử dụng điển hình bao gồm:\nKiểm tra khả năng tiếp cận datagram đến một Destination Xác thực cấu hình tường lửa và sổ địa chỉ Thử nghiệm với datagram thô so với datagram đã ký (có thể trả lời) Sử dụng Cách gọi cơ bản thay đổi tùy theo nền tảng và cách đóng gói. Các tùy chọn phổ biến bao gồm:\nDestination: Destination dạng base64 hoặc tên .i2p Protocol: raw (PROTOCOL 18) hoặc signed (PROTOCOL 17) Payload: chuỗi inline hoặc đầu vào từ file Tham khảo tài liệu đóng gói của bản phân phối hoặc kết quả từ --help để biết chính xác các cờ lệnh.\nXem thêm Datagram API SAM v3 Streaming Library (thay thế cho datagram) ","description":"Tiện ích CLI để gửi datagram I2P qua SAM v3","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/vi/docs/api/v3dgsend/"}]
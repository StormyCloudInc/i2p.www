[{"categories":null,"content":" Statut hérité : Ce contenu est conservé uniquement à des fins de référence historique. Il documente le système de tunnel livré avant I2P 0.6.1.10 et ne doit pas être utilisé pour le développement moderne. Reportez-vous à l’implémentation actuelle pour des recommandations destinées à la production.\nLe sous-système de tunnel d\u0026rsquo;origine utilisait lui aussi des tunnels unidirectionnels, mais différait par la structure des messages, la détection des doublons et la stratégie de construction. De nombreuses sections ci-dessous reprennent la structure du document obsolète pour faciliter la comparaison.\n1. Vue d’ensemble du Tunnel Les tunnels étaient construits sous forme de séquences ordonnées de pairs sélectionnés par le créateur. Les longueurs de tunnels allaient de 0–7 sauts, avec plusieurs paramètres pour le bourrage, la limitation de débit et la génération de trafic leurre. Les tunnels entrants acheminaient les messages d\u0026rsquo;une passerelle non fiable jusqu\u0026rsquo;au créateur (endpoint, point de terminaison); les tunnels sortants envoyaient les données loin du créateur. La durée de vie des tunnels était de 10 minutes, après quoi de nouveaux tunnels étaient construits (souvent en utilisant les mêmes pairs mais avec des identifiants de tunnel différents). 2. Fonctionnement dans l’ancienne conception 2.1 Prétraitement des messages Les passerelles ont accumulé ≤32 KB de charge utile I2NP, sélectionné un bourrage, et produit une charge utile contenant:\nUn champ de longueur de bourrage sur deux octets et autant d\u0026rsquo;octets aléatoires Une séquence de paires {instructions, I2NP message} décrivant les cibles de livraison, la fragmentation et des retards optionnels Des I2NP messages complets, complétés par bourrage jusqu\u0026rsquo;à un alignement sur 16 octets Les instructions de livraison compactaient les informations de routage dans des champs de bits (type de livraison, indicateurs de délai, indicateurs de fragmentation et extensions facultatives). Les messages fragmentés comportaient un identifiant de message de 4 octets ainsi qu’un indicateur index/dernier-fragment.\n2.2 Chiffrement de passerelle La conception héritée fixait, pour la phase de chiffrement, la longueur du tunnel à huit sauts. Les passerelles superposaient des blocs AES-256/CBC ainsi que des blocs de somme de contrôle afin que chaque saut puisse vérifier l’intégrité sans réduire la charge utile. La somme de contrôle elle-même était un bloc dérivé de SHA-256, intégré au sein du message.\n2.3 Comportement des participants Les participants suivaient les identifiants de tunnels entrants, vérifiaient l’intégrité dès réception et éliminaient les doublons avant l’acheminement. Comme le bourrage et les blocs de vérification étaient intégrés, la taille du message restait constante quel que soit le nombre de sauts.\n2.4 Traitement du point de terminaison Les points de terminaison ont déchiffré séquentiellement les blocs en couches, validé les sommes de contrôle et scindé à nouveau la charge utile en instructions encodées ainsi qu\u0026rsquo;en messages I2NP pour un acheminement ultérieur.\n3. Construction de Tunnel (Processus obsolète) Sélection des pairs: Les pairs étaient choisis à partir de profils maintenus localement (exploratoires vs client). Le document d’origine soulignait déjà l’atténuation de la prédecessor attack en réutilisant des listes de pairs ordonnées pour chaque pool de tunnels. Acheminement des requêtes: Les Build messages (messages de construction) étaient transférés saut par saut, avec des sections chiffrées pour chaque pair. Des idées alternatives telles que l’extension télescopique, le réacheminement en cours de route ou la suppression des blocs de somme de contrôle ont été évoquées comme expérimentations, mais n’ont jamais été adoptées. Regroupement: Chaque destination locale disposait de pools entrants et sortants distincts. Les paramètres incluaient la quantité souhaitée, des tunnels de secours, la variance de longueur, la limitation de débit et les politiques de bourrage. 4. Concepts de limitation de débit et de mélange Le document ancien proposait plusieurs stratégies qui ont guidé les versions ultérieures :\nRejet aléatoire précoce pondéré (WRED) pour le contrôle de congestion Limitations de débit par tunnel basées sur des moyennes mobiles de l\u0026rsquo;utilisation récente Contrôles facultatifs de chaff (trafic leurre) et de mise en lots (pas entièrement mis en œuvre) 5. Alternatives archivées Des sections du document original exploraient des idées qui n\u0026rsquo;ont jamais été déployées :\nSupprimer les blocs de somme de contrôle afin de réduire le traitement par saut Télescopage des tunnels en cours de route pour modifier la composition des pairs Passer à des tunnels bidirectionnels (finalement rejeté) Utiliser des hachages plus courts ou des schémas de bourrage différents Ces idées restent un contexte historique précieux, mais ne reflètent pas la base de code moderne.\nRéférences Archive originale des documents hérités (avant 0.6.1.10) Aperçu du Tunnel pour la terminologie actuelle Profilage et sélection des pairs pour les heuristiques modernes ","description":"Description archivée de la conception du tunnel utilisée avant I2P 0.6.1.10.","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"Ancienne implémentation de Tunnel (héritée)","url":"/fr/docs/legacy/old-implementation/"},{"categories":null,"content":"Aperçu Cette spécification documente le protocole des annonces BitTorrent en UDP dans I2P. Pour la spécification générale de BitTorrent dans I2P, voir la documentation BitTorrent sur I2P . Pour le contexte et des informations supplémentaires sur le développement de cette spécification, voir la Proposition 160 .\nCe protocole a été formellement approuvé le 24 juin 2025 et implémenté dans la version 2.10.0 d\u0026rsquo;I2P (API 0.9.67), publiée le 8 septembre 2025. La prise en charge des trackers UDP est actuellement opérationnelle sur le réseau I2P, avec plusieurs trackers en production et une prise en charge complète du client i2psnark.\nConception Cette spécification utilise repliable datagram2, repliable datagram3 et des raw datagrams (datagrammes bruts), tels que définis dans la Spécification des datagrammes I2P . Datagram2 et Datagram3 sont des variantes de repliable datagrams (datagrammes permettant la réponse), définies dans la Proposition 163 . Datagram2 ajoute une résistance au rejeu et la prise en charge des signatures hors ligne. Datagram3 est plus petit que l’ancien format de datagramme, mais sans authentification.\nBEP 15 Pour référence, le flux de messages défini dans BEP 15 est le suivant :\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. La phase de connexion est requise pour empêcher l’usurpation d’adresse IP. Le tracker renvoie un identifiant de connexion que le client utilise dans les annonces suivantes. Cet identifiant de connexion expire par défaut au bout d’une minute côté client, et au bout de deux minutes côté tracker.\nI2P utilise le même flux de messages que BEP 15 (proposition d’amélioration BitTorrent 15), afin de faciliter l’adoption dans des bases de code de clients existantes prenant en charge l’UDP, par souci d’efficacité, et pour des raisons de sécurité exposées ci-dessous:\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... Cela peut offrir une économie de bande passante importante par rapport aux annonces en streaming (TCP). Bien que le Datagram2 (datagramme 2) ait à peu près la même taille qu’un SYN en streaming, la réponse brute est bien plus petite que le SYN ACK en streaming. Les requêtes ultérieures utilisent Datagram3 (datagramme 3), et les réponses ultérieures sont brutes.\nLes requêtes d’annonce sont des Datagram3 afin que le tracker (serveur de suivi) n’ait pas à maintenir une grande table de correspondance d’ID de connexion vers la destination ou le hachage d’annonce. À la place, le tracker peut générer des ID de connexion cryptographiquement à partir du hachage de l’expéditeur, de l’horodatage actuel (basé sur un certain intervalle) et d’une valeur secrète. Lorsqu’une requête d’annonce est reçue, le tracker valide l’ID de connexion, puis utilise le hachage d’expéditeur Datagram3 comme cible d’envoi.\nDurée de vie de la connexion BEP 15 spécifie que l’ID de connexion expire au bout d’une minute côté client, et au bout de deux minutes côté tracker. Ce n’est pas configurable. Cela limite les gains d’efficacité potentiels, à moins que les clients ne regroupent les announces (requêtes d’annonce au tracker) pour les effectuer toutes dans une fenêtre d’une minute. i2psnark ne regroupe actuellement pas les announces ; il les échelonne afin d’éviter des pics de trafic. Il est rapporté que des utilisateurs avancés exécutent des milliers de torrents simultanément, et regrouper autant d’announces dans une minute n’est pas réaliste.\nIci, nous proposons d’étendre la réponse de connexion afin d’ajouter un champ facultatif de durée de vie de la connexion. Par défaut, si ce champ est absent, la durée de vie est d’une minute. Sinon, la durée spécifiée en secondes doit être utilisée par le client, et le tracker maintiendra l’ID de connexion pendant une minute supplémentaire.\nCompatibilité avec le BEP 15 Cette conception préserve autant que possible la compatibilité avec BEP 15 afin de limiter les modifications requises dans les clients et les trackers (serveurs de suivi) existants.\nLa seule modification requise concerne le format des informations sur les pairs dans la réponse d’annonce. L’ajout du champ de durée de vie dans la réponse de connexion n’est pas obligatoire, mais il est fortement recommandé pour des raisons d’efficacité, comme expliqué ci-dessus.\nAnalyse de sécurité Un objectif important d’un protocole d’annonce UDP est d’empêcher l’usurpation d’adresse. Le client doit réellement exister et inclure un véritable leaseSet. Il doit disposer de tunnels entrants pour recevoir la Connect Response (réponse de connexion). Ces tunnels pourraient être zero-hop (sans relais) et être construits instantanément, mais cela exposerait le créateur. Ce protocole atteint cet objectif.\nProblèmes Ce protocole ne prend pas en charge les blinded destinations (destinations aveuglées), mais pourrait être étendu pour les prendre en charge. Voir ci-dessous.\nSpécification Protocoles et ports Datagram2 repliable (permettant une réponse) utilise le protocole I2CP 19; Datagram3 repliable utilise le protocole I2CP 20; les datagrammes bruts utilisent le protocole I2CP 18. Les requêtes peuvent être en Datagram2 ou Datagram3. Les réponses sont toujours brutes. L\u0026rsquo;ancien format de datagramme repliable (\u0026ldquo;Datagram1\u0026rdquo;) utilisant le protocole I2CP 17 ne doit PAS être utilisé pour les requêtes ou les réponses; ceux-ci doivent être rejetés s\u0026rsquo;ils sont reçus sur les ports de requête/réponse. Notez que le protocole Datagram1 17 est toujours utilisé pour le protocole DHT.\nLes requêtes utilisent le \u0026ldquo;port de destination\u0026rdquo; I2CP indiqué dans l’URL d’annonce ; voir ci-dessous. Le \u0026ldquo;port source\u0026rdquo; de la requête est choisi par le client, mais devrait être non nul et différent des ports utilisés par la DHT, afin que les réponses puissent être facilement classées. Les trackers devraient rejeter les requêtes reçues sur le mauvais port.\nLes réponses utilisent le \u0026ldquo;to port\u0026rdquo; I2CP de la requête (port de destination). Le \u0026ldquo;from port\u0026rdquo; de la réponse (port source) est le \u0026ldquo;to port\u0026rdquo; de la requête.\nURL d\u0026rsquo;annonce Le format de l’URL d’annonce n’est pas spécifié dans BEP 15 , mais, comme sur le clearnet (Internet public), les URL d’annonce UDP sont de la forme \u0026ldquo;udp://host:port/path\u0026rdquo;. Le chemin est ignoré et peut être vide, mais il est généralement \u0026ldquo;/announce\u0026rdquo; sur le clearnet. La partie :port devrait toujours être présente ; toutefois, si la partie \u0026ldquo;:port\u0026rdquo; est omise, utilisez un port I2CP par défaut de 6969, car c’est le port usuel sur le clearnet. Il peut aussi y avoir des paramètres CGI \u0026amp;a=b\u0026amp;c=d ajoutés ; ceux-ci peuvent être traités et fournis dans la requête d’annonce, voir BEP 41 . S’il n’y a ni paramètres ni chemin, le \u0026lsquo;/\u0026rsquo; final peut aussi être omis, comme l’implique BEP 41 .\nFormats de datagrammes Toutes les valeurs sont envoyées en ordre d’octets réseau (big endian, octet de poids fort en premier). Ne vous attendez pas à ce que les paquets aient exactement une taille donnée. De futures extensions pourraient augmenter la taille des paquets.\nDemande de connexion Client vers le tracker. 16 octets. Doit être un Datagram2 repliable (permettant la réponse). Identique à BEP 15 . Aucun changement.\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id Réponse de connexion Du tracker vers le client. 16 ou 18 octets. Doit être brut. Identique à BEP 15 sauf comme indiqué ci-dessous.\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 La réponse DOIT être envoyée vers le \u0026ldquo;to port\u0026rdquo; I2CP reçu en tant que \u0026ldquo;from port\u0026rdquo; dans la requête.\nLe champ lifetime est facultatif et indique, en secondes, la durée de vie du client associée au connection_id. La valeur par défaut est 60, et la valeur minimale, si elle est spécifiée, est 60. La valeur maximale est 65535, soit environ 18 heures. Le tracker (serveur de suivi) devrait conserver le connection_id pendant 60 secondes de plus que la durée de vie du client.\nRequête d’annonce Client vers le tracker. 98 octets minimum. Doit être un Datagram3 (datagramme v3) pouvant recevoir une réponse. Identique à BEP 15 sauf mention contraire ci-dessous.\nLe connection_id est tel que reçu dans la réponse de connexion.\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 Modifications par rapport à BEP 15 :\nla clé est ignorée l\u0026rsquo;adresse IP n\u0026rsquo;est pas utilisée le port est probablement ignoré, mais doit être identique au port source I2CP la section des options, si présente, est telle que définie dans BEP 41 La réponse DOIT être envoyée au \u0026ldquo;to port\u0026rdquo; I2CP qui a été reçu en tant que \u0026ldquo;from port\u0026rdquo; de la requête. N\u0026rsquo;utilisez pas le port de la requête d\u0026rsquo;annonce.\nRéponse d\u0026rsquo;annonce Du tracker au client. 20 octets minimum. Doit être brut. Identique à BEP 15 sauf comme indiqué ci-dessous.\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 Modifications par rapport à BEP 15 :\nAu lieu d’un IPv4+port de 6 octets ou d’un IPv6+port de 18 octets, nous renvoyons une séquence de \u0026ldquo;réponses compactes\u0026rdquo; de 32 octets contenant les hachages binaires SHA-256 des pairs. Comme pour les réponses compactes TCP, nous n’incluons pas de port. La réponse DOIT être envoyée au \u0026ldquo;to port\u0026rdquo; I2CP qui a été reçu comme \u0026ldquo;from port\u0026rdquo; de la requête. N\u0026rsquo;utilisez pas le port de la requête d\u0026rsquo;annonce.\nLes datagrammes I2P ont une taille maximale très élevée, d’environ 64 Ko ; toutefois, pour un acheminement fiable, il convient d’éviter les datagrammes de plus de 4 Ko. Pour optimiser l’utilisation de la bande passante, les trackers devraient probablement limiter le nombre maximal de pairs à environ 50, ce qui correspond à un paquet d’environ 1 600 octets avant la surcharge introduite par les différentes couches, et devrait rester dans la limite de charge utile équivalente à deux messages tunnel après fragmentation.\nComme dans le BEP 15, aucun décompte du nombre d’adresses de pairs (IP/port pour le BEP 15, des hachages ici) à venir n’est inclus. Bien que non prévu par le BEP 15, on pourrait définir un marqueur de fin de liste de pairs tout à zéro pour indiquer que les informations sur les pairs sont complètes et que des données d’extension suivent.\nAfin de permettre cette extension à l\u0026rsquo;avenir, les clients devraient ignorer un hachage de 32 octets composé uniquement de zéros, ainsi que toutes les données qui suivent. Les trackers devraient rejeter les requêtes d\u0026rsquo;annonce utilisant un hachage tout en zéros, bien que ce hachage soit déjà banni par les Java routers.\nExtraction de données (scrape) La requête/réponse scrape (interrogation du tracker) de BEP 15 n’est pas requise par cette spécification, mais peut être mise en œuvre si souhaité, sans nécessiter de modifications. Le client doit d’abord obtenir un identifiant de connexion. La requête scrape est toujours un Datagram3 repliable (auquel on peut répondre). La réponse scrape est toujours raw (brut).\nRéponse d\u0026rsquo;erreur Du tracker au client. 8 octets minimum (si le message est vide). Doit être brut. Identique à BEP 15 . Aucun changement.\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message Extensions Les bits d’extension ou un champ de version ne sont pas inclus. Les clients et les trackers ne devraient pas supposer que les paquets ont une taille déterminée. Ainsi, des champs supplémentaires peuvent être ajoutés sans compromettre la compatibilité. Le format d’extensions défini dans BEP 41 est recommandé si nécessaire.\nLa réponse de connexion est modifiée pour ajouter une durée de vie optionnelle pour l’identifiant de connexion.\nSi la prise en charge des destinations aveuglées est requise, nous pouvons soit ajouter l’adresse aveuglée de 35 octets à la fin de la requête d’annonce, soit demander des hachages aveuglés dans les réponses, en utilisant le format BEP 41 (paramètres à définir). L’ensemble des adresses de pairs aveuglées de 35 octets pourrait être ajouté à la fin de la réponse d’annonce, après un hachage de 32 octets composé uniquement de zéros.\nDirectives de mise en œuvre Voir la section de conception ci-dessus pour une discussion des défis liés aux clients non intégrés, non I2CP, et aux trackers.\nClients Pour un nom d\u0026rsquo;hôte de tracker donné, un client devrait préférer les URL UDP aux URL HTTP, et ne devrait pas s\u0026rsquo;annoncer aux deux.\nLes clients prenant déjà en charge BEP 15 ne devraient nécessiter que de légères modifications.\nSi un client prend en charge la DHT ou d\u0026rsquo;autres protocoles de datagrammes, il devrait probablement choisir un port différent comme \u0026ldquo;from port\u0026rdquo; (port source) de la requête, afin que les réponses reviennent sur ce port et ne se confondent pas avec les messages DHT. Le client ne reçoit que des datagrammes bruts en réponse. Les trackers n\u0026rsquo;enverront jamais au client un datagram2 répliable.\nLes clients disposant d’une liste par défaut d’opentrackers (trackers ouverts) devraient mettre cette liste à jour pour y ajouter des URL UDP après confirmation que les opentrackers connus prennent en charge UDP.\nLes clients peuvent ou non implémenter la retransmission des requêtes. Les retransmissions, si elles sont mises en œuvre, devraient utiliser un délai d’expiration initial d’au moins 15 secondes et doubler ce délai à chaque retransmission (exponential backoff (attente exponentielle)).\nLes clients doivent attendre avant de réessayer après avoir reçu une réponse d’erreur.\nServeurs de suivi Les trackers (serveurs de suivi BitTorrent) prenant déjà en charge BEP 15 ne devraient nécessiter que des modifications mineures. Cette spécification diffère de la proposition de 2014, en ce que le tracker doit prendre en charge la réception de datagram2 et datagram3 répliables sur le même port.\nPour minimiser les ressources nécessaires côté tracker, ce protocole est conçu pour supprimer toute nécessité pour le tracker de stocker des correspondances entre les hachages des clients et les identifiants de connexion en vue d’une validation ultérieure. Ceci est possible parce que le paquet de requête announce (requête d’annonce) est un paquet Datagram3 permettant la réponse, et il contient donc le hachage de l’expéditeur.\nUne implémentation recommandée est :\nDéfinir l\u0026rsquo;époque actuelle comme le temps actuel avec une résolution égale à la durée de vie de la connexion, epoch = now / lifetime. Définir une fonction de hachage cryptographique H(secret, clienthash, epoch) qui génère une sortie de 8 octets. Générer le secret constant aléatoire utilisé pour toutes les connexions. Pour les réponses de connexion, générer connection_id = H(secret, clienthash, epoch) Pour les requêtes d\u0026rsquo;annonce, valider l\u0026rsquo;ID de connexion reçu pour l\u0026rsquo;époque actuelle en vérifiant connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1) Statut du déploiement Ce protocole a été approuvé le 24 juin 2025 et est entièrement opérationnel sur le réseau I2P depuis septembre 2025.\nImplémentations actuelles i2psnark: La prise en charge complète des traqueurs UDP est intégrée à I2P version 2.10.0 (API 0.9.67), publiée le 8 septembre 2025. Toutes les installations d\u0026rsquo;I2P à partir de cette version incluent par défaut la prise en charge des traqueurs UDP.\nzzzot tracker: À partir de la version 0.20.0-beta2, les annonces UDP sont prises en charge. En octobre 2025, les trackers de production suivants sont opérationnels: - opentracker.dg2.i2p - opentracker.simp.i2p - opentracker.skank.i2p\nNotes de compatibilité pour les clients Limitations de SAM v3.3: Les clients BitTorrent externes utilisant SAM (Simple Anonymous Messaging, messagerie anonyme simple) nécessitent la prise en charge de SAM v3.3 pour Datagram2/3. Ceci est disponible dans Java I2P mais n\u0026rsquo;est pas actuellement pris en charge par i2pd (l\u0026rsquo;implémentation I2P en C++), ce qui peut limiter l\u0026rsquo;adoption dans les clients basés sur libtorrent comme qBittorrent.\nClients I2CP: Les clients utilisant I2CP directement (comme BiglyBT) peuvent implémenter la prise en charge du tracker UDP sans les limitations de SAM.\nRéférences [BEP15]: Protocole du tracker UDP de BitTorrent [BEP41]: Extensions du protocole du tracker UDP [DATAGRAMS]: Spécification des datagrammes I2P [Prop160]: Proposition relative aux trackers UDP [Prop163]: Proposition Datagram2 [SPEC]: BitTorrent sur I2P ","description":"Spécification du protocole pour les annonces du tracker BitTorrent basées sur UDP dans I2P","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"Annonces BitTorrent via UDP","url":"/fr/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":" Statut : Mis à jour jusqu\u0026rsquo;à I2P 2.10.0 (octobre 2025). Cette liste regroupe tous les ports actifs, obsolètes et réservés utilisés par le I2P Java Router, i2pd et les plugins associés. Tous les ports sont listés par ordre numérique pour plus de cohérence.\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. ## Notes d'implémentation Tous les ports inférieurs à 9000 (sauf 8887) sont liés à 127.0.0.1 par défaut pour des raisons de sécurité. Le port réseau du router (9151–30777) doit être ouvert sur internet pour une participation complète. i2pd utilise principalement les mêmes assignations pour la compatibilité (7070 console, 7654 I2CP, 7656/7655 SAM). Les développeurs de plugins doivent coordonner les nouvelles assignations via la communauté I2P pour éviter les conflits. ","description":"Référence complète des attributions de ports I2P, des ports de plugins et des plages réservées.","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"Attributions de ports","url":"/fr/docs/overview/ports/"},{"categories":null,"content":"Aperçu Les adresses Base 32 standard (\u0026ldquo;b32\u0026rdquo;) contiennent le hachage de la destination. Cela ne fonctionnera pas pour LS2 (leaseSet version 2) chiffré (proposition 123).\nNous ne pouvons pas utiliser une adresse traditionnelle en base 32 pour un LS2 chiffré (proposition 123), car elle ne contient que le hachage de la destination. Elle ne fournit pas la clé publique non aveuglée. Les clients doivent connaître la clé publique de la destination, le type de signature, le type de signature de la clé aveuglée, ainsi qu’un secret ou une clé privée facultatifs pour récupérer et déchiffrer le leaseset. Par conséquent, une adresse en base 32 seule est insuffisante. Le client a besoin soit de la destination complète (qui contient la clé publique), soit de la clé publique seule. Si le client dispose de la destination complète dans un carnet d’adresses, et que ce carnet prend en charge la recherche inverse par hachage, alors la clé publique peut être récupérée.\nCe format place la clé publique, au lieu du hachage, dans une adresse en base32. Ce format doit également contenir le type de signature de la clé publique, ainsi que le type de signature du schéma d’aveuglement.\nCe document spécifie un format b32 pour ces adresses. Bien que nous ayons désigné ce nouveau format, lors des discussions, comme une \u0026ldquo;adresse b33\u0026rdquo;, le format effectivement retenu conserve le suffixe habituel \u0026ldquo;.b32.i2p\u0026rdquo;.\nStatut de l\u0026rsquo;implémentation Proposition 123 (Nouvelles entrées netDB) a été entièrement implémentée dans la version 0.9.43 (octobre 2019). L\u0026rsquo;ensemble des fonctionnalités de LS2 (version 2 de leaseSet) chiffré est resté stable jusqu\u0026rsquo;à la version 2.10.0 (septembre 2025), sans modifications rompant la compatibilité du format d\u0026rsquo;adressage ni des spécifications cryptographiques.\nJalons clés de l\u0026rsquo;implémentation : - 0.9.38 : Prise en charge de Floodfill pour LS2 standard avec des clés hors ligne - 0.9.39 : Type de signature RedDSA 11 et chiffrement/déchiffrement de base - 0.9.40 : Prise en charge complète de l\u0026rsquo;adressage B32 (Proposition 149) - 0.9.41 : Authentification par client basée sur X25519 - 0.9.42 : Toutes les fonctionnalités d\u0026rsquo;aveuglement opérationnelles - 0.9.43 : Implémentation complète déclarée (octobre 2019)\nConception Le nouveau format contient la clé publique démasquée, le type de signature démasqué et le type de signature masqué. Peut indiquer, en option, les exigences de secret et/ou de clé privée pour les liens privés. Utilise le suffixe \u0026ldquo;.b32.i2p\u0026rdquo; existant, mais avec une longueur plus longue. Inclut une somme de contrôle pour la détection d’erreurs. Les adresses pour les leasesets chiffrés sont identifiées par 56 caractères codés ou plus (35 octets décodés ou plus), contre 52 caractères (32 octets) pour les adresses traditionnelles en base 32. Spécification Création et encodage Construisez un nom d\u0026rsquo;hôte de {56+ caractères}.b32.i2p (35+ caractères en binaire) comme suit :\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype Post-traitement et somme de contrôle:\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; Tous les bits non utilisés à la fin du b32 (base32) doivent être à 0. Il n’y a pas de bits non utilisés pour une adresse standard de 56 caractères (35 octets).\nDécodage et vérification strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key Bits des clés secrètes et privées Les indicateurs de clé secrète et de clé privée sont utilisés pour signaler aux clients, aux proxies ou à tout autre code côté client que la clé secrète et/ou la clé privée seront nécessaires pour déchiffrer le leaseSet (ensemble de baux). Certaines implémentations peuvent demander à l’utilisateur de fournir les données requises, ou rejeter les tentatives de connexion si les données requises sont absentes.\nCes bits ne servent que d\u0026rsquo;indicateurs. La clé secrète ou privée ne doit jamais être incluse dans l\u0026rsquo;adresse B32 elle-même, car cela compromettrait la sécurité.\nDétails cryptographiques Schéma d’aveuglement Le schéma d’aveuglement utilise RedDSA, basé sur Ed25519 et sur la conception de ZCash, pour produire des signatures Red25519 sur la courbe Ed25519 en utilisant SHA-512. Cette approche garantit que les clés publiques aveuglées restent dans le sous-groupe d’ordre premier, évitant ainsi les problèmes de sécurité présents dans certaines conceptions alternatives.\nLes clés aveuglées sont renouvelées quotidiennement en fonction de la date UTC à l\u0026rsquo;aide de la formule :\nblinded_key = BLIND(unblinded_key, date, optional_secret) L’emplacement de stockage de la table de hachage distribuée (DHT) est calculé comme suit :\nSHA256(type_byte || blinded_public_key) Chiffrement Le leaseset (ensemble de baux) chiffré utilise l’algorithme de chiffrement en flux ChaCha20, choisi pour ses performances supérieures sur les appareils dépourvus d’accélération matérielle AES. La spécification emploie HKDF pour la dérivation de clés et X25519 pour les opérations Diffie-Hellman.\nLes leaseSet chiffrés ont une structure en trois couches : - Couche externe : métadonnées en clair - Couche intermédiaire : authentification du client (méthodes DH ou PSK) - Couche interne : données LS2 proprement dites contenant les informations de lease (période et paramètres d\u0026rsquo;un tunnel)\nMéthodes d\u0026rsquo;authentification L\u0026rsquo;authentification par client prend en charge deux méthodes :\nAuthentification DH: Utilise l\u0026rsquo;accord de clés X25519. Chaque client autorisé fournit sa clé publique au serveur, et le serveur chiffre la couche intermédiaire à l\u0026rsquo;aide d\u0026rsquo;un secret partagé dérivé d\u0026rsquo;ECDH.\nAuthentification PSK: Utilise directement des clés pré-partagées pour le chiffrement.\nLe bit de drapeau 2 de l’adresse B32 indique si une authentification par client est requise.\nMise en cache Bien que cela soit hors du champ de cette spécification, les routers et les clients doivent mémoriser et mettre en cache (de préférence de manière persistante) la correspondance entre la clé publique et la destination, et inversement.\nLe service de nommage blockfile (fichier en blocs), système de carnet d’adresses par défaut d’I2P depuis la version 0.9.8, gère plusieurs carnets d’adresses avec un mappage de recherche inversée dédié, permettant des recherches rapides par hachage. Cette fonctionnalité est essentielle pour la résolution de leaseSet chiffré lorsqu’au départ seul un hachage est connu.\nTypes de signature À partir de la version 2.10.0 d\u0026rsquo;I2P, les types de signature de 0 à 11 sont définis. L\u0026rsquo;encodage sur un octet reste la norme, tandis que l\u0026rsquo;encodage sur deux octets est disponible mais n\u0026rsquo;est pas utilisé en pratique.\nTypes couramment utilisés: - Type 0 (DSA_SHA1): Déprécié pour les router, pris en charge pour les destinations - Type 7 (EdDSA_SHA512_Ed25519): Norme actuelle pour les identités de router et les destinations - Type 11 (RedDSA_SHA512_Ed25519): Exclusivement pour les LS2 leasesets chiffrés avec prise en charge du blinding (aveuglement)\nRemarque importante : Seuls Ed25519 (type 7) et Red25519 (type 11) prennent en charge le blindage (aveuglement cryptographique) nécessaire aux leasesets chiffrés. Les autres types de signature ne peuvent pas être utilisés avec cette fonctionnalité.\nLes types 9-10 (algorithmes GOST) restent réservés mais non implémentés. Les types 4-6 et 8 sont marqués \u0026ldquo;offline only\u0026rdquo; pour les clés de signature hors ligne.\nRemarques Distinguer les anciennes des nouvelles variantes par la longueur. Les anciennes adresses b32 sont toujours {52 caractères}.b32.i2p. Les nouvelles sont {56+ caractères}.b32.i2p L’encodage base32 suit la norme RFC 4648, avec un décodage insensible à la casse et une sortie en minuscules privilégiée Les adresses peuvent dépasser 200 caractères lorsqu’on utilise des types de signature avec des clés publiques plus grandes (par exemple, ECDSA P521 avec des clés de 132 octets) Le nouveau format peut être utilisé dans des liens de saut (et servi par des serveurs de saut) si souhaité, tout comme le b32 standard Les clés aveuglées sont renouvelées quotidiennement en fonction de la date UTC afin d’améliorer la confidentialité Ce format s’écarte de l’approche de l’annexe A.2 de rend-spec-v3.txt de Tor, qui présente des implications potentielles en matière de sécurité avec des clés publiques aveuglées hors courbe Compatibilité des versions Cette spécification est valide pour I2P de la version 0.9.47 (août 2020) à la version 2.10.0 (septembre 2025). Aucun changement rétro-incompatible n’a affecté le format d’adressage B32, la structure LS2 (LeaseSet, version 2) chiffrée, ni les implémentations cryptographiques durant cette période. Toutes les adresses créées avec la 0.9.47 restent entièrement compatibles avec les versions actuelles.\nRéférences CRC-32 - CRC-32 (Wikipédia) - RFC 3309 : Somme de contrôle du Stream Control Transmission Protocol (protocole de transport gérant des flux) Spécifications I2P - Spécification du LeaseSet chiffré - Proposition 123 : Nouvelles entrées du netDB - Proposition 149 : B32 pour LS2 chiffré - Spécification des structures communes - Nommage et carnet d’adresses Comparaison avec Tor - Fil de discussion Tor (contexte de conception) Ressources supplémentaires - Projet I2P - Forum I2P - Documentation de l\u0026rsquo;API Java ","description":"Format d’adresse Base 32 pour les leaseSets LS2 chiffrés","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"B32 pour les Leasesets chiffrés","url":"/fr/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":" 1. Aperçu Le netDb est une base de données distribuée spécialisée ne contenant que deux types de données : - RouterInfos – informations de contact du router - LeaseSets – informations de contact de la destination\nToutes les données sont signées cryptographiquement et vérifiables. Chaque entrée inclut des informations de liveness (indicateurs d\u0026rsquo;activité) permettant d’éliminer les entrées obsolètes et de remplacer celles périmées, ce qui protège contre certaines classes d’attaques.\nLa distribution utilise un mécanisme de floodfill (propagation en inondation), où un sous-ensemble de routers maintient la base de données distribuée.\n2. RouterInfo Lorsque des routers ont besoin de contacter d\u0026rsquo;autres routers, ils échangent des paquets RouterInfo contenant :\nIdentité du router – clé de chiffrement, clé de signature, certificat Adresses de contact – comment joindre le router Horodatage de publication – quand ces informations ont été publiées Options textuelles arbitraires – indicateurs de capacité et paramètres Signature cryptographique – prouve l\u0026rsquo;authenticité 2.1 Drapeaux de capacités Les routers annoncent leurs capacités via des codes alphabétiques dans leur RouterInfo (informations du router):\nFlag Meaning f Floodfill participation R Reachable U Unreachable D, E, G, H Various capability indicators ### 2.2 Classes de bande passante Code Bandwidth K Under 12 KBps L 12–48 KBps (default) M 48–64 KBps N 64–128 KBps O 128–256 KBps P 256–2000 KBps X Over 2000 KBps ### 2.3 Valeurs d'ID de réseau Value Purpose 0 Reserved 1 Current Network (default) 2 Reserved for Future Networks 3–15 Forks and Test Networks 16–254 Reserved 255 Reserved ### 2.4 Statistiques de RouterInfo Les Routers publient des statistiques de santé facultatives pour l\u0026rsquo;analyse du réseau: - Taux de réussite/rejet/dépassement de délai de la construction des tunnels exploratoires - Nombre moyen sur 1 heure de tunnels participants\nLes statistiques suivent le format stat_(statname).(statperiod) avec des valeurs séparées par des points-virgules.\nExemple de statistiques:\nstat_tunnel.buildExploratoryExpire.60m = 0;0;0;53.14 stat_tunnel.buildExploratoryReject.60m = 0;0;0;15.51 stat_tunnel.buildExploratorySuccess.60m = 0;0;0;31.35 stat_tunnel.participatingTunnels.60m = 289.20 Les Floodfill routers peuvent également publier : netdb.knownLeaseSets et netdb.knownRouters\n2.5 Options de la famille À partir de la version 0.9.24, les routers peuvent déclarer leur appartenance à une famille (même opérateur):\nfamily: Nom de la famille family.key: Code du type de signature concaténé avec la clé publique de signature encodée en base64 family.sig: Signature du nom de la famille et du hachage de 32 octets du router Plusieurs routers appartenant à la même famille ne seront pas utilisés dans un même tunnel.\n2.6 Expiration de RouterInfo Pas d\u0026rsquo;expiration pendant la première heure de fonctionnement Pas d\u0026rsquo;expiration avec 25 RouterInfos stockés ou moins La durée d\u0026rsquo;expiration diminue à mesure que le nombre local augmente (72 heures pour \u0026lt;120 routers ; ~30 heures pour 300 routers) Les SSU introducers expirent en ~1 heure Les Floodfills (nœuds floodfill d\u0026rsquo;I2P) utilisent une expiration d\u0026rsquo;une heure pour tous les RouterInfos locaux 3. LeaseSet LeaseSets décrivent les points d\u0026rsquo;entrée de tunnel pour des destinations particulières et précisent :\nIdentité du router passerelle du tunnel ID de tunnel sur 4 octets Heure d’expiration du tunnel Les LeaseSets comprennent : - Destination – clé de chiffrement, clé de signature, certificat - Clé publique de chiffrement supplémentaire – pour la garlic encryption (technique de chiffrement « garlic » propre à I2P) de bout en bout - Clé publique de signature supplémentaire – destinée à la révocation (actuellement inutilisée) - Signature cryptographique\n3.1 Variantes de LeaseSet Type Description Unpublished Destinations used only for outgoing connections aren't published to floodfill routers Revoked Published with zero leases, signed by additional signing key (not fully implemented) LeaseSet2 (LS2) As of 0.9.38, supports new encryption types, multiple encryption types, options, offline signing keys ([Proposal 123](/proposals/123-new-netdb-entries/)) Meta LeaseSet Tree-like DHT structure for multihomed services, supporting hundreds/thousands of destinations with long expirations (up to 18.2 hours) Encrypted LeaseSet (LS1) All leases encrypted with separate key; only those with the key can decode and contact the destination Encrypted LeaseSet (LS2) As of 0.9.38, destination hidden with only blinded public key and expiration visible to floodfill ### 3.2 Expiration du LeaseSet (ensemble de baux) Les LeaseSets (structures publiant les baux de tunnels entrants) standard expirent à l’expiration la plus tardive de leurs baux. L’expiration d’un LeaseSet2 est spécifiée dans l’en-tête. Les expirations des EncryptedLeaseSet et MetaLeaseSet peuvent varier, avec, le cas échéant, l’application d’une durée maximale.\n4. Amorçage La netDb décentralisée nécessite au moins une référence à un pair pour s’intégrer. Le réensemencement récupère des fichiers RouterInfo (métadonnées d’un router I2P) (routerInfo-$hash.dat) depuis les répertoires netDb de volontaires. Au premier démarrage, le téléchargement depuis des URL codées en dur sélectionnées aléatoirement est effectué automatiquement.\n5. Mécanisme de Floodfill Le netDb floodfill utilise un stockage distribué simple : il suffit d’envoyer les données au pair floodfill le plus proche. Lorsque des pairs non-floodfill envoient des éléments à stocker, les floodfills les transmettent à un sous-ensemble de pairs floodfill les plus proches de la clé donnée.\nLa participation au floodfill est signalée par un indicateur de capacité (f) dans RouterInfo.\n5.1 Exigences pour la participation volontaire à Floodfill Contrairement aux serveurs d\u0026rsquo;annuaire de confiance codés en dur de Tor, l\u0026rsquo;ensemble floodfill d\u0026rsquo;I2P est non approuvé et évolue au fil du temps.\nFloodfill s’active automatiquement uniquement sur les routers à haut débit qui répondent à ces exigences: - Bande passante partagée minimale de 128 KBytes/sec (configurée manuellement) - Doit réussir des tests de santé supplémentaires (temps de file d’attente des messages sortants, retard des tâches)\nL’activation automatique actuelle se traduit par environ 6 % de participation au floodfill du réseau.\nDes floodfills (nœuds spéciaux qui stockent et propagent la netDb) configurés manuellement coexistent avec des volontaires automatiques. Lorsque le nombre de floodfills passe en dessous du seuil, les routers à bande passante élevée se portent automatiquement volontaires. Quand il y a trop de floodfills, ils cessent de faire office de floodfill.\n5.2 Rôles de floodfill Outre l’acceptation des opérations de stockage netDb et la réponse aux requêtes, les floodfills assurent des fonctions standard de router. Leur bande passante plus élevée se traduit généralement par une participation accrue aux tunnel, mais cela n’est pas directement lié aux services de base de données.\n6. Métrique de proximité de Kademlia Le netDb utilise une mesure de distance de style Kademlia basée sur XOR. Le hachage SHA256 de RouterIdentity ou Destination crée la clé Kademlia (sauf pour les LS2 Encrypted LeaseSets, qui utilisent SHA256 de l\u0026rsquo;octet de type 3 plus la clé publique aveuglée).\n6.1 Rotation de l\u0026rsquo;espace de clés Pour augmenter le coût d\u0026rsquo;une attaque Sybil, au lieu d\u0026rsquo;utiliser SHA256(key), le système utilise :\nSHA256(key + yyyyMMdd) où la date est une date UTC en ASCII sur 8 octets. Cela crée la clé de routage, qui change quotidiennement à minuit UTC — appelé rotation de l\u0026rsquo;espace de clés.\nLes clés de routage ne sont jamais transmises dans les messages I2NP ; elles sont utilisées uniquement pour la détermination locale de la distance.\n7. Segmentation de la base de données réseau Les DHT Kademlia traditionnelles ne préservent pas la non-corrélabilité des informations stockées. I2P empêche les attaques visant à associer des tunnels clients aux routers en implémentant la segmentation.\n7.1 Stratégie de segmentation Les Routers suivent : - Si les entrées sont arrivées via des tunnels clients ou directement - Si via un tunnel, quel tunnel client/destination - Les arrivées via plusieurs tunnels sont suivies - Les réponses de stockage sont distinguées des réponses de recherche\nLes implémentations Java et C++ utilisent toutes deux : - Une \u0026ldquo;Principale\u0026rdquo; netDb pour les recherches directes/opérations de floodfill dans le contexte du router - \u0026ldquo;Bases de données réseau client\u0026rdquo; ou \u0026ldquo;Sous-bases de données\u0026rdquo; dans des contextes client, capturant les entrées envoyées aux tunnels client\nLes netDbs clients n\u0026rsquo;existent que pendant la durée de vie du client et ne contiennent que des entrées de tunnels clients. Les entrées provenant des tunnels clients ne peuvent pas chevaucher les arrivées directes.\nChaque netDb enregistre si les entrées sont arrivées sous forme de stores (messages de stockage; répondent aux requêtes de recherche) ou sous forme de réponses de recherche (ne répondent que si elles ont été préalablement stockées pour la même destination). Les clients ne répondent jamais aux requêtes avec des entrées du Main netDb, uniquement avec des entrées de la base de données réseau client.\nLes stratégies combinées segmentent le netDb pour contrer les attaques d\u0026rsquo;association client-router.\n8. Stockage, vérification et recherche 8.1 Stockage de RouterInfo (métadonnées du router) auprès des pairs I2NP DatabaseStoreMessage contenant l’échange de RouterInfo local lors de l’initialisation de la connexion de transport NTCP ou SSU.\n8.2 Stockage du LeaseSet chez les pairs Les I2NP DatabaseStoreMessage contenant le LeaseSet local sont échangés périodiquement via des messages chiffrés avec garlic encryption (technique de chiffrement « garlic » propre à I2P), regroupés avec le trafic de la Destination (identité d’adresse publique I2P), ce qui permet des réponses sans recherche du LeaseSet.\n8.3 Sélection des floodfill DatabaseStoreMessage envoie au floodfill le plus proche de la clé de routage actuelle. Le floodfill le plus proche est trouvé via une recherche dans la base de données locale. Même s’il n’est pas réellement le plus proche, la diffusion le propage \u0026ldquo;plus près\u0026rdquo; en l’envoyant à plusieurs floodfills.\nKademlia traditionnel utilise une recherche \u0026ldquo;find-closest\u0026rdquo; (recherche du nœud le plus proche) avant l\u0026rsquo;insertion. Bien que I2NP ne dispose pas de tels messages, les routers peuvent effectuer une recherche itérative en inversant le bit de poids faible (key ^ 0x01) afin de garantir la découverte du pair réellement le plus proche.\n8.4 Stockage des RouterInfo dans les floodfills Les routers publient leur RouterInfo en se connectant directement à un floodfill, en envoyant un message I2NP DatabaseStoreMessage avec un Reply Token (jeton de réponse) non nul. Le message n’est pas chiffré de bout en bout via garlic encryption (connexion directe, sans intermédiaires). Le floodfill répond avec DeliveryStatusMessage en utilisant le Reply Token comme identifiant de message.\nLes Routers peuvent également envoyer leur RouterInfo (informations du router) via un tunnel exploratoire (limites de connexion, incompatibilité, masquage d’IP). Les Floodfills peuvent rejeter de telles opérations de stockage en cas de surcharge.\n8.5 Publication du LeaseSet aux Floodfills Le stockage des LeaseSet est plus sensible que celui des RouterInfo. Les Routers doivent empêcher toute association de LeaseSet avec eux-mêmes.\nLes routers publient un LeaseSet via un tunnel client sortant au moyen d’un DatabaseStoreMessage avec un jeton de réponse non nul. Le message est chiffré de bout en bout au moyen de garlic encryption en utilisant le gestionnaire de clés de session de la Destination, ce qui le dissimule à l’extrémité sortante du tunnel. Floodfill répond avec un DeliveryStatusMessage renvoyé via un tunnel entrant.\n8.6 Processus d\u0026rsquo;inondation Les Floodfills valident les RouterInfo (informations du router)/LeaseSet avant de les stocker localement, en utilisant des critères adaptatifs dépendant de la charge, de la taille du netdb et d\u0026rsquo;autres facteurs.\nAprès réception de nouvelles données valides, les floodfills les \u0026ldquo;inondent\u0026rdquo; en recherchant les 3 floodfill routers les plus proches de la clé de routage. Les connexions directes envoient un I2NP DatabaseStoreMessage avec un jeton de réponse égal à zéro. Les autres routers ne répondent pas et ne ré-inondent pas.\nContraintes importantes: - Les Floodfills ne doivent pas propager via des tunnels; uniquement des connexions directes - Les Floodfills ne propagent jamais un LeaseSet expiré ni un RouterInfo publié il y a plus d\u0026rsquo;une heure\n8.7 Recherche de RouterInfo (informations du router) et de LeaseSet I2NP DatabaseLookupMessage demande des entrées netdb aux routers floodfill. Les recherches sont envoyées via un tunnel d\u0026rsquo;exploration sortant ; les réponses spécifient le tunnel d\u0026rsquo;exploration entrant pour le retour.\nLes recherches envoient généralement vers deux routeurs floodfill \u0026ldquo;fiables\u0026rdquo; les plus proches de la clé demandée, en parallèle.\nCorrespondance locale: reçoit une réponse I2NP DatabaseStoreMessage Aucune correspondance locale: reçoit un I2NP DatabaseSearchReplyMessage avec des références à d\u0026rsquo;autres floodfill router (nœuds spécialisés qui stockent et propagent le netDb) proches de la clé Les recherches de LeaseSet utilisent la garlic encryption (chiffrement \u0026ldquo;garlic\u0026rdquo;, agrégation de messages propre à I2P) de bout en bout (depuis la version 0.9.5). Les recherches de RouterInfo (métadonnées d\u0026rsquo;un router I2P) ne sont pas chiffrées en raison du coût de calcul d\u0026rsquo;ElGamal, ce qui les rend vulnérables à l\u0026rsquo;espionnage au niveau de l\u0026rsquo;extrémité sortante.\nÀ partir de la version 0.9.7, les réponses de recherche incluent la clé de session et un tag de session, masquant ces réponses à la passerelle d\u0026rsquo;entrée.\n8.8 Recherches itératives Avant la version 0.8.9 : Deux recherches redondantes en parallèle sans routage récursif ni itératif.\nÀ partir de la version 0.8.9: Recherches itératives mises en œuvre sans redondance—plus efficaces, fiables et adaptées à une connaissance incomplète des floodfills. À mesure que le réseau croît et que les routers connaissent moins de floodfills, les recherches approchent une complexité O(log n).\nLes recherches itératives se poursuivent même sans références vers des pairs plus proches, afin d’empêcher le black-holing malveillant (mise en trou noir du trafic). Les limites actuelles de nombre maximal de requêtes et de délai d’expiration s’appliquent.\n8.9 Vérification RouterInfo Verification: Désactivée à partir de la version 0.9.7.1 afin d\u0026rsquo;empêcher les attaques décrites dans l\u0026rsquo;article \u0026ldquo;Practical Attacks Against the I2P Network\u0026rdquo;.\nVérification du LeaseSet: Les routers attendent ~10 secondes, puis effectuent une recherche depuis un floodfill différent via un tunnel client sortant. Le garlic encryption de bout en bout masque cela à l’extrémité sortante. Les réponses reviennent via des tunnels entrants.\nÀ partir de la version 0.9.7, les réponses sont chiffrées en masquant la clé de session et le tag (étiquette) à la passerelle entrante.\n8.10 Exploration Exploration implique une recherche netdb (base de données réseau) avec des clés aléatoires pour découvrir de nouveaux routers. Les Floodfills (nœuds floodfill spéciaux) répondent avec DatabaseSearchReplyMessage contenant des hachages de routers non-floodfill proches de la clé demandée. Les requêtes d’exploration définissent un indicateur spécial dans DatabaseLookupMessage.\n9. MultiHoming (rattachement à plusieurs réseaux) Les Destinations utilisant des clés privées/publiques identiques (le eepPriv.dat traditionnel) peuvent héberger sur plusieurs routers simultanément. Chaque instance publie périodiquement des LeaseSets (descripteurs des tunnels d\u0026rsquo;entrée) signés ; le LeaseSet publié le plus récent est renvoyé aux clients effectuant une recherche. Avec une durée de vie maximale de 10 minutes pour les LeaseSets, les pannes durent au plus ~10 minutes.\nÀ partir de la version 0.9.38, les Meta LeaseSets prennent en charge des services multi‑hébergés à grande échelle utilisant des Destinations (identité/adresse I2P) distinctes fournissant des services communs. Les entrées de Meta LeaseSet sont des Destinations ou d’autres Meta LeaseSets, avec des expirations pouvant aller jusqu’à 18,2 heures, ce qui permet à des centaines/des milliers de Destinations d’héberger des services communs.\n10. Analyse des menaces Environ 1700 floodfill routers (nœuds chargés de diffuser la netDb) opèrent actuellement. La croissance du réseau rend la plupart des attaques plus difficiles ou moins efficaces.\n10.1 Mesures d’atténuation générales Croissance: Plus de floodfills rendent les attaques plus difficiles ou moins impactantes Redondance: Toutes les entrées netdb sont stockées sur 3 floodfill routers les plus proches de la clé via flooding (diffusion massive) Signatures: Toutes les entrées sont signées par leur créateur; les falsifications sont impossibles 10.2 Routers lents ou non réactifs Routers maintiennent des statistiques étendues dans les profils de pairs pour les floodfills: - Temps de réponse moyen - Pourcentage de réponses aux requêtes - Pourcentage de réussite de la vérification du stockage - Dernier stockage réussi - Dernière recherche réussie - Dernière réponse\nLes routers utilisent ces métrriques pour évaluer la \u0026ldquo;qualité\u0026rdquo; lors de la sélection du floodfill le plus proche. Les routers complètement non réactifs sont rapidement identifiés et évités; les routers partiellement malveillants posent un défi plus important.\n10.3 Attaque Sybil (espace de clés complet) Des attaquants pourraient créer de nombreux floodfill routers répartis dans l’ensemble du keyspace (espace de clés) afin de mener une attaque par déni de service (DoS) efficace.\nSi le comportement n\u0026rsquo;est pas suffisamment problématique pour une désignation \u0026ldquo;bad\u0026rdquo;, des réponses possibles comprennent : - Compilation de listes de hash/IP de router \u0026ldquo;bad\u0026rdquo; annoncées via les actualités de la console, le site web, le forum - Activation du floodfill à l\u0026rsquo;échelle du réseau (\u0026ldquo;combattre Sybil par plus de Sybil\u0026rdquo;) - Nouvelles versions logicielles avec des listes \u0026ldquo;bad\u0026rdquo; codées en dur - Amélioration des métriques de profils de pairs et des seuils pour l\u0026rsquo;identification automatique - Qualification par bloc IP disqualifiant plusieurs floodfills au sein d\u0026rsquo;un même bloc IP - Liste noire automatique basée sur abonnement (similaire au consensus de Tor)\nLes réseaux plus vastes rendent cela plus difficile.\n10.4 Attaque Sybil (espace de clés partiel) Des attaquants peuvent créer 8 à 15 routers floodfill étroitement regroupés dans l\u0026rsquo;espace de clés. Toutes les requêtes de recherche/stockage pour cet espace de clés aboutissent aux routers des attaquants, ce qui permet de lancer une attaque par déni de service (DoS) contre certains sites I2P.\nComme l\u0026rsquo;espace de clés indexe des hachages SHA256 cryptographiques, les attaquants doivent recourir à la force brute pour générer des routers suffisamment proches.\nDéfense: L’algorithme de proximité Kademlia (algorithme de table de hachage distribuée) varie au fil du temps en utilisant SHA256(key + YYYYMMDD), changeant chaque jour à minuit UTC. Cette rotation de l’espace de clés impose une régénération quotidienne des attaques.\nNote: Des recherches récentes montrent que la rotation de l\u0026rsquo;espace de clés n\u0026rsquo;est pas particulièrement efficace — les attaquants peuvent précalculer les hachages de routers, ce qui ne requiert que quelques routers pour éclipser des portions de l\u0026rsquo;espace de clés dans la demi-heure suivant la rotation.\nConséquence de la rotation quotidienne: le netdb distribué devient peu fiable pendant plusieurs minutes après la rotation—les recherches échouent avant que le nouveau router le plus proche ne reçoive les messages de stockage.\n10.5 Attaques d\u0026rsquo;amorçage Des attaquants pourraient prendre le contrôle de reseed websites (sites servant à fournir les informations initiales du réseau I2P) ou tromper les développeurs pour ajouter des reseed websites hostiles, amenant de nouveaux routers à démarrer au sein de réseaux isolés ou majoritairement contrôlés.\nDéfenses mises en œuvre: - Récupérer des sous-ensembles de RouterInfo depuis plusieurs sites de reseed (réensemencement) plutôt que depuis un seul site - Surveillance du reseed hors du réseau, interrogeant périodiquement les sites - À partir de la 0.9.14, les paquets de données de reseed sont des fichiers zip signés avec vérification des signatures téléchargées (voir spécification su3 )\n10.6 Capture des requêtes Les routers floodfill pourraient \u0026ldquo;orienter\u0026rdquo; des pairs vers des routers contrôlés par un attaquant via les références renvoyées.\nPeu probable via l\u0026rsquo;exploration en raison de sa faible fréquence ; les routers acquièrent des références de pairs principalement via la construction normale de tunnel.\nÀ partir de la version 0.8.9, les recherches itératives sont implémentées. Les références floodfill dans DatabaseSearchReplyMessage sont suivies si elles sont plus proches de la clé de recherche. Les router qui effectuent la requête ne font pas confiance à la proximité déclarée des références. Les recherches se poursuivent même en l’absence de clés plus proches, jusqu’à expiration du délai ou atteinte du nombre maximal de requêtes, ce qui empêche le black-holing (mise en trou noir) malveillant.\n10.7 Fuites d’informations Les fuites d’informations de la DHT (table de hachage distribuée) dans I2P nécessitent des investigations supplémentaires. Les Floodfill routers observent les requêtes et recueillent des informations. Avec 20 % de nœuds malveillants, les menaces de type Sybil décrites précédemment deviennent problématiques pour plusieurs raisons.\n11. Travaux futurs Chiffrement de bout en bout des recherches netDb supplémentaires et des réponses associées De meilleures méthodes de suivi des réponses aux recherches Méthodes d\u0026rsquo;atténuation des problèmes de fiabilité liés à la rotation de l\u0026rsquo;espace de clés 12. Références ","description":"Comprendre la base de données réseau distribuée d'I2P (netDb) - une table de hachage distribuée spécialisée pour les informations de contact du router et les recherches de destinations","id":"ef0a5e8bee4372a50a7f4562af717b0c","section":"docs","title":"Base de données du réseau","url":"/fr/docs/overview/network-database/"},{"categories":null,"content":" Obsolète : La bibliothèque ministreaming est antérieure à la bibliothèque de streaming actuelle. Les applications modernes doivent utiliser l’API de streaming complète ou SAM v3. Les informations ci-dessous sont conservées pour les développeurs qui examinent du code source hérité fourni dans ministreaming.jar.\nVue d\u0026rsquo;ensemble Ministreaming (mécanisme de flux minimal) s\u0026rsquo;appuie sur I2CP pour fournir une livraison fiable et ordonnée au sein de la couche de messages d\u0026rsquo;I2P — à l\u0026rsquo;instar de TCP sur IP. Il a été initialement extrait de l\u0026rsquo;application I2PTunnel des débuts (sous licence BSD) afin que des transports alternatifs puissent évoluer indépendamment.\nPrincipales contraintes de conception :\nÉtablissement de connexion classique en deux phases (SYN/ACK/FIN) emprunté à TCP Taille de fenêtre fixe de 1 paquet Pas d\u0026rsquo;identifiants par paquet ni d\u0026rsquo;accusés de réception sélectifs Ces choix ont permis de garder l’implémentation compacte mais limitent le débit—chaque paquet attend généralement presque deux RTT (temps aller-retour) avant que le suivant soit envoyé. Pour les flux de longue durée, la pénalité est acceptable, mais les échanges courts de type HTTP en pâtissent sensiblement.\nRelation avec la bibliothèque de streaming La bibliothèque de streaming actuelle utilise le même package Java (net.i2p.client.streaming). Les classes et méthodes obsolètes restent dans la Javadoc, clairement annotées afin que les développeurs puissent identifier les API de l’ère ministreaming (ancien sous-système « ministreaming »). Lorsque la bibliothèque de streaming a remplacé ministreaming, elle a ajouté :\nÉtablissement de connexion plus intelligent avec moins d\u0026rsquo;allers-retours Fenêtres de congestion adaptatives et logique de retransmission Meilleures performances sur des tunnels avec pertes Quand le Ministreaming a-t-il été utile ? Malgré ses limites, le ministreaming (sous-système de streaming minimaliste) a assuré un transport fiable lors des tout premiers déploiements. L’API était volontairement réduite et pérenne afin que des moteurs de streaming alternatifs puissent être substitués sans rompre la compatibilité avec le code appelant. Les applications Java l’intégraient directement ; les clients non Java accédaient à la même fonctionnalité via la prise en charge de SAM pour les sessions de streaming.\nÀ ce jour, considérez ministreaming.jar uniquement comme une couche de compatibilité. Les nouveaux développements devraient :\nCiblez la bibliothèque de streaming complète (Java) ou SAM v3 (style STREAM) Supprimez toute hypothèse résiduelle de fenêtre fixe lors de la modernisation du code Privilégiez des tailles de fenêtre plus élevées et des handshakes de connexion optimisés pour améliorer les charges de travail sensibles à la latence Référence Documentation de la bibliothèque de streaming Javadoc de streaming – inclut des classes ministreaming obsolètes Spécification SAM v3 – prise en charge du streaming pour les applications non Java Si vous rencontrez du code qui dépend encore de ministreaming (fonctionnalité héritée), prévoyez de le porter vers l’API de streaming moderne — le réseau et ses outils s’attendent au nouveau comportement.\n","description":"Notes historiques sur la première couche de transport de type TCP d’I2P","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"Bibliothèque Ministreaming","url":"/fr/docs/legacy/ministreaming/"},{"categories":null,"content":"Aperçu BitTorrent sur I2P permet le partage de fichiers anonyme via des tunnels chiffrés en utilisant la couche de streaming d\u0026rsquo;I2P. Tous les pairs sont identifiés par des destinations I2P cryptographiques au lieu d\u0026rsquo;adresses IP. Le système prend en charge les trackers HTTP et UDP, les liens magnet hybrides et le chiffrement hybride post-quantique.\n1. Pile de protocoles Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP Toutes les connexions transitent par la couche de transport chiffrée d'I2P (NTCP2 ou SSU2). Même les paquets de tracker UDP sont encapsulés dans le streaming I2P. 2. Trackers Trackers HTTP Les trackers .i2p standards répondent aux requêtes HTTP GET telles que :\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 Les réponses sont bencodées et utilisent des hachages de destination I2P pour les pairs.\nTrackers UDP Les trackers UDP ont été standardisés en 2025 (Proposition 160).\nTrackers UDP principaux - udp://tracker2.postman.i2p/announce - udp://opentracker.simp.i2p/a - http://opentracker.skank.i2p/a - http://opentracker.dg2.i2p/a \u0026mdash;\n3. Liens Magnet magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name Les liens magnet prennent en charge les essaims hybrides sur I2P et le clearnet lorsqu'ils sont configurés. 4. Implémentations DHT Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported --- 5. Implémentations clientes I2PSnark Fourni avec tous les routeurs Support des trackers HTTP uniquement Tracker intégré à http://127.0.0.1:7658/ Pas de support des trackers UDP BiglyBT Complet avec plugin I2P Prend en charge les trackers HTTP + UDP Prise en charge des torrents hybrides Utilise l\u0026rsquo;interface SAM v3.3 Tixati / XD Clients légers Tunneling basé sur SAM Chiffrement hybride ML-KEM expérimental 6. Configuration I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. Modèle de sécurité Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) Les torrents hybrides (clearnet + I2P) ne doivent être utilisés que si l'anonymat n'est pas critique. 8. Performance Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal Les vitesses typiques varient de **30 à 80 Ko/s**, selon les pairs et les conditions du réseau. 9. Problèmes connus Interopérabilité partielle du DHT entre Java I2P et i2pd Délai de récupération des métadonnées magnet sous charge élevée NTCP1 obsolète mais toujours utilisé par les anciens pairs UDP simulé sur streaming augmente la latence 10. Feuille de route future Multiplexage de type QUIC Intégration complète de ML-KEM Logique d\u0026rsquo;essaim hybride unifiée Miroirs reseed améliorés Tentatives DHT adaptatives Références BEP 15 – UDP Tracker Protocol Proposition 160 – UDP Tracker sur I2P Documentation I2PSnark Spécification de la bibliothèque Streaming ","description":"Spécification détaillée et aperçu de l'écosystème BitTorrent au sein du réseau I2P","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"BitTorrent sur I2P","url":"/fr/docs/applications/bittorrent/"},{"categories":null,"content":" Avertissement : BOB ne prend en charge que l’ancien type de signature DSA-SHA1. Java I2P a cessé d’inclure BOB à partir de la 1.7.0 (2022-02); il ne subsiste que sur les installations démarrées avec la 1.6.1 ou une version antérieure et sur certaines builds d’i2pd. Les nouvelles applications doivent utiliser SAM v3 .\nLiaisons de langage Go – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp Notes sur le protocole KEYS désigne une destination en base64 (clés publiques + privées). KEY est une clé publique en base64. Les réponses ERROR ont la forme ERROR \u0026lt;description\u0026gt;\\n. OK indique la fin de la commande ; des données facultatives peuvent suivre sur la même ligne. Les lignes DATA fournissent une sortie supplémentaire avant un OK final. La commande help constitue la seule exception : elle peut ne rien renvoyer pour indiquer « aucune commande de ce type ».\nBannière de connexion BOB utilise des lignes ASCII terminées par un saut de ligne (LF ou CRLF). À la connexion, il envoie :\nBOB \u0026lt;version\u0026gt; OK Version actuelle : 00.00.10. Les versions précédentes utilisaient des caractères hexadécimaux en majuscules et une numérotation non standard.\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds ## Commandes de base Pour obtenir tous les détails sur les commandes, connectez-vous via telnet localhost 2827 et exécutez help.\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK Résumé des éléments dépréciés BOB ne prend pas en charge les types de signatures modernes, les LeaseSets chiffrés, ni les fonctionnalités de transport. L\u0026rsquo;API est figée ; aucune nouvelle commande ne sera ajoutée. Les applications qui dépendent encore de BOB devraient migrer vers SAM v3 dès que possible. ","description":"API dépréciée pour la gestion des destinations (dépréciée)","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – Passerelle ouverte de base","url":"/fr/docs/legacy/bob/"},{"categories":null,"content":" Statut: Ce document décrit l’ancien protocole de chiffrement ElGamal/AES+SessionTag. Il reste pris en charge uniquement pour assurer la rétrocompatibilité, car les versions modernes d’I2P (2.10.0+) utilisent ECIES-X25519-AEAD-Ratchet (mécanisme « ratchet » AEAD basé sur X25519). Le protocole ElGamal est obsolète et conservé uniquement pour des raisons historiques et d’interopérabilité.\nAperçu ElGamal/AES+SessionTag a fourni le mécanisme original de chiffrement de bout en bout d’I2P pour les garlic messages (messages « ail », un type de message agrégé spécifique à I2P). Il combinait :\nElGamal (2048 bits) — pour l\u0026rsquo;échange de clés AES-256/CBC — pour le chiffrement de la charge utile SHA-256 — pour le hachage et la dérivation du vecteur d\u0026rsquo;initialisation (IV) Session Tags (32 octets) — identifiants de message à usage unique Le protocole permettait aux routers et aux destinations de communiquer en toute sécurité sans maintenir de connexions persistantes. Chaque session recourait à un échange asymétrique ElGamal pour établir une clé symétrique AES, puis à des messages légers « étiquetés » faisant référence à cette session.\nFonctionnement du protocole Établissement d\u0026rsquo;une session (nouvelle session) Une nouvelle session a commencé avec un message contenant deux sections :\nSection Size Contents Purpose ElGamal-encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient's ElGamal public key Establishes the AES session key and IV seed AES-encrypted block Variable (≥128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags Le texte en clair à l'intérieur du bloc ElGamal se composait de : Field Size Description Session Key 32 bytes AES-256 key for the session Pre-IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA-256(Pre-IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length ### Messages de session existants Une fois la session établie, l\u0026rsquo;expéditeur pouvait envoyer des messages existing-session (messages de session existante) en utilisant des balises de session mises en cache :\nField Size Description Session Tag 32 bytes Single-use identifier tied to the existing session key AES-Encrypted Block Variable Encrypted payload and metadata using the established AES key Les routers mettaient en cache les tags reçus pendant environ **15 minutes**, après quoi les tags inutilisés expiraient. Chaque tag n’était valable que pour **un seul message** afin d’empêcher les attaques par corrélation. Format de bloc chiffré en AES Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single-use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA-256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16-byte aligned) Random padding to block boundary Les Routers déchiffrent à l’aide de la clé de session et de l’IV (vecteur d’initialisation) dérivés soit du Pre-IV (valeur préalable du vecteur d’initialisation, pour les nouvelles sessions), soit du session tag (étiquette de session, pour les sessions existantes). Après le déchiffrement, ils vérifient l’intégrité en recalculant le hachage SHA-256 de la charge utile en clair. Gestion des étiquettes de session Les étiquettes sont unidirectionnelles: les étiquettes Alice → Bob ne peuvent pas être réutilisées dans le sens Bob → Alice. Les étiquettes expirent après environ 15 minutes. Les Routers maintiennent des gestionnaires de clés de session par destination pour suivre les étiquettes, les clés et les dates d\u0026rsquo;expiration. Les applications peuvent contrôler le comportement des étiquettes via les options I2CP : i2cp.tagThreshold — minimum d\u0026rsquo;étiquettes mises en cache avant le réapprovisionnement i2cp.tagCount — nombre de nouvelles étiquettes par message Ce mécanisme a minimisé les handshakes ElGamal coûteux tout en maintenant l\u0026rsquo;impossibilité d\u0026rsquo;établir un lien entre les messages.\nConfiguration et efficacité Les Session tags (étiquettes de session) ont été introduits pour améliorer l’efficacité sur le transport à forte latence et non ordonné d’I2P. Une configuration typique fournissait 40 tags par message, ajoutant environ 1,2 Ko de surcharge. Les applications pouvaient ajuster le comportement d’acheminement en fonction du trafic attendu :\nUse Case Recommended Tags Notes Short-lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re-establishment Long-term services 50+ Ensures steady tag supply despite loss or delay Routers purgent périodiquement les étiquettes expirées et nettoient l'état de session inutilisé afin de réduire la consommation mémoire et d'atténuer les attaques de tag-flooding (saturation par étiquettes). Limites Category Limitation Performance 514-byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES-CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor's algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. Ces lacunes ont directement motivé la conception du protocole [ECIES-X25519-AEAD-Ratchet](/docs/specs/ecies/), qui fournit la perfect forward secrecy (confidentialité persistante parfaite), un chiffrement authentifié et un échange de clés efficace. Statut de dépréciation et de migration Introduit: Premières versions d\u0026rsquo;I2P (pré-0.6) Déprécié: Avec l\u0026rsquo;introduction d\u0026rsquo;ECIES-X25519 (0.9.46 → 0.9.48) Supprimé: N\u0026rsquo;est plus la valeur par défaut à partir de la version 2.4.0 (décembre 2023) Pris en charge: Uniquement pour compatibilité héritée Les routers et les destinations modernes annoncent désormais crypto type 4 (ECIES-X25519) plutôt que type 0 (ElGamal/AES). Le protocole hérité reste reconnu pour l\u0026rsquo;interopérabilité avec des pairs obsolètes, mais ne devrait pas être utilisé pour de nouveaux déploiements.\nContexte historique ElGamal/AES+SessionTag (schéma hybride basé sur ElGamal et AES avec étiquettes de session) a été fondamental pour l’architecture cryptographique initiale d’I2P. Sa conception hybride a introduit des innovations telles que des étiquettes de session à usage unique et des sessions unidirectionnelles qui ont influencé les protocoles ultérieurs. Bon nombre de ces idées ont évolué vers des constructions modernes comme des deterministic ratchets (mécanismes à cliquet déterministes) et des échanges de clés post‑quantiques hybrides.\n","description":"Chiffrement de bout en bout hérité combinant ElGamal, AES, SHA-256 et des étiquettes de session à usage unique","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"Chiffrement ElGamal/AES + SessionTag (étiquette de session)","url":"/fr/docs/legacy/elgamal-aes/"},{"categories":null,"content":"Statut de l’implémentation Déploiement actuel: - i2pd (implémentation C++): Entièrement implémenté dans la version 2.58.0 (septembre 2025), avec prise en charge de ML-KEM-512, ML-KEM-768 et ML-KEM-1024. Le chiffrement de bout en bout post-quantique est activé par défaut lorsque OpenSSL 3.5.0 ou une version ultérieure est disponible. - Java I2P: Pas encore implémenté à la version 0.9.67 / 2.10.0 (septembre 2025). Spécification approuvée et mise en œuvre prévue pour de prochaines versions.\nCette spécification décrit les fonctionnalités approuvées actuellement déployées dans i2pd et prévues pour les implémentations Java I2P.\nVue d\u0026rsquo;ensemble Ceci est la variante hybride post-quantique du protocole ECIES-X25519-AEAD-Ratchet ECIES . Elle représente la première phase de la Proposition 169 Prop169 à être approuvée. Voir cette proposition pour les objectifs globaux, les modèles de menace, l\u0026rsquo;analyse, les alternatives et des informations supplémentaires.\nStatut de la proposition 169 : Ouvert (première phase approuvée pour une implémentation ECIES hybride).\nLa présente spécification ne contient que les différences par rapport à la norme ECIES et doit être lue conjointement avec cette dernière.\nConception Nous utilisons la norme NIST FIPS 203 FIPS203 qui est basée sur, mais n\u0026rsquo;est pas compatible avec, CRYSTALS-Kyber (versions 3.1, 3 et antérieures).\nLes poignées de main hybrides combinent le Diffie-Hellman X25519 classique avec des mécanismes d’encapsulation de clés post-quantiques ML-KEM. Cette approche s’appuie sur des concepts de confidentialité persistante hybride documentés dans la recherche PQNoise et sur des implémentations similaires dans TLS 1.3, IKEv2 et WireGuard.\nÉchange de clés Nous définissons un échange de clés hybride pour Ratchet. Un KEM post-quantique (mécanisme d\u0026rsquo;encapsulation de clé) ne fournit que des clés éphémères et ne prend pas directement en charge les échanges initiaux à clés statiques tels que Noise IK.\nNous définissons les trois variantes ML-KEM (mécanisme d\u0026rsquo;encapsulation de clés post-quantique à réseaux modulaires) telles que spécifiées dans FIPS203 , ce qui représente au total 3 nouveaux types de chiffrement. Les types hybrides ne sont définis qu\u0026rsquo;en combinaison avec X25519.\nLes nouveaux types de chiffrement sont :\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 **Remarque:** MLKEM768_X25519 (Type 6) est la variante par défaut recommandée, offrant une sécurité post-quantique robuste avec un surcoût raisonnable. La surcharge est considérable par rapport au chiffrement reposant uniquement sur X25519. Les tailles typiques des messages 1 et 2 (pour l\u0026rsquo;IK pattern (schéma IK)) sont actuellement d\u0026rsquo;environ 96 à 103 octets (avant toute charge utile supplémentaire). Cela augmentera d\u0026rsquo;environ 9-12x pour MLKEM512, 13-16x pour MLKEM768, et 17-23x pour MLKEM1024, selon le type de message.\nNouveau chiffrement requis ML-KEM (anciennement CRYSTALS-Kyber) FIPS203 - Norme relative au mécanisme d’encapsulation de clés basé sur des réseaux modulaires SHA3-256 (anciennement Keccak-512) FIPS202 - Partie de la norme SHA-3 SHAKE128 et SHAKE256 (extensions XOF (fonctions à sortie extensible) de SHA3) FIPS202 - Fonctions à sortie extensible Des vecteurs de test pour SHA3-256, SHAKE128 et SHAKE256 sont disponibles dans le Programme de validation des algorithmes cryptographiques du NIST .\nPrise en charge des bibliothèques: - Java: la bibliothèque Bouncycastle à partir de la version 1.79 prend en charge toutes les variantes de ML-KEM et les fonctions SHA3/SHAKE - C++: OpenSSL à partir de la version 3.5 inclut une prise en charge complète de ML-KEM (publiée en avril 2025) - Go: plusieurs bibliothèques sont disponibles pour l\u0026rsquo;implémentation de ML-KEM et de SHA3\nSpécification Structures courantes Voir la Spécification des structures communes pour les longueurs de clés et les identifiants.\nSchémas de poignée de main Les handshakes (échanges d\u0026rsquo;initialisation) utilisent les modèles de handshake du Noise Protocol Framework avec des adaptations spécifiques à I2P pour une sécurité post-quantique hybride.\nLa table de correspondance suivante est utilisée :\ne = clé éphémère à usage unique (X25519) s = clé statique p = charge utile du message e1 = clé post-quantique (PQ) éphémère à usage unique, envoyée d\u0026rsquo;Alice à Bob (jeton spécifique à I2P) ekem1 = le texte chiffré KEM, envoyé de Bob à Alice (jeton spécifique à I2P) Note importante : Les noms de patrons \u0026ldquo;IKhfs\u0026rdquo; et \u0026ldquo;IKhfselg2\u0026rdquo; et les jetons \u0026ldquo;e1\u0026rdquo; et \u0026ldquo;ekem1\u0026rdquo; sont des adaptations spécifiques à I2P qui ne sont pas documentées dans la spécification officielle du Noise Protocol Framework. Ils représentent des définitions personnalisées pour intégrer ML-KEM dans le Noise IK pattern (patron IK du protocole Noise). Bien que l’approche hybride X25519 + ML-KEM soit largement reconnue dans la recherche en cryptographie post-quantique et dans d’autres protocoles, la nomenclature utilisée ici est spécifique à I2P.\nLes modifications suivantes apportées à IK pour une confidentialité persistante hybride sont appliquées :\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. Le modèle e1 est défini comme suit :\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) Le modèle ekem1 est défini comme suit:\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) Opérations ML-KEM définies Nous définissons les fonctions suivantes correspondant aux primitives cryptographiques telles que spécifiées dans FIPS203 .\n(encap_key, decap_key) = PQ_KEYGEN() : Alice crée les clés d’encapsulation et de décapsulation. La clé d’encapsulation est envoyée dans le message NS. Tailles des clés : - ML-KEM-512: encap_key = 800 octets, decap_key = 1632 octets - ML-KEM-768: encap_key = 1184 octets, decap_key = 2400 octets - ML-KEM-1024: encap_key = 1568 octets, decap_key = 3168 octets\n(ciphertext, kem_shared_key) = ENCAPS(encap_key) : Bob calcule le texte chiffré et la clé partagée en utilisant la clé d\u0026rsquo;encapsulation reçue dans le message NS. Le texte chiffré est envoyé dans le message NSR. Tailles du texte chiffré: - ML-KEM-512: 768 octets - ML-KEM-768: 1088 octets - ML-KEM-1024: 1568 octets\nLa kem_shared_key est toujours de 32 octets pour les trois variantes.\nkem_shared_key = DECAPS(ciphertext, decap_key) : Alice calcule la clé partagée en utilisant le texte chiffré reçu dans le message NSR. La kem_shared_key est toujours de 32 octets.\nImportant: L\u0026rsquo;encap_key et le texte chiffré sont tous deux chiffrés dans des blocs ChaCha20-Poly1305 dans les messages 1 et 2 du handshake (négociation initiale) Noise. Ils seront déchiffrés dans le cadre du processus de handshake.\nLa kem_shared_key est intégrée à la clé de chaînage avec MixKey(). Voir ci-dessous pour plus de détails.\nFonction de dérivation de clés du handshake Noise Aperçu Le handshake hybride (poignée de main hybride) combine X25519 ECDH classique avec ML-KEM post-quantique. Le premier message, d’Alice à Bob, contient e1 (la clé d’encapsulation ML-KEM) avant la charge utile du message. Celle-ci est traitée comme un matériau de clé supplémentaire ; appelez EncryptAndHash() sur e1 (en tant qu’Alice) ou DecryptAndHash() (en tant que Bob). Traitez ensuite la charge utile du message comme d’habitude.\nLe deuxième message, de Bob à Alice, contient ekem1 (le texte chiffré ML-KEM) avant la charge utile du message. Ceci est traité comme du matériel de clé supplémentaire; appelez EncryptAndHash() sur celui-ci (en tant que Bob) ou DecryptAndHash() (en tant qu’Alice). Calculez ensuite kem_shared_key et appelez MixKey(kem_shared_key). Traitez ensuite la charge utile du message comme d’habitude.\nIdentifiants Noise (cadre de protocoles cryptographiques) Voici les chaînes d\u0026rsquo;initialisation Noise (spécifiques à I2P) :\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 KDF (fonction de dérivation de clés) d’Alice pour le message NS Après le motif de message \u0026rsquo;es\u0026rsquo; et avant le motif de message \u0026rsquo;s\u0026rsquo;, ajoutez :\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). KDF (fonction de dérivation de clé) de Bob pour le message NS Après le motif de message \u0026rsquo;es\u0026rsquo; et avant le motif de message \u0026rsquo;s\u0026rsquo;, ajoutez :\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). Fonction de dérivation de clé (KDF) de Bob pour le message NSR Après le modèle de message \u0026rsquo;ee\u0026rsquo; et avant le modèle de message \u0026lsquo;se\u0026rsquo;, ajoutez :\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. Fonction de dérivation de clé (KDF) d\u0026rsquo;Alice pour le message NSR Après le motif de message \u0026rsquo;ee\u0026rsquo; et avant le motif de message \u0026lsquo;ss\u0026rsquo;, ajoutez:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. Fonction de dérivation de clé (KDF) pour split() La fonction split() reste inchangée par rapport à la spécification standard d’ECIES. Après l’achèvement du handshake (négociation de session) :\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] Ce sont les clés de session bidirectionnelles pour la communication en cours.\nFormat du message Format de NS (New Session) Modifications : Le ratchet (mécanisme de cliquet cryptographique) actuel contient la clé statique dans la première section ChaCha20-Poly1305 et la charge utile dans la deuxième section. Avec ML-KEM, il y a désormais trois sections. La première section contient la clé publique ML-KEM chiffrée (encap_key). La deuxième section contient la clé statique. La troisième section contient la charge utile.\nTailles des messages :\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl **Remarque :** La charge utile doit contenir un bloc DateTime (date-heure) (minimum 7 octets : type sur 1 octet, taille sur 2 octets, horodatage sur 4 octets). Les tailles NS minimales peuvent être calculées en conséquence. La taille NS pratique minimale est donc de 103 octets pour X25519 et va de 919 à 1687 octets pour les variantes hybrides. Les augmentations de taille de 816, 1200 et 1584 octets pour les trois variantes de ML-KEM (mécanisme d’encapsulation de clés basé sur des réseaux modulaires) s’expliquent par l’ajout de la clé publique ML-KEM et d’un MAC Poly1305 de 16 octets pour le chiffrement authentifié.\nNSR (réponse de nouvelle session) Format Modifications: Le ratchet (mécanisme de cliquet cryptographique) actuel a une charge utile vide pour la première section ChaCha20-Poly1305 et place la charge utile dans la deuxième section. Avec ML-KEM, il y a désormais trois sections. La première section contient le texte chiffré de ML-KEM, lui-même chiffré. La deuxième section a une charge utile vide. La troisième section contient la charge utile.\nTailles des messages:\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl Les augmentations de taille de 784, 1104 et 1584 octets pour les trois variantes de ML-KEM s’expliquent par le texte chiffré ML-KEM, ainsi qu’un MAC Poly1305 de 16 octets pour le chiffrement authentifié. Analyse de la surcharge Échange de clés La surcharge du chiffrement hybride est considérable par rapport à X25519 seul :\nMLKEM512_X25519: Augmentation d\u0026rsquo;environ 9-12x de la taille du message de poignée de main (NS: 9.5x, NSR: 11.9x) MLKEM768_X25519: Augmentation d\u0026rsquo;environ 13-16x de la taille du message de poignée de main (NS: 13.5x, NSR: 16.3x) MLKEM1024_X25519: Augmentation d\u0026rsquo;environ 17-23x de la taille du message de poignée de main (NS: 17.5x, NSR: 23x) Cette surcharge est acceptable compte tenu des avantages supplémentaires en matière de sécurité post-quantique. Les multiplicateurs varient selon le type de message, car les tailles de base des messages diffèrent (NS minimum 96 octets, NSR minimum 72 octets).\nConsidérations sur la bande passante Pour un établissement de session typique avec des charges utiles minimales: - X25519 uniquement: ~200 octets au total (NS + NSR) - MLKEM512_X25519: ~1,800 octets au total (augmentation de 9x) - MLKEM768_X25519: ~2,500 octets au total (augmentation de 12.5x) - MLKEM1024_X25519: ~3,400 octets au total (augmentation de 17x)\nAprès l’établissement de la session, le chiffrement continu des messages utilise le même format de transport de données que les sessions utilisant uniquement X25519, de sorte qu’il n’y a pas de surcharge pour les messages ultérieurs.\nAnalyse de sécurité Poignées de main Le handshake hybride offre une sécurité classique (X25519) et post-quantique (ML-KEM, mécanisme d\u0026rsquo;encapsulation de clé). Un attaquant doit casser à la fois l\u0026rsquo;ECDH classique et le KEM post-quantique pour compromettre les clés de session.\nCela fournit: - Sécurité actuelle: X25519 ECDH fournit une sécurité contre des adversaires classiques (niveau de sécurité de 128 bits) - Sécurité future: ML-KEM (mécanisme d’encapsulation de clé post-quantique) fournit une sécurité contre des adversaires quantiques (varie selon le jeu de paramètres) - Sécurité hybride: Les deux doivent être brisés pour compromettre la session (niveau de sécurité = maximum des deux composants)\nNiveaux de sécurité Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit **Remarque :** Le niveau de sécurité hybride est borné par le plus faible des deux composants. Dans tous les cas, X25519 offre une sécurité classique de 128 bits. Si un ordinateur quantique pertinent du point de vue cryptographique devenait disponible, le niveau de sécurité dépendrait du jeu de paramètres ML-KEM choisi. Confidentialité persistante L\u0026rsquo;approche hybride préserve les propriétés de confidentialité persistante. Les clés de session sont dérivées des deux échanges de clés éphémères, X25519 et ML-KEM. Si les clés privées éphémères X25519 ou ML-KEM sont détruites après le handshake (échange initial), les sessions passées ne peuvent pas être déchiffrées, même si les clés statiques à long terme sont compromises.\nLe pattern IK (modèle IK) fournit une confidentialité persistante complète (confidentialité Noise niveau 5) après l’envoi du deuxième message (NSR).\nPréférences de type Les implémentations devraient prendre en charge plusieurs types hybrides et négocier la variante la plus sûre mutuellement prise en charge. L’ordre de préférence devrait être :\nMLKEM768_X25519 (Type 6) - Valeur par défaut recommandée, meilleur équilibre entre sécurité et performances MLKEM1024_X25519 (Type 7) - Sécurité maximale pour les applications sensibles MLKEM512_X25519 (Type 5) - Niveau de sécurité post-quantique de base pour les scénarios avec ressources limitées X25519 (Type 4) - Classique uniquement, solution de repli pour la compatibilité Justification: MLKEM768_X25519 est recommandé comme valeur par défaut car il offre une sécurité de catégorie 3 du NIST (équivalent AES-192), jugée suffisante pour se protéger contre les ordinateurs quantiques tout en conservant des tailles de messages raisonnables. MLKEM1024_X25519 offre une sécurité plus élevée, mais au prix d\u0026rsquo;une surcharge considérablement accrue.\nNotes d\u0026rsquo;implémentation Prise en charge des bibliothèques Java: La bibliothèque Bouncycastle à partir de la version 1.79 (août 2024) prend en charge toutes les variantes ML-KEM (mécanisme d\u0026rsquo;encapsulation de clés basé sur des réseaux modulaires) requises ainsi que les fonctions SHA3/SHAKE. Utilisez org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine pour la conformité FIPS 203. C++: OpenSSL 3.5 (avril 2025) et versions ultérieures incluent la prise en charge de ML-KEM via l\u0026rsquo;interface EVP_KEM. Il s\u0026rsquo;agit d\u0026rsquo;une version à support à long terme (LTS) maintenue jusqu\u0026rsquo;en avril 2030. Go: Plusieurs bibliothèques tierces sont disponibles pour ML-KEM et SHA3, dont la bibliothèque CIRCL de Cloudflare. Stratégie de migration Les implémentations devraient : 1. Prendre en charge à la fois X25519 seul et les variantes hybrides ML-KEM (mécanisme d’encapsulation de clé basé sur des réseaux modulaires, standard post-quantique) pendant la période de transition 2. Privilégier les variantes hybrides lorsque les deux pairs les prennent en charge 3. Conserver une solution de repli vers X25519 seul pour la rétrocompatibilité 4. Prendre en compte les contraintes de bande passante du réseau lors du choix de la variante par défaut\nTunnels partagés L’augmentation de la taille des messages peut affecter l’utilisation des tunnel partagés. Les implémentations devraient envisager: - Regrouper les handshakes (échanges d’amorçage) lorsque c’est possible pour amortir la surcharge - Utiliser des durées d’expiration plus courtes pour les sessions hybrides afin de réduire l’état stocké - Surveiller l’utilisation de la bande passante et ajuster les paramètres en conséquence - Mettre en œuvre un contrôle de congestion pour le trafic d’établissement de session\nConsidérations sur la taille des nouvelles sessions En raison de messages de handshake (négociation initiale) plus volumineux, les implémentations pourraient avoir besoin de: - augmenter les tailles de tampon pour la négociation de session (minimum de 4 Ko recommandé) - ajuster les valeurs de délai d\u0026rsquo;expiration pour les connexions plus lentes (tenir compte de messages ~3-17x plus volumineux) - envisager la compression des données de charge utile dans les messages NS/NSR - implémenter la gestion de la fragmentation si la couche de transport l\u0026rsquo;exige\nTests et validation Les implémentations devraient vérifier: - Exactitude de la génération de clés ML-KEM, de l\u0026rsquo;encapsulation et de la décapsulation - Intégration correcte de kem_shared_key dans Noise KDF - Les calculs de la taille des messages correspondent à la spécification - Interopérabilité avec d\u0026rsquo;autres implémentations de router I2P - Comportement de repli lorsque ML-KEM n\u0026rsquo;est pas disponible\nLes vecteurs de test pour les opérations ML-KEM sont disponibles dans le Programme de validation des algorithmes cryptographiques (Cryptographic Algorithm Validation Program) du NIST.\nCompatibilité des versions Numérotation des versions d\u0026rsquo;I2P : I2P maintient deux numéros de version parallèles : - Version de publication du router : format 2.x.x (par exemple, 2.10.0 publiée en septembre 2025) - Version de l\u0026rsquo;API/protocole : format 0.9.x (par exemple, 0.9.67 correspond au router 2.10.0)\nCette spécification fait référence à la version 0.9.67 du protocole, laquelle correspond à la version 2.10.0 du router et aux versions ultérieures.\nMatrice de compatibilité:\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release ## Références [ECIES]: Spécification ECIES-X25519-AEAD-Ratchet [Prop169]: Proposition 169 : cryptographie post-quantique [FIPS203]: NIST FIPS 203 - Norme ML-KEM [FIPS202]: NIST FIPS 202 - Norme SHA-3 [Noise]: Cadre du protocole Noise [COMMON]: Spécification des structures communes [RFC7539]: RFC 7539 - ChaCha20 et Poly1305 [RFC5869]: RFC 5869 - HKDF [OpenSSL]: Documentation OpenSSL 3.5 ML-KEM [Bouncycastle]: Bibliothèque de cryptographie Java Bouncycastle ","description":"Variante hybride post-quantique du protocole de chiffrement ECIES utilisant ML-KEM (mécanisme d'encapsulation de clés post-quantique basé sur des réseaux modulaires)","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"Chiffrement hybride ECIES-X25519-AEAD-Ratchet","url":"/fr/docs/specs/ecies-hybrid/"},{"categories":null,"content":" Les versions 0.9.57 et suivantes sont signées par idk. Sa clé publique actuelle est : Télécharger la clé publique PGP Les versions 0.7.6 et 0.9.56 sont signées par zzz. Sa clé publique actuelle est : Télécharger la clé publique PGP -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 J\u0026rsquo;ai créé de nouvelles clés GPG et sous-clés et j\u0026rsquo;ai signé les nouvelles clés avec l\u0026rsquo;ancienne clé.\nAnciennes clés :\npub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) \u0026lt;zzz@mail.i2p\u0026gt; sub 2048g/74C8122D 2005-12-16 Nouvelles clés :\npub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) \u0026lt;zzz@mail.i2p\u0026gt; uid zzz on i2p (key signing) \u0026lt;zzz@i2pmail.org\u0026gt; sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07] J\u0026rsquo;utiliserai les nouvelles clés comme suit :\nEE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing La clé de signature des versions sera utilisée à partir de la version 0.9.13. Ce message est signé avec mon ancienne clé.\nzzz 25 mai 2014\nLes nouvelles clés suivent :\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.14 (GNU/Linux)\nmQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dpXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHp\niEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; Les versions à partir de 0.9.9 peuvent être signées par str4d. Sa clé publique actuelle est : -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 Mes clés publiques actuelles sont les suivantes :\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [expire : 2019-03-10] uid [ complet ] str4d (http://str4d.i 2p) str4d@mail.i2p uid [ complet ] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [expiré : 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [expiré : 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [expire : 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [expire : 2016-04-04]\nJ\u0026rsquo;utilise actuellement les clés comme suit :\nA94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing Je génère de nouvelles sous-clés de chiffrement et de signature chaque année. Toute version d\u0026rsquo;I2P signée par moi sera toujours signée avec la dernière sous-clé de signature disponible au moment de la publication.\nstr4d 20 nov. 2015\nLes clés actuelles (à la date ci-dessus) suivent :\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z\niQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d a signé les versions suivantes : 0.9.23 Les versions 0.7.6 à 0.9.12 ont été signées par zzz avec la clé suivante : -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enop IDx6enpAbWFpbC5pMnA+iF8EExECAB8FAkOjTnUCGwMGCwkIBwMCBBUCCAMDFgIB Ah4BAheAAAoJEEFVdrqnbgvtxGsAn39SvQ3+ey87WDDG+TWArN6oU8gnAJ4zeAsA LUK37WZIt8OImZSxk37uQbkCDQRDo06VEAgAy2UeqsM5a+U6ZOWS9NQiILb3KbTL FeeAd2rn9oLSLpn5gDWycwUS0Q62JmbSMWy6m9aczpnxvwaBYXz6aCIvZmTNtaU6 vyR/6wfJDyiUWSHtCyjpyFFYJimANd8Y8dDCimvceI/ihEDVyBX0kkgUGRAn8t3e unaLXqhbfiLiFw/GG1MNxUMzHt55/+9AqLOfRZg0riZvDoV79K+1sYSs8n1WeaVc T3wTb+Cb7fKNN7GT1MUhcXIoYYY6FGwsy5EWFsxYBRervqHtBJog2SoNUa/6BFGr zX+LDjK9L3xMTr3+fHIt4gPR/Lt4nnfEzL+rjClz/Fazmv38BRwPuKahFwADBQgA nD/AvZCnbWSB6khAVMqva5ROaD0gV0/UejCelZdYfgfHeCmrcMNQ+wCyww2NPsih 9vB1w+AUE0pdH37k65VZN+2falUdzN+PFugJGuH2pmlVOprH2SuC5gKpGRvzUqV5 U0nJmT2okDpW/52asUDJJLu1g//A3qBP83WGvSKUZg/ZisZA0qTiHH4QpjklopXi sSxR2hT8Fr9gF9WmDa09wbxE2xh/EL7gvVg/vk0gwOJcsFd67bNC+KUMOnjhOP0T K0/Ah4TEEs/hHNe9RsyyWlMoIUsF8AhG71ISOrJ5lLSXNe151XEb5FzZRM8sD9Zq 0E3PjmLbdVhanYvsPnWK6YhJBBgRAgAJBQJDo06VAhsMAAoJEEFVdrqnbgvtXTwA njMu9ueCFbsjme7nwsz96PdazJcHAKCce17hGI25QNXDZyHohrjha6IxDg== =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nLes versions 0.6.1.31 à 0.7.5 ont été signées par Complication. Sa clé publique est : \u0026mdash;\u0026ndash;BEGIN PGP SIGNED MESSAGE\u0026mdash;\u0026ndash; Hash: SHA1\nBonjour,\nJe certifie que ci-dessous se trouve ma nouvelle clé publique, émise le 24/11/2007, valide jusqu\u0026rsquo;au 23/11/2009, et son empreinte de clé est :\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\nSi vous avez mon ancienne clé publique et que vous l\u0026rsquo;utilisez pour vérifier ceci, vous remarquerez que mon ancienne clé a expiré le 15-11-2007. Toutes mes excuses pour ce retard dans la mise à jour.\nPour les personnes qui souhaitent copier la clé directement depuis ce message, mais qui ne lisent pas ceci via un programme de messagerie électronique, n\u0026rsquo;oubliez pas de supprimer les séquences d\u0026rsquo;échappement \u0026ldquo;- \u0026quot; du marqueur de début et de fin du bloc de clé publique. Sinon, elle ne sera pas reconnue.\nComplication.\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\nmQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK - \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\niD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"Clés PGP utilisées pour signer les versions d'I2P et où les obtenir","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"Clé de signature des versions","url":"/fr/docs/develop/release-signing-key/"},{"categories":null,"content":"Contact de sécurité Pour signaler des vulnérabilités de sécurité ou des problèmes de sécurité sensibles, veuillez contacter l\u0026rsquo;équipe de sécurité I2P à security@i2p.net Pour une communication sécurisée, veuillez utiliser notre clé PGP ci-dessous.\nInformations sur la clé PGP Email : security@i2p.net ID de clé : 176E1941 Empreinte : 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 Type de clé : RSA 4096-bit Créée : 2025-10-19 Expire : 2030-11-19 UID : I2P Security \u0026lt;security@i2p.net\u0026gt; Clé publique mQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"Clé publique GPG pour contacter l'équipe de sécurité I2P","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"Clé GPG de sécurité","url":"/fr/docs/develop/security-key/"},{"categories":null,"content":"1. Aperçu général Les entrées dans clients.config indiquent au router quelles applications lancer au démarrage. Chaque entrée peut s\u0026rsquo;exécuter en tant que client géré (préféré) ou en tant que client non géré. Les clients gérés collaborent avec ClientAppManager, qui :\nInstancie l\u0026rsquo;application et suit l\u0026rsquo;état du cycle de vie pour la console du routeur Expose les contrôles de démarrage/arrêt à l\u0026rsquo;utilisateur et impose des arrêts propres à la sortie du routeur Héberge un registre de clients léger et un mappeur de ports afin que les applications puissent découvrir les services des autres Les clients non gérés invoquent simplement une méthode main() ; utilisez-les uniquement pour du code legacy qui ne peut pas être modernisé.\n2. Implémenter un client géré Les clients gérés doivent implémenter soit net.i2p.app.ClientApp (pour les applications destinées aux utilisateurs) soit net.i2p.router.app.RouterApp (pour les extensions de router). Fournissez l\u0026rsquo;un des constructeurs ci-dessous afin que le gestionnaire puisse fournir les arguments de contexte et de configuration :\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) Le tableau args contient les valeurs configurées dans clients.config ou les fichiers individuels dans clients.config.d/. Étendez les classes d\u0026rsquo;assistance ClientApp / RouterApp lorsque possible pour hériter du câblage de cycle de vie par défaut.\n2.1 Lifecycle Methods Les clients gérés doivent implémenter :\nstartup() - effectuer l\u0026rsquo;initialisation et retourner rapidement. Doit appeler manager.notify() au moins une fois pour passer de l\u0026rsquo;état INITIALIZED. shutdown(String[] args) - libérer les ressources et arrêter les threads d\u0026rsquo;arrière-plan. Doit appeler manager.notify() au moins une fois pour changer l\u0026rsquo;état vers STOPPING ou STOPPED. getState() - informer la console si l\u0026rsquo;application est en cours d\u0026rsquo;exécution, en démarrage, en arrêt, ou en échec Le gestionnaire appelle ces méthodes lorsque les utilisateurs interagissent avec la console.\n2.2 Advantages Rapports d\u0026rsquo;état précis dans la console du routeur Redémarrages propres sans fuite de threads ou de références statiques Empreinte mémoire réduite une fois l\u0026rsquo;application arrêtée Journalisation et rapport d\u0026rsquo;erreurs centralisés via le contexte injecté 3. Unmanaged Clients (Fallback Mode) Si la classe configurée n\u0026rsquo;implémente pas une interface gérée, le routeur la lance en invoquant main(String[] args) et ne peut pas suivre le processus résultant. La console affiche des informations limitées et les hooks d\u0026rsquo;arrêt peuvent ne pas s\u0026rsquo;exécuter. Réservez ce mode aux scripts ou aux utilitaires ponctuels qui ne peuvent pas adopter les API gérées.\n4. Client Registry Les clients gérés et non gérés peuvent s\u0026rsquo;enregistrer auprès du gestionnaire afin que d\u0026rsquo;autres composants puissent récupérer une référence par nom :\nmanager.register(this); L\u0026rsquo;enregistrement utilise la valeur de retour de getName() du client comme clé de registre. Les enregistrements connus incluent console, i2ptunnel, Jetty, outproxy et update. Récupérez un client avec ClientAppManager.getRegisteredApp(String name) pour coordonner les fonctionnalités (par exemple, la console interrogeant Jetty pour obtenir des détails d\u0026rsquo;état).\nNotez que le registre client et le mappeur de ports sont des systèmes séparés. Le registre client permet la communication inter-applications par recherche de nom, tandis que le mappeur de ports associe les noms de services aux combinaisons hôte:port pour la découverte de services.\n3. Clients non gérés (Mode de secours) Le mappeur de ports offre un répertoire simple pour les services TCP internes. Enregistrez les ports de loopback afin que les collaborateurs évitent les adresses codées en dur :\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); Ou avec une spécification explicite de l\u0026rsquo;hôte :\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); Recherchez les services en utilisant PortMapper.getPort(String name) (retourne -1 si non trouvé) ou getPort(String name, int defaultPort) (retourne la valeur par défaut si non trouvé). Vérifiez le statut d\u0026rsquo;enregistrement avec isRegistered(String name) et récupérez l\u0026rsquo;hôte enregistré avec getActualHost(String name).\nConstantes courantes du service de mappage de ports provenant de net.i2p.util.PortMapper :\nSVC_CONSOLE - Console du routeur (port par défaut 7657) SVC_HTTP_PROXY - Proxy HTTP (port par défaut 4444) SVC_HTTPS_PROXY - Proxy HTTPS (port par défaut 4445) SVC_I2PTUNNEL - Gestionnaire I2PTunnel SVC_SAM - Pont SAM (port par défaut 7656) SVC_SAM_SSL - Pont SAM SSL SVC_SAM_UDP - SAM UDP SVC_BOB - Pont BOB (port par défaut 2827) SVC_EEPSITE - Eepsite standard (port par défaut 7658) SVC_HTTPS_EEPSITE - Eepsite HTTPS SVC_IRC - Tunnel IRC (port par défaut 6668) SVC_SUSIDNS - SusiDNS Remarque : httpclient, httpsclient et httpbidirclient sont des types de tunnel i2ptunnel (utilisés dans la configuration tunnel.N.type), et non des constantes de service de mappage de ports.\n4. Registre des clients 2.1 Méthodes de cycle de vie À partir de la version 0.9.42, le router prend en charge la répartition de la configuration dans des fichiers individuels au sein du répertoire clients.config.d/. Chaque fichier contient les propriétés d\u0026rsquo;un seul client avec toutes les propriétés préfixées par clientApp.0. :\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true C\u0026rsquo;est l\u0026rsquo;approche recommandée pour les nouvelles installations et les plugins.\n2.2 Avantages Pour des raisons de rétrocompatibilité, le format traditionnel utilise une numérotation séquentielle :\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties Requis : - main - Nom complet de la classe implémentant ClientApp ou RouterApp, ou contenant la méthode statique main(String[] args)\nOptionnel : - name - Nom d\u0026rsquo;affichage pour la console du router (par défaut le nom de la classe) - args - Arguments séparés par des espaces ou des tabulations (prend en charge les chaînes entre guillemets) - delay - Secondes avant le démarrage (par défaut 120) - onBoot - Force delay=0 si vrai - startOnLoad - Active/désactive le client (par défaut vrai)\nSpécifique au plugin : - stopargs - Arguments passés lors de l\u0026rsquo;arrêt - uninstallargs - Arguments passés lors de la désinstallation du plugin - classpath - Entrées de classpath supplémentaires séparées par des virgules\nSubstitution de variables pour les plugins : - $I2P - Répertoire de base I2P - $CONFIG - Répertoire de configuration utilisateur (par ex., ~/.i2p) - $PLUGIN - Répertoire du plugin - $OS - Nom du système d\u0026rsquo;exploitation - $ARCH - Nom de l\u0026rsquo;architecture\n5. Port Mapper Privilégier les clients gérés ; ne recourir aux clients non gérés que lorsque c\u0026rsquo;est absolument nécessaire. Garder l\u0026rsquo;initialisation et l\u0026rsquo;arrêt légers afin que les opérations de console restent réactives. Utiliser des noms de registre et de port descriptifs pour que les outils de diagnostic (et les utilisateurs finaux) comprennent ce que fait un service. Éviter les singletons statiques - s\u0026rsquo;appuyer sur le contexte et le gestionnaire injectés pour partager les ressources. Appeler manager.notify() lors de toutes les transitions d\u0026rsquo;état pour maintenir un statut de console précis. Si vous devez exécuter dans une JVM séparée, documenter comment les journaux et diagnostics sont exposés à la console principale. Pour les programmes externes, envisager d\u0026rsquo;utiliser ShellService (ajouté dans la version 1.7.0) pour bénéficier des avantages des clients gérés. 6. Format de configuration Les clients gérés ont été introduits dans la version 0.9.4 (17 décembre 2012) et restent l\u0026rsquo;architecture recommandée depuis la version 2.10.0 (9 septembre 2025). Les API principales sont restées stables sans aucun changement incompatible durant cette période :\nSignatures des constructeurs inchangées Méthodes de cycle de vie (startup, shutdown, getState) inchangées Méthodes d\u0026rsquo;enregistrement ClientAppManager inchangées Méthodes d\u0026rsquo;enregistrement et de recherche PortMapper inchangées Améliorations notables : - 0.9.42 (2019) - structure de répertoire clients.config.d/ pour les fichiers de configuration individuels - 1.7.0 (2021) - ShellService ajouté pour le suivi d\u0026rsquo;état des programmes externes - 2.10.0 (2025) - Version actuelle sans modifications de l\u0026rsquo;API des clients gérés\nLa prochaine version majeure nécessitera Java 17+ au minimum (exigence d\u0026rsquo;infrastructure, et non une modification de l\u0026rsquo;API).\nReferences Spécification de clients.config Spécification des fichiers de configuration Index de la documentation technique I2P Javadoc de ClientAppManager (API 0.9.66) Javadoc de PortMapper (API 0.9.66) Interface ClientApp (API 0.9.66) Interface RouterApp (API 0.9.66) Javadoc alternative (version stable) Javadoc alternative (miroir clearnet) Remarque : Le réseau I2P héberge une documentation complète sur http://idk.i 2p/javadoc-i2p/ qui nécessite un router I2P pour y accéder. Pour un accès clearnet, utilisez le miroir GitHub Pages ci-dessus.\n","description":"Comment les applications gérées par le routeur s'intègrent avec ClientAppManager et le mappeur de ports","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"Clients Gérés","url":"/fr/docs/applications/managed-clients/"},{"categories":null,"content":"L\u0026rsquo;implémentation principale du client I2P utilise Java. Si vous ne pouvez pas ou préférez ne pas utiliser Java sur un système particulier, il existe des implémentations alternatives du client I2P développées et maintenues par des membres de la communauté. Ces programmes fournissent les mêmes fonctionnalités de base en utilisant différents langages de programmation ou approches.\nTableau de comparaison Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements --- i2pd (C++) Site web : https://i2pd.website Description : i2pd (le I2P Daemon) est un client I2P complet implémenté en C++. Il est stable pour une utilisation en production depuis de nombreuses années (depuis environ 2016) et est activement maintenu par la communauté. i2pd implémente entièrement les protocoles réseau et les API I2P, le rendant totalement compatible avec le réseau I2P Java. Ce router C++ est souvent utilisé comme alternative légère sur les systèmes où l\u0026rsquo;environnement d\u0026rsquo;exécution Java n\u0026rsquo;est pas disponible ou souhaité. i2pd inclut une console web intégrée pour la configuration et la surveillance. Il est multiplateforme et disponible dans de nombreux formats de paquets — il existe même une version Android d\u0026rsquo;i2pd (par exemple, via F-Droid).\nGo-I2P (Go) Dépôt : https://github.com/go-i2p/go-i2p Description : Go-I2P est un client I2P écrit dans le langage de programmation Go. Il s\u0026rsquo;agit d\u0026rsquo;une implémentation indépendante du router I2P, visant à tirer parti de l\u0026rsquo;efficacité et de la portabilité de Go. Le projet est en développement actif, mais il est encore à un stade précoce et n\u0026rsquo;est pas encore complet en termes de fonctionnalités. En 2025, Go-I2P est considéré comme expérimental — il fait l\u0026rsquo;objet d\u0026rsquo;un travail actif par les développeurs de la communauté, mais il n\u0026rsquo;est pas recommandé pour une utilisation en production tant qu\u0026rsquo;il n\u0026rsquo;aura pas davantage mûri. L\u0026rsquo;objectif de Go-I2P est de fournir un router I2P moderne et léger avec une compatibilité totale avec le réseau I2P une fois le développement terminé.\nI2P+ (fork Java) Site web : https://i2pplus.github.io Description : I2P+ est un fork maintenu par la communauté du client Java I2P standard. Il ne s\u0026rsquo;agit pas d\u0026rsquo;une réimplémentation dans un nouveau langage, mais plutôt d\u0026rsquo;une version améliorée du router Java avec des fonctionnalités et optimisations supplémentaires. I2P+ se concentre sur l\u0026rsquo;amélioration de l\u0026rsquo;expérience utilisateur et de meilleures performances tout en restant totalement compatible avec le réseau I2P officiel. Il introduit une interface de console web rafraîchie, des options de configuration plus conviviales et diverses optimisations (par exemple, performances torrent améliorées et meilleure gestion des pairs réseau, en particulier pour les routers derrière des pare-feu). I2P+ nécessite un environnement Java tout comme le logiciel I2P officiel, ce n\u0026rsquo;est donc pas une solution pour les environnements non-Java. Cependant, pour les utilisateurs qui disposent de Java et souhaitent une version alternative avec des capacités supplémentaires, I2P+ offre une option intéressante. Ce fork est maintenu à jour avec les versions I2P en amont (sa numérotation de version ajoutant un « + ») et peut être obtenu depuis le site web du projet.\n","description":"Implémentations client I2P maintenues par la communauté (mises à jour pour 2025)","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"Clients I2P alternatifs","url":"/fr/docs/overview/alternative-clients/"},{"categories":null,"content":"Aperçu Cette spécification étend le flux d’abonnement aux adresses avec des commandes, permettant aux serveurs de noms de diffuser des mises à jour des entrées provenant des détenteurs de noms d’hôte. Proposée à l’origine dans Proposal 112 (septembre 2014), implémentée dans la version 0.9.26 (juin 2016) et déployée à l’échelle du réseau avec le statut CLOSED.\nLe système est resté stable et inchangé depuis sa mise en œuvre initiale, continuant à fonctionner à l’identique dans I2P 2.10.0 (Router API 0.9.65, septembre 2025).\nMotivation Auparavant, les serveurs d’abonnement hosts.txt envoyaient des données uniquement dans un format hosts.txt simple :\nexample.i2p=b64destination Ce format de base a créé plusieurs problèmes :\nLes détenteurs de noms d’hôte ne peuvent pas mettre à jour la Destination (identifiant public I2P) associée à leurs noms d’hôte (par exemple, pour mettre à niveau la clé de signature vers un type cryptographique plus robuste). Les détenteurs de noms d’hôte ne peuvent pas céder leurs noms d’hôte arbitrairement. Ils doivent remettre directement au nouveau titulaire les clés privées de la Destination correspondante. Il n’existe aucun moyen d’authentifier qu’un sous-domaine est contrôlé par le nom d’hôte de base correspondant. Cela n’est actuellement appliqué qu’individuellement par certains serveurs de noms. Conception Cette spécification ajoute des directives au format hosts.txt. Grâce à ces directives, les serveurs de noms peuvent étendre leurs services afin de fournir des fonctionnalités supplémentaires. Les clients qui implémentent cette spécification peuvent recevoir ces fonctionnalités via le processus d’abonnement habituel.\nToutes les lignes de commande doivent être signées par la Destination correspondante. Cela garantit que les modifications ne sont effectuées qu’à la demande du titulaire du nom d’hôte.\nImplications en matière de sécurité Cette spécification n\u0026rsquo;affecte pas l\u0026rsquo;anonymat.\nOn observe une augmentation du risque lié à la perte de contrôle d’une Destination key (clé associée à une Destination I2P), car toute personne qui l’obtient peut utiliser ces commandes pour apporter des modifications à tous les noms d’hôte associés. Cependant, ce n’est pas plus problématique que le statu quo, où quelqu’un qui obtient une Destination (identifiant I2P) peut usurper un nom d’hôte et prendre (partiellement) le contrôle de son trafic. Ce risque accru est compensé par la possibilité donnée aux détenteurs de noms d’hôte de modifier la Destination associée à un nom d’hôte s’ils estiment que la Destination a été compromise. Cela est impossible avec le système actuel.\nSpécification Nouveaux types de ligne Il existe deux nouveaux types de lignes :\nCommandes Add et Change: example.i2p=b64destination#!key1=val1#key2=val2... Supprimer les commandes: #!key1=val1#key2=val2... Ordonnancement Un flux n\u0026rsquo;est pas nécessairement dans l\u0026rsquo;ordre ni complet. Par exemple, une commande change peut apparaître sur une ligne avant une commande add, ou sans commande add.\nLes clés peuvent être dans n\u0026rsquo;importe quel ordre. Les clés en double ne sont pas autorisées. Toutes les clés et les valeurs sont sensibles à la casse.\nClés communes Requis dans toutes les commandes :\nsig : signature Base64, utilisant la clé de signature de la destination\nRéférences à un second nom d\u0026rsquo;hôte et/ou une destination:\noldname : Un deuxième nom d’hôte (nouveau ou modifié)\nolddest : Une deuxième destination Base64 (nouvelle ou modifiée)\noldsig : Une deuxième signature Base64, utilisant la clé de signature provenant de olddest\nAutres clés courantes :\naction : Une commande\nname : Le nom d\u0026rsquo;hôte, présent uniquement s\u0026rsquo;il n\u0026rsquo;est pas précédé de example.i2p=b64dest\ndest : La destination Base64, uniquement présente si elle n\u0026rsquo;est pas précédée de example.i2p=b64dest\ndate : En secondes depuis l\u0026rsquo;époque Unix\nexpires : En secondes depuis l\u0026rsquo;époque Unix\nCommandes Toutes les commandes, à l’exception de la commande \u0026ldquo;Add\u0026rdquo;, doivent contenir une paire clé/valeur action=command.\nPour assurer la compatibilité avec des clients plus anciens, la plupart des commandes sont précédées de example.i2p=b64dest, comme indiqué ci-dessous. En cas de modification, les valeurs indiquées sont toujours les nouvelles. Les anciennes valeurs sont incluses dans la section clé/valeur.\nLes clés répertoriées sont obligatoires. Toutes les commandes peuvent contenir des paires clé-valeur supplémentaires non définies ici.\nAjouter un nom d\u0026rsquo;hôte Précédé par example.i2p=b64dest : OUI, il s’agit du nouveau nom d’hôte et de la destination.\naction : NON incluse, c\u0026rsquo;est implicite.\nsig : signature\nExemple :\nexample.i2p=b64dest#!sig=b64sig Modifier le nom d\u0026rsquo;hôte Précédé par example.i2p=b64dest : OUI, c\u0026rsquo;est le nouveau nom d\u0026rsquo;hôte et l\u0026rsquo;ancienne destination.\naction : changename\noldname : l\u0026rsquo;ancien nom d\u0026rsquo;hôte, à remplacer\nsig : signature\nExemple:\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig Changer de destination Précédé de example.i2p=b64dest : OUI, c’est l’ancien nom d’hôte et la nouvelle destination.\naction : changedest\nolddest : l\u0026rsquo;ancienne destination, à remplacer\noldsig : signature utilisant olddest\nsig : signature\nExemple :\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Ajouter un alias de nom d’hôte Précédé de example.i2p=b64dest : OUI, il s\u0026rsquo;agit du nouveau nom d\u0026rsquo;hôte (alias) et de l\u0026rsquo;ancienne destination.\naction : addname\noldname : l\u0026rsquo;ancien nom d\u0026rsquo;hôte\nsig : signature\nExemple :\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig Ajouter un alias de destination (Utilisé pour la mise à niveau cryptographique)\nPrécédé par example.i2p=b64dest : OUI, il s’agit de l’ancien nom d’hôte et de la nouvelle destination (alternative).\naction : adddest\nolddest : l\u0026rsquo;ancienne destination\noldsig : signature utilisant olddest\nsig : signature utilisant dest\nExemple:\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Ajouter un sous-domaine Précédé par subdomain.example.i2p=b64dest : OUI, c\u0026rsquo;est le nouveau nom de sous-domaine et la destination.\naction : addsubdomain\noldname : le nom d\u0026rsquo;hôte de niveau supérieur (example.i2p)\nolddest : la destination de niveau supérieur (par exemple example.i2p)\noldsig : signature utilisant olddest\nsig : signature utilisant dest\nExemple :\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Mettre à jour les métadonnées Précédé par example.i2p=b64dest : OUI, il s\u0026rsquo;agit de l\u0026rsquo;ancien nom d\u0026rsquo;hôte et de la destination.\naction : mise à jour\nsig : signature\n(ajoutez ici toutes les clés mises à jour)\nExemple:\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig Supprimer le nom d\u0026rsquo;hôte Précédé par example.i2p=b64dest : NON, ceux-ci sont spécifiés dans les options\naction : supprimer\nname : le nom d\u0026rsquo;hôte\ndest : la destination\nsig : signature\nExemple:\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig Supprimer tout ayant cette destination Précédé par example.i2p=b64dest : NON, cela est spécifié dans les options\naction : removeall\ndest : la destination\nsig : signature\nExemple:\n#!action=removeall#dest=b64dest#sig=b64sig Signatures Toutes les commandes doivent être signées par la Destination correspondante. Les commandes avec deux destinations peuvent nécessiter deux signatures.\noldsig est toujours la signature \u0026ldquo;interne\u0026rdquo;. Signez et vérifiez sans que les clés oldsig ou sig soient présentes. sig est toujours la signature \u0026ldquo;externe\u0026rdquo;. Signez et vérifiez avec la clé oldsig présente mais pas la clé sig.\nEntrée pour les signatures Pour générer un flux d\u0026rsquo;octets afin de créer ou de vérifier la signature, sérialisez comme suit :\nSupprimez la clé sig Si vous vérifiez avec oldsig, supprimez également la clé oldsig Pour les commandes Add ou Change uniquement, émettez example.i2p=b64dest S\u0026rsquo;il reste des clés, émettez #! Triez les options par clé UTF-8, échouez en cas de clés en double Pour chaque paire clé/valeur, émettez key=value, suivi (s\u0026rsquo;il ne s\u0026rsquo;agit pas de la dernière paire clé/valeur) d\u0026rsquo;un # Remarques\nNe pas produire de saut de ligne L\u0026rsquo;encodage de sortie est UTF-8 Tout encodage de destination et de signature est en Base 64 utilisant l\u0026rsquo;alphabet I2P Les clés et les valeurs sont sensibles à la casse Les noms d\u0026rsquo;hôte doivent être en minuscules Types de signature actuels À partir de I2P 2.10.0, les types de signature suivants sont pris en charge pour les destinations :\nEdDSA_SHA512_Ed25519 (Type 7): Le plus courant pour les destinations depuis la 0.9.15. Utilise une clé publique de 32 octets et une signature de 64 octets. C’est le type de signature recommandé pour les nouvelles destinations. RedDSA_SHA512_Ed25519 (Type 13): Disponible uniquement pour les destinations et les leaseSets chiffrés (depuis la 0.9.39). Types hérités (DSA_SHA1, variantes ECDSA): Toujours pris en charge mais dépréciés pour les nouvelles identités de router depuis la 0.9.58. Remarque : Des options cryptographiques post-quantiques sont disponibles depuis I2P 2.10.0, mais ne sont pas encore les types de signature par défaut.\nCompatibilité Toutes les nouvelles lignes au format hosts.txt sont implémentées à l’aide de caractères de commentaire en tête (#!), de sorte que toutes les anciennes versions d’I2P interpréteront les nouvelles commandes comme des commentaires et les ignoreront proprement.\nLorsque les routers I2P sont mis à jour vers la nouvelle spécification, ils ne réinterpréteront pas les anciens commentaires, mais commenceront à prendre en compte les nouvelles commandes lors des récupérations ultérieures de leurs flux d’abonnement. Il est donc important que les serveurs de noms assurent la persistance des entrées de commande, d’une manière ou d’une autre, ou activent la prise en charge d’ETag afin que les routers puissent récupérer toutes les commandes passées.\nÉtat de l\u0026rsquo;implémentation Déploiement initial : Version 0.9.26 (7 juin 2016)\nStatut actuel: Stable et inchangé jusqu\u0026rsquo;à I2P 2.10.0 (Router API 0.9.65, septembre 2025)\nStatut de la proposition: FERMÉE (déployée avec succès sur l\u0026rsquo;ensemble du réseau)\nEmplacement de l\u0026rsquo;implémentation: apps/addressbook/java/src/net/i2p/addressbook/ dans le router Java d\u0026rsquo;I2P\nClasses clés: - SubscriptionList.java: Gère le traitement des abonnements - Subscription.java: Gère les flux d’abonnement individuels - AddressBook.java: Fonctionnalité de base du carnet d’adresses - Daemon.java: Service d’arrière-plan du carnet d’adresses\nURL d\u0026rsquo;abonnement par défaut : http://i2p-projekt.i2p/hosts.txt\nDétails des transports Les abonnements utilisent HTTP avec prise en charge des requêtes GET conditionnelles:\nEn-tête ETag: Permet une détection efficace des modifications En-tête Last-Modified: Suit les dates de mise à jour des abonnements 304 Not Modified: Les serveurs devraient renvoyer ce code lorsque le contenu n\u0026rsquo;a pas changé Content-Length: Fortement recommandé pour toutes les réponses Le router I2P utilise le comportement standard d\u0026rsquo;un client HTTP avec une prise en charge appropriée de la mise en cache.\nContexte de version Note sur le versionnage d\u0026rsquo;I2P : À partir de la version 1.5.0 (août 2021), I2P est passé d\u0026rsquo;un schéma de versionnage 0.9.x à un versionnage sémantique (1.x, 2.x, etc.). Cependant, la version interne de l\u0026rsquo;API du Router continue d\u0026rsquo;utiliser une numérotation en 0.9.x pour assurer la rétrocompatibilité. En octobre 2025, la version actuelle est I2P 2.10.0 avec une version de l\u0026rsquo;API du Router 0.9.65.\nCe document de spécification a été rédigé à l’origine pour la version 0.9.49 (février 2021) et reste parfaitement exact pour la version actuelle 0.9.65 (I2P 2.10.0), car le système de flux d’abonnement n’a connu aucun changement depuis sa mise en œuvre initiale dans la version 0.9.26.\nRéférences Proposition 112 (version originale) Spécification officielle Documentation sur le nommage I2P Spécification des structures communes Dépôt du code source I2P Dépôt I2P sur Gitea Développements connexes Bien que le système de flux d’abonnement lui-même n’ait pas changé, les développements connexes suivants dans l’infrastructure de nommage d’I2P peuvent vous intéresser :\nNoms Base32 étendus (0.9.40+) : Prise en charge des adresses base32 de 56 caractères et plus pour les leaseSets chiffrés. N\u0026rsquo;affecte pas le format du flux d\u0026rsquo;abonnement. Enregistrement du TLD .i2p.alt (RFC 9476, fin 2023) : Enregistrement officiel par la GANA de .i2p.alt en tant que TLD alternatif. De futures mises à jour du router pourraient supprimer le suffixe .alt, mais aucune modification des commandes d\u0026rsquo;abonnement n\u0026rsquo;est requise. Cryptographie post-quantique (2.10.0+) : Disponible mais non activée par défaut. Des évolutions futures sont envisagées pour les algorithmes de signature dans les flux d\u0026rsquo;abonnement. ","description":"Extension des flux d’abonnement d’adresses, permettant aux titulaires de noms d’hôte de mettre à jour et de gérer leurs entrées","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"Commandes du flux d'abonnement aux adresses","url":"/fr/docs/specs/subscription/"},{"categories":null,"content":"Ce guide explique comment configurer les navigateurs courants pour envoyer le trafic via le proxy HTTP intégré d\u0026rsquo;I2P. Il couvre Safari, Firefox et les navigateurs Chrome/Chromium avec des instructions détaillées étape par étape.\nNotes importantes :\nLe proxy HTTP par défaut d\u0026rsquo;I2P écoute sur 127.0.0.1:4444. I2P protège le trafic à l\u0026rsquo;intérieur du réseau I2P (sites .i2p). Assurez-vous que votre router I2P est en cours d\u0026rsquo;exécution avant de configurer votre navigateur. Safari (macOS) Safari utilise les paramètres de proxy à l\u0026rsquo;échelle du système sur macOS.\nStep 1: Open Network Settings Ouvrez Safari et allez dans Safari → Réglages (ou Préférences) Cliquez sur l\u0026rsquo;onglet Avancé Dans la section Proxys, cliquez sur Modifier les réglages\u0026hellip; Cela ouvrira les Réglages Réseau système de votre Mac.\nÉtape 1 : Ouvrir les paramètres réseau Dans les paramètres réseau, cochez la case Proxy Web (HTTP) Entrez les informations suivantes : Serveur Proxy Web : 127.0.0.1 Port : 4444 Cliquez sur OK pour enregistrer vos paramètres Vous pouvez maintenant parcourir les sites .i2p dans Safari !\nNote : Ces paramètres de proxy affecteront toutes les applications qui utilisent les proxys système de macOS. Envisagez de créer un compte utilisateur séparé ou d\u0026rsquo;utiliser un navigateur différent exclusivement pour I2P si vous souhaitez isoler la navigation I2P.\nFirefox (Desktop) Firefox possède ses propres paramètres de proxy indépendants du système, ce qui le rend idéal pour une navigation I2P dédiée.\nÉtape 2 : Configurer le proxy HTTP Cliquez sur le bouton de menu (☰) en haut à droite Sélectionnez Paramètres Step 2: Find Proxy Settings Dans la boîte de recherche des Paramètres, tapez \u0026ldquo;proxy\u0026rdquo; Faites défiler jusqu\u0026rsquo;à Paramètres réseau Cliquez sur le bouton Paramètres\u0026hellip; Étape 1 : Ouvrir les paramètres Sélectionnez Configuration manuelle du proxy Saisissez les informations suivantes : Proxy HTTP : 127.0.0.1 Port : 4444 Laissez Hôte SOCKS vide (sauf si vous avez spécifiquement besoin d\u0026rsquo;un proxy SOCKS) Cochez Proxy DNS lors de l\u0026rsquo;utilisation de SOCKS uniquement si vous utilisez un proxy SOCKS Cliquez sur OK pour enregistrer Vous pouvez maintenant naviguer sur les sites .i2p dans Firefox !\nAstuce : Envisagez de créer un profil Firefox distinct dédié à la navigation I2P. Cela permet de garder votre navigation I2P isolée de votre navigation habituelle. Pour créer un profil, tapez about:profiles dans la barre d\u0026rsquo;adresse de Firefox.\nChrome / Chromium (Desktop) Chrome et les navigateurs basés sur Chromium (Brave, Edge, etc.) utilisent généralement les paramètres proxy du système sur Windows et macOS. Ce guide présente la configuration Windows.\nÉtape 2 : Trouver les paramètres du proxy Cliquez sur le menu trois points (⋮) en haut à droite Sélectionnez Paramètres Étape 3 : Configurer le proxy manuellement Dans la zone de recherche des Paramètres, tapez \u0026ldquo;proxy\u0026rdquo; Cliquez sur Ouvrir les paramètres de proxy de votre ordinateur Step 3: Open Manual Proxy Setup Cela ouvrira les paramètres Réseau et Internet de Windows.\nFaites défiler vers le bas jusqu\u0026rsquo;à Configuration manuelle du proxy Cliquez sur Configurer Étape 1 : Ouvrir les paramètres de Chrome Basculez Utiliser un serveur proxy sur Activé Entrez ce qui suit : Adresse IP du proxy : 127.0.0.1 Port : 4444 Facultativement, ajoutez des exceptions dans « Ne pas utiliser le serveur proxy pour les adresses commençant par » (par ex., localhost;127.*) Cliquez sur Enregistrer Vous pouvez maintenant naviguer sur les sites .i2p dans Chrome !\nRemarque : Ces paramètres affectent tous les navigateurs basés sur Chromium et certaines autres applications sur Windows. Pour éviter cela, envisagez d\u0026rsquo;utiliser Firefox avec un profil I2P dédié à la place.\nÉtape 2 : Ouvrir les paramètres du proxy Sous Linux, vous pouvez lancer Chrome/Chromium avec des paramètres de proxy pour éviter de modifier les paramètres système :\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; Ou créez un script de lanceur de bureau :\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; Le flag --user-data-dir crée un profil Chrome distinct pour la navigation I2P.\nFirefox (Bureau) Les versions modernes de Firefox \u0026ldquo;Fenix\u0026rdquo; limitent about:config et les extensions par défaut. IceRaven est un fork de Firefox qui active un ensemble sélectionné d\u0026rsquo;extensions, simplifiant ainsi la configuration du proxy.\nConfiguration basée sur les extensions (IceRaven) :\nSi vous utilisez déjà IceRaven, envisagez d\u0026rsquo;effacer l\u0026rsquo;historique de navigation en premier (Menu → Historique → Supprimer l\u0026rsquo;historique). 2) Ouvrez Menu → Modules complémentaires → Gestionnaire de modules complémentaires. 3) Installez l\u0026rsquo;extension « I2P Proxy for Android and Other Systems ». 4) Le navigateur utilisera désormais I2P comme proxy. Cette extension fonctionne également sur les navigateurs basés sur Firefox pré-Fenix si elle est installée depuis AMO .\nL\u0026rsquo;activation d\u0026rsquo;une prise en charge étendue des extensions dans Firefox Nightly nécessite un processus distinct documenté par Mozilla .\nInternet Explorer / Windows System Proxy Sur Windows, la boîte de dialogue du proxy système s\u0026rsquo;applique à IE et peut être utilisée par les navigateurs basés sur Chromium lorsqu\u0026rsquo;ils héritent des paramètres système.\nOuvrez « Paramètres réseau et Internet » → « Proxy ». 2) Activez « Utiliser un serveur proxy pour votre réseau local ». 3) Définissez l\u0026rsquo;adresse 127.0.0.1, port 4444 pour HTTP. 4) Cochez éventuellement « Ne pas utiliser de serveur proxy pour les adresses locales ». ","description":"Configurer les navigateurs populaires pour utiliser les proxies HTTP/HTTPS d'I2P sur ordinateur de bureau et Android","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"Configuration du navigateur Web","url":"/fr/docs/guides/browser-config/"},{"categories":null,"content":"Aperçu Ce document fournit une spécification technique exhaustive des fichiers de configuration I2P utilisés par le router et diverses applications. Il couvre les spécifications des formats de fichiers, les définitions des propriétés et les détails d’implémentation vérifiés par rapport au code source d’I2P et à la documentation officielle.\nPortée Fichiers et formats de configuration du router Configurations des applications clientes Configurations de tunnel I2PTunnel Spécifications des formats de fichiers et implémentation Fonctionnalités spécifiques à une version et dépréciations Notes d’implémentation Les fichiers de configuration sont lus et écrits à l\u0026rsquo;aide des méthodes DataHelper.loadProps() et storeProps() de la bibliothèque principale d\u0026rsquo;I2P. Le format du fichier diffère sensiblement du format sérialisé utilisé dans les protocoles I2P (voir Spécification des structures communes - Correspondance des types ).\nFormat général du fichier de configuration Les fichiers de configuration I2P suivent un format Java Properties modifié, avec des exceptions et des contraintes spécifiques.\nSpécification du format Basé sur Java Properties avec les différences essentielles suivantes :\nEncodage DOIT utiliser l\u0026rsquo;encodage UTF-8 (PAS ISO-8859-1 comme dans les propriétés Java standard) Implémentation : Utilise les utilitaires DataHelper.getUTF8() pour toutes les opérations sur les fichiers Séquences d’échappement AUCUNE séquence d’échappement n’est reconnue (y compris le caractère de barre oblique inverse \\) La continuation de ligne n’est PAS prise en charge Les caractères de barre oblique inverse sont traités comme des caractères littéraux Caractères de commentaire # introduit un commentaire à n\u0026rsquo;importe quelle position sur une ligne ; introduit un commentaire uniquement lorsqu\u0026rsquo;il est en colonne 1 ! n\u0026rsquo;introduit PAS un commentaire (diffère de Java Properties) Séparateurs clé-valeur = est le SEUL séparateur clé-valeur valide : n\u0026rsquo;est PAS reconnu comme séparateur Les caractères d\u0026rsquo;espacement ne sont PAS reconnus comme des séparateurs Gestion des espaces blancs Les espaces blancs en début et en fin ne sont PAS supprimés pour les clés Les espaces blancs en début et en fin SONT supprimés pour les valeurs Traitement des lignes Les lignes sans = sont ignorées (traitées comme des commentaires ou des lignes vides) Les valeurs vides (key=) sont prises en charge à partir de la version 0.9.10 Les clés avec des valeurs vides sont stockées et récupérées normalement Restrictions de caractères Les clés ne doivent PAS contenir: - # (signe dièse) - = (signe égal) - \\n (caractère de saut de ligne) - Ne peuvent pas commencer par ; (point-virgule)\nLes valeurs ne doivent PAS contenir: - # (signe dièse/hash) - \\n (caractère de saut de ligne) - Ne peuvent pas commencer ni se terminer par \\r (retour chariot) - Ne peuvent pas commencer ni se terminer par des caractères d\u0026rsquo;espacement (supprimés automatiquement)\nTri des fichiers Les fichiers de configuration n\u0026rsquo;ont pas besoin d\u0026rsquo;être triés par clé. Cependant, la plupart des applications I2P trient les clés par ordre alphabétique lors de l\u0026rsquo;écriture des fichiers de configuration afin de faciliter : - Édition manuelle - Opérations diff (comparaison) de contrôle de version - Lisibilité humaine\nDétails d’implémentation Lecture des fichiers de configuration // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) Comportement: - Lit des fichiers encodés en UTF-8 - Applique toutes les règles de format décrites ci-dessus - Valide les restrictions de caractères - Retourne un objet Properties vide si le fichier n\u0026rsquo;existe pas - Lève une IOException en cas d\u0026rsquo;erreurs de lecture\nÉcriture des fichiers de configuration // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) Comportement: - Écrit des fichiers encodés en UTF-8 - Trie les clés par ordre alphabétique (sauf si OrderedProperties est utilisé) - Définit les permissions du fichier au mode 600 (lecture/écriture utilisateur uniquement) à partir de la version 0.8.1 - Lève IllegalArgumentException pour les caractères non valides dans les clés ou les valeurs - Lève IOException en cas d\u0026rsquo;erreurs d\u0026rsquo;écriture\nValidation du format L\u0026rsquo;implémentation effectue une validation stricte : - Les clés et les valeurs sont vérifiées afin de détecter les caractères interdits - Les entrées invalides provoquent des exceptions lors des opérations d\u0026rsquo;écriture - La lecture ignore silencieusement les lignes mal formées (lignes sans =)\nExemples de formats Fichier de configuration valide # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは Exemples de configurations invalides # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value Configuration de la bibliothèque principale et du router Configuration des clients (clients.config) Emplacement: $I2P_CONFIG_DIR/clients.config (ancien) ou $I2P_CONFIG_DIR/clients.config.d/ (moderne) Interface de configuration: console du router à /configclients Changement de format: Version 0.9.42 (août 2019)\nArborescence des répertoires (Version 0.9.42+) À partir de la version 0.9.42, le fichier clients.config par défaut est automatiquement scindé en fichiers de configuration individuels :\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) Comportement de migration: - Lors de la première exécution après la mise à niveau vers 0.9.42+, le fichier monolithique est scindé automatiquement - Les propriétés des fichiers scindés sont préfixées par clientApp.0. - L\u0026rsquo;ancien format reste pris en charge pour la rétrocompatibilité - Le format scindé permet une paquetisation modulaire et la gestion des plugins\nFormat des propriétés Les lignes sont de la forme clientApp.x.prop=val, où x est le numéro de l\u0026rsquo;application.\nExigences de numérotation des applications: - DOIT commencer par 0 - DOIT être consécutive (sans trous) - L\u0026rsquo;ordre détermine la séquence de démarrage\nPropriétés obligatoires principal Type: String (nom de classe entièrement qualifié) Requis: Oui Description: Selon le type de client (géré vs non géré), le constructeur ou la méthode main() de cette classe sera appelé Exemple: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner Propriétés facultatives nom Type: Chaîne de caractères Required: Non Description: Nom affiché dans la console du router Example: clientApp.0.name=Router Console arguments Type: Chaîne (séparée par des espaces ou des tabulations) Obligatoire: Non Description: Arguments transmis au constructeur de la classe principale ou à la méthode main() Guillemets: Les arguments contenant des espaces ou des tabulations peuvent être mis entre guillemets avec ' ou \u0026quot; Exemple: clientApp.0.args=-d $CONFIG/eepsite délai Type: Entier (secondes) Obligatoire: Non Par défaut: 120 Description: Nombre de secondes à attendre avant de démarrer le client Surcharges: Écrasé par onBoot=true (fixe le délai à 0) Valeurs spéciales: \u0026lt; 0: Attendre que le router atteigne l\u0026rsquo;état RUNNING, puis démarrer immédiatement dans un nouveau thread = 0: Exécuter immédiatement dans le même thread (les exceptions se propagent vers la console) \u0026gt; 0: Démarrer après le délai dans un nouveau thread (les exceptions sont consignées dans les journaux, non propagées) onBoot Type: Booléen Required: Non Default: false Description: Impose un délai de 0, outrepasse le réglage explicite du délai Use Case: Démarrer les services critiques immédiatement au démarrage du router startOnLoad Type: booléen Obligatoire: Non Valeur par défaut: true Description: Indique s\u0026rsquo;il faut démarrer le client Cas d\u0026rsquo;utilisation: Désactiver les clients sans supprimer la configuration Propriétés spécifiques au plugin Ces propriétés sont utilisées uniquement par les plugins (pas par les clients du noyau):\nstopargs Type: Chaîne de caractères (séparée par des espaces ou des tabulations) Description: Arguments transmis pour arrêter le client Variable Substitution: Oui (voir ci-dessous) uninstallargs Type: Chaîne (séparée par des espaces ou des tabulations) Description: Arguments transmis pour désinstaller le client Variable Substitution: Oui (voir ci-dessous) classpath (chemin de classes) Type: String (chemins séparés par des virgules) Description: Éléments supplémentaires du classpath pour le client Substitution de variables: Oui (voir ci-dessous) Substitution de variables (plugins uniquement) Les variables suivantes sont remplacées dans args, stopargs, uninstallargs et classpath pour les plugins :\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 **Remarque**: La substitution de variables est effectuée uniquement pour les plugins, pas pour les clients principaux. Types de clients Clients gérés Le constructeur est appelé avec les paramètres RouterContext et ClientAppManager Le client doit implémenter l\u0026rsquo;interface ClientApp Cycle de vie contrôlé par le router Peut être démarré, arrêté et redémarré dynamiquement Clients non gérés La méthode main(String[] args) est appelée S\u0026rsquo;exécute dans un fil d\u0026rsquo;exécution séparé Le cycle de vie n\u0026rsquo;est pas géré par le router Type de client hérité Exemple de configuration # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true Configuration de la journalisation (logger.config) Emplacement: $I2P_CONFIG_DIR/logger.config Interface de configuration: Console du router à /configlogging\nRéférence des propriétés Configuration du tampon de la console logger.consoleBufferSize Type: Entier Valeur par défaut: 20 Description: Nombre maximal de messages de journal à mettre en mémoire tampon dans la console Plage: 1-1000 recommandé Formatage de la date et de l\u0026rsquo;heure logger.dateFormat Type: String (motif SimpleDateFormat) Default: Selon la locale du système Example: HH:mm:ss.SSS Documentation: Java SimpleDateFormat Niveaux de journalisation logger.defaultLevel Type: Énumération Valeur par défaut: ERROR Valeurs: CRIT, ERROR, WARN, INFO, DEBUG Description: Niveau de journalisation par défaut pour toutes les classes logger.minimumOnScreenLevel Type: Énumération Par défaut: CRIT Valeurs: CRIT, ERROR, WARN, INFO, DEBUG Description: Niveau minimal pour les messages affichés à l\u0026rsquo;écran logger.record.{class} Type: Énumération Values: CRIT, ERROR, WARN, INFO, DEBUG Description: Surcharge du niveau de journalisation par classe Example: logger.record.net.i2p.router.transport.udp=DEBUG Options d’affichage logger.displayOnScreen Type: Booléen Par défaut: true Description: Indique s’il faut afficher les messages de journal dans la sortie de la console logger.dropDuplicates Type: Booléen Default: true Description: Supprime les messages de journal consécutifs en double logger.dropOnOverflow Type: Booléen Valeur par défaut: faux Description: Abandonner les messages lorsque le tampon est plein (plutôt que de bloquer) Comportement de vidage logger.flushInterval Type: Entier (secondes) Par défaut: 29 Depuis: Version 0.9.18 Description: Fréquence à laquelle vider le tampon de journal sur le disque Configuration du format logger.format Type: Chaîne (séquence de caractères) Description: Modèle de format de message de journalisation Format Characters: d = date/heure c = nom de classe t = nom du thread (fil d’exécution) p = priorité (niveau de journalisation) m = message Example: dctpm produit [horodatage] [classe] [thread] [niveau] message Compression (version 0.9.56+) logger.gzip Type: booléen Par défaut: false Depuis: Version 0.9.56 Description: Activer la compression gzip pour les fichiers journaux faisant l\u0026rsquo;objet d\u0026rsquo;une rotation logger.minGzipSize Type: Entier (octets) Valeur par défaut: 65536 Depuis: Version 0.9.56 Description: Taille de fichier minimale pour déclencher la compression (64 Ko par défaut) Gestion des fichiers logger.logBufferSize Type: Entier (octets) Valeur par défaut: 1024 Description: Nombre maximal de messages à mettre en mémoire tampon avant de vider le tampon logger.logFileName Type: Chaîne (chemin de fichier) Default: logs/log-@.txt Description: Modèle de nommage du fichier journal (@ remplacé par le numéro de rotation) logger.logFilenameOverride Type: Chaîne de caractères (chemin de fichier) Description: Remplacement du nom du fichier journal (désactive le schéma de rotation) logger.logFileSize Type: Chaîne de caractères (taille avec unité) Valeur par défaut: 10M Unités: K (kilooctets), M (mégaoctets), G (gigaoctets) Exemple: 50M, 1G logger.logRotationLimit Type: Entier Par défaut: 2 Description: Numéro maximal de fichier de rotation (log-0.txt à log-N.txt) Exemple de configuration # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN Configuration du plugin Configuration individuelle du plugin (plugins/*/plugin.config) Emplacement: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config Format: Format de fichier de configuration I2P standard Documentation: Spécification du plugin Propriétés requises nom Type: Chaîne de caractères Obligatoire: Oui Description: Nom d\u0026rsquo;affichage du plugin Exemple: name=I2P Plugin Example clé Type: Chaîne (clé publique) Obligatoire: Oui (à omettre pour les plugins signés SU3) Description: Clé publique de signature du plugin utilisée pour la vérification Format: Clé de signature encodée en Base64 signataire Type: Chaîne de caractères Required: Oui Description: Identité du signataire du plugin Example: signer=user@example.i2p version Type: Chaîne (format VersionComparator) Required: Oui Description: Version du plugin pour la vérification des mises à jour Format: Versionnage sémantique ou format comparable personnalisé Example: version=1.2.3 Propriétés d’affichage date Type: Long (type entier 64 bits; horodatage Unix en millisecondes) Description: Date de publication du plugin auteur Type: Chaîne de caractères Description: Nom de l\u0026rsquo;auteur du plugin websiteURL Type: Chaîne (URL) Description: URL du site du plugin updateURL Type : Chaîne de caractères (URL) Description : URL de vérification des mises à jour pour le plug-in updateURL.su3 Type: Chaîne (URL) Since: Version 0.9.15 Description: URL de mise à jour au format SU3 (recommandée) description Type: String Description: Description du plugin en anglais description_{language} Type: Chaîne de caractères Description: Description localisée du plugin Example: description_de=Deutsche Beschreibung licence Type: Chaîne de caractères Description: Identifiant de licence du plugin Exemple: license=Apache 2.0 Propriétés d\u0026rsquo;installation Ne pas démarrer après l’installation Type: booléen Default: false Description: Empêcher le démarrage automatique après l\u0026rsquo;installation Redémarrage du router requis Type: Booléen Default: false Description: Nécessite un redémarrage du router après l\u0026rsquo;installation installation seule Type: booléen Par défaut: false Description: Installer une seule fois (aucune mise à jour) mise à jour uniquement Type: Booléen Default: false Description: Mettre à jour uniquement l\u0026rsquo;installation existante (pas de nouvelle installation) Exemple de configuration de module d\u0026rsquo;extension # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false Configuration globale des plugins (plugins.config) Emplacement: $I2P_CONFIG_DIR/plugins.config Objectif: activer/désactiver globalement les plugins installés\nFormat des propriétés plugin.{name}.startOnLoad=true|false {name}: Nom du plugin indiqué dans plugin.config startOnLoad: Indique s\u0026rsquo;il faut démarrer le plugin au démarrage du router Exemple plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false Configuration des applications Web (webapps.config) Emplacement: $I2P_CONFIG_DIR/webapps.config Objectif: Activer/désactiver et configurer des applications web\nFormat des propriétés webapps.{name}.startOnLoad Type: Booléen Description: Indique s\u0026rsquo;il faut démarrer l\u0026rsquo;application web au lancement du router Format: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath Type: Chaîne (chemins séparés par des espaces ou des virgules) Description: Éléments supplémentaires du classpath pour l\u0026rsquo;application web Format: webapps.{name}.classpath=[paths] Substitution de variables Les chemins prennent en charge les substitutions de variables suivantes :\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps #### Résolution du classpath Applications web principales: Chemins relatifs à $I2P/lib Applications web des plugins: Chemins relatifs à $CONFIG/plugins/{appname}/lib Exemple de configuration # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar Configuration du Router (router.config) Emplacement: $I2P_CONFIG_DIR/router.config Interface de configuration: Console du router à /configadvanced Objectif: Paramètres essentiels du router et paramètres réseau\nCatégories de configuration Configuration du réseau Paramètres de bande passante :\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 Configuration des transports:\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true Comportement du router # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 Configuration de la console # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true Configuration de l\u0026rsquo;heure # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org Remarque: La configuration du router est étendue. Consultez la console du router à /configadvanced pour la référence complète des propriétés.\nFichiers de configuration des applications Configuration du carnet d\u0026rsquo;adresses (addressbook/config.txt) Emplacement: $I2P_CONFIG_DIR/addressbook/config.txt Application: SusiDNS Objectif: résolution des noms d\u0026rsquo;hôte et gestion du carnet d\u0026rsquo;adresses\nEmplacements des fichiers router_addressbook Par défaut: ../hosts.txt Description: Carnet d\u0026rsquo;adresses principal (noms d\u0026rsquo;hôte à l\u0026rsquo;échelle du système) Format: Format standard du fichier hosts privatehosts.txt Emplacement: $I2P_CONFIG_DIR/addressbook/privatehosts.txt Description: Correspondances de noms d’hôte privés Priorité: La plus élevée (a priorité sur toutes les autres sources) userhosts.txt Emplacement: $I2P_CONFIG_DIR/addressbook/userhosts.txt Description: Correspondances de noms d’hôte ajoutées par l’utilisateur Gestion: Via l’interface SusiDNS hosts.txt Emplacement: $I2P_CONFIG_DIR/addressbook/hosts.txt Description: Carnet d\u0026rsquo;adresses public téléchargé Source: Flux d\u0026rsquo;abonnement Service de noms BlockfileNamingService (Par défaut depuis 0.8.8) Format de stockage: - Fichier: hostsdb.blockfile - Emplacement: $I2P_CONFIG_DIR/addressbook/ - Performances: résolutions ~10x plus rapides que hosts.txt - Format: format de base de données binaire\nService de noms hérité: - Format: Fichier hosts.txt en texte brut - Statut: Obsolète mais toujours pris en charge - Cas d\u0026rsquo;usage: Édition manuelle, gestion de versions\nRègles concernant les noms d’hôte Les noms d\u0026rsquo;hôte I2P doivent être conformes à :\nExigence relative au TLD: Doit se terminer par .i2p Longueur maximale: 67 caractères au total Jeu de caractères: [a-z], [0-9], . (point), - (tiret) Casse: minuscules uniquement Restrictions de début: Ne peut pas commencer par . ou - Motifs interdits: Ne peut pas contenir .., .- ou -. (depuis 0.6.1.33) Réservé: Noms d’hôte Base32 *.b32.i2p (52 caractères de base32.b32.i2p) Exemples valides example.i2p my-site.i2p test.example.i2p site123.i2p Exemples non valides example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long Gestion des abonnements subscriptions.txt Emplacement: $I2P_CONFIG_DIR/addressbook/subscriptions.txt Format: Une URL par ligne Par défaut: http://i2p-projekt.i2p/hosts.txt Format du flux d’abonnement (depuis la version 0.9.26) Format de flux avancé avec des métadonnées:\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 Propriétés des métadonnées: - added: Date d\u0026rsquo;ajout du nom d\u0026rsquo;hôte (format YYYYMMDD) - src: Identifiant de la source - sig: Signature facultative\nRétrocompatibilité: Le format simple hostname=destination est toujours pris en charge.\nExemple de configuration # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false Configuration d\u0026rsquo;I2PSnark (i2psnark.config.d/i2psnark.config) Emplacement: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config Application: client BitTorrent I2PSnark Interface de configuration: Interface Web à l\u0026rsquo;adresse http://127.0.0.1:7657/i2psnark\nArborescence des répertoires $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... Configuration principale (i2psnark.config) Configuration par défaut minimale:\ni2psnark.dir=i2psnark Propriétés supplémentaires gérées via l\u0026rsquo;interface web:\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 Configuration individuelle du torrent Emplacement: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config Format: Paramètres par torrent Gestion: Automatique (via l\u0026rsquo;interface web)\nLes propriétés comprennent : - Paramètres de téléversement/téléchargement spécifiques au torrent - Priorités des fichiers - Informations du tracker - Limites du nombre de pairs\nRemarque: Les paramètres des torrents sont principalement gérés via l\u0026rsquo;interface web. La modification manuelle n\u0026rsquo;est pas recommandée.\nOrganisation des données du torrent Le stockage des données est distinct de la configuration :\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs Configuration d\u0026rsquo;I2PTunnel (i2ptunnel.config) Emplacement: $I2P_CONFIG_DIR/i2ptunnel.config (hérité) ou $I2P_CONFIG_DIR/i2ptunnel.config.d/ (moderne) Interface de configuration: Console du router à /i2ptunnel Changement de format: Version 0.9.42 (août 2019)\nStructure des répertoires (Version 0.9.42+) À partir de la version 0.9.42, le fichier i2ptunnel.config par défaut est automatiquement scindé :\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) Différence critique de format: - Format monolithique: Propriétés préfixées par tunnel.N. - Format scindé: Propriétés PAS préfixées (p. ex., description=, et non tunnel.0.description=)\nComportement de migration Lors de la première exécution après la mise à jour vers 0.9.42: 1. Le fichier i2ptunnel.config existant est lu 2. Des configurations de tunnel individuelles sont créées dans i2ptunnel.config.d/ 3. Les préfixes sont supprimés des propriétés dans les fichiers séparés 4. Le fichier d\u0026rsquo;origine est sauvegardé 5. L\u0026rsquo;ancien format reste pris en charge pour la rétrocompatibilité\nSections de configuration La configuration d’I2PTunnel est documentée en détail dans la section Référence de configuration d’I2PTunnel ci-dessous. Les descriptions des propriétés s’appliquent aux formats monolithique (tunnel.N.property) et séparé (property).\nRéférence de configuration d\u0026rsquo;I2PTunnel Cette section fournit une référence technique complète pour toutes les propriétés de configuration d’I2PTunnel. Les propriétés sont présentées au format scindé (sans le préfixe tunnel.N.). Pour le format monolithique, préfixez toutes les propriétés avec tunnel.N. où N est le numéro du tunnel.\nImportant: Les propriétés décrites sous la forme tunnel.N.option.i2cp.* sont implémentées dans I2PTunnel (outil I2P de gestion des tunnels) et ne sont PAS prises en charge via d\u0026rsquo;autres interfaces telles que le protocole I2CP ou SAM API.\nPropriétés de base tunnel.N.description (description) Type: Chaîne de caractères Context: Tous les tunnels Description: Description de tunnel lisible par l\u0026rsquo;utilisateur pour l\u0026rsquo;affichage dans l\u0026rsquo;interface utilisateur Example: description=HTTP Proxy for outproxy access tunnel.N.name (nom) Type: Chaîne de caractères Contexte: Tous les tunnels Obligatoire: Oui Description: Identifiant de tunnel unique et nom d\u0026rsquo;affichage Exemple: name=I2P HTTP Proxy tunnel.N.type (type) Type: Énumération Contexte: Tous les tunnels Obligatoire: Oui Valeurs: client - tunnel client générique httpclient - client proxy HTTP ircclient - tunnel client IRC socksirctunnel - proxy SOCKS IRC sockstunnel - proxy SOCKS (version 4, 4a, 5) connectclient - client proxy CONNECT streamrclient - client Streamr server - tunnel serveur générique httpserver - tunnel serveur HTTP ircserver - tunnel serveur IRC httpbidirserver - serveur HTTP bidirectionnel streamrserver - serveur Streamr tunnel.N.interface (interface) Type: Chaîne (adresse IP ou nom d’hôte) Contexte: tunnels client uniquement Par défaut: 127.0.0.1 Description: Interface locale à laquelle se lier pour les connexions entrantes Note de sécurité: Se lier à 0.0.0.0 autorise les connexions distantes Exemple: interface=127.0.0.1 tunnel.N.listenPort (listenPort) Type: Entier Contexte: Tunnels clients uniquement Plage: 1-65535 Description: Port local d\u0026rsquo;écoute pour les connexions client Exemple: listenPort=4444 tunnel.N.targetHost (targetHost) Type: Chaîne (adresse IP ou nom d\u0026rsquo;hôte) Contexte: Tunnels serveur uniquement Description: Serveur local vers lequel rediriger les connexions Exemple: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) Type: Entier Context: Uniquement les tunnels serveur Range: 1-65535 Description: Port sur targetHost auquel se connecter Example: targetPort=80 tunnel.N.targetDestination (targetDestination) Type: Chaîne de caractères (destinations séparées par des virgules ou des espaces) Contexte: Uniquement pour les tunnels clients Format: destination[:port][,destination[:port]] Description: Destinations I2P auxquelles se connecter Exemples: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) Type: Chaîne (adresse IP ou nom d’hôte) Par défaut: 127.0.0.1 Description: Adresse de l’interface I2CP du router I2P Remarque: Ignoré lors de l’exécution dans le contexte du router Exemple: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) Type: Entier Valeur par défaut: 7654 Plage: 1-65535 Description: Port I2CP du router I2P Remarque: Ignoré lors de l\u0026rsquo;exécution dans le contexte du router Exemple: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) Type: Booléen Default: true Description: Indique s\u0026rsquo;il faut démarrer le tunnel au chargement d\u0026rsquo;I2PTunnel Example: startOnLoad=true Configuration du proxy tunnel.N.proxyList (proxyList) Type: Chaîne (noms d’hôte séparés par des virgules ou des espaces) Contexte: Proxies HTTP et SOCKS uniquement Description: Liste des hôtes d’outproxy (mandataire de sortie vers l’Internet classique) Exemple: proxyList=outproxy.example.i2p,backup.example.i2p Configuration du serveur tunnel.N.privKeyFile (privKeyFile) Type: Chaîne (chemin de fichier) Context: Serveurs et tunnels clients persistants Description: Fichier contenant les clés privées d\u0026rsquo;une destination persistante Path: Absolu ou relatif au répertoire de configuration d\u0026rsquo;I2P Example: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) Type: Chaîne (nom d\u0026rsquo;hôte) Contexte: Serveurs HTTP uniquement Par défaut: Nom d\u0026rsquo;hôte Base32 de la destination Description: Valeur de l\u0026rsquo;en-tête Host transmise au serveur local Exemple: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) Type: Chaîne (nom d\u0026rsquo;hôte) Contexte: Serveurs HTTP uniquement Description: Redéfinition de l\u0026rsquo;hôte virtuel pour un port entrant spécifique Cas d\u0026rsquo;utilisation: Héberger plusieurs sites sur des ports différents Exemple: spoofedHost.8080=site1.example.i2p Options spécifiques au client tunnel.N.sharedClient (sharedClient) Type: Booléen Context: Tunnels client uniquement Default: false Description: Indique si plusieurs clients peuvent partager ce tunnel Example: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) Type: booléen Contexte: Uniquement pour les tunnels clients Valeur par défaut: false Description: Stocker et réutiliser les clés de destination entre les redémarrages Conflit: Incompatible avec i2cp.newDestOnResume=true Exemple: option.persistentClientKey=true Options I2CP (implémentation d\u0026rsquo;I2PTunnel) Important: Ces propriétés sont préfixées par option.i2cp. mais sont implémentées dans I2PTunnel, et non dans la couche de protocole I2CP. Elles ne sont pas disponibles via I2CP ou les API SAM.\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) Type: Booléen Context: Uniquement pour les tunnels client Default: false Description: Retarder la création du tunnel jusqu’à la première connexion Use Case: Économiser des ressources pour les tunnels rarement utilisés Example: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) Type: booléen Context: Tunnels client uniquement Default: false Requires: i2cp.closeOnIdle=true Conflict: Mutuellement exclusif avec persistentClientKey=true Description: Créer une nouvelle destination après expiration du délai d\u0026rsquo;inactivité Example: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) Type: Chaîne (clé encodée en base64) Context: Uniquement pour les tunnels serveur Description: Clé de chiffrement privée persistante du leaseSet (ensemble de baux) Use Case: Maintenir un leaseSet chiffré cohérent entre les redémarrages Example: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) Type: Chaîne (sigtype:base64) Context: Tunnels serveur uniquement Format: sigtype:base64key Description: Clé privée persistante de signature du leaseset Example: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... Options spécifiques au serveur tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) Type: Booléen Contexte: Uniquement pour les tunnels serveur Valeur par défaut: false Description: Utiliser une adresse IP locale unique par destination I2P distante Cas d\u0026rsquo;utilisation: Suivre les adresses IP des clients dans les journaux du serveur Note de sécurité: Peut réduire l\u0026rsquo;anonymat Exemple: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) Type: Chaîne (hostname:port) Contexte: Uniquement pour les tunnels serveur Description: Remplace targetHost/targetPort pour le port entrant NNNN Cas d\u0026rsquo;utilisation: Routage basé sur le port vers différents services locaux Exemple: option.targetForPort.8080=localhost:8080 Configuration du pool de threads tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) Type: Booléen Contexte: Tunnels serveur uniquement Par défaut: true Description: Utiliser un pool de threads pour la gestion des connexions Remarque: Toujours false pour les serveurs standard (ignoré) Exemple: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) Type: Entier Contexte: Uniquement pour les tunnels serveur Valeur par défaut: 65 Description: Taille maximale du pool de threads Remarque: Ignoré pour les serveurs standard Exemple: option.i2ptunnel.blockingHandlerCount=100 Options du client HTTP tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) Type: Booléen Contexte: Clients HTTP uniquement Par défaut: false Description: Autoriser les connexions SSL aux adresses .i2p Exemple: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) Type: Booléen Contexte: clients HTTP uniquement Par défaut: false Description: Désactiver les liens address helper (assistant d’adresse) dans les réponses du proxy Exemple: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) Type: Chaîne (URL séparées par des virgules ou des espaces) Contexte: clients HTTP uniquement Description: URL de jump server (service de saut) pour la résolution de noms d\u0026rsquo;hôte Exemple: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) Type: Booléen Contexte: Clients HTTP uniquement Valeur par défaut: false Description: Transmettre les en-têtes Accept-* (sauf Accept et Accept-Encoding) Exemple: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) Type: booléen Context: clients HTTP uniquement Default: false Description: Transmettre les en-têtes Referer via le proxy Privacy Note: Peut divulguer des informations Example: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) Type: Booléen Context: Clients HTTP uniquement Default: false Description: Transmettre les en-têtes User-Agent via le proxy Privacy Note: Peut divulguer des informations sur le navigateur Example: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) Type: booléen Contexte: clients HTTP uniquement Par défaut: false Description: Transmettre les en-têtes Via à travers le proxy Exemple: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) Type: Chaîne (destinations séparées par des virgules ou des espaces) Contexte: clients HTTP uniquement Description: Outproxies (mandataires sortants) SSL internes au réseau pour HTTPS Exemple: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) Type: Booléen Contexte: Clients HTTP uniquement Par défaut: true Description: Utiliser les greffons de proxy de sortie locaux enregistrés Exemple: option.i2ptunnel.useLocalOutproxy=true Authentification du client HTTP tunnel.N.option.proxyAuth (option.proxyAuth) Type: Énumération Contexte: Clients HTTP uniquement Par défaut: false Valeurs: true, false, basic, digest Description: Exiger une authentification locale pour l\u0026rsquo;accès au proxy Remarque: true est équivalent à basic Exemple: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) Type: Chaîne (hexadécimal en minuscules de 32 caractères) Contexte: Clients HTTP uniquement Nécessite: proxyAuth=basic ou proxyAuth=digest Description: Hachage MD5 du mot de passe de l\u0026rsquo;utilisateur USER Obsolescence: Utilisez SHA-256 à la place (0.9.56+) Exemple: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) Type: Chaîne (hexadécimal en minuscules de 64 caractères) Contexte: Clients HTTP uniquement Nécessite: proxyAuth=digest Depuis: Version 0.9.56 Norme: RFC 7616 Description: Hachage SHA-256 du mot de passe de l\u0026rsquo;utilisateur USER Exemple: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 Authentification du proxy de sortie tunnel.N.option.outproxyAuth (option.outproxyAuth) Type: booléen Contexte: clients HTTP uniquement Valeur par défaut: false Description: Envoyer les informations d’authentification à l’outproxy (proxy de sortie) Exemple: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) Type: Chaîne Context: Clients HTTP uniquement Requires: outproxyAuth=true Description: Nom d\u0026rsquo;utilisateur pour l\u0026rsquo;authentification outproxy Example: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) Type: Chaîne de caractères Contexte: clients HTTP uniquement Requiert: outproxyAuth=true Description: Mot de passe pour l’authentification de l’outproxy (proxy sortant I2P) Sécurité: Stocké en clair Exemple: option.outproxyPassword=secret Options du client SOCKS tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) Type: Chaîne (destinations séparées par des virgules ou des espaces) Contexte: Uniquement pour les clients SOCKS Description: Mandataires de sortie au sein du réseau pour les ports non spécifiés Exemple: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) Type: String (destinations séparées par des virgules ou des espaces) Context: Clients SOCKS uniquement Description: Outproxies (proxies de sortie) internes au réseau I2P spécifiquement pour le port NNNN Example: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) Type: Enum Contexte: clients SOCKS uniquement Par défaut: socks Depuis: Version 0.9.57 Valeurs: socks, connect (HTTPS) Description: Type d\u0026rsquo;outproxy (proxy de sortie) configuré Exemple: option.outproxyType=connect Options du serveur HTTP tunnel.N.option.maxPosts (option.maxPosts) Type: Entier Contexte: Serveurs HTTP uniquement Par défaut: 0 (illimité) Description: Nombre maximal de requêtes POST provenant d\u0026rsquo;une Destination (identité I2P) unique par postCheckTime Exemple: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) Type: Entier Context: Serveurs HTTP uniquement Default: 0 (illimité) Description: Nombre maximal de requêtes POST provenant de toutes les destinations par intervalle postCheckTime Example: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) Type: Entier (secondes) Contexte: serveurs HTTP uniquement Par défaut: 300 Description: Fenêtre de temps pour la vérification des limites POST Exemple: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) Type: Entier (secondes) Contexte: Serveurs HTTP uniquement Par défaut: 1800 Description: Durée de bannissement après dépassement de maxPosts pour une destination donnée Exemple: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) Type: Entier (secondes) Contexte: Serveurs HTTP uniquement Valeur par défaut: 600 Description: Durée de bannissement après dépassement de maxTotalPosts Exemple: option.postTotalBanTime=1200 Options de sécurité du serveur HTTP tunnel.N.option.rejectInproxy (option.rejectInproxy) Type: Booléen Contexte: Serveurs HTTP uniquement Par défaut: false Description: Refuser les connexions qui semblent passer par un inproxy (proxy entrant) Exemple: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) Type: Booléen Contexte: Serveurs HTTP uniquement Par défaut: false Depuis: Version 0.9.25 Description: Refuser les connexions avec un en-tête Referer Exemple: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) Type: Booléen Contexte: Serveurs HTTP uniquement Valeur par défaut: false Depuis: Version 0.9.25 Nécessite: la propriété userAgentRejectList Description: Rejette les connexions avec un User-Agent correspondant Exemple: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) Type: Chaîne (chaînes de correspondance séparées par des virgules) Contexte: Serveurs HTTP uniquement Depuis: Version 0.9.25 Casse: Correspondance sensible à la casse Spécial: \u0026ldquo;none\u0026rdquo; (depuis 0.9.33) correspond à un User-Agent vide Description: Liste des motifs User-Agent à rejeter Exemple: option.userAgentRejectList=Mozilla,Opera,none Options du serveur IRC tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) Type: Chaîne (modèle de nom d’hôte) Contexte: Serveurs IRC uniquement Valeur par défaut: %f.b32.i2p Jetons: %f = Hachage de destination base32 complet %c = Hachage de destination masqué (voir cloakKey) Description: Format de nom d’hôte envoyé au serveur IRC Exemple: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) Type: Chaîne (phrase de passe) Contexte: Serveurs IRC uniquement Par défaut: Aléatoire par session Restrictions: Pas de guillemets ni d’espaces Description: Phrase de passe pour un masquage de nom d’hôte cohérent Cas d’utilisation: Suivi persistant de l’utilisateur entre redémarrages/serveurs Exemple: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) Type: Énumération Contexte: Serveurs IRC uniquement Valeur par défaut: user Valeurs: user, webirc Description: Méthode d\u0026rsquo;authentification pour le serveur IRC Exemple: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) Type: Chaîne (mot de passe) Context: Serveurs IRC uniquement Requires: method=webirc Restrictions: Pas de guillemets ni d\u0026rsquo;espaces Description: Mot de passe pour l\u0026rsquo;authentification du protocole WEBIRC Example: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) Type: Chaîne (adresse IP) Contexte: Serveurs IRC uniquement Requiert: method=webirc Description: Adresse IP usurpée pour le protocole WEBIRC Exemple: option.ircserver.webircSpoofIP=10.0.0.1 Configuration SSL/TLS tunnel.N.option.useSSL (option.useSSL) Type: booléen Valeur par défaut: false Contexte: Tous les tunnels Comportement: Serveurs: Utiliser SSL pour les connexions au serveur local Clients: Exiger SSL de la part des clients locaux Exemple: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) Type: Chaîne de caractères (chemin de fichier) Contexte: Tunnels clients uniquement Par défaut: i2ptunnel-(random).ks Chemin: Relatif à $(I2P_CONFIG_DIR)/keystore/ s\u0026rsquo;il n\u0026rsquo;est pas absolu Généré automatiquement: Créé s\u0026rsquo;il n\u0026rsquo;existe pas Description: Fichier keystore (magasin de clés) contenant la clé privée SSL Exemple: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) Type: Chaîne (mot de passe) Context: Client tunnels uniquement Default: changeit Auto-generated: Mot de passe aléatoire si un nouveau magasin de clés est créé Description: Mot de passe du magasin de clés SSL Example: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) Type: Chaîne de caractères (alias) Contexte: Tunnels client uniquement Généré automatiquement: Créé si une nouvelle clé est générée Description: Alias de la clé privée dans le keystore (magasin de clés) Exemple: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) Type: Chaîne (mot de passe) Contexte: Uniquement pour les tunnels client Généré automatiquement: Mot de passe aléatoire si une nouvelle clé est créée Description: Mot de passe pour la clé privée dans le keystore (magasin de clés) Exemple: option.keyPassword=keypass123 Options génériques pour I2CP et le Streaming Toutes les propriétés tunnel.N.option.* (non spécifiquement documentées ci-dessus) sont transmises à l\u0026rsquo;interface I2CP et à la bibliothèque de streaming, avec le préfixe tunnel.N.option. supprimé.\nImportant: Ces options sont distinctes de celles spécifiques à I2PTunnel. Voir : - Spécification I2CP - Spécification de la bibliothèque de streaming Exemples d’options de streaming :\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 Exemple complet de Tunnel # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 Historique des versions et chronologie des fonctionnalités Version 0.9.10 (2013) Fonctionnalité: Prise en charge des valeurs vides dans les fichiers de configuration - Les clés avec des valeurs vides (key=) sont désormais prises en charge - Auparavant ignorées ou provoquaient des erreurs d\u0026rsquo;analyse\nVersion 0.9.18 (2015) Fonctionnalité: Configuration de l’intervalle de vidage du journaliseur - Propriété: logger.flushInterval (29 secondes par défaut) - Réduit les E/S disque tout en maintenant une latence de journalisation acceptable\nVersion 0.9.23 (novembre 2015) Changement majeur : Java 7 requis au minimum - La prise en charge de Java 6 est terminée - Requis pour continuer à recevoir les mises à jour de sécurité\nVersion 0.9.25 (2015) Fonctionnalités: options de sécurité du serveur HTTP - tunnel.N.option.rejectReferer - Rejeter les connexions avec l\u0026rsquo;en-tête Referer - tunnel.N.option.rejectUserAgents - Rejeter des en-têtes User-Agent spécifiques - tunnel.N.option.userAgentRejectList - Modèles de User-Agent à rejeter - Cas d\u0026rsquo;utilisation: Limiter les robots d\u0026rsquo;exploration et les clients indésirables\nVersion 0.9.33 (janvier 2018) Fonctionnalité: Filtrage amélioré de l’User-Agent - la chaîne userAgentRejectList \u0026ldquo;none\u0026rdquo; correspond à un User-Agent vide - Corrections de bogues supplémentaires pour i2psnark, i2ptunnel, streaming, SusiMail\nVersion 0.9.41 (2019) Dépréciation: Protocole BOB supprimé d\u0026rsquo;Android - les utilisateurs Android doivent migrer vers SAM ou I2CP\nVersion 0.9.42 (août 2019) Changement majeur: Scission des fichiers de configuration - clients.config scindé en une structure de répertoires clients.config.d/ - i2ptunnel.config scindé en une structure de répertoires i2ptunnel.config.d/ - Migration automatique lors de la première exécution après mise à niveau - Permet l\u0026rsquo;empaquetage modulaire et la gestion des plugins - L\u0026rsquo;ancien format monolithique reste pris en charge\nFonctionnalités supplémentaires: - Améliorations des performances de SSU - Prévention inter-réseau (Proposition 147) - Prise en charge initiale des types de chiffrement\nVersion 0.9.56 (2021) Fonctionnalités : Améliorations de la sécurité et de la journalisation - logger.gzip - Compression Gzip pour les journaux en rotation (valeur par défaut : false) - logger.minGzipSize - Taille minimale pour la compression (valeur par défaut : 65536 octets) - tunnel.N.option.proxy.auth.USER.sha256 - Authentification Digest SHA-256 (RFC 7616) - Sécurité : SHA-256 remplace MD5 pour l\u0026rsquo;authentification Digest\nVersion 0.9.57 (janvier 2023) Fonctionnalité: configuration du type d’outproxy (proxy de sortie) SOCKS - tunnel.N.option.outproxyType - Sélection du type d’outproxy (socks|connect) - Valeur par défaut: socks - Prise en charge de HTTPS CONNECT pour les outproxies HTTPS\nVersion 2.6.0 (juillet 2024) Changement incompatible : I2P via Tor bloqué - Connexions provenant des adresses IP des relais de sortie Tor désormais rejetées - Raison : Dégrade les performances d\u0026rsquo;I2P, gaspille les ressources des relais de sortie Tor - Impact : Les utilisateurs accédant à I2P via des relais de sortie Tor seront bloqués - Les relais non-sortie et les clients Tor ne sont pas concernés\nVersion 2.10.0 (septembre 2025 - à ce jour) Fonctionnalités majeures: - Cryptographie post-quantique disponible (activation facultative via Hidden Service Manager (gestionnaire de service caché)) - Prise en charge du tracker UDP pour I2PSnark afin de réduire la charge du tracker - Stabilité du Hidden Mode (mode caché) améliorations pour réduire l’épuisement de RouterInfo - Améliorations du réseau pour les routers congestionnés - Traversée UPnP/NAT améliorée - Améliorations de NetDB avec suppression agressive des leaseset - Réductions de l’observabilité des événements du router\nConfiguration: Aucune nouvelle propriété de configuration ajoutée\nChangement critique à venir: La prochaine version (probablement 2.11.0 ou 3.0.0) nécessitera Java 17 ou une version ultérieure\nDépréciations et changements rétro-incompatibles Dépréciations critiques Accès I2P-over-Tor (Version 2.6.0+) Statut: BLOQUÉ depuis juillet 2024 Impact: Connexions depuis les adresses IP des nœuds de sortie Tor rejetées Raison: Dégrade les performances du réseau I2P sans offrir d\u0026rsquo;avantages en matière d\u0026rsquo;anonymat Affecte: Uniquement les nœuds de sortie Tor, pas les relais ni les clients Tor classiques Alternative: Utiliser I2P ou Tor séparément, sans les combiner Authentification Digest MD5 Statut: Obsolète (utilisez SHA-256) Propriété: tunnel.N.option.proxy.auth.USER.md5 Raison: MD5 est cassé sur le plan cryptographique Remplacement: tunnel.N.option.proxy.auth.USER.sha256 (depuis 0.9.56) Chronologie: MD5 toujours pris en charge mais déconseillé Modifications de l\u0026rsquo;architecture de configuration Fichiers de configuration monolithiques (Version 0.9.42+) Concernés: clients.config, i2ptunnel.config Statut: Déprécié au profit d’une structure de répertoires scindée Migration: Automatique lors de la première exécution après la mise à niveau vers la version 0.9.42 Compatibilité: L’ancien format fonctionne toujours (rétrocompatible) Recommandation: Utiliser le format scindé pour les nouvelles configurations Versions de Java requises Prise en charge de Java 6 Fin: Version 0.9.23 (novembre 2015) Minimum: Java 7 requis depuis la version 0.9.23 Exigence Java 17 (à venir) Statut: CHANGEMENT CRITIQUE À VENIR Cible: Prochaine version majeure après 2.10.0 (probablement 2.11.0 ou 3.0.0) Minimum actuel: Java 8 Action requise: Préparer la migration vers Java 17 Calendrier: Sera annoncé avec les notes de version Fonctionnalités supprimées Protocole BOB (Android) Retiré: Version 0.9.41 Plateforme: Android uniquement Alternative: protocoles SAM ou I2CP Bureau: BOB (API simple pour clients I2P) toujours disponible sur les plateformes de bureau Migrations recommandées Authentification: Migrer de MD5 à SHA-256 pour l\u0026rsquo;authentification Digest (authentification par condensat) Format de configuration: Migrer vers une structure de répertoires séparée pour les clients et les tunnels Environnement d\u0026rsquo;exécution Java: Planifier la mise à niveau vers Java 17 avant la prochaine version majeure Intégration à Tor: Ne pas acheminer I2P via les nœuds de sortie Tor Références Documentation officielle Spécification de configuration I2P - Spécification officielle du format de fichier de configuration Spécification des plugins I2P - Configuration et empaquetage des plugins Structures communes I2P - Correspondance des types - Format de sérialisation des données du protocole Format Java Properties - Spécification du format de base Code source Dépôt du I2P Java Router - Miroir GitHub Gitea des développeurs I2P - Dépôt officiel du code source d’I2P DataHelper.java - Implémentation de l’E/S des fichiers de configuration Ressources de la communauté Forum I2P - Discussions communautaires actives et assistance Site web I2P - Site web officiel du projet Documentation de l\u0026rsquo;API DataHelper JavaDoc - Documentation de l\u0026rsquo;API pour les méthodes liées aux fichiers de configuration Statut de la spécification Dernière mise à jour de la spécification: janvier 2023 (version 0.9.57) Version I2P actuelle: 2.10.0 (septembre 2025) Précision technique: La spécification reste exacte jusqu’à la version 2.10.0 (aucune rupture de compatibilité) Maintenance: Document évolutif mis à jour lorsque le format de configuration est modifié ","description":"Options et formats de configuration pour les I2P routers et les clients I2P","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"Configuration du Router","url":"/fr/docs/specs/configuration/"},{"categories":null,"content":" 1. Vue d\u0026rsquo;ensemble Un transport dans I2P est une méthode de communication directe, point à point, entre routers. Ces mécanismes assurent la confidentialité et l\u0026rsquo;intégrité tout en vérifiant l\u0026rsquo;authentification des routers.\nChaque transport fonctionne selon des modèles de connexion intégrant l’authentification, le contrôle de flux, des accusés de réception et des fonctionnalités de retransmission.\n2. Transports actuels I2P prend actuellement en charge deux transports principaux :\nTransport Protocol Description NTCP2 TCP Noise-based TCP transport with modern encryption (as of 0.9.36) SSU2 UDP Secure Semireliable UDP with modern encryption (as of 0.9.56) ### 2.1 Transports hérités (dépréciés) Transport Protocol Status NTCP TCP Replaced by NTCP2; removed in 0.9.62 SSU UDP Replaced by SSU2; removed in 0.9.62 --- 3. Services de transport Le sous-système de transport fournit les services suivants :\n3.1 Acheminement des messages Acheminement fiable des messages I2NP (les transports gèrent exclusivement la messagerie I2NP) La livraison dans l\u0026rsquo;ordre n\u0026rsquo;est PAS garantie universellement Mise en file d\u0026rsquo;attente des messages basée sur les priorités 3.2 Gestion des connexions Établissement et fermeture des connexions Gestion des limites de connexion avec application des seuils Suivi de l’état pour chaque pair Application automatique et manuelle de la liste de bannissement des pairs 3.3 Configuration du réseau Plusieurs adresses de router par transport (prise en charge IPv4 et IPv6 depuis la v0.9.8) Ouverture des ports du pare-feu via UPnP Prise en charge de la traversée NAT/pare-feu Détection de l’adresse IP locale via plusieurs méthodes 3.4 Sécurité Chiffrement des échanges point à point Validation des adresses IP selon les règles locales Détermination du consensus horaire (repli NTP) 3.5 Gestion de la bande passante Limites de bande passante entrante et sortante Sélection optimale du transport pour les messages sortants 4. Adresses de transport Le sous-système tient à jour la liste des points de contact du router:\nMéthode de transport (NTCP2, SSU2) Adresse IP Numéro de port Paramètres optionnels Plusieurs adresses par méthode de transport sont possibles.\n4.1 Configurations d\u0026rsquo;adresses courantes Configuration Description Hidden Routers with no published addresses Firewalled Routers publishing SSU2 addresses with \"introducer\" peer lists for NAT traversal Unrestricted Routers advertising both NTCP2 and SSU2 addresses on IPv4 and/or IPv6 --- 5. Sélection du transport Le système sélectionne les transports pour les messages I2NP indépendamment des protocoles de couche supérieure. La sélection utilise un système d’enchères dans lequel chaque transport soumet des offres, la valeur la plus basse l’emportant.\n5.1 Facteurs de détermination des offres Paramètres des préférences de transport Connexions aux pairs existantes Nombres de connexions actuels par rapport aux seuils Historique récent des tentatives de connexion Contraintes de taille des messages Capacités de transport du RouterInfo du pair Directivité de la connexion (directe versus dépendante d’un introducer (nœud d’introduction)) Préférences de transport annoncées par le pair En général, deux routers maintiennent simultanément des connexions à transport unique, bien que des connexions multi-transport simultanées soient possibles.\n6. NTCP2 NTCP2 (New Transport Protocol 2) est le protocole de transport moderne basé sur TCP pour I2P, introduit dans la version 0.9.36.\n6.1 Fonctionnalités clés Basé sur le Noise Protocol Framework (modèle Noise_XK) Utilise X25519 pour l’échange de clés Utilise ChaCha20/Poly1305 pour le chiffrement authentifié Utilise BLAKE2s pour le hachage Obfuscation du protocole pour résister à l’inspection approfondie des paquets (DPI) Remplissage optionnel pour résister à l’analyse du trafic 6.2 Établissement de la connexion Requête de session (Alice → Bob): Clé X25519 éphémère + charge utile chiffrée Session créée (Bob → Alice): Clé éphémère + confirmation chiffrée Session confirmée (Alice → Bob): Poignée de main finale avec RouterInfo (informations du router) Toutes les données suivantes sont chiffrées avec des clés de session dérivées du handshake (phase d\u0026rsquo;initialisation).\nVoir la spécification NTCP2 pour tous les détails.\n7. SSU2 SSU2 (Secure Semireliable UDP 2, protocole UDP semi-fiable sécurisé) est le transport moderne basé sur UDP pour I2P, introduit dans la version 0.9.56.\n7.1 Fonctionnalités clés Basé sur le Noise Protocol Framework (modèle Noise_XK) Utilise X25519 pour l\u0026rsquo;échange de clés Utilise ChaCha20/Poly1305 pour le chiffrement authentifié Remise semi-fiable avec accusés de réception sélectifs Traversée de NAT via hole punching (perforation de NAT) et relais/introduction Prise en charge de la migration de connexion Découverte du MTU de chemin 7.2 Avantages par rapport à SSU (ancien) Feature SSU (Legacy) SSU2 Encryption ElGamal + AES X25519 + ChaCha20/Poly1305 Header encryption Partial Full (ChaCha20) Connection ID Fixed Encrypted, rotatable NAT traversal Basic introduction Enhanced hole punching + relay Obfuscation Minimal Improved (variable padding) Consultez la [spécification SSU2](/docs/specs/ssu2/) (protocole de transport UDP de seconde génération d'I2P) pour tous les détails. 8. Traversée de NAT Les deux transports prennent en charge la traversée du NAT afin de permettre aux routers derrière un pare-feu de participer au réseau.\n8.1 Introduction à SSU2 Lorsqu’un router ne peut pas accepter des connexions entrantes directement :\nLe router publie les adresses d\u0026rsquo;introducer (nœud introducteur) dans son RouterInfo Le pair qui se connecte envoie une requête d\u0026rsquo;introduction à l\u0026rsquo;introducer L\u0026rsquo;introducer relaie les informations de connexion au router derrière un pare-feu Le router derrière un pare-feu initie une connexion sortante (hole punch, traversée de NAT) Communication directe établie 8.2 NTCP2 et pare-feu NTCP2 nécessite une connectivité TCP entrante. Les routers derrière un NAT peuvent :\nUtiliser l\u0026rsquo;UPnP pour ouvrir automatiquement les ports Configurer manuellement la redirection de ports S\u0026rsquo;appuyer sur SSU2 pour les connexions entrantes tout en utilisant NTCP2 pour les connexions sortantes 9. Obfuscation du protocole Les deux transports modernes intègrent des fonctionnalités d’obfuscation :\nBourrage aléatoire dans les messages d\u0026rsquo;initialisation En-têtes chiffrés qui ne révèlent pas les signatures du protocole Messages de longueur variable pour résister à l\u0026rsquo;analyse du trafic Aucun schéma fixe lors de l\u0026rsquo;établissement de la connexion Remarque: L\u0026rsquo;obfuscation de la couche de transport complète mais ne remplace pas l\u0026rsquo;anonymat fourni par l\u0026rsquo;architecture de tunnel d\u0026rsquo;I2P.\n10. Développements futurs Les recherches et améliorations prévues comprennent:\nTransports enfichables – plugins d\u0026rsquo;obfuscation compatibles avec Tor Transport basé sur QUIC – étude des avantages du protocole QUIC Optimisation des limites de connexion – recherche sur les limites optimales des connexions aux pairs Stratégies de padding améliorées – résistance accrue à l\u0026rsquo;analyse de trafic 11. Références Spécification NTCP2 – Transport TCP basé sur Noise Spécification SSU2 – UDP semi-fiable sécurisé 2 Spécification I2NP – Messages du protocole réseau I2P Structures communes – RouterInfo et structures d’adresses Discussion historique sur NTCP – Historique du développement du transport hérité Documentation SSU héritée – Spécification SSU originale (obsolète) ","description":"Comprendre la couche de transport d'I2P - méthodes de communication point à point entre routers, y compris NTCP2 et SSU2","id":"5fbac972dc212081634c49c5e6ac0004","section":"docs","title":"Couche de transport","url":"/fr/docs/overview/transport/"},{"categories":null,"content":"Qu\u0026rsquo;est-ce qu\u0026rsquo;un Eepsite ? Un eepsite est un site web qui réside exclusivement sur le réseau I2P. Contrairement aux sites web traditionnels accessibles via le clearnet (Internet public classique), les eepsites ne sont accessibles que via I2P, garantissant l’anonymat et la confidentialité tant pour l’opérateur du site que pour les visiteurs. Les eepsites utilisent le pseudo-domaine de premier niveau .i2p et sont accessibles via des adresses spéciales .b32.i2p ou des noms lisibles par des humains enregistrés dans le carnet d’adresses I2P.\nToutes les installations Java d’I2P sont fournies avec Jetty , un serveur Web léger basé sur Java, préinstallé et préconfiguré. Cela permet de commencer à héberger votre propre eepsite (site web I2P) en quelques minutes - aucune installation logicielle supplémentaire n’est requise.\nCe guide vous expliquera pas à pas comment créer et configurer votre premier eepsite à l\u0026rsquo;aide des outils intégrés d\u0026rsquo;I2P.\nÉtape 1 : Accéder au Gestionnaire des services cachés Le Gestionnaire des services cachés (également appelé I2P Tunnel Manager) est l\u0026rsquo;endroit où vous configurez tous les tunnels serveur et client I2P, y compris les serveurs HTTP (eepsites).\nOuvrez votre Console du router I2P Accédez au Gestionnaire des services cachés Vous devriez voir l’interface du Gestionnaire des services cachés affichant : - Messages d’état - État actuel du tunnel et du client - Contrôle global des tunnels - Boutons pour gérer tous les tunnels en même temps - Services cachés I2P - Liste des tunnels serveur configurés\nPar défaut, vous verrez une entrée serveur web I2P existante, configurée mais non démarrée. Il s’agit du serveur web Jetty préconfiguré, prêt à l’emploi.\nÉtape 2: Configurez les paramètres de votre serveur Eepsite Cliquez sur l’entrée I2P webserver dans la liste des services cachés pour ouvrir la page de configuration du serveur. C’est ici que vous personnaliserez les paramètres de votre eepsite.\nOptions de configuration expliquées Nom - Il s’agit d’un identifiant interne pour votre tunnel - Utile si vous exécutez plusieurs eepsites afin de savoir lequel est lequel - Par défaut : \u0026ldquo;I2P webserver\u0026rdquo;\nDescription - Une brève description de votre eepsite (site web sur I2P) pour votre propre référence - Visible uniquement pour vous dans le Gestionnaire des services cachés - Exemple : \u0026ldquo;Mon eepsite\u0026rdquo; ou \u0026ldquo;Blog personnel\u0026rdquo;\nDémarrage automatique du Tunnel - Important: Cochez cette case pour démarrer automatiquement votre eepsite lorsque votre router I2P démarre - Garantit que votre site reste disponible sans intervention manuelle après les redémarrages du router - Recommandé: Activé\nCible (Hôte et port) - Hôte : L’adresse locale où votre serveur web s’exécute (par défaut : 127.0.0.1) - Port : Le port sur lequel votre serveur web écoute (par défaut : 7658 pour Jetty) - Si vous utilisez le serveur web Jetty préinstallé, laissez ces valeurs par défaut - Ne modifiez ces paramètres que si vous exécutez un serveur web personnalisé sur un port différent\nNom d’hôte du site Web - Il s’agit du nom de domaine .i2p de votre eepsite, lisible par un humain - Valeur par défaut : mysite.i2p (texte indicatif) - Vous pouvez enregistrer un domaine personnalisé comme stormycloud.i2p ou myblog.i2p - Laissez vide si vous souhaitez uniquement utiliser l’adresse .b32.i2p générée automatiquement (pour les outproxies, mandataires sortants) - Voir Enregistrer votre domaine I2P ci‑dessous pour savoir comment obtenir un nom d’hôte personnalisé\nDestination locale - Il s\u0026rsquo;agit de l\u0026rsquo;identifiant cryptographique unique de votre eepsite (adresse de destination) - Généré automatiquement lors de la création initiale du tunnel - Considérez-le comme l\u0026rsquo;\u0026ldquo;adresse IP\u0026rdquo; permanente de votre site sur I2P - La longue chaîne alphanumérique est l\u0026rsquo;adresse .b32.i2p de votre site sous forme encodée\nFichier de clé privée - Emplacement où sont stockées les clés privées de votre eepsite (site web hébergé sur I2P) - Par défaut : eepsite/eepPriv.dat - Conservez ce fichier en lieu sûr - toute personne ayant accès à ce fichier peut se faire passer pour votre eepsite - Ne partagez ni ne supprimez jamais ce fichier\nRemarque importante L\u0026rsquo;encadré d\u0026rsquo;avertissement jaune vous rappelle que, pour activer les fonctionnalités de génération de codes QR ou d\u0026rsquo;authentification à l\u0026rsquo;inscription, vous devez configurer un nom d\u0026rsquo;hôte de site Web avec le suffixe .i2p (par exemple, mynewsite.i2p).\nÉtape 3 : Options réseau avancées (facultatif) Si vous faites défiler vers le bas la page de configuration, vous trouverez des options réseau avancées. Ces paramètres sont facultatifs - les valeurs par défaut conviennent à la plupart des utilisateurs. Cependant, vous pouvez les ajuster en fonction de vos exigences en matière de sécurité et de vos besoins en performances.\nOptions de longueur des tunnels Longueur du tunnel - Par défaut : tunnel à 3 sauts (anonymat élevé) - Contrôle le nombre de sauts de router qu’une requête effectue avant d’atteindre votre eepsite - Plus de sauts = Anonymat plus élevé, mais des performances plus lentes - Moins de sauts = Performances plus rapides, mais anonymat réduit - Les options vont de 0-3 sauts avec des paramètres de variance - Recommandation : Conserver 3 sauts sauf si vous avez des exigences de performances spécifiques\nVariance de tunnel - Par défaut: variance de 0 saut (pas de randomisation, performances constantes) - Ajoute une randomisation à la longueur des tunnels pour une sécurité accrue - Exemple: \u0026ldquo;variance de 0-1 saut\u0026rdquo; signifie que les tunnels feront aléatoirement 3 ou 4 sauts - Augmente l\u0026rsquo;imprévisibilité mais peut entraîner des temps de chargement variables\nOptions relatives au nombre de tunnels Nombre (Tunnels entrants/sortants) - Par défaut: 2 tunnels entrants, 2 tunnels sortants (bande passante et fiabilité standard) - Contrôle le nombre de tunnels parallèles dédiés à votre eepsite - Plus de tunnels = Meilleure disponibilité et gestion de la charge, mais utilisation des ressources plus élevée - Moins de tunnels = Utilisation des ressources plus faible, mais redondance réduite - Recommandé pour la plupart des utilisateurs: 2/2 (par défaut) - Les sites à fort trafic peuvent bénéficier de 3/3 ou plus\nNombre de tunnels de secours - Par défaut: 0 tunnels de secours (aucune redondance, aucune consommation de ressources supplémentaire) - Tunnels de secours en attente qui s\u0026rsquo;activent si les tunnels principaux défaillent - Augmente la fiabilité mais consomme davantage de bande passante et de CPU - La plupart des eepsites personnels n\u0026rsquo;ont pas besoin de tunnels de secours\nLimites des requêtes POST Si votre eepsite comprend des formulaires (formulaires de contact, sections de commentaires, téléversements de fichiers, etc.), vous pouvez configurer des limites pour les requêtes POST afin de prévenir les abus :\nLimites par client - Par période: Nombre maximal de requêtes provenant d’un seul client (par défaut: 6 toutes les 5 minutes) - Durée de bannissement: Durée de blocage des clients abusifs (par défaut: 20 minutes)\nLimites totales - Total: Nombre maximal de requêtes POST provenant de tous les clients réunis (par défaut : 20 toutes les 5 minutes) - Durée du bannissement: Durée pendant laquelle rejeter toutes les requêtes POST en cas de dépassement de la limite (par défaut : 10 minutes)\nPériode de limitation des requêtes POST (méthode HTTP) - Fenêtre temporelle pour mesurer la fréquence des requêtes (par défaut : 5 minutes)\nCes limites contribuent à protéger contre le spam, les attaques par déni de service et les abus liés à la soumission automatisée de formulaires.\nQuand ajuster les paramètres avancés Site communautaire à fort trafic: Augmenter le nombre de tunnels (3-4 entrants/sortants) Application critique en termes de performances: Réduire la longueur des tunnels à 2 sauts (compromis de confidentialité) Anonymat maximal requis: Conserver 3 sauts, ajouter 0-1 de variation Formulaires avec une utilisation légitime élevée: Augmenter en conséquence les limites de POST Blog/portfolio personnel: Utiliser tous les paramètres par défaut Étape 4 : Ajout de contenu à votre Eepsite Maintenant que votre eepsite est configuré, vous devez ajouter les fichiers de votre site web (HTML, CSS, images, etc.) dans le répertoire racine du serveur web. L’emplacement varie selon votre système d’exploitation, le type d’installation et l’implémentation I2P.\nTrouver le répertoire racine de votre site Le répertoire racine du site (souvent appelé docroot) est le répertoire où vous placez tous les fichiers de votre site web. Votre fichier index.html doit être placé directement dans ce répertoire.\nJava I2P (distribution standard) Linux - Installation standard: ~/.i2p/eepsite/docroot/ - Installation via paquet (exécutée en tant que service): /var/lib/i2p/i2p-config/eepsite/docroot/\nWindows - Installation standard: %LOCALAPPDATA%\\I2P\\eepsite\\docroot\\ - Chemin typique: C:\\Users\\YourUsername\\AppData\\Local\\I2P\\eepsite\\docroot\\ - Installation en tant que service Windows: %PROGRAMDATA%\\I2P\\eepsite\\docroot\\ - Chemin typique: C:\\ProgramData\\I2P\\eepsite\\docroot\\\nmacOS - Installation par défaut: /Users/YourUsername/Library/Application Support/i2p/eepsite/docroot/\nI2P+ (Distribution I2P améliorée) I2P+ utilise la même structure de répertoires que Java I2P. Suivez les chemins ci-dessus en fonction de votre système d’exploitation.\ni2pd (Implémentation C++) Linux/Unix - Par défaut: /var/lib/i2pd/eepsite/ ou ~/.i2pd/eepsite/ - Vérifiez votre fichier de configuration i2pd.conf pour connaître la valeur effective de root dans la section de votre tunnel de serveur HTTP\nWindows - Vérifiez i2pd.conf dans votre répertoire d\u0026rsquo;installation d\u0026rsquo;i2pd\nmacOS - Généralement : ~/Library/Application Support/i2pd/eepsite/\nAjout des fichiers de votre site web Accédez à la racine de votre site à l\u0026rsquo;aide de votre gestionnaire de fichiers ou du terminal Créez ou copiez les fichiers de votre site web dans le dossier docroot Au minimum, créez un fichier index.html (c\u0026rsquo;est votre page d\u0026rsquo;accueil) Ajoutez au besoin des fichiers CSS, JavaScript, des images et d\u0026rsquo;autres ressources Organisez les sous-répertoires comme vous le feriez pour n\u0026rsquo;importe quel site web : docroot/ ├── index.html ├── about.html ├── css/ │ └── style.css ├── images/ │ └── logo.png └── js/ └── script.js Démarrage rapide : exemple HTML simple Si vous commencez tout juste, créez un fichier index.html simple dans votre dossier docroot :\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My I2P Eepsite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Eepsite!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first website on the I2P network.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Privacy-focused and decentralized!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Autorisations (Linux/Unix/macOS) Si vous exécutez I2P en tant que service ou sous un autre utilisateur, assurez-vous que le processus I2P dispose d’un accès en lecture à vos fichiers :\n# Set appropriate ownership (if running as i2p user) sudo chown -R i2p:i2p /var/lib/i2p/i2p-config/eepsite/docroot/ # Or set readable permissions for all users chmod -R 755 ~/.i2p/eepsite/docroot/ Conseils Contenu par défaut: Lorsque vous installez I2P pour la première fois, du contenu d\u0026rsquo;exemple est déjà présent dans le dossier docroot - n\u0026rsquo;hésitez pas à le remplacer Les sites statiques fonctionnent le mieux: Bien que Jetty prenne en charge les servlets et JSP, les sites simples en HTML/CSS/JavaScript sont les plus faciles à maintenir Serveurs web externes: Les utilisateurs avancés peuvent exécuter des serveurs web personnalisés (Apache, Nginx, Node.js, etc.) sur différents ports et faire pointer le tunnel I2P vers eux Étape 5: Démarrer votre Eepsite Maintenant que votre eepsite est configuré et comporte du contenu, il est temps de le démarrer et de le rendre accessible sur le réseau I2P.\nDémarrer le Tunnel Retournez au Gestionnaire des services cachés Trouvez l’entrée de votre serveur web I2P dans la liste Cliquez sur le bouton Démarrer dans la colonne Contrôle Attendre l’établissement du tunnel Après avoir cliqué sur Démarrer, le tunnel de votre eepsite commencera à se mettre en place. Ce processus prend généralement 30 à 60 secondes. Surveillez l\u0026rsquo;indicateur d\u0026rsquo;état:\nVoyant rouge = Tunnel en cours de démarrage/construction Voyant jaune = Tunnel partiellement établi Voyant vert = Tunnel pleinement opérationnel et prêt Dès que vous voyez le voyant vert, votre eepsite est en ligne sur le réseau I2P !\nAccédez à votre Eepsite Cliquez sur le bouton Preview à côté de votre eepsite en cours d’exécution (site web sur I2P). Cela ouvrira un nouvel onglet du navigateur avec l’adresse de votre eepsite.\nVotre eepsite a deux types d\u0026rsquo;adresses :\nAdresse Base32 (.b32.i2p): Une longue adresse cryptographique qui ressemble à :\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p Il s’agit de l’adresse permanente de votre eepsite, dérivée cryptographiquement Elle ne peut pas être modifiée et est liée à votre clé privée Fonctionne toujours, même sans enregistrement de domaine Domaine lisible par l\u0026rsquo;humain (.i2p): Si vous définissez un nom d\u0026rsquo;hôte de site web (p. ex., testwebsite.i2p)\nNe fonctionne qu\u0026rsquo;après l\u0026rsquo;enregistrement du domaine (voir la section suivante) Plus facile à mémoriser et à partager Pointe vers votre adresse .b32.i2p Le bouton Copier le nom d’hôte vous permet de copier rapidement votre adresse .b32.i2p complète pour la partager.\n⚠️ Critique : sauvegardez votre clé privée Avant d\u0026rsquo;aller plus loin, vous devez impérativement sauvegarder le fichier de clé privée de votre eepsite. C\u0026rsquo;est d\u0026rsquo;une importance cruciale pour plusieurs raisons :\nPourquoi sauvegarder votre clé ? Votre clé privée (eepPriv.dat) est l\u0026rsquo;identité de votre eepsite. Elle détermine votre adresse .b32.i2p et prouve que vous êtes le propriétaire de votre eepsite.\nClé = adresse .b32: Votre clé privée génère mathématiquement votre adresse .b32.i2p unique Ne peut pas être récupérée: Si vous perdez votre clé, vous perdez définitivement l\u0026rsquo;adresse de votre eepsite Ne peut pas être modifiée: Si vous avez enregistré un domaine pointant vers une adresse .b32, il n\u0026rsquo;y a aucun moyen de la mettre à jour - l\u0026rsquo;enregistrement est permanent Requise pour la migration: Passer à un nouvel ordinateur ou réinstaller I2P nécessite cette clé pour conserver la même adresse Prise en charge du multihoming (hébergement multi-emplacements): Héberger votre eepsite depuis plusieurs emplacements nécessite la même clé sur chaque serveur Où se trouve la clé privée ? Par défaut, votre clé privée est stockée à l’emplacement suivant : - Linux: ~/.i2p/eepsite/eepPriv.dat (ou /var/lib/i2p/i2p-config/eepsite/eepPriv.dat pour les installations en tant que service) - Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat ou %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat - macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat\nVous pouvez également vérifier/modifier ce chemin dans la configuration de votre tunnel sous \u0026ldquo;Private Key File\u0026rdquo;.\nComment sauvegarder Arrêtez votre tunnel (facultatif, mais plus sûr) Copiez eepPriv.dat dans un emplacement sécurisé: Disque USB externe Disque de sauvegarde chiffré Archive protégée par mot de passe Stockage cloud sécurisé (chiffré) Conservez plusieurs sauvegardes à des emplacements physiques différents Ne partagez jamais ce fichier - quiconque le possède peut se faire passer pour votre eepsite Restaurer à partir d\u0026rsquo;une sauvegarde Pour restaurer votre eepsite sur un nouveau système ou après une réinstallation :\nInstallez I2P et créez/configurez les paramètres de votre tunnel Arrêtez le tunnel avant de copier la clé Copiez votre eepPriv.dat sauvegardé à l’emplacement correct Démarrez le tunnel - il utilisera votre adresse .b32 d’origine Si vous n\u0026rsquo;enregistrez pas de domaine Félicitations ! Si vous ne prévoyez pas d\u0026rsquo;enregistrer un nom de domaine .i2p personnalisé, votre eepsite est désormais complet et opérationnel.\nVous pouvez : - Partager votre adresse .b32.i2p avec d’autres - Accéder à votre site via le réseau I2P en utilisant n’importe quel navigateur compatible I2P - Mettre à jour les fichiers de votre site dans le dossier docroot à tout moment - Surveiller l’état de votre tunnel dans le Hidden Services Manager (gestionnaire des services cachés)\nSi vous souhaitez un nom de domaine lisible par un humain (comme mysite.i2p plutôt qu\u0026rsquo;une longue adresse .b32), passez à la section suivante.\nEnregistrement de votre domaine I2P Un domaine .i2p lisible par un humain (comme testwebsite.i2p) est bien plus facile à mémoriser et à partager qu’une longue adresse .b32.i2p. L’enregistrement d’un domaine est gratuit et associe le nom choisi à l’adresse cryptographique de votre eepsite.\nPrérequis Votre eepsite doit être en cours d’exécution avec un voyant vert Vous devez avoir défini un Nom d’hôte du site Web dans la configuration de votre tunnel (Étape 2) Exemple : testwebsite.i2p ou myblog.i2p Étape 1 : Générer la chaîne d\u0026rsquo;authentification Revenez à la configuration de votre tunnel dans le Gestionnaire de services cachés Cliquez sur l’entrée de votre serveur web I2P pour ouvrir les paramètres Faites défiler vers le bas pour trouver le bouton Authentification d’enregistrement Cliquez sur Authentification d’enregistrement Copiez l’intégralité de la chaîne d’authentification affichée pour « Authentication for adding host [yourdomainhere] » La chaîne d’authentification ressemblera à :\ntestwebsite.i2p=I8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1uNxFZ0HN7tQbbVj1pmbahepQZNxEW0ufwnMYAoFo8opBQAEAAcAAA==#!date=1762104890#sig=9DjEfrcNRxsoSxiE0Mp0-7rH~ktYWtgwU8c4J0eSo0VHbGxDxdiO9D1Cvwcx8hkherMO07UWOC9BWf-1wRyUAw== Cette chaîne contient : - Votre nom de domaine (testwebsite.i2p) - Votre adresse de destination (le long identifiant cryptographique) - Un horodatage - Une signature cryptographique prouvant que vous possédez la clé privée\nConservez cette chaîne d’authentification - vous en aurez besoin pour les deux services d’inscription.\nÉtape 2 : S\u0026rsquo;inscrire sur stats.i2p Accédez à stats.i2p Ajouter une clé (au sein d\u0026rsquo;I2P) Collez la chaîne d\u0026rsquo;authentification dans le champ \u0026ldquo;Authentication String\u0026rdquo; Ajoutez votre nom (facultatif) - par défaut \u0026ldquo;Anonymous\u0026rdquo; Ajoutez une description (recommandée) - décrivez brièvement l\u0026rsquo;objet de votre eepsite (site I2P) Exemple : \u0026ldquo;Nouvel I2P Eepsite\u0026rdquo;, \u0026ldquo;Blog personnel\u0026rdquo;, \u0026ldquo;Service de partage de fichiers\u0026rdquo; Cochez \u0026ldquo;HTTP Service?\u0026rdquo; s\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un site web (laissez coché pour la plupart des eepsites) Décochez pour IRC, NNTP, serveurs proxy, XMPP, git, etc. Cliquez sur Submit Si tout s’est bien passé, vous verrez un message de confirmation indiquant que votre domaine a été ajouté au carnet d’adresses de stats.i2p.\nÉtape 3 : S’inscrire sur reg.i2p Pour garantir une disponibilité maximale, vous devriez également vous inscrire auprès du service reg.i2p :\nAccédez à reg.i2p Ajouter un domaine (dans I2P) Collez la même chaîne d\u0026rsquo;authentification dans le champ \u0026ldquo;Auth string\u0026rdquo; Ajoutez une description (facultatif mais recommandé) Cela aide les autres utilisateurs I2P à comprendre ce que votre site propose Cliquez sur Submit Vous devriez recevoir une confirmation de l’enregistrement de votre domaine.\nÉtape 4 : Attendre la propagation Après avoir soumis votre demande aux deux services, votre enregistrement de domaine se propagera à travers le système de carnet d’adresses du réseau I2P.\nChronologie de la propagation: - Enregistrement initial: Immédiat sur les services d\u0026rsquo;enregistrement - Propagation à l\u0026rsquo;échelle du réseau: De plusieurs heures à 24+ heures - Disponibilité complète: Peut prendre jusqu\u0026rsquo;à 48 heures pour que tous les routers se mettent à jour\nC\u0026rsquo;est normal ! Le système de carnet d\u0026rsquo;adresses I2P se met à jour périodiquement, pas instantanément. Votre eepsite fonctionne - les autres utilisateurs doivent simplement recevoir le carnet d\u0026rsquo;adresses mis à jour.\nVérifiez votre domaine Après quelques heures, vous pouvez tester votre domaine :\nOuvrez un nouvel onglet dans votre navigateur I2P Essayez d\u0026rsquo;accéder directement à votre domaine : http://yourdomainname.i2p S\u0026rsquo;il se charge, votre domaine est enregistré et se propage ! Si cela ne fonctionne pas encore : - Patientez davantage (les carnets d’adresses se mettent à jour selon leur propre calendrier) - Le carnet d’adresses de votre router peut avoir besoin de temps pour se synchroniser - Essayez de redémarrer votre router I2P pour forcer une mise à jour du carnet d’adresses\nRemarques importantes L’enregistrement est permanent: Une fois enregistré et propagé, votre domaine pointe de façon permanente vers votre adresse .b32.i2p Impossible de changer la destination: Vous ne pouvez pas modifier l’adresse .b32.i2p vers laquelle pointe votre domaine - c’est pourquoi la sauvegarde de eepPriv.dat est cruciale Propriété du domaine: Seul le détenteur de la clé privée peut enregistrer ou mettre à jour le domaine Service gratuit: L’enregistrement de domaine sur I2P est gratuit, géré par la communauté et décentralisé Plusieurs bureaux d’enregistrement: L’enregistrement auprès de stats.i2p et de reg.i2p augmente la fiabilité et la vitesse de propagation Félicitations ! Votre eepsite I2P est désormais pleinement opérationnel avec un domaine enregistré !\nProchaines étapes: - Ajoutez davantage de contenu à votre dossier docroot - Partagez votre domaine avec la communauté I2P - Conservez la sauvegarde de votre eepPriv.dat en lieu sûr - Surveillez régulièrement l\u0026rsquo;état de votre tunnel - Envisagez de rejoindre les forums I2P ou IRC pour promouvoir votre site\nBienvenue sur le réseau I2P ! 🎉\n","description":"Apprenez à créer et héberger votre propre site web sur le réseau I2P à l'aide du serveur web Jetty intégré","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"Création d'un Eepsite I2P","url":"/fr/docs/guides/cr%C3%A9ation-dun-eepsite-i2p/"},{"categories":null,"content":"Les hôtes de reseed sont une infrastructure cruciale pour le réseau I2P, fournissant aux nouveaux routers un groupe initial de nœuds lors du processus de bootstrap. Ce guide vous guidera à travers la configuration et l\u0026rsquo;exécution de votre propre serveur de reseed.\nQu\u0026rsquo;est-ce qu\u0026rsquo;un serveur I2P Reseed ? Un serveur de reseed I2P aide à intégrer de nouveaux routeurs dans le réseau I2P en :\nFourniture de la découverte initiale des pairs : Les nouveaux routeurs reçoivent un ensemble de départ de nœuds réseau auxquels se connecter Récupération du bootstrap : Aide aux routeurs qui ont des difficultés à maintenir leurs connexions Distribution sécurisée : Le processus de reseeding est chiffré et signé numériquement pour garantir la sécurité du réseau Lorsqu\u0026rsquo;un nouveau router I2P démarre pour la première fois (ou a perdu toutes ses connexions avec ses pairs), il contacte les serveurs de reseed pour télécharger un ensemble initial d\u0026rsquo;informations de router. Cela permet au nouveau router de commencer à construire sa propre netDb et à établir des tunnels.\nPrérequis Avant de commencer, vous aurez besoin de :\nUn serveur Linux (Debian/Ubuntu recommandé) avec accès root Un nom de domaine pointant vers votre serveur Au moins 1 Go de RAM et 10 Go d\u0026rsquo;espace disque Un router I2P en fonctionnement sur le serveur pour alimenter la netDb Une connaissance de base de l\u0026rsquo;administration système Linux Préparation du serveur Step 1: Update System and Install Dependencies Tout d\u0026rsquo;abord, mettez à jour votre système et installez les paquets requis :\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y Cela installe : - golang-go : environnement d\u0026rsquo;exécution du langage de programmation Go - git : système de contrôle de version - make : outil d\u0026rsquo;automatisation de compilation - docker.io \u0026amp; docker-compose : plateforme de conteneurisation pour exécuter Nginx Proxy Manager\nStep 2: Clone and Build Reseed Tools Clonez le dépôt reseed-tools et compilez l\u0026rsquo;application :\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install Le package reseed-tools fournit les fonctionnalités de base pour exécuter un serveur reseed. Il gère : - La collecte des informations de router depuis votre base de données réseau locale - L\u0026rsquo;empaquetage des informations de router dans des fichiers SU3 signés - La distribution de ces fichiers via HTTPS\nStep 3: Generate SSL Certificate Générez le certificat SSL et la clé privée de votre serveur reseed :\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Paramètres importants : - --signer : Votre adresse email (remplacez admin@stormycloud.org par la vôtre) - --netdb : Chemin vers la base de données réseau de votre routeur I2P - --port : Port interne (8443 est recommandé) - --ip : Lier à localhost (nous utiliserons un reverse proxy pour l\u0026rsquo;accès public) - --trustProxy : Faire confiance aux en-têtes X-Forwarded-For du reverse proxy\nLa commande va générer : - Une clé privée pour signer les fichiers SU3 - Un certificat SSL pour les connexions HTTPS sécurisées\nÉtape 1 : Mettre à jour le système et installer les dépendances Critique : Sauvegardez de manière sécurisée les clés générées situées dans /home/i2p/.reseed/ :\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ Stockez cette sauvegarde dans un emplacement sécurisé et chiffré avec un accès limité. Ces clés sont essentielles au fonctionnement de votre serveur reseed et doivent être protégées avec soin.\nConfiguring the Service Étape 2 : Cloner et compiler les outils Reseed Créez un service systemd pour exécuter le serveur reseed automatiquement :\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF N\u0026rsquo;oubliez pas de remplacer admin@stormycloud.org par votre propre adresse e-mail.\nMaintenant, activez et démarrez le service :\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed Vérifiez que le service est en cours d\u0026rsquo;exécution :\nsudo systemctl status reseed Étape 3 : Générer un certificat SSL Pour des performances optimales, vous pouvez redémarrer périodiquement le service de reseed afin de rafraîchir les informations du router :\nsudo crontab -e Ajoutez cette ligne pour redémarrer le service toutes les 3 heures :\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy Le serveur reseed s\u0026rsquo;exécute sur localhost:8443 et nécessite un reverse proxy pour gérer le trafic HTTPS public. Nous recommandons Nginx Proxy Manager pour sa facilité d\u0026rsquo;utilisation.\nÉtape 4 : Sauvegardez vos clés Déployer Nginx Proxy Manager avec Docker :\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest Ceci expose : - Port 80 : Trafic HTTP - Port 81 : Interface d\u0026rsquo;administration - Port 443 : Trafic HTTPS\nConfigure Proxy Manager Accédez à l\u0026rsquo;interface d\u0026rsquo;administration à l\u0026rsquo;adresse http://your-server-ip:81\nConnexion avec les identifiants par défaut :\nEmail : admin@example.com Mot de passe : changeme Important : Modifiez ces identifiants immédiatement après la première connexion !\nNaviguez vers Proxy Hosts et cliquez sur Add Proxy Host Configurez l\u0026rsquo;hôte proxy : Nom de domaine : Votre domaine reseed (par ex., reseed.example.com) Schéma : https Nom d\u0026rsquo;hôte / IP de transfert : 127.0.0.1 Port de transfert : 8443 Activez Cache Assets Activez Block Common Exploits Activez Websockets Support Dans l\u0026rsquo;onglet SSL : Sélectionnez Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) Activez Force SSL Activez HTTP/2 Support Acceptez les conditions d\u0026rsquo;utilisation de Let\u0026rsquo;s Encrypt Cliquez sur Enregistrer Votre serveur de reseed devrait maintenant être accessible à https://reseed.example.com\nRegistering Your Reseed Server Une fois votre serveur de reseed opérationnel, contactez les développeurs I2P pour qu\u0026rsquo;il soit ajouté à la liste officielle des serveurs de reseed.\nÉtape 5 : Créer le service Systemd Envoyez un email à zzz (développeur principal d\u0026rsquo;I2P) avec les informations suivantes :\nEmail I2P : zzz@mail.i2p Email Clearnet : zzz@i2pmail.org Étape 6 : Optionnel - Configurer les redémarrages périodiques Incluez dans votre e-mail :\nURL du serveur de reseed : L\u0026rsquo;URL HTTPS complète (par ex., https://reseed.example.com) Certificat public de reseed : Situé dans /home/i2p/.reseed/ (joindre le fichier .crt) Adresse e-mail de contact : Votre méthode de contact privilégiée pour les notifications de maintenance du serveur Emplacement du serveur : Optionnel mais utile (pays/région) Disponibilité prévue : Votre engagement à maintenir le serveur Verification Les développeurs I2P vérifieront que votre serveur de reseed : - Est correctement configuré et distribue les informations de router - Utilise des certificats SSL valides - Fournit des fichiers SU3 correctement signés - Est accessible et réactif\nUne fois approuvé, votre serveur de reseed sera ajouté à la liste distribuée avec les routeurs I2P, aidant les nouveaux utilisateurs à rejoindre le réseau !\nMonitoring and Maintenance Installer Nginx Proxy Manager Surveillez votre service de reseed :\nsudo systemctl status reseed sudo journalctl -u reseed -f Configurer le gestionnaire de proxy Surveillez les ressources système :\nhtop df -h Update Reseed Tools Mettez à jour périodiquement les reseed-tools pour obtenir les dernières améliorations :\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed Informations de contact Si vous utilisez Let\u0026rsquo;s Encrypt via Nginx Proxy Manager, les certificats se renouvelleront automatiquement. Vérifiez que le renouvellement fonctionne :\ndocker logs nginx-proxy-manager | grep -i certificate Configuration du Service Informations requises Vérifier les logs pour les erreurs :\nsudo journalctl -u reseed -n 50 Problèmes courants : - Le routeur I2P n\u0026rsquo;est pas en cours d\u0026rsquo;exécution ou la netDb est vide - Le port 8443 est déjà utilisé - Problèmes de permissions avec le répertoire /home/i2p/.reseed/\nVérification Assurez-vous que votre routeur I2P est en cours d\u0026rsquo;exécution et qu\u0026rsquo;il a rempli sa base de données réseau :\nls -lh /home/i2p/.i2p/netDb/ Vous devriez voir plusieurs fichiers .dat. Si vide, attendez que votre routeur I2P découvre des pairs.\nSSL Certificate Errors Vérifiez que vos certificats sont valides :\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com Vérifier l\u0026rsquo;état du service Vérifiez : - Les enregistrements DNS pointent correctement vers votre serveur - Le pare-feu autorise les ports 80 et 443 - Nginx Proxy Manager est en cours d\u0026rsquo;exécution : docker ps\nSecurity Considerations Protégez vos clés privées : Ne partagez jamais et n\u0026rsquo;exposez jamais le contenu de /home/i2p/.reseed/ Mises à jour régulières : Maintenez à jour les paquets système, Docker et reseed-tools Surveillez les journaux : Surveillez les modèles d\u0026rsquo;accès suspects Limitation du débit : Envisagez de mettre en place une limitation du débit pour éviter les abus Règles de pare-feu : N\u0026rsquo;exposez que les ports nécessaires (80, 443, 81 pour l\u0026rsquo;administration) Interface d\u0026rsquo;administration : Restreignez l\u0026rsquo;interface d\u0026rsquo;administration de Nginx Proxy Manager (port 81) aux adresses IP de confiance Contributing to the Network En exécutant un serveur reseed, vous fournissez une infrastructure critique pour le réseau I2P. Merci de contribuer à un internet plus privé et décentralisé !\nPour toute question ou assistance, contactez la communauté I2P : - Forum : i2pforum.net - IRC/Reddit : #i2p sur différents réseaux - Développement : i2pgit.org IMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nGuide initialement créé par Stormy Cloud , adapté pour la documentation I2P.\n","description":"Guide complet pour configurer et exploiter un serveur de reseed I2P afin d'aider les nouveaux routeurs à rejoindre le réseau","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"Créer et exécuter un serveur de réamorçage I2P","url":"/fr/docs/guides/cr%C3%A9er-et-ex%C3%A9cuter-un-serveur-de-r%C3%A9amor%C3%A7age-i2p/"},{"categories":null,"content":"Un tunnel SSH fournit une connexion sécurisée et chiffrée pour accéder à la console de votre router I2P distant ou à d\u0026rsquo;autres services. Ce guide vous montre comment créer des tunnels SSH sur les systèmes Windows, Linux et Mac.\nQu\u0026rsquo;est-ce qu\u0026rsquo;un tunnel SSH ? Un tunnel SSH est une méthode d\u0026rsquo;acheminement de données et d\u0026rsquo;informations de manière sécurisée via une connexion SSH chiffrée. Imaginez-le comme la création d\u0026rsquo;un « pipeline » protégé à travers internet - vos données transitent par ce tunnel chiffré, empêchant quiconque de les intercepter ou de les lire en cours de route.\nLe tunneling SSH est particulièrement utile pour :\nAccéder à des routeurs I2P distants : Connectez-vous à votre console I2P s\u0026rsquo;exécutant sur un serveur distant Connexions sécurisées : Tout le trafic est chiffré de bout en bout Contournement des restrictions : Accédez aux services sur des systèmes distants comme s\u0026rsquo;ils étaient locaux Redirection de port : Associez un port local à un service distant Dans le contexte d\u0026rsquo;I2P, vous pouvez utiliser un tunnel SSH pour accéder à la console de votre router I2P (généralement sur le port 7657) sur un serveur distant en le redirigeant vers un port local sur votre ordinateur.\nPrérequis Avant de créer un tunnel SSH, vous aurez besoin de :\nClient SSH : Windows : PuTTY (téléchargement gratuit) Linux/Mac : Client SSH intégré (via Terminal) Accès au serveur distant : Nom d\u0026rsquo;utilisateur pour le serveur distant Adresse IP ou nom d\u0026rsquo;hôte du serveur distant Mot de passe SSH ou authentification par clé Port local disponible : Choisissez un port inutilisé entre 1 et 65535 (7657 est couramment utilisé pour I2P) Comprendre la commande Tunnel La commande tunnel SSH suit ce modèle :\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] Explication des paramètres : - local_port : Le port sur votre machine locale (par ex., 7657) - destination_ip : Généralement 127.0.0.1 (localhost sur le serveur distant) - destination_port : Le port du service sur le serveur distant (par ex., 7657 pour I2P) - username : Votre nom d\u0026rsquo;utilisateur sur le serveur distant - remote_server : Adresse IP ou nom d\u0026rsquo;hôte du serveur distant\nExemple : ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\nCela crée un tunnel où : - Le port local 7657 sur votre machine transfère vers\u0026hellip; - Le port 7657 sur le localhost du serveur distant (où I2P est en cours d\u0026rsquo;exécution) - En se connectant en tant qu\u0026rsquo;utilisateur i2p au serveur 20.228.143.58\nCréer des tunnels SSH sur Windows Les utilisateurs Windows peuvent créer des tunnels SSH en utilisant PuTTY, un client SSH gratuit.\nStep 1: Download and Install PuTTY Téléchargez PuTTY depuis putty.org et installez-le sur votre système Windows.\nStep 2: Configure the SSH Connection Ouvrez PuTTY et configurez votre connexion :\nDans la catégorie Session : Saisissez l\u0026rsquo;adresse IP ou le nom d\u0026rsquo;hôte de votre serveur distant dans le champ Host Name Assurez-vous que le Port est défini sur 22 (port SSH par défaut) Le type de connexion doit être SSH Step 3: Configure the Tunnel Accédez à Connection → SSH → Tunnels dans la barre latérale gauche :\nPort source : Entrez le port local que vous souhaitez utiliser (par exemple, 7657) Destination : Entrez 127.0.0.1:7657 (localhost:port sur le serveur distant) Cliquez sur Ajouter pour ajouter le tunnel Le tunnel devrait apparaître dans la liste \u0026ldquo;Ports transférés\u0026rdquo; Step 4: Connect Cliquez sur Ouvrir pour initier la connexion Si c\u0026rsquo;est votre première connexion, vous verrez une alerte de sécurité - cliquez sur Oui pour faire confiance au serveur Entrez votre nom d\u0026rsquo;utilisateur lorsque demandé Entrez votre mot de passe lorsque demandé Une fois connecté, vous pouvez accéder à votre console I2P distante en ouvrant un navigateur et en naviguant vers http://127.0.0.1:7657\nÉtape 1 : Télécharger et installer PuTTY Pour éviter de reconfigurer à chaque fois :\nRetournez à la catégorie Session Entrez un nom dans Saved Sessions (par exemple, « I2P Tunnel ») Cliquez sur Save La prochaine fois, chargez simplement cette session et cliquez sur Open Creating SSH Tunnels on Linux Les systèmes Linux ont SSH intégré dans le terminal, ce qui rend la création de tunnels rapide et simple.\nÉtape 2 : Configurer la connexion SSH Ouvrez un terminal et exécutez la commande de tunnel SSH :\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Remplacer : - 7657 (première occurrence) : Le port local souhaité - 127.0.0.1:7657 : L\u0026rsquo;adresse de destination et le port sur le serveur distant - i2p : Votre nom d\u0026rsquo;utilisateur sur le serveur distant - 20.228.143.58 : L\u0026rsquo;adresse IP de votre serveur distant\nLorsque vous y êtes invité, entrez votre mot de passe. Une fois connecté, le tunnel est actif.\nAccédez à votre console I2P distante à l\u0026rsquo;adresse http://127.0.0.1:7657 dans votre navigateur.\nÉtape 3 : Configurer le Tunnel Le tunnel reste actif tant que la session SSH est en cours d\u0026rsquo;exécution. Pour le maintenir actif en arrière-plan :\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Drapeaux supplémentaires : - -f : Exécute SSH en arrière-plan - -N : Ne pas exécuter de commandes distantes (tunnel uniquement)\nPour fermer un tunnel en arrière-plan, trouvez et arrêtez le processus SSH :\nps aux | grep ssh kill [process_id] Étape 4 : Connexion Pour une meilleure sécurité et commodité, utilisez l\u0026rsquo;authentification par clé SSH :\nGénérez une paire de clés SSH (si vous n\u0026rsquo;en avez pas) :\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Copiez votre clé publique vers le serveur distant :\nssh-copy-id i2p@20.228.143.58 Vous pouvez maintenant vous connecter sans mot de passe :\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac Les systèmes Mac utilisent le même client SSH que Linux, le processus est donc identique.\nOptionnel : Sauvegarder votre session Ouvrez Terminal (Applications → Utilitaires → Terminal) et exécutez :\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Remplacer : - 7657 (première occurrence) : Le port local souhaité - 127.0.0.1:7657 : L\u0026rsquo;adresse de destination et le port sur le serveur distant - i2p : Votre nom d\u0026rsquo;utilisateur sur le serveur distant - 20.228.143.58 : L\u0026rsquo;adresse IP de votre serveur distant\nSaisissez votre mot de passe lorsque vous y êtes invité. Une fois connecté, accédez à votre console I2P distante à l\u0026rsquo;adresse http://127.0.0.1:7657\nBackground Tunnels on Mac Comme sous Linux, vous pouvez exécuter le tunnel en arrière-plan :\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Utilisation du Terminal La configuration des clés SSH sur Mac est identique à celle de Linux :\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases Maintenir le tunnel actif Le cas d\u0026rsquo;usage le plus courant - accéder à la console de votre router I2P distant :\nssh -L 7657:127.0.0.1:7657 user@remote-server Ouvrez ensuite http://127.0.0.1:7657 dans votre navigateur.\nUtilisation des clés SSH (Recommandé) Transférer plusieurs ports à la fois :\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server Ceci transfère à la fois le port 7657 (console I2P) et 7658 (un autre service).\nCustom Local Port Utilisez un port local différent si le port 7657 est déjà utilisé :\nssh -L 8080:127.0.0.1:7657 user@remote-server Accédez à la console I2P via http://127.0.0.1:8080 à la place.\nTroubleshooting Utilisation du Terminal Erreur : \u0026ldquo;bind: Address already in use\u0026rdquo;\nSolution : Choisissez un port local différent ou arrêtez le processus utilisant ce port :\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] Tunnels en arrière-plan sur Mac Erreur : \u0026ldquo;Connection refused\u0026rdquo; ou \u0026ldquo;channel 2: open failed\u0026rdquo;\nCauses possibles : - Le service distant n\u0026rsquo;est pas en cours d\u0026rsquo;exécution (vérifiez que le routeur I2P fonctionne sur le serveur distant) - Un pare-feu bloque la connexion - Port de destination incorrect\nSolution : Vérifiez que le routeur I2P est en cours d\u0026rsquo;exécution sur le serveur distant :\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; Configuration des clés SSH sur Mac Erreur : « Permission refusée » ou « Échec de l\u0026rsquo;authentification »\nCauses possibles : - Nom d\u0026rsquo;utilisateur ou mot de passe incorrect - Clé SSH mal configurée - Accès SSH désactivé sur le serveur distant\nSolution : Vérifiez les informations d\u0026rsquo;identification et assurez-vous que l\u0026rsquo;accès SSH est activé sur le serveur distant.\nTunnel Drops Connection Erreur : La connexion se coupe après une période d\u0026rsquo;inactivité\nSolution : Ajoutez des paramètres keep-alive à votre configuration SSH (~/.ssh/config) :\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices Utiliser des clés SSH : Plus sécurisées que les mots de passe, plus difficiles à compromettre Désactiver l\u0026rsquo;authentification par mot de passe : Une fois les clés SSH configurées, désactiver la connexion par mot de passe sur le serveur Utiliser des mots de passe robustes : Si vous utilisez l\u0026rsquo;authentification par mot de passe, utilisez un mot de passe fort et unique Limiter l\u0026rsquo;accès SSH : Configurer les règles de pare-feu pour limiter l\u0026rsquo;accès SSH aux adresses IP de confiance Maintenir SSH à jour : Mettre à jour régulièrement vos logiciels client et serveur SSH Surveiller les journaux : Vérifier les journaux SSH sur le serveur pour détecter toute activité suspecte Utiliser des ports SSH non standard : Changer le port SSH par défaut (22) pour réduire les attaques automatisées Créer des tunnels SSH sur Linux Accès à la console I2P Créer un script pour établir automatiquement des tunnels :\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; Rendre le fichier exécutable :\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh Tunnels Multiples Créer un service systemd pour la création automatique de tunnels :\nsudo nano /etc/systemd/system/i2p-tunnel.service Ajouter :\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target Activer et démarrer :\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling Port Local Personnalisé Créer un proxy SOCKS pour le transfert dynamique :\nssh -D 8080 user@remote-server Configurez votre navigateur pour utiliser 127.0.0.1:8080 comme proxy SOCKS5.\nReverse Tunneling Autoriser le serveur distant à accéder aux services sur votre machine locale :\nssh -R 7657:127.0.0.1:7657 user@remote-server Port déjà utilisé Tunnel via un serveur intermédiaire :\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion Le tunneling SSH est un outil puissant pour accéder de manière sécurisée aux routers I2P distants et à d\u0026rsquo;autres services. Que vous utilisiez Windows, Linux ou Mac, le processus est simple et fournit un chiffrement robuste pour vos connexions.\nPour obtenir de l\u0026rsquo;aide supplémentaire ou poser des questions, visitez la communauté I2P : - Forum : i2pforum.net - IRC : #i2p sur différents réseaux - Documentation : I2P Docs IMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nGuide créé à l\u0026rsquo;origine par Stormy Cloud , adapté pour la documentation I2P.\n","description":"Apprenez à créer des tunnels SSH sécurisés sur Windows, Linux et Mac pour accéder à votre router I2P distant","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"Créer un tunnel SSH pour accéder à I2P à distance","url":"/fr/docs/guides/cr%C3%A9er-un-tunnel-ssh-pour-acc%C3%A9der-%C3%A0-i2p-%C3%A0-distance/"},{"categories":null,"content":"Instantané de l\u0026rsquo;évolution Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) ## Chiffrement asymétrique X25519 (algorithme d’échange de clés Diffie-Hellman à courbe elliptique) Utilisé pour NTCP2, ECIES-X25519-AEAD-Ratchet, SSU2 et la création de tunnel basée sur X25519. Fournit des clés compactes, des opérations en temps constant et la confidentialité persistante via le cadre du protocole Noise. Offre une sécurité de 128 bits avec des clés de 32 octets et un échange de clés efficace. ElGamal (ancien) Conservé pour des raisons de compatibilité ascendante avec d’anciens routers. Fonctionne sur le nombre premier du groupe Oakley 14 à 2048 bits (RFC 3526) avec le générateur 2. Chiffre les clés de session AES ainsi que les IV dans des textes chiffrés de 514 octets. N’offre ni chiffrement authentifié ni confidentialité persistante ; tous les points de terminaison modernes ont migré vers ECIES. Chiffrement symétrique ChaCha20/Poly1305 (algorithme de chiffrement authentifié combinant ChaCha20 pour le chiffrement et Poly1305 pour l\u0026rsquo;authentification) Primitive de chiffrement authentifié par défaut dans NTCP2, SSU2 et ECIES. Fournit une sécurité AEAD et de hautes performances sans prise en charge matérielle AES. Implémenté conformément à la RFC 7539 (clé 256 bits, nonce 96 bits, tag 128 bits). AES‑256/CBC (ancien) Toujours utilisé pour le chiffrement de la couche de tunnel, où sa structure de chiffrement par blocs s’aligne bien sur le modèle de chiffrement en couches d’I2P. Utilise le remplissage PKCS#5 et des transformations de l’IV (vecteur d’initialisation) à chaque saut. Prévu pour un examen à long terme, mais reste solide sur le plan cryptographique. Signatures Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer ## Hachage et dérivation de clés SHA‑256: Utilisé pour les clés DHT (table de hachage distribuée), HKDF (fonction de dérivation de clés) et les anciennes signatures. SHA‑512: Utilisé par EdDSA/RedDSA (schémas de signature) et pour les dérivations HKDF de Noise (protocole cryptographique). HKDF‑SHA256: Dérive les clés de session dans ECIES (schéma de chiffrement à courbe elliptique), NTCP2 et SSU2. Des dérivations SHA‑256 à rotation quotidienne sécurisent les emplacements de stockage de RouterInfo et LeaseSet dans le netDb. Résumé de la couche de transport Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) Les deux transports fournissent une confidentialité persistante au niveau de la liaison et une protection contre les attaques par rejeu, en utilisant le Noise_XK handshake pattern (schéma de poignée de main Noise_XK). Chiffrement de la couche Tunnel Continue d’utiliser AES‑256/CBC pour le chiffrement en couches par saut. Les passerelles sortantes effectuent un déchiffrement AES itératif ; chaque saut ré‑chiffre en utilisant sa clé de couche et sa clé d’IV (vecteur d’initialisation). Le chiffrement à double IV atténue les attaques par corrélation et par confirmation. La migration vers l’AEAD (chiffrement authentifié avec données associées) est à l’étude mais n’est pas actuellement prévue. Cryptographie post‑quantique I2P 2.10.0 introduit le chiffrement post‑quantique hybride expérimental. Activé manuellement via Hidden Service Manager (gestionnaire de services cachés) pour des tests. Combine X25519 avec un KEM (mécanisme d’encapsulation de clés) résistant aux attaques quantiques (mode hybride). Pas activé par défaut; destiné à la recherche et à l’évaluation des performances. Cadre d\u0026rsquo;extensibilité Les identifiants de type pour le chiffrement et la signature permettent la prise en charge parallèle de plusieurs primitives. Les correspondances actuelles incluent: Types de chiffrement: 0 = ElGamal/AES+SessionTags, 4 = ECIES‑X25519‑AEAD‑Ratchet. Types de signature: 0 = DSA‑SHA1, 7 = EdDSA‑SHA512‑Ed25519, 11 = RedDSA‑SHA512‑Ed25519. Ce cadre permet des mises à niveau futures, y compris des schémas post‑quantiques, sans scissions du réseau. Composition cryptographique Couche de transport: X25519 + ChaCha20/Poly1305 (cadre Noise). Couche tunnel: Chiffrement en couches AES‑256/CBC pour l’anonymat. De bout en bout: ECIES‑X25519‑AEAD‑Ratchet pour la confidentialité et la confidentialité persistante. Couche de base de données: Signatures EdDSA/RedDSA pour l’authenticité. Ces couches se combinent pour fournir une défense en profondeur : même si l’une d’elles est compromise, les autres préservent la confidentialité et la non‑corrélabilité.\nRésumé La pile cryptographique d’I2P 2.10.0 s’articule autour de :\nCurve25519 (X25519) pour l\u0026rsquo;échange de clés ChaCha20/Poly1305 pour le chiffrement symétrique EdDSA / RedDSA pour les signatures SHA‑256 / SHA‑512 pour le hachage et la dérivation de clés Modes hybrides post‑quantiques expérimentaux pour la compatibilité future Les algorithmes hérités ElGamal, AES‑CBC et DSA demeurent pour assurer la compatibilité ascendante, mais ne sont plus utilisés dans les transports actifs ni dans les chemins de chiffrement.\n","description":"Résumé des primitives cryptographiques symétriques, asymétriques et de signature utilisées au sein d'I2P","id":"f5b93f818161e04d49735c3df52fcbdc","section":"docs","title":"Cryptographie de bas niveau","url":"/fr/docs/specs/cryptography/"},{"categories":null,"content":"Aperçu Les datagrammes fournissent une communication orientée message au-dessus d\u0026rsquo;I2CP et en parallèle de la bibliothèque de streaming. Ils permettent des paquets avec réponse possible, authentifiés ou bruts sans nécessiter de flux orientés connexion. Les routeurs encapsulent les datagrammes dans des messages I2NP et des messages tunnel, que le trafic soit transporté par NTCP2 ou SSU2.\nLa motivation principale est de permettre aux applications (comme les trackers, les résolveurs DNS ou les jeux) d\u0026rsquo;envoyer des paquets autonomes qui identifient leur expéditeur.\nNouveau en 2025 : Le projet I2P a approuvé Datagram2 (protocole 19) et Datagram3 (protocole 20), ajoutant une protection contre la rejouabilité et une messagerie répondable à faible surcharge pour la première fois en une décennie.\n1. Constantes de protocole Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) Les protocoles 19 et 20 ont été formalisés dans la **Proposition 163 (avril 2025)**. Ils coexistent avec Datagram1 / RAW pour assurer la rétrocompatibilité. 2. Types de datagrammes Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. ### Modèles de conception typiques Requête → Réponse : Envoyez un Datagram2 signé (requête + nonce), recevez une réponse brute ou Datagram3 (écho nonce). Haute fréquence/faible surcharge : Préférez Datagram3 ou RAW. Messages de contrôle authentifiés : Datagram2. Compatibilité héritée : Datagram1 toujours entièrement pris en charge. 3. Détails de Datagram2 et Datagram3 (2025) Datagram2 (Protocole 19) Remplacement amélioré de Datagram1. Fonctionnalités : - Prévention de la rejouabilité : jeton anti-rejouabilité de 4 octets. - Support de signature hors ligne : permet l\u0026rsquo;utilisation par des Destinations signées hors ligne. - Couverture de signature étendue : inclut le hachage de destination, les drapeaux, les options, le bloc de signature hors ligne, la charge utile. - Prêt pour le post-quantique : compatible avec les futurs hybrides ML-KEM. - Surcharge : ≈ 457 octets (clés X25519).\nDatagram3 (Protocole 20) Comble le fossé entre les types bruts et signés. Fonctionnalités : - Peut être répondu sans signature : contient le hash 32 octets de l\u0026rsquo;expéditeur + drapeaux 2 octets. - Surcharge minime : ≈ 34 octets. - Aucune défense contre la rejouabilité — l\u0026rsquo;application doit l\u0026rsquo;implémenter.\nLes deux protocoles sont des fonctionnalités de l\u0026rsquo;API 0.9.66 et implémentés dans le routeur Java depuis la version 2.9.0 ; aucune implémentation i2pd ou Go pour l\u0026rsquo;instant (octobre 2025).\n4. Limites de taille et de fragmentation Taille du message tunnel : 1 028 octets (4 o ID Tunnel + 16 o IV + 1 008 o charge utile). Fragment initial : 956 o (livraison TUNNEL typique). Fragment suivant : 996 o. Fragments max : 63–64. Limite pratique : ≈ 62 708 o (~61 Ko). Limite recommandée : ≤ 10 Ko pour une livraison fiable (les pertes augmentent de manière exponentielle au-delà). Résumé de la surcharge : - Datagram1 ≈ 427 o (minimum). - Datagram2 ≈ 457 o. - Datagram3 ≈ 34 o. - Couches supplémentaires (en-tête I2CP gzip, I2NP, Garlic, Tunnel) : + ~5,5 Ko dans le pire cas.\n5. Intégration I2CP / I2NP Chemin du message : 1. L\u0026rsquo;application crée un datagramme (via l\u0026rsquo;API I2P ou SAM). 2. I2CP l\u0026rsquo;enveloppe avec un en-tête gzip (0x1F 0x8B 0x08, RFC 1952) et une somme de contrôle CRC-32. 3. Les numéros de protocole + port sont stockés dans les champs d\u0026rsquo;en-tête gzip. 4. Le router encapsule comme message I2NP → clove Garlic → fragments de tunnel de 1 KB. 5. Les fragments traversent le tunnel sortant → réseau → tunnel entrant. 6. Le datagramme réassemblé est livré au gestionnaire d\u0026rsquo;application en fonction du numéro de protocole.\nIntégrité : CRC-32 (depuis I2CP) + signature cryptographique optionnelle (Datagram1/2). Il n\u0026rsquo;y a pas de champ de somme de contrôle séparé dans le datagramme lui-même.\n6. Interfaces de programmation API Java Le package net.i2p.client.datagram comprend : - I2PDatagramMaker – construit des datagrammes signés. - I2PDatagramDissector – vérifie et extrait les informations de l\u0026rsquo;expéditeur. - I2PInvalidDatagramException – levée en cas d\u0026rsquo;échec de vérification.\nI2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl) gère le multiplexage de protocole et de port pour les applications partageant une Destination.\nAccès Javadoc : - idk.i2p Javadoc (réseau I2P uniquement) - Miroir Javadoc (miroir clearnet) - Javadocs officiels (documentation officielle)\nSupport SAMv3 SAM 3.2 (2016) : ajout des paramètres PORT et PROTOCOL. SAM 3.3 (2016) : introduction du modèle PRIMARY/subsession ; permet les flux + datagrammes sur une seule Destination. Support des styles de session Datagram2 / 3 ajouté à la spécification 2025 (implémentation en attente). Spécification officielle : Spécification SAM v3 Modules i2ptunnel udpTunnel: Base entièrement fonctionnelle pour les applications I2P UDP (net.i2p.i2ptunnel.udpTunnel). streamr: Opérationnel pour le streaming A/V (net.i2p.i2ptunnel.streamr). SOCKS UDP: Non fonctionnel depuis la version 2.10.0 (stub UDP uniquement). Pour l\u0026rsquo;UDP à usage général, utilisez l\u0026rsquo;API Datagram ou udpTunnel directement — ne vous fiez pas au SOCKS UDP.\n7. Écosystème et support linguistique (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental Java I2P est le seul routeur prenant en charge les subsessions SAM 3.3 complètes et l'API Datagram2 à l'heure actuelle. 8. Exemple d\u0026rsquo;utilisation – Tracker UDP (I2PSnark 2.10.0) Première application concrète de Datagram2/3 :\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return Le modèle démontre l'utilisation mixte de datagrammes authentifiés et légers pour équilibrer sécurité et performance. 9. Sécurité et bonnes pratiques Utilisez Datagram2 pour tout échange authentifié ou lorsque les attaques par rejeu sont importantes. Préférez Datagram3 pour des réponses rapides reproductibles avec une confiance modérée. Utilisez RAW pour les diffusions publiques ou les données anonymes. Maintenez les charges utiles ≤ 10 Ko pour une livraison fiable. Sachez que SOCKS UDP reste non fonctionnel. Vérifiez toujours le CRC gzip et les signatures numériques à la réception. 10. Spécification technique Cette section couvre les formats de datagrammes de bas niveau, l\u0026rsquo;encapsulation et les détails du protocole.\n10.1 Identification du protocole Les formats de datagramme ne partagent pas d\u0026rsquo;en-tête commun. Les routeurs ne peuvent pas déduire le type uniquement à partir des octets de la charge utile.\nLors du mélange de plusieurs types de datagrammes—ou lors de la combinaison de datagrammes avec du streaming—définissez explicitement : - Le numéro de protocole (via I2CP ou SAM) - Éventuellement le numéro de port, si votre application multiplexe des services\nLaisser le protocole non défini (0 ou PROTO_ANY) est déconseillé et peut entraîner des erreurs de routage ou de livraison.\n10.2 Datagrammes bruts Les datagrammes non répondables ne contiennent aucune donnée d\u0026rsquo;expéditeur ou d\u0026rsquo;authentification. Ce sont des charges utiles opaques, gérées en dehors de l\u0026rsquo;API de datagrammes de niveau supérieur mais prises en charge via SAM et I2PTunnel.\nProtocole : 18 (PROTO_DATAGRAM_RAW)\nFormat :\n+----+----+----+----+----// | payload... +----+----+----+----+----// La longueur de la charge utile est contrainte par les limites du transport (≈32 Ko max pratique, souvent beaucoup moins).\n10.3 Datagram1 (Datagrammes avec réponse) Intègre la Destination de l\u0026rsquo;expéditeur et une Signature pour l\u0026rsquo;authentification et l\u0026rsquo;adressage de réponse.\nProtocole : 17 (PROTO_DATAGRAM)\nSurcharge : ≥427 octets Charge utile : jusqu\u0026rsquo;à ~31,5 Ko (limité par le transport)\nFormat :\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from : une Destination (387+ octets) signature : une Signature correspondant au type de clé Pour DSA_SHA1 : Signature du hash SHA-256 de la charge utile Pour les autres types de clés : Signature directement sur la charge utile Notes : - Les signatures pour les types non-DSA ont été normalisées dans I2P 0.9.14. - Les signatures hors ligne LS2 (Proposition 123) ne sont actuellement pas prises en charge dans Datagram1.\n10.4 Format Datagram2 Un datagramme réponse amélioré qui ajoute une résistance aux rejeux tel que défini dans la Proposition 163 .\nProtocole: 19 (PROTO_DATAGRAM2)\nLa mise en œuvre est en cours. Les applications doivent inclure des vérifications de nonce ou d\u0026rsquo;horodatage pour la redondance.\n10.5 Format Datagram3 Fournit des datagrammes pouvant recevoir une réponse mais non authentifiés. S\u0026rsquo;appuie sur l\u0026rsquo;authentification de session maintenue par le router plutôt que sur une destination et une signature intégrées.\nProtocole : 20 (PROTO_DATAGRAM3) Statut : En développement depuis 0.9.66\nUtile lorsque : - Les destinations sont volumineuses (par exemple, clés post-quantiques) - L\u0026rsquo;authentification se produit à une autre couche - L\u0026rsquo;efficacité de la bande passante est critique\n10.6 Intégrité des données L\u0026rsquo;intégrité du datagramme est protégée par la somme de contrôle gzip CRC-32 dans la couche I2CP. Aucun champ de somme de contrôle explicite n\u0026rsquo;existe dans le format de charge utile du datagramme lui-même.\n10.7 Encapsulation des paquets Chaque datagramme est encapsulé comme un seul message I2NP ou comme un clove individuel dans un Garlic Message. Les couches I2CP, I2NP et tunnel gèrent la longueur et le cadrage — il n\u0026rsquo;y a pas de délimiteur interne ou de champ de longueur dans le protocole de datagramme.\n10.8 Considérations post-quantiques (PQ) Si la Proposition 169 (signatures ML-DSA) est mise en œuvre, les tailles de signature et de destination augmenteront considérablement — passant de ~455 octets à ≥3739 octets. Ce changement augmentera substantiellement la surcharge des datagrammes et réduira la capacité de charge utile effective.\nDatagram3, qui repose sur l\u0026rsquo;authentification au niveau de la session (et non sur des signatures intégrées), deviendra probablement la conception privilégiée dans les environnements I2P post-quantiques.\n11. Références Proposition 163 – Datagram2 et Datagram3 Proposition 160 – Intégration de Tracker UDP Proposition 144 – Calculs MTU en Streaming Proposition 169 – Signatures Post-Quantiques Spécification I2CP Spécification I2NP Spécification des Messages Tunnel Spécification SAM v3 Documentation i2ptunnel 12. Points saillants du journal des modifications (2019 – 2025) Year Release Change 20190.9.43Datagram API stabilization 20210.9.50Protocol port handling reworked 20222.0.0SSU2 adoption completed 20242.6.0Legacy transport removal simplified UDP code 20252.9.0Datagram2/3 support added (Java API) 20252.10.0UDP Tracker implementation released --- 13. Résumé Le sous-système datagram prend désormais en charge quatre variantes de protocole offrant un spectre allant de la transmission entièrement authentifiée à la transmission brute légère. Les développeurs devraient migrer vers Datagram2 pour les cas d\u0026rsquo;usage sensibles en matière de sécurité et Datagram3 pour un trafic efficient avec possibilité de réponse. Tous les anciens types restent compatibles pour garantir l\u0026rsquo;interopérabilité à long terme.\n","description":"Formats de messages authentifiés, avec réponse et bruts au-dessus d'I2CP","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"Datagrammes","url":"/fr/docs/api/datagrams/"},{"categories":null,"content":"Pourquoi écrire du code spécifique à I2P ? Il existe plusieurs façons d\u0026rsquo;utiliser des applications dans I2P. En utilisant I2PTunnel , vous pouvez utiliser des applications ordinaires sans avoir besoin de programmer une prise en charge explicite d\u0026rsquo;I2P. Cela est très efficace pour les scénarios client-serveur, où vous devez vous connecter à un seul site web. Vous pouvez simplement créer un tunnel en utilisant I2PTunnel pour vous connecter à ce site web, comme illustré dans la Figure 1.\nSi votre application est distribuée, elle nécessitera des connexions vers un grand nombre de pairs. En utilisant I2PTunnel, vous devrez créer un nouveau tunnel pour chaque pair que vous souhaitez contacter, comme illustré dans la Figure 2. Ce processus peut bien sûr être automatisé, mais l\u0026rsquo;exécution de nombreuses instances I2PTunnel crée une surcharge importante. De plus, avec de nombreux protocoles, vous devrez forcer tout le monde à utiliser le même ensemble de ports pour tous les pairs — par exemple, si vous voulez exécuter de manière fiable un chat DCC, tout le monde doit convenir que le port 10001 est Alice, le port 10002 est Bob, le port 10003 est Charlie, et ainsi de suite, puisque le protocole inclut des informations spécifiques TCP/IP (hôte et port).\nLes applications réseau générales envoient souvent beaucoup de données supplémentaires qui pourraient être utilisées pour identifier les utilisateurs. Les noms d\u0026rsquo;hôtes, numéros de port, fuseaux horaires, jeux de caractères, etc. sont souvent envoyés sans en informer l\u0026rsquo;utilisateur. Par conséquent, concevoir le protocole réseau spécifiquement en gardant l\u0026rsquo;anonymat à l\u0026rsquo;esprit peut éviter de compromettre l\u0026rsquo;identité des utilisateurs.\nIl y a également des considérations d\u0026rsquo;efficacité à examiner lors de la détermination de la manière d\u0026rsquo;interagir au-dessus d\u0026rsquo;I2P. La bibliothèque streaming et les éléments construits par-dessus fonctionnent avec des handshakes similaires à TCP, tandis que les protocoles I2P de base (I2NP et I2CP) sont strictement basés sur des messages (comme UDP ou dans certains cas IP brut). La distinction importante est qu\u0026rsquo;avec I2P, la communication s\u0026rsquo;opère sur un réseau long et large — chaque message de bout en bout aura des latences non négligeables, mais peut contenir des charges utiles allant jusqu\u0026rsquo;à plusieurs Ko. Une application qui nécessite une simple requête et réponse peut se débarrasser de tout état et réduire la latence encourue par les handshakes de démarrage et de fermeture en utilisant des datagrammes (au mieux de leurs possibilités) sans avoir à se soucier de la détection de MTU ou de la fragmentation des messages.\nFigure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. En résumé, plusieurs raisons de développer du code spécifique à I2P : La création d\u0026rsquo;un grand nombre d\u0026rsquo;instances I2PTunnel consomme une quantité non négligeable de ressources, ce qui pose problème pour les applications distribuées (un nouveau tunnel est requis pour chaque pair). Les protocoles réseau généraux envoient souvent beaucoup de données supplémentaires qui peuvent être utilisées pour identifier les utilisateurs. Programmer spécifiquement pour I2P permet la création d\u0026rsquo;un protocole réseau qui ne divulgue pas de telles informations, gardant les utilisateurs anonymes et en sécurité. Les protocoles réseau conçus pour être utilisés sur Internet classique peuvent être inefficaces sur I2P, qui est un réseau avec une latence beaucoup plus élevée. I2P prend en charge une interface de plugins standard pour les développeurs afin que les applications puissent être facilement intégrées et distribuées.\nLes applications écrites en Java et accessibles/exécutables via une interface HTML au moyen du fichier standard webapps/app.war peuvent être considérées pour inclusion dans la distribution I2P.\nConcepts importants Il y a quelques changements qui nécessitent un ajustement lors de l\u0026rsquo;utilisation d\u0026rsquo;I2P :\nDestinations Une application fonctionnant sur I2P envoie des messages depuis et reçoit des messages vers un point de terminaison unique cryptographiquement sécurisé — une \u0026ldquo;destination\u0026rdquo;. En termes TCP ou UDP, une destination pourrait (en grande partie) être considérée comme l\u0026rsquo;équivalent d\u0026rsquo;une paire nom d\u0026rsquo;hôte plus numéro de port, bien qu\u0026rsquo;il existe quelques différences.\nUne destination I2P est en elle-même une construction cryptographique — toutes les données qui lui sont envoyées sont chiffrées comme s\u0026rsquo;il y avait un déploiement universel d\u0026rsquo;IPsec avec l\u0026rsquo;emplacement (anonymisé) du point terminal signé comme s\u0026rsquo;il y avait un déploiement universel de DNSSEC. Les destinations I2P sont des identifiants mobiles — elles peuvent être déplacées d\u0026rsquo;un router I2P à un autre (ou même fonctionner en « multihébergement » — opérer sur plusieurs routers simultanément). Cela diffère considérablement du monde TCP ou UDP où un seul point terminal (port) doit rester sur un seul hôte. Les destinations I2P sont volumineuses et peu élégantes — en coulisses, elles contiennent une clé publique ElGamal de 2048 bits pour le chiffrement, une clé publique DSA de 1024 bits pour la signature, et un certificat de taille variable, qui peut contenir une preuve de travail ou des données masquées. Il existe des moyens de faire référence à ces destinations volumineuses et disgracieuses par des noms courts et élégants (par exemple « irc.duck.i2p »), mais ces techniques ne garantissent pas l\u0026rsquo;unicité globale (puisqu\u0026rsquo;elles sont stockées localement dans une base de données sur la machine de chaque personne) et le mécanisme actuel n\u0026rsquo;est pas particulièrement évolutif ni sécurisé (les mises à jour de la liste d\u0026rsquo;hôtes sont gérées à l\u0026rsquo;aide d\u0026rsquo;« abonnements » aux services de nommage). Il pourrait y avoir un jour un système de nommage sécurisé, lisible par l\u0026rsquo;homme, évolutif et globalement unique, mais les applications ne devraient pas dépendre de sa mise en place. Plus d\u0026rsquo;informations sur le système de nommage sont disponibles.\nBien que la plupart des applications n\u0026rsquo;aient pas besoin de distinguer les protocoles et les ports, I2P prend effectivement en charge cette fonctionnalité. Les applications complexes peuvent spécifier un protocole, un port source et un port de destination, pour chaque message individuellement, afin de multiplexer le trafic sur une seule destination. Consultez la page sur les datagrammes pour plus de détails. Les applications simples fonctionnent en écoutant « tous les protocoles » sur « tous les ports » d\u0026rsquo;une destination.\nAnonymat et Confidentialité I2P offre un chiffrement et une authentification de bout en bout transparents pour toutes les données transmises sur le réseau — si Bob envoie des données vers la destination d\u0026rsquo;Alice, seule la destination d\u0026rsquo;Alice peut les recevoir, et si Bob utilise la bibliothèque de datagrammes ou de streaming, Alice sait avec certitude que c\u0026rsquo;est la destination de Bob qui a envoyé les données.\nBien entendu, I2P anonymise de manière transparente les données échangées entre Alice et Bob, mais il n\u0026rsquo;anonymise en rien le contenu de ce qu\u0026rsquo;ils envoient. Par exemple, si Alice envoie à Bob un formulaire contenant son nom complet, ses pièces d\u0026rsquo;identité et ses numéros de carte bancaire, I2P ne peut rien y faire. Par conséquent, les protocoles et applications doivent garder à l\u0026rsquo;esprit quelles informations ils tentent de protéger et quelles informations ils sont prêts à exposer.\nLes datagrammes I2P peuvent atteindre plusieurs Ko Les applications qui utilisent les datagrammes I2P (qu\u0026rsquo;ils soient bruts ou répondables) peuvent essentiellement être considérées en termes d\u0026rsquo;UDP — les datagrammes sont non ordonnés, au mieux de leurs capacités, et sans connexion — mais contrairement à UDP, les applications n\u0026rsquo;ont pas besoin de se préoccuper de la détection du MTU et peuvent simplement envoyer de grands datagrammes. Bien que la limite supérieure soit nominalement de 32 Ko, le message est fragmenté pour le transport, ce qui diminue la fiabilité de l\u0026rsquo;ensemble. Les datagrammes de plus d\u0026rsquo;environ 10 Ko ne sont actuellement pas recommandés. Consultez la page sur les datagrammes pour plus de détails. Pour de nombreuses applications, 10 Ko de données suffisent pour une requête ou une réponse complète, leur permettant de fonctionner de manière transparente dans I2P comme une application de type UDP sans avoir à écrire de fragmentation, de renvois, etc.\nOptions de développement Il existe plusieurs moyens d\u0026rsquo;envoyer des données via I2P, chacun avec ses propres avantages et inconvénients. La bibliothèque streaming est l\u0026rsquo;interface recommandée, utilisée par la majorité des applications I2P.\nBibliothèque de streaming La bibliothèque de streaming complète est désormais l\u0026rsquo;interface standard. Elle permet de programmer en utilisant des sockets de type TCP, comme expliqué dans le guide de développement Streaming .\nBOB BOB est le Basic Open Bridge , permettant à une application dans n\u0026rsquo;importe quel langage d\u0026rsquo;établir des connexions streaming vers et depuis I2P. À l\u0026rsquo;heure actuelle, il ne prend pas en charge UDP, mais la prise en charge UDP est prévue dans un avenir proche. BOB contient également plusieurs outils, tels que la génération de clés de destination et la vérification qu\u0026rsquo;une adresse est conforme aux spécifications I2P. Des informations à jour et des applications qui utilisent BOB peuvent être trouvées sur ce site I2P .\nSAM, SAM V2, SAM V3 SAM n\u0026rsquo;est pas recommandé. SAM V2 est acceptable, SAM V3 est recommandé.\nSAM est le protocole Simple Anonymous Messaging , permettant à une application écrite dans n\u0026rsquo;importe quel langage de communiquer avec un pont SAM via une socket TCP simple et de faire en sorte que ce pont multiplexe tout son trafic I2P, en coordonnant de manière transparente le chiffrement/déchiffrement et la gestion basée sur les événements. SAM prend en charge trois styles de fonctionnement :\nstreams, pour quand Alice et Bob veulent s\u0026rsquo;envoyer des données de manière fiable et ordonnée repliable datagrams, pour quand Alice veut envoyer à Bob un message auquel Bob peut répondre raw datagrams, pour quand Alice veut maximiser la bande passante et les performances autant que possible, et que Bob ne se soucie pas de savoir si l\u0026rsquo;expéditeur des données est authentifié ou non (par exemple, les données transférées sont auto-authentifiantes) SAMv3 vise le même objectif que SAM et SAMv2, mais ne nécessite pas de multiplexage/démultiplexage. Chaque flux I2P est géré par son propre socket entre l\u0026rsquo;application et le pont SAM. De plus, les datagrammes peuvent être envoyés et reçus par l\u0026rsquo;application via des communications par datagrammes avec le pont SAM.\nSAM V2 est une nouvelle version utilisée par imule qui corrige certains des problèmes présents dans SAM .\nSAM V3 est utilisé par imule depuis la version 1.4.0.\nI2PTunnel L\u0026rsquo;application I2PTunnel permet aux applications de construire des tunnels TCP spécifiques vers des pairs en créant soit des applications I2PTunnel \u0026lsquo;client\u0026rsquo; (qui écoutent sur un port spécifique et se connectent à une destination I2P spécifique chaque fois qu\u0026rsquo;un socket vers ce port est ouvert) soit des applications I2PTunnel \u0026lsquo;server\u0026rsquo; (qui écoutent sur une destination I2P spécifique et chaque fois qu\u0026rsquo;elles reçoivent une nouvelle connexion I2P, elles redirigent vers un hôte/port TCP spécifique). Ces flux sont 8-bit clean et sont authentifiés et sécurisés via la même bibliothèque de streaming qu\u0026rsquo;utilise SAM, mais la création de plusieurs instances I2PTunnel uniques implique une surcharge non négligeable, car chacune possède sa propre destination I2P unique et son propre ensemble de tunnels, clés, etc.\nSOCKS I2P prend en charge un proxy SOCKS V4 et V5. Les connexions sortantes fonctionnent bien. Les fonctionnalités entrantes (serveur) et UDP peuvent être incomplètes et non testées.\nMinistreaming Supprimé\nIl existait auparavant une bibliothèque simple \u0026ldquo;ministreaming\u0026rdquo;, mais maintenant ministreaming.jar ne contient que les interfaces pour la bibliothèque streaming complète.\nDatagrammes Recommandé pour les applications de type UDP\nLa bibliothèque Datagram permet d\u0026rsquo;envoyer des paquets de type UDP. Il est possible d\u0026rsquo;utiliser :\nDatagrammes avec réponse Datagrammes bruts I2CP Non recommandé\nI2CP lui-même est un protocole indépendant du langage, mais pour implémenter une bibliothèque I2CP dans un autre langage que Java, il faut écrire une quantité significative de code (routines de chiffrement, sérialisation d\u0026rsquo;objets, gestion de messages asynchrones, etc.). Bien que quelqu\u0026rsquo;un puisse écrire une bibliothèque I2CP en C ou dans un autre langage, il serait probablement plus utile d\u0026rsquo;utiliser la bibliothèque SAM en C à la place.\nApplications Web I2P est livré avec le serveur web Jetty, et la configuration pour utiliser le serveur Apache à la place est simple. Toute technologie d\u0026rsquo;application web standard devrait fonctionner.\nCommencer à développer — Un guide simple Développer avec I2P nécessite une installation I2P fonctionnelle et un environnement de développement de votre choix. Si vous utilisez Java, vous pouvez commencer le développement avec la bibliothèque streaming ou la bibliothèque datagram. En utilisant un autre langage de programmation, SAM ou BOB peuvent être utilisés.\nDéveloppement avec la bibliothèque Streaming Ci-dessous se trouve une version réduite et modernisée de l\u0026rsquo;exemple de la page originale. Pour l\u0026rsquo;exemple complet, consultez la page historique ou nos exemples Java dans le code source.\n// Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\u0026#34;Received: \u0026#34; + s); } Exemple de code : serveur basique recevant des données.\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\u0026#34;Hello I2P!\\n\u0026#34;); bw.flush(); Exemple de code : client se connectant et envoyant une ligne.\n","description":"Pourquoi développer des applications spécifiques à I2P, concepts clés, options de développement et guide de démarrage simple","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"Développement d'applications","url":"/fr/docs/develop/applications/"},{"categories":null,"content":"Objectif: Maintenir la cohérence, l\u0026rsquo;exactitude et l\u0026rsquo;accessibilité dans l\u0026rsquo;ensemble de la documentation technique d\u0026rsquo;I2P\nPrincipes fondamentaux 1. Vérifiez tout Ne supposez ni ne devinez jamais. Toutes les affirmations techniques doivent être vérifiées par rapport à: - Code source I2P actuel (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master ) - Documentation officielle de l\u0026rsquo;API (https://i2p.github.io/i2p.i2p/ - Spécifications de configuration /docs/specs/ - Notes de version récentes /releases/ Exemple de vérification appropriée :\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. La clarté avant la concision Écrivez pour des développeurs qui pourraient découvrir I2P pour la première fois. Expliquez les concepts de manière complète plutôt que de supposer des connaissances préalables.\nExemple:\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. Priorité à l’accessibilité La documentation doit être accessible aux développeurs sur le clearnet (internet classique) bien que I2P soit une surcouche réseau. Fournissez toujours des alternatives accessibles sur le clearnet aux ressources internes à I2P.\nExactitude technique Documentation de l\u0026rsquo;API et de l\u0026rsquo;interface Toujours inclure : 1. Noms de packages complets à la première mention : net.i2p.app.ClientApp 2. Signatures de méthodes complètes avec types de retour 3. Noms et types des paramètres 4. Paramètres obligatoires vs optionnels\nExemple:\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. Propriétés de configuration Lors de la documentation des fichiers de configuration: 1. Indiquer les noms de propriétés exacts 2. Préciser l\u0026rsquo;encodage du fichier (UTF-8 pour les configurations I2P) 3. Fournir des exemples complets 4. Documenter les valeurs par défaut 5. Indiquer la version à laquelle les propriétés ont été introduites/modifiées\nExemple:\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) Constantes et énumérations Lors de la documentation des constantes, utilisez les noms de code réels :\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; Faire la distinction entre des concepts similaires I2P comporte plusieurs systèmes qui se recoupent. Précisez toujours quel système vous documentez :\nExemple :\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations URL et références de la documentation Règles d\u0026rsquo;accessibilité des URL Références principales devraient utiliser des URL accessibles sur le clearnet (Internet public) URL internes à I2P (domaines .i2p) doivent inclure des indications d’accessibilité Toujours fournir des alternatives lors de la création de liens vers des ressources internes à I2P Modèle pour les URL internes à I2P :\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ URLs de référence I2P recommandées Spécifications officielles: - Configuration - Greffon - Index de la documentation Documentation de l\u0026rsquo;API (choisir la plus récente): - La plus récente: https://i2p.github.io/i2p.i2p/ (API 0.9.66 à partir d\u0026rsquo;I2P 2.10.0) - Miroir Clearnet: https://eyedeekay.github.io/javadoc-i2p/ Code source: - GitLab (officiel): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master - miroir GitHub: https://github.com/i2p/i2p.i2p Normes de format des liens ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text Suivi des versions Métadonnées du document Chaque document technique devrait inclure des métadonnées de version dans le frontmatter (en-tête YAML du fichier):\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Définitions des champs: - lastUpdated: Année et mois de la dernière révision/mise à jour du document - accurateFor: Version d\u0026rsquo;I2P avec laquelle le document a été vérifié - reviewStatus: L\u0026rsquo;une de \u0026ldquo;draft\u0026rdquo;, \u0026ldquo;needs-review\u0026rdquo;, \u0026ldquo;verified\u0026rdquo;, \u0026ldquo;outdated\u0026rdquo;\nRéférences de version dans le contenu Lorsque vous mentionnez des versions : 1. Utilisez le gras pour la version actuelle : \u0026ldquo;version 2.10.0 (septembre 2025)\u0026rdquo; 2. Indiquez à la fois le numéro de version et la date pour les références historiques 3. Indiquez la version de l’API séparément de la version I2P lorsque c’est pertinent\nExemple:\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. Documenter les changements au fil du temps Pour les fonctionnalités qui ont évolué :\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients Avis de dépréciation Si vous documentez des fonctionnalités dépréciées :\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. Normes de terminologie Termes officiels d\u0026rsquo;I2P Utilisez ces termes exacts de manière cohérente :\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address ### Terminologie des clients gérés Lors de la documentation des clients gérés :\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory ### Terminologie de la configuration Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config ### Noms de packages et de classes Utilisez toujours des noms entièrement qualifiés lors de la première occurrence, puis des noms courts par la suite:\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... Exemples de code et mise en forme Exemples de code Java Utilisez une coloration syntaxique appropriée et des exemples complets:\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` Exigences pour les exemples de code : 1. Inclure des commentaires expliquant les lignes clés 2. Montrer la gestion des erreurs lorsque c\u0026rsquo;est pertinent 3. Utiliser des noms de variables réalistes 4. Respecter les conventions de codage I2P (indentation de 4 espaces) 5. Afficher les imports s\u0026rsquo;ils ne sont pas évidents à partir du contexte\nExemples de configuration Afficher des exemples de configuration complets et valides :\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` Exemples en ligne de commande Utilisez $ pour les commandes utilisateur, # pour root:\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` Code en ligne Utilisez des backticks (accent grave inversé) pour : - Noms de méthodes : startup() - Noms de classes : ClientApp - Noms de propriétés : clientApp.0.main - Noms de fichiers : clients.config - Constantes : SVC_HTTP_PROXY - Noms de packages : net.i2p.app\nTon et voix Professionnel mais accessible Rédigez pour un public technique sans condescendance:\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; Voix active Utilisez la voix active pour plus de clarté :\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; Forme impérative pour les instructions Utilisez l’impératif direct dans le contenu procédural :\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; Évitez le jargon inutile Expliquez les termes lors de leur première apparition :\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) Directives de ponctuation Pas de tirets cadratins - utilisez des tirets ordinaires, des virgules ou des points-virgules à la place Utilisez la virgule d\u0026rsquo;Oxford dans les listes: \u0026ldquo;console, i2ptunnel, et Jetty\u0026rdquo; Points à l\u0026rsquo;intérieur des blocs de code uniquement lorsque c\u0026rsquo;est grammaticalement nécessaire Dans les listes énumératives, utilisez des points-virgules lorsque les éléments contiennent des virgules Structure du document Ordre standard des sections Pour la documentation de l’API :\nVue d\u0026rsquo;ensemble - ce que fait la fonctionnalité, pourquoi elle existe Implémentation - comment l\u0026rsquo;implémenter/l\u0026rsquo;utiliser Configuration - comment la configurer Référence de l\u0026rsquo;API - descriptions détaillées des méthodes/propriétés Exemples - exemples complets et entièrement fonctionnels Bonnes pratiques - conseils et recommandations Historique des versions - date d\u0026rsquo;introduction, changements au fil du temps Références - liens vers la documentation connexe Hiérarchie des titres Utilisez des niveaux de titres sémantiques :\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** Encadrés d’information Utilisez des blocs de citation pour les remarques particulières :\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. Listes et organisation Listes non ordonnées pour des éléments sans ordre particulier :\n- First item - Second item - Third item Listes ordonnées pour des étapes séquentielles:\n1. First step 2. Second step 3. Third step Listes de définitions pour expliquer des termes :\n**Term One** : Explanation of term one **Term Two** : Explanation of term two Écueils courants à éviter 1. Systèmes similaires faciles à confondre Ne pas confondre: - registre de ClientAppManager vs. PortMapper - types de tunnels i2ptunnel vs. constantes de service du port mapper - ClientApp vs. RouterApp (contextes différents) - clients gérés vs. non gérés\nPrécisez toujours de quel système vous parlez :\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. Références à des versions obsolètes À ne pas faire : - Présenter d\u0026rsquo;anciennes versions comme « actuelles » - Pointer vers une documentation d\u0026rsquo;API obsolète - Utiliser des signatures de méthodes dépréciées dans les exemples\nÀ faire : - Consulter les notes de version avant publication - Vérifier que la documentation de l\u0026rsquo;API correspond à la version actuelle - Mettre à jour les exemples pour utiliser les bonnes pratiques actuelles\n3. URL inaccessibles À ne pas faire: - Créer des liens uniquement vers des domaines .i2p sans alternatives clearnet (Internet public classique) - Utiliser des URL de documentation cassées ou obsolètes - Créer des liens vers des chemins locaux file://\nÀ faire : - Fournir des alternatives clearnet pour tous les liens internes à I2P - Vérifier que les URL sont accessibles avant publication - Utiliser des URL persistantes (geti2p.net, pas un hébergement temporaire)\n4. Exemples de code incomplets À ne pas faire: - Afficher des extraits sans contexte - Omettre la gestion des erreurs - Utiliser des variables non définies - Omettre les instructions d\u0026rsquo;importation lorsqu\u0026rsquo;elles ne sont pas évidentes\nÀ faire: - Présenter des exemples complets et compilables - Inclure la gestion des erreurs requise - Expliquer ce que fait chaque ligne importante - Tester les exemples avant publication\n5. Déclarations ambiguës ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; Conventions Markdown Nommage des fichiers Utilisez le kebab-case (mots séparés par des tirets) pour les noms de fichiers : - managed-clients.md - port-mapper-guide.md - configuration-reference.md\nFormat du Frontmatter (métadonnées d\u0026rsquo;en-tête) Toujours inclure le front matter YAML (métadonnées en tête du document):\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Mise en forme des liens Liens internes (dans la documentation):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) Liens externes (vers d\u0026rsquo;autres ressources):\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) Liens vers le dépôt de code:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) Mise en forme des tableaux Utilisez des tableaux GitHub-flavored Markdown (Markdown spécifique à GitHub):\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | Étiquettes de langue pour les blocs de code Indiquez toujours la langue pour la coloration syntaxique :\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` Liste de contrôle de revue Avant de publier la documentation, vérifiez :\nToutes les affirmations techniques sont vérifiées par rapport au code source ou à la documentation officielle Les numéros de version et les dates sont à jour Toutes les URL sont accessibles depuis le clearnet (ou des alternatives sont fournies) Les exemples de code sont complets et testés La terminologie suit les conventions d’I2P Pas de tirets cadratins (utiliser des tirets normaux ou une autre ponctuation) Le Frontmatter (métadonnées d’en-tête) est complet et exact La hiérarchie des titres est sémantique (h1 → h2 → h3) Les listes et les tableaux sont correctement formatés La section des références inclut toutes les sources citées Le document suit les directives de structure Le ton est professionnel mais accessible Les concepts similaires sont clairement distingués Aucun lien ni référence brisés Les exemples de configuration sont valides et à jour Commentaires: Si vous rencontrez des problèmes ou avez des suggestions concernant ces directives, veuillez les soumettre via les canaux officiels de développement d\u0026rsquo;I2P.\n","description":"Maintenir la cohérence, l’exactitude et l’accessibilité dans l’ensemble de la documentation technique I2P","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"Directives de rédaction de la documentation d'I2P","url":"/fr/docs/writing-guidelines/"},{"categories":null,"content":"Lisez d\u0026rsquo;abord le Guide des nouveaux développeurs .\nDirectives de base et style de code La plupart des points suivants devraient être du bon sens pour quiconque a travaillé sur des projets open source ou dans un environnement de programmation commercial. Ce qui suit s\u0026rsquo;applique principalement à la branche de développement principale i2p.i2p. Les directives pour les autres branches, plugins et applications externes peuvent être substantiellement différentes ; consultez le développeur approprié pour obtenir des conseils.\nCommunauté Veuillez ne pas vous contenter d\u0026rsquo;écrire du code. Si vous le pouvez, participez à d\u0026rsquo;autres activités de développement, notamment : les discussions de développement et le support sur IRC et i2pforum.i2p ; les tests ; les rapports de bugs et les réponses ; la documentation ; les revues de code ; etc. Les développeurs actifs devraient être disponibles périodiquement sur IRC #i2p-dev. Soyez conscient du cycle de publication actuel. Respectez les jalons de publication tels que le gel des fonctionnalités, le gel des tags et la date limite de check-in pour une version. Cycle de publication Le cycle de publication normal est de 10 à 16 semaines, soit quatre publications par an. Voici les échéances approximatives dans un cycle typique de 13 semaines. Les échéances réelles pour chaque publication sont fixées par le responsable de publication après consultation avec l\u0026rsquo;équipe complète.\n1–2 jours après la version précédente : Les commits sur trunk sont autorisés. 2–3 semaines après la version précédente : Date limite pour propager les changements majeurs des autres branches vers trunk. 4–5 semaines avant la version : Date limite pour demander de nouveaux liens sur la page d\u0026rsquo;accueil. 3–4 semaines avant la version : Gel des fonctionnalités. Date limite pour les nouvelles fonctionnalités majeures. 2–3 semaines avant la version : Tenir une réunion de projet pour examiner les demandes de nouveaux liens pour la page d\u0026rsquo;accueil, le cas échéant. 10–14 jours avant la version : Gel des chaînes de caractères. Plus aucune modification aux chaînes traduites (étiquetées). Pousser les chaînes vers Transifex, annoncer la date limite de traduction sur Transifex. 10–14 jours avant la version : Date limite des fonctionnalités. Uniquement des corrections de bugs après cette date. Plus de fonctionnalités, de refactorisation ou de nettoyage. 3–4 jours avant la version : Date limite de traduction. Récupérer les traductions depuis Transifex et les valider. 3–4 jours avant la version : Date limite de commit. Aucun commit après cette date sans l\u0026rsquo;autorisation du responsable de la version. Quelques heures avant la version : Date limite de revue de code. Git Avoir une compréhension de base des systèmes de contrôle de source distribués, même si vous n\u0026rsquo;avez jamais utilisé git auparavant. Demandez de l\u0026rsquo;aide si nécessaire. Une fois poussés, les commits sont permanents ; il n\u0026rsquo;y a pas d\u0026rsquo;annulation. Soyez prudent. Si vous n\u0026rsquo;avez jamais utilisé git auparavant, commencez par de petites étapes. Validez quelques petits changements et voyez comment cela se passe. Testez vos modifications avant de les valider. Si vous préférez le modèle de développement commit‑avant‑test, utilisez votre propre branche de développement dans votre propre compte, et créez une MR une fois le travail terminé. Ne cassez pas le build. Ne provoquez pas de régressions. Si cela arrive (ça arrive), ne disparaissez pas pendant une longue période après avoir poussé votre modification. Si votre modification n\u0026rsquo;est pas triviale, ou si vous voulez que les gens la testent et avez besoin de bons rapports de test pour savoir si votre modification a été testée ou non, ajoutez un commentaire de commit dans history.txt et incrémentez la révision du build dans RouterVersion.java. Ne validez pas de changements majeurs dans la branche principale i2p.i2p tard dans le cycle de publication. Si un projet vous prendra plus de quelques jours, créez votre propre branche dans git, dans votre propre compte, et effectuez le développement là-bas pour ne pas bloquer les publications. Pour les grands changements (en général, plus de 100 lignes, ou touchant plus de trois fichiers), validez-les dans une nouvelle branche sur votre propre compte GitLab, créez une MR, et assignez un réviseur. Assignez-vous la MR. Fusionnez la MR vous-même une fois que le réviseur l\u0026rsquo;approuve. Ne créez pas de branches WIP dans le compte principal I2P_Developers (sauf pour i2p.www). Les WIP appartiennent à votre propre compte. Lorsque le travail est terminé, créez une MR. Les seules branches du compte principal devraient être pour de véritables forks, comme une publication ponctuelle. Effectuez le développement de manière transparente et avec la communauté à l\u0026rsquo;esprit. Validez souvent. Validez ou fusionnez dans la branche principale aussi fréquemment que possible, compte tenu des directives ci-dessus. Si vous travaillez sur un grand projet dans votre propre branche/compte, informez-en les gens afin qu\u0026rsquo;ils puissent suivre et réviser/tester/commenter. Style de codage Le style de codage dans la majeure partie du code est de 4 espaces pour l\u0026rsquo;indentation. N\u0026rsquo;utilisez pas de tabulations. Ne reformatez pas le code. Si votre IDE ou éditeur veut tout reformater, maîtrisez-le. Dans certains endroits, le style de codage est différent. Utilisez le bon sens. Imitez le style du fichier que vous modifiez. Toutes les nouvelles classes et méthodes publiques et package-private nécessitent des Javadocs. Ajoutez @since numéro-de-version. Les Javadocs pour les nouvelles méthodes privées sont souhaitables. Pour toutes les Javadocs ajoutées, il ne doit y avoir aucune erreur ou avertissement doclint. Exécutez ant javadoc avec Oracle Java 14 ou supérieur pour vérifier. Tous les paramètres doivent avoir des lignes @param, toutes les méthodes non-void doivent avoir des lignes @return, toutes les exceptions déclarées levées doivent avoir des lignes @throws, et aucune erreur HTML. Les classes dans core/ (i2p.jar) et des parties de i2ptunnel font partie de notre API officielle. Il existe plusieurs plugins hors arborescence et autres applications qui dépendent de cette API. Faites attention à ne pas apporter de modifications qui rompent la compatibilité. N\u0026rsquo;ajoutez pas de méthodes à l\u0026rsquo;API sauf si elles sont d\u0026rsquo;utilité générale. Les Javadocs pour les méthodes d\u0026rsquo;API doivent être claires et complètes. Si vous ajoutez ou modifiez l\u0026rsquo;API, mettez également à jour la documentation sur le site web (branche i2p.www). Balisez les chaînes pour la traduction lorsque cela est approprié, ce qui est vrai pour toutes les chaînes d\u0026rsquo;interface utilisateur. Ne modifiez pas les chaînes balisées existantes sauf si c\u0026rsquo;est vraiment nécessaire, car cela cassera les traductions existantes. N\u0026rsquo;ajoutez pas ou ne modifiez pas les chaînes balisées après le gel des balises dans le cycle de publication afin que les traducteurs aient la possibilité de mettre à jour avant la sortie. Utilisez les génériques et les classes concurrentes dans la mesure du possible. I2P est une application hautement multi-threadée. Familiarisez-vous avec les pièges Java courants qui sont détectés par FindBugs/SpotBugs. Exécutez ant findbugs pour en savoir plus. Java 8 est requis pour compiler et exécuter I2P depuis la version 0.9.47. N\u0026rsquo;utilisez pas de classes ou méthodes Java 7 ou 8 dans les sous-systèmes embarqués : addressbook, core, i2ptunnel.jar (non-UI), mstreaming, router, routerconsole (news uniquement), streaming. Ces sous-systèmes sont utilisés par Android et des applications embarquées qui ne nécessitent que Java 6. Toutes les classes doivent être disponibles dans Android API 14. Les fonctionnalités du langage Java 7 sont acceptables dans ces sous-systèmes si elles sont prises en charge par la version actuelle du SDK Android et qu\u0026rsquo;elles compilent en code compatible Java 6. Try-with-resources ne peut pas être utilisé dans les sous-systèmes embarqués car il nécessite java.lang.AutoCloseable dans le runtime, et ceci n\u0026rsquo;est pas disponible avant Android API 19 (KitKat 4.4). Le package java.nio.file ne peut pas être utilisé dans les sous-systèmes embarqués car il n\u0026rsquo;est pas disponible avant Android API 26 (Oreo 8). Outre les limitations ci-dessus, les classes, méthodes et constructions Java 8 peuvent être utilisées uniquement dans les sous-systèmes suivants : BOB, desktopgui, i2psnark, i2ptunnel.war (UI), jetty-i2p.jar, jsonrpc, routerconsole (sauf news), SAM, susidns, susimail, systray. Les auteurs de plugins peuvent exiger n\u0026rsquo;importe quelle version minimale de Java via le fichier plugin.config. Convertissez explicitement entre les types primitifs et les classes ; ne vous fiez pas à l\u0026rsquo;autoboxing/unboxing. N\u0026rsquo;utilisez pas URL. Utilisez URI. N\u0026rsquo;attrapez pas Exception. Attrapez RuntimeException et les exceptions vérifiées individuellement. N\u0026rsquo;utilisez pas String.getBytes() sans argument charset UTF-8. Vous pouvez également utiliser DataHelper.getUTF8() ou DataHelper.getASCII(). Spécifiez toujours un charset UTF-8 lors de la lecture ou de l\u0026rsquo;écriture de fichiers. Les utilitaires DataHelper peuvent être utiles. Spécifiez toujours une locale (par exemple Locale.US) lors de l\u0026rsquo;utilisation de String.toLowerCase() ou String.toUpperCase(). N\u0026rsquo;utilisez pas String.equalsIgnoreCase(), car une locale ne peut pas être spécifiée. N\u0026rsquo;utilisez pas String.split(). Utilisez DataHelper.split(). N\u0026rsquo;ajoutez pas de code pour formater les dates et heures. Utilisez DataHelper.formatDate() et DataHelper.formatTime(). Assurez-vous que les InputStreams et OutputStreams sont fermés dans des blocs finally. Utilisez {} pour tous les blocs for et while, même si une seule ligne. Si vous utilisez {} pour le bloc if, else ou if-else, utilisez-le pour tous les blocs. Mettez } else { sur une seule ligne. Spécifiez les champs comme final partout où c\u0026rsquo;est possible. Ne stockez pas I2PAppContext, RouterContext, Log, ou toute autre référence aux éléments du router ou du contexte dans des champs statiques. Ne démarrez pas de threads dans les constructeurs. Utilisez I2PAppThread au lieu de Thread. Journalisation Les directives suivantes s\u0026rsquo;appliquent au router, aux applications web et à tous les plugins.\nPour tous les messages qui ne sont pas affichés au niveau de log par défaut (WARN, INFO et DEBUG), sauf si le message est une chaîne statique (sans concaténation), utilisez toujours log.shouldWarn(), log.shouldInfo() ou log.shouldDebug() avant l\u0026rsquo;appel au log pour éviter une allocation d\u0026rsquo;objets inutile. Les messages de log susceptibles d\u0026rsquo;être affichés au niveau de log par défaut (ERROR, CRIT et logAlways()) doivent être brefs, clairs et compréhensibles pour un utilisateur non technique. Cela inclut le texte des raisons d\u0026rsquo;exception qui peuvent également être affichés. Envisagez de traduire si l\u0026rsquo;erreur est susceptible de se produire (par exemple, lors d\u0026rsquo;erreurs de soumission de formulaire). Sinon, la traduction n\u0026rsquo;est pas nécessaire, mais il peut être utile de rechercher et de réutiliser une chaîne déjà marquée pour la traduction ailleurs. Les messages de log qui ne sont pas affichés au niveau de log par défaut (WARN, INFO et DEBUG) sont destinés à l\u0026rsquo;usage des développeurs et n\u0026rsquo;ont pas les exigences ci-dessus. Cependant, les messages WARN sont disponibles dans l\u0026rsquo;onglet log Android et peuvent aider les utilisateurs à déboguer des problèmes, donc faites également attention aux messages WARN. Les messages de log INFO et DEBUG doivent être utilisés avec parcimonie, en particulier dans les chemins de code critiques. Bien qu\u0026rsquo;utiles pendant le développement, envisagez de les supprimer ou de les mettre en commentaire une fois les tests terminés. Ne loguez pas vers stdout ou stderr (wrapper log). Licences Ne soumettez que du code que vous avez écrit vous-même. Avant de soumettre du code ou des fichiers JAR de bibliothèques provenant d\u0026rsquo;autres sources, justifiez pourquoi c\u0026rsquo;est nécessaire, vérifiez que la licence est compatible et obtenez l\u0026rsquo;approbation du gestionnaire de version. Si vous obtenez l\u0026rsquo;approbation pour ajouter du code externe ou des fichiers JAR, et que des binaires sont disponibles dans un paquet Debian ou Ubuntu, vous devez implémenter des options de compilation et d\u0026rsquo;empaquetage pour utiliser le paquet externe à la place. Liste des fichiers à modifier : build.properties, build.xml, debian/control, debian/i2p-router.install, debian/i2p-router.links, debian/rules, sub-build.xml. Pour toute image soumise provenant de sources externes, il est de votre responsabilité de vérifier d\u0026rsquo;abord que la licence est compatible. Incluez la licence et les informations sur la source dans le commentaire de soumission. Bugs La gestion des problèmes est l\u0026rsquo;affaire de tous ; merci d\u0026rsquo;aider. Surveillez GitLab pour les problèmes sur lesquels vous pouvez aider. Commentez, corrigez et fermez les problèmes si vous le pouvez. Les nouveaux développeurs devraient commencer par corriger des problèmes. Lorsque vous avez un correctif, joignez votre patch au problème et ajoutez le mot-clé review-needed. Ne fermez pas le problème tant qu\u0026rsquo;il n\u0026rsquo;a pas été examiné avec succès et que vous n\u0026rsquo;avez pas vérifié vos modifications. Une fois que vous avez fait cela sans accroc pour quelques tickets, vous pouvez suivre la procédure normale ci-dessus. Fermez un problème lorsque vous pensez l\u0026rsquo;avoir corrigé. Nous n\u0026rsquo;avons pas de département de test pour vérifier et fermer les tickets. Si vous n\u0026rsquo;êtes pas sûr de l\u0026rsquo;avoir corrigé, fermez-le et ajoutez une note disant \u0026ldquo;Je pense l\u0026rsquo;avoir corrigé, veuillez tester et rouvrir si c\u0026rsquo;est toujours cassé\u0026rdquo;. Ajoutez un commentaire avec le numéro de build de développement ou la révision et définissez le jalon pour la prochaine version. ","description":"Directives complètes pour contribuer à I2P : flux de travail, cycle de publication, style de codage, journalisation, licences et gestion des problèmes","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"Directives pour les développeurs et style de codage","url":"/fr/docs/develop/dev-guidelines/"},{"categories":null,"content":" Remarque : Cette discussion archivée présente des approches historiques de la base de données réseau (netDb). Consultez la documentation principale de netDb pour le comportement actuel et les recommandations.\nHistorique Le netDb d\u0026rsquo;I2P est distribué au moyen d\u0026rsquo;un algorithme floodfill simple. Les premières versions conservaient également une implémentation de la DHT Kademlia comme solution de repli, mais elle s\u0026rsquo;est révélée peu fiable et a été entièrement désactivée dans la version 0.6.1.20. La conception floodfill transmet une entrée publiée à un router participant, attend une confirmation, puis réessaie avec d\u0026rsquo;autres pairs floodfill si nécessaire. Les pairs floodfill propagent vers tous les autres participants floodfill les enregistrements provenant des routers non-floodfill.\nFin 2009, les recherches Kademlia (protocole DHT) ont été partiellement réintroduites afin de réduire la charge de stockage pesant sur les floodfill routers individuels.\nIntroduction à Floodfill Floodfill est apparu pour la première fois dans la version 0.6.0.4, tandis que Kademlia est resté disponible en solution de repli. À l\u0026rsquo;époque, d\u0026rsquo;importantes pertes de paquets et des routes restreintes rendaient difficile l\u0026rsquo;obtention d\u0026rsquo;accusés de réception de la part des quatre pairs les plus proches, nécessitant souvent des dizaines de tentatives de stockage redondantes. Le passage à un sous-ensemble floodfill de routers joignables depuis l\u0026rsquo;extérieur a apporté une solution pragmatique à court terme.\nRepenser Kademlia (protocole de table de hachage distribuée, DHT) Parmi les alternatives envisagées figuraient :\nExécuter la netDb en tant que DHT Kademlia, limitée aux routers joignables qui choisissent d’y participer Conserver le modèle floodfill tout en limitant la participation aux routers capables et en vérifiant la distribution au moyen de contrôles aléatoires L’approche floodfill l’a emporté parce qu’elle était plus facile à déployer et que la netDb ne contient que des métadonnées, pas de données utilisateur. La plupart des destinations ne publient jamais de LeaseSet, car l’expéditeur inclut généralement son LeaseSet dans des garlic messages (un mécanisme de regroupement de messages).\nStatut actuel (perspective historique) Les algorithmes du netDb sont adaptés aux besoins du réseau et ont historiquement géré aisément quelques centaines de routers. Les premières estimations suggéraient que 3–5 floodfill routers pouvaient prendre en charge environ 10 000 nœuds.\nCalculs mis à jour (mars 2008) recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T Où :\nN: routers dans le réseau L: Nombre moyen de destinations client par router (plus un pour le RouterInfo) F: Pourcentage d’échec de tunnel R: Période de reconstruction de tunnel en fraction de la durée de vie du tunnel S: Taille moyenne d’une entrée netDb T: Durée de vie du tunnel En utilisant des valeurs datant de 2008 (N = 700, L = 0.5, F = 0.33, R = 0.5, S = 4 KB, T = 10 minutes) on obtient :\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps Kademlia (protocole DHT) fera-t-il son retour ? Les développeurs ont discuté de la réintroduction de Kademlia (algorithme de table de hachage distribuée, DHT) vers début 2007. Le consensus était que la capacité floodfill (mode de diffusion de la netDb) pouvait être augmentée progressivement selon les besoins, tandis que Kademlia ajoutait une complexité et des besoins en ressources importants pour la population de routers standard. Le mécanisme de repli reste dormant à moins que la capacité floodfill ne devienne insuffisante.\nPlanification de la capacité Floodfill L’admission automatique des routers de classe de bande passante O dans le floodfill, bien que tentante, comporte le risque de scénarios de déni de service si des nœuds hostiles choisissent d’y participer. Des analyses historiques ont suggéré que limiter le pool de floodfill (par exemple, 3–5 pairs gérant ~10K routers) était plus sécurisé. Des opérateurs de confiance ou des heuristiques automatiques ont été utilisés pour maintenir un ensemble de floodfill adéquat mais contrôlé.\nFloodfill À faire (Historique) Cette section est conservée pour la postérité. La page principale de netDb (base de données du réseau I2P) suit la feuille de route actuelle et les considérations de conception.\nDes incidents opérationnels, comme une période, le 13 mars 2008, au cours de laquelle un seul floodfill router était disponible, ont entraîné plusieurs améliorations introduites dans les versions 0.6.1.33 à 0.7.x, notamment :\nRandomisation de la sélection des floodfill pour les recherches et préférence donnée aux pairs réactifs Affichage de métriques floodfill supplémentaires sur la page \u0026ldquo;Profiles\u0026rdquo; de la console du router Réductions progressives de la taille des entrées netDb pour réduire l\u0026rsquo;utilisation de bande passante des floodfill Participation automatique pour un sous-ensemble de routers de classe O, en fonction des performances collectées via les données de profil Amélioration des listes de blocage, de la sélection des pairs floodfill et des heuristiques d\u0026rsquo;exploration Les idées restantes de cette période comprenaient :\nUtiliser les statistiques de dbHistory pour mieux évaluer et sélectionner des pairs floodfill Améliorer le comportement de réessai afin d’éviter de contacter à répétition des pairs défaillants Exploiter les métriques de latence et les scores d’intégration lors de la sélection Détecter et réagir plus rapidement aux routers floodfill défaillants Continuer à réduire la charge en ressources sur les nœuds à haut débit et les nœuds floodfill Même à la date de ces notes, le réseau était considéré comme résilient, avec une infrastructure en place pour réagir rapidement aux floodfills hostiles ou aux attaques par déni de service ciblant les floodfills.\nNotes supplémentaires La console du router expose depuis longtemps des données de profil enrichies pour faciliter l\u0026rsquo;analyse de la fiabilité du floodfill. Alors que des commentaires historiques ont spéculé sur Kademlia ou des schémas DHT alternatifs, le floodfill est resté l\u0026rsquo;algorithme principal pour les réseaux de production. La recherche prospective s\u0026rsquo;est concentrée sur le fait de rendre l\u0026rsquo;admission au floodfill adaptative tout en limitant les possibilités d\u0026rsquo;abus. ","description":"Notes historiques sur floodfill, les expérimentations Kademlia et les ajustements futurs pour la netDb","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"Discussion sur la base de données du réseau","url":"/fr/docs/netdb/"},{"categories":null,"content":" Contexte: Cette page archive des débats de longue haleine datant des débuts de la conception d\u0026rsquo;I2P. Elle explique pourquoi le projet a privilégié des carnets d\u0026rsquo;adresses locaux de confiance plutôt que des résolutions de type DNS ou des registres fondés sur un vote majoritaire. Pour des recommandations d\u0026rsquo;utilisation à jour, voir la documentation sur le nommage .\nAlternatives écartées Les objectifs de sécurité d’I2P excluent les schémas de nommage familiers:\nRésolution de type DNS. N’importe quel résolveur sur la chaîne de résolution pourrait usurper ou censurer les réponses. Même avec DNSSEC, des bureaux d’enregistrement ou des autorités de certification compromis restent un point de défaillance unique. Dans I2P, les destinations sont des clés publiques — détourner une requête de résolution compromettrait entièrement une identité. Nommage par vote. Un adversaire peut créer un nombre illimité d’identités (une attaque Sybil) et « gagner » des votes pour des noms populaires. Les contre-mesures basées sur la preuve de travail augmentent le coût, mais introduisent une lourde surcharge de coordination. Au lieu de cela, I2P maintient délibérément la résolution de noms au-dessus de la couche de transport. La bibliothèque de nommage incluse offre une interface de fournisseur de services afin que des mécanismes alternatifs puissent coexister—les utilisateurs décident à quels carnets d’adresses ou jump services (services de saut aidant à résoudre les adresses) ils font confiance.\nNoms locaux vs noms globaux (jrandom, 2005) Dans I2P, les noms sont localement uniques mais lisibles par des humains. Votre boss.i2p peut ne pas correspondre au boss.i2p de quelqu’un d’autre, et c’est voulu. Si un acteur malveillant vous amenait à modifier la destination (identifiant d’un service dans I2P) associée à un nom, il détournerait effectivement un service. Le fait de ne pas imposer l’unicité globale empêche cette catégorie d’attaque. Traitez les noms comme des signets ou des pseudos de messagerie instantanée — vous choisissez les destinations auxquelles faire confiance en vous abonnant à des carnets d’adresses spécifiques ou en ajoutant des clés manuellement. Objections courantes et réponses (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. ## Idées d’efficacité abordées Servir des mises à jour incrémentielles (uniquement les destinations ajoutées depuis la dernière récupération). Proposer des flux supplémentaires (recenthosts.cgi) en complément des fichiers hosts complets. Explorer des outils scriptables (par exemple, i2host.i2p) pour fusionner des flux ou filtrer par niveaux de confiance. Points clés La sécurité prime sur le consensus global : des carnets d\u0026rsquo;adresses gérés localement minimisent le risque d\u0026rsquo;usurpation. Plusieurs approches de nommage peuvent coexister via l\u0026rsquo;API de nommage—les utilisateurs décident à quoi faire confiance. Un nommage global entièrement décentralisé reste un problème de recherche ouvert ; les compromis entre la sécurité, la mémorisation humaine et l\u0026rsquo;unicité globale reflètent toujours le triangle de Zooko . Références Documentation sur la résolution de noms “Noms : décentralisés, sécurisés, compréhensibles pour l’humain : choisissez-en deux” de Zooko Exemple de flux incrémentiel: stats.i2p/cgi-bin/newhosts.txt ","description":"Débat historique sur le modèle de nommage d’I2P et les raisons pour lesquelles les schémas de type DNS global ont été rejetés","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"Discussion sur le nommage","url":"/fr/docs/legacy/naming/"},{"categories":null,"content":" Remarque : Cette archive rassemble des travaux de conception spéculatifs antérieurs à I2P 0.9.41. Pour l’implémentation en production, consultez la documentation des tunnels .\nAlternatives de configuration Les idées envisagées pour de futurs paramètres de tunnel comprenaient :\nMécanismes de limitation de fréquence pour la livraison des messages Politiques de bourrage (y compris l\u0026rsquo;injection de chaff (trafic factice)) Contrôles de durée de vie des tunnels Stratégies de traitement par lots et de gestion des files d\u0026rsquo;attente pour l\u0026rsquo;acheminement des charges utiles Aucune de ces options n’était incluse dans l’ancienne implémentation.\nStratégies de bourrage Approches potentielles de remplissage discutées :\nSans aucun remplissage Remplissage de longueur aléatoire Remplissage de longueur fixe Remplissage jusqu’au kilooctet le plus proche Remplissage jusqu’à une puissance de deux (2^n octets) Les premières mesures (version 0.4) ont conduit à la taille fixe actuelle de 1024 octets des messages tunnel. Les garlic messages (format de messages agrégés spécifique à I2P) de niveau supérieur peuvent ajouter leur propre bourrage.\nFragmentation Pour éviter les attaques par marquage fondées sur la longueur des messages, les messages de tunnel ont une taille fixe de 1024 octets. Les charges utiles I2NP plus volumineuses sont fragmentées par la passerelle ; le point de terminaison réassemble les fragments dans un court délai d’expiration. Les routers peuvent réorganiser les fragments afin de maximiser l’efficacité du remplissage avant l’envoi.\nAlternatives supplémentaires Ajuster le traitement des tunnels en cours de route Trois possibilités ont été examinées :\nAutoriser un saut intermédiaire à mettre fin temporairement à un tunnel en accordant l’accès aux charges utiles déchiffrées. Autoriser les routers participants à « remixer » les messages en les envoyant par l’un de leurs propres tunnels sortants avant de passer au prochain saut. Permettre au créateur du tunnel de redéfinir dynamiquement le prochain saut d’un pair. Tunnels bidirectionnels L’utilisation de tunnels entrants et sortants distincts limite les informations qu’un même ensemble de pairs peut observer (par exemple, une requête GET par opposition à une réponse volumineuse). Les tunnels bidirectionnels simplifient la gestion des pairs, mais exposent intégralement les schémas de trafic dans les deux directions simultanément. Les tunnels unidirectionnels sont donc restés l’approche privilégiée.\nCanaux de retour et tailles variables Autoriser des tailles de messages de tunnel variables permettrait des canaux cachés entre des pairs agissant de concert (p. ex., en codant des données via des tailles ou des fréquences choisies). Des messages de taille fixe atténuent ce risque au prix d’un surcoût de bourrage supplémentaire.\nAlternatives pour la construction de tunnels Référence : Hashing it out in Public Ancienne méthode de compilation “parallèle” Avant la version 0.6.1.10, les requêtes de construction de tunnel étaient envoyées en parallèle à chaque participant. Cette méthode est documentée sur la ancienne page du tunnel .\nConstruction télescopique en une seule fois (méthode actuelle) L’approche moderne envoie les messages de construction de saut en saut à travers le tunnel partiellement construit. Bien que similaire au \u0026ldquo;telescoping\u0026rdquo; de Tor (construction de circuits en ajoutant les relais un par un), l’acheminement des messages de construction via des tunnels exploratoires réduit les fuites d’information.\nTélescopage « interactif » Construire un saut à la fois avec des allers-retours explicites permet aux pairs de compter les messages et d’inférer leur position dans le tunnel, donc cette approche a été rejetée.\nTunnels de gestion non exploratoires Une proposition était de maintenir un groupe distinct de tunnels de gestion dédiés au build traffic (trafic de construction de tunnels). Bien que cela puisse aider les routers partitionnés, cela a été jugé inutile avec une intégration réseau suffisante.\nAcheminement exploratoire (hérité) Avant la version 0.6.1.10, les requêtes de tunnel individuelles étaient chiffrées avec garlic encryption et acheminées via des tunnels exploratoires, les réponses revenant séparément. Cette stratégie a été remplacée par la one-shot telescoping method (méthode télescopique en une seule étape) actuelle.\nPoints à retenir Des messages de tunnel de taille fixe protègent contre le marquage basé sur la taille et les canaux clandestins, malgré le coût supplémentaire du bourrage. Des alternatives en matière de bourrage, de fragmentation et de stratégies de construction (build) ont été explorées, mais n\u0026rsquo;ont pas été adoptées au regard des compromis d’anonymat. La conception des tunnels continue d’équilibrer l’efficacité, l’observabilité et la résistance aux attaques de prédécesseur et de congestion. ","description":"Exploration historique du bourrage des tunnels, de la fragmentation et des stratégies de construction des tunnels","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"Discussion sur le tunnel","url":"/fr/docs/legacy/tunnel/"},{"categories":null,"content":"Discussion NTCP (protocole de transport chiffré sur TCP d\u0026rsquo;I2P) vs. SSU (mars 2007) Questions sur NTCP Adapté d\u0026rsquo;une conversation sur IRC entre zzz et cervantes.\nPourquoi NTCP est-il prioritaire par rapport à SSU alors que NTCP semble ajouter de la surcharge et de la latence ?\nNTCP offre généralement une meilleure fiabilité que l\u0026rsquo;implémentation SSU d\u0026rsquo;origine. Le streaming sur NTCP se heurte-t-il à l\u0026rsquo;effondrement classique du TCP-sur-TCP ?\nC\u0026rsquo;est possible, mais SSU était censé être l\u0026rsquo;option UDP légère et s\u0026rsquo;est révélé trop peu fiable en pratique. « NTCP (protocole de transport d\u0026rsquo;I2P) considéré nuisible » (zzz, 25 mars 2007) Résumé : la latence et la surcharge plus élevées de NTCP peuvent provoquer de la congestion, mais le routage privilégie NTCP parce que ses scores de bid (valeurs d\u0026rsquo;enchère) sont codés en dur à un niveau inférieur à ceux de SSU. L’analyse a soulevé plusieurs points :\nNTCP a actuellement un coût inférieur à SSU, si bien que les routers préfèrent NTCP, sauf si une session SSU est déjà établie. SSU met en œuvre des accusés de réception avec des temporisations strictement bornées et des statistiques ; NTCP s’appuie sur Java NIO TCP avec des temporisations de type RFC, potentiellement bien plus longues. La plupart du trafic (HTTP, IRC, BitTorrent) utilise la bibliothèque de streaming d’I2P, ce qui revient à superposer TCP à NTCP. Lorsque les deux couches retransmettent, un effondrement est possible. Les références classiques incluent TCP over TCP is a bad idea . Les temporisations de la bibliothèque de streaming sont passées de 10 s à 45 s dans la version 0.8 ; le délai d’expiration maximal de SSU est de 3 s, tandis que les délais d’expiration de NTCP sont supposés avoisiner 60 s (recommandation RFC). Les paramètres NTCP sont difficiles à inspecter de l’extérieur. Des observations sur le terrain en 2007 ont montré que le débit d’envoi d’i2psnark oscillait, ce qui suggère des épisodes périodiques d’effondrement par congestion. Des tests d’efficacité (en forçant la préférence pour SSU) ont réduit les rapports de surcharge de tunnel d’environ 3.5:1 à 3:1 et amélioré les métriques de streaming (taille de fenêtre, RTT, ratio envoi/accusé de réception). Propositions du fil de discussion de 2007 Inverser les priorités de transport pour que les routers préfèrent SSU (en restaurant i2np.udp.alwaysPreferred). Marquer le trafic de streaming afin que SSU n’offre une enchère plus faible que pour les messages marqués, sans compromettre l’anonymat. Resserrer les limites de retransmission de SSU pour réduire le risque d’effondrement. Étudier les sous-couches semi-fiables afin de déterminer si les retransmissions en dessous de la bibliothèque de streaming sont un bénéfice net. Réexaminer les files de priorité et les délais d’expiration—par exemple, augmenter les délais d’expiration du streaming au-delà de 45 s pour s’aligner sur NTCP. Réponse de jrandom (27 mars 2007) Principaux contre-arguments :\nNTCP existe parce que les premiers déploiements de SSU ont subi un effondrement dû à la congestion. Même des taux de retransmission modestes par saut peuvent exploser à travers des tunnels multi-sauts. Sans accusés de réception au niveau du tunnel, seule une fraction des messages reçoit un statut de livraison de bout en bout ; les échecs peuvent être silencieux. Le contrôle de congestion TCP bénéficie de plusieurs décennies d’optimisations ; NTCP en tire parti via des piles TCP matures. Les gains d’efficacité observés lorsqu’on privilégie SSU pourraient refléter le comportement de mise en file d’attente du router plutôt que des avantages intrinsèques du protocole. Des délais d’expiration de streaming plus longs amélioraient déjà la stabilité ; davantage d’observations et de données étaient encouragées avant des changements majeurs. Le débat a contribué à affiner les réglages de transport ultérieurs, mais il ne reflète pas l\u0026rsquo;architecture NTCP2/SSU2 moderne.\n","description":"Notes historiques comparant les transports NTCP et SSU et des idées d’optimisation proposées","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"Discussion sur NTCP","url":"/fr/docs/ntcp/"},{"categories":null,"content":"Héberger GitLab dans I2P est simple : exécutez le conteneur omnibus GitLab, exposez-le sur loopback, et transférez le trafic à travers un tunnel I2P. Les étapes ci-dessous reflètent la configuration utilisée pour git.idk.i2p mais fonctionnent pour toute instance auto-hébergée.\n1. Prérequis Debian ou une autre distribution Linux avec Docker Engine installé (sudo apt install docker.io ou docker-ce depuis le dépôt de Docker). Un routeur I2P (Java I2P ou i2pd) avec suffisamment de bande passante pour servir vos utilisateurs. Optionnel : une VM dédiée afin que GitLab et le routeur restent isolés de votre environnement de bureau. 2. Télécharger l\u0026rsquo;image GitLab docker pull gitlab/gitlab-ce:latest L\u0026rsquo;image officielle est construite à partir de couches de base Ubuntu et mise à jour régulièrement. Examinez le Dockerfile si vous avez besoin d\u0026rsquo;une assurance supplémentaire.\n3. Décider entre le pontage et I2P uniquement Les instances I2P uniquement ne contactent jamais les hôtes du clearnet. Les utilisateurs peuvent cloner des dépôts depuis d\u0026rsquo;autres services I2P mais pas depuis GitHub/GitLab.com. Cela maximise l\u0026rsquo;anonymat. Les instances pontées se connectent aux hébergeurs Git du clearnet via un proxy HTTP. Cela est utile pour cloner des projets publics dans I2P mais désanonymise les requêtes sortantes du serveur. Si vous choisissez le mode bridged, configurez GitLab pour utiliser un proxy HTTP I2P lié sur l\u0026rsquo;hôte Docker (par exemple http://172.17.0.1:4446). Le proxy router par défaut écoute uniquement sur 127.0.0.1 ; ajoutez un nouveau tunnel proxy lié à l\u0026rsquo;adresse de passerelle Docker.\n4. Démarrer le conteneur docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest Liez les ports publiés à loopback ; les tunnels I2P les exposeront selon les besoins. Remplacez /srv/gitlab/... par des chemins de stockage adaptés à votre hôte. Une fois le conteneur en cours d\u0026rsquo;exécution, visitez https://127.0.0.1:8443/, définissez un mot de passe administrateur et configurez les limites de compte.\n5. Exposer GitLab via I2P Créez trois tunnels serveur I2PTunnel :\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated Configurez chaque tunnel avec des longueurs de tunnel et une bande passante appropriées. Pour les instances publiques, 3 sauts avec 4 à 6 tunnels par direction constituent un bon point de départ. Publiez les destinations Base32/Base64 résultantes sur votre page d\u0026rsquo;accueil afin que les utilisateurs puissent configurer les tunnels clients. Destination Enforcement Si vous utilisez des tunnels HTTP(S), activez l\u0026rsquo;application de destination afin que seul le nom d\u0026rsquo;hôte prévu puisse atteindre le service. Cela empêche le tunnel d\u0026rsquo;être utilisé abusivement comme proxy générique.\n6. Maintenance Tips Exécutez docker exec gitlab gitlab-ctl reconfigure à chaque modification des paramètres GitLab. Surveillez l\u0026rsquo;utilisation du disque (/srv/gitlab/data)—les dépôts Git croissent rapidement. Sauvegardez régulièrement les répertoires de configuration et de données. Les tâches rake de sauvegarde de GitLab fonctionnent à l\u0026rsquo;intérieur du conteneur. Envisagez de placer un tunnel de surveillance externe en mode client pour garantir que le service est accessible depuis le réseau élargi. 6. Conseils de maintenance Intégrer I2P dans votre application Git sur I2P (guide client) Bundles Git pour réseaux hors ligne/lents Une instance GitLab bien configurée fournit un hub de développement collaboratif entièrement à l\u0026rsquo;intérieur d\u0026rsquo;I2P. Maintenez le router en bonne santé, restez à jour avec les mises à jour de sécurité de GitLab et coordonnez-vous avec la communauté à mesure que votre base d\u0026rsquo;utilisateurs grandit.\n","description":"Déploiement de GitLab dans I2P en utilisant Docker et un routeur I2P","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"Exécuter GitLab sur I2P","url":"/fr/docs/guides/gitlab/"},{"categories":null,"content":"Les filtres d’accès permettent aux opérateurs de serveur I2PTunnel d’autoriser, refuser ou limiter le débit des connexions entrantes en fonction de la Destination source et du taux récent de connexions. Le filtre est un fichier texte brut de règles. Le fichier est lu de haut en bas et la première règle correspondante prévaut.\nLes modifications apportées à la définition du filtre prennent effet au redémarrage du tunnel. Certaines versions peuvent relire les listes basées sur des fichiers à l’exécution, mais prévoyez un redémarrage pour garantir que les modifications sont appliquées.\nFormat de fichier Une règle par ligne. Les lignes vides sont ignorées. # commence un commentaire qui s\u0026rsquo;étend jusqu\u0026rsquo;à la fin de la ligne. Les règles sont évaluées dans l\u0026rsquo;ordre ; la première correspondance est utilisée. Seuils Un seuil définit combien de tentatives de connexion provenant d’une seule Destination sont autorisées dans une fenêtre temporelle glissante.\nNumérique: N/S signifie autoriser N connexions par période de S secondes. Exemple : 15/5 autorise jusqu\u0026rsquo;à 15 connexions toutes les 5 secondes. La tentative N+1 dans la fenêtre de temps est rejetée. Mots-clés: allow signifie aucune limite. deny signifie toujours rejeter. Syntaxe des règles Les règles prennent la forme suivante :\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; Où :\n\u0026lt;threshold\u0026gt; est N/S, allow, ou deny \u0026lt;scope\u0026gt; est l\u0026rsquo;un de default, explicit, file, ou record (voir ci-dessous) \u0026lt;target\u0026gt; dépend de la portée Règle par défaut S’applique si aucune autre règle ne correspond. Une seule règle par défaut est autorisée. Si elle est omise, les destinations inconnues sont autorisées sans restriction.\n15/5 default allow default deny default Règle explicite Cible une destination spécifique par son adresse Base32 (par exemple example1.b32.i2p) ou par sa clé complète.\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p Règle basée sur des fichiers Cible toutes les Destinations répertoriées dans un fichier externe. Chaque ligne contient une Destination ; les commentaires # et les lignes vides sont autorisés.\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt Note opérationnelle : Certaines implémentations relisent périodiquement les listes de fichiers. Si vous modifiez une liste pendant que le tunnel est en cours d’exécution, attendez-vous à un court délai avant que les modifications ne soient prises en compte. Redémarrez pour les appliquer immédiatement.\nEnregistreur (contrôle progressif) Un enregistreur surveille les tentatives de connexion et écrit dans un fichier les Destinations qui dépassent un seuil. Vous pouvez ensuite référencer ce fichier dans une règle file afin d’appliquer des limitations de débit ou des blocages aux tentatives ultérieures.\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt Vérifiez la prise en charge de l’enregistreur dans votre build avant de vous y fier. Utilisez des listes file pour un comportement garanti.\nOrdre d’évaluation Mettez d\u0026rsquo;abord les règles spécifiques, puis les règles générales. Un modèle courant :\nAutorisations explicites pour les pairs de confiance Refus explicites pour les utilisateurs abusifs connus Listes d\u0026rsquo;autorisation/interdiction basées sur des fichiers Enregistreurs pour une limitation progressive Règle par défaut servant de fourre-tout Exemple complet # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt Notes d\u0026rsquo;implémentation Le filtre d\u0026rsquo;accès fonctionne au niveau de la couche tunnel, avant le traitement applicatif, afin que le trafic abusif puisse être rejeté en amont. Placez le fichier de filtre dans votre répertoire de configuration I2PTunnel et redémarrez le tunnel pour appliquer les modifications. Partagez des listes basées sur des fichiers entre plusieurs tunnels si vous souhaitez une politique cohérente entre les services. ","description":"Syntaxe des fichiers de filtre du contrôle d'accès des tunnels","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"Format du filtre d'accès","url":"/fr/docs/specs/filter-format/"},{"categories":null,"content":"Vue d\u0026rsquo;ensemble Les plugins I2P sont des archives signées qui étendent les fonctionnalités du router. Ils sont fournis sous forme de fichiers .xpi2p ou .su3, s’installent dans ~/.i2p/plugins/\u0026lt;name\u0026gt;/ (ou %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\ sous Windows) et s’exécutent avec des permissions complètes du router, sans bac à sable.\nTypes de plugins pris en charge Applications web de la console Nouveaux eepsites avec cgi-bin, applications web Thèmes de la console Traductions de la console Programmes Java (dans le même processus ou JVM séparée) Scripts shell et binaires natifs Modèle de sécurité CRITIQUE: Les plugins s\u0026rsquo;exécutent dans la même JVM avec des permissions identiques à celles du router I2P. Ils ont un accès sans restriction à : - Système de fichiers (lecture et écriture) - API du router et état interne - Connexions réseau - Exécution de programmes externes\nLes plugins doivent être traités comme du code entièrement approuvé. Les utilisateurs doivent vérifier les sources et les signatures des plugins avant l’installation.\nFormats de fichiers Format SU3 (fortement recommandé) Statut: Actif, format préféré depuis I2P 0.9.15 (septembre 2014)\nLe format .su3 offre : - clés de signature RSA-4096 (contre DSA-1024 dans xpi2p) - Signature stockée dans l\u0026rsquo;en-tête du fichier - Nombre magique : I2Psu3 - Meilleure compatibilité avec les versions futures\nStructure:\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] Format XPI2P (hérité, déprécié) Statut: Pris en charge pour des raisons de rétrocompatibilité, non recommandé pour les nouveaux plugins\nLe format .xpi2p utilise d’anciennes signatures cryptographiques : - Signatures DSA-1024 (obsolètes selon NIST-800-57) - Signature DSA de 40 octets ajoutée en tête du ZIP - Nécessite le champ key dans plugin.config\nStructure:\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] Chemin de migration : Lors de la migration de xpi2p vers su3, fournissez à la fois updateURL et updateURL.su3 pendant la transition. Les routers modernes (0.9.15+) donnent automatiquement la priorité à SU3.\nStructure de l’archive et plugin.config Fichiers requis plugin.config - Fichier de configuration I2P standard avec des paires clé-valeur\nPropriétés requises Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format **Exemples de formats de version :** - `1.2.3` - `1.2.3-4` - `2.0.0-beta.1` Séparateurs valides : . (point), - (tiret), _ (tiret bas)\nPropriétés de métadonnées facultatives Afficher les informations date - Date de publication (horodatage long Java) author - Nom du développeur (user@mail.i2p recommandé) description - Description en anglais description_xx - Description localisée (xx = code de langue) websiteURL - Page d\u0026rsquo;accueil du plugin (http://foo.i2p/) license - Identifiant de licence (par exemple, \u0026ldquo;Apache-2.0\u0026rdquo;, \u0026ldquo;GPL-3.0\u0026rdquo;) Mettre à jour la configuration updateURL - Emplacement de mise à jour XPI2P (hérité) updateURL.su3 - Emplacement de mise à jour SU3 (recommandé) min-i2p-version - Version minimale d\u0026rsquo;I2P requise max-i2p-version - Version maximale d\u0026rsquo;I2P compatible min-java-version - Version minimale de Java (par ex., 1.7, 17) min-jetty-version - Version minimale de Jetty (utilisez 6 pour Jetty 6+) max-jetty-version - Version maximale de Jetty (utilisez 5.99999 pour Jetty 5) Comportement d\u0026rsquo;installation dont-start-at-install - Par défaut false. Si true, nécessite un démarrage manuel router-restart-required - Par défaut false. Indique à l’utilisateur qu’un redémarrage est nécessaire après la mise à jour update-only - Par défaut false. Échoue si le plug-in n’est pas déjà installé install-only - Par défaut false. Échoue si le plug-in existe déjà min-installed-version - Version minimale requise pour la mise à jour max-installed-version - Version maximale pouvant être mise à jour disableStop - Par défaut false. Masque le bouton d’arrêt si true Intégration à la console consoleLinkName - Texte du lien de la barre de résumé de la console consoleLinkName_xx - Texte de lien localisé (xx = code de langue) consoleLinkURL - Destination du lien (par ex. /appname/index.jsp) consoleLinkTooltip - Texte de l’info-bulle (pris en charge depuis 0.7.12-6) consoleLinkTooltip_xx - Info-bulle localisée console-icon - Chemin vers une icône 32x32 (pris en charge depuis 0.9.20) icon-code - PNG 32x32 encodé en Base64 pour les plugins sans ressources web (depuis 0.9.25) Exigences de plateforme (affichage uniquement) required-platform-OS - Exigence du système d’exploitation (non imposée) other-requirements - Exigences supplémentaires (p. ex., \u0026ldquo;Python 3.8+\u0026rdquo;) Gestion des dépendances (non implémentée) depends - Dépendances du plugin, séparées par des virgules depends-version - Exigences de version pour les dépendances langs - Contenu du pack de langue type - Type de plugin (app/theme/locale/webapp) Substitution de variables dans l’URL de mise à jour Statut de la fonctionnalité : Disponible depuis I2P 1.7.0 (0.9.53)\nLes deux updateURL et updateURL.su3 prennent en charge des variables spécifiques à la plateforme :\nVariables: - $OS - Système d\u0026rsquo;exploitation: windows, linux, mac - $ARCH - Architecture: 386, amd64, arm64\nExemple:\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 Résultat sur Windows AMD64 :\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 Cela permet d\u0026rsquo;utiliser des fichiers plugin.config uniques pour les compilations spécifiques à la plateforme.\nStructure des répertoires Disposition standard plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration Objectifs du répertoire console/locale/ - Fichiers JAR contenant des Resource bundles (fichiers de ressources) pour les traductions de base d\u0026rsquo;I2P - Les traductions spécifiques aux plugins doivent se trouver dans console/webapps/*.war ou lib/*.jar\nconsole/themes/ - Chaque sous-répertoire contient un thème de console complet - Ajouté automatiquement au chemin de recherche des thèmes\nconsole/webapps/ - fichiers .war pour l\u0026rsquo;intégration à la console - Démarrés automatiquement sauf s\u0026rsquo;ils sont désactivés dans webapps.config - Le nom du WAR n\u0026rsquo;a pas besoin de correspondre au nom du plugin\neepsite/ - eepsite complet avec sa propre instance Jetty - Nécessite une configuration jetty.xml avec substitution de variables - Voir les exemples de plug-ins zzzot et pebble\nlib/ - Bibliothèques JAR de plug-in - À spécifier dans le classpath via clients.config ou webapps.config\nConfiguration de l\u0026rsquo;application Web Format de webapps.config Fichier de configuration I2P standard régissant le comportement de l\u0026rsquo;application web.\nSyntaxe:\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar Notes importantes: - Avant router 0.7.12-9, utilisez plugin.warname.startOnLoad pour la compatibilité - Avant l\u0026rsquo;API 0.9.53, le classpath ne fonctionnait que si le warname (nom du fichier WAR) correspondait au nom du plugin - À partir de la 0.9.53+, le classpath fonctionne pour n\u0026rsquo;importe quel nom d\u0026rsquo;application web\nMeilleures pratiques pour les applications web Implémentation de ServletContextListener\nImplémenter javax.servlet.ServletContextListener pour le nettoyage Ou surcharger destroy() dans la servlet Garantit un arrêt correct lors des mises à jour et de l\u0026rsquo;arrêt du router Gestion des bibliothèques\nPlacez les JARs partagés dans lib/, pas à l’intérieur du WAR Référencez-les via le classpath de webapps.config Permet d’installer et de mettre à jour les plugins séparément Évitez les bibliothèques en conflit\nN\u0026rsquo;intégrez jamais Jetty, Tomcat ni des fichiers JAR de servlets N\u0026rsquo;intégrez jamais des fichiers JAR issus de l\u0026rsquo;installation standard d\u0026rsquo;I2P Consultez la section classpath (chemin des classes) pour les bibliothèques standard Exigences de compilation\nN\u0026rsquo;incluez pas de fichiers source .java ou .jsp Précompilez toutes les JSP pour éviter les retards au démarrage Ne présumez pas de la disponibilité d’un compilateur Java/JSP Compatibilité avec l\u0026rsquo;API Servlet\nI2P prend en charge Servlet 3.0 (depuis 0.9.30) L\u0026rsquo;analyse des annotations n\u0026rsquo;est PAS prise en charge (@WebContent) Doit fournir le descripteur de déploiement web.xml traditionnel Version de Jetty\nVersion actuelle : Jetty 9 (I2P 0.9.30+) Utilisez net.i2p.jetty.JettyStart pour l’abstraction Protège contre les modifications de l’API Jetty Configuration du client Format de clients.config Définit les clients (services) lancés avec le plugin.\nClient de base:\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties Client avec Arrêt/Désinstallation:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar Référence des propriétés Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths ### Substitution de variables Les variables suivantes sont remplacées dans args, stopargs, uninstallargs et classpath:\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 ### Clients gérés vs. non gérés Clients gérés (Recommandés depuis la version 0.9.4): - Instanciés par ClientAppManager (gestionnaire d’applications client) - Assurent le suivi des références et de l’état - Gestion du cycle de vie facilitée - Meilleure gestion de la mémoire\nClients non gérés : - Démarrés par le router, pas de suivi d\u0026rsquo;état - Doivent gérer proprement plusieurs appels start/stop - Utiliser un état statique ou des fichiers PID pour la coordination - Appelés à l\u0026rsquo;arrêt du router (à partir de la version 0.7.12-3)\nShellService (depuis la version 0.9.53 / 1.7.0) Solution généralisée pour exécuter des programmes externes avec suivi automatique de l’état.\nFonctionnalités: - Gère le cycle de vie des processus - Communique avec ClientAppManager - Gestion automatique du PID - Prise en charge multiplateforme\nUtilisation:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh Pour les scripts spécifiques à la plateforme:\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH Alternative (ancienne): Écrire un wrapper Java (adaptateur) qui vérifie le type de système d’exploitation (OS), et appeler ShellCommand avec le fichier .bat ou .sh approprié.\nProcédure d’installation Processus d’installation de l’utilisateur L’utilisateur colle l’URL du plugin dans la page de configuration des plugins de la Console du Router (/configplugins) Le Router télécharge le fichier du plugin Vérification de la signature (échoue si la clé est inconnue et que le mode strict est activé) Vérification de l’intégrité du ZIP Extraction et analyse de plugin.config Vérification de la compatibilité des versions (min-i2p-version, min-java-version, etc.) Détection d’un conflit de nom de l’application web Arrêt du plugin existant en cas de mise à jour Validation du répertoire (doit se trouver sous plugins/) Extraction de tous les fichiers vers le répertoire du plugin Mise à jour de plugins.config Démarrage du plugin (sauf si dont-start-at-install=true) Sécurité et confiance Gestion des clés: - Modèle de confiance « First-key-seen » (première clé vue) pour les nouveaux signataires - Seules les clés jrandom et zzz sont pré-intégrées - À partir de 0.9.14.1, les clés inconnues sont rejetées par défaut - Une propriété avancée peut outrepasser ce comportement pour le développement\nRestrictions d\u0026rsquo;installation : - Les archives doivent être extraites uniquement dans le répertoire du plugin - Le programme d\u0026rsquo;installation refuse les chemins en dehors de plugins/ - Les plugins peuvent accéder à des fichiers ailleurs après l\u0026rsquo;installation - Pas de sandboxing ni d\u0026rsquo;isolation des privilèges\nMécanisme de mise à jour Processus de vérification des mises à jour Router lit updateURL.su3 (préféré) ou updateURL depuis plugin.config Requête HTTP HEAD ou GET partielle pour récupérer les octets 41-56 Extraire la chaîne de version depuis le fichier distant Comparer avec la version installée en utilisant VersionComparator Si plus récente, demander à l\u0026rsquo;utilisateur ou télécharger automatiquement (selon les paramètres) Arrêter le plugin Installer la mise à jour Démarrer le plugin (à moins que la préférence de l\u0026rsquo;utilisateur n\u0026rsquo;ait changé) Comparaison des versions Versions analysées en composants séparés par des points/tirets/underscores (tirets bas): - 1.2.3 \u0026lt; 1.2.4 - 1.2.3 \u0026lt; 1.2.3-1 - 2.0.0 \u0026gt; 1.9.9\nLongueur maximale: 16 octets (doit correspondre à l’en-tête SUD/SU3)\nMeilleures pratiques de mise à jour Toujours incrémenter la version pour chaque publication Tester le parcours de mise à jour depuis la version précédente Prendre en compte router-restart-required pour les changements majeurs Fournir à la fois updateURL et updateURL.su3 pendant la migration Utiliser un suffixe de numéro de build pour les tests (1.2.3-456) Classpath et bibliothèques standard Toujours disponible dans le classpath Les fichiers JAR suivants de $I2P/lib sont toujours dans le classpath pour I2P 0.9.30+:\nJAR Contents Plugin Usage i2p.jarCore APIRequired for all plugins mstreaming.jarStreaming APIMost plugins need streaming.jarStreaming implementationMost plugins need i2ptunnel.jarI2PTunnelHTTP/server plugins router.jarRouter internalsRarely needed, avoid if possible javax.servlet.jarServlet 3.1, JSP 2.3 APIPlugins with servlets/JSPs jasper-runtime.jarJasper compiler/runtimePlugins with JSPs commons-el.jarEL 3.0 APIJSPs using expression language jetty-i2p.jarJetty utilitiesPlugins starting Jetty org.mortbay.jetty.jarJetty 9 baseCustom Jetty instances sam.jarSAM APIRarely needed addressbook.jarSubscription/blockfileUse NamingService instead routerconsole.jarConsole librariesNot public API, avoid jbigi.jarNative cryptoPlugins should not need systray.jarURL launcherRarely needed wrapper.jarService wrapperPlugins should not need ### Remarques particulières commons-logging.jar: - Vide depuis 0.9.30 - Avant 0.9.30: Apache Tomcat JULI - Avant 0.9.24: Commons Logging + JULI - Avant 0.9: Commons Logging uniquement\njasper-compiler.jar: - Vide depuis Jetty 6 (0.9)\nsystray4j.jar: - Retiré dans la version 0.9.26\nNon présent dans le Classpath (doit être spécifié) JAR Contents Usage jstl.jarStandard TaglibJSP tag libraries standard.jarStandard TaglibJSP tag libraries ### Spécification du classpath (chemin de classes Java) Dans clients.config :\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar Dans webapps.config:\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar Important: À partir de la 0.7.13-3, les classpath sont spécifiques à chaque thread, et non à l’échelle de la JVM. Spécifiez le classpath complet pour chaque client.\nExigences relatives à la version de Java Exigences actuelles (octobre 2025) I2P 2.10.0 et versions antérieures: - Minimum: Java 7 (requis depuis 0.9.24, janvier 2016) - Recommandé: Java 8 ou supérieur\nI2P 2.11.0 et ultérieures (À VENIR): - Minimum : Java 17+ (annoncé dans les notes de version 2.9.0) - Avertissement sur deux versions consécutives (2.9.0 → 2.10.0 → 2.11.0)\nStratégie de compatibilité des plugins Pour une compatibilité maximale (jusqu\u0026rsquo;à I2P 2.10.x):\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 Pour les fonctionnalités de Java 8+ :\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 Pour les fonctionnalités de Java 11+ :\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 Préparation pour 2.11.0+:\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 Meilleures pratiques de compilation Lors de la compilation avec un JDK plus récent pour une cible plus ancienne:\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; Cela empêche d\u0026rsquo;utiliser des API non disponibles dans la version cible de Java.\nCompression Pack200 - OBSOLÈTE Mise à jour critique : n\u0026rsquo;utilisez pas Pack200 Statut: DÉPRÉCIÉ ET SUPPRIMÉ\nLa spécification d’origine recommandait vivement la compression Pack200 pour une réduction de taille de 60 à 65 %. Cela n’est plus valable.\nChronologie: - JEP 336: Pack200 déprécié en Java 11 (septembre 2018) - JEP 367: Pack200 supprimé en Java 14 (mars 2020)\nLa spécification officielle des mises à jour I2P indique : \u0026gt; \u0026ldquo;Les fichiers JAR et WAR dans l\u0026rsquo;archive ZIP ne sont plus compressés avec pack200 comme documenté ci-dessus pour les fichiers \u0026lsquo;su2\u0026rsquo;, parce que les environnements d\u0026rsquo;exécution Java récents ne le prennent plus en charge.\u0026rdquo;\nQue faire :\nRetirez pack200 des processus de compilation immédiatement Utilisez la compression ZIP standard Envisagez des alternatives : ProGuard/R8 pour la réduction du code UPX pour les binaires natifs Algorithmes de compression modernes (zstd, brotli) si un décompresseur personnalisé est fourni Pour les plugins existants: - Anciens routers (0.7.11-5 jusqu\u0026rsquo;à Java 10) peuvent encore décompresser pack200 (format de compression Java) - Nouveaux routers (Java 11+) ne peuvent pas décompresser pack200 - Republiez les plugins sans compression pack200\nClés de signature et sécurité Génération de clés (format SU3) Utilisez le script makeplugin.sh du dépôt i2p.scripts :\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ Détails clés: - Algorithme: RSA_SHA512_4096 - Format: certificat X.509 - Stockage: format de keystore Java (magasin de clés)\nSignature des plugins # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 Bonnes pratiques de gestion des clés Générez une fois, protégez pour toujours\nLes Routers rejettent les noms de clé dupliqués avec des clés différentes Les Routers rejettent les clés dupliquées avec des noms de clé différents Mises à jour rejetées en cas de non-correspondance clé/nom Stockage sécurisé\nSauvegardez le magasin de clés en toute sécurité Utilisez une phrase de passe robuste Ne validez jamais dans le système de gestion de versions Rotation des clés\nNon pris en charge par l\u0026rsquo;architecture actuelle Planifier l\u0026rsquo;utilisation des clés à long terme Envisager des schémas multisignatures pour le développement en équipe Signature DSA héritée (XPI2P) Statut : Fonctionnel mais obsolète\nSignatures DSA-1024 utilisées par le format xpi2p: - signature de 40 octets - clé publique de 172 caractères en base64 - NIST-800-57 recommande (L=2048, N=224) au minimum - I2P utilise des paramètres plus faibles (L=1024, N=160)\nRecommandation : Utilisez plutôt SU3 avec RSA-4096.\nDirectives de développement des plugins Bonnes pratiques essentielles Documentation\nFournir un README clair avec des instructions d’installation Documenter les options de configuration et les valeurs par défaut Inclure un journal des modifications avec chaque version Préciser les versions d’I2P/Java requises Optimisation de la taille\nInclure uniquement les fichiers nécessaires Ne jamais inclure les fichiers JAR du router Séparer les paquets d’installation et de mise à jour (bibliothèques dans lib/) Utiliser la compression Pack200 OBSOLÈTE - Utiliser un ZIP standard Configuration\nNe jamais modifier plugin.config pendant l\u0026rsquo;exécution Utiliser un fichier de configuration distinct pour les paramètres d\u0026rsquo;exécution Documenter les paramètres nécessaires du router (ports SAM, tunnels, etc.) Respecter la configuration existante de l\u0026rsquo;utilisateur Utilisation des ressources\nÉviter une consommation de bande passante agressive par défaut Mettre en œuvre des limites raisonnables d\u0026rsquo;utilisation du CPU Libérer les ressources lors de l\u0026rsquo;arrêt Utiliser des threads daemon (threads de démon) le cas échéant Tests\nTester l’installation/la mise à niveau/la désinstallation sur toutes les plateformes Tester les mises à jour depuis la version précédente Vérifier l’arrêt/le redémarrage de l’application web pendant les mises à jour Tester avec la version minimale d’I2P prise en charge Système de fichiers\nN\u0026rsquo;écrivez jamais dans $I2P (peut être en lecture seule) Écrivez les données d\u0026rsquo;exécution dans $PLUGIN ou $CONFIG Utilisez I2PAppContext pour la découverte des répertoires Ne présumez pas de l\u0026rsquo;emplacement de $CWD Compatibilité\nNe dupliquez pas les classes I2P standard Étendez les classes si nécessaire, ne les remplacez pas Vérifiez min-i2p-version, min-jetty-version dans plugin.config Testez avec des versions I2P plus anciennes si vous les prenez en charge Gestion de l\u0026rsquo;arrêt\nConfigurer correctement les stopargs dans clients.config Enregistrer les hooks d\u0026rsquo;arrêt: I2PAppContext.addShutdownTask() Gérer proprement plusieurs appels de démarrage/arrêt Mettre tous les threads en mode démon Sécurité\nValidez toutes les entrées externes N\u0026rsquo;appelez jamais System.exit() Respectez la vie privée des utilisateurs Suivez les bonnes pratiques de codage sécurisé Licences\nSpécifier clairement la licence du plug-in Respecter les licences des bibliothèques intégrées Inclure les mentions d’attribution requises Fournir l’accès au code source si requis Considérations avancées Gestion des fuseaux horaires: - Router définit le fuseau horaire de la JVM sur UTC - Fuseau horaire réel de l\u0026rsquo;utilisateur : propriété I2PAppContext i2p.systemTimeZone\nDécouverte de l\u0026rsquo;annuaire:\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args Numérotation des versions: - Utiliser le versionnage sémantique (major.minor.patch) - Ajouter un numéro de build pour les tests (1.2.3-456) - Veiller à une progression strictement croissante des mises à jour\nAccès aux classes du router : - Évitez généralement les dépendances à router.jar - Utilisez plutôt les API publiques dans i2p.jar - De futures versions d\u0026rsquo;I2P pourraient restreindre l\u0026rsquo;accès aux classes du router\nPrévention des crashs de la JVM (historique): - Corrigé dans 0.7.13-3 - Utiliser correctement les chargeurs de classes - Éviter de mettre à jour des JAR dans un plugin en cours d\u0026rsquo;exécution - Concevoir pour permettre un redémarrage lors de la mise à jour si nécessaire\nGreffons pour Eepsite Aperçu Les plugins peuvent fournir des eepsites complets avec leurs propres instances Jetty (serveur web Java) et I2PTunnel.\nArchitecture N\u0026rsquo;essayez pas de : - Installer dans une eepsite (site hébergé sur I2P) existante - Fusionner avec l\u0026rsquo;eepsite par défaut du router - Supposer la disponibilité d\u0026rsquo;une seule eepsite\nAu lieu de: - Démarrer une nouvelle instance I2PTunnel (via l\u0026rsquo;interface en ligne de commande) - Démarrer une nouvelle instance Jetty - Configurer les deux dans clients.config\nStructure d\u0026rsquo;exemple plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] Substitution de variables dans jetty.xml Utilisez la variable $PLUGIN pour les chemins:\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; Router effectue une substitution lors du démarrage du plug-in.\nExemples Implémentations de référence : - zzzot plugin - Tracker de torrents - pebble plugin - Plateforme de blog\nTous deux sont disponibles sur la page des plugins de zzz (interne à I2P).\nIntégration à la console Liens de la barre de synthèse Ajouter un lien cliquable à la barre récapitulative de la console du router :\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface Versions localisées :\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle Icônes de la console Fichier image (depuis 0.9.20):\nconsole-icon=/myicon.png Chemin relatif à consoleLinkURL si spécifié (depuis la version 0.9.53), sinon relatif au nom de l’application web.\nIcône intégrée (depuis 0.9.25) :\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... Générer avec:\nbase64 -w 0 icon-32x32.png Ou Java:\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png Exigences: - 32x32 pixels - format PNG - encodé en Base64 (sans sauts de ligne)\nInternationalisation Ensembles de traduction Pour les traductions de base d\u0026rsquo;I2P : - Placez les JAR dans console/locale/ - Doivent contenir des resource bundles (fichiers de ressources) pour les applications I2P existantes - Nommage : messages_xx.properties (xx = code de langue)\nPour les traductions spécifiques aux plugins : - Inclure dans console/webapps/*.war - Ou inclure dans lib/*.jar - Utiliser la méthode standard ResourceBundle de Java\nChaînes localisées dans plugin.config description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble Champs pris en charge: - description_xx - consoleLinkName_xx - consoleLinkTooltip_xx\nTraduction du thème de la console Les thèmes dans console/themes/ sont automatiquement ajoutés au chemin de recherche des thèmes.\nPlugins spécifiques à la plateforme Approche par paquets séparés Utilisez des noms de plugins différents pour chaque plateforme:\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac Approche de substitution de variables Un seul plugin.config avec des variables de plateforme :\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 Dans clients.config:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH Détection du système d’exploitation à l’exécution Approche en Java pour l’exécution conditionnelle :\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } Dépannage Problèmes courants Le plugin ne démarre pas : 1. Vérifiez la compatibilité de la version I2P (min-i2p-version) 2. Vérifiez la version de Java (min-java-version) 3. Vérifiez les journaux du router pour détecter des erreurs 4. Vérifiez que tous les fichiers JAR requis sont dans le classpath (chemin de classes Java)\nApplication Web inaccessible : 1. Confirmez que webapps.config ne la désactive pas 2. Vérifiez la compatibilité de la version de Jetty (min-jetty-version) 3. Vérifiez que web.xml est présent (la recherche d’annotations n’est pas prise en charge) 4. Vérifiez qu’il n’y a pas de conflit de noms d’applications Web\nÉchec de la mise à jour : 1. Vérifiez que le numéro de version a été incrémenté 2. Vérifiez que la signature correspond à la clé de signature 3. Assurez-vous que le nom du plugin correspond à la version installée 4. Passez en revue les paramètres update-only/install-only\nImpossible d\u0026rsquo;arrêter le programme externe : 1. Utilisez ShellService pour une gestion automatique du cycle de vie 2. Implémentez une gestion correcte de stopargs 3. Vérifiez le nettoyage du fichier PID 4. Vérifiez la terminaison du processus\nJournalisation de débogage Activer la journalisation de débogage sur le router :\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG Consultez les journaux:\n~/.i2p/logs/log-router-0.txt Informations de référence Spécifications officielles Spécification des plugins Format de configuration Spécification des mises à jour Cryptographie Historique des versions d’I2P Version actuelle: - I2P 2.10.0 (8 septembre 2025)\nVersions majeures depuis 0.9.53: - 2.10.0 (sept. 2025) - annonce Java 17+ - 2.9.0 (juin 2025) - avertissement Java 17+ - 2.8.0 (oct. 2024) - tests de cryptographie post-quantique - 2.6.0 (mai 2024) - blocage d\u0026rsquo;I2P-over-Tor - 2.4.0 (déc. 2023) - améliorations de la sécurité de NetDB - 2.2.0 (mars 2023) - contrôle de congestion - 2.1.0 (janv. 2023) - améliorations du réseau - 2.0.0 (nov. 2022) - protocole de transport SSU2 - 1.7.0/0.9.53 (févr. 2022) - ShellService, substitution de variables - 0.9.15 (sept. 2014) - format SU3 introduit\nNumérotation des versions: - série 0.9.x: Jusqu\u0026rsquo;à la version 0.9.53 - série 2.x: À partir de la version 2.0.0 (introduction de SSU2, nouvelle version du transport SSU)\nRessources pour les développeurs Code source: - Dépôt principal: https://i2pgit.org/I2P_Developers/i2p.i2p - Miroir GitHub: https://github.com/i2p/i2p.i2p Exemples de plugins: - zzzot (tracker BitTorrent) - pebble (plateforme de blog) - i2p-bote (messagerie sans serveur) - orchid (client Tor) - seedless (échange de pairs)\nOutils de compilation: - makeplugin.sh - Génération et signature de clés - Disponible dans le dépôt i2p.scripts - Automatise la création et la vérification des fichiers su3 (format de mise à jour signé)\nAssistance communautaire Forums: - Forum I2P - zzz.i2p (interne à I2P)\nIRC/Chat: - #i2p-dev sur OFTC - I2P IRC au sein du réseau\nAnnexe A : Exemple complet de plugin.config # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space Annexe B : Exemple complet de clients.config # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config Annexe C : Exemple complet de webapps.config # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true Annexe D : Liste de contrôle de migration (de 0.9.53 à 2.10.0) Modifications requises Supprimer la compression Pack200 du processus de build\nSupprimer les tâches pack200 des scripts Ant/Maven/Gradle Republier les plug-ins existants sans pack200 Revoir les exigences de version de Java\nEnvisager d\u0026rsquo;exiger Java 11+ pour les nouvelles fonctionnalités Prévoir l\u0026rsquo;exigence de Java 17+ pour I2P 2.11.0 Mettre à jour min-java-version dans plugin.config Mettre à jour la documentation\nSupprimer les références à Pack200 Mettre à jour les exigences de version de Java Mettre à jour les références de version d\u0026rsquo;I2P (0.9.x → 2.x) Modifications recommandées Renforcer les signatures cryptographiques\nMigrer de XPI2P vers SU3 si ce n\u0026rsquo;est pas déjà fait Utiliser des clés RSA-4096 pour les nouveaux plugins Tirer parti des nouvelles fonctionnalités (si vous utilisez 0.9.53+)\nUtilisez les variables $OS / $ARCH pour des mises à jour spécifiques à la plateforme Utilisez ShellService pour les programmes externes Utilisez le classpath amélioré des applications web (fonctionne pour n\u0026rsquo;importe quel nom de WAR) Tester la compatibilité\nTester sur I2P 2.10.0 Vérifier avec Java 8, 11, 17 Tester sur Windows, Linux, macOS Améliorations facultatives Implémenter un ServletContextListener approprié (écouteur de contexte Servlet) Ajouter des descriptions localisées Fournir une icône pour la console Améliorer la gestion de l\u0026rsquo;arrêt Ajouter une journalisation complète Écrire des tests automatisés ","description":"Règles d'empaquetage .xpi2p / .su3 pour les plugins I2P","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"Format du paquet de plugin","url":"/fr/docs/specs/plugin/"},{"categories":null,"content":"Aperçu REMARQUE : OBSOLÈTE - Nous prenons désormais en charge trois formats, par ordre de préférence :\nMaxmind geoip2 (GeoLite2-Country.mmdb) fourni avec toutes les installations sauf les paquets Debian et Android Maxmind geoip1 (GeoIP.dat) dans le paquet Debian geoip-database Le format Tor IPv4 (geoip.txt) et le format IPv6 personnalisé (geoipv6.dat.gz) documentés ci-dessous, toujours pris en charge mais non utilisés. Cette page spécifie le format des différents fichiers GeoIP, utilisés par le router pour associer un pays à une adresse IP.\nFormat du nom de pays (countries.txt) Ce format peut être facilement généré à partir de fichiers de données disponibles auprès de nombreuses sources publiques. Par exemple :\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Spécifications du format :\nL\u0026rsquo;encodage est UTF-8 Le \u0026lsquo;#\u0026rsquo; dans la colonne 1 indique une ligne de commentaire Les lignes d\u0026rsquo;entrée sont CountryCode,CountryName CountryCode est le code ISO à deux lettres, en majuscules CountryName est en anglais Format IPv4 (geoip.txt) Ce format est emprunté à Tor et peut être facilement généré à partir de fichiers de données disponibles auprès de nombreuses sources publiques. Par exemple :\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Spécifications du format:\nL\u0026rsquo;encodage est ASCII \u0026lsquo;#\u0026rsquo; en colonne 1 indique une ligne de commentaire Les lignes d\u0026rsquo;entrée sont FromIP,ToIP,CountryCode FromIP et ToIP sont des représentations entières non signées de l\u0026rsquo;IP sur 4 octets CountryCode est le code ISO à deux lettres, en majuscules Les lignes d\u0026rsquo;entrée doivent être triées par la valeur numérique de FromIP Format IPv6 (geoipv6.dat.gz) Ceci est un format binaire compressé conçu pour I2P. Le fichier est compressé avec gzip. Format après décompression :\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) REMARQUES:\nLes données doivent être triées (long signé en complément à deux), sans chevauchement. L’ordre est donc 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF. La classe GeoIPv6.java contient un programme pour générer ce format à partir de sources publiques telles que les données GeoLite de Maxmind. La recherche GeoIP IPv6 est prise en charge à partir de la version 0.9.8. ","description":"Spécifications du format de fichier GeoIP hérité pour les recherches IP-vers-pays","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"Formats de fichiers GeoIP","url":"/fr/docs/legacy/formats-de-fichiers-geoip/"},{"categories":null,"content":"Lorsque les conditions réseau rendent git clone peu fiable, vous pouvez distribuer des dépôts sous forme de git bundles via BitTorrent ou tout autre moyen de transfert de fichiers. Un bundle est un fichier unique contenant l\u0026rsquo;intégralité de l\u0026rsquo;historique du dépôt. Une fois téléchargé, vous récupérez les données localement depuis celui-ci, puis vous rebasculez vers le dépôt distant en amont.\n1. Avant de commencer Générer un bundle nécessite un clone Git complet. Les clones superficiels créés avec --depth 1 produiront silencieusement des bundles défectueux qui semblent fonctionner mais échouent lorsque d\u0026rsquo;autres tentent de les utiliser. Récupérez toujours depuis une source fiable (GitHub à github.com/i2p/i2p.i2p , l\u0026rsquo;instance Gitea I2P à i2pgit.org , ou git.idk.i2p via I2P) et exécutez git fetch --unshallow si nécessaire pour convertir tout clone superficiel en clone complet avant de créer des bundles.\nSi vous ne faites que consommer un bundle existant, téléchargez-le simplement. Aucune préparation spéciale n\u0026rsquo;est requise.\n2. Télécharger un Bundle Obtaining the Bundle File Téléchargez le fichier bundle via BitTorrent en utilisant I2PSnark (le client torrent intégré dans I2P) ou d\u0026rsquo;autres clients compatibles I2P comme BiglyBT avec le plugin I2P.\nImportant : I2PSnark fonctionne uniquement avec les torrents spécifiquement créés pour le réseau I2P. Les torrents clearnet standards ne sont pas compatibles car I2P utilise des Destinations (adresses de 387+ octets) au lieu d\u0026rsquo;adresses IP et de ports.\nL\u0026rsquo;emplacement du fichier bundle dépend de votre type d\u0026rsquo;installation I2P :\nInstallations utilisateur/manuelles (installées avec l\u0026rsquo;installateur Java) : ~/.i2p/i2psnark/ Installations système/daemon (installées via apt-get ou gestionnaire de paquets) : /var/lib/i2p/i2p-config/i2psnark/ Les utilisateurs de BiglyBT trouveront les fichiers téléchargés dans leur répertoire de téléchargements configuré.\nCloning from the Bundle Méthode standard (fonctionne dans la plupart des cas) :\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle Si vous rencontrez des erreurs fatal: multiple updates for ref (un problème connu dans Git 2.21.0 et versions ultérieures lorsque la configuration globale de Git contient des refspecs de récupération conflictuelles), utilisez l\u0026rsquo;approche d\u0026rsquo;initialisation manuelle :\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle Alternativement, vous pouvez utiliser le drapeau --update-head-ok :\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; Obtention du fichier bundle Après avoir cloné à partir du bundle, pointez votre clone vers le dépôt distant en direct afin que les futures récupérations passent par I2P ou le clearnet :\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p Ou pour l\u0026rsquo;accès clearnet :\ngit remote set-url origin https://github.com/i2p/i2p.i2p Pour l\u0026rsquo;accès SSH via I2P, vous devez configurer un tunnel client SSH dans la console de votre routeur I2P (généralement le port 7670) pointant vers g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p. Si vous utilisez un port non standard :\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle Clonage depuis le Bundle Assurez-vous que votre dépôt est entièrement à jour avec un clone complet (pas superficiel) :\ngit fetch --all Si vous avez un clone superficiel, convertissez-le d\u0026rsquo;abord :\ngit fetch --unshallow Passage au Remote en Direct Utilisation de la cible de compilation Ant (recommandé pour l\u0026rsquo;arborescence source d\u0026rsquo;I2P) :\nant git-bundle Cela crée à la fois i2p.i2p.bundle (le fichier bundle) et i2p.i2p.bundle.torrent (les métadonnées BitTorrent).\nUtiliser git bundle directement :\ngit bundle create i2p.i2p.bundle --all Pour des bundles plus sélectifs :\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle Toujours vérifier le bundle avant de le distribuer :\ngit bundle verify i2p.i2p.bundle Cela confirme que le bundle est valide et affiche tous les commits prérequis nécessaires.\nPrérequis Copiez le bundle et ses métadonnées torrent dans votre répertoire I2PSnark :\nPour les installations utilisateur :\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ Pour les installations système :\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ I2PSnark détecte et charge automatiquement les fichiers .torrent en quelques secondes. Accédez à l\u0026rsquo;interface web à l\u0026rsquo;adresse http://127.0.0.1:7657/i2psnark pour commencer à partager.\n4. Creating Incremental Bundles Pour les mises à jour périodiques, créez des bundles incrémentaux contenant uniquement les nouveaux commits depuis le dernier bundle :\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master Les utilisateurs peuvent récupérer depuis le bundle incrémental s\u0026rsquo;ils possèdent déjà le dépôt de base :\ngit fetch /path/to/update.bundle Vérifiez toujours que les bundles incrémentaux affichent les commits prérequis attendus :\ngit bundle verify update.bundle 5. Updating After the Initial Clone Une fois que vous avez un dépôt fonctionnel à partir du bundle, traitez-le comme n\u0026rsquo;importe quel autre clone Git :\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master Ou pour des flux de travail plus simples :\ngit fetch origin git pull origin master 3. Créer un bundle Distribution résiliente : Les grands dépôts peuvent être partagés via BitTorrent, qui gère automatiquement les nouvelles tentatives, la vérification des morceaux et la reprise. Amorçage pair-à-pair : Les nouveaux contributeurs peuvent amorcer leur clone depuis des pairs proches sur le réseau I2P, puis récupérer les modifications incrémentales directement depuis les hôtes Git. Charge serveur réduite : Les miroirs peuvent publier des bundles périodiques pour réduire la pression sur les hôtes Git actifs, particulièrement utile pour les grands dépôts ou les conditions réseau lentes. Transport hors ligne : Les bundles fonctionnent sur n\u0026rsquo;importe quel transport de fichiers (clés USB, transferts directs, sneakernet), pas uniquement BitTorrent. Les bundles ne remplacent pas les remotes actifs. Ils fournissent simplement une méthode de bootstrap plus résiliente pour les clones initiaux ou les mises à jour majeures.\n7. Troubleshooting Génération du Bundle Problème : La création du bundle réussit mais les autres ne peuvent pas cloner à partir du bundle.\nCause : Votre clone source est superficiel (créé avec --depth).\nSolution : Convertir en clone complet avant de créer des bundles :\ngit fetch --unshallow Vérification de votre bundle Problème : fatal: multiple updates for ref lors du clonage depuis un bundle.\nCause : Git 2.21.0+ entre en conflit avec les refspecs de récupération globaux dans ~/.gitconfig.\nSolutions : 1. Utilisez l\u0026rsquo;initialisation manuelle : mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle 2. Utilisez le flag --update-head-ok : git fetch --update-head-ok /path/to/bundle '*:*' 3. Supprimez la configuration conflictuelle : git config --global --unset remote.origin.fetch\nDistribuer via I2PSnark Problème : git bundle verify signale des prérequis manquants.\nCause : Bundle incrémental ou clone source incomplet.\nSolution : Soit récupérer les commits prérequis, soit utiliser d\u0026rsquo;abord le bundle de base, puis appliquer les mises à jour incrémentales.\n","description":"Récupération et distribution de dépôts volumineux avec git bundle et BitTorrent","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"Git Bundles pour I2P","url":"/fr/docs/applications/git-bundle/"},{"categories":null,"content":"Cloner et pousser des dépôts au sein d\u0026rsquo;I2P utilise les mêmes commandes Git que vous connaissez déjà—votre client se connecte simplement via des tunnels I2P au lieu de TCP/IP. Ce guide explique comment configurer un compte, configurer les tunnels et gérer les connexions lentes.\nDémarrage rapide : L\u0026rsquo;accès en lecture seule fonctionne via le proxy HTTP : http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git. Suivez les étapes ci-dessous pour l\u0026rsquo;accès SSH en lecture/écriture.\n1. Créer un compte Choisissez un service Git I2P et inscrivez-vous :\nÀ l\u0026rsquo;intérieur d\u0026rsquo;I2P : http://git.idk.i2p Miroir Clearnet : https://i2pgit.org L\u0026rsquo;inscription peut nécessiter une approbation manuelle ; consultez la page d\u0026rsquo;accueil pour obtenir des instructions. Une fois approuvé, créez une bifurcation (fork) ou créez un dépôt afin d\u0026rsquo;avoir quelque chose pour tester.\n2. Configurer un client I2PTunnel (SSH) Ouvrez la console du routeur → I2PTunnel et ajoutez un nouveau tunnel Client. Entrez la destination du service (Base32 ou Base64). Pour git.idk.i2p, vous trouverez les destinations HTTP et SSH sur la page d\u0026rsquo;accueil du projet. Choisissez un port local (par exemple localhost:7442). Activez le démarrage automatique si vous prévoyez d\u0026rsquo;utiliser le tunnel fréquemment. L\u0026rsquo;interface utilisateur confirmera le nouveau tunnel et affichera son état. Lorsqu\u0026rsquo;il est en cours d\u0026rsquo;exécution, les clients SSH peuvent se connecter à 127.0.0.1 sur le port choisi.\n3. Cloner via SSH Utilisez le port du tunnel avec GIT_SSH_COMMAND ou une stanza de configuration SSH :\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git Si la première tentative échoue (les tunnels peuvent être lents), essayez un clone superficiel :\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow Configurer Git pour récupérer toutes les branches :\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin Conseils de performance Ajoutez un ou deux tunnels de secours dans l\u0026rsquo;éditeur de tunnels pour améliorer la résilience. Pour les tests ou les dépôts à faible risque, vous pouvez réduire la longueur du tunnel à 1 saut, mais soyez conscient du compromis sur l\u0026rsquo;anonymat. Conservez GIT_SSH_COMMAND dans votre environnement ou ajoutez une entrée dans ~/.ssh/config : Host git.i2p HostName 127.0.0.1 Port 7442 User git Ensuite, clonez en utilisant git clone git@git.i2p:namespace/project.git.\n4. Suggestions de flux de travail Adoptez un flux de travail de fork et branches courant sur GitLab/GitHub :\nDéfinir un dépôt distant upstream : git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p Maintenir votre master synchronisé : git pull upstream master Créer des branches de fonctionnalité pour les modifications : git checkout -b feature/new-thing Pousser les branches vers votre fork : git push origin feature/new-thing Soumettre une demande de fusion, puis effectuer un fast-forward du master de votre fork depuis upstream. 5. Rappels de confidentialité Git stocke les horodatages de commit dans votre fuseau horaire local. Pour forcer les horodatages UTC : git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; Utilisez git utccommit au lieu de git commit lorsque la confidentialité est importante.\nÉvitez d\u0026rsquo;incorporer des URL clearnet ou des adresses IP dans les messages de commit ou les métadonnées du dépôt si l\u0026rsquo;anonymat est une préoccupation. 6. Dépannage Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. Pour les scénarios avancés (mise en miroir de dépôts externes, distribution de bundles), consultez les guides associés : [Flux de travail avec les bundles Git](/docs/applications/git-bundle/) et [Héberger GitLab sur I2P](/docs/guides/gitlab/). ","description":"Connexion des clients Git aux services hébergés sur I2P tels que i2pgit.org","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"Git sur I2P","url":"/fr/docs/applications/git/"},{"categories":null,"content":"Ce glossaire définit les termes courants utilisés dans la documentation et les discussions I2P.\nB Blockchain Un registre distribué qui peut enregistrer des transactions entre plusieurs parties de manière efficace, vérifiable et permanente.\nD Décentralisation Architecture de réseau qui évite la dépendance envers une seule partie. Englobe les technologies pair-à-pair, blockchain, fédérées et distribuées.\nDestination L\u0026rsquo;identité cryptographique d\u0026rsquo;un tunnel. Ce sont les identités des clients et des serveurs au sein du réseau I2P.\nDHT (Distributed Hash Table) Utilisé dans certains projets pour connecter des pairs entre eux en stockant des informations sous forme de paires clé-valeur de manière distribuée.\nSystèmes Distribués Sujet académique en informatique concernant la conception de systèmes informatiques composés de nombreux ordinateurs individuels connectés via un réseau.\nF Fédéré La fédération permet à des déploiements distincts d\u0026rsquo;un service de communiquer entre eux via un protocole commun.\nH Hash Un nombre, généralement affiché sous forme d\u0026rsquo;une chaîne de lettres et de chiffres. Il peut servir d\u0026rsquo;« empreinte digitale » identifiant de manière unique des données.\nI I2P Invisible Internet Project : un projet destiné à fournir une couche d\u0026rsquo;anonymat, permettant aux utilisateurs de communiquer de manière anonyme en utilisant une gamme d\u0026rsquo;applications.\nAdresse IP Un numéro d\u0026rsquo;un ordinateur ou d\u0026rsquo;un réseau qui est unique et peut donc être utilisé pour l\u0026rsquo;adresser.\nL LeaseSet Un ensemble d\u0026rsquo;informations nécessaires pour communiquer avec un client ou un serveur à une Destination particulière.\nP Peer-to-Peer (P2P) Les pairs mettent une partie de leurs ressources directement à la disposition des autres participants du réseau, sans nécessiter de coordination centrale par des serveurs ou des hôtes stables.\nR Router Le logiciel I2P principal, qui achemine les paquets chiffrés sur le réseau I2P.\nRouterIdentity Un ensemble d\u0026rsquo;informations requises pour communiquer directement avec un router.\nT TCP/UDP Les deux protocoles de transport fondamentaux utilisés sur Internet.\nTunnel Un chemin de communication anonyme entre un client ou un serveur et le réseau I2P.\nU UX Expérience utilisateur, l\u0026rsquo;expérience globale d\u0026rsquo;une personne utilisant un produit ou un service.\nW WebRTC Un protocole standard pour établir des connexions dans un navigateur web où les données transitent directement entre les utilisateurs.\n","description":"Termes et définitions courants utilisés dans la documentation I2P","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"Glossaire","url":"/fr/docs/overview/glossaire/"},{"categories":null,"content":" Portée: Ce guide regroupe l’implémentation du tunnel, le format des messages, ainsi que les deux spécifications de création de tunnel (ECIES et ElGamal ancien). Les liens profonds existants continuent de fonctionner via les alias ci-dessus.\nModèle de Tunnel I2P achemine les charges utiles via tunnels unidirectionnels: des ensembles ordonnés de routers qui transportent le trafic dans une seule direction. Un aller-retour complet entre deux destinations nécessite quatre tunnels (deux sortants, deux entrants).\nCommencez par le Tunnel Overview pour la terminologie, puis utilisez ce guide pour les détails opérationnels.\nCycle de vie des messages La passerelle du tunnel regroupe un ou plusieurs messages I2NP, les fragmente et écrit les instructions de livraison. La passerelle encapsule la charge utile dans un message de tunnel de taille fixe (1024 B), en ajoutant du bourrage si nécessaire. Chaque participant vérifie le saut précédent, applique sa couche de chiffrement et transmet {nextTunnelId, nextIV, encryptedPayload} au saut suivant. Le point de terminaison du tunnel retire la couche finale, lit et applique les instructions de livraison, réassemble les fragments et achemine les messages I2NP reconstruits. La détection des doublons utilise un filtre de Bloom à vieillissement, dont la clé est dérivée de l’XOR du vecteur d’initialisation (IV) et du premier bloc chiffré, afin d’empêcher les attaques par marquage basées sur des échanges d’IV.\nRôles en un coup d’œil Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally ### Processus de chiffrement {#encryption-workflow} Tunnels entrants: la passerelle chiffre une fois avec sa clé de couche ; les participants en aval continuent à chiffrer jusqu’à ce que le créateur déchiffre la charge utile finale. Tunnels sortants: la passerelle préapplique l’inverse du chiffrement de chaque saut afin que chaque participant chiffre. Lorsque l’extrémité chiffre, le texte en clair d’origine de la passerelle est révélé. Les deux directions acheminent {tunnelId, IV, encryptedPayload} vers le prochain saut.\nFormat du message tunnel Les passerelles de tunnel fragmentent les messages I2NP en enveloppes de taille fixe afin de masquer la longueur de la charge utile et de simplifier le traitement à chaque saut.\nStructure chiffrée +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – identifiant sur 32 bits pour le prochain saut (non nul, renouvelé à chaque cycle de construction). IV – IV AES de 16 octets choisi pour chaque message. Charge utile chiffrée – 1008 octets de texte chiffré AES-256-CBC. Taille totale : 1028 octets.\nStructure déchiffrée Après qu\u0026rsquo;un relais a retiré sa couche de chiffrement :\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... Somme de contrôle vérifie l’intégrité du bloc déchiffré. Bourrage consiste en des octets aléatoires non nuls, terminés par un octet nul. Instructions de livraison indiquent au point de terminaison comment traiter chaque fragment (livrer localement, transférer vers un autre tunnel, etc.). Fragments transport les messages I2NP sous-jacents; le point de terminaison les réassemble avant de les transmettre aux couches supérieures. Étapes de traitement Les passerelles fragmentent et mettent en file d\u0026rsquo;attente les messages I2NP, en conservant brièvement les fragments partiels pour leur réassemblage. La passerelle chiffre la charge utile avec les clés de couche appropriées et inscrit l\u0026rsquo;ID du tunnel ainsi que le vecteur d\u0026rsquo;initialisation (IV). Chaque participant chiffre l\u0026rsquo;IV (AES-256/ECB) puis la charge utile (AES-256/CBC), avant de rechiffrer l\u0026rsquo;IV et de transmettre le message. Le point de terminaison déchiffre dans l\u0026rsquo;ordre inverse, vérifie la somme de contrôle, traite les instructions de remise et réassemble les fragments. Création de tunnel (ECIES-X25519) Les routers modernes construisent des tunnels avec des clés ECIES-X25519, réduisant la taille des messages de construction et permettant la confidentialité persistante.\nMessage de construction : un seul message I2NP TunnelBuild (ou VariableTunnelBuild) transporte 1 à 8 enregistrements de construction chiffrés, un par saut. Clés de couche : les créateurs dérivent, pour chaque saut, les clés de couche, d’IV et de réponse via HKDF (fonction de dérivation de clé basée sur HMAC) en utilisant l’identité X25519 statique du saut et la clé éphémère du créateur. Traitement : chaque saut déchiffre son enregistrement, valide les indicateurs de requête, écrit le bloc de réponse (succès ou code d’échec détaillé), rechiffre les enregistrements restants et transmet le message. Réponses : le créateur reçoit un message de réponse encapsulé via garlic encryption. Les enregistrements marqués comme ayant échoué incluent un code de gravité afin que le router puisse profiler le pair. Compatibilité : les routers peuvent encore accepter des constructions ElGamal héritées pour la rétrocompatibilité, mais les nouveaux tunnels utilisent ECIES par défaut. Pour les constantes champ par champ et les notes sur la dérivation de clés, voir l\u0026rsquo;historique de la proposition ECIES et le code source du router ; ce guide couvre le déroulement opérationnel.\nCréation de tunnel héritée (ElGamal-2048) Le format de construction de tunnel d’origine utilisait des clés publiques ElGamal. Les routers modernes conservent une prise en charge limitée pour la rétrocompatibilité.\nStatut : Obsolète. Conservé ici à titre de référence historique et pour toute personne assurant la maintenance d’outils compatibles avec les systèmes hérités.\nNon-interactive telescoping (télescopage non interactif): un seul message de construction parcourt l’intégralité du chemin. Chaque saut déchiffre son enregistrement de 528 octets, met à jour le message et le relaie. Longueur variable: le Variable Tunnel Build Message (VTBM) autorisait 1–8 enregistrements. Le message fixe antérieur contenait toujours huit enregistrements pour masquer la longueur du tunnel. Structure de l’enregistrement de requête: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding Drapeaux: le bit 7 indique une passerelle entrante (IBGW); le bit 6 marque une extrémité sortante (OBEP). Ils sont mutuellement exclusifs. Chiffrement: chaque enregistrement est chiffré en ElGamal-2048 avec la clé publique du saut. Une superposition symétrique AES-256-CBC garantit que seul le saut visé peut lire son enregistrement. Points clés: les ID de tunnel sont des valeurs 32 bits non nulles; les créateurs peuvent insérer des enregistrements factices pour masquer la longueur réelle du tunnel; la fiabilité dépend du réessai des constructions échouées. Pools de tunnels et cycle de vie Les routers maintiennent des pools de tunnels entrants et sortants indépendants pour le trafic exploratoire et pour chaque session I2CP.\nSélection des pairs : les tunnels exploratoires puisent dans le groupe de pairs “actifs, non défaillants” afin de favoriser la diversité ; les tunnels clients privilégient des pairs rapides et à haute capacité. Ordonnancement déterministe : les pairs sont triés selon la distance XOR entre SHA256(peerHash || poolKey) et la clé aléatoire du pool (groupe de tunnels). La clé est renouvelée au redémarrage, apportant de la stabilité au sein d’une exécution tout en contrariant les attaques du prédécesseur d’une exécution à l’autre. Cycle de vie : les routers suivent les temps de construction historiques par tuple {mode, direction, longueur, variance}. À l’approche de l’expiration des tunnels, les remplacements commencent tôt ; le router augmente les constructions parallèles en cas d’échecs tout en plafonnant les tentatives en cours. Paramètres de configuration : nombres de tunnels actifs/de secours, longueur de saut et variance, autorisations zero-hop (0 saut) et limites de cadence de construction sont tous réglables pour chaque pool. Congestion et fiabilité Bien que les tunnels ressemblent à des circuits, les routers les traitent comme des files d\u0026rsquo;attente de messages. L\u0026rsquo;élimination aléatoire anticipée pondérée (WRED) est utilisée pour maintenir la latence limitée:\nLa probabilité de rejet augmente à mesure que l’utilisation se rapproche des limites configurées. Les participants considèrent des fragments de taille fixe ; les passerelles/points d’extrémité rejettent en fonction de la taille combinée des fragments, en pénalisant en priorité les charges utiles volumineuses. Les points d’extrémité sortants rejettent avant les autres rôles afin de gaspiller le moins possible de ressources réseau. La remise garantie est laissée aux couches supérieures telles que la bibliothèque de streaming . Les applications qui exigent de la fiabilité doivent prendre en charge elles-mêmes la retransmission et les accusés de réception.\nPour aller plus loin Sélection des pairs Aperçu des Tunnels Ancienne implémentation des Tunnels ","description":"Spécification unifiée pour la construction, le chiffrement et le transport du trafic avec des tunnels I2P.","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"Guide d’exploitation des tunnels","url":"/fr/docs/specs/implementation/"},{"categories":null,"content":"Ce guide fournit un aperçu de la console du router I2P et de ses pages de configuration. Chaque section explique le rôle de la page et son utilité, vous aidant à comprendre comment surveiller et configurer votre router I2P.\nAccéder à la console du routeur La Console du Router I2P est le centre de contrôle pour gérer et surveiller votre router I2P. Par défaut, elle est accessible via la Console du Router I2P une fois votre router I2P en cours d\u0026rsquo;exécution.\nLa page d\u0026rsquo;accueil affiche plusieurs sections clés :\nApplications - Accès rapide aux applications I2P intégrées comme Email, Torrents, Gestionnaire de Services Cachés et Serveur Web Sites Communautaires I2P - Liens vers les ressources communautaires importantes incluant forums, documentation et sites web du projet Configuration et Aide - Outils pour configurer les paramètres de bande passante, gérer les plugins et accéder aux ressources d\u0026rsquo;aide Informations Réseau et Développeur - Accès aux graphiques, journaux, documentation technique et statistiques réseau Carnet d\u0026rsquo;adresses URL : Carnet d\u0026rsquo;adresses Le carnet d\u0026rsquo;adresses I2P fonctionne de manière similaire au DNS sur le clearnet, vous permettant de gérer des noms lisibles par l\u0026rsquo;homme pour les destinations I2P (eepsites). C\u0026rsquo;est ici que vous pouvez consulter et ajouter des adresses I2P à votre carnet d\u0026rsquo;adresses personnel.\nLe système de carnet d\u0026rsquo;adresses fonctionne à travers plusieurs couches :\nEnregistrements locaux - Vos carnets d\u0026rsquo;adresses personnels qui sont stockés uniquement sur votre routeur\nCarnet d\u0026rsquo;adresses local - Hôtes que vous ajoutez manuellement ou enregistrez pour votre usage personnel Carnet d\u0026rsquo;adresses privé - Adresses que vous ne souhaitez pas partager avec d\u0026rsquo;autres ; jamais distribuées publiquement Abonnements - Sources distantes de carnet d\u0026rsquo;adresses (comme http://i2p-projekt.i2p/hosts.txt) qui mettent automatiquement à jour le carnet d\u0026rsquo;adresses de votre router avec les sites I2P connus\nCarnet d\u0026rsquo;adresses du routeur - Le résultat fusionné de vos enregistrements locaux et de vos abonnements, consultable par toutes les applications I2P sur votre routeur\nCarnet d\u0026rsquo;adresses publié - Partage public optionnel de votre carnet d\u0026rsquo;adresses pour que d\u0026rsquo;autres puissent l\u0026rsquo;utiliser comme source d\u0026rsquo;abonnement (utile si vous hébergez un eepsite)\nLe carnet d\u0026rsquo;adresses interroge régulièrement vos abonnements et fusionne le contenu dans le carnet d\u0026rsquo;adresses de votre routeur, maintenant votre fichier hosts.txt à jour avec le réseau I2P.\nConfiguration URL : Configuration Avancée La section Configuration donne accès à tous les paramètres du routeur via plusieurs onglets spécialisés.\nAdvanced La page de configuration avancée permet d\u0026rsquo;accéder aux paramètres de bas niveau du routeur qui ne sont généralement pas nécessaires pour un fonctionnement normal. La plupart des utilisateurs ne doivent pas modifier ces paramètres à moins de comprendre l\u0026rsquo;option de configuration spécifique et son impact sur le comportement du routeur.\nFonctionnalités principales :\nConfiguration Floodfill - Contrôlez si votre routeur participe en tant que pair floodfill, ce qui aide le réseau en stockant et distribuant les informations de la base de données réseau (netDb). Cela peut utiliser davantage de ressources système mais renforce le réseau I2P.\nConfiguration I2P avancée - Accès direct au fichier router.config, affichant tous les paramètres de configuration avancés incluant :\nLimites de bande passante et paramètres de rafale Paramètres de transport (NTCP2, SSU2, ports UDP et clés) Identification du router et informations de version Préférences de la console et paramètres de mise à jour La plupart des options de configuration avancées ne sont pas exposées dans l\u0026rsquo;interface utilisateur car elles sont rarement nécessaires. Pour activer l\u0026rsquo;édition de ces paramètres, vous devez ajouter routerconsole.advanced=true à votre fichier router.config manuellement.\nAvertissement : La modification incorrecte des paramètres avancés peut avoir un impact négatif sur les performances ou la connectivité de votre router. Ne modifiez ces paramètres que si vous savez ce que vous faites.\nBandwidth URL : Configuration de la bande passante La page de configuration de la bande passante vous permet de contrôler la quantité de bande passante que votre router contribue au réseau I2P. I2P fonctionne mieux lorsque vous configurez vos débits pour qu\u0026rsquo;ils correspondent à la vitesse de votre connexion internet.\nParamètres Clés :\nKBps In - Bande passante entrante maximale que votre routeur acceptera (vitesse de téléchargement) KBps Out - Bande passante sortante maximale que votre routeur utilisera (vitesse de téléversement) Share - Pourcentage de votre bande passante sortante dédié au trafic de participation (aide au routage du trafic pour les autres) Notes importantes :\nToutes les valeurs sont en octets par seconde (Ko/s), et non en bits par seconde Plus vous allouez de bande passante, plus vous aidez le réseau et améliorez votre propre anonymat Votre quantité de partage en envoi (Ko/s sortant) détermine votre contribution globale au réseau Si vous n\u0026rsquo;êtes pas certain de la vitesse de votre réseau, utilisez le Test de bande passante pour la mesurer Une bande passante de partage plus élevée améliore à la fois votre anonymat et contribue à renforcer le réseau I2P La page de configuration affiche une estimation du transfert de données mensuel basée sur vos paramètres, vous aidant à planifier l\u0026rsquo;allocation de bande passante selon les limites de votre forfait internet.\nClient Configuration URL: Configuration du client La page de configuration client vous permet de contrôler quelles applications et services I2P s\u0026rsquo;exécutent au démarrage. C\u0026rsquo;est ici que vous pouvez activer ou désactiver les clients I2P intégrés sans les désinstaller.\nAvertissement Important : Soyez prudent lors de la modification des paramètres ici. La console du routeur et les tunnels d\u0026rsquo;application sont requis pour la plupart des utilisations d\u0026rsquo;I2P. Seuls les utilisateurs avancés devraient modifier ces paramètres.\nClients disponibles :\nTunnels d\u0026rsquo;application - Le système I2PTunnel qui gère les tunnels client et serveur (proxy HTTP, IRC, etc.) Console du routeur I2P - L\u0026rsquo;interface d\u0026rsquo;administration web que vous utilisez actuellement Serveur web I2P (eepsite) - Serveur web Jetty intégré pour héberger votre propre site web I2P Ouvrir la console du routeur dans le navigateur web au démarrage - Lance automatiquement votre navigateur vers la page d\u0026rsquo;accueil de la console Pont d\u0026rsquo;application SAM - Pont API permettant aux applications tierces de se connecter à I2P Chaque client affiche : - Exécuter au démarrage ? - Case à cocher pour activer/désactiver le démarrage automatique - Contrôle - Boutons Démarrer/Arrêter pour un contrôle immédiat - Classe et arguments - Détails techniques sur la façon dont le client est lancé\nLes modifications du paramètre « Exécuter au démarrage ? » nécessitent un redémarrage du router pour prendre effet. Toutes les modifications sont enregistrées dans /var/lib/i2p/i2p-config/clients.config.d/.\nAvancé URL: Configuration I2CP La page de configuration I2CP (I2P Client Protocol) vous permet de configurer la façon dont les applications externes se connectent à votre routeur I2P. I2CP est le protocole que les applications utilisent pour communiquer avec le routeur afin de créer des tunnels et d\u0026rsquo;envoyer/recevoir des données via I2P.\nImportant : Les paramètres par défaut fonctionneront pour la plupart des utilisateurs. Toute modification effectuée ici doit également être configurée dans l\u0026rsquo;application cliente externe. De nombreux clients ne prennent pas en charge SSL ou l\u0026rsquo;authentification. Toutes les modifications nécessitent un redémarrage pour prendre effet.\nOptions de Configuration :\nConfiguration de l\u0026rsquo;interface I2CP externe\nActivée sans SSL - Accès I2CP standard (par défaut et plus compatible) Activée avec SSL requis - Connexions I2CP chiffrées uniquement Désactivée - Bloque les clients externes de se connecter via I2CP Interface I2CP - L\u0026rsquo;interface réseau sur laquelle écouter (par défaut : 127.0.0.1 pour localhost uniquement)\nPort I2CP - Le numéro de port pour les connexions I2CP (par défaut : 7654)\nAutorisation\nExiger un nom d\u0026rsquo;utilisateur et un mot de passe - Activer l\u0026rsquo;authentification pour les connexions I2CP Nom d\u0026rsquo;utilisateur - Définir le nom d\u0026rsquo;utilisateur requis pour l\u0026rsquo;accès I2CP Mot de passe - Définir le mot de passe requis pour l\u0026rsquo;accès I2CP Note de sécurité : Si vous exécutez uniquement des applications sur la même machine que votre routeur I2P, conservez l\u0026rsquo;interface définie sur 127.0.0.1 pour empêcher l\u0026rsquo;accès distant. Ne modifiez ces paramètres que si vous devez autoriser des applications I2P provenant d\u0026rsquo;autres appareils à se connecter à votre routeur.\nBande passante URL: Configuration réseau La page de Configuration Réseau vous permet de configurer la manière dont votre router I2P se connecte à Internet, y compris la détection d\u0026rsquo;adresse IP, les préférences IPv4/IPv6, et les paramètres de port pour les transports UDP et TCP.\nAdresse IP accessible de l\u0026rsquo;extérieur :\nUtiliser toutes les méthodes de détection automatique - Détecte automatiquement votre IP publique en utilisant plusieurs méthodes (recommandé) Désactiver la détection d\u0026rsquo;adresse IP UPnP - Empêche l\u0026rsquo;utilisation d\u0026rsquo;UPnP pour découvrir votre IP Ignorer l\u0026rsquo;adresse IP de l\u0026rsquo;interface locale - Ne pas utiliser votre IP de réseau local Utiliser uniquement la détection d\u0026rsquo;adresse IP SSU - Utilise uniquement le transport SSU2 pour la détection d\u0026rsquo;IP Mode caché - ne pas publier l\u0026rsquo;IP - Empêche la participation au trafic réseau (réduit l\u0026rsquo;anonymat) Spécifier un nom d\u0026rsquo;hôte ou une IP - Définir manuellement votre IP publique ou nom d\u0026rsquo;hôte Configuration IPv4 :\nDésactiver les connexions entrantes (Derrière un pare-feu) - Cochez cette option si vous êtes derrière un pare-feu, un réseau domestique, un FAI, DS-Lite ou un NAT de niveau opérateur qui bloque les connexions entrantes Configuration IPv6 :\nPréférer IPv4 à IPv6 - Priorise les connexions IPv4 Préférer IPv6 à IPv4 - Priorise les connexions IPv6 (par défaut pour les réseaux double pile) Activer IPv6 - Autorise les connexions IPv6 Désactiver IPv6 - Désactive toute connectivité IPv6 Utiliser IPv6 uniquement (désactiver IPv4) - Mode IPv6 uniquement expérimental Désactiver les connexions entrantes (Derrière un pare-feu) - Cochez si votre IPv6 est derrière un pare-feu Action en cas de changement d\u0026rsquo;IP :\nMode portable - Fonctionnalité expérimentale qui modifie l\u0026rsquo;identité du routeur et le port UDP lorsque votre adresse IP change pour une anonymat renforcé Configuration UDP :\nSpécifier le port - Définir un port UDP spécifique pour le transport SSU2 (doit être ouvert dans votre pare-feu) Désactiver complètement - Sélectionner uniquement si vous êtes derrière un pare-feu qui bloque tout le trafic UDP sortant Configuration TCP :\nSpécifier le port - Définir un port TCP spécifique pour le transport NTCP2 (doit être ouvert dans votre pare-feu) Utiliser le même port configuré pour UDP - Simplifie la configuration en utilisant un seul port pour les deux transports Utiliser l\u0026rsquo;adresse IP détectée automatiquement - Détecte automatiquement votre IP publique (affiche « actuellement inconnue » si pas encore détectée ou bloquée par un pare-feu) Toujours utiliser l\u0026rsquo;adresse IP détectée automatiquement (Non protégé par un pare-feu) - Idéal pour les routeurs avec accès direct à Internet Désactiver les connexions entrantes (Protégé par un pare-feu) - Cochez si les connexions TCP sont bloquées par votre pare-feu Désactiver complètement - Ne sélectionnez que si vous êtes derrière un pare-feu qui limite ou bloque le TCP sortant Spécifier un nom d\u0026rsquo;hôte ou une IP - Configurer manuellement votre adresse accessible de l\u0026rsquo;extérieur Important : Les modifications des paramètres réseau peuvent nécessiter un redémarrage du router pour prendre pleinement effet. Une configuration appropriée de la redirection de port améliore considérablement les performances de votre router et contribue au réseau I2P.\nConfiguration du client URL : Configuration des pairs La page de Configuration des Pairs fournit des contrôles manuels pour gérer les pairs individuels sur le réseau I2P. Il s\u0026rsquo;agit d\u0026rsquo;une fonctionnalité avancée généralement utilisée uniquement pour résoudre les problèmes liés à des pairs problématiques.\nContrôles Manuels des Pairs :\nHash du routeur - Entrez le hash du routeur en base64 de 44 caractères du pair que vous souhaitez gérer Bannir / Débannir manuellement un pair :\nBannir un pair l\u0026rsquo;empêche de participer aux tunnels que vous créez. Cette action : - Empêche le pair d\u0026rsquo;être utilisé dans vos tunnels clients ou exploratoires - Prend effet immédiatement sans nécessiter de redémarrage - Persiste jusqu\u0026rsquo;à ce que vous débannissiez manuellement le pair ou redémarriez votre routeur - Bannir le pair jusqu\u0026rsquo;au redémarrage - Bloque temporairement le pair - Débannir le pair - Retire le bannissement d\u0026rsquo;un pair précédemment bloqué\nAjuster les bonus de profil :\nLes bonus de profil affectent la manière dont les pairs sont sélectionnés pour la participation aux tunnels. Les bonus peuvent être positifs ou négatifs : - Pairs rapides - Utilisés pour les tunnels client nécessitant une vitesse élevée - Pairs à haute capacité - Utilisés pour certains tunnels exploratoires nécessitant un routage fiable - Les bonus actuels sont affichés sur la page des profils\nConfiguration : - Vitesse - Ajuster le bonus de vitesse pour ce pair (0 = neutre) - Capacité - Ajuster le bonus de capacité pour ce pair (0 = neutre) - Ajuster les bonus de pairs - Appliquer les paramètres de bonus\nCas d\u0026rsquo;utilisation : - Bannir un pair qui cause régulièrement des problèmes de connexion - Exclure temporairement un pair que vous soupçonnez d\u0026rsquo;être malveillant - Ajuster les bonus pour dé-prioriser les pairs sous-performants - Déboguer les problèmes de construction de tunnel en excluant des pairs spécifiques\nRemarque : La plupart des utilisateurs n\u0026rsquo;auront jamais besoin d\u0026rsquo;utiliser cette fonctionnalité. Le routeur I2P gère automatiquement la sélection et le profilage des pairs en fonction des métriques de performance.\nConfiguration I2CP URL: Configuration Reseed La page de configuration du Reseed vous permet de réensemencer manuellement votre router si le réensemencement automatique échoue. Le réensemencement est le processus d\u0026rsquo;amorçage utilisé pour trouver d\u0026rsquo;autres routers lorsque vous installez I2P pour la première fois, ou lorsque votre router dispose de trop peu de références de routers restantes.\nQuand Utiliser le Reseeding Manuel :\nSi le réamorçage a échoué, vous devriez d\u0026rsquo;abord vérifier votre connexion réseau\nSi un pare-feu bloque vos connexions aux hôtes de réamorçage, vous pouvez avoir accès à un proxy :\nLe proxy peut être un proxy public distant, ou peut s\u0026rsquo;exécuter sur votre ordinateur (localhost) Pour utiliser un proxy, configurez le type, l\u0026rsquo;hôte et le port dans la section Configuration du réamorçage Si vous utilisez Tor Browser, réamorcez à travers celui-ci en configurant SOCKS 5, localhost, port 9150 Si vous utilisez Tor en ligne de commande, réamorcez à travers celui-ci en configurant SOCKS 5, localhost, port 9050 Si vous avez quelques pairs mais en avez besoin de davantage, vous pouvez essayer l\u0026rsquo;option I2P Outproxy. Laissez l\u0026rsquo;hôte et le port vides. Cela ne fonctionnera pas pour un réamorçage initial lorsque vous n\u0026rsquo;avez aucun pair Ensuite, cliquez sur « Enregistrer les modifications et réamorcer maintenant » Les paramètres par défaut fonctionneront pour la plupart des utilisateurs. Modifiez-les uniquement si HTTPS est bloqué par un pare-feu restrictif et que le réamorçage a échoué Si vous connaissez et faites confiance à quelqu\u0026rsquo;un qui utilise I2P, demandez-lui de vous envoyer un fichier reseed généré à partir de cette page sur sa console router. Ensuite, utilisez cette page pour effectuer un reseed avec le fichier que vous avez reçu. D\u0026rsquo;abord, sélectionnez le fichier ci-dessous. Puis, cliquez sur « Reseed depuis un fichier »\nSi vous connaissez et faites confiance à quelqu\u0026rsquo;un qui publie des fichiers reseed, demandez-lui l\u0026rsquo;URL. Ensuite, utilisez cette page pour effectuer un reseed avec l\u0026rsquo;URL que vous avez reçue. D\u0026rsquo;abord, saisissez l\u0026rsquo;URL ci-dessous. Puis, cliquez sur « Reseed depuis une URL »\nVoir la FAQ pour les instructions sur le reseeding manuel\nOptions de Reseed manuel :\nReseed depuis URL - Entrez une URL zip ou su3 provenant d\u0026rsquo;une source de confiance et cliquez sur \u0026ldquo;Reseed from URL\u0026rdquo;\nLe format su3 est préférable, car il sera vérifié comme étant signé par une source de confiance Le format zip n\u0026rsquo;est pas signé ; utilisez un fichier zip uniquement depuis une source en qui vous avez confiance Reseed depuis un fichier - Parcourez et sélectionnez un fichier zip ou su3 local, puis cliquez sur \u0026ldquo;Reseed from file\u0026rdquo;\nVous pouvez trouver des fichiers reseed sur checki2p.com/reseed Créer un fichier Reseed - Générer un nouveau fichier zip reseed que vous pouvez partager pour que d\u0026rsquo;autres puissent reseed manuellement\nCe fichier ne contiendra jamais l\u0026rsquo;identité ou l\u0026rsquo;IP de votre propre router Configuration du Reseeding :\nLes paramètres par défaut fonctionneront pour la plupart des utilisateurs. Modifiez-les uniquement si HTTPS est bloqué par un pare-feu restrictif et que le reseed a échoué.\nURL de reseed - Liste des URL HTTPS vers les serveurs de reseed (la liste par défaut est intégrée et régulièrement mise à jour) Configuration du proxy - Configurez un proxy HTTP/HTTPS/SOCKS si vous devez accéder aux serveurs de reseed via un proxy Réinitialiser la liste d\u0026rsquo;URL - Restaurer la liste par défaut des serveurs de reseed Important : Le réamorçage manuel ne devrait être nécessaire que dans de rares cas où le réamorçage automatique échoue de façon répétée. La plupart des utilisateurs n\u0026rsquo;auront jamais besoin d\u0026rsquo;utiliser cette page.\nConfiguration Réseau URL : Configuration de la famille de routeurs La page de configuration de la famille de routeurs vous permet de gérer les familles de routeurs. Les routeurs d\u0026rsquo;une même famille partagent une clé de famille, qui les identifie comme étant exploités par la même personne ou organisation. Cela empêche la sélection de plusieurs routeurs que vous contrôlez pour le même tunnel, ce qui réduirait l\u0026rsquo;anonymat.\nQu\u0026rsquo;est-ce qu\u0026rsquo;une famille de routeurs ?\nLorsque vous exploitez plusieurs routeurs I2P, vous devez les configurer pour qu\u0026rsquo;ils fassent partie de la même famille. Cela garantit : - Vos routeurs ne seront pas utilisés ensemble dans le même chemin de tunnel - Les autres utilisateurs maintiennent un anonymat approprié lorsque leurs tunnels utilisent vos routeurs - Le réseau peut distribuer correctement la participation aux tunnels\nFamille actuelle :\nLa page affiche le nom de famille actuel de votre routeur. Si vous ne faites pas partie d\u0026rsquo;une famille, ce champ sera vide.\nExporter la clé de famille :\nExportez la clé de famille secrète pour l\u0026rsquo;importer dans d\u0026rsquo;autres routeurs que vous contrôlez Cliquez sur « Export Family Key » pour télécharger votre fichier de clé de famille Importez cette clé sur vos autres routeurs pour les ajouter à la même famille Quitter la famille de routeur :\nNe plus être membre de la famille Cliquez sur « Quitter la famille » pour retirer ce routeur de sa famille actuelle Cette action ne peut pas être annulée sans réimporter la clé de famille Considérations importantes :\nEnregistrement public requis : Pour que votre famille soit reconnue sur l\u0026rsquo;ensemble du réseau, votre clé de famille doit être ajoutée au code source d\u0026rsquo;I2P par l\u0026rsquo;équipe de développement. Cela garantit que tous les routeurs du réseau connaissent votre famille. Contactez l\u0026rsquo;équipe I2P pour enregistrer votre clé de famille si vous exploitez plusieurs routeurs publics La plupart des utilisateurs n\u0026rsquo;exécutant qu\u0026rsquo;un seul routeur n\u0026rsquo;auront jamais besoin d\u0026rsquo;utiliser cette fonctionnalité La configuration de famille est principalement utilisée par les opérateurs de plusieurs routeurs publics ou les fournisseurs d\u0026rsquo;infrastructure Cas d\u0026rsquo;Usage :\nExploiter plusieurs routeurs I2P pour la redondance Exécuter une infrastructure comme des serveurs reseed ou des outproxies sur plusieurs machines Gérer un réseau de routeurs I2P pour une organisation Configuration des pairs URL : Configuration des tunnels La page de Configuration des Tunnels vous permet d\u0026rsquo;ajuster les paramètres par défaut des tunnels pour les tunnels exploratoires (utilisés pour la communication du routeur) et les tunnels clients (utilisés par les applications). Les paramètres par défaut conviennent à la plupart des utilisateurs et ne devraient être modifiés que si vous comprenez les compromis.\nAvertissements importants :\n⚠️ Compromis Anonymat vs Performance : Il existe un compromis fondamental entre l\u0026rsquo;anonymat et la performance. Des tunnels de plus de 3 hops (par exemple 2 hops + 0-2 hops, 3 hops + 0-1 hops, 3 hops + 0-2 hops), ou une quantité élevée + quantité de secours, peuvent réduire considérablement la performance ou la fiabilité. Une utilisation élevée du CPU et/ou de la bande passante sortante peut en résulter. Modifiez ces paramètres avec prudence et ajustez-les si vous rencontrez des problèmes.\n⚠️ Persistance : Les modifications des paramètres des tunnels exploratoires sont enregistrées dans le fichier router.config. Les modifications des tunnels clients sont temporaires et ne sont pas sauvegardées. Pour effectuer des modifications permanentes des tunnels clients, consultez la page I2PTunnel .\nTunnels exploratoires :\nLes tunnels exploratoires sont utilisés par votre routeur pour communiquer avec la base de données réseau (netDb) et participer au réseau I2P.\nOptions de configuration pour l\u0026rsquo;Inbound et l\u0026rsquo;Outbound : - Length - Nombre de sauts dans le tunnel (par défaut : 2-3 sauts) - Randomization - Variance aléatoire de la longueur du tunnel (par défaut : 0-1 sauts) - Quantity - Nombre de tunnels actifs (par défaut : 2 tunnels) - Backup quantity - Nombre de tunnels de secours prêts à être activés (par défaut : 0 tunnels)\nTunnels Client pour le Serveur Web I2P :\nCes paramètres contrôlent les tunnels pour le serveur web I2P intégré (eepsite).\n⚠️ AVERTISSEMENT D\u0026rsquo;ANONYMAT - Les paramètres incluent des tunnels à 1 saut. ⚠️ AVERTISSEMENT DE PERFORMANCE - Les paramètres incluent des quantités élevées de tunnels.\nOptions de configuration pour l\u0026rsquo;Entrant et le Sortant : - Longueur - Longueur du tunnel (par défaut : 1 saut pour le serveur web) - Randomisation - Variance aléatoire dans la longueur du tunnel - Quantité - Nombre de tunnels actifs - Quantité de sauvegarde - Nombre de tunnels de sauvegarde\nTunnels client pour les clients partagés :\nCes paramètres s\u0026rsquo;appliquent aux applications clientes partagées (proxy HTTP, IRC, etc.).\nOptions de configuration pour l\u0026rsquo;Entrant et le Sortant : - Longueur - Longueur du tunnel (par défaut : 3 sauts) - Randomisation - Variance aléatoire dans la longueur du tunnel - Quantité - Nombre de tunnels actifs - Quantité de sauvegarde - Nombre de tunnels de sauvegarde\nComprendre les paramètres de tunnel :\nLongueur : Des tunnels plus longs offrent plus d\u0026rsquo;anonymat mais réduisent les performances et la fiabilité Randomisation : Ajoute de l\u0026rsquo;imprévisibilité aux chemins des tunnels, améliorant la sécurité Quantité : Plus de tunnels améliorent la fiabilité et la distribution de charge mais augmentent l\u0026rsquo;utilisation des ressources Quantité de secours : Tunnels pré-construits prêts à remplacer les tunnels défaillants, améliorant la résilience Bonnes pratiques :\nConservez les paramètres par défaut sauf si vous avez des besoins spécifiques N\u0026rsquo;augmentez la longueur des tunnels que si l\u0026rsquo;anonymat est critique et que vous pouvez accepter une performance plus lente Augmentez la quantité/sauvegarde uniquement si vous rencontrez des échecs de tunnel fréquents Surveillez les performances du router après avoir effectué des modifications Cliquez sur « Enregistrer les modifications » pour appliquer les changements Configuration du Reseed URL: Configuration de l\u0026rsquo;interface utilisateur La page de configuration de l\u0026rsquo;interface utilisateur vous permet de personnaliser l\u0026rsquo;apparence et l\u0026rsquo;accessibilité de votre console du router, y compris la sélection du thème, les préférences linguistiques et la protection par mot de passe.\nThème de la Console du Routeur :\nChoisissez entre les thèmes sombre et clair pour l\u0026rsquo;interface de la console du router : - Sombre - Thème en mode sombre (plus confortable pour les yeux dans les environnements peu éclairés) - Clair - Thème en mode clair (apparence traditionnelle)\nOptions de thème supplémentaires : - Définir le thème universellement pour toutes les applications - Appliquer le thème sélectionné à toutes les applications I2P, pas seulement à la console du routeur - Forcer l\u0026rsquo;utilisation de la console mobile - Utiliser l\u0026rsquo;interface optimisée pour mobile même sur les navigateurs de bureau - Intégrer les applications Email et Torrent dans la console - Intégrer Susimail et I2PSnark directement dans l\u0026rsquo;interface de la console au lieu de les ouvrir dans des onglets séparés\nLangue de la Console du Routeur :\nSélectionnez votre langue préférée pour l\u0026rsquo;interface de la console du routeur dans le menu déroulant. I2P prend en charge de nombreuses langues, notamment l\u0026rsquo;anglais, l\u0026rsquo;allemand, le français, l\u0026rsquo;espagnol, le russe, le chinois, le japonais et bien d\u0026rsquo;autres.\nContributions aux traductions bienvenues : Si vous remarquez des traductions incomplètes ou incorrectes, vous pouvez aider à améliorer I2P en contribuant au projet de traduction. Contactez les développeurs sur #i2p-dev via IRC ou consultez le rapport d\u0026rsquo;état des traductions (lien disponible sur la page).\nMot de passe de la Console du Router :\nAjoutez une authentification par nom d\u0026rsquo;utilisateur et mot de passe pour protéger l\u0026rsquo;accès à votre console router :\nNom d\u0026rsquo;utilisateur - Saisissez le nom d\u0026rsquo;utilisateur pour l\u0026rsquo;accès à la console Mot de passe - Saisissez le mot de passe pour l\u0026rsquo;accès à la console Ajouter un utilisateur - Créer un nouvel utilisateur avec les identifiants spécifiés Supprimer la sélection - Supprimer les comptes utilisateur existants Pourquoi ajouter un mot de passe ?\nEmpêche l\u0026rsquo;accès local non autorisé à votre console du routeur Essentiel si plusieurs personnes utilisent votre ordinateur Recommandé si votre console du routeur est accessible sur votre réseau local Protège votre configuration I2P et vos paramètres de confidentialité contre toute modification Note de sécurité : La protection par mot de passe n\u0026rsquo;affecte que l\u0026rsquo;accès à l\u0026rsquo;interface web de la console du routeur à l\u0026rsquo;adresse I2P Router Console . Elle ne chiffre pas le trafic I2P et n\u0026rsquo;empêche pas les applications d\u0026rsquo;utiliser I2P. Si vous êtes le seul utilisateur de votre ordinateur et que la console du routeur n\u0026rsquo;écoute que sur localhost (par défaut), un mot de passe peut ne pas être nécessaire.\nConfiguration de la famille de routeurs URL : Configuration WebApp La page de configuration WebApp vous permet de gérer les applications web Java qui s\u0026rsquo;exécutent dans votre routeur I2P. Ces applications sont démarrées par le client webConsole et s\u0026rsquo;exécutent dans la même JVM que le routeur, fournissant des fonctionnalités intégrées accessibles via la console du routeur.\nQu\u0026rsquo;est-ce que les WebApps ?\nLes WebApps sont des applications basées sur Java qui peuvent être : - Des applications complètes (par ex. I2PSnark pour les torrents) - Des interfaces pour d\u0026rsquo;autres clients qui doivent être activés séparément (par ex. Susidns, I2PTunnel) - Des applications web sans interface web (par ex. carnet d\u0026rsquo;adresses)\nNotes importantes :\nUne webapp peut être complètement désactivée, ou elle peut simplement être désactivée au démarrage Supprimer un fichier war du répertoire webapps désactive complètement la webapp Cependant, le fichier .war et le répertoire de la webapp réapparaîtront lorsque vous mettrez à jour votre routeur vers une version plus récente Pour désactiver définitivement une webapp : Désactivez-la ici, ce qui est la méthode recommandée WebApps disponibles :\nWebApp Description i2psnark Torrents - Built-in BitTorrent client for I2P i2ptunnel Hidden Services Manager - Configure client and server tunnels imagegen Identification Image Generator - Creates unique identicons jsonrpc jsonrpc.war - JSON-RPC API interface (disabled by default) routerconsole I2P Router Console - The main administrative interface susidns Address Book - Manage I2P addresses and subscriptions susimail Email - Web-based email client for I2P Contrôles : Pour chaque webapp : - Démarrer au lancement ? - Case à cocher pour activer/désactiver le démarrage automatique - Contrôle - Boutons Démarrer/Arrêter pour un contrôle immédiat - Arrêter - Arrête la webapp en cours d\u0026rsquo;exécution - Démarrer - Démarre une webapp arrêtée\nBoutons de configuration :\nAnnuler - Abandonner les modifications et retourner à la page précédente Enregistrer la configuration WebApp - Enregistrer vos modifications et les appliquer Cas d\u0026rsquo;usage :\nArrêtez I2PSnark si vous n\u0026rsquo;utilisez pas de torrents pour économiser des ressources Désactivez jsonrpc si vous n\u0026rsquo;avez pas besoin d\u0026rsquo;un accès API Arrêtez Susimail si vous utilisez un client de messagerie externe Arrêtez temporairement les webapps pour libérer de la mémoire ou résoudre des problèmes Conseil de performance : Désactiver les applications web inutilisées peut réduire l\u0026rsquo;utilisation de la mémoire et améliorer les performances du router, en particulier sur les systèmes à ressources limitées.\nHelp URL : Aide La page d\u0026rsquo;aide fournit une documentation complète et des ressources pour vous aider à comprendre et utiliser I2P efficacement. Elle sert de point central pour le dépannage, l\u0026rsquo;apprentissage et l\u0026rsquo;obtention d\u0026rsquo;assistance.\nCe que vous trouverez :\nGuide de démarrage rapide - Informations essentielles pour les nouveaux utilisateurs qui découvrent I2P Foire aux questions (FAQ) - Réponses aux questions courantes sur l\u0026rsquo;installation, la configuration et l\u0026rsquo;utilisation d\u0026rsquo;I2P Dépannage - Solutions aux problèmes courants et aux problèmes de connectivité Documentation technique - Informations détaillées sur les protocoles, l\u0026rsquo;architecture et les spécifications d\u0026rsquo;I2P Guides d\u0026rsquo;application - Instructions pour utiliser les applications I2P comme les torrents, le courrier électronique et les services cachés Informations sur le réseau - Comprendre le fonctionnement d\u0026rsquo;I2P et ce qui le rend sécurisé Ressources d\u0026rsquo;assistance - Liens vers les forums, les canaux IRC et le support communautaire Obtenir de l\u0026rsquo;aide :\nSi vous rencontrez des problèmes avec I2P : 1. Consultez la FAQ pour les questions et réponses courantes 2. Examinez la section de dépannage pour votre problème spécifique 3. Visitez le forum I2P sur i2pforum.i2p ou i2pforum.net 4. Rejoignez le canal IRC #i2p pour un support communautaire en temps réel 5. Recherchez dans la documentation pour des informations techniques détaillées\nAstuce : La page d\u0026rsquo;aide est toujours accessible depuis la barre latérale de la console du routeur, ce qui facilite l\u0026rsquo;accès à l\u0026rsquo;assistance à tout moment.\nPerformance Graphs URL : Graphiques de performance La page Graphiques de Performance fournit une surveillance visuelle en temps réel des performances de votre router I2P et de l\u0026rsquo;activité réseau. Ces graphiques vous aident à comprendre l\u0026rsquo;utilisation de la bande passante, les connexions aux pairs, la consommation de mémoire et la santé globale du router.\nGraphiques disponibles :\nUtilisation de la bande passante\nDébit d\u0026rsquo;envoi bas niveau (octets/sec) - Débit du trafic sortant Débit de réception bas niveau (octets/sec) - Débit du trafic entrant Affiche l\u0026rsquo;utilisation actuelle, moyenne et maximale de la bande passante Permet de surveiller si vous approchez de vos limites de bande passante configurées Pairs actifs\nrouter.activePeers moyenné sur 60 sec - Nombre de pairs avec lesquels vous communiquez activement Indique l\u0026rsquo;état de santé de votre connectivité réseau Plus de pairs actifs signifie généralement une meilleure construction de tunnels et participation au réseau Utilisation de la mémoire du routeur\nrouter.memoryUsed moyenné sur 60 sec - Consommation mémoire de la JVM Affiche l\u0026rsquo;utilisation mémoire actuelle, moyenne et maximale en Mo Utile pour identifier les fuites mémoire ou déterminer si vous devez augmenter la taille du tas Java Configurer l\u0026rsquo;affichage du graphique :\nPersonnalisez l\u0026rsquo;affichage et le rafraîchissement des graphiques :\nTaille du graphique - Définir la largeur (par défaut : 400 pixels) et la hauteur (par défaut : 100 pixels) Période d\u0026rsquo;affichage - Plage de temps à afficher (par défaut : 60 minutes) Délai de rafraîchissement - Fréquence de mise à jour des graphiques (par défaut : 5 minutes) Type de tracé - Choisir entre l\u0026rsquo;affichage des moyennes ou des événements Masquer la légende - Supprimer la légende des graphiques pour gagner de l\u0026rsquo;espace UTC - Utiliser l\u0026rsquo;heure UTC au lieu de l\u0026rsquo;heure locale sur les graphiques Persistance - Stocker les données des graphiques sur disque pour l\u0026rsquo;analyse historique Options avancées :\nCliquez sur [Select Stats] pour choisir les statistiques à représenter graphiquement : - Métriques des tunnels (taux de réussite de construction, nombre de tunnels, etc.) - Statistiques de la base de données réseau (netDb) - Statistiques de transport (NTCP2, SSU2) - Performance des tunnels clients - Et bien d\u0026rsquo;autres métriques détaillées\nCas d\u0026rsquo;usage :\nSurveiller la bande passante pour vous assurer de ne pas dépasser vos limites configurées Vérifier la connectivité des pairs lors du dépannage de problèmes réseau Suivre l\u0026rsquo;utilisation de la mémoire pour optimiser les paramètres de heap Java Identifier les tendances de performance au fil du temps Diagnostiquer les problèmes de construction de tunnel en corrélant les graphiques Conseil : Cliquez sur « Enregistrer les paramètres et redessiner les graphiques » après avoir effectué des modifications pour appliquer votre configuration. Les graphiques se rafraîchiront automatiquement en fonction de votre paramètre de délai de rafraîchissement.\n","description":"Guide complet pour comprendre et configurer la Console du Routeur I2P","id":"c46f1b6edeab9b686fd57cf9b311df1c","section":"docs","title":"Guide de configuration de la console du routeur","url":"/fr/docs/guides/router-console-config/"},{"categories":null,"content":"Les routers I2P rencontrent le plus souvent des problèmes en raison de problèmes de redirection de port, d’une allocation de bande passante insuffisante et d’un temps d’amorçage insuffisant. Ces trois facteurs représentent plus de 70 % des problèmes signalés. Le router nécessite au moins 10 à 15 minutes après le démarrage pour s’intégrer complètement au réseau, une bande passante minimale de 128 KB/sec (256 KB/sec recommandé), et une redirection de port UDP/TCP correcte pour atteindre un statut non filtré par pare-feu. Les nouveaux utilisateurs s’attendent souvent à une connectivité immédiate et redémarrent prématurément, ce qui réinitialise la progression de l’intégration et crée un cycle frustrant. Ce guide fournit des solutions détaillées pour tous les principaux problèmes I2P affectant les versions 2.10.0 et ultérieures.\nL’architecture d’anonymat d’I2P sacrifie par nature de la vitesse au profit de la confidentialité grâce à des tunnels chiffrés multi-sauts. Comprendre cette conception fondamentale aide les utilisateurs à définir des attentes réalistes et à dépanner efficacement, plutôt que d’interpréter à tort un comportement normal comme des problèmes.\nLe Router ne démarre pas ou plante immédiatement Les échecs de démarrage les plus courants proviennent de conflits de ports, d\u0026rsquo;incompatibilité de version de Java ou de fichiers de configuration corrompus. Avant d\u0026rsquo;approfondir le diagnostic, vérifiez si une autre instance d\u0026rsquo;I2P est déjà en cours d\u0026rsquo;exécution.\nVérifiez l\u0026rsquo;absence de processus en conflit :\nLinux: ps aux | grep i2p ou netstat -tulpn | grep 7657\nWindows: Gestionnaire des tâches → Détails → recherchez java.exe avec i2p dans la ligne de commande\nmacOS: Moniteur d’activité → recherchez « i2p »\nSi un processus zombie existe, tuez-le : pkill -9 -f i2p (Linux/Mac) ou taskkill /F /IM javaw.exe (Windows)\nVérifiez la compatibilité de la version de Java :\nI2P 2.10.0+ nécessite Java 8 minimum. Il est recommandé d\u0026rsquo;utiliser Java 11 ou une version ultérieure. Vérifiez que votre installation affiche \u0026ldquo;mixed mode\u0026rdquo; (et non \u0026ldquo;interpreted mode\u0026rdquo;):\njava -version Devrait afficher : OpenJDK ou Oracle Java, version 8+, \u0026ldquo;mixed mode\u0026rdquo;\nÀ éviter : GNU GCJ, implémentations Java obsolètes, modes uniquement interprétés\nConflits de ports fréquents surviennent lorsque plusieurs services se disputent les ports par défaut d\u0026rsquo;I2P. La console du router (nœud I2P) (7657), I2CP (7654), SAM (7656) et le proxy HTTP (4444) doivent être disponibles. Vérifiez la présence de conflits : netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (Windows) ou lsof -i :7657,4444,7654 (Linux/Mac).\nLa corruption du fichier de configuration se manifeste par des plantages immédiats avec des erreurs d\u0026rsquo;analyse syntaxique dans les journaux. Router.config exige un encodage UTF-8 sans BOM, utilise = comme séparateur (et non :), et interdit certains caractères spéciaux. Sauvegardez puis examinez : ~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS).\nPour réinitialiser la configuration tout en préservant l\u0026rsquo;identité : Arrêtez I2P, sauvegardez router.keys et le répertoire keyData, supprimez router.config, redémarrez. Le router régénère la configuration par défaut.\nAllocation du heap (tas mémoire) Java trop faible entraîne des plantages OutOfMemoryError. Modifiez wrapper.config et augmentez wrapper.java.maxmemory de la valeur par défaut 128 ou 256 à 512 minimum (1024 pour les routers à haut débit). Cela nécessite un arrêt complet, attendre 11 minutes, puis un redémarrage - cliquer sur \u0026ldquo;Restart\u0026rdquo; dans la console n\u0026rsquo;appliquera pas la modification.\nRésolution du statut \u0026ldquo;Network: Firewalled\u0026rdquo; Le statut Firewalled (derrière un pare-feu) signifie que le router ne peut pas recevoir de connexions entrantes directes, ce qui oblige à s’appuyer sur des introducers (pairs introducteurs). Bien que le router fonctionne dans cet état, les performances se dégradent fortement et la contribution au réseau reste minimale. Pour atteindre un statut non-Firewalled, il faut configurer correctement la redirection de ports.\nLe router sélectionne aléatoirement un port entre 9000 et 31000 pour les communications. Trouvez votre port à l\u0026rsquo;adresse http://127.0.0.1:7657/confignet - cherchez \u0026ldquo;UDP Port\u0026rdquo; et \u0026ldquo;TCP Port\u0026rdquo; (généralement le même numéro). Vous devez rediriger à la fois UDP et TCP pour des performances optimales, bien que l\u0026rsquo;UDP seul permette une fonctionnalité de base.\nActiver la redirection automatique via UPnP (méthode la plus simple):\nAccédez à http://127.0.0.1:7657/confignet Cochez \u0026ldquo;Enable UPnP\u0026rdquo; Enregistrez les modifications et redémarrez le router Attendez 5-10 minutes et vérifiez que le statut passe de \u0026ldquo;Network: Firewalled\u0026rdquo; à \u0026ldquo;Network: OK\u0026rdquo; UPnP nécessite la prise en charge par le router (activée par défaut sur la plupart des routers grand public fabriqués après 2010) et une configuration réseau appropriée.\nRedirection de port manuelle (requise lorsque l\u0026rsquo;UPnP échoue):\nNotez votre port I2P depuis http://127.0.0.1:7657/confignet (p. ex., 22648) Trouvez votre adresse IP locale: ipconfig (Windows), ip addr (Linux), Préférences Système → Réseau (macOS) Accédez à l\u0026rsquo;interface d\u0026rsquo;administration de votre router (généralement 192.168.1.1 ou 192.168.0.1) Accédez à Transfert de port (peut se trouver sous Avancé, NAT ou Serveurs virtuels) Créez deux règles: Port externe: [votre port I2P] → IP interne: [votre ordinateur] → Port interne: [le même] → Protocole: UDP Port externe: [votre port I2P] → IP interne: [votre ordinateur] → Port interne: [le même] → Protocole: TCP Enregistrez la configuration et redémarrez votre router si nécessaire Vérifiez la redirection de port à l’aide d’outils de test en ligne après la configuration. Si la détection échoue, vérifiez les paramètres du pare-feu - le pare-feu du système ainsi que tout pare-feu d’antivirus doivent autoriser le port I2P.\nAlternative en mode masqué pour les réseaux restrictifs où la redirection de port est impossible : Activez-la sur http://127.0.0.1:7657/confignet → cochez \u0026ldquo;Hidden mode\u0026rdquo;. Le router reste derrière un pare-feu mais s’adapte à cet état en utilisant exclusivement des SSU introducers (nœuds introducteurs). Les performances seront réduites, mais cela restera fonctionnel.\nRouter bloqué dans les états \u0026ldquo;Démarrage\u0026rdquo; ou \u0026ldquo;Test\u0026rdquo; Ces états transitoires durant l’amorçage initial se résolvent généralement en 10-15 minutes pour les nouvelles installations ou 3-5 minutes pour les routers établis. Une intervention prématurée aggrave souvent les problèmes.\n\u0026ldquo;Network: Testing\u0026rdquo; indique que le router sonde la joignabilité via différents types de connexions (direct, introducers (nœuds d’introduction), plusieurs versions du protocole). Ceci est normal pendant les 5 à 10 premières minutes après le démarrage. Le router teste plusieurs scénarios afin de déterminer la configuration optimale.\n\u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; apparaît pendant l\u0026rsquo;amorçage lorsque le router ne dispose pas d\u0026rsquo;informations suffisantes sur les pairs. Le router ne participera pas au trafic de relais tant qu\u0026rsquo;il ne sera pas suffisamment intégré. Ce message devrait disparaître au bout de 10 à 20 minutes, une fois que netDb contiendra des informations sur plus de 50 routers.\nLe décalage d’horloge tue les tests de joignabilité. I2P exige que l’heure système soit à ±60 secondes de l’heure du réseau. Un écart dépassant 90 secondes entraîne un rejet automatique des connexions. Synchronisez l’horloge de votre système :\nLinux: sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows : Panneau de configuration → Date et heure → Heure Internet → Mettre à jour maintenant → Activer la synchronisation automatique\nmacOS : Préférences Système → Date et heure → Activer \u0026ldquo;Régler la date et l’heure automatiquement\u0026rdquo;\nAprès avoir corrigé le décalage de l’horloge, redémarrez complètement I2P afin d’assurer une intégration correcte.\nAllocation de bande passante insuffisante empêche la réussite des tests. Le router a besoin d’une capacité adéquate pour construire des tunnels de test. Configurez sur http://127.0.0.1:7657/config:\nMinimum viable: Entrant 96 KB/sec, Sortant 64 KB/sec Standard recommandé: Entrant 256 KB/sec, Sortant 128 KB/sec Performances optimales: Entrant 512+ KB/sec, Sortant 256+ KB/sec Pourcentage de partage: 80 % (permet au router de fournir de la bande passante au réseau) Une bande passante plus faible peut fonctionner, mais elle fait passer le temps d’intégration de quelques minutes à plusieurs heures.\nnetDb corrompue suite à un arrêt incorrect ou à des erreurs de disque entraîne des boucles de test perpétuelles. Le router ne peut pas terminer les tests sans données de pairs valides:\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start Windows: Supprimez le contenu de %APPDATA%\\I2P\\netDb\\ ou de %LOCALAPPDATA%\\I2P\\netDb\\\nPare-feu bloquant le réensemencement empêche l’acquisition des pairs initiaux. Pendant le bootstrap (amorçage), I2P récupère les informations du router depuis des serveurs de réensemencement HTTPS. Les pare-feux d’entreprise ou de FAI peuvent bloquer ces connexions. Configurez le proxy de réensemencement à l’adresse http://127.0.0.1:7657/configreseed si vous opérez derrière des réseaux restrictifs.\nDébits lents, dépassements de délai et échecs de construction de tunnels La conception d’I2P entraîne intrinsèquement des vitesses 3 à 10 fois plus lentes que sur le clearnet en raison du chiffrement à plusieurs sauts, de la surcharge des paquets et de l’imprévisibilité du routage. La construction d’un tunnel parcourt plusieurs routers, chacun ajoutant de la latence. Le comprendre évite de prendre un comportement normal pour des problèmes.\nAttentes de performances typiques:\nNavigation sur les sites .i2p : chargement initial des pages en 10 à 30 secondes, plus rapide après l\u0026rsquo;établissement du tunnel Téléchargement de torrents via I2PSnark : 10-100 Ko/s par torrent, selon le nombre de sources (seeders) et les conditions du réseau Téléchargements de gros fichiers : patience requise - des fichiers de l\u0026rsquo;ordre du mégaoctet peuvent prendre des minutes, ceux de l\u0026rsquo;ordre du gigaoctet des heures Première connexion la plus lente : la construction du tunnel prend 30-90 secondes ; les connexions suivantes utilisent les tunnels existants Taux de réussite d\u0026rsquo;établissement de tunnel indique l\u0026rsquo;état de santé du réseau. Consultez http://127.0.0.1:7657/tunnels:\nSupérieur à 60 % : Fonctionnement normal et sain 40-60 % : Marginal, envisager d’augmenter la bande passante ou de réduire la charge Inférieur à 40 % : Problématique - indique une bande passante insuffisante, des problèmes de réseau ou une sélection de pairs médiocre Augmentez l’allocation de bande passante comme première optimisation. La plupart des lenteurs proviennent d’un manque de bande passante. À l’adresse http://127.0.0.1:7657/config, augmentez les limites progressivement et surveillez les graphiques à l’adresse http://127.0.0.1:7657/graphs.\nPour DSL/Câble (connexions de 1 à 10 Mbps): - Entrant: 400 Ko/s - Sortant: 200 Ko/s - Partage: 80% - Mémoire: 384 Mo (modifier wrapper.config)\nPour les connexions haut débit (10-100+ Mbps): - Entrant: 1500 KB/sec - Sortant: 1000 KB/sec - Partage: 80-100% - Mémoire: 512-1024 MB - À envisager: augmenter le nombre de tunnels participants à 2000-5000 à http://127.0.0.1:7657/configadvanced\nOptimisez la configuration des tunnels pour de meilleures performances. Accédez aux paramètres spécifiques des tunnels à l’adresse http://127.0.0.1:7657/i2ptunnel et modifiez chaque tunnel :\nQuantité de tunnel: Augmenter de 2 à 3-4 (plus de chemins disponibles) Quantité de secours: Régler sur 1-2 (basculement rapide si un tunnel tombe en panne) Longueur de tunnel: 3 sauts par défaut offrent un bon équilibre; réduire à 2 améliore la vitesse mais diminue l’anonymat La bibliothèque cryptographique native (jbigi) offre des performances 5 à 10 fois supérieures à celles du chiffrement Java pur. Vérifiez qu’elle est chargée sur http://127.0.0.1:7657/logs - recherchez \u0026ldquo;jbigi loaded successfully\u0026rdquo; ou \u0026ldquo;Using native CPUID implementation\u0026rdquo;. Si rien n’apparaît :\nLinux: Généralement détecté automatiquement et chargé depuis ~/.i2p/jbigi-*.so Windows: Vérifiez la présence de jbigi.dll dans le répertoire d\u0026rsquo;installation d\u0026rsquo;I2P S\u0026rsquo;il manque: Installez les outils de compilation et compilez à partir des sources, ou téléchargez des binaires précompilés depuis les dépôts officiels\nMaintenez le router en fonctionnement en continu. Chaque redémarrage réinitialise l\u0026rsquo;intégration et nécessite 30 à 60 minutes pour reconstruire le réseau de tunnels et les relations avec les pairs. Les routers stables à haute disponibilité bénéficient d\u0026rsquo;une sélection préférentielle pour la construction de tunnels, créant une boucle de rétroaction positive sur les performances.\nUtilisation élevée du processeur et de la mémoire Une utilisation excessive des ressources indique généralement une allocation mémoire insuffisante, des bibliothèques cryptographiques natives manquantes, ou un engagement excessif dans la participation au réseau. Les routers bien configurés devraient consommer 10-30 % de CPU lors d’une utilisation active et maintenir une utilisation mémoire stable en dessous de 80 % du heap (tas mémoire) alloué.\nLes problèmes de mémoire se manifestent par : - Graphiques de mémoire à plateau (bloqués au maximum) - Collecte de mémoire (ramasse-miettes) fréquente (profil en dents de scie avec chutes abruptes) - OutOfMemoryError dans les journaux - Le router devient non réactif sous charge - Arrêt automatique dû à l\u0026rsquo;épuisement des ressources\nAugmenter l’allocation du tas Java dans wrapper.config (nécessite un arrêt complet) :\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 Critique : Après avoir modifié wrapper.config, vous devez arrêter complètement (et non redémarrer), attendre 11 minutes pour un arrêt en douceur, puis démarrer à nouveau. Le bouton \u0026ldquo;Restart\u0026rdquo; de la console du router ne recharge pas les paramètres de wrapper.config.\nL\u0026rsquo;optimisation du CPU nécessite une bibliothèque de chiffrement native. Les opérations BigInteger en Java pur consomment 10 à 20 fois plus de CPU que les implémentations natives. Vérifiez l\u0026rsquo;état de jbigi à http://127.0.0.1:7657/logs au démarrage. Sans jbigi, l\u0026rsquo;utilisation du CPU grimpera à 50-100% pendant la construction de tunnels et les opérations de chiffrement.\nRéduire la charge des tunnels participants si le router est surchargé:\nAccédez à http://127.0.0.1:7657/configadvanced Définissez router.maxParticipatingTunnels=1000 (valeur par défaut 8000) Réduisez le pourcentage de partage à http://127.0.0.1:7657/config de 80 % à 50 % Désactivez le mode floodfill si activé : router.floodfillParticipant=false Limitez la bande passante d’I2PSnark et le nombre de torrents simultanés. Le téléchargement par torrent consomme des ressources importantes. À http://127.0.0.1:7657/i2psnark:\nLimiter les torrents actifs à 3-5 maximum Définir \u0026ldquo;Up BW Limit\u0026rdquo; et \u0026ldquo;Down BW Limit\u0026rdquo; à des valeurs raisonnables (50-100 KB/sec chacune) Arrêter les torrents lorsqu\u0026rsquo;ils ne sont pas activement nécessaires Éviter de partager des dizaines de torrents simultanément Surveillez l\u0026rsquo;utilisation des ressources au moyen des graphiques intégrés à l\u0026rsquo;adresse http://127.0.0.1:7657/graphs. La mémoire devrait indiquer une marge disponible, pas un plafonnement. Les pics du CPU pendant la construction de tunnel sont normaux ; une utilisation du CPU durablement élevée indique des problèmes de configuration.\nPour les systèmes très limités en ressources (Raspberry Pi, matériel ancien), envisagez i2pd (implémentation en C++) comme alternative. i2pd nécessite ~130 Mo de RAM contre 350+ Mo pour Java I2P, et utilise ~7% de CPU contre 70% dans des conditions de charge similaires. Notez qu’i2pd n’inclut pas d’applications intégrées et nécessite des outils externes.\nProblèmes de torrent avec I2PSnark L\u0026rsquo;intégration d\u0026rsquo;I2PSnark avec l\u0026rsquo;architecture du router I2P nécessite de comprendre que l\u0026rsquo;activité BitTorrent dépend entièrement de la santé des tunnels du router. Les torrents ne démarrent pas tant que le router n\u0026rsquo;a pas atteint une intégration suffisante avec 10+ pairs actifs et des tunnels fonctionnels.\nLes torrents bloqués à 0 % indiquent généralement :\nRouter pas encore pleinement intégré : Patientez 10-15 minutes après le démarrage d’I2P avant d’espérer une activité torrent DHT désactivée : Activez-la sur http://127.0.0.1:7657/i2psnark → Configuration → cochez \u0026ldquo;Enable DHT\u0026rdquo; (activée par défaut depuis la version 0.9.2) Trackers invalides ou inactifs : Les torrents I2P requièrent des trackers spécifiques à I2P - les trackers du clearnet (Internet public) ne fonctionneront pas Configuration de tunnel insuffisante : Augmentez le nombre de tunnels dans I2PSnark Configuration → section Tunnels Configurez les tunnels I2PSnark pour de meilleures performances:\nTunnels entrants: 3-5 (par défaut: 2 pour Java I2P, 5 pour i2pd) Tunnels sortants: 3-5 Longueur du tunnel: 3 sauts (réduire à 2 pour plus de vitesse, moins d\u0026rsquo;anonymat) Quantité de tunnels: 3 (offre des performances constantes) Trackers torrent I2P essentiels à inclure : - tracker2.postman.i2p (principal, le plus fiable) - w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a\nSupprimez tous les trackers clearnet (non-.i2p) : ils n’apportent aucun bénéfice et provoquent des tentatives de connexion qui expirent (timeout, dépassement de délai).\nErreurs \u0026ldquo;Torrent not registered\u0026rdquo; surviennent lorsque la communication avec le tracker échoue. Clic droit sur le torrent → \u0026ldquo;Start\u0026rdquo; force une nouvelle annonce. Si le problème persiste, vérifiez l’accessibilité du tracker en accédant à http://tracker2.postman.i 2p dans un navigateur configuré pour I2P. Les trackers hors service doivent être remplacés par des alternatives fonctionnelles.\nAucun pair ne se connecte malgré le succès du tracker suggère : - Router derrière un pare-feu (la redirection de ports améliore la situation, mais n\u0026rsquo;est pas obligatoire) - Bande passante insuffisante (augmenter à 256+ Ko/s) - Essaim trop petit (certains torrents n\u0026rsquo;ont que 1-2 sources complètes; patience requise) - DHT désactivé (à activer pour la découverte de pairs sans tracker)\nActivez DHT et PEX (Peer Exchange) dans la configuration d’I2PSnark. DHT permet de trouver des pairs sans dépendre d’un tracker. PEX découvre des pairs à partir des pairs connectés, ce qui accélère la découverte de l’essaim.\nCorruption des fichiers téléchargés survient rarement avec la vérification d\u0026rsquo;intégrité intégrée d\u0026rsquo;I2PSnark. Si elle est détectée:\nClic droit sur le torrent → \u0026ldquo;Check\u0026rdquo; force le recalcul du hachage de toutes les pièces Supprimez les données du torrent corrompues (conserve le fichier .torrent) Clic droit → \u0026ldquo;Start\u0026rdquo; pour retélécharger avec vérification des pièces Si la corruption persiste, vérifiez le disque pour détecter des erreurs : chkdsk (Windows), fsck (Linux) Le répertoire surveillé ne fonctionne pas nécessite une configuration appropriée :\nConfiguration d\u0026rsquo;I2PSnark → \u0026ldquo;Watch directory\u0026rdquo; : Définissez un chemin absolu (par ex., /home/user/torrents/watch) Assurez-vous que le processus I2P dispose des permissions de lecture : chmod 755 /path/to/watch Placez les fichiers .torrent dans le répertoire de surveillance - I2PSnark les ajoute automatiquement Configurez \u0026ldquo;Auto start\u0026rdquo; : Indiquez si les torrents doivent démarrer immédiatement lors de leur ajout Optimisation des performances pour le torrenting (utilisation de BitTorrent):\nLimitez le nombre de torrents actifs simultanés : 3 à 5 maximum pour les connexions standard Priorisez les téléchargements importants : arrêtez temporairement les torrents de faible priorité Augmentez l’allocation de bande passante du router : plus de bande passante = de meilleures performances pour les torrents Soyez patient : le torrent via I2P est par nature plus lent que BitTorrent sur le clearnet Continuez à partager après le téléchargement : le réseau repose sur la réciprocité Configuration et dépannage de Git via I2P Les opérations Git via I2P nécessitent soit une configuration du proxy SOCKS, soit des tunnels I2P dédiés pour l\u0026rsquo;accès SSH/HTTP. La conception de Git suppose des connexions à faible latence, ce qui rend l\u0026rsquo;architecture à forte latence d\u0026rsquo;I2P problématique.\nConfigurer Git pour utiliser le proxy SOCKS d\u0026rsquo;I2P :\nModifiez ~/.ssh/config (créez-le s\u0026rsquo;il n\u0026rsquo;existe pas) :\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes Cette configuration achemine toutes les connexions SSH vers les hôtes .i2p via le proxy SOCKS d\u0026rsquo;I2P (port 4447). Les paramètres ServerAlive maintiennent la connexion pendant la latence d\u0026rsquo;I2P.\nPour les opérations Git via HTTP/HTTPS, configurez Git au niveau global :\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 Remarque : socks5h effectue la résolution DNS via le proxy - indispensable pour les domaines .i2p.\nCréer un tunnel I2P dédié pour Git via SSH (plus fiable que SOCKS):\nAccédez à http://127.0.0.1:7657/i2ptunnel \u0026ldquo;Nouveau tunnel client\u0026rdquo; → \u0026ldquo;Standard\u0026rdquo; Configurer: Nom: Git-SSH Type: Client Port: 2222 (port local pour l\u0026rsquo;accès Git) Destination: [your-git-server].i2p:22 Démarrage automatique: Activé Nombre de tunnels: 3-4 (plus élevé pour une meilleure fiabilité) Enregistrez et démarrez le tunnel Configurez SSH pour utiliser le tunnel: ssh -p 2222 git@127.0.0.1 Erreurs d’authentification SSH via I2P sont généralement dues à :\nClé non ajoutée à ssh-agent : ssh-add ~/.ssh/id_rsa Mauvaises permissions du fichier de clé : chmod 600 ~/.ssh/id_rsa Tunnel non démarré : vérifiez sur http://127.0.0.1:7657/i2ptunnel que le statut est vert Le serveur Git exige un type de clé spécifique : générez une clé ed25519 si RSA échoue Le dépassement de délai des opérations Git est lié aux caractéristiques de latence d\u0026rsquo;I2P:\nAugmenter le délai d\u0026rsquo;expiration Git: git config --global http.postBuffer 524288000 (tampon de 500 Mo) Augmenter le seuil de basse vitesse: git config --global http.lowSpeedLimit 1000 et git config --global http.lowSpeedTime 600 (patiente 10 minutes) Utiliser un clone superficiel pour la récupération initiale: git clone --depth 1 [url] (récupère uniquement le dernier commit, plus rapide) Cloner pendant les périodes de faible activité: La congestion du réseau affecte les performances d\u0026rsquo;I2P Opérations git clone/fetch lentes sont inhérentes à l\u0026rsquo;architecture d\u0026rsquo;I2P. Un dépôt de 100 Mo peut prendre 30 à 60 minutes sur I2P, contre quelques secondes sur le clearnet. Stratégies:\nUtilisez des clones superficiels : --depth 1 réduit considérablement le transfert de données initial Récupérez de manière incrémentielle : Au lieu d’un clone complet, récupérez des branches spécifiques : git fetch origin branch:branch Envisagez rsync via I2P : Pour des dépôts très volumineux, rsync peut offrir de meilleures performances Augmentez le nombre de tunnels : Plus de tunnels offrent un meilleur débit pour des transferts volumineux soutenus Les erreurs \u0026ldquo;Connection refused\u0026rdquo; indiquent une mauvaise configuration des tunnels:\nVérifiez que le router I2P fonctionne: Consultez http://127.0.0.1:7657 Confirmez que le tunnel est actif et vert sur http://127.0.0.1:7657/i2ptunnel Testez le tunnel: nc -zv 127.0.0.1 2222 (devrait se connecter si le tunnel fonctionne) Vérifiez que la destination est joignable: Accédez à l\u0026rsquo;interface HTTP de la destination si disponible Consultez les journaux du tunnel sur http://127.0.0.1:7657/logs pour des erreurs spécifiques Bonnes pratiques pour Git via I2P:\nMaintenez le router I2P en fonctionnement en continu pour un accès Git stable Utilisez des clés SSH plutôt que l’authentification par mot de passe (moins d’invites interactives) Configurez des tunnels persistants plutôt que des connexions SOCKS éphémères Envisagez d’héberger votre propre serveur Git I2P pour un meilleur contrôle Documentez vos points de terminaison Git en .i2p pour les collaborateurs Accès aux eepsites et résolution des noms de domaine .i2p La raison la plus fréquente pour laquelle les utilisateurs ne parviennent pas à accéder aux sites .i2p est une configuration incorrecte du proxy du navigateur. Les sites I2P existent uniquement au sein du réseau I2P et nécessitent un acheminement via le proxy HTTP d\u0026rsquo;I2P.\nConfigurez exactement les paramètres de proxy du navigateur :\nFirefox (recommandé pour I2P):\nMenu → Paramètres → Paramètres réseau → bouton Paramètres Sélectionnez \u0026ldquo;Configuration manuelle du proxy\u0026rdquo; Proxy HTTP: 127.0.0.1 Port: 4444 Proxy SSL: 127.0.0.1 Port: 4444 Proxy SOCKS: 127.0.0.1 Port: 4447 (optionnel, pour les applications SOCKS) Cochez \u0026ldquo;Proxy DNS lors de l\u0026rsquo;utilisation de SOCKS v5\u0026rdquo; OK pour enregistrer Paramètres critiques d\u0026rsquo;about:config de Firefox:\nAccédez à about:config et modifiez :\nmedia.peerconnection.ice.proxy_only = true (empêche les fuites d’adresse IP via WebRTC) keyword.enabled = false (empêche les adresses .i2p d’être redirigées vers les moteurs de recherche) network.proxy.socks_remote_dns = true (DNS via le proxy) Limitations de Chrome/Chromium :\nChrome utilise les paramètres proxy du système plutôt que des paramètres spécifiques à l\u0026rsquo;application. Sous Windows : Paramètres → recherchez \u0026ldquo;proxy\u0026rdquo; → \u0026ldquo;Ouvrir les paramètres proxy de votre ordinateur\u0026rdquo; → Configurez HTTP : 127.0.0.1:4444 et HTTPS : 127.0.0.1:4445.\nMeilleure approche : utilisez les extensions FoxyProxy ou Proxy SwitchyOmega pour un routage sélectif du trafic .i2p.\nErreurs \u0026ldquo;Website Not Found In Address Book\u0026rdquo; signifient que le router ne dispose pas de l\u0026rsquo;adresse cryptographique du domaine .i2p. I2P utilise des carnets d\u0026rsquo;adresses locaux plutôt qu’un DNS centralisé. Solutions :\nMéthode 1 : Utiliser des services de saut (le plus simple pour les nouveaux sites) :\nAccédez à http://stats.i 2p et recherchez le site. Cliquez sur le lien addresshelper : http://example.i2p/?i2paddresshelper=base64destination. Votre navigateur affiche \u0026ldquo;Enregistrer dans le carnet d\u0026rsquo;adresses ?\u0026rdquo; - confirmez pour l\u0026rsquo;ajouter.\nMéthode 2: Mettre à jour les abonnements du carnet d\u0026rsquo;adresses:\nAccédez à http://127.0.0.1:7657/dns (SusiDNS) Cliquez sur l\u0026rsquo;onglet \u0026ldquo;Subscriptions\u0026rdquo; Vérifiez les abonnements actifs (par défaut : http://i2p-projekt.i 2p/hosts.txt) Ajoutez les abonnements recommandés : http://stats.i 2p/cgi-bin/newhosts.txt http://notbob.i 2p/hosts.txt http://reg.i 2p/export/hosts.txt Cliquez sur \u0026ldquo;Update Now\u0026rdquo; pour forcer la mise à jour immédiate des abonnements Attendez 5 à 10 minutes pour le traitement Méthode 3: Utiliser des adresses en base32 (fonctionne toujours si le site est en ligne):\nChaque site .i2p possède une adresse Base32 : 52 caractères aléatoires suivis de .b32.i2p (par ex., ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p). Les adresses Base32 contournent le carnet d’adresses - le router effectue une recherche cryptographique directe.\nErreurs courantes de configuration du navigateur :\nTentative d’HTTPS sur des sites uniquement HTTP : La plupart des sites .i2p n’utilisent que HTTP - essayer https://example.i2p échoue Oubli du préfixe http:// : Le navigateur peut lancer une recherche au lieu de se connecter - utilisez toujours http://example.i2p WebRTC activé : Peut divulguer l’adresse IP réelle - désactivez-le via les paramètres de Firefox ou des extensions DNS non passé par le proxy : Le DNS du Clearnet (Internet public/clair) ne peut pas résoudre .i2p - il faut acheminer les requêtes DNS via un proxy Mauvais port de proxy : 4444 pour HTTP (et non 4445, qui est un outproxy (proxy sortant) HTTPS vers le clearnet) Router non entièrement intégré empêche l\u0026rsquo;accès à tous les sites. Vérifiez que l\u0026rsquo;intégration est suffisante :\nVérifiez que http://127.0.0.1:7657 affiche \u0026ldquo;Network: OK\u0026rdquo; ou \u0026ldquo;Network: Firewalled\u0026rdquo; (et non \u0026ldquo;Network: Testing\u0026rdquo;) Active peers affiche au minimum 10 (50+ optimal) Aucun message \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; Attendez 10 à 15 minutes complètes après le démarrage du router avant d\u0026rsquo;espérer un accès .i2p La configuration des clients IRC et de messagerie suit des schémas de proxy similaires :\nIRC: Les clients se connectent à 127.0.0.1:6668 (le tunnel proxy IRC d\u0026rsquo;I2P). Désactivez les paramètres de proxy du client IRC - la connexion à localhost:6668 passe déjà par I2P.\nE-mail (Postman): - SMTP: 127.0.0.1:7659 - POP3: 127.0.0.1:7660 - Pas de SSL/TLS (le chiffrement est assuré par le tunnel I2P) - Identifiants issus de l\u0026rsquo;inscription du compte sur postman.i2p\nTous ces tunnels doivent afficher le statut \u0026ldquo;running\u0026rdquo; (vert) sur http://127.0.0.1:7657/i2ptunnel.\nÉchecs d’installation et problèmes de paquets Les installations basées sur des paquets (Debian, Ubuntu, Arch) échouent parfois en raison de modifications des dépôts, d’expiration de la clé GPG, ou de conflits de dépendances. Les dépôts officiels sont passés de deb.i2p2.de/deb.i2p2.no (fin de vie) à deb.i2p.net dans les versions récentes.\nMettre à jour le dépôt Debian/Ubuntu vers la version actuelle :\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring Les échecs de vérification des signatures GPG surviennent lorsque les clés du dépôt expirent ou changent :\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc Le service ne démarre pas après l\u0026rsquo;installation du paquet provient le plus souvent de problèmes liés au profil AppArmor sur Debian/Ubuntu :\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service Problèmes d’autorisations avec I2P installé via un paquet:\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 Problèmes de compatibilité Java:\nI2P 2.10.0 nécessite Java 8 au minimum. Les systèmes plus anciens peuvent avoir Java 7 ou une version antérieure :\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java Erreurs de configuration du Wrapper empêchent le démarrage du service:\nL\u0026rsquo;emplacement de Wrapper.config varie selon la méthode d\u0026rsquo;installation : - Installation utilisateur : ~/.i2p/wrapper.config - Installation via paquet : /etc/i2p/wrapper.config ou /var/lib/i2p/wrapper.config\nProblèmes courants avec wrapper.config:\nChemins incorrects : wrapper.java.command doit pointer vers une installation Java valide Mémoire insuffisante : wrapper.java.maxmemory est réglé trop bas (augmentez à 512 ou plus) Mauvais emplacement du pidfile : wrapper.pidfile doit être un emplacement accessible en écriture Binaire wrapper manquant : certaines plateformes n\u0026rsquo;ont pas de wrapper précompilé (utilisez runplain.sh comme solution de repli) Échecs de mise à jour et mises à jour corrompues :\nLes mises à jour de la console du router échouent parfois en cours de téléchargement en raison d’interruptions du réseau. Procédure de mise à jour manuelle :\nTéléchargez i2pupdate_X.X.X.zip depuis https://geti2p.net/en/download Vérifiez que la somme de contrôle SHA256 correspond au hachage publié Copiez dans le répertoire d\u0026rsquo;installation d\u0026rsquo;I2P sous le nom i2pupdate.zip Redémarrez le router (nœud I2P) - détecte et extrait automatiquement la mise à jour Attendez 5 à 10 minutes pour l\u0026rsquo;installation de la mise à jour Vérifiez la nouvelle version à l\u0026rsquo;adresse http://127.0.0.1:7657 Migration depuis des versions très anciennes (pré-0.9.47) vers les versions actuelles peut échouer en raison de clés de signature incompatibles ou de fonctionnalités supprimées. Des mises à jour incrémentielles sont nécessaires :\nVersions antérieures à 0.9.9: Impossible de vérifier les signatures actuelles - mise à jour manuelle nécessaire Versions utilisant Java 6/7: Java doit être mis à niveau avant la mise à jour d\u0026rsquo;I2P vers la 2.x Sauts de version majeurs: Mettre à jour d\u0026rsquo;abord vers une version intermédiaire (0.9.47 recommandée comme jalon) Quand utiliser l’installateur vs le paquet :\nPaquets (apt/yum): Idéal pour les serveurs, mises à jour de sécurité automatiques, intégration au système, gestion par systemd Installeur (.jar): Idéal pour une installation au niveau utilisateur, Windows, macOS, installations personnalisées, disponibilité de la version la plus récente Corruption des fichiers de configuration et récupération La persistance de la configuration d\u0026rsquo;I2P repose sur plusieurs fichiers essentiels. La corruption résulte généralement d\u0026rsquo;un arrêt incorrect, d\u0026rsquo;erreurs de disque, ou d\u0026rsquo;erreurs de modification manuelle. Comprendre la finalité des fichiers permet une réparation ciblée plutôt qu\u0026rsquo;une réinstallation complète.\nFichiers critiques et leurs fonctions:\nrouter.keys (516+ octets) : Identité cryptographique du router - la perte de ce fichier crée une nouvelle identité router.info (généré automatiquement) : Informations publiées du router - peut être supprimé sans risque, se régénère router.config (texte) : Configuration principale - bande passante, paramètres réseau, préférences i2ptunnel.config (texte) : Définitions de tunnel - tunnels client/serveur, clés, destinations netDb/ (répertoire) : Base de données des pairs - informations de router pour les participants du réseau peerProfiles/ (répertoire) : Statistiques de performance sur les pairs - influencent la sélection des tunnels keyData/ (répertoire) : Clés de destination pour les eepsites et les services - les perdre change les adresses addressbook/ (répertoire) : Correspondances locales de noms d’hôte .i2p Procédure de sauvegarde complète avant toute modification:\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR Symptômes de corruption de Router.config:\nLe Router ne démarre pas avec des erreurs d\u0026rsquo;analyse dans les journaux Les paramètres ne persistent pas après le redémarrage Des valeurs par défaut inattendues apparaissent Caractères illisibles lors de l\u0026rsquo;affichage du fichier Réparer un router.config corrompu:\nSauvegardez l\u0026rsquo;existant : cp router.config router.config.broken Vérifiez l\u0026rsquo;encodage du fichier : Doit être UTF-8 sans BOM Validez la syntaxe : Les clés utilisent le séparateur = (pas :), pas d\u0026rsquo;espaces en fin de clé, # uniquement pour les commentaires Corruptions courantes : Caractères non-ASCII dans les valeurs, problèmes de fin de ligne (CRLF vs LF) Si irréparable : Supprimez router.config - le router génère une configuration par défaut, en préservant l\u0026rsquo;identité Paramètres essentiels de router.config à conserver :\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false Un router.keys perdu ou invalide crée une nouvelle identité du router. C\u0026rsquo;est acceptable, sauf si :\nFonctionnement en floodfill (perd le statut floodfill) Hébergement d\u0026rsquo;eepsites avec une adresse publiée (perd la continuité) Réputation établie sur le réseau Récupération impossible sans sauvegarde — créez-en une nouvelle : supprimez router.keys, redémarrez I2P ; une nouvelle identité sera créée.\nDistinction cruciale: router.keys (identité) vs keyData/* (services). La perte de router.keys modifie l\u0026rsquo;identité du router. La perte de keyData/mysite-keys.dat change l\u0026rsquo;adresse .i2p de votre eepsite (site I2P) - catastrophique si l\u0026rsquo;adresse est publiée.\nSauvegardez les clés de l\u0026rsquo;eepsite/du service séparément:\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat Corruption de NetDb et de peerProfiles:\nSymptômes : aucun pair actif, impossible de construire des tunnels, \u0026ldquo;Database corruption detected\u0026rdquo; dans les journaux\nCorrectif sans risque (tout sera reseed (réensemencé)/reconstruit automatiquement):\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration Ces répertoires ne contiennent que des informations réseau mises en cache - leur suppression force un nouvel amorçage mais n\u0026rsquo;entraîne aucune perte de données critiques.\nStratégies de prévention:\nArrêt propre systématique: Utilisez i2prouter stop ou le bouton \u0026ldquo;Shutdown\u0026rdquo; de la console du router - ne forcez jamais l’arrêt Sauvegardes automatisées: Tâche cron hebdomadaire de sauvegarde de ~/.i2p vers un disque séparé Surveillance de l’état des disques: Vérifiez périodiquement l’état SMART - des disques défaillants corrompent les données Espace disque suffisant: Maintenez plus de 1 Go libres - des disques pleins entraînent une corruption UPS (onduleur) recommandé: Les coupures de courant pendant les écritures corrompent les fichiers Contrôle de version des configurations critiques: Un dépôt Git pour router.config et i2ptunnel.config permet de revenir en arrière Les permissions de fichiers sont importantes:\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems Messages d’erreur courants décryptés La journalisation d\u0026rsquo;I2P fournit des messages d\u0026rsquo;erreur spécifiques qui ciblent précisément les problèmes. Comprendre ces messages accélère le dépannage.\n\u0026ldquo;No tunnels available\u0026rdquo; apparaît lorsque le router n\u0026rsquo;a pas établi suffisamment de tunnels pour fonctionner. C\u0026rsquo;est normal pendant les 5 à 10 premières minutes après le démarrage. Si cela persiste au-delà de 15 minutes:\nVérifiez que le nombre de pairs actifs \u0026gt; 10 à l’adresse http://127.0.0.1:7657 Vérifiez que l’allocation de bande passante est suffisante (128+ Ko/s minimum) Examinez le taux de réussite des tunnels (chaînes de relais chiffrées I2P) à http://127.0.0.1:7657/tunnels (devrait être \u0026gt;40 %) Passez en revue les journaux pour connaître les motifs de rejet lors de la construction des tunnels \u0026ldquo;Décalage d\u0026rsquo;horloge détecté\u0026rdquo; ou \u0026ldquo;code de déconnexion NTCP2 7\u0026rdquo; indique que l\u0026rsquo;heure du système diffère du consensus du réseau de plus de 90 secondes. I2P exige une précision de ±60 secondes. Les connexions avec des routers présentant un décalage horaire sont automatiquement rejetées.\nÀ corriger immédiatement :\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings \u0026ldquo;Build timeout\u0026rdquo; ou \u0026ldquo;Tunnel build timeout exceeded\u0026rdquo; signifie que la construction du tunnel via la chaîne de pairs ne s\u0026rsquo;est pas terminée dans la fenêtre de délai d\u0026rsquo;expiration (généralement 60 secondes). Causes :\nPairs lents: Le router a sélectionné des participants non réactifs pour le tunnel Congestion du réseau: Le réseau I2P subit une forte charge Bande passante insuffisante: Vos limites de bande passante empêchent la construction du tunnel en temps voulu Router surchargé: Trop de tunnels participants consomment des ressources Solutions: Augmenter la bande passante, réduire le nombre de tunnels participants (router.maxParticipatingTunnels à http://127.0.0.1:7657/configadvanced), activer la redirection de port pour une meilleure sélection des pairs.\n\u0026ldquo;Router is shutting down\u0026rdquo; ou \u0026ldquo;Graceful shutdown in progress\u0026rdquo; s\u0026rsquo;affichent lors d\u0026rsquo;un arrêt normal ou d\u0026rsquo;une récupération après un crash. Un arrêt propre peut prendre jusqu\u0026rsquo;à 10 minutes pendant que le router ferme les tunnels, notifie ses pairs et sauvegarde son état.\nSi l\u0026rsquo;état d\u0026rsquo;arrêt persiste au-delà de 11 minutes, forcer l\u0026rsquo;arrêt :\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; indique un épuisement du tas mémoire. Solutions immédiates :\nModifiez wrapper.config: wrapper.java.maxmemory=512 (ou plus) Arrêt complet requis - un redémarrage n\u0026rsquo;appliquera pas la modification Attendez 11 minutes pour un arrêt complet Démarrez le router à neuf Vérifiez l’allocation mémoire à l’adresse http://127.0.0.1:7657/graphs - cela devrait montrer une marge libre Erreurs de mémoire associées:\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo;: Trop de temps passé dans la collecte de mémoire - augmenter la taille du tas \u0026ldquo;Metaspace\u0026rdquo;: Espace des métadonnées des classes Java épuisé - ajouter wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M Spécifique à Windows : Kaspersky Antivirus limite le tas Java à 512 Mo, indépendamment des paramètres de wrapper.config - désinstallez-le ou ajoutez I2P aux exclusions.\n\u0026ldquo;Délai d’attente de connexion expiré\u0026rdquo; ou \u0026ldquo;Erreur I2CP - port 7654\u0026rdquo; lorsque des applications tentent de se connecter au router :\nVérifiez que le router fonctionne : http://127.0.0.1:7657 devrait répondre Vérifiez le port I2CP : netstat -an | grep 7654 devrait afficher LISTENING Assurez-vous que le pare-feu localhost autorise : sudo ufw allow from 127.0.0.1 Vérifiez que l’application utilise le bon port (I2CP=7654, SAM=7656) \u0026ldquo;Certificate validation failed\u0026rdquo; ou \u0026ldquo;RouterInfo corrupt\u0026rdquo; lors du réensemencement :\nCauses sous-jacentes : décalage d’horloge (à corriger en premier), netDb corrompue, certificats de réensemencement invalides\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data \u0026ldquo;Corruption de la base de données détectée\u0026rdquo; indique une corruption des données au niveau du disque dans netDb ou peerProfiles :\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start Vérifiez l’état du disque avec des outils S.M.A.R.T. - des corruptions récurrentes suggèrent une défaillance du périphérique de stockage.\nDéfis spécifiques à chaque plateforme Les différents systèmes d’exploitation présentent des défis uniques de déploiement d’I2P liés aux autorisations, aux politiques de sécurité et à l’intégration au système.\nProblèmes de permissions et de services sous Linux I2P installé via les paquets de la distribution s’exécute en tant qu’utilisateur système i2psvc (Debian/Ubuntu) ou i2p (autres distributions), et nécessite des autorisations spécifiques :\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config Limites des descripteurs de fichiers affectent la capacité du router en matière de connexions. Les limites par défaut (1024) sont insuffisantes pour les routers à haut débit :\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p Conflits AppArmor courants sur Debian/Ubuntu empêchent le démarrage du service:\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined Problèmes liés à SELinux sur RHEL/CentOS/Fedora :\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t Dépannage des services SystemD:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service Interférences du pare-feu et de l’antivirus Windows Windows Defender et les produits antivirus tiers signalent fréquemment I2P en raison de modèles de comportement réseau. Une configuration correcte permet d’éviter des blocages inutiles tout en préservant la sécurité.\nConfigurer le Pare-feu Windows Defender :\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; Remplacez le port 22648 par votre port I2P réel indiqué sur http://127.0.0.1:7657/confignet.\nProblème spécifique à Kaspersky Antivirus: La fonctionnalité \u0026ldquo;Application Control\u0026rdquo; de Kaspersky limite le tas Java à 512 Mo, indépendamment des paramètres de wrapper.config. Cela provoque des erreurs OutOfMemoryError sur des routers à haut débit.\nSolutions: 1. Ajouter I2P aux exclusions de Kaspersky : Paramètres → Supplémentaire → Menaces et exclusions → Gérer les exclusions 2. Ou désinstaller Kaspersky (recommandé pour le fonctionnement d\u0026rsquo;I2P)\nRecommandations générales pour les antivirus tiers :\nAjouter le dossier d’installation d’I2P à la liste des exclusions Ajouter %APPDATA%\\I2P et %LOCALAPPDATA%\\I2P à la liste des exclusions Exclure javaw.exe de l’analyse comportementale Désactiver les fonctionnalités \u0026ldquo;Network Attack Protection\u0026rdquo; (protection contre les attaques réseau) susceptibles d’interférer avec les protocoles I2P Gatekeeper de macOS bloque l\u0026rsquo;installation Gatekeeper de macOS empêche les applications non signées de s’exécuter. Les programmes d’installation d’I2P ne sont pas signés avec un Apple Developer ID, ce qui déclenche des avertissements de sécurité.\nContourner Gatekeeper pour le programme d’installation I2P:\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file Après l\u0026rsquo;installation, l\u0026rsquo;exécution peut encore déclencher des avertissements :\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ Ne désactivez jamais Gatekeeper de façon permanente - risque de sécurité pour les autres applications. N\u0026rsquo;utilisez que des contournements spécifiques à un fichier.\nConfiguration du pare-feu de macOS:\nPréférences Système → Sécurité et confidentialité → Pare-feu → Options du pare-feu Cliquez sur « + » pour ajouter une application Accédez à l’installation de Java (par exemple : /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java) Ajoutez-la et définissez sur « Autoriser les connexions entrantes » Problèmes de l’application I2P sur Android Les contraintes liées aux versions d\u0026rsquo;Android et les limitations de ressources posent des défis particuliers.\nExigences minimales : - Android 5.0+ (niveau d\u0026rsquo;API 21+) requis pour les versions actuelles - 512 Mo de RAM minimum, 1 Go+ recommandé - 100 Mo de stockage pour l’application + les données du router - Restrictions des applications en arrière-plan désactivées pour I2P\nL\u0026rsquo;application plante immédiatement:\nVérifiez la version d’Android : Paramètres → À propos du téléphone → Version d’Android (doit être 5.0+) Désinstallez toutes les versions d’I2P : N’installez qu’une seule variante : net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\nPlusieurs installations entrent en conflit Effacez les données de l’application : Paramètres → Applications → I2P → Stockage → Effacer les données Réinstallez à partir d’un état propre L\u0026rsquo;optimisation de la batterie tue le router:\nAndroid ferme de manière agressive les applications en arrière-plan pour économiser la batterie. I2P doit être exclu :\nParamètres → Batterie → Optimisation de la batterie (ou Utilisation de la batterie de l’application) Recherchez I2P → Ne pas optimiser (ou Autoriser l’activité en arrière-plan) Paramètres → Applications → I2P → Batterie → Autoriser l’activité en arrière-plan + Supprimer les restrictions Problèmes de connexion sur mobile :\nL’amorçage nécessite le WiFi : Le reseed (procédure d’obtention initiale des pairs) initial télécharge une quantité importante de données - utilisez le WiFi, pas le réseau mobile Changements de réseau : I2P gère mal les basculements de réseau - redémarrez l’application après une transition WiFi/réseau mobile Bande passante pour mobile : Configurez prudemment à 64-128 KB/sec pour éviter d’épuiser votre forfait de données mobiles Optimisation des performances pour mobile:\nApplication I2P → Menu → Paramètres → Bande passante Réglez des limites appropriées : 64 Ko/s en entrée, 32 Ko/s en sortie pour le réseau mobile Réduisez les tunnels participants : Paramètres → Avancé → Nombre maximum de tunnels participants : 100-200 Activez \u0026ldquo;Arrêter I2P lorsque l\u0026rsquo;écran est éteint\u0026rdquo; pour économiser la batterie Téléchargement de torrents sur Android :\nLimiter à 2-3 torrents simultanés maximum Réduire l\u0026rsquo;agressivité de la DHT Utiliser uniquement le WiFi pour les torrents Accepter des vitesses plus lentes sur du matériel mobile Problèmes de reseed et de bootstrap Les nouvelles installations d\u0026rsquo;I2P nécessitent un reseeding (réensemencement initial) - récupération des informations initiales sur les pairs depuis des serveurs HTTPS publics pour rejoindre le réseau. Les problèmes de reseeding piègent les utilisateurs sans aucun pair et sans accès au réseau.\n\u0026ldquo;No active peers\u0026rdquo; après une nouvelle installation indique généralement un échec du reseed (importation initiale de pairs). Symptômes :\nPairs connus: 0 ou reste inférieur à 5 \u0026ldquo;Network: Testing\u0026rdquo; persiste au-delà de 15 minutes Les journaux affichent \u0026ldquo;Reseed failed\u0026rdquo; ou des erreurs de connexion aux serveurs de reseed (réensemencement) Pourquoi le reseed (réensemencement) échoue:\nPare-feu bloquant HTTPS: Les pare-feu d\u0026rsquo;entreprise/FAI bloquent les connexions aux reseed servers (serveurs de démarrage du réseau I2P) (port 443) Erreurs de certificats SSL: Le système ne dispose pas de certificats racine à jour Exigence de proxy: Le réseau requiert un proxy HTTP/SOCKS pour les connexions externes Décalage d\u0026rsquo;horloge: La validation des certificats SSL échoue lorsque l\u0026rsquo;heure du système est incorrecte Censure géographique: Certains pays/FAI bloquent des reseed servers connus Forcer un reseed manuel (réamorçage du réseau):\nAccédez à http://127.0.0.1:7657/configreseed Cliquez sur \u0026ldquo;Save changes and reseed now\u0026rdquo; Surveillez http://127.0.0.1:7657/logs pour \u0026ldquo;Reseed got XX router infos\u0026rdquo; Attendez 5 à 10 minutes pour le traitement Vérifiez http://127.0.0.1:7657 - Les pairs connus devraient atteindre 50+ Configurer le proxy de reseed (réensemencement) pour les réseaux restrictifs :\nhttp://127.0.0.1:7657/configreseed → Configuration du proxy:\nProxy HTTP: [proxy-server]:[port] Ou SOCKS5: [socks-server]:[port] Activer \u0026ldquo;Utiliser le proxy uniquement pour le réensemencement\u0026rdquo; Identifiants si nécessaire Enregistrer et forcer le réensemencement Alternative: Proxy Tor pour le réensemencement:\nSi Tor Browser ou le démon Tor est en cours d’exécution :\nType de proxy: SOCKS5 Hôte: 127.0.0.1 Port: 9050 (port SOCKS Tor par défaut) Activer et réensemencer Réensemencement manuel via un fichier su3 (en dernier recours) :\nLorsque toutes les opérations de reseed automatisées (réensemencement) échouent, obtenez le fichier de reseed par un canal hors bande :\nTéléchargez i2pseeds.su3 depuis une source de confiance sur une connexion sans restriction (https://reseed.i2p.rocks/i2pseeds.su3 , https://reseed-fr.i2pd.xyz/i2pseeds.su3 ) Arrêtez complètement I2P Copiez i2pseeds.su3 dans le répertoire ~/.i2p/ Démarrez I2P - extrait et traite automatiquement le fichier Supprimez i2pseeds.su3 après le traitement Vérifiez que le nombre de pairs augmente à l\u0026rsquo;adresse http://127.0.0.1:7657 Erreurs de certificat SSL lors du réensemencement :\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing Solutions :\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates Bloqué à 0 pairs connus depuis plus de 30 minutes :\nIndique un échec complet du réamorçage. Procédure de dépannage :\nVérifiez que l’heure du système est exacte (problème le plus courant - à corriger EN PREMIER) Testez la connectivité HTTPS : Essayez d’accéder à https://reseed.i2p.rocks dans le navigateur - si cela échoue, problème réseau Vérifiez les journaux I2P à http://127.0.0.1:7657/logs pour des erreurs de reseed (réamorçage) spécifiques Essayez une autre URL de reseed : http://127.0.0.1:7657/configreseed → ajoutez une URL de reseed personnalisée : https://reseed-fr.i2pd.xyz/ Utilisez la méthode manuelle via un fichier su3 si les tentatives automatisées sont épuisées Serveurs de réensemencement occasionnellement hors ligne: I2P inclut plusieurs serveurs de réensemencement codés en dur. Si l’un d’eux échoue, le router essaie automatiquement les autres. Une panne totale de tous les serveurs de réensemencement est extrêmement rare, mais possible.\nServeurs de reseed (serveurs d’amorçage) actifs (en octobre 2025):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ Ajoutez-les en tant qu’URL personnalisées si vous rencontrez des problèmes avec les paramètres par défaut.\nPour les utilisateurs dans des régions fortement censurées:\nEnvisagez d’utiliser des ponts Snowflake/Meek via Tor pour le réensemencement initial, puis de passer à I2P direct une fois intégré au réseau. Ou obtenez i2pseeds.su3 via stéganographie, par e-mail ou sur une clé USB depuis l’extérieur de la zone de censure.\nQuand demander une aide supplémentaire Ce guide couvre la grande majorité des problèmes I2P, mais certains nécessitent l’attention des développeurs ou l’expertise de la communauté.\nDemandez de l\u0026rsquo;aide à la communauté I2P lorsque :\nLe router plante systématiquement après avoir suivi toutes les étapes de dépannage Fuites de mémoire entraînant une croissance continue au-delà du tas mémoire alloué Le taux de réussite des tunnels reste inférieur à 20 % malgré une configuration adéquate Nouvelles erreurs dans les journaux non couvertes par ce guide Vulnérabilités de sécurité découvertes Demandes de fonctionnalités ou suggestions d\u0026rsquo;amélioration Avant de demander de l\u0026rsquo;aide, rassemblez les informations de diagnostic:\nVersion d\u0026rsquo;I2P : http://127.0.0.1:7657 (p. ex., \u0026ldquo;2.10.0\u0026rdquo;) Version de Java : sortie de java -version Système d\u0026rsquo;exploitation et version Statut du router : État du réseau, nombre de pairs actifs, tunnels participants Configuration de la bande passante : limites entrantes/sortantes Statut de la redirection de ports : Derrière un pare-feu ou OK Extraits de journaux pertinents : 50 dernières lignes affichant les erreurs depuis http://127.0.0.1:7657/logs Canaux officiels d\u0026rsquo;assistance:\nForum: https://i2pforum.net (clearnet) ou http://i2pforum.i 2p (au sein d\u0026rsquo;I2P) IRC: #i2p sur Irc2P (irc.postman.i2p via I2P) ou irc.freenode.net (clearnet) Reddit: https://reddit.com/r/i2p pour les discussions de la communauté Suivi des bogues: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues pour les bogues confirmés Liste de diffusion: i2p-dev@lists.i2p-projekt.de pour les questions de développement Les attentes réalistes comptent. I2P est plus lent que la clearnet (Internet public non chiffré) de par sa conception - les tunnels chiffrés multi-sauts créent une latence inhérente. Un I2P router avec des chargements de page de 30 secondes et des vitesses de torrent de 50 KB/sec fonctionne correctement, il n’est pas en panne. Les utilisateurs qui s’attendent à des vitesses de clearnet seront déçus, quelle que soit l’optimisation de la configuration.\nConclusion La plupart des problèmes I2P proviennent de trois catégories : manque de patience pendant l’amorçage (bootstrap) — 10 à 15 minutes sont nécessaires —, allocation de ressources insuffisante (au minimum 512 Mo de RAM et 256 Ko/s de bande passante), ou redirection de ports mal configurée. Comprendre l’architecture distribuée d’I2P et sa conception axée sur l’anonymat aide les utilisateurs à distinguer le comportement attendu des problèmes réels.\nLe statut \u0026ldquo;Firewalled\u0026rdquo; (connectivité entrante bloquée) du router, bien que sous-optimal, n’empêche pas l’utilisation d’I2P - il limite seulement la contribution au réseau et dégrade légèrement les performances. Les nouveaux utilisateurs devraient privilégier la stabilité plutôt que l’optimisation : faites fonctionner le router en continu pendant plusieurs jours avant d’ajuster les paramètres avancés, car l’intégration s’améliore naturellement avec le temps de disponibilité.\nLors du dépannage, vérifiez toujours d’abord les fondamentaux : horloge système correctement réglée, bande passante suffisante, router fonctionnant en continu et au moins 10 pairs actifs. La plupart des problèmes se résolvent en corrigeant ces bases plutôt qu’en ajustant des paramètres de configuration obscurs. I2P récompense la patience et le fonctionnement en continu par des performances améliorées, à mesure que le router construit sa réputation et optimise la sélection des pairs au fil des jours et des semaines de fonctionnement.\n","description":"Guide de dépannage complet pour les problèmes courants du router I2P, y compris les problèmes de connectivité, de performances et de configuration","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"Guide de dépannage du router I2P","url":"/fr/docs/troubleshooting/"},{"categories":null,"content":"Vous souhaitez donc commencer à travailler sur I2P ? Excellent ! Voici un guide rapide pour débuter et contribuer au site web ou au logiciel, effectuer du développement ou créer des traductions.\nPas encore prêt à coder ? Essayez d\u0026rsquo;abord de vous impliquer .\nApprendre à connaître Java Le router I2P et ses applications intégrées utilisent Java comme langage de développement principal. Si vous n\u0026rsquo;avez pas d\u0026rsquo;expérience avec Java, vous pouvez toujours consulter Thinking in Java Étudiez l\u0026rsquo;introduction pratique, les autres documents « comment faire », l\u0026rsquo;introduction technique et les documents associés :\nComment introduction : Introduction à I2P Hub de documentation : Documentation Introduction technique : Introduction technique Cela vous donnera un bon aperçu de la structure d\u0026rsquo;I2P et des différentes fonctions qu\u0026rsquo;il accomplit.\nObtenir le code I2P Pour le développement sur le routeur I2P ou les applications intégrées, vous devez obtenir le code source.\nNotre méthode actuelle : Git I2P dispose de services Git officiels et accepte les contributions via Git sur notre propre GitLab :\nÀ l\u0026rsquo;intérieur d\u0026rsquo;I2P : http://git.idk.i2p À l\u0026rsquo;extérieur d\u0026rsquo;I2P : https://i2pgit.org Clonez le dépôt principal :\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git Un miroir en lecture seule est également disponible sur GitHub :\nMiroir GitHub : github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git Compilation d\u0026rsquo;I2P Pour compiler le code, vous avez besoin du Sun/Oracle Java Development Kit 6 ou supérieur, ou d\u0026rsquo;un JDK équivalent (Sun/Oracle JDK 6 fortement recommandé) et d\u0026rsquo;Apache Ant version 1.7.0 ou supérieure. Si vous travaillez sur le code principal d\u0026rsquo;I2P, allez dans le répertoire i2p.i2p et exécutez ant pour voir les options de compilation.\nPour compiler ou travailler sur les traductions de la console, vous avez besoin des outils xgettext, msgfmt et msgmerge du paquet GNU gettext.\nPour le développement de nouvelles applications, consultez le guide de développement d\u0026rsquo;applications .\nIdées de développement Consultez la liste TODO du projet ou la liste des problèmes sur GitLab pour des idées :\nTickets GitLab : i2pgit.org/I2P_Developers/i2p.i2p/issues Rendre les résultats disponibles Consultez le bas de la page des licences pour connaître les exigences relatives aux privilèges de commit. Vous en avez besoin pour intégrer du code dans i2p.i2p (non requis pour le site web !).\nPage des licences Faites notre connaissance ! Les développeurs traînent sur IRC. Ils peuvent être contactés sur différents réseaux et sur les réseaux internes I2P. L\u0026rsquo;endroit habituel pour les trouver est #i2p-dev. Rejoignez le canal et dites bonjour ! Nous avons également des directives supplémentaires pour les développeurs réguliers .\nTraductions Traducteurs du site web et de la console du routeur : Consultez le Guide du nouveau traducteur pour les prochaines étapes.\nOutils I2P est un logiciel open source principalement développé à l\u0026rsquo;aide d\u0026rsquo;outils open source. Le projet I2P a récemment obtenu une licence pour YourKit Java Profiler. Les projets open source peuvent bénéficier d\u0026rsquo;une licence gratuite à condition que YourKit soit mentionné sur le site web du projet. N\u0026rsquo;hésitez pas à nous contacter si vous souhaitez profiler la base de code I2P.\nYourKit soutient généreusement les projets open source avec ses profileurs complets. YourKit, LLC est le créateur d\u0026rsquo;outils innovants et intelligents pour le profilage d\u0026rsquo;applications Java et .NET. Découvrez les logiciels de pointe de YourKit :\nYourKit Java Profiler YourKit .NET Profiler ","description":"Comment commencer à contribuer à I2P : matériel d'étude, code source, compilation, idées, publication, communauté, traductions et outils","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"Guide du Nouveau Développeur","url":"/fr/docs/develop/new-developers/"},{"categories":null,"content":"Vous souhaitez aider à rendre I2P accessible à plus de personnes dans le monde ? La traduction est l\u0026rsquo;une des contributions les plus précieuses que vous puissiez apporter au projet. Ce guide vous expliquera comment traduire la console du routeur.\nMéthodes de traduction Il existe deux façons de contribuer aux traductions :\nMéthode 1 : Transifex (Recommandée) C\u0026rsquo;est la façon la plus simple de traduire I2P. Transifex fournit une interface web qui rend la traduction simple et accessible.\nInscrivez-vous sur Transifex Demandez à rejoindre l\u0026rsquo;équipe de traduction I2P Commencez à traduire directement dans votre navigateur Aucune connaissance technique requise - il suffit de s\u0026rsquo;inscrire et de commencer à traduire !\nMéthode 2 : Traduction manuelle Pour les traducteurs qui préfèrent travailler avec git et des fichiers locaux, ou pour les langues qui ne sont pas encore configurées sur Transifex.\nExigences : - Familiarité avec le contrôle de version git - Éditeur de texte ou outil de traduction (POEdit recommandé) - Outils en ligne de commande : git, gettext\nConfiguration : 1. Rejoignez #i2p-dev sur IRC et présentez-vous 2. Mettez à jour le statut de traduction sur le wiki (demandez l\u0026rsquo;accès sur IRC) 3. Clonez le dépôt approprié (voir les sections ci-dessous)\nTraduction de la Console du Routeur La console du routeur est l\u0026rsquo;interface web que vous voyez lorsque vous exécutez I2P. La traduire aide les utilisateurs qui ne sont pas à l\u0026rsquo;aise avec l\u0026rsquo;anglais.\nUtiliser Transifex (recommandé) Accédez à I2P sur Transifex Sélectionnez le projet de la console du router Choisissez votre langue Commencez à traduire Traduction manuelle de la console du routeur Prérequis : - Identiques à ceux de la traduction de site web (git, gettext) - Clé GPG (pour l\u0026rsquo;accès aux commits) - Accord de développeur signé\nCloner le dépôt principal I2P :\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p Fichiers à traduire :\nLa console du routeur contient environ 15 fichiers qui nécessitent une traduction :\nFichiers d\u0026rsquo;interface principaux :\napps/routerconsole/locale/messages_*.po - Messages principaux de la console apps/routerconsole/locale-news/messages_*.po - Messages d\u0026rsquo;actualités Fichiers proxy :\napps/i2ptunnel/locale/messages_*.po - Interface de configuration de tunnel Locales des applications :\napps/susidns/locale/messages_*.po - Interface du carnet d\u0026rsquo;adresses apps/susimail/locale/messages_*.po - Interface de messagerie électronique Autres répertoires de locales spécifiques aux applications Fichiers de documentation :\ninstaller/resources/readme/readme_*.html - Fichier readme d\u0026rsquo;installation Fichiers d\u0026rsquo;aide dans diverses applications Flux de travail de traduction :\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console Soumettez votre travail : - Créez une demande de fusion sur GitLab - Ou partagez des fichiers avec l\u0026rsquo;équipe de développement sur IRC\nOutils de traduction POEdit (Hautement recommandé) POEdit est un éditeur spécialisé pour les fichiers de traduction .po.\nFonctionnalités : - Interface visuelle pour le travail de traduction - Affiche le contexte de traduction - Validation automatique - Disponible pour Windows, macOS et Linux\nÉditeurs de texte Vous pouvez également utiliser n\u0026rsquo;importe quel éditeur de texte : - VS Code (avec des extensions i18n) - Sublime Text - vim/emacs (pour les utilisateurs de terminal)\nContrôles de qualité Avant de soumettre : 1. Vérifiez le formatage : Assurez-vous que les espaces réservés comme %s et {0} restent inchangés 2. Testez vos traductions : Installez et exécutez I2P pour voir comment elles s\u0026rsquo;affichent 3. Cohérence : Maintenez une terminologie cohérente dans tous les fichiers 4. Longueur : Certaines chaînes ont des contraintes d\u0026rsquo;espace dans l\u0026rsquo;interface utilisateur\nConseils pour les traducteurs Directives générales Restez cohérent : Utilisez les mêmes traductions pour les termes courants tout au long du document Conservez la mise en forme : Préservez les balises HTML, les espaces réservés (%s, {0}) et les sauts de ligne Le contexte compte : Lisez attentivement la source anglaise pour comprendre le contexte Posez des questions : Utilisez IRC ou les forums si quelque chose n\u0026rsquo;est pas clair Termes courants I2P Certains termes doivent rester en anglais ou être translittérés avec soin :\nI2P - Keep as is eepsite - Site web I2P (peut nécessiter une explication dans votre langue) tunnel - Chemin de connexion (éviter la terminologie Tor comme \u0026ldquo;circuit\u0026rdquo;) netDb - Base de données réseau floodfill - Type de router destination - Point de terminaison d\u0026rsquo;adresse I2P Tester vos traductions Compilez I2P avec vos traductions Changez la langue dans les paramètres de la console du routeur Parcourez toutes les pages pour vérifier : Le texte s\u0026rsquo;adapte aux éléments de l\u0026rsquo;interface Aucun caractère mal affiché (problèmes d\u0026rsquo;encodage) Les traductions ont du sens dans le contexte Foire aux questions Pourquoi le processus de traduction est-il si complexe ? Le processus utilise le contrôle de version (git) et des outils de traduction standards (fichiers .po) car :\nResponsabilité : Suivre qui a modifié quoi et quand Qualité : Examiner les modifications avant leur mise en ligne Cohérence : Maintenir un formatage et une structure de fichiers appropriés Évolutivité : Gérer efficacement les traductions dans plusieurs langues Collaboration : Plusieurs traducteurs peuvent travailler sur la même langue Ai-je besoin de compétences en programmation ? Non ! Si vous utilisez Transifex, vous avez seulement besoin de : - Maîtrise de l\u0026rsquo;anglais et de votre langue cible - Un navigateur web - Compétences informatiques de base\nPour une traduction manuelle, vous aurez besoin de connaissances de base en ligne de commande, mais aucune programmation n\u0026rsquo;est requise.\nCombien de temps cela prend-il ? Console du routeur : Environ 15-20 heures pour tous les fichiers Maintenance : Quelques heures par mois pour mettre à jour les nouvelles chaînes Plusieurs personnes peuvent-elles travailler sur une seule langue ? Oui ! La coordination est essentielle : - Utilisez Transifex pour une coordination automatique - Pour le travail manuel, communiquez sur le canal IRC #i2p-dev - Divisez le travail par sections ou fichiers\nQue faire si ma langue n\u0026rsquo;est pas répertoriée ? Demandez-le sur Transifex ou contactez l\u0026rsquo;équipe sur IRC. L\u0026rsquo;équipe de développement peut configurer une nouvelle langue rapidement.\nComment puis-je tester mes traductions avant de les soumettre ? Compiler I2P depuis les sources avec vos traductions Installer et exécuter localement Changer la langue dans les paramètres de la console Obtenir de l\u0026rsquo;aide Support IRC Rejoignez #i2p-dev sur IRC pour : - Aide technique avec les outils de traduction - Questions sur la terminologie I2P - Coordination avec les autres traducteurs - Support direct des développeurs\nForums Discussions sur la traduction dans les Forums I2P Inside I2P : Forum de traduction sur zzz.i2p (nécessite un routeur I2P) Documentation Documentation Transifex Documentation POEdit Manuel gettext Reconnaissance Tous les traducteurs sont crédités dans : - La console du routeur I2P (page À propos) - La page des crédits du site web - L\u0026rsquo;historique des commits Git - Les annonces de version\nVotre travail aide directement des personnes du monde entier à utiliser I2P de manière sûre et privée. Merci de votre contribution !\nProchaines étapes Prêt à commencer la traduction ?\nChoisissez votre méthode :\nDémarrage rapide : Inscrivez-vous sur Transifex Approche manuelle : Rejoignez #i2p-dev sur IRC Commencez petit : Traduisez quelques chaînes pour vous familiariser avec le processus\nDemandez de l\u0026rsquo;aide : N\u0026rsquo;hésitez pas à contacter sur IRC ou les forums\nMerci de contribuer à rendre I2P accessible à tous !\n","description":"Comment contribuer des traductions pour le site Web I2P et la console du routeur en utilisant Transifex ou des méthodes manuelles","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"Guide du nouveau traducteur","url":"/fr/docs/develop/new-translators/"},{"categories":null,"content":"À propos des hôtes de réensemencement De nouveaux routers ont besoin d’une poignée de pairs pour rejoindre le réseau I2P. Les Reseed hosts (serveurs de réamorçage) fournissent cet ensemble de démarrage initial via des téléchargements HTTPS chiffrés. Chaque reseed bundle (archive de réamorçage) est signé par l’hôte, ce qui empêche toute altération par des tiers non authentifiés. Les routers établis peuvent occasionnellement effectuer un reseed si leur ensemble de pairs devient obsolète.\nProcessus d’amorçage du réseau Lorsqu’un router I2P démarre pour la première fois ou a été hors ligne pendant une longue période, il a besoin de données RouterInfo (informations du routeur) pour se connecter au réseau. Comme le router n’a pas encore de pairs, il ne peut pas obtenir ces informations depuis l’intérieur du réseau I2P lui-même. Le mécanisme de reseed (réensemencement) résout ce problème d’amorçage en fournissant des fichiers RouterInfo depuis des serveurs HTTPS externes de confiance.\nLe processus de reseed (réamorçage) fournit 75 à 100 fichiers RouterInfo dans un seul paquet signé cryptographiquement. Cela garantit que les nouveaux routers peuvent établir rapidement des connexions sans les exposer à des attaques de type homme du milieu qui pourraient les isoler dans des partitions de réseau distinctes et non approuvées.\nÉtat actuel du réseau En octobre 2025, le réseau I2P fonctionne avec la version 2.10.0 du router (version de l\u0026rsquo;API 0.9.67). Le protocole de réensemencement introduit avec la version 0.9.14 demeure stable et inchangé dans ses fonctionnalités essentielles. Le réseau maintient plusieurs serveurs de réensemencement indépendants, répartis dans le monde entier, afin de garantir la disponibilité et la résistance à la censure.\nLe service checki2p surveille tous les serveurs I2P de reseed (réensemencement) toutes les 4 heures, fournissant des vérifications du statut en temps réel et des métriques de disponibilité pour l’infrastructure de reseed.\nSpécification du format de fichier SU3 Le format de fichier SU3 est la base du protocole de réensemencement d\u0026rsquo;I2P, fournissant une distribution de contenu signée cryptographiquement. Comprendre ce format est essentiel pour implémenter des serveurs et des clients de réensemencement.\nStructure des fichiers Le format SU3 se compose de trois composants principaux : un en-tête (40 octets ou plus), un contenu (longueur variable) et une signature (longueur indiquée dans l’en-tête).\nFormat de l\u0026rsquo;en-tête (octets 0-39 minimum) Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") ### Paramètres SU3 spécifiques au réensemencement Pour les bundles de reseed (réamorçage), le fichier SU3 doit avoir les caractéristiques suivantes :\nNom de fichier: Doit être exactement i2pseeds.su3 Type de contenu (octet 27): 0x03 (RESEED, réensemencement) Type de fichier (octet 25): 0x00 (ZIP) Type de signature (octets 8-9): 0x0006 (RSA-4096-SHA512) Chaîne de version: Horodatage Unix en ASCII (secondes depuis l\u0026rsquo;époque Unix, au format date +%s) Identifiant du signataire: Identifiant de type adresse e-mail correspondant au CN du certificat X.509 Paramètre de requête pour l\u0026rsquo;identifiant du réseau Depuis la version 0.9.42, les routers ajoutent ?netid=2 aux requêtes de réensemencement. Cela empêche les connexions inter-réseaux, car les réseaux de test utilisent des identifiants de réseau différents. Le réseau de production I2P actuel utilise l’identifiant de réseau 2.\nExemple de requête : https://reseed.example.com/i2pseeds.su3?netid=2\nStructure du contenu ZIP La section de contenu (après l’en-tête, avant la signature) contient une archive ZIP standard répondant aux exigences suivantes :\nCompression: Compression ZIP standard (DEFLATE) Nombre de fichiers: Généralement 75 à 100 fichiers RouterInfo Structure du répertoire: Tous les fichiers doivent se trouver à la racine (aucun sous-répertoire) Convention de nommage: routerInfo-{44-character-base64-hash}.dat Alphabet Base64: Doit utiliser l\u0026rsquo;alphabet Base64 modifié d\u0026rsquo;I2P L\u0026rsquo;alphabet base64 d\u0026rsquo;I2P diffère du base64 standard en utilisant - et ~ au lieu de + et / afin de garantir la compatibilité avec les systèmes de fichiers et les URL.\nSignature cryptographique La signature couvre l’ensemble du fichier depuis l’octet 0 jusqu’à la fin de la section de contenu. La signature elle-même est ajoutée après le contenu.\nAlgorithme de signature (RSA-4096-SHA512) Calculer le hachage SHA-512 de l’octet 0 jusqu’à la fin du contenu Signer le hachage en utilisant \u0026ldquo;raw\u0026rdquo; RSA (NONEwithRSA en terminologie Java; RSA sans remplissage) Compléter la signature avec des zéros en tête si nécessaire pour atteindre 512 octets Ajouter la signature de 512 octets à la fin du fichier Processus de vérification de signature Les clients doivent :\nLire les octets 0-11 pour déterminer le type et la longueur de la signature Lire l\u0026rsquo;en-tête complet pour localiser les limites du contenu Lire le contenu en flux tout en calculant le hachage SHA-512 Extraire la signature de la fin du fichier Vérifier la signature à l\u0026rsquo;aide de la clé publique RSA-4096 du signataire Rejeter le fichier si la vérification de la signature échoue Modèle de confiance des certificats Les clés de signature de reseed (mécanisme d’amorçage du réseau) sont distribuées sous forme de certificats X.509 autosignés avec des clés RSA-4096. Ces certificats sont inclus dans les paquets du router I2P dans le répertoire certificates/reseed/.\nFormat du certificat: - Type de clé: RSA-4096 - Signature: Auto-signée - CN du sujet: Doit correspondre à l\u0026rsquo;ID du signataire dans l\u0026rsquo;en-tête SU3 - Dates de validité: Les clients devraient faire respecter les périodes de validité du certificat\nExploiter un hôte Reseed (serveur de réensemencement) Exploiter un service de reseed (distribution initiale des données du netDb aux nouveaux routers) nécessite une attention particulière à la sécurité, à la fiabilité et à la diversité du réseau. Un plus grand nombre d’hôtes de reseed indépendants accroît la résilience et rend plus difficile pour des attaquants ou des censeurs de bloquer l’arrivée de nouveaux routers.\nExigences techniques Spécifications du serveur Système d’exploitation: Unix/Linux (Ubuntu, Debian, FreeBSD testés et recommandés) Connectivité: Adresse IPv4 statique requise, IPv6 recommandé mais facultatif CPU: Minimum 2 cœurs RAM: Minimum 2 Go Bande passante: Environ 15 Go par mois Disponibilité: Fonctionnement 24 h/24 et 7 j/7 requis I2P Router: I2P router bien intégré, fonctionnant en continu Exigences logicielles Java: JDK 8 ou ultérieur (Java 17+ sera requis à partir d\u0026rsquo;I2P 2.11.0) Serveur Web: nginx ou Apache avec prise en charge du proxy inverse (Lighttpd n\u0026rsquo;est plus pris en charge en raison des limitations de l\u0026rsquo;en-tête X-Forwarded-For) TLS/SSL: Certificat TLS valide (Let\u0026rsquo;s Encrypt, autosigné ou AC commerciale) Protection DDoS: fail2ban ou équivalent (obligatoire, non facultatif) Reseed Tools (outils de réensemencement initial du netDb): reseed-tools officiels depuis https://i2pgit.org/idk/reseed-tools Exigences de sécurité Configuration HTTPS/TLS Protocole: HTTPS uniquement, pas de repli HTTP Version TLS: TLS 1.2 minimum Suites de chiffrement: Doivent inclure des chiffrements forts compatibles avec Java 8+ CN/SAN du certificat: Doit correspondre au nom d’hôte de l’URL servie Type de certificat: Peut être autosigné s’il a été communiqué à l’équipe de développement, ou délivré par une autorité de certification reconnue Gestion des certificats Les certificats de signature SU3 et les certificats TLS remplissent des fonctions différentes :\nCertificat TLS (certificates/ssl/): Sécurise le transport HTTPS Certificat de signature SU3 (certificates/reseed/): Signe les paquets de réensemencement Les deux certificats doivent être fournis au coordinateur du reseed (amorçage initial du réseau) (zzz@mail.i2p ) en vue de leur inclusion dans les paquets du router.\nProtection contre les attaques DDoS et le scraping Les serveurs Reseed (serveurs de réensemencement) subissent des attaques récurrentes provenant d’implémentations défectueuses, de botnets et d’acteurs malveillants tentant d’aspirer la base de données du réseau. Les mesures de protection comprennent :\nfail2ban: Requis pour la limitation du débit et l\u0026rsquo;atténuation des attaques Diversité des lots: Distribuer des ensembles de RouterInfo différents à des demandeurs différents Cohérence des lots: Distribuer le même lot aux requêtes répétées provenant de la même IP dans une fenêtre temporelle configurable Restrictions de journalisation IP: Ne pas divulguer les journaux ni les adresses IP (exigence de la politique de confidentialité) Méthodes d\u0026rsquo;implémentation Méthode 1 : reseed-tools officiel (recommandé) L’implémentation canonique maintenue par le projet I2P. Dépôt : https://i2pgit.org/idk/reseed-tools Installation:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 Lors de la première exécution, l\u0026rsquo;outil générera : - your-email@mail.i2p.crt (certificat de signature SU3) - your-email@mail.i2p.pem (clé privée de signature SU3) - your-email@mail.i2p.crl (liste de révocation de certificats) - fichiers de certificat et de clé TLS\nFonctionnalités: - Génération automatique de bundles SU3 (350 variantes, 77 RouterInfos (descripteurs de router I2P) chacune) - Serveur HTTPS intégré - Reconstruction du cache toutes les 9 heures via cron - Prise en charge de l\u0026rsquo;en-tête X-Forwarded-For avec l\u0026rsquo;option --trustProxy - Compatible avec les configurations de proxy inverse\nDéploiement en production:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed Méthode 2: Implémentation en Python (pyseeder) Implémentation alternative par le projet PurpleI2P: https://github.com/PurpleI2P/pyseeder pip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 Méthode 3 : Déploiement avec Docker Pour les environnements conteneurisés, plusieurs implémentations prêtes pour Docker existent :\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: Ajoute un service onion de Tor et la prise en charge d’IPFS Configuration du proxy inverse Configuration de nginx upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } Configuration d’Apache \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; Enregistrement et coordination Pour inclure votre reseed server (serveur de réensemencement) dans le paquet officiel d\u0026rsquo;I2P:\nTerminez la configuration et les tests Envoyez les deux certificats (signature SU3 et TLS) au coordinateur du reseed (réensemencement) Contact : zzz@mail.i2p ou zzz@i2pmail.org Rejoignez #i2p-dev sur IRC2P pour la coordination avec les autres opérateurs Meilleures pratiques opérationnelles Surveillance et journalisation Activer le format de journalisation combiné d’Apache/nginx pour les statistiques Mettre en place la rotation des journaux (ils grossissent rapidement) Surveiller la réussite de la génération du bundle et les durées de reconstruction Suivre l’utilisation de la bande passante et les schémas de requêtes Ne jamais divulguer les adresses IP ni les journaux d’accès détaillés Calendrier de maintenance Toutes les 9 heures: Reconstruire le cache du bundle SU3 (format de mise à jour signé I2P) (automatisé via cron) Chaque semaine: Examiner les journaux à la recherche de schémas d\u0026rsquo;attaque Chaque mois: Mettre à jour l\u0026rsquo;I2P router et reseed-tools (outils de réensemencement I2P) Au besoin: Renouveler les certificats TLS (automatiser avec Let\u0026rsquo;s Encrypt) Sélection des ports Par défaut : 8443 (recommandé) Alternative : n\u0026rsquo;importe quel port entre 1024-49151 Port 443 : requiert des privilèges root ou une redirection de port (redirection iptables recommandée) Exemple de redirection de port:\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 Méthodes alternatives de reseed (réamorçage de netDb) D\u0026rsquo;autres options d\u0026rsquo;amorçage aident les utilisateurs situés derrière des réseaux restrictifs :\nReseed (réamorçage) basé sur des fichiers Introduit dans la version 0.9.16, le réensemencement basé sur des fichiers permet aux utilisateurs de charger manuellement des paquets RouterInfo (informations du router). Cette méthode est particulièrement utile pour les utilisateurs situés dans des régions censurées où les serveurs de réensemencement HTTPS sont bloqués.\nProcessus: 1. Un contact de confiance génère un SU3 bundle (fichier SU3 signé) à l\u0026rsquo;aide de son router 2. Le bundle est transféré via e-mail, une clé USB ou un autre canal hors bande 3. L\u0026rsquo;utilisateur place i2pseeds.su3 dans le répertoire de configuration d\u0026rsquo;I2P 4. Le router détecte et traite automatiquement le bundle au redémarrage\nDocumentation: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\nCas d\u0026rsquo;utilisation: - Utilisateurs derrière des pare-feux nationaux bloquant les reseed servers (serveurs de réamorçage) - Réseaux isolés nécessitant un bootstrap (amorçage) manuel - Environnements de test et de développement\nRéensemencement via Cloudflare Acheminer le trafic de reseed (réamorçage) via le CDN de Cloudflare offre plusieurs avantages pour les opérateurs dans les régions fortement censurées.\nAvantages: - Adresse IP du serveur d’origine masquée aux clients - Protection contre les attaques DDoS grâce à l’infrastructure de Cloudflare - Répartition géographique de la charge via la mise en cache en périphérie - Amélioration des performances pour les clients du monde entier\nExigences d\u0026rsquo;implémentation: - option --trustProxy activée dans reseed-tools - Proxy Cloudflare activé pour l\u0026rsquo;enregistrement DNS - Gestion correcte de l\u0026rsquo;en-tête X-Forwarded-For\nPoints importants: - Des restrictions de ports Cloudflare s\u0026rsquo;appliquent (il faut utiliser des ports pris en charge) - La cohérence du regroupement par client nécessite la prise en charge de X-Forwarded-For - La configuration SSL/TLS est gérée par Cloudflare\nDocumentation : https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/ Stratégies résistantes à la censure Une étude de Nguyen Phong Hoang (USENIX FOCI 2019) identifie des méthodes d’amorçage supplémentaires pour les réseaux censurés :\nFournisseurs de stockage dans le cloud Box, Dropbox, Google Drive, OneDrive: Héberger des fichiers SU3 sur des liens publics Avantage: Difficile à bloquer sans perturber les services légitimes Limitation: Nécessite la distribution manuelle des URL aux utilisateurs Distribution IPFS Héberger des paquets de reseed (réensemencement) sur InterPlanetary File System Le stockage adressé par contenu empêche toute altération Résistant aux tentatives de retrait Services onion de Tor Serveurs de réensemencement accessibles via des adresses .onion Résistant au blocage par adresse IP Nécessite un client Tor sur le système de l’utilisateur Documentation de recherche: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/ Pays où I2P est connu pour être bloqué En 2025, il est confirmé que les pays suivants bloquent les I2P reseed servers (serveurs d\u0026rsquo;amorçage du réseau):\nChine Iran Oman Qatar Koweït Les utilisateurs de ces régions devraient utiliser des méthodes d’amorçage alternatives ou des stratégies de reseeding (réamorçage du réseau) résistantes à la censure.\nDétails du protocole pour les implémenteurs Spécification de la requête de reseed (amorçage initial du netDb) Comportement du client Sélection du serveur: Router maintient une liste codée en dur d’URL de reseed (bootstrap/amorçage initial du netDb) Sélection aléatoire: Le client sélectionne aléatoirement un serveur dans la liste disponible Format de requête: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: Doit imiter les navigateurs courants (p. ex., \u0026ldquo;Wget/1.11.4\u0026rdquo;) Logique de nouvelle tentative: Si la requête SU3 échoue, se replier sur l’analyse de la page d’index Validation du certificat: Vérifier le certificat TLS par rapport au magasin de certificats de confiance du système Validation de la signature SU3: Vérifier la signature par rapport aux certificats de reseed connus Comportement du serveur Sélection du lot: Sélectionner un sous-ensemble pseudo-aléatoire de RouterInfos depuis netDb Suivi client: Identifier les requêtes par l’adresse IP source (en respectant X-Forwarded-For) Cohérence du lot: Renvoyer le même lot pour les requêtes répétées dans une fenêtre temporelle (généralement 8-12 heures) Diversité des lots: Renvoyer des lots différents à des clients différents pour assurer la diversité du réseau Content-Type: application/octet-stream ou application/x-i2p-reseed Format du fichier RouterInfo Chaque fichier .dat dans le paquet de reseed contient une structure RouterInfo (structure d\u0026rsquo;information du router) :\nNommage des fichiers: routerInfo-{base64-hash}.dat - Le hachage comporte 44 caractères en utilisant l\u0026rsquo;alphabet base64 d\u0026rsquo;I2P - Exemple: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat\nContenu du fichier: - RouterIdentity (hachage du router, clé de chiffrement, clé de signature) - Horodatage de publication - Adresses du router (IP, port, type de transport) - Fonctionnalités et options du router - Signature couvrant l\u0026rsquo;ensemble des données ci-dessus\nExigences en matière de diversité du réseau Pour éviter la centralisation du réseau et permettre la détection des attaques Sybil :\nPas de dumps NetDb complets: Ne jamais fournir tous les RouterInfos (descripteurs de router I2P) à un seul client Échantillonnage aléatoire: Chaque lot contient un sous-ensemble différent des pairs disponibles Taille minimale du lot: 75 RouterInfos (augmentée par rapport à la valeur initiale de 50) Taille maximale du lot: 100 RouterInfos Fraîcheur: Les RouterInfos doivent être récents (dans les 24 heures suivant leur génération) Considérations relatives à IPv6 État actuel (2025): - Plusieurs serveurs de réensemencement présentent une absence de réponse en IPv6 - Les clients devraient privilégier ou imposer l\u0026rsquo;IPv4 pour plus de fiabilité - La prise en charge d\u0026rsquo;IPv6 est recommandée pour les nouveaux déploiements, mais elle n\u0026rsquo;est pas critique\nRemarque d’implémentation: Lors de la configuration de serveurs à double pile, assurez-vous que les adresses d’écoute IPv4 et IPv6 fonctionnent correctement, ou désactivez IPv6 s’il ne peut pas être correctement pris en charge.\nConsidérations de sécurité Modèle de menace Le protocole de reseed protège contre :\nAttaques de l\u0026rsquo;homme du milieu: Les signatures RSA-4096 empêchent l\u0026rsquo;altération des paquets Partitionnement du réseau: Plusieurs serveurs de réensemencement indépendants empêchent l\u0026rsquo;existence d\u0026rsquo;un point de contrôle unique Attaques Sybil: La diversité des paquets limite la capacité de l\u0026rsquo;attaquant à isoler les utilisateurs Censure: Plusieurs serveurs et des méthodes alternatives offrent une redondance Le protocole de reseed (bootstrap : procédure d’amorçage initiale du réseau I2P) ne protège PAS contre :\nServeurs reseed compromis (serveurs de réensemencement): Si un attaquant contrôle les clés privées des certificats de reseed Blocage complet du réseau: Si toutes les méthodes de reseed sont bloquées dans une région Surveillance à long terme: Les requêtes de reseed révèlent l\u0026rsquo;adresse IP qui tente de rejoindre I2P Gestion des certificats Sécurité des clés privées: - Conservez les clés de signature SU3 hors ligne lorsqu\u0026rsquo;elles ne sont pas utilisées - Utilisez des mots de passe robustes pour le chiffrement des clés - Maintenez des sauvegardes sécurisées des clés et des certificats - Envisagez des modules matériels de sécurité (HSM) pour les déploiements à forte valeur\nRévocation de certificats: - Listes de révocation de certificats (CRLs) distribuées via un flux d\u0026rsquo;actualités - Les certificats compromis peuvent être révoqués par le coordinateur - Routers mettent automatiquement à jour les CRLs avec les mises à jour logicielles\nAtténuation des attaques Protection contre les attaques DDoS: - règles fail2ban pour les requêtes excessives - limitation de débit au niveau du serveur web - limites de connexions par adresse IP - Cloudflare ou un CDN similaire pour une couche supplémentaire\nPrévention du scraping: - Différents bundles (lots) par adresse IP requérante - Mise en cache temporelle des bundles par adresse IP - Journalisation de motifs indiquant des tentatives de scraping - Coordination avec d\u0026rsquo;autres opérateurs concernant les attaques détectées\nTests et validation Tester votre serveur de réensemencement Méthode 1 : Installation neuve du Router Installez I2P sur un système vierge Ajoutez votre URL de réensemencement à la configuration Supprimez ou désactivez les autres URL de réensemencement Démarrez le router et surveillez les journaux pour confirmer un réensemencement réussi Vérifiez la connexion au réseau dans les 5 à 10 minutes Sortie de journal attendue :\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received Méthode 2 : validation manuelle de SU3 (format de paquet de mise à jour signé d\u0026rsquo;I2P) # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) Méthode 3: surveillance via checki2p Le service à l’adresse https://checki2p.com/reseed effectue des vérifications automatisées toutes les 4 heures sur tous les serveurs de reseed I2P (reseed : serveur qui fournit les informations initiales du réseau aux nouveaux router I2P) enregistrés. Cela permet :\nSurveillance de la disponibilité Métriques du temps de réponse Validation des certificats TLS Vérification de la signature SU3 (format de paquet de mise à jour d\u0026rsquo;I2P) Données historiques de temps de fonctionnement Une fois que votre reseed (serveur de réamorçage) est enregistré auprès du projet I2P, il apparaîtra automatiquement sur checki2p dans les 24 heures.\nDépannage des problèmes courants Problème: \u0026ldquo;Unable to read signing key\u0026rdquo; lors du premier lancement - Solution: C\u0026rsquo;est normal. Répondez \u0026lsquo;y\u0026rsquo; pour générer de nouvelles clés.\nProblème: Le router ne parvient pas à vérifier la signature - Cause: Le certificat n\u0026rsquo;est pas dans le magasin de confiance du router - Solution: Placez le certificat dans le répertoire ~/.i2p/certificates/reseed/\nProblème: Même bundle livré à différents clients - Cause: l’en-tête X-Forwarded-For n’est pas correctement transmis - Solution: Activer --trustProxy et configurer les en-têtes du proxy inverse\nProblème: erreurs \u0026ldquo;Connection refused\u0026rdquo; - Cause: port non accessible depuis Internet - Solution: Vérifiez les règles du pare-feu, vérifiez la redirection de port\nProblème: Utilisation élevée du processeur lors de la reconstruction du bundle - Cause: Comportement normal lors de la génération de plus de 350 variantes SU3 (format de fichier de mise à jour d\u0026rsquo;I2P) - Solution: Veillez à disposer de ressources processeur suffisantes, envisagez de réduire la fréquence des reconstructions\nInformations de référence Documentation officielle Guide des contributeurs de Reseed (réamorçage): /guides/creating-and-running-an-i2p-reseed-server/ Exigences de la politique de Reseed: /guides/reseed-policy/ Spécification SU3: /docs/specs/updates/ Dépôt des outils de Reseed: https://i2pgit.org/idk/reseed-tools Documentation des outils de Reseed: https://eyedeekay.github.io/reseed-tools/ Implémentations alternatives PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Reseeder (serveur de réensemencement) WSGI Python: https://github.com/torbjo/i2p-reseeder Ressources communautaires Forum I2P: https://i2pforum.net/ Dépôt Gitea: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: #i2p-dev sur IRC2P Surveillance de l\u0026rsquo;état: https://checki2p.com/reseed Historique des versions 0.9.14 (2014): Introduction du format de réensemencement SU3 0.9.16 (2014): Ajout du réensemencement basé sur des fichiers 0.9.42 (2019): Exigence du paramètre de requête ID de réseau 2.0.0 (2022): Introduction du protocole de transport SSU2 2.4.0 (2024): Améliorations de l’isolation et de la sécurité de NetDB 2.6.0 (2024): Connexions I2P-over-Tor bloquées 2.10.0 (2025): Version stable actuelle (en septembre 2025) Référence des types de signature Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 **Standard de réensemencement**: Le type 6 (RSA-SHA512-4096) est requis pour les paquets de réensemencement. Remerciements Merci à tous les reseed operator (opérateurs des services d’amorçage du réseau) pour que le réseau reste accessible et résilient. Une reconnaissance particulière aux contributeurs et projets suivants :\nzzz: Développeur I2P de longue date et coordinateur du réensemencement idk: Mainteneur actuel de reseed-tools et responsable des versions Nguyen Phong Hoang: Recherche sur des stratégies de réensemencement résistantes à la censure PurpleI2P Team: Implémentations et outils I2P alternatifs checki2p: Service de surveillance automatisé pour l’infrastructure de réensemencement L’infrastructure de réensemencement décentralisée du réseau I2P représente un effort collaboratif de la part de dizaines d’opérateurs à travers le monde, garantissant que les nouveaux utilisateurs puissent toujours trouver une voie pour rejoindre le réseau, indépendamment de la censure locale ou des obstacles techniques.\n","description":"Exploitation des services de reseed (distribution initiale du netDb) et des méthodes alternatives d'amorçage","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"Hôtes de réensemencement","url":"/fr/docs/misc/reseed/"},{"categories":null,"content":"Introduction I2P est une couche réseau anonyme à commutation de paquets, évolutive, auto-organisée et résiliente, sur laquelle peut fonctionner un nombre quelconque d\u0026rsquo;applications différentes soucieuses de l\u0026rsquo;anonymat ou de la sécurité. Chacune de ces applications peut faire ses propres compromis en matière d\u0026rsquo;anonymat, de latence et de débit sans se soucier de la mise en œuvre appropriée d\u0026rsquo;un mixnet à route libre, leur permettant de fusionner leur activité avec l\u0026rsquo;ensemble d\u0026rsquo;anonymat plus large des utilisateurs qui utilisent déjà I2P.\nLes applications déjà disponibles offrent une gamme complète d\u0026rsquo;activités Internet typiques — navigation web anonyme, hébergement web, messagerie instantanée, partage de fichiers, courrier électronique, blogs et syndication de contenu, ainsi que plusieurs autres applications en cours de développement.\nNavigation web : en utilisant n\u0026rsquo;importe quel navigateur existant qui prend en charge un proxy Chat : IRC et autres protocoles Partage de fichiers : I2PSnark et autres applications E-mail : Susimail et autres applications Blog : en utilisant n\u0026rsquo;importe quel serveur web local, ou des plugins disponibles Contrairement aux sites web hébergés au sein de réseaux de distribution de contenu comme Freenet ou GNUnet , les services hébergés sur I2P sont entièrement interactifs — il existe des moteurs de recherche de style web traditionnel, des forums de discussion, des blogs sur lesquels vous pouvez commenter, des sites pilotés par base de données, et des passerelles pour interroger des systèmes statiques comme Freenet sans avoir besoin de les installer localement.\nAvec toutes ces applications permettant l\u0026rsquo;anonymat, I2P agit comme un intergiciel orienté messages — les applications spécifient les données à envoyer vers un identifiant cryptographique (une \u0026ldquo;destination\u0026rdquo;), et I2P s\u0026rsquo;assure qu\u0026rsquo;elles arrivent de manière sécurisée et anonyme. I2P inclut également une simple bibliothèque de streaming pour permettre aux messages anonymes en best-effort d\u0026rsquo;I2P d\u0026rsquo;être transférés sous forme de flux fiables et ordonnés, offrant un contrôle de congestion basé sur TCP adapté au produit bande passante-délai élevé du réseau.\nBien que de simples proxies SOCKS aient été développés pour connecter des applications existantes, leur valeur est limitée car la plupart des applications divulguent des informations sensibles dans un contexte anonyme. L\u0026rsquo;approche la plus sûre consiste à auditer et adapter l\u0026rsquo;application pour utiliser directement les API d\u0026rsquo;I2P.\nI2P n\u0026rsquo;est pas un projet de recherche — académique, commercial ou gouvernemental — mais un effort d\u0026rsquo;ingénierie visant à fournir un anonymat utilisable. Il est en développement continu depuis début 2003 par un groupe distribué de contributeurs dans le monde entier. Tout le travail sur I2P est open source sur le site officiel , principalement publié dans le domaine public, avec certains composants sous licences permissives de style BSD. Plusieurs applications clientes sous licence GPL sont disponibles, telles que I2PTunnel , Susimail et I2PSnark . Le financement provient uniquement de dons d\u0026rsquo;utilisateurs.\nFonctionnement Overview I2P fait une distinction claire entre les routers (nœuds participant au réseau) et les destinations (points de terminaison anonymes pour les applications). L\u0026rsquo;exécution d\u0026rsquo;I2P elle-même n\u0026rsquo;est pas secrète ; ce qui est caché est ce que l\u0026rsquo;utilisateur fait et quel router ses destinations utilisent. Les utilisateurs finaux exécutent généralement plusieurs destinations (par exemple, une pour la navigation web, une autre pour l\u0026rsquo;hébergement, une autre pour IRC).\nUn concept clé dans I2P est le tunnel — un chemin unidirectionnel chiffré à travers une série de routeurs. Chaque routeur ne déchiffre qu\u0026rsquo;une seule couche et ne connaît que le saut suivant. Les tunnels expirent toutes les 10 minutes et doivent être reconstruits.\nFigure 1 : Il existe deux types de tunnels — entrants (inbound) et sortants (outbound).\nLes tunnels sortants envoient des messages depuis le créateur. Les tunnels entrants ramènent des messages vers le créateur. La combinaison de ces éléments permet une communication bidirectionnelle. Par exemple, \u0026ldquo;Alice\u0026rdquo; utilise un tunnel sortant pour envoyer vers le tunnel entrant de \u0026ldquo;Bob\u0026rdquo;. Alice chiffre son message avec les instructions de routage vers la passerelle d\u0026rsquo;entrée de Bob.\nUn autre concept clé est la base de données réseau ou netDb, qui distribue les métadonnées sur les routeurs et les destinations :\nRouterInfo: Contient les informations de contact du routeur et le matériel cryptographique. LeaseSet: Contient les informations nécessaires pour contacter une destination (passerelles de tunnel, dates d\u0026rsquo;expiration, clés de chiffrement). Les routeurs publient leur RouterInfo directement dans la netDb ; les LeaseSets sont envoyés via des tunnels sortants pour l\u0026rsquo;anonymat.\nPour construire des tunnels, Alice interroge la netDb à la recherche d\u0026rsquo;entrées RouterInfo afin de choisir des pairs, puis envoie des messages de construction de tunnel chiffrés de pair en pair jusqu\u0026rsquo;à ce que le tunnel soit complet.\nFigure 2 : Les informations de router sont utilisées pour construire des tunnels.\nPour envoyer des données à Bob, Alice recherche le LeaseSet de Bob et utilise l\u0026rsquo;un de ses tunnels sortants pour acheminer les données via la passerelle du tunnel entrant de Bob.\nFigure 3 : Les LeaseSets connectent les tunnels sortants et entrants.\nParce qu\u0026rsquo;I2P est basé sur les messages, il ajoute un chiffrement garlic de bout en bout pour protéger les messages même du point de sortie sortant ou de la passerelle d\u0026rsquo;entrée. Un message garlic enveloppe plusieurs \u0026ldquo;cloves\u0026rdquo; (messages) chiffrés pour masquer les métadonnées et améliorer l\u0026rsquo;anonymat.\nLes applications peuvent soit utiliser l\u0026rsquo;interface de message directement, soit s\u0026rsquo;appuyer sur la bibliothèque de streaming pour des connexions fiables.\nTunnels Les tunnels entrants et sortants utilisent tous deux le chiffrement en couches, mais diffèrent dans leur construction :\nDans les tunnels entrants, le créateur (le point de terminaison) déchiffre toutes les couches. Dans les tunnels sortants, le créateur (la passerelle) pré-déchiffre les couches pour assurer la clarté au point de terminaison. I2P profile les pairs via des métriques indirectes telles que la latence et la fiabilité sans sondage direct. Sur la base de ces profils, les pairs sont regroupés dynamiquement en quatre niveaux :\nRapide et haute capacité Haute capacité Non défaillant Défaillant La sélection des pairs de tunnel privilégie généralement les pairs à haute capacité, choisis aléatoirement pour équilibrer anonymat et performance, avec des stratégies d\u0026rsquo;ordonnancement supplémentaires basées sur XOR pour atténuer les attaques par prédécesseur et la collecte du netDb.\nPour plus de détails, consultez la Spécification des Tunnels .\nAperçu Les routeurs participant à la table de hachage distribuée (DHT) floodfill stockent et répondent aux recherches de LeaseSet. La DHT utilise une variante de Kademlia . Les routeurs floodfill sont sélectionnés automatiquement s\u0026rsquo;ils disposent de suffisamment de capacité et de stabilité, ou peuvent être configurés manuellement.\nRouterInfo: Décrit les capacités et les transports d\u0026rsquo;un router. LeaseSet: Décrit les tunnels et les clés de chiffrement d\u0026rsquo;une destination. Toutes les données dans le netDb sont signées par l\u0026rsquo;éditeur et horodatées pour prévenir les attaques par rejeu ou par entrées périmées. La synchronisation temporelle est maintenue via SNTP et la détection de décalage au niveau de la couche transport.\nAdditional concepts LeaseSets non publiés et chiffrés :\nUne destination peut rester privée en ne publiant pas son LeaseSet, en le partageant uniquement avec des pairs de confiance. L\u0026rsquo;accès nécessite la clé de déchiffrement appropriée.\nBootstrapping (reseeding) :\nPour rejoindre le réseau, un nouveau router télécharge des fichiers RouterInfo signés depuis des serveurs de reseed HTTPS de confiance.\nÉvolutivité des recherches :\nI2P utilise des recherches itératives, et non récursives, pour améliorer l\u0026rsquo;évolutivité et la sécurité de la DHT.\nTunnels La communication I2P moderne utilise deux transports entièrement chiffrés :\nNTCP2 : Protocole basé sur TCP chiffré SSU2 : Protocole basé sur UDP chiffré Tous deux sont construits sur le moderne Noise Protocol Framework , offrant une authentification forte et une résistance à l\u0026rsquo;empreinte digitale du trafic. Ils ont remplacé les protocoles hérités NTCP et SSU (complètement retirés depuis 2023).\nNTCP2 offre un streaming chiffré et efficace sur TCP.\nSSU2 fournit une fiabilité basée sur UDP, la traversée NAT et un perçage de trou optionnel. SSU2 est conceptuellement similaire à WireGuard ou QUIC, équilibrant fiabilité et anonymat.\nLes routeurs peuvent prendre en charge à la fois IPv4 et IPv6, en publiant leurs adresses de transport et leurs coûts dans la netDb. Le transport d\u0026rsquo;une connexion est sélectionné dynamiquement par un système d\u0026rsquo;enchères qui optimise en fonction des conditions et des liens existants.\nBase de données réseau (netDb) I2P utilise une cryptographie en couches pour tous les composants : transports, tunnels, messages garlic et la base de données réseau (netDb).\nLes primitives actuelles incluent :\nX25519 pour l\u0026rsquo;échange de clés EdDSA (Ed25519) pour les signatures ChaCha20-Poly1305 pour le chiffrement authentifié SHA-256 pour le hachage AES256 pour le chiffrement de la couche tunnel Les algorithmes historiques (ElGamal, DSA-SHA1, ECDSA) sont conservés pour des raisons de rétrocompatibilité.\nI2P introduit actuellement des schémas cryptographiques hybrides post-quantiques (PQ) combinant X25519 avec ML-KEM pour résister aux attaques de type « récolter maintenant, déchiffrer plus tard ».\nGarlic Messages Les messages garlic étendent le routage en oignon en regroupant plusieurs « cloves » (segments) chiffrés avec des instructions de livraison indépendantes. Ceux-ci permettent une flexibilité de routage au niveau des messages et un remplissage uniforme du trafic.\nSession Tags Deux systèmes cryptographiques sont pris en charge pour le chiffrement de bout en bout :\nElGamal/AES+SessionTags (hérité) :\nUtilise des tags de session pré-livrés comme nonces de 32 octets. Désormais obsolète en raison de son inefficacité.\nECIES-X25519-AEAD-Ratchet (actuel) :\nUtilise ChaCha20-Poly1305 et des PRNG synchronisés basés sur HKDF pour générer dynamiquement des clés de session éphémères et des balises de 8 octets, réduisant la charge processeur, mémoire et bande passante tout en maintenant la confidentialité persistante (forward secrecy).\nFuture of the Protocol Les domaines de recherche clés se concentrent sur le maintien de la sécurité contre les adversaires étatiques et l\u0026rsquo;introduction de protections post-quantiques. Deux concepts de conception précoces — les routes restreintes et la latence variable — ont été remplacés par des développements modernes.\nRestricted Route Operation Les concepts originaux de routage restreint visaient à masquer les adresses IP. Ce besoin a été largement atténué par :\nUPnP pour la redirection automatique de ports Traversée NAT robuste en SSU2 Support IPv6 Introducers coopératifs et perforation NAT Connectivité overlay optionnelle (par exemple, Yggdrasil) Ainsi, l\u0026rsquo;I2P moderne atteint les mêmes objectifs de manière plus pratique sans routage restreint complexe.\nSimilar Systems I2P intègre des concepts issus des middleware orientés messages, des DHT et des mixnets. Son innovation réside dans la combinaison de ces éléments en une plateforme d\u0026rsquo;anonymat utilisable et auto-organisée.\nProtocoles de transport Site web Tor et I2P partagent des objectifs mais diffèrent architecturalement :\nTor: Commutation de circuits ; repose sur des autorités d\u0026rsquo;annuaire de confiance. (~10k relais) I2P: Commutation de paquets ; réseau entièrement distribué piloté par DHT. (~50k routers) Les tunnels unidirectionnels d\u0026rsquo;I2P exposent moins de métadonnées et permettent des chemins de routage flexibles, tandis que Tor se concentre sur l\u0026rsquo;accès anonyme à Internet (outproxying). I2P prend plutôt en charge l\u0026rsquo;hébergement anonyme dans le réseau.\nCryptographie Site web Freenet se concentre sur la publication et la récupération anonymes et persistantes de fichiers. I2P, en revanche, fournit une couche de communications en temps réel pour une utilisation interactive (web, chat, torrents). Ensemble, les deux systèmes se complètent — Freenet fournit un stockage résistant à la censure ; I2P fournit l\u0026rsquo;anonymat du transport.\nOther Networks Lokinet: Réseau superposé basé sur IP utilisant des nœuds de service incités. Nym: Mixnet de nouvelle génération mettant l\u0026rsquo;accent sur la protection des métadonnées avec trafic de couverture à latence plus élevée. Appendix A: Application Layer I2P lui-même ne gère que le transport des messages. Les fonctionnalités de la couche application sont implémentées en externe via des API et des bibliothèques.\nStreaming Library La bibliothèque de streaming fonctionne comme l\u0026rsquo;analogue TCP d\u0026rsquo;I2P, avec un protocole de fenêtre glissante et un contrôle de congestion optimisés pour le transport anonyme à haute latence.\nLes schémas typiques de requête/réponse HTTP peuvent souvent se terminer en un seul aller-retour grâce aux optimisations de regroupement de messages.\nNaming Library and Address Book Développé par : mihi, Ragnarok Voir la page Nommage et Carnet d\u0026rsquo;adresses .\nLe système de nommage d\u0026rsquo;I2P est local et décentralisé, évitant les noms globaux de type DNS. Chaque router maintient une correspondance locale entre des noms lisibles par l\u0026rsquo;homme et des destinations. Des carnets d\u0026rsquo;adresses optionnels basés sur un réseau de confiance peuvent être partagés ou importés depuis des pairs de confiance.\nCette approche évite les autorités centralisées et contourne les vulnérabilités Sybil inhérentes aux systèmes de nommage globaux ou basés sur le vote.\nFonctionnement en mode de routage restreint Développé par : mihi\nI2PTunnel est l\u0026rsquo;interface principale de la couche client permettant le proxy TCP anonyme. Il prend en charge :\nTunnels client (sortants vers les destinations I2P) Client HTTP (eepproxy) pour les domaines \u0026ldquo;.i2p\u0026rdquo; Tunnels serveur (entrants depuis I2P vers un service local) Tunnels serveur HTTP (proxy sécurisé pour les services web) L\u0026rsquo;outproxy (vers l\u0026rsquo;Internet classique) est facultatif, mis en œuvre par des tunnels « serveur » gérés par des volontaires.\nI2PSnark Développé par : jrandom, et al — porté depuis Snark Fourni avec I2P, I2PSnark est un client BitTorrent anonyme multi-torrent avec support DHT et UDP, accessible via une interface web.\nTor Développé par : postman, susi23, mastiejaner\nI2Pmail fournit un courrier électronique anonyme via des connexions I2PTunnel. Susimail est un client web conçu spécifiquement pour empêcher les fuites d\u0026rsquo;informations courantes dans les clients de messagerie traditionnels. Le service mail.i2p propose un filtrage antivirus, des quotas hashcash et une séparation des proxies de sortie pour une protection supplémentaire.\n","description":"Introduction technique à l'architecture et au fonctionnement d'I2P","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P : Un cadre évolutif pour la communication anonyme","url":"/fr/docs/overview/tech-intro/"},{"categories":null,"content":"Introduction I2P fournit une messagerie privée de type e-mail via le service Postman\u0026rsquo;s Mail.i2p combiné avec SusiMail, un client webmail intégré. Ce système permet aux utilisateurs d\u0026rsquo;envoyer et de recevoir des e-mails à la fois au sein du réseau I2P et vers/depuis l\u0026rsquo;internet classique (clearnet) via une passerelle.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nPostman / Mail.i2p + SusiMail What it is Mail.i2p est un fournisseur d\u0026rsquo;e-mail hébergé à l\u0026rsquo;intérieur d\u0026rsquo;I2P, géré par \u0026ldquo;Postman\u0026rdquo; SusiMail est le client webmail intégré dans la console du routeur I2P. Il est conçu pour éviter la fuite de métadonnées (par ex. nom d\u0026rsquo;hôte) vers les serveurs SMTP externes. Grâce à cette configuration, les utilisateurs I2P peuvent envoyer/recevoir des messages à la fois au sein d\u0026rsquo;I2P et vers/depuis le clearnet (par ex. Gmail) via le pont Postman. How Addressing Works Le courrier électronique I2P utilise un système à double adresse :\nÀ l\u0026rsquo;intérieur du réseau I2P : username@mail.i2p (par ex., idk@mail.i2p) Depuis le clearnet : username@i2pmail.org (par ex., idk@i2pmail.org) La passerelle i2pmail.org permet aux utilisateurs réguliers d\u0026rsquo;Internet d\u0026rsquo;envoyer des emails vers des adresses I2P, et aux utilisateurs I2P d\u0026rsquo;envoyer vers des adresses clearnet. Les emails Internet sont acheminés via la passerelle avant d\u0026rsquo;être transférés à travers I2P vers votre boîte de réception SusiMail.\nQuota d\u0026rsquo;envoi Clearnet : 20 emails par jour lors de l\u0026rsquo;envoi vers des adresses internet classiques.\nCe que c\u0026rsquo;est Pour créer un compte mail.i2p :\nAssurez-vous que votre routeur I2P est en cours d\u0026rsquo;exécution Visitez http://hq.postman.i2p à l\u0026rsquo;intérieur d\u0026rsquo;I2P Suivez le processus d\u0026rsquo;inscription Accédez à votre courriel via SusiMail dans la console du routeur Note : hq.postman.i2p est une adresse réseau I2P (eepsite) et ne peut être accessible que lorsque vous êtes connecté à I2P. Pour plus d\u0026rsquo;informations sur la configuration, la sécurité et l\u0026rsquo;utilisation de la messagerie électronique, visitez Postman HQ.\nComment fonctionne l\u0026rsquo;adressage Suppression automatique des en-têtes identifiants (User-Agent:, X-Mailer:) pour la confidentialité Nettoyage des métadonnées pour éviter les fuites vers les serveurs SMTP externes Chiffrement de bout en bout pour les courriels internes I2P-à-I2P Démarrage Interopérabilité avec l\u0026rsquo;email \u0026ldquo;normal\u0026rdquo; (SMTP/POP) via le pont Postman Expérience utilisateur simple (webmail intégré dans la console du routeur) Intégré à la distribution I2P de base (SusiMail est fourni avec Java I2P) Suppression des en-têtes pour la protection de la vie privée Fonctionnalités de confidentialité Le pont vers l\u0026rsquo;email externe nécessite une confiance dans l\u0026rsquo;infrastructure de Postman Le pont vers le clearnet réduit la confidentialité par rapport à une communication purement interne à I2P Dépend de la disponibilité et de la sécurité du serveur de messagerie Postman IMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nTechnical Details Service SMTP : localhost:7659 (fourni par Postman) Service POP3 : localhost:7660 Accès Webmail : Intégré dans la console du routeur à http://127.0.0.1:7657/susimail/\nImportant : SusiMail est uniquement destiné à la lecture et l\u0026rsquo;envoi d\u0026rsquo;e-mails. La création et la gestion des comptes doivent être effectuées sur hq.postman.i2p.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte est juste un titre ou semble incomplet, traduisez-le tel quel.\nBest Practices Changez votre mot de passe après avoir enregistré votre compte mail.i2p Utilisez le courriel I2P-à-I2P autant que possible pour une confidentialité maximale (pas de passerelle clearnet) Tenez compte de la limite de 20/jour lors de l\u0026rsquo;envoi vers des adresses clearnet Comprenez les compromis : La passerelle clearnet offre la commodité mais réduit l\u0026rsquo;anonymat comparé aux communications purement internes à I2P Maintenez I2P à jour pour bénéficier des améliorations de sécurité dans SusiMail IMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\n","description":"Un aperçu des systèmes de messagerie électronique au sein du réseau I2P — historique, options et statut actuel","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"I2P Mail (courrier électronique anonyme sur I2P)","url":"/fr/docs/applications/i2p-mail/"},{"categories":null,"content":"Aperçu Plusieurs grands réseaux de confidentialité et d\u0026rsquo;anonymat existent aujourd\u0026rsquo;hui, chacun avec des objectifs de conception et des modèles de menace différents. Bien que Tor, Lokinet, GNUnet et Freenet apportent tous des approches précieuses pour les communications préservant la vie privée, I2P se distingue comme le seul réseau à commutation de paquets prêt pour la production, entièrement optimisé pour les services cachés dans le réseau et les applications pair-à-pair.\nLe tableau ci-dessous résume les principales distinctions architecturales et opérationnelles entre ces réseaux en 2025.\nComparaison des Réseaux de Confidentialité (2025) Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) --- Pourquoi I2P est leader en matière de conception axée sur la confidentialité 1. Packet Switching \u0026gt; Circuit Switching Le modèle à commutation de circuits de Tor lie le trafic à des chemins fixes de trois sauts—efficace pour la navigation, mais fragile pour les services internes de longue durée. Les tunnels à commutation de paquets d\u0026rsquo;I2P envoient les messages à travers plusieurs chemins simultanés, contournant automatiquement la congestion ou les pannes pour une meilleure disponibilité et répartition de charge.\n2. Unidirectional Tunnels I2P sépare le trafic entrant et sortant. Cela signifie que chaque participant ne voit jamais que la moitié d\u0026rsquo;un flux de communication, rendant les attaques de corrélation temporelle considérablement plus difficiles. Tor, Lokinet et autres utilisent des circuits bidirectionnels où les requêtes et réponses partagent le même chemin—plus simple, mais plus traçable.\n3. Fully Distributed netDB Les neuf autorités de répertoire de Tor définissent sa topologie réseau. I2P utilise une DHT Kademlia auto-organisée maintenue par des routeurs floodfill rotatifs, éliminant tout point de contrôle central ou serveur de coordination.\n1. Commutation de paquets \u0026gt; Commutation de circuits I2P étend le routage en oignon avec le garlic routing (routage en ail), regroupant plusieurs messages chiffrés dans un seul conteneur. Cela réduit la fuite de métadonnées et la surcharge de bande passante tout en améliorant l\u0026rsquo;efficacité pour les messages d\u0026rsquo;accusé de réception, de données et de contrôle.\n2. Tunnels unidirectionnels Chaque routeur I2P achemine du trafic pour les autres. Il n\u0026rsquo;existe pas d\u0026rsquo;opérateurs de relais dédiés ni de nœuds privilégiés : la bande passante et la fiabilité déterminent automatiquement la quantité de routage qu\u0026rsquo;un nœud contribue. Cette approche démocratique renforce la résilience et s\u0026rsquo;adapte naturellement à mesure que le réseau se développe.\n3. netDB entièrement distribué L\u0026rsquo;aller-retour de 12 sauts d\u0026rsquo;I2P (6 entrants + 6 sortants) crée une déliaison plus forte que les circuits de service caché à 6 sauts de Tor. Parce que les deux parties sont internes, les connexions évitent complètement le goulot d\u0026rsquo;étranglement de sortie, offrant un hébergement interne plus rapide et une intégration native des applications (I2PSnark, I2PTunnel, I2PBote).\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication --- When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet --- Summary L\u0026rsquo;architecture d\u0026rsquo;I2P est unique, privilégiant la confidentialité avant tout—pas de serveurs d\u0026rsquo;annuaire, pas de dépendances blockchain, pas de confiance centralisée. Sa combinaison de tunnels unidirectionnels, routage à commutation de paquets, regroupement de messages garlic et découverte distribuée de pairs en fait le système techniquement le plus avancé pour l\u0026rsquo;hébergement anonyme et la communication pair-à-pair aujourd\u0026rsquo;hui.\nI2P n\u0026rsquo;est pas « une alternative à Tor ». C\u0026rsquo;est une classe de réseau différente — conçue pour ce qui se passe à l\u0026rsquo;intérieur du réseau de confidentialité, et non à l\u0026rsquo;extérieur.\n","description":"Une comparaison technique et philosophique moderne mettant en avant les avantages uniques de conception d'I2P","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P vs autres réseaux de confidentialité","url":"/fr/docs/overview/comparison/"},{"categories":null,"content":"Documentation de l\u0026rsquo;API I2PControl I2PControl est une API JSON-RPC 2.0 intégrée au routeur I2P (depuis la version 0.9.39). Elle permet la surveillance et le contrôle authentifiés du routeur via des requêtes JSON structurées.\nMot de passe par défaut : itoopie — il s\u0026rsquo;agit du mot de passe d\u0026rsquo;usine et doit être modifié immédiatement pour des raisons de sécurité.\n1. Aperçu et accès Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior Dans le cas de Java I2P, vous devez aller dans **Console du Router → WebApps → I2PControl** et l'activer (configurer pour démarrer automatiquement). Une fois actif, toutes les méthodes nécessitent que vous vous authentifiiez d'abord et receviez un jeton de session. 2. Format JSON-RPC Toutes les requêtes suivent la structure JSON-RPC 2.0 :\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } Une réponse réussie inclut un champ result ; en cas d\u0026rsquo;échec, un objet error est renvoyé :\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } ou\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. Flux d\u0026rsquo;authentification Requête (Authentification) curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Réponse réussie { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } Vous devez inclure ce Token dans toutes les requêtes suivantes dans les params.\n4. Méthodes \u0026amp; Points de terminaison 4.1 RouterInfo Récupère les données de télémétrie clés concernant le routeur.\nExemple de Requête\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Champs de réponse (result) Selon la documentation officielle (GetI2P) : - i2p.router.status (String) — un statut lisible par l\u0026rsquo;humain - i2p.router.uptime (long) — millisecondes (ou chaîne pour les anciennes versions i2pd) :contentReference[oaicite:0]{index=0} - i2p.router.version (String) — chaîne de version :contentReference[oaicite:1]{index=1} - i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — bande passante entrante en B/s :contentReference[oaicite:2]{index=2} - i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — bande passante sortante en B/s :contentReference[oaicite:3]{index=3} - i2p.router.net.status (long) — code de statut numérique (voir énumération ci-dessous) :contentReference[oaicite:4]{index=4} - i2p.router.net.tunnels.participating (long) — nombre de tunnels participants :contentReference[oaicite:5]{index=5} - i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — statistiques des pairs netDB :contentReference[oaicite:6]{index=6} - i2p.router.netdb.isreseeding (boolean) — indique si le réamorçage est actif :contentReference[oaicite:7]{index=7} - i2p.router.netdb.knownpeers (long) — nombre total de pairs connus :contentReference[oaicite:8]{index=8}\nÉnumération des Codes de Statut (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET --- 4.2 GetRate Utilisé pour récupérer les métriques de débit (par exemple bande passante, succès de tunnel) sur une fenêtre de temps donnée.\nExemple de Requête\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Exemple de Réponse\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 RouterManager Effectuer des actions administratives.\nParamètres / méthodes autorisés - Restart, RestartGraceful - Shutdown, ShutdownGraceful - Reseed, FindUpdates, Update :contentReference[oaicite:10]{index=10}\nExemple de requête\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Réponse réussie\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 NetworkSetting Obtenir ou définir les paramètres de configuration réseau (ports, upnp, partage de bande passante, etc.)\nExemple de requête (obtenir les valeurs actuelles)\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Exemple de réponse\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } Note : les versions d\u0026rsquo;i2pd antérieures à 2.41 peuvent renvoyer des types numériques au lieu de chaînes de caractères — les clients doivent gérer les deux. :contentReference[oaicite:11]{index=11}\n4.5 Paramètres avancés Permet de manipuler les paramètres internes du routeur.\nExemple de requête\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Exemple de réponse\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. Codes d\u0026rsquo;erreur En plus des erreurs JSON-RPC standard (-32700, -32600, etc.), I2PControl définit :\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported --- 6. Utilisation et bonnes pratiques Incluez toujours le paramètre Token (sauf lors de l\u0026rsquo;authentification). Modifiez le mot de passe par défaut (itoopie) lors de la première utilisation. Pour Java I2P, assurez-vous que l\u0026rsquo;application web I2PControl est activée via WebApps. Préparez-vous à de légères variations : certains champs peuvent être des nombres ou des chaînes, selon la version d\u0026rsquo;I2P. Enveloppez les longues chaînes de statut pour une sortie adaptée à l\u0026rsquo;affichage. ","description":"API de gestion à distance du routeur via l'application web I2PControl","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/fr/docs/api/i2pcontrol/"},{"categories":null,"content":"Aperçu I2PTunnel est un composant central d\u0026rsquo;I2P permettant d\u0026rsquo;interagir avec le réseau I2P et d\u0026rsquo;y fournir des services. Il permet aux applications basées sur TCP et au streaming multimédia de fonctionner de manière anonyme grâce à l\u0026rsquo;abstraction des tunnels. La destination d\u0026rsquo;un tunnel peut être définie par un nom d\u0026rsquo;hôte , un Base32 , ou une clé de destination complète.\nChaque tunnel établi écoute localement (par exemple, localhost:port) et se connecte en interne aux destinations I2P. Pour héberger un service, créez un tunnel pointant vers l\u0026rsquo;IP et le port souhaités. Une clé de destination I2P correspondante est générée, permettant au service de devenir accessible globalement au sein du réseau I2P. L\u0026rsquo;interface web I2PTunnel est disponible à l\u0026rsquo;adresse I2P Router Tunnel Manager .\nServices par défaut Tunnel serveur I2P Webserver – Un tunnel vers un serveur web Jetty sur localhost:7658 pour héberger facilement sur I2P. Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot Tunnels clients I2P HTTP Proxy – localhost:4444 – Utilisé pour naviguer sur I2P et Internet via des outproxies. I2P HTTPS Proxy – localhost:4445 – Variante sécurisée du proxy HTTP. Irc2P – localhost:6668 – Tunnel par défaut vers le réseau IRC anonyme. Git SSH (gitssh.idk.i2p) – localhost:7670 – Tunnel client pour l\u0026rsquo;accès SSH aux dépôts. Postman SMTP – localhost:7659 – Tunnel client pour le courrier sortant. Postman POP3 – localhost:7660 – Tunnel client pour le courrier entrant. Note : Seul le serveur web I2P est un tunnel serveur par défaut ; tous les autres sont des tunnels clients se connectant à des services I2P externes.\nConfiguration La spécification de configuration I2PTunnel est documentée sur /spec/configuration .\nModes Client Standard Ouvre un port TCP local qui se connecte à un service sur une destination I2P. Prend en charge plusieurs entrées de destination séparées par des virgules pour la redondance.\nHTTP Un tunnel proxy pour les requêtes HTTP/HTTPS. Prend en charge les proxies sortants locaux et distants, le filtrage d\u0026rsquo;en-têtes, la mise en cache, l\u0026rsquo;authentification et la compression transparente.\nProtections de la vie privée : - Supprime les en-têtes : Accept-*, Referer, Via, From - Remplace les en-têtes d\u0026rsquo;hôte par des destinations Base32 - Applique la suppression hop-by-hop conforme à la RFC - Ajoute la prise en charge de la décompression transparente - Fournit des pages d\u0026rsquo;erreur internes et des réponses localisées\nComportement de compression : - Les requêtes peuvent utiliser l\u0026rsquo;en-tête personnalisé X-Accept-Encoding: x-i2p-gzip - Les réponses avec Content-Encoding: x-i2p-gzip sont décompressées de manière transparente - La compression est évaluée selon le type MIME et la longueur de la réponse pour plus d\u0026rsquo;efficacité\nPersistance (nouveauté depuis la version 2.5.0) : HTTP Keepalive et les connexions persistantes sont désormais pris en charge pour les services hébergés sur I2P via le Hidden Services Manager. Cela réduit la latence et la surcharge de connexion, mais n\u0026rsquo;active pas encore les sockets persistants entièrement conformes à la RFC 2616 sur tous les sauts.\nPipelining : Reste non pris en charge et inutile ; les navigateurs modernes l\u0026rsquo;ont abandonné.\nComportement du User-Agent : - Outproxy : Utilise un User-Agent Firefox ESR actuel. - Interne : MYOB/6.66 (AN/ON) pour cohérence de l\u0026rsquo;anonymat.\nClient IRC Se connecte aux serveurs IRC basés sur I2P. Autorise un sous-ensemble sécurisé de commandes tout en filtrant les identifiants pour protéger la vie privée.\nSOCKS 4/4a/5 Fournit la capacité de proxy SOCKS pour les connexions TCP. UDP reste non implémenté dans Java I2P (uniquement dans i2pd).\nCONNECT Implémente la tunnelisation HTTP CONNECT pour les connexions SSL/TLS.\nStreamr Active la diffusion en continu de style UDP via une encapsulation basée sur TCP. Prend en charge la diffusion multimédia lorsqu\u0026rsquo;il est associé à un tunnel serveur Streamr correspondant.\nModes du serveur Serveur Standard Crée une destination TCP mappée vers une IP:port locale.\nServeur HTTP Crée une destination qui s\u0026rsquo;interface avec un serveur web local. Prend en charge la compression (x-i2p-gzip), la suppression des en-têtes et les protections DDoS. Bénéficie désormais de la prise en charge des connexions persistantes (v2.5.0+) et de l\u0026rsquo;optimisation du pool de threads (v2.7.0–2.9.0).\nHTTP Bidirectionnel Obsolète – Toujours fonctionnel mais déconseillé. Agit à la fois comme serveur et client HTTP sans outproxying. Principalement utilisé pour les tests de diagnostic en boucle locale.\nServeur IRC Crée une destination filtrée pour les services IRC, en transmettant les clés de destination du client comme noms d\u0026rsquo;hôte.\nServeur Streamr Se couple avec un tunnel client Streamr pour gérer les flux de données de type UDP sur I2P.\nNouvelles fonctionnalités (2.4.0–2.10.0) Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. --- Fonctionnalités de sécurité Suppression d\u0026rsquo;en-têtes pour l\u0026rsquo;anonymat (Accept, Referer, From, Via) Randomisation du User-Agent selon l\u0026rsquo;in/outproxy Limitation du taux de POST et protection Slowloris Limitation des connexions dans les sous-systèmes de streaming Gestion de la congestion réseau au niveau de la couche tunnel Isolation du NetDB empêchant les fuites inter-applications Détails techniques Taille par défaut de la clé de destination : 516 octets (peut être dépassée pour les certificats LS2 étendus) Adresses Base32 : {52–56+ chars}.b32.i2p Les tunnels serveur restent compatibles avec Java I2P et i2pd Fonctionnalité dépréciée : httpbidirserver uniquement ; aucune suppression depuis 0.9.59 Ports par défaut et racines de documents vérifiés corrects pour toutes les plateformes Résumé I2PTunnel reste la colonne vertébrale de l\u0026rsquo;intégration des applications avec I2P. Entre les versions 0.9.59 et 2.10.0, il a bénéficié de la prise en charge des connexions persistantes, du chiffrement post-quantique et d\u0026rsquo;améliorations majeures du threading. La plupart des configurations restent compatibles, mais les développeurs doivent vérifier leurs paramètres pour garantir la conformité avec les valeurs par défaut modernes de transport et de sécurité.\n","description":"Outil pour interagir avec I2P et fournir des services sur le réseau","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/fr/docs/api/i2ptunnel/"},{"categories":null,"content":"Le projet I2P maintient des paquets officiels pour Debian, Ubuntu et leurs distributions dérivées. Ce guide fournit des instructions complètes pour installer I2P en utilisant nos dépôts officiels.\n🚀 Bêta : Installation Automatique (Expérimental) Pour les utilisateurs avancés qui souhaitent une installation automatisée rapide :\nCette commande unique détectera automatiquement votre distribution et installera I2P. À utiliser avec précaution - examinez le script d\u0026rsquo;installation avant de l\u0026rsquo;exécuter.\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash Ce que cela fait : - Détecte votre distribution Linux (Ubuntu/Debian) - Ajoute le dépôt I2P approprié - Installe les clés GPG et les paquets requis - Installe I2P automatiquement\n⚠️ Ceci est une fonctionnalité bêta. Si vous préférez l\u0026rsquo;installation manuelle ou souhaitez comprendre chaque étape, utilisez les méthodes d\u0026rsquo;installation manuelle ci-dessous.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nPlateformes supportées Les paquets Debian sont compatibles avec :\nUbuntu 18.04 (Bionic) et versions ultérieures Linux Mint 19 (Tara) et versions ultérieures Debian Buster (10) et versions ultérieures Knoppix Autres distributions basées sur Debian (LMDE, ParrotOS, Kali Linux, etc.) Architectures supportées : amd64, i386, armhf, arm64, powerpc, ppc64el, s390x\nLes paquets I2P peuvent fonctionner sur d\u0026rsquo;autres systèmes basés sur Debian qui ne sont pas explicitement listés ci-dessus. Si vous rencontrez des problèmes, veuillez les signaler sur notre GitLab .\nMéthodes d\u0026rsquo;installation Choisissez la méthode d\u0026rsquo;installation qui correspond à votre distribution :\nOption 1 : Ubuntu et dérivés (Linux Mint, elementary OS, Pop!_OS, etc.) Option 2 : Debian et distributions basées sur Debian (incluant LMDE, Kali, ParrotOS) IMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nInstallation sur Ubuntu Ubuntu et ses dérivés officiels (Linux Mint, elementary OS, Trisquel, etc.) peuvent utiliser le PPA I2P (Personal Package Archive) pour une installation facile et des mises à jour automatiques.\nMethod 1: Command Line Installation (Recommended) C\u0026rsquo;est la méthode la plus rapide et la plus fiable pour installer I2P sur les systèmes basés sur Ubuntu.\nÉtape 1 : Ajouter le PPA I2P\nOuvrez un terminal et exécutez :\nsudo apt-add-repository ppa:i2p-maintainers/i2p Cette commande ajoute le PPA I2P à /etc/apt/sources.list.d/ et importe automatiquement la clé GPG qui signe le dépôt. La signature GPG garantit que les paquets n\u0026rsquo;ont pas été modifiés depuis leur construction.\nÉtape 2 : Mettre à jour la liste des paquets\nActualisez la base de données des paquets de votre système pour inclure le nouveau PPA :\nsudo apt-get update Cela récupère les dernières informations sur les paquets depuis tous les dépôts activés, y compris le PPA I2P que vous venez d\u0026rsquo;ajouter.\nÉtape 3 : Installer I2P\nInstallez maintenant I2P :\nsudo apt-get install i2p C\u0026rsquo;est tout ! Passez à la section Configuration post-installation pour apprendre comment démarrer et configurer I2P.\nMethod 2: Using the Software Center GUI Si vous préférez une interface graphique, vous pouvez ajouter le PPA en utilisant la Logithèque Ubuntu.\nÉtape 1 : Ouvrir Logiciels et mises à jour\nLancez « Logiciels et mises à jour » depuis votre menu d\u0026rsquo;applications.\nÉtape 2 : Accéder à Autres logiciels\nSélectionnez l\u0026rsquo;onglet « Autres logiciels » et cliquez sur le bouton « Ajouter » en bas pour configurer un nouveau PPA.\nÉtape 3 : Ajouter le PPA I2P\nDans la boîte de dialogue PPA, saisissez :\nppa:i2p-maintainers/i2p Étape 4 : Recharger les informations du dépôt\nCliquez sur le bouton « Recharger » pour télécharger les informations mises à jour du dépôt.\nÉtape 5 : Installer I2P\nOuvrez l\u0026rsquo;application « Logiciels » depuis votre menu d\u0026rsquo;applications, recherchez « i2p », et cliquez sur Installer.\nUne fois l\u0026rsquo;installation terminée, procédez à la Configuration Post-Installation .\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nDebian Installation Debian et ses distributions dérivées (LMDE, Kali Linux, ParrotOS, Knoppix, etc.) doivent utiliser le dépôt Debian officiel I2P à deb.i2p.net.\nImportant Notice Nos anciens dépôts à deb.i2p2.de et deb.i2p2.no ne sont plus maintenus. Si vous utilisez ces dépôts obsolètes, veuillez suivre les instructions ci-dessous pour migrer vers le nouveau dépôt à deb.i2p.net.\nPrerequisites Toutes les étapes ci-dessous nécessitent un accès root. Soit passez à l\u0026rsquo;utilisateur root avec su, soit préfixez chaque commande avec sudo.\nMéthode 1 : Installation en ligne de commande (Recommandée) Étape 1 : Installer les paquets requis\nAssurez-vous d\u0026rsquo;avoir les outils nécessaires installés :\nsudo apt-get update sudo apt-get install apt-transport-https lsb-release curl Ces packages permettent un accès sécurisé aux dépôts HTTPS, la détection de la distribution et le téléchargement de fichiers.\nÉtape 2 : Ajouter le dépôt I2P\nLa commande que vous utilisez dépend de votre version de Debian. Tout d\u0026rsquo;abord, déterminez quelle version vous utilisez :\ncat /etc/debian_version Recoupez cette information avec les informations de version Debian pour identifier le nom de code de votre distribution (par exemple, Bookworm, Bullseye, Buster).\nPour Debian Bullseye (11) ou plus récent :\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Pour les dérivés de Debian (LMDE, Kali, ParrotOS, etc.) sur Bullseye-équivalent ou plus récent :\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Pour Debian Buster (10) ou antérieure :\necho \u0026#34;deb https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Pour les dérivés Debian sur Buster-équivalent ou plus ancien :\necho \u0026#34;deb https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Étape 3 : Télécharger la clé de signature du dépôt\ncurl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg Étape 4 : Vérifier l\u0026rsquo;empreinte de la clé\nAvant de faire confiance à la clé, vérifiez que son empreinte correspond à la clé de signature officielle d\u0026rsquo;I2P :\ngpg --keyid-format long --import --import-options show-only --with-fingerprint i2p-archive-keyring.gpg Vérifiez que la sortie affiche cette empreinte :\n7840 E761 0F28 B904 7535 49D7 67EC E560 5BCF 1346 ⚠️ Ne continuez pas si l\u0026rsquo;empreinte ne correspond pas. Cela pourrait indiquer un téléchargement compromis.\nÉtape 5 : Installer la clé du dépôt\nCopiez le trousseau de clés vérifié dans le répertoire des trousseaux de clés système :\nsudo cp i2p-archive-keyring.gpg /usr/share/keyrings Pour Debian Buster ou versions antérieures uniquement, vous devez également créer un lien symbolique :\nsudo ln -sf /usr/share/keyrings/i2p-archive-keyring.gpg /etc/apt/trusted.gpg.d/i2p-archive-keyring.gpg Étape 6 : Mettre à jour les listes de paquets\nActualisez la base de données des paquets de votre système pour inclure le dépôt I2P :\nsudo apt-get update Étape 7 : Installer I2P\nInstallez à la fois le routeur I2P et le paquet keyring (qui garantit que vous recevrez les futures mises à jour de clés) :\nsudo apt-get install i2p i2p-keyring Parfait ! I2P est maintenant installé. Continuez vers la section Configuration post-installation .\nPost-Installation Configuration Après avoir installé I2P, vous devrez démarrer le router et effectuer quelques configurations initiales.\nMéthode 2 : Utilisation de l\u0026rsquo;interface graphique du centre de logiciels Les paquets I2P fournissent trois façons d\u0026rsquo;exécuter le routeur I2P :\nOption 1: On-Demand (Basic) Démarrez I2P manuellement lorsque nécessaire en utilisant le script i2prouter :\ni2prouter start Important : N\u0026rsquo;utilisez pas sudo et n\u0026rsquo;exécutez pas ceci en tant que root ! I2P doit s\u0026rsquo;exécuter avec votre utilisateur normal.\nPour arrêter I2P :\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) Si vous êtes sur un système non-x86 ou si le Java Service Wrapper ne fonctionne pas sur votre plateforme, utilisez :\ni2prouter-nowrapper Encore une fois, n\u0026rsquo;utilisez pas sudo et n\u0026rsquo;exécutez pas en tant que root.\nOption 3: System Service (Recommended) Pour une expérience optimale, configurez I2P pour démarrer automatiquement au démarrage de votre système, même avant la connexion :\nsudo dpkg-reconfigure i2p Cela ouvre une boîte de dialogue de configuration. Sélectionnez « Oui » pour activer I2P en tant que service système.\nIl s\u0026rsquo;agit de la méthode recommandée car : - I2P démarre automatiquement au démarrage - Votre routeur maintient une meilleure intégration réseau - Vous contribuez à la stabilité du réseau - I2P est disponible immédiatement lorsque vous en avez besoin\nInitial Router Configuration Après avoir démarré I2P pour la première fois, l\u0026rsquo;intégration au réseau prendra plusieurs minutes. En attendant, configurez ces paramètres essentiels :\n1. Configure NAT/Firewall Pour des performances optimales et une participation au réseau, transférez les ports I2P à travers votre NAT/pare-feu :\nOuvrez la Console du routeur I2P Accédez à la page de configuration réseau Notez les numéros de port listés (généralement des ports aléatoires entre 9000 et 31000) Redirigez ces ports UDP et TCP dans votre routeur/pare-feu Si vous avez besoin d\u0026rsquo;aide pour la redirection de ports, portforward.com propose des guides spécifiques à chaque routeur.\n2. Adjust Bandwidth Settings Les paramètres de bande passante par défaut sont conservateurs. Ajustez-les en fonction de votre connexion internet :\nVisitez la page de configuration Trouvez la section des paramètres de bande passante Les valeurs par défaut sont 96 Ko/s en téléchargement / 40 Ko/s en envoi Augmentez ces valeurs si vous avez une connexion internet plus rapide (par exemple, 250 Ko/s en téléchargement / 100 Ko/s en envoi pour une connexion haut débit classique) Note : Définir des limites plus élevées aide le réseau et améliore vos propres performances.\n3. Configure Your Browser Pour accéder aux sites I2P (eepsites) et services, configurez votre navigateur pour utiliser le proxy HTTP d\u0026rsquo;I2P :\nConsultez notre Guide de Configuration du Navigateur pour des instructions détaillées de configuration pour Firefox, Chrome et d\u0026rsquo;autres navigateurs.\nInstallation Debian Avis Important Assurez-vous de ne pas exécuter I2P en tant que root : ps aux | grep i2p Vérifiez les journaux : tail -f ~/.i2p/wrapper.log Vérifiez que Java est installé : java -version Prérequis Si vous recevez des erreurs de clé GPG pendant l\u0026rsquo;installation :\nRetéléchargez et vérifiez l\u0026rsquo;empreinte de la clé (Étape 3-4 ci-dessus) Assurez-vous que le fichier de trousseau de clés dispose des permissions correctes : sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg Étapes d\u0026rsquo;installation Si I2P ne reçoit pas les mises à jour :\nVérifiez que le dépôt est configuré : cat /etc/apt/sources.list.d/i2p.list Mettez à jour les listes de paquets : sudo apt-get update Vérifiez les mises à jour d\u0026rsquo;I2P : sudo apt-get upgrade Migrating from old repositories Si vous utilisez les anciens dépôts deb.i2p2.de ou deb.i2p2.no :\nSupprimer l\u0026rsquo;ancien dépôt : sudo rm /etc/apt/sources.list.d/i2p.list Suivre les étapes d\u0026rsquo;Installation Debian ci-dessus Mettre à jour : sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring Next Steps Maintenant qu\u0026rsquo;I2P est installé et en cours d\u0026rsquo;exécution :\nConfigurez votre navigateur pour accéder aux sites I2P Explorez la console du router I2P pour surveiller votre router Découvrez les applications I2P que vous pouvez utiliser Lisez comment I2P fonctionne pour comprendre le réseau Bienvenue sur l\u0026rsquo;Internet Invisible !\n","description":"Guide complet pour installer I2P sur Debian, Ubuntu et leurs dérivés en utilisant les dépôts officiels","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"Installation d'I2P sur Debian et Ubuntu","url":"/fr/docs/guides/installation-di2p-sur-debian-et-ubuntu/"},{"categories":null,"content":"Choisissez Votre Méthode d\u0026rsquo;Installation Il existe deux façons d\u0026rsquo;installer I2P sur Windows. Choisissez la méthode qui correspond le mieux à vos besoins :\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte est seulement un titre ou semble incomplet, traduisez-le tel quel.\n🚀 Easy Install Bundle (Recommended) Idéal pour la plupart des utilisateurs\n✅ Programme d\u0026rsquo;installation tout-en-un ✅ Java inclus (aucune installation séparée) ✅ Profils Firefox inclus ✅ Configuration la plus rapide\nChoisissez ceci si : - Vous souhaitez l\u0026rsquo;installation la plus simple - Vous n\u0026rsquo;avez pas Java installé - Vous débutez avec I2P\nGuide d\u0026rsquo;installation facile →\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications, et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\n🚀 Bundle d\u0026rsquo;Installation Facile (Recommandé) Pour les utilisateurs avancés\n📦 Programme d\u0026rsquo;installation JAR basé sur Java 🔧 Plus de contrôle sur l\u0026rsquo;installation 💾 Taille de téléchargement réduite\nChoisissez cette option si : - Vous avez déjà Java installé - Vous souhaitez plus de contrôle - Vous préférez la méthode traditionnelle\nGuide d\u0026rsquo;installation standard →\nEasy Install Bundle ⚙️ Installation Standard Le I2P Easy Install Bundle est la méthode d\u0026rsquo;installation recommandée pour les utilisateurs Windows. Ce programme d\u0026rsquo;installation tout-en-un inclut tout ce dont vous avez besoin pour commencer avec I2P :\nI2P Router - Le logiciel I2P principal Embedded Java Runtime - Aucune installation Java séparée requise Profils et extensions Firefox - Profils de navigateur et extensions optimisés pour I2P pour une navigation sécurisée Installateur simple - Aucune configuration manuelle requise Mises à jour automatiques - Maintenez votre logiciel I2P à jour Cet installateur bêta simplifie le processus d\u0026rsquo;installation en incluant Java directement, vous n\u0026rsquo;avez donc pas besoin de télécharger ou configurer Java séparément.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nStep 1: Select Your Language Après avoir lancé l\u0026rsquo;installateur Easy Install Bundle, vous serez accueilli par l\u0026rsquo;écran de sélection de la langue.\nChoisissez votre langue préférée dans le menu déroulant Les langues disponibles incluent l\u0026rsquo;anglais, l\u0026rsquo;allemand, l\u0026rsquo;espagnol, le français et bien d\u0026rsquo;autres Cliquez sur OK pour continuer L\u0026rsquo;interface d\u0026rsquo;installation utilisera la langue que vous avez sélectionnée pour toutes les étapes suivantes.\nOptions générales Bundle d\u0026rsquo;Installation Facile Ensuite, les informations de licence d\u0026rsquo;I2P vous seront présentées. Le Bundle d\u0026rsquo;Installation Facile inclut des composants sous diverses licences libres et open source.\nPour continuer l\u0026rsquo;installation : 1. Examinez les informations de licence (facultatif mais recommandé) 2. Cliquez sur J\u0026rsquo;accepte pour accepter les licences et continuer 3. Cliquez sur Annuler si vous ne souhaitez pas installer\nIMPORTANT : Ne posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nStep 3: Choose Installation Folder Vous allez maintenant sélectionner où installer I2P sur votre ordinateur.\nOptions d\u0026rsquo;installation :\nUtiliser l\u0026rsquo;emplacement par défaut (recommandé)\nChemin par défaut : C:\\Users\\[YourUsername]\\AppData\\Local\\I2peasy\\ Cela installe I2P dans le répertoire de votre profil utilisateur Aucun privilège administrateur requis pour les mises à jour Choisir un emplacement personnalisé\nCliquez sur Parcourir\u0026hellip; pour sélectionner un dossier différent Utile si vous souhaitez installer sur un autre lecteur Assurez-vous d\u0026rsquo;avoir les permissions d\u0026rsquo;écriture sur le dossier sélectionné Besoins en espace disque : - L\u0026rsquo;installateur indique l\u0026rsquo;espace nécessaire (généralement moins de 1 Go) - Vérifiez que vous disposez de suffisamment d\u0026rsquo;espace libre sur le disque sélectionné\nCliquez sur Install pour commencer le processus d\u0026rsquo;installation L\u0026rsquo;installateur va maintenant copier tous les fichiers nécessaires vers l\u0026rsquo;emplacement que vous avez choisi. Cela peut prendre quelques minutes.\nÉtape 1 : Sélectionnez votre langue Une fois l\u0026rsquo;installation terminée, vous verrez l\u0026rsquo;écran de finalisation.\nL\u0026rsquo;assistant d\u0026rsquo;installation confirme que « I2P - i2peasy a été installé sur votre ordinateur. »\nImportant : Assurez-vous que la case \u0026ldquo;Start I2P?\u0026rdquo; est cochée (elle devrait être cochée par défaut).\nCoché (recommandé) : I2P démarrera automatiquement lorsque vous cliquerez sur Terminer Décoché : Vous devrez démarrer I2P manuellement plus tard depuis le menu Démarrer ou le raccourci du bureau Cliquez sur Terminer pour finaliser l\u0026rsquo;installation et lancer I2P.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nÉtape 2 : Accepter le contrat de licence Après avoir cliqué sur Terminer avec « Démarrer I2P ? » coché :\nLe router I2P démarre - Le router I2P commence à s\u0026rsquo;exécuter en arrière-plan L\u0026rsquo;icône de la barre système apparaît - Recherchez l\u0026rsquo;icône I2P dans votre barre système Windows (coin inférieur droit) La console du router s\u0026rsquo;ouvre - Votre navigateur web par défaut s\u0026rsquo;ouvrira automatiquement sur la console du router I2P (généralement à http://127.0.0.1:7657) Connexion initiale - I2P commencera à se connecter au réseau et à construire des tunnels (cela peut prendre 5 à 10 minutes au premier lancement) Félicitations ! I2P est maintenant installé et fonctionne sur votre ordinateur Windows.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nÉtape 3 : Choisir le dossier d\u0026rsquo;installation Bien que ce ne soit pas strictement requis, le transfert de port améliore considérablement votre expérience I2P en permettant à votre routeur de communiquer plus efficacement avec les autres routeurs I2P. Sans le transfert de port, vous pourrez toujours utiliser I2P, mais avec des performances réduites et une contribution moindre au réseau.\nWhy Forward a Port? Meilleure connectivité : Permet les connexions entrantes depuis d\u0026rsquo;autres routeurs I2P Intégration plus rapide : Vous aide à vous intégrer au réseau plus rapidement Contribution au réseau : Fait de vous un meilleur participant du réseau I2P Performances améliorées : Résulte généralement en une meilleure fiabilité et vitesse des tunnels Qu\u0026rsquo;est-ce que le Bundle d\u0026rsquo;Installation Facile ? Tout d\u0026rsquo;abord, vous devez identifier quel port I2P utilise (il est attribué aléatoirement par défaut).\nLocalisez l\u0026rsquo;icône I2P dans la barre d\u0026rsquo;état système Windows (zone de notification) en bas à droite de votre écran Faites un clic droit sur l\u0026rsquo;icône I2P pour ouvrir le menu contextuel Cliquez sur \u0026ldquo;Launch I2P Browser\u0026rdquo; pour ouvrir la console du routeur I2P Le menu affiche également des options utiles telles que : - Network: Firewalled - Affiche l\u0026rsquo;état actuel de votre réseau - Configure I2P System Tray - Personnaliser les paramètres de l\u0026rsquo;icône de la barre d\u0026rsquo;état système - Stop I2P / Stop I2P Immediately - Options d\u0026rsquo;arrêt\nFinding Your Port Numbers Une fois que le navigateur I2P s\u0026rsquo;ouvre, vous devez vérifier quels ports I2P utilise :\nAccédez à la page de configuration réseau :\nRendez-vous sur I2P Router Network Configuration dans votre navigateur Ou depuis la barre latérale de la console du router : Configuration → Réseau Faites défiler vers le bas jusqu\u0026rsquo;à la section de configuration des ports\nNotez les numéros de port affichés : Configuration UDP : - Port UDP : Le port affiché ici (exemple : 13697) - Par défaut, celui-ci est défini sur \u0026ldquo;Spécifier le port\u0026rdquo; avec un numéro attribué aléatoirement\nConfiguration TCP : - Port TCP accessible de l\u0026rsquo;extérieur : Généralement configuré pour utiliser le même port qu\u0026rsquo;UDP - Dans l\u0026rsquo;exemple ci-dessus : \u0026ldquo;Utiliser le même port configuré pour UDP (actuellement 13697)\u0026rdquo;\nImportant : Vous devez rediriger à la fois UDP et TCP sur le même numéro de port (dans cet exemple, le port 13697) dans votre routeur/pare-feu.\nHow to Forward Your Port Comme chaque routeur et pare-feu est différent, nous ne pouvons pas fournir d\u0026rsquo;instructions universelles. Cependant, portforward.com propose des guides détaillés pour des milliers de modèles de routeurs :\nVisitez portforward.com Sélectionnez le fabricant et le modèle de votre routeur Suivez le guide étape par étape pour rediriger votre port Redirigez les protocoles UDP et TCP sur le numéro de port indiqué dans votre configuration I2P Étapes générales (varie selon le routeur) : - Connectez-vous à l\u0026rsquo;interface d\u0026rsquo;administration de votre routeur (généralement à 192.168.1.1 ou 192.168.0.1) - Trouvez la section \u0026ldquo;Redirection de ports\u0026rdquo; ou \u0026ldquo;Serveurs virtuels\u0026rdquo; - Créez une nouvelle règle de redirection de port pour votre numéro de port I2P - Configurez les protocoles UDP et TCP - Dirigez la règle vers l\u0026rsquo;adresse IP locale de votre ordinateur - Enregistrez la configuration\nAprès avoir transféré votre port, I2P devrait passer de « Réseau : Pare-feu » à « Réseau : OK » dans le menu de la barre système (cela peut prendre quelques minutes).\nÉtape 4 : Terminer l\u0026rsquo;installation et démarrer I2P Attendez l\u0026rsquo;intégration : Accordez à I2P 5 à 10 minutes pour s\u0026rsquo;intégrer au réseau et construire les tunnels Configurez votre navigateur : Utilisez le profil Firefox inclus pour naviguer sur I2P Transférez votre port : Consultez portforward.com pour des instructions spécifiques à votre routeur sur la façon de transférer le port utilisé par I2P Explorez la console du router : Découvrez les fonctionnalités, services et options de configuration d\u0026rsquo;I2P Visitez des eepsites : Essayez d\u0026rsquo;accéder à des sites web .i2p via le réseau I2P Lisez la documentation : Consultez la documentation I2P pour plus d\u0026rsquo;informations Bienvenue sur le réseau I2P ! 🎉\nQue se passe-t-il ensuite What is the Standard Installation? L\u0026rsquo;installation standard d\u0026rsquo;I2P est la méthode traditionnelle d\u0026rsquo;installation d\u0026rsquo;I2P sur Windows. Contrairement au Easy Install Bundle, cette méthode nécessite que vous :\nInstaller Java séparément - Téléchargez et installez l\u0026rsquo;environnement d\u0026rsquo;exécution Java (JRE) avant d\u0026rsquo;installer I2P Exécuter l\u0026rsquo;installateur JAR - Utilisez l\u0026rsquo;installateur graphique basé sur Java Configurer manuellement - Configurez vous-même les paramètres du navigateur (optionnel) Cette méthode est recommandée pour : - Les utilisateurs qui ont déjà Java installé - Les utilisateurs avancés qui souhaitent plus de contrôle sur l\u0026rsquo;installation - Les utilisateurs qui préfèrent la méthode d\u0026rsquo;installation traditionnelle - Les systèmes où le bundle Easy Install n\u0026rsquo;est pas compatible\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nRecommandé : Redirection de port (Optionnel mais Important) Avant d\u0026rsquo;installer I2P, vous devez avoir Java installé sur votre système.\nJava Requirements Version Java : Java 8 (1.8) ou supérieur requis Recommandé : Java 11 ou ultérieur (version LTS) Type : Java Runtime Environment (JRE) ou Java Development Kit (JDK) Installing Java Si vous n\u0026rsquo;avez pas encore Java installé, vous pouvez le télécharger depuis plusieurs sources :\nOption 1 : Oracle Java - Source officielle : java.com/download - Distribution la plus largement utilisée\nOption 2 : OpenJDK - Implémentation open-source : openjdk.org - Gratuit et open-source\nOption 3 : Adoptium (Eclipse Temurin) - Alternative recommandée : adoptium.net - Versions LTS gratuites, open-source et bien maintenues\nPour vérifier que Java est installé : 1. Ouvrez l\u0026rsquo;Invite de commandes (appuyez sur Windows + R, tapez cmd, appuyez sur Entrée) 2. Tapez : java -version 3. Vous devriez voir s\u0026rsquo;afficher la version de Java installée\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nStep 1: Install Java Avant d\u0026rsquo;installer I2P, vous devez installer Java sur votre système.\nChoisissez une distribution Java :\nOracle Java : java.com/download OpenJDK : openjdk.org Adoptium : adoptium.net Téléchargez le programme d\u0026rsquo;installation Windows pour la distribution de votre choix\nExécutez le programme d\u0026rsquo;installation et suivez les instructions d\u0026rsquo;installation\nVérifier l\u0026rsquo;installation :\nOuvrir l\u0026rsquo;Invite de commandes Taper java -version et appuyer sur Entrée Confirmer que Java 8 ou version ultérieure est installé Une fois Java installé, vous êtes prêt à installer I2P.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications, et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nStep 2: Download and Launch the I2P Installer Télécharger le programme d\u0026rsquo;installation I2P :\nVisitez la page de téléchargements I2P Téléchargez le programme d\u0026rsquo;installation Windows (fichier JAR) : i2pinstall_X.X.X.jar Enregistrez-le dans un emplacement facilement accessible (par exemple, le dossier Téléchargements) Lancer l\u0026rsquo;installateur :\nDouble-cliquez sur le fichier JAR téléchargé pour lancer l\u0026rsquo;installateur Si le double-clic ne fonctionne pas, faites un clic droit sur le fichier et sélectionnez « Ouvrir avec → Java(TM) Platform SE binary » Alternativement, ouvrez l\u0026rsquo;invite de commandes et exécutez : java -jar i2pinstall_X.X.X.jar Step 3: Select Your Language Après avoir lancé l\u0026rsquo;installateur, vous verrez la boîte de dialogue de sélection de langue.\nSélectionnez votre langue préférée dans le menu déroulant Les langues disponibles incluent l\u0026rsquo;anglais, l\u0026rsquo;allemand, l\u0026rsquo;espagnol, le français et bien d\u0026rsquo;autres Cliquez sur OK pour continuer L\u0026rsquo;installateur utilisera la langue que vous avez sélectionnée pour toutes les étapes suivantes.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nStep 4: Welcome to I2P Installation Ceci est l\u0026rsquo;Étape 1 sur 8 du processus d\u0026rsquo;installation.\nCliquez sur Next pour continuer l\u0026rsquo;installation.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nProchaines étapes Il s\u0026rsquo;agit de l\u0026rsquo;étape 2 sur 8 du processus d\u0026rsquo;installation.\nCliquez sur Suivant pour accepter la licence et continuer.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte est simplement un titre ou semble incomplet, traduisez-le tel quel.\nInstallation Standard Choisissez l\u0026rsquo;emplacement où vous souhaitez installer I2P sur votre ordinateur.\nChemin d\u0026rsquo;installation par défaut : C:\\Program Files (x86)\\i2p\\\nVous pouvez soit : - Utiliser l\u0026rsquo;emplacement par défaut (recommandé) - Cliquer sur Parcourir\u0026hellip; pour sélectionner un dossier différent\nIl s\u0026rsquo;agit de l\u0026rsquo;étape 3 sur 8 du processus d\u0026rsquo;installation.\nCliquez sur Suivant pour continuer.\nRemarque : Si c\u0026rsquo;est la première fois que vous installez I2P, une fenêtre contextuelle confirmera la création du répertoire :\nCliquez sur OK pour créer le répertoire d\u0026rsquo;installation.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nStep 7: Select Installation Packs Choisissez les composants à installer.\nImportant : Assurez-vous que les deux packs sont sélectionnés : - Base (requis) - Logiciel I2P principal (27,53 MB) - Windows Service (recommandé) - Démarrer automatiquement I2P au démarrage\nL\u0026rsquo;option Service Windows garantit que I2P démarre automatiquement au démarrage de votre ordinateur, vous n\u0026rsquo;avez donc pas besoin de le lancer manuellement à chaque fois.\nIl s\u0026rsquo;agit de l\u0026rsquo;Étape 4 sur 8 du processus d\u0026rsquo;installation.\nCliquez sur Suivant pour continuer.\nPrérequis L\u0026rsquo;installateur va maintenant copier les fichiers sur votre système.\nVous verrez deux barres de progression : - Progression de l\u0026rsquo;installation du pack : Affiche le pack en cours d\u0026rsquo;installation - Progression globale de l\u0026rsquo;installation : Affiche la progression globale (par ex., « 2 / 2 »)\nIl s\u0026rsquo;agit de l\u0026rsquo;étape 5 sur 8 du processus d\u0026rsquo;installation.\nAttendez que l\u0026rsquo;installation se termine, puis cliquez sur Suivant.\nStep 9: Setup Shortcuts Configurez l\u0026rsquo;emplacement où vous souhaitez créer les raccourcis I2P.\nOptions de raccourci : - ✓ Créer des raccourcis dans le menu Démarrer (recommandé) - ✓ Créer des raccourcis supplémentaires sur le bureau (facultatif)\nGroupe de programmes : Sélectionnez ou créez un nom de dossier pour les raccourcis - Par défaut : I2P - Vous pouvez choisir un groupe de programmes existant ou en créer un nouveau\nCréer un raccourci pour : - Utilisateur actuel - Seul vous pouvez accéder aux raccourcis - Tous les utilisateurs - Tous les utilisateurs du système peuvent accéder aux raccourcis (nécessite des privilèges administrateur)\nCeci est l\u0026rsquo;étape 6 sur 8 du processus d\u0026rsquo;installation.\nCliquez sur Suivant pour continuer.\nIMPORTANT : Ne posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nStep 10: Installation Complete L\u0026rsquo;installation est maintenant terminée !\nVous verrez : - ✓ L\u0026rsquo;installation s\u0026rsquo;est terminée avec succès - Un programme de désinstallation sera créé dans : C:\\Program Files (x86)\\i2p\\Uninstaller\nIl s\u0026rsquo;agit de l\u0026rsquo;étape 8 sur 8 - la dernière étape du processus d\u0026rsquo;installation.\nCliquez sur Terminé pour finaliser.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nÉtape 1 : Installer Java Après avoir cliqué sur Terminé :\nLe routeur I2P démarre - Si vous avez installé le service Windows, I2P démarrera automatiquement La console du routeur s\u0026rsquo;ouvre - Votre navigateur web par défaut ouvrira la console du routeur I2P à l\u0026rsquo;adresse http://127.0.0.1:7657 Connexion initiale - I2P commencera à se connecter au réseau et à construire des tunnels (cela peut prendre 5 à 10 minutes au premier lancement) Félicitations ! I2P est maintenant installé sur votre ordinateur Windows.\nÉtape 2 : Télécharger et lancer l\u0026rsquo;installateur I2P Si I2P ne démarre pas automatiquement, ou si vous devez le démarrer manuellement à l\u0026rsquo;avenir, vous avez deux options :\nOption 1: Start Menu Ouvrez le Menu Démarrer de Windows Accédez au dossier I2P Choisissez l\u0026rsquo;une des options de démarrage : I2P router console - Ouvre la console du routeur dans votre navigateur Start I2P (no window) - Démarre I2P silencieusement en arrière-plan Start I2P (restartable) - Démarre I2P avec la capacité de redémarrage automatique Vous pouvez également accéder au Dossier de profil I2P ouvert (service) pour consulter les fichiers de configuration d\u0026rsquo;I2P.\nPourquoi transférer un port ? Appuyez sur Windows + R pour ouvrir la boîte de dialogue Exécuter Tapez services.msc et appuyez sur Entrée Faites défiler vers le bas pour trouver I2P Service Cliquez avec le bouton droit sur I2P Service et sélectionnez : Démarrer - Démarrer le service I2P Arrêter - Arrêter le service I2P Redémarrer - Redémarrer le service I2P Propriétés - Configurer les paramètres du service (type de démarrage, etc.) La méthode des Services Windows est utile pour gérer I2P en tant que service en arrière-plan, en particulier si vous l\u0026rsquo;avez installé en tant que Service Windows.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nÉtape 3 : Sélectionnez votre langue Attendre l\u0026rsquo;intégration : Laissez à I2P 5 à 10 minutes pour s\u0026rsquo;intégrer au réseau et construire des tunnels Configurer la redirection de port : Consultez le guide de redirection de port pour les instructions Configurer votre navigateur : Paramétrez votre navigateur web pour utiliser le proxy HTTP d\u0026rsquo;I2P Explorer la console du routeur : Découvrez les fonctionnalités, services et options de configuration d\u0026rsquo;I2P Visiter des eepsites : Essayez d\u0026rsquo;accéder à des sites web .i2p via le réseau I2P Lire la documentation : Consultez la documentation I2P pour plus d\u0026rsquo;informations Bienvenue sur le réseau I2P ! 🎉\n","description":"Choisissez votre méthode d'installation Windows : Easy Install Bundle ou Installation Standard","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"Installation d'I2P sur Windows","url":"/fr/docs/guides/installation-di2p-sur-windows/"},{"categories":null,"content":"Le framework de plugins d\u0026rsquo;I2P vous permet d\u0026rsquo;étendre le router sans toucher à l\u0026rsquo;installation principale. Les plugins disponibles couvrent la messagerie, les blogs, l\u0026rsquo;IRC, le stockage, les wikis, les outils de surveillance et bien plus encore.\nNote de sécurité : Les plugins s\u0026rsquo;exécutent avec les mêmes permissions que le router. Traitez les téléchargements tiers de la même manière que vous traiteriez toute mise à jour logicielle signée—vérifiez la source avant l\u0026rsquo;installation.\n1. Installer un Plugin Copiez l\u0026rsquo;URL de téléchargement du plugin depuis la page du projet.\nOuvrez la page de configuration des plugins de la console du routeur.\nCollez l\u0026rsquo;URL dans le champ d\u0026rsquo;installation et cliquez sur Installer le plugin.\nLe routeur récupère l\u0026rsquo;archive signée, vérifie la signature et active le plugin immédiatement. La plupart des plugins ajoutent des liens dans la console ou des services en arrière-plan sans nécessiter de redémarrage du routeur.\n2. Pourquoi les plugins sont importants Distribution en un clic pour les utilisateurs finaux—aucune modification manuelle de wrapper.config ou clients.config Conserve la taille du bundle i2pupdate.su3 principal réduite tout en livrant des fonctionnalités volumineuses ou spécialisées à la demande Les JVM optionnelles par plugin fournissent une isolation des processus lorsque nécessaire Vérifications automatiques de compatibilité avec la version du router, l\u0026rsquo;environnement d\u0026rsquo;exécution Java et Jetty Le mécanisme de mise à jour reflète celui du router : paquets signés et téléchargements incrémentiels Les intégrations à la console, packs de langues, thèmes d\u0026rsquo;interface et applications non-Java (via scripts) sont tous pris en charge Permet des répertoires type « app store » organisés tels que plugins.i2p 3. Gérer les plugins installés Utilisez les contrôles sur I2P Router Plugin\u0026rsquo;s pour :\nVérifier les mises à jour d\u0026rsquo;un seul plugin Vérifier tous les plugins en une fois (déclenché automatiquement après les mises à niveau du routeur) Installer toutes les mises à jour disponibles en un clic\nActiver/désactiver le démarrage automatique pour les plugins qui enregistrent des services Désinstaller les plugins proprement 4. Créez votre propre plugin Consultez la spécification des plugins pour les exigences de packaging, de signature et de métadonnées. Utilisez makeplugin.sh pour encapsuler un binaire ou une webapp existante dans une archive installable. Publiez à la fois les URL d\u0026rsquo;installation et de mise à jour afin que le router puisse distinguer les installations initiales des mises à niveau incrémentielles. Fournissez les sommes de contrôle et les clés de signature de manière visible sur la page de votre projet pour aider les utilisateurs à vérifier l\u0026rsquo;authenticité. Vous cherchez des exemples ? Parcourez le code source des plugins communautaires sur plugins.i2p (par exemple, l\u0026rsquo;échantillon snowman).\n5. Limitations connues La mise à jour d\u0026rsquo;un plugin qui fournit des fichiers JAR simples peut nécessiter un redémarrage du routeur car le chargeur de classes Java met en cache les classes. La console peut afficher un bouton Stop même si le plugin n\u0026rsquo;a aucun processus actif. Les plugins lancés dans une JVM séparée créent un répertoire logs/ dans le répertoire de travail actuel. La première fois qu\u0026rsquo;une clé de signataire apparaît, elle est automatiquement approuvée ; il n\u0026rsquo;existe aucune autorité de signature centrale. Windows laisse parfois des répertoires vides après la désinstallation d\u0026rsquo;un plugin. L\u0026rsquo;installation d\u0026rsquo;un plugin exclusif à Java 6 sur une JVM Java 5 signale « plugin is corrupt » en raison de la compression Pack200. Les plugins de thème et de traduction restent largement non testés. Les indicateurs de démarrage automatique ne persistent pas toujours pour les plugins non gérés. 6. Exigences et bonnes pratiques La prise en charge des plugins est disponible dans I2P 0.7.12 et versions ultérieures. Maintenez votre routeur et vos plugins à jour pour recevoir les correctifs de sécurité. Fournissez des notes de version concises afin que les utilisateurs comprennent les changements entre les versions. Dans la mesure du possible, hébergez les archives de plugins via HTTPS à l\u0026rsquo;intérieur d\u0026rsquo;I2P pour minimiser l\u0026rsquo;exposition des métadonnées sur le clearnet. 7. Pour aller plus loin Spécification des plugins Framework d\u0026rsquo;application cliente Dépôt de scripts I2P pour les utilitaires d\u0026rsquo;empaquetage ","description":"Installation, mise à jour et développement de plugins pour le routeur","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"Installation de Plugins Personnalisés","url":"/fr/docs/guides/plugins/"},{"categories":null,"content":"Ce dont vous aurez besoin Un Mac fonctionnant sous macOS 10.14 (Mojave) ou version ultérieure Accès administrateur pour installer des applications Environ 15 à 20 minutes Connexion Internet pour télécharger les installateurs Vue d\u0026rsquo;ensemble Ce processus d\u0026rsquo;installation comporte quatre étapes principales :\nInstaller Java - Téléchargez et installez Oracle Java Runtime Environment Installer I2P - Téléchargez et exécutez le programme d\u0026rsquo;installation I2P Configurer l\u0026rsquo;application I2P - Configurez le lanceur et ajoutez-le à votre dock Configurer la bande passante I2P - Lancez l\u0026rsquo;assistant de configuration pour optimiser votre connexion Première partie : Installer Java I2P nécessite Java pour fonctionner. Si vous avez déjà Java 8 ou une version ultérieure installée, vous pouvez passer directement à la deuxième partie .\nStep 1: Download Java Visitez la page de téléchargement Oracle Java et téléchargez l\u0026rsquo;installateur macOS pour Java 8 ou version ultérieure.\nStep 2: Run the Installer Localisez le fichier .dmg téléchargé dans votre dossier Téléchargements et double-cliquez pour l\u0026rsquo;ouvrir.\nStep 3: Allow Installation macOS peut afficher une invite de sécurité car l\u0026rsquo;installateur provient d\u0026rsquo;un développeur identifié. Cliquez sur Ouvrir pour continuer.\nÉtape 1 : Télécharger Java Cliquez sur Install pour commencer le processus d\u0026rsquo;installation de Java.\nÉtape 2 : Exécuter l\u0026rsquo;installateur L\u0026rsquo;installateur copiera les fichiers et configurera Java sur votre système. Cela prend généralement 1 à 2 minutes.\nÉtape 3 : Autoriser l\u0026rsquo;installation Lorsque vous voyez le message de réussite, Java est installé ! Cliquez sur Fermer pour terminer.\nPart Two: Download and Install I2P Maintenant que Java est installé, vous pouvez installer le routeur I2P.\nÉtape 4 : Installer Java Visitez la page Téléchargements et téléchargez l\u0026rsquo;installateur I2P pour Unix/Linux/BSD/Solaris (le fichier .jar).\nÉtape 5 : Attendre l\u0026rsquo;installation Double-cliquez sur le fichier i2pinstall_X.X.X.jar téléchargé. Le programme d\u0026rsquo;installation se lancera et vous demandera de sélectionner votre langue préférée.\nÉtape 6 : Installation terminée Lisez le message de bienvenue et cliquez sur Suivant pour continuer.\nStep 4: Important Notice L\u0026rsquo;installateur affichera un avis important concernant les mises à jour. Les mises à jour I2P sont signées et vérifiées de bout en bout, même si cet installateur lui-même n\u0026rsquo;est pas signé. Cliquez sur Suivant.\nÉtape 1 : Télécharger I2P Lisez le contrat de licence I2P (licence de type BSD). Cliquez sur Suivant pour accepter.\nÉtape 2 : Exécuter l\u0026rsquo;Installateur Choisissez l\u0026rsquo;emplacement d\u0026rsquo;installation d\u0026rsquo;I2P. L\u0026rsquo;emplacement par défaut (/Applications/i2p) est recommandé. Cliquez sur Suivant.\nÉtape 3 : Écran de bienvenue Laissez tous les composants sélectionnés pour une installation complète. Cliquez sur Suivant.\nÉtape 4 : Avis Important Vérifiez vos choix et cliquez sur Suivant pour commencer l\u0026rsquo;installation d\u0026rsquo;I2P.\nÉtape 5 : Accord de licence L\u0026rsquo;installateur copiera les fichiers I2P sur votre système. Cela prend environ 1 à 2 minutes.\nÉtape 6 : Sélectionner le répertoire d\u0026rsquo;installation L\u0026rsquo;installateur crée des scripts de lancement pour démarrer I2P.\nÉtape 7 : Sélectionner les composants L\u0026rsquo;installateur propose de créer des raccourcis sur le bureau et des entrées de menu. Effectuez vos sélections et cliquez sur Suivant.\nÉtape 8 : Démarrer l\u0026rsquo;installation Succès ! I2P est maintenant installé. Cliquez sur Terminé pour finaliser.\nPart Three: Configure I2P App Maintenant, facilitons le lancement d\u0026rsquo;I2P en l\u0026rsquo;ajoutant à votre dossier Applications et au Dock.\nÉtape 9 : Installation des fichiers Ouvrez le Finder et naviguez vers votre dossier Applications.\nÉtape 10 : Générer les scripts de lancement Recherchez le dossier I2P ou l\u0026rsquo;application Start I2P Router dans /Applications/i2p/.\nÉtape 11 : Raccourcis d\u0026rsquo;installation Faites glisser l\u0026rsquo;application Start I2P Router vers votre Dock pour un accès facile. Vous pouvez également créer un alias sur votre bureau.\nAstuce : Faites un clic droit sur l\u0026rsquo;icône I2P dans le Dock et sélectionnez Options → Garder dans le Dock pour la rendre permanente.\nPart Four: Configure I2P Bandwidth Lorsque vous lancez I2P pour la première fois, vous passerez par un assistant de configuration pour paramétrer vos réglages de bande passante. Cela permet d\u0026rsquo;optimiser les performances d\u0026rsquo;I2P pour votre connexion.\nÉtape 12 : Installation terminée Cliquez sur l\u0026rsquo;icône I2P dans votre Dock (ou double-cliquez sur le lanceur). Votre navigateur web par défaut s\u0026rsquo;ouvrira sur la Console du Routeur I2P.\nStep 2: Welcome Wizard L\u0026rsquo;assistant de configuration vous accueillera. Cliquez sur Next pour commencer à configurer I2P.\nÉtape 1 : Ouvrir le dossier Applications Sélectionnez votre langue d\u0026rsquo;interface préférée et choisissez entre le thème clair ou sombre. Cliquez sur Suivant.\nÉtape 2 : Trouver le lanceur I2P L\u0026rsquo;assistant expliquera le test de bande passante. Ce test se connecte au service M-Lab pour mesurer votre vitesse internet. Cliquez sur Suivant pour continuer.\nÉtape 3 : Ajouter au Dock Cliquez sur Run Test pour mesurer vos vitesses de téléchargement ascendant et descendant. Le test dure environ 30 à 60 secondes.\nStep 6: Test Results Examinez vos résultats de test. I2P recommandera des paramètres de bande passante en fonction de la vitesse de votre connexion.\nÉtape 1 : Lancer I2P Choisissez la quantité de bande passante que vous souhaitez partager avec le réseau I2P :\nAutomatique (Recommandé) : I2P gère la bande passante en fonction de votre utilisation Limitée : Définir des limites spécifiques de téléversement/téléchargement Illimitée : Partager autant que possible (pour les connexions rapides) Cliquez sur Suivant pour enregistrer vos paramètres.\nÉtape 2 : Assistant de bienvenue Votre routeur I2P est maintenant configuré et en fonctionnement ! La console du routeur affichera l\u0026rsquo;état de votre connexion et vous permettra de naviguer sur les sites I2P.\nGetting Started with I2P Maintenant que I2P est installé et configuré, vous pouvez :\nParcourir les sites I2P : Visitez la page d\u0026rsquo;accueil I2P pour voir les liens vers les services I2P populaires Configurer votre navigateur : Créez un profil de navigateur pour accéder aux sites .i2p Explorer les services : Découvrez le courrier électronique I2P, les forums, le partage de fichiers et bien plus encore Surveiller votre router : La console affiche l\u0026rsquo;état de votre réseau et les statistiques Étape 3 : Langue et Thème Console du routeur : http://127.0.0.1:7657/ Configuration : http://127.0.0.1:7657/config Carnet d\u0026rsquo;adresses : http://127.0.0.1:7657/susidns/addressbook Paramètres de bande passante : http://127.0.0.1:7657/config Re-running the Setup Wizard Si vous souhaitez modifier vos paramètres de bande passante ou reconfigurer I2P ultérieurement, vous pouvez relancer l\u0026rsquo;assistant de bienvenue depuis la Console du routeur :\nAllez sur l\u0026rsquo;assistant de configuration I2P Suivez à nouveau les étapes de l\u0026rsquo;assistant Troubleshooting Étape 4 : Informations sur le test de bande passante Vérifier Java : Assurez-vous que Java est installé en exécutant java -version dans le Terminal Vérifier les permissions : Assurez-vous que le dossier I2P dispose des permissions correctes Vérifier les logs : Consultez ~/.i2p/wrapper.log pour les messages d\u0026rsquo;erreur Étape 5 : Exécuter le test de bande passante Assurez-vous qu\u0026rsquo;I2P est en cours d\u0026rsquo;exécution (vérifiez la Console du Router) Configurez les paramètres proxy de votre navigateur pour utiliser le proxy HTTP 127.0.0.1:4444 Patientez 5 à 10 minutes après le démarrage pour qu\u0026rsquo;I2P s\u0026rsquo;intègre au réseau Étape 6 : Résultats des tests Exécutez à nouveau le test de bande passante et ajustez vos paramètres Assurez-vous de partager de la bande passante avec le réseau Vérifiez l\u0026rsquo;état de votre connexion dans la Console du Router Partie Deux : Télécharger et Installer I2P Pour supprimer I2P de votre Mac :\nQuittez le routeur I2P s\u0026rsquo;il est en cours d\u0026rsquo;exécution Supprimez le dossier /Applications/i2p Supprimez le dossier ~/.i2p (votre configuration et vos données I2P) Retirez l\u0026rsquo;icône I2P de votre Dock Next Steps Rejoignez la communauté : Visitez i2pforum.net ou consultez I2P sur Reddit En savoir plus : Lisez la documentation I2P pour comprendre le fonctionnement du réseau Participez : Envisagez de contribuer au développement d\u0026rsquo;I2P ou d\u0026rsquo;héberger de l\u0026rsquo;infrastructure Félicitations ! Vous faites maintenant partie du réseau I2P. Bienvenue sur l\u0026rsquo;internet invisible !\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\n","description":"Guide étape par étape pour installer manuellement I2P et ses dépendances sur macOS","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"Installer I2P sur macOS (La méthode longue)","url":"/fr/docs/guides/installer-i2p-sur-macos-la-m%C3%A9thode-longue/"},{"categories":null,"content":"Intégrer I2P dans votre application est un moyen puissant d\u0026rsquo;embarquer les utilisateurs — mais seulement si le router est configuré de manière responsable.\n1. Coordonner avec les équipes de routeurs Contactez les mainteneurs de Java I2P et i2pd avant de les intégrer. Ils peuvent examiner vos paramètres par défaut et signaler les problèmes de compatibilité. Choisissez l\u0026rsquo;implémentation du router qui correspond à votre pile technologique : Java/Scala → Java I2P C/C++ → i2pd Autres langages → intégrez un router et connectez-le en utilisant SAM v3 ou I2CP Vérifiez les conditions de redistribution pour les binaires du router et les dépendances (environnement d\u0026rsquo;exécution Java, ICU, etc.). 2. Valeurs par défaut de configuration recommandées Visez à \u0026ldquo;contribuer plus que vous ne consommez.\u0026rdquo; Les paramètres par défaut modernes privilégient la santé et la stabilité du réseau.\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. ### Les tunnels participants restent essentiels Ne désactivez pas les tunnels de participation.\nLes routeurs qui ne relaient pas de trafic ont eux-mêmes de moins bonnes performances. Le réseau dépend du partage volontaire de capacité. Le trafic de couverture (trafic relayé) améliore l\u0026rsquo;anonymat. Minimums officiels : - Bande passante partagée : ≥ 12 Ko/s - Activation automatique floodfill : ≥ 128 Ko/s - Recommandé : 2 tunnels entrants / 2 tunnels sortants (par défaut Java I2P)\n3. Persistance et Reseeding Les répertoires d\u0026rsquo;état persistants (netDb/, profils, certificats) doivent être préservés entre les exécutions.\nSans persistance, vos utilisateurs déclencheront des réamorçages (reseeds) à chaque démarrage, ce qui dégradera les performances et augmentera la charge sur les serveurs de réamorçage.\nSi la persistance est impossible (par exemple, conteneurs ou installations éphémères) :\nIntégrer 1 000 à 2 000 router infos dans le programme d\u0026rsquo;installation. Exploiter un ou plusieurs serveurs de reseed personnalisés pour décharger les serveurs publics. Variables de configuration : - Répertoire de base : i2p.dir.base - Répertoire de configuration : i2p.dir.config - Inclut certificates/ pour le reseeding.\n4. Sécurité et exposition Gardez la console du routeur (127.0.0.1:7657) en local uniquement. Utilisez HTTPS si vous exposez l\u0026rsquo;interface utilisateur en externe. Désactivez SAM/I2CP externe sauf si nécessaire. Vérifiez les plugins inclus—distribuez uniquement ce que votre application prend en charge. Incluez toujours une authentification pour l\u0026rsquo;accès distant à la console. Fonctionnalités de sécurité introduites depuis la version 2.5.0 : - Isolation du netDb entre les applications (2.4.0+) - Atténuation des attaques DoS et listes de blocage Tor (2.5.1) - Résistance au sondage NTCP2 (2.9.0) - Améliorations de la sélection des routeurs floodfill (2.6.0+)\n5. APIs prises en charge (2025) API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. Toute la documentation officielle se trouve sous `/docs/api/` — l'ancien chemin `/spec/samv3/` n'existe **pas**. 6. Réseau et Ports Ports par défaut typiques : - 4444 – Proxy HTTP - 4445 – Proxy HTTPS - 7654 – I2CP - 7656 – SAM Bridge - 7657 – Console du routeur - 7658 – Site I2P local - 6668 – Proxy IRC - 9000–31000 – Port routeur aléatoire (UDP/TCP entrant)\nLes routeurs sélectionnent un port entrant aléatoire lors de la première exécution. Le transfert de port améliore les performances, mais UPnP peut gérer cela automatiquement.\n7. Changements récents (2024–2025) Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). ## 8. Expérience utilisateur et tests Communiquer ce que fait I2P et pourquoi la bande passante est partagée. Fournir des diagnostics du router (bande passante, tunnels, statut de reseed). Tester les bundles sur Windows, macOS et Linux (RAM faible incluse). Vérifier l\u0026rsquo;interopérabilité avec les pairs Java I2P et i2pd. Tester la récupération après des coupures réseau et des sorties non gracieuses. 9. Ressources de la Communauté Forum : i2pforum.net ou http://i2pforum.i2p à l\u0026rsquo;intérieur d\u0026rsquo;I2P. Code : i2pgit.org/I2P_Developers/i2p.i2p . IRC (réseau Irc2P) : #i2p-dev, #i2pd. #i2papps non vérifié ; pourrait ne pas exister. Précisez quel réseau (Irc2P vs ilita.i2p) héberge votre canal. Intégrer de manière responsable signifie trouver un équilibre entre l\u0026rsquo;expérience utilisateur, les performances et la contribution au réseau. Utilisez ces valeurs par défaut, restez synchronisé avec les mainteneurs du router, et testez sous charge réelle avant la publication.\n","description":"Guide pratique mis à jour pour intégrer un routeur I2P à votre application de manière responsable","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"Intégrer I2P dans votre application","url":"/fr/docs/applications/embedding/"},{"categories":null,"content":"Qu\u0026rsquo;est-ce qu\u0026rsquo;I2P ? Le Invisible Internet Project (I2P) est une couche réseau anonyme qui permet une communication pair-à-pair résistante à la censure. Les connexions anonymes sont obtenues en chiffrant le trafic de l\u0026rsquo;utilisateur et en l\u0026rsquo;acheminant à travers un réseau distribué géré par des volontaires du monde entier.\nFonctionnalités principales Anonymity I2P cache à la fois l\u0026rsquo;expéditeur et le destinataire des messages. Contrairement aux connexions internet traditionnelles où votre adresse IP est visible par les sites web et les services, I2P utilise plusieurs couches de chiffrement et de routage pour préserver la confidentialité de votre identité.\nDecentralization Il n\u0026rsquo;existe aucune autorité centrale dans I2P. Le réseau est maintenu par des bénévoles qui donnent de la bande passante et des ressources informatiques. Cela le rend résistant à la censure et aux points de défaillance uniques.\nAnonymat Tout le trafic au sein d\u0026rsquo;I2P est chiffré de bout en bout. Les messages sont chiffrés plusieurs fois lorsqu\u0026rsquo;ils traversent le réseau, de manière similaire au fonctionnement de Tor mais avec des différences importantes dans l\u0026rsquo;implémentation.\nHow It Works Décentralisation I2P utilise des « tunnels » pour acheminer le trafic. Lorsque vous envoyez ou recevez des données :\nVotre routeur crée un tunnel sortant (pour l\u0026rsquo;envoi) Votre routeur crée un tunnel entrant (pour la réception) Les messages sont chiffrés et envoyés à travers plusieurs routeurs Chaque routeur ne connaît que le saut précédent et le suivant, pas le chemin complet Chiffrement de bout en bout I2P améliore le routage en oignon traditionnel avec le « garlic routing » :\nPlusieurs messages peuvent être regroupés ensemble (comme des gousses dans une tête d\u0026rsquo;ail) Cela offre de meilleures performances et un anonymat supplémentaire Rend l\u0026rsquo;analyse de trafic plus difficile Network Database I2P maintient une base de données réseau distribuée contenant :\nInformations du routeur Adresses de destination (similaires aux sites web .i2p) Données de routage chiffrées Common Use Cases Tunnels Hébergez ou visitez des sites web se terminant par .i2p - ceux-ci ne sont accessibles que depuis le réseau I2P et offrent de solides garanties d\u0026rsquo;anonymat tant pour les hébergeurs que pour les visiteurs.\nRoutage en Ail Partagez des fichiers de manière anonyme en utilisant BitTorrent sur I2P. De nombreuses applications de torrent intègrent nativement le support I2P.\nBase de données réseau Envoyez et recevez des courriels anonymes en utilisant I2P-Bote ou d\u0026rsquo;autres applications de messagerie conçues pour I2P.\nMessaging Utilisez IRC, la messagerie instantanée ou d\u0026rsquo;autres outils de communication de manière privée sur le réseau I2P.\nGetting Started Prêt à essayer I2P ? Consultez notre page de téléchargements pour installer I2P sur votre système.\nPour plus de détails techniques, consultez l\u0026rsquo;Introduction technique ou explorez la documentation complète.\nComment ça fonctionne Introduction technique - Concepts techniques approfondis Modèle de menace - Comprendre le modèle de sécurité d\u0026rsquo;I2P Comparaison avec Tor - En quoi I2P diffère de Tor Cryptographie - Détails sur les algorithmes cryptographiques d\u0026rsquo;I2P ","description":"Une introduction moins technique au réseau anonyme I2P","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"Introduction à I2P","url":"/fr/docs/overview/intro/"},{"categories":null,"content":"Aperçu Points clés\nI2P fournit un chiffrement de bout en bout pour le trafic IRC à travers ses tunnels. Désactivez SSL/TLS dans les clients IRC sauf si vous utilisez un outproxy vers le clearnet. Le tunnel client Irc2P préconfiguré écoute sur 127.0.0.1:6668 par défaut. Connectez votre client IRC à cette adresse et ce port. N\u0026rsquo;utilisez pas le terme « TLS fourni par le routeur ». Utilisez « chiffrement natif d\u0026rsquo;I2P » ou « chiffrement de bout en bout ». Démarrage rapide (Java I2P) Ouvrez le Gestionnaire de Services Cachés à l\u0026rsquo;adresse http://127.0.0.1:7657/i2ptunnel/ et assurez-vous que le tunnel Irc2P est en cours d\u0026rsquo;exécution. Dans votre client IRC, configurez serveur = 127.0.0.1, port = 6668, SSL/TLS = désactivé. Connectez-vous et rejoignez des canaux comme #i2p, #i2p-dev, #i2p-help. Pour les utilisateurs d\u0026rsquo;i2pd (routeur C++), créez un tunnel client dans tunnels.conf (voir les exemples ci-dessous).\nRéseaux et serveurs IRC2P (main community network) Serveurs fédérés : irc.postman.i2p:6667, irc.echelon.i2p:6667, irc.dg.i2p:6667. Le tunnel Irc2P à 127.0.0.1:6668 se connecte automatiquement à l\u0026rsquo;un de ces serveurs. Canaux typiques : #i2p, #i2p-chat, #i2p-dev, #i2p-help. Ilita network Serveurs : irc.ilita.i2p:6667, irc.r4sas.i2p:6667, irc.acetone.i2p:6667, rusirc.ilita.i2p:6667. Langues principales : russe et anglais. Des interfaces web existent sur certains hôtes. Client setup Recommended, actively maintained WeeChat (terminal) — excellent support SOCKS ; facile à scripter. Pidgin (bureau) — toujours maintenu ; fonctionne bien sous Windows/Linux. Thunderbird Chat (bureau) — pris en charge dans ESR 128+. The Lounge (web auto‑hébergé) — client web moderne. IRC2P (réseau communautaire principal) LimeChat (gratuit, open source). Textual (payant sur l\u0026rsquo;App Store ; source disponible pour la compilation). Réseau Ilita WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin Protocole : IRC Serveur : 127.0.0.1 Port : 6668 Chiffrement : désactivé Nom d\u0026rsquo;utilisateur/pseudonyme : au choix Thunderbird Chat Type de compte : IRC Serveur : 127.0.0.1 Port : 6668 SSL/TLS : désactivé Optionnel : rejoindre automatiquement les canaux à la connexion Dispatch (SAM v3) Exemple de valeurs par défaut de config.toml :\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults Tunnel client Irc2P : 127.0.0.1:6668 → serveur en amont sur le port 6667. Gestionnaire de Services Cachés : http://127.0.0.1:7657/i2ptunnel/. Recommandé, activement maintenu ~/.i2pd/tunnels.conf :\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat Tunnel séparé pour Ilita (exemple) :\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat Options macOS Activer SAM dans Java I2P (désactivé par défaut) via /configclients ou clients.config. Par défaut : 127.0.0.1:7656/TCP et 127.0.0.1:7655/UDP. Cryptographie recommandée : SIGNATURE_TYPE=7 (Ed25519) et i2cp.leaseSetEncType=4,0 (ECIES‑X25519 avec repli ElGamal) ou simplement 4 pour les versions modernes uniquement. Exemples de configurations Java I2P par défaut : 2 entrants / 2 sortants. i2pd par défaut : 5 entrants / 5 sortants. Pour IRC : 2–3 de chaque est suffisant ; définissez explicitement pour un comportement cohérent entre les routeurs. Configuration du client N\u0026rsquo;activez pas SSL/TLS pour les connexions IRC internes I2P. I2P fournit déjà un chiffrement de bout en bout. L\u0026rsquo;ajout de TLS supplémentaire crée une surcharge sans gain d\u0026rsquo;anonymat. Utilisez des clés persistantes pour une identité stable ; évitez de régénérer les clés à chaque redémarrage sauf en phase de test. Si plusieurs applications utilisent IRC, privilégiez des tunnels séparés (non partagés) pour réduire la corrélation entre services. Si vous devez autoriser le contrôle à distance (SAM/I2CP), liez à localhost et sécurisez l\u0026rsquo;accès avec des tunnels SSH ou des reverse proxies authentifiés. Alternative connection method: SOCKS5 Certains clients peuvent se connecter via le proxy SOCKS5 d\u0026rsquo;I2P : 127.0.0.1:4447. Pour de meilleurs résultats, privilégiez un tunnel IRC dédié sur le port 6668 ; SOCKS ne peut pas nettoyer les identifiants de la couche application et peut divulguer des informations si le client n\u0026rsquo;est pas conçu pour l\u0026rsquo;anonymat.\nTroubleshooting Impossible de se connecter — assurez-vous que le tunnel Irc2P est en cours d\u0026rsquo;exécution et que le routeur est entièrement bootstrappé. Blocage lors de la résolution/jonction — vérifiez que SSL est désactivé et que le client pointe vers 127.0.0.1:6668. Latence élevée — I2P a une latence élevée par conception. Maintenez un nombre modeste de tunnels (2–3) et évitez les boucles de reconnexion rapides. Utilisation d\u0026rsquo;applications SAM — confirmez que SAM est activé (Java) ou non bloqué par un pare-feu (i2pd). Les sessions de longue durée sont recommandées. Appendix: Ports and naming Ports de tunnel IRC courants : 6668 (Irc2P par défaut), 6667 et 6669 comme alternatives. Noms d\u0026rsquo;hôte .b32.i2p : forme standard de 52 caractères ; des formes étendues de 56+ caractères existent pour LS2/certificats avancés. Utilisez les noms d\u0026rsquo;hôte .i2p sauf si vous avez explicitement besoin d\u0026rsquo;adresses b32. ","description":"Guide complet des réseaux IRC I2P, clients, tunnels et configuration de serveur (mis à jour 2025)","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"IRC sur I2P","url":"/fr/docs/applications/irc/"},{"categories":null,"content":"Aperçu Ce document spécifie l’aveuglement, le chiffrement et le déchiffrement du LeaseSet2 (LS2) chiffré. Les LeaseSets chiffrés permettent la publication, avec contrôle d’accès, d’informations relatives aux services cachés dans la base de données du réseau I2P.\nFonctionnalités clés: - Rotation quotidienne des clés pour une confidentialité persistante - Autorisation client à deux niveaux (basée sur DH et basée sur PSK) - Chiffrement ChaCha20 pour des performances accrues sur les appareils sans accélération matérielle AES - Signatures Red25519 avec aveuglement de clé - Adhésion des clients respectueuse de la vie privée\nDocumentation associée : - Spécification des structures communes - Structure de LeaseSet (jeu de baux I2P) chiffré - Proposition 123 : Nouvelles entrées netDB - Contexte sur les LeaseSets chiffrés - Documentation de la base de données réseau - Utilisation de NetDB (base de données réseau I2P)\nHistorique des versions et état de l’implémentation Chronologie du développement du protocole Note importante sur la numérotation des versions : I2P utilise deux systèmes distincts de numérotation des versions : - Version API/Router : série 0.9.x (utilisée dans les spécifications techniques) - Version de publication du produit : série 2.x.x (utilisée pour les versions publiques)\nLes spécifications techniques font référence aux versions de l\u0026rsquo;API (p. ex., 0.9.41), tandis que les utilisateurs finaux voient des versions du produit (p. ex., 2.10.0).\nJalons d’implémentation Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility ### État actuel ✅ État du protocole: Stable et inchangé depuis juin 2019 ✅ Java I2P: Entièrement implémenté à partir de la version 0.9.40+ ✅ i2pd (C++): Entièrement implémenté à partir de la version 2.58.0+ ✅ Interopérabilité: Complète entre les implémentations ✅ Déploiement réseau: Prêt pour la production, avec plus de 6 ans d\u0026rsquo;expérience opérationnelle Définitions cryptographiques Notations et conventions || désigne la concaténation mod L désigne la réduction modulo l’ordre d’Ed25519 Tous les tableaux d’octets sont en ordre d’octets réseau (big-endian) sauf indication contraire Les valeurs little-endian sont explicitement indiquées CSRNG(n) Générateur de nombres aléatoires cryptographiquement sûr\nProduit n octets de données aléatoires cryptographiquement sûres, adaptées à la génération de key material (matériel de clés).\nExigences de sécurité: - Doit être sécurisé sur le plan cryptographique (adapté à la génération de clés) - Doit rester sûr lorsque des séquences d’octets adjacentes sont exposées sur le réseau - Les implémentations devraient hacher la sortie provenant de sources potentiellement non fiables\nRéférences : - Considérations de sécurité concernant les PRNG - Discussion des développeurs de Tor H(p, d) Hachage SHA-256 avec personnalisation\nFonction de hachage à séparation de domaine qui prend: - p: chaîne de personnalisation (fournit la séparation de domaine) - d: données à hacher\nImplémentation:\nH(p, d) := SHA-256(p || d) Utilisation: Fournit une séparation de domaines cryptographique pour empêcher les attaques par collision entre différents usages protocolaires de SHA-256.\nChiffrement par flux: ChaCha20 Chiffre de flux : ChaCha20 conformément à la RFC 7539, section 2.4\nParamètres: - S_KEY_LEN = 32 (clé de 256 bits) - S_IV_LEN = 12 (nonce de 96 bits, nombre utilisé une seule fois) - Compteur initial: 1 (RFC 7539 autorise 0 ou 1 ; 1 est recommandé pour les contextes AEAD)\nCHIFFRER(k, iv, plaintext)\nChiffre le texte en clair à l\u0026rsquo;aide de: - k: clé de chiffrement de 32 octets - iv: nonce de 12 octets (DOIT être unique pour chaque clé) - Renvoie un texte chifré de la même taille que le texte en clair\nPropriété de sécurité : L’intégralité du texte chiffré doit être indiscernable d’une donnée aléatoire si la clé est secrète.\nDÉCHIFFRER(k, iv, ciphertext)\nDéchiffre le texte chiffré en utilisant: - k: clé de chiffrement de 32 octets - iv: nonce de 12 octets - Renvoie le texte en clair\nJustification de la conception : ChaCha20 a été préféré à AES car : - 2,5 à 3× plus rapide qu’AES sur les appareils sans accélération matérielle - Implémentation en temps constant plus facile à réaliser - Sécurité et vitesse comparables lorsque AES-NI est disponible\nRéférences: - RFC 7539 - ChaCha20 et Poly1305 pour les protocoles de l\u0026rsquo;IETF\nSIG : Red25519 (algorithme de signature Ed25519 utilisé par I2P) Schéma de signature : Red25519 (SigType 11) avec Key Blinding (aveuglement de clé)\nRed25519 est basé sur des signatures Ed25519 sur la courbe Ed25519, utilisant SHA-512 pour le hachage, avec prise en charge de l\u0026rsquo;aveuglement de clé tel que spécifié dans ZCash RedDSA.\nFonctions :\nDERIVE_PUBLIC(privkey) Renvoie la clé publique correspondant à la clé privée fournie. - Utilise la multiplication scalaire standard d\u0026rsquo;Ed25519 par le point de base\nSIGN(privkey, m) Renvoie une signature générée par la clé privée privkey pour le message m.\nDifférences de signature Red25519 par rapport à Ed25519 : 1. Nonce aléatoire (valeur aléatoire à usage unique) : Utilise 80 octets de données aléatoires supplémentaires\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) Cela rend chaque signature Red25519 (variante randomisée d\u0026rsquo;Ed25519) unique, même pour le même message et la même clé.\nGénération de clés privées: Les clés privées Red25519 sont générées à partir de nombres aléatoires et réduites mod L, plutôt que d\u0026rsquo;utiliser l\u0026rsquo;approche de bit-clamping d\u0026rsquo;Ed25519 (ajustement des bits par masquage). VERIFY(pubkey, m, sig) Vérifie la signature sig par rapport à la clé publique pubkey et au message m. - Renvoie true si la signature est valide, false sinon - La vérification est identique à celle d’Ed25519\nOpérations d\u0026rsquo;aveuglement de clé:\nGENERATE_ALPHA(data, secret) Génère alpha pour l\u0026rsquo;aveuglement de clé. - data: Contient généralement la clé publique de signature et les types de signature - secret: Secret additionnel optionnel (de longueur nulle s\u0026rsquo;il n\u0026rsquo;est pas utilisé) - Le résultat a la même distribution que les clés privées Ed25519 (après réduction mod L)\nBLIND_PRIVKEY(privkey, alpha) Procède à l’aveuglement d’une clé privée à l’aide du secret alpha. - Implémentation : blinded_privkey = (privkey + alpha) mod L - Utilise l’arithmétique scalaire dans le corps\nBLIND_PUBKEY(pubkey, alpha) Aveugle une clé publique à l\u0026rsquo;aide du secret alpha. - Implémentation: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) - Utilise l\u0026rsquo;addition d\u0026rsquo;éléments du groupe (points) sur la courbe\nPropriété critique:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) Considérations de sécurité :\nD’après la spécification du protocole ZCash, section 5.4.6.1 : Pour des raisons de sécurité, alpha doit avoir la même distribution que les clés privées démasquées. Cela garantit que \u0026ldquo;la combinaison d’une clé publique ré-aléatoirisée et de signature(s) effectuée(s) avec cette clé ne révèle pas la clé d’origine à partir de laquelle elle a été ré-aléatoirisée\u0026rdquo;.\nTypes de signatures pris en charge: - Type 7 (Ed25519): Pris en charge pour les destinations existantes (rétrocompatibilité) - Type 11 (Red25519): Recommandé pour les nouvelles destinations utilisant le chiffrement - Clés aveuglées: Utilisez toujours le type 11 (Red25519)\nRéférences: - Spécification du protocole ZCash - Section 5.4.6 RedDSA - Spécification Red25519 d\u0026rsquo;I2P DH: X25519 Diffie-Hellman sur courbe elliptique: X25519\nSystème de négociation de clé publique basé sur Curve25519.\nParamètres: - Clés privées: 32 octets - Clés publiques: 32 octets - Sortie du secret partagé: 32 octets\nFonctions :\nGENERATE_PRIVATE() Génère une nouvelle clé privée de 32 octets à l\u0026rsquo;aide d\u0026rsquo;un CSRNG (générateur de nombres aléatoires cryptographiquement sécurisé).\nDERIVE_PUBLIC(privkey) Dérive la clé publique de 32 octets à partir de la clé privée donnée. - Utilise la multiplication scalaire sur Curve25519\nDH(privkey, pubkey) Effectue un accord de clé Diffie-Hellman. - privkey: Clé privée locale de 32 octets - pubkey: Clé publique distante de 32 octets - Renvoie: Secret partagé de 32 octets\nPropriétés de sécurité: - Hypothèse Diffie-Hellman computationnelle sur Curve25519 - Confidentialité persistante lorsque des clés éphémères sont utilisées - Implémentation en temps constant requise pour prévenir les attaques temporelles\nRéférences: - RFC 7748 - Courbes elliptiques pour la sécurité\nHKDF (fonction de dérivation de clés basée sur HMAC) Fonction de dérivation de clé basée sur HMAC\nExtrait et étend des données de clé à partir des données de clé d\u0026rsquo;entrée.\nParamètres: - salt: 32 octets maximum (généralement 32 octets pour SHA-256) - ikm: matériau de clé d\u0026rsquo;entrée (de longueur quelconque, doit présenter une bonne entropie) - info: informations spécifiques au contexte (séparation des domaines) - n: longueur de sortie en octets\nImplémentation:\nUtilise HKDF (fonction de dérivation de clés basée sur HMAC) tel que spécifié dans la RFC 5869 avec: - Fonction de hachage: SHA-256 - HMAC: Tel que spécifié dans la RFC 2104 - Longueur du sel: Maximum 32 octets (HashLen pour SHA-256)\nSchéma d’utilisation:\nkeys = HKDF(salt, ikm, info, n) Séparation des domaines: Le paramètre info assure une séparation cryptographique des domaines entre les différentes utilisations de HKDF dans le protocole.\nValeurs d\u0026rsquo;informations vérifiées: - \u0026ldquo;ELS2_L1K\u0026rdquo; - Chiffrement de la couche 1 (externe) - \u0026ldquo;ELS2_L2K\u0026rdquo; - Chiffrement de la couche 2 (interne) - \u0026ldquo;ELS2_XCA\u0026rdquo; - Autorisation client DH - \u0026ldquo;ELS2PSKA\u0026rdquo; - Autorisation client PSK - \u0026ldquo;i2pblinding1\u0026rdquo; - Génération alpha\nRéférences: - RFC 5869 - Spécification HKDF - RFC 2104 - Spécification HMAC\nSpécification du format LS2 (version 2 de LeaseSet) chiffré se compose de trois couches imbriquées :\nCouche 0 (Externe): Informations en clair pour le stockage et la récupération Couche 1 (Intermédiaire): Données d\u0026rsquo;authentification du client (chiffrées) Couche 2 (Interne): Données LeaseSet2 proprement dites (chiffrées) Structure générale:\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature Important: Le LS2 (format LeaseSet de seconde génération) chiffré utilise des clés aveuglées. La Destination (identité publique I2P) ne figure pas dans l\u0026rsquo;en-tête. L\u0026rsquo;emplacement de stockage dans la DHT est SHA-256(sig type || blinded public key), avec rotation quotidienne.\nCouche 0 (Externe) - Texte en clair La couche 0 n\u0026rsquo;utilise PAS l\u0026rsquo;en-tête LS2 standard. Elle utilise un format personnalisé optimisé pour les clés aveuglées.\nStructure:\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data **Champ Flags (2 octets, bits 15-0):** - **Bit 0:** Indicateur de clés hors ligne - `0` = Aucune clé hors ligne - `1` = Clés hors ligne présentes (des données de clés éphémères suivent) - **Bits 1-15:** Réservés, doivent être à 0 pour une compatibilité future Données de clé éphémère (présent si le bit de drapeau 0 = 1):\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key **Vérification de la signature :** - **Sans clés hors ligne :** Vérifier avec une clé publique aveuglée - **Avec des clés hors ligne :** Vérifier avec une clé publique temporaire La signature couvre toutes les données de Type à outerCiphertext (inclus).\nCouche 1 (Intermédiaire) - Autorisation du client Déchiffrement: Voir la section Chiffrement de la couche 1 .\nStructure:\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) **Champ Flags (1 octet, bits 7-0):** - **Bit 0:** Mode d'autorisation - `0` = Aucune autorisation par client (tout le monde) - `1` = Autorisation par client (section d'authentification suivante) - **Bits 3-1:** Schéma d'authentification (uniquement si bit 0 = 1) - `000` = authentification client DH - `001` = authentification client PSK - Autres réservés - **Bits 7-4:** Non utilisés, doivent être 0 Données d\u0026rsquo;autorisation client DH (flags = 0x01, bits 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **Entrée authClient (40 octets):** - `clientID_i`: 8 octets - `clientCookie_i`: 32 octets (authCookie chiffré) Données d\u0026rsquo;autorisation du client PSK (clé pré-partagée) (flags = 0x03, bits 3-1 = 001):\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **Entrée authClient (40 octets):** - `clientID_i`: 8 octets - `clientCookie_i`: 32 octets (authCookie chiffré) Couche 2 (interne) - Données du LeaseSet Déchiffrement : Voir la section Chiffrement de couche 2 .\nStructure :\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 La couche interne contient la structure LeaseSet2 (deuxième version de LeaseSet) complète, incluant : - en-tête LS2 - informations de bail - signature LS2 Exigences de vérification : Après déchiffrement, les implémentations doivent vérifier : 1. L\u0026rsquo;horodatage interne correspond à l\u0026rsquo;horodatage externe publié 2. L\u0026rsquo;expiration interne correspond à l\u0026rsquo;expiration externe 3. La signature LS2 (leaseSet v2) est valide 4. Les données de lease sont bien formées\nRéférences: - Spécification des structures communes - détails du format LeaseSet2 (jeu de baux version 2)\nDérivation de la clé d\u0026rsquo;aveuglement Aperçu I2P utilise un schéma d\u0026rsquo;aveuglement de clé additif basé sur Ed25519 et ZCash RedDSA. Les clés aveuglées sont renouvelées quotidiennement (à minuit UTC) afin d\u0026rsquo;assurer la confidentialité persistante (forward secrecy).\nJustification de la conception:\nI2P a explicitement choisi de NE PAS utiliser l’approche de l’annexe A.2 du document rend-spec-v3.txt de Tor. Selon la spécification :\n\u0026ldquo;Nous n\u0026rsquo;utilisons pas l\u0026rsquo;annexe A.2 de rend-spec-v3.txt de Tor, dont les objectifs de conception sont similaires, car ses clés publiques aveuglées peuvent être hors du sous-groupe d\u0026rsquo;ordre premier, avec des implications de sécurité inconnues.\u0026rdquo;\nL\u0026rsquo;aveuglement additif d\u0026rsquo;I2P garantit que les clés aveuglées restent dans le sous-groupe d\u0026rsquo;ordre premier de la courbe Ed25519.\nDéfinitions mathématiques Paramètres Ed25519: - B: point de base Ed25519 (générateur) = 2^255 - 19 - L: ordre Ed25519 = 2^252 + 27742317777372353535851937790883648493\nVariables clés: - A: Clé publique de signature de 32 octets désaveuglée (dans la Destination) - a: Clé privée de signature de 32 octets désaveuglée - A': Clé publique de signature de 32 octets aveuglée (utilisée dans le LeaseSet chiffré) - a': Clé privée de signature de 32 octets aveuglée - alpha: Facteur d\u0026rsquo;aveuglement de 32 octets (secret)\nFonctions utilitaires:\nLEOS2IP(x) \u0026ldquo;Conversion d’une chaîne d’octets Little-Endian en entier\u0026rdquo;\nConvertit un tableau d’octets en ordre little-endian en valeur entière.\nH*(x) \u0026ldquo;Hachage et réduction\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L Même opération que lors de la génération de clés Ed25519.\nGénération Alpha Rotation quotidienne: Un nouvel alpha et des clés aveuglées DOIVENT être générés chaque jour à minuit UTC (00:00:00 UTC).\nGENERATE_ALPHA(destination, date, secret) Algorithme:\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L Paramètres vérifiés: - Personnalisation du sel: \u0026quot;I2PGenerateAlpha\u0026quot; - Info HKDF: \u0026quot;i2pblinding1\u0026quot; - Sortie: 64 octets avant réduction - Distribution d\u0026rsquo;alpha: Identique à celle des clés privées Ed25519 après mod L\nAveuglement de clé privée Algorithme BLIND_PRIVKEY(a, alpha):\nPour le propriétaire de la destination qui publie le LeaseSet chiffré :\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) Critique: La réduction mod L est essentielle pour maintenir la relation algébrique correcte entre la clé privée et la clé publique.\nAveuglement de clé publique Algorithme BLIND_PUBKEY(A, alpha):\nPour les clients récupérant et vérifiant le LeaseSet chiffré :\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) Équivalence mathématique :\nLes deux méthodes produisent des résultats identiques :\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) C’est parce que :\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) Signature avec des clés aveuglées Signature de LeaseSet non aveuglé:\nLe LeaseSet non aveuglé (envoyé directement aux clients authentifiés) est signé avec : - Signature Ed25519 standard (type 7) ou Red25519 (type 11) - Clé privée de signature non aveuglée - Vérifiée avec la clé publique non aveuglée\nAvec des clés hors ligne: - Signé par une clé privée transitoire désaveuglée - Vérifié avec une clé publique transitoire désaveuglée - Les deux doivent être de type 7 ou 11\nSignature d\u0026rsquo;un LeaseSet chiffré :\nLa partie externe d\u0026rsquo;un LeaseSet chiffré utilise des signatures Red25519 avec des clés aveuglées.\nAlgorithme de signature Red25519:\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total Principales différences par rapport à Ed25519: 1. Utilise 80 octets de données aléatoires T (et non le hachage de la clé privée) 2. Utilise directement la valeur de la clé publique (et non le hachage de la clé privée) 3. Chaque signature est unique, même pour le même message et la même clé\nVérification:\nIdentique à Ed25519 :\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; Considérations de sécurité Distribution alpha:\nPour des raisons de sécurité, alpha doit suivre la même distribution que les clés privées non aveuglées. Lors de l\u0026rsquo;aveuglement d\u0026rsquo;Ed25519 (type 7) en Red25519 (type 11), les distributions diffèrent légèrement.\nRecommandation : Utilisez Red25519 (type 11) pour les clés à la fois désaveuglées et aveuglées afin de respecter les exigences de ZCash : \u0026ldquo;la combinaison d’une clé publique ré-aléatoirisée et de signature(s) produite(s) avec cette clé ne révèle pas la clé source de la ré-aléatoirisation.\u0026rdquo;\nPrise en charge du type 7 : Ed25519 est pris en charge pour assurer la rétrocompatibilité avec les destinations existantes, mais le type 11 est recommandé pour les nouvelles destinations chiffrées.\nAvantages de la rotation quotidienne : - Confidentialité persistante (PFS) : La compromission de la clé aveuglée d\u0026rsquo;aujourd\u0026rsquo;hui ne révèle pas celle d\u0026rsquo;hier - Non-corrélabilité : La rotation quotidienne empêche le suivi à long terme via la DHT (table de hachage distribuée) - Séparation des clés : Des clés différentes pour des périodes distinctes\nRéférences : - Spécification du protocole ZCash - Section 5.4.6.1 - Discussion Tor sur le Key Blinding (aveuglement de clé) - Ticket Tor n° 8106 Chiffrement et traitement Dérivation du Subcredential (élément d\u0026rsquo;identification dérivé) Avant le chiffrement, nous dérivons un credential (valeur d\u0026rsquo;authentification) et un subcredential (sous-valeur d\u0026rsquo;authentification) afin d\u0026rsquo;associer les couches chiffrées à la connaissance de la clé publique de signature de la Destination.\nObjectif: Garantir que seuls ceux qui connaissent la clé publique de signature de la Destination (identifiant de service I2P) peuvent déchiffrer le LeaseSet chiffré. La Destination complète n\u0026rsquo;est pas nécessaire.\nCalcul des informations d\u0026rsquo;identification A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes Séparation de domaines: La chaîne de personnalisation \u0026quot;credential\u0026quot; garantit que ce hachage n\u0026rsquo;entre pas en collision avec les clés de recherche de la DHT ni avec d\u0026rsquo;autres usages du protocole.\nCalcul du Subcredential (identifiant dérivé) blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes Objectif: Le subcredential (identifiant secondaire) lie le LeaseSet chiffré à: 1. La Destination spécifique (via l’identifiant) 2. La clé aveuglée spécifique (via blindedPublicKey) 3. Le jour spécifique (via la rotation quotidienne de blindedPublicKey)\nCela empêche les attaques par rejeu et les recoupements d\u0026rsquo;un jour à l\u0026rsquo;autre.\nChiffrement de la couche 1 Contexte : La couche 1 contient des données d’autorisation du client et est chiffrée à l’aide d’une clé dérivée du subcredential (sous‑identifiant d’authentification).\nAlgorithme de chiffrement # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) Sortie: outerCiphertext est de 32 + len(outerPlaintext) octets.\nPropriétés de sécurité: - Le sel garantit des paires clé/IV uniques, même pour le même subcredential (sous-identifiant d’authentification) - La chaîne de contexte \u0026quot;ELS2_L1K\u0026quot; assure une séparation des domaines - ChaCha20 assure une sécurité sémantique (texte chiffré indiscernable du hasard)\nAlgorithme de déchiffrement # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) Vérification: Après déchiffrement, vérifiez que la structure de la couche 1 est bien formée avant de passer à la couche 2.\nChiffrement de la couche 2 Contexte: La couche 2 contient les données LeaseSet2 proprement dites et est chiffrée avec une clé dérivée d\u0026rsquo;authCookie (si l\u0026rsquo;authentification par client est activée) ou de la chaîne vide (sinon).\nAlgorithme de chiffrement # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) Sortie : innerCiphertext fait 32 + len(innerPlaintext) octets.\nLiaison de clé: - Si aucune authentification client : Associée uniquement à subcredential (sous-jeton d’authentification) et à l’horodatage - Si l’authentification client est activée : Associée en plus à authCookie (différent pour chaque client autorisé)\nAlgorithme de déchiffrement # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) Vérification : Après déchiffrement : 1. Vérifier que l’octet de type LS2 est valide (3 ou 7) 2. Analyser la structure LeaseSet2 (deuxième génération de LeaseSet) 3. Vérifier que l’horodatage interne correspond à l’horodatage externe publié 4. Vérifier que l’expiration interne correspond à l’expiration externe 5. Vérifier la signature de LeaseSet2\nRésumé de la couche de chiffrement ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ Flux de déchiffrement : 1. Vérifier la signature de la couche 0 avec la clé publique aveuglée 2. Déchiffrer la couche 1 à l\u0026rsquo;aide de subcredential (justificatif dérivé) 3. Traiter les données d\u0026rsquo;autorisation (si présentes) pour obtenir authCookie (jeton d\u0026rsquo;authentification) 4. Déchiffrer la couche 2 en utilisant authCookie et subcredential 5. Vérifier et analyser LeaseSet2\nAutorisation par client Vue d\u0026rsquo;ensemble Lorsque l’autorisation par client est activée, le serveur conserve une liste de clients autorisés. Chaque client dispose de données de clé qui doivent être transmises de manière sécurisée par un canal hors bande.\nDeux mécanismes d’autorisation : 1. Autorisation client DH (Diffie-Hellman): Plus sécurisé, utilise l’accord de clé X25519 2. Autorisation PSK (clé pré-partagée): Plus simple, utilise des clés symétriques\nPropriétés de sécurité courantes : - Confidentialité de l’appartenance des clients : Les observateurs voient le nombre de clients mais ne peuvent pas identifier de clients spécifiques - Ajout/révocation de clients de façon anonyme : Impossible de déterminer quand des clients spécifiques sont ajoutés ou retirés - Probabilité de collision d’un identifiant client sur 8 octets : ~1 sur 18 milliards de milliards (négligeable)\nAutorisation du client via DH (échange de clés Diffie–Hellman) Aperçu: Chaque client génère une paire de clés X25519 et envoie sa clé publique au serveur via un canal hors bande sécurisé. Le serveur utilise un Diffie-Hellman éphémère pour chiffrer un authCookie unique pour chaque client.\nGénération des clés client # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) Avantage de sécurité : La clé privée du client ne quitte jamais son appareil. Un adversaire qui intercepte la transmission hors bande ne peut pas déchiffrer de futurs LeaseSets chiffrés sans casser X25519 DH (échange de clés Diffie-Hellman X25519).\nTraitement côté serveur # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Structure de données de la couche 1:\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Recommandations serveur: - Générer une nouvelle paire de clés éphémère pour chaque LeaseSet chiffré publié - Randomiser l\u0026rsquo;ordre des clients pour empêcher le suivi basé sur la position - Envisager d\u0026rsquo;ajouter des entrées factices pour masquer le nombre réel de clients\nTraitement côté client # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Gestion des erreurs côté client: - Si clientID_i est introuvable : le client a été révoqué ou n\u0026rsquo;a jamais été autorisé - Si le déchiffrement échoue : données corrompues ou clés incorrectes (extrêmement rare) - Les clients devraient réinterroger périodiquement pour détecter une révocation\nAutorisation du client par PSK Vue d\u0026rsquo;ensemble : Chaque client possède une clé symétrique de 32 octets pré-partagée (PSK). Le serveur chiffre le même authCookie à l\u0026rsquo;aide de la PSK de chaque client.\nGénération de clés # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel Note de sécurité: Le même PSK (clé pré-partagée) peut être partagé entre plusieurs clients si désiré (crée une autorisation de type \u0026ldquo;groupe\u0026rdquo;).\nTraitement côté serveur # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Structure de données de la couche 1:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Traitement côté client # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Comparaison et recommandations Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access **Recommandation:** - **Utilisez l’autorisation DH** pour des applications hautement sécurisées où la forward secrecy (confidentialité persistante) est importante - **Utilisez l’autorisation PSK** lorsque les performances sont critiques ou lors de la gestion de groupes de clients - **Ne réutilisez jamais les PSK** entre différents services ou périodes - **Utilisez toujours des canaux sécurisés** pour la distribution des clés (p. ex., Signal, OTR, PGP) Considérations de sécurité Confidentialité de l\u0026rsquo;appartenance des clients:\nLes deux mécanismes assurent la confidentialité de l’appartenance des clients grâce à : 1. Identifiants client chiffrés : clientID de 8 octets dérivé de la sortie de HKDF 2. Cookies indiscernables : tous les clientCookie de 32 octets semblent aléatoires 3. Aucune métadonnée spécifique à un client : aucun moyen d’identifier quelle entrée appartient à quel client\nUn observateur peut voir : - Nombre de clients autorisés (d\u0026rsquo;après le champ clients) - Évolution du nombre de clients au fil du temps\nUn observateur NE PEUT PAS voir: - Quels clients spécifiques sont autorisés - Quand des clients spécifiques sont ajoutés ou supprimés (si le nombre reste inchangé) - Toute information permettant d’identifier un client\nRecommandations de randomisation :\nLes serveurs DEVRAIENT mélanger aléatoirement l’ordre des clients chaque fois qu’ils génèrent un LeaseSet chiffré :\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order Avantages : - Empêche les clients de connaître leur position dans la liste - Empêche les attaques d\u0026rsquo;inférence basées sur des changements de position - Rend indiscernables l\u0026rsquo;ajout et la révocation de clients\nMasquer le nombre de clients:\nLes serveurs PEUVENT insérer des entrées factices aléatoires :\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) Coût: Les entrées factices augmentent la taille du LeaseSet chiffré (40 octets chacune).\nRotation d\u0026rsquo;AuthCookie (cookie d\u0026rsquo;authentification):\nLes serveurs devraient générer un nouvel authCookie: - Chaque fois qu\u0026rsquo;un LeaseSet chiffré est publié (toutes les quelques heures, en général) - Immédiatement après la révocation d\u0026rsquo;un client - Selon un calendrier régulier (p. ex., quotidien), même si aucun client ne change\nAvantages: - Limite l\u0026rsquo;exposition si authCookie est compromis - Garantit que les clients révoqués perdent rapidement l\u0026rsquo;accès - Fournit la confidentialité persistante pour la couche 2\nAdressage en Base32 pour les LeaseSets chiffrés (ensembles de baux) Vue d\u0026rsquo;ensemble Les adresses I2P en base32 traditionnelles ne contiennent que le hachage de la Destination (32 octets → 52 caractères). Cela est insuffisant pour les LeaseSets chiffrés, car :\nLes clients ont besoin de la clé publique non aveuglée pour dériver la clé publique aveuglée Les clients ont besoin des types de signature (non aveuglée et aveuglée) pour une dérivation correcte des clés Le hachage seul ne fournit pas ces informations Solution : Un nouveau format base32 qui inclut les types de clé publique et de signature.\nSpécification du format d\u0026rsquo;adresse Structure décodée (35 octets):\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ Les 3 premiers octets (XOR avec la somme de contrôle):\nLes 3 premiers octets contiennent des métadonnées combinées par XOR (ou exclusif) avec des portions d\u0026rsquo;une somme de contrôle CRC-32 :\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey Propriétés de la somme de contrôle : - Utilise le polynôme CRC-32 standard - Taux de faux négatifs : ~1 sur 16 millions - Permet de détecter les erreurs de frappe dans les adresses - Ne peut pas être utilisé pour l\u0026rsquo;authentification (non sécurisé cryptographiquement)\nFormat encodé:\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; Caractéristiques: - Nombre total de caractères: 56 (35 octets × 8 bits ÷ 5 bits par caractère) - Suffixe: \u0026ldquo;.b32.i2p\u0026rdquo; (identique à la base32 traditionnelle) - Longueur totale: 56 + 8 = 64 caractères (sans le terminateur nul)\nEncodage Base32: - Alphabet: abcdefghijklmnopqrstuvwxyz234567 (standard RFC 4648) - 5 bits inutilisés à la fin DOIVENT être à 0 - Insensible à la casse (par convention en minuscules)\nGénération d\u0026rsquo;adresses import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address Analyse syntaxique des adresses import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype Comparaison avec le Base32 traditionnel Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations ### Restrictions d'utilisation Incompatibilité avec BitTorrent:\nLes adresses LS2 chiffrées NE PEUVENT PAS être utilisées avec les réponses d’annonce compactes de BitTorrent :\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ Problème: Le format compact ne contient que le hachage (32 octets), sans espace pour les types de signature ni les informations de clé publique.\nSolution : Utilisez des réponses d\u0026rsquo;annonce complètes ou des trackers basés sur HTTP qui prennent en charge les adresses complètes.\nIntégration du carnet d’adresses Si un client dispose de la Destination complète (identifiant cryptographique I2P) dans un carnet d’adresses :\nStocker la Destination complète (identité I2P) (inclut la clé publique) Prendre en charge la recherche inverse par hachage Lorsqu\u0026rsquo;un LS2 (LeaseSet version 2) chiffré est rencontré, récupérer la clé publique depuis le carnet d\u0026rsquo;adresses Pas besoin d\u0026rsquo;un nouveau format base32 si la Destination complète est déjà connue Formats de carnet d’adresses qui prennent en charge LS2 (LeaseSet2, nouvelle version de leaseSet) chiffré: - hosts.txt avec des chaînes de destination complètes - bases de données SQLite avec colonne de destination - formats JSON/XML avec des données de destination complètes\nExemples d\u0026rsquo;implémentation Exemple 1 : Générer une adresse\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p Exemple 2: Analyser et valider\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) Exemple 3 : Conversion depuis une Destination (identité publique I2P)\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) Considérations de sécurité Confidentialité: - L\u0026rsquo;adresse Base32 révèle la clé publique - C\u0026rsquo;est intentionnel et requis par le protocole - Ne révèle PAS la clé privée et ne compromet pas la sécurité - Les clés publiques sont, par conception, des informations publiques\nRésistance aux collisions: - CRC-32 n\u0026rsquo;offre que 32 bits de résistance aux collisions - Non sécurisé cryptographiquement (à utiliser uniquement pour la détection d\u0026rsquo;erreurs) - Ne PAS s’appuyer sur la somme de contrôle pour l’authentification - Une vérification complète de la destination reste nécessaire\nValidation d\u0026rsquo;adresse: - Toujours valider la somme de contrôle avant utilisation - Rejeter les adresses avec des types de signature invalides - Vérifier que la clé publique est sur la courbe (spécifique à l\u0026rsquo;implémentation)\nRéférences: - Proposition 149 : B32 pour LS2 chiffré - Spécification d\u0026rsquo;adressage B32 - Spécification de nommage I2P Prise en charge des clés hors ligne Aperçu Les clés hors ligne permettent à la clé de signature principale de rester hors ligne (stockage à froid) tandis qu\u0026rsquo;une clé de signature éphémère est utilisée pour les opérations quotidiennes. Cela est essentiel pour les services à haute sécurité.\nExigences spécifiques pour LS2 chiffré: - Les clés éphémères doivent être générées hors ligne - Les clés privées aveuglées doivent être pré-générées (une par jour) - Les clés, qu’elles soient éphémères ou aveuglées, sont fournies par lots - Aucun format de fichier standardisé n’est encore défini (à faire dans la spécification)\nStructure de la clé hors ligne Données de clé éphémère de la couche 0 (lorsque le bit de drapeau 0 = 1) :\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ Portée de la signature: La signature dans le bloc de clé hors ligne couvre : - Horodatage d’expiration (4 octets) - Type de signature temporaire (2 octets) - Clé publique de signature temporaire (variable)\nCette signature est vérifiée à l\u0026rsquo;aide de la clé publique aveuglée, prouvant que l\u0026rsquo;entité détenant la clé privée aveuglée a autorisé cette clé éphémère.\nProcessus de génération de clés Pour un LeaseSet chiffré avec des clés hors ligne:\nGénérer des paires de clés éphémères (hors ligne, en stockage à froid):\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\nPour chaque jour for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026quot;%Y%m%d\u0026quot;) # \u0026quot;YYYYMMDD\u0026quot; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) 3. **Sign transient keys with blinded keys** (offline): ```python for date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router: Pour chaque date delivery_package[date] = { 'transient_privkey': keys[date][0], 'transient_pubkey': keys[date][1], 'blinded_privkey': blinded_keys[date][0], 'blinded_pubkey': blinded_keys[date][1], 'offline_sig_block': offline_sig_blocks[date] }\n### Router Usage **Daily Key Loading:** ```python # À minuit UTC (ou avant publication) date = datetime.utcnow().date() # Charger les clés du jour today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # Utilisez ces clés pour le LeaseSet (ensemble de baux) chiffré d\u0026#39;aujourd\u0026#39;hui Publishing Process:\n# 1. Créer un LeaseSet2 interne inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. Chiffrer la couche 2 layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. Créer la couche 1 avec des données d’autorisation layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. Chiffrer la couche 1 layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. Créer la couche 0 avec un bloc de signature hors ligne layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ) # 6. Signer la couche 0 avec une clé privée éphémère signature = RED25519_SIGN(transient_privkey, layer0) # 7. Ajouter la signature et publier encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# Générez LES DEUX, de nouvelles clés éphémères et de nouvelles clés aveuglées, chaque jour for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - Lot de matériel de clés chiffré - Plage de dates couverte OFFLINE_KEY_STATUS - Nombre de jours restants - Date d\u0026#39;expiration de la prochaine clé REVOKE_OFFLINE_KEYS - Plage de dates à révoquer - Nouvelles clés de remplacement (facultatif) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p Key Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# Activer le LeaseSet (descripteur d\u0026#39;accès à une destination I2P) chiffré i2cp.encryptLeaseSet=true # Facultatif : activer l’autorisation des clients i2cp.enableAccessList=true # Facultatif : utiliser l’autorisation DH (Diffie-Hellman) (par défaut : PSK, clé pré-partagée) i2cp.accessListType=0 # Facultatif : Blinding secret (secret d’aveuglement, fortement recommandé) i2cp.blindingSecret=votre-secret-ici API Usage Example:\n// Créer un LeaseSet chiffré EncryptedLeaseSet els = new EncryptedLeaseSet(); // Définir la destination els.setDestination(destination); // Activer l\u0026#39;autorisation par client els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // Ajouter des clients autorisés (clés publiques DH (Diffie-Hellman)) for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // Définir les paramètres d\u0026#39;aveuglement (blinding) els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // Signer et publier els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd Key Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Activer le LeaseSet chiffré encryptleaseset = true # Optionnel : Type d’autorisation client (0=DH, 1=PSK) authtype = 0 # Optionnel: Secret d\u0026#39;aveuglement secret = your-secret-here # Facultatif : Clients autorisés (une par ligne, clés publiques encodées en base64) client.1 = base64-encoded-client-pubkey-1 client.2 = base64-encoded-client-pubkey-2 API Usage Example:\n// Créer un LeaseSet chiffré auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // Activer l\u0026#39;autorisation par client encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // Ajouter les clients autorisés for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // Signer et publier encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# Vecteur de test 1 : Aveuglement de clé destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # Attendu: (vérifier par rapport à l\u0026#39;implémentation de référence) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets Red25519 Specification - Detailed Red25519 implementation B32 Addressing Specification - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # Point de base Ed25519 (générateur) B = 2**255 - 19 # Ordre d\u0026#39;Ed25519 (taille du corps scalaire) L = 2**252 + 27742317777372353535851937790883648493 # Valeurs des types de signature SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # Tailles de clés PRIVKEY_SIZE = 32 # bytes PUBKEY_SIZE = 32 # bytes SIGNATURE_SIZE = 64 # bytes ChaCha20 Constants # Paramètres de ChaCha20 CHACHA20_KEY_SIZE = 32 # octets (256 bits) CHACHA20_NONCE_SIZE = 12 # octets (96 bits) CHACHA20_INITIAL_COUNTER = 1 # RFC 7539 autorise 0 ou 1 HKDF Constants # Paramètres de HKDF (fonction de dérivation de clés basée sur HMAC) HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # bytes (HashLen) # Chaînes d\u0026#39;info HKDF (séparation des domaines) HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # Chaînes de personnalisation pour SHA-256 HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # Tailles de la couche 0 (externe) BLINDED_SIGTYPE_SIZE = 2 # octets BLINDED_PUBKEY_SIZE = 32 # octets (pour Red25519) PUBLISHED_TS_SIZE = 4 # octets EXPIRES_SIZE = 2 # octets FLAGS_SIZE = 2 # octets LEN_OUTER_CIPHER_SIZE = 2 # octets SIGNATURE_SIZE = 64 # octets (Red25519) # Tailles des blocs de clés hors ligne OFFLINE_EXPIRES_SIZE = 4 # octets OFFLINE_SIGTYPE_SIZE = 2 # octets OFFLINE_SIGNATURE_SIZE = 64 # octets # Tailles de la couche 1 (intermédiaire) AUTH_FLAGS_SIZE = 1 # octet EPHEMERAL_PUBKEY_SIZE = 32 # octets (authentification DH) AUTH_SALT_SIZE = 32 # octets (authentification PSK) NUM_CLIENTS_SIZE = 2 # octets CLIENT_ID_SIZE = 8 # octets CLIENT_COOKIE_SIZE = 32 # octets AUTH_CLIENT_ENTRY_SIZE = 40 # octets (CLIENT_ID + CLIENT_COOKIE) # Surcoût du chiffrement SALT_SIZE = 32 # octets (ajoutés en tête de chaque couche chiffrée) # Adresse Base32 B32_ENCRYPTED_DECODED_SIZE = 35 # octets B32_ENCRYPTED_ENCODED_LEN = 56 # caractères B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# Clé publique de destination (Ed25519) A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # Secret vide Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 octets salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) mod L Expected Output:\n(Vérifier par rapport à l’implémentation de référence) alpha = [valeur hexadécimale de 64 octets] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nciphertext = [vérifier par rapport aux vecteurs de test de la RFC 7539] Test Vector 3: HKDF Input:\nsalt = bytes(32) # Tous à zéro ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [valeur hexadécimale de 44 octets] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32 octets unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\naddress = [56 caractères en base32].b32.i2p # Vérifiez que la somme de contrôle est valide Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"Format de LeaseSet avec contrôle d'accès pour les Destinations privées","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"LeaseSet (ensemble de baux I2P) chiffré","url":"/fr/docs/specs/encryptedleaseset/"},{"categories":null,"content":"Comme l\u0026rsquo;exige notre modèle de menace (entre autres raisons), le logiciel développé pour prendre en charge le réseau de communication anonyme que nous appelons I2P doit être librement disponible, open source et modifiable par l\u0026rsquo;utilisateur. Pour répondre à ces critères, nous utilisons diverses techniques juridiques et d\u0026rsquo;ingénierie logicielle afin d\u0026rsquo;éliminer autant de barrières à l\u0026rsquo;entrée que possible pour ceux qui envisagent d\u0026rsquo;utiliser ou de contribuer au projet I2P.\nBien que les informations ci-dessous puissent être plus déroutantes que de simplement affirmer \u0026ldquo;I2P est sous BSD\u0026rdquo;, \u0026ldquo;I2P est sous GPL\u0026rdquo; ou \u0026ldquo;I2P est dans le domaine public\u0026rdquo;, la réponse courte à la question \u0026ldquo;Quelle est la licence d\u0026rsquo;I2P ?\u0026rdquo; est la suivante :\nTous les logiciels inclus dans les distributions I2P permettront : utilisation sans frais utilisation sans restrictions sur comment, quand, où, pourquoi, ou par qui elle est exécutée accès au code source sans frais modifications du code source La plupart des logiciels garantissent bien plus - la possibilité pour quiconque de distribuer le code source modifié comme bon lui semble. Cependant, tous les logiciels intégrés ne fournissent pas cette liberté - la GPL restreint la capacité des développeurs qui souhaitent intégrer I2P à leurs propres applications qui ne sont pas elles-mêmes des applications open source. Bien que nous applaudissions les nobles objectifs d\u0026rsquo;augmentation des ressources dans les biens communs, I2P est mieux servi en supprimant tous les obstacles qui se dressent sur le chemin de son adoption - si un développeur qui envisage d\u0026rsquo;intégrer I2P à son application doit s\u0026rsquo;arrêter et consulter son avocat, ou effectuer un audit de code pour s\u0026rsquo;assurer que son propre code source peut être publié sous une licence compatible GPL, nous y perdons.\nLicences des composants La distribution I2P contient plusieurs ressources, reflétant le partitionnement du code source en composants. Chaque composant possède sa propre licence, que tous les développeurs qui y contribuent acceptent - soit en déclarant explicitement la publication du code soumis sous une licence compatible avec ce composant, soit en publiant implicitement le code soumis sous la licence principale du composant. Chacun de ces composants a un développeur principal qui a le dernier mot quant à savoir quelle licence est compatible avec la licence principale du composant, et le chef de projet I2P a le dernier mot quant aux licences qui répondent aux quatre garanties mentionnées ci-dessus pour l\u0026rsquo;inclusion dans la distribution I2P.\nComponent Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD, Cryptix, MIT zzz I2P Router router router.jar Public domain BSD, Cryptix, MIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain, Cryptix, MIT zzz Streaming apps/streaming streaming.jar Public domain BSD, Cryptix, MIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain, BSD, Cryptix, MIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain — zzz Address Book apps/addressbook addressbook.war MIT Public domain, Cryptix, BSD — Susidns apps/susidns susidns.war GPL + exception — — Susimail apps/susimail susimail.war GPL + exception — — I2PSnark apps/i2psnark i2psnark.jar GPL + exception — zzz [BOB](/docs/legacy/bob/) Bridge apps/BOB BOB.jar WTFPL — sponge [SAM](/docs/api/samv3/) Bridge apps/sam sam.jar Public domain Cryptix, BSD, MIT zzz [SAM v1](/docs/legacy/sam/) Perl library apps/sam/perl SAM.pm GPL Public domain, Cryptix, BSD, MIT BrianR [SAM v1](/docs/legacy/sam/) C library apps/sam/c libSAM BSD Public domain, Cryptix, MIT Nightblade [SAM v1](/docs/legacy/sam/) Python library apps/sam/python i2p.py Public domain BSD, Cryptix, MIT Connelly [SAM v1](/docs/legacy/sam/) C# library apps/sam/csharp/ n/a Public domain BSD, Cryptix, MIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source — — Installer installer install.jar, guiinstall.jar Public domain GPL + exception, BSD, Cryptix, MIT — Exception GPL Bien que cela puisse être redondant, pour plus de clarté, le code sous licence GPL inclus dans I2PTunnel et d\u0026rsquo;autres applications doit être publié sous GPL avec une \u0026ldquo;exception\u0026rdquo; supplémentaire autorisant explicitement l\u0026rsquo;utilisation des bibliothèques standard de Java :\nIn addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version. Tout le code source de chaque composant sera par défaut sous licence principale, sauf indication contraire dans le code. Tout ce qui précède est un résumé des termes de licence - veuillez consulter la licence spécifique du composant ou du code source en question pour les termes officiels. Les emplacements des sources des composants et l\u0026rsquo;empaquetage des ressources peuvent être modifiés si le dépôt est réorganisé.\nLicence du site web Sauf mention contraire, le contenu de ce site est sous licence Creative Commons Attribution-ShareAlike 4.0 International .\nAccès aux commits Les développeurs peuvent pousser des modifications vers un dépôt git distribué s\u0026rsquo;ils reçoivent l\u0026rsquo;autorisation de la personne qui gère ce dépôt. Voir le Guide du nouveau développeur pour plus de détails.\nCependant, pour que les modifications soient incluses dans une version, les développeurs doivent être considérés de confiance par le gestionnaire de version (actuellement zzz). De plus, ils doivent explicitement accepter les conditions ci-dessus pour être considérés de confiance. Cela signifie qu\u0026rsquo;ils doivent envoyer à l\u0026rsquo;un des gestionnaires de version un message signé affirmant que :\nSauf indication contraire, tout code que je soumets est implicitement sous licence selon la licence principale du composant Si spécifié dans la source, le code peut être explicitement sous licence selon l\u0026rsquo;une des licences alternatives du composant J\u0026rsquo;ai le droit de publier le code que je soumets selon les termes sous lesquels je le soumets Si quelqu\u0026rsquo;un est au courant de cas où les conditions ci-dessus ne sont pas remplies, veuillez contacter le responsable du composant et/ou un gestionnaire de version I2P avec plus d\u0026rsquo;informations.\n","description":"Politique de licence et licences des composants pour les logiciels intégrés à I2P","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"Licences logicielles I2P","url":"/fr/docs/develop/licenses/"},{"categories":null,"content":"1. Ce que signifie « Anonyme » I2P fournit une anonymat pratique—pas l\u0026rsquo;invisibilité. L\u0026rsquo;anonymat est défini comme la difficulté pour un adversaire d\u0026rsquo;apprendre des informations que vous souhaitez garder privées : qui vous êtes, où vous êtes, ou à qui vous parlez. L\u0026rsquo;anonymat absolu est impossible ; à la place, I2P vise un anonymat suffisant face à des adversaires passifs et actifs globaux.\nVotre anonymat dépend de la façon dont vous configurez I2P, de la manière dont vous choisissez vos pairs et vos abonnements, et des applications que vous exposez.\n2. Évolution cryptographique et du transport (2003 → 2025) Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental **Suite cryptographique actuelle (Noise XK) :** - **X25519** pour l'échange de clés - **ChaCha20/Poly1305 AEAD** pour le chiffrement - **Ed25519 (EdDSA-SHA512)** pour les signatures - **SHA-256** pour le hachage et HKDF - **Hybrides ML-KEM** optionnels pour les tests post-quantiques Toutes les utilisations d\u0026rsquo;ElGamal et d\u0026rsquo;AES-CBC ont été retirées. Le transport est entièrement NTCP2 (TCP) et SSU2 (UDP) ; les deux prennent en charge IPv4/IPv6, le secret de transmission (forward secrecy) et l\u0026rsquo;obscurcissement DPI.\n3. Résumé de l\u0026rsquo;architecture réseau Mixnet à routage libre : Les émetteurs et les destinataires définissent chacun leurs propres tunnels. Aucune autorité centrale : Le routage et le nommage sont décentralisés ; chaque router maintient une confiance locale. Tunnels unidirectionnels : Les tunnels entrants et sortants sont séparés (durée de vie de 10 min). Tunnels exploratoires : 2 sauts par défaut ; tunnels clients 2–3 sauts. Routeurs floodfill : ~1 700 sur ~55 000 nœuds (~6 %) maintiennent la NetDB distribuée. Rotation NetDB : L\u0026rsquo;espace de clés effectue une rotation quotidienne à minuit UTC. Isolation des sous-DB : Depuis la version 2.4.0, chaque client et router utilisent des bases de données séparées pour éviter le lien. 4. Catégories d\u0026rsquo;attaques et défenses actuelles Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. --- 5. Base de données réseau moderne (NetDB) Faits essentiels (toujours exacts) : - DHT Kademlia modifiée stocke les RouterInfo et LeaseSets. - Hachage de clé SHA-256 ; requêtes parallèles vers les 2 floodfills les plus proches avec délai d\u0026rsquo;attente de 10 s. - Durée de vie des LeaseSet ≈ 10 min (LeaseSet2) ou 18 h (MetaLeaseSet).\nNouveaux types (depuis 0.9.38) : - LeaseSet2 (Type 3) – types de chiffrement multiples, horodaté. - EncryptedLeaseSet2 (Type 5) – destination masquée pour services privés (authentification DH ou PSK). - MetaLeaseSet (Type 7) – multihébergement et expirations étendues.\nMise à niveau de sécurité majeure – Isolation Sub-DB (2.4.0) : - Empêche l\u0026rsquo;association router↔client. - Chaque client et router utilisent des segments netDb séparés. - Vérifié et audité (2.5.0).\n6. Mode caché et routes restreintes Mode Caché : Implémenté (automatique dans les pays strictes selon les scores Freedom House).\nLes routeurs ne publient pas de RouterInfo et n\u0026rsquo;acheminent pas le trafic. Routes Restreintes : Partiellement implémenté (tunnels de confiance basiques uniquement).\nLe routage complet par pairs de confiance reste planifié (3.0+). Compromis : Meilleure confidentialité ↔ contribution réduite à la capacité du réseau.\n7. Attaques DoS et Floodfill Historique : Une recherche de l\u0026rsquo;UCSB en 2013 a montré que les attaques Eclipse et la prise de contrôle des floodfills étaient possibles. Les défenses modernes incluent : - Rotation quotidienne de l\u0026rsquo;espace de clés. - Limite de floodfills ≈ 500, un par /16. - Délais de vérification de stockage aléatoires. - Préférence pour les routeurs plus récents (2.6.0). - Correction de l\u0026rsquo;inscription automatique (2.9.0). - Routage sensible à la congestion et limitation des baux (2.4.0+).\nLes attaques floodfill restent théoriquement possibles mais pratiquement plus difficiles.\n8. Analyse du trafic et censure Le trafic I2P est difficile à identifier : pas de port fixe, pas de handshake en clair, et padding aléatoire. Les paquets NTCP2 et SSU2 imitent les protocoles courants et utilisent l\u0026rsquo;obfuscation d\u0026rsquo;en-tête ChaCha20. Les stratégies de padding sont basiques (tailles aléatoires), le trafic factice n\u0026rsquo;est pas implémenté (coûteux). Les connexions depuis les nœuds de sortie Tor sont bloquées depuis la version 2.6.0 (pour protéger les ressources).\n9. Limitations persistantes (reconnues) La corrélation temporelle pour les applications à faible latence reste un risque fondamental. Les attaques par intersection restent puissantes contre les destinations publiques connues. Les attaques Sybil manquent de défense complète (HashCash non appliqué). Le trafic à débit constant et les délais non triviaux restent non implémentés (prévus pour la version 3.0). La transparence concernant ces limites est intentionnelle — elle empêche les utilisateurs de surestimer l\u0026rsquo;anonymat.\n10. Statistiques du réseau (2025) ~55 000 routeurs actifs dans le monde (↑ depuis 7 000 en 2013) ~1 700 routeurs floodfill (~6 %) 95 % participent au routage des tunnels par défaut Niveaux de bande passante : K (\u0026lt;12 Ko/s) → X (\u0026gt;2 Mo/s) Débit minimum floodfill : 128 Ko/s Console du routeur Java 8+ (requis), Java 17+ prévu pour le prochain cycle 11. Développement et ressources centrales Site officiel : geti2p.net Docs : Documentation Dépôt Debian : https://deb.i2pgit.org ( a remplacé deb.i2p2.de en octobre 2023 ) Code source : https://i2pgit.org/I2P_Developers/i2p.i2p (Gitea) + miroir GitHub Toutes les versions sont des conteneurs SU3 signés (RSA-4096, clés zzz/str4d) Pas de listes de diffusion actives ; communauté via https://i2pforum.net et IRC2P. Cycle de mise à jour : versions stables toutes les 6 à 8 semaines. 12. Résumé des améliorations de sécurité depuis la version 0.8.x Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing --- 13. Travaux non résolus connus ou planifiés Routes restreintes complètes (routage par pairs de confiance) → prévu pour la version 3.0. Délai/regroupement non trivial pour résistance au chronométrage → prévu pour la version 3.0. Remplissage avancé et trafic factice → non implémenté. Vérification d\u0026rsquo;identité HashCash → infrastructure existante mais inactive. Remplacement DHT R5N → proposition uniquement. 14. Références clés Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) Documentation officielle I2P 15. Conclusion Le modèle d\u0026rsquo;anonymat fondamental d\u0026rsquo;I2P perdure depuis deux décennies : sacrifier l\u0026rsquo;unicité globale au profit de la confiance locale et de la sécurité. D\u0026rsquo;ElGamal à X25519, de NTCP à NTCP2, et des réamorçages manuels à l\u0026rsquo;isolation Sub-DB, le projet a évolué tout en maintenant sa philosophie de défense en profondeur et de transparence.\nDe nombreuses attaques restent théoriquement possibles contre tout mixnet à faible latence, mais le renforcement continu d\u0026rsquo;I2P les rend de plus en plus impraticables. Le réseau est plus grand, plus rapide et plus sécurisé que jamais — tout en restant honnête sur ses limites.\n","description":"Catalogue des attaques prises en compte dans la conception d'I2P et les mesures d'atténuation mises en place","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"Modèle de menace I2P","url":"/fr/docs/overview/threat-model/"},{"categories":null,"content":"Les adresses I2P sont de longues clés cryptographiques. Le système de nommage fournit une couche plus conviviale au-dessus de ces clés sans introduire d\u0026rsquo;autorité centrale. Tous les noms sont locaux—chaque router décide indépendamment à quelle destination un nom d\u0026rsquo;hôte fait référence.\nBesoin de contexte ? La discussion sur le nommage documente les débats de conception initiaux, les propositions alternatives et les fondements philosophiques derrière le système de nommage décentralisé d\u0026rsquo;I2P.\n1. Composants La couche de nommage d\u0026rsquo;I2P est composée de plusieurs sous-systèmes indépendants mais coopératifs :\nService de nommage – résout les noms d\u0026rsquo;hôtes en destinations et gère les noms d\u0026rsquo;hôtes Base32 . Proxy HTTP – transmet les recherches .i2p au router et suggère des services jump lorsqu\u0026rsquo;un nom est inconnu. Services d\u0026rsquo;ajout d\u0026rsquo;hôtes – formulaires de type CGI qui ajoutent de nouvelles entrées dans le carnet d\u0026rsquo;adresses local. Services jump – assistants distants qui renvoient la destination pour un nom d\u0026rsquo;hôte fourni. Carnet d\u0026rsquo;adresses – récupère et fusionne périodiquement des listes d\u0026rsquo;hôtes distantes en utilisant un « réseau de confiance » localement approuvé. SusiDNS – une interface web pour gérer les carnets d\u0026rsquo;adresses, les abonnements et les remplacements locaux. Cette conception modulaire permet aux utilisateurs de définir leurs propres limites de confiance et d\u0026rsquo;automatiser autant ou aussi peu que souhaité le processus de nommage.\n2. Services de Nommage L\u0026rsquo;API de nommage du router (net.i2p.client.naming) prend en charge plusieurs backends via la propriété configurable i2p.naming.impl=\u0026lt;class\u0026gt;. Chaque implémentation peut offrir différentes stratégies de recherche, mais toutes partagent le même modèle de confiance et de résolution.\n2.1 Hosts.txt (legacy format) Le modèle historique utilisait trois fichiers en texte brut vérifiés dans l\u0026rsquo;ordre :\nprivatehosts.txt userhosts.txt hosts.txt Chaque ligne stocke une correspondance hostname=base64-destination. Ce format texte simple reste entièrement pris en charge pour l\u0026rsquo;import/export, mais ce n\u0026rsquo;est plus le format par défaut en raison de performances médiocres une fois que la liste d\u0026rsquo;hôtes dépasse quelques milliers d\u0026rsquo;entrées.\n2.2 Blockfile Naming Service (default backend) Introduit dans la version 0.8.8, le Blockfile Naming Service est désormais le backend par défaut. Il remplace les fichiers plats par un magasin clé/valeur haute performance sur disque basé sur des skiplists (hostsdb.blockfile) qui offre des recherches environ 10× plus rapides.\nCaractéristiques principales : - Stocke plusieurs carnets d\u0026rsquo;adresses logiques (privé, utilisateur et hôtes) dans une seule base de données binaire. - Maintient la compatibilité avec l\u0026rsquo;import/export des fichiers hosts.txt hérités. - Prend en charge les recherches inversées, les métadonnées (date d\u0026rsquo;ajout, source, commentaires) et la mise en cache efficace. - Utilise le même ordre de recherche à trois niveaux : privé → utilisateur → hôtes.\nCette approche préserve la rétrocompatibilité tout en améliorant considérablement la vitesse de résolution et l\u0026rsquo;évolutivité.\n2.1 Hosts.txt (format obsolète) Les développeurs peuvent implémenter des backends personnalisés tels que : - Meta – agrège plusieurs systèmes de nommage. - PetName – prend en charge les petnames stockés dans un fichier petnames.txt. - AddressDB, Exec, Eepget, et Dummy – pour la résolution externe ou de secours.\nL\u0026rsquo;implémentation blockfile reste le backend recommandé pour un usage général en raison de ses performances et de sa fiabilité.\n3. Base32 Hostnames Les noms d\u0026rsquo;hôte Base32 (*.b32.i2p) fonctionnent de manière similaire aux adresses .onion de Tor. Lorsque vous accédez à une adresse .b32.i2p :\nLe routeur décode la charge utile Base32. Il reconstruit la destination directement à partir de la clé—aucune recherche dans le carnet d\u0026rsquo;adresses n\u0026rsquo;est requise. Cela garantit l\u0026rsquo;accessibilité même si aucun nom d\u0026rsquo;hôte lisible par l\u0026rsquo;homme n\u0026rsquo;existe. Les noms Base32 étendus introduits dans la version 0.9.40 prennent en charge LeaseSet2 et les destinations chiffrées.\n4. Address Book \u0026amp; Subscriptions L\u0026rsquo;application de carnet d\u0026rsquo;adresses récupère les listes d\u0026rsquo;hôtes distants via HTTP et les fusionne localement selon les règles de confiance configurées par l\u0026rsquo;utilisateur.\n2.2 Service de nommage Blockfile (backend par défaut) Les abonnements sont des URL .i2p standard pointant vers des fichiers hosts.txt ou des flux de mise à jour incrémentale. Les mises à jour sont récupérées périodiquement (toutes les heures par défaut) et validées avant fusion. Les conflits sont résolus selon le principe premier arrivé, premier servi, suivant l\u0026rsquo;ordre de priorité :\nprivatehosts.txt → userhosts.txt → hosts.txt. Default Providers Depuis I2P 2.3.0 (juin 2023), deux fournisseurs d\u0026rsquo;abonnement par défaut sont inclus : - http://i2p-projekt.i2p/hosts.txt - http://notbob.i2p/hosts.txt\nCette redondance améliore la fiabilité tout en préservant le modèle de confiance local. Les utilisateurs peuvent ajouter ou supprimer des abonnements via SusiDNS.\nIncremental Updates Les mises à jour incrémentales sont récupérées via newhosts.txt (remplaçant l\u0026rsquo;ancien concept recenthosts.cgi). Ce point de terminaison fournit des mises à jour delta efficaces basées sur ETag—renvoyant uniquement les nouvelles entrées depuis la dernière requête ou 304 Not Modified lorsqu\u0026rsquo;il n\u0026rsquo;y a aucun changement.\n2.3 Backends alternatifs et plug-ins Les services Host-add (add*.cgi) permettent la soumission manuelle de mappages nom-vers-destination. Vérifiez toujours la destination avant d\u0026rsquo;accepter. Les services Jump répondent avec la clé appropriée et peuvent rediriger via le proxy HTTP avec un paramètre ?i2paddresshelper=.\nExemples courants : stats.i2p, identiguy.i2p, et notbob.i2p.\nCes services ne sont pas des autorités de confiance—les utilisateurs doivent décider lesquels utiliser. 5. Managing Entries Locally (SusiDNS) SusiDNS est disponible à : http://127.0.0.1:7657/susidns/\nVous pouvez : - Afficher et modifier les carnets d\u0026rsquo;adresses locaux. - Gérer et prioriser les abonnements. - Importer/exporter des listes d\u0026rsquo;hôtes. - Configurer les planifications de récupération.\nNouveautés d\u0026rsquo;I2P 2.8.1 (mars 2025) : - Ajout d\u0026rsquo;une fonctionnalité « trier par date ». - Amélioration de la gestion des abonnements (correction des incohérences ETag).\nTous les changements restent locaux—le carnet d\u0026rsquo;adresses de chaque routeur est unique.\n3. Noms d\u0026rsquo;hôte Base32 Conformément à la RFC 9476, I2P a enregistré .i2p.alt auprès de la GNUnet Assigned Numbers Authority (GANA) depuis mars 2025 (I2P 2.8.1).\nObjectif : Empêcher les fuites DNS accidentelles provenant de logiciels mal configurés.\nLes résolveurs DNS conformes à la RFC 9476 ne transmettront pas les domaines .alt au DNS public. Le logiciel I2P traite .i2p.alt comme équivalent à .i2p, en supprimant le suffixe .alt lors de la résolution. .i2p.alt n\u0026rsquo;est pas destiné à remplacer .i2p ; c\u0026rsquo;est une mesure de sécurité technique, pas un changement de marque. 4. Carnet d\u0026rsquo;adresses et abonnements Clés de destination : 516–616 octets (Base64) Noms d\u0026rsquo;hôte : Maximum 67 caractères (incluant .i2p) Caractères autorisés : a–z, 0–9, -, . (pas de points doubles, pas de majuscules) Réservé : *.b32.i2p ETag et Last-Modified : activement utilisés pour minimiser la bande passante Taille moyenne de hosts.txt : ~400 Ko pour ~800 hôtes (chiffre d\u0026rsquo;exemple) Utilisation de la bande passante : ~10 octets/sec si récupéré toutes les 12 heures 8. Security Model and Philosophy I2P sacrifie intentionnellement l\u0026rsquo;unicité globale en échange de la décentralisation et de la sécurité—une application directe du triangle de Zooko.\nPrincipes clés : - Aucune autorité centrale : toutes les recherches sont locales. - Résistance au détournement DNS : les requêtes sont chiffrées vers les clés publiques de destination. - Prévention des attaques Sybil : aucun système de vote ou de nommage basé sur le consensus. - Associations immuables : une fois qu\u0026rsquo;une association locale existe, elle ne peut pas être écrasée à distance.\nLes systèmes de nommage basés sur la blockchain (par exemple, Namecoin, ENS) ont exploré la résolution des trois côtés du triangle de Zooko, mais I2P les évite intentionnellement en raison de la latence, de la complexité et de l\u0026rsquo;incompatibilité philosophique avec son modèle de confiance local.\n9. Compatibility and Stability Aucune fonctionnalité de nommage n\u0026rsquo;a été dépréciée entre 2023 et 2025. Le format hosts.txt, les services de redirection (jump services), les abonnements et toutes les implémentations d\u0026rsquo;API de nommage restent fonctionnels. Le projet I2P maintient une stricte rétrocompatibilité tout en introduisant des améliorations de performance et de sécurité (isolation NetDB, séparation Sub-DB, etc.). 10. Best Practices Conservez uniquement les abonnements de confiance ; évitez les listes d\u0026rsquo;hôtes volumineuses et inconnues. Sauvegardez hostsdb.blockfile et privatehosts.txt avant toute mise à niveau ou réinstallation. Examinez régulièrement les services de saut (jump services) et désactivez ceux en qui vous n\u0026rsquo;avez plus confiance. N\u0026rsquo;oubliez pas : votre carnet d\u0026rsquo;adresses définit votre version du monde I2P—chaque nom d\u0026rsquo;hôte est local. Further Reading Discussion sur le nommage Spécification Blockfile Format du fichier de configuration Javadoc du service de nommage ","description":"Comment I2P associe les noms d'hôtes lisibles aux destinations","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"Nommage et carnet d'adresses","url":"/fr/docs/overview/naming/"},{"categories":null,"content":"Cette implémentation d\u0026rsquo;I2P (l\u0026rsquo;implémentation Java distribuée sur ce site) inclut une « Liste des pays stricts » utilisée pour ajuster le comportement du router dans les régions où participer au routage pour d\u0026rsquo;autres utilisateurs peut être restreint par la loi. Bien que nous n\u0026rsquo;ayons pas connaissance de juridictions interdisant l\u0026rsquo;utilisation d\u0026rsquo;I2P, plusieurs ont des interdictions générales concernant le relais de trafic. Les routers qui semblent se trouver dans des pays « stricts » sont automatiquement placés en mode Caché.\nLe Projet fait référence aux recherches d\u0026rsquo;organisations de droits civils et numériques lors de la prise de ces décisions. En particulier, les recherches continues de Freedom House guident nos choix. La recommandation générale est d\u0026rsquo;inclure les pays avec un score de Libertés Civiles (CL) de 16 ou moins, ou un score de Liberté Internet de 39 ou moins (non libre).\nRésumé du mode caché Lorsqu\u0026rsquo;un routeur est placé en mode Caché, trois éléments clés changent dans son comportement :\nIl ne publie pas de RouterInfo dans la netDb. Il n\u0026rsquo;accepte pas les tunnels participants. Il rejette les connexions directes aux routeurs situés dans le même pays. Ces défenses rendent les routeurs plus difficiles à énumérer de manière fiable et réduisent le risque de violer les interdictions locales concernant le relais du trafic pour autrui.\nListe des pays stricts (en 2024) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; Si vous pensez qu\u0026rsquo;un pays devrait être ajouté ou retiré de la liste stricte, veuillez ouvrir un ticket : https://i2pgit.org/i2p/i2p.i2p/ Référence : Freedom House – https://freedomhouse.org/ ","description":"Comment I2P se comporte dans les juridictions où le routage ou les outils d'anonymat sont restreints (Mode Caché et liste stricte)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"Pays stricts/restrictifs","url":"/fr/docs/overview/restrictive-countries/"},{"categories":null,"content":"Performance du réseau I2P : Vitesse, connexions et gestion des ressources Le réseau I2P est entièrement dynamique. Chaque client est connu des autres nœuds et teste localement les nœuds connus pour vérifier leur accessibilité et leur capacité. Seuls les nœuds accessibles et capables sont enregistrés dans une NetDB locale. Pendant le processus de construction de tunnel, les meilleures ressources sont sélectionnées dans ce pool pour construire les tunnels. Comme les tests se déroulent en continu, le pool de nœuds évolue. Chaque nœud I2P connaît une partie différente de la NetDB, ce qui signifie que chaque routeur dispose d\u0026rsquo;un ensemble différent de nœuds I2P à utiliser pour les tunnels. Même si deux routeurs ont le même sous-ensemble de nœuds connus, les tests d\u0026rsquo;accessibilité et de capacité donneront probablement des résultats différents, car les autres routeurs pourraient être sous charge au moment où un routeur effectue ses tests, mais être disponibles lorsque le second routeur effectue les siens.\nCeci explique pourquoi chaque nœud I2P dispose de nœuds différents pour construire des tunnels. Parce que chaque nœud I2P a une latence et une bande passante différentes, les tunnels (qui sont construits via ces nœuds) ont des valeurs de latence et de bande passante différentes. Et parce que chaque nœud I2P a des tunnels construits différemment, aucun deux nœuds I2P n\u0026rsquo;a les mêmes ensembles de tunnels.\nUn serveur/client est appelé une \u0026ldquo;destination\u0026rdquo; et chaque destination possède au moins un tunnel entrant et un tunnel sortant. La valeur par défaut est de 3 sauts par tunnel. Cela représente un total de 12 sauts (12 nœuds I2P différents) pour un aller-retour complet client → serveur → client.\nChaque paquet de données est envoyé à travers 6 autres nœuds I2P jusqu\u0026rsquo;à ce qu\u0026rsquo;il atteigne le serveur :\nclient - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - serveur\net au retour 6 nœuds I2P différents :\nserver - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - client\nLe trafic sur le réseau nécessite un ACK avant l\u0026rsquo;envoi de nouvelles données ; il doit attendre qu\u0026rsquo;un ACK revienne du serveur : envoyer des données, attendre l\u0026rsquo;ACK, envoyer plus de données, attendre l\u0026rsquo;ACK. Comme le RTT (Round Trip Time) s\u0026rsquo;accumule à partir de la latence de chaque nœud I2P individuel et de chaque connexion sur cet aller-retour, il faut généralement 1 à 3 secondes avant qu\u0026rsquo;un ACK revienne au client. En raison de la conception du transport TCP et I2P, un paquet de données a une taille limitée. Ensemble, ces conditions fixent une limite de bande passante maximale par tunnel d\u0026rsquo;environ 20 à 50 ko/s. Cependant, si un seul hop dans le tunnel ne dispose que de 5 ko/s de bande passante, l\u0026rsquo;ensemble du tunnel est limité à 5 ko/s, indépendamment de la latence et des autres limitations.\nLe chiffrement, la latence et la façon dont un tunnel est construit le rendent assez coûteux en temps CPU. C\u0026rsquo;est pourquoi une destination n\u0026rsquo;est autorisée à avoir qu\u0026rsquo;un maximum de 6 tunnels entrants et 6 tunnels sortants pour transporter des données. Avec un maximum de 50 kB/s par tunnel, une destination pourrait utiliser environ 300 kB/s de trafic combiné (en réalité cela pourrait être plus si des tunnels plus courts sont utilisés avec une anonymat faible ou inexistant). Les tunnels utilisés sont éliminés toutes les 10 minutes et de nouveaux sont construits. Ce changement de tunnels, et parfois des clients qui s\u0026rsquo;arrêtent ou perdent leur connexion au réseau, va parfois casser des tunnels et des connexions. Un exemple de cela peut être observé sur le réseau IRC2P par une perte de connexion (ping timeout) ou lors de l\u0026rsquo;utilisation d\u0026rsquo;eepget.\nAvec un ensemble limité de destinations et un ensemble limité de tunnels par destination, un nœud I2P n\u0026rsquo;utilise qu\u0026rsquo;un ensemble limité de tunnels à travers d\u0026rsquo;autres nœuds I2P. Par exemple, si un nœud I2P est \u0026ldquo;hop1\u0026rdquo; dans le petit exemple ci-dessus, il ne voit qu\u0026rsquo;un seul tunnel participant provenant du client. Si nous additionnons l\u0026rsquo;ensemble du réseau I2P, seul un nombre relativement limité de tunnels participants pourrait être construit avec une quantité limitée de bande passante au total. Si l\u0026rsquo;on répartit ces nombres limités sur le nombre de nœuds I2P, il n\u0026rsquo;y a qu\u0026rsquo;une fraction de la bande passante/capacité disponible utilisable.\nPour rester anonyme, un seul routeur ne devrait pas être utilisé par l\u0026rsquo;ensemble du réseau pour construire des tunnels. Si un routeur agit comme routeur de tunnel pour tous les nœuds I2P, il devient un point de défaillance central très réel ainsi qu\u0026rsquo;un point central pour collecter les adresses IP et les données des clients. C\u0026rsquo;est pourquoi le réseau distribue le trafic entre les nœuds dans le processus de construction de tunnels.\nUn autre aspect à considérer pour les performances est la manière dont I2P gère le réseau maillé. Chaque saut de connexion hop-to-hop utilise une connexion TCP ou UDP sur les nœuds I2P. Avec 1000 connexions, on observe 1000 connexions TCP. C\u0026rsquo;est énorme, et certains routeurs domestiques et de petits bureaux n\u0026rsquo;autorisent qu\u0026rsquo;un petit nombre de connexions. I2P tente de limiter ces connexions à moins de 1500 par type UDP et par type TCP. Cela limite également la quantité de trafic acheminé à travers un nœud I2P.\nSi un nœud est joignable, dispose d\u0026rsquo;un paramètre de bande passante partagée supérieur à 128 ko/s et est accessible 24h/24 et 7j/7, il devrait être utilisé après un certain temps pour le trafic participant. S\u0026rsquo;il est indisponible entre-temps, les tests d\u0026rsquo;un nœud I2P effectués par d\u0026rsquo;autres nœuds leur indiqueront qu\u0026rsquo;il n\u0026rsquo;est pas joignable. Cela bloque un nœud pendant au moins 24 heures sur les autres nœuds. Ainsi, les autres nœuds qui ont testé ce nœud comme étant indisponible ne l\u0026rsquo;utiliseront pas pendant 24 heures pour la construction de tunnels. C\u0026rsquo;est pourquoi votre trafic est plus faible après un redémarrage/arrêt de votre routeur I2P pendant un minimum de 24 heures.\nDe plus, les autres nœuds I2P doivent connaître un routeur I2P pour tester sa joignabilité et sa capacité. Ce processus peut être accéléré lorsque vous interagissez avec le réseau, par exemple en utilisant des applications ou en visitant des sites I2P, ce qui entraînera davantage de construction de tunnels et donc plus d\u0026rsquo;activité et de joignabilité pour les tests effectués par les nœuds du réseau.\nHistorique des performances (sélection) Au fil des années, I2P a connu un certain nombre d\u0026rsquo;améliorations de performance notables :\nNative math Implémenté via des liaisons JNI vers la bibliothèque GNU MP (GMP) pour accélérer modPow de BigInteger, qui dominait auparavant le temps CPU. Les premiers résultats ont montré des accélérations spectaculaires en cryptographie à clé publique. Voir : /misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) Auparavant, les réponses nécessitaient souvent une recherche dans la base de données réseau pour le LeaseSet de l\u0026rsquo;expéditeur. L\u0026rsquo;inclusion du LeaseSet de l\u0026rsquo;expéditeur dans le garlic initial améliore la latence des réponses. Cela se fait désormais de manière sélective (au début d\u0026rsquo;une connexion ou lorsque le LeaseSet change) afin de réduire la surcharge.\nMathématiques natives Déplacé certaines étapes de validation plus tôt dans la poignée de main du transport pour rejeter les pairs défectueux plus rapidement (horloges incorrectes, mauvais NAT/pare-feu, versions incompatibles), économisant ainsi du CPU et de la bande passante.\nEnvelopper en garlic un LeaseSet de \u0026ldquo;réponse\u0026rdquo; (ajusté) Utilisez des tests de tunnels sensibles au contexte : évitez de tester les tunnels dont on sait déjà qu\u0026rsquo;ils transmettent des données ; privilégiez les tests en période d\u0026rsquo;inactivité. Cela réduit la charge et accélère la détection des tunnels défaillants.\nRejet TCP plus efficace La persistance des sélections pour une connexion donnée réduit la livraison hors séquence et permet à la bibliothèque de streaming d\u0026rsquo;augmenter la taille des fenêtres, améliorant ainsi le débit.\nAjustements des tests de tunnel GZip ou similaire pour les structures volumineuses (par exemple, options RouterInfo) réduit la bande passante lorsque approprié.\nSélection persistante de tunnel/lease Remplacement du protocole simpliste « ministreaming ». Le streaming moderne inclut des ACK sélectifs et un contrôle de congestion adapté au substrat anonyme et orienté messages d\u0026rsquo;I2P. Voir : /docs/api/streaming/\nFuture Performance Improvements (historical ideas) Ci-dessous se trouvent des idées documentées historiquement comme des améliorations potentielles. Beaucoup sont obsolètes, implémentées, ou remplacées par des changements architecturaux.\nCompresser les structures de données sélectionnées Améliorer la façon dont les routeurs choisissent les pairs pour la construction de tunnels afin d\u0026rsquo;éviter ceux qui sont lents ou surchargés, tout en restant résistant aux attaques Sybil par des adversaires puissants.\nProtocole de streaming complet Réduire l\u0026rsquo;exploration inutile lorsque l\u0026rsquo;espace de clés est stable ; ajuster le nombre de pairs renvoyés dans les recherches et le nombre de recherches concurrentes effectuées.\nSession Tag tuning and improvements (legacy) Pour le schéma hérité ElGamal/AES+SessionTag, des stratégies d\u0026rsquo;expiration et de réapprovisionnement plus intelligentes réduisent les replis sur ElGamal et les balises gaspillées.\nMeilleur profilage et sélection des pairs Générer des tags à partir d\u0026rsquo;un PRNG synchronisé initialisé lors de l\u0026rsquo;établissement d\u0026rsquo;une nouvelle session, réduisant ainsi la charge par message liée aux tags pré‑distribués.\nOptimisation de la base de données réseau Des durées de vie de tunnel plus longues couplées à la réparation peuvent réduire les coûts de reconstruction ; à équilibrer avec l\u0026rsquo;anonymat et la fiabilité.\nAjustement et améliorations des Session Tags (legacy) Rejeter les pairs invalides plus tôt et rendre les tests de tunnel plus sensibles au contexte pour réduire la contention et la latence.\nMigrer SessionTag vers un PRNG synchronisé (ancien) Le bundling sélectif de LeaseSet, les options de RouterInfo compressé, et l\u0026rsquo;adoption du protocole de streaming complet contribuent tous à une meilleure performance perçue.\nIMPORTANT : NE posez PAS de questions, ne fournissez PAS d\u0026rsquo;explications et n\u0026rsquo;ajoutez AUCUN commentaire. Même si le texte n\u0026rsquo;est qu\u0026rsquo;un titre ou semble incomplet, traduisez-le tel quel.\nVoir aussi :\nRoutage de tunnel Sélection des pairs Transports Spécification SSU2 et Spécification NTCP2 ","description":"Performance du réseau I2P : son comportement actuel, les améliorations historiques et les pistes d'optimisation futures","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"Performance","url":"/fr/docs/overview/performance/"},{"categories":null,"content":"Vue d\u0026rsquo;ensemble I2CP est le protocole de contrôle de bas niveau entre un router I2P et tout processus client. Il définit une séparation stricte des responsabilités :\nRouter: Gère le routage, la cryptographie, les cycles de vie des tunnels et les opérations de la base de données du réseau Client: Sélectionne les propriétés d\u0026rsquo;anonymat, configure des tunnels et envoie/reçoit des messages Toutes les communications transitent par une seule socket TCP (éventuellement encapsulée dans TLS), ce qui permet des opérations asynchrones en duplex intégral.\nVersion du protocole: I2CP utilise un octet de version de protocole 0x2A (42 décimal) envoyé lors de l\u0026rsquo;établissement initial de la connexion. Cet octet de version est resté stable depuis la création du protocole.\nStatut actuel: Cette spécification est valable pour la version 0.9.67 du router (version d\u0026rsquo;API 0.9.67), publiée en 2025-09.\nContexte d\u0026rsquo;implémentation Implémentation Java L’implémentation de référence est en Java I2P: - SDK client: i2p.jar package - Implémentation du Router: router.jar package - Javadocs Lorsque le client et le router s’exécutent dans la même JVM, les messages I2CP sont transmis sous forme d’objets Java sans sérialisation. Les clients externes utilisent le protocole sérialisé via TCP.\nImplémentation C++ i2pd (le router I2P en C++) implémente également I2CP en externe pour les connexions client.\nClients non-Java Il n\u0026rsquo;existe aucune implémentation non-Java connue d\u0026rsquo;une bibliothèque cliente I2CP complète. Les applications non-Java devraient plutôt utiliser des protocoles de plus haut niveau :\nSAM (Simple Anonymous Messaging) v3: Interface basée sur des sockets avec des bibliothèques disponibles dans plusieurs langages BOB (Basic Open Bridge): Alternative plus simple à SAM Ces protocoles de niveau supérieur gèrent en interne la complexité d\u0026rsquo;I2CP et fournissent également la bibliothèque de streaming (pour des connexions de type TCP) et la bibliothèque de datagrammes (pour des connexions de type UDP).\nÉtablissement de la connexion 1. Connexion TCP Connectez-vous au port I2CP du router : - Par défaut : 127.0.0.1:7654 - Configurable via les paramètres du router - Enveloppe TLS optionnelle (fortement recommandée pour les connexions à distance)\n2. Négociation du protocole Étape 1: Envoyez l\u0026rsquo;octet de version du protocole 0x2A\nÉtape 2: Synchronisation de l\u0026rsquo;horloge\nClient → Router: GetDateMessage Router → Client: SetDateMessage Le router renvoie son horodatage actuel et la chaîne de version de l’API I2CP (depuis la version 0.8.7).\nÉtape 3: Authentification (si activée)\nÀ partir de la version 0.9.11, l’authentification peut être incluse dans GetDateMessage via un Mapping contenant: - i2cp.username - i2cp.password\nÀ partir de la version 0.9.16, lorsque l’authentification est activée, elle doit être effectuée via GetDateMessage avant l’envoi de tout autre message.\nÉtape 4: Création de la session\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) Étape 5: Signal de disponibilité du Tunnel\nRouter → Client: RequestVariableLeaseSetMessage Ce message indique que des tunnels entrants ont été établis. Le router n’enverra PAS ce message tant qu’au moins un tunnel entrant ET un tunnel sortant n’existent pas.\nÉtape 6: Publication du LeaseSet\nClient → Router: CreateLeaseSet2Message À ce stade, la session est entièrement opérationnelle pour l’envoi et la réception de messages.\nModèles de flux de messages Message sortante (Le client envoie vers une destination distante) Avec i2cp.messageReliability=none:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] Avec i2cp.messageReliability=BestEffort:\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) Message entrant (le Router le remet au client) Avec i2cp.fastReceive=true (valeur par défaut depuis la version 0.9.4):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] Avec i2cp.fastReceive=false (DÉPRÉCIÉ):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage Les clients modernes devraient toujours utiliser le mode de réception rapide.\nStructures de données courantes En-tête de message I2CP Tous les messages I2CP utilisent cet en-tête commun:\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ Longueur du corps : entier sur 4 octets, longueur du corps du message uniquement (exclut l\u0026rsquo;en-tête) Type : entier sur 1 octet, identifiant du type de message Corps du message : 0+ octets, le format varie selon le type de message Taille maximale du message: Environ 64 Ko maximum.\nID de session Entier sur 2 octets identifiant de manière unique une session sur un router.\nValeur spéciale : 0xFFFF indique \u0026ldquo;aucune session\u0026rdquo; (utilisée pour les résolutions de noms d’hôte sans session établie).\nID du message Entier sur 4 octets généré par le router pour identifier de manière unique un message au sein d\u0026rsquo;une session.\nImportant : Les IDs de message ne sont pas uniques globalement, uniquement au sein d\u0026rsquo;une session. Ils sont également distincts du nonce (nombre utilisé une seule fois) généré par le client.\nFormat de la charge utile Les charges utiles des messages sont compressées avec gzip avec un en-tête gzip standard de 10 octets : - Commence par : 0x1F 0x8B 0x08 (RFC 1952) - Depuis 0.7.1 : Les parties inutilisées de l\u0026rsquo;en-tête gzip contiennent des informations de protocole, from-port et to-port - Cela permet le streaming et les datagrammes sur la même destination\nContrôle de la compression : Définissez i2cp.gzip=false pour désactiver la compression (définit l\u0026rsquo;effort de gzip à 0). L\u0026rsquo;en-tête gzip est toujours inclus, mais avec un surcoût de compression minimal.\nStructure de SessionConfig Définit la configuration pour une session client :\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ Exigences critiques: 1. Le mappage doit être trié par clé pour la validation de la signature 2. Date de création doit se situer dans un intervalle de ±30 secondes par rapport à l\u0026rsquo;heure actuelle du router 3. Signature est créée par la SigningPrivateKey (clé privée de signature) de la Destination\nSignatures hors ligne (à partir de la 0.9.38):\nSi vous utilisez la signature hors ligne, le mappage doit contenir : - i2cp.leaseSetOfflineExpiration - i2cp.leaseSetTransientPublicKey - i2cp.leaseSetOfflineSignature\nLa Signature est ensuite générée par la SigningPrivateKey (clé privée de signature) éphémère.\nOptions de configuration du cœur Configuration du tunnel Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) **Remarques**: - Des valeurs de `quantity` \u003e 6 nécessitent des pairs exécutant la version 0.9.0 ou supérieure et augmentent considérablement l'utilisation des ressources - Réglez `backupQuantity` sur 1-2 pour des services à haute disponibilité - Les tunnels à zéro saut sacrifient l'anonymat au profit de la latence, mais sont utiles pour les tests Gestion des messages Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) **Fiabilité des messages**: - `None`: Aucun accusé de réception du router (paramètre par défaut de la bibliothèque de streaming depuis la version 0.8.1) - `BestEffort`: Le router envoie l’acceptation + des notifications de réussite/échec - `Guaranteed`: Non implémenté (se comporte actuellement comme BestEffort) Dérogation par message (depuis la version 0.9.14): - Dans une session avec messageReliability=none, définir un nonce non nul (nombre à usage unique) demande une notification de livraison pour ce message spécifique - Définir nonce=0 dans une session BestEffort désactive les notifications pour ce message\nConfiguration du LeaseSet (annonce de service I2P) Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) ### Anciennes étiquettes de session ElGamal/AES Ces options ne concernent que l\u0026rsquo;ancien chiffrement ElGamal:\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch **Remarque**: Les clients ECIES-X25519 utilisent un mécanisme de ratchet (mécanisme à cliquet) différent et ignorent ces options. Types de chiffrement I2CP prend en charge plusieurs schémas de chiffrement de bout en bout via l’option i2cp.leaseSetEncType. Plusieurs types peuvent être spécifiés (séparés par des virgules) afin de prendre en charge à la fois les pairs modernes et anciens.\nTypes de chiffrement pris en charge Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned **Configuration recommandée**: i2cp.leaseSetEncType=4,0 Cela fournit X25519 (préféré) avec une solution de repli ElGamal pour la compatibilité.\nDétails du type de chiffrement Type 0 - ElGamal/AES+SessionTags (schéma ElGamal/AES avec étiquettes de session): - clés publiques ElGamal 2048 bits (256 octets) - chiffrement symétrique AES-256 - étiquettes de session de 32 octets envoyées par lots - surcharge élevée en CPU, bande passante et mémoire - en cours de retrait progressif à l’échelle du réseau\nType 4 - ECIES-X25519-AEAD-Ratchet: - Échange de clés X25519 (clés de 32 octets) - ChaCha20/Poly1305 AEAD - Double ratchet de style Signal (algorithme à double cliquet) - Étiquettes de session de 8 octets (contre 32 octets pour ElGamal) - Étiquettes générées via un PRNG synchronisé (non envoyées à l\u0026rsquo;avance) - Réduction de ~92 % du surcoût par rapport à ElGamal - Standard pour l\u0026rsquo;I2P moderne (la plupart des routers l\u0026rsquo;utilisent)\nTypes 5-6 - Hybride post-quantique: - Combine X25519 avec ML-KEM (NIST FIPS 203) - Fournit une sécurité résistante aux attaques quantiques - ML-KEM-768 pour un équilibre sécurité/performances - ML-KEM-1024 pour une sécurité maximale - Tailles de messages plus grandes en raison du PQ key material (matériel de clé post-quantique) - La prise en charge réseau est encore en cours de déploiement\nStratégie de migration Le réseau I2P migre activement d\u0026rsquo;ElGamal (type 0) vers X25519 (type 4): - NTCP → NTCP2 (terminé) - SSU → SSU2 (terminé) - ElGamal tunnels → X25519 tunnels (terminé) - ElGamal de bout en bout → ECIES-X25519 (majoritairement terminé)\nLeaseSet2 et fonctionnalités avancées Options de LeaseSet2 (depuis la version 0.9.38) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) ### Adresses aveuglées À partir de la 0.9.39, les destinations peuvent utiliser des adresses \u0026ldquo;blinded\u0026rdquo; (masquées) (format b33) qui changent périodiquement: - Nécessite i2cp.leaseSetSecret pour la protection par mot de passe - Authentification optionnelle par client - Voir les propositions 123 et 149 pour plus de détails\nEnregistrements de service (depuis 0.9.66) LeaseSet2 prend en charge des options pour les enregistrements de service (proposition 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p Le format suit le style des enregistrements SRV DNS, mais il est adapté à I2P.\nSessions multiples (depuis 0.9.21) Une seule connexion I2CP peut maintenir plusieurs sessions :\nSession principale: La première session créée sur une connexion Sous-sessions: Sessions supplémentaires partageant le pool de tunnel de la session principale\nCaractéristiques des sous-sessions Tunnels partagés: Utiliser les mêmes pools de tunnel entrants/sortants que la session principale Clés de chiffrement partagées: Doit utiliser des clés de chiffrement LeaseSet identiques Clés de signature différentes: Doit utiliser des clés de signature de Destination distinctes Aucune garantie d’anonymat: Clairement lié à la session principale (même router, mêmes tunnels) Cas d\u0026rsquo;utilisation d\u0026rsquo;une sous-session Activer la communication avec des destinations utilisant différents types de signature : - Principale : signature EdDSA (moderne) - Sous-session : signature DSA (compatibilité héritée)\nCycle de vie d’une sous-session Création:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) Destruction: - Détruire une sous-session : laisse la session principale intacte - Détruire la session principale : détruit toutes les sous-sessions et ferme la connexion - DisconnectMessage (message de déconnexion) : détruit toutes les sessions\nGestion de l\u0026rsquo;ID de session La plupart des messages I2CP contiennent un champ d\u0026rsquo;ID de session. Exceptions: - DestLookup / DestReply (dépréciés, utilisez HostLookup / HostReply) - GetBandwidthLimits / BandwidthLimits (réponse non spécifique à la session)\nImportant : Les clients ne doivent pas avoir plusieurs messages CreateSession en attente simultanément, car les réponses ne peuvent pas être corrélées sans ambiguïté aux requêtes.\nCatalogue de messages Résumé des types de messages Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current **Légende**: C = Client, R = Router Détails du message clé CreateSessionMessage (Type 1) Objectif: Initier une nouvelle session I2CP\nContenu: structure SessionConfig\nRéponse: SessionStatusMessage (status=Created ou Invalid)\nExigences: - La date dans SessionConfig doit être dans une fenêtre de ±30 secondes par rapport à l’horloge du router - Le mapping doit être trié par clé pour la validation de la signature - Destination ne doit pas déjà avoir une session active\nRequestVariableLeaseSetMessage (Type 37) Objectif: Le Router demande l\u0026rsquo;autorisation du client pour les tunnels entrants\nContenu: - ID de session - Nombre de leases (jetons de routage temporaires) - Tableau de structures Lease (chacune avec sa propre expiration)\nRéponse: CreateLeaseSet2Message\nImportance: C’est le signal indiquant que la session est opérationnelle. Le router l’envoie uniquement après: 1. Au moins un tunnel entrant est établi 2. Au moins un tunnel sortant est établi\nRecommandation de délai d’expiration: Les clients doivent détruire la session si ce message n’est pas reçu dans un délai de 5 minutes ou plus après la création de la session.\nCreateLeaseSet2Message (Type 41) Objectif: Le client publie le LeaseSet dans la base de données du réseau\nContenu: - ID de session - Octet de type LeaseSet (1, 3, 5 ou 7) - LeaseSet ou LeaseSet2 ou EncryptedLeaseSet ou MetaLeaseSet - Nombre de clés privées - Liste des clés privées (une par clé publique dans le LeaseSet, même ordre)\nClés privées: Nécessaires pour déchiffrer les garlic messages entrants (messages « garlic » d’I2P). Format:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) Remarque: Remplace le CreateLeaseSetMessage obsolète (type 4), qui ne prend pas en charge :\nVariantes de LeaseSet2 Chiffrement non-ElGamal Plusieurs types de chiffrement LeaseSets chiffrés Clés de signature hors ligne SendMessageExpiresMessage (Type 36) Objectif: Envoyer un message vers une destination avec expiration et options avancées\nContenu: - ID de session - Destination - Charge utile (compressée en gzip) - Nonce (4 octets) - Indicateurs (2 octets) - voir ci-dessous - Date d\u0026rsquo;expiration (6 octets, tronquée depuis 8)\nChamp des drapeaux (2 octets, ordre des bits 15\u0026hellip;0) :\nBits 15-11: Non utilisés, doivent être à 0\nBits 10-9: Forçage de la fiabilité des messages (inutilisé ; utiliser plutôt un nonce, valeur unique à usage unique)\nBit 8: Ne pas inclure le LeaseSet - 0: Le Router peut inclure le LeaseSet dans un message garlic (mécanisme d\u0026rsquo;agrégation de messages d\u0026rsquo;I2P) - 1: Ne pas inclure le LeaseSet\nBits 7-4: Seuil bas de tags (ElGamal uniquement, ignoré pour ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags Bits 3-0: Étiquettes à envoyer si nécessaire (ElGamal uniquement, ignorées pour ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage (Type 22) Objectif: Notifier le client du statut de livraison du message\nContenu: - ID de session - ID de message (généré par le router) - Code d\u0026rsquo;état (1 octet) - Taille (4 octets, pertinent uniquement si status=0) - Nonce (valeur unique utilisée une seule fois) (4 octets, correspond au nonce de SendMessage du client)\nCodes d\u0026rsquo;état (Messages sortants):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure **Codes de réussite**: 1, 2, 4, 6 **Codes d'échec**: Tous les autres Code d’état 0 (OBSOLÈTE): Message disponible (entrant, réception rapide désactivée)\nHostLookupMessage (Type 38) Objectif: Rechercher la destination par nom d\u0026rsquo;hôte ou par hachage (remplace DestLookup)\nContenu: - ID de session (ou 0xFFFF s\u0026rsquo;il n\u0026rsquo;y a pas de session) - ID de requête (4 octets) - Délai d\u0026rsquo;attente en millisecondes (4 octets, minimum recommandé: 10000) - Type de requête (1 octet) - Clé de recherche (hachage, chaîne de nom d\u0026rsquo;hôte, ou Destination)\nTypes de requêtes:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 Les types 2 à 4 renvoient les options de LeaseSet (proposition 167) si elles sont disponibles. Réponse: HostReplyMessage\nHostReplyMessage (message de réponse d’hôte) (Type 39) Objectif: Réponse à HostLookupMessage (message de résolution de nom d’hôte)\nContenu: - ID de session - ID de requête - Code de résultat (1 octet) - Destination (présente en cas de réussite, parfois en cas d\u0026rsquo;échecs spécifiques) - Mappage (uniquement pour les types de recherche 2-4, peut être vide)\nCodes de résultat:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type #### BlindingInfoMessage (Type 42) Objectif: Informer le router des exigences d’authentification concernant les destinations aveuglées (depuis la version 0.9.43)\nContenu: - ID de session - Indicateurs (1 octet) - Type de point de terminaison (1 octet): 0=Hash, 1=nom d\u0026rsquo;hôte, 2=Destination, 3=SigType+Key - Type de signature aveuglée (2 octets) - Expiration (4 octets, secondes depuis l\u0026rsquo;époque Unix) - Données du point de terminaison (varient selon le type) - Clé privée (32 octets, uniquement si le bit d\u0026rsquo;indicateur 0 est activé) - Mot de passe de recherche (Chaîne, uniquement si le bit d\u0026rsquo;indicateur 4 est activé)\nIndicateurs (ordre des bits 76543210):\nBit 0: 0=tout le monde, 1=par client Bits 3-1: Schéma d\u0026rsquo;authentification (si le bit 0=1): 000=DH, 001=PSK Bit 4: 1=secret requis Bits 7-5: Non utilisés, fixés à 0 Aucune réponse: Le Router traite silencieusement\nCas d\u0026rsquo;utilisation : Avant d\u0026rsquo;envoyer vers une blinded destination (b33 address, destination aveuglée), le client doit soit : 1. Rechercher l\u0026rsquo;adresse b33 via HostLookup (recherche d\u0026rsquo;hôte), OU 2. Envoyer un BlindingInfo message (message d\u0026rsquo;information d\u0026rsquo;aveuglement)\nSi la destination nécessite une authentification, BlindingInfo (informations d\u0026rsquo;aveuglement) est obligatoire.\nReconfigureSessionMessage (Type 2) Objectif: Mettre à jour la configuration de la session après la création\nContenu: - Session ID - SessionConfig (seules les options modifiées sont nécessaires)\nRéponse: SessionStatusMessage (status=Updated ou Invalid)\nRemarques: - Router fusionne la nouvelle configuration avec la configuration existante - Les options de tunnel (inbound.*, outbound.*) sont toujours appliquées - Certaines options peuvent être immuables après la création de la session - La date doit être à ±30 secondes de l\u0026rsquo;heure du router - Le mappage doit être trié par clé\nDestroySessionMessage (message de destruction de session) (Type 3) Objectif: Terminer une session\nContenu: ID de session\nRéponse attendue: SessionStatusMessage (status=Destroyed)\nComportement actuel (Java I2P jusqu\u0026rsquo;à la 0.9.66): - Router n\u0026rsquo;envoie jamais SessionStatus(Destroyed) - S\u0026rsquo;il ne reste aucune session : envoie DisconnectMessage - S\u0026rsquo;il reste des sous-sessions : aucune réponse\nImportant: Le comportement de Java I2P s\u0026rsquo;écarte de la spécification. Les implémentations devraient faire preuve de prudence lors de la destruction de sous-sessions individuelles.\nDisconnectMessage (message de déconnexion) (Type 30) Objectif: Indiquer que la connexion est sur le point d\u0026rsquo;être fermée\nContenu: Motif (chaîne de caractères)\nEffet: Toutes les sessions de la connexion sont détruites, le socket se ferme\nImplémentation: Principalement router → client dans Java I2P\nHistorique des versions du protocole Détection de version La version du protocole I2CP est échangée dans les messages Get/SetDate (depuis la 0.8.7). Pour les routers plus anciens, les informations de version ne sont pas disponibles.\nChaîne de version: Indique la version de l\u0026rsquo;API \u0026ldquo;core\u0026rdquo;, pas nécessairement la version du router.\nChronologie des fonctionnalités Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features ## Considérations de sécurité Authentification Par défaut: Aucune authentification requise Facultatif: Authentification par nom d\u0026rsquo;utilisateur/mot de passe (depuis 0.9.11) Obligatoire: Lorsque cette option est activée, l\u0026rsquo;authentification doit se terminer avant les autres messages (depuis 0.9.16)\nConnexions distantes : Utilisez toujours TLS (i2cp.SSL=true) pour protéger les identifiants et les clés privées.\nDécalage de l\u0026rsquo;horloge SessionConfig Date doit être à ±30 secondes de l’heure du router, sinon la session sera rejetée. Utilisez Get/SetDate pour synchroniser.\nGestion des clés privées CreateLeaseSet2Message (message CreateLeaseSet2, type de message I2P) contient des clés privées pour déchiffrer les messages entrants. Ces clés doivent être : - Transmises de manière sécurisée (TLS pour les connexions distantes) - Stockées de manière sécurisée par le router - Renouvelées en cas de compromission\nExpiration des messages Utilisez toujours SendMessageExpires (et non SendMessage) pour définir une expiration explicite. Ceci : - Empêche que les messages restent en file d’attente indéfiniment - Réduit la consommation de ressources - Améliore la fiabilité\nGestion des tags de session ElGamal (déprécié): - Les tags doivent être transmis par lots - La perte de tags entraîne des échecs de déchiffrement - Surcoût mémoire élevé\nECIES-X25519 (actuel): - Étiquettes générées via un PRNG synchronisé - Aucune transmission préalable nécessaire - Résistant à la perte de messages - Surcharge nettement plus faible\nBonnes pratiques Pour les développeurs de clients Utilisez le mode de réception rapide: Définissez toujours i2cp.fastReceive=true (ou laissez la valeur par défaut)\nPrivilégiez ECIES-X25519: Configurez i2cp.leaseSetEncType=4,0 pour des performances optimales tout en préservant la compatibilité\nDéfinissez une expiration explicite: Utilisez SendMessageExpires, pas SendMessage\nManipulez les sous-sessions avec précaution: Sachez que les sous-sessions n\u0026rsquo;offrent aucun anonymat entre destinations\nExpiration de la création de session: Détruire la session si RequestVariableLeaseSet n\u0026rsquo;est pas reçu dans les 5 minutes\nTrier les mappages de configuration: Toujours trier les clés de mappage avant de signer SessionConfig\nUtilisez des nombres de tunnel appropriés: Ne définissez pas quantity à plus de 6 sauf si nécessaire\nEnvisagez SAM/BOB pour les langages non Java: Implémentez SAM plutôt qu’I2CP directement\nPour les développeurs du Router Valider les dates : Appliquer une tolérance de ±30 secondes sur les dates de SessionConfig\nLimiter la taille des messages: Imposer une taille de message maximale de ~64 KB\nPrise en charge de plusieurs sessions : Implémenter la prise en charge des sous-sessions conformément à la spécification 0.9.21\nEnvoyez RequestVariableLeaseSet (requête de leaseSet variable) rapidement: Uniquement une fois que les tunnels entrants et sortants sont établis\nGérer les messages obsolètes: Accepter mais déconseiller ReceiveMessageBegin/End\nPrendre en charge ECIES-X25519 (implémentation ECIES utilisant X25519): Privilégier le chiffrement de type 4 pour les nouveaux déploiements\nDébogage et dépannage Problèmes courants Session rejetée (invalide): - Vérifiez le décalage d\u0026rsquo;horloge (doit être dans une marge de ±30 secondes) - Vérifiez que Mapping est trié par clé - Assurez-vous que Destination n\u0026rsquo;est pas déjà utilisée\nAucun RequestVariableLeaseSet: - Router est peut-être en train de construire des tunnels (attendez jusqu\u0026rsquo;à 5 minutes) - Vérifiez s\u0026rsquo;il y a des problèmes de connectivité réseau - Vérifiez qu\u0026rsquo;il y a suffisamment de connexions aux pairs\nÉchecs d\u0026rsquo;acheminement des messages: - Vérifiez les codes MessageStatus pour identifier la cause précise de l\u0026rsquo;échec - Vérifiez que le LeaseSet distant est publié et à jour - Assurez-vous que les types de chiffrement sont compatibles\nProblèmes de Subsession (sous-session): - Vérifier que la session principale a été créée en premier - Confirmer les mêmes clés de chiffrement - Vérifier des clés de signature distinctes\nMessages de diagnostic GetBandwidthLimits: Interroger les limites de bande passante du router HostLookup: Tester la résolution de noms et la disponibilité du LeaseSet MessageStatus: Suivre l\u0026rsquo;acheminement des messages de bout en bout\nSpécifications connexes Structures communes: /docs/specs/common-structures/ I2NP (protocole réseau): /docs/specs/i2np/ ECIES-X25519 (schéma ECIES avec X25519): /docs/specs/ecies/ Création de tunnel: /docs/specs/implementation/ Bibliothèque de streaming: /docs/specs/streaming/ Bibliothèque de datagrammes: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ Propositions référencées Proposition 123 : LeaseSets chiffrés et authentification Proposition 144 : ECIES-X25519-AEAD-Ratchet (mécanisme de ratchet cryptographique combinant ECIES et X25519 avec AEAD) Proposition 149 : Format d’adresse aveuglé (b33) Proposition 152 : Création de tunnel X25519 Proposition 154 : Recherches dans la base de données à partir de destinations ECIES Proposition 156 : Migration des routers vers ECIES-X25519 Proposition 161 : Compression du bourrage de destination Proposition 167 : Enregistrements de service du LeaseSet Proposition 169 : Cryptographie hybride post-quantique (ML-KEM) Référence des Javadocs Package I2CP MessageStatusMessage API client Résumé des dépréciations Messages dépréciés (à ne pas utiliser) CreateLeaseSetMessage (type 4): Utilisez CreateLeaseSet2Message RequestLeaseSetMessage (type 21): Utilisez RequestVariableLeaseSetMessage ReceiveMessageBeginMessage (type 6): Utilisez le mode de réception rapide ReceiveMessageEndMessage (type 7): Utilisez le mode de réception rapide DestLookupMessage (type 34): Utilisez HostLookupMessage DestReplyMessage (type 35): Utilisez HostReplyMessage ReportAbuseMessage (type 29): Jamais implémenté Options dépréciées Chiffrement ElGamal (type 0) : migrer vers ECIES-X25519 (type 4) Signatures DSA : migrer vers EdDSA ou ECDSA i2cp.fastReceive=false : toujours utiliser le mode de réception rapide ","description":"Comment les applications négocient des sessions, des tunnels et des LeaseSets avec le router I2P.","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"Protocole client I2P (I2CP)","url":"/fr/docs/specs/i2cp/"},{"categories":null,"content":"Aperçu La I2P Streaming Library fournit un transport fiable, ordonné et authentifié sur la couche de messages I2P, similaire à TCP sur IP. Elle se situe au-dessus du protocole I2CP et est utilisée par presque toutes les applications I2P interactives, notamment les proxies HTTP, IRC, BitTorrent et le courrier électronique.\nCaractéristiques principales Établissement de connexion en une phase utilisant les drapeaux SYN, ACK et FIN qui peuvent être regroupés avec les données de charge utile pour réduire les allers-retours. Contrôle de congestion à fenêtre glissante, avec démarrage lent et évitement de congestion ajustés pour l\u0026rsquo;environnement à haute latence d\u0026rsquo;I2P. Compression de paquets (segments compressés de 4 Ko par défaut) équilibrant le coût de retransmission et la latence de fragmentation. Abstraction de canal entièrement authentifié, chiffré et fiable entre les destinations I2P. Cette conception permet aux petites requêtes et réponses HTTP de se terminer en un seul aller-retour. Un paquet SYN peut transporter la charge utile de la requête, tandis que le SYN/ACK/FIN du répondeur peut contenir le corps complet de la réponse.\nNotions de base de l\u0026rsquo;API L\u0026rsquo;API de streaming Java reflète la programmation socket standard de Java :\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory négocie ou réutilise une session router via I2CP. Si aucune clé n\u0026rsquo;est fournie, une nouvelle destination est automatiquement générée. Les développeurs peuvent transmettre des options I2CP (par exemple, longueurs de tunnel, types de chiffrement ou paramètres de connexion) via la map options. I2PSocket et I2PServerSocket reflètent les interfaces Java Socket standard, rendant la migration simple. La documentation Javadocs complète est disponible depuis la console du routeur I2P ou ici .\nConfiguration et Réglage Vous pouvez passer des propriétés de configuration lors de la création d\u0026rsquo;un gestionnaire de socket via :\nI2PSocketManagerFactory.createManager(host, port, properties); Options de clés Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false ### Comportement par charge de travail Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. Les nouvelles fonctionnalités depuis la version 0.9.4 incluent la suppression des journaux de rejet, la prise en charge des listes DSA (0.9.21) et l'application obligatoire du protocole (0.9.36). Les routeurs depuis la version 2.10.0 incluent le chiffrement hybride post-quantique (ML-KEM + X25519) au niveau de la couche transport. Détails du protocole Chaque flux est identifié par un Stream ID. Les paquets transportent des drapeaux de contrôle similaires à TCP : SYNCHRONIZE, ACK, FIN, et RESET. Les paquets peuvent contenir à la fois des données et des drapeaux de contrôle simultanément, améliorant l\u0026rsquo;efficacité pour les connexions de courte durée.\nCycle de vie de la connexion SYN envoyé — l\u0026rsquo;initiateur inclut des données optionnelles. Réponse SYN/ACK — le répondeur inclut des données optionnelles. Finalisation ACK — établit la fiabilité et l\u0026rsquo;état de session. FIN/RESET — utilisé pour une fermeture ordonnée ou une terminaison abrupte. Fragmentation et réordonnancement Étant donné que les tunnels I2P introduisent de la latence et un réordonnancement des messages, la bibliothèque met en mémoire tampon les paquets provenant de flux inconnus ou arrivant prématurément. Les messages mis en mémoire tampon sont stockés jusqu\u0026rsquo;à ce que la synchronisation soit terminée, garantissant ainsi une livraison complète et ordonnée.\nApplication du protocole L\u0026rsquo;option i2p.streaming.enforceProtocol=true (par défaut depuis la version 0.9.36) garantit que les connexions utilisent le numéro de protocole I2CP correct, évitant ainsi les conflits entre plusieurs sous-systèmes partageant une même destination.\nInteropérabilité et bonnes pratiques Le protocole de streaming coexiste avec l\u0026rsquo;API Datagram, donnant aux développeurs le choix entre des transports orientés connexion et sans connexion.\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram ### Clients Partagés Les applications peuvent réutiliser des tunnels existants en fonctionnant comme clients partagés, permettant à plusieurs services de partager la même destination. Bien que cela réduise la charge système, cela augmente le risque de corrélation entre services—à utiliser avec précaution.\nContrôle de congestion La couche de streaming s\u0026rsquo;adapte en continu à la latence réseau et au débit via un retour d\u0026rsquo;information basé sur le RTT. Les applications fonctionnent mieux lorsque les routeurs sont des pairs contributeurs (tunnels participants activés). Les mécanismes de contrôle de congestion de type TCP empêchent la surcharge des pairs lents et aident à équilibrer l\u0026rsquo;utilisation de la bande passante entre les tunnels. Considérations de latence Comme I2P ajoute plusieurs centaines de millisecondes de latence de base, les applications devraient minimiser les allers-retours. Regrouper les données avec l\u0026rsquo;établissement de connexion lorsque c\u0026rsquo;est possible (par exemple, requêtes HTTP dans SYN). Éviter les conceptions reposant sur de nombreux petits échanges séquentiels.\nTests et Compatibilité Testez toujours avec Java I2P et i2pd pour garantir une compatibilité totale. Bien que le protocole soit normalisé, des différences mineures d\u0026rsquo;implémentation peuvent exister. Gérez les anciens routers avec souplesse—de nombreux pairs exécutent encore des versions antérieures à la 2.0. Surveillez les statistiques de connexion en utilisant I2PSocket.getOptions() et getSession() pour lire les métriques de RTT et de retransmission. Les performances dépendent fortement de la configuration des tunnels : - Tunnels courts (1–2 sauts) → latence plus faible, anonymat réduit. - Tunnels longs (3+ sauts) → anonymat accru, RTT augmenté.\nAméliorations clés (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. --- Résumé La bibliothèque I2P Streaming est l\u0026rsquo;épine dorsale de toutes les communications fiables au sein d\u0026rsquo;I2P. Elle garantit la livraison de messages ordonnés, authentifiés et chiffrés, et fournit un remplacement quasi transparent pour TCP dans les environnements anonymes.\nPour obtenir des performances optimales : - Minimisez les allers-retours en regroupant SYN+payload. - Ajustez les paramètres de fenêtre et de délai d\u0026rsquo;expiration selon votre charge de travail. - Privilégiez des tunnels plus courts pour les applications sensibles à la latence. - Utilisez des conceptions respectueuses de la congestion pour éviter de surcharger les pairs.\n","description":"Transport de type TCP utilisé par la plupart des applications I2P","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"Protocole de streaming","url":"/fr/docs/api/streaming/"},{"categories":null,"content":"Aperçu La bibliothèque de streaming d\u0026rsquo;I2P fournit une transmission de données fiable, ordonnée et authentifiée au-dessus de la couche de messages non fiable d\u0026rsquo;I2P — analogue à TCP sur IP. Elle est utilisée par la quasi-totalité des applications I2P interactives, telles que la navigation web, l’IRC, le courrier électronique et le partage de fichiers.\nIl assure une transmission fiable, le contrôle de la congestion, la retransmission et le contrôle de flux à travers les tunnels anonymes à haute latence d’I2P. Chaque flux est entièrement chiffré de bout en bout entre les destinations.\nPrincipes fondamentaux de conception La bibliothèque de streaming implémente une procédure d’établissement de connexion en une seule phase, où les indicateurs SYN, ACK et FIN peuvent transporter une charge utile de données dans le même message. Cela minimise les allers-retours dans des environnements à forte latence — une petite transaction HTTP peut s’achever en un seul aller-retour.\nLe contrôle de congestion et la retransmission sont inspirés de TCP mais adaptés à l’environnement d’I2P. Les tailles de fenêtre sont basées sur les messages, et non sur les octets, et sont optimisées pour la latence et la surcharge du tunnel. Le protocole prend en charge le démarrage lent, l’évitement de congestion et une temporisation exponentielle, à l’instar de l’algorithme AIMD de TCP.\nArchitecture La bibliothèque de streaming fonctionne entre les applications et l’interface I2CP.\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels La plupart des utilisateurs y accèdent via I2PSocketManager, I2PTunnel ou SAMv3. La bibliothèque prend en charge, de manière transparente, la gestion des destinations, l'utilisation des tunnel (chemins de communication I2P) et les retransmissions. Format du paquet +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | Détails de l’en-tête Identifiants de flux: valeurs sur 32 bits identifiant de manière unique le flux local et le flux distant. Numéro de séquence: commence à 0 pour SYN, s\u0026rsquo;incrémente à chaque message. Accusés de réception jusqu’à: accuse réception de tous les messages jusqu\u0026rsquo;à N, à l\u0026rsquo;exception de ceux présents dans la liste NACK (accusé de réception négatif). Drapeaux: masque de bits contrôlant l\u0026rsquo;état et le comportement. Options: liste de longueur variable pour le RTT, le MTU et la négociation de protocole. Drapeaux de clé Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive --- Contrôle de flux et fiabilité Le streaming utilise un fenêtrage basé sur les messages, contrairement à l\u0026rsquo;approche de TCP basée sur les octets. Le nombre de paquets non acquittés autorisés en transit est égal à la taille de fenêtre actuelle (par défaut 128).\nMécanismes Contrôle de congestion: démarrage lent et évitement basé sur AIMD (augmentation additive/diminution multiplicative). Choke/Unchoke: signalisation de contrôle de flux basée sur l\u0026rsquo;occupation du tampon. Retransmission: calcul du RTO basé sur la RFC 6298 avec temporisation exponentielle. Filtrage des doublons: garantit la fiabilité en présence de messages potentiellement réordonnés. Valeurs de configuration typiques :\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout --- Établissement de la connexion Initiateur envoie un SYN (facultativement avec charge utile et FROM_INCLUDED). Répondeur répond avec SYN+ACK (peut inclure une charge utile). Initiateur envoie l’ACK final confirmant l’établissement. Les charges utiles initiales facultatives permettent la transmission de données avant l\u0026rsquo;achèvement complet du handshake (phase de négociation initiale).\nDétails de l\u0026rsquo;implémentation Retransmission et délai d\u0026rsquo;expiration L\u0026rsquo;algorithme de retransmission suit la RFC 6298. - RTO initiale: 9s - RTO min: 100ms - RTO max: 45s - Alpha: 0.125 - Beta: 0.25\nPartage du bloc de contrôle Les connexions récentes avec le même pair réutilisent les données de RTT (temps aller-retour) et de fenêtre pour une montée en régime plus rapide, évitant la latence de “démarrage à froid”. Les blocs de contrôle expirent après plusieurs minutes.\nMTU et fragmentation MTU par défaut : 1730 octets (suffit pour deux messages I2NP). Destinations ECIES (schéma de chiffrement intégré aux courbes elliptiques) : 1812 octets (surcharge réduite). MTU minimale prise en charge : 512 octets. La taille de la charge utile exclut l’en-tête de streaming minimal de 22 octets.\nHistorique des versions Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) --- Utilisation au niveau applicatif Exemple Java Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); Prise en charge de SAMv3 et i2pd SAMv3: Fournit les modes STREAM et DATAGRAM pour les clients non-Java. i2pd: Expose des paramètres de streaming identiques via des options du fichier de configuration (p. ex. i2p.streaming.maxWindowSize, profile, etc) Choisir entre streaming et datagrammes Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn --- Sécurité et avenir post-quantique Les sessions de streaming sont chiffrées de bout en bout au niveau de la couche I2CP. Le chiffrement hybride post-quantique (ML-KEM + X25519) est pris en charge à titre expérimental dans la version 2.10.0, mais il est désactivé par défaut.\nRéférences Aperçu de l’API de Streaming Spécification du protocole Streaming Spécification I2CP Proposition 144 : Calculs de MTU pour le Streaming Notes de version d’I2P 2.10.0 ","description":"Transport fiable, de type TCP, utilisé par la plupart des applications I2P","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"Protocole de streaming","url":"/fr/docs/specs/streaming/"},{"categories":null,"content":"Vue d\u0026rsquo;ensemble Le protocole réseau I2P (I2NP) définit comment les routers échangent des messages, sélectionnent les transports et mélangent le trafic tout en préservant l’anonymat. Il fonctionne entre I2CP (API client) et les protocoles de transport (NTCP2 et SSU2).\nI2NP est la couche au-dessus des protocoles de transport I2P. C\u0026rsquo;est un protocole de type router-to-router utilisé pour: - Recherches et réponses dans la base de données du réseau - Création de tunnels - Messages de données chiffrés du router et du client\nLes messages I2NP peuvent être envoyés point à point à un autre router, ou envoyés anonymement via des tunnels vers ce router.\nLes Routers placent en file d’attente les tâches sortantes à l’aide de priorités locales. Les numéros de priorité plus élevés sont traités en premier. Toute priorité supérieure à la priorité standard des données de tunnel (400) est considérée comme urgente.\nTransports actuels I2P utilise désormais NTCP2 (TCP) et SSU2 (UDP) à la fois pour IPv4 et IPv6. Les deux transports emploient: - X25519 échange de clés (cadre de protocole Noise) - ChaCha20/Poly1305 chiffrement authentifié (AEAD) - SHA-256 hachage\nTransports hérités supprimés: - NTCP (TCP d\u0026rsquo;origine) a été supprimé du router Java dans la version 0.9.50 (mai 2021) - SSU v1 (UDP d\u0026rsquo;origine) a été supprimé du router Java dans la version 2.4.0 (décembre 2023) - SSU v1 a été supprimé d\u0026rsquo;i2pd dans la version 2.44.0 (novembre 2022)\nÀ partir de 2025, le réseau a entièrement basculé vers des transports basés sur Noise (cadre de protocoles cryptographiques), sans aucune prise en charge des transports hérités.\nSystème de numérotation des versions IMPORTANT: I2P utilise un double système de versionnage qui doit être clairement compris :\nVersions de publication (visibles par l’utilisateur) Voici les versions que les utilisateurs voient et téléchargent : - 0.9.50 (mai 2021) - Dernière version 0.9.x - 1.5.0 (août 2021) - Première version 1.x - 1.6.0, 1.7.0, 1.8.0, 1.9.0 (de 2021 à 2022) - 2.0.0 (novembre 2022) - Première version 2.x - 2.1.0 à 2.9.0 (de 2023 à 2025) - 2.10.0 (8 septembre 2025) - Version actuelle\nVersions d’API (compatibilité du protocole) Ce sont les numéros de version internes publiés dans le champ \u0026ldquo;router.version\u0026rdquo; des propriétés RouterInfo : - 0.9.50 (mai 2021) - 0.9.51 (août 2021) - Version d\u0026rsquo;API pour la version 1.5.0 - 0.9.52 à 0.9.66 (se poursuivant dans les versions 2.x) - 0.9.67 (septembre 2025) - Version d\u0026rsquo;API pour la version 2.10.0\nPoint clé : Il n\u0026rsquo;y a eu AUCUNE version numérotée de 0.9.51 à 0.9.67. Ces numéros existent uniquement en tant qu\u0026rsquo;identifiants de version d\u0026rsquo;API. I2P est passé de la version 0.9.50 directement à la version 1.5.0.\nTable de correspondance des versions Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) **À venir :** La version 2.11.0 (prévue pour décembre 2025) nécessitera Java 17+ et activera par défaut la cryptographie post-quantique. Versions du protocole Tous les routers doivent publier leur version du protocole I2NP dans le champ \u0026ldquo;router.version\u0026rdquo; des propriétés RouterInfo (métadonnées d’un router I2P). Ce champ de version correspond à la version de l\u0026rsquo;API, indiquant le niveau de prise en charge de diverses fonctionnalités du protocole I2NP, et n’est pas nécessairement la version réelle du router.\nSi des routers alternatifs (non-Java) souhaitent publier des informations de version concernant l’implémentation du router proprement dite, ils doivent le faire dans une autre propriété. Des versions autres que celles indiquées ci-dessous sont autorisées. La prise en charge sera déterminée par une comparaison numérique ; par exemple, 0.9.13 implique la prise en charge des fonctionnalités de 0.9.12.\nRemarque : La propriété \u0026ldquo;coreVersion\u0026rdquo; n\u0026rsquo;est plus publiée dans les informations du router et n\u0026rsquo;a jamais été utilisée pour déterminer la version du protocole I2NP.\nRésumé des fonctionnalités par version de l’API API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network **Remarque :** Il existe également des fonctionnalités liées au transport et des problèmes de compatibilité. Voir la documentation des transports NTCP2 et SSU2 pour plus de détails. En-tête du message I2NP utilise une structure d’en-tête logique de 16 octets, tandis que les transports modernes (NTCP2 et SSU2) utilisent un en-tête raccourci de 9 octets, omettant les champs de taille et de somme de contrôle redondants. Les champs restent conceptuellement identiques.\nComparaison des formats d\u0026rsquo;en-tête Format standard (16 octets):\nUtilisé dans le transport NTCP hérité et lorsque des messages I2NP sont encapsulés dans d\u0026rsquo;autres messages (TunnelData, TunnelGateway, GarlicClove).\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity Format court pour SSU (Obsolète, 5 octets):\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) Format court pour NTCP2, SSU2 et ECIES-Ratchet Garlic Cloves (éléments « clove » d’un message garlic dans ECIES-Ratchet) (9 octets):\nUtilisé dans les transports modernes et dans les garlic messages (messages groupés spécifiques à I2P) chiffrés avec ECIES.\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) Détails des champs d\u0026rsquo;en-tête Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity ### Notes de mise en œuvre Lorsqu’il est transmis via SSU (obsolète), seuls le type et l’expiration sur 4 octets étaient inclus Lorsqu’il est transmis via NTCP2 ou SSU2, le format court de 9 octets est utilisé L’en-tête standard de 16 octets est requis pour les messages I2NP contenus dans d’autres messages (Data, TunnelData, TunnelGateway, GarlicClove) Depuis la version 0.8.12, la vérification de la somme de contrôle est désactivée à certains endroits de la pile de protocoles pour des raisons d’efficacité, mais la génération de la somme de contrôle reste requise pour la compatibilité L’expiration courte est non signée et reviendra à zéro le 7 février 2106. Après cette date, un décalage doit être ajouté pour obtenir l’heure correcte Pour la compatibilité avec les anciennes versions, générez toujours des sommes de contrôle même si elles peuvent ne pas être vérifiées Contraintes de taille Les messages Tunnel fragmentent les charges utiles I2NP en morceaux de taille fixe:\nPremier fragment: environ 956 octets Fragments suivants: environ 996 octets chacun Nombre maximal de fragments: 64 (numérotés 0-63) Charge utile maximale: environ 61 200 octets (61,2 KB) Calcul: 956 + (63 × 996) = maximum théorique de 63,704 octets, avec une limite pratique d\u0026rsquo;environ 61,200 octets en raison de l\u0026rsquo;overhead (surcharge).\nContexte historique Les anciens transports avaient des limites de taille de trame plus strictes: - NTCP: trames de 16 Ko - SSU: trames d’environ 32 Ko\nNTCP2 prend en charge des trames d’environ 65 Ko, mais la limite de fragmentation du tunnel s’applique toujours.\nConsidérations relatives aux données applicatives Les Garlic messages (messages composites d\u0026rsquo;I2P) peuvent regrouper des LeaseSets, des Session Tags (étiquettes de session), ou des variantes LeaseSet2 chiffrées, réduisant l\u0026rsquo;espace disponible pour les données de charge utile.\nRecommandation: Les datagrammes devraient rester ≤ 10 KB pour assurer une livraison fiable. Les messages s\u0026rsquo;approchant de la limite de 61 KB peuvent subir : - Latence accrue due au réassemblage après fragmentation - Probabilité plus élevée d\u0026rsquo;échec de livraison - Plus grande exposition à l\u0026rsquo;analyse du trafic\nDétails techniques de la fragmentation Chaque message de tunnel fait exactement 1 024 octets (1 Ko) et contient : - ID de tunnel de 4 octets - vecteur d\u0026rsquo;initialisation de 16 octets (IV) - 1 004 octets de données chiffrées\nAu sein des données chiffrées, les messages tunnel transportent des messages I2NP fragmentés avec des en-têtes de fragment indiquant: - Numéro de fragment (0-63) - S\u0026rsquo;il s\u0026rsquo;agit du premier fragment ou d\u0026rsquo;un fragment suivant - ID de message global pour le réassemblage\nLe premier fragment inclut l’en-tête complet de message I2NP (16 octets), laissant environ 956 octets pour la charge utile. Les fragments suivants n’incluent pas l’en-tête du message, ce qui permet environ 996 octets de charge utile par fragment.\nTypes de messages courants Les routers utilisent le type de message et la priorité pour ordonnancer les tâches sortantes. Les valeurs de priorité les plus élevées sont traitées en premier. Les valeurs ci-dessous correspondent aux valeurs par défaut actuelles de Java I2P (version de l\u0026rsquo;API 0.9.67).\nRemarque: Les priorités dépendent de l’implémentation. Pour connaître les valeurs de priorité de référence, consultez la documentation de la classe OutNetMessage dans le code source Java d’I2P.\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) **Types de messages réservés :** - Type 0 : Réservé - Types 4-9 : Réservés pour un usage futur - Types 12-17 : Réservés pour un usage futur - Types 224-254 : Réservés pour des messages expérimentaux - Type 255 : Réservé pour de futures extensions Notes sur les types de messages Les messages du plan de contrôle (DatabaseLookup, TunnelBuild, etc.) empruntent généralement des tunnels exploratoires, et non des tunnels clients, ce qui permet une priorisation indépendante Les valeurs de priorité sont approximatives et peuvent varier selon l\u0026rsquo;implémentation TunnelBuild (21) et TunnelBuildReply (22) sont dépréciés mais toujours implémentés pour la compatibilité avec les tunnels très longs (\u0026gt;8 sauts) La priorité standard des données de tunnel est de 400; tout ce qui est au-dessus est traité comme urgent La longueur typique des tunnels dans le réseau actuel est de 3-4 sauts, donc la plupart des constructions de tunnel utilisent ShortTunnelBuild (enregistrements de 218 octets) ou VariableTunnelBuild (enregistrements de 528 octets) Chiffrement et encapsulation des messages Les routers encapsulent fréquemment des messages I2NP avant la transmission, créant plusieurs couches de chiffrement. Un message DeliveryStatus peut être : 1. enveloppé dans un GarlicMessage (chiffré) 2. à l’intérieur d’un DataMessage 3. au sein d’un TunnelData message (à nouveau chiffré)\nChaque saut ne déchiffre que sa couche ; la destination finale révèle la charge utile la plus interne.\nAlgorithmes de chiffrement Hérité (en cours de retrait progressif): - ElGamal/AES + SessionTags (étiquettes de session) - ElGamal-2048 pour le chiffrement asymétrique - AES-256 pour le chiffrement symétrique - session tags de 32 octets\nActuel (Standard depuis l\u0026rsquo;API 0.9.48): - ECIES-X25519 + ChaCha20/Poly1305 AEAD avec confidentialité persistante à cliquet - Noise Protocol Framework (Noise_IK_25519_ChaChaPoly_SHA256 pour les destinations) - Étiquettes de session de 8 octets (réduites de 32 octets) - Algorithme Signal Double Ratchet pour la confidentialité persistante (forward secrecy) - Introduit dans la version d\u0026rsquo;API 0.9.46 (2020) - Obligatoire pour tous les routers à partir de la version d\u0026rsquo;API 0.9.58 (2023)\nÀ venir (Bêta à partir de la version 2.10.0): - Cryptographie hybride post-quantique utilisant MLKEM (ML-KEM-768) combinée avec X25519 - Cliquet hybride combinant des mécanismes d’accord de clé classiques et post-quantiques - Rétrocompatible avec ECIES-X25519 - Deviendra la valeur par défaut dans la version 2.11.0 (décembre 2025)\nMise en obsolescence du Router ElGamal CRITIQUE: Les routers ElGamal ont été dépréciés à partir de la version d’API 0.9.58 (version 2.2.0, mars 2023). Étant donné que la version floodfill minimale recommandée pour les requêtes est désormais 0.9.58, les implémentations n’ont pas besoin d’implémenter le chiffrement pour les routers floodfill ElGamal.\nCependant : Les destinations ElGamal sont toujours prises en charge pour la rétrocompatibilité. Les clients utilisant le chiffrement ElGamal peuvent toujours communiquer via des routers ECIES.\nDétails sur ECIES-X25519-AEAD-Ratchet (mécanisme de cliquet cryptographique basé sur ECIES-X25519 avec AEAD) C\u0026rsquo;est le crypto type 4 (type de chiffrement 4) dans la spécification de cryptographie d\u0026rsquo;I2P. Il fournit:\nCaractéristiques clés : - Confidentialité persistante grâce au ratcheting (mécanisme à cliquet cryptographique; nouvelles clés pour chaque message) - Réduction du stockage des étiquettes de session (8 octets contre 32 octets) - Plusieurs types de session (nouvelle session, session existante, session à usage unique) - Basé sur le protocole Noise Noise_IK_25519_ChaChaPoly_SHA256 - Intégré à l’algorithme Double Ratchet de Signal\nPrimitives cryptographiques: - X25519 pour l\u0026rsquo;accord de clé Diffie-Hellman - ChaCha20 pour le chiffrement en flux - Poly1305 pour l\u0026rsquo;authentification des messages (AEAD, chiffrement authentifié avec données associées) - SHA-256 pour le hachage - HKDF pour la dérivation de clés\nGestion des sessions: - Nouvelle session: Connexion initiale utilisant une clé de destination statique - Session existante: Messages ultérieurs utilisant des session tags (étiquettes de session) - Session à usage unique: Sessions à message unique pour une surcharge réduite\nVoir Spécification ECIES et Proposition 144 pour des détails techniques complets.\nStructures communes Les structures suivantes sont des éléments de plusieurs messages I2NP. Ce ne sont pas des messages complets.\nBuildRequestRecord (enregistrement de requête de construction) (ElGamal) DÉPRÉCIÉ. Uniquement utilisé dans le réseau actuel lorsqu\u0026rsquo;un tunnel contient un router ElGamal. Voir ECIES Tunnel Creation pour le format moderne.\nObjectif: Un enregistrement dans un ensemble de plusieurs enregistrements pour demander la création d\u0026rsquo;un saut dans le tunnel.\nFormat:\nChiffré avec ElGamal et AES (528 octets au total):\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Structure chiffrée par ElGamal (528 octets):\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) Structure en clair (222 octets avant chiffrement) :\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data Notes : - Le chiffrement ElGamal-2048 produit un bloc de 514 octets, mais les deux octets de bourrage (aux positions 0 et 257) sont supprimés, pour un total de 512 octets - Voir Spécification de création de Tunnel pour les détails des champs - Code source : net.i2p.data.i2np.BuildRequestRecord - Constante : EncryptedBuildRecord.RECORD_SIZE = 528\nBuildRequestRecord (ECIES-X25519 Long) Pour les routers ECIES-X25519, introduits dans la version de l’API 0.9.48. Utilise 528 octets pour la rétrocompatibilité avec des tunnels mixtes.\nFormat :\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) Taille totale : 528 octets (identique à ElGamal pour des raisons de compatibilité)\nVoir Création de Tunnel ECIES pour la structure des données en clair et les détails du chiffrement.\nBuildRequestRecord (ECIES-X25519 version courte) Uniquement pour les routers ECIES-X25519, à partir de la version de l\u0026rsquo;API 0.9.51 (version 1.5.0). Il s’agit du format standard actuel.\nFormat:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) Taille totale: 218 octets (réduction de 59 % par rapport à 528 octets)\nDifférence clé : Les enregistrements courts dérivent TOUTES les clés via HKDF (fonction de dérivation de clés) plutôt que de les inclure explicitement dans l\u0026rsquo;enregistrement. Cela inclut : - Clés de couche (pour le chiffrement du tunnel) - Clés IV (vecteur d\u0026rsquo;initialisation) (pour le chiffrement du tunnel) - Clés de réponse (pour build reply [réponse de construction]) - IV de réponse (pour build reply)\nToutes les clés sont dérivées à l\u0026rsquo;aide du mécanisme HKDF du protocole Noise, à partir du secret partagé issu de l\u0026rsquo;échange de clés X25519.\nAvantages: - 4 enregistrements courts tiennent dans un seul message de tunnel (873 octets) - 3 messages de construction de tunnel au lieu de messages séparés pour chaque enregistrement - Bande passante et latence réduites - Mêmes propriétés de sécurité que le format long\nVoir Proposition 157 pour la justification et Création de tunnel ECIES pour la spécification complète.\nCode source : - net.i2p.data.i2np.ShortEncryptedBuildRecord - Constante : ShortEncryptedBuildRecord.RECORD_SIZE = 218\nBuildResponseRecord (enregistrement de réponse de construction) (ElGamal) OBSOLÈTE. Uniquement utilisé lorsque le tunnel contient un router ElGamal.\nObjectif : Un enregistrement au sein d’un ensemble de plusieurs enregistrements contenant des réponses à une requête de construction.\nFormat :\nChiffré (528 octets, même taille que BuildRequestRecord) :\nbytes 0-527 :: AES-encrypted record Structure non chiffrée:\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) Codes de réponse : - 0 - Accepté - 30 - Rejeté (bande passante dépassée)\nVoir Spécification de création de tunnel pour plus de détails sur le champ de réponse.\nBuildResponseRecord (ECIES-X25519) Pour les routers ECIES-X25519, version de l’API 0.9.48+. Même taille que la requête correspondante (528 pour le format long, 218 pour le format court).\nFormat:\nFormat long (528 octets):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Format court (218 octets):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Structure du texte en clair (les deux formats):\nContient une structure Mapping (format clé-valeur d\u0026rsquo;I2P) avec: - Code d\u0026rsquo;état de réponse (obligatoire) - Paramètre de bande passante disponible (\u0026ldquo;b\u0026rdquo;) (facultatif, ajouté dans l\u0026rsquo;API 0.9.65) - Autres paramètres optionnels pour de futures extensions\nCodes d\u0026rsquo;état de réponse: - 0 - Succès - 30 - Rejet : bande passante dépassée\nVoir Création de tunnel ECIES pour la spécification complète.\nGarlicClove (ElGamal/AES) (élément de base d’un message garlic d’I2P) AVERTISSEMENT : Ceci est le format utilisé pour les garlic cloves (gousses de message) à l’intérieur des garlic messages chiffrés avec ElGamal. Le format des garlic messages et des garlic cloves ECIES-AEAD-X25519-Ratchet est sensiblement différent. Voir Spécification ECIES pour le format moderne.\nDéprécié pour les routers (API 0.9.58+), toujours pris en charge pour les destinations.\nFormat :\nNon chiffré:\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) Remarques: - Les clove (sous-messages) ne sont jamais fragmentés - Lorsque le premier bit de l\u0026rsquo;octet de drapeau des Delivery Instructions vaut 0, le clove n\u0026rsquo;est pas chiffré - Lorsque le premier bit vaut 1, le clove est chiffré (fonctionnalité non implémentée) - La longueur maximale est fonction de la somme des longueurs des clove et de la longueur maximale de GarlicMessage - Le certificat pourrait éventuellement être utilisé avec HashCash pour \u0026ldquo;payer\u0026rdquo; l\u0026rsquo;acheminement (possibilité future) - Messages utilisés en pratique : DataMessage, DeliveryStatusMessage, DatabaseStoreMessage - GarlicMessage peut contenir un GarlicMessage (garlic imbriqué), mais cela n\u0026rsquo;est pas utilisé en pratique\nVoir Garlic Routing (technique de routage d\u0026rsquo;I2P où plusieurs messages sont regroupés) pour un aperçu conceptuel.\nGarlicClove (ECIES-X25519-AEAD-Ratchet) Pour les routers et les destinations ECIES-X25519, version de l\u0026rsquo;API 0.9.46+. C\u0026rsquo;est le format standard actuel.\nDIFFÉRENCE FONDAMENTALE: ECIES garlic utilise une structure complètement différente, basée sur des blocs du protocole Noise plutôt que sur des structures de clove (sous-message d’un message garlic) explicites.\nFormat :\nLes messages garlic (agrégation de messages spécifique à I2P) ECIES contiennent une série de blocs :\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data Types de blocs: - 0 - Garlic Clove Block (bloc « Garlic Clove »; contient un message I2NP) - 1 - Bloc DateTime (horodatage) - 2 - Bloc d’options (options d’acheminement) - 3 - Bloc de bourrage - 254 - Bloc de terminaison (non implémenté)\nBloc Garlic Clove (gousse d\u0026rsquo;ail) (type 0):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ Principales différences par rapport au format ElGamal : - Utilise une expiration sur 4 octets (secondes depuis l\u0026rsquo;époque Unix) au lieu d\u0026rsquo;une Date sur 8 octets - Aucun champ de certificat - Encapsulé dans une structure de blocs avec type et longueur - Message entier chiffré avec ChaCha20/Poly1305 AEAD - Gestion de session via ratcheting (mécanisme à cliquet)\nVoir Spécification ECIES pour des détails complets sur le Noise Protocol Framework (cadre de protocoles Noise) et les structures de blocs.\nInstructions d’acheminement de Garlic Clove (élément « clove » d’un message garlic dans I2P) Ce format est utilisé à la fois pour les gousses « garlic » (terme I2P) ElGamal et ECIES. Il spécifie comment acheminer le message inclus.\nAVERTISSEMENT CRITIQUE: Cette spécification concerne UNIQUEMENT les Delivery Instructions (\u0026ldquo;instructions de livraison\u0026rdquo;) à l\u0026rsquo;intérieur des Garlic Cloves (gousses d\u0026rsquo;ail). \u0026ldquo;Delivery Instructions\u0026rdquo; sont également utilisées à l\u0026rsquo;intérieur des Tunnel Messages, où le format est sensiblement différent. Voir la Tunnel Message Specification pour les instructions de livraison liées aux tunnels. NE PAS confondre ces deux formats.\nFormat :\nLa clé de session et le délai ne sont pas utilisés et ne sont jamais présents, donc les trois longueurs possibles sont :\n1 octet (LOCAL) 33 octets (ROUTER et DESTINATION) 37 octets (TUNNEL) +----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds Longueurs typiques: - acheminement LOCAL: 1 octet (drapeau uniquement) - acheminement ROUTER / DESTINATION: 33 octets (drapeau + hachage) - acheminement TUNNEL: 37 octets (drapeau + hachage + ID de tunnel)\nDescriptions des types de livraison:\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router **Notes d'implémentation:** - Le chiffrement par clé de session n'est pas implémenté et le bit de drapeau est toujours à 0 - Le délai n'est pas entièrement implémenté et le bit de drapeau est toujours à 0 - Pour l'acheminement TUNNEL, le hachage identifie le router passerelle et l'ID de tunnel spécifie quel tunnel entrant - Pour l'acheminement DESTINATION, le hachage est le SHA-256 de la clé publique de la destination - Pour l'acheminement ROUTER, le hachage est le SHA-256 de l'identité du router Messages I2NP Spécifications complètes pour tous les types de messages I2NP.\nRésumé des types de messages Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active **Réservé:** - Type 0: Réservé - Types 4-9: Réservés pour une utilisation future - Types 12-17: Réservés pour une utilisation future - Types 224-254: Réservés pour des messages expérimentaux - Type 255: Réservé pour de futures extensions DatabaseStore (Type 1) Objectif : Un enregistrement non sollicité dans la base de données, ou la réponse à un message DatabaseLookup (recherche dans la base de données) réussi.\nContenu : Un LeaseSet non compressé, un LeaseSet2, un MetaLeaseSet ou un EncryptedLeaseSet, ou un RouterInfo compressé.\nFormat avec jeton de réponse:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet Format avec le jeton de réponse == 0:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// Notes : - Pour des raisons de sécurité, les champs de réponse sont ignorés si le message est reçu via un tunnel - La clé est le hachage « réel » de la RouterIdentity ou de la Destination, ET NON la clé de routage - Les types 3, 5 et 7 (variantes de LeaseSet2) ont été ajoutés dans la version 0.9.38 (API 0.9.38). Voir Proposition 123 pour plus de détails - Ces types ne doivent être envoyés qu’aux routers dont la version d’API est 0.9.38 ou supérieure - À titre d’optimisation pour réduire les connexions, si le type est un LeaseSet, que le jeton de réponse est inclus, que l’ID de tunnel de réponse est non nul, et que la paire passerelle de réponse/tunnelID se trouve dans le LeaseSet en tant que lease, le destinataire peut réacheminer la réponse vers n’importe quel autre lease dans le LeaseSet - Format gzip de RouterInfo : Pour masquer l’OS et l’implémentation du router, imiter l’implémentation du router Java en définissant la date de modification à 0 et l’octet OS à 0xFF, et régler XFL à 0x02 (compression maximale, algorithme le plus lent) conformément à la RFC 1952. 10 premiers octets : 1F 8B 08 00 00 00 00 00 02 FF\nCode source: - net.i2p.data.i2np.DatabaseStoreMessage - net.i2p.data.RouterInfo (pour la structure RouterInfo) - net.i2p.data.LeaseSet (pour la structure LeaseSet)\nDatabaseLookup (Type 2) (requête de recherche dans la base de données) Objectif: Une requête visant à rechercher un élément dans la base de données réseau. La réponse est soit un DatabaseStore, soit un DatabaseSearchReply.\nFormat :\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) Modes de chiffrement des réponses :\nREMARQUE: Les routers ElGamal sont dépréciés depuis l\u0026rsquo;API 0.9.58. Étant donné que la version minimale recommandée de floodfill à interroger est désormais 0.9.58, les implémentations n\u0026rsquo;ont pas à implémenter le chiffrement pour les routers floodfill ElGamal. Les destinations ElGamal sont toujours prises en charge.\nLe bit d’indicateur 4 (ECIESFlag) est utilisé en combinaison avec le bit 1 (encryptionFlag) pour déterminer le mode de chiffrement de la réponse :\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future **Aucun chiffrement (indicateurs 0,0):** reply_key, tags et reply_tags ne sont pas présents.\nElG vers ElG (indicateurs 0,1) - OBSOLÈTE:\nPris en charge à partir de 0.9.7, déprécié à partir de 0.9.58.\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES vers ElG (indicateurs 1,0) - OBSOLÈTE:\nPris en charge depuis la 0.9.46, déprécié depuis la 0.9.58.\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data La réponse est un message ECIES Existing Session (session existante) tel que défini dans la Spécification ECIES :\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES (schéma de chiffrement intégré à courbe elliptique) vers ECIES (drapeaux 1,0) - NORME ACTUELLE:\nUne destination ECIES ou un router envoie une requête de recherche à un router ECIES. Pris en charge à partir de la version 0.9.49.\nMême format que \u0026ldquo;ECIES to ElG\u0026rdquo; ci-dessus. Le chiffrement du message de recherche est spécifié dans ECIES Routers . Le demandeur est anonyme.\nECIES vers ECIES avec DH (indicateurs 1,1) - FUTUR:\nPas encore entièrement défini. Voir la Proposition 156 .\nNotes : - Avant la 0.9.16, la clé pouvait correspondre à un RouterInfo (descriptif de routeur) ou à un LeaseSet (ensemble de baux) (même espace de clés, aucun indicateur pour les distinguer) - Les réponses chiffrées ne sont utiles que lorsque la réponse passe par un tunnel - Le nombre d’étiquettes (tags) incluses peut être supérieur à un si des stratégies alternatives de recherche DHT sont mises en œuvre - La clé de recherche et les clés d’exclusion sont les hachages « réels », PAS des clés de routage - Les types 3, 5 et 7 (variantes de LeaseSet2) peuvent être retournés depuis la 0.9.38. Voir Proposition 123 - Notes sur les recherches exploratoires : Une recherche exploratoire est définie comme renvoyant une liste de hachages non-floodfill proches de la clé. Cependant, les implémentations varient : Java recherche bien la clé de recherche pour un RI (RouterInfo) et renvoie un DatabaseStore (enregistrement de base de données) s’il est présent ; i2pd ne le fait pas. Par conséquent, il n’est pas recommandé d’utiliser une recherche exploratoire pour des hachages déjà reçus\nCode source: - net.i2p.data.i2np.DatabaseLookupMessage - Chiffrement: net.i2p.crypto.SessionKeyManager\nDatabaseSearchReply (Type 3) Objectif : La réponse à un message DatabaseLookup (recherche dans la base de données) ayant échoué.\nContenu: Une liste de hachages de router les plus proches de la clé demandée.\nFormat:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from Remarques: - Le hachage \u0026lsquo;from\u0026rsquo; n\u0026rsquo;est pas authentifié et ne peut pas être considéré comme digne de confiance - Les hachages des pairs renvoyés ne sont pas nécessairement plus proches de la clé que le router interrogé. Pour les réponses aux recherches normales, cela facilite la découverte de nouveaux floodfills et la recherche \u0026ldquo;à rebours\u0026rdquo; (plus éloignée de la clé) afin d\u0026rsquo;améliorer la robustesse - Pour les recherches d\u0026rsquo;exploration, la clé est généralement générée aléatoirement. Les peer_hashes non-floodfill de la réponse peuvent être sélectionnés à l\u0026rsquo;aide d\u0026rsquo;un algorithme optimisé (par ex., des pairs proches mais pas nécessairement les plus proches) afin d\u0026rsquo;éviter un tri inefficace de toute la base de données locale. Des stratégies de mise en cache peuvent également être utilisées. Cela dépend de l\u0026rsquo;implémentation - Nombre typique de hachages renvoyés: 3 - Nombre maximal recommandé de hachages à renvoyer: 16 - La clé de recherche, les hachages des pairs et le hachage \u0026lsquo;from\u0026rsquo; sont de \u0026ldquo;vrais\u0026rdquo; hachages, PAS des clés de routage - Si num vaut 0, cela indique qu\u0026rsquo;aucun pair plus proche n\u0026rsquo;a été trouvé (impasse)\nCode source : - net.i2p.data.i2np.DatabaseSearchReplyMessage\nDeliveryStatus (statut de livraison) (Type 10) Objectif: Un simple accusé de réception de message. Généralement créé par l’émetteur du message et encapsulé dans un Garlic Message (message de type « Garlic » dans I2P) avec le message lui-même, pour être renvoyé par la destination.\nContenu : L\u0026rsquo;identifiant du message livré ainsi que l\u0026rsquo;heure de création ou d\u0026rsquo;arrivée.\nFormat :\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered Remarques : - L\u0026rsquo;horodatage est toujours défini par le créateur sur l\u0026rsquo;heure actuelle. Cependant, cela est utilisé à plusieurs endroits dans le code, et d\u0026rsquo;autres usages pourraient être ajoutés à l\u0026rsquo;avenir - Ce message est également utilisé comme confirmation d\u0026rsquo;établissement de session dans SSU. Dans ce cas, l\u0026rsquo;ID de message est défini sur un nombre aléatoire, et le \u0026ldquo;arrival time\u0026rdquo; (heure d\u0026rsquo;arrivée) est défini sur l\u0026rsquo;ID global du réseau actuel, qui vaut 2 (c.-à-d. 0x0000000000000002) - DeliveryStatus est généralement encapsulé dans un GarlicMessage et envoyé via un tunnel afin de fournir un accusé de réception sans révéler l\u0026rsquo;expéditeur - Utilisé pour les tests de tunnel afin de mesurer la latence et la fiabilité\nCode source : - net.i2p.data.i2np.DeliveryStatusMessage - Utilisé dans : net.i2p.router.tunnel.InboundEndpointProcessor pour les tests de tunnel\nGarlicMessage (Type 11) AVERTISSEMENT : Il s\u0026rsquo;agit du format utilisé pour les messages garlic chiffrés avec ElGamal. Le format des messages garlic ECIES-AEAD-X25519-Ratchet (mécanisme à cliquet cryptographique) est sensiblement différent. Voir la Spécification ECIES pour le format moderne.\nObjectif: Utilisé pour encapsuler plusieurs messages I2NP chiffrés.\nContenu: Une fois déchiffré, une série de Garlic Cloves (éléments unitaires d’un message garlic encryption) et des données supplémentaires, également appelée Clove Set (ensemble de Garlic Cloves).\nFormat chiffré:\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data Données déchiffrées (Clove Set, ensemble de gousses):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) Notes: - Lorsque non chiffrées, les données contiennent une ou plusieurs Garlic Cloves (segments « garlic ») - Le bloc chiffré AES est rembourré jusqu’à un minimum de 128 octets ; avec la Session Tag de 32 octets (étiquette de session), la taille minimale du message chiffré est de 160 octets ; avec le champ de longueur de 4 octets, la taille minimale du Garlic Message (message « garlic ») est de 164 octets - La longueur maximale réelle est inférieure à 64 Ko (limite pratique d’environ 61,2 Ko pour les messages de tunnel) - Voir ElGamal/AES Specification pour les détails du chiffrement - Voir Garlic Routing pour une vue d’ensemble conceptuelle - La taille minimale de 128 octets du bloc chifré AES n’est pas configurable pour le moment - L’ID de message est généralement défini à un nombre aléatoire à l’émission et semble être ignoré à la réception - Le certificat pourrait éventuellement être utilisé avec HashCash pour « payer » le routage (possibilité future) - Structure de chiffrement ElGamal : session tag de 32 octets + clé de session chiffrée ElGamal + charge utile chiffrée AES\nPour le format ECIES-X25519-AEAD-Ratchet (standard actuel pour les routers):\nVoir Spécification ECIES et Proposition 144 .\nCode source: - net.i2p.data.i2np.GarlicMessage - Chiffrement: net.i2p.crypto.elgamal.ElGamalAESEngine (déprécié) - Chiffrement moderne: net.i2p.crypto.ECIES packages\nTunnelData (type 18) Objectif: Un message envoyé depuis la passerelle d’un tunnel ou d’un participant vers le participant suivant ou le point de terminaison. Les données sont de longueur fixe et contiennent des messages I2NP qui sont fragmentés, regroupés par lots, complétés par remplissage et chiffrés.\nFormat :\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes Structure de la charge utile (1024 octets) :\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) Remarques : - L\u0026rsquo;ID du message I2NP pour TunnelData est défini sur un nouveau nombre aléatoire à chaque saut - Le format des messages de tunnel (dans les données chiffrées) est spécifié dans Spécification des messages de tunnel - Chaque saut déchiffre une couche à l\u0026rsquo;aide d\u0026rsquo;AES-256 en mode CBC - L\u0026rsquo;IV (vecteur d\u0026rsquo;initialisation) est mis à jour à chaque saut en utilisant les données déchiffrées - La taille totale est exactement de 1,028 octets (4 tunnelId + 1024 data) - C\u0026rsquo;est l\u0026rsquo;unité fondamentale du trafic de tunnel - Les messages TunnelData transportent des messages I2NP fragmentés (GarlicMessage, DatabaseStore, etc.)\nCode source: - net.i2p.data.i2np.TunnelDataMessage - Constante: TunnelDataMessage.DATA_LENGTH = 1024 - Traitement: net.i2p.router.tunnel.InboundGatewayProcessor\nTunnelGateway (passerelle de tunnel) (Type 19) Objectif: Encapsule un autre message I2NP destiné à être envoyé dans un tunnel, à la passerelle d\u0026rsquo;entrée du tunnel.\nFormat:\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message Remarques: - La charge utile est un message I2NP avec un en-tête standard de 16 octets - Utilisé pour injecter des messages dans des tunnels depuis le router local - La passerelle fragmente le message inclus si nécessaire - Après fragmentation, les fragments sont encapsulés dans des messages TunnelData (messages de données de tunnel) - TunnelGateway (type de message « passerelle de tunnel ») n\u0026rsquo;est jamais envoyé sur le réseau; c\u0026rsquo;est un type de message interne utilisé avant le traitement du tunnel\nCode source: - net.i2p.data.i2np.TunnelGatewayMessage - Traitement: net.i2p.router.tunnel.OutboundGatewayProcessor\nDataMessage (message de données) (Type 20) Objectif : Utilisé par les Garlic Messages (messages Garlic, mécanisme d’agrégation de messages dans I2P) et les Garlic Cloves (sous-messages contenus dans un Garlic Message) pour encapsuler des données arbitraires (généralement des données applicatives chiffrées de bout en bout).\nFormat :\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message Remarques: - Ce message ne contient aucune information de routage et ne sera jamais envoyé \u0026ldquo;non encapsulé\u0026rdquo; - Uniquement utilisé à l\u0026rsquo;intérieur de Garlic messages (format de message spécifique à I2P) - Contient généralement des données d\u0026rsquo;application chiffrées de bout en bout (HTTP, IRC, email, etc.) - Les données sont généralement une charge utile chiffrée ElGamal/AES ou ECIES - La taille maximale pratique est d\u0026rsquo;environ 61,2 Ko en raison des limites de fragmentation des messages de tunnel\nCode source: - net.i2p.data.i2np.DataMessage\nTunnelBuild (Type 21) OBSOLÈTE. Utilisez VariableTunnelBuild (type 23) ou ShortTunnelBuild (type 25).\nObjectif: Requête de construction de tunnel de longueur fixe pour 8 sauts.\nFormat :\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes Notes : - Depuis la version 0.9.48, peut contenir des BuildRequestRecords ECIES-X25519 (enregistrements de requête de construction). Voir Création de tunnel ECIES - Voir Spécification de création de tunnel pour plus de détails - L\u0026rsquo;ID de message I2NP pour ce message doit être défini conformément à la spécification de création de tunnel - Bien que rarement observé sur le réseau actuel (remplacé par VariableTunnelBuild (construction de tunnel variable)), il peut encore être utilisé pour des tunnels très longs et n\u0026rsquo;a pas été officiellement déprécié - Routers doivent toujours l\u0026rsquo;implémenter pour des raisons de compatibilité - Le format fixe à 8 enregistrements est peu flexible et gaspille de la bande passante pour les tunnels plus courts\nCode source : - net.i2p.data.i2np.TunnelBuildMessage - Constante : TunnelBuildMessageBase.MAX_RECORD_COUNT = 8\nTunnelBuildReply (réponse de construction de tunnel) (Type 22) DÉPRÉCIÉ. Utilisez VariableTunnelBuildReply (type 24) ou OutboundTunnelBuildReply (type 26).\nObjectif : Réponse de construction de tunnel de longueur fixe pour 8 sauts.\nFormat :\nMême format que TunnelBuildMessage, avec BuildResponseRecords au lieu de BuildRequestRecords.\nTotal size: 8 × 528 = 4,224 bytes Remarques : - À partir de la version 0.9.48, peut contenir ECIES-X25519 BuildResponseRecords. Voir Création de tunnel ECIES - Voir Spécification de création de tunnel pour plus de détails - L\u0026rsquo;ID de message I2NP pour ce message doit être défini conformément à la spécification de création de tunnel - Bien que rarement observé dans le réseau actuel (remplacé par VariableTunnelBuildReply), il peut encore être utilisé pour des tunnels très longs et n\u0026rsquo;a pas été formellement déprécié - Les Routers doivent encore l\u0026rsquo;implémenter pour des raisons de compatibilité\nCode source: - net.i2p.data.i2np.TunnelBuildReplyMessage\nVariableTunnelBuild (Type 23) Objectif: Construction de tunnel à longueur variable de 1 à 8 sauts. Prend en charge les routers ElGamal et ECIES-X25519.\nFormat :\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Notes : - À partir de la 0.9.48, peut contenir des BuildRequestRecords ECIES-X25519 (enregistrements de demande de construction). Voir Création de Tunnel ECIES - Introduit dans la version 0.7.12 (2009) du router - Ne doit pas être envoyé aux participants du tunnel antérieurs à la version 0.7.12 - Voir Spécification de création de tunnel pour plus de détails - L\u0026rsquo;ID de message I2NP doit être défini conformément à la spécification de création de tunnel - Nombre typique d\u0026rsquo;enregistrements : 4 (pour un tunnel à 4 sauts) - Taille totale typique : 1 + (4 × 528) = 2 113 octets - Ceci est le message standard de construction de tunnel pour les routers ElGamal - Les routers ECIES utilisent généralement ShortTunnelBuild (construction de tunnel courte, type 25) à la place\nCode source: - net.i2p.data.i2np.VariableTunnelBuildMessage\nVariableTunnelBuildReply (Type 24) Objectif : Réponse de construction de tunnel de longueur variable pour 1 à 8 sauts. Prend en charge à la fois les routers ElGamal et ECIES-X25519.\nFormat:\nMême format que VariableTunnelBuildMessage, avec BuildResponseRecords au lieu de BuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Remarques : - À partir de la 0.9.48, peut contenir des ECIES-X25519 BuildResponseRecords. Voir Création de tunnel ECIES - Introduit dans la version 0.7.12 du router (2009) - Ne doit pas être envoyé aux participants du tunnel exécutant une version antérieure à 0.7.12 - Voir Spécification de création de tunnel pour plus de détails - L’ID de message I2NP doit être défini conformément à la spécification de création de tunnel - Nombre typique d’enregistrements : 4 - Taille totale typique : 2 113 octets\nCode source : - net.i2p.data.i2np.VariableTunnelBuildReplyMessage\nShortTunnelBuild (Type 25) Objectif : Messages courts de construction de tunnel pour les routers ECIES-X25519 uniquement. Introduit dans la version d\u0026rsquo;API 0.9.51 (version 1.5.0, août 2021). C\u0026rsquo;est le standard actuel pour les constructions de tunnel ECIES.\nFormat :\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Remarques : - Introduit dans la version 0.9.51 du router (version 1.5.0, août 2021) - Ne peut pas être envoyé aux participants du tunnel utilisant une version d’API antérieure à 0.9.51 - Voir Création de tunnel ECIES pour la spécification complète - Voir Proposition 157 pour la justification - Nombre typique d’enregistrements : 4 - Taille totale typique : 1 + (4 × 218) = 873 octets - Économie de bande passante : 59 % plus petit que VariableTunnelBuild (873 contre 2,113 octets) - Gain de performance : 4 enregistrements courts tiennent dans un seul message de tunnel ; VariableTunnelBuild nécessite 3 messages de tunnel - Il s’agit désormais du format standard de construction de tunnel pour les tunnels ECIES-X25519 purs - Les enregistrements dérivent les clés via HKDF (fonction de dérivation de clés HMAC) au lieu de les inclure explicitement\nCode source : - net.i2p.data.i2np.ShortTunnelBuildMessage - Constante : ShortEncryptedBuildRecord.RECORD_SIZE = 218\nOutboundTunnelBuildReply (réponse de construction de tunnel sortant) (Type 26) But: Envoyé depuis l\u0026rsquo;extrémité sortante d\u0026rsquo;un nouveau tunnel vers l\u0026rsquo;initiateur. Pour les routers ECIES-X25519 uniquement. Introduit dans la version 0.9.51 de l\u0026rsquo;API (version 1.5.0, août 2021).\nFormat :\nMême format que ShortTunnelBuildMessage, avec ShortBuildResponseRecords au lieu de ShortBuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Remarques : - Introduit dans la version 0.9.51 du router (version 1.5.0, août 2021) - Voir Création de tunnel ECIES pour la spécification complète - Nombre typique d’enregistrements : 4 - Taille totale typique : 873 octets - Cette réponse est envoyée depuis le point d’extrémité sortant (OBEP) vers le créateur du tunnel via le tunnel sortant nouvellement créé - Fournit la confirmation que tous les sauts ont accepté la création du tunnel\nCode source: - net.i2p.data.i2np.OutboundTunnelBuildReplyMessage\nRéférences Spécifications officielles Spécification I2NP - Spécification complète du format des messages I2NP Structures communes - Types de données et structures utilisés dans tout I2P Création de tunnel - Création de tunnel ElGamal (obsolète) Création de tunnel ECIES - Création de tunnel ECIES-X25519 (actuelle) Message de tunnel - Format des messages de tunnel et instructions d\u0026rsquo;acheminement Spécification NTCP2 - Protocole de transport TCP Spécification SSU2 - Protocole de transport UDP Spécification ECIES - Chiffrement ECIES-X25519-AEAD-Ratchet Spécification de cryptographie - Primitives cryptographiques de bas niveau Spécification I2CP - Spécification du protocole client Spécification des datagrammes - Formats Datagram2 et Datagram3 Propositions Proposal 123 - Nouvelles entrées netDB (LeaseSet2, EncryptedLeaseSet, MetaLeaseSet) Proposal 144 - Chiffrement ECIES-X25519-AEAD-Ratchet (mécanisme à cliquet AEAD avec X25519) Proposal 154 - Recherche chiffrée dans la base de données Proposal 156 - routers ECIES Proposal 157 - Messages de construction de tunnel plus petits (format court) Proposal 159 - Transport SSU2 Proposal 161 - Bourrage compressible Proposal 163 - Datagram2 et Datagram3 Proposal 167 - Paramètres d\u0026rsquo;enregistrement de service LeaseSet Proposal 168 - Paramètres de bande passante de construction de tunnel Proposal 169 - Cryptographie hybride post-quantique Documentation Garlic Routing (routage Garlic) - Regroupement de messages en couches ElGamal/AES - Schéma de chiffrement déprécié Implémentation du tunnel - Fragmentation et traitement Base de données réseau - Table de hachage distribuée Transport NTCP2 - Spécification du transport TCP Transport SSU2 - Spécification du transport UDP Introduction technique - Aperçu de l’architecture I2P Code source Dépôt Java I2P - Implémentation Java officielle Miroir GitHub - Miroir GitHub de Java I2P Dépôt i2pd - Implémentation C++ Emplacements clés du code source Java I2P (i2pgit.org/I2P_Developers/i2p.i2p): - core/java/src/net/i2p/data/i2np/ - Implémentations des messages I2NP - core/java/src/net/i2p/crypto/ - Implémentations cryptographiques - router/java/src/net/i2p/router/tunnel/ - Traitement du tunnel - router/java/src/net/i2p/router/transport/ - Implémentations du transport\nConstantes et valeurs: - I2NPMessage.MAX_SIZE = 65536 - Taille maximale d’un message I2NP - I2NPMessageImpl.HEADER_LENGTH = 16 - Taille standard de l’en-tête - TunnelDataMessage.DATA_LENGTH = 1024 - Charge utile du message de tunnel - EncryptedBuildRecord.RECORD_SIZE = 528 - Enregistrement de construction long - ShortEncryptedBuildRecord.RECORD_SIZE = 218 - Enregistrement de construction court - TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - Nombre maximal d’enregistrements par construction\nAnnexe A : Statistiques du réseau et état actuel Composition du réseau (en octobre 2025) Nombre total de routers: Environ 60 000-70 000 (variable) Routers floodfill: Environ 500-700 actifs Types de chiffrement: ECIES-X25519: \u0026gt;95 % des routers ElGamal: \u0026lt;5 % des routers (déprécié, usage hérité uniquement) Adoption des transports: SSU2: \u0026gt;60 % comme transport principal NTCP2: ~40 % comme transport principal Transports hérités (SSU1, NTCP): 0 % (supprimés) Types de signature: EdDSA (Ed25519): Très grande majorité ECDSA: Faible pourcentage RSA: Interdit (supprimé) Exigences minimales du router Version de l\u0026rsquo;API: 0.9.16+ (pour la compatibilité EdDSA avec le réseau) Minimum recommandé: API 0.9.51+ (constructions de tunnels courts ECIES) Minimum actuel pour les floodfills: API 0.9.58+ (dépréciation du router ElGamal) Exigence à venir: Java 17+ (à partir de la version 2.11.0, décembre 2025) Exigences de bande passante Minimum : 128 KBytes/sec (drapeau N ou supérieur) pour le floodfill Recommandé : 256 KBytes/sec (drapeau O) ou supérieur Exigences pour le floodfill : Bande passante minimale de 128 KB/sec Temps de fonctionnement stable (\u0026gt;95% recommandé) Faible latence (\u0026lt;500ms vers les pairs) Réussir les tests d’intégrité (temps de file d’attente, retard des tâches) Statistiques des tunnels Longueur typique du tunnel : 3-4 sauts Longueur maximale du tunnel : 8 sauts (théorique, rarement utilisée) Durée de vie typique du tunnel : 10 minutes Taux de réussite de construction de tunnel : \u0026gt;85% pour des routers bien connectés Format des messages de construction de tunnel : routers ECIES (schéma de chiffrement intégré à courbe elliptique) : ShortTunnelBuild (enregistrements de 218 octets) Tunnels mixtes : VariableTunnelBuild (enregistrements de 528 octets) Métriques de performance Temps de construction du tunnel: 1-3 secondes (typique) Latence de bout en bout: 0,5-2 secondes (typique, 6-8 sauts au total) Débit: Limité par la bande passante du tunnel (typiquement 10-50 KB/sec par tunnel) Taille maximale du datagramme: 10 KB recommandé (61,2 KB maximum théorique) Annexe B : Fonctionnalités dépréciées et supprimées Entièrement supprimé (n\u0026rsquo;est plus pris en charge) Transport NTCP - Supprimé dans la version 0.9.50 (mai 2021) Transport SSU v1 - Supprimé de Java I2P dans la version 2.4.0 (décembre 2023) Transport SSU v1 - Supprimé d\u0026rsquo;i2pd dans la version 2.44.0 (novembre 2022) Types de signature RSA - Interdits depuis l\u0026rsquo;API 0.9.28 Déprécié (pris en charge mais déconseillé) ElGamal routers - Dépréciés depuis l’API 0.9.58 (mars 2023) Les destinations ElGamal sont toujours prises en charge pour la rétrocompatibilité Les nouveaux routers doivent utiliser ECIES-X25519 exclusivement TunnelBuild (type 21) - Déprécié au profit de VariableTunnelBuild et ShortTunnelBuild Toujours implémenté pour des tunnels très longs (\u0026gt;8 sauts) TunnelBuildReply (type 22) - Déprécié au profit de VariableTunnelBuildReply et OutboundTunnelBuildReply Chiffrement ElGamal/AES - Déprécié au profit d’ECIES-X25519-AEAD-Ratchet Toujours utilisé pour les anciennes destinations BuildRequestRecords ECIES longs (528 octets) - Dépréciés au profit du format court (218 octets) Toujours utilisés pour des tunnels mixtes avec des sauts ElGamal Calendrier de prise en charge des anciennes versions Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels --- Annexe C : Développements futurs Cryptographie post-quantique Statut : Bêta à partir de la version 2.10.0 (septembre 2025), deviendra l’option par défaut avec la version 2.11.0 (décembre 2025)\nImplémentation: - Approche hybride combinant X25519 classique et MLKEM post-quantique (ML-KEM-768) - Rétrocompatible avec l\u0026rsquo;infrastructure ECIES-X25519 existante - Utilise Signal Double Ratchet (mécanisme à double cliquet de Signal) avec du matériel de clés classique et PQ - Voir Proposition 169 pour plus de détails\nPlan de migration: 1. Version 2.10.0 (septembre 2025): Disponible en tant qu’option bêta 2. Version 2.11.0 (décembre 2025): Activé par défaut 3. Versions futures: À terme, obligatoire\nFonctionnalités prévues Améliorations IPv6 - Meilleure prise en charge d\u0026rsquo;IPv6 et des mécanismes de transition Régulation de débit par tunnel - Contrôle fin de la bande passante par tunnel Métriques améliorées - Meilleure surveillance des performances et des capacités de diagnostic Optimisations des protocoles - Surcharge réduite et efficacité accrue Sélection floodfill améliorée - Meilleure distribution de la base de données réseau Domaines de recherche Optimisation de la longueur des tunnels - Longueur de tunnels dynamique basée sur le modèle de menace Bourrage avancé - Améliorations de la résistance à l\u0026rsquo;analyse de trafic Nouveaux schémas de chiffrement - Préparation face aux menaces de l\u0026rsquo;informatique quantique Contrôle de congestion - Meilleure gestion de la charge réseau Prise en charge mobile - Optimisations pour les appareils et réseaux mobiles Annexe D : Directives de mise en œuvre Pour les nouvelles implémentations Exigences minimales: 1. Prendre en charge les fonctionnalités de la version 0.9.51+ de l’API 2. Implémenter le chiffrement ECIES-X25519-AEAD-Ratchet 3. Prendre en charge les transports NTCP2 et SSU2 4. Implémenter les messages ShortTunnelBuild (enregistrements de 218 octets) 5. Prendre en charge les variantes LeaseSet2 (types 3, 5, 7) 6. Utiliser des signatures EdDSA (Ed25519)\nRecommandé: 1. Prendre en charge la cryptographie hybride post-quantique (à partir de la version 2.11.0) 2. Implémenter des paramètres de bande passante par tunnel 3. Prendre en charge les formats Datagram2 et Datagram3 4. Implémenter les options d’enregistrement de service dans les LeaseSets 5. Suivre les spécifications officielles à /docs/specs/\nNon requis: 1. Prise en charge du router ElGamal (dépréciée) 2. Prise en charge des transports hérités (SSU1, NTCP) 3. BuildRequestRecords ECIES longs (528 octets pour des tunnels ECIES purs) 4. messages TunnelBuild/TunnelBuildReply (utiliser les variantes Variable ou Short)\nTests et validation Conformité au protocole: 1. Tester l\u0026rsquo;interopérabilité avec le router I2P officiel en Java 2. Tester l\u0026rsquo;interopérabilité avec le router i2pd en C++ 3. Valider les formats de message selon les spécifications 4. Tester les cycles d\u0026rsquo;établissement/démontage de tunnel 5. Vérifier le chiffrement/déchiffrement avec des vecteurs de test\nTests de performance: 1. Mesurer les taux de réussite de la construction des tunnels (devraient être \u0026gt; 85 %) 2. Tester avec différentes longueurs de tunnels (2-8 sauts) 3. Valider la fragmentation et le réassemblage 4. Tester sous charge (tunnels multiples simultanés) 5. Mesurer la latence de bout en bout\nTests de sécurité: 1. Vérifier l\u0026rsquo;implémentation du chiffrement (utiliser des vecteurs de test) 2. Tester la prévention des attaques par rejeu 3. Valider la gestion de l\u0026rsquo;expiration des messages 4. Tester la robustesse face aux messages malformés 5. Vérifier la génération correcte de nombres aléatoires\nÉcueils courants d’implémentation Formats d\u0026rsquo;instructions de livraison déroutants - Garlic clove (élément « gousse » du schéma garlic) vs tunnel message (message de tunnel) Dérivation de clés incorrecte - Utilisation de HKDF pour short build records (format court des enregistrements de construction de tunnel) Gestion de l\u0026rsquo;ID de message - Non défini correctement pour les constructions de tunnel Problèmes de fragmentation - Non-respect de la limite pratique de 61,2 Ko Erreurs d\u0026rsquo;ordre des octets - Java utilise le big-endian pour tous les entiers Gestion de l\u0026rsquo;expiration - Le format court déborde le 7 février 2106 Génération de somme de contrôle - Toujours requise même si elle n\u0026rsquo;est pas vérifiée ","description":"Formats de messages de router à router, priorités et limites de taille au sein d’I2P.","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"Protocole réseau d'I2P (I2NP)","url":"/fr/docs/specs/i2np/"},{"categories":null,"content":" Attention : Le tunnel SOCKS transmet les charges utiles des applications sans les nettoyer. De nombreux protocoles divulguent des adresses IP, des noms d\u0026rsquo;hôtes ou d\u0026rsquo;autres identifiants. Utilisez SOCKS uniquement avec des logiciels que vous avez vérifiés pour l\u0026rsquo;anonymat.\n1. Aperçu I2P fournit la prise en charge des proxys SOCKS 4, 4a et 5 pour les connexions sortantes via un client I2PTunnel. Cela permet aux applications standard d\u0026rsquo;atteindre les destinations I2P mais ne peut pas accéder au clearnet. Il n\u0026rsquo;existe aucun outproxy SOCKS, et tout le trafic reste au sein du réseau I2P.\nRésumé de l\u0026rsquo;implémentation Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None **Types d'adresses supportés :** - Noms d'hôtes `.i2p` (entrées du carnet d'adresses) - Hachages Base32 (`.b32.i2p`) - Aucun support pour Base64 ou clearnet 2. Risques de sécurité et limitations Fuite au niveau de la couche applicative SOCKS fonctionne en dessous de la couche application et ne peut pas assainir les protocoles. De nombreux clients (par exemple, navigateurs, IRC, email) incluent des métadonnées qui révèlent votre adresse IP, nom d\u0026rsquo;hôte ou détails système.\nLes fuites courantes incluent : - Les adresses IP dans les en-têtes de courrier électronique ou les réponses CTCP IRC - Les noms réels/noms d\u0026rsquo;utilisateur dans les charges utiles de protocole - Les chaînes user-agent avec empreintes du système d\u0026rsquo;exploitation - Les requêtes DNS externes - WebRTC et la télémétrie du navigateur\nI2P ne peut pas empêcher ces fuites—elles se produisent au-dessus de la couche tunnel. N\u0026rsquo;utilisez SOCKS que pour des clients audités conçus pour l\u0026rsquo;anonymat.\nIdentité de tunnel partagée Si plusieurs applications partagent un tunnel SOCKS, elles partagent la même identité de destination I2P. Cela permet la corrélation ou l\u0026rsquo;empreinte digitale entre différents services.\nAtténuation : Utilisez des tunnels non partagés pour chaque application et activez les clés persistantes pour maintenir des identités cryptographiques cohérentes entre les redémarrages.\nMode UDP désactivé Le support UDP dans SOCKS5 n\u0026rsquo;est pas implémenté. Le protocole annonce la capacité UDP, mais les appels sont ignorés. Utilisez des clients TCP uniquement.\nPas d\u0026rsquo;Outproxy par conception Contrairement à Tor, I2P n\u0026rsquo;offre pas d\u0026rsquo;outproxies clearnet basés sur SOCKS. Les tentatives d\u0026rsquo;accéder à des adresses IP externes échoueront ou exposeront votre identité. Utilisez des proxies HTTP ou HTTPS si l\u0026rsquo;outproxying est nécessaire.\n3. Contexte historique Les développeurs déconseillent depuis longtemps l\u0026rsquo;utilisation de SOCKS pour un usage anonyme. D\u0026rsquo;après les discussions internes entre développeurs et les Réunion 81 et Réunion 82 de 2004 :\n\u0026ldquo;Transférer du trafic arbitraire n\u0026rsquo;est pas sûr, et il nous incombe en tant que développeurs de logiciels d\u0026rsquo;anonymat d\u0026rsquo;avoir la sécurité de nos utilisateurs finaux au premier plan de nos préoccupations.\u0026rdquo;\nLe support SOCKS a été inclus pour des raisons de compatibilité mais n\u0026rsquo;est pas recommandé pour les environnements de production. Presque toutes les applications internet divulguent des métadonnées sensibles inadaptées au routage anonyme.\n4. Configuration Java I2P Ouvrez le I2PTunnel Manager Créez un nouveau tunnel client de type \u0026ldquo;SOCKS 4/4a/5\u0026rdquo; Configurez les options : Port local (n\u0026rsquo;importe quel port disponible) Client partagé : désactiver pour une identité séparée par application Clé persistante : activer pour réduire la corrélation de clés Démarrez le tunnel i2pd i2pd inclut le support SOCKS5 activé par défaut sur 127.0.0.1:4447. La configuration dans i2pd.conf sous [SOCKSProxy] vous permet d\u0026rsquo;ajuster le port, l\u0026rsquo;hôte et les paramètres de tunnel.\n5. Calendrier de développement Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 Le module SOCKS lui-même n'a connu aucune mise à jour majeure du protocole depuis 2013, mais la pile de tunnels environnante a bénéficié d'améliorations en matière de performances et de cryptographie. 6. Alternatives recommandées Pour toute application de production, exposée publiquement ou critique en matière de sécurité, utilisez l\u0026rsquo;une des API I2P officielles au lieu de SOCKS :\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM Ces API fournissent une isolation appropriée des destinations, un contrôle de l'identité cryptographique et de meilleures performances de routage. 7. OnionCat / GarliCat OnionCat prend en charge I2P via son mode GarliCat (plage IPv6 fd60:db4d:ddb5::/48). Toujours fonctionnel mais avec un développement limité depuis 2019.\nLimitations d\u0026rsquo;utilisation : - Nécessite une configuration manuelle .oc.b32.i2p dans SusiDNS - Requiert une attribution IPv6 statique - Non officiellement pris en charge par le projet I2P\nRecommandé uniquement pour les configurations VPN-over-I2P avancées.\n8. Bonnes Pratiques Si vous devez utiliser SOCKS : 1. Créez des tunnels séparés par application. 2. Désactivez le mode client partagé. 3. Activez les clés persistantes. 4. Forcez la résolution DNS SOCKS5. 5. Auditez le comportement du protocole pour détecter les fuites. 6. Évitez les connexions clearnet. 7. Surveillez le trafic réseau pour détecter les fuites.\n9. Résumé technique Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) --- 10. Conclusion Le proxy SOCKS dans I2P offre une compatibilité de base avec les applications TCP existantes mais n\u0026rsquo;est pas conçu pour garantir un anonymat robuste. Il ne devrait être utilisé que dans des environnements de test contrôlés et audités.\nPour les déploiements sérieux, migrez vers SAM v3 ou l\u0026rsquo;API Streaming. Ces API isolent les identités des applications, utilisent une cryptographie moderne et bénéficient d\u0026rsquo;un développement continu.\nRessources supplémentaires Documentation officielle SOCKS Spécification SAM v3 Documentation de la bibliothèque Streaming Référence I2PTunnel Documentation développeur I2P Forum de la communauté ","description":"Utiliser le tunnel SOCKS d'I2P en toute sécurité (mis à jour pour la version 2.10.0)","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"Proxy SOCKS","url":"/fr/docs/api/socks/"},{"categories":null,"content":"Aide du Routeur I2P Sur quels systèmes I2P peut-il fonctionner ? I2P est écrit en langage de programmation Java. Il a été testé sur Windows, Linux, FreeBSD et OSX. Un portage Android est également disponible.\nEn termes d\u0026rsquo;utilisation de la mémoire, I2P est configuré pour utiliser 128 Mo de RAM par défaut. Ceci est suffisant pour la navigation et l\u0026rsquo;utilisation d\u0026rsquo;IRC. Cependant, d\u0026rsquo;autres activités peuvent nécessiter une allocation de mémoire plus importante. Par exemple, si l\u0026rsquo;on souhaite exécuter un router à bande passante élevée, participer aux torrents I2P ou héberger des services cachés à fort trafic, une quantité de mémoire plus importante est requise.\nEn termes d\u0026rsquo;utilisation du processeur, I2P a été testé pour fonctionner sur des systèmes modestes tels que la gamme d\u0026rsquo;ordinateurs monocartes Raspberry Pi. Comme I2P fait un usage intensif de techniques cryptographiques, un processeur plus puissant sera mieux adapté pour gérer la charge de travail générée par I2P ainsi que les tâches liées au reste du système (c\u0026rsquo;est-à-dire système d\u0026rsquo;exploitation, interface graphique, autres processus tels que la navigation Web).\nL\u0026rsquo;utilisation de Sun/Oracle Java ou OpenJDK est recommandée.\nL\u0026rsquo;installation de Java est-elle nécessaire pour utiliser I2P ? Oui, Java est nécessaire pour utiliser I2P Core. Nous incluons Java dans nos installateurs faciles pour Windows, Mac OSX et Linux. Si vous utilisez l\u0026rsquo;application I2P Android, vous aurez également besoin d\u0026rsquo;un environnement d\u0026rsquo;exécution Java comme Dalvik ou ART installé dans la plupart des cas.\nQu\u0026rsquo;est-ce qu\u0026rsquo;un \u0026ldquo;I2P Site\u0026rdquo; et comment configurer mon navigateur pour pouvoir les utiliser ? Un site I2P est un site web normal, sauf qu\u0026rsquo;il est hébergé à l\u0026rsquo;intérieur d\u0026rsquo;I2P. Les sites I2P ont des adresses qui ressemblent à des adresses internet normales, se terminant par \u0026ldquo;.i2p\u0026rdquo; d\u0026rsquo;une manière lisible par l\u0026rsquo;homme et non cryptographique, pour le bénéfice des utilisateurs. La connexion réelle à un site I2P nécessite de la cryptographie, ce qui signifie que les adresses de sites I2P sont également les longues Destinations \u0026ldquo;Base64\u0026rdquo; et les adresses \u0026ldquo;B32\u0026rdquo; plus courtes. Vous devrez peut-être effectuer une configuration supplémentaire pour naviguer correctement. La navigation sur les sites I2P nécessite d\u0026rsquo;activer le proxy HTTP dans votre installation I2P, puis de configurer votre navigateur pour l\u0026rsquo;utiliser. Pour plus d\u0026rsquo;informations, consultez la section \u0026ldquo;Navigateurs\u0026rdquo; ci-dessous ou le guide \u0026ldquo;Configuration du navigateur\u0026rdquo;.\nQue signifient les chiffres Actifs x/y dans la console du routeur ? Sur la page Pairs de votre console routeur, vous pouvez voir deux nombres - Actifs x/y. Le premier nombre est le nombre de pairs avec lesquels vous avez envoyé ou reçu un message au cours des dernières minutes. Le second nombre est le nombre de pairs vus récemment, celui-ci sera toujours supérieur ou égal au premier nombre.\nMon routeur a très peu de pairs actifs, est-ce normal ? Oui, cela peut être normal, surtout lorsque le routeur vient d\u0026rsquo;être démarré. Les nouveaux routeurs ont besoin de temps pour démarrer et se connecter au reste du réseau. Pour améliorer l\u0026rsquo;intégration au réseau, la disponibilité et les performances, vérifiez ces paramètres :\nPartager la bande passante - Si un router est configuré pour partager la bande passante, il acheminera davantage de trafic pour d\u0026rsquo;autres routers, ce qui contribue à l\u0026rsquo;intégrer au reste du réseau et améliore également les performances de sa connexion locale. Cela peut être configuré sur la page http://localhost:7657/config . Interface réseau - Assurez-vous qu\u0026rsquo;aucune interface n\u0026rsquo;est spécifiée sur la page http://localhost:7657/confignet . Cela peut réduire les performances, sauf si votre ordinateur est multi-hébergé avec plusieurs adresses IP externes. Protocole I2NP - Assurez-vous que le router est configuré pour attendre des connexions sur un protocole valide pour le système d\u0026rsquo;exploitation de l\u0026rsquo;hôte et des paramètres réseau (Avancés) vides. N\u0026rsquo;entrez pas d\u0026rsquo;adresse IP dans le champ \u0026lsquo;Nom d\u0026rsquo;hôte\u0026rsquo; de la page de configuration réseau. Le protocole I2NP que vous sélectionnez ici ne sera utilisé que si vous n\u0026rsquo;avez pas déjà une adresse accessible. La plupart des connexions sans fil Verizon 4G et 5G aux États-Unis, par exemple, bloquent UDP et ne peuvent pas être jointes via ce protocole. D\u0026rsquo;autres utiliseraient UDP de force même s\u0026rsquo;il leur est disponible. Choisissez un paramètre raisonnable parmi les protocoles I2NP listés. Je suis opposé à certains types de contenu. Comment puis-je éviter de les distribuer, de les stocker ou d\u0026rsquo;y accéder ? Aucun de ce contenu n\u0026rsquo;est installé par défaut. Cependant, comme I2P est un réseau pair-à-pair, il est possible que vous rencontriez du contenu interdit par accident. Voici un résumé de la façon dont I2P vous empêche d\u0026rsquo;être impliqué inutilement dans des violations de vos convictions.\nDistribution - Le trafic est interne au réseau I2P, vous n\u0026rsquo;êtes pas un nœud de sortie (appelé outproxy dans notre documentation). Stockage - Le réseau I2P ne fait pas de stockage distribué de contenu, cela doit être spécifiquement installé et configuré par l\u0026rsquo;utilisateur (avec Tahoe-LAFS, par exemple). C\u0026rsquo;est une fonctionnalité d\u0026rsquo;un réseau anonyme différent, Freenet . En exécutant un router I2P, vous ne stockez pas de contenu pour qui que ce soit. Accès - Votre router ne demandera aucun contenu sans votre instruction spécifique de le faire. Est-il possible de bloquer I2P ? Oui, de loin le moyen le plus simple et le plus courant est de bloquer le bootstrap, ou les serveurs \u0026ldquo;Reseed\u0026rdquo;. Bloquer complètement tout le trafic obfusqué fonctionnerait également (bien que cela casserait beaucoup, beaucoup d\u0026rsquo;autres choses qui ne sont pas I2P et la plupart ne sont pas prêts à aller aussi loin). Dans le cas du blocage du reseed, il existe un bundle de reseed sur Github, le bloquer bloquera également Github. Vous pouvez effectuer un reseed via un proxy (beaucoup peuvent être trouvés sur Internet si vous ne voulez pas utiliser Tor) ou partager des bundles de reseed sur une base ami-à-ami hors ligne.\nDans wrapper.log je vois une erreur indiquant \u0026ldquo;Protocol family unavailable\u0026rdquo; lors du chargement de la Console du Routeur Souvent, cette erreur se produit avec n\u0026rsquo;importe quel logiciel Java utilisant le réseau sur certains systèmes configurés pour utiliser IPv6 par défaut. Il existe plusieurs façons de résoudre ce problème :\nSur les systèmes basés sur Linux, vous pouvez exécuter echo 0 \u0026gt; /proc/sys/net/ipv6/bindv6only Recherchez les lignes suivantes dans wrapper.config : #wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true #wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false Si les lignes sont présentes, décommentez-les en supprimant les \u0026ldquo;#\u0026rdquo;. Si les lignes ne sont pas présentes, ajoutez-les sans les \u0026ldquo;#\u0026rdquo;. Une autre option serait de supprimer le ::1 de ~/.i2p/clients.config\nAVERTISSEMENT : Pour que les modifications apportées à wrapper.config prennent effet, vous devez arrêter complètement le routeur et le wrapper. Cliquer sur Redémarrer dans votre console de routeur ne relira PAS ce fichier ! Vous devez cliquer sur Arrêter, attendre 11 minutes, puis démarrer I2P.\nLa plupart des sites I2P dans I2P sont inaccessibles ? Si vous considérez tous les sites I2P qui ont jamais été créés, oui, la plupart sont hors ligne. Les personnes et les sites I2P vont et viennent. Un bon moyen de débuter sur I2P est de consulter une liste de sites I2P actuellement en ligne. identiguy.i2p répertorie les sites I2P actifs.\nPourquoi I2P écoute-t-il sur le port 32000 ? Le wrapper de service Java Tanuki que nous utilisons ouvre ce port — lié à localhost — afin de communiquer avec le logiciel s\u0026rsquo;exécutant dans la JVM. Lorsque la JVM est lancée, elle reçoit une clé pour pouvoir se connecter au wrapper. Après que la JVM a établi sa connexion au wrapper, le wrapper refuse toute connexion supplémentaire.\nPlus d\u0026rsquo;informations peuvent être trouvées dans la documentation du wrapper .\nComment configurer mon navigateur ? La configuration du proxy pour différents navigateurs se trouve sur une page séparée avec des captures d\u0026rsquo;écran. Des configurations plus avancées avec des outils externes, tels que l\u0026rsquo;extension de navigateur FoxyProxy ou le serveur proxy Privoxy, sont possibles mais pourraient introduire des fuites dans votre configuration.\nComment puis-je me connecter à IRC au sein d\u0026rsquo;I2P ? Un tunnel vers le serveur IRC principal au sein d\u0026rsquo;I2P, Irc2P, est créé lors de l\u0026rsquo;installation d\u0026rsquo;I2P (voir la page de configuration I2PTunnel ), et est automatiquement démarré lorsque le router I2P démarre. Pour vous y connecter, configurez votre client IRC pour se connecter à localhost 6668. Les utilisateurs de clients de type HexChat peuvent créer un nouveau réseau avec le serveur localhost/6668 (n\u0026rsquo;oubliez pas de cocher \u0026ldquo;Contourner le serveur proxy\u0026rdquo; si vous avez un serveur proxy configuré). Les utilisateurs de Weechat peuvent utiliser la commande suivante pour ajouter un nouveau réseau :\n/server add irc2p localhost/6668 Comment configurer mon propre site I2P ? La méthode la plus simple consiste à cliquer sur le lien i2ptunnel dans la console du routeur et à créer un nouveau \u0026lsquo;Tunnel Serveur\u0026rsquo;. Vous pouvez servir du contenu dynamique en définissant la destination du tunnel vers le port d\u0026rsquo;un serveur web existant, tel que Tomcat ou Jetty. Vous pouvez également servir du contenu statique. Pour cela, définissez la destination du tunnel sur : 0.0.0.0 port 7659 et placez le contenu dans le répertoire ~/.i2p/eepsite/docroot/. (Sur les systèmes non-Linux, cela peut se trouver à un emplacement différent. Vérifiez la console du routeur.) Le logiciel \u0026rsquo;eepsite\u0026rsquo; est fourni dans le paquet d\u0026rsquo;installation I2P et est configuré pour démarrer automatiquement au lancement d\u0026rsquo;I2P. Le site par défaut ainsi créé est accessible à l\u0026rsquo;adresse http://127.0.0.1:7658. Cependant, votre \u0026rsquo;eepsite\u0026rsquo; est également accessible aux autres via votre fichier de clés eepsite, situé à : ~/.i2p/eepsite/i2p/eepsite.keys. Pour en savoir plus, lisez le fichier readme à l\u0026rsquo;adresse : ~/.i2p/eepsite/README.txt.\nSi j\u0026rsquo;héberge un site web sur I2P à la maison, contenant uniquement du HTML et du CSS, est-ce dangereux ? Cela dépend de votre adversaire et de votre modèle de menace. Si vous êtes uniquement préoccupé par les violations de « confidentialité » des entreprises, les criminels typiques et la censure, alors ce n\u0026rsquo;est pas vraiment dangereux. Les forces de l\u0026rsquo;ordre vous trouveront probablement de toute façon si elles le veulent vraiment. N\u0026rsquo;héberger que lorsque vous avez un navigateur d\u0026rsquo;utilisateur domestique normal (internet) en cours d\u0026rsquo;exécution rendra vraiment difficile de savoir qui héberge cette partie. Veuillez considérer l\u0026rsquo;hébergement de votre site I2P comme l\u0026rsquo;hébergement de tout autre service - c\u0026rsquo;est aussi dangereux - ou sûr - que vous le configurez et le gérez vous-même.\nNote : Il existe déjà un moyen de séparer l\u0026rsquo;hébergement d\u0026rsquo;un service i2p (destination) du routeur i2p. Si vous comprenez comment cela fonctionne, vous pouvez simplement configurer une machine séparée comme serveur pour le site web (ou service) qui sera accessible publiquement et transférer cela vers le serveur web via un tunnel SSH [très] sécurisé ou utiliser un système de fichiers partagé et sécurisé.\nComment I2P trouve-t-il les sites web \u0026ldquo;.i2p\u0026rdquo; ? L\u0026rsquo;application Carnet d\u0026rsquo;adresses I2P associe des noms lisibles par l\u0026rsquo;homme à des destinations à long terme, liées à des services, ce qui la rend plus similaire à un fichier hosts ou à une liste de contacts qu\u0026rsquo;à une base de données réseau ou à un service DNS. Elle fonctionne également en mode local d\u0026rsquo;abord : il n\u0026rsquo;existe pas d\u0026rsquo;espace de noms global reconnu, vous décidez en fin de compte à quoi correspond un domaine .i2p donné. La solution intermédiaire est un service appelé \u0026ldquo;Jump Service\u0026rdquo; qui fournit un nom lisible par l\u0026rsquo;homme en vous redirigeant vers une page où il vous sera demandé \u0026ldquo;Autorisez-vous le routeur I2P à appeler $SITE_CRYPTO_KEY par le nom $SITE_NAME.i2p\u0026rdquo; ou quelque chose dans ce genre. Une fois l\u0026rsquo;entrée dans votre carnet d\u0026rsquo;adresses, vous pouvez générer vos propres URL de saut pour aider à partager le site avec d\u0026rsquo;autres.\nComment ajouter des adresses au Carnet d\u0026rsquo;adresses ? Vous ne pouvez pas ajouter une adresse sans connaître au moins le base32 ou le base64 du site que vous souhaitez visiter. Le \u0026ldquo;nom d\u0026rsquo;hôte\u0026rdquo; qui est lisible par l\u0026rsquo;humain n\u0026rsquo;est qu\u0026rsquo;un alias pour l\u0026rsquo;adresse cryptographique, qui correspond au base32 ou au base64. Sans l\u0026rsquo;adresse cryptographique, il n\u0026rsquo;y a aucun moyen d\u0026rsquo;accéder à un site I2P, c\u0026rsquo;est voulu par conception. La distribution de l\u0026rsquo;adresse aux personnes qui ne la connaissent pas encore relève généralement de la responsabilité du fournisseur de service Jump. Visiter un site I2P inconnu déclenchera l\u0026rsquo;utilisation d\u0026rsquo;un service Jump. stats.i2p est le service Jump le plus fiable.\nSi vous hébergez un site via i2ptunnel, il n\u0026rsquo;aura pas encore d\u0026rsquo;enregistrement auprès d\u0026rsquo;un service de saut. Pour lui attribuer une URL localement, visitez la page de configuration et cliquez sur le bouton « Add to Local Address Book ». Ensuite, rendez-vous sur http://127.0.0.1:7657/dns pour rechercher l\u0026rsquo;URL addresshelper et la partager.\nQuels ports I2P utilise-t-il ? Les ports utilisés par I2P peuvent être divisés en 2 sections :\nPorts exposés à Internet, qui sont utilisés pour la communication avec d\u0026rsquo;autres routeurs I2P Ports locaux, pour les connexions locales Ceux-ci sont décrits en détail ci-dessous.\n1. Ports exposés à Internet Remarque : Depuis la version 0.7.8, les nouvelles installations n\u0026rsquo;utilisent plus le port 8887 ; un port aléatoire entre 9000 et 31000 est sélectionné lors de la première exécution du programme. Le port sélectionné est affiché sur la page de configuration du routeur.\nSORTANT\nUDP depuis le port aléatoire listé sur la page de configuration vers des ports UDP distants arbitraires, permettant les réponses TCP depuis des ports hauts aléatoires vers des ports TCP distants arbitraires UDP sortant sur le port 123, permettant les réponses. Ceci est nécessaire pour la synchronisation horaire interne d\u0026rsquo;I2P (via SNTP - interrogeant un hôte SNTP aléatoire dans pool.ntp.org ou un autre serveur que vous spécifiez) ENTRANT\n(Optionnel, recommandé) UDP vers le port indiqué sur la page de configuration depuis des emplacements arbitraires (Optionnel, recommandé) TCP vers le port indiqué sur la page de configuration depuis des emplacements arbitraires Le TCP entrant peut être désactivé sur la page de configuration 2. Ports I2P locaux Les ports I2P locaux n\u0026rsquo;écoutent que les connexions locales par défaut, sauf indication contraire :\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. ### Il me manque beaucoup d'hôtes dans mon carnet d'adresses. Quels sont les bons liens d'abonnement ? {#subscriptions} Le carnet d\u0026rsquo;adresses se trouve à l\u0026rsquo;adresse http://localhost:7657/dns où vous trouverez plus d\u0026rsquo;informations.\nQuels sont les bons liens d\u0026rsquo;abonnement aux carnets d\u0026rsquo;adresses ?\nVous pouvez essayer ce qui suit :\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt Comment puis-je accéder à la console web depuis mes autres machines ou la protéger par mot de passe ? Pour des raisons de sécurité, la console d\u0026rsquo;administration du routeur n\u0026rsquo;écoute par défaut que les connexions sur l\u0026rsquo;interface locale.\nIl existe deux méthodes pour accéder à la console à distance :\nTunnel SSH Configurer votre console pour qu\u0026rsquo;elle soit accessible sur une adresse IP publique avec un nom d\u0026rsquo;utilisateur et un mot de passe Ceux-ci sont détaillés ci-dessous :\nMéthode 1 : Tunnel SSH\nSi vous utilisez un système d\u0026rsquo;exploitation de type Unix, c\u0026rsquo;est la méthode la plus simple pour accéder à distance à votre console I2P. (Note : un logiciel serveur SSH est disponible pour les systèmes fonctionnant sous Windows, par exemple https://github.com/PowerShell/Win32-OpenSSH )\nUne fois que vous avez configuré l\u0026rsquo;accès SSH à votre système, le drapeau \u0026lsquo;-L\u0026rsquo; est passé à SSH avec les arguments appropriés - par exemple :\nssh -L 7657:localhost:7657 (System_IP) où \u0026lsquo;(System_IP)\u0026rsquo; est remplacé par l\u0026rsquo;adresse IP de votre système. Cette commande transfère le port 7657 (le numéro avant le premier deux-points) vers le port 7657 du système distant (tel que spécifié par la chaîne \u0026rsquo;localhost\u0026rsquo; entre le premier et le second deux-points) (le numéro après le second deux-points). Votre console I2P distante sera désormais accessible sur votre système local à l\u0026rsquo;adresse \u0026lsquo;http://localhost:7657\u0026rsquo; et restera disponible tant que votre session SSH est active.\nSi vous souhaitez démarrer une session SSH sans lancer de shell sur le système distant, vous pouvez ajouter l\u0026rsquo;option \u0026lsquo;-N\u0026rsquo; :\nssh -NL 7657:localhost:7657 (System_IP) Méthode 2 : Configurer votre console pour qu\u0026rsquo;elle soit accessible sur une adresse IP publique avec un nom d\u0026rsquo;utilisateur et un mot de passe\nOuvrez ~/.i2p/clients.config et remplacez :\nclientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ par :\nclientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ où vous remplacez (System_IP) par l\u0026rsquo;adresse IP publique de votre système\nAllez sur http://localhost:7657/configui et ajoutez un nom d\u0026rsquo;utilisateur et un mot de passe pour la console si vous le souhaitez - L\u0026rsquo;ajout d\u0026rsquo;un nom d\u0026rsquo;utilisateur et d\u0026rsquo;un mot de passe est fortement recommandé pour sécuriser votre console I2P contre les manipulations, qui pourraient conduire à une désanonymisation.\nAccédez à http://localhost:7657/index et cliquez sur \u0026ldquo;Graceful restart\u0026rdquo;, ce qui redémarre la JVM et recharge les applications clientes\nUne fois démarré, vous devriez maintenant pouvoir accéder à votre console à distance. Chargez la console du router à l\u0026rsquo;adresse http://(System_IP):7657 et vous serez invité à saisir le nom d\u0026rsquo;utilisateur et le mot de passe que vous avez spécifiés à l\u0026rsquo;étape 2 ci-dessus si votre navigateur prend en charge la fenêtre d\u0026rsquo;authentification.\nNOTE : Vous pouvez spécifier 0.0.0.0 dans la configuration ci-dessus. Cela spécifie une interface, pas un réseau ou un masque de réseau. 0.0.0.0 signifie \u0026ldquo;se lier à toutes les interfaces\u0026rdquo;, il peut donc être accessible sur 127.0.0.1:7657 ainsi que sur n\u0026rsquo;importe quelle IP LAN/WAN. Soyez prudent lors de l\u0026rsquo;utilisation de cette option car la console sera disponible sur TOUTES les adresses configurées sur votre système.\nComment puis-je utiliser des applications depuis mes autres machines ? Veuillez consulter la réponse précédente pour les instructions sur l\u0026rsquo;utilisation du transfert de port SSH, et consultez également cette page dans votre console : http://localhost:7657/configi2cp Est-il possible d\u0026rsquo;utiliser I2P comme proxy SOCKS ? Le proxy SOCKS est fonctionnel depuis la version 0.7.1. SOCKS 4/4a/5 sont pris en charge. I2P n\u0026rsquo;a pas d\u0026rsquo;outproxy SOCKS, son utilisation est donc limitée à I2P uniquement.\nDe nombreuses applications divulguent des informations sensibles qui pourraient vous identifier sur Internet et c\u0026rsquo;est un risque dont il faut être conscient lors de l\u0026rsquo;utilisation du proxy SOCKS I2P. I2P filtre uniquement les données de connexion, mais si le programme que vous avez l\u0026rsquo;intention d\u0026rsquo;utiliser envoie ces informations en tant que contenu, I2P n\u0026rsquo;a aucun moyen de protéger votre anonymat. Par exemple, certaines applications de messagerie enverront l\u0026rsquo;adresse IP de la machine sur laquelle elles s\u0026rsquo;exécutent à un serveur de messagerie. Nous recommandons des outils ou applications spécifiques à I2P (comme I2PSnark pour les torrents), ou des applications dont il est connu qu\u0026rsquo;elles sont sûres à utiliser avec I2P, qui incluent des plugins populaires disponibles sur Firefox .\nComment accéder à IRC, BitTorrent ou d\u0026rsquo;autres services sur Internet classique ? Il existe des services appelés Outproxies qui font le pont entre I2P et Internet, comme les nœuds de sortie Tor. La fonctionnalité outproxy par défaut pour HTTP et HTTPS est fournie par exit.stormycloud.i2p et est gérée par StormyCloud Inc. Elle est configurée dans le proxy HTTP. De plus, pour aider à protéger l\u0026rsquo;anonymat, I2P ne vous permet pas par défaut d\u0026rsquo;établir des connexions anonymes vers Internet classique. Veuillez consulter la page Socks Outproxy pour plus d\u0026rsquo;informations.\nReseeds Mon routeur fonctionne depuis plusieurs minutes et n\u0026rsquo;a aucune connexion ou très peu de connexions Vérifiez d\u0026rsquo;abord la page http://127.0.0.1:7657/netdb dans la Console du Routeur – votre base de données réseau. Si vous ne voyez aucun routeur listé depuis I2P mais que la console indique que vous devriez être derrière un pare-feu, alors vous ne pouvez probablement pas vous connecter aux serveurs reseed. Si vous voyez d\u0026rsquo;autres routeurs I2P listés, essayez de réduire le nombre de connexions maximum http://127.0.0.1:7657/config peut-être que votre routeur ne peut pas gérer autant de connexions.\nComment réamorcer manuellement ? Dans des circonstances normales, I2P vous connectera automatiquement au réseau en utilisant nos liens de démarrage. Si une perturbation d\u0026rsquo;Internet empêche le démarrage depuis les serveurs reseed, un moyen facile de démarrer est d\u0026rsquo;utiliser le navigateur Tor (par défaut, il s\u0026rsquo;ouvre sur localhost), qui fonctionne très bien avec http://127.0.0.1:7657/configreseed . Il est également possible de réamorcer (reseed) un routeur I2P manuellement.\nLors de l\u0026rsquo;utilisation du navigateur Tor pour réamorcer (reseed), vous pouvez sélectionner plusieurs URL à la fois et continuer. Bien que la valeur par défaut qui est de 2 (parmi les multiples URL) fonctionne également, elle sera lente.\nConfidentialité-Sécurité Mon routeur est-il un \u0026ldquo;nœud de sortie\u0026rdquo; (outproxy) vers l\u0026rsquo;Internet régulier ? Je ne veux pas qu\u0026rsquo;il le soit. Non, votre router participe au transport du trafic chiffré de bout en bout à travers le réseau i2p vers un point de terminaison de tunnel aléatoire, généralement pas un outproxy, mais aucun trafic n\u0026rsquo;est transmis entre votre router et Internet au niveau de la couche transport. En tant qu\u0026rsquo;utilisateur final, vous ne devriez pas exécuter un outproxy si vous n\u0026rsquo;êtes pas compétent en administration système et réseau.\nEst-il facile de détecter l\u0026rsquo;utilisation d\u0026rsquo;I2P en analysant le trafic réseau ? Le trafic I2P ressemble généralement à du trafic UDP, et pas beaucoup plus – et faire en sorte qu\u0026rsquo;il ne ressemble pas à beaucoup plus est un objectif. Il prend également en charge TCP. Avec un certain effort, l\u0026rsquo;analyse passive du trafic peut être en mesure de classifier le trafic comme « I2P », mais nous espérons que le développement continu de l\u0026rsquo;obscurcissement du trafic réduira cela davantage. Même une couche d\u0026rsquo;obscurcissement de protocole assez simple comme obfs4 empêchera les censeurs de bloquer I2P (c\u0026rsquo;est un objectif que I2P déploie).\nL\u0026rsquo;utilisation d\u0026rsquo;I2P est-elle sûre ? Cela dépend de votre modèle de menace personnel. Pour la plupart des gens, I2P est beaucoup plus sûr que de ne pas utiliser de protection du tout. Certains autres réseaux (comme Tor, mixminion/mixmaster) sont probablement plus sûrs contre certains adversaires. Par exemple, le trafic I2P n\u0026rsquo;utilise pas TLS/SSL, il n\u0026rsquo;a donc pas les problèmes du \u0026ldquo;maillon le plus faible\u0026rdquo; que Tor a. I2P a été utilisé par beaucoup de personnes en Syrie lors du \u0026ldquo;Printemps arabe\u0026rdquo;, et récemment le projet a connu une croissance plus importante dans les installations linguistiques plus petites d\u0026rsquo;I2P au Proche et Moyen-Orient. Le point le plus important à noter ici est qu\u0026rsquo;I2P est une technologie et vous avez besoin d\u0026rsquo;un guide/tutoriel pour améliorer votre vie privée/anonymat sur Internet. Vérifiez également votre navigateur ou importez le moteur de recherche d\u0026rsquo;empreintes numériques pour bloquer les attaques par empreinte numérique avec un ensemble de données très important (c\u0026rsquo;est-à-dire : longues traînes typiques / structure de données diversifiée très précise) concernant de nombreux éléments d\u0026rsquo;environnement et n\u0026rsquo;utilisez pas de VPN pour réduire tous les risques qui en découlent comme le comportement du cache TLS lui-même et la construction technique de l\u0026rsquo;entreprise fournisseur qui peut être piratée plus facilement qu\u0026rsquo;un système de bureau personnel. L\u0026rsquo;utilisation d\u0026rsquo;un Tor V-Browser isolé avec ses excellentes protections anti-empreintes numériques et une protection appguard globale en temps réel n\u0026rsquo;autorisant que les communications système nécessaires et une dernière utilisation en VM avec des scripts de désactivation anti-espionnage et un live-CD pour supprimer tout \u0026ldquo;risque presque permanent possible\u0026rdquo; et réduire tous les risques par une probabilité décroissante peuvent être une bonne option dans un réseau public et un modèle de risque individuel élevé et pourraient être le mieux que vous puissiez faire avec cet objectif pour l\u0026rsquo;utilisation d\u0026rsquo;I2P.\nJe vois les adresses IP de tous les autres nœuds I2P dans la console du routeur. Cela signifie-t-il que mon adresse IP est visible par les autres ? Oui, pour les autres nœuds I2P qui connaissent votre router. Nous utilisons cela pour nous connecter avec le reste du réseau I2P. Les adresses sont physiquement situées dans des objets \u0026ldquo;routerInfos (clé,valeur)\u0026rdquo;, soit récupérés à distance, soit reçus d\u0026rsquo;un pair. Les \u0026ldquo;routerInfos\u0026rdquo; contiennent certaines informations (certaines ajoutées de manière opportuniste et optionnelle), \u0026ldquo;publiées par le pair\u0026rdquo;, concernant le router lui-même pour le démarrage. Aucune donnée concernant les clients n\u0026rsquo;est présente dans cet objet. En regardant de plus près sous le capot, vous constaterez que tout le monde est comptabilisé avec le nouveau type de création d\u0026rsquo;identifiants appelé \u0026ldquo;hachages SHA-256 (low=hachage positif(-clé), high=hachage négatif(+clé))\u0026rdquo;. Le réseau I2P possède sa propre base de données de routerInfos créée lors du téléchargement et de l\u0026rsquo;indexation, mais cela dépend profondément de la réalisation des tables clé/valeur et de la topologie du réseau ainsi que de l\u0026rsquo;état de charge / état de bande passante et des probabilités de routage pour les stockages dans les composants de base de données.\nL\u0026rsquo;utilisation d\u0026rsquo;un outproxy est-elle sûre ? Cela dépend de votre définition de « sûr ». Les outproxies sont excellents lorsqu\u0026rsquo;ils fonctionnent, mais malheureusement ils sont gérés volontairement par des personnes qui peuvent perdre leur intérêt ou ne pas avoir les ressources nécessaires pour les maintenir 24h/24 et 7j/7 – veuillez noter que vous pourriez connaître des périodes pendant lesquelles les services sont indisponibles, interrompus ou peu fiables, et nous ne sommes pas associés à ce service et n\u0026rsquo;avons aucune influence sur celui-ci.\nLes outproxys eux-mêmes peuvent voir votre trafic entrant et sortant, à l\u0026rsquo;exception des données HTTPS/SSL chiffrées de bout en bout, tout comme votre FAI peut voir votre trafic entrant et sortant de votre ordinateur. Si vous faites confiance à votre FAI, ce ne serait pas pire avec l\u0026rsquo;outproxy.\nQu\u0026rsquo;en est-il des attaques de « désanonymisation » ? Pour une explication très détaillée, consultez nos articles sur le Modèle de menace . En général, la désanonymisation n\u0026rsquo;est pas triviale, mais possible si vous n\u0026rsquo;êtes pas suffisamment prudent.\nAccès Internet/Performances Je ne peux pas accéder aux sites Internet classiques via I2P. Le proxy vers les sites Internet (eepsites qui sont accessibles sur Internet) est fourni en tant que service aux utilisateurs I2P par des fournisseurs non-bloquants. Ce service n\u0026rsquo;est pas l\u0026rsquo;objectif principal du développement d\u0026rsquo;I2P, et est fourni sur une base volontaire. Les eepsites hébergés sur I2P devraient toujours fonctionner sans outproxy. Les outproxies sont une commodité mais ils ne sont pas parfaits par conception et ne constituent pas une grande partie du projet. Sachez qu\u0026rsquo;ils peuvent ne pas être en mesure de fournir le service de haute qualité que d\u0026rsquo;autres services d\u0026rsquo;I2P peuvent offrir.\nJe ne peux pas accéder aux sites https:// ou ftp:// via I2P. Le proxy HTTP par défaut prend en charge uniquement la redirection sortante HTTP et HTTPS.\nPourquoi mon routeur utilise-t-il trop de CPU ? Tout d\u0026rsquo;abord, assurez-vous d\u0026rsquo;avoir la dernière version de chaque composant lié à I2P – les versions plus anciennes contenaient des sections de code consommant inutilement du processeur. Il existe également un journal des performances qui documente certaines des améliorations des performances d\u0026rsquo;I2P au fil du temps.\nMes pairs actifs / pairs connus / tunnels participants / connexions / bande passante varient considérablement dans le temps ! Y a-t-il un problème ? La stabilité générale du réseau I2P est un domaine de recherche en cours. Une partie importante de cette recherche se concentre sur la façon dont de petits changements dans les paramètres de configuration modifient le comportement du router. Comme I2P est un réseau pair-à-pair, les actions des autres pairs auront une influence sur les performances de votre router.\nQu\u0026rsquo;est-ce qui rend les téléchargements, les torrents, la navigation web et tout le reste plus lents sur I2P par rapport à l\u0026rsquo;internet classique ? I2P dispose de différentes protections qui ajoutent un routage supplémentaire et des couches de chiffrement additionnelles. Il fait également rebondir le trafic à travers d\u0026rsquo;autres pairs (Tunnels) qui ont leur propre vitesse et qualité, certains sont lents, d\u0026rsquo;autres rapides. Cela ajoute beaucoup de surcharge et de trafic à différents rythmes dans différentes directions. Par conception, tous ces éléments le rendent plus lent par rapport à une connexion directe sur Internet, mais beaucoup plus anonyme et toujours suffisamment rapide pour la plupart des usages.\nCi-dessous un exemple présenté avec une explication pour aider à fournir un contexte sur les considérations de latence et de bande passante lors de l\u0026rsquo;utilisation d\u0026rsquo;I2P.\nConsidérez le diagramme ci-dessous. Il représente une connexion entre un client effectuant une requête via I2P, un serveur recevant la requête via I2P puis répondant également via I2P. Le circuit emprunté par la requête est également représenté.\nD\u0026rsquo;après le diagramme, considérons que les boîtes étiquetées \u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo; et \u0026lsquo;R\u0026rsquo; représentent un tunnel sortant pour \u0026lsquo;A\u0026rsquo; et que les boîtes étiquetées \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; et \u0026lsquo;Z\u0026rsquo; représentent un tunnel sortant pour \u0026lsquo;B\u0026rsquo;. De même, les boîtes étiquetées \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; et \u0026lsquo;Z\u0026rsquo; représentent un tunnel entrant pour \u0026lsquo;B\u0026rsquo; tandis que les boîtes étiquetées \u0026lsquo;P_1\u0026rsquo;, \u0026lsquo;Q_1\u0026rsquo; et \u0026lsquo;R_1\u0026rsquo; représentent un tunnel entrant pour \u0026lsquo;A\u0026rsquo;. Les flèches entre les boîtes indiquent le sens du trafic. Le texte au-dessus et en dessous des flèches détaille quelques exemples de bande passante entre une paire de sauts ainsi que des exemples de latences.\nLorsque le client et le serveur utilisent tous deux des tunnels à 3 sauts tout au long du processus, un total de 12 autres routeurs I2P sont impliqués dans le relais du trafic. 6 pairs relayent le trafic du client vers le serveur, qui est divisé en un tunnel sortant à 3 sauts depuis \u0026lsquo;A\u0026rsquo; (\u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;R\u0026rsquo;) et un tunnel entrant à 3 sauts vers \u0026lsquo;B\u0026rsquo; (\u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;). De même, 6 pairs relayent le trafic du serveur vers le client.\nTout d\u0026rsquo;abord, nous pouvons considérer la latence - le temps nécessaire pour qu\u0026rsquo;une requête d\u0026rsquo;un client traverse le réseau I2P, atteigne le serveur et revienne au client. En additionnant toutes les latences, nous constatons que :\n40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms Le temps d\u0026rsquo;aller-retour total dans notre exemple s\u0026rsquo;élève à 740 ms - certainement beaucoup plus élevé que ce que l\u0026rsquo;on observerait normalement en naviguant sur des sites web Internet classiques.\nDeuxièmement, nous pouvons considérer la bande passante disponible. Celle-ci est déterminée par le lien le plus lent entre les sauts du client au serveur ainsi que lorsque le trafic est transmis par le serveur vers le client. Pour le trafic allant du client vers le serveur, nous voyons que la bande passante disponible dans notre exemple entre les sauts \u0026lsquo;R\u0026rsquo; \u0026amp; \u0026lsquo;X\u0026rsquo; ainsi qu\u0026rsquo;entre les sauts \u0026lsquo;X\u0026rsquo; \u0026amp; \u0026lsquo;Y\u0026rsquo; est de 32 KB/s. Malgré une bande passante disponible plus élevée entre les autres sauts, ces sauts agiront comme un goulot d\u0026rsquo;étranglement et limiteront la bande passante maximale disponible pour le trafic de \u0026lsquo;A\u0026rsquo; à \u0026lsquo;B\u0026rsquo; à 32 KB/s. De même, en traçant le chemin du serveur vers le client, on constate qu\u0026rsquo;il y a une bande passante maximale de 64 KB/s - entre les sauts \u0026lsquo;Z_1\u0026rsquo; \u0026amp; \u0026lsquo;Y_1\u0026rsquo;, \u0026lsquo;Y_1\u0026rsquo; \u0026amp; \u0026lsquo;X_1\u0026rsquo; et \u0026lsquo;Q_1\u0026rsquo; \u0026amp; \u0026lsquo;P_1\u0026rsquo;.\nNous recommandons d\u0026rsquo;augmenter vos limites de bande passante. Cela aide le réseau en augmentant la quantité de bande passante disponible, ce qui améliorera en retour votre expérience I2P. Les paramètres de bande passante se trouvent sur la page http://localhost:7657/config . Veuillez tenir compte des limites de votre connexion internet déterminées par votre FAI, et ajustez vos paramètres en conséquence.\nNous recommandons également de définir une quantité suffisante de bande passante partagée - cela permet aux tunnels participants d\u0026rsquo;être routés via votre routeur I2P. Autoriser le trafic participant maintient votre routeur bien intégré dans le réseau et améliore vos vitesses de transfert.\nI2P est un projet en cours de développement. De nombreuses améliorations et corrections sont mises en œuvre et, de manière générale, utiliser la dernière version améliorera vos performances. Si ce n\u0026rsquo;est pas déjà fait, installez la dernière version.\nJe pense avoir trouvé un bug, où puis-je le signaler ? Vous pouvez signaler tout bug ou problème que vous rencontrez sur notre système de suivi des bugs, qui est accessible à la fois sur Internet classique et sur I2P. Nous avons un forum de discussion, également disponible sur I2P et sur Internet classique. Vous pouvez également rejoindre notre canal IRC : soit via notre réseau IRC, IRC2P, soit sur Freenode.\nNotre Bugtracker : Internet non privé : https://i2pgit.org/I2P_Developers/i2p.i2p/issues Sur I2P : http://git.idk.i2p/I2P_Developers/i2p.i2p/issues Nos forums : i2pforum.i2p Coller les logs : Vous pouvez coller tous les logs intéressants sur un service de partage tel que les services internet non privés listés sur le Wiki PrivateBin , ou un service de partage I2P tel que cette instance PrivateBin ou ce service de partage sans Javascript et faire un suivi sur IRC dans #i2p IRC : Rejoignez #i2p-dev Discutez avec les développeurs sur IRC Veuillez inclure les informations pertinentes de la page des journaux du router disponible à : http://127.0.0.1:7657/logs . Nous vous demandons de partager tout le texte de la section « I2P Version and Running Environment » ainsi que toutes les erreurs ou avertissements affichés dans les différents journaux présents sur la page.\nJ\u0026rsquo;ai une question ! Génial ! Retrouvez-nous sur IRC :\nsur irc.freenode.net canal #i2p sur IRC2P canal #i2p ou postez sur le forum et nous le publierons ici (avec la réponse, espérons-le).\n","description":"FAQ complète I2P : aide du router, configuration, reseeds, confidentialité/sécurité, performance et dépannage","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"Questions fréquemment posées","url":"/fr/docs/overview/faq/"},{"categories":null,"content":"Aperçu I2P construit des tunnels temporaires et unidirectionnels — des séquences ordonnées de routeurs qui transmettent du trafic chiffré. Les tunnels sont classés comme entrants (les messages circulent vers le créateur) ou sortants (les messages circulent depuis le créateur).\nUn échange typique achemine le message d\u0026rsquo;Alice à travers l\u0026rsquo;un de ses tunnels sortants, ordonne au point de sortie de le transférer vers la passerelle de l\u0026rsquo;un des tunnels entrants de Bob, puis Bob le reçoit à son point d\u0026rsquo;entrée.\nA : Gateway sortant (Alice) B : Participant sortant C : Point terminal sortant D : Gateway entrant E : Participant entrant F : Point terminal entrant (Bob) Les tunnels ont une durée de vie fixe de 10 minutes et transportent des messages de taille fixe de 1024 octets (1028 octets en incluant l\u0026rsquo;en-tête du tunnel) afin d\u0026rsquo;empêcher l\u0026rsquo;analyse de trafic basée sur la taille des messages ou les modèles temporels.\nVocabulaire des tunnels Tunnel gateway: Premier router dans un tunnel. Pour les tunnels entrants, l\u0026rsquo;identité de ce router apparaît dans le LeaseSet publié. Pour les tunnels sortants, le gateway est le router d\u0026rsquo;origine (A et D ci-dessus). Tunnel endpoint: Dernier router dans un tunnel (C et F ci-dessus). Tunnel participant: Router intermédiaire dans un tunnel (B et E ci-dessus). Les participants ne peuvent pas déterminer leur position ni la direction du tunnel. Tunnel n-hop: Nombre de sauts inter-router. 0-hop: Gateway et endpoint sont le même router – anonymat minimal. 1-hop: Gateway se connecte directement au endpoint – faible latence, faible anonymat. 2-hop: Par défaut pour les tunnels exploratoires ; sécurité/performance équilibrée. 3-hop: Recommandé pour les applications nécessitant un anonymat élevé. Tunnel ID: Entier de 4 octets unique par router et par saut, choisi aléatoirement par le créateur. Chaque saut reçoit et transmet sur des ID différents. Informations de construction de tunnel Les routeurs remplissant les rôles de passerelle, participant et point de terminaison reçoivent différents enregistrements dans le Tunnel Build Message. I2P moderne prend en charge deux méthodes :\nElGamal (ancien, enregistrements de 528 octets) ECIES-X25519 (actuel, enregistrements de 218 octets via Short Tunnel Build Message – STBM) Information Distributed to Participants Le gateway reçoit : - Clé de couche tunnel (clé AES-256 ou ChaCha20 selon le type de tunnel) - Clé IV du tunnel (pour chiffrer les vecteurs d\u0026rsquo;initialisation) - Clé de réponse et IV de réponse (pour le chiffrement de la réponse de construction) - ID du tunnel (gateways entrants uniquement) - Hash d\u0026rsquo;identité du prochain saut et ID du tunnel (si non-terminal)\nLes participants intermédiaires reçoivent : - La clé de couche tunnel et la clé IV pour leur saut - L\u0026rsquo;ID du tunnel et les informations sur le prochain saut - La clé de réponse et l\u0026rsquo;IV pour le chiffrement de la réponse de construction\nLes endpoints reçoivent : - Les clés de couche tunnel et IV - Le routeur de réponse et l\u0026rsquo;ID du tunnel (endpoints sortants uniquement) - La clé de réponse et l\u0026rsquo;IV (endpoints sortants uniquement)\nPour plus de détails, consultez la Spécification de création de tunnel et la Spécification de création de tunnel ECIES .\nTunnel Pooling Les routeurs regroupent les tunnels en pools de tunnels pour la redondance et la distribution de charge. Chaque pool maintient plusieurs tunnels parallèles, permettant le basculement lorsqu\u0026rsquo;un tunnel échoue. Les pools utilisés en interne sont les tunnels exploratoires (exploratory tunnels), tandis que les pools spécifiques aux applications sont les tunnels clients (client tunnels).\nChaque destination maintient des pools entrants et sortants séparés, configurés par les options I2CP (nombre de tunnels, nombre de sauvegardes, longueur et paramètres QoS). Les routeurs surveillent l\u0026rsquo;état des tunnels, effectuent des tests périodiques et reconstruisent automatiquement les tunnels défaillants pour maintenir la taille du pool.\nMutualisation des tunnels Tunnels à 0 saut : Offrent uniquement un déni plausible. Le trafic provient toujours du même router et s\u0026rsquo;y termine — déconseillé pour toute utilisation anonyme.\nTunnels à 1 saut : Offrent une anonymité de base contre les observateurs passifs mais sont vulnérables si un adversaire contrôle ce saut unique.\nTunnels à 2 sauts : Incluent deux routeurs distants et augmentent considérablement le coût d\u0026rsquo;une attaque. Par défaut pour les pools exploratoires.\nTunnels à 3 sauts : Recommandés pour les applications nécessitant une protection robuste de l\u0026rsquo;anonymat. Des sauts supplémentaires ajoutent de la latence sans gain de sécurité significatif.\nPar défaut : Les routeurs utilisent des tunnels exploratoires à 2 sauts et des tunnels clients spécifiques aux applications à 2 ou 3 sauts, équilibrant performance et anonymat.\nLongueur du tunnel Les routeurs testent périodiquement les tunnels en envoyant un DeliveryStatusMessage à travers un tunnel sortant vers un tunnel entrant. Si le test échoue, les deux tunnels reçoivent un poids de profil négatif. Des échecs consécutifs marquent un tunnel comme inutilisable ; le routeur reconstruit alors un remplaçant et publie un nouveau LeaseSet. Les résultats alimentent les métriques de capacité des pairs utilisées par le système de sélection des pairs .\nTest des tunnels Les routeurs construisent des tunnels en utilisant une méthode de telescoping non interactive : un seul message Tunnel Build se propage saut par saut. Chaque saut déchiffre son enregistrement, ajoute sa réponse et transmet le message. Le saut final renvoie la réponse de construction agrégée via un chemin différent, empêchant la corrélation. Les implémentations modernes utilisent des Short Tunnel Build Messages (STBM) pour ECIES et des Variable Tunnel Build Messages (VTBM) pour les chemins legacy. Chaque enregistrement est chiffré par saut en utilisant ElGamal ou ECIES-X25519.\nCréation de tunnel Le trafic des tunnels utilise un chiffrement multi-couches. Chaque saut ajoute ou retire une couche de chiffrement au fur et à mesure que les messages traversent le tunnel.\nTunnels ElGamal : AES-256/CBC pour les charges utiles avec remplissage PKCS#5. Tunnels ECIES : ChaCha20 ou ChaCha20-Poly1305 pour le chiffrement authentifié. Chaque saut possède deux clés : une clé de couche et une clé IV. Les routeurs déchiffrent l\u0026rsquo;IV, l\u0026rsquo;utilisent pour traiter la charge utile, puis rechiffrent l\u0026rsquo;IV avant de le transmettre. Ce schéma de double IV empêche le marquage des messages.\nLes passerelles sortantes pré-déchiffrent toutes les couches afin que les points de terminaison reçoivent du texte en clair après que tous les participants aient ajouté le chiffrement. Les tunnels entrants chiffrent dans la direction opposée. Les participants ne peuvent pas déterminer la direction ou la longueur du tunnel.\nChiffrement des tunnels Durées de vie des tunnels dynamiques et dimensionnement adaptatif des pools pour l\u0026rsquo;équilibrage de charge réseau Stratégies alternatives de test des tunnels et diagnostics individuels des sauts Validation optionnelle par preuve de travail ou certificat de bande passante (implémenté dans l\u0026rsquo;API 0.9.65+) Recherche sur le façonnage du trafic et l\u0026rsquo;insertion de chaff pour le mélange des points de terminaison Retrait progressif d\u0026rsquo;ElGamal et migration vers ECIES-X25519 Développement en cours Spécification d\u0026rsquo;implémentation de tunnel Spécification de création de tunnel (ElGamal) Spécification de création de tunnel (ECIES-X25519) Spécification des messages de tunnel Garlic Routing Base de données réseau I2P (netDb) Profilage et sélection des pairs Modèle de menace I2P Chiffrement ElGamal/AES + SessionTag Options I2CP ","description":"Aperçu de la terminologie, construction et cycle de vie des tunnels I2P","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"Routage de Tunnel","url":"/fr/docs/overview/tunnel-routing/"},{"categories":null,"content":" 1. Aperçu général Le garlic routing reste l\u0026rsquo;une des innovations fondamentales d\u0026rsquo;I2P, combinant le chiffrement en couches, le regroupement de messages et les tunnels unidirectionnels. Bien que conceptuellement similaire au onion routing, il étend le modèle en regroupant plusieurs messages chiffrés (\u0026ldquo;cloves\u0026rdquo;) dans une seule enveloppe (\u0026ldquo;garlic\u0026rdquo;), améliorant l\u0026rsquo;efficacité et l\u0026rsquo;anonymat.\nLe terme garlic routing a été inventé par Michael J. Freedman dans la thèse de Master de Roger Dingledine sur Free Haven (juin 2000, §8.1.1). Les développeurs I2P ont adopté ce terme au début des années 2000 pour refléter ses améliorations en matière de regroupement et son modèle de transport unidirectionnel, le distinguant de la conception à commutation de circuits de Tor.\nRésumé : Garlic routing = chiffrement en couches + regroupement de messages + livraison anonyme via des tunnels unidirectionnels.\n2. La terminologie \u0026ldquo;Garlic\u0026rdquo; Historiquement, le terme garlic a été utilisé dans trois contextes différents au sein d\u0026rsquo;I2P :\nChiffrement en couches – protection de style onion au niveau du tunnel Regroupement de plusieurs messages – plusieurs « cloves » à l\u0026rsquo;intérieur d\u0026rsquo;un « garlic message » Chiffrement de bout en bout – anciennement ElGamal/AES+SessionTags, maintenant ECIES‑X25519‑AEAD‑Ratchet Bien que l\u0026rsquo;architecture reste intacte, le schéma de chiffrement a été complètement modernisé.\n3. Chiffrement en couches Le routage garlic partage son principe fondamental avec le routage en oignon : chaque routeur ne déchiffre qu\u0026rsquo;une seule couche de chiffrement, ne connaissant que le prochain saut et non le chemin complet.\nCependant, I2P implémente des tunnels unidirectionnels, et non des circuits bidirectionnels :\nTunnel sortant : envoie des messages à partir du créateur Tunnel entrant : transporte les messages vers le créateur Un aller-retour complet (Alice ↔ Bob) utilise quatre tunnels : outbound d\u0026rsquo;Alice → inbound de Bob, puis outbound de Bob → inbound d\u0026rsquo;Alice. Cette conception réduit de moitié l\u0026rsquo;exposition des données de corrélation par rapport aux circuits bidirectionnels.\nPour les détails d\u0026rsquo;implémentation des tunnels, voir la Spécification des Tunnels et la spécification Création de Tunnel (ECIES) .\n4. Regroupement de plusieurs messages (les \u0026ldquo;Cloves\u0026rdquo;) Le garlic routing original de Freedman envisageait de regrouper plusieurs « bulbes » chiffrés au sein d\u0026rsquo;un seul message. I2P implémente cela sous forme de cloves (gousses) à l\u0026rsquo;intérieur d\u0026rsquo;un garlic message — chaque clove possède ses propres instructions de livraison chiffrées et sa cible (router, destination ou tunnel).\nLe regroupement en garlic permet à I2P de :\nCombiner les accusés de réception et les métadonnées avec les messages de données Réduire les modèles de trafic observables Prendre en charge des structures de messages complexes sans connexions supplémentaires Figure 1 : Un Garlic Message contenant plusieurs cloves, chacun avec ses propres instructions de livraison.\nLes clous de girofle typiques incluent :\nMessage de statut de livraison — accusés de réception confirmant le succès ou l\u0026rsquo;échec de la livraison.\nCeux-ci sont enveloppés dans leur propre couche garlic pour préserver la confidentialité. Message Database Store — LeaseSets regroupés automatiquement afin que les pairs puissent répondre sans interroger à nouveau le netDb. Les cloves sont regroupés lorsque :\nUn nouveau LeaseSet doit être publié De nouvelles balises de session sont livrées Aucun regroupement n\u0026rsquo;a eu lieu récemment (~1 minute par défaut) Les messages garlic permettent une livraison de bout en bout efficace de plusieurs composants chiffrés dans un seul paquet.\n5. Évolution du chiffrement 5.1 Historical Context La documentation ancienne (≤ v0.9.12) décrivait le chiffrement ElGamal/AES+SessionTags : - ElGamal 2048 bits encapsulant les clés de session AES - AES‑256/CBC pour le chiffrement de la charge utile - Balises de session de 32 octets utilisées une fois par message\nCe système cryptographique est obsolète.\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) Entre 2019 et 2023, I2P a migré entièrement vers ECIES‑X25519‑AEAD‑Ratchet. La pile moderne standardise les composants suivants :\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains Avantages de la migration ECIES : Confidentialité persistante via des clés de ratchet par message Taille de charge utile réduite par rapport à ElGamal Résilience contre les avancées cryptanalytiques Compatibilité avec les futurs hybrides post-quantiques (voir Proposition 169) Détails supplémentaires : voir la spécification ECIES et la spécification EncryptedLeaseSet .\n6. LeaseSets and Garlic Bundling Les enveloppes garlic incluent fréquemment des leaseSets pour publier ou mettre à jour l\u0026rsquo;accessibilité des destinations.\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively Tous les LeaseSets sont distribués via la *floodfill DHT* maintenue par des routeurs spécialisés. Les publications sont vérifiées, horodatées et limitées en débit pour réduire la corrélation des métadonnées. Voir la documentation de la base de données réseau pour plus de détails.\n7. Modern “Garlic” Applications within I2P Le chiffrement basé sur garlic encryption et le regroupement de messages sont utilisés dans toute la pile de protocoles I2P :\nCréation et utilisation de tunnels — chiffrement en couches par saut Livraison de messages de bout en bout — messages garlic groupés avec accusés de réception clonés et cloves LeaseSet Publication dans la Network Database — LeaseSets encapsulés dans des enveloppes garlic pour la confidentialité Transports SSU2 et NTCP2 — chiffrement de sous-couche utilisant le framework Noise et les primitives X25519/ChaCha20 Le garlic routing est donc à la fois une méthode de chiffrement en couches et un modèle de messagerie réseau.\n6. LeaseSets et Garlic Bundling Le centre de documentation d\u0026rsquo;I2P est disponible ici , maintenu en continu. Les spécifications pertinentes incluent :\nSpécification ECIES — ECIES‑X25519‑AEAD‑Ratchet Création de tunnel (ECIES) — protocole moderne de construction de tunnel Spécification I2NP — formats de message I2NP Spécification SSU2 — transport UDP SSU2 Structures communes — comportement netDb et floodfill Validation académique : Hoang et al. (IMC 2018, USENIX FOCI 2019) et Muntaka et al. (2025) confirment la stabilité architecturale et la résilience opérationnelle de la conception d\u0026rsquo;I2P.\n7. Applications « Garlic » modernes au sein d\u0026rsquo;I2P Propositions en cours :\nProposition 169 : Hybride post-quantique (ML-KEM 512/768/1024 + X25519) Proposition 168 : Optimisation de la bande passante du transport Mises à jour datagramme et streaming : Gestion améliorée de la congestion Les adaptations futures pourraient inclure des stratégies supplémentaires de délai de message ou une redondance multi-tunnel au niveau du garlic-message, en s\u0026rsquo;appuyant sur des options de livraison inutilisées décrites à l\u0026rsquo;origine par Freedman.\n8. Documentation actuelle et références Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. ","description":"Comprendre la terminologie, l'architecture et l'implémentation moderne du routage en ail (garlic routing) dans I2P","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"Routage en bulbe d'ail (Garlic Routing)","url":"/fr/docs/overview/garlic-routing/"},{"categories":null,"content":" Obsolète : SAM v1 est conservée uniquement à des fins de référence historique. Les nouvelles applications devraient utiliser SAM v3 ou BOB . La passerelle d\u0026rsquo;origine ne prend en charge que les destinations DSA-SHA1 et un jeu d\u0026rsquo;options limité.\nBibliothèques L’arborescence du code source Java d’I2P inclut encore des liaisons héritées pour C, C#, Perl et Python. Elles ne sont plus maintenues et sont principalement distribuées afin d’assurer la compatibilité avec les archives.\nNégociation de version Les clients se connectent via TCP (par défaut 127.0.0.1:7656) et échangent:\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 À partir de Java I2P 0.9.14, le paramètre MIN est facultatif et MIN/MAX acceptent tous deux des formes à un chiffre (\u0026quot;3\u0026quot; etc.) pour les ponts mis à niveau.\nCréation de session SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name charge ou crée une entrée dans sam.keys; TRANSIENT crée toujours une destination temporaire. STYLE sélectionne des flux virtuels (de type TCP), des datagrammes signés ou des datagrammes bruts. DIRECTION s’applique uniquement aux sessions de flux; la valeur par défaut est BOTH. Des paires clé/valeur supplémentaires sont transmises comme options I2CP (par exemple, tunnels.quantityInbound=3). Le pont répond :\nSESSION STATUS RESULT=OK DESTINATION=name Les échecs renvoient DUPLICATED_DEST, I2P_ERROR ou INVALID_KEY, plus un message facultatif.\nFormats de messages Les messages SAM sont en ASCII sur une seule ligne, avec des paires clé/valeur séparées par des espaces. Les clés sont en UTF‑8 ; les valeurs peuvent être entre guillemets si elles contiennent des espaces. Aucun mécanisme d’échappement n’est défini.\nTypes de communication :\nFlux – acheminés via la bibliothèque de streaming I2P Datagrammes répondables – charges utiles signées (Datagram1) Datagrammes bruts – charges utiles non signées (Datagram RAW) Options ajoutées dans la version 0.9.14 DEST GENERATE accepte SIGNATURE_TYPE=... (permettant Ed25519, etc.) HELLO VERSION considère MIN comme facultatif et accepte des chaînes de version à un seul chiffre Quand utiliser SAM v1 Uniquement pour l’interopérabilité avec des logiciels hérités qui ne peuvent pas être mis à jour. Pour tout nouveau développement, utilisez :\nSAM v3 pour un accès complet en fonctionnalités aux flux/datagrammes BOB pour la gestion des destinations (encore limité, mais prend en charge des fonctionnalités plus modernes) Références SAM v2 SAM v3 Spécification des datagrammes Protocole de streaming SAM v1 a jeté les bases du développement d’applications indépendant du router, mais l’écosystème a évolué. Considérez ce document comme une aide à la compatibilité plutôt qu’un point de départ.\n","description":"Protocole hérité Simple Anonymous Messaging (déprécié)","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM v1","url":"/fr/docs/legacy/sam/"},{"categories":null,"content":" Obsolète : SAM v2 a été livré avec I2P 0.6.1.31 et n’est plus maintenu. Utilisez SAM v3 pour tout nouveau développement. La seule amélioration de la v2 par rapport à la v1 était la prise en charge de plusieurs sockets multiplexés sur une seule connexion SAM.\nNotes de version La chaîne de version indiquée reste \u0026quot;2.0\u0026quot;. Depuis 0.9.14, le message HELLO VERSION accepte des valeurs MIN/MAX d’un seul chiffre et le paramètre MIN est facultatif. DEST GENERATE prend en charge SIGNATURE_TYPE, de sorte que des destinations Ed25519 peuvent être créées. Notions de base sur les sessions SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] Chaque destination ne peut avoir qu’une seule session SAM active (flux, datagrammes ou mode brut). STYLE sélectionne des flux virtuels, des datagrammes signés ou des datagrammes bruts. Des options supplémentaires sont transmises à I2CP (par exemple, tunnels.quantityInbound=3). Les réponses sont identiques à la v1 : SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY. Encodage des messages ASCII organisé par lignes, avec des paires key=value séparées par des espaces (les valeurs peuvent être entre guillemets). Les types de communication sont les mêmes que dans la v1 :\nFlux via la bibliothèque de streaming I2P Datagrammes avec possibilité de réponse (PROTO_DATAGRAM) Datagrammes bruts (PROTO_DATAGRAM_RAW) Quand l’utiliser Uniquement pour les anciens clients qui ne peuvent pas migrer. SAM v3 propose :\nTransfert de destination binaire (DEST GENERATE BASE64) Sous-sessions et prise en charge de la DHT (table de hachage distribuée) (v3.3) Meilleur signalement des erreurs et négociation des options Reportez-vous à :\nSAM v1 SAM v3 API des datagrammes Protocole de diffusion en continu ","description":"Ancien protocole Simple Anonymous Messaging (SAM, protocole d'interface client d'I2P)","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2","url":"/fr/docs/legacy/samv2/"},{"categories":null,"content":"SAM v3 (« Simple Anonymous Messaging ») est l\u0026rsquo;API stable et indépendante du routeur actuelle qui permet aux applications externes de communiquer avec le réseau I2P sans intégrer le routeur lui-même. Elle fournit un accès unifié aux flux, datagrammes et messages bruts, et reste la couche pont canonique pour les logiciels non-Java.\n1. Aperçu et objectif SAM v3 permet aux développeurs de créer des logiciels compatibles I2P dans n\u0026rsquo;importe quel langage en utilisant un protocole TCP/UDP léger. Il abstrait les composants internes du router, exposant un ensemble minimal de commandes via TCP (7656) et UDP (7655). Java I2P et i2pd implémentent tous deux des sous-ensembles de la spécification SAM v3, bien qu\u0026rsquo;i2pd ne dispose toujours pas de la plupart des extensions 3.2 et 3.3 en 2025.\n2. Historique des versions Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. ### Note sur la nomenclature Java I2P utilise PRIMARY/SUBSESSION. i2pd et I2P+ continuent d\u0026rsquo;utiliser la terminologie héritée MASTER/SUBSESSION pour la rétrocompatibilité. 3. Flux de travail principal Négociation de version HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 Création de destination DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512). Fortement recommandé depuis I2P 0.9.15. Création de session SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4 est X25519 (ECIES X25519 AEAD Ratchet) et 0 est le repli ElGamal pour la compatibilité. Quantités de tunnels explicites pour la cohérence : Java I2P par défaut 2, i2pd par défaut 5. Opérations du protocole STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 Les types de messages principaux incluent : STREAM CONNECT, STREAM ACCEPT, STREAM FORWARD, DATAGRAM SEND, RAW SEND, NAMING LOOKUP, DEST LOOKUP, PING, QUIT.\nArrêt gracieux QUIT 4. Différences d\u0026rsquo;implémentation (Java I2P vs i2pd) Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 **Recommandation :** Spécifiez toujours explicitement les quantités de tunnels pour garantir la cohérence entre les routeurs. 5. Bibliothèques prises en charge (instantané 2025) Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance ## 6. Fonctionnalités à venir et nouvelles (2024–2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ ## 7. Notes de sécurité et de configuration Lier SAM à 127.0.0.1 uniquement. Pour les services persistants, utiliser des sessions PRIMARY avec des clés statiques. Utiliser HELLO VERSION pour tester la prise en charge des fonctionnalités. Utiliser PING ou NAMING LOOKUP pour vérifier la disponibilité du router. Éviter les connexions SAM distantes non authentifiées (pas de TLS dans i2pd). 8. Références et Spécifications Spécification SAM v3 SAM v2 (Hérité) Spécification Streaming Datagrammes Centre de Documentation Documentation i2pd 9. Résumé SAM v3 reste le protocole de pont recommandé pour toutes les applications I2P non Java. Il offre stabilité, liaisons multi-langages et performances cohérentes sur tous les types de routeurs.\nLors du développement avec SAM : - Utilisez les signatures Ed25519 et le chiffrement X25519. - Vérifiez la prise en charge des fonctionnalités de manière dynamique via HELLO VERSION. - Concevez pour la compatibilité, en particulier lors de la prise en charge des routeurs Java I2P et i2pd.\n","description":"Protocole bridge stable pour les applications I2P non-Java","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/fr/docs/api/samv3/"},{"categories":null,"content":"Vue d\u0026rsquo;ensemble Ce document spécifie un schéma de signature re-randomisable, adapté à la création de Destinations (adresses I2P) pouvant être aveuglées. Il peut en outre être utilisé pour aveugler des Destinations Ed25519 existantes, avec une légère réduction d’efficacité.\nRed25519 est pleinement opérationnel dans les routers I2P depuis la version 0.9.39 (publiée le 21 mars 2019). Cette spécification a été finalisée dans la version 0.9.47 (août 2020) après 17 mois de déploiement en production. Le schéma de signature fonctionne en tant que type de signature 11 (RedDSA_SHA512_Ed25519) sur le réseau I2P.\nMotivation La Proposition 123 (New netDB Entries) définit un format de LeaseSet2 chiffré qui incarne le principe de moindre autorité : chaque participant du réseau ne reçoit que les informations nécessaires à son rôle. En particulier, un LeaseSet2 chiffré publié sur un floodfill ne révèle pas la Destination (identité publique I2P) à laquelle il est destiné, et les Leases ne peuvent être consultés que par une personne ayant une connaissance préalable de la Destination. Toutefois, les floodfills doivent toujours pouvoir authentifier les LeaseSet2 chiffrés au moment de leur publication, et les clients doivent en outre s’assurer que cette authentification a bien été assurée par la Destination elle-même.\nLa proposition 123 y parvient en aveuglant les clés de signature des Destinations (identités de service I2P). Les clés aveuglées peuvent être utilisées pour créer des signatures vérifiables par les floodfills, et les clients peuvent être certains que seule la Destination peut les avoir créées. Il est donc nécessaire de spécifier un schéma de signature pouvant être utilisé pour l’aveuglement.\nNote sur l\u0026rsquo;état de la Proposition 123: Des parties de la Proposition 123 ont été implémentées et déployées progressivement depuis la version 0.9.38, avec la prise en charge de Red25519 ajoutée dans la version 0.9.39. La fonctionnalité LeaseSet2 chiffrée est prête pour la production et est utilisée activement sur le réseau I2P pour des services cachés à confidentialité renforcée.\nConception Schéma de signature principal Le schéma de signature spécifié ici, Red25519, est une instanciation de RedDSA telle que définie à la section 5.4.6 de la Spécification du protocole Zcash (Sapling et ultérieures). RedDSA est un schéma de signature basé sur Schnorr qui prend en charge la ré-randomisation des clés. Il fournit les fonctions suivantes :\nGENERATE_PRIVATE() : Renvoie une clé privée tirée uniformément au hasard.\nDERIVE_PUBLIC(sk) : Renvoie la clé publique correspondant à la clé privée donnée.\nGENERATE_RANDOM() : Renvoie un scalaire aléatoire approprié pour rerandomiser une paire de clés.\nRANDOMIZE_PRIVATE(sk, alpha) : Ré-randomise une clé privée, en utilisant un scalaire secret alpha.\nRANDOMIZE_PUBLIC(vk, alpha) : Re-randomise une clé publique à l\u0026rsquo;aide d\u0026rsquo;un scalaire secret alpha.\nSIGN(sk, m) : Renvoie une signature générée par la clé privée sk sur le message m donné.\nVERIFY(vk, m, sig) : Vérifie la signature sig par rapport à la clé publique vk et au message m. Renvoie vrai si la signature est valide, faux sinon.\nPour une paire de clés donnée (sk, vk), la relation suivante est vérifiée :\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) Conversion des clés Ed25519 en Red25519 Les clés Ed25519 PEUVENT faire l’objet d’une conversion unidirectionnelle temporaire en clés Red25519, afin de permettre la ré-aléatorisation de Destinations Ed25519 existantes. Les autres types de signature ne sont pas compatibles.\nNous définissons les fonctions de conversion suivantes :\nCONVERT_ED25519_PRIVATE(privkey) : Renvoie la clé privée Red25519 correspondante à la clé privée Ed25519 fournie.\nCONVERT_ED25519_PUBLIC(pubkey) : Renvoie la clé publique Red25519 correspondant à la clé publique Ed25519 fournie.\nPour une paire de clés Ed25519 donnée (privkey, pubkey), la relation suivante est vérifiée :\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) Spécification Définitions B : Le point de base Ed25519 comme dans RFC 8032 .\nL : L\u0026rsquo;ordre d\u0026rsquo;Ed25519 2^252 + 27742317777372353535851937790883648493 tel que défini dans RFC 8032 .\n[s] B : Multiplication scalaire à base fixe du point de base par s.\n[s] A : Multiplication scalaire à base variable de A par s.\nx || y : Concatène deux tableaux d\u0026rsquo;octets x et y.\nRed25519 Le schéma Red25519 est une spécialisation de RedDSA avec :\nG := le groupe des points sur la forme Edwards de Curve25519. En particulier, cela signifie que Red25519 utilise le sous-groupe d\u0026rsquo;ordre premier L, et le cofacteur h_G vaut 8. P_G := le point de base Ed25519 B. l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) Remarque sur le choix de la fonction de hachage: Red25519 utilise SHA-512 plutôt que BLAKE2b-512 (comme dans RedDSA de Zcash). Ce choix de conception est compensé par la protection par préfixage de longueur décrite ci-dessous. La proposition I2P 148 suggère une migration future vers BLAKE2b-512 pour une protection renforcée contre Duplicate Message Identification (DMI, identification des messages dupliqués) et Length Extension Attacks (LEA, attaques par extension de longueur), ainsi qu’une amélioration des performances.\nRedDSA suppose que H(x) est instanciée avec une fonction de hachage cryptographique résistante aux attaques par extension de longueur. SHA-512 ne satisfait pas à cette exigence à elle seule. Pour y remédier, nous exigeons que les messages soient précédés d’un encodage à préfixe libre de leur longueur:\nlen_u16(M) || M où len_u16(M) est la représentation sur 2 octets de la longueur de M, en little-endian (afin d\u0026rsquo;être cohérent avec l\u0026rsquo;encodage little-endian des scalaires et des points).\nLes messages ne doivent pas dépasser 65534 octets. Une longueur de 65535 est réservée pour d\u0026rsquo;éventuelles extensions futures.\nNote de sécurité: L\u0026rsquo;inclusion de la clé publique (vk) dans la fonction de hachage, combinée à 80 octets aléatoires lors de la signature, garantit une protection contre les vulnérabilités SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack — non-forgeabilité forte avec clés re-randomisées sous attaque par message choisi) découvertes dans les premières conceptions de RedDSA. Cette implémentation intègre les correctifs de sécurité issus de l\u0026rsquo;audit Zcash de NCC Group (Finding NCC-Zcash2018-009).\nEncodage et décodage Les clés privées Red25519 sont des scalaires modulo L, encodés en représentation little-endian (octet de poids faible en premier). Nous définissons les fonctions DECODE_SCALAR et ENCODE_SCALAR pour convertir entre la représentation en tableau d’octets et la représentation entière d’un scalaire.\nLes clés publiques Red25519 sont des points sur la forme Edwards de Curve25519. Elles sont encodées comme la représentation little-endian sur 255 bits de la coordonnée y (ordre des octets du moins significatif au plus significatif), suivie d’un seul bit indiquant le signe de la coordonnée x. Il s’agit du même encodage que pour Ed25519. Nous définissons les fonctions DECODE_POINT et ENCODE_POINT pour passer entre la représentation en tableau d’octets et la représentation par coordonnées d’un point.\nFonctions RedDSA Pour faciliter l\u0026rsquo;implémentation, nous détaillons explicitement ci-dessous les fonctions RedDSA (ainsi que plusieurs fonctions utilitaires) déjà spécialisées pour Red25519. Les implémenteurs devraient se référer à la section 5.4.6 de la spécification du protocole Zcash pour la spécification générale des fonctions RedDSA.\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() Fonctions de conversion CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey Notez que l’implémentation de CONVERT_ED25519_PRIVATE est équivalente au calcul du scalaire secret s lors de la dérivation d’une clé publique Ed25519 à partir d’une clé privée Ed25519, comme spécifié aux étapes 1 à 3 de la section 5.1.5 de RFC 8032 .\nImplications en matière de sécurité Rerandomiser une Destination Red25519 et ensuite créer des signatures avec celle‑ci ne divulgue aucune information sur la Destination, car la distribution des clés privées Red25519 générées via RANDOMIZE_PRIVATE est identique à la distribution des clés privées générées via GENERATE_PRIVATE, et DERIVE_PUBLIC est déterministe.\nLa conversion des clés privées Ed25519 en Red25519 via CONVERT_ED25519_PRIVATE ne produit pas la même distribution. Cependant, nous jugeons la diminution du niveau de sécurité acceptable pour les raisons suivantes :\nL’espace des scalaires Ed25519 représente environ la moitié de la taille de l’espace des scalaires Red25519 (il existe 2^251 scalaires Ed25519 possibles, et L ~= 2^252 scalaires Red25519 possibles). Par conséquent, la perte de sécurité est au plus d’un facteur d’environ 2, soit environ 1 bit (car nous aurions pu, par coïncidence, choisir un scalaire Red25519 qui est aussi un scalaire Ed25519 valide). Les Destinations Ed25519 existantes ont déjà été exposées par le passé sur le réseau, et il faut partir du principe que des floodfills malveillants les ont déjà recensées. Important: Les utilisateurs préoccupés par cette réduction de sécurité devraient utiliser Red25519 (type de signature 11) comme sigtype (type de signature) pour leurs Destinations plutôt que Ed25519 (type de signature 7).\nNotez que l’argument ci-dessus ne s’applique pas au scalaire alpha de ré-randomisation ; des informations sur la clé sont divulguées chaque fois qu’un alpha biaisé est choisi, car la ré-randomisation additive se comporte comme un masque jetable.\nStatut de l\u0026rsquo;audit de sécurité Divulgation importante: I2P, y compris Red25519 (instanciation de RedDSA spécifique à I2P), n\u0026rsquo;a jamais fait l\u0026rsquo;objet d\u0026rsquo;un audit de sécurité formel par une tierce partie. La conception sous-jacente RedDSA (algorithme de signature numérique de type Schnorr utilisé notamment par Zcash) a fait l\u0026rsquo;objet d\u0026rsquo;un examen de sécurité par NCC Group dans le cadre de l\u0026rsquo;audit du protocole Sapling de Zcash en 2018, au cours duquel des problèmes de sécurité ont été identifiés et corrigés. Cependant, l\u0026rsquo;instanciation spécifique d\u0026rsquo;I2P avec SHA-512 (au lieu de BLAKE2b-512) et la séparation de domaines propre à I2P n\u0026rsquo;ont pas fait l\u0026rsquo;objet d\u0026rsquo;une analyse indépendante.\nL’implémentation de référence ed25519-java par str4d a fait l’objet d’un audit par un tiers indépendant, mais celui-ci a précédé l’implémentation de Red25519 et ne couvrait que les fonctionnalités d’Ed25519, pas les extensions Red25519.\nLes utilisateurs qui déploient Red25519 (algorithme de signature) devraient comprendre cette limitation et évaluer les compromis de sécurité en fonction de leur modèle de menace.\nCompatibilité Les versions d\u0026rsquo;I2P qui prennent en charge Red25519 (algorithme de signature EdDSA sur Curve25519 utilisé par I2P) (version 0.9.39 et ultérieures) pourront vérifier les structures de données du réseau qui sont signées avec Red25519. Les versions d\u0026rsquo;I2P qui ne prennent pas en charge Red25519 le traiteront comme une signature inconnue et PEUVENT rejeter les structures de données.\nChronologie du déploiement: - 0.9.39 (mars 2019): Première implémentation avec prise en charge du LS2 chiffré dans les floodfills - 0.9.40 (mai 2019): Autorisation par client pour le LS2 chiffré - 0.9.41 (août 2019): Meta LS2 et LS2 chiffré avec des clés hors ligne - 0.9.43 (février 2020): Prise en charge du b32 pour le LS2 chiffré - 0.9.47 (août 2020): Finalisation de la spécification - 2.10.0 (octobre 2025): Version actuelle du réseau (équivalente à 0.9.67+)\nLes utilisateurs devraient s’attendre à ce que la fiabilité des structures de données signées Red25519 soit bonne pour les cas d’utilisation d’Encrypted LeaseSet2 (LeaseSet2 chiffré), car le réseau a eu plus de six ans pour se mettre à niveau depuis la mise en œuvre initiale. Cependant, les indicateurs d’adoption concernant l’usage général des destinations ne sont pas disponibles publiquement.\nCas d’utilisation principal: Red25519 est principalement utilisé pour la fonctionnalité LeaseSet2 chiffrée où l’aveuglement de clé est requis. Pour les destinations standard sans exigences de leaseset chiffré, Ed25519 (signature type 7) reste le choix recommandé en raison d’une compatibilité plus large et d’un historique éprouvé plus long.\nNotes d\u0026rsquo;implémentation Red25519 est implémenté dans le router Java d’I2P à net.i2p.crypto.eddsa.RedDSAEngine et utilise la bibliothèque ed25519-java de str4d (Jack Grigg) en tant que dépendance Maven net.i2p.crypto:eddsa (versions 0.1.0 à 0.3.0).\nL’implémentation C++ d’i2pd prend également en charge Red25519 (signaturetype=11) pour la publication de LeaseSet chiffrés.\nExemple de configuration pour i2pd :\nsignaturetype=11 i2cp.leaseSetType=5 Compatibilité du LeaseSet2 chiffré: La spécification du LeaseSet chiffré exige que la clé publique de signature dans l\u0026rsquo;unblinded destination (destination désaveuglée) soit Ed25519 (type de signature 7) ou Red25519 (type de signature 11). Aucun autre type de signature n\u0026rsquo;est pris en charge pour la fonctionnalité de LeaseSet chiffré.\nVecteurs de test Les vecteurs de test suivants sont fournis pour la validation de l\u0026rsquo;implémentation. Chaque vecteur comprend :\nedsk: Clé privée Ed25519 (aléatoire) edpk: Clé publique Ed25519 correspondante à edsk sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: Message à signer sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) Note d\u0026rsquo;implémentation: Ces vecteurs de test devraient être intégrés dans des suites de tests unitaires automatisées pour une validation continue. Les implémenteurs devraient vérifier que toutes les conversions, signatures et opérations de ré-randomisation correspondent à ces valeurs attendues.\nVecteur de test 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 Vecteur de test 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f Remarque: Les vecteurs de test supplémentaires 3 à 10 suivent le même format et se trouvent dans l’implémentation de référence.\nRéférences Proposition 123 : Nouvelles entrées netDB - Parties mises en œuvre et déployées dans les versions 0.9.38, 0.9.39 et ultérieures Spécification du protocole Zcash, section 5.4.6 : RedDSA, RedJubjub et RedPallas - RedDSA est défini dans la spécification du protocole Zcash ; audit de sécurité par NCC Group (janvier 2019) RFC 8032 : Algorithme de signature numérique à courbe d\u0026rsquo;Edwards (EdDSA) Proposition 148 : RedDSA-BLAKE2b-Ed25519 - Proposé mais pas encore implémenté ; suggère une migration future vers BLAKE2b-512 Spécification du LeaseSet chiffré Spécification de la cryptographie de bas niveau ","description":"Schéma de signature ré-randomisable pour créer des Destinations aveuglées","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"Schéma de signature Red25519","url":"/fr/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":"Vue d\u0026rsquo;ensemble Routers vérifient automatiquement la disponibilité de mises à jour en interrogeant un flux d’actualités signé, distribué via le réseau I2P. Lorsqu’une version plus récente est annoncée, le router télécharge une archive de mise à jour signée cryptographiquement (.su3) et la prépare pour l’installation. Ce système garantit une distribution des versions officielles authentifiée, résistante aux altérations et multicanale.\nÀ partir d’I2P 2.10.0, le système de mise à jour utilise: - RSA-4096 / SHA-512 signatures - Format de conteneur SU3 (remplaçant les anciens SUD/SU2) - Miroirs redondants: HTTP dans le réseau I2P, HTTPS en clearnet (Internet public), et BitTorrent\n1. Fil d\u0026rsquo;actualité Les routers interrogent périodiquement le flux Atom signé à intervalles de quelques heures afin de découvrir de nouvelles versions et des avis de sécurité. Le flux est signé et distribué sous la forme d’un fichier .su3, qui peut inclure :\n\u0026lt;i2p:version\u0026gt; — nouveau numéro de version \u0026lt;i2p:minVersion\u0026gt; — version minimale prise en charge du router \u0026lt;i2p:minJavaVersion\u0026gt; — environnement d\u0026rsquo;exécution Java minimal requis \u0026lt;i2p:update\u0026gt; — énumère plusieurs miroirs de téléchargement (I2P, HTTPS, torrent) \u0026lt;i2p:revocations\u0026gt; — données de révocation de certificats \u0026lt;i2p:blocklist\u0026gt; — listes de blocage au niveau du réseau pour les pairs compromis Distribution du flux Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load Les routers privilégient le flux I2P, mais peuvent basculer vers le clearnet (Internet public) ou une distribution par torrent si nécessaire. 2. Formats de fichiers SU3 (Norme actuelle) Introduit en 0.9.9, SU3 a remplacé les anciens formats SUD et SU2. Chaque fichier contient un en-tête, une charge utile et une signature en fin de fichier.\nStructure de l\u0026rsquo;en-tête \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Field\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Magic\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I2Psu3\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Format Version\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;e.g., \u0026lt;code\u0026gt;0x000B\u0026lt;/code\u0026gt; (RSA-SHA512-4096)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Length\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;512 bytes\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Version String\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Router version\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signer ID\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Certificate name\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Content Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;1 = router update, 3 = reseed, 4 = news feed\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Étapes de vérification de la signature 1. Analyser l\u0026rsquo;en-tête et identifier l\u0026rsquo;algorithme de signature. 2. Vérifier le hachage et la signature à l\u0026rsquo;aide du certificat du signataire stocké. 3. Confirmer que le signataire n\u0026rsquo;est pas révoqué. 4. Comparer la chaîne de version intégrée avec les métadonnées de la charge utile.\nLes routers sont livrés avec des certificats de signataire de confiance (actuellement zzz et str4d) et rejettent toutes les sources non signées ou révoquées.\nSU2 (Obsolète) Utilisait l\u0026rsquo;extension .su2 avec des fichiers JAR compressés avec Pack200 (format de compression Java). Supprimé après que Java 14 a déprécié Pack200 (JEP 367). Désactivé dans I2P 0.9.48+; désormais entièrement remplacé par la compression ZIP. SUD (ancien) Ancien format ZIP signé DSA-SHA1 (avant 0.9.9). Aucun identifiant de signataire ni en-tête, intégrité limitée. Remplacé en raison d\u0026rsquo;une cryptographie faible et de l\u0026rsquo;absence de contrainte de version. 3. Flux de mise à jour 3.1 Vérification de l’en-tête Routers ne récupèrent que l’en-tête SU3 pour vérifier la chaîne de version avant de télécharger les fichiers complets. Cela évite de gaspiller de la bande passante sur des miroirs périmés ou des versions obsolètes.\n3.2 Téléchargement complet Après vérification de l’en-tête, le router télécharge le fichier .su3 complet depuis: - Miroirs eepsite intra-réseau (préféré) - Miroirs HTTPS clearnet (solution de repli) - BitTorrent (distribution facultative assistée par les pairs)\nLes téléchargements utilisent des clients HTTP I2PTunnel standard, avec réessais, gestion des délais d\u0026rsquo;expiration et repli sur un miroir.\n3.3 Vérification de la signature Chaque fichier téléchargé est soumis à: - Contrôle de la signature: Vérification RSA-4096/SHA512 - Correspondance de version: Vérification de la version de l\u0026rsquo;en-tête par rapport à celle de la charge utile - Prévention de la rétrogradation: Garantit que la mise à jour est plus récente que la version installée\nLes fichiers invalides ou non correspondants sont immédiatement rejetés.\n3.4 Préparation de l\u0026rsquo;installation Après vérification: 1. Extraire le contenu du ZIP dans un répertoire temporaire 2. Supprimer les fichiers répertoriés dans deletelist.txt 3. Remplacer les bibliothèques natives si lib/jbigi.jar est présent 4. Copier les certificats des signataires dans ~/.i2p/certificates/ 5. Renommer la mise à jour en i2pupdate.zip afin qu\u0026rsquo;elle soit appliquée au prochain redémarrage\nLa mise à jour s’installe automatiquement au prochain démarrage ou lorsque vous déclenchez manuellement « Installer la mise à jour maintenant ».\n4. Gestion des fichiers deletelist.txt Une liste en texte brut des fichiers obsolètes à supprimer avant d’extraire les nouveaux contenus.\nRègles: - Un chemin par ligne (chemins relatifs uniquement) - Lignes commençant par # ignorées - .. et chemins absolus rejetés\nBibliothèques natives Pour éviter des binaires natifs périmés ou incompatibles : - Si lib/jbigi.jar existe, les anciens fichiers .so ou .dll sont supprimés - Assure que les bibliothèques spécifiques à la plateforme sont fraîchement extraites\n5. Gestion des certificats Routers peuvent recevoir de nouveaux certificats de signature au moyen de mises à jour ou de révocations transmises par le flux d’actualités.\nLes nouveaux fichiers .crt sont copiés dans le répertoire des certificats. Les certificats révoqués sont supprimés avant les vérifications ultérieures. Prend en charge la rotation des clés sans nécessiter d\u0026rsquo;intervention manuelle de l\u0026rsquo;utilisateur. Toutes les mises à jour sont signées hors ligne à l\u0026rsquo;aide de air-gapped signing systems (systèmes de signature isolés du réseau). Les clés privées ne sont jamais stockées sur les serveurs de build.\n6. Directives pour les développeurs Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. Les prochaines versions exploreront l’intégration de signatures post-quantiques (voir la proposition 169) et des compilations reproductibles. 7. Vue d\u0026rsquo;ensemble de la sécurité Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity --- 8. Versionnage Router: 2.10.0 (API 0.9.67) Versionnage sémantique avec Major.Minor.Patch. L\u0026rsquo;application d\u0026rsquo;une version minimale empêche les mises à niveau dangereuses. Java pris en charge : Java 8–17. À partir de 2.11.0+, Java 17+ sera requis. ","description":"Mécanisme de mise à jour signé et sécurisé et structure du flux pour les routers I2P","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"Spécification de mise à jour logicielle","url":"/fr/docs/specs/updates/"},{"categories":null,"content":"1. Vue d\u0026rsquo;ensemble SSU2 est un protocole de couche de transport basé sur UDP, utilisé pour des communications sécurisées et semi-fiables de router à router dans I2P. Ce n’est pas un transport polyvalent, mais il est spécialisé pour l’échange de messages I2NP.\nCapacités fondamentales Échange de clés authentifié via le Noise XK pattern (modèle XK de Noise) En-têtes chiffrés pour résister à l’inspection approfondie des paquets (DPI) Traversée de NAT à l’aide de relais et de hole punching (perforation de NAT) Migration de connexion et validation d’adresse Validation de chemin facultative Confidentialité persistante (forward secrecy) et protection contre les attaques par rejeu Prise en charge de l’existant et compatibilité Implementation SSU2 Default SSU1 Removed i2pd2.44.02.44.0 Java I2P0.9.560.9.61 SSU1 n'est plus utilisé dans l'ensemble du réseau public I2P. 2. Cryptographie SSU2 utilise Noise_XK_25519_ChaChaPoly_SHA256 avec des extensions spécifiques à I2P.\nFunction Algorithm Notes Diffie-HellmanX25519 (RFC 7748)32-byte keys CipherChaCha20/Poly1305 (RFC 7539)AEAD encryption HashSHA-256Used for key derivation and message integrity KDFHKDF-SHA256 (RFC 5869)For session and header keys Les en-têtes et les charges utiles sont liés cryptographiquement via `mixHash()`. Toutes les primitives cryptographiques sont partagées avec NTCP2 et ECIES (schéma de chiffrement intégré sur courbe elliptique) pour des raisons d’efficacité d’implémentation. 3. Vue d\u0026rsquo;ensemble des messages 3.1 Règles des datagrammes UDP Chaque datagramme UDP transporte exactement un message SSU2. Les messages « Session Confirmed » (confirmation de session) peuvent être fragmentés sur plusieurs datagrammes. Taille minimale : 40 octets Taille maximale : 1472 octets (IPv4) / 1452 octets (IPv6)\n3.2 Types de messages Type Message Header Description 0Session Request32BHandshake initiation 1Session Created32BHandshake response 2Session Confirmed16BFinal handshake, may be fragmented 6Data16BEncrypted I2NP message blocks 7Peer Test32BNAT reachability testing 9Retry32BToken or rejection notice 10Token Request32BRequest for validation token 11Hole Punch32BNAT traversal signaling --- 4. Établissement de session 4.1 Flux standard (jeton valide) Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 Obtention d\u0026rsquo;un jeton Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 Jeton invalide Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. Structures d\u0026rsquo;en-tête 5.1 En-tête long (32 octets) Utilisés avant l’établissement de la session (SessionRequest, Created, Retry, PeerTest, TokenRequest, HolePunch).\nField Size Description Destination Connection ID8Random unique ID Packet Number4Random (ignored during handshake) Type1Message type Version1Always 2 NetID12 = main I2P network Flags1Reserved (0) Source Connection ID8Random ID distinct from destination Token8Token for address validation ### 5.2 En-tête court (16 octets) Utilisé lors de sessions établies (SessionConfirmed, Data).\nField Size Description Destination Connection ID8Stable throughout session Packet Number4Incrementing per message Type1Message type (2 or 6) Flags3ACK/fragment flags --- 6. Chiffrement 6.1 AEAD (chiffrement authentifié avec données associées) Toutes les charges utiles sont chiffrées avec ChaCha20/Poly1305 AEAD :\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) Nonce: 12 octets (4 zéros + 8 octets de compteur) Tag: 16 octets Données associées: incluent l\u0026rsquo;en-tête pour la liaison d\u0026rsquo;intégrité 6.2 Protection de l\u0026rsquo;en-tête Les en-têtes sont masqués à l’aide d’un flux de clés ChaCha20 dérivé des clés d’en-tête de session. Cela garantit que tous les identifiants de connexion et les champs des paquets semblent aléatoires, offrant une résistance à l’inspection approfondie des paquets (DPI).\n6.3 Dérivation de clé Phase Input Output InitialintroKey + salthandshake header key HandshakeDH(X25519)chainKey + AEAD key Data phasechainKeyTX/RX keys Key rotationoldKeynewKey --- 7. Sécurité et prévention des attaques par rejeu Les jetons sont par adresse IP et expirent après ~60 secondes. Les attaques par rejeu sont empêchées à l\u0026rsquo;aide de filtres de Bloom par session. Les clés éphémères en double sont rejetées. Les en-têtes et les charges utiles sont liés cryptographiquement. Les routers doivent rejeter tout paquet ne passant pas l\u0026rsquo;authentification AEAD ou dont la version ou le NetID (identifiant de réseau) est invalide.\n8. Numérotation des paquets et durée de vie de la session Chaque direction maintient son propre compteur 32 bits. - Commence à 0, s\u0026rsquo;incrémente à chaque paquet. - Ne doit pas déborder ; renouveler les clés de session ou terminer la session avant d\u0026rsquo;atteindre 2³².\nLes identifiants de connexion restent inchangés pendant toute la session, y compris lors de la migration.\n9. Phase de données Type = 6 (Données) En-tête court (16 octets) La charge utile contient un ou plusieurs blocs chiffrés: Listes d\u0026rsquo;ACK/NACK Fragments de message I2NP Bourrage (0–31 octets aléatoires) Blocs de terminaison (optionnels) La retransmission sélective et la livraison hors séquence sont prises en charge. La fiabilité reste « semi-fiable » — les paquets manquants peuvent être abandonnés silencieusement après dépassement des limites de réessais.\n10. Relais et traversée de NAT Message Type Purpose Peer Test7Determines inbound reachability Retry9Issues new token or rejection Token Request10Requests new address token Hole Punch11Coordinates NAT hole punching Les routers relais aident les pairs derrière des NAT restrictifs en utilisant ces messages de contrôle. 11. Fin de session Chaque pair peut fermer la session en utilisant un Termination block (bloc de terminaison) dans un Data message (message de données). Les ressources doivent être libérées immédiatement après réception. Les paquets de terminaison répétés peuvent être ignorés après l\u0026rsquo;accusé de réception.\n12. Directives de mise en œuvre Routers DOIVENT: - Vérifier que la version = 2 et que le NetID = 2. - Ignorer les paquets \u0026lt;40 octets ou avec AEAD invalide. - Appliquer un cache anti-rejeu de 120s. - Refuser les jetons réutilisés ou les clés éphémères réutilisées.\nRouters DEVRAIENT: - Randomiser le bourrage de 0–31 octets. - Utiliser une retransmission adaptative (RFC 6298). - Implémenter une validation de chemin pour chaque pair avant la migration.\n13. Synthèse de la sécurité Property Achieved By Forward secrecyX25519 ephemeral keys Replay protectionTokens + Bloom filter Authenticated encryptionChaCha20/Poly1305 KCI resistanceNoise XK pattern DPI resistanceEncrypted headers NAT traversalRelay + Hole Punch MigrationStatic connection IDs --- 14. Références Proposition 159 – SSU2 Noise Protocol Framework RFC 9000 – Transport QUIC RFC 9001 – QUIC TLS RFC 7539 – ChaCha20/Poly1305 AEAD RFC 7748 – X25519 ECDH RFC 5869 – HKDF-SHA256 ","description":"Version 2 du protocole de transport UDP semi-fiable sécurisé","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"Spécification de SSU2","url":"/fr/docs/specs/ssu2/"},{"categories":null,"content":"Vue d’ensemble Ce document spécifie le format de fichier blockfile (fichier en blocs) d\u0026rsquo;I2P et les tables dans le hostsdb.blockfile utilisées par le Blockfile Naming Service (service de nommage Blockfile). Pour le contexte, voir Nommage I2P et carnet d\u0026rsquo;adresses .\nLe blockfile (fichier par blocs) permet d\u0026rsquo;effectuer des recherches de destinations rapides dans un format binaire compact. Par rapport à l\u0026rsquo;ancien système hosts.txt:\nLes destinations sont stockées en binaire, pas en Base64. Des métadonnées arbitraires (p. ex., date d’ajout, source, commentaires) peuvent être attachées. Les temps de recherche sont environ 10× plus rapides. L’utilisation du disque augmente modestement. Un blockfile (fichier de blocs) est une collection sur disque d’associations triées (paires clé-valeur) implémentée sous forme de skiplists (listes à sauts). Ce format est dérivé de la Metanotion Blockfile Database . Cette spécification définit d’abord la structure du fichier, puis décrit comment il est utilisé par le BlockfileNamingService.\nLe Blockfile Naming Service (service de nommage au format blockfile) a remplacé l\u0026rsquo;ancienne implémentation hosts.txt à partir de I2P 0.8.8. \u0026gt; Lors de l\u0026rsquo;initialisation, il importe des entrées depuis privatehosts.txt, userhosts.txt, et hosts.txt.\nFormat Blockfile (format de fichier par blocs) Le format se compose de pages de 1024 octets, chacune préfixée par un nombre magique pour garantir l\u0026rsquo;intégrité. Les pages sont numérotées à partir de 1:\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) Tous les entiers utilisent **l'ordre des octets réseau (big-endian, octet de poids fort en premier)**. Les valeurs sur 2 octets sont non signées ; les valeurs sur 4 octets (numéros de page) sont signées et doivent être positives. Gestion des threads: La base de données est conçue pour un accès monothread; BlockfileNamingService assure la synchronisation.\nFormat du superbloc Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused --- Format de page de bloc de liste à sauts Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused --- Format de page de bloc à niveau de saut Chaque niveau a une portée, mais toutes les portées n\u0026rsquo;ont pas de niveau.\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused --- Format de page du bloc Skip Span Les paires clé/valeur sont triées par clé sur l’ensemble des spans (segments). Les spans autres que le premier ne doivent pas être vides.\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures --- Format de page de bloc de continuation de Span (étendue) Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures --- Format de structure clé-valeur Pour la clé et la valeur, les champs de longueur ne peuvent pas s\u0026rsquo;étendre sur plusieurs pages (les 4 octets doivent tous tenir). S\u0026rsquo;il ne reste pas assez d\u0026rsquo;espace, ajoutez jusqu\u0026rsquo;à 3 octets de remplissage et continuez à l\u0026rsquo;offset (décalage) 8 de la page suivante.\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each --- Format de la page de la liste des blocs libres Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) --- Format du bloc de page libre Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused --- Méta-index Situé à la page 2. Associe des chaînes US-ASCII → entiers de 4 octets. La clé est le nom de la liste à sauts ; la valeur est l\u0026rsquo;index de page.\nTables du service de noms Blockfile Le service définit plusieurs skiplists (listes à sauts). Chaque plage prend en charge jusqu\u0026rsquo;à 16 entrées.\nListe à sauts des propriétés %%__INFO__%% contient une entrée :\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping Champs typiques : Property Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) --- Liste à sauts de recherche inverse %%__REVERSE__%% contient des entrées de type Entier → Propriétés (depuis DB v2).\nClé: Les 4 premiers octets du hachage SHA-256 de la Destination. Valeur: Objet Properties (Mapping sérialisé). Plusieurs entrées gèrent les collisions et les Destinations à plusieurs noms d\u0026rsquo;hôte. Chaque clé de propriété = nom d\u0026rsquo;hôte; valeur = chaîne vide. Skiplists (listes à sauts) de la base de données des hôtes Chacun de hosts.txt, userhosts.txt et privatehosts.txt fait correspondre des noms d\u0026rsquo;hôte → des Destinations (identifiants de service I2P).\nLa version 4 prend en charge plusieurs destinations par nom d\u0026rsquo;hôte (fonctionnalité introduite dans I2P 0.9.26). Les bases de données de la version 3 sont migrées automatiquement.\nClé Chaîne de caractères UTF-8 (nom d\u0026rsquo;hôte, en minuscules, se terminant par .i2p)\nValeur Version 4: Nombre sur 1 octet de paires Propriété/Destination Pour chaque paire : Propriétés → Destination (binaire) Version 3: Propriétés → Destination (binaire) Propriétés de DestEntry Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) --- Notes d\u0026rsquo;implémentation La classe Java BlockfileNamingService implémente cette spécification.\nHors contexte du router, la base de données s’ouvre en lecture seule sauf si i2p.naming.blockfile.writeInAppContext=true. Non destiné à un accès multi-instance ou multi-JVM. Maintient trois tables de correspondance principales (privatehosts, userhosts, hosts) ainsi qu’une table de correspondance inversée pour des recherches rapides. Références Documentation sur le nommage et le carnet d\u0026rsquo;adresses d\u0026rsquo;I2P Spécification des structures communes Base de données Blockfile de Metanotion JavaDoc de BlockfileNamingService ","description":"Format de stockage sur disque de type blockfile (fichier en blocs) utilisé par I2P pour la résolution des noms d'hôte","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"Spécification du Blockfile (format de fichier par blocs)","url":"/fr/docs/specs/blockfile/"},{"categories":null,"content":"Vue d\u0026rsquo;ensemble Objectif ECIES-X25519-AEAD-Ratchet est le protocole moderne de chiffrement de bout en bout d’I2P, remplaçant l’ancien système ElGamal/AES+SessionTags. Il offre la confidentialité persistante (PFS), un chiffrement authentifié et des améliorations significatives en matière de performances et de sécurité.\nAméliorations clés par rapport à ElGamal/AES+SessionTags Clés plus petites : Clés de 32 octets contre clés publiques ElGamal de 256 octets (réduction de 87,5 %) Confidentialité persistante : Obtenue via DH ratcheting (mécanisme de cliquet Diffie-Hellman) (non disponible dans l\u0026rsquo;ancien protocole) Cryptographie moderne : X25519 DH, ChaCha20-Poly1305 AEAD, SHA-256 Chiffrement authentifié : Authentification intégrée via la construction AEAD (chiffrement authentifié avec données associées) Protocole bidirectionnel : Sessions entrantes/sortantes appariées, par opposition à l\u0026rsquo;ancien protocole unidirectionnel Étiquettes efficaces : Étiquettes de session de 8 octets contre étiquettes de 32 octets (réduction de 75 %) Obfuscation du trafic : L\u0026rsquo;encodage Elligator2 rend les handshakes (négociation initiale) indiscernables du trafic aléatoire Statut du déploiement Publication initiale: Version 0.9.46 (25 mai 2020) Déploiement sur le réseau: Achevé en 2020 État actuel: Mature, largement déployé (plus de 5 ans en production) Prise en charge du router: Version 0.9.46 ou supérieure requise Exigences de Floodfill: Adoption proche de 100 % pour les recherches chiffrées État de l’implémentation Entièrement implémentés: - messages New Session (NS) avec liaison - messages New Session Reply (NSR) - messages Existing Session (ES) - mécanisme de ratchet (à cliquet) DH - mécanismes à cliquet pour l’étiquette de session et la clé symétrique - blocs DateTime, NextKey, ACK, ACK Request, Garlic Clove (élément « gousse » du schéma garlic d’I2P), et de bourrage\nNon implémenté (à compter de la version 0.9.50) : - Bloc MessageNumbers (type 6) - Bloc d’options (type 5) - Bloc de terminaison (type 4) - Réponses automatiques au niveau du protocole - Zero static key mode (mode à clé statique nulle) - Sessions de multidiffusion\nRemarque: L\u0026rsquo;état d\u0026rsquo;implémentation pour les versions 1.5.0 à 2.10.0 (2021-2025) nécessite une vérification, certaines fonctionnalités ayant peut-être été ajoutées.\nFondements du protocole Cadre de protocoles Noise ECIES-X25519-AEAD-Ratchet est fondé sur le Noise Protocol Framework (révision 34, 2018-07-11), en particulier le modèle de poignée de main IK (Interactif, clé statique distante connue) avec des extensions spécifiques à I2P.\nIdentifiant du protocole Noise Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 Composants de l’identifiant: - Noise - Cadre de base - IK - Modèle de poignée de main interactive avec clé statique distante connue - elg2 - Encodage Elligator2 pour des clés éphémères (extension I2P) - +hs2 - MixHash appelée avant le deuxième message pour y intégrer le tag (extension I2P) - 25519 - Fonction Diffie-Hellman X25519 - ChaChaPoly - Chiffrement AEAD ChaCha20-Poly1305 - SHA256 - Fonction de hachage SHA-256\nSchéma de handshake Noise Notation du schéma IK:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) Sens des jetons: - e - Transmission de clé éphémère - s - Transmission de clé statique - es - DH entre la clé éphémère d\u0026rsquo;Alice et la clé statique de Bob - ss - DH entre la clé statique d\u0026rsquo;Alice et la clé statique de Bob - ee - DH entre la clé éphémère d\u0026rsquo;Alice et la clé éphémère de Bob - se - DH entre la clé statique de Bob et la clé éphémère d\u0026rsquo;Alice\nPropriétés de sécurité de Noise En termes de Noise (cadre de protocoles cryptographiques), l’IK pattern (motif IK) fournit :\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) **Niveaux d'authentification:** - **Niveau 1**: La charge utile est authentifiée comme appartenant au propriétaire de la clé statique de l'expéditeur, mais vulnérable à l'usurpation d'identité par compromission de clé (KCI) - **Niveau 2**: Résistant aux attaques KCI après NSR Niveaux de confidentialité : - Niveau 2 : Confidentialité persistante si la clé statique de l’expéditeur est ultérieurement compromise - Niveau 4 : Confidentialité persistante si la clé éphémère de l’expéditeur est ultérieurement compromise - Niveau 5 : Confidentialité persistante parfaite après la suppression des deux clés éphémères\nDifférences entre IK et XK Le schéma IK diffère du schéma XK utilisé dans NTCP2 et SSU2 :\nQuatre opérations DH: IK utilise 4 opérations DH (es, ss, ee, se) contre 3 pour XK Authentification immédiate: Alice est authentifiée dès le premier message (Niveau d’authentification 1) Confidentialité persistante plus rapide: Confidentialité persistante complète (niveau 5) atteinte après le deuxième message (1-RTT) Compromis: La charge utile du premier message n’est pas protégée par la confidentialité persistante (contrairement à XK où toutes les charges utiles le sont) Résumé: IK permet la livraison en un seul aller-retour (1-RTT) de la réponse de Bob avec une confidentialité persistante complète, au prix d\u0026rsquo;une requête initiale dépourvue de confidentialité persistante.\nConcepts du Double Ratchet (algorithme à double cliquet) de Signal ECIES (schéma de chiffrement intégré à courbe elliptique) intègre des concepts issus de l’algorithme Double Ratchet de Signal :\nCliquet DH: Assure la confidentialité persistante en échangeant périodiquement de nouvelles clés DH Cliquet à clé symétrique: Dérive de nouvelles clés de session pour chaque message Session Tag Ratchet: Génère de manière déterministe des session tags (étiquettes de session) à usage unique Principales différences par rapport à Signal: - Ratcheting (mécanisme de mise à jour progressive des clés) moins fréquent: I2P effectue le ratcheting uniquement lorsque nécessaire (proche de l’épuisement des étiquettes ou selon la politique) - Session Tags (étiquettes de session) au lieu du chiffrement d’en-tête: Utilise des étiquettes déterministes plutôt que des en-têtes chiffrés - ACK explicites (accusés de réception): Utilise des blocs d’ACK dans le même canal plutôt que de se reposer uniquement sur le trafic retour - Ratchets séparés pour les étiquettes et les clés: Plus efficace pour le récepteur (peut différer le calcul de la clé)\nExtensions d\u0026rsquo;I2P pour Noise (protocole) Encodage Elligator2: Clés éphémères encodées pour être indiscernables de données aléatoires Étiquette préfixée au NSR: Étiquette de session ajoutée avant le message NSR pour corrélation Format de charge utile défini: Structure de charge utile par blocs pour tous les types de messages Encapsulation I2NP: Tous les messages sont encapsulés dans des en-têtes I2NP Garlic Message Phase de données séparée: Les messages de transport (ES) divergent de la phase de données standard de Noise (cadre cryptographique) Primitives cryptographiques X25519 Diffie-Hellman Spécification: RFC 7748 Caractéristiques principales: - Taille de la clé privée: 32 octets - Taille de la clé publique: 32 octets - Taille du secret partagé: 32 octets - Ordre des octets: Little-endian (poids faible en premier) - Courbe: Curve25519\nOpérations:\nX25519 GENERATE_PRIVATE() Génère une clé privée aléatoire de 32 octets :\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) Dérive la clé publique correspondante:\npubkey = curve25519_scalarmult_base(privkey) Renvoie une clé publique de 32 octets en little-endian (octet le moins significatif en premier).\nX25519 DH(privkey, pubkey) Effectue un échange de clés Diffie-Hellman :\nsharedSecret = curve25519_scalarmult(privkey, pubkey) Renvoie un secret partagé de 32 octets.\nNote de sécurité: Les implémenteurs doivent vérifier que le secret partagé n’est pas entièrement composé de zéros (clé faible). Le cas échéant, rejeter et interrompre le handshake (établissement de session).\nChaCha20-Poly1305 AEAD (chiffrement authentifié avec données associées) Spécification: RFC 7539 section 2.8\nParamètres: - Taille de clé: 32 octets (256 bits) - Taille du nonce (nombre utilisé une fois): 12 octets (96 bits) - Taille du MAC: 16 octets (128 bits) - Taille de bloc: 64 octets (interne)\nFormat du Nonce (valeur aléatoire à usage unique):\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) Construction AEAD (chiffrement authentifié avec données associées):\nL\u0026rsquo;AEAD (chiffrement authentifié avec des données associées) combine le chiffrement en flux ChaCha20 avec le MAC Poly1305 :\nGénérer le flux de clés ChaCha20 à partir de la clé et du nonce (valeur unique) Chiffrer le texte en clair via XOR avec le flux de clés Calculer le MAC Poly1305 sur (données associées || texte chiffré) Ajouter à la fin du texte chiffré un MAC de 16 octets ChaCha20-Poly1305 ENCRYPT(k, n, plaintext, ad) Chiffre le texte en clair avec authentification:\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 Propriétés: - Le texte chiffré a la même longueur que le texte en clair (chiffrement par flot) - La sortie est de plaintext_length + 16 octets (inclut le MAC) - L’ensemble de la sortie est indiscernable de données aléatoires si la clé est secrète - Le MAC authentifie à la fois les données associées et le texte chiffré\nChaCha20-Poly1305 DECRYPT(k, n, ciphertext, ad) Déchiffre et vérifie l\u0026rsquo;authentification :\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext Exigences de sécurité critiques: - Nonces (nombre arbitraire utilisé une seule fois) DOIVENT être uniques pour chaque message avec la même clé - Nonces NE DOIVENT PAS être réutilisés (défaillance catastrophique en cas de réutilisation) - La vérification du MAC (code d’authentification de message) DOIT utiliser une comparaison en temps constant pour empêcher les attaques par temporisation - Une vérification du MAC échouée DOIT entraîner un rejet complet du message (aucun déchiffrement partiel)\nFonction de hachage SHA-256 Spécification: NIST FIPS 180-4\nPropriétés: - Taille de sortie: 32 octets (256 bits) - Taille de bloc: 64 octets (512 bits) - Niveau de sécurité: 128 bits (résistance aux collisions)\nOpérations :\nSHA-256 de H(p, d) Hachage SHA-256 avec chaîne de personnalisation :\nH(p, d) := SHA256(p || d) Où || désigne la concaténation, p est une chaîne de personnalisation, d représente les données.\nSHA-256 MixHash(d) Met à jour le hachage cumulatif avec de nouvelles données :\nh = SHA256(h || d) Utilisé tout au long du handshake Noise pour maintenir le hachage de la transcription.\nDérivation de clé HKDF Spécification: RFC 5869 Description: Fonction de dérivation de clé basée sur HMAC utilisant SHA-256\nParamètres: - Fonction de hachage: HMAC-SHA256 - Longueur du sel: Jusqu\u0026rsquo;à 32 octets (taille de sortie SHA-256) - Longueur de sortie: Variable (jusqu\u0026rsquo;à 255 * 32 octets)\nFonction HKDF:\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] Modèles d\u0026rsquo;utilisation courants:\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] Chaînes d\u0026rsquo;information utilisées dans ECIES: - \u0026quot;KDFDHRatchetStep\u0026quot; - Dérivation de clés du cliquet DH - \u0026quot;TagAndKeyGenKeys\u0026quot; - Initialisation des clés des chaînes de tags et de clés - \u0026quot;STInitialization\u0026quot; - Initialisation du cliquet des tags de session - \u0026quot;SessionTagKeyGen\u0026quot; - Génération des tags de session - \u0026quot;SymmetricRatchet\u0026quot; - Génération de clés symétriques - \u0026quot;XDHRatchetTagSet\u0026quot; - Clé de tagset (ensemble de tags) du cliquet DH - \u0026quot;SessionReplyTags\u0026quot; - Génération du tagset NSR (New Session Reply, réponse de nouvelle session) - \u0026quot;AttachPayloadKDF\u0026quot; - Dérivation de la clé de charge utile NSR\nEncodage Elligator2 Objectif: Encoder des clés publiques X25519 de façon qu\u0026rsquo;elles soient indiscernables de chaînes aléatoires uniformes de 32 octets.\nSpécification: Article Elligator2 Problème: Les clés publiques X25519 standard présentent une structure reconnaissable. Un observateur peut identifier les messages de handshake (établissement de connexion) en détectant ces clés, même si le contenu est chiffré.\nSolution: Elligator2 fournit une correspondance bijective entre environ 50 % des clés publiques X25519 valides et des chaînes de 254 bits d\u0026rsquo;apparence aléatoire.\nGénération de clés avec Elligator2 (technique de mappage des points de courbe elliptique vers des octets à distribution uniforme) :\nElligator2 GENERATE_PRIVATE_ELG2() Génère une clé privée qui correspond à une clé publique encodable au format Elligator2 :\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue Important: Environ 50 % des clés privées générées aléatoirement produiront des clés publiques non encodables. Celles-ci doivent être écartées et une nouvelle génération doit être tentée.\nOptimisation des performances: Générez des clés à l\u0026rsquo;avance dans un fil d\u0026rsquo;exécution en arrière-plan pour maintenir une réserve de paires de clés adéquates, afin d\u0026rsquo;éviter les retards lors du handshake (phase de négociation initiale).\nElligator2 ENCODE_ELG2(pubkey) Encode une clé publique en 32 octets d\u0026rsquo;apparence aléatoire :\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey Détails d\u0026rsquo;encodage: - Elligator2 produit 254 bits (pas les 256 complets) - Les 2 bits de poids fort de l\u0026rsquo;octet 31 sont du remplissage aléatoire - Le résultat est uniformément réparti dans l\u0026rsquo;espace de 32 octets - Encode avec succès environ 50 % des clés publiques X25519 valides\nElligator2 DECODE_ELG2(encodedKey) Se décode pour obtenir la clé publique d’origine:\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey Propriétés de sécurité: - Les clés encodées sont computationnellement indiscernables d\u0026rsquo;octets aléatoires - Aucun test statistique ne peut détecter de manière fiable des clés encodées avec Elligator2 (méthode de mappage cryptographique) - Le décodage est déterministe (la même clé encodée produit toujours la même clé publique) - L\u0026rsquo;encodage est bijectif pour ~50 % des clés du sous-ensemble encodable\nNotes d’implémentation: - Stocker les clés encodées lors de la phase de génération pour éviter de les réencoder pendant le handshake - Les clés inadaptées issues de la génération Elligator2 (mécanisme de camouflage de clés sur courbe elliptique) peuvent être utilisées pour NTCP2 (qui ne requiert pas Elligator2) - La génération de clés en arrière-plan est essentielle pour les performances - Le temps moyen de génération double en raison d’un taux de rejet de 50 %\nFormats des messages Aperçu ECIES (schéma de chiffrement intégré sur courbe elliptique) définit trois types de messages :\nNouvelle session (NS): Message de poignée de main initial d\u0026rsquo;Alice à Bob Réponse de nouvelle session (NSR): Réponse de poignée de main de Bob à Alice Session existante (ES): Tous les messages ultérieurs dans les deux sens Tous les messages sont encapsulés au format I2NP Garlic Message, avec des couches de chiffrement supplémentaires.\nConteneur I2NP de Garlic Message (message composite « garlic ») Tous les messages ECIES sont encapsulés dans des en-têtes I2NP Garlic Message standard :\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ Champs: - type: 0x26 (Garlic Message, message \u0026lsquo;garlic\u0026rsquo; d\u0026rsquo;I2P) - msg_id: identifiant de message I2NP de 4 octets - expiration: horodatage Unix de 8 octets (millisecondes) - size: taille de la charge utile de 2 octets - chks: somme de contrôle sur 1 octet - length: longueur des données chiffrées sur 4 octets - encrypted data: charge utile chiffrée ECIES\nObjectif: Fournit l’identification et le routage des messages au niveau de la couche I2NP. Le champ length permet aux récepteurs de connaître la taille totale de la charge utile chiffrée.\nMessage de nouvelle session (NS) Le message « New Session » initie une nouvelle session d’Alice vers Bob. Il se décline en trois variantes :\nAvec liaison (1b): Inclut la clé statique d’Alice pour une communication bidirectionnelle Sans liaison (1c): Omet la clé statique pour une communication unidirectionnelle À usage unique (1d): Mode à message unique sans établissement de session Message NS avec liaison (Type 1b) Cas d’utilisation: Diffusion en continu, datagrammes pouvant recevoir une réponse, tout protocole nécessitant des réponses\nLongueur totale : 96 + payload_length octets\nFormat:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Détails du champ:\nClé publique éphémère (32 octets, en clair): - La clé publique X25519 à usage unique d\u0026rsquo;Alice - Encodée avec Elligator2 (indiscernable d\u0026rsquo;une donnée aléatoire) - Générée pour chaque message NS (jamais réutilisée) - Format little-endian\nSection de clé statique (32 octets chiffrés, 48 octets avec MAC): - Contient la clé publique statique X25519 d\u0026rsquo;Alice (32 octets) - Chiffrée avec ChaCha20 - Authentifiée avec un MAC Poly1305 (16 octets) - Utilisée par Bob pour lier la session à la destination d\u0026rsquo;Alice\nSection de charge utile (chiffrée de longueur variable, +16 octets de MAC): - Contient des garlic cloves (sous-blocs de message de garlic encryption) et d\u0026rsquo;autres blocs - Doit inclure un bloc DateTime comme premier bloc - Inclut généralement des blocs Garlic Clove contenant des données applicatives - Peut inclure un bloc NextKey pour un ratchet immédiat (mécanisme de rotation de clés) - Chiffré avec ChaCha20 - Authentifié avec un MAC Poly1305 (16 octets)\nPropriétés de sécurité: - La clé éphémère fournit une composante de confidentialité persistante - La clé statique authentifie Alice (liaison à la destination) - Les deux sections ont des MAC distincts pour la séparation des domaines - Le handshake complet effectue 2 opérations DH (es, ss)\nMessage NS sans liaison (Type 1c) Cas d\u0026rsquo;utilisation: Datagrammes bruts où aucune réponse n\u0026rsquo;est attendue ni souhaitée\nLongueur totale: 96 + payload_length octets\nFormat :\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Différence principale: La section des drapeaux contient 32 octets à zéro au lieu d\u0026rsquo;une clé statique.\nDétection: Bob détermine le type de message en déchiffrant la section de 32 octets et en vérifiant si tous les octets sont à zéro: - Tous à zéro → Session non liée (type 1c) - Non nuls → Session liée avec clé statique (type 1b)\nPropriétés: - L\u0026rsquo;absence de clé statique signifie qu\u0026rsquo;il n\u0026rsquo;y a pas de liaison à la destination d\u0026rsquo;Alice - Bob ne peut pas envoyer de réponses (aucune destination connue) - N\u0026rsquo;effectue qu'1 opération DH (Diffie-Hellman) - Suit le Noise \u0026ldquo;N\u0026rdquo; pattern (modèle \u0026ldquo;N\u0026rdquo; du protocole Noise) plutôt que \u0026ldquo;IK\u0026rdquo; - Plus efficace lorsque les réponses ne sont jamais nécessaires\nSection des drapeaux (réservée pour une utilisation future): Actuellement tous à zéro. Peut être utilisée pour la négociation de fonctionnalités dans de futures versions.\nMessage NS à usage unique (Type 1d) Cas d\u0026rsquo;utilisation: Message anonyme unique sans session ni réponse attendue\nLongueur totale: 96 + payload_length octets\nFormat: Identique à NS sans liaison (type 1c)\nDistinction: - Le type 1c peut envoyer plusieurs messages dans la même session (des messages ES suivent) - Le type 1d envoie exactement un seul message sans établissement de session - En pratique, les implémentations peuvent les traiter de manière identique initialement\nPropriétés : - Anonymat maximal (aucune clé statique, aucune session) - Aucun état de session conservé par aucune des parties - Suit le modèle \u0026ldquo;N\u0026rdquo; de Noise - Une seule opération DH (Diffie-Hellman)\nMessage de réponse de nouvelle session (NSR) Bob envoie un ou plusieurs messages NSR en réponse au message NS d\u0026rsquo;Alice. Le NSR achève le Noise IK handshake (échange d\u0026rsquo;initialisation sécurisé) et établit une session bidirectionnelle.\nLongueur totale: 72 + payload_length octets\nFormat:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Détails du champ:\nÉtiquette de session (8 octets, en clair): - Générée à partir du jeu de tags NSR (voir les sections KDF) - Associe cette réponse au message NS d’Alice - Permet à Alice d’identifier à quel NS cette NSR répond - Utilisation unique (jamais réutilisée)\nClé publique éphémère (32 octets, en clair): - Clé publique X25519 à usage unique de Bob - Encodée avec Elligator2 - Générée spécifiquement pour chaque message NSR - Doit être différente pour chaque NSR envoyé\nMAC de la section de clé (16 octets): - Authentifie des données vides (ZEROLEN) - Fait partie du protocole Noise IK (se pattern (static-ephemeral, statique-éphémère)) - Utilise la transcription de hachage comme données associées - Essentiel pour lier NSR à NS\nSection de charge utile (longueur variable): - Contient des garlic cloves (unités de message « garlic ») et des blocs - Inclut généralement des réponses de la couche applicative - Peut être vide (ACK-only NSR, NSR ne contenant qu’un ACK) - Taille maximale : 65519 octets (65535 - MAC de 16 octets)\nPlusieurs messages NSR:\nBob peut envoyer plusieurs messages NSR en réponse à un NS : - Chaque NSR possède une clé éphémère unique - Chaque NSR possède une étiquette de session unique - Alice utilise le premier NSR reçu pour terminer le handshake (établissement de session) - Les autres NSR servent de redondance (en cas de perte de paquets)\nSynchronisation critique : - Alice doit recevoir un NSR avant d\u0026rsquo;envoyer des messages ES - Bob doit recevoir un message ES avant d\u0026rsquo;envoyer des messages ES - NSR établit des clés de session bidirectionnelles via l\u0026rsquo;opération split()\nPropriétés de sécurité : - Achève le handshake IK de Noise - Effectue 2 opérations DH supplémentaires (ee, se) - Total de 4 opérations DH sur NS+NSR - Assure une authentification mutuelle (Niveau 2) - Fournit une confidentialité persistante (PFS) faible (Niveau 4) pour la charge utile NSR\nMessage de session existante (ES) Tous les messages après la poignée de main NS/NSR utilisent le format Existing Session (session existante). Les messages ES sont utilisés dans les deux sens par Alice et Bob.\nLongueur totale: 8 + payload_length + 16 octets (minimum 24 octets)\nFormat:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ Détails des champs:\nSession Tag (étiquette de session) (8 octets, en clair): - Généré à partir du jeu de tags sortant actuel - Identifie la session et le numéro du message - Le récepteur recherche le tag pour trouver la clé de session et le nonce (nombre utilisé une seule fois) - Usage unique (chaque tag utilisé exactement une fois) - Format: les 8 premiers octets de la sortie HKDF\nSection de charge utile (longueur variable): - Contient des garlic cloves (« gousses » dans la terminologie I2P) et des blocs - Aucun bloc obligatoire (peut être vide) - Blocs courants : Garlic Clove, NextKey, ACK, ACK Request, Padding - Taille maximale : 65519 octets (65535 - MAC de 16 octets)\nMAC (16 octets): - Tag d\u0026rsquo;authentification Poly1305 - Calculé sur l\u0026rsquo;ensemble de la charge utile - Données associées : le tag de session de 8 octets - Doit être vérifié correctement, sinon le message est rejeté\nProcessus de recherche d\u0026rsquo;étiquettes:\nLe récepteur extrait un tag de 8 octets Recherche le tag dans tous les tagsets (ensembles de tags) entrants actuels Récupère la clé de session associée et le numéro de message N Construit le nonce : [0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] Déchiffre la charge utile en utilisant l’AEAD avec le tag comme données associées Retire le tag du tagset (usage unique) Traite les blocs déchiffrés Étiquette de session introuvable :\nSi le tag (étiquette) n\u0026rsquo;est trouvé dans aucun tagset (ensemble de tags): - Peut être un message NS (session Noise) → tenter le déchiffrement NS - Peut être un message NSR (réponse de session Noise) → tenter le déchiffrement NSR - Peut être un ES hors séquence (session existante) → attendre brièvement une mise à jour du tagset - Peut être une attaque par rejeu → rejeter - Peut être des données corrompues → rejeter\nCharge utile vide:\nLes messages ES peuvent avoir des charges utiles vides (0 octet) : - Sert d\u0026rsquo;accusé de réception explicite (ACK) lorsqu\u0026rsquo;une requête d\u0026rsquo;ACK a été reçue - Fournit une réponse au niveau du protocole sans données d\u0026rsquo;application - Consomme tout de même une étiquette de session - Utile lorsque la couche supérieure n\u0026rsquo;a pas de données immédiates à envoyer\nPropriétés de sécurité : - Confidentialité persistante totale (niveau 5) après réception de NSR - Chiffrement authentifié via AEAD (chiffrement authentifié avec données associées) - Le Tag (étiquette) agit comme des données associées supplémentaires - Maximum 65535 messages par tagset (ensemble de tags) avant qu\u0026rsquo;un ratchet (mécanisme de cliquet cryptographique) ne soit requis\nFonctions de dérivation de clés Cette section documente toutes les opérations de KDF utilisées dans ECIES, en présentant les dérivations cryptographiques complètes.\nNotation et constantes Constantes: - ZEROLEN - Tableau d\u0026rsquo;octets de longueur zéro (chaîne vide) - || - Opérateur de concaténation\nVariables : - h - Hachage cumulatif du transcript (historique des échanges) (32 octets) - chainKey - Clé de chaînage pour HKDF (32 octets) - k - Clé de chiffrement symétrique (32 octets) - n - Nonce (valeur à usage unique) / numéro de message\nClés: - ask / apk - clé privée/publique statique d\u0026rsquo;Alice - aesk / aepk - clé privée/publique éphémère d\u0026rsquo;Alice - bsk / bpk - clé privée/publique statique de Bob - besk / bepk - clé privée/publique éphémère de Bob\nFonctions de dérivation de clés (KDF) pour les messages NS KDF 1: Clé de chaîne initiale Effectué une seule fois lors de l\u0026rsquo;initialisation du protocole (peut être précalculé):\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions Résultat: - chainKey = Clé de chaînage initiale pour toutes les fonctions de dérivation de clé (KDF) ultérieures - h = Transcription de hachage initiale\nKDF 2: Mélange avec la clé statique de Bob Bob exécute ceci une fois (peut être précalculé pour toutes les sessions entrantes):\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF 3 : Génération de la clé éphémère d\u0026rsquo;Alice Alice génère de nouvelles clés pour chaque message NS :\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF 4 : Section de clé statique NS (DH) Dérive des clés pour chiffrer la clé statique d\u0026rsquo;Alice :\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF 5: Section de charge utile NS (ss DH, liée uniquement) Pour les sessions liées, effectuez un second échange de clés Diffie-Hellman (DH) pour le chiffrement de la charge utile :\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message Notes importantes :\nLié vs Non lié:\nLié effectue 2 opérations DH (es + ss) Non lié effectue 1 opération DH (es uniquement) Non lié incrémente le nonce (nombre utilisé une seule fois) au lieu de dériver une nouvelle clé Sécurité contre la réutilisation des clés:\nDes nonces différents (0 vs 1) empêchent la réutilisation de la paire clé/nonce Des données associées différentes (h est différent) assurent une séparation des domaines Transcription de hachage:\nh contient maintenant : protocol_name, prologue vide, bpk, aepk, static_key_ciphertext, payload_ciphertext Cette transcription lie toutes les parties du message NS entre elles KDF (fonction de dérivation de clés) du jeu d’étiquettes de réponse NSR Bob génère des tags pour les messages NSR (un type de message spécifique) :\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR Fonctions de dérivation de clés pour les messages NSR KDF 6: Génération de clés éphémères NSR Bob génère une nouvelle clé éphémère pour chaque NSR :\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7 : Section de clés NSR (ee et se DH) Dérive des clés pour la section de clés NSR:\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR Critique: Cela termine le Noise IK handshake (échange initial du protocole Noise IK). chainKey contient désormais les contributions des 4 opérations DH (es, ss, ee, se).\nKDF 8: Section de charge utile NSR Dérive des clés pour le chiffrement de la charge utile NSR :\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message Notes importantes :\nOpération de séparation:\nCrée des clés indépendantes pour chaque direction Empêche la réutilisation des clés entre Alice→Bob et Bob→Alice Liaison de la charge utile NSR:\nUtilise h comme données associées pour lier la charge utile au handshake (poignée de main) Une KDF distincte (\u0026ldquo;AttachPayloadKDF\u0026rdquo;) assure la séparation des domaines Préparation ES:\nAprès NSR, les deux parties peuvent envoyer des messages ES Alice doit recevoir NSR avant d\u0026rsquo;envoyer ES Bob doit recevoir ES avant d\u0026rsquo;envoyer ES Fonctions de dérivation de clés pour les messages ES Les messages ES utilisent des clés de session générées à l\u0026rsquo;avance issues de tagsets (ensembles de tags):\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) Processus de réception :\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) Fonction DH_INITIALIZE Crée un ensemble d\u0026rsquo;étiquettes pour un seul sens:\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset Contextes d’utilisation :\nNSR Tagset (ensemble d’étiquettes): DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) ES Tagsets: DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) Tagsets à cliquet: DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) Mécanismes à cliquet ECIES utilise trois mécanismes à cliquet synchronisés pour assurer la confidentialité persistante et une gestion des sessions efficace.\nVue d’ensemble de Ratchet (mécanisme d’actualisation des clés cryptographiques) Trois types de Ratchet (mécanisme à cliquet cryptographique):\nDH Ratchet (mécanisme à cliquet Diffie-Hellman): Effectue des échanges de clés Diffie-Hellman pour générer de nouvelles clés racine Session Tag Ratchet (mécanisme à cliquet pour les étiquettes de session): Dérive de manière déterministe des étiquettes de session à usage unique Symmetric Key Ratchet (mécanisme à cliquet pour les clés symétriques): Dérive des clés de session pour le chiffrement des messages Relation:\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) Propriétés clés:\nÉmetteur: Génère des tags et des clés à la demande (aucun stockage nécessaire) Récepteur: Pré-génère des tags pour la fenêtre d’anticipation (stockage requis) Synchronisation: L’index de tag détermine l’index de clé (N_tag = N_key) Confidentialité persistante: Obtenue via un DH ratchet (mécanisme à cliquet Diffie-Hellman) Efficacité: Le récepteur peut différer le calcul de la clé jusqu’à réception du tag Cliquet Diffie-Hellman Le DH ratchet (mécanisme à cliquet Diffie-Hellman) assure la confidentialité persistante en échangeant périodiquement de nouvelles clés éphémères.\nFréquence du cliquet Diffie-Hellman Conditions requises du ratchet (mécanisme à cliquet cryptographique): - Ensemble de tags approchant l’épuisement (le tag 65535 est le maximum) - Politiques propres à l’implémentation: - Seuil basé sur le nombre de messages (par exemple, tous les 4096 messages) - Seuil temporel (par exemple, toutes les 10 minutes) - Seuil de volume de données (par exemple, tous les 100 Mo)\nRatchet (mécanisme de cliquet cryptographique) initial recommandé: Aux environs du numéro de tag 4096 pour éviter d\u0026rsquo;atteindre la limite\nValeurs maximales: - ID maximum de l’ensemble de tags: 65535 - ID maximum de clé: 32767 - Nombre maximal de messages par ensemble de tags: 65535 - Volume de données maximal théorique par session: ~6.9 TB (64K ensembles de tags × 64K messages × 1730 octets en moyenne)\nIdentifiants de tags et de clés du DH Ratchet (mécanisme à cliquet Diffie-Hellman) Ensemble de tags initial (après le handshake): - ID de l\u0026rsquo;ensemble de tags: 0 - Aucun bloc NextKey n\u0026rsquo;a encore été envoyé - Aucun ID de clé n\u0026rsquo;a été attribué\nAprès le premier Ratchet (mécanisme de cliquet cryptographique): - ID de l\u0026rsquo;ensemble de tags: 1 = (1 + ID de la clé d\u0026rsquo;Alice + ID de la clé de Bob) = (1 + 0 + 0) - Alice envoie NextKey avec l\u0026rsquo;ID de clé 0 - Bob répond avec NextKey avec l\u0026rsquo;ID de clé 0\nSubsequent Tag Sets (jeux de tags ultérieurs): - Tag set ID = 1 + ID de la clé de l\u0026rsquo;expéditeur + ID de la clé du destinataire - Exemple : Tag set 5 = (1 + sender_key_2 + receiver_key_2)\nTableau de progression des ensembles de balises:\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set \\* = Nouvelle clé générée par ce ratchet (mécanisme à cliquet) Règles de l\u0026rsquo;ID de clé: - Les ID sont séquentiels à partir de 0 - Les ID sont incrémentés uniquement lorsqu\u0026rsquo;une nouvelle clé est générée - L\u0026rsquo;ID de clé maximal est 32767 (15 bits) - Après l\u0026rsquo;ID de clé 32767, une nouvelle session est requise\nFlux des messages du DH Ratchet (mécanisme de cliquet Diffie-Hellman) Rôles: - Émetteur de tags (étiquettes): Possède l\u0026rsquo;ensemble de tags sortants, envoie des messages - Récepteur de tags: Possède l\u0026rsquo;ensemble de tags entrants, reçoit des messages\nSchéma: L\u0026rsquo;expéditeur des tags initie le ratchet (mécanisme à cliquet cryptographique) lorsque l\u0026rsquo;ensemble de tags est presque épuisé.\nDiagramme de flux des messages :\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) Schémas de ratchet (mécanisme à cliquet):\nCréation de Tag Sets (ensembles d’étiquettes) numérotés pairs (2, 4, 6, \u0026hellip;): 1. L’émetteur génère une nouvelle clé 2. L’émetteur envoie un NextKey block (bloc NextKey) avec la nouvelle clé 3. Le récepteur envoie un NextKey block avec l’ancien identifiant de clé (ACK, accusé de réception) 4. Les deux effectuent un DH (Diffie-Hellman) avec (nouvelle clé de l’émetteur × ancienne clé du récepteur)\nCréation de Tag Sets (ensembles de tags) à nombre impair (3, 5, 7, \u0026hellip;): 1. L’émetteur demande la reverse key (clé de retour) (envoie NextKey avec l’indicateur de requête) 2. Le récepteur génère une nouvelle clé 3. Le récepteur envoie un bloc NextKey avec la nouvelle clé 4. Les deux réalisent un Diffie-Hellman (DH) avec (ancienne clé de l’émetteur × nouvelle clé du récepteur)\nFormat du bloc NextKey Voir la section Payload Format pour une spécification détaillée du bloc NextKey.\nÉléments clés: - Octet de drapeaux: - Bit 0: Clé présente (1) ou ID uniquement (0) - Bit 1: Clé retour (1) ou clé aller (0) - Bit 2: Demander la clé retour (1) ou aucune demande (0) - ID de clé: 2 octets, big-endian (0-32767) - Clé publique: 32 octets X25519 (si le bit 0 = 1)\nExemples de blocs NextKey:\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) Fonction de dérivation de clés (KDF) du ratchet DH (mécanisme à cliquet) Lorsque de nouvelles clés sont échangées:\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset Synchronisation critique:\nTag Sender (émetteur de tags): - Crée immédiatement un nouvel ensemble de tags sortants - Commence immédiatement à utiliser les nouveaux tags - Supprime l’ancien ensemble de tags sortants\nRécepteur de tags: - Crée un nouvel ensemble de tags entrants - Conserve l\u0026rsquo;ancien ensemble de tags entrants pendant la période de grâce (3 minutes) - Accepte des tags provenant à la fois de l\u0026rsquo;ancien et du nouvel ensemble de tags pendant la période de grâce - Supprime l\u0026rsquo;ancien ensemble de tags entrants après la période de grâce\nGestion de l\u0026rsquo;état du DH Ratchet (mécanisme à cliquet Diffie-Hellman) État de l\u0026rsquo;expéditeur: - Ensemble de tags sortants actuel - Identifiant de l\u0026rsquo;ensemble de tags et identifiants des clés - Prochaine clé racine (pour le prochain ratchet (mécanisme de cliquet cryptographique)) - Nombre de messages dans l\u0026rsquo;ensemble de tags actuel\nÉtat du récepteur: - Ensemble(s) d’étiquettes entrantes actuel(s) (il peut y en avoir deux pendant la période de grâce) - Numéros des messages précédents (PN) pour la détection des écarts - Fenêtre d’anticipation d’étiquettes pré-générées - Prochaine clé racine (pour le prochain ratchet, mécanisme de cliquet cryptographique)\nRègles de transition d\u0026rsquo;état :\nAvant le premier Ratchet (mécanisme de chiffrement à cliquet):\nUtilisation de l\u0026rsquo;ensemble de tags 0 (provenant de NSR) Aucun identifiant de clé attribué Initialisation du Ratchet (mécanisme de cliquet cryptographique):\nGénérer une nouvelle clé (si l\u0026rsquo;expéditeur génère pour cette itération) Envoyer le bloc NextKey dans le message ES Attendre la réponse NextKey avant de créer un nouvel ensemble de tags sortants Réception d\u0026rsquo;une requête de ratchet (mécanisme à cliquet cryptographique):\nGénérer une nouvelle clé (si c\u0026rsquo;est au récepteur de générer à ce tour) Effectuer un DH (Diffie-Hellman) avec la clé reçue Créer un nouvel ensemble de tags entrants Envoyer une réponse NextKey Conserver l\u0026rsquo;ancien ensemble de tags entrants pendant une période de grâce Finalisation du Ratchet (mécanisme de cliquet cryptographique):\nRecevoir la réponse NextKey Effectuer l\u0026rsquo;échange DH Créer un nouvel ensemble de tags sortants Commencer à utiliser les nouveaux tags Mécanisme à cliquet des étiquettes de session Le session tag ratchet (mécanisme à cliquet des étiquettes de session) génère de manière déterministe des étiquettes de session à usage unique de 8 octets.\nObjectif du cliquet des étiquettes de session Remplace la transmission explicite des étiquettes (ElGamal envoyait des étiquettes de 32 octets) Permet au récepteur de pré-générer des étiquettes pour une fenêtre d’anticipation L’expéditeur les génère à la demande (aucun stockage requis) Se synchronise avec le ratchet de clé symétrique (mécanisme à cliquet) via un index Formule du cliquet pour Session Tag (étiquette de session) Initialisation:\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset Génération de l\u0026rsquo;étiquette (pour l\u0026rsquo;étiquette N):\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 Séquence complète :\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] Implémentation côté expéditeur du Session Tag Ratchet (mécanisme de cliquet pour les étiquettes de session) class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) Processus d’envoi: 1. Appeler get_next_tag() pour chaque message 2. Utiliser le tag renvoyé dans le message ES 3. Stocker l’index N pour un suivi éventuel des ACK (accusé de réception) 4. Aucun stockage de tag n’est requis (généré à la demande)\nImplémentation du récepteur de Session Tag Ratchet (mécanisme à cliquet des étiquettes de session) class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) Processus de réception: 1. Pré-générer des étiquettes pour la fenêtre d’anticipation (p. ex., 32 étiquettes) 2. Stocker les étiquettes dans une table de hachage ou un dictionnaire 3. À l’arrivée d’un message, rechercher l’étiquette pour obtenir l’index N 4. Retirer l’étiquette du stockage (usage unique) 5. Étendre la fenêtre si le nombre d’étiquettes tombe en dessous du seuil\nStratégie d’anticipation des tags de session Objectif: Équilibrer l\u0026rsquo;utilisation de la mémoire et la gestion des messages arrivant dans le désordre\nTailles d\u0026rsquo;anticipation recommandées:\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets **Anticipation adaptative:** # Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 Élagage arrière:\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 Calcul de la mémoire :\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total Traitement des Session Tag (étiquettes de session) hors séquence Scénario: Les messages arrivent dans le désordre\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 Comportement du récepteur:\nRecevoir tag_5:\nRecherche: trouvé à l\u0026rsquo;index 5 Traiter le message Supprimer tag_5 Plus haut reçu: 5 Recevoir tag_7 (hors séquence):\nRecherche: trouvé à l\u0026rsquo;index 7 Traiter le message Supprimer tag_7 Reçu le plus élevé: 7 Remarque: tag_6 toujours en stockage (pas encore reçu) Réception de tag_6 (retardé):\nRecherche: trouvé à l\u0026rsquo;index 6 Traiter le message Supprimer tag_6 Maximum reçu: 7 (inchangé) Recevoir tag_8:\nRechercher: trouvé à l\u0026rsquo;index 8 Traiter le message Supprimer tag_8 Plus élevé reçu: 8 Gestion de la fenêtre: - Suivre le plus grand indice reçu - Maintenir une liste des indices manquants (lacunes) - Étendre la fenêtre en fonction du plus grand indice - Optionnel : supprimer les anciennes lacunes après expiration du délai\nCliquet à clé symétrique Le cliquet symétrique génère des clés de chiffrement de 32 octets synchronisées avec les étiquettes de session.\nObjectif du cliquet à clé symétrique Fournit une clé de chiffrement unique pour chaque message Synchronisé avec session tag ratchet (mécanisme de progression cryptographique des étiquettes de session; même index) L’expéditeur peut générer à la demande Le destinataire peut différer la génération jusqu’à réception de l’étiquette Formule du ratchet à clé symétrique (mécanisme à cliquet) Initialisation:\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived Génération de la clé (pour la clé N):\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) Séquence complète:\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] Implémentation côté expéditeur du cliquet à clé symétrique class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) Processus de l\u0026rsquo;expéditeur: 1. Récupérer l\u0026rsquo;étiquette suivante et son indice N 2. Générer une clé pour l\u0026rsquo;indice N 3. Utiliser la clé pour chiffrer le message 4. Aucun stockage de clé n\u0026rsquo;est requis\nImplémentation du récepteur du Symmetric Key Ratchet (cliquet symétrique) Stratégie 1: Génération différée (recommandée)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) Processus de génération différée: 1. Recevoir un message ES avec un tag 2. Rechercher le tag pour obtenir l\u0026rsquo;index N 3. Générer les clés 0 à N (si elles n\u0026rsquo;ont pas déjà été générées) 4. Utiliser la clé N pour déchiffrer le message 5. La clé de chaîne est maintenant positionnée à l\u0026rsquo;index N\nAvantages : - Utilisation mémoire minimale - Clés générées uniquement au besoin - Implémentation simple\nInconvénients: - Doit générer toutes les clés de 0 à N lors de la première utilisation - Ne peut pas gérer les messages reçus dans le désordre sans mise en cache\nStratégie 2 : Pré-génération avec fenêtre de balises (alternative)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None Processus de pré-génération: 1. Pré-générer des clés correspondant à la fenêtre de tags (par exemple, 32 clés) 2. Stocker les clés indexées par numéro de message 3. À la réception d’un tag, rechercher la clé correspondante 4. Étendre la fenêtre au fur et à mesure que les tags sont utilisés\nAvantages : - Gère naturellement les messages hors séquence - Récupération rapide des clés (aucun délai de génération)\nInconvénients : - Consommation mémoire plus élevée (32 octets par clé contre 8 octets par étiquette) - Les clés doivent rester synchronisées avec les étiquettes\nComparaison de la mémoire:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB Synchronisation du Ratchet symétrique (cliquet cryptographique) avec les Session Tags (étiquettes de session) Exigence critique: L\u0026rsquo;index du tag de session DOIT être égal à l\u0026rsquo;index de la clé symétrique\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) Modes de défaillance:\nSi la synchronisation est rompue : - Mauvaise clé utilisée pour le déchiffrement - Échec de la vérification du MAC - Message rejeté\nPrévention: - Toujours utiliser le même indice pour le tag et la clé - Ne jamais sauter des indices dans l’un ou l’autre ratchet (mécanisme à cliquet) - Traiter avec prudence les messages hors séquence\nConstruction du nonce pour le Ratchet (mécanisme à cliquet) symétrique Le nonce (nombre utilisé une seule fois) est dérivé du numéro de message :\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) Exemples:\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 Propriétés importantes: - Les nonces (nombre aléatoire à usage unique) sont uniques pour chaque message dans un tagset (ensemble de tags) - Les nonces ne se répètent jamais (les tags à usage unique le garantissent) - Un compteur sur 8 octets permet 2^64 messages (nous n\u0026rsquo;en utilisons que 2^16) - Le format du nonce correspond à la construction basée sur un compteur de la RFC 7539\nGestion des sessions Contexte de session Toutes les sessions entrantes et sortantes doivent appartenir à un contexte spécifique:\nContexte du router: Sessions pour le router lui-même Contexte de destination: Sessions pour une destination locale spécifique (application cliente) Règle critique: Les sessions NE DOIVENT PAS être partagées entre les contextes afin d\u0026rsquo;empêcher les attaques par corrélation.\nImplémentation:\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) Implémentation Java d\u0026rsquo;I2P:\nDans Java I2P, la classe SessionKeyManager fournit cette fonctionnalité : - Un SessionKeyManager par router - Un SessionKeyManager par destination locale - Gestion distincte des sessions ECIES et ElGamal dans chaque contexte\nLiaison de session Binding (association) associe une session à une destination distante spécifique.\nSessions liées Caractéristiques: - Inclut la clé statique de l\u0026rsquo;expéditeur dans le message NS - Le destinataire peut identifier la destination de l\u0026rsquo;expéditeur - Permet une communication bidirectionnelle - Une seule session sortante par destination - Peut avoir plusieurs sessions entrantes (pendant les transitions)\nCas d’utilisation: - Connexions en streaming (de type TCP) - Datagrammes répondables - Tout protocole nécessitant un modèle requête/réponse\nProcessus de liaison:\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) Avantages: 1. DH éphémère-éphémère: La réponse utilise un DH ee (confidentialité persistante totale) 2. Continuité de session: Les ratchets (mécanismes de cliquet cryptographiques) maintiennent la liaison avec la même destination 3. Sécurité: Empêche le détournement de session (authentification par clé statique) 4. Efficacité: Une seule session par destination (aucune duplication)\nSessions non liées Caractéristiques: - Aucune clé statique dans le NS message (message NS) (la section des indicateurs ne contient que des zéros) - Le destinataire ne peut pas identifier l\u0026rsquo;expéditeur - Communication unidirectionnelle uniquement - Plusieurs sessions vers la même destination autorisées\nCas d\u0026rsquo;utilisation: - Datagrammes bruts (envoi sans acquittement) - Publication anonyme - Messagerie de type diffusion\nPropriétés: - Plus anonyme (pas d\u0026rsquo;identification de l\u0026rsquo;expéditeur) - Plus efficace (1 DH contre 2 DH lors du handshake (négociation initiale)) - Aucune réponse possible (le destinataire ne sait pas où répondre) - Pas de session ratcheting (mécanisme de renouvellement progressif des clés de session; utilisation unique ou limitée)\nAppariement de session L\u0026rsquo;appairage relie une session entrante à une session sortante pour une communication bidirectionnelle.\nCréation de sessions appariées Point de vue d\u0026rsquo;Alice (initiatrice):\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) Point de vue de Bob (répondant):\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) Avantages de l\u0026rsquo;appairage de session Accusés de réception in-band (ACKs): Peuvent accuser réception des messages sans clove (sous-message encapsulé) séparé Ratcheting (mécanisme de cliquet cryptographique) efficace: Les deux directions avancent de concert sur le même ratchet Contrôle de flux: Peut mettre en œuvre une contre-pression entre des sessions appariées Cohérence de l’état: Plus facile de maintenir un état synchronisé Règles d\u0026rsquo;appariement des sessions La session sortante peut être non appariée (NS non lié) La session entrante pour un NS lié doit être appariée L\u0026rsquo;appariement a lieu lors de la création de la session, pas après Les sessions appariées ont la même liaison de destination Les Ratchets (cliquets) se produisent indépendamment mais sont coordonnés Cycle de vie de la session Cycle de vie de la session : phase de création Création de session sortante (Alice):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session Création d\u0026rsquo;une session entrante (Bob) :\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session Cycle de vie de la session : phase active Transitions d\u0026rsquo;état:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED Maintien actif de la session:\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) Cycle de vie de la session : phase d’expiration Valeurs du délai d\u0026rsquo;expiration de session :\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet **Logique d’expiration :** def check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) Règle critique: Les sessions sortantes DOIVENT expirer avant les sessions entrantes pour éviter toute désynchronisation.\nArrêt en douceur:\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() Plusieurs messages NS Scénario: Le message NS d\u0026rsquo;Alice est perdu ou la réponse NSR est perdue.\nComportement d\u0026rsquo;Alice :\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] Propriétés importantes :\nClés éphémères uniques: Chaque NS utilise une clé éphémère différente Négociations indépendantes: Chaque NS crée un état de négociation distinct Corrélation NSR: L\u0026rsquo;étiquette NSR identifie le NS auquel elle répond Nettoyage de l\u0026rsquo;état: Les états de NS inutilisés sont supprimés après une NSR réussie Prévention des attaques :\nPour éviter l\u0026rsquo;épuisement des ressources :\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context Plusieurs messages NSR Scénario : Bob envoie plusieurs NSRs (terme technique; par exemple, des données de réponse découpées en plusieurs messages).\nComportement de Bob :\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES Comportement d\u0026rsquo;Alice:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake Nettoyage de Bob:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED Propriétés importantes :\nPlusieurs NSR autorisées: Bob peut envoyer plusieurs NSR par NS Clés éphémères différentes: Chaque NSR doit utiliser une clé éphémère unique Même tagset (jeu de tags) pour les NSR: Toutes les NSR pour un même NS utilisent le même tagset Le premier ES l\u0026rsquo;emporte: Le premier ES d\u0026rsquo;Alice détermine quelle NSR a réussi Nettoyage après ES: Bob supprime les états inutilisés après réception de l\u0026rsquo;ES Automate à états de session Diagramme d\u0026rsquo;états complet:\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED Descriptions des états :\nNEW: Session sortante créée, aucun NS envoyé pour l’instant PENDING_REPLY: NS envoyé, en attente du NSR AWAITING_ES: NSR envoyé, en attente du premier ES d’Alice ESTABLISHED: Négociation initiale (handshake) terminée, peut envoyer/recevoir des ES ACTIVE: Échange activement des messages ES RATCHETING: DH ratchet (mécanisme à cliquet Diffie-Hellman) en cours (sous-ensemble de ACTIVE) EXPIRED: Session expirée, en attente de suppression TERMINATED: Session explicitement terminée Format de la charge utile La section de charge utile de tous les messages ECIES (schéma de chiffrement intégré à courbe elliptique) (NS, NSR, ES) utilise un format basé sur des blocs similaire à NTCP2.\nStructure des blocs Format général :\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Champs :\nblk: 1 octet - Numéro de type de bloc size: 2 octets - Taille Big-endian du champ de données (0-65516) data: Longueur variable - Données spécifiques au bloc Contraintes:\nTrame ChaChaPoly maximale : 65535 octets MAC Poly1305 (code d\u0026rsquo;authentification de message) : 16 octets Taille totale maximale des blocs : 65519 octets (65535 - 16) Taille maximale d’un bloc unique : 65519 octets (en incluant un en-tête de 3 octets) Taille maximale des données d’un bloc unique : 65516 octets Types de blocs Types de blocs définis :\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension **Gestion des blocs inconnus:** Les implémentations DOIVENT ignorer les blocs dont le numéro de type est inconnu et les traiter comme du remplissage. Cela assure la compatibilité ascendante.\nRègles d\u0026rsquo;ordonnancement des blocs Ordre des messages NS Obligatoire: - Le bloc DateTime DOIT être le premier\nAutorisés : - Garlic Clove (sous-message « gousse d\u0026rsquo;ail ») (type 11) - Options (type 5) - si implémenté - Bourrage (type 254)\nInterdits: - NextKey, ACK, ACK Request, Termination, MessageNumbers\nExemple de charge utile NS valide :\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) Ordre des messages NSR Requis: - Aucun (la charge utile peut être vide)\nAutorisé : - Garlic Clove (sous-unité de garlic encryption, type 11) - Options (type 5) - si implémenté - Bourrage (type 254)\nInterdits: - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers\nExemple de charge utile NSR valide :\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) ou\n(empty - ACK only) Ordonnancement des messages ES Obligatoire: - Aucun (la charge utile peut être vide)\nAutorisés (dans n\u0026rsquo;importe quel ordre) : - Garlic Clove (sous-message \u0026lsquo;clove\u0026rsquo;) (type 11) - NextKey (type 7) - ACK (type 8) - ACK Request (type 9) - Termination (type 4) - si implémenté - MessageNumbers (type 6) - si implémenté - Options (type 5) - si implémenté - Padding (type 254)\nRègles spéciales : - Termination DOIT être le dernier bloc (sauf Padding) - Padding DOIT être le dernier bloc - Plusieurs Garlic Cloves autorisés (gousses/sous-messages) - Jusqu\u0026rsquo;à 2 blocs NextKey autorisés (aller et retour) - Plusieurs blocs Padding NON autorisés\nExemples de charges utiles ES valides :\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) Bloc DateTime (Type 0) Objectif: Horodatage pour la prévention des attaques par rejeu et la validation du décalage d\u0026rsquo;horloge\nTaille: 7 octets (en-tête de 3 octets + 4 octets de données)\nFormat :\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Champs:\nblk: 0 size: 4 (big-endian, octets de poids fort en premier) timestamp: 4 octets - horodatage Unix en secondes (non signé, big-endian) Format d\u0026rsquo;horodatage :\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) Règles de validation :\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True Prévention du rejeu:\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass Notes d\u0026rsquo;implémentation:\nMessages NS: DateTime DOIT être le premier bloc Messages NSR/ES: DateTime généralement non inclus Fenêtre de rejeu: 5 minutes sont le minimum recommandé Filtre de Bloom: Recommandé pour une détection efficace des rejeux Dérive d\u0026rsquo;horloge: Tolérer 5 minutes dans le passé, 2 minutes dans le futur Garlic Clove Block (bloc « clove » dans un message Garlic) (Type 11) Objectif: Encapsule les messages I2NP pour l\u0026rsquo;acheminement\nFormat :\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ Champs :\nblk: 11 size: Taille totale du clove (sous-message d\u0026rsquo;un message \u0026lsquo;garlic\u0026rsquo;, variable) Delivery Instructions: Comme indiqué dans la spécification I2NP type: Type de message I2NP (1 octet) Message_ID: ID de message I2NP (4 octets) Expiration: Horodatage Unix en secondes (4 octets) I2NP Message body: Données de message de longueur variable Formats des instructions d\u0026rsquo;acheminement:\nLivraison locale (1 octet) :\n+----+ |0x00| +----+ Remise à la destination (33 octets):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Remise au Router (33 octets):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Acheminement via Tunnel (37 octets):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ En-tête de message I2NP (9 octets au total) :\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: type de message I2NP (Database Store, Database Lookup, Data, etc.) msg_id: identifiant de message sur 4 octets expiration: horodatage Unix sur 4 octets (secondes) Principales différences par rapport au format ElGamal Clove :\nPas de certificat: Champ Certificate omis (non utilisé avec ElGamal) Pas d\u0026rsquo;ID de Clove (sous-message encapsulé): ID de Clove omis (valait toujours 0) Pas d\u0026rsquo;expiration de Clove: Utilise à la place l\u0026rsquo;expiration du message I2NP En-tête compact: En-tête I2NP de 9 octets, contre le format ElGamal plus volumineux Chaque Clove est un bloc distinct: Pas de structure CloveSet (ensemble de Clove) Plusieurs Cloves (sous-messages dans un message garlic):\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] Types de messages I2NP courants dans les Cloves (gousses) :\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages **Traitement des Cloves (sous-messages encapsulés):** def process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) Bloc NextKey (Type 7) Objectif: échange de clés DH ratchet (mécanisme à cliquet Diffie-Hellman)\nFormat (clé présente - 38 octets):\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ Format (ID de clé uniquement - 6 octets):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ Champs :\nblk: 7 size: 3 (ID uniquement) ou 35 (avec clé) flag: 1 octet - Bits de drapeau key ID: 2 octets - Identifiant de clé Big-endian (ordre des octets du poids fort en premier) (0-32767) Public Key: 32 octets - clé publique X25519 (little-endian, ordre des octets du poids faible en premier), si le bit 0 du drapeau = 1 Bits de drapeau:\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) Exemples de flags (indicateurs) :\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 Règles pour les ID de clé:\nLes ID sont séquentiels : 0, 1, 2, \u0026hellip;, 32767 L\u0026rsquo;ID ne s\u0026rsquo;incrémente que lorsqu\u0026rsquo;une nouvelle clé est générée Le même ID est utilisé pour plusieurs messages jusqu\u0026rsquo;au prochain ratchet (mécanisme de renouvellement de clés) L\u0026rsquo;ID maximal est 32767 (il faut démarrer une nouvelle session après) Exemples d\u0026rsquo;utilisation :\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) Logique de traitement :\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) Plusieurs blocs NextKey :\nUn seul message ES peut contenir jusqu\u0026rsquo;à 2 blocs NextKey lorsque les deux directions appliquent le mécanisme de ratchet (mécanisme à cliquet) simultanément:\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] Bloc ACK (Type 8) Objectif: Accuser réception des messages reçus en bande\nFormat (ACK unique - 7 octets):\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ Format (accusés de réception multiples):\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Champs:\nblk: 8 size: 4 * nombre d\u0026rsquo;ACK (acquittements) (minimum 4) Pour chaque ACK: tagsetid: 2 octets - ID de l\u0026rsquo;ensemble de tags en Big-endian (octets de poids fort en premier) (0-65535) N: 2 octets - numéro de message en Big-endian (0-65535) Détermination de l\u0026rsquo;ID de l\u0026rsquo;ensemble d\u0026rsquo;étiquettes :\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 Exemple d\u0026rsquo;un accusé de réception (ACK) unique:\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) Exemple d’ACK multiples:\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) Traitement:\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) Quand envoyer des ACK :\nDemande explicite d’accusé de réception (ACK): Toujours répondre au bloc de demande d’ACK Livraison du LeaseSet: Lorsque l’expéditeur inclut un LeaseSet dans le message Établissement de session: Peut envoyer un accusé de réception pour NS/NSR (bien que le protocole préfère un accusé de réception implicite via ES) Confirmation du Ratchet (mécanisme de cliquet cryptographique): Peut accuser réception de NextKey Couche applicative: Selon les exigences du protocole de couche supérieure (p. ex., Streaming) Temporisation des ACK:\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None Bloc de demande d\u0026rsquo;ACK (accusé de réception) (Type 9) Objectif: Demander un accusé de réception in-band (dans le même canal) du message en cours\nFormat :\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ Champs:\nblk: 9 size: 1 flg: 1 octet - Drapeaux (tous les bits actuellement inutilisés, positionnés à 0) Utilisation:\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] Réponse du récepteur:\nLorsqu\u0026rsquo;une ACK Request (requête d\u0026rsquo;accusé de réception) est reçue:\nAvec données immédiates: Inclure un bloc ACK dans la réponse immédiate Sans données immédiates: Démarrer un minuteur (p. ex., 100ms) et envoyer un ES vide avec ACK si le minuteur expire Tag Set ID: Utiliser l\u0026rsquo;ID de tagset (ensemble de balises) entrant actuel Numéro de message: Utiliser le numéro de message associé au tag de session reçu Traitement :\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) Quand utiliser une requête d’ACK :\nMessages critiques: Messages qui doivent être accusés de réception Transmission d\u0026rsquo;un LeaseSet: Lors de l\u0026rsquo;inclusion d\u0026rsquo;un LeaseSet Session Ratchet (mécanisme de ratchet de session): Après l\u0026rsquo;envoi du bloc NextKey Fin de transmission: Lorsque l\u0026rsquo;expéditeur n\u0026rsquo;a plus de données à envoyer mais souhaite une confirmation Quand NE PAS l\u0026rsquo;utiliser :\nProtocole de streaming: La couche de streaming gère les ACK (accusés de réception) Messages à haute fréquence: Éviter une requête d’ACK pour chaque message (surcharge) Datagrammes peu importants: Les datagrammes bruts n’ont généralement pas besoin d’ACK Bloc de terminaison (Type 4) Statut: NON IMPLÉMENTÉ\nObjectif: Terminer la session proprement\nFormat :\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ Champs:\nblk: 4 size: 1 octet ou plus rsn: 1 octet - Code de motif addl data: Données supplémentaires facultatives (le format dépend du motif) Codes de cause :\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific **Utilisation (lorsque cela sera implémenté) :** # Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) Règles:\nDOIT être le dernier bloc sauf Padding (remplissage) Padding (remplissage) DOIT suivre Termination (terminaison) si présent Interdit dans les messages NS ou NSR Autorisé uniquement dans les messages ES Bloc d\u0026rsquo;options (Type 5) Statut: NON IMPLÉMENTÉ\nObjectif: Négocier les paramètres de session\nFormat:\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Champs:\nblk: 5 size: 21 octets ou plus ver: 1 octet - Version du protocole (doit être 0) flg: 1 octet - Drapeaux (tous les bits actuellement inutilisés) STL: 1 octet - Longueur du tag de session (doit être 8) STimeout: 2 octets - Délai d\u0026rsquo;inactivité de session en secondes (big-endian, octet de poids fort en premier) SOTW: 2 octets - Fenêtre de tags sortants de l\u0026rsquo;émetteur (big-endian) RITW: 2 octets - Fenêtre de tags entrants du récepteur (big-endian) tmin, tmax, rmin, rmax: 1 octet chacun - Paramètres de bourrage (format à virgule fixe 4.4) tdmy: 2 octets - Trafic factice maximum que l\u0026rsquo;on est disposé à envoyer (octets/s, big-endian) rdmy: 2 octets - Trafic factice demandé (octets/s, big-endian) tdelay: 2 octets - Délai intra-message maximal que l\u0026rsquo;on est disposé à insérer (msec, big-endian) rdelay: 2 octets - Délai intra-message demandé (msec, big-endian) more_options: Variable - Extensions futures Paramètres de bourrage (4.4 à virgule fixe):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) Négociation de la fenêtre de tags:\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size Valeurs par défaut (lorsque les options ne sont pas négociées):\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } MessageNumbers Block (bloc des numéros de message) (Type 6) Statut: NON IMPLÉMENTÉ\nObjectif: Indiquer le dernier message envoyé dans le jeu de balises précédent (permet la détection des écarts)\nFormat :\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ Champs :\nblk: 6 size: 2 PN: 2 octets - Numéro du dernier message de l\u0026rsquo;ensemble d\u0026rsquo;étiquettes précédent (big-endian, 0-65535) Définition de PN (numéro précédent):\nPN est l’indice du dernier tag (étiquette) envoyé dans l’ensemble de tags précédent.\nUtilisation (lorsque ce sera mis en œuvre):\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] Avantages pour le récepteur:\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) Règles :\nNE DOIT PAS être envoyé dans l’ensemble de tags 0 (aucun ensemble de tags précédent) Envoyé uniquement dans les messages ES Envoyé uniquement dans le(s) premier(s) message(s) d’un nouvel ensemble de tags La valeur PN est du point de vue de l’expéditeur (dernier tag envoyé par l’expéditeur) Relation avec Signal :\nDans Signal Double Ratchet, PN se trouve dans l’en-tête du message. Dans ECIES, il est dans la charge utile chiffrée et est facultatif.\nBloc de bourrage (Type 254) Objectif: Résistance à l\u0026rsquo;analyse de trafic et obfuscation de la taille des messages\nFormat :\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Champs :\nblk: 254 size: 0-65516 octets (big-endian) padding: Données aléatoires ou nulles Règles :\nDOIT être le dernier bloc du message Plusieurs blocs de bourrage NON autorisés Peut être de longueur nulle (en-tête de 3 octets uniquement) Les données de bourrage peuvent être des zéros ou des octets aléatoires Bourrage par défaut :\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) Stratégies de résistance à l\u0026rsquo;analyse de trafic:\nStratégie 1: Taille aléatoire (par défaut)\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Stratégie 2 : Arrondir à un multiple\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Stratégie 3 : taille fixe des messages\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Stratégie 4: Bourrage négocié (bloc d’options)\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Messages uniquement de bourrage:\nDes messages peuvent ne contenir que du bourrage (aucune donnée applicative):\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] Notes d\u0026rsquo;implémentation:\nBourrage de zéros: Acceptable (sera chiffré par ChaCha20) Bourrage aléatoire: N\u0026rsquo;apporte aucune sécurité supplémentaire après chiffrement mais consomme davantage d\u0026rsquo;entropie Performances: La génération de bourrage aléatoire peut être coûteuse ; envisagez d\u0026rsquo;utiliser des zéros Mémoire: Les blocs de bourrage volumineux consomment de la bande passante ; soyez prudent avec la taille maximale Guide d\u0026rsquo;implémentation Prérequis Bibliothèques cryptographiques :\nX25519: libsodium, NaCl, ou Bouncy Castle ChaCha20-Poly1305: libsodium, OpenSSL 1.1.0+, ou Bouncy Castle SHA-256: OpenSSL, Bouncy Castle, ou prise en charge native du langage Elligator2: Prise en charge limitée au niveau des bibliothèques ; peut nécessiter une implémentation personnalisée Implémentation d’Elligator2 (technique de masquage pour courbes elliptiques):\nElligator2 (méthode permettant de représenter des points de courbe elliptique comme des données indiscernables d\u0026rsquo;un flux aléatoire) n\u0026rsquo;est pas largement implémenté. Options:\nOBFS4 : Le transport enfichable obfs4 de Tor inclut une implémentation d’Elligator2 (technique cryptographique de dissimulation sur courbe elliptique) Implémentation personnalisée : Basée sur l’article Elligator2 kleshni/Elligator : Implémentation de référence sur GitHub Remarque Java I2P : Java I2P utilise la bibliothèque net.i2p.crypto.eddsa avec des ajouts personnalisés pour Elligator2 (technique de mappage elliptique permettant de rendre les clés publiques indiscernables de données aléatoires).\nOrdre d\u0026rsquo;implémentation recommandé Phase 1: Cryptographie de base 1. Génération et échange de clés DH X25519 2. Chiffrement/déchiffrement AEAD ChaCha20-Poly1305 3. Hachage SHA-256 et MixHash 4. Dérivation de clés HKDF 5. Encodage/décodage Elligator2 (peut utiliser des vecteurs de test au départ)\nPhase 2: Formats de messages 1. message NS (non lié) - format le plus simple 2. message NS (lié) - ajoute une clé statique 3. message NSR 4. message ES 5. Analyse et génération de blocs\nPhase 3 : Gestion des sessions 1. Création et stockage des sessions 2. Gestion de l\u0026rsquo;ensemble des tags (émetteur et récepteur) 3. Ratchet (mécanisme de cliquet cryptographique) des tags de session 4. Ratchet des clés symétriques 5. Recherche des tags et gestion de la fenêtre\nPhase 4 : DH Ratcheting (mécanisme à cliquet Diffie-Hellman) 1. Gestion du bloc NextKey 2. Fonction de dérivation de clé du DH ratchet 3. Création d\u0026rsquo;un ensemble de tags après le ratchet 4. Gestion de plusieurs ensembles de tags\nPhase 5: Logique du protocole 1. Machine à états NS/NSR/ES 2. Prévention du rejeu (DateTime, filtre de Bloom) 3. Logique de retransmission (NS/NSR multiples) 4. Gestion des ACK (acquittements)\nPhase 6: Intégration 1. Traitement des Garlic Clove d’I2NP (élément d’un message garlic) 2. Regroupement de LeaseSet 3. Intégration du protocole de streaming 4. Intégration du protocole de datagrammes\nImplémentation de l\u0026rsquo;émetteur Cycle de vie de la session sortante:\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() Implémentation du récepteur Cycle de vie d\u0026rsquo;une session entrante:\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() Classification des messages Distinction des types de messages:\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type Meilleures pratiques de gestion des sessions Stockage de session :\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] Gestion de la mémoire:\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 Stratégies de test Tests unitaires:\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 Tests d\u0026rsquo;intégration:\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 Vecteurs de test :\nImplémenter les vecteurs de test issus de la spécification :\nNoise IK Handshake: Utiliser des vecteurs de test Noise standard HKDF: Utiliser les vecteurs de test de la RFC 5869 ChaCha20-Poly1305: Utiliser les vecteurs de test de la RFC 7539 Elligator2: Utiliser les vecteurs de test de l\u0026rsquo;article Elligator2 ou d\u0026rsquo;OBFS4 Tests d\u0026rsquo;interopérabilité:\nJava I2P: Tester par rapport à l\u0026rsquo;implémentation de référence Java I2P i2pd: Tester par rapport à l\u0026rsquo;implémentation i2pd en C++ Captures de paquets: Utiliser le dissecteur Wireshark (s\u0026rsquo;il est disponible) pour vérifier les formats des messages Inter-implémentation: Créer un test harness (infrastructure de test) capable d\u0026rsquo;envoyer/recevoir entre les implémentations Considérations relatives aux performances Génération de clés :\nLa génération de clés Elligator2 (méthode de représentation uniforme de points de courbe elliptique) est coûteuse (taux de rejet de 50 %) :\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() Recherche de tags:\nUtilisez des tables de hachage pour une recherche d’étiquettes en O(1):\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) Optimisation de la mémoire :\nDifférer la génération de clés symétriques :\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key Traitement par lots:\nTraiter plusieurs messages par lot:\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results Considérations de sécurité Modèle de menaces Capacités de l’adversaire:\nObservateur passif: Peut observer tout le trafic réseau Attaquant actif: Peut injecter, modifier, rejeter, rejouer des messages Nœud compromis: Peut compromettre un router ou une destination Analyse du trafic: Peut effectuer une analyse statistique des schémas de trafic Objectifs de sécurité :\nConfidentialité: Contenu des messages caché aux observateurs Authentification: Identité de l\u0026rsquo;expéditeur vérifiée (pour les sessions liées) Confidentialité persistante: Les messages passés restent secrets même si les clés sont compromises Protection contre la relecture: Impossible de rejouer d\u0026rsquo;anciens messages Obfuscation du trafic: Les handshakes (échanges initiaux) sont indiscernables de données aléatoires Hypothèses cryptographiques Hypothèses de difficulté :\nX25519 CDH: Le problème Diffie-Hellman computationnel est difficile sur Curve25519 ChaCha20 PRF: ChaCha20 est une fonction pseudo-aléatoire Poly1305 MAC: Poly1305 est inforgeable sous attaque par message choisi SHA-256 CR: SHA-256 est résistant aux collisions HKDF Security: HKDF extrait et étend des clés uniformément distribuées Niveaux de sécurité:\nX25519: sécurité de ~128 bits (ordre de la courbe 2^252) ChaCha20: clés de 256 bits, sécurité de 256 bits Poly1305: sécurité de 128 bits (probabilité de collision) SHA-256: résistance aux collisions de 128 bits, résistance aux préimages de 256 bits Gestion des clés Génération de clés:\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) Stockage des clés :\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] Rotation des clés:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age Mesures d\u0026rsquo;atténuation des attaques Mesures d’atténuation des attaques par rejeu Validation de la date et de l\u0026rsquo;heure:\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True Filtre de Bloom pour les messages NS:\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] Session Tag (étiquette de session) à usage unique:\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index Mesures d\u0026rsquo;atténuation contre l\u0026rsquo;usurpation d\u0026rsquo;identité en cas de compromission de clé (KCI) Problème: l\u0026rsquo;authentification des messages NS est vulnérable à KCI (Key Compromise Impersonation - usurpation après compromission de clé) (Niveau d\u0026rsquo;authentification 1)\nAtténuation:\nPassez à NSR (niveau d\u0026rsquo;authentification 2) le plus rapidement possible Ne faites pas confiance à la charge utile NS pour les opérations critiques pour la sécurité Attendez la confirmation NSR avant d\u0026rsquo;effectuer des actions irréversibles def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) Mesures d\u0026rsquo;atténuation des attaques par déni de service Protection contre les inondations NS:\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 Limites de stockage des étiquettes:\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count Gestion adaptative des ressources:\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } Résistance à l\u0026rsquo;analyse de trafic Encodage Elligator2:\nGarantit que les messages de poignée de main (handshake) sont indiscernables de données aléatoires :\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string Stratégies de remplissage:\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) Attaques par temporisation:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) Écueils d’implémentation Erreurs courantes:\nRéutilisation du nonce (valeur unique): NE JAMAIS réutiliser les paires (key, nonce) # BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC BON: nonce (valeur unique non répétée) pour chaque message ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) 2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR ```python # MAUVAIS : Réutilisation d\u0026#39;une clé éphémère ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # MAUVAIS # BON : Nouvelle clé pour chaque message send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator MAUVAIS : Générateur de nombres aléatoires non cryptographique import random key = bytes([random.randint(0, 255) for _ in range(32)]) # NON SÉCURISÉ BON : Générateur de nombres aléatoires cryptographiquement sûr import os key = os.urandom(32) 4. **Timing Attacks**: Use constant-time comparisons ```python # MAUVAIS: comparaison avec sortie anticipée if computed_mac == received_mac: # Fuite temporelle pass # BON: Comparaison en temps constant if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data MAUVAIS: Déchiffrement avant vérification plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # TROP TARD if not mac_ok: return error BON: AEAD vérifie avant de déchiffrer try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError:\nreturn error 6. **Key Deletion**: Securely wipe keys from memory ```python # MAUVAIS: Suppression simple del private_key # Toujours en mémoire # CORRECT: Écraser avant suppression for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# Cas de test critiques pour la sécurité def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# ECIES (schéma de chiffrement intégré à courbes elliptiques) uniquement (recommandé pour les nouveaux déploiements) i2cp.leaseSetEncType=4 # À deux clés (ECIES + ElGamal pour la compatibilité) i2cp.leaseSetEncType=4,0 # ElGamal uniquement (ancien, déconseillé) i2cp.leaseSetEncType=0 LeaseSet Type:\n# LS2 standard (leaseSet version 2, le plus courant) i2cp.leaseSetType=3 # LS2 chiffré (destinations aveuglées) i2cp.leaseSetType=5 # Méta LS2 (abréviation de leaseSet version 2) (plusieurs destinations) i2cp.leaseSetType=7 Additional Options:\n# Clé statique pour ECIES (schéma de chiffrement intégré à courbes elliptiques) (optionnelle, générée automatiquement si elle n\u0026#39;est pas spécifiée) # Clé publique X25519 de 32 octets, encodée en base64 i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # Type de signature (pour LeaseSet) i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# ECIES entre routers i2p.router.useECIES=true Build Properties:\n// Pour les clients I2CP (Java) Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[limites] # Limite de mémoire des sessions ECIES (schéma de chiffrement intégré sur courbes elliptiques) ecies.memory = 128M [ecies] # Activer ECIES (schéma de chiffrement intégré sur courbes elliptiques) enabled = true # ECIES uniquement ou à double clé compatibility = true # true = à double clé, false = ECIES uniquement Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # ECIES (schéma de chiffrement intégré à courbe elliptique) uniquement ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# Ajouter ECIES (schéma de chiffrement intégré à courbe elliptique) tout en conservant ElGamal (cryptosystème de chiffrement asymétrique) i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# Vérifiez les types de connexion i2prouter.exe status # ou http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# Supprimer ElGamal i2cp.leaseSetEncType=4 Step 4: Restart Application\n# Redémarrer l\u0026#39;I2P router ou l\u0026#39;application systemctl restart i2p # ou i2prouter.exe restart Rollback Plan:\n# Revenir à ElGamal uniquement en cas de problèmes i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# Nombre maximal de sessions entrantes i2p.router.maxInboundSessions=1000 # Nombre maximal de sessions sortantes i2p.router.maxOutboundSessions=1000 # Délai d’expiration de la session (secondes) i2p.router.sessionTimeout=600 Memory Limits:\n# Limite de stockage des étiquettes (Ko) i2p.ecies.maxTagMemory=10240 # 10 Mo # Fenêtre d\u0026#39;anticipation i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# Messages avant le ratchet i2p.ecies.ratchetThreshold=4096 # Délai avant déclenchement du cliquet (secondes) i2p.ecies.ratchetTimeout=600 # 10 minutes Monitoring and Debugging Logging:\n# Activer la journalisation de débogage pour ECIES (schéma de chiffrement intégré à courbes elliptiques) logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # Exemples print(\u0026#34;NS (bound, charge utile de 1 Ko) :\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;octets\u0026#34;) # Sortie: 1120 octets print(\u0026#34;NSR (1KB payload):\u0026#34;, calculate_nsr_size(1024), \u0026#34;bytes\u0026#34;) # Sortie : 1096 octets print(\u0026#34;ES (1 Ko de charge utile) :\u0026#34;, calculate_es_size(1024), \u0026#34;octets\u0026#34;) # Sortie : 1048 octets Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"Schéma de chiffrement intégré à courbes elliptiques pour I2P (X25519 + AEAD)","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"Spécification du chiffrement ECIES-X25519-AEAD-Ratchet","url":"/fr/docs/specs/ecies/"},{"categories":null,"content":" Obsolète: SSU a été remplacé par SSU2. La prise en charge a été supprimée dans i2pd 2.44.0 (API 0.9.56, nov 2022) et dans Java I2P 2.4.0 (API 0.9.61, déc 2023).\nSSU fournissait un acheminement semi-fiable basé sur UDP avec contrôle de congestion, traversée de NAT et prise en charge des introducers (relais d\u0026rsquo;introduction). Il complétait NTCP en gérant les routers derrière des NAT/pare-feux et en coordonnant la découverte de l\u0026rsquo;adresse IP.\nÉléments d\u0026rsquo;adresse transport: SSU caps: indicateurs de capacité (B, C, 4, 6, etc.) host / port: écouteur IPv4 ou IPv6 (facultatif lorsque le router est derrière un pare-feu) key: clé d\u0026rsquo;introduction Base64 mtu: Facultatif; valeur par défaut 1484 (IPv4) / 1488 (IPv6) ihost/ikey/iport/itag/iexp: entrées d\u0026rsquo;introducteur lorsque le router est derrière un pare-feu Fonctionnalités Traversée NAT coopérative à l\u0026rsquo;aide d\u0026rsquo;introducers (nœuds introducteurs) Détection de l\u0026rsquo;IP locale via des tests entre pairs et l\u0026rsquo;inspection des paquets entrants État du pare-feu relayé automatiquement aux autres transports et à la console du router Livraison semi-fiable : messages retransmis jusqu\u0026rsquo;à une limite, puis abandonnés Contrôle de congestion avec augmentation additive / diminution multiplicative et champs de bits d\u0026rsquo;ACK de fragments SSU gérait également des tâches liées aux métadonnées telles que les balises de synchronisation temporelle et la négociation de la MTU. Toutes ces fonctionnalités sont désormais fournies (avec une cryptographie moderne) par SSU2 .\n","description":"Transport UDP sécurisé semi-fiable d'origine","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (ancien)","url":"/fr/docs/legacy/ssu/"},{"categories":null,"content":"Vue d\u0026rsquo;ensemble Ce document spécifie les structures de données fondamentales utilisées dans l’ensemble des protocoles I2P, y compris I2NP , I2CP , SSU2 , NTCP2 , et d’autres. Ces structures communes garantissent l’interopérabilité entre les différentes implémentations I2P et les couches de protocole.\nPrincipaux changements depuis la 0.9.58 ElGamal et DSA-SHA1 déconseillés pour les identités du router (utiliser X25519 + EdDSA) Prise en charge post-quantique de ML-KEM en test bêta (opt-in, activation facultative, à partir de la 2.10.0) Options des enregistrements de service normalisées (Proposition 167 , implémentées depuis 0.9.66) Spécifications de bourrage compressible finalisées (Proposition 161 , implémentées depuis 0.9.57) Spécifications des types communs Entier Description: Représente un entier non négatif au format d’octets réseau big-endian (gros-boutiste).\nContenu: 1 à 8 octets représentant un entier non signé.\nUtilisation : Longueurs de champ, décomptes, identifiants de type et valeurs numériques dans l\u0026rsquo;ensemble des protocoles I2P.\nDate Description: Horodatage représentant le nombre de millisecondes écoulées depuis l\u0026rsquo;époque Unix (1er janvier 1970 00:00:00 GMT).\nContenu : Entier sur 8 octets (long non signé)\nValeurs spéciales : - 0 = Date non définie ou nulle - Valeur maximale : 0xFFFFFFFFFFFFFFFF (année 584,942,417,355)\nNotes d’implémentation: - Toujours le fuseau horaire UTC/GMT - Précision à la milliseconde requise - Utilisé pour l’expiration du lease (bail de tunnel), la publication de RouterInfo et la validation de l’horodatage\nChaîne Description : Chaîne encodée en UTF-8 avec un préfixe de longueur.\nFormat :\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes Contraintes: - Longueur maximale: 255 octets (et non des caractères - les séquences UTF-8 à plusieurs octets comptent comme plusieurs octets) - La longueur peut être zéro (chaîne vide) - Le terminateur nul n\u0026rsquo;est PAS inclus - La chaîne n\u0026rsquo;est PAS terminée par un caractère nul\nImportant: Les séquences UTF-8 peuvent utiliser plusieurs octets par caractère. Une chaîne de 100 caractères peut dépasser la limite de 255 octets si elle utilise des caractères encodés sur plusieurs octets.\nStructures de clés cryptographiques Clé publique Description: Clé publique pour le chiffrement asymétrique. Le type et la taille de la clé dépendent du contexte ou sont spécifiés dans un Key Certificate (certificat de clé).\nType par défaut: ElGamal (déprécié pour les identités de Router à partir de la version 0.9.58)\nTypes pris en charge :\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta **Exigences d’implémentation:** X25519 (Type 4) - Standard actuel:\nUtilisé pour le chiffrement ECIES-X25519-AEAD-Ratchet Obligatoire pour les identités de router depuis la version 0.9.48 Encodage en little-endian (ordre des octets du moins significatif au plus) Voir ECIES et ECIES-ROUTERS ElGamal (Type 0) - Ancien:\nDéprécié pour les Identités de Router depuis 0.9.58 Toujours valide pour les Destinations (champ inutilisé depuis 0.6/2005) Utilise des nombres premiers fixes définis dans la spécification ElGamal Prise en charge maintenue pour la rétrocompatibilité MLKEM (post-quantique) - Bêta:\nL\u0026rsquo;approche hybride combine ML-KEM avec X25519 NON activée par défaut dans la version 2.10.0 Nécessite une activation manuelle via Hidden Service Manager (gestionnaire de service caché) Voir ECIES-HYBRID et Proposal 169 Les codes de type et les spécifications sont susceptibles d\u0026rsquo;être modifiés JavaDoc: PublicKey PrivateKey Description: Clé privée pour le déchiffrement asymétrique, correspondant aux types PublicKey.\nStockage: Type et longueur inférés du contexte ou stockés séparément dans des structures de données/fichiers de clés.\nTypes pris en charge:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta **Notes de sécurité :** - Les clés privées DOIVENT être générées à l'aide de générateurs de nombres aléatoires cryptographiquement sûrs - Les clés privées X25519 utilisent le \"scalar clamping\" (ajustement du scalaire) tel que défini dans la RFC 7748 - Les données de clé DOIVENT être effacées de manière sécurisée de la mémoire lorsqu'elles ne sont plus nécessaires JavaDoc: PrivateKey Clé de session Description : Clé symétrique pour le chiffrement et le déchiffrement AES-256 dans le tunnel et la garlic encryption d\u0026rsquo;I2P.\nContenu : 32 octets (256 bits)\nUtilisation: - Chiffrement au niveau du tunnel (AES-256/CBC avec IV) - Chiffrement des messages (garlic encryption) - Chiffrement de session de bout en bout\nGénération: DOIT utiliser un générateur de nombres aléatoires cryptographiquement sécurisé.\nJavaDoc: SessionKey SigningPublicKey Description: Clé publique pour la vérification de la signature. Type et longueur spécifiés dans le certificat de clé de la Destination ou déduits du contexte.\nType par défaut: DSA_SHA1 (déprécié depuis la 0.9.58)\nTypes pris en charge:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- **Exigences d'implémentation:** EdDSA_SHA512_Ed25519 (Type 7) - Standard actuel :\nValeur par défaut pour toutes les nouvelles Router Identities et destinations depuis fin 2015 Utilise la courbe Ed25519 avec hachage SHA-512 Clés publiques de 32 octets, signatures de 64 octets Encodage little-endian (ordre des octets où l\u0026rsquo;octet le moins significatif vient en premier), contrairement à la plupart des autres types Performances et sécurité élevées RedDSA_SHA512_Ed25519 (Type 11) - Spécialisé :\nUtilisé UNIQUEMENT pour les leasesets chiffrés et le blinding (aveuglement) Jamais utilisé pour les Router Identities ni les destinations standard Principales différences par rapport à EdDSA : Clés privées via réduction modulaire (pas de clamping (ajustement par masquage de bits)) Les signatures incluent 80 octets de données aléatoires Utilise directement les clés publiques (et non des hachages de clés privées) Voir [Spécification Red25519](//docs/specs/red25519-signature-scheme/ DSA_SHA1 (Type 0) - Ancien:\nDéprécié pour les Router Identities (identités du router) à partir de la 0.9.58 Déconseillé pour les nouvelles Destinations DSA 1024 bits avec SHA-1 (faiblesses connues) Prise en charge maintenue uniquement pour compatibilité Clés à plusieurs éléments :\nLorsqu’elles sont composées de deux éléments (p. ex., points ECDSA X,Y) Chaque élément est complété par des zéros en tête jusqu’à length/2 Exemple : clé ECDSA de 64 octets = X de 32 octets + Y de 32 octets JavaDoc: SigningPublicKey SigningPrivateKey Description: Clé privée utilisée pour créer des signatures, correspondant aux types SigningPublicKey (clé publique de signature).\nStockage : Type et longueur spécifiés lors de la création.\nTypes pris en charge:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized **Exigences de sécurité:** - Générer à partir d'une source d'aléa cryptographiquement sûre - Protéger avec des contrôles d'accès appropriés - Effacer de la mémoire de manière sécurisée une fois terminé - Pour EdDSA: graine de 32 octets hachée avec SHA-512, les 32 premiers octets deviennent le scalaire (clampé) - Pour RedDSA: génération de clé différente (réduction modulaire au lieu de clampage) JavaDoc: SigningPrivateKey (clé privée de signature)\nSignature Description: Signature cryptographique des données, utilisant l’algorithme de signature correspondant au type SigningPrivateKey.\nType et longueur: Déduits du type de clé utilisé pour la signature.\nTypes pris en charge:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized **Notes de format :** - Les signatures à éléments multiples (p. ex., valeurs R et S d’ECDSA) sont complétées, pour chaque élément, à longueur/2, en les préfixant de zéros - EdDSA et RedDSA utilisent un encodage en little-endian - Tous les autres types utilisent un encodage en big-endian Vérification : - Utiliser la SigningPublicKey (clé publique de signature) correspondante - Suivre les spécifications de l’algorithme de signature pour le type de clé - Vérifier que la longueur de la signature correspond à la longueur attendue pour ce type de clé\nJavaDoc: Signature Hachage Description: Hachage SHA-256 des données, utilisé partout dans I2P pour la vérification de l’intégrité et l’identification.\nContenu: 32 octets (256 bits)\nUtilisation : - Hachages de Router Identity (clés de la base de données réseau) - Hachages de Destination (clés de la base de données réseau) - Identification de la passerelle de Tunnel dans les Leases - Vérification de l\u0026rsquo;intégrité des données - Génération de Tunnel ID\nAlgorithme : SHA-256 tel que défini dans la norme FIPS 180-4\nJavaDoc: Hash Session Tag (étiquette de session) Description: Nombre aléatoire utilisé pour l\u0026rsquo;identification de session et le tag-based encryption (chiffrement basé sur des tags).\nImportant: La taille de Session Tag (étiquette de session) varie selon le type de chiffrement: - ElGamal/AES+SessionTag: 32 octets (ancien) - ECIES-X25519: 8 octets (standard actuel)\nNorme actuelle (ECIES):\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers Voir ECIES et ECIES-ROUTERS pour des spécifications détaillées.\nAncien (ElGamal/AES):\nContents: 32 bytes Usage: Deprecated encryption scheme Génération: DOIT utiliser un générateur de nombres aléatoires cryptographiquement sûr.\nJavaDoc: SessionTag TunnelId Description: Identifiant unique de la position d’un router dans un tunnel. Chaque saut dans un tunnel possède son propre TunnelId (identifiant de tunnel).\nFormat :\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) Utilisation : - Identifie les connexions de tunnel entrantes/sortantes à chaque router - TunnelId (identifiant de tunnel) différent à chaque saut dans la chaîne du tunnel - Utilisé dans les structures Lease (éléments du LeaseSet) pour identifier les tunnels passerelle\nValeurs spéciales: - 0 = Réservé à des usages particuliers du protocole (à éviter en fonctionnement normal) - Les TunnelIds (identifiants de tunnel) sont localement significatifs pour chaque router\nJavaDoc: TunnelId Spécifications des certificats Certificat Description : Conteneur pour des reçus, des preuves de travail ou des métadonnées cryptographiques, utilisés dans l’ensemble d’I2P.\nFormat:\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes Taille totale : 3 octets minimum (NULL certificate, certificat nul), jusqu’à 65538 octets maximum\nTypes de certificats Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) ### Certificat de clé (Type 5) Introduction: Version 0.9.12 (décembre 2013)\nObjectif: Spécifie des types de clés autres que le type par défaut et stocke les données de clé excédentaires au-delà de la structure KeysAndCert standard de 384 octets.\nStructure de la charge utile :\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space Remarques importantes pour l\u0026rsquo;implémentation:\nOrdre des types de clés:\nAVERTISSEMENT: Le type de clé de signature vient AVANT le type de clé de chiffrement C\u0026rsquo;est contre-intuitif, mais cela est conservé pour des raisons de compatibilité Ordre: SPKtype, CPKtype (et non CPKtype, SPKtype) Agencement des données de clés dans KeysAndCert (structure combinant les clés et le certificat):\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] Calcul des données de clé excédentaires:\nSi Crypto Key \u0026gt; 256 octets: Excess = (Crypto Length - 256) Si Signing Key \u0026gt; 128 octets: Excess = (Signing Length - 128) Padding = max(0, 384 - Crypto Length - Signing Length) Exemples (Clé cryptographique ElGamal):\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 **Exigences relatives à l'identité du Router:** - Certificat NULL utilisé jusqu'à la version 0.9.15 - Certificat de clé requis pour les types de clés non par défaut depuis la version 0.9.16 - Clés de chiffrement X25519 prises en charge depuis la version 0.9.48 Exigences relatives à la Destination: - certificat NULL OU Certificat de clé (au besoin) - Certificat de clé requis pour les types de clé de signature non par défaut depuis la 0.9.12 - Champ de clé publique cryptographique inutilisé depuis la 0.6 (2005), mais doit toujours être présent\nAvertissements importants:\nCertificat NULL vs KEY:\nUn certificat KEY avec les types (0,0) spécifiant ElGamal+DSA_SHA1 est autorisé mais déconseillé Utilisez toujours le certificat NULL pour ElGamal+DSA_SHA1 (représentation canonique) Un certificat KEY avec (0,0) est plus long de 4 octets et peut entraîner des problèmes de compatibilité Certaines implémentations peuvent ne pas gérer correctement les certificats KEY (0,0) Validation des données excédentaires :\nLes implémentations DOIVENT vérifier que la longueur du certificat correspond à la longueur attendue pour les types de clés Rejeter les certificats contenant des données excédentaires qui ne correspondent pas aux types de clés Interdire la présence de données parasites à la suite d’une structure de certificat valide JavaDoc: Certificat Mappage Description: Collection de propriétés clé-valeur utilisée pour la configuration et les métadonnées.\nFormat:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] Limites de taille: - Longueur de la clé : 0-255 octets (+ 1 octet de longueur) - Longueur de la valeur : 0-255 octets (+ 1 octet de longueur) - Taille totale du mappage : 0-65535 octets (+ 2 octets du champ de taille) - Taille maximale de la structure : 65537 octets\nExigence critique de tri:\nLorsque des mappages apparaissent dans des structures signées (RouterInfo, RouterAddress, Destination properties, I2CP SessionConfig), les entrées DOIVENT être triées par clé pour garantir l\u0026rsquo;invariance de la signature:\nMéthode de tri: Ordre lexicographique utilisant les valeurs des points de code Unicode (équivalent à Java String.compareTo()) Sensibilité à la casse: Les clés et les valeurs sont généralement sensibles à la casse (selon l\u0026rsquo;application) Clés en double: NON autorisées dans les structures signées (provoquera un échec de vérification de la signature) Encodage des caractères: Comparaison au niveau des octets en UTF-8 Pourquoi le tri est important : - Les signatures sont calculées sur la représentation en octets - Des ordres de clés différents produisent des signatures différentes - Les mappages non signés ne nécessitent pas de tri mais devraient suivre la même convention\nNotes d\u0026rsquo;implémentation:\nRedondance d\u0026rsquo;encodage:\nLes délimiteurs = et ; ET les octets de longueur de chaîne sont présents C’est inefficace, mais maintenu pour des raisons de compatibilité Les octets de longueur font autorité; les délimiteurs sont requis mais redondants Prise en charge des caractères :\nMalgré la documentation, = et ; SONT pris en charge dans les chaînes (les octets de longueur gèrent cela) L’encodage UTF-8 prend en charge la totalité d’Unicode Avertissement : I2CP utilise UTF-8, mais I2NP, historiquement, ne gérait pas correctement UTF-8 Utilisez l’ASCII pour les mappages I2NP lorsque possible pour une compatibilité maximale Contextes particuliers:\nRouterInfo/RouterAddress: DOIT être trié, sans doublons I2CP SessionConfig: DOIT être trié, sans doublons Mappages d’application: Tri recommandé mais pas toujours obligatoire Exemple (options de RouterInfo):\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 JavaDoc : DataHelper Spécification des structures communes Clés et certificats Description: Structure fondamentale combinant une clé de chiffrement, une clé de signature et un certificat. Utilisée à la fois comme RouterIdentity et Destination.\nStructure :\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) Alignement des clés: - Clé publique de chiffrement: Alignée au début (octet 0) - Bourrage: Au milieu (si nécessaire) - Clé publique de signature: Alignée à la fin (octet 256 à octet 383) - Certificat: Commence à l’octet 384\nCalcul de la taille:\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length Directives de génération de bourrage (Proposition 161 ) Version de l\u0026rsquo;implémentation: 0.9.57 (janvier 2023, sortie 2.1.0)\nContexte: - Pour les clés autres que ElGamal+DSA, un bourrage est présent dans la structure fixe de 384 octets - Pour les Destinations, le champ de clé publique de 256 octets n’est plus utilisé depuis la version 0.6 (2005) - Le bourrage doit être généré de manière à être compressible tout en restant sécurisé\nPrérequis :\nDonnées aléatoires minimales :\nUtilisez au moins 32 octets de données aléatoires cryptographiquement sécurisées Cela fournit une entropie suffisante pour la sécurité Stratégie de compression:\nRépéter les 32 octets dans tout le champ de bourrage/clé publique Des protocoles comme I2NP Database Store, Streaming SYN, SSU2 handshake utilisent la compression Importantes économies de bande passante sans compromettre la sécurité Exemples:\nIdentité du router (X25519 + EdDSA):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed Destination (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed Pourquoi cela fonctionne :\nLe hachage SHA-256 de la structure complète inclut toujours toute l\u0026rsquo;entropie La distribution DHT (table de hachage distribuée) de la base de données réseau ne dépend que du hachage La clé de signature (32 octets EdDSA/X25519) fournit 256 bits d\u0026rsquo;entropie 32 octets supplémentaires de données aléatoires répétées = 512 bits d\u0026rsquo;entropie au total Plus que suffisant pour la solidité cryptographique Notes d’implémentation :\nDOIT stocker et transmettre la structure complète de 387+ octets Hachage SHA-256 calculé sur la structure complète non compressée Compression appliquée à la couche protocolaire (I2NP, Streaming, SSU2) Rétrocompatible avec toutes les versions depuis la version 0.6 (2005) JavaDoc : KeysAndCert RouterIdentity (identité du router) Description: Identifie de manière unique un router dans le réseau I2P. Structure identique à KeysAndCert.\nFormat: Voir la structure KeysAndCert ci-dessus\nExigences actuelles (à partir de la version 0.9.58):\nTypes de clés obligatoires:\nChiffrement: X25519 (type 4, 32 octets) Signature: EdDSA_SHA512_Ed25519 (type 7, 32 octets) Certificat: Certificat de clé (type 5) Types de clés dépréciés:\nElGamal (type 0) déprécié pour les Router Identities (identités de router) à partir de la version 0.9.58 DSA_SHA1 (type 0) déprécié pour les Router Identities à partir de la version 0.9.58 Ces types ne doivent PAS être utilisés pour de nouveaux routers Taille typique:\nX25519 + EdDSA avec certificat de clé = 391 octets 32 octets de clé publique X25519 remplissage de 320 octets (compressible selon la Proposition 161 ) 32 octets de clé publique EdDSA certificat de 7 octets (en-tête de 3 octets + 4 octets pour les types de clés) Évolution historique: - Avant 0.9.16: toujours un NULL certificate (certificat NULL) (ElGamal + DSA_SHA1) - 0.9.16-0.9.47: prise en charge du Key Certificate (certificat de clé) ajoutée - 0.9.48+: clés de chiffrement X25519 prises en charge - 0.9.58+: ElGamal et DSA_SHA1 dépréciés\nClé de la base de données réseau: - RouterInfo (informations du router) indexé par le hachage SHA-256 de la RouterIdentity (identité du router) complète - Hachage calculé sur la structure complète de 391+ octets (y compris le bourrage)\nVoir aussi : - Recommandations pour la génération du bourrage (Proposition 161 ) - Spécification du certificat de clé ci-dessus\nJavaDoc : RouterIdentity Destination Description: Identifiant de point de terminaison pour la remise sécurisée de messages. Structurellement identique à KeysAndCert (clés et certificat), mais avec une sémantique d\u0026rsquo;utilisation différente.\nFormat: Voir la structure KeysAndCert ci-dessus\nDifférence critique par rapport à RouterIdentity: - Le champ de clé publique est INUTILISÉ et peut contenir des données aléatoires - Ce champ est inutilisé depuis la version 0.6 (2005) - Servait à l’origine à l’ancien chiffrement I2CP-to-I2CP (désactivé) - Actuellement utilisé uniquement comme IV (vecteur d’initiation) pour le chiffrement LeaseSet déprécié\nRecommandations actuelles :\nClé de signature:\nRecommandé: EdDSA_SHA512_Ed25519 (type 7, 32 octets) Alternative: types ECDSA pour la compatibilité avec les anciennes versions À éviter: DSA_SHA1 (obsolète, déconseillé) Clé de chiffrement :\nLe champ est inutilisé mais doit être présent Recommandé : Remplir avec des données aléatoires conformément à Proposal 161 (compressibles) Taille : toujours 256 octets (emplacement ElGamal, même s’il n’est pas utilisé pour ElGamal) Certificat:\nCertificat NULL pour ElGamal + DSA_SHA1 (ancien format uniquement) Certificat de clé pour tous les autres types de clés de signature Destination moderne typique:\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes Clé de chiffrement en vigueur : - La clé de chiffrement de la Destination se trouve dans le LeaseSet, et non dans la Destination - Le LeaseSet contient la/les clé(s) publique(s) de chiffrement actuelle(s) - Voir la spécification LeaseSet2 pour la gestion des clés de chiffrement\nClé de la base de données réseau: - LeaseSet indexé par le hachage SHA-256 de la Destination complète - Hachage calculé sur l\u0026rsquo;intégralité de la structure de 387+ octets\nJavaDoc : Destination Structures de la base de données du réseau Bail Description: Autorise un tunnel spécifique à recevoir des messages pour une Destination. Fait partie du format LeaseSet original (type 1).\nFormat:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch Taille totale : 44 octets\nUtilisation: - Utilisé uniquement dans le LeaseSet original (type 1, obsolète) - Pour LeaseSet2 et les variantes ultérieures, utilisez plutôt Lease2\nJavaDoc: Lease LeaseSet (Type 1) Description: Format LeaseSet d’origine. Contient des tunnels autorisés et des clés pour une Destination (identité de service I2P). Stocké dans la base de données réseau. Statut: Déprécié (utilisez LeaseSet2 à la place).\nStructure:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey Stockage de base de données: - Type de base de données: 1 - Clé: hachage SHA-256 de la destination - Valeur: structure complète de LeaseSet\nNotes importantes:\nClé publique de chiffrement de la Destination non utilisée :\nLe champ de clé publique de chiffrement dans la Destination n\u0026rsquo;est pas utilisé La clé de chiffrement dans le LeaseSet (structure de baux I2P) est la clé de chiffrement réelle Clés temporaires :\nencryption_key est temporaire (régénérée au démarrage du router) signing_key est temporaire (régénérée au démarrage du router) Aucune des deux clés n\u0026rsquo;est persistante d\u0026rsquo;un redémarrage à l\u0026rsquo;autre Révocation (non implémentée):\nsigning_key était prévu pour la révocation du LeaseSet Le mécanisme de révocation n\u0026rsquo;a jamais été implémenté Un LeaseSet à zéro lease (entrée de tunnel temporaire) était prévu pour la révocation mais n\u0026rsquo;est pas utilisé Versionnage/Horodatage:\nLeaseSet n’a pas de champ d’horodatage published explicite La version est l’expiration la plus imminente de tous les leases (autorisations temporaires de tunnels entrants) Un nouveau LeaseSet doit avoir une expiration de lease plus imminente pour être accepté Publication de l\u0026rsquo;expiration des baux:\nPré-0.9.7: Tous les baux publiés avec la même date d\u0026rsquo;expiration (la plus proche) 0.9.7+: Publication des dates d\u0026rsquo;expiration individuelles réelles des baux Ceci est un détail d\u0026rsquo;implémentation, qui ne fait pas partie de la spécification Zéro bail :\nUn LeaseSet avec zéro bail est techniquement autorisé Prévu pour la révocation (non implémenté) Inutilisé en pratique Les variantes de LeaseSet2 requièrent au moins un bail Dépréciation : LeaseSet type 1 est déprécié. Les nouvelles implémentations devraient utiliser LeaseSet2 (type 3) qui offre : - Champ d’horodatage de publication (meilleure gestion des versions) - Prise en charge de plusieurs clés de chiffrement - Capacité de signature hors ligne - Expirations de lease (période de bail I2P) sur 4 octets (contre 8 octets) - Options plus flexibles\nJavaDoc: LeaseSet Variantes de LeaseSet Lease2 (terme technique I2P) Description : Format de lease (enregistrement d’accès I2P) amélioré avec expiration sur 4 octets. Utilisé dans LeaseSet2 (type 3) et MetaLeaseSet (type 7).\nIntroduction : Version 0.9.38 (voir Proposition 123 )\nFormat:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 Taille totale : 40 octets (4 octets de moins que le Lease d\u0026rsquo;origine)\nComparaison avec le Lease (entrée d\u0026rsquo;un leaseSet indiquant un tunnel de destination et son expiration) d\u0026rsquo;origine:\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet **JavaDoc:** [Lease2](http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html) Signature hors ligne Description: Structure facultative pour des clés éphémères pré-signées, permettant la publication du LeaseSet sans accès en ligne à la clé de signature privée de la Destination.\nIntroduction : Version 0.9.38 (voir Proposition 123 )\nFormat :\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey Objectif: - Permet la génération de LeaseSet hors ligne - Protège la clé maîtresse de la Destination (identité I2P) contre une exposition en ligne - La clé éphémère peut être révoquée en publiant un nouveau LeaseSet sans la signature hors ligne\nScénarios d\u0026rsquo;utilisation :\nDestinations hautement sécurisées:\nClé de signature maîtresse stockée hors ligne (HSM [module matériel de sécurité], stockage à froid) Clés éphémères générées hors ligne pour des durées limitées La compromission d\u0026rsquo;une clé éphémère n\u0026rsquo;expose pas la clé de signature maîtresse Publication de LeaseSet chiffré:\nEncryptedLeaseSet peut inclure une signature hors ligne Une clé publique aveuglée + une signature hors ligne offrent une sécurité supplémentaire Considérations de sécurité:\nGestion de l’expiration:\nDéfinissez une durée d’expiration raisonnable (de quelques jours à quelques semaines, pas des années) Générez de nouvelles clés éphémères avant l’expiration Une expiration plus courte = une meilleure sécurité, mais davantage de maintenance Génération de clés:\nGénérer des clés éphémères hors ligne dans un environnement sécurisé Signer hors ligne avec la clé maîtresse Transférer uniquement la clé éphémère signée + la signature vers le router en ligne Révocation:\nPublier un nouveau LeaseSet sans signature hors ligne pour le révoquer implicitement Ou publier un nouveau LeaseSet avec une clé éphémère différente Vérification de la signature:\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature Notes d\u0026rsquo;implémentation: - La taille totale varie selon le sigtype (type de signature) et le type de clé de signature de Destination - Taille minimale : 4 + 2 + 32 (clé EdDSA) + 64 (signature EdDSA) = 102 octets - Taille maximale pratique : ~600 octets (clé éphémère RSA-4096 + signature RSA-4096)\nCompatible avec : - LeaseSet2 (type 3) - EncryptedLeaseSet (type 5) - MetaLeaseSet (type 7)\nVoir aussi : Proposition 123 pour le protocole de signature hors ligne détaillé.\nLeaseSet2Header (en-tête de LeaseSet2) Description: Structure d\u0026rsquo;en-tête commune pour LeaseSet2 (format de leaseSet de nouvelle génération) (type 3) et MetaLeaseSet (variante « meta » de leaseSet) (type 7).\nIntroduction: Version 0.9.38 (voir Proposition 123 )\nFormat:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length Taille totale minimale: 395 octets (sans signature hors ligne)\nDéfinitions des indicateurs (ordre des bits: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility **Détails du drapeau:** Bit 0 - Clés hors ligne: - 0: Aucune signature hors ligne, utiliser la clé de signature de la Destination (identifiant public I2P) pour vérifier la signature du LeaseSet - 1: La structure OfflineSignature (structure de signature hors ligne) suit le champ des indicateurs (flags)\nBit 1 - Non publié: - 0: LeaseSet (ensemble de baux) standard publié, doit être propagé aux floodfills - 1: LeaseSet non publié (côté client uniquement) - NE DOIT PAS être propagé, publié, ni envoyé en réponse aux requêtes - S\u0026rsquo;il est expiré, NE PAS interroger netdb pour un remplacement (sauf si le bit 2 est également défini) - Utilisé pour des tunnels locaux ou des tests\nBit 2 - Aveuglé (depuis 0.9.42): - 0: LeaseSet standard - 1: Ce LeaseSet non chiffré sera aveuglé et chiffré lors de sa publication - La version publiée sera EncryptedLeaseSet (type 5) - S\u0026rsquo;il a expiré, interroger l\u0026rsquo;emplacement aveuglé dans netdb pour en obtenir un de remplacement - Il faut aussi mettre le bit 1 à 1 (non publié + aveuglé) - Utilisé pour les services cachés chiffrés\nLimites d\u0026rsquo;expiration:\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours **Exigences relatives à l’horodatage de publication :** LeaseSet (type 1) ne comportait pas de champ published, ce qui nécessitait de rechercher, pour le versionnage, la date d\u0026rsquo;expiration de lease (entrée de tunnel à durée limitée) la plus proche. LeaseSet2 ajoute un horodatage published explicite avec une résolution d\u0026rsquo;une seconde.\nNote critique d\u0026rsquo;implémentation : - Routers DOIVENT limiter le débit de publication des LeaseSet à un rythme bien inférieur à une fois par seconde par Destination (adresse I2P) - Si la publication est plus rapide, s\u0026rsquo;assurer que chaque nouveau LeaseSet possède un horodatage published au moins 1 seconde plus tard - Les Floodfills rejettent le LeaseSet si l\u0026rsquo;horodatage published n\u0026rsquo;est pas plus récent que la version actuelle - Intervalle minimal recommandé : 10-60 secondes entre les publications\nExemples de calculs:\nLeaseSet2 (11 minutes maximum):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet (maximum 18,2 heures):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) Versionnage: - LeaseSet est considéré comme « plus récent » si l’horodatage published est supérieur - Floodfills stockent et diffusent uniquement la version la plus récente - Attention lorsque le plus ancien Lease (composant d’un LeaseSet dans I2P) correspond au plus ancien Lease du LeaseSet précédent\nLeaseSet2 (Type 3) Description: Format LeaseSet moderne avec plusieurs clés de chiffrement, des signatures hors ligne et des enregistrements de service. Norme actuelle pour les services cachés I2P.\nIntroduction : Version 0.9.38 (voir Proposition 123 )\nStructure :\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix Stockage de base de données: - Type de base de données: 3 - Clé: hachage SHA-256 de la Destination - Valeur: Structure LeaseSet2 complète\nCalcul de la signature :\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key Ordre de préférence des clés de chiffrement Pour un LeaseSet publié (serveur): - Les clés sont listées par ordre de préférence du serveur (les plus préférées en premier) - Les clients prenant en charge plusieurs types DEVRAIENT respecter la préférence du serveur - Sélectionner le premier type pris en charge dans la liste - En général, les types de clés avec un numéro plus élevé (plus récents) sont plus sûrs/efficaces - Ordre recommandé : lister les clés dans l\u0026rsquo;ordre inverse du code de type (les plus récents d\u0026rsquo;abord)\nExemple de préférence du serveur:\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] Pour un LeaseSet (client) non publié: - L\u0026rsquo;ordre des clés importe peu en pratique (les connexions vers les clients sont rarement tentées) - Suivez la même convention par cohérence\nSélection de la clé du client: - Respecter la préférence du serveur (sélectionner le premier type pris en charge) - Ou utiliser une préférence définie par l’implémentation - Ou déterminer une préférence combinée en fonction des capacités des deux côtés\nMappage des options Exigences: - Les options DOIVENT être triées par clé (ordre lexicographique, ordre des octets UTF-8) - Le tri garantit l\u0026rsquo;invariance de la signature - Les clés en double NE sont PAS autorisées\nFormat standard (Proposition 167 ):\nÀ partir de l’API 0.9.66 (juin 2025, version 2.9.0), les options de service record (enregistrement de service) suivent un format standardisé. Voir Proposition 167 pour la spécification complète.\nFormat de l\u0026rsquo;option d\u0026rsquo;enregistrement de service:\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) Exemples d\u0026rsquo;enregistrements de service :\n1. Serveur SMTP auto-référencé :\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. Serveur SMTP externe unique:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. Plusieurs serveurs SMTP (répartition de charge):\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. Service HTTP avec options de l\u0026rsquo;application:\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates Recommandations TTL : - Minimum : 86400 secondes (1 jour) - Un TTL plus long réduit la charge des requêtes netdb - Équilibre entre la réduction des requêtes et la propagation des mises à jour du service - Pour les services stables : 604800 (7 jours) ou plus\nNotes d\u0026rsquo;implémentation:\nClés de chiffrement (à partir de la version 0.9.44):\nElGamal (type 0, 256 octets): Compatibilité avec les anciennes versions X25519 (type 4, 32 octets): Standard actuel Variantes MLKEM (Module-Lattice Key Encapsulation Mechanism, mécanisme d’encapsulation de clés à treillis modulaires): Post-quantique (bêta, non finalisées) Validation de la longueur de clé:\nLes Floodfills et les clients DOIVENT pouvoir analyser des types de clé inconnus Utilisez le champ keylen pour ignorer les clés inconnues Ne faites pas échouer l\u0026rsquo;analyse si le type de clé est inconnu Horodatage de publication :\nVoir les notes de LeaseSet2Header concernant la limitation du débit Incrément minimal d’une seconde entre les publications Recommandé : 10 à 60 secondes entre les publications Migration du type de chiffrement:\nLa prise en charge de plusieurs clés permet une migration progressive Répertoriez les anciennes et les nouvelles clés pendant la période de transition Supprimez l\u0026rsquo;ancienne clé après une période suffisante de mise à niveau des clients JavaDoc: LeaseSet2 MetaLease (terme technique I2P sans équivalent établi) Description: Structure de Lease pour MetaLeaseSet pouvant référencer d\u0026rsquo;autres LeaseSets plutôt que des tunnels. Utilisée pour l\u0026rsquo;équilibrage de charge et la redondance.\nIntroduction: Version 0.9.38, mise en service prévue pour 0.9.40 (voir Proposition 123 )\nFormat :\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 Taille totale: 40 octets\nType d\u0026rsquo;entrée (bits de drapeau 3-0):\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) **Scénarios d'utilisation :** Équilibrage de charge:\nMetaLeaseSet (collection méta de LeaseSet) avec plusieurs entrées MetaLease (entrées méta) Chaque entrée pointe vers un LeaseSet2 différent Les clients sélectionnent en fonction du champ de coût Redondance:\nPlusieurs entrées pointant vers des LeaseSets de secours Repli si le LeaseSet principal est indisponible Migration du service:\nMetaLeaseSet pointe vers un nouveau LeaseSet Permet une transition fluide entre les destinations Utilisation du champ Cost : - Coût plus faible = priorité plus élevée - Coût 0 = priorité la plus élevée - Coût 255 = priorité la plus basse - Les clients DEVRAIENT préférer les entrées à coût plus faible - Les entrées de coût égal peuvent faire l\u0026rsquo;objet d\u0026rsquo;un équilibrage de charge aléatoire\nComparaison avec Lease2 :\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing **JavaDoc:** [MetaLease](http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html) MetaLeaseSet (Type 7) Description: Variante de LeaseSet qui contient des entrées MetaLease (entrées « méta »), fournissant une indirection vers d\u0026rsquo;autres LeaseSets. Utilisée pour la répartition de charge, la redondance et la migration de services.\nIntroduction: Défini en 0.9.38, prévu fonctionnel en 0.9.40 (voir Proposition 123 )\nStatut: Spécification complète. L\u0026rsquo;état du déploiement en production doit être vérifié avec les versions actuelles d\u0026rsquo;I2P.\nStructure:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations Stockage de base de données: - Type de base de données: 7 - Clé: hachage SHA-256 de Destination - Valeur: structure MetaLeaseSet complète\nCalcul de la signature :\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key Scénarios d\u0026rsquo;utilisation:\n1. Équilibrage de charge:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. Basculement:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. Migration du service:\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. Architecture multi-tiers:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing Liste de révocation :\nLa liste de révocation permet à MetaLeaseSet de révoquer explicitement des LeaseSets publiés précédemment :\nObjectif: Marquer des Destinations spécifiques comme n\u0026rsquo;étant plus valides Contenu: Hachages SHA-256 des structures Destination révoquées Utilisation: Les clients NE DOIVENT PAS utiliser des LeaseSets dont le hachage de la Destination figure dans la liste de révocation Valeur typique: Vide (numr=0) dans la plupart des déploiements Exemple de révocation :\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached Gestion de l\u0026rsquo;expiration:\nMetaLeaseSet utilise LeaseSet2Header avec un expires maximal de 65535 secondes (~18,2 heures):\nBeaucoup plus long que LeaseSet2 (max. ~11 minutes) Adapté à une indirection relativement statique Les LeaseSets référencés peuvent avoir une expiration plus courte Les clients doivent vérifier l’expiration à la fois de MetaLeaseSet ET des LeaseSets référencés Correspondance des options:\nUtiliser le même format que les options de LeaseSet2 Peut inclure des enregistrements de service (Proposal 167 ) DOIT être trié par clé Les enregistrements de service décrivent généralement le service final, pas la structure d’indirection Notes d’implémentation côté client :\nProcessus de résolution:\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry Mise en cache:\nMettre en cache à la fois MetaLeaseSet (structure méta référençant des LeaseSets) et les LeaseSets référencés Vérifier l’expiration des deux niveaux Surveiller les mises à jour de la publication du MetaLeaseSet Basculement:\nSi l\u0026rsquo;entrée préférée échoue, essayer l\u0026rsquo;option au coût immédiatement supérieur Envisager de marquer les entrées défaillantes comme temporairement indisponibles Revérifier périodiquement pour détecter un rétablissement Statut de l’implémentation :\nProposition 123 indique que certaines parties restent \u0026ldquo;en cours de développement.\u0026rdquo; Les implémenteurs devraient: - Vérifier l\u0026rsquo;état de préparation à la mise en production dans la version I2P cible - Tester la prise en charge de MetaLeaseSet (type de leaseSet I2P) avant le déploiement - Vérifier l\u0026rsquo;existence de spécifications mises à jour dans les versions plus récentes d\u0026rsquo;I2P\nJavaDoc: MetaLeaseSet EncryptedLeaseSet (Type 5) Description : LeaseSet chiffré et aveuglé pour une confidentialité renforcée. Seules la clé publique aveuglée et les métadonnées sont visibles ; les leases (références temporaires vers des tunnels) et les clés de chiffrement sont chiffrés.\nIntroduction: Défini en 0.9.38, fonctionnel en 0.9.39 (voir Proposition 123 )\nStructure :\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key Stockage de la base de données : - Type de base de données : 5 - Clé : hachage SHA-256 de la Destination aveuglée (et non la Destination d\u0026rsquo;origine) - Valeur : structure EncryptedLeaseSet complète\nDifférences essentielles par rapport à LeaseSet2:\nN\u0026rsquo;utilise PAS la structure LeaseSet2Header (présente des champs similaires mais une disposition différente) Clé publique aveuglée au lieu de la Destination (identifiant d\u0026rsquo;adresse I2P) complète Charge utile chiffrée au lieu de baux et de clés en clair La clé de base de données est le hachage de la Destination aveuglée, pas de la Destination d\u0026rsquo;origine Calcul de la signature:\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key Exigence relative au type de signature :\nDOIT utiliser RedDSA_SHA512_Ed25519 (type 11) : - Clés publiques aveuglées de 32 octets - Signatures de 64 octets - Requis pour les propriétés de sécurité de l’aveuglement - Voir [Spécification Red25519](//docs/specs/red25519-signature-scheme/\nPrincipales différences par rapport à EdDSA : - Clés privées par réduction modulaire (pas de clamping, ajustement des bits de la clé privée) - Les signatures incluent 80 octets de données aléatoires - Utilise les clés publiques directement (pas de hachages) - Permet une opération d\u0026rsquo;aveuglement sécurisée\nAveuglement et chiffrement:\nVoir la spécification EncryptedLeaseSet pour des détails complets :\n1. Aveuglement de clé:\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. Emplacement de la base de données :\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. Couches de chiffrement (à trois couches):\nCouche 1 - Couche d’authentification (accès client): - Chiffrement : chiffre en flux ChaCha20 - Dérivation de clé : HKDF avec des secrets propres à chaque client - Les clients authentifiés peuvent déchiffrer la couche externe\nCouche 2 - Couche de chiffrement: - Chiffrement: ChaCha20 - Clé: dérivée de DH (Diffie-Hellman) entre le client et le serveur - Contient le LeaseSet2 ou MetaLeaseSet effectif\nCouche 3 - LeaseSet interne: - LeaseSet2 ou MetaLeaseSet complet - Inclut tous les tunnels, les clés de chiffrement, les options - Accessible uniquement après un déchiffrement réussi\nDérivation de clé de chiffrement:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) Processus de découverte:\nPour les clients autorisés :\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication Pour les clients non autorisés : - Ne peuvent pas déchiffrer même s\u0026rsquo;ils trouvent l\u0026rsquo;EncryptedLeaseSet - Ne peuvent pas déterminer la Destination d\u0026rsquo;origine à partir de la version aveuglée - Ne peuvent pas relier les EncryptedLeaseSets entre différentes périodes d\u0026rsquo;aveuglement (rotation quotidienne)\nDélais d\u0026rsquo;expiration:\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived **Horodatage de publication:** Mêmes exigences que pour LeaseSet2Header : - Doit s\u0026rsquo;incrémenter d\u0026rsquo;au moins 1 seconde entre les publications - Les floodfills rejettent s\u0026rsquo;il n\u0026rsquo;est pas plus récent que la version actuelle - Recommandé : 10-60 secondes entre les publications\nSignatures hors ligne avec des LeaseSets chiffrés:\nConsidérations particulières lors de l\u0026rsquo;utilisation des signatures hors ligne: - La clé publique aveuglée est renouvelée quotidiennement - La signature hors ligne doit être régénérée quotidiennement avec la nouvelle clé aveuglée - OU utiliser la signature hors ligne sur le LeaseSet interne, pas sur l\u0026rsquo;EncryptedLeaseSet (LeaseSet chiffré) externe - Voir les notes de Proposal 123 Notes d\u0026rsquo;implémentation:\nAutorisation des clients:\nPlusieurs clients peuvent être autorisés avec des clés différentes Chaque client autorisé possède des identifiants de déchiffrement uniques Révoquer un client en modifiant les clés d\u0026rsquo;autorisation Rotation quotidienne des clés:\nLes clés blinded (masquées) changent à minuit UTC Les clients doivent recalculer la Destination blinded chaque jour Les anciens EncryptedLeaseSets deviennent introuvables après la rotation Propriétés de confidentialité:\nLes Floodfills ne peuvent pas déterminer la destination d\u0026rsquo;origine Les clients non autorisés ne peuvent pas accéder au service Différentes périodes de blinding (périodes de masquage cryptographique) ne peuvent pas être liées Aucune métadonnée en clair au-delà des dates d\u0026rsquo;expiration Performances:\nLes clients doivent effectuer un calcul d’aveuglement quotidien Le chiffrement en trois couches ajoute une surcharge de calcul Envisager la mise en cache du LeaseSet interne déchiffré Considérations de sécurité :\nGestion des clés d’autorisation :\nDistribuer en toute sécurité les identifiants d’autorisation des clients Utiliser des identifiants uniques par client pour une révocation granulaire Renouveler périodiquement les clés d’autorisation Synchronisation de l’horloge:\nL’aveuglement quotidien dépend de dates UTC synchronisées Un décalage de l’horloge peut provoquer des échecs de recherche Envisagez de prendre en charge l’aveuglement du jour précédent/suivant pour plus de tolérance Fuite de métadonnées:\nLes champs Published et expires sont en clair L\u0026rsquo;analyse des motifs pourrait révéler des caractéristiques du service Rendez aléatoires les intervalles de publication si cela vous préoccupe JavaDoc: EncryptedLeaseSet Structures du Router (nœud I2P) RouterAddress (adresse du router) Description: Définit les informations de connexion pour un router via un protocole de transport spécifique.\nFormat:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary CRITIQUE - Champ d\u0026rsquo;expiration:\n⚠️ Le champ d\u0026rsquo;expiration DOIT être défini entièrement à zéro (8 octets nuls).\nRaison: Depuis la version 0.9.3, une expiration non nulle entraîne un échec de la vérification de la signature Historique: L\u0026rsquo;expiration n\u0026rsquo;était à l\u0026rsquo;origine pas utilisée, toujours null Statut actuel: Le champ a de nouveau été reconnu à partir de la version 0.9.12, mais doit attendre une mise à niveau du réseau Implémentation: Toujours défini à 0x0000000000000000 Toute valeur d\u0026rsquo;expiration non nulle fera échouer la validation de la signature de RouterInfo (informations du router).\nProtocoles de transport Protocoles actuels (à la version 2.10.0):\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 **Valeurs de style de transport :** - `\"SSU2\"`: Transport actuel basé sur UDP - `\"NTCP2\"`: Transport actuel basé sur TCP - `\"NTCP\"`: Ancien, supprimé (ne pas utiliser) - `\"SSU\"`: Ancien, supprimé (ne pas utiliser) Options communes Tous les transports incluent généralement:\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) Options spécifiques à SSU2 Voir la spécification SSU2 pour tous les détails.\nOptions obligatoires:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Options facultatives :\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) Exemple de SSU2 RouterAddress (adresse du router):\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 Options spécifiques à NTCP2 Voir la spécification NTCP2 pour tous les détails.\nOptions requises :\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Options facultatives (depuis 0.9.50):\n\u0026#34;caps\u0026#34; = Capability string Exemple de NTCP2 RouterAddress (adresse du router) :\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 Notes d\u0026rsquo;implémentation Valeurs de coût:\nUDP (SSU2) généralement à coût plus faible (5-6) grâce à son efficacité TCP (NTCP2) généralement à coût plus élevé (10-11) en raison de la surcharge Coût plus faible = transport préféré Adresses multiples :\nLes routers peuvent publier plusieurs entrées RouterAddress Transports différents (SSU2 et NTCP2) Différentes versions IP (IPv4 et IPv6) Les clients sélectionnent en fonction du coût et des capacités Nom d\u0026rsquo;hôte vs IP :\nLes adresses IP sont à privilégier pour les performances Les noms d\u0026rsquo;hôte sont pris en charge mais ajoutent une surcharge de résolution DNS Envisagez d\u0026rsquo;utiliser des adresses IP pour les RouterInfos (descripteurs de routeur I2P) publiés Encodage Base64:\nToutes les clés et les données binaires sont encodées en Base64 Base64 standard (RFC 4648) Pas de remplissage ni de caractères non standard JavaDoc: RouterAddress RouterInfo Description: Ensemble complet d’informations publiées sur un router, stocké dans la base de données réseau (netDb). Il comprend l’identité, les adresses et les capacités.\nFormat:\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey Stockage de la base de données: - Type de base de données: 0 - Clé: hachage SHA-256 de RouterIdentity (identité du router) - Valeur: structure RouterInfo (informations du router) complète\nHorodatage de publication: - Date sur 8 octets (millisecondes depuis l\u0026rsquo;époque Unix) - Utilisé pour la gestion des versions de RouterInfo - Les Routers publient périodiquement un nouveau RouterInfo - Les Floodfills conservent la version la plus récente en se basant sur l\u0026rsquo;horodatage de publication\nTri des adresses: - Historique: Des routers très anciens exigeaient que les adresses soient triées selon le SHA-256 de leurs données - Actuel: Le tri n\u0026rsquo;est PAS requis, cela ne vaut pas la peine de l\u0026rsquo;implémenter pour des raisons de compatibilité - Les adresses peuvent être dans n\u0026rsquo;importe quel ordre\nChamp de taille des pairs (historique): - Toujours 0 dans I2P moderne - Était destiné aux routes restreintes (non implémenté) - S\u0026rsquo;il était implémenté, il serait suivi d\u0026rsquo;autant de Router Hashes (hachages du router) - Certaines anciennes implémentations pouvaient exiger une liste de pairs triée\nMappage des options :\nLes options DOIVENT être triées par clé. Les options standard comprennent :\nOptions de capacités:\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable Options réseau:\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; Options statistiques:\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string Voir la documentation RouterInfo de la base de données du réseau (informations sur le router) pour la liste complète des options standard.\nCalcul de la signature:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length RouterInfo moderne typique (enregistrement d\u0026rsquo;informations du router) :\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical Notes d’implémentation:\nPlusieurs adresses:\nLes routers publient généralement 1 à 4 adresses Variantes IPv4 et IPv6 Transports SSU2 et/ou NTCP2 Chaque adresse est indépendante Versionnage:\nUn RouterInfo (fiche d’information du router) plus récent a un horodatage published plus tardif Les routers republient toutes les ~2 heures ou lorsque les adresses changent Les floodfills stockent et diffusent uniquement la version la plus récente Validation:\nVérifier la signature avant d\u0026rsquo;accepter RouterInfo Vérifier que le champ d\u0026rsquo;expiration est entièrement à zéro dans chaque RouterAddress Valider que le mappage des options est trié par clé Vérifier que les types de certificats et de clés sont connus/pris en charge Base de données réseau:\nLes floodfills stockent des RouterInfo indexés par Hash(RouterIdentity) Conservés pendant ~2 jours après la dernière publication Les routers interrogent les floodfills pour découvrir d\u0026rsquo;autres routers JavaDoc: RouterInfo Notes d\u0026rsquo;implémentation Ordre des octets (Endianness) Par défaut: Big-Endian (ordre des octets du réseau)\nLa plupart des structures I2P utilisent l’ordre des octets big-endian: - Tous les types d’entiers (1-8 octets) - Horodatages de date - TunnelId - Préfixe de longueur de chaîne - Types et longueurs de certificat - Codes de type de clé - Champs de taille de mappage\nException : Little-Endian (ordre d\u0026rsquo;octets où l\u0026rsquo;octet le moins significatif est stocké en premier)\nLes types de clés suivants utilisent l\u0026rsquo;encodage little-endian : - X25519 clés de chiffrement (type 4) - EdDSA_SHA512_Ed25519 clés de signature (type 7) - EdDSA_SHA512_Ed25519ph clés de signature (type 8) - RedDSA_SHA512_Ed25519 clés de signature (type 11)\nImplémentation:\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); Versionnage des structures Ne partez jamais du principe que les tailles sont fixes :\nDe nombreuses structures ont une longueur variable: - RouterIdentity (identité du router I2P): 387+ octets (pas toujours 387) - Destination (identifiant de destination I2P): 387+ octets (pas toujours 387) - LeaseSet2 (version 2 de LeaseSet): Varie considérablement - Certificate (structure de certificat): 3+ octets\nToujours lire les champs de taille : - Longueur du certificat aux octets 1-2 - Taille du mappage au début - KeysAndCert est toujours calculé comme 384 + 3 + certificate_length\nVérifier la présence de données superflues: - Interdire les données parasites après des structures valides - Vérifier que les longueurs des certificats correspondent aux types de clés - Imposer les longueurs exactement attendues pour les types à taille fixe\nRecommandations actuelles (octobre 2025) Pour les nouvelles identités de Router:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/fr/proposals/161-ri-dest-padding/) Pour de nouvelles destinations :\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/fr/proposals/161-ri-dest-padding/) Pour les nouveaux LeaseSets:\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per [Proposal 167](/proposals/167-service-records/) Signature: EdDSA (64 bytes) Pour les services chiffrés:\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys Fonctionnalités obsolètes - Ne pas utiliser Chiffrement déprécié: - ElGamal (type 0) pour Router Identities (déprécié depuis 0.9.58) - chiffrement ElGamal/AES+SessionTag (utilisez ECIES-X25519)\nSignatures dépréciées: - DSA_SHA1 (type 0) pour les Identités de Router (déprécié depuis 0.9.58) - variantes ECDSA (types 1-3) pour les nouvelles implémentations - variantes RSA (types 4-6) sauf pour les fichiers SU3\nFormats réseau obsolètes : - LeaseSet (ensemble de baux dans I2P) type 1 (utiliser LeaseSet2) - Lease (44 octets, utiliser Lease2) - Format d\u0026rsquo;expiration de Lease d\u0026rsquo;origine\nTransports obsolètes: - NTCP (supprimé en 0.9.50) - SSU (supprimé en 2.4.0)\nCertificats obsolètes: - HASHCASH (type 1) - HIDDEN (type 2) - SIGNED (type 3) - MULTIPLE (type 4)\nConsidérations de sécurité Génération de clés: - Toujours utiliser des générateurs de nombres aléatoires cryptographiquement sûrs - Ne jamais réutiliser des clés dans des contextes différents - Protéger les clés privées avec des contrôles d\u0026rsquo;accès appropriés - Effacer en toute sécurité le matériau de clé de la mémoire une fois l\u0026rsquo;opération terminée\nVérification des signatures: - Toujours vérifier les signatures avant de faire confiance aux données - Vérifier que la longueur de la signature correspond au type de clé - S\u0026rsquo;assurer que les données signées contiennent les champs attendus - Pour les mappages triés, vérifier l\u0026rsquo;ordre de tri avant de signer/vérifier\nValidation des horodatages: - Vérifier que les horodatages de publication sont raisonnables (pas dans un futur lointain) - Valider que les dates d’expiration des leases (entrée de tunnel dans un leaseSet) ne sont pas échues - Prendre en compte la tolérance au décalage d’horloge (±30 secondes typique)\nBase de données réseau: - Valider toutes les structures avant leur stockage - Imposer des limites de taille pour prévenir les attaques par déni de service (DoS) - Limiter la fréquence des requêtes et des publications - Vérifier que les clés de la base de données correspondent aux hachages des structures\nNotes de compatibilité Rétrocompatibilité: - ElGamal et DSA_SHA1 toujours pris en charge pour les routers historiques - Les types de clés dépréciés restent fonctionnels mais sont déconseillés - Bourrage compressible (Proposal 161 ) rétrocompatible jusqu\u0026rsquo;à la version 0.6\nCompatibilité ascendante : - Les types de clés inconnus peuvent être analysés à l\u0026rsquo;aide des champs de longueur - Les types de certificats inconnus peuvent être ignorés à l\u0026rsquo;aide du champ de longueur - Les types de signatures inconnus doivent être gérés de manière robuste - Les implémenteurs ne doivent pas échouer en présence de fonctionnalités optionnelles inconnues\nStratégies de migration: - Prendre en charge à la fois les anciens et les nouveaux types de clés pendant la transition - LeaseSet2 (LeaseSet de 2e génération) peut répertorier plusieurs clés de chiffrement - Les signatures hors ligne permettent une rotation sécurisée des clés - MetaLeaseSet (format de LeaseSet pour la migration) permet une migration transparente du service\nTests et validation Validation de la structure: - Vérifier que tous les champs de longueur se situent dans les plages attendues - Vérifier que les structures à longueur variable sont analysées correctement - Valider que la vérification des signatures réussit - Tester avec des structures de taille minimale et maximale\nCas limites : - Chaînes de longueur nulle - Mappages vides - Nombre minimal et maximal de leases (entrées de tunnel I2P) - Certificat avec une charge utile de longueur nulle - Structures très volumineuses (proches des tailles maximales)\nInteropérabilité: - Tester par rapport à l\u0026rsquo;implémentation Java officielle d\u0026rsquo;I2P - Vérifier la compatibilité avec i2pd - Tester avec divers contenus de la base de données réseau (netDb) - Valider à l\u0026rsquo;aide de vecteurs de test réputés corrects\nRéférences Spécifications Protocole I2NP Protocole I2CP Transport SSU2 Transport NTCP2 Protocole de tunnel Protocole de datagrammes Cryptographie Vue d’ensemble de la cryptographie Chiffrement ElGamal/AES Chiffrement ECIES-X25519 ECIES pour les routers ECIES hybride (post-quantique) Signatures Red25519 LeaseSet chiffré Propositions Proposition 123: Nouvelles entrées netDB Proposition 134: Types de signature GOST Proposition 136: Types de signature expérimentaux Proposition 145: ECIES-P256 Proposition 156: ECIES Routers Proposition 161: Génération du bourrage Proposition 167: Enregistrements de service Proposition 169: Cryptographie post-quantique Index de toutes les propositions Base de données réseau Aperçu de la base de données réseau Options standard de RouterInfo Référence de l\u0026rsquo;API JavaDoc Package de données cœur PublicKey PrivateKey SessionKey SigningPublicKey SigningPrivateKey Signature Hash SessionTag TunnelId Certificate DataHelper KeysAndCert RouterIdentity Destination Lease LeaseSet Lease2 LeaseSet2 MetaLease MetaLeaseSet EncryptedLeaseSet RouterAddress RouterInfo Normes externes RFC 7748 (X25519): Courbes elliptiques pour la sécurité RFC 7539 (ChaCha20): ChaCha20 et Poly1305 pour les protocoles de l\u0026rsquo;IETF RFC 4648 (Base64): Les encodages de données Base16, Base32 et Base64 FIPS 180-4 (SHA-256): Norme de hachage sécurisé FIPS 204 (ML-DSA): Norme de signature numérique basée sur des réseaux modulaires (module-lattice) Registre des services de l\u0026rsquo;IANA Ressources de la communauté Site Web I2P Forum I2P GitLab d\u0026rsquo;I2P Miroir GitHub d\u0026rsquo;I2P Index de la documentation technique Informations sur la version Annonce de la version 2.10.0 d’I2P Historique des versions Journal des modifications Annexe : tableaux de référence rapide Référence rapide des types de clés Standard actuel (recommandé pour toutes les nouvelles implémentations): - Chiffrement: X25519 (type 4, 32 octets, little-endian (ordre des octets du moins significatif au plus significatif)) - Signature: EdDSA_SHA512_Ed25519 (type 7, 32 octets, little-endian)\nAncien (pris en charge mais obsolète): - Chiffrement: ElGamal (type 0, 256 octets, big-endian (ordre des octets du plus significatif au moins significatif)) - Signature: DSA_SHA1 (type 0, 20 octets pour la clé privée / 128 octets pour la clé publique, big-endian)\nSpécialisé: - Signature (LeaseSet chiffré): RedDSA_SHA512_Ed25519 (type 11, 32 octets, little-endian (ordre petit-boutiste))\nPost-quantique (bêta, non finalisé): - Chiffrement hybride: variantes MLKEM_X25519 (types 5-7) - Chiffrement post-quantique pur: variantes MLKEM (pas encore de codes de type attribués)\nRéférence rapide des tailles de structures Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes ### Référence rapide des types de base de données Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status ### Référence rapide du protocole de transport Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 ### Référence rapide des jalons de version Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023[Proposal 161](/fr/proposals/161-ri-dest-padding/) padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025[Proposal 167](/proposals/167-service-records/) service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) --- ","description":"Types de données partagés et formats de sérialisation utilisés dans l’ensemble des spécifications I2P","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"Structures communes","url":"/fr/docs/specs/common-structures/"},{"categories":null,"content":"Aperçu NTCP2 remplace l’ancien transport NTCP par un handshake basé sur Noise (framework de protocoles cryptographiques) qui résiste au fingerprinting du trafic, chiffre les champs de longueur et prend en charge des suites cryptographiques modernes. Les routers peuvent exécuter NTCP2 aux côtés de SSU2, les deux protocoles de transport obligatoires du réseau I2P. NTCP (version 1) a été déprécié dans la 0.9.40 (mai 2019) et entièrement supprimé dans la 0.9.50 (mai 2021).\nCadre de protocoles Noise NTCP2 utilise le Noise Protocol Framework (cadre de protocoles cryptographiques) Revision 33, 2017-10-04 avec des extensions spécifiques à I2P :\nSchéma: Noise_XK_25519_ChaChaPoly_SHA256 Identifiant étendu: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256 (pour l\u0026rsquo;initialisation du KDF, fonction de dérivation de clé) Fonction DH: X25519 (RFC 7748) - clés de 32 octets, encodage little-endian Chiffrement: AEAD_CHACHA20_POLY1305 (RFC 7539/RFC 8439) Nonce de 12 octets: 4 premiers octets à zéro, 8 derniers octets servent de compteur (little-endian) Valeur maximale du nonce: 2^64 - 2 (la connexion doit se terminer avant d\u0026rsquo;atteindre 2^64 - 1) Fonction de hachage: SHA-256 (sortie de 32 octets) MAC: Poly1305 (tag d\u0026rsquo;authentification de 16 octets) Extensions spécifiques à I2P Obfuscation par AES: Clés éphémères chiffrées avec AES-256-CBC en utilisant le hachage du router de Bob et un IV publié (vecteur d\u0026rsquo;initialisation) Bourrage aléatoire: Bourrage en clair dans les messages 1-2 (authentifiés), bourrage AEAD (Authenticated Encryption with Associated Data) dans les messages 3+ (chiffrés) Obfuscation de la longueur par SipHash-2-4: Longueurs de trame sur deux octets XORées (OU exclusif) avec la sortie de SipHash Structure des trames: Trames préfixées par la longueur pour la phase de données (compatibilité avec le streaming TCP) Charges utiles basées sur des blocs: Format de données structuré avec des blocs typés Flux de négociation Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► Poignée de main en trois messages SessionRequest - la clé éphémère obfusquée d\u0026rsquo;Alice, options, indications de bourrage SessionCreated - la clé éphémère obfusquée de Bob, options chiffrées, bourrage SessionConfirmed - la clé statique chiffrée d\u0026rsquo;Alice et RouterInfo (deux trames AEAD) Schémas de messages Noise XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 Niveaux d’authentification: - 0: Aucune authentification (n’importe qui aurait pu l’envoyer) - 2: Authentification de l’expéditeur résistante aux attaques de key-compromise impersonation (KCI, usurpation en cas de compromission de clé)\nNiveaux de confidentialité: - 1: Destinataire éphémère (confidentialité persistante, aucune authentification du destinataire) - 2: Destinataire connu, confidentialité persistante uniquement en cas de compromission de l\u0026rsquo;expéditeur - 5: Confidentialité persistante forte (DH éphémère-éphémère + éphémère-statique)\nSpécifications des messages Notation des clés RH_A = Hachage du Router d’Alice (32 octets, SHA-256) RH_B = Hachage du Router de Bob (32 octets, SHA-256) || = opérateur de concaténation byte(n) = Un octet unique de valeur n Tous les entiers multi-octets sont en big-endian sauf indication contraire Les clés X25519 sont en little-endian (32 octets) Chiffrement authentifié (ChaCha20-Poly1305) Fonction de chiffrement :\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) Paramètres: - key: clé de chiffrement de 32 octets issue d\u0026rsquo;une KDF (fonction de dérivation de clé) - nonce: 12 octets (4 octets nuls + compteur sur 8 octets, little-endian (ordre des octets du moins significatif au plus significatif)) - associatedData: hachage de 32 octets pendant la phase de handshake (établissement de session); longueur nulle pendant la phase de données - plaintext: Données à chiffrer (0+ octets)\nSortie: - Texte chiffré: Même longueur que le texte en clair - MAC: 16 octets (tag d\u0026rsquo;authentification Poly1305)\nGestion du nonce (nombre à usage unique): - Le compteur commence à 0 pour chaque instance de chiffrement - S\u0026rsquo;incrémente à chaque opération AEAD dans cette direction - Compteurs séparés pour Alice→Bob et Bob→Alice dans la phase de données - La connexion doit être interrompue avant que le compteur n\u0026rsquo;atteigne 2^64 - 1\nMessage 1 : SessionRequest (requête de session) Alice initie une connexion vers Bob.\nOpérations Noise: e, es (génération et échange de clés éphémères)\nFormat brut +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Contraintes de taille : - Minimum : 80 octets (32 AES + 48 AEAD) - Maximum : 65535 octets au total - Cas particulier : 287 octets max lors de la connexion à des adresses \u0026ldquo;NTCP\u0026rdquo; (détection de la version)\nContenu déchiffré +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Bloc d’options (16 octets, big-endian (ordre des octets gros-boutiste)) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 Champs critiques: - Network ID (depuis la version 0.9.42): Rejet rapide des connexions entre réseaux - m3p2len: Taille exacte du message 3 partie 2 (doit correspondre lors de l’envoi)\nFonction de dérivation de clé (KDF-1) Initialiser le protocole :\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash Opérations de MixHash :\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD Opération MixKey (es pattern — schéma « es »):\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF Notes d\u0026rsquo;implémentation Obfuscation par AES: Utilisée uniquement pour la résistance au DPI (inspection approfondie des paquets) ; toute personne disposant du hachage du router de Bob et de l’IV (vecteur d’initialisation) peut déchiffrer X Prévention du rejeu: Bob doit mettre en cache les valeurs X (ou leurs équivalents chiffrés) pendant au moins 2*D secondes (D = écart d’horloge maximal) Validation de l’horodatage: Bob doit rejeter les connexions avec |tsA - current_time| \u0026gt; D (typiquement D = 60 secondes) Validation de la courbe: Bob doit vérifier que X est un point X25519 valide Rejet rapide: Bob peut vérifier que X[31] \u0026amp; 0x80 == 0 avant déchiffrement (les clés X25519 valides ont le bit de poids fort (MSB) à 0) Gestion des erreurs: En cas d’échec, Bob ferme avec un TCP RST après un délai aléatoire et la lecture d’un nombre aléatoire d’octets Mise en tampon: Alice doit vider l’intégralité du message (y compris le remplissage) en une seule fois pour des raisons d’efficacité Message 2 : SessionCreated Bob répond à Alice.\nOpérations Noise (cadre de protocoles cryptographiques) : e, ee (DH éphémère-éphémère)\nFormat brut +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Contenu déchiffré +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Bloc d’options (16 octets, big-endian) +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) Fonction de dérivation de clés (KDF-2) Opérations de MixHash:\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD Opération MixKey (schéma ee):\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF Nettoyage de la mémoire:\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side Notes d\u0026rsquo;implémentation Chaînage AES: Le chiffrement de Y utilise l’état AES-CBC du message 1 (non réinitialisé) Prévention des rejouements: Alice doit mettre en cache les valeurs Y pendant au moins 2*D secondes Validation de l’horodatage: Alice doit rejeter |tsB - current_time| \u0026gt; D Validation de la courbe: Alice doit vérifier que Y est un point X25519 valide Gestion des erreurs: Alice ferme avec un TCP RST en cas d’échec Mise en tampon: Bob doit vider l’intégralité du message en une seule fois Message 3 : SessionConfirmed Alice confirme la session et envoie RouterInfo (informations du router).\nOpérations Noise: s, se (révélation de clé statique et DH statique-éphémère)\nStructure en deux parties Message 3 se compose de deux trames AEAD (chiffrement authentifié avec des données associées) distinctes:\nPartie 1: Trame fixe de 48 octets avec la clé statique chiffrée d\u0026rsquo;Alice Partie 2: Trame de longueur variable avec RouterInfo, des options et du bourrage Format brut +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Contraintes de taille: - Partie 1: Exactement 48 octets (32 texte en clair + 16 MAC) - Partie 2: Longueur spécifiée dans le message 1 (champ m3p2len) - Maximum total: 65535 octets (partie 1 max 48, donc partie 2 max 65487)\nContenu déchiffré Partie 1:\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ Partie 2 :\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ Fonction de dérivation de clé (KDF-3) Partie 1 (modèle s):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 Partie 2 (se pattern):\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF Nettoyage de la mémoire:\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side Notes de mise en œuvre Validation de RouterInfo (métadonnées du router): Bob doit vérifier la signature, l’horodatage et la cohérence des clés Correspondance des clés: Bob doit vérifier que la clé statique d’Alice dans la partie 1 correspond à la clé dans RouterInfo Emplacement de la clé statique: Rechercher un paramètre \u0026ldquo;s\u0026rdquo; correspondant dans le RouterAddress (adresse du router) NTCP ou NTCP2 Ordre des blocs: RouterInfo doit être en premier, Options en second (si présentes), Padding en dernier (si présent) Planification de la longueur: Alice doit s’assurer que m3p2len dans le message 1 correspond exactement à la longueur de la partie 2 Mise en tampon: Alice doit envoyer les deux parties ensemble en un seul envoi TCP Chaînage facultatif: Alice peut ajouter immédiatement une trame de phase de données pour plus d’efficacité Phase de données Après l’achèvement de la négociation, tous les messages utilisent des trames AEAD (chiffrement authentifié avec données associées) à longueur variable avec des champs de longueur obfusqués.\nFonction de dérivation de clés (phase de données) Fonction Split (Noise):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) Dérivation de clé SipHash:\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV Structure de trame +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ Contraintes de trame: - Minimum: 18 octets (2 longueur obfusquée + 0 texte en clair + 16 MAC) - Maximum: 65537 octets (2 longueur obfusquée + 65535 trame) - Recommandé: Quelques Ko par trame (minimiser la latence côté récepteur)\nObfuscation de la longueur avec SipHash Objectif : Empêcher l’identification par DPI des limites de trame\nAlgorithme :\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes Décodage:\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) Notes : - Chaînes d\u0026rsquo;IV (vecteur d\u0026rsquo;initialisation) séparées pour chaque direction (Alice→Bob et Bob→Alice) - Si SipHash renvoie uint64, utiliser les 2 octets de poids faible comme masque - Convertir uint64 en l\u0026rsquo;IV suivant sous forme d\u0026rsquo;octets little-endian\nFormat de bloc Chaque trame contient zéro ou plusieurs blocs :\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload Limites de taille: - Trame maximale : 65535 octets (y compris le MAC) - Espace maximal d\u0026rsquo;un bloc : 65519 octets (trame - MAC de 16 octets) - Taille maximale d\u0026rsquo;un bloc : 65519 octets (en-tête de 3 octets + 65516 octets de données)\nTypes de blocs Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions **Règles d’ordonnancement des blocs:** - **Message 3 partie 2**: RouterInfo (informations du router), Options (facultatif), Padding (facultatif) - AUCUN autre type - **Phase de données**: N'importe quel ordre sauf: - Padding DOIT être le dernier bloc si présent - Termination DOIT être le dernier bloc (sauf Padding) si présent - Plusieurs blocs I2NP autorisés par trame - Plusieurs blocs Padding NON autorisés par trame Type de bloc 0 : DateTime Synchronisation de l\u0026rsquo;heure pour la détection du décalage d\u0026rsquo;horloge.\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) Implémentation: Arrondir à la seconde la plus proche pour éviter l\u0026rsquo;accumulation du biais d\u0026rsquo;horloge.\nType de bloc 1 : Options Paramètres de bourrage et de mise en forme du trafic.\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) Taux de bourrage (nombre en virgule fixe 4.4, valeur/16.0): - tmin: Taux de bourrage minimal en émission (0.0 - 15.9375) - tmax: Taux de bourrage maximal en émission (0.0 - 15.9375) - rmin: Taux de bourrage minimal en réception (0.0 - 15.9375) - rmax: Taux de bourrage maximal en réception (0.0 - 15.9375)\nExemples : - 0x00 = 0 % de bourrage - 0x01 = 6,25 % de bourrage - 0x10 = 100 % de bourrage (rapport 1:1) - 0x80 = 800 % de bourrage (rapport 8:1)\nTrafic factice: - tdmy: Maximum prêt à envoyer (2 octets, débit moyen en octets/s) - rdmy: Montant demandé en réception (2 octets, débit moyen en octets/s)\nInsertion de délai: - tdelay: Maximum disposé à insérer (2 octets, moyenne en millisecondes) - rdelay: Délai demandé (2 octets, moyenne en millisecondes)\nDirectives: - Les valeurs minimales indiquent la résistance souhaitée à l\u0026rsquo;analyse de trafic - Les valeurs maximales indiquent les contraintes de bande passante - L\u0026rsquo;expéditeur doit respecter la valeur maximale du destinataire - L\u0026rsquo;expéditeur peut respecter la valeur minimale du destinataire dans les limites des contraintes - Aucun mécanisme de contrainte; les implémentations peuvent varier\nType de bloc 2 : RouterInfo (informations du router) Acheminement des RouterInfo (métadonnées d\u0026rsquo;un Router) pour le peuplement et l’inondation de la netDb.\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 Utilisation:\nDans le message 3 partie 2 (handshake): - Alice envoie son RouterInfo à Bob - Flood bit (bit d\u0026rsquo;inondation) généralement à 0 (stockage local) - RouterInfo n\u0026rsquo;est PAS compressé avec gzip\nEn phase de données: - L\u0026rsquo;une ou l\u0026rsquo;autre des parties peut envoyer son RouterInfo mis à jour - Flood bit = 1: Demande de distribution via floodfill (si le destinataire est floodfill) - Flood bit = 0: Stockage local netdb uniquement\nExigences de validation: 1. Vérifier que le type de signature est pris en charge 2. Vérifier la signature du RouterInfo 3. Vérifier que l\u0026rsquo;horodatage est dans des limites acceptables 4. Pour le handshake: Vérifier que la clé statique correspond au paramètre \u0026ldquo;s\u0026rdquo; de l\u0026rsquo;adresse NTCP2 5. Pour la phase de données: Vérifier que le hachage du router correspond au pair de la session 6. Ne diffuser que les RouterInfos avec des adresses publiées\nRemarques: - Pas de mécanisme d\u0026rsquo;ACK (accusé de réception) (utilisez I2NP DatabaseStore avec un jeton de réponse si nécessaire) - Peut contenir des RouterInfos de tiers (usage de floodfill) - PAS compressé en gzip (contrairement à I2NP DatabaseStore)\nType de bloc 3: Message I2NP Message I2NP à en-tête raccourci de 9 octets.\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) Différences par rapport à NTCP1: - Expiration : 4 octets (secondes) contre 8 octets (millisecondes) - Longueur : Omise (déductible de la longueur du bloc) - Somme de contrôle : Omise (AEAD assure l\u0026rsquo;intégrité) - En-tête : 9 octets contre 16 octets (réduction de 44 %)\nFragmentation: - Les messages I2NP NE DOIVENT PAS être fragmentés sur plusieurs blocs - Les messages I2NP NE DOIVENT PAS être fragmentés sur plusieurs trames - Plusieurs blocs I2NP sont autorisés par trame\nType de bloc 4: Terminaison Fermeture explicite de la connexion avec un code de motif.\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) Codes motif:\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny **Règles:** - La terminaison DOIT être le dernier bloc qui n’est pas de remplissage dans la trame - Un seul bloc de terminaison par trame au maximum - L’émetteur devrait fermer la connexion après l’envoi - Le récepteur devrait fermer la connexion après la réception Gestion des erreurs : - Erreurs de handshake : se terminent généralement par un TCP RST (pas de bloc de terminaison) - Erreurs AEAD (chiffrement authentifié avec données associées) pendant la phase de données : délai d\u0026rsquo;expiration aléatoire + lecture aléatoire, puis envoi d\u0026rsquo;une terminaison - Voir la section \u0026ldquo;AEAD Error Handling\u0026rdquo; pour les procédures de sécurité\nType de bloc 254 : Bourrage Bourrage aléatoire pour résister à l\u0026rsquo;analyse de trafic.\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes Règles : - Le bloc de bourrage DOIT être le dernier bloc de la trame s\u0026rsquo;il est présent - Un bourrage de longueur nulle est autorisé - Un seul bloc de bourrage par trame - Les trames composées uniquement de bourrage sont autorisées - Devrait respecter les paramètres négociés du Options block (bloc d\u0026rsquo;options)\nBourrage dans les messages 1-2: - Hors de la trame AEAD (chiffrement authentifié avec données associées) (texte en clair) - Inclus dans la chaîne de hachage du message suivant (authentifié) - La falsification est détectée lorsque l\u0026rsquo;AEAD du message suivant échoue\nBourrage dans Message 3+ et la phase de données: - Dans la trame AEAD (chiffrée et authentifiée) - Utilisé pour la mise en forme du trafic et l\u0026rsquo;obfuscation de la taille\nGestion des erreurs de l’AEAD (chiffrement authentifié avec données associées) Exigences de sécurité critiques :\nPhase de négociation (Messages 1 à 3) Taille de message connue : - Les tailles de messages sont prédéterminées ou spécifiées à l\u0026rsquo;avance - Un échec d\u0026rsquo;authentification AEAD est sans ambiguïté\nRéponse de Bob à l\u0026rsquo;échec du Message 1: 1. Définir un délai d\u0026rsquo;expiration aléatoire (plage dépendante de l\u0026rsquo;implémentation, suggéré 100-500ms) 2. Lire un nombre aléatoire d\u0026rsquo;octets (plage dépendante de l\u0026rsquo;implémentation, suggéré 1KB-64KB) 3. Fermer la connexion avec TCP RST (aucune réponse) 4. Bloquer temporairement l\u0026rsquo;adresse IP source 5. Suivre les échecs répétés en vue de bannissements à long terme\nRéponse d\u0026rsquo;Alice à l\u0026rsquo;échec du message 2: 1. Fermer la connexion immédiatement avec TCP RST 2. Ne pas répondre à Bob\nRéponse de Bob à l\u0026rsquo;échec du message 3: 1. Fermer immédiatement la connexion avec un TCP RST 2. Aucune réponse à Alice\nPhase de données Taille du message obfusquée: - Le champ de longueur est obfusqué par SipHash - Une longueur invalide ou un échec AEAD (chiffrement authentifié avec données associées) peut indiquer: - Sondage par un attaquant - Corruption des données réseau - IV SipHash désynchronisé - Pair malveillant\nRéponse à une erreur AEAD ou de longueur: 1. Définir un délai d\u0026rsquo;expiration aléatoire (recommandé : 100-500 ms) 2. Lire un nombre aléatoire d\u0026rsquo;octets (recommandé : 1 Ko-64 Ko) 3. Envoyer un bloc de terminaison avec le code de raison 4 (échec AEAD) ou 9 (erreur de trame) 4. Fermer la connexion\nPrévention d\u0026rsquo;un oracle de déchiffrement: - Ne jamais révéler le type d\u0026rsquo;erreur au pair avant l\u0026rsquo;expiration d\u0026rsquo;un délai d\u0026rsquo;attente aléatoire - Ne jamais omettre la validation de la longueur avant la vérification AEAD - Traiter une longueur invalide de la même manière qu\u0026rsquo;un échec AEAD - Utiliser un chemin de gestion des erreurs identique pour les deux erreurs\nConsidérations d’implémentation: - Certaines implémentations peuvent continuer après des erreurs AEAD si elles sont peu fréquentes - Mettre fin après des erreurs répétées (seuil suggéré: 3 à 5 erreurs par heure) - Équilibrer la reprise après erreur et la sécurité\nRouterInfo (fiche d\u0026rsquo;information du router) publié Format d\u0026rsquo;adresse du router La prise en charge de NTCP2 est annoncée via des entrées RouterAddress (adresse du router) publiées avec des options spécifiques.\nStyle de transport: - \u0026quot;NTCP2\u0026quot; - NTCP2 uniquement sur ce port - \u0026quot;NTCP\u0026quot; - NTCP et NTCP2 tous deux sur ce port (détection automatique) - Remarque: la prise en charge de NTCP (v1) a été supprimée dans la version 0.9.50 (mai 2021) - Le style \u0026ldquo;NTCP\u0026rdquo; est désormais obsolète ; utilisez \u0026ldquo;NTCP2\u0026rdquo;\nOptions requises Toutes les adresses NTCP2 publiées:\nhost - Adresse IP (IPv4 ou IPv6) ou nom d\u0026rsquo;hôte\nFormat: notation IP standard ou nom de domaine Peut être omis pour les routers uniquement sortants ou cachés port - Numéro de port TCP\nFormat : entier, 1-65535 Peut être omis pour les routers uniquement sortants ou cachés s - Clé publique statique (X25519, algorithme de courbe elliptique)\nFormat: encodé en Base64, 44 caractères Encodage: alphabet Base64 d\u0026rsquo;I2P Source: clé publique X25519 de 32 octets, little-endian (octet de poids faible en premier) i - Vecteur d\u0026rsquo;initialisation pour AES\nFormat: Encodé en Base64, 24 caractères Encodage: alphabet Base64 d\u0026rsquo;I2P Source: IV de 16 octets, big-endian v - Version du protocole\nFormat: entier ou entiers séparés par des virgules Actuel: \u0026quot;2\u0026quot; Futur: \u0026quot;2,3\u0026quot; (doit être en ordre numérique) Options facultatives:\ncaps - Capacités (depuis la version 0.9.50)\nFormat: chaîne de caractères indiquant les capacités Valeurs: \u0026quot;4\u0026quot; - capacité sortante IPv4 \u0026quot;6\u0026quot; - capacité sortante IPv6 \u0026quot;46\u0026quot; - IPv4 et IPv6 (ordre recommandé) Pas nécessaire si host est publié Utile pour les routers cachés/derrière un pare-feu cost - Priorité de l\u0026rsquo;adresse\nFormat: entier, 0-255 Valeurs plus faibles = priorité plus élevée Suggéré: 5-10 pour les adresses normales Suggéré: 14 pour les adresses non publiées Exemples d\u0026rsquo;entrées RouterAddress Adresse IPv4 publiée:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Router masqué (sortant uniquement):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Router à double pile:\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Règles importantes: - Plusieurs adresses NTCP2 avec le même port DOIVENT utiliser des valeurs s, i et v identiques - Des ports différents peuvent utiliser des clés différentes - Les routers à double pile devraient publier des adresses IPv4 et IPv6 séparées\nAdresse NTCP2 non publiée Pour les routers sortants uniquement :\nSi un router n\u0026rsquo;accepte pas les connexions NTCP2 entrantes mais établit des connexions sortantes, il DOIT tout de même publier une RouterAddress (adresse du routeur) avec:\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Objectif: - Permet à Bob de valider la clé statique d\u0026rsquo;Alice pendant la négociation - Nécessaire à la vérification de RouterInfo du message 3 partie 2 - Aucun i, host ni port requis (sortant uniquement)\nAlternative: - Ajouter s et v à l\u0026rsquo;adresse \u0026ldquo;NTCP\u0026rdquo; ou SSU déjà publiée\nRotation de la clé publique et de l\u0026rsquo;IV (vecteur d\u0026rsquo;initialisation) Politique de sécurité critique :\nRègles générales : 1. Ne jamais effectuer une rotation pendant que le router est en cours d’exécution 2. Conserver de manière persistante la clé et l’IV (vecteur d’initialisation) entre les redémarrages 3. Suivre le temps d’arrêt précédent pour déterminer l’éligibilité à la rotation\nTemps d\u0026rsquo;arrêt minimal avant la rotation:\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact **Déclencheurs supplémentaires:** - Changement d'adresse IP locale: Peut entraîner une rotation indépendamment du temps d'arrêt - Router \"rekey\" (nouveau Router Hash): Générer de nouvelles clés Justification: - Empêche d\u0026rsquo;exposer les heures de redémarrage via des changements de clés - Permet aux RouterInfos mis en cache d\u0026rsquo;expirer naturellement - Maintient la stabilité du réseau - Réduit les tentatives de connexion échouées\nImplémentation: 1. Stocker de manière persistante la clé, le vecteur d\u0026rsquo;initialisation (IV) et l\u0026rsquo;horodatage du dernier arrêt 2. Au démarrage, calculer downtime = current_time - last_shutdown 3. Si downtime \u0026gt; minimum pour le type de router, peut procéder à une rotation 4. Si l\u0026rsquo;IP a changé ou en cas de renouvellement des clés, peut procéder à une rotation 5. Sinon, réutiliser la clé et l\u0026rsquo;IV précédents\nRotation de l\u0026rsquo;IV: - Soumise aux mêmes règles que la rotation de clé - Présente uniquement dans les adresses publiées (pas dans les routers cachés) - Recommandé de changer l\u0026rsquo;IV chaque fois que la clé change\nDétection de version Contexte: Lorsque transportStyle=\u0026quot;NTCP\u0026quot; (ancien), Bob prend en charge à la fois NTCP v1 et v2 sur le même port et doit détecter automatiquement la version du protocole.\nAlgorithme de détection:\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 Vérification rapide du MSB (bit de poids fort) : - Avant le déchiffrement AES, vérifiez : encrypted_X[31] \u0026amp; 0x80 == 0 - Les clés X25519 valides ont le bit de poids fort à zéro - Un échec indique probablement NTCP1 (ou une attaque) - Implémentez une résistance au sondage (temporisation aléatoire + lecture) en cas d\u0026rsquo;échec\nExigences d\u0026rsquo;implémentation:\nResponsabilité d\u0026rsquo;Alice :\nLors de la connexion à une adresse \u0026ldquo;NTCP\u0026rdquo;, limiter le message 1 à 287 octets maximum Mettre en mémoire tampon et vider l\u0026rsquo;intégralité du message 1 en une seule fois Augmente la probabilité d\u0026rsquo;une livraison en un seul paquet TCP Responsabilités de Bob :\nMettre en mémoire tampon les données reçues avant de déterminer la version Implémenter une gestion correcte des délais d’expiration Utiliser TCP_NODELAY pour une détection rapide de la version Mettre en mémoire tampon puis vider l’intégralité du message 2 en une seule fois après détection de la version Considérations de sécurité : - Attaques par segmentation : Bob doit être résistant à la segmentation TCP - Attaques de sondage : mettre en œuvre des délais aléatoires et des lectures d’octets en cas d’échec - Prévention du déni de service (DoS) : limiter les connexions en attente simultanées - Délais d’expiration de lecture : à la fois par lecture et au total (\u0026ldquo;slowloris\u0026rdquo; protection)\nDirectives sur le décalage d’horloge Champs d\u0026rsquo;horodatage: - Message 1: tsA (horodatage d\u0026rsquo;Alice) - Message 2: tsB (horodatage de Bob) - Message 3+: Blocs DateTime (date/heure) optionnels\nDécalage maximal (D): - Typique : ±60 secondes - Configurable selon l’implémentation - Un décalage \u0026gt; D est généralement fatal\nTraitement par Bob (Message 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally Justification: L\u0026rsquo;envoi du message 2, même en cas de décalage d\u0026rsquo;horloge, permet à Alice de diagnostiquer des problèmes d\u0026rsquo;horloge.\nTraitement par Alice (Message 2) 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization Ajustement du RTT (Round-Trip Time, temps aller-retour): - Soustraire la moitié du RTT du décalage calculé - Tient compte du délai de propagation sur le réseau - Estimation du décalage plus précise\nTraitement par Bob (Message 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) Synchronisation de l\u0026rsquo;heure Blocs DateTime (phase de données): - Envoyer périodiquement un bloc DateTime (type 0) - Le récepteur peut l\u0026rsquo;utiliser pour l\u0026rsquo;ajustement de l\u0026rsquo;horloge - Arrondir l\u0026rsquo;horodatage à la seconde la plus proche (pour éviter un biais)\nSources de temps externes: - NTP (Network Time Protocol) - Synchronisation de l\u0026rsquo;horloge système - Temps de consensus du réseau I2P\nStratégies d’ajustement de l’horloge: - Si l’horloge locale est incorrecte : ajuster l’heure du système ou utiliser un décalage - Si les horloges des pairs sont constamment incorrectes : signaler un problème côté pair - Suivre les statistiques de dérive d’horloge pour la surveillance de la santé du réseau\nPropriétés de sécurité Confidentialité persistante Réalisé grâce à : - Échange de clés Diffie-Hellman éphémère (X25519) - Trois opérations DH : es, ee, se (schéma Noise XK) - Clés éphémères détruites après l\u0026rsquo;achèvement de la négociation (handshake)\nProgression de la confidentialité : - Message 1 : Niveau 2 (confidentialité persistante en cas de compromission de l\u0026rsquo;expéditeur) - Message 2 : Niveau 1 (destinataire éphémère) - Message 3+ : Niveau 5 (forte confidentialité persistante)\nPerfect Forward Secrecy (confidentialité persistante): - La compromission de clés statiques à long terme ne révèle PAS les anciennes clés de session - Chaque session utilise des clés éphémères uniques - Les clés privées éphémères ne sont jamais réutilisées - Nettoyage de la mémoire après la négociation de clés\nLimitations : - Message 1 vulnérable si la clé statique de Bob est compromise (mais confidentialité persistante en cas de compromission d\u0026rsquo;Alice) - Des attaques par rejeu sont possibles pour le message 1 (atténuées par un horodatage et un cache anti-rejeu)\nAuthentification Authentification mutuelle : - Alice authentifiée par une clé statique dans le message 3 - Bob authentifié par la possession de la clé privée statique (implicite suite à un échange initial réussi)\nRésistance à la Key Compromise Impersonation (usurpation d\u0026rsquo;identité après compromission de clé, KCI): - Niveau d\u0026rsquo;authentification 2 (résistant aux attaques KCI) - L\u0026rsquo;attaquant ne peut pas usurper l\u0026rsquo;identité d\u0026rsquo;Alice même avec la clé privée statique d\u0026rsquo;Alice (sans la clé éphémère d\u0026rsquo;Alice) - L\u0026rsquo;attaquant ne peut pas usurper l\u0026rsquo;identité de Bob même avec la clé privée statique de Bob (sans la clé éphémère de Bob)\nVérification de la clé statique: - Alice connaît à l\u0026rsquo;avance la clé statique de Bob (à partir de RouterInfo) - Bob vérifie que la clé statique d\u0026rsquo;Alice correspond à RouterInfo dans le message 3 - Empêche les attaques de type « man-in-the-middle »\nRésistance à l\u0026rsquo;analyse du trafic Contre-mesures DPI (inspection profonde des paquets): 1. Obfuscation AES: Clés éphémères chiffrées, aspect aléatoire 2. Obfuscation de la longueur avec SipHash: Les longueurs de trame ne sont pas en clair 3. Bourrage aléatoire: Tailles de message variables, aucun motif fixe 4. Trames chiffrées: Toute la charge utile est chiffrée avec ChaCha20\nPrévention des attaques par rejeu : - Validation de l\u0026rsquo;horodatage (±60 secondes) - Cache anti-rejeu des clés éphémères (durée de vie 2*D) - Les incréments de nonce (nombre utilisé une seule fois) empêchent le rejeu de paquets au sein de la session\nRésistance au sondage: - Temporisations aléatoires en cas d\u0026rsquo;échecs AEAD (chiffrement authentifié avec données associées) - Lectures d\u0026rsquo;octets aléatoires avant la fermeture de la connexion - Aucune réponse en cas d\u0026rsquo;échecs du handshake (établissement de la connexion) - Mise sur liste noire des IP en cas d\u0026rsquo;échecs répétés\nDirectives de bourrage: - Messages 1-2: Bourrage en clair (authentifié) - Message 3+: Bourrage chiffré à l\u0026rsquo;intérieur des trames AEAD - Paramètres de bourrage négociés (Options block) - Trames uniquement de bourrage autorisées\nAtténuation des attaques par déni de service Limites de connexion: - Nombre maximal de connexions actives (dépendant de l’implémentation) - Nombre maximal de handshakes (initialisation de connexion) en attente (p. ex., 100-1000) - Limites de connexion par IP (p. ex., 3-10 simultanées)\nProtection des ressources: - Limitation du débit des opérations DH (coûteuses) - Temporisations de lecture par socket et totales - Protection \u0026ldquo;Slowloris\u0026rdquo; (limites de temps totales) - Mise en liste noire des IP en cas d\u0026rsquo;abus\nRejet rapide: - Non-correspondance de l\u0026rsquo;ID de réseau → fermeture immédiate - Point X25519 invalide → vérification rapide du bit de poids fort (MSB) avant déchiffrement - Horodatage hors limites → fermeture sans calcul - Échec de l\u0026rsquo;AEAD → aucune réponse, délai aléatoire\nRésistance au sondage: - Temporisation aléatoire: 100-500ms (dépend de l’implémentation) - Lecture aléatoire: 1KB-64KB (dépend de l’implémentation) - Aucune information d’erreur transmise à l’attaquant - Fermeture avec TCP RST (sans handshake FIN)\nSécurité cryptographique Algorithmes: - X25519: sécurité de 128 bits, DH à courbe elliptique (Curve25519) - ChaCha20: chiffrement en flux à clé de 256 bits - Poly1305: MAC sécurisé au sens de la théorie de l\u0026rsquo;information - SHA-256: résistance aux collisions de 128 bits, résistance aux préimages de 256 bits - HMAC-SHA256: PRF (fonction pseudo-aléatoire) pour la dérivation de clés\nTailles des clés: - Clés statiques: 32 octets (256 bits) - Clés éphémères: 32 octets (256 bits) - Clés de chiffrement: 32 octets (256 bits) - MAC: 16 octets (128 bits)\nProblèmes connus: - La réutilisation du nonce (valeur aléatoire à usage unique) ChaCha20 est catastrophique (empêchée par l\u0026rsquo;incrément du compteur) - X25519 présente des problèmes liés aux petits sous-groupes (atténués par la validation de la courbe) - SHA-256 est théoriquement vulnérable à l’extension de longueur (non exploitable dans HMAC)\nAucune vulnérabilité connue (à ce jour, octobre 2025): - Noise Protocol Framework largement analysé - ChaCha20-Poly1305 déployé dans TLS 1.3 - X25519 standard des protocoles modernes - Aucune attaque pratique connue contre la construction\nRéférences Spécifications principales Spécification NTCP2 - Spécification officielle d’I2P Proposition 111 - Document de conception original avec justification Noise Protocol Framework (cadre de protocoles Noise) - Révision 33 (2017-10-04) Normes cryptographiques RFC 7748 - Courbes elliptiques pour la sécurité (X25519) RFC 7539 - ChaCha20 et Poly1305 pour les protocoles de l\u0026rsquo;IETF RFC 8439 - ChaCha20-Poly1305 (rend obsolète la RFC 7539) RFC 2104 - HMAC : hachage à clé pour l\u0026rsquo;authentification des messages SipHash - SipHash-2-4 pour les applications de fonctions de hachage Spécifications I2P connexes Spécification I2NP - Format des messages du protocole réseau I2P Structures communes - Formats de RouterInfo et RouterAddress Transport SSU - Transport UDP (d\u0026rsquo;origine, maintenant SSU2) Proposition 147 - Vérification de l\u0026rsquo;ID de réseau de transport (0.9.42) Références d’implémentation I2P Java - Implémentation de référence (Java) i2pd - Implémentation en C++ Notes de version I2P - Historique des versions et mises à jour Contexte historique Station-To-Station Protocol (STS) - Source d\u0026rsquo;inspiration pour le Noise framework (cadre de protocoles cryptographiques) obfs4 - Pluggable transport (mécanisme de transport modulaire) (précédent d\u0026rsquo;obfuscation de longueur par SipHash) Directives d’implémentation Exigences obligatoires À des fins de conformité :\nImplémenter le handshake complet:\nPrendre en charge les trois messages avec des chaînes de KDF correctes Valider tous les tags AEAD Vérifier que les points X25519 sont valides Implémenter la phase de données:\nObfuscation de la longueur avec SipHash (dans les deux sens) Tous les types de blocs : 0 (DateTime), 1 (Options), 2 (RouterInfo), 3 (I2NP), 4 (Termination), 254 (Padding) Gestion correcte des nonces (nombre utilisé une seule fois) (compteurs séparés) Fonctionnalités de sécurité:\nPrévention des attaques par rejeu (mise en cache des clés éphémères pendant 2*D) Validation des horodatages (±60 secondes par défaut) Remplissage aléatoire dans les messages 1-2 Gestion des erreurs AEAD avec délais d\u0026rsquo;attente aléatoires Publication de RouterInfo:\nPublier la clé statique (\u0026ldquo;s\u0026rdquo;), l’IV (vecteur d\u0026rsquo;initialisation) (\u0026ldquo;i\u0026rdquo;) et la version (\u0026ldquo;v\u0026rdquo;) Effectuer la rotation des clés conformément à la politique Prendre en charge le champ des capacités (\u0026ldquo;caps\u0026rdquo;) pour les routers cachés Compatibilité réseau:\nPrendre en charge le champ d\u0026rsquo;ID réseau (actuellement 2 pour le réseau principal) Interopérer avec les implémentations Java et i2pd existantes Gérer IPv4 et IPv6 Pratiques recommandées Optimisation des performances:\nStratégie de mise en tampon :\nÉmettre chaque message en une seule fois (messages 1, 2, 3) Utiliser TCP_NODELAY pour les messages de handshake (phase d\u0026rsquo;initialisation de la connexion) Regrouper plusieurs blocs de données dans une seule trame Limiter la taille des trames à quelques Ko (minimiser la latence côté récepteur) Gestion des connexions:\nRéutiliser les connexions lorsque c\u0026rsquo;est possible Mettre en place un pool de connexions Surveiller la santé des connexions (DateTime blocks) Gestion de la mémoire :\nMettre à zéro les données sensibles après utilisation (clés éphémères, résultats DH) Limiter les handshakes (échanges d\u0026rsquo;initialisation) simultanés (prévention des attaques DoS) Utiliser des pools de mémoire pour les allocations fréquentes Renforcement de la sécurité :\nRésistance au sondage:\nTemporisations aléatoires: 100-500ms Lectures d\u0026rsquo;octets aléatoires: 1KB-64KB Mise sur liste noire des adresses IP en cas d\u0026rsquo;échecs répétés Aucun détail d\u0026rsquo;erreur communiqué aux pairs Limites de ressources :\nNombre maximal de connexions par IP : 3-10 Nombre maximal de handshakes (négociation initiale) en attente : 100-1000 Délais d\u0026rsquo;expiration de lecture : 30-60 secondes par opération Délai d\u0026rsquo;expiration total de connexion : 5 minutes pour le handshake Gestion des clés:\nStockage persistant de la clé statique et de l’IV (vecteur d’initialisation) Génération aléatoire sécurisée (RNG cryptographique) Appliquer strictement les politiques de rotation Ne jamais réutiliser les clés éphémères Surveillance et diagnostics:\nMétriques:\nTaux de réussite/échec du handshake (établissement de connexion) Taux d\u0026rsquo;erreur AEAD (chiffrement authentifié avec données associées) Distribution du décalage d\u0026rsquo;horloge Statistiques de durée de connexion Journalisation:\nConsigner les échecs de handshake (négociation initiale) avec des codes de cause Consigner les événements de décalage d\u0026rsquo;horloge Consigner les adresses IP bannies Ne jamais consigner de key material (informations sensibles de clé) Tests:\nTests unitaires des chaînes de KDF (fonction de dérivation de clé) Tests d\u0026rsquo;intégration avec d\u0026rsquo;autres implémentations Fuzzing (tests par données aléatoires) pour le traitement des paquets Tests de charge pour la résistance aux attaques par déni de service (DoS) Pièges courants Erreurs critiques à éviter :\nRéutilisation du nonce (nombre utilisé une seule fois):\nNe jamais réinitialiser le compteur de nonce en cours de session Utiliser des compteurs distincts pour chaque direction Terminer avant d\u0026rsquo;atteindre 2^64 - 1 Rotation des clés :\nNe jamais effectuer une rotation des clés pendant que le router est en cours d\u0026rsquo;exécution Ne jamais réutiliser des clés éphémères entre les sessions Respecter les règles de temps d\u0026rsquo;arrêt minimal Gestion des horodatages:\nNe jamais accepter des horodatages expirés Toujours ajuster en fonction du RTT lors du calcul du décalage Arrondir les horodatages DateTime à la seconde près Erreurs AEAD (chiffrement authentifié avec données associées):\nNe jamais révéler le type d’erreur à un attaquant Toujours utiliser une temporisation aléatoire avant de fermer Traiter une longueur non valide comme un échec AEAD Bourrage:\nNe jamais envoyer de bourrage en dehors des limites négociées Toujours placer le bloc de bourrage en dernier Ne jamais inclure plusieurs blocs de bourrage par trame RouterInfo:\nToujours vérifier que la clé statique correspond au RouterInfo Ne jamais flood (diffuser massivement) des RouterInfos sans adresses publiées Toujours valider les signatures Méthodologie de test Tests unitaires:\nPrimitives cryptographiques:\nVecteurs de test pour X25519, ChaCha20, Poly1305, SHA-256 Vecteurs de test pour HMAC-SHA256 Vecteurs de test pour SipHash-2-4 Chaînes KDF:\nTests à réponse connue pour les trois messages Vérifier la propagation de la clé de chaînage Tester la génération de l\u0026rsquo;IV (vecteur d\u0026rsquo;initialisation) SipHash Analyse des messages:\nDécodage de messages valides Rejet des messages invalides Cas limites (vide, taille maximale) Tests d\u0026rsquo;intégration:\nHandshake (négociation initiale):\nÉchange en trois messages réussi Rejet en cas de décalage d\u0026rsquo;horloge Détection d\u0026rsquo;attaque par rejeu Rejet de clé invalide Phase de données:\nTransfert de messages I2NP Échange de RouterInfo Gestion du bourrage (padding) Messages de terminaison Interopérabilité:\nTester avec Java I2P Tester avec i2pd Tester IPv4 et IPv6 Tester les routers publiés et cachés Tests de sécurité:\nTests négatifs :\nÉtiquettes AEAD non valides Messages rejoués Attaques par décalage d’horloge Trames mal formées Tests de DoS:\nInondation de connexions Attaques Slowloris Épuisement du CPU (DH (Diffie-Hellman) excessif) Épuisement de la mémoire Fuzzing (tests aléatoires):\nMessages de handshake aléatoires Trames aléatoires pour la phase de données Types et tailles de blocs aléatoires Valeurs cryptographiques invalides Migration depuis NTCP Pour la prise en charge NTCP héritée (désormais supprimée):\nNTCP (version 1) a été supprimé dans I2P 0.9.50 (mai 2021). Toutes les implémentations actuelles doivent prendre en charge NTCP2. Notes historiques :\nPériode de transition (2018-2021):\n0.9.36: NTCP2 introduit (désactivé par défaut) 0.9.37: NTCP2 activé par défaut 0.9.40: NTCP déprécié 0.9.50: NTCP supprimé Détection de version:\nLe transportStyle \u0026ldquo;NTCP\u0026rdquo; indiquait que les deux versions étaient prises en charge Le transportStyle \u0026ldquo;NTCP2\u0026rdquo; indiquait uniquement NTCP2 Détection automatique via la taille du message (287 vs 288 octets) État actuel:\nTous les routers doivent prendre en charge NTCP2 Le transportStyle \u0026ldquo;NTCP\u0026rdquo; est obsolète Utiliser exclusivement le transportStyle \u0026ldquo;NTCP2\u0026rdquo; Annexe A : Noise XK Pattern (schéma de poignée de main XK du framework Noise) Modèle Noise XK standard:\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se Interprétation:\n\u0026lt;- : Message du répondeur (Bob) à l\u0026rsquo;initiateur (Alice) -\u0026gt; : Message de l\u0026rsquo;initiateur (Alice) au répondeur (Bob) s : Clé statique (clé d\u0026rsquo;identité à long terme) rs : Clé statique distante (clé statique du pair, connue à l\u0026rsquo;avance) e : Clé éphémère (spécifique à la session, générée à la demande) es : DH éphémère–statique (éphémère d\u0026rsquo;Alice × statique de Bob) ee : DH éphémère–éphémère (éphémère d\u0026rsquo;Alice × éphémère de Bob) se : DH statique–éphémère (statique d\u0026rsquo;Alice × éphémère de Bob) Séquence d\u0026rsquo;accord de clés:\nPré-message: Alice connaît la clé publique statique de Bob (provenant de RouterInfo) Message 1: Alice envoie une clé éphémère, effectue es DH (échange Diffie-Hellman éphémère-statique) Message 2: Bob envoie une clé éphémère, effectue ee DH Message 3: Alice révèle sa clé statique, effectue se DH Propriétés de sécurité:\nAlice authentifiée : Oui (par le message 3) Bob authentifié : Oui (par la possession de la clé privée statique) Confidentialité persistante : Oui (clés éphémères détruites) Résistance KCI (Key Compromise Impersonation, usurpation par compromission de clé) : Oui (niveau d\u0026rsquo;authentification 2) Annexe B : Encodage Base64 Alphabet Base64 d\u0026rsquo;I2P:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ Différences par rapport au Base64 standard: - Caractères 62-63: -~ au lieu de +/ - Remplissage: identique (=) ou omis selon le contexte\nUtilisation dans NTCP2: - Clé statique (\u0026ldquo;s\u0026rdquo;): 32 octets → 44 caractères (sans remplissage) - IV (\u0026ldquo;i\u0026rdquo;): 16 octets → 24 caractères (sans remplissage)\nExemple d\u0026rsquo;encodage :\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= Annexe C: Analyse des captures de paquets Identification du trafic NTCP2:\nÉtablissement de la connexion TCP:\nSéquence TCP standard SYN, SYN-ACK, ACK Port de destination généralement 8887 ou similaire Message 1 (SessionRequest — demande de session):\nPremières données applicatives envoyées par Alice 80-65535 octets (généralement quelques centaines) Semble aléatoire (clé éphémère chiffrée en AES) 287 octets max si connexion à une adresse \u0026ldquo;NTCP\u0026rdquo; Message 2 (SessionCreated):\nRéponse de Bob 80-65535 octets (généralement quelques centaines) Semble également aléatoire Message 3 (SessionConfirmed — confirmation de session):\nProvenant d’Alice 48 octets + variable (taille de RouterInfo + bourrage) En général 1-4 Ko Phase de données:\nTrames de longueur variable Champ de longueur obfusqué (semble aléatoire) Charge utile chiffrée Le bourrage rend la taille imprévisible Évasion du DPI: - Pas d\u0026rsquo;en-têtes en clair - Pas de motifs fixes - Champs de longueur obfusqués - Le remplissage aléatoire met en échec les heuristiques fondées sur la taille\nComparaison avec NTCP : - Le message 1 NTCP fait toujours 288 octets (identifiable) - La taille du message 1 NTCP2 varie (non identifiable) - NTCP présentait des schémas reconnaissables - NTCP2 est conçu pour résister à l’inspection approfondie des paquets (DPI)\nAnnexe D : Historique des versions Principaux jalons:\n0.9.36 (23 août 2018): NTCP2 introduit, désactivé par défaut 0.9.37 (4 octobre 2018): NTCP2 activé par défaut 0.9.40 (20 mai 2019): NTCP déprécié 0.9.42 (27 août 2019): Champ Network ID ajouté (Proposition 147) 0.9.50 (17 mai 2021): NTCP supprimé, prise en charge des capacités ajoutée 2.10.0 (9 septembre 2025): Dernière version stable Stabilité du protocole : - Aucune modification non rétrocompatible depuis la 0.9.50 - Améliorations continues de la résistance aux attaques de sondage - Accent sur les performances et la fiabilité - Cryptographie post-quantique en développement (désactivée par défaut)\nStatut actuel des transports : - NTCP2: Transport TCP obligatoire - SSU2: Transport UDP obligatoire - NTCP (v1): Supprimé - SSU (v1): Supprimé\n","description":"Transport TCP basé sur Noise (cadre de protocoles) pour les liens de router à router","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"Transport NTCP2","url":"/fr/docs/specs/ntcp2/"},{"categories":null,"content":" Obsolète : SSU (Secure Semi-Reliable UDP) a été remplacé par SSU2 . Java I2P a retiré SSU dans la version 2.4.0 (API 0.9.61) et i2pd l\u0026rsquo;a retiré dans la version 2.44.0 (API 0.9.56). Ce document est conservé uniquement à des fins de référence historique.\nPoints forts Transport UDP fournissant une livraison point à point chiffrée et authentifiée des messages I2NP. S’appuyait sur un échange Diffie–Hellman de 2048 bits (même nombre premier qu’ElGamal). Chaque datagramme transportait un HMAC‑MD5 de 16 octets (variante tronquée non standard) + un IV de 16 octets, suivi d’une charge utile chiffrée en AES‑256‑CBC. La prévention des attaques par rejeu et l’état de session étaient suivis à l’intérieur de la charge utile chiffrée. En-tête de message [16-byte MAC][16-byte IV][encrypted payload] Calcul de MAC utilisé : HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8))) avec une clé MAC de 32 octets. La longueur de la charge utile (payload), un entier 16 bits big-endian, était ajoutée dans le calcul du MAC. La version du protocole avait pour valeur par défaut 0 ; netId avait pour valeur par défaut 2 (réseau principal).\nClés de session et de MAC Dérivé du secret partagé DH:\nConvertissez la valeur partagée en un tableau d’octets big-endian (préfixez par 0x00 si le bit de poids fort est à 1). Clé de session : les 32 premiers octets (complétez avec des zéros si plus court). Clé MAC : octets 33–64 ; si insuffisant, utilisez à défaut le hachage SHA-256 de la valeur partagée. Statut Les routers n\u0026rsquo;annoncent plus d\u0026rsquo;adresses SSU. Les clients devraient migrer vers les transports SSU2 ou NTCP2. Des implémentations historiques peuvent être trouvées dans des versions plus anciennes :\nSources Java antérieures à la 2.4.0 sous router/transport/udp Sources i2pd antérieures à la 2.44.0 Pour le comportement actuel du transport UDP, voir la spécification SSU2 (version 2 de SSU).\n","description":"Transport UDP d'origine utilisé avant SSU2","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"Transport SSU (Déprécié)","url":"/fr/docs/legacy/ssu/"},{"categories":null,"content":" Avis historique : Cette page conserve, à titre de référence, l’ancienne discussion « Tunnels unidirectionnels ». Consultez la documentation de l’implémentation des tunnels en vigueur pour le comportement actuel.\nVue d’ensemble I2P construit des tunnels unidirectionnels: un tunnel transporte le trafic sortant et un tunnel distinct transporte les réponses entrantes. Cette structure remonte aux toutes premières conceptions du réseau et demeure un facteur de différenciation majeur par rapport aux systèmes à circuits bidirectionnels comme Tor. Pour la terminologie et les détails d\u0026rsquo;implémentation, voir l\u0026rsquo;aperçu des tunnels et la spécification des tunnels .\nRevue Les tunnels unidirectionnels séparent le trafic de requête et de réponse, de sorte que tout groupe de pairs en collusion n’observe que la moitié d’un aller-retour. Les attaques temporelles doivent croiser deux pools de tunnels (sortants et entrants) au lieu d’analyser un seul circuit, ce qui rend la corrélation plus difficile. Des pools de tunnels entrants et sortants indépendants permettent aux routers d’ajuster, par direction, la latence, la capacité et les caractéristiques de gestion des défaillances. Les inconvénients incluent une complexité accrue de la gestion des pairs et la nécessité de maintenir plusieurs ensembles de tunnels pour une prestation de service fiable. Anonymat L\u0026rsquo;article de Hermann et Grothoff, I2P is Slow… and What to Do About It , analyse les attaques du prédécesseur contre des tunnels unidirectionnels, suggérant que des adversaires déterminés peuvent finir par confirmer des pairs persistants. Les retours de la communauté notent que l\u0026rsquo;étude repose sur des hypothèses spécifiques concernant la patience de l\u0026rsquo;adversaire et ses pouvoirs juridiques, et ne compare pas cette approche aux attaques par temporisation qui touchent les conceptions bidirectionnelles. Les recherches continues et l\u0026rsquo;expérience pratique ne cessent de conforter les tunnels unidirectionnels comme un choix délibéré en matière d\u0026rsquo;anonymat plutôt qu\u0026rsquo;un oubli.\n","description":"Résumé historique de la conception des tunnels unidirectionnels d'I2P.","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"Tunnels unidirectionnels","url":"/fr/docs/legacy/unidirectional/"},{"categories":null,"content":" La branche de développement principale d'I2P (i2p.i2p) a été configurée pour permettre aux développeurs de mettre en place facilement deux des IDE couramment utilisés pour le développement Java : Eclipse et NetBeans. Eclipse Les branches principales de développement I2P (i2p.i2p et ses dérivées) contiennent build.gradle pour permettre une configuration facile de la branche dans Eclipse. Assurez-vous d'avoir une version récente d'Eclipse. N'importe quelle version plus récente que 2017 devrait convenir. Clonez la branche I2P dans un répertoire (par exemple $HOME/dev/i2p.i2p). Sélectionnez « Fichier → Importer... » puis sous « Gradle » sélectionnez « Existing Gradle Project ». Pour « Project root directory: » choisissez le répertoire dans lequel la branche I2P a été clonée. Dans la boîte de dialogue « Import Options », sélectionnez « Gradle Wrapper » et appuyez sur Continuer. Dans la boîte de dialogue « Import Preview » vous pouvez examiner la structure du projet. Plusieurs projets devraient apparaître sous « i2p.i2p ». Appuyez sur « Terminer ». Terminé ! Votre espace de travail devrait maintenant contenir tous les projets de la branche I2P, et leurs dépendances de compilation devraient être correctement configurées. NetBeans Les branches principales de développement I2P (i2p.i2p et ses branches dérivées) contiennent des fichiers de projet NetBeans. ","description":"Configurer Eclipse et NetBeans pour développer I2P avec Gradle et les fichiers de projet fournis","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"Utiliser un IDE avec I2P","url":"/fr/docs/guides/ides/"},{"categories":null,"content":" Statut : Ceci est une référence concise pour l\u0026rsquo;utilitaire v3dgsend. Il complète la documentation de l\u0026rsquo;API Datagram et de SAM v3 .\nAperçu v3dgsend est un utilitaire en ligne de commande pour envoyer des datagrammes I2P via l\u0026rsquo;interface SAMv3. Il est utile pour tester la livraison de datagrammes, prototyper des services et vérifier le comportement de bout en bout sans avoir à écrire un client complet.\nUtilisations typiques :\nTest de fumée de l\u0026rsquo;accessibilité des datagrammes vers une Destination Validation de la configuration du pare-feu et du carnet d\u0026rsquo;adresses Expérimentation avec des datagrammes bruts vs. signés (auxquels on peut répondre) Utilisation L\u0026rsquo;invocation de base varie selon la plateforme et l\u0026rsquo;empaquetage. Les options courantes incluent :\nDestination : Destination en base64 ou nom .i2p Protocol : raw (PROTOCOL 18) ou signed (PROTOCOL 17) Payload : chaîne inline ou fichier en entrée Consultez l\u0026rsquo;empaquetage de votre distribution ou la sortie de --help pour les options exactes.\nVoir aussi API Datagram SAM v3 Bibliothèque Streaming (alternative aux datagrammes) ","description":"Utilitaire CLI pour envoyer des datagrammes I2P via SAM v3","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/fr/docs/api/v3dgsend/"}]
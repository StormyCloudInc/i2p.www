<!DOCTYPE html>
<html lang="pt" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>ECIES-X25519-AEAD-Ratchet | I2P - O Projeto de Internet Invisível</title>

    <meta name="description" content="The Invisible Internet Project - A privacy-focused, anonymous network layer">
    <meta name="keywords" content="i2p, privacy, anonymity, dark net, encryption, security">

    
    <meta property="og:title" content="ECIES-X25519-AEAD-Ratchet | I2P - O Projeto de Internet Invisível">
    <meta property="og:description" content="The Invisible Internet Project - A privacy-focused, anonymous network layer">
    <meta property="og:type" content="website">
    <meta property="og:url" content="/pt/proposals/144-ecies-x25519-aead-ratchet/">

    
    <link rel="icon" type="image/svg+xml" href="../../../images/favicon.svg">
    <link rel="icon" type="image/png" href="../../../images/i2plogo.png" sizes="32x32">

    
    
    
    
    <link rel="stylesheet" href="../../../css/main.min.be6880f32f5ff44e57579da7b11513b973319944ebe38748e3ac7f3268662d18.css" integrity="sha256-vmiA8y9f9E5XV52nsRUTuXMxmUTr44dI46x/MmhmLRg=">
    


    
</head>

<body>
    
    <input type="checkbox" id="theme-toggle-checkbox" class="theme-checkbox" aria-hidden="true">

    
<div class="site-banner" id="site-banner" data-banner-id="banner-3" role="alert" aria-live="polite">
    <div class="container">
        <div class="banner-content">
            <span class="banner-message">Site Beta I2P Agora no Ar Reporte problemas por e-mail para stormycloud@mail.i2p</span>
            
        </div>
        
        <form method="GET" action="../../../api/banner/dismiss" style="display: inline;">
            <input type="hidden" name="id" value="banner-3">
            <button type="submit" class="banner-close" aria-label="Fechar banner" title="Fechar banner">
                <span aria-hidden="true">&times;</span>
            </button>
        </form>
        
    </div>
</div>


    <header class="site-header">
    <div class="container">
        <nav class="main-nav">
            <div class="nav-brand">
                <a href="../../../pt/" class="logo-link">
                    <img src="../../../images/i2plogo_lightmode.svg" alt="I2P Logo" class="logo logo-light">
                    <img src="../../../images/i2plogo_darkmode.svg" alt="I2P Logo" class="logo logo-dark">
                </a>
            </div>

            
            <input type="checkbox" id="mobile-menu-checkbox" class="mobile-menu-checkbox"
                aria-label="Toggle navigation menu">
            <label for="mobile-menu-checkbox" class="mobile-menu-toggle" aria-label="Toggle navigation menu">
                <span class="hamburger"></span>
            </label>

            <div class="nav-menu">
                <ul class="nav-links">
                    <li class="nav-dropdown">
                        <a href="../../../pt/about/" class="">Sobre</a>
                        <ul class="dropdown-menu">
                            <li><a href="../../../pt/about/">Visão Geral</a></li>
                            <li><a href="../../../pt/papers/">Artigos de Pesquisa</a></li>
                            <li><a href="../../../pt/about/media/">Imprensa</a></li>
                            <li><a href="../../../pt/contact/">Contate-nos</a></li>
                        </ul>
                    </li>
                    <li><a href="../../../pt/docs/" class="">Docs</a></li>
                    <li><a href="../../../pt/downloads/" class="">Downloads</a></li>
                    <li><a href="../../../pt/blog/" class="">Blog</a></li>
                    <li class="nav-dropdown">
                        <a href="../../../pt/get-involved/" class="">Participe</a>
                        <ul class="dropdown-menu">
                            <li><a href="../../../pt/get-involved/">Visão Geral</a></li>
                            <li><a href="../../../pt/feedback/">Sugestões de Recursos</a></li>
                        </ul>
                    </li>
                </ul>

                <div class="nav-actions">
                    
                    <div class="language-selector">
                        <button class="language-toggle" aria-label="Select language" title="Language">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" />
                                <path
                                    d="M2 12h20M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10 15.3 15.3 0 014-10z"
                                    stroke="currentColor" stroke-width="2" />
                            </svg>
                            <span class="current-lang">pt</span>
                        </button>
                        <div class="language-dropdown">
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../en/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option">Inglês</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../es/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option">Espanhol</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../ko/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option">Coreano</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../zh/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option">Chinês</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../ru/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option">Russo</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../cs/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option">Tcheco</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../de/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option">Alemão</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../fr/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option">Francês</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../tr/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option">Turco</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../vi/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option">Vietnamita</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../hi/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option">Hindi</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../ar/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option">Árabe</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../pt/proposals/144-ecies-x25519-aead-ratchet/"
                                class="lang-option active">Português</a>
                            
                            
                        </div>
                    </div>

                    
                    <label for="theme-toggle-checkbox" class="theme-toggle" aria-label="Toggle dark mode"
                        title="Toggle theme">
                        <svg class="sun-icon" width="20" height="20" viewBox="0 0 20 20" fill="none"
                            xmlns="http://www.w3.org/2000/svg">
                            <circle cx="10" cy="10" r="4" stroke="currentColor" stroke-width="2" />
                            <path
                                d="M10 2V4M10 16V18M18 10H16M4 10H2M15.657 4.343L14.243 5.757M5.757 14.243L4.343 15.657M15.657 15.657L14.243 14.243M5.757 5.757L4.343 4.343"
                                stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        </svg>
                        <svg class="moon-icon" width="20" height="20" viewBox="0 0 20 20" fill="none"
                            xmlns="http://www.w3.org/2000/svg">
                            <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"
                                stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
                        </svg>
                    </label>

                    
                    <a href="../../../pt/financial-support/" class="btn btn-primary" id="donate-btn">Donate</a>

                    
                    <a href="../../../pt/downloads/" class="btn btn-primary">Obter I2P</a>
                </div>
            </div>
        </nav>
    </div>
</header>

    <main id="main-content">
        



<div class="proposals-page">
    <div class="container">
        
        <nav class="breadcrumbs">
            <a href="../../../pt/">Home</a>
            <span class="separator">/</span>
            <a href="../../../pt/proposals/">Proposals</a>
            <span class="separator">/</span>
            <span class="current">ECIES-X25519-AEAD-Ratchet</span>
        </nav>

        
<div class="translation-disclaimer" role="note">
    <span class="disclaimer-message">Esta tradução foi gerada usando aprendizado de máquina e pode não ser 100% precisa.</span>
    
    
    <a href="../../../en/proposals/144-ecies-x25519-aead-ratchet/" class="disclaimer-link">Ver versão em inglês</a>
    
</div>



        
        <header class="proposal-header">
            <div class="proposal-title-section">
                <h1 class="proposal-title">ECIES-X25519-AEAD-Ratchet</h1>
                <div class="proposal-number">Proposal 144</div>
            </div>

            
            <div class="proposal-meta-box">
                <div class="proposal-status status-fechado">
                    Fechado
                </div>

                
                <div class="proposal-info-grid">
                    
                    <div class="info-item">
                        <span class="info-label">Author</span>
                        <span class="info-value">zzz, chisana, orignal</span>
                    </div>
                    

                    
                    <div class="info-item">
                        <span class="info-label">Created</span>
                        <span class="info-value">2018-11-22</span>
                    </div>
                    

                    
                    <div class="info-item">
                        <span class="info-label">Last Updated</span>
                        <span class="info-value">2025-03-05</span>
                    </div>
                    

                    
                    <div class="info-item">
                        <span class="info-label">Target Version</span>
                        <span class="info-value">0.9.46</span>
                    </div>
                    

                    
                    <div class="info-item">
                        <span class="info-label">Implemented In</span>
                        <span class="info-value">0.9.46</span>
                    </div>
                    
                </div>

                
                
            </div>
        </header>

        
        <div class="proposal-layout proposal-layout--with-toc">
            
            
            <aside class="proposal-toc-sidebar">
                <nav class="toc-nav">
                    <div class="toc-header">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                            <path d="M4 6h16M4 12h16M4 18h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        On This Page
                    </div>
                    <div class="toc-content">
                        <nav id="TableOfContents">
  <ul>
    <li><a href="#nota">Nota</a></li>
    <li><a href="#visão-geral">Visão Geral</a>
      <ul>
        <li><a href="#current-elgamal-uses">Current ElGamal Uses</a></li>
        <li><a href="#enctypes-in-key-certs">EncTypes in Key Certs</a></li>
        <li><a href="#usos-atuais-do-elgamal">Usos Atuais do ElGamal</a></li>
        <li><a href="#enctypes-em-key-certs">EncTypes em Key Certs</a></li>
        <li><a href="#usos-de-criptografia-assimétrica">Usos de Criptografia Assimétrica</a></li>
        <li><a href="#objetivos">Objetivos</a></li>
        <li><a href="#não-objetivos--fora-do-escopo">Não-objetivos / Fora do escopo</a></li>
      </ul>
    </li>
    <li><a href="#detailed-proposal">Detailed Proposal</a>
      <ul>
        <li><a href="#justificativa">Justificativa</a></li>
        <li><a href="#modelo-de-ameaças">Modelo de Ameaças</a></li>
        <li><a href="#crypto-type">Crypto Type</a></li>
        <li><a href="#resumo-do-design-criptográfico">Resumo do Design Criptográfico</a></li>
        <li><a href="#novas-primitivas-criptográficas-para-i2p">Novas Primitivas Criptográficas para I2P</a></li>
        <li><a href="#tipo-de-criptografia">Tipo de Criptografia</a></li>
        <li><a href="#estrutura-do-protocolo-noise">Estrutura do Protocolo Noise</a></li>
        <li><a href="#adições-ao-framework">Adições ao Framework</a></li>
        <li><a href="#padrões-de-handshake">Padrões de Handshake</a></li>
        <li><a href="#sessões">Sessões</a></li>
        <li><a href="#contexto-da-sessão">Contexto da Sessão</a></li>
        <li><a href="#emparelhando-sessões-de-entrada-e-saída">Emparelhando Sessões de Entrada e Saída</a></li>
        <li><a href="#vinculação-de-sessões-e-destinos">Vinculação de Sessões e Destinos</a></li>
        <li><a href="#benefícios-do-binding-e-pairing">Benefícios do Binding e Pairing</a></li>
        <li><a href="#acks-de-mensagem">ACKs de Mensagem</a></li>
        <li><a href="#timeouts-de-sessão">Timeouts de Sessão</a></li>
        <li><a href="#multicast">Multicast</a></li>
        <li><a href="#definições">Definições</a></li>
        <li><a href="#1-formato-da-mensagem">1) Formato da mensagem</a></li>
        <li><a href="#revisão-do-formato-de-mensagem-atual">Revisão do Formato de Mensagem Atual</a></li>
        <li><a href="#revisão-do-formato-de-dados-criptografados">Revisão do Formato de Dados Criptografados</a></li>
        <li><a href="#novas-session-tags-e-comparação-com-o-signal">Novas Session Tags e Comparação com o Signal</a></li>
        <li><a href="#1a-novo-formato-de-sessão">1a) Novo formato de sessão</a></li>
        <li><a href="#1b-novo-formato-de-sessão-com-vinculação">1b) Novo formato de sessão (com vinculação)</a></li>
        <li><a href="#chave-efêmera-de-nova-sessão">Chave Efêmera de Nova Sessão</a></li>
        <li><a href="#chave-estática">Chave Estática</a></li>
        <li><a href="#payload">Payload</a></li>
        <li><a href="#1c-novo-formato-de-sessão-sem-vinculação">1c) Novo formato de sessão (sem vinculação)</a></li>
        <li><a href="#chave-efêmera-de-nova-sessão-1">Chave Efêmera de Nova Sessão</a></li>
        <li><a href="#seção-de-flags-dados-descriptografados">Seção de Flags Dados descriptografados</a></li>
        <li><a href="#payload-1">Payload</a></li>
        <li><a href="#1d-formato-único-sem-vinculação-ou-sessão">1d) Formato único (sem vinculação ou sessão)</a></li>
        <li><a href="#nova-chave-de-sessão-de-uso-único">Nova Chave de Sessão de Uso Único</a></li>
        <li><a href="#seção-de-flags-dados-descriptografados-1">Seção de Flags Dados descriptografados</a></li>
        <li><a href="#payload-2">Payload</a></li>
        <li><a href="#1f-kdfs-para-mensagem-de-nova-sessão">1f) KDFs para Mensagem de Nova Sessão</a></li>
        <li><a href="#kdf-para-chainkey-inicial">KDF para ChainKey Inicial</a></li>
        <li><a href="#kdf-para-conteúdos-encriptados-da-seção-flagsstatic-key">KDF para Conteúdos Encriptados da Seção Flags/Static Key</a></li>
        <li><a href="#kdf-para-seção-de-payload-com-chave-estática-da-alice">KDF para Seção de Payload (com chave estática da Alice)</a></li>
        <li><a href="#kdf-para-seção-de-payload-sem-chave-estática-da-alice">KDF para Seção de Payload (sem chave estática da Alice)</a></li>
        <li><a href="#1g-formato-da-resposta-de-nova-sessão">1g) Formato da Resposta de Nova Sessão</a></li>
        <li><a href="#session-tag">Session Tag</a></li>
        <li><a href="#resposta-de-nova-sessão-com-chave-efêmera">Resposta de Nova Sessão com Chave Efêmera</a></li>
        <li><a href="#payload-3">Payload</a></li>
        <li><a href="#kdf-para-reply-tagset">KDF para Reply TagSet</a></li>
        <li><a href="#kdf-para-conteúdos-criptografados-da-seção-reply-key">KDF para Conteúdos Criptografados da Seção Reply Key</a></li>
        <li><a href="#kdf-para-conteúdos-criptografados-da-seção-de-payload">KDF para Conteúdos Criptografados da Seção de Payload</a></li>
        <li><a href="#notas">Notas</a></li>
        <li><a href="#1h-formato-de-sessão-existente">1h) Formato de sessão existente</a></li>
        <li><a href="#formato">Formato</a></li>
        <li><a href="#payload-4">Payload</a></li>
        <li><a href="#2-ecies-x25519">2) ECIES-X25519</a></li>
        <li><a href="#2a-elligator2">2a) Elligator2</a></li>
        <li><a href="#formato-1">Formato</a></li>
        <li><a href="#justificativa-1">Justificativa</a></li>
        <li><a href="#notas-1">Notas</a></li>
        <li><a href="#3-aead-chachapoly">3) AEAD (ChaChaPoly)</a></li>
        <li><a href="#entradas-de-nova-sessão-e-resposta-de-nova-sessão">Entradas de Nova Sessão e Resposta de Nova Sessão</a></li>
        <li><a href="#entradas-de-sessão-existentes">Entradas de Sessão Existentes</a></li>
        <li><a href="#formato-criptografado">Formato Criptografado</a></li>
        <li><a href="#notas-2">Notas</a></li>
        <li><a href="#tratamento-de-erros-aead">Tratamento de Erros AEAD</a></li>
        <li><a href="#justificativa-2">Justificativa</a></li>
        <li><a href="#4-ratchets">4) Ratchets</a></li>
        <li><a href="#números-de-mensagem">Números de Mensagem</a></li>
        <li><a href="#implementação-de-exemplo">Implementação de Exemplo</a></li>
        <li><a href="#4a-dh-ratchet">4a) DH Ratchet</a></li>
        <li><a href="#payload-section-decrypted-data">Payload Section Decrypted data</a></li>
        <li><a href="#unencrypted-data">Unencrypted data</a></li>
        <li><a href="#block-ordering-rules">Block Ordering Rules</a></li>
        <li><a href="#datetime">DateTime</a></li>
        <li><a href="#4b-session-tag-ratchet">4b) Session Tag Ratchet</a></li>
        <li><a href="#termination">Termination</a></li>
        <li><a href="#4c-ratchet-de-chave-simétrica">4c) Ratchet de Chave Simétrica</a></li>
        <li><a href="#message-numbers">Message Numbers</a></li>
        <li><a href="#5-payload">5) Payload</a></li>
        <li><a href="#seção-de-payload-dados-descriptografados">Seção de Payload Dados descriptografados</a></li>
        <li><a href="#dados-não-criptografados">Dados não criptografados</a></li>
        <li><a href="#regras-de-ordenação-de-blocos">Regras de Ordenação de Blocos</a></li>
        <li><a href="#datetime-1">DateTime</a></li>
        <li><a href="#dente-de-garlic">Dente de Garlic</a></li>
      </ul>
    </li>
    <li><a href="#typical-usage-patterns">Typical Usage Patterns</a>
      <ul>
        <li><a href="#terminação">Terminação</a></li>
        <li><a href="#opções">Opções</a></li>
        <li><a href="#números-de-mensagem-1">Números de Mensagem</a></li>
        <li><a href="#próxima-chave-pública-dh-ratchet">Próxima Chave Pública DH Ratchet</a></li>
        <li><a href="#confirmação">Confirmação</a></li>
        <li><a href="#solicitação-de-ack">Solicitação de Ack</a></li>
      </ul>
    </li>
    <li><a href="#implementation-considerations">Implementation Considerations</a>
      <ul>
        <li><a href="#preenchimento">Preenchimento</a></li>
        <li><a href="#outros-tipos-de-blocos">Outros tipos de blocos</a></li>
        <li><a href="#trabalho-futuro">Trabalho futuro</a></li>
        <li><a href="#x25519-only">X25519 Only</a></li>
        <li><a href="#http-get">HTTP GET</a></li>
        <li><a href="#http-post">HTTP POST</a></li>
      </ul>
    </li>
    <li><a href="#analysis">Analysis</a>
      <ul>
        <li><a href="#datagrama-replicável">Datagrama Replicável</a></li>
        <li><a href="#múltiplos-datagramas-raw">Múltiplos Datagramas Raw</a></li>
        <li><a href="#datagrama-bruto-único">Datagrama Bruto Único</a></li>
        <li><a href="#sessões-de-longa-duração">Sessões de Longa Duração</a></li>
        <li><a href="#cpu">CPU</a></li>
        <li><a href="#defesa">Defesa</a></li>
        <li><a href="#parâmetros">Parâmetros</a></li>
        <li><a href="#classificação">Classificação</a></li>
      </ul>
    </li>
    <li><a href="#related-changes">Related Changes</a>
      <ul>
        <li><a href="#apenas-x25519">Apenas X25519</a></li>
        <li><a href="#x25519-compartilhado-com-elgamalaessessiontags">X25519 Compartilhado com ElGamal/AES+SessionTags</a></li>
        <li><a href="#respostas-da-camada-de-protocolo">Respostas da Camada de Protocolo</a></li>
        <li><a href="#create-leaseset2-message">Create Leaseset2 Message</a></li>
        <li><a href="#sobrecarga">Sobrecarga</a></li>
      </ul>
    </li>
  </ul>
</nav>
                    </div>
                </nav>
            </aside>
            

            
            <div class="proposal-main">
                <article class="proposal-content">
                    <h2 id="nota">Nota</h2>
<p>Implantação e teste de rede em andamento. Sujeito a pequenas revisões. Consulte <a href="../../../pt/docs/specs/ecies/">SPEC</a>
 para a especificação oficial.</p>
<p>As seguintes funcionalidades não estão implementadas a partir da versão 0.9.46:</p>
<ul>
<li>Blocos MessageNumbers, Options e Termination</li>
<li>Respostas da camada de protocolo</li>
<li>Chave estática zero</li>
<li>Multicast</li>
</ul>
<h2 id="visão-geral">Visão Geral</h2>
<p>Esta é uma proposta para o primeiro novo tipo de criptografia ponta a ponta desde o início do I2P, para substituir ElGamal/AES+SessionTags <a href="../../../pt/docs/legacy/elgamal-aes/">Elg-AES</a>
.</p>
<p>Baseia-se no trabalho anterior da seguinte forma:</p>
<ul>
<li>Especificação de estruturas comuns <a href="../../../pt/docs/specs/common-structures/">Common Structures</a>
</li>
<li>Especificação <a href="../../../pt/docs/specs/i2np/">I2NP</a>
 incluindo LS2</li>
<li>ElGamal/AES+Session Tags <a href="../../../pt/docs/legacy/elgamal-aes/">Elg-AES</a>
</li>
<li><a href="http://zzz.i2p/topics/1768">http://zzz.i2p/topics/1768</a>
 visão geral da nova criptografia assimétrica</li>
<li>Visão geral da criptografia de baixo nível <a href="../../../pt/docs/specs/cryptography/">CRYPTO-ELG</a>
</li>
<li>ECIES <a href="http://zzz.i2p/topics/2418">http://zzz.i2p/topics/2418</a>
</li>
<li><a href="../../../pt/docs/specs/ntcp2/">NTCP2</a>
 <a href="../../../pt/proposals/111-ntcp-2/">Proposta 111</a>
</li>
<li>123 Novas Entradas netDB</li>
<li>142 Novo Modelo de Criptografia</li>
<li>Protocolo <a href="https://noiseprotocol.org/noise.html">Noise</a>
</li>
<li>Algoritmo double ratchet do <a href="https://signal.org/docs/">Signal</a>
</li>
</ul>
<p>O objetivo é suportar nova encriptação para comunicação ponto a ponto, de destino para destino.</p>
<p>O design usará um handshake Noise e uma fase de dados incorporando o double ratchet do Signal.</p>
<p>Todas as referências ao Signal e Noise nesta proposta são apenas para informação de contexto. O conhecimento dos protocolos Signal e Noise não é necessário para entender ou implementar esta proposta.</p>
<h3 id="current-elgamal-uses">Current ElGamal Uses</h3>
<p>Para revisão, chaves públicas ElGamal de 256 bytes podem ser encontradas nas seguintes estruturas de dados. Consulte a especificação de estruturas comuns.</p>
<ul>
<li>
<p>Em uma Router Identity
Esta é a chave de criptografia do router.</p>
</li>
<li>
<p>Em um Destination
A chave pública do destination foi usada para a antiga criptografia i2cp-to-i2cp
que foi desabilitada na versão 0.6, atualmente não é utilizada exceto para
o IV para criptografia LeaseSet, que está obsoleta.
A chave pública no LeaseSet é usada em seu lugar.</p>
</li>
<li>
<p>Em um LeaseSet
Esta é a chave de criptografia do destino.</p>
</li>
<li>
<p>Em um LS2
Esta é a chave de criptografia do destino.</p>
</li>
</ul>
<h3 id="enctypes-in-key-certs">EncTypes in Key Certs</h3>
<p>Como revisão, adicionamos suporte para tipos de criptografia quando adicionamos suporte para tipos de assinatura. O campo do tipo de criptografia é sempre zero, tanto em Destinations quanto em RouterIdentities. Se isso deve ser alterado algum dia está por ser determinado (TBD). Consulte a especificação de estruturas comuns <a href="../../../pt/docs/specs/common-structures/">Common Structures</a>
.</p>
<h3 id="usos-atuais-do-elgamal">Usos Atuais do ElGamal</h3>
<p>Como revisão, usamos ElGamal para:</p>
<ol>
<li>
<p>Mensagens de construção de tunnel (chave está na RouterIdentity)    A substituição não é coberta nesta proposta.    Veja a proposta 152 <a href="../../../pt/proposals/152-ecies-tunnels">Proposta 152</a>
.</p>
</li>
<li>
<p>Criptografia router-para-router de netDb e outras mensagens I2NP (Chave está na RouterIdentity)    Depende desta proposta.    Requer uma proposta para 1) também, ou colocar a chave nas opções RI.</p>
</li>
<li>
<p>Cliente End-to-end ElGamal+AES/SessionTag (chave está no LeaseSet, a chave de Destino não é usada)    A substituição ESTÁ coberta nesta proposta.</p>
</li>
<li>
<p>DH Efêmero para NTCP1 e SSU    A substituição não está coberta nesta proposta.    Veja a proposta 111 para NTCP2.    Nenhuma proposta atual para SSU2.</p>
</li>
</ol>
<h3 id="enctypes-em-key-certs">EncTypes em Key Certs</h3>
<ul>
<li>Compatível com versões anteriores</li>
<li>Requer e baseia-se no LS2 (proposta 123)</li>
<li>Aproveita nova criptografia ou primitivas adicionadas para NTCP2 (proposta 111)</li>
<li>Nenhuma nova criptografia ou primitivas necessárias para suporte</li>
<li>Manter desacoplamento de criptografia e assinatura; suportar todas as versões atuais e futuras</li>
<li>Habilitar nova criptografia para destinos</li>
<li>Habilitar nova criptografia para routers, mas apenas para mensagens garlic - construção de túnel seria
uma proposta separada</li>
<li>Não quebrar nada que dependa de hashes de destino binários de 32 bytes, por exemplo, bittorrent</li>
<li>Manter entrega de mensagem 0-RTT usando DH ephemeral-static</li>
<li>Não exigir buffering / enfileiramento de mensagens nesta camada de protocolo;
continuar suportando entrega ilimitada de mensagens em ambas as direções sem aguardar resposta</li>
<li>Atualizar para DH ephemeral-ephemeral após 1 RTT</li>
<li>Manter manipulação de mensagens fora de ordem</li>
<li>Manter segurança de 256 bits</li>
<li>Adicionar forward secrecy</li>
<li>Adicionar autenticação (AEAD)</li>
<li>Muito mais eficiente em CPU que ElGamal</li>
<li>Não depender do Java jbigi para tornar DH eficiente</li>
<li>Minimizar operações DH</li>
<li>Muito mais eficiente em largura de banda que ElGamal (bloco ElGamal de 514 bytes)</li>
<li>Suportar criptografia nova e antiga no mesmo túnel se desejado</li>
<li>Destinatário consegue distinguir eficientemente criptografia nova da antiga chegando pelo
mesmo túnel</li>
<li>Outros não podem distinguir criptografia nova da antiga ou futura</li>
<li>Eliminar classificação de comprimento de Sessão nova vs. Existente (suportar padding)</li>
<li>Nenhuma nova mensagem I2NP necessária</li>
<li>Substituir checksum SHA-256 no payload AES por AEAD</li>
<li>Suportar vinculação de sessões de transmissão e recepção para que
confirmações possam acontecer dentro do protocolo, ao invés de somente fora de banda.
Isso também permitirá que respostas tenham forward secrecy imediatamente.</li>
<li>Habilitar criptografia ponta a ponta de certas mensagens (armazenamentos RouterInfo)
que atualmente não fazemos devido ao overhead de CPU.</li>
<li>Não alterar a I2NP Garlic Message
ou formato de Garlic Message Delivery Instructions.</li>
<li>Eliminar campos não utilizados ou redundantes nos formatos Garlic Clove Set e Clove.</li>
</ul>
<p>Elimina vários problemas com session tags, incluindo:</p>
<ul>
<li>Incapacidade de usar AES até a primeira resposta</li>
<li>Não confiabilidade e travamentos se a entrega de tag for assumida</li>
<li>Ineficiente em largura de banda, especialmente na primeira entrega</li>
<li>Enorme ineficiência de espaço para armazenar tags</li>
<li>Enorme sobrecarga de largura de banda para entregar tags</li>
<li>Altamente complexo, difícil de implementar</li>
<li>Difícil de ajustar para vários casos de uso
(streaming vs. datagramas, servidor vs. cliente, alta vs. baixa largura de banda)</li>
<li>Vulnerabilidades de esgotamento de memória devido à entrega de tags</li>
</ul>
<h3 id="usos-de-criptografia-assimétrica">Usos de Criptografia Assimétrica</h3>
<ul>
<li>Mudanças no formato LS2 (proposta 123 está concluída)</li>
<li>Novo algoritmo de rotação DHT ou geração aleatória compartilhada</li>
<li>Nova criptografia para construção de túneis.
Veja a proposta 152 <a href="../../../pt/proposals/152-ecies-tunnels">Proposal 152</a>
.</li>
<li>Nova criptografia para criptografia de camada de túnel.
Veja a proposta 153 <a href="../../../pt/proposals/153-chacha20-layer-encryption">Proposal 153</a>
.</li>
<li>Métodos de criptografia, transmissão e recepção de mensagens I2NP DLM / DSM / DSRM.
Não alterando.</li>
<li>Nenhuma comunicação LS1-para-LS2 ou ElGamal/AES-para-esta-proposta é suportada.
Esta proposta é um protocolo bidirecional.
Destinos podem lidar com compatibilidade retroativa publicando dois leasesets
usando os mesmos túneis, ou colocar ambos os tipos de criptografia no LS2.</li>
<li>Mudanças no modelo de ameaça</li>
<li>Detalhes de implementação não são discutidos aqui e são deixados para cada projeto.</li>
<li>(Otimista) Adicionar extensões ou ganchos para suportar multicast</li>
</ul>
<h3 id="objetivos">Objetivos</h3>
<p>ElGamal/AES+SessionTag tem sido nosso único protocolo end-to-end por cerca de 15 anos, essencialmente sem modificações no protocolo. Existem agora primitivas criptográficas que são mais rápidas. Precisamos aprimorar a segurança do protocolo. Também desenvolvemos estratégias heurísticas e soluções alternativas para minimizar o overhead de memória e largura de banda do protocolo, mas essas estratégias são frágeis, difíceis de ajustar e tornam o protocolo ainda mais propenso a falhas, causando a queda da sessão.</p>
<p>Por aproximadamente o mesmo período de tempo, a especificação ElGamal/AES+SessionTag e a documentação relacionada descreveram como é custoso em termos de largura de banda entregar session tags, e propuseram substituir a entrega de session tag por um &ldquo;PRNG sincronizado&rdquo;. Um PRNG sincronizado gera deterministicamente as mesmas tags em ambas as extremidades, derivadas de uma semente comum. Um PRNG sincronizado também pode ser denominado um &ldquo;ratchet&rdquo;. Esta proposta (finalmente) especifica esse mecanismo ratchet e elimina a entrega de tags.</p>
<p>Ao usar um ratchet (um PRNG sincronizado) para gerar as session tags, eliminamos a sobrecarga de enviar session tags na mensagem New Session e mensagens subsequentes quando necessário. Para um conjunto típico de 32 tags, isso representa 1KB. Isso também elimina o armazenamento de session tags no lado do remetente, reduzindo assim os requisitos de armazenamento pela metade.</p>
<p>Um handshake bidirecional completo, semelhante ao padrão Noise IK, é necessário para evitar ataques de Personificação por Comprometimento de Chave (KCI). Veja a tabela &ldquo;Payload Security Properties&rdquo; do Noise em <a href="https://noiseprotocol.org/noise.html">NOISE</a>
. Para mais informações sobre KCI, consulte o artigo <a href="https://www.usenix.org/system/files/conference/woot15/woot15-paper-hlauschek.pdf">https://www.usenix.org/system/files/conference/woot15/woot15-paper-hlauschek.pdf</a>
</p>
<h3 id="não-objetivos--fora-do-escopo">Não-objetivos / Fora do escopo</h3>
<p>O modelo de ameaça é um pouco diferente do que para NTCP2 (proposta 111). Os nós MitM são o OBEP e IBGW e presume-se que tenham visão completa do netDb global atual ou histórico, através de conluio com floodfills.</p>
<p>O objetivo é impedir que esses MitMs classifiquem o tráfego como mensagens de Nova Sessão e Sessão Existente, ou como nova criptografia versus criptografia antiga.</p>
<h2 id="detailed-proposal">Detailed Proposal</h2>
<p>Esta proposta define um novo protocolo fim-a-fim para substituir ElGamal/AES+SessionTags. O design utilizará um handshake Noise e uma fase de dados incorporando o double ratchet do Signal.</p>
<h3 id="justificativa">Justificativa</h3>
<p>Existem cinco partes do protocolo a serem reprojetadas:</p>
<ul>
<li>
<ol>
<li>Os formatos de contêiner de Sessão nova e Existente
são substituídos por novos formatos.</li>
</ol>
</li>
<li>
<ol start="2">
<li>ElGamal (chaves públicas de 256 bytes, chaves privadas de 128 bytes) é substituído
por ECIES-X25519 (chaves públicas e privadas de 32 bytes)</li>
</ol>
</li>
<li>
<ol start="3">
<li>AES é substituído por
AEAD_ChaCha20_Poly1305 (abreviado como ChaChaPoly abaixo)</li>
</ol>
</li>
<li>
<ol start="4">
<li>SessionTags serão substituídas por ratchets,
que é essencialmente um PRNG criptográfico e sincronizado.</li>
</ol>
</li>
<li>
<ol start="5">
<li>O payload AES, conforme definido na especificação ElGamal/AES+SessionTags,
é substituído por um formato de bloco similar ao do NTCP2.</li>
</ol>
</li>
</ul>
<p>Cada uma das cinco mudanças tem sua própria seção abaixo.</p>
<h3 id="modelo-de-ameaças">Modelo de Ameaças</h3>
<p>As implementações existentes de router I2P exigirão implementações para as seguintes primitivas criptográficas padrão, que não são necessárias para os protocolos I2P atuais:</p>
<ul>
<li>ECIES (mas isso é essencialmente X25519)</li>
<li>Elligator2</li>
</ul>
<p>As implementações existentes de roteadores I2P que ainda não implementaram <a href="../../../pt/docs/specs/ntcp2/">NTCP2</a>
 (<a href="../../../pt/proposals/111-ntcp-2/">Proposta 111</a>
) também exigirão implementações para:</p>
<ul>
<li>Geração de chaves X25519 e DH</li>
<li>AEAD_ChaCha20_Poly1305 (abreviado como ChaChaPoly abaixo)</li>
<li>HKDF</li>
</ul>
<h3 id="crypto-type">Crypto Type</h3>
<p>O tipo de criptografia (usado no LS2) é 4. Isso indica uma chave pública X25519 de 32 bytes little-endian, e o protocolo ponta-a-ponta especificado aqui.</p>
<p>O tipo de criptografia 0 é ElGamal. Os tipos de criptografia 1-3 são reservados para ECIES-ECDH-AES-SessionTag, veja a proposta 145 <a href="../../../pt/proposals/145-ecies">Proposal 145</a>
.</p>
<h3 id="resumo-do-design-criptográfico">Resumo do Design Criptográfico</h3>
<p>Esta proposta fornece os requisitos baseados no Noise Protocol Framework <a href="https://noiseprotocol.org/noise.html">NOISE</a>
 (Revisão 34, 2018-07-11). O Noise tem propriedades similares ao protocolo Station-To-Station <a href="https://en.wikipedia.org/wiki/Station-to-Station_protocol">STS</a>
, que é a base para o protocolo <a href="../../../pt/docs/legacy/ssu/">SSU</a>
. Na terminologia do Noise, Alice é a iniciadora e Bob é o respondedor.</p>
<p>Esta proposta é baseada no protocolo Noise Noise_IK_25519_ChaChaPoly_SHA256. (O identificador real para a função de derivação de chave inicial é &ldquo;Noise_IKelg2_25519_ChaChaPoly_SHA256&rdquo; para indicar extensões I2P - veja a seção KDF 1 abaixo) Este protocolo Noise usa as seguintes primitivas:</p>
<ul>
<li>
<p>Padrão de Handshake Interativo: IK
Alice transmite imediatamente sua chave estática para Bob (I)
Alice já conhece a chave estática de Bob (K)</p>
</li>
<li>
<p>One-Way Handshake Pattern: N
Alice não transmite sua chave estática para Bob (N)</p>
</li>
<li>
<p>Função DH: X25519
X25519 DH com comprimento de chave de 32 bytes conforme especificado na <a href="https://tools.ietf.org/html/rfc7748">RFC-7748</a>
.</p>
</li>
<li>
<p>Função de Cifra: ChaChaPoly
AEAD_CHACHA20_POLY1305 conforme especificado na <a href="https://tools.ietf.org/html/rfc7539">RFC-7539</a>
 seção 2.8.
Nonce de 12 bytes, com os primeiros 4 bytes definidos como zero.
Idêntica à do <a href="../../../pt/docs/specs/ntcp2/">NTCP2</a>
.</p>
</li>
<li>
<p>Função de Hash: SHA256
Hash padrão de 32 bytes, já usado extensivamente no I2P.</p>
</li>
</ul>
<h3 id="novas-primitivas-criptográficas-para-i2p">Novas Primitivas Criptográficas para I2P</h3>
<p>Esta proposta define as seguintes melhorias para Noise_IK_25519_ChaChaPoly_SHA256. Estas geralmente seguem as diretrizes na seção 13 do <a href="https://noiseprotocol.org/noise.html">NOISE</a>
.</p>
<ol>
<li>
<p>Chaves efêmeras em texto simples são codificadas com <a href="https://elligator.cr.yp.to/">Elligator2</a>
.</p>
</li>
<li>
<p>A resposta é prefixada com uma tag de texto claro.</p>
</li>
<li>
<p>O formato da carga útil é definido para as mensagens 1, 2, e a fase de dados. Claro, isso não é definido no Noise.</p>
</li>
</ol>
<p>Todas as mensagens incluem um cabeçalho de <a href="../../../pt/docs/specs/i2np/">I2NP</a>
 Garlic Message. A fase de dados usa criptografia similar, mas não compatível com a fase de dados do Noise.</p>
<h3 id="tipo-de-criptografia">Tipo de Criptografia</h3>
<p>Os handshakes utilizam padrões de handshake <a href="https://noiseprotocol.org/noise.html">Noise</a>
.</p>
<p>O seguinte mapeamento de letras é usado:</p>
<ul>
<li>e = chave efêmera de uso único</li>
<li>s = chave estática</li>
<li>p = carga útil da mensagem</li>
</ul>
<p>Sessões One-time e Unbound são similares ao padrão Noise N.</p>
<pre tabindex="0"><code>
&lt;- s
  ...
  e es p -&gt;
</code></pre><p>Sessões vinculadas são similares ao padrão Noise IK.</p>
<pre tabindex="0"><code>
&lt;- s
  ...
  e es s ss p -&gt;
  &lt;- tag e ee se
  &lt;- p
  p -&gt;
</code></pre><h3 id="estrutura-do-protocolo-noise">Estrutura do Protocolo Noise</h3>
<p>O protocolo ElGamal/AES+SessionTag atual é unidirecional. Nesta camada, o receptor não sabe de onde vem uma mensagem. As sessões de saída e entrada não estão associadas. As confirmações são fora de banda usando uma DeliveryStatusMessage (encapsulada em uma GarlicMessage) no cravo.</p>
<p>Há uma ineficiência substancial em um protocolo unidirecional. Qualquer resposta também deve usar uma mensagem custosa de &lsquo;Nova Sessão&rsquo;. Isso causa maior uso de largura de banda, CPU e memória.</p>
<p>Também há fraquezas de segurança em um protocolo unidirecional. Todas as sessões são baseadas em DH ephemeral-static. Sem um caminho de retorno, não há maneira de Bob &ldquo;ratchet&rdquo; sua chave estática para uma chave ephemeral. Sem saber de onde uma mensagem vem, não há maneira de usar a chave ephemeral recebida para mensagens de saída, então a resposta inicial também usa DH ephemeral-static.</p>
<p>Para esta proposta, definimos dois mecanismos para criar um protocolo bidirecional - &ldquo;pairing&rdquo; e &ldquo;binding&rdquo;. Estes mecanismos proporcionam maior eficiência e segurança.</p>
<h3 id="adições-ao-framework">Adições ao Framework</h3>
<p>Assim como com ElGamal/AES+SessionTags, todas as sessões de entrada e saída devem estar em um contexto específico, seja o contexto do router ou o contexto para um destino local particular. No Java I2P, este contexto é chamado de Session Key Manager.</p>
<p>As sessões não devem ser compartilhadas entre contextos, pois isso permitiria a correlação entre os vários destinos locais, ou entre um destino local e um router.</p>
<p>Quando um determinado destino suporta tanto ElGamal/AES+SessionTags quanto esta proposta, ambos os tipos de sessões podem compartilhar um contexto. Veja a seção 1c) abaixo.</p>
<h3 id="padrões-de-handshake">Padrões de Handshake</h3>
<p>Quando uma sessão de saída é criada no originador (Alice), uma nova sessão de entrada é criada e emparelhada com a sessão de saída, a menos que nenhuma resposta seja esperada (por exemplo, datagramas brutos).</p>
<p>Uma nova sessão de entrada é sempre emparelhada com uma nova sessão de saída, a menos que nenhuma resposta seja solicitada (por exemplo, datagramas brutos).</p>
<p>Se uma resposta for solicitada e vinculada a um destino ou router de extremidade distante, essa nova sessão de saída é vinculada a esse destino ou router, e substitui qualquer sessão de saída anterior para esse destino ou router.</p>
<p>O emparelhamento de sessões de entrada e saída fornece um protocolo bidirecional com a capacidade de rotacionar as chaves DH.</p>
<h3 id="sessões">Sessões</h3>
<p>Existe apenas uma sessão de saída para um determinado destino ou router. Pode haver várias sessões de entrada atuais de um determinado destino ou router. Geralmente, quando uma nova sessão de entrada é criada e o tráfego é recebido nessa sessão (o que serve como um ACK), quaisquer outras serão marcadas para expirar relativamente rapidamente, dentro de um minuto ou mais. O valor das mensagens anteriores enviadas (PN) é verificado e, se não houver mensagens não recebidas (dentro do tamanho da janela) na sessão de entrada anterior, a sessão anterior pode ser excluída imediatamente.</p>
<p>Quando uma sessão de saída é criada no originador (Alice), ela é vinculada ao Destination de destino (Bob), e qualquer sessão de entrada emparelhada também será vinculada ao Destination de destino. Conforme as sessões evoluem, elas continuam vinculadas ao Destination de destino.</p>
<p>Quando uma sessão de entrada é criada no receptor (Bob), ela pode ser vinculada ao Destination remoto (Alice), conforme opção da Alice. Se Alice incluir informações de vinculação (sua chave estática) na mensagem New Session, a sessão será vinculada a esse destination, e uma sessão de saída será criada e vinculada ao mesmo Destination. À medida que as sessões fazem ratchet, elas continuam vinculadas ao Destination remoto.</p>
<h3 id="contexto-da-sessão">Contexto da Sessão</h3>
<p>Para o caso comum de streaming, esperamos que Alice e Bob usem o protocolo da seguinte forma:</p>
<ul>
<li>Alice emparelha sua nova sessão de saída com uma nova sessão de entrada, ambas vinculadas ao destino remoto (Bob).</li>
<li>Alice inclui as informações de vinculação e assinatura, e uma solicitação de resposta, na
mensagem New Session enviada para Bob.</li>
<li>Bob emparelha sua nova sessão de entrada com uma nova sessão de saída, ambas vinculadas ao destino remoto (Alice).</li>
<li>Bob envia uma resposta (ack) para Alice na sessão emparelhada, com um ratchet para uma nova chave DH.</li>
<li>Alice executa ratchet para uma nova sessão de saída com a nova chave de Bob, emparelhada à sessão de entrada existente.</li>
</ul>
<p>Ao vincular uma sessão de entrada a um Destination de extremidade distante, e emparelhar a sessão de entrada com uma sessão de saída vinculada ao mesmo Destination, obtemos dois grandes benefícios:</p>
<ol>
<li>
<p>A resposta inicial de Bob para Alice usa DH efêmero-efêmero</p>
</li>
<li>
<p>Após a Alice receber a resposta do Bob e realizar os ratchets, todas as mensagens subsequentes da Alice para o Bob usam DH efêmero-efêmero.</p>
</li>
</ol>
<h3 id="emparelhando-sessões-de-entrada-e-saída">Emparelhando Sessões de Entrada e Saída</h3>
<p>Em ElGamal/AES+SessionTags, quando um LeaseSet é empacotado como um garlic clove, ou tags são entregues, o router remetente solicita um ACK. Este é um garlic clove separado contendo uma Mensagem DeliveryStatus. Para segurança adicional, a Mensagem DeliveryStatus é encapsulada em uma Mensagem Garlic. Este mecanismo é fora da banda da perspectiva do protocolo.</p>
<p>No novo protocolo, uma vez que as sessões de entrada e saída estão emparelhadas, podemos ter ACKs em banda. Nenhum clove separado é necessário.</p>
<p>Um ACK explícito é simplesmente uma mensagem de Sessão Existente sem bloco I2NP. No entanto, na maioria dos casos, um ACK explícito pode ser evitado, pois há tráfego reverso. Pode ser desejável que as implementações aguardem um curto período (talvez cem ms) antes de enviar um ACK explícito, para dar tempo à camada de streaming ou aplicação para responder.</p>
<p>As implementações também precisarão adiar o envio de qualquer ACK até após o bloco I2NP ser processado, pois a Garlic Message pode conter uma Database Store Message com um leaseSet. Um leaseSet recente será necessário para rotear o ACK, e o destino da extremidade distante (contido no leaseSet) será necessário para verificar a chave estática de vinculação.</p>
<h3 id="vinculação-de-sessões-e-destinos">Vinculação de Sessões e Destinos</h3>
<p>As sessões de saída devem sempre expirar antes das sessões de entrada. Quando uma sessão de saída expira e uma nova é criada, uma nova sessão de entrada emparelhada também será criada. Se havia uma sessão de entrada antiga, ela será permitida a expirar.</p>
<h3 id="benefícios-do-binding-e-pairing">Benefícios do Binding e Pairing</h3>
<p>A ser definido</p>
<h3 id="acks-de-mensagem">ACKs de Mensagem</h3>
<p>Definimos as seguintes funções correspondentes aos blocos de construção criptográficos utilizados.</p>
<p>ZEROLEN</p>
<pre><code>zero-length byte array
</code></pre>
<p>CSRNG(n)</p>
<pre><code>n-byte output from a cryptographically-secure random number generator.
</code></pre>
<p>H(p, d)</p>
<pre><code>SHA-256 hash function that takes a personalization string p and data d, and
produces an output of length 32 bytes.
As defined in [NOISE](https://noiseprotocol.org/noise.html).
|| below means append.

Use SHA-256 as follows::

    H(p, d) := SHA-256(p || d)
</code></pre>
<p>MixHash(d)</p>
<pre><code>SHA-256 hash function that takes a previous hash h and new data d,
and produces an output of length 32 bytes.
|| below means append.

Use SHA-256 as follows::

    MixHash(d) := h = SHA-256(h || d)
</code></pre>
<p>STREAM</p>
<pre><code>The ChaCha20/Poly1305 AEAD as specified in [RFC-7539](https://tools.ietf.org/html/rfc7539).
S_KEY_LEN = 32 and S_IV_LEN = 12.

ENCRYPT(k, n, plaintext, ad)
    Encrypts plaintext using the cipher key k, and nonce n which MUST be unique for
    the key k.
    Associated data ad is optional.
    Returns a ciphertext that is the size of the plaintext + 16 bytes for the HMAC.

    The entire ciphertext must be indistinguishable from random if the key is secret.

DECRYPT(k, n, ciphertext, ad)
    Decrypts ciphertext using the cipher key k, and nonce n.
    Associated data ad is optional.
    Returns the plaintext.
</code></pre>
<p>DH</p>
<pre><code>X25519 public key agreement system. Private keys of 32 bytes, public keys of 32
bytes, produces outputs of 32 bytes. It has the following
functions:

GENERATE_PRIVATE()
    Generates a new private key.

DERIVE_PUBLIC(privkey)
    Returns the public key corresponding to the given private key.

GENERATE_PRIVATE_ELG2()
    Generates a new private key that maps to a public key suitable for Elligator2 encoding.
    Note that half of the randomly-generated private keys will not be suitable and must be discarded.

ENCODE_ELG2(pubkey)
    Returns the Elligator2-encoded public key corresponding to the given public key (inverse mapping).
    Encoded keys are little endian.
    Encoded key must be 256 bits indistinguishable from random data.
    See Elligator2 section below for specification.

DECODE_ELG2(pubkey)
    Returns the public key corresponding to the given Elligator2-encoded public key.
    See Elligator2 section below for specification.

DH(privkey, pubkey)
    Generates a shared secret from the given private and public keys.
</code></pre>
<p>HKDF(salt, ikm, info, n)</p>
<pre><code>A cryptographic key derivation function which takes some input key material ikm (which
should have good entropy but is not required to be a uniformly random string), a salt
of length 32 bytes, and a context-specific 'info' value, and produces an output
of n bytes suitable for use as key material.

Use HKDF as specified in [RFC-5869](https://tools.ietf.org/html/rfc5869), using the HMAC hash function SHA-256
as specified in [RFC-2104](https://tools.ietf.org/html/rfc2104). This means that SALT_LEN is 32 bytes max.
</code></pre>
<p>MixKey(d)</p>
<pre><code>Use HKDF() with a previous chainKey and new data d, and
sets the new chainKey and k.
As defined in [NOISE](https://noiseprotocol.org/noise.html).

Use HKDF as follows::

    MixKey(d) := output = HKDF(chainKey, d, &quot;&quot;, 64)
                 chainKey = output[0:31]
                 k = output[32:63]
</code></pre>
<h3 id="timeouts-de-sessão">Timeouts de Sessão</h3>
<h3 id="multicast">Multicast</h3>
<p>A Mensagem Garlic conforme especificada em <a href="../../../pt/docs/specs/i2np/">I2NP</a>
 é a seguinte. Como um objetivo de design é que os saltos intermediários não possam distinguir criptografia nova da antiga, este formato não pode mudar, mesmo que o campo de comprimento seja redundante. O formato é mostrado com o cabeçalho completo de 16 bytes, embora o cabeçalho real possa estar em um formato diferente, dependendo do transporte usado.</p>
<p>Quando descriptografado, os dados contêm uma série de Garlic Cloves e dados adicionais, também conhecidos como um Clove Set.</p>
<p>Veja <a href="../../../pt/docs/specs/i2np/">I2NP</a>
 para detalhes e especificação completa.</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |type|      msg_id       |  expiration
  +----+----+----+----+----+----+----+----+
                           |  size   |chks|
  +----+----+----+----+----+----+----+----+
  |      length       |                   |
  +----+----+----+----+                   +
  |          encrypted data               |
  ~                                       ~
  ~                                       ~
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><h3 id="definições">Definições</h3>
<p>O formato de mensagem atual, usado por mais de 15 anos, é ElGamal/AES+SessionTags. No ElGamal/AES+SessionTags, há dois formatos de mensagem:</p>
<ol>
<li>
<p>Nova sessão: - Bloco ElGamal de 514 bytes - Bloco AES (128 bytes mínimo, múltiplo de 16)</p>
</li>
<li>
<p>Sessão existente: - 32 byte Session Tag - Bloco AES (128 bytes mínimo, múltiplo de 16)</p>
</li>
</ol>
<p>O preenchimento mínimo para 128 é como implementado no Java I2P, mas não é aplicado na recepção.</p>
<p>Essas mensagens são encapsuladas em uma mensagem I2NP garlic, que contém um campo de comprimento, portanto o comprimento é conhecido.</p>
<p>Observe que não há padding definido para um comprimento não-mod-16, então a New Session é sempre (mod 16 == 2), e uma Existing Session é sempre (mod 16 == 0). Precisamos corrigir isso.</p>
<p>O receptor primeiro tenta procurar os primeiros 32 bytes como uma Session Tag. Se encontrada, ele descriptografa o bloco AES. Se não encontrada, e os dados tiverem pelo menos (514+16) de comprimento, ele tenta descriptografar o bloco ElGamal, e se bem-sucedido, descriptografa o bloco AES.</p>
<h3 id="1-formato-da-mensagem">1) Formato da mensagem</h3>
<p>No Signal Double Ratchet, o cabeçalho contém:</p>
<ul>
<li>DH: Chave pública ratchet atual</li>
<li>PN: Comprimento da mensagem da cadeia anterior</li>
<li>N: Número da Mensagem</li>
</ul>
<p>As &ldquo;sending chains&rdquo; do Signal são aproximadamente equivalentes aos nossos conjuntos de tags. Ao usar uma tag de sessão, podemos eliminar a maior parte disso.</p>
<p>Em New Session, colocamos apenas a chave pública no cabeçalho não criptografado.</p>
<p>Na Sessão Existente, usamos uma tag de sessão para o cabeçalho. A tag de sessão está associada à chave pública do ratchet atual e ao número da mensagem.</p>
<p>Tanto em Sessão nova quanto em Sessão Existente, PN e N estão no corpo criptografado.</p>
<p>No Signal, as coisas estão constantemente fazendo ratcheting. Uma nova chave pública DH requer que o receptor faça ratchet e envie uma nova chave pública de volta, o que também serve como o ack para a chave pública recebida. Isso seria muitas operações DH demais para nós. Então separamos o ack da chave recebida e a transmissão de uma nova chave pública. Qualquer mensagem usando uma session tag gerada a partir da nova chave pública DH constitui um ACK. Só transmitimos uma nova chave pública quando desejamos fazer rekey.</p>
<p>O número máximo de mensagens antes que o DH deve fazer ratchet é 65535.</p>
<p>Ao entregar uma chave de sessão, derivamos o &ldquo;Tag Set&rdquo; dela, em vez de ter que entregar session tags também. Um Tag Set pode ter até 65536 tags. No entanto, os receptores devem implementar uma estratégia de &ldquo;look-ahead&rdquo;, em vez de gerar todas as tags possíveis de uma vez. Gere apenas no máximo N tags além da última tag válida recebida. N pode ser no máximo 128, mas 32 ou até menos pode ser uma escolha melhor.</p>
<h3 id="revisão-do-formato-de-mensagem-atual">Revisão do Formato de Mensagem Atual</h3>
<p>Chave Pública de Sessão Nova de Uso Único (32 bytes) Dados criptografados e MAC (bytes restantes)</p>
<p>A mensagem New Session pode ou não conter a chave pública estática do remetente. Se estiver incluída, a sessão reversa fica vinculada a essa chave. A chave estática deve ser incluída se respostas forem esperadas, ou seja, para streaming e datagramas que podem ser respondidos. Não deve ser incluída para datagramas brutos.</p>
<p>A mensagem New Session é semelhante ao padrão <a href="https://noiseprotocol.org/noise.html">NOISE</a>
 unidirecional &ldquo;N&rdquo; (se a chave estática não for enviada), ou ao padrão bidirecional &ldquo;IK&rdquo; (se a chave estática for enviada).</p>
<h3 id="revisão-do-formato-de-dados-criptografados">Revisão do Formato de Dados Criptografados</h3>
<p>O comprimento é 96 + comprimento do payload. Formato criptografado:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   New Session Ephemeral Public Key    |
  +             32 bytes                  +
  |     Encoded with Elligator2           |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +         Static Key                    +
  |       ChaCha20 encrypted data         |
  +            32 bytes                   +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +    (MAC) for Static Key Section       +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +            Payload Section            +
  |       ChaCha20 encrypted data         |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +         (MAC) for Payload Section     +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+

  Public Key :: 32 bytes, little endian, Elligator2, cleartext

  Static Key encrypted data :: 32 bytes

  Payload Section encrypted data :: remaining data minus 16 bytes

  MAC :: Poly1305 message authentication code, 16 bytes
</code></pre><h3 id="novas-session-tags-e-comparação-com-o-signal">Novas Session Tags e Comparação com o Signal</h3>
<p>A chave efêmera tem 32 bytes, codificada com Elligator2. Esta chave nunca é reutilizada; uma nova chave é gerada com cada mensagem, incluindo retransmissões.</p>
<h3 id="1a-novo-formato-de-sessão">1a) Novo formato de sessão</h3>
<p>Quando decriptada, a chave estática X25519 de Alice, 32 bytes.</p>
<h3 id="1b-novo-formato-de-sessão-com-vinculação">1b) Novo formato de sessão (com vinculação)</h3>
<p>O comprimento criptografado é o restante dos dados. O comprimento descriptografado é 16 a menos que o comprimento criptografado. O payload deve conter um bloco DateTime e geralmente conterá um ou mais blocos Garlic Clove. Consulte a seção payload abaixo para formato e requisitos adicionais.</p>
<h3 id="chave-efêmera-de-nova-sessão">Chave Efêmera de Nova Sessão</h3>
<p>Se nenhuma resposta for necessária, nenhuma chave estática é enviada.</p>
<p>O comprimento é 96 + comprimento do payload. Formato criptografado:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   New Session Ephemeral Public Key    |
  +             32 bytes                  +
  |     Encoded with Elligator2           |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +           Flags Section               +
  |       ChaCha20 encrypted data         |
  +            32 bytes                   +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +         (MAC) for above section       +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +            Payload Section            +
  |       ChaCha20 encrypted data         |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +         (MAC) for Payload Section     +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+

  Public Key :: 32 bytes, little endian, Elligator2, cleartext

  Flags Section encrypted data :: 32 bytes

  Payload Section encrypted data :: remaining data minus 16 bytes

  MAC :: Poly1305 message authentication code, 16 bytes
</code></pre><h3 id="chave-estática">Chave Estática</h3>
<p>Chave efêmera da Alice. A chave efêmera tem 32 bytes, codificada com Elligator2, little endian. Esta chave nunca é reutilizada; uma nova chave é gerada a cada mensagem, incluindo retransmissões.</p>
<h3 id="payload">Payload</h3>
<p>A seção Flags não contém nada. Ela sempre tem 32 bytes, porque deve ter o mesmo comprimento que a chave estática para mensagens New Session com binding. Bob determina se são 32 bytes de uma chave estática ou de uma seção flags testando se os 32 bytes são todos zeros.</p>
<p>TODO alguma flag necessária aqui?</p>
<h3 id="1c-novo-formato-de-sessão-sem-vinculação">1c) Novo formato de sessão (sem vinculação)</h3>
<p>O comprimento criptografado é o restante dos dados. O comprimento descriptografado é 16 a menos que o comprimento criptografado. A carga útil deve conter um bloco DateTime e geralmente conterá um ou mais blocos Garlic Clove. Veja a seção de carga útil abaixo para formato e requisitos adicionais.</p>
<h3 id="chave-efêmera-de-nova-sessão-1">Chave Efêmera de Nova Sessão</h3>
<p>Se apenas uma única mensagem for esperada para ser enviada, nenhuma configuração de sessão ou chave estática é necessária.</p>
<p>O comprimento é 96 + comprimento do payload. Formato criptografado:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |       Ephemeral Public Key            |
  +             32 bytes                  +
  |     Encoded with Elligator2           |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +           Flags Section               +
  |       ChaCha20 encrypted data         |
  +            32 bytes                   +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +         (MAC) for above section       +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +            Payload Section            +
  |       ChaCha20 encrypted data         |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +         (MAC) for Payload Section     +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+

  Public Key :: 32 bytes, little endian, Elligator2, cleartext

  Flags Section encrypted data :: 32 bytes

  Payload Section encrypted data :: remaining data minus 16 bytes

  MAC :: Poly1305 message authentication code, 16 bytes
</code></pre><h3 id="seção-de-flags-dados-descriptografados">Seção de Flags Dados descriptografados</h3>
<p>A chave de uso único tem 32 bytes, codificada com Elligator2, little endian. Esta chave nunca é reutilizada; uma nova chave é gerada a cada mensagem, incluindo retransmissões.</p>
<h3 id="payload-1">Payload</h3>
<p>A seção Flags não contém nada. Ela sempre tem 32 bytes, porque deve ter o mesmo comprimento que a chave estática para mensagens New Session com binding. Bob determina se são 32 bytes de uma chave estática ou uma seção de flags testando se os 32 bytes são todos zeros.</p>
<p>TODO alguma flag necessária aqui?</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                                       |
  +             All zeros                 +
  |              32 bytes                 |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+

  zeros:: All zeros, 32 bytes.
</code></pre><h3 id="1d-formato-único-sem-vinculação-ou-sessão">1d) Formato único (sem vinculação ou sessão)</h3>
<p>O comprimento encriptado é o restante dos dados. O comprimento descriptografado é 16 a menos que o comprimento encriptado. A carga útil deve conter um bloco DateTime e geralmente conterá um ou mais blocos Garlic Clove. Consulte a seção de carga útil abaixo para formato e requisitos adicionais.</p>
<h3 id="nova-chave-de-sessão-de-uso-único">Nova Chave de Sessão de Uso Único</h3>
<h3 id="seção-de-flags-dados-descriptografados-1">Seção de Flags Dados descriptografados</h3>
<p>Este é o <a href="https://noiseprotocol.org/noise.html">NOISE</a>
 padrão para IK com um nome de protocolo modificado. Note que usamos o mesmo inicializador tanto para o padrão IK (sessões vinculadas) quanto para o padrão N (sessões não vinculadas).</p>
<p>O nome do protocolo é modificado por duas razões. Primeiro, para indicar que as chaves efêmeras são codificadas com Elligator2, e segundo, para indicar que MixHash() é chamado antes da segunda mensagem para misturar o valor da tag.</p>
<pre tabindex="0"><code>
This is the &#34;e&#34; message pattern:

  // Define protocol_name.
  Set protocol_name = &#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256&#34;
   (40 bytes, US-ASCII encoded, no NULL termination).

  // Define Hash h = 32 bytes
  h = SHA256(protocol_name);

  Define ck = 32 byte chaining key. Copy the h data to ck.
  Set chainKey = h

  // MixHash(null prologue)
  h = SHA256(h);

  // up until here, can all be precalculated by Alice for all outgoing connections
</code></pre><h3 id="payload-2">Payload</h3>
<pre tabindex="0"><code>
This is the &#34;e&#34; message pattern:

  // Bob&#39;s X25519 static keys
  // bpk is published in leaseset
  bsk = GENERATE_PRIVATE()
  bpk = DERIVE_PUBLIC(bsk)

  // Bob static public key
  // MixHash(bpk)
  // || below means append
  h = SHA256(h || bpk);

  // up until here, can all be precalculated by Bob for all incoming connections

  // Alice&#39;s X25519 ephemeral keys
  aesk = GENERATE_PRIVATE_ELG2()
  aepk = DERIVE_PUBLIC(aesk)

  // Alice ephemeral public key
  // MixHash(aepk)
  // || below means append
  h = SHA256(h || aepk);

  // h is used as the associated data for the AEAD in the New Session Message
  // Retain the Hash h for the New Session Reply KDF
  // eapk is sent in cleartext in the
  // beginning of the New Session message
  elg2_aepk = ENCODE_ELG2(aepk)
  // As decoded by Bob
  aepk = DECODE_ELG2(elg2_aepk)

  End of &#34;e&#34; message pattern.

  This is the &#34;es&#34; message pattern:

  // Noise es
  sharedSecret = DH(aesk, bpk) = DH(bsk, aepk)

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  // ChaChaPoly parameters to encrypt/decrypt
  keydata = HKDF(chainKey, sharedSecret, &#34;&#34;, 64)
  chainKey = keydata[0:31]

  // AEAD parameters
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, flags/static key section, ad)

  End of &#34;es&#34; message pattern.

  This is the &#34;s&#34; message pattern:

  // MixHash(ciphertext)
  // Save for Payload section KDF
  h = SHA256(h || ciphertext)

  // Alice&#39;s X25519 static keys
  ask = GENERATE_PRIVATE()
  apk = DERIVE_PUBLIC(ask)

  End of &#34;s&#34; message pattern.
</code></pre><h3 id="1f-kdfs-para-mensagem-de-nova-sessão">1f) KDFs para Mensagem de Nova Sessão</h3>
<pre tabindex="0"><code>
This is the &#34;ss&#34; message pattern:

  // Noise ss
  sharedSecret = DH(ask, bpk) = DH(bsk, apk)

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  // ChaChaPoly parameters to encrypt/decrypt
  // chainKey from Static Key Section
  Set sharedSecret = X25519 DH result
  keydata = HKDF(chainKey, sharedSecret, &#34;&#34;, 64)
  chainKey = keydata[0:31]

  // AEAD parameters
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, payload, ad)

  End of &#34;ss&#34; message pattern.

  // MixHash(ciphertext)
  // Save for New Session Reply KDF
  h = SHA256(h || ciphertext)
</code></pre><h3 id="kdf-para-chainkey-inicial">KDF para ChainKey Inicial</h3>
<p>Note que este é um padrão Noise &ldquo;N&rdquo;, mas usamos o mesmo inicializador &ldquo;IK&rdquo; que para sessões vinculadas.</p>
<p>As mensagens New Session não podem ser identificadas como contendo a chave estática da Alice ou não até que a chave estática seja descriptografada e inspecionada para determinar se contém todos os zeros. Portanto, o receptor deve usar a máquina de estados &ldquo;IK&rdquo; para todas as mensagens New Session. Se a chave estática for todos os zeros, o padrão de mensagem &ldquo;ss&rdquo; deve ser pulado.</p>
<pre tabindex="0"><code>
chainKey = from Flags/Static key section
  k = from Flags/Static key section
  n = 1
  ad = h from Flags/Static key section
  ciphertext = ENCRYPT(k, n, payload, ad)
</code></pre><h3 id="kdf-para-conteúdos-encriptados-da-seção-flagsstatic-key">KDF para Conteúdos Encriptados da Seção Flags/Static Key</h3>
<p>Uma ou mais New Session Replies podem ser enviadas em resposta a uma única mensagem New Session. Cada resposta é precedida por uma tag, que é gerada a partir de um TagSet para a sessão.</p>
<p>A New Session Reply está em duas partes. A primeira parte é a conclusão do handshake Noise IK com uma tag anexada. O comprimento da primeira parte é de 56 bytes. A segunda parte é o payload da fase de dados. O comprimento da segunda parte é 16 + comprimento do payload.</p>
<p>O comprimento total é 72 + comprimento do payload. Formato criptografado:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |       Session Tag   8 bytes           |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Ephemeral Public Key           +
  |                                       |
  +            32 bytes                   +
  |     Encoded with Elligator2           |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +  (MAC) for Key Section (no data)      +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +            Payload Section            +
  |       ChaCha20 encrypted data         |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +         (MAC) for Payload Section     +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+

  Tag :: 8 bytes, cleartext

  Public Key :: 32 bytes, little endian, Elligator2, cleartext

  MAC :: Poly1305 message authentication code, 16 bytes
         Note: The ChaCha20 plaintext data is empty (ZEROLEN)

  Payload Section encrypted data :: remaining data minus 16 bytes

  MAC :: Poly1305 message authentication code, 16 bytes
</code></pre><h3 id="kdf-para-seção-de-payload-com-chave-estática-da-alice">KDF para Seção de Payload (com chave estática da Alice)</h3>
<p>A tag é gerada no Session Tags KDF, conforme inicializado no DH Initialization KDF abaixo. Isso correlaciona a resposta à sessão. A Session Key do DH Initialization não é utilizada.</p>
<h3 id="kdf-para-seção-de-payload-sem-chave-estática-da-alice">KDF para Seção de Payload (sem chave estática da Alice)</h3>
<p>Chave efêmera do Bob. A chave efêmera tem 32 bytes, codificada com Elligator2, little endian. Esta chave nunca é reutilizada; uma nova chave é gerada a cada mensagem, incluindo retransmissões.</p>
<h3 id="1g-formato-da-resposta-de-nova-sessão">1g) Formato da Resposta de Nova Sessão</h3>
<p>O comprimento criptografado é o restante dos dados. O comprimento descriptografado é 16 menos que o comprimento criptografado. O payload geralmente conterá um ou mais blocos Garlic Clove. Consulte a seção de payload abaixo para formato e requisitos adicionais.</p>
<h3 id="session-tag">Session Tag</h3>
<p>Uma ou mais tags são criadas a partir do TagSet, que é inicializado usando o KDF abaixo, usando a chainKey da mensagem New Session.</p>
<pre tabindex="0"><code>
// Generate tagset
  tagsetKey = HKDF(chainKey, ZEROLEN, &#34;SessionReplyTags&#34;, 32)
  tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey)
</code></pre><h3 id="resposta-de-nova-sessão-com-chave-efêmera">Resposta de Nova Sessão com Chave Efêmera</h3>
<pre tabindex="0"><code>
// Keys from the New Session message
  // Alice&#39;s X25519 keys
  // apk and aepk are sent in original New Session message
  // ask = Alice private static key
  // apk = Alice public static key
  // aesk = Alice ephemeral private key
  // aepk = Alice ephemeral public key
  // Bob&#39;s X25519 static keys
  // bsk = Bob private static key
  // bpk = Bob public static key

  // Generate the tag
  tagsetEntry = tagset_nsr.GET_NEXT_ENTRY()
  tag = tagsetEntry.SESSION_TAG

  // MixHash(tag)
  h = SHA256(h || tag)

  This is the &#34;e&#34; message pattern:

  // Bob&#39;s X25519 ephemeral keys
  besk = GENERATE_PRIVATE_ELG2()
  bepk = DERIVE_PUBLIC(besk)

  // Bob&#39;s ephemeral public key
  // MixHash(bepk)
  // || below means append
  h = SHA256(h || bepk);

  // elg2_bepk is sent in cleartext in the
  // beginning of the New Session message
  elg2_bepk = ENCODE_ELG2(bepk)
  // As decoded by Bob
  bepk = DECODE_ELG2(elg2_bepk)

  End of &#34;e&#34; message pattern.

  This is the &#34;ee&#34; message pattern:

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  // ChaChaPoly parameters to encrypt/decrypt
  // chainKey from original New Session Payload Section
  sharedSecret = DH(aesk, bepk) = DH(besk, aepk)
  keydata = HKDF(chainKey, sharedSecret, &#34;&#34;, 32)
  chainKey = keydata[0:31]

  End of &#34;ee&#34; message pattern.

  This is the &#34;se&#34; message pattern:

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  sharedSecret = DH(ask, bepk) = DH(besk, apk)
  keydata = HKDF(chainKey, sharedSecret, &#34;&#34;, 64)
  chainKey = keydata[0:31]

  // AEAD parameters
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, ZEROLEN, ad)

  End of &#34;se&#34; message pattern.

  // MixHash(ciphertext)
  h = SHA256(h || ciphertext)

  chainKey is used in the ratchet below.
</code></pre><h3 id="payload-3">Payload</h3>
<p>Isso é como a primeira mensagem de Sessão Existente, pós-divisão, mas sem uma tag separada. Além disso, usamos o hash de cima para vincular o payload à mensagem NSR.</p>
<pre tabindex="0"><code>
// split()
  keydata = HKDF(chainKey, ZEROLEN, &#34;&#34;, 64)
  k_ab = keydata[0:31]
  k_ba = keydata[32:63]
  tagset_ab = DH_INITIALIZE(chainKey, k_ab)
  tagset_ba = DH_INITIALIZE(chainKey, k_ba)

  // AEAD parameters for New Session Reply payload
  k = HKDF(k_ba, ZEROLEN, &#34;AttachPayloadKDF&#34;, 32)
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, payload, ad)
</code></pre><h3 id="kdf-para-reply-tagset">KDF para Reply TagSet</h3>
<p>Múltiplas mensagens NSR podem ser enviadas em resposta, cada uma com chaves efêmeras únicas, dependendo do tamanho da resposta.</p>
<p>Alice e Bob são obrigados a usar novas chaves efêmeras para cada mensagem NS e NSR.</p>
<p>Alice deve receber uma das mensagens NSR de Bob antes de enviar mensagens de Sessão Existente (ES), e Bob deve receber uma mensagem ES de Alice antes de enviar mensagens ES.</p>
<p>O <code>chainKey</code> e <code>k</code> da Seção de Payload NSR do Bob são usados como entradas para os Ratchets ES DH iniciais (ambas as direções, veja DH Ratchet KDF).</p>
<p>Bob deve manter apenas as Sessões Existentes para as mensagens ES recebidas de Alice. Qualquer outra sessão de entrada e saída criada (para múltiplos NSRs) deve ser destruída imediatamente após receber a primeira mensagem ES de Alice para uma determinada sessão.</p>
<h3 id="kdf-para-conteúdos-criptografados-da-seção-reply-key">KDF para Conteúdos Criptografados da Seção Reply Key</h3>
<p>Tag da sessão (8 bytes) Dados criptografados e MAC (veja a seção 3 abaixo)</p>
<h3 id="kdf-para-conteúdos-criptografados-da-seção-de-payload">KDF para Conteúdos Criptografados da Seção de Payload</h3>
<p>Criptografado:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |       Session Tag                     |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +            Payload Section            +
  |       ChaCha20 encrypted data         |
  ~                                       ~
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +              (MAC)                    +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+

  Session Tag :: 8 bytes, cleartext

  Payload Section encrypted data :: remaining data minus 16 bytes

  MAC :: Poly1305 message authentication code, 16 bytes
</code></pre><h3 id="notas">Notas</h3>
<p>O comprimento criptografado é o restante dos dados. O comprimento descriptografado é 16 a menos que o comprimento criptografado. Veja a seção de payload abaixo para formato e requisitos.</p>
<p>KDF</p>
<pre tabindex="0"><code>See AEAD section below.

  // AEAD parameters for Existing Session payload
  k = The 32-byte session key associated with this session tag
  n = The message number N in the current chain, as retrieved from the associated Session Tag.
  ad = The session tag, 8 bytes
  ciphertext = ENCRYPT(k, n, payload, ad)
</code></pre><h3 id="1h-formato-de-sessão-existente">1h) Formato de sessão existente</h3>
<p>Formato: Chaves públicas e privadas de 32 bytes, little-endian.</p>
<p>Justificativa: Usado em <a href="../../../pt/docs/specs/ntcp2/">NTCP2</a>
.</p>
<h3 id="formato">Formato</h3>
<p>Nos handshakes Noise padrão, as mensagens iniciais de handshake em cada direção começam com chaves efêmeras que são transmitidas em texto simples. Como chaves X25519 válidas são distinguíveis de dados aleatórios, um atacante man-in-the-middle pode distinguir essas mensagens das mensagens de Sessão Existente que começam com tags de sessão aleatórias. No <a href="../../../pt/docs/specs/ntcp2/">NTCP2</a>
 (<a href="../../../pt/proposals/111-ntcp-2/">Proposta 111</a>
), usamos uma função XOR de baixo overhead usando a chave estática fora de banda para ofuscar a chave. No entanto, o modelo de ameaça aqui é diferente; não queremos permitir que qualquer MitM use qualquer meio para confirmar o destino do tráfego, ou para distinguir as mensagens iniciais de handshake das mensagens de Sessão Existente.</p>
<p>Portanto, <a href="https://elligator.cr.yp.to/">Elligator2</a>
 é usado para transformar as chaves efêmeras nas mensagens New Session e New Session Reply de modo que sejam indistinguíveis de strings uniformemente aleatórias.</p>
<h3 id="payload-4">Payload</h3>
<p>Chaves públicas e privadas de 32 bytes. As chaves codificadas são little endian.</p>
<p>Como definido em <a href="https://elligator.cr.yp.to/">Elligator2</a>
, as chaves codificadas são indistinguíveis de 254 bits aleatórios. Precisamos de 256 bits aleatórios (32 bytes). Portanto, a codificação e decodificação são definidas da seguinte forma:</p>
<p>Codificação:</p>
<pre tabindex="0"><code>
ENCODE_ELG2() Definition

  // Encode as defined in Elligator2 specification
  encodedKey = encode(pubkey)
  // OR in 2 random bits to MSB
  randomByte = CSRNG(1)
  encodedKey[31] |= (randomByte &amp; 0xc0)
</code></pre><p>Decodificação:</p>
<pre tabindex="0"><code>
DECODE_ELG2() Definition

  // Mask out 2 random bits from MSB
  encodedKey[31] &amp;= 0x3f
  // Decode as defined in Elligator2 specification
  pubkey = decode(encodedKey)
</code></pre><h3 id="2-ecies-x25519">2) ECIES-X25519</h3>
<p>Necessário para impedir que o OBEP e o IBGW classifiquem o tráfego.</p>
<h3 id="2a-elligator2">2a) Elligator2</h3>
<p>Elligator2 dobra o tempo médio de geração de chaves, pois metade das chaves privadas resulta em chaves públicas inadequadas para codificação com Elligator2. Além disso, o tempo de geração de chaves é ilimitado com uma distribuição exponencial, pois o gerador deve continuar tentando até encontrar um par de chaves adequado.</p>
<p>Este overhead pode ser gerenciado fazendo a geração de chaves antecipadamente, em uma thread separada, para manter um pool de chaves adequadas.</p>
<p>O gerador executa a função ENCODE_ELG2() para determinar a adequação. Portanto, o gerador deve armazenar o resultado de ENCODE_ELG2() para que não precise ser calculado novamente.</p>
<p>Adicionalmente, as chaves inadequadas podem ser adicionadas ao conjunto de chaves usadas para <a href="../../../pt/docs/specs/ntcp2/">NTCP2</a>
, onde Elligator2 não é usado. As questões de segurança de fazê-lo ainda estão por ser determinadas.</p>
<h3 id="formato-1">Formato</h3>
<p>AEAD usando ChaCha20 e Poly1305, igual ao usado em <a href="../../../pt/docs/specs/ntcp2/">NTCP2</a>
. Isto corresponde à <a href="https://tools.ietf.org/html/rfc7539">RFC-7539</a>
, que também é usado de forma similar no TLS <a href="https://tools.ietf.org/html/rfc7905">RFC-7905</a>
.</p>
<h3 id="justificativa-1">Justificativa</h3>
<p>Entradas para as funções de criptografia/descriptografia para um bloco AEAD numa mensagem New Session:</p>
<pre tabindex="0"><code>
k :: 32 byte cipher key
       See New Session and New Session Reply KDFs above.

  n :: Counter-based nonce, 12 bytes.
       n = 0

  ad :: Associated data, 32 bytes.
        The SHA256 hash of the preceding data, as output from mixHash()

  data :: Plaintext data, 0 or more bytes
</code></pre><h3 id="notas-1">Notas</h3>
<p>Entradas para as funções de criptografia/descriptografia para um bloco AEAD em uma mensagem de Sessão Existente:</p>
<pre tabindex="0"><code>
k :: 32 byte session key
       As looked up from the accompanying session tag.

  n :: Counter-based nonce, 12 bytes.
       Starts at 0 and incremented for each message when transmitting.
       For the receiver, the value
       as looked up from the accompanying session tag.
       First four bytes are always zero.
       Last eight bytes are the message number (n), little-endian encoded.
       Maximum value is 65535.
       Session must be ratcheted when N reaches that value.
       Higher values must never be used.

  ad :: Associated data
        The session tag

  data :: Plaintext data, 0 or more bytes
</code></pre><h3 id="3-aead-chachapoly">3) AEAD (ChaChaPoly)</h3>
<p>Saída da função de criptografia, entrada da função de descriptografia:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |       ChaCha20 encrypted data         |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +              (MAC)                    +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+

  encrypted data :: Same size as plaintext data, 0 - 65519 bytes

  MAC :: Poly1305 message authentication code, 16 bytes
</code></pre><h3 id="entradas-de-nova-sessão-e-resposta-de-nova-sessão">Entradas de Nova Sessão e Resposta de Nova Sessão</h3>
<ul>
<li>
<p>Como ChaCha20 é uma cifra de fluxo, os textos simples não precisam ser preenchidos.
Bytes adicionais de keystream são descartados.</p>
</li>
<li>
<p>A chave para a cifra (256 bits) é acordada por meio do SHA256 KDF.
Os detalhes do KDF para cada mensagem estão em seções separadas abaixo.</p>
</li>
<li>
<p>Os frames ChaChaPoly têm tamanho conhecido pois são encapsulados na mensagem de dados I2NP.</p>
</li>
<li>
<p>Para todas as mensagens,
o padding está dentro do quadro de
dados autenticados.</p>
</li>
</ul>
<h3 id="entradas-de-sessão-existentes">Entradas de Sessão Existentes</h3>
<p>Todos os dados recebidos que falharem na verificação AEAD devem ser descartados. Nenhuma resposta é retornada.</p>
<h3 id="formato-criptografado">Formato Criptografado</h3>
<p>Usado em <a href="../../../pt/docs/specs/ntcp2/">NTCP2</a>
.</p>
<h3 id="notas-2">Notas</h3>
<p>Ainda usamos session tags, como antes, mas usamos ratchets para gerá-las. Session tags também tinham uma opção de rekey que nunca implementamos. Então é como um double ratchet, mas nunca fizemos o segundo.</p>
<p>Aqui definimos algo similar ao Double Ratchet do Signal. As session tags são geradas de forma determinística e idêntica nos lados do receptor e do remetente.</p>
<p>Ao usar um ratchet de chave/tag simétrica, eliminamos o uso de memória para armazenar session tags no lado do remetente. Também eliminamos o consumo de largura de banda do envio de conjuntos de tags. O uso no lado do receptor ainda é significativo, mas podemos reduzi-lo ainda mais, pois iremos diminuir a session tag de 32 bytes para 8 bytes.</p>
<p>Não usamos criptografia de cabeçalho conforme especificado (e opcional) no Signal, usamos session tags em vez disso.</p>
<p>Ao usar um DH ratchet, alcançamos forward secrecy, que nunca foi implementado no ElGamal/AES+SessionTags.</p>
<p>Nota: A chave pública única da Nova Sessão não faz parte do ratchet, sua única função é criptografar a chave inicial do ratchet DH de Alice.</p>
<h3 id="tratamento-de-erros-aead">Tratamento de Erros AEAD</h3>
<p>O Double Ratchet lida com mensagens perdidas ou fora de ordem incluindo uma tag no cabeçalho de cada mensagem. O receptor procura o índice da tag, este é o número da mensagem N. Se a mensagem contém um bloco Message Number com um valor PN, o destinatário pode deletar quaisquer tags maiores que esse valor no conjunto de tags anterior, enquanto retém tags ignoradas do conjunto de tags anterior no caso das mensagens ignoradas chegarem mais tarde.</p>
<h3 id="justificativa-2">Justificativa</h3>
<p>Definimos as seguintes estruturas de dados e funções para implementar estes ratchets.</p>
<p>TAGSET_ENTRY</p>
<pre><code>A single entry in a TAGSET.

INDEX
    An integer index, starting with 0

SESSION_TAG
    An identifier to go out on the wire, 8 bytes

SESSION_KEY
    A symmetric key, never goes on the wire, 32 bytes
</code></pre>
<p>TAGSET</p>
<pre><code>A collection of TAGSET_ENTRIES.

CREATE(key, n)
    Generate a new TAGSET using initial cryptographic key material of 32 bytes.
    The associated session identifier is provided.
    The initial number of of tags to create is specified; this is generally 0 or 1
    for an outgoing session.
    LAST_INDEX = -1
    EXTEND(n) is called.

EXTEND(n)
    Generate n more TAGSET_ENTRIES by calling EXTEND() n times.

EXTEND()
    Generate one more TAGSET_ENTRY, unless the maximum number SESSION_TAGS have
    already been generated.
    If LAST_INDEX is greater than or equal to 65535, return.
    ++ LAST_INDEX
    Create a new TAGSET_ENTRY with the LAST_INDEX value and the calculated SESSION_TAG.
    Calls RATCHET_TAG() and (optionally) RATCHET_KEY().
    For inbound sessions, the calculation of the SESSION_KEY may
    be deferred and calculated in GET_SESSION_KEY().
    Calls EXPIRE()

EXPIRE()
    Remove tags and keys that are too old, or if the TAGSET size exceeds some limit.

RATCHET_TAG()
    Calculates the next SESSION_TAG based on the last SESSION_TAG.

RATCHET_KEY()
    Calculates the next SESSION_KEY based on the last SESSION_KEY.

SESSION
    The associated session.

CREATION_TIME
    When the TAGSET was created.

LAST_INDEX
    The last TAGSET_ENTRY INDEX generated by EXTEND().

GET_NEXT_ENTRY()
    Used for outgoing sessions only.
    EXTEND(1) is called if there are no remaining TAGSET_ENTRIES.
    If EXTEND(1) did nothing, the max of 65535 TAGSETS have been used,
    and return an error.
    Returns the next unused TAGSET_ENTRY.

GET_SESSION_KEY(sessionTag)
    Used for incoming sessions only.
    Returns the TAGSET_ENTRY containing the sessionTag.
    If found, the TAGSET_ENTRY is removed.
    If the SESSION_KEY calculation was deferred, it is calculated now.
    If there are few TAGSET_ENTRIES remaining, EXTEND(n) is called.
</code></pre>
<h3 id="4-ratchets">4) Ratchets</h3>
<p>Ratchets mas não tão rápido quanto o Signal faz. Separamos o reconhecimento da chave recebida da geração da nova chave. No uso típico, Alice e Bob farão cada um ratchet (duas vezes) imediatamente em uma Nova Sessão, mas não farão ratchet novamente.</p>
<p>Note que um ratchet é para uma única direção, e gera uma cadeia de ratchet de tag de Nova Sessão / chave de mensagem para essa direção. Para gerar chaves para ambas as direções, você tem que fazer ratchet duas vezes.</p>
<p>Você faz ratchet toda vez que gera e envia uma nova chave. Você faz ratchet toda vez que recebe uma nova chave.</p>
<p>Alice executa um ratchet uma vez ao criar uma sessão outbound não vinculada, ela não cria uma sessão inbound (não vinculada significa não respondível).</p>
<p>Bob faz um ratchet uma vez ao criar uma sessão inbound não vinculada, e não cria uma sessão outbound correspondente (não vinculada é não respondível).</p>
<p>Alice continua enviando mensagens New Session (NS) para Bob até receber uma das mensagens New Session Reply (NSR) de Bob. Ela então usa os resultados do KDF da Seção de Payload do NSR como entradas para os ratchets da sessão (veja DH Ratchet KDF), e começa a enviar mensagens Existing Session (ES).</p>
<p>Para cada mensagem NS recebida, Bob cria uma nova sessão de entrada, usando os resultados do KDF da Seção de Payload de resposta como entradas para o novo Ratchet DH ES de entrada e saída.</p>
<p>Para cada resposta necessária, Bob envia a Alice uma mensagem NSR com a resposta no payload. É obrigatório que Bob use novas chaves efêmeras para cada NSR.</p>
<p>Bob deve receber uma mensagem ES de Alice numa das sessões de entrada, antes de criar e enviar mensagens ES na sessão de saída correspondente.</p>
<p>Alice deve usar um temporizador para receber uma mensagem NSR de Bob. Se o temporizador expirar, a sessão deve ser removida.</p>
<p>Para evitar um ataque KCI e/ou de exaustão de recursos, onde um atacante descarta as respostas NSR de Bob para manter Alice enviando mensagens NS, Alice deve evitar iniciar New Sessions para Bob após um certo número de tentativas devido à expiração do temporizador.</p>
<p>Alice e Bob fazem cada um um ratchet DH para cada bloco NextKey recebido.</p>
<p>Alice e Bob geram cada um novos ratchets de conjuntos de tags e dois ratchets de chaves simétricas após cada ratchet DH. Para cada nova mensagem ES em uma determinada direção, Alice e Bob avançam os ratchets de tag de sessão e chave simétrica.</p>
<p>A frequência dos ratchets DH após o handshake inicial depende da implementação. Embora o protocolo estabeleça um limite de 65535 mensagens antes que um ratchet seja obrigatório, ratcheting mais frequente (baseado na contagem de mensagens, tempo decorrido, ou ambos) pode fornecer segurança adicional.</p>
<p>Após o KDF final do handshake em sessões vinculadas, Bob e Alice devem executar a função Noise Split() no CipherState resultante para criar chaves simétricas e de cadeia de tags independentes para sessões de entrada e saída.</p>
<h4 id="key-and-tag-set-ids">KEY AND TAG SET IDS</h4>
<p>Os números de ID das chaves e conjuntos de tags são usados para identificar chaves e conjuntos de tags. Os IDs de chave são usados em blocos NextKey para identificar a chave enviada ou utilizada. Os IDs de conjunto de tags são usados (com o número da mensagem) em blocos ACK para identificar a mensagem que está sendo confirmada. Tanto os IDs de chave quanto os de conjunto de tags se aplicam aos conjuntos de tags para uma única direção. Os números de ID das chaves e conjuntos de tags devem ser sequenciais.</p>
<p>Nos primeiros conjuntos de tags utilizados para uma sessão em cada direção, o ID do conjunto de tags é 0. Nenhum bloco NextKey foi enviado, portanto não há IDs de chave.</p>
<p>Para iniciar um DH ratchet, o remetente transmite um novo bloco NextKey com um ID de chave de 0. O receptor responde com um novo bloco NextKey com um ID de chave de 0. O remetente então começa a usar um novo conjunto de tags com um ID de conjunto de tags de 1.</p>
<p>Os conjuntos de tags subsequentes são gerados de forma similar. Para todos os conjuntos de tags usados após as trocas NextKey, o número do conjunto de tags é (1 + ID da chave de Alice + ID da chave de Bob).</p>
<p>Os IDs de chave e conjunto de tags começam em 0 e incrementam sequencialmente. O ID máximo do conjunto de tags é 65535. O ID máximo da chave é 32767. Quando um conjunto de tags está quase esgotado, o remetente do conjunto de tags deve iniciar uma troca NextKey. Quando o conjunto de tags 65535 está quase esgotado, o remetente do conjunto de tags deve iniciar uma nova sessão enviando uma mensagem New Session.</p>
<p>Com um tamanho máximo de mensagem de streaming de 1730, e assumindo nenhuma retransmissão, a transferência máxima teórica de dados usando um único conjunto de tags é 1730 * 65536 ~= 108 MB. O máximo real será menor devido às retransmissões.</p>
<p>A transferência máxima teórica de dados com todos os 65536 conjuntos de tags disponíveis, antes que a sessão tenha que ser descartada e substituída, é 64K * 108 MB ~= 6,9 TB.</p>
<h4 id="dh-ratchet-message-flow">DH RATCHET MESSAGE FLOW</h4>
<p>A próxima troca de chaves para um conjunto de tags deve ser iniciada pelo remetente dessas tags (o proprietário do conjunto de tags de saída). O receptor (proprietário do conjunto de tags de entrada) responderá. Para um tráfego HTTP GET típico na camada de aplicação, Bob enviará mais mensagens e fará o ratchet primeiro ao iniciar a troca de chaves; o diagrama abaixo mostra isso. Quando Alice faz o ratchet, a mesma coisa acontece em sentido inverso.</p>
<p>O primeiro conjunto de tags usado após o handshake NS/NSR é o conjunto de tags 0. Quando o conjunto de tags 0 está quase esgotado, novas chaves devem ser trocadas em ambas as direções para criar o conjunto de tags 1. Depois disso, uma nova chave é enviada apenas em uma direção.</p>
<p>Para criar o conjunto de tags 2, o remetente das tags envia uma nova chave e o receptor das tags envia o ID de sua chave antiga como confirmação. Ambos os lados fazem um DH.</p>
<p>Para criar o conjunto de tags 3, o remetente da tag envia o ID de sua chave antiga e solicita uma nova chave do destinatário da tag. Ambos os lados fazem um DH.</p>
<p>Os conjuntos de tags subsequentes são gerados como para os conjuntos de tags 2 e 3. O número do conjunto de tags é (1 + ID da chave do remetente + ID da chave do destinatário).</p>
<pre tabindex="0"><code>
Tag Sender                    Tag Receiver

                   ... use tag set #0 ...


  (Tagset #0 almost empty)
  (generate new key #0)

  Next Key, forward, request reverse, with key #0  --------&gt;
  (repeat until next key received)

                              (generate new key #0, do DH, create IB Tagset #1)

          &lt;-------------      Next Key, reverse, with key #0
                              (repeat until tag received on new tagset)

  (do DH, create OB Tagset #1)


                   ... use tag set #1 ...


  (Tagset #1 almost empty)
  (generate new key #1)

  Next Key, forward, with key #1        --------&gt;
  (repeat until next key received)

                              (reuse key #0, do DH, create IB Tagset #2)

          &lt;--------------     Next Key, reverse, id 0
                              (repeat until tag received on new tagset)

  (do DH, create OB Tagset #2)


                   ... use tag set #2 ...


  (Tagset #2 almost empty)
  (reuse key #1)

  Next Key, forward, request reverse, id 1  --------&gt;
  (repeat until next key received)

                              (generate new key #1, do DH, create IB Tagset #3)

          &lt;--------------     Next Key, reverse, with key #1

  (do DH, create OB Tagset #3)
  (reuse key #1, do DH, create IB Tagset #3)


                   ... use tag set #3 ...


       After tag set 3, repeat the above
       patterns as shown for tag sets 2 and 3.

       To create a new even-numbered tag set, the sender sends a new key
       to the receiver. The receiver sends his old key ID
       back as an acknowledgement.

       To create a new odd-numbered tag set, the sender sends a reverse request
       to the receiver. The receiver sends a new reverse key to the sender.
</code></pre><p>Após a conclusão do DH ratchet para um tagset de saída, e um novo tagset de saída ser criado, ele deve ser usado imediatamente, e o antigo tagset de saída pode ser excluído.</p>
<p>Depois que o DH ratchet estiver completo para um tagset de entrada, e um novo tagset de entrada for criado, o receptor deve escutar tags em ambos os tagsets, e deletar o tagset antigo após um tempo curto, cerca de 3 minutos.</p>
<p>Resumo da progressão do conjunto de tags e ID da chave está na tabela abaixo. * indica que uma nova chave é gerada.</p>
<table>
  <thead>
      <tr>
          <th>New Tag Set ID</th>
          <th>Sender key ID</th>
          <th>Rcvr key ID</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>n/a</td>
          <td>n/a</td>
      </tr>
      <tr>
          <td>1</td>
          <td>0 *</td>
          <td>0 *</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1 *</td>
          <td>0</td>
      </tr>
      <tr>
          <td>3</td>
          <td>1</td>
          <td>1 *</td>
      </tr>
      <tr>
          <td>4</td>
          <td>2 *</td>
          <td>1</td>
      </tr>
      <tr>
          <td>5</td>
          <td>2</td>
          <td>2 *</td>
      </tr>
      <tr>
          <td>&hellip;</td>
          <td>&hellip;</td>
          <td>&hellip;</td>
      </tr>
      <tr>
          <td>65534</td>
          <td>32767 *</td>
          <td>32766</td>
      </tr>
      <tr>
          <td>65535</td>
          <td>32767</td>
          <td>32767 *</td>
      </tr>
      <tr>
          <td>Os números de ID do conjunto de chaves e tags devem ser sequenciais.</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h4 id="dh-initialization-kdf">DH INITIALIZATION KDF</h4>
<p>Esta é a definição de DH_INITIALIZE(rootKey, k) para uma única direção. Ela cria um tagset e uma &ldquo;próxima chave raiz&rdquo; para ser usada em um ratchet DH subsequente, se necessário.</p>
<p>Usamos a inicialização DH em três lugares. Primeiro, a usamos para gerar um conjunto de tags para as New Session Replies. Segundo, a usamos para gerar dois conjuntos de tags, um para cada direção, para uso em mensagens Existing Session. Por último, a usamos após um DH Ratchet para gerar um novo conjunto de tags em uma única direção para mensagens Existing Session adicionais.</p>
<pre tabindex="0"><code>
Inputs:
  1) rootKey = chainKey from Payload Section
  2) k from the New Session KDF or split()

  // KDF_RK(rk, dh_out)
  keydata = HKDF(rootKey, k, &#34;KDFDHRatchetStep&#34;, 64)

  // Output 1: The next Root Key (KDF input for the next DH ratchet)
  nextRootKey = keydata[0:31]
  // Output 2: The chain key to initialize the new
  // session tag and symmetric key ratchets
  // for the tag set
  ck = keydata[32:63]

  // session tag and symmetric key chain keys
  keydata = HKDF(ck, ZEROLEN, &#34;TagAndKeyGenKeys&#34;, 64)
  sessTag_ck = keydata[0:31]
  symmKey_ck = keydata[32:63]
</code></pre><h4 id="dh-ratchet-kdf">DH RATCHET KDF</h4>
<p>Isto é usado após novas chaves DH serem trocadas em blocos NextKey, antes de um tagset ser esgotado.</p>
<pre tabindex="0"><code>

// Tag sender generates new X25519 ephemeral keys
  // and sends rapk to tag receiver in a NextKey block
  rask = GENERATE_PRIVATE()
  rapk = DERIVE_PUBLIC(rask)
  
  // Tag receiver generates new X25519 ephemeral keys
  // and sends rbpk to Tag sender in a NextKey block
  rbsk = GENERATE_PRIVATE()
  rbpk = DERIVE_PUBLIC(rbsk)

  sharedSecret = DH(rask, rbpk) = DH(rbsk, rapk)
  tagsetKey = HKDF(sharedSecret, ZEROLEN, &#34;XDHRatchetTagSet&#34;, 32)
  rootKey = nextRootKey // from previous tagset in this direction
  newTagSet = DH_INITIALIZE(rootKey, tagsetKey)
</code></pre><h3 id="números-de-mensagem">Números de Mensagem</h3>
<p>Ratchets para cada mensagem, como no Signal. O ratchet de tag de sessão é sincronizado com o ratchet de chave simétrica, mas o ratchet de chave do receptor pode &ldquo;ficar para trás&rdquo; para economizar memória.</p>
<p>O transmissor executa ratchet uma vez para cada mensagem transmitida. Nenhuma tag adicional deve ser armazenada. O transmissor também deve manter um contador para &lsquo;N&rsquo;, o número da mensagem da mensagem na cadeia atual. O valor &lsquo;N&rsquo; é incluído na mensagem enviada. Veja a definição do bloco Message Number.</p>
<p>O receptor deve avançar por ratchet pelo tamanho máximo da janela e armazenar as tags em um &ldquo;conjunto de tags&rdquo;, que está associado à sessão. Uma vez recebida, a tag armazenada pode ser descartada, e se não houver tags anteriores não recebidas, a janela pode ser avançada. O receptor deve manter o valor &lsquo;N&rsquo; associado a cada tag de sessão, e verificar se o número na mensagem enviada corresponde a este valor. Consulte a definição do bloco Message Number.</p>
<h4 id="kdf">KDF</h4>
<p>Esta é a definição de RATCHET_TAG().</p>
<pre tabindex="0"><code>
Inputs:
  1) Session Tag Chain key sessTag_ck
     First time: output from DH ratchet
     Subsequent times: output from previous session tag ratchet

  Generated:
  2) input_key_material = SESSTAG_CONSTANT
     Must be unique for this tag set (generated from chain key),
     so that the sequence isn&#39;t predictable, since session tags
     go out on the wire in plaintext.

  Outputs:
  1) N (the current session tag number)
  2) the session tag (and symmetric key, probably)
  3) the next Session Tag Chain Key (KDF input for the next session tag ratchet)

  Initialization:
  keydata = HKDF(sessTag_ck, ZEROLEN, &#34;STInitialization&#34;, 64)
  // Output 1: Next chain key
  sessTag_chainKey = keydata[0:31]
  // Output 2: The constant
  SESSTAG_CONSTANT = keydata[32:63]

  // KDF_ST(ck, constant)
  keydata_0 = HKDF(sessTag_chainkey, SESSTAG_CONSTANT, &#34;SessionTagKeyGen&#34;, 64)
  // Output 1: Next chain key
  sessTag_chainKey_0 = keydata_0[0:31]
  // Output 2: The session tag
  // or more if tag is longer than 8 bytes
  tag_0 = keydata_0[32:39]

  // repeat as necessary to get to tag_n
  keydata_n = HKDF(sessTag_chainKey_(n-1), SESSTAG_CONSTANT, &#34;SessionTagKeyGen&#34;, 64)
  // Output 1: Next chain key
  sessTag_chainKey_n = keydata_n[0:31]
  // Output 2: The session tag
  // or more if tag is longer than 8 bytes
  tag_n = keydata_n[32:39]
</code></pre><h3 id="implementação-de-exemplo">Implementação de Exemplo</h3>
<p>Ratchets para cada mensagem, como no Signal. Cada chave simétrica tem um número de mensagem associado e uma tag de sessão. O ratchet da chave de sessão é sincronizado com o ratchet da tag simétrica, mas o ratchet da chave do receptor pode &ldquo;ficar para trás&rdquo; para economizar memória.</p>
<p>Transmitter ratchets uma vez para cada mensagem transmitida. Nenhuma chave adicional precisa ser armazenada.</p>
<p>Quando o receptor recebe uma session tag, se ainda não tiver avançado o ratchet de chave simétrica até a chave associada, ele deve &ldquo;alcançar&rdquo; a chave associada. O receptor provavelmente armazenará em cache as chaves para quaisquer tags anteriores que ainda não foram recebidas. Uma vez recebidas, a chave armazenada pode ser descartada, e se não houver tags anteriores não recebidas, a janela pode ser avançada.</p>
<p>Para eficiência, os ratchets da session tag e da chave simétrica são separados, permitindo que o ratchet da session tag execute à frente do ratchet da chave simétrica. Isso também fornece segurança adicional, já que as session tags são transmitidas pela rede.</p>
<h4 id="kdf-1">KDF</h4>
<p>Esta é a definição de RATCHET_KEY().</p>
<pre tabindex="0"><code>
Inputs:
  1) Symmetric Key Chain key symmKey_ck
     First time: output from DH ratchet
     Subsequent times: output from previous symmetric key ratchet

  Generated:
  2) input_key_material = SYMMKEY_CONSTANT = ZEROLEN
     No need for uniqueness. Symmetric keys never go out on the wire.
     TODO: Set a constant anyway?

  Outputs:
  1) N (the current session key number)
  2) the session key
  3) the next Symmetric Key Chain Key (KDF input for the next symmetric key ratchet)

  // KDF_CK(ck, constant)
  SYMMKEY_CONSTANT = ZEROLEN
  // Output 1: Next chain key
  keydata_0 = HKDF(symmKey_ck, SYMMKEY_CONSTANT, &#34;SymmetricRatchet&#34;, 64)
  symmKey_chainKey_0 = keydata_0[0:31]
  // Output 2: The symmetric key
  k_0 = keydata_0[32:63]

  // repeat as necessary to get to k[n]
  keydata_n = HKDF(symmKey_chainKey_(n-1), SYMMKEY_CONSTANT, &#34;SymmetricRatchet&#34;, 64)
  // Output 1: Next chain key
  symmKey_chainKey_n = keydata_n[0:31]
  // Output 2: The symmetric key
  k_n = keydata_n[32:63]
</code></pre><h3 id="4a-dh-ratchet">4a) DH Ratchet</h3>
<p>Isso substitui o formato da seção AES definido na especificação ElGamal/AES+SessionTags.</p>
<p>Isto usa o mesmo formato de bloco conforme definido na especificação <a href="../../../pt/docs/specs/ntcp2/">NTCP2</a>
. Os tipos de blocos individuais são definidos de forma diferente.</p>
<p>Há preocupações de que encorajar implementadores a compartilhar código pode levar a problemas de parsing. Os implementadores devem considerar cuidadosamente os benefícios e riscos de compartilhar código, e garantir que as regras de ordenação e blocos válidos sejam diferentes para os dois contextos.</p>
<h3 id="payload-section-decrypted-data">Payload Section Decrypted data</h3>
<p>O comprimento criptografado é o restante dos dados. O comprimento descriptografado é 16 a menos que o comprimento criptografado. Todos os tipos de bloco são suportados. O conteúdo típico inclui os seguintes blocos:</p>
<table>
  <thead>
      <tr>
          <th>Payload Block Type</th>
          <th>Type Number</th>
          <th>Block Length</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>DateTime</td>
          <td>0</td>
          <td>7</td>
      </tr>
      <tr>
          <td>Termination (TBD)</td>
          <td>4</td>
          <td>9 typ.</td>
      </tr>
      <tr>
          <td>Options (TBD)</td>
          <td>5</td>
          <td>21+</td>
      </tr>
      <tr>
          <td>Message Number (TBD)</td>
          <td>6</td>
          <td>TBD</td>
      </tr>
      <tr>
          <td>Next Key</td>
          <td>7</td>
          <td>3 or 35</td>
      </tr>
      <tr>
          <td>ACK</td>
          <td>8</td>
          <td>4 typ.</td>
      </tr>
      <tr>
          <td>ACK Request</td>
          <td>9</td>
          <td>3</td>
      </tr>
      <tr>
          <td>Garlic Clove</td>
          <td>11</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Padding</td>
          <td>254</td>
          <td>varies</td>
      </tr>
  </tbody>
</table>
<h3 id="unencrypted-data">Unencrypted data</h3>
<p>Há zero ou mais blocos no frame criptografado. Cada bloco contém um identificador de um byte, um comprimento de dois bytes e zero ou mais bytes de dados.</p>
<p>Para extensibilidade, os receptores DEVEM ignorar blocos com números de tipo desconhecidos e tratá-los como preenchimento.</p>
<p>Os dados criptografados têm um máximo de 65535 bytes, incluindo um cabeçalho de autenticação de 16 bytes, portanto o máximo de dados não criptografados é de 65519 bytes.</p>
<p>(Tag de autenticação Poly1305 não mostrada):</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |blk |  size   |       data             |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |blk |  size   |       data             |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  ~               .   .   .               ~

  blk :: 1 byte
         0 datetime
         1-3 reserved
         4 termination
         5 options
         6 previous message number
         7 next session key
         8 ack
         9 ack request
         10 reserved
         11 Garlic Clove
         224-253 reserved for experimental features
         254 for padding
         255 reserved for future extension
  size :: 2 bytes, big endian, size of data to follow, 0 - 65516
  data :: the data

  Maximum ChaChaPoly frame is 65535 bytes.
  Poly1305 tag is 16 bytes
  Maximum total block size is 65519 bytes
  Maximum single block size is 65519 bytes
  Block type is 1 byte
  Block length is 2 bytes
  Maximum single block data size is 65516 bytes.
</code></pre><h3 id="block-ordering-rules">Block Ordering Rules</h3>
<p>Na mensagem New Session, o bloco DateTime é obrigatório e deve ser o primeiro bloco.</p>
<p>Outros blocos permitidos:</p>
<ul>
<li>Garlic Clove (tipo 11)</li>
<li>Opções (tipo 5)</li>
<li>Preenchimento (tipo 254)</li>
</ul>
<p>Na mensagem de Resposta de Nova Sessão, nenhum bloco é obrigatório.</p>
<p>Outros blocos permitidos:</p>
<ul>
<li>Garlic Clove (tipo 11)</li>
<li>Opções (tipo 5)</li>
<li>Preenchimento (tipo 254)</li>
</ul>
<p>Nenhum outro bloco é permitido. O padding, se presente, deve ser o último bloco.</p>
<p>Na mensagem Existing Session, nenhum bloco é obrigatório, e a ordem não é especificada, exceto pelos seguintes requisitos:</p>
<p>A terminação, se presente, deve ser o último bloco exceto pelo Padding. O Padding, se presente, deve ser o último bloco.</p>
<p>Pode haver múltiplos blocos Garlic Clove em um único frame. Pode haver até dois blocos Next Key em um único frame. Múltiplos blocos Padding não são permitidos em um único frame. Outros tipos de bloco provavelmente não terão múltiplos blocos em um único frame, mas isso não é proibido.</p>
<h3 id="datetime">DateTime</h3>
<p>Uma expiração. Auxilia na prevenção de respostas. Bob deve validar que a mensagem é recente, usando este timestamp. Bob deve implementar um filtro Bloom ou outro mecanismo para prevenir ataques de replay, se o tempo for válido. Geralmente incluído apenas em mensagens New Session.</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+
  | 0  |    4    |     timestamp     |
  +----+----+----+----+----+----+----+

  blk :: 0
  size :: 2 bytes, big endian, value = 4
  timestamp :: Unix timestamp, unsigned seconds.
               Wraps around in 2106
</code></pre><h3 id="4b-session-tag-ratchet">4b) Session Tag Ratchet</h3>
<p>Um único Garlic Clove descriptografado conforme especificado em <a href="../../../pt/docs/specs/i2np/">I2NP</a>
, com modificações para remover campos que não são utilizados ou são redundantes. Aviso: Este formato é significativamente diferente daquele para ElGamal/AES. Cada clove é um bloco de payload separado. Garlic Cloves não podem ser fragmentados entre blocos ou entre frames ChaChaPoly.</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  | 11 |  size   |                        |
  +----+----+----+                        +
  |      Delivery Instructions            |
  ~                                       ~
  ~                                       ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |type|  Message_ID       | Expiration   
  +----+----+----+----+----+----+----+----+
       |      I2NP Message body           |
  +----+                                  +
  ~                                       ~
  ~                                       ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  size :: size of all data to follow

  Delivery Instructions :: As specified in
         the Garlic Clove section of [I2NP](/docs/specs/i2np/).
         Length varies but is typically 1, 33, or 37 bytes

  type :: I2NP message type

  Message_ID :: 4 byte `Integer` I2NP message ID

  Expiration :: 4 bytes, seconds since the epoch
</code></pre><p>Notas:</p>
<ul>
<li>
<p>Os implementadores devem garantir que ao ler um bloco,
dados malformados ou maliciosos não causem leituras que
ultrapassem o próximo bloco.</p>
</li>
<li>
<p>O formato Clove Set especificado em <a href="../../../pt/docs/specs/i2np/">I2NP</a>
 não é usado.
Cada clove está contido em seu próprio bloco.</p>
</li>
<li>
<p>O cabeçalho da mensagem I2NP tem 9 bytes, com um formato idêntico
ao usado no <a href="../../../pt/docs/specs/ntcp2/">NTCP2</a>
.</p>
</li>
<li>
<p>O Certificate, Message ID e Expiration da
definição de Garlic Message em <a href="../../../pt/docs/specs/i2np/">I2NP</a>
 não estão incluídos.</p>
</li>
<li>
<p>O Certificate, Clove ID e Expiration da
definição Garlic Clove em <a href="../../../pt/docs/specs/i2np/">I2NP</a>
 não estão incluídos.</p>
</li>
</ul>
<p>Justificativa:</p>
<ul>
<li>Os certificados nunca foram usados.</li>
<li>O ID de mensagem separado e os IDs de clove nunca foram usados.</li>
<li>As expirações separadas nunca foram usadas.</li>
<li>A economia geral em comparação com os formatos antigos Clove Set e Clove
é de aproximadamente 35 bytes para 1 clove, 54 bytes para 2 cloves,
e 73 bytes para 3 cloves.</li>
<li>O formato de bloco é extensível e quaisquer novos campos podem ser adicionados
como novos tipos de bloco.</li>
</ul>
<h3 id="termination">Termination</h3>
<p>A implementação é opcional. Encerre a sessão. Este deve ser o último bloco não-padding no quadro. Nenhuma mensagem adicional será enviada nesta sessão.</p>
<p>Não permitido em NS ou NSR. Incluído apenas em mensagens de Sessão Existente.</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  | 4  |  size   | rsn|     addl data     |
  +----+----+----+----+                   +
  ~               .   .   .               ~
  +----+----+----+----+----+----+----+----+

  blk :: 4
  size :: 2 bytes, big endian, value = 1 or more
  rsn :: reason, 1 byte:
         0: normal close or unspecified
         1: termination received
         others: optional, impementation-specific
  addl data :: optional, 0 or more bytes, for future expansion, debugging,
               or reason text.
               Format unspecified and may vary based on reason code.
</code></pre><h3 id="4c-ratchet-de-chave-simétrica">4c) Ratchet de Chave Simétrica</h3>
<p>NÃO IMPLEMENTADO, para estudo adicional. Passar opções atualizadas. As opções incluem vários parâmetros para a sessão. Consulte a seção Análise do Comprimento da Tag de Sessão abaixo para mais informações.</p>
<p>O bloco de opções pode ter comprimento variável, pois more_options pode estar presente.</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  | 5  |  size   |ver |flg |STL |STimeout |
  +----+----+----+----+----+----+----+----+
  |  SOTW   |  RITW   |tmin|tmax|rmin|rmax|
  +----+----+----+----+----+----+----+----+
  |  tdmy   |  rdmy   |  tdelay |  rdelay |
  +----+----+----+----+----+----+----+----+
  |              more_options             |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 5
  size :: 2 bytes, big endian, size of options to follow, 21 bytes minimum
  ver :: Protocol version, must be 0
  flg :: 1 byte flags
         bits 7-0: Unused, set to 0 for future compatibility
  STL :: Session tag length (must be 8), other values unimplemented
  STimeout :: Session idle timeout (seconds), big endian
  SOTW :: Sender Outbound Tag Window, 2 bytes big endian
  RITW :: Receiver Inbound Tag Window 2 bytes big endian

  tmin, tmax, rmin, rmax :: requested padding limits
      tmin and rmin are for desired resistance to traffic analysis.
      tmax and rmax are for bandwidth limits.
      tmin and tmax are the transmit limits for the router sending this options block.
      rmin and rmax are the receive limits for the router sending this options block.
      Each is a 4.4 fixed-point float representing 0 to 15.9375
      (or think of it as an unsigned 8-bit integer divided by 16.0).
      This is the ratio of padding to data. Examples:
      Value of 0x00 means no padding
      Value of 0x01 means add 6 percent padding
      Value of 0x10 means add 100 percent padding
      Value of 0x80 means add 800 percent (8x) padding
      Alice and Bob will negotiate the minimum and maximum in each direction.
      These are guidelines, there is no enforcement.
      Sender should honor receiver&#39;s maximum.
      Sender may or may not honor receiver&#39;s minimum, within bandwidth constraints.

  tdmy: Max dummy traffic willing to send, 2 bytes big endian, bytes/sec average
  rdmy: Requested dummy traffic, 2 bytes big endian, bytes/sec average
  tdelay: Max intra-message delay willing to insert, 2 bytes big endian, msec average
  rdelay: Requested intra-message delay, 2 bytes big endian, msec average

  more_options :: Format undefined, for future use
</code></pre><p>SOTW é a recomendação do remetente para o destinatário sobre a janela de tag de entrada do destinatário (o lookahead máximo). RITW é a declaração do remetente da janela de tag de entrada (lookahead máximo) que ele planeja usar. Cada lado então define ou ajusta o lookahead com base em algum mínimo ou máximo ou outro cálculo.</p>
<p>Notas:</p>
<ul>
<li>O suporte para comprimento de tag de sessão não padrão
esperamos que nunca seja necessário.</li>
<li>A janela de tag é MAX_SKIP na documentação do Signal.</li>
</ul>
<p>Problemas:</p>
<ul>
<li>A negociação de opções está por definir (TBD).</li>
<li>Padrões por definir (TBD).</li>
<li>As opções de padding e atraso são copiadas do NTCP2,
mas essas opções não foram totalmente implementadas ou estudadas lá.</li>
</ul>
<h3 id="message-numbers">Message Numbers</h3>
<p>A implementação é opcional. O comprimento (número de mensagens enviadas) no conjunto de tags anterior (PN). O receptor pode imediatamente deletar tags maiores que PN do conjunto de tags anterior. O receptor pode expirar tags menores ou iguais a PN do conjunto de tags anterior após um curto período de tempo (ex.: 2 minutos).</p>
<pre tabindex="0"><code>
+----+----+----+----+----+
  | 6  |  size   |  PN    |
 +----+----+----+----+----+

  blk :: 6
  size :: 2
  PN :: 2 bytes big endian. The index of the last tag sent in the previous tag set.
</code></pre><p>Notas:</p>
<ul>
<li>O PN máximo é 65535.</li>
<li>As definições de PN são iguais à definição do Signal, menos uma.
Isso é similar ao que o Signal faz, mas no Signal, PN e N estão no cabeçalho.
Aqui, eles estão no corpo da mensagem criptografada.</li>
<li>Não envie este bloco no conjunto de tags 0, pois não havia conjunto de tags anterior.</li>
</ul>
<h3 id="5-payload">5) Payload</h3>
<p>A próxima chave DH ratchet está no payload, e é opcional. Não fazemos ratchet toda vez. (Isso é diferente do Signal, onde ela está no cabeçalho e é enviada toda vez)</p>
<p>Para o primeiro ratchet, Key ID = 0.</p>
<p>Não permitido em NS ou NSR. Incluído apenas em mensagens de Sessão Existente.</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  | 7  |  size   |flag|  key ID |         |
  +----+----+----+----+----+----+         +
  |                                       |
  +                                       +
  |     Next DH Ratchet Public Key        |
  +                                       +
  |                                       |
  +                             +----+----+
  |                             |
  +----+----+----+----+----+----+

  blk :: 7
  size :: 3 or 35
  flag :: 1 byte flags
          bit order: 76543210
          bit 0: 1 for key present, 0 for no key present
          bit 1: 1 for reverse key, 0 for forward key
          bit 2: 1 to request reverse key, 0 for no request
                 only set if bit 1 is 0
          bits 7-2: Unused, set to 0 for future compatibility
  key ID :: The key ID of this key. 2 bytes, big endian
            0 - 32767
  Public Key :: The next X25519 public key, 32 bytes, little endian
                Only if bit 0 is 1
</code></pre><p>Notas:</p>
<ul>
<li>O Key ID é um contador incremental para a chave local usada para esse conjunto de tags, começando em 0.</li>
<li>O ID não deve mudar a menos que a chave mude.</li>
<li>Pode não ser estritamente necessário, mas é útil para debugging.
O Signal não usa um key ID.</li>
<li>O Key ID máximo é 32767.</li>
<li>No caso raro em que os conjuntos de tags em ambas as direções estão fazendo ratcheting ao
mesmo tempo, um frame conterá dois blocos Next Key, um para
a chave forward e um para a chave reverse.</li>
<li>Os números de ID de conjuntos de chaves e tags devem ser sequenciais.</li>
<li>Veja a seção DH Ratchet acima para detalhes.</li>
</ul>
<h3 id="seção-de-payload-dados-descriptografados">Seção de Payload Dados descriptografados</h3>
<p>Isso só é enviado se um bloco de solicitação de confirmação foi recebido. Várias confirmações podem estar presentes para confirmar múltiplas mensagens.</p>
<p>Não permitido em NS ou NSR. Incluído apenas em mensagens de Sessão Existente.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 8  |  size   |tagsetid |   N     |    |
  +----+----+----+----+----+----+----+    +
  |             more acks                 |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 8
  size :: 4 * number of acks to follow, minimum 1 ack
  for each ack:
  tagsetid :: 2 bytes, big endian, from the message being acked
  N :: 2 bytes, big endian, from the message being acked
</code></pre><p>Notas:</p>
<ul>
<li>O ID do conjunto de tags e N identificam unicamente a mensagem sendo confirmada.</li>
<li>Nos primeiros conjuntos de tags usados para uma sessão em cada direção, o ID do conjunto de tags é 0.</li>
<li>Nenhum bloco NextKey foi enviado, então não há IDs de chave.</li>
<li>Para todos os conjuntos de tags usados após trocas NextKey, o número do conjunto de tags é (1 + ID da chave da Alice + ID da chave do Bob).</li>
</ul>
<h3 id="dados-não-criptografados">Dados não criptografados</h3>
<p>Solicitar um ack in-band. Para substituir a Mensagem DeliveryStatus out-of-band no Garlic Clove.</p>
<p>Se um ack explícito for solicitado, o ID do tagset atual e o número da mensagem (N) são retornados em um bloco de ack.</p>
<p>Não permitido em NS ou NSR. Incluído apenas em mensagens de Sessão Existente.</p>
<pre tabindex="0"><code>
+----+----+----+----+
  |  9 |  size   |flg |
  +----+----+----+----+

  blk :: 9
  size :: 1
  flg :: 1 byte flags
         bits 7-0: Unused, set to 0 for future compatibility
</code></pre><h3 id="regras-de-ordenação-de-blocos">Regras de Ordenação de Blocos</h3>
<p>Todo o padding está dentro dos frames AEAD. TODO O padding dentro do AEAD deve aderir aproximadamente aos parâmetros negociados. TODO Alice enviou seus parâmetros tx/rx min/max solicitados na mensagem NS. TODO Bob enviou seus parâmetros tx/rx min/max solicitados na mensagem NSR. Opções atualizadas podem ser enviadas durante a fase de dados. Veja as informações do bloco de opções acima.</p>
<p>Se presente, este deve ser o último bloco no quadro.</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |254 |  size   |      padding           |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 254
  size :: 2 bytes, big endian, 0-65516
  padding :: zeros or random data
</code></pre><p>Notas:</p>
<ul>
<li>O preenchimento com zeros é aceitável, pois será criptografado.</li>
<li>Estratégias de preenchimento a serem definidas.</li>
<li>Frames apenas de preenchimento são permitidos.</li>
<li>O padrão de preenchimento é 0-15 bytes.</li>
<li>Consulte o bloco de opções para negociação do parâmetro de preenchimento</li>
<li>Consulte o bloco de opções para parâmetros mínimo/máximo de preenchimento</li>
<li>A resposta do router à violação do preenchimento negociado depende da implementação.</li>
</ul>
<h3 id="datetime-1">DateTime</h3>
<p>As implementações devem ignorar tipos de bloco desconhecidos para compatibilidade futura.</p>
<h3 id="dente-de-garlic">Dente de Garlic</h3>
<ul>
<li>O comprimento do preenchimento deve ser decidido por mensagem com base em estimativas da distribuição de comprimento, ou atrasos aleatórios devem ser adicionados. Essas contramedidas devem ser incluídas para resistir à DPI, pois os tamanhos das mensagens revelariam que o tráfego I2P está sendo transportado pelo protocolo de transporte. O esquema exato de preenchimento é uma área de trabalho futuro, o Apêndice A fornece mais informações sobre o tópico.</li>
</ul>
<h2 id="typical-usage-patterns">Typical Usage Patterns</h2>
<h3 id="terminação">Terminação</h3>
<p>Este é o caso de uso mais típico, e a maioria dos casos de uso de streaming não-HTTP será idêntica a este caso de uso também. Uma pequena mensagem inicial é enviada, uma resposta segue, e mensagens adicionais são enviadas em ambas as direções.</p>
<p>Um HTTP GET geralmente cabe em uma única mensagem I2NP. Alice envia uma pequena requisição com uma única mensagem de Session nova, incluindo um reply leaseset. Alice inclui ratchet imediato para nova chave. Inclui sig para vincular ao destino. Nenhum ack solicitado.</p>
<p>Bob executa o ratchet imediatamente.</p>
<p>Alice faz o ratchet imediatamente.</p>
<p>Continua com essas sessões.</p>
<pre tabindex="0"><code>
Alice                           Bob

  New Session (1b)     -------------------&gt;
  with ephemeral key 1
  with static key for binding
  with next key
  with bundled HTTP GET
  with bundled LS
  without bundled Delivery Status Message

  any retransmissions, same as above

  following messages may arrive in any order:

  &lt;--------------     New Session Reply (1g)
                      with Bob ephemeral key 1
                      with bundled HTTP reply part 1

  &lt;--------------     New Session Reply (1g)
                      with Bob ephemeral key 2
                      with bundled HTTP reply part 2

  &lt;--------------     New Session Reply (1g)
                      with Bob ephemeral key 3
                      with bundled HTTP reply part 3

  After reception of any of these messages,
  Alice switches to use Existing Session messages,
  creates a new inbound + outbound session pair,
  and ratchets.


  Existing Session     -------------------&gt;
  with bundled streaming ack


  Existing Session     -------------------&gt;
  with bundled streaming ack


  After reception of any of these messages,
  Bob switches to use Existing Session messages.


  &lt;--------------     Existing Session
                      with bundled HTTP reply part 4


  Existing Session     -------------------&gt;
  with bundled streaming ack

  &lt;--------------     Existing Session
                      with bundled HTTP reply part 5
</code></pre><h3 id="opções">Opções</h3>
<p>Alice tem três opções:</p>
<ol>
<li>
<p>Enviar apenas a primeira mensagem (tamanho da janela = 1), como no HTTP GET. Não recomendado.</p>
</li>
<li>
<p>Enviar até a janela de streaming, mas usando a mesma chave pública em texto claro codificada com Elligator2. Todas as mensagens contêm a mesma próxima chave pública (ratchet). Isso será visível para OBGW/IBEP porque todas começam com o mesmo texto claro. As coisas prosseguem como em 1). Não recomendado.</p>
</li>
<li>
<p>Implementação recomendada. Enviar até a janela de streaming, mas usando uma chave pública de texto claro codificada em Elligator2 diferente (sessão) para cada uma. Todas as mensagens contêm a mesma próxima chave pública (ratchet). Isso não será visível para OBGW/IBEP porque todas começam com texto claro diferente. Bob deve reconhecer que todas contêm a mesma próxima chave pública, e responder a todas com o mesmo ratchet. Alice usa essa próxima chave pública e continua.</p>
</li>
</ol>
<p>Fluxo de mensagens da Opção 3:</p>
<pre tabindex="0"><code>
Alice                           Bob

  New Session (1b)     -------------------&gt;
  with ephemeral key 1
  with static key for binding
  with bundled HTTP POST part 1
  with bundled LS
  without bundled Delivery Status Message


  New Session (1b)     -------------------&gt;
  with ephemeral key 2
  with static key for binding
  with bundled HTTP POST part 2
  with bundled LS
  without bundled Delivery Status Message


  New Session (1b)     -------------------&gt;
  with ephemeral key 3
  with static key for binding
  with bundled HTTP POST part 3
  with bundled LS
  without bundled Delivery Status Message


  following messages can arrive in any order:

  &lt;--------------     New Session Reply (1g)
                      with Bob ephemeral key 1
                      with bundled streaming ack

  &lt;--------------     New Session Reply (1g)
                      with Bob ephemeral key 2
                      with bundled streaming ack

  After reception of any of these messages,
  Alice switches to use Existing Session messages,
  creates a new inbound + outbound session pair,
  and ratchets.


  following messages can arrive in any order:


  Existing Session     -------------------&gt;
  with bundled HTTP POST part 4

  Existing Session     -------------------&gt;
  with next key
  with bundled HTTP POST part 5


  After reception of any of these messages,
  Bob switches to use Existing Session messages.


  &lt;--------------     Existing Session
                      with bundled streaming ack

  After reception of any of this message,
  Alice switches to use Existing Session messages,
  and Alice ratchets.


  Existing Session     -------------------&gt;
  with next key
  with bundled HTTP POST part 4

  after reception of this message, Bob ratchets

  Existing Session     -------------------&gt;
  with next key
  with bundled HTTP POST part 5

  &lt;--------------     Existing Session
                      with bundled streaming ack
</code></pre><h3 id="números-de-mensagem-1">Números de Mensagem</h3>
<p>Uma única mensagem, com uma única resposta esperada. Mensagens ou respostas adicionais podem ser enviadas.</p>
<p>Semelhante ao HTTP GET, mas com opções menores para o tamanho da janela de tag de sessão e tempo de vida. Talvez não solicite um ratchet.</p>
<pre tabindex="0"><code>
Alice                           Bob

  New Session (1b)     -------------------&gt;
  with static key for binding
  with next key
  with bundled repliable datagram
  with bundled LS
  without bundled Delivery Status Message


  &lt;--------------     New Session Reply (1g)
                      with Bob ephemeral key
                      with bundled reply part 1

  &lt;--------------     New Session Reply (1g)
                      with Bob ephemeral key
                      with bundled reply part 2

  After reception of either message,
  Alice switches to use Existing Session messages,
  and ratchets.

  If the Existing Session message arrives first,
  Alice ratchets on the existing inbound and outbound
  sessions.

  When the New Session Reply arrives, Alice
  sets the existing inbound session to expire,
  creates a new inbound and outbound session,
  and sends Existing Session messages on
  the new outbound session.

  Alice keeps the expiring inbound session
  around for a while to process the Existing Session
  message sent to Alice.
  If all expected original Existing Session message replies
  have been processed, Alice can expire the original
  inbound session immediately.

  if there are any other messages:

  Existing Session     -------------------&gt;
  with bundled message

  Existing Session     -------------------&gt;
  with bundled streaming ack

  &lt;--------------     Existing Session
                      with bundled message
</code></pre><h3 id="próxima-chave-pública-dh-ratchet">Próxima Chave Pública DH Ratchet</h3>
<p>Múltiplas mensagens anônimas, sem respostas esperadas.</p>
<p>Neste cenário, Alice solicita uma sessão, mas sem vinculação. Uma nova mensagem de sessão é enviada. Nenhum leaseSet de resposta é agrupado. Um DSM de resposta é agrupado (este é o único caso de uso que requer DSMs agrupados). Nenhuma próxima chave é incluída. Nenhuma resposta ou ratchet é solicitado. Nenhum ratchet é enviado. As opções definem a janela de session tags como zero.</p>
<pre tabindex="0"><code>
Alice                           Bob

  New Session (1c)     -------------------&gt;
  with bundled message
  without bundled LS
  with bundled Delivery Status Message 1

  New Session (1c)     -------------------&gt;
  with bundled message
  without bundled LS
  with bundled Delivery Status Message 2

  New Session (1c)     -------------------&gt;
  with bundled message
  without bundled LS
  with bundled Delivery Status Message 3
 
  following messages can arrive in any order:

  &lt;--------------     Delivery Status Message 1

  &lt;--------------     Delivery Status Message 2

  &lt;--------------     Delivery Status Message 3

  After reception of any of these messages,
  Alice switches to use Existing Session messages.

  Existing Session     -------------------&gt;

  Existing Session     -------------------&gt;

  Existing Session     -------------------&gt;
</code></pre><h3 id="confirmação">Confirmação</h3>
<p>Uma única mensagem anônima, sem resposta esperada.</p>
<p>Uma mensagem única é enviada. Nenhum LS de resposta ou DSM são incluídos. Nenhuma próxima chave é incluída. Nenhuma resposta ou ratchet é solicitado. Nenhum ratchet é enviado. As opções definem a janela de session tags como zero.</p>
<pre tabindex="0"><code>
Alice                           Bob

  One-Time Message (1d)   -------------------&gt;
  with bundled message
  without bundled LS
  without bundled Delivery Status Message
</code></pre><h3 id="solicitação-de-ack">Solicitação de Ack</h3>
<p>Sessões de longa duração podem executar ratchet, ou solicitar um ratchet, a qualquer momento, para manter o sigilo futuro a partir desse ponto no tempo. As sessões devem executar ratchet à medida que se aproximam do limite de mensagens enviadas por sessão (65535).</p>
<h2 id="implementation-considerations">Implementation Considerations</h2>
<h3 id="preenchimento">Preenchimento</h3>
<p>Assim como no protocolo ElGamal/AES+SessionTag existente, as implementações devem limitar o armazenamento de session tags e proteger contra ataques de esgotamento de memória.</p>
<p>Algumas estratégias recomendadas incluem:</p>
<ul>
<li>Limite rígido no número de tags de sessão armazenadas</li>
<li>Expiração agressiva de sessões inbound inativas quando sob pressão de memória</li>
<li>Limite no número de sessões inbound vinculadas a um único destino remoto</li>
<li>Redução adaptativa da janela de tags de sessão e exclusão de tags antigas não utilizadas
quando sob pressão de memória</li>
<li>Recusa em fazer ratchet quando solicitado, se sob pressão de memória</li>
</ul>
<h3 id="outros-tipos-de-blocos">Outros tipos de blocos</h3>
<p>Parâmetros recomendados e timeouts:</p>
<ul>
<li>Tamanho do tagset NSR: 12 tsmin e tsmax</li>
<li>Tamanho do tagset ES 0: tsmin 24, tsmax 160</li>
<li>Tamanho do tagset ES (1+): 160 tsmin e tsmax</li>
<li>Timeout do tagset NSR: 3 minutos para o receptor</li>
<li>Timeout do tagset ES: 8 minutos para o remetente, 10 minutos para o receptor</li>
<li>Remover tagset ES anterior após: 3 minutos</li>
<li>Antecipação do tagset da tag N: min(tsmax, tsmin + N/4)</li>
<li>Corte do tagset atrás da tag N: min(tsmax, tsmin + N/4) / 2</li>
<li>Enviar próxima chave na tag: TBD</li>
<li>Enviar próxima chave após tempo de vida do tagset: TBD</li>
<li>Substituir sessão se NS recebido após: 3 minutos</li>
<li>Desvio máximo do relógio: -5 minutos a +2 minutos</li>
<li>Duração do filtro de replay NS: 5 minutos</li>
<li>Tamanho do padding: 0-15 bytes (outras estratégias TBD)</li>
</ul>
<h3 id="trabalho-futuro">Trabalho futuro</h3>
<p>Seguem as recomendações para classificar mensagens recebidas.</p>
<h3 id="x25519-only">X25519 Only</h3>
<p>Num túnel que é usado exclusivamente com este protocolo, faça a identificação como é feito atualmente com ElGamal/AES+SessionTags:</p>
<p>Primeiro, trate os dados iniciais como uma session tag e procure a session tag. Se encontrada, descriptografe usando os dados armazenados associados a essa session tag.</p>
<p>Se não encontrado, trate os dados iniciais como uma chave pública DH e nonce. Execute uma operação DH e o KDF especificado, e tente descriptografar os dados restantes.</p>
<h3 id="http-get">HTTP GET</h3>
<p>Em um túnel que suporta tanto este protocolo quanto ElGamal/AES+SessionTags, classifique as mensagens recebidas da seguinte forma:</p>
<p>Devido a uma falha na especificação ElGamal/AES+SessionTags, o bloco AES não é preenchido com um comprimento aleatório não-mod-16. Portanto, o comprimento das mensagens Existing Session mod 16 é sempre 0, e o comprimento das mensagens New Session mod 16 é sempre 2 (já que o bloco ElGamal tem 514 bytes de comprimento).</p>
<p>Se o comprimento mod 16 não for 0 ou 2, trate os dados iniciais como uma session tag, e procure pela session tag. Se encontrada, descriptografe usando os dados armazenados associados a essa session tag.</p>
<p>Se não encontrado, e o comprimento mod 16 não for 0 ou 2, trate os dados iniciais como uma chave pública DH e nonce. Execute uma operação DH e o KDF especificado, e tente descriptografar os dados restantes. (baseado na mistura relativa de tráfego, e nos custos relativos das operações DH X25519 e ElGamal, este passo pode ser feito por último)</p>
<p>Caso contrário, se o comprimento mod 16 for 0, trate os dados iniciais como uma session tag ElGamal/AES, e procure pela session tag. Se encontrada, descriptografe usando os dados armazenados associados àquela session tag.</p>
<p>Se não for encontrado, e os dados tiverem pelo menos 642 (514 + 128) bytes de comprimento, e o comprimento mod 16 for 2, trate os dados iniciais como um bloco ElGamal. Tente descriptografar os dados restantes.</p>
<p>Note que se a especificação ElGamal/AES+SessionTag for atualizada para permitir padding não-mod-16, as coisas precisarão ser feitas de forma diferente.</p>
<h3 id="http-post">HTTP POST</h3>
<p>As implementações iniciais dependem de tráfego bidirecional nas camadas superiores. Ou seja, as implementações assumem que o tráfego na direção oposta será transmitido em breve, o que forçará qualquer resposta necessária na camada ECIES.</p>
<p>No entanto, certo tráfego pode ser unidirecional ou de largura de banda muito baixa, de modo que não há tráfego de camada superior para gerar uma resposta oportuna.</p>
<p>O recebimento de mensagens NS e NSR requer uma resposta; o recebimento de blocos ACK Request e Next Key também requer uma resposta.</p>
<p>Uma implementação sofisticada pode iniciar um temporizador quando uma dessas mensagens é recebida e requer uma resposta, e gerar uma resposta &ldquo;vazia&rdquo; (sem bloco Garlic Clove) na camada ECIES se nenhum tráfego reverso for enviado em um período curto de tempo (por exemplo, 1 segundo).</p>
<p>Também pode ser apropriado usar um timeout ainda mais curto para respostas a mensagens NS e NSR, para direcionar o tráfego para as eficientes mensagens ES o mais rápido possível.</p>
<h2 id="analysis">Analysis</h2>
<h3 id="datagrama-replicável">Datagrama Replicável</h3>
<p>A sobrecarga de mensagem para as duas primeiras mensagens em cada direção é a seguinte. Isto assume apenas uma mensagem em cada direção antes do ACK, ou que quaisquer mensagens adicionais sejam enviadas especulativamente como mensagens de Sessão Existente. Se não houver ACKs especulativos de session tags entregues, a sobrecarga do protocolo antigo é muito maior.</p>
<p>Nenhum preenchimento é assumido para análise do novo protocolo. Nenhum leaseSet agrupado é assumido.</p>
<h3 id="múltiplos-datagramas-raw">Múltiplos Datagramas Raw</h3>
<p>Nova mensagem de sessão, igual para cada direção:</p>
<pre tabindex="0"><code>
ElGamal block:
  514 bytes

  AES block:
  - 2 byte tag count
  - 1024 bytes of tags (32 typical)
  - 4 byte payload size
  - 32 byte hash of payload
  - 1 byte flags
  - 1 byte clove count
  - 33 byte Garlic deliv. inst.
  - 16 byte I2NP header
  - 15 byte clove cert, id, exp.
  - 15 byte msg cert, id, exp.
  - 0 byte padding assuming 1936 byte message
  1143 total

  Total:
  1657 bytes
</code></pre><p>Mensagens de sessão existentes, iguais em cada direção:</p>
<pre tabindex="0"><code>
AES block:
  - 32 byte session tag
  - 2 byte tag count
  - 4 byte payload size
  - 32 byte hash of payload
  - 1 byte flags
  - 1 byte clove count
  - 33 byte Garlic deliv. inst.
  - 16 byte I2NP header
  - 15 byte msg cert, id, exp.
  - 15 byte clove cert, id, exp.
  - 0 byte padding assuming 1936 byte message
  151 total
</code></pre><pre tabindex="0"><code>Four message total (two each direction)
  3616 bytes overhead
</code></pre><h3 id="datagrama-bruto-único">Datagrama Bruto Único</h3>
<p>Mensagem de Nova Sessão Alice-para-Bob:</p>
<pre tabindex="0"><code>
- 32 byte ephemeral public key
  - 32 byte static public key
  - 16 byte Poly1305 MAC
  - 7 byte DateTime block
  - 3 byte Garlic block overhead
  - 9 byte I2NP header
  - 33 byte Garlic deliv. inst.
  - 16 byte Poly1305 MAC

  Total:
  148 bytes overhead
</code></pre><p>Mensagem de Resposta de Nova Sessão de Bob-para-Alice:</p>
<pre tabindex="0"><code>
- 8 byte session tag
  - 32 byte ephemeral public key
  - 16 byte Poly1305 MAC
  - 3 byte Garlic block overhead
  - 9 byte I2NP header
  - 33 byte Garlic deliv. inst.
  - 16 byte Poly1305 MAC

  Total:
  117 bytes overhead
</code></pre><p>Mensagens de sessão existentes, mesma em cada direção:</p>
<pre tabindex="0"><code>
- 8 byte session tag
  - 3 byte Garlic block overhead
  - 9 byte I2NP header
  - 33 byte Garlic deliv. inst.
  - 16 byte Poly1305 MAC

  Total:
  69 bytes
</code></pre><h3 id="sessões-de-longa-duração">Sessões de Longa Duração</h3>
<p>Quatro mensagens no total (duas em cada direção):</p>
<pre tabindex="0"><code>
372 bytes
  90% (approx. 10x) reduction compared to ElGamal/AES+SessionTags
</code></pre><p>Apenas handshake:</p>
<pre tabindex="0"><code>
ElGamal: 1657 + 1657 = 3314 bytes
  Ratchet: 148 _ 117 = 265 bytes
  92% (approx. 12x) reduction compared to ElGamal/AES+SessionTags
</code></pre><p>Total a longo prazo (ignorando handshakes):</p>
<pre tabindex="0"><code>ElGamal: 151 + 32 byte tag sent previously = 183 bytes
  Ratchet: 69 bytes
  64% (approx. 3x) reduction compared to ElGamal/AES+SessionTags
</code></pre><h3 id="cpu">CPU</h3>
<p>TODO atualizar esta seção após a proposta estar estável.</p>
<p>As seguintes operações criptográficas são necessárias para cada parte trocar mensagens New Session e New Session Reply:</p>
<ul>
<li>HMAC-SHA256: 3 por HKDF, total TBD</li>
<li>ChaChaPoly: 2 cada</li>
<li>Geração de chave X25519: 2 Alice, 1 Bob</li>
<li>X25519 DH: 3 cada</li>
<li>Verificação de assinatura: 1 (Bob)</li>
</ul>
<p>Alice calcula 5 ECDHs por sessão vinculada (mínimo), 2 para cada mensagem NS para Bob, e 3 para cada uma das mensagens NSR de Bob.</p>
<p>Bob também calcula 6 ECDHs por sessão vinculada, 3 para cada uma das mensagens NS de Alice, e 3 para cada uma de suas mensagens NSR.</p>
<p>As seguintes operações criptográficas são requeridas por cada parte para cada mensagem de Sessão Existente:</p>
<ul>
<li>HKDF: 2</li>
<li>ChaChaPoly: 1</li>
</ul>
<h3 id="defesa">Defesa</h3>
<p>O comprimento atual da tag de sessão é de 32 bytes. Ainda não encontramos nenhuma justificativa para esse comprimento, mas continuamos pesquisando os arquivos. A proposta acima define o novo comprimento da tag como 8 bytes. A análise que justifica uma tag de 8 bytes é a seguinte:</p>
<p>O ratchet de session tag é assumido como gerador de tags aleatórias, uniformemente distribuídas. Não há razão criptográfica para um comprimento específico de session tag. O ratchet de session tag é sincronizado com, mas gera uma saída independente do, ratchet de chave simétrica. As saídas dos dois ratchets podem ter comprimentos diferentes.</p>
<p>Portanto, a única preocupação é a colisão de tags de sessão. Presume-se que as implementações não tentarão lidar com colisões tentando descriptografar com ambas as sessões; as implementações simplesmente associarão a tag com a sessão anterior ou nova, e qualquer mensagem recebida com essa tag na outra sessão será descartada após a falha na descriptografia.</p>
<p>O objetivo é selecionar um comprimento de session tag que seja grande o suficiente para minimizar o risco de colisões, mas pequeno o suficiente para minimizar o uso de memória.</p>
<p>Isso assume que as implementações limitam o armazenamento de session tags para prevenir ataques de exaustão de memória. Isso também reduzirá drasticamente as chances de um atacante criar colisões. Veja a seção Considerações de Implementação abaixo.</p>
<p>Para um caso pior, assuma um servidor movimentado com 64 novas sessões de entrada por segundo. Assuma um tempo de vida de session tag de entrada de 15 minutos (igual ao atual, provavelmente deveria ser reduzido). Assuma uma janela de session tag de entrada de 32. 64 * 15 * 60 * 32 = 1.843.200 tags O máximo atual de tags de entrada do Java I2P é 750.000 e nunca foi atingido pelo que sabemos.</p>
<p>Uma meta de 1 em um milhão (1e-6) de colisões de session tag provavelmente é suficiente. A probabilidade de descartar uma mensagem ao longo do caminho devido ao congestionamento é muito maior que isso.</p>
<p>Ref: <a href="https://en.wikipedia.org/wiki/Birthday_paradox">https://en.wikipedia.org/wiki/Birthday_paradox</a>
 Seção da tabela de probabilidades.</p>
<p>Com session tags de 32 bytes (256 bits), o espaço de session tag é 1.2e77. A probabilidade de uma colisão com probabilidade 1e-18 requer 4.8e29 entradas. A probabilidade de uma colisão com probabilidade 1e-6 requer 4.8e35 entradas. 1,8 milhão de tags de 32 bytes cada é cerca de 59 MB no total.</p>
<p>Com session tags de 16 bytes (128 bits), o espaço de session tags é de 3,4e38. A probabilidade de uma colisão com probabilidade 1e-18 requer 2,6e10 entradas. A probabilidade de uma colisão com probabilidade 1e-6 requer 2,6e16 entradas. 1,8 milhão de tags de 16 bytes cada uma totaliza cerca de 30 MB.</p>
<p>Com session tags de 8 bytes (64 bits), o espaço de session tags é 1,8e19. A probabilidade de uma colisão com probabilidade 1e-18 requer 6,1 entradas. A probabilidade de uma colisão com probabilidade 1e-6 requer 6,1e6 (6.100.000) entradas. 1,8 milhão de tags de 8 bytes cada uma totaliza cerca de 15 MB.</p>
<p>6,1 milhões de tags ativas é mais de 3x superior à nossa estimativa do pior caso de 1,8 milhões de tags. Portanto, a probabilidade de colisão seria inferior a uma em um milhão. Concluímos, portanto, que session tags de 8 bytes são suficientes. Isso resulta em uma redução de 4x do espaço de armazenamento, além da redução de 2x porque as tags de transmissão não são armazenadas. Assim, teremos uma redução de 8x no uso de memória de session tags comparado ao ElGamal/AES+SessionTags.</p>
<p>Para manter flexibilidade caso essas suposições estejam erradas, incluiremos um campo de comprimento de session tag nas opções, para que o comprimento padrão possa ser substituído por sessão. Não esperamos implementar negociação dinâmica de comprimento de tag a menos que seja absolutamente necessário.</p>
<p>As implementações devem, no mínimo, reconhecer colisões de session tag, tratá-las de forma elegante, e registrar ou contar o número de colisões. Embora ainda extremamente improváveis, elas serão muito mais prováveis do que eram para ElGamal/AES+SessionTags, e poderiam realmente acontecer.</p>
<h3 id="parâmetros">Parâmetros</h3>
<p>Usando duas vezes as sessões por segundo (128) e duas vezes a janela de tag (64), temos 4 vezes as tags (7,4 milhões). O máximo para uma chance de colisão de um em um milhão é 6,1 milhões de tags. Tags de 12 bytes (ou até mesmo 10 bytes) adicionariam uma margem enorme.</p>
<p>No entanto, será que a chance de um em um milhão de colisão é um bom objetivo? Muito maior que a chance de ser descartado ao longo do caminho não é muito útil. O objetivo de falso-positivo para o DecayingBloomFilter do Java é aproximadamente 1 em 10.000, mas mesmo 1 em 1.000 não é motivo de grave preocupação. Ao reduzir o objetivo para 1 em 10.000, há uma margem abundante com tags de 8 bytes.</p>
<h3 id="classificação">Classificação</h3>
<p>O remetente gera tags e chaves dinamicamente, portanto não há armazenamento. Isso reduz os requisitos gerais de armazenamento pela metade em comparação com ElGamal/AES. As tags ECIES têm 8 bytes em vez de 32 para ElGamal/AES. Isso reduz os requisitos gerais de armazenamento por outro fator de 4. As chaves de sessão por tag não são armazenadas no receptor, exceto para &ldquo;lacunas&rdquo;, que são mínimas para taxas de perda razoáveis.</p>
<p>A redução de 33% no tempo de expiração das tags cria uma economia adicional de 33%, assumindo tempos de sessão curtos.</p>
<p>Portanto, a economia total de espaço vs. ElGamal/AES é um fator de 10,7, ou 92%.</p>
<h2 id="related-changes">Related Changes</h2>
<h3 id="apenas-x25519">Apenas X25519</h3>
<p>Consultas de Banco de Dados a partir de Destinos ECIES: Consulte a <a href="../../../pt/proposals/154-ecies-lookups">Proposta 154</a>
, agora incorporada no <a href="../../../pt/docs/specs/i2np/">I2NP</a>
 para a versão 0.9.46.</p>
<p>Esta proposta requer suporte LS2 para publicar a chave pública X25519 com o leaseset. Nenhuma alteração é necessária nas especificações LS2 em <a href="../../../pt/docs/specs/i2np/">I2NP</a>
. Todo o suporte foi projetado, especificado e implementado na <a href="../../../pt/proposals/123-new-netdb-entries">Proposta 123</a>
 implementada na versão 0.9.38.</p>
<h3 id="x25519-compartilhado-com-elgamalaessessiontags">X25519 Compartilhado com ElGamal/AES+SessionTags</h3>
<p>Nenhuma. Esta proposta requer suporte a LS2 e uma propriedade a ser definida nas opções I2CP para ser habilitada. Não são necessárias alterações nas especificações do <a href="../../../pt/docs/specs/i2cp/">I2CP</a>
. Todo o suporte foi projetado, especificado e implementado na <a href="../../../pt/proposals/123-new-netdb-entries">Proposta 123</a>
 implementada na versão 0.9.38.</p>
<p>A opção necessária para habilitar ECIES é uma única propriedade I2CP para I2CP, BOB, SAM, ou i2ptunnel.</p>
<p>Os valores típicos são i2cp.leaseSetEncType=4 apenas para ECIES, ou i2cp.leaseSetEncType=4,0 para chaves duplas ECIES e ElGamal.</p>
<h3 id="respostas-da-camada-de-protocolo">Respostas da Camada de Protocolo</h3>
<p>Esta seção é copiada da <a href="../../../pt/proposals/123-new-netdb-entries">Proposta 123</a>
.</p>
<p>Opção no Mapeamento SessionConfig:</p>
<pre tabindex="0"><code>  i2cp.leaseSetEncType=nnn[,nnn]  The encryption types to be used.
                                  0: ElGamal
                                  1-3: See proposal 145
                                  4: This proposal.
</code></pre><h3 id="create-leaseset2-message">Create Leaseset2 Message</h3>
<p>Esta proposta requer LS2 que é suportado a partir da versão 0.9.38. Nenhuma alteração é necessária nas especificações do <a href="../../../pt/docs/specs/i2cp/">I2CP</a>
. Todo o suporte foi projetado, especificado e implementado na <a href="../../../pt/proposals/123-new-netdb-entries">Proposta 123</a>
 implementada na 0.9.38.</p>
<h3 id="sobrecarga">Sobrecarga</h3>
<p>Qualquer router que suporte LS2 com chaves duplas (0.9.38 ou superior) deve suportar conexão para destinos com chaves duplas.</p>
<p>Destinos apenas ECIES exigirão que a maioria dos floodfills seja atualizada para 0.9.46 para obter respostas de consulta criptografadas. Veja <a href="../../../pt/proposals/154-ecies-lookups">Proposta 154</a>
.</p>
<p>Destinos ECIES-only só podem conectar com outros destinos que sejam ECIES-only ou dual-key.</p>

                </article>

                
                <nav class="page-nav">
                    <a href="../../../pt/proposals/" class="page-nav-link">
                        ← Back to Proposals
                    </a>
                    
                    
                    
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                            
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                    <a href="../../../proposals/144-ecies-x25519-aead-ratchet.txt" class="page-nav-link" download>
                        Download Source (.txt)
                    </a>
                    
                </nav>
            </div>
        </div>
    </div>
</div>

<style>
.proposals-page {
    min-height: 100vh;
    padding: var(--spacing-xl) 0;
}

.breadcrumbs {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
    margin-bottom: var(--spacing-lg);
    font-size: 0.875rem;
    color: var(--color-text-muted);
}

.breadcrumbs a {
    color: var(--color-text-muted);
    text-decoration: none;
    transition: color var(--transition-fast);
}

.breadcrumbs a:hover {
    color: var(--color-primary);
}

.separator {
    color: var(--color-border);
}

.current {
    color: var(--color-text);
}

 
.translation-disclaimer {
    background: #fef3c7;
    border: 1px solid #f59e0b;
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spacing-md);
    flex-wrap: wrap;
}

.dark .translation-disclaimer {
    background: #78350f;
    border-color: #d97706;
}

.disclaimer-message {
    color: #92400e;
    font-size: 0.875rem;
}

.dark .disclaimer-message {
    color: #fde047;
}

.disclaimer-link {
    color: #92400e;
    font-weight: 600;
    text-decoration: underline;
    white-space: nowrap;
}

.dark .disclaimer-link {
    color: #fde047;
}

 
.proposal-header {
    margin-bottom: var(--spacing-2xl);
}

.proposal-title-section {
    margin-bottom: var(--spacing-lg);
}

.proposal-title {
    font-size: 2.5rem;
    margin: 0 0 var(--spacing-sm) 0;
    color: var(--color-text);
}

.proposal-number {
    font-size: 0.875rem;
    color: var(--color-text-muted);
    font-weight: 600;
}

 
.proposal-meta-box {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--spacing-lg);
}

.proposal-status {
    display: inline-block;
    padding: var(--spacing-xs) var(--spacing-md);
    border-radius: var(--radius-md);
    font-weight: 600;
    font-size: 0.875rem;
    margin-bottom: var(--spacing-md);
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

 
.status-open {
    background: #dbeafe;
    color: #0369a1;
}

.dark .status-open {
    background: #0c4a6e;
    color: #7dd3fc;
}

.status-accepted {
    background: #dbeafe;
    color: #0369a1;
}

.dark .status-accepted {
    background: #0c4a6e;
    color: #7dd3fc;
}

.status-finished {
    background: #dcfce7;
    color: #15803d;
}

.dark .status-finished {
    background: #164e63;
    color: #86efac;
}

.status-closed {
    background: #dcfce7;
    color: #15803d;
}

.dark .status-closed {
    background: #164e63;
    color: #86efac;
}

.status-rejected {
    background: #fee2e2;
    color: #991b1b;
}

.dark .status-rejected {
    background: #7f1d1d;
    color: #fca5a5;
}

.status-draft,
.status-needs-revision,
.status-dead,
.status-needs-research {
    background: #fef3c7;
    color: #92400e;
}

.dark .status-draft,
.dark .status-needs-revision,
.dark .status-dead,
.dark .status-needs-research {
    background: #78350f;
    color: #fde047;
}

.status-meta,
.status-informational,
.status-reserve {
    background: #e9d5ff;
    color: #6b21a8;
}

.dark .status-meta,
.dark .status-informational,
.dark .status-reserve {
    background: #581c87;
    color: #e879f9;
}

 
.proposal-info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
}

.info-item {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-xs);
}

.info-label {
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
}

.info-value {
    font-size: 0.9375rem;
    color: var(--color-text);
    font-weight: 500;
}

 
.proposal-relationships {
    border-top: 1px solid var(--color-border);
    padding-top: var(--spacing-md);
}

.relationship {
    display: flex;
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
}

.relationship:last-child {
    margin-bottom: 0;
}

.relationship-label {
    font-weight: 600;
    color: var(--color-text-muted);
    min-width: 120px;
}

.relationship-value {
    color: var(--color-text);
}

 
.proposal-layout {
    display: block;
}

.proposal-layout--with-toc {
    display: grid;
    grid-template-columns: 260px 1fr;
    gap: var(--spacing-2xl);
    align-items: start;
}

 
.proposal-toc-sidebar {
    position: sticky;
    top: 100px;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
}

.toc-nav {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--spacing-md);
}

.toc-header {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    font-weight: 700;
    font-size: 0.875rem;
    color: var(--color-text);
    padding-bottom: var(--spacing-md);
    margin-bottom: var(--spacing-md);
    border-bottom: 1px solid var(--color-border);
}

.toc-content {
    max-height: calc(100vh - 250px);
    overflow-y: auto;
}

.toc-content::-webkit-scrollbar {
    width: 4px;
}

.toc-content::-webkit-scrollbar-track {
    background: transparent;
}

.toc-content::-webkit-scrollbar-thumb {
    background: var(--color-border);
    border-radius: 2px;
}

.toc-content::-webkit-scrollbar-thumb:hover {
    background: var(--color-text-muted);
}

.toc-nav ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}

.toc-nav li {
    margin-bottom: 0.25rem;
}

.toc-nav ul ul {
    padding-left: var(--spacing-md);
    margin-top: 0.25rem;
}

.toc-nav a {
    color: var(--color-text-secondary);
    text-decoration: none;
    font-size: 0.8125rem;
    display: block;
    padding: 0.25rem 0.5rem;
    border-radius: var(--radius-sm);
    transition: all var(--transition-fast);
    line-height: 1.4;
}

.toc-nav a:hover {
    color: var(--color-primary);
    background: var(--color-bg-tertiary);
}

 
.proposal-main {
    min-width: 0;
}

 
.proposal-content {
    line-height: 1.8;
    color: var(--color-text);
    max-width: 900px;
}

.proposal-content h2 {
    margin-top: var(--spacing-2xl);
    margin-bottom: var(--spacing-md);
    font-size: 1.75rem;
    scroll-margin-top: 100px;
}

.proposal-content h3 {
    margin-top: var(--spacing-xl);
    margin-bottom: var(--spacing-sm);
    font-size: 1.375rem;
    scroll-margin-top: 100px;
}

.proposal-content h4 {
    margin-top: var(--spacing-lg);
    margin-bottom: var(--spacing-xs);
    font-size: 1.125rem;
    scroll-margin-top: 100px;
}

.proposal-content p {
    margin-bottom: var(--spacing-md);
}

.proposal-content ul,
.proposal-content ol {
    margin-bottom: var(--spacing-md);
    padding-left: var(--spacing-xl);
}

.proposal-content li {
    margin-bottom: var(--spacing-xs);
}

.proposal-content code {
    background: var(--color-bg-secondary);
    padding: 0.125rem 0.375rem;
    border-radius: var(--radius-sm);
    font-size: 0.875em;
    font-family: 'Courier New', monospace;
}

.proposal-content pre {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    overflow-x: auto;
    margin-bottom: var(--spacing-md);
    font-size: 0.875rem;
}

.proposal-content pre code {
    background: none;
    padding: 0;
}

.proposal-content blockquote {
    border-left: 4px solid var(--color-primary);
    padding-left: var(--spacing-md);
    margin-left: 0;
    margin-bottom: var(--spacing-md);
    font-style: italic;
    color: var(--color-text-secondary);
}

.proposal-content a {
    color: var(--color-primary);
    text-decoration: none;
    border-bottom: 1px solid transparent;
    transition: border-color var(--transition-fast);
}

.proposal-content a:hover {
    border-bottom-color: var(--color-primary);
}

.proposal-content table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: var(--spacing-md);
}

.proposal-content table th {
    background: var(--color-bg-secondary);
    padding: var(--spacing-sm);
    text-align: left;
    font-weight: 600;
    border-bottom: 2px solid var(--color-border);
}

.proposal-content table td {
    padding: var(--spacing-sm);
    border-bottom: 1px solid var(--color-border);
}

.proposal-content img {
    max-width: 100%;
    height: auto;
    border-radius: var(--radius-md);
    border: 1px solid var(--color-border);
    margin: var(--spacing-lg) 0;
    display: block;
}

 
.page-nav {
    margin-top: var(--spacing-2xl);
    padding-top: var(--spacing-xl);
    border-top: 1px solid var(--color-border);
    display: flex;
    gap: var(--spacing-md);
    flex-wrap: wrap;
}

.page-nav-link {
    display: inline-block;
    padding: var(--spacing-md) var(--spacing-lg);
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    color: var(--color-text);
    text-decoration: none;
    transition: all var(--transition-fast);
}

.page-nav-link:hover {
    border-color: var(--color-primary);
    color: var(--color-primary);
}

 
@media (max-width: 1024px) {
    .proposal-layout--with-toc {
        grid-template-columns: 1fr;
    }

    .proposal-toc-sidebar {
        position: static;
        max-height: none;
        margin-bottom: var(--spacing-xl);
    }

    .toc-content {
        max-height: 300px;
    }
}

@media (max-width: 768px) {
    .proposal-title {
        font-size: 1.75rem;
    }

    .proposal-info-grid {
        grid-template-columns: 1fr;
    }
}
</style>



<script>
document.addEventListener('DOMContentLoaded', function() {
    const tocLinks = document.querySelectorAll('.toc-nav a');
    const headings = [];

    tocLinks.forEach(link => {
        const href = link.getAttribute('href');
        if (href && href.startsWith('#')) {
            const heading = document.getElementById(href.slice(1));
            if (heading) {
                headings.push({ element: heading, link: link });
            }
        }
    });

    function updateActiveLink() {
        const scrollPos = window.scrollY + 120;
        let activeIndex = 0;

        for (let i = 0; i < headings.length; i++) {
            if (headings[i].element.offsetTop <= scrollPos) {
                activeIndex = i;
            }
        }

        tocLinks.forEach(link => link.classList.remove('active'));
        if (headings[activeIndex]) {
            headings[activeIndex].link.classList.add('active');
        }
    }

    window.addEventListener('scroll', updateActiveLink);
    updateActiveLink();
});
</script>
<style>
.toc-nav a.active {
    color: var(--color-primary);
    background: var(--color-bg-tertiary);
    font-weight: 600;
}
</style>



    </main>

    <footer class="site-footer">
    <div class="container">
        <div class="footer-grid">
            <div class="footer-col footer-brand">
                <img src="../../../images/i2plogo_lightmode.svg" alt="I2P Logo" class="footer-logo logo-light" loading="lazy" decoding="async">
                <img src="../../../images/i2plogo_darkmode.svg" alt="I2P Logo" class="footer-logo logo-dark" loading="lazy" decoding="async">
                <p class="footer-tagline">Privacy. Security. Freedom.</p>
                <p class="footer-description">The Invisible Internet Project - A privacy-focused, anonymous network layer</p>

                <div class="footer-social-newsletter">
                    <div class="social-links">
                        <a href="https://mastodon.social/@i2p" target="_blank" rel="noopener" aria-label="Mastodon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M21.327 8.566c0-4.339-2.843-5.61-2.843-5.61-1.433-.658-3.894-.935-6.451-.956h-.063c-2.557.021-5.016.298-6.45.956 0 0-2.843 1.272-2.843 5.61 0 .993-.019 2.181.012 3.441.103 4.243.778 8.425 4.701 9.463 1.809.479 3.362.579 4.612.51 2.268-.126 3.541-.809 3.541-.809l-.075-1.646s-1.621.511-3.441.449c-1.804-.062-3.707-.194-3.999-2.409a4.523 4.523 0 0 1-.04-.621s1.77.433 4.014.536c1.372.063 2.658-.08 3.965-.236 2.506-.299 4.688-1.843 4.962-3.254.434-2.223.398-5.424.398-5.424zm-3.353 5.59h-2.081V9.057c0-1.075-.452-1.62-1.357-1.62-1 0-1.501.647-1.501 1.927v2.791h-2.069V9.364c0-1.28-.501-1.927-1.502-1.927-.905 0-1.357.546-1.357 1.62v5.099H6.026V8.903c0-1.074.273-1.927.823-2.558.566-.631 1.307-.955 2.228-.955 1.065 0 1.872.409 2.405 1.228l.518.869.519-.869c.533-.819 1.34-1.228 2.405-1.228.92 0 1.662.324 2.228.955.549.631.822 1.484.822 2.558v5.253z"/>
                            </svg>
                        </a>
                        <a href="https://twitter.com/GetI2P" target="_blank" rel="noopener" aria-label="Twitter">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                            </svg>
                        </a>
                        <a href="https://old.reddit.com/r/i2p" target="_blank" rel="noopener" aria-label="Reddit">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z"/>
                            </svg>
                        </a>
                        <a href="https://signal.group/#CjQKIOSUTtxlhbumAKcRsthPFkxkTUrkWcX39bbN6njLEgAIEhCTNsR0KDuiehAXZnkt42v5" target="_blank" rel="noopener" aria-label="Signal" class="signal-link">
                            <img src="../../../images/Signal-Logo-Black.svg" alt="Signal" class="signal-logo signal-logo-light" loading="lazy" decoding="async">
                            <img src="../../../images/Signal-Logo-White.svg" alt="Signal" class="signal-logo signal-logo-dark" loading="lazy" decoding="async">
                        </a>
                    </div>

                    
                    <div class="footer-newsletter-inline">
                        <p class="newsletter-description">Fique atualizado com as notícias do I2P:</p>
                        <form action="https://feedback.i2p.net/api/mailing-list/subscribe" method="POST" class="newsletter-form">
                            <input type="email" name="email" placeholder="Digite seu e-mail" required>
                            <button type="submit">Inscrever-se</button>
                        </form>
                    </div>
                </div>
            </div>

            <div class="footer-col">
                <h3>Links Rápidos</h3>
                <ul>
                    <li><a href="../../../pt/financial-support/">Doar</a></li>
                    <li><a href="../../../pt/docs/overview/intro/">Introdução ao I2P</a></li>
                </ul>
            </div>

            <div class="footer-col">
                <h3>Comunidade</h3>
                <ul>
                    <li><a href="../../../pt/get-involved/">Participe</a></li>
                    <li><a href="../../../pt/blog/">Blog</a></li>
                    <li><a href="http://i2pforum.net/" target="_blank" rel="noopener">Fóruns Oficiais</a></li>
                    <li><a href="../../../pt/contact/">Contato</a></li>
                </ul>
            </div>

            <div class="footer-col">
                <h3>Recursos</h3>
                <ul>
                    <li><a href="https://i2p-metrics.np-tokumei.net/" target="_blank" rel="noopener">Métricas I2P</a></li>
                    <li><a href="../../../pt/papers/">Pesquisa</a></li>
                    <li><a href="https://i2pgit.org/" target="_blank" rel="noopener">GitLab</a></li>
                    <li><a href="https://www.stormycloud.org/" target="_blank" rel="noopener">StormyCloud</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p class="copyright">&copy; 2025 O Projeto de Internet Invisível. Licenciado sob Creative Commons.</p>
            <div class="footer-links">
                <a href="../../../pt/privacy/">Privacidade</a>
                <a href="../../../pt/terms/">Termos</a>
                <a href="../../../pt/about/media/">Imprensa</a>
            </div>
        </div>
    </div>
</footer>


    
    
<div class="modal-overlay" id="poll">
    <div class="modal-content poll-modal-content">
        <a href="#" class="modal-close" aria-label="Fechar">
            <span aria-hidden="true">&times;</span>
        </a>

        <div class="modal-header">
            <h2>Enquete da comunidade</h2>
            <p class="modal-subtitle">Gostaríamos de ouvir sua opinião</p>
        </div>

        <div class="modal-body">
            
            <iframe 
                id="poll-iframe"
                data-poll-id="2"
                data-api-url="https://feedback.i2p.net"
                frameborder="0"
                scrolling="no"
                style="width: 100%; border: none; min-height: 400px;">
            </iframe>
        </div>

        <div class="modal-footer">
            <p class="modal-disclaimer">
                Seu voto ajuda a moldar o futuro do I2P.
            </p>
        </div>
    </div>
</div>


<script>
(function() {
    const iframe = document.getElementById('poll-iframe');
    if (!iframe) return;
    
    const hostname = window.location.hostname;
    let apiUrl = 'https://feedback.i2p.net';
    const pollId = iframe.getAttribute('data-poll-id') || '1';

    
    if (hostname.endsWith('.b32.i2p') || hostname.endsWith('.i2p')) {
        apiUrl = 'http://5kwyynf3eetgqa2nors6ctwo7doi7yu73k7uvypy5eqmm326zkiq.b32.i2p';
    }
    
    else if (hostname.endsWith('.onion')) {
        apiUrl = 'http://gfonxmohvarpmocsvllscsuszdu5rikipm6innvcwq4vpng7zzqmmfyd.onion';
    }

    
    const pollUrl = apiUrl + '/widgets/poll.html?poll_id=' + encodeURIComponent(pollId) + '&api_url=' + encodeURIComponent(apiUrl);
    iframe.src = pollUrl;
})();
</script>



    
    



    
    <script>
        (function () {
            'use strict';
            var hostname = window.location.hostname;
            var baseUrl;

            
            if (hostname.endsWith('.b32.i2p') || hostname.endsWith('.i2p')) {
                baseUrl = 'http://5kwyynf3eetgqa2nors6ctwo7doi7yu73k7uvypy5eqmm326zkiq.b32.i2p';
            } else if (hostname.endsWith('.onion')) {
                baseUrl = 'http://gfonxmohvarpmocsvllscsuszdu5rikipm6innvcwq4vpng7zzqmmfyd.onion';
            } else {
                baseUrl = 'https://feedback.i2p.net';
            }

            window.feedbackBaseUrl = baseUrl;

            
            document.querySelectorAll('[data-api-url]').forEach(function (widget) {
                widget.setAttribute('data-api-url', baseUrl);
            });

            
            document.write('<link rel="stylesheet" href="' + baseUrl + '/widgets/styles.css">');
            
        })();
    </script>

    

    
    
    

    

</body>

</html>
[{"categories":null,"content":"Visão geral Esta especificação documenta o protocolo para mensagens announce UDP do BitTorrent no I2P (announce: solicitação do cliente ao tracker). Para a especificação geral do BitTorrent no I2P, consulte a documentação do BitTorrent via I2P . Para contexto e informações adicionais sobre o desenvolvimento desta especificação, consulte a Proposta 160 .\nEste protocolo foi formalmente aprovado em 24 de junho de 2025 e implementado na versão 2.10.0 do I2P (API 0.9.67), lançada em 8 de setembro de 2025. O suporte ao rastreador UDP está atualmente operacional na rede I2P, com múltiplos rastreadores em produção e suporte completo no cliente i2psnark.\nArquitetura Esta especificação usa datagram2 com possibilidade de resposta, datagram3 com possibilidade de resposta e datagramas brutos, conforme definidos na I2P Datagram Specification . Datagram2 e Datagram3 são variantes de datagramas com possibilidade de resposta, definidas na Proposal 163 . O Datagram2 adiciona resistência a ataques de repetição e suporte a assinatura offline. O Datagram3 é menor que o formato antigo de datagrama, porém sem autenticação.\nBEP 15 Para referência, o fluxo de mensagens definido no BEP 15 é o seguinte:\nClient Tracker Connect Req. -------------\u0026gt; \u0026lt;-------------- Connect Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. Announce Req. -------------\u0026gt; \u0026lt;-------------- Announce Resp. A fase de conexão é necessária para evitar a falsificação de endereços IP. O rastreador retorna um ID de conexão que o cliente usa em anúncios subsequentes. Esse ID de conexão expira, por padrão, em um minuto no cliente e em dois minutos no rastreador.\nI2P usa o mesmo fluxo de mensagens que o BEP 15, para facilitar a adoção em bases de código de clientes com suporte a UDP, por questões de eficiência, e por razões de segurança discutidas abaixo:\nClient Tracker Connect Req. -------------\u0026gt; (Repliable Datagram2) \u0026lt;-------------- Connect Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) Announce Req. -------------\u0026gt; (Repliable Datagram3) \u0026lt;-------------- Announce Resp. (Raw) ... Isso pode proporcionar uma grande economia de largura de banda em relação a anúncios via streaming (TCP). Embora o Datagram2 tenha aproximadamente o mesmo tamanho que um SYN de streaming, a resposta bruta é muito menor do que o SYN ACK de streaming. As solicitações subsequentes usam o Datagram3, e as respostas subsequentes são brutas.\nAs solicitações de anúncio são Datagram3 (formato de datagrama v3), de modo que o rastreador não precise manter uma grande tabela de mapeamento de IDs de conexão para destino de anúncio ou hash. Em vez disso, o rastreador pode gerar IDs de conexão criptograficamente a partir do hash do remetente, do carimbo de data/hora atual (com base em algum intervalo) e de um valor secreto. Quando uma solicitação de anúncio é recebida, o rastreador valida o ID de conexão e então usa o hash do remetente do Datagram3 como o destino de envio.\nDuração da conexão BEP 15 especifica que o ID de conexão expira em um minuto no cliente e em dois minutos no rastreador. Isso não é configurável. Isso limita os ganhos potenciais de eficiência, a menos que os clientes agrupem as operações \u0026ldquo;announce\u0026rdquo; (requisições do BitTorrent ao rastreador) para realizar todas dentro de uma janela de um minuto. O i2psnark atualmente não agrupa as operações \u0026ldquo;announce\u0026rdquo;; ele as distribui para evitar picos de tráfego. Há relatos de que usuários avançados executam milhares de torrents ao mesmo tempo, e concentrar tantas operações \u0026ldquo;announce\u0026rdquo; em um único minuto não é realista.\nAqui, propomos estender a resposta de conexão para adicionar um campo opcional de tempo de vida da conexão. O padrão, caso o campo não esteja presente, é de um minuto. Caso contrário, o tempo de vida especificado em segundos deverá ser usado pelo cliente, e o rastreador manterá o ID da conexão por mais um minuto.\nCompatibilidade com o BEP 15 Este design mantém a compatibilidade com BEP 15 tanto quanto possível para limitar as mudanças necessárias nos clientes e rastreadores existentes.\nA única alteração necessária é o formato das informações do par na resposta de anúncio. A adição do campo de tempo de vida na resposta de conexão não é necessária, mas é fortemente recomendada por questões de eficiência, conforme explicado acima.\nAnálise de Segurança Um objetivo importante de um protocolo de anúncio UDP é impedir a falsificação de endereços. O cliente deve de fato existir e incluir um leaseSet real. Ele deve ter tunnels de entrada para receber a Resposta de Conexão. Esses tunnels poderiam ser zero-hop e construídos instantaneamente, mas isso exporia o criador. Este protocolo cumpre esse objetivo.\nProblemas Este protocolo não oferece suporte a blinded destinations (destinos ofuscados), mas pode ser estendido para fazê-lo. Veja abaixo.\nEspecificação Protocolos e Portas O Datagram2 replicável usa o protocolo I2CP 19; o Datagram3 replicável usa o protocolo I2CP 20; datagramas brutos usam o protocolo I2CP 18. As solicitações podem ser Datagram2 ou Datagram3. As respostas são sempre datagramas brutos. O formato mais antigo de datagrama replicável (\u0026ldquo;Datagram1\u0026rdquo;), que usa o protocolo I2CP 17, NÃO deve ser usado para solicitações ou respostas; estes devem ser descartados se recebidos nas portas de solicitação/resposta. Observe que o Datagram1, protocolo 17, ainda é usado pelo protocolo DHT.\nAs requisições usam o I2CP \u0026ldquo;to port\u0026rdquo; da URL de anúncio; veja abaixo. O \u0026ldquo;from port\u0026rdquo; da requisição é escolhido pelo cliente, mas deve ser diferente de zero e distinto das portas usadas pela DHT (tabela hash distribuída), para que as respostas possam ser classificadas facilmente. Os rastreadores devem rejeitar requisições recebidas na porta errada.\nAs respostas usam o \u0026ldquo;to port\u0026rdquo; do I2CP da solicitação. O \u0026ldquo;from port\u0026rdquo; da resposta é o \u0026ldquo;to port\u0026rdquo; da solicitação.\nURL de anúncio O formato da URL de announce não é especificado no BEP 15 , mas, como na clearnet (internet pública), URLs de announce UDP têm a forma \u0026ldquo;udp://host:port/path\u0026rdquo;. O caminho é ignorado e pode estar vazio, mas é tipicamente \u0026ldquo;/announce\u0026rdquo; na clearnet. A parte :port deve estar sempre presente; entretanto, se a parte \u0026ldquo;:port\u0026rdquo; for omitida, use 6969 como porta I2CP padrão, já que essa é a porta comum na clearnet. Também podem ser anexados parâmetros CGI \u0026amp;a=b\u0026amp;c=d; eles podem ser processados e fornecidos na requisição de announce, veja BEP 41 . Se não houver parâmetros ou caminho, a barra final / também pode ser omitida, como implícito no BEP 41 .\nFormatos de Datagramas Todos os valores são enviados em ordem de bytes de rede (big-endian). Não espere que os pacotes tenham exatamente um determinado tamanho. Extensões futuras podem aumentar o tamanho dos pacotes.\nSolicitação de conexão Do cliente para o tracker. 16 bytes. Deve ser um Datagram2 repliable (permite resposta). Igual ao BEP 15 . Sem alterações.\nOffset Size Name Value 0 64-bit integer protocol_id 0x41727101980 // magic constant 8 32-bit integer action 0 // connect 12 32-bit integer transaction_id Resposta de Conexão Do rastreador para o cliente. 16 ou 18 bytes. Deve estar em formato bruto. Igual ao definido no BEP 15 , exceto conforme indicado abaixo.\nOffset Size Name Value 0 32-bit integer action 0 // connect 4 32-bit integer transaction_id 8 64-bit integer connection_id 16 16-bit integer lifetime optional // Change from BEP 15 A resposta DEVE ser enviada para o \u0026ldquo;to port\u0026rdquo; do I2CP que foi recebido como o \u0026ldquo;from port\u0026rdquo; da solicitação.\nO campo lifetime é opcional e indica o tempo de vida do connection_id do cliente em segundos. O padrão é 60, e o mínimo, se especificado, é 60. O máximo é 65535 ou cerca de 18 horas. O rastreador deve manter o connection_id por 60 segundos a mais do que o tempo de vida do cliente.\nSolicitação de anúncio Cliente para o tracker. 98 bytes no mínimo. Deve ser um Datagram3 com possibilidade de resposta. Igual ao descrito em BEP 15 exceto conforme observado abaixo.\nO connection_id é o mesmo que o recebido na resposta de conexão.\nOffset Size Name Value 0 64-bit integer connection_id 8 32-bit integer action 1 // announce 12 32-bit integer transaction_id 16 20-byte string info_hash 36 20-byte string peer_id 56 64-bit integer downloaded 64 64-bit integer left 72 64-bit integer uploaded 80 32-bit integer event 0 // 0: none; 1: completed; 2: started; 3: stopped 84 32-bit integer IP address 0 // default, unused in I2P 88 32-bit integer key 92 32-bit integer num_want -1 // default 96 16-bit integer port // must be same as I2CP from port 98 varies options optional // As specified in BEP 41 Alterações em relação ao BEP 15 :\nkey é ignorado O endereço IP não é utilizado a porta provavelmente é ignorada, mas deve ser a mesma que o I2CP from port A seção de opções, se presente, é definida conforme BEP 41 A resposta DEVE ser enviada ao \u0026ldquo;to port\u0026rdquo; do I2CP que foi recebido como o \u0026ldquo;from port\u0026rdquo; da requisição. Não use a porta da requisição de anúncio.\nResposta de Anúncio Do rastreador para o cliente. Mínimo de 20 bytes. Deve ser em bruto. Igual ao BEP 15 , exceto conforme observado abaixo.\nOffset Size Name Value 0 32-bit integer action 1 // announce 4 32-bit integer transaction_id 8 32-bit integer interval 12 32-bit integer leechers 16 32-bit integer seeders 20 32 * n 32-byte hash binary hashes // Change from BEP 15 ... // Change from BEP 15 Alterações em relação ao BEP 15 :\nEm vez de IPv4+porta de 6 bytes ou IPv6+porta de 18 bytes, retornamos um número múltiplo de \u0026ldquo;respostas compactas\u0026rdquo; de 32 bytes com os hashes SHA-256 binários dos pares. Como nas respostas compactas TCP, não incluímos uma porta. A resposta DEVE ser enviada ao I2CP \u0026ldquo;to port\u0026rdquo; que foi recebido como o \u0026ldquo;from port\u0026rdquo; da solicitação. Não use a porta da solicitação de anúncio.\nOs datagramas do I2P têm um tamanho máximo muito grande, de cerca de 64 KB; no entanto, para entrega confiável, é recomendável evitar datagramas maiores que 4 KB. Por eficiência de banda, os rastreadores provavelmente devem limitar o número máximo de pares a cerca de 50, o que corresponde a um pacote de aproximadamente 1600 bytes antes da sobrecarga em várias camadas, e deve ficar dentro do limite de carga útil de uma mensagem que percorre dois tunnel após a fragmentação.\nComo no BEP 15, não há uma contagem incluída do número de endereços de pares (IP/porta no BEP 15, hashes aqui) a seguir. Embora não contemplado no BEP 15, poderia ser definido um marcador de fim de pares composto apenas por zeros para indicar que as informações dos pares estão completas e que alguns dados de extensão seguem.\nPara que essa extensão seja possível no futuro, os clientes devem ignorar um hash de 32 bytes composto apenas por zeros, e quaisquer dados que vierem depois. Os rastreadores devem rejeitar anúncios provenientes de um hash composto apenas por zeros, embora esse hash já seja banido pelos Java routers.\nRaspagem A requisição/resposta de scrape (consulta ao tracker por estatísticas) de BEP 15 não é exigida por esta especificação, mas pode ser implementada se desejado, sem necessidade de alterações. O cliente deve obter um ID de conexão primeiro. A requisição de scrape é sempre um Datagram3 repliable. A resposta de scrape é sempre raw.\nResposta de erro Do rastreador para o cliente. Mínimo de 8 bytes (se a mensagem estiver vazia). Deve ser em formato bruto. O mesmo que em BEP 15 . Sem alterações.\nOffset Size Name Value 0 32-bit integer action 3 // error 4 32-bit integer transaction_id 8 string message Extensões Bits de extensão ou um campo de versão não estão incluídos. Clientes e trackers não devem assumir que os pacotes têm um tamanho específico. Dessa forma, campos adicionais podem ser adicionados sem comprometer a compatibilidade. O formato de extensões definido em BEP 41 é recomendado, se necessário.\nA resposta de conexão é modificada para incluir um tempo de vida opcional do ID de conexão.\nSe for necessário suporte a blinded destination (destino cego), podemos ou adicionar o endereço cego de 35 bytes ao final da requisição announce, ou solicitar hashes cegos nas respostas, usando o formato BEP 41 (parâmetros a definir). O conjunto de endereços de pares cegos de 35 bytes poderia ser acrescentado ao final da resposta announce, após um hash de 32 bytes composto apenas por zeros.\nDiretrizes de Implementação Consulte a seção de design acima para uma discussão sobre os desafios enfrentados por clientes e rastreadores não integrados e que não usam I2CP.\nClientes Para um determinado nome de host do rastreador, um cliente deve preferir URLs UDP a URLs HTTP e não deve anunciar a ambos.\nClientes com suporte existente ao BEP 15 (proposta de melhoria do BitTorrent 15) devem necessitar apenas de pequenas modificações.\nSe um cliente oferecer suporte a DHT ou a outros protocolos de datagrama, provavelmente deve selecionar uma porta diferente como a \u0026ldquo;from port\u0026rdquo; da solicitação, para que as respostas cheguem de volta a essa porta e não se confundam com mensagens do DHT. O cliente só recebe datagramas brutos como respostas. Os rastreadores nunca enviarão um repliable datagram2 (datagrama ao qual é possível responder) ao cliente.\nClientes com uma lista predefinida de trackers abertos devem atualizar a lista para adicionar URLs UDP depois de se confirmar que os trackers abertos conhecidos suportam UDP.\nOs clientes podem ou não implementar retransmissão de solicitações. As retransmissões, se implementadas, devem usar um tempo limite inicial de pelo menos 15 segundos e dobrar o tempo limite a cada retransmissão (backoff exponencial).\nOs clientes devem fazer back off (aguardar e reduzir a taxa antes de tentar novamente) após receber uma resposta de erro.\nRastreadores Rastreadores com suporte existente a BEP 15 deveriam exigir apenas pequenas modificações. Esta especificação difere da proposta de 2014, pois o rastreador deve suportar a recepção de datagram2 (datagrama versão 2) e datagram3 (datagrama versão 3) com capacidade de resposta na mesma porta.\nPara minimizar os requisitos de recursos do rastreador, este protocolo foi projetado para eliminar qualquer necessidade de que o rastreador armazene mapeamentos de hashes de cliente para IDs de conexão para validação posterior. Isso é possível porque o pacote de solicitação de announce é um pacote Datagram3 (formato de datagrama do I2P) com possibilidade de resposta, portanto contém o hash do remetente.\nUma implementação recomendada é:\nDefina a epoch (época de tempo) atual como o tempo atual com resolução igual ao tempo de vida da conexão, epoch = now / lifetime. Defina uma função hash criptográfica H(secret, clienthash, epoch) que gera uma saída de 8 bytes. Gere o segredo constante aleatório usado para todas as conexões. Para respostas de conexão, gere connection_id = H(secret, clienthash, epoch) Para solicitações de anúncio, valide o ID de conexão recebido na epoch atual verificando connection_id == H(secret, clienthash, epoch) || connection_id == H(secret, clienthash, epoch - 1) Estado da implantação Este protocolo foi aprovado em 24 de junho de 2025 e está plenamente operacional na rede I2P desde setembro de 2025.\nImplementações atuais i2psnark: O suporte completo a rastreadores UDP está incluído no I2P versão 2.10.0 (API 0.9.67), lançado em 8 de setembro de 2025. Todas as instalações do I2P a partir desta versão incluem suporte a rastreadores UDP por padrão.\nzzzot tracker: A partir da versão 0.20.0-beta2, há suporte a announce (anúncio do cliente ao rastreador) via UDP. Em outubro de 2025, os seguintes rastreadores de produção estão operacionais: - opentracker.dg2.i2p - opentracker.simp.i2p - opentracker.skank.i2p\nNotas de compatibilidade do cliente Limitações do SAM v3.3: Clientes externos de BitTorrent que usam SAM (Simple Anonymous Messaging) exigem suporte ao SAM v3.3 para Datagram2/3. Isso está disponível no Java I2P, mas não é atualmente suportado pelo i2pd (a implementação de I2P em C++), o que pode limitar a adoção em clientes baseados em libtorrent (biblioteca BitTorrent em C++) como o qBittorrent.\nClientes I2CP: Clientes que usam I2CP diretamente (como o BiglyBT) podem implementar suporte a trackers UDP sem as limitações do SAM.\nReferências [BEP15]: Protocolo de Tracker UDP do BitTorrent [BEP41]: Extensões do Protocolo de Tracker UDP [DATAGRAMS]: Especificação de Datagramas do I2P [Prop160]: Proposta de Trackers UDP [Prop163]: Proposta do Datagram2 [SPEC]: BitTorrent sobre I2P ","description":"Especificação do protocolo para mensagens announce (requisições de anúncio ao tracker) do tracker BitTorrent baseadas em UDP no I2P","id":"2413d642663e185a8a31352c9a9e8f28","section":"docs","title":"Anúncios UDP do BitTorrent","url":"/pt/docs/specs/udp-bittorrent-announces/"},{"categories":null,"content":" Status: Atualizado até I2P 2.10.0 (Outubro 2025). Esta lista consolida todas as portas ativas, obsoletas e reservadas utilizadas pelo I2P Java Router, i2pd e plugins relacionados. Todas as portas estão listadas em ordem numérica para consistência.\nPort Service / Component Description Notes 123SNTPNetwork time synchronizationUses external NTP servers; required for accurate LeaseSet timestamps. 2827BOB interfaceLegacy client API bridgeDeprecated; disabled by default. 4444HTTP ProxyStandard web proxy for eepsite browsingDefault for both HTTP and HTTPS browser traffic. 4445HTTPS ProxyDedicated SSL/TLS proxyOptional; often redundant with 4444. 6667–6669IRC ProxyAccess to I2P IRC networksDefault = 6668; alternate ports avoid conflicts. 7650I2PControl PluginJSON‑RPC management APIAuth required; default password itoopie. 7652UPnP HTTP eventsUPnP control interfaceSupports automatic port forwarding. 7653UPnP SSDP responsesUPnP discoveryUDP response listener for device search. 7654I2CPCore application APIUsed by Java apps and i2pd for router integration. 7655SAM DatagramUDP bridge for SAM APISAM v3 support for real‑time apps. 7656SAM StreamTCP bridge for SAM APIPrimary non‑Java application interface. 7657Router Console (HTTP)Web admin interfaceLoopback‑only by default (127.0.0.1). 7658EepsiteDefault web server for I2PTunnelUsed for locally hosted services. 7659SMTP ProxyOutgoing mail via I2P‑BoteBridges standard email clients. 7660POP3 ProxyIncoming mail via I2P‑BoteServerless email retrieval. 7661I2PBote SMTP / Pebble BlogPlugin dual‑use portRarely conflicts since plugins don’t co‑install. 7662I2PBote IMAP / Zzzot TrackerPlugin dual‑use portUsed by Zzzot for BitTorrent tracking. 7663—Reserved for future pluginsUnused as of 2.10.0. 7664JAMWiki PluginWiki platform for I2P sitesOptional plugin. 7667Router Console (HTTPS)Secure web admin interfaceSelf‑signed cert by default. 7672Railroad PluginPlugin port reservationLast documented plugin port in series. 7644Browser Mode ProxyHTTP proxy for I2P Browser BundleUsed when running Browser mode alongside router. 7647Browser Mode ConsoleRouter console for I2P Browser BundleAvoids conflict with 7657. 8002I2PSnark Web UI (HTTP)BitTorrent client UIIntegrated in router console. 8003I2PSnark Web UI (HTTPS)BitTorrent client UI (SSL)Optional secure mode. 8887Router Network Port (Legacy)Old default for peer connectionsReplaced by randomized 9151–30777 range. 8118Privoxy (Reserved)External web proxy integrationNot part of core I2P; reserved for compatibility. 8123Polipo (Reserved)Alternate proxy integrationLegacy Tor proxy compatibility. 8888Freenet (Reserved)Anonymous network portPrevents conflicts on privacy nodes. 9050–9053Tor SOCKS (Reserved)Tor proxy range for co‑installationAvoids conflicts with I2P. 9150–9153Tor Browser SOCKS (Reserved)Tor Browser integrationReserved for cross‑tool coexistence. 9151–30777Router Network Port (Random)Active TCP/UDP transport portRandomized per install for anti‑fingerprinting. 1488 / 1776XD BitTorrent ClientStandalone I2P torrent clientAlternate to I2PSnark. 31000–32000Java Service WrapperRouter process managementHandles service control and restart. 3456 / 3458 / 3459Tahoe‑LAFS PluginDecentralized file storageOptional third‑party plugin. 4691 / 8997–8999Monotone Version ControlDistributed VCS supportHistorical usage for developer tools. 7070i2pd ConsoleWeb console for C++ implementationEquivalent to Java router console. 767xPlugin Range (General)Recommended port block for pluginsDevelopers start from 7672 upward. 11371SKS/GPG Key Server (Reserved)Key distribution serviceUsed for PGP/GPG over I2P. ## Notas de Implementação Todas as portas abaixo de 9000 (exceto 8887) são vinculadas a 127.0.0.1 por padrão por segurança. A porta de rede do router (9151–30777) deve estar aberta para a internet para participação completa. i2pd usa principalmente as mesmas atribuições para compatibilidade (7070 console, 7654 I2CP, 7656/7655 SAM). Desenvolvedores de plugins devem coordenar novas atribuições através da comunidade I2P para evitar conflitos. ","description":"Referência abrangente de atribuições de portas I2P, portas de plugins e intervalos reservados.","id":"69ea4623f7bc59ab65ef7ea636966780","section":"docs","title":"Atribuições de Portas","url":"/pt/docs/overview/ports/"},{"categories":null,"content":"Visão geral Endereços Base 32 padrão (\u0026ldquo;b32\u0026rdquo;) contêm o hash do destino. Isso não funciona para LS2 (LeaseSet 2, \u0026rsquo;leaseSet\u0026rsquo; de segunda geração) criptografado (Proposta 123).\nNão podemos usar um endereço base 32 tradicional para um LS2 criptografado (proposta 123), pois ele contém apenas o hash do destino. Ele não fornece a chave pública não cegada. Os clientes devem conhecer a chave pública do destino, o tipo de assinatura, o tipo de assinatura cegada e uma chave secreta ou privada opcional para obter e decifrar o leaseset. Portanto, um endereço base 32 por si só é insuficiente. O cliente precisa do destino completo (que contém a chave pública) ou da própria chave pública. Se o cliente tiver o destino completo em um livro de endereços e o livro de endereços suportar busca reversa por hash, então a chave pública poderá ser recuperada.\nEste formato coloca a chave pública, em vez do hash, em um endereço base32. Este formato também deve conter o tipo de assinatura da chave pública e o tipo de assinatura do esquema de cegamento.\nEste documento especifica um formato b32 para esses endereços. Embora tenhamos nos referido a esse novo formato durante as discussões como um endereço \u0026ldquo;b33\u0026rdquo;, o novo formato de fato mantém o sufixo habitual \u0026ldquo;.b32.i2p\u0026rdquo;.\nStatus da Implementação A Proposta 123 (Novas entradas do netDB) foi totalmente implementada na versão 0.9.43 (outubro de 2019). O conjunto de recursos do LS2 (leaseSet de segunda geração) criptografado manteve-se estável até a versão 2.10.0 (setembro de 2025), sem alterações incompatíveis no formato de endereçamento ou nas especificações criptográficas.\nPrincipais marcos de implementação: - 0.9.38: Suporte a Floodfill para LS2 (LeaseSet versão 2) padrão com chaves offline - 0.9.39: Tipo de assinatura RedDSA 11 e criptografia/descriptografia básicas - 0.9.40: Suporte completo a endereçamento B32 (Proposta 149) - 0.9.41: Autenticação por cliente baseada em X25519 - 0.9.42: Todos os recursos de blinding (cegamento) operacionais - 0.9.43: Implementação completa declarada (outubro de 2019)\nConcepção O novo formato contém a chave pública não cega, o tipo de assinatura não cego e o tipo de assinatura cego. Opcionalmente indica requisitos de segredo e/ou de chave privada para links privados. Usa o sufixo existente \u0026ldquo;.b32.i2p\u0026rdquo;, mas com um comprimento maior. Inclui um checksum para detecção de erros. Os endereços para leasesets criptografados são identificados por 56 ou mais caracteres codificados (35 ou mais bytes decodificados), em comparação com 52 caracteres (32 bytes) para endereços tradicionais base 32. Especificação Criação e Codificação Construa um nome de host de {56+ caracteres}.b32.i2p (35+ caracteres em binário) da seguinte forma:\nflag (1 byte) bit 0: 0 for one-byte sigtypes, 1 for two-byte sigtypes bit 1: 0 for no secret, 1 if secret is required bit 2: 0 for no per-client auth, 1 if client private key is required bits 7-3: Unused, set to 0 public key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero blinded key sigtype (1 or 2 bytes as indicated in flags) If 1 byte, the upper byte is assumed zero public key Number of bytes as implied by sigtype Pós-processamento e soma de verificação:\nConstruct the binary data as above. Treat checksum as little-endian. Calculate checksum = CRC-32(data[3:end]) data[0] ^= (byte) checksum data[1] ^= (byte) (checksum \u0026gt;\u0026gt; 8) data[2] ^= (byte) (checksum \u0026gt;\u0026gt; 16) hostname = Base32.encode(data) || \u0026#34;.b32.i2p\u0026#34; Quaisquer bits não utilizados no final do b32 (endereço base32) devem ser 0. Não há bits não utilizados para um endereço padrão de 56 caracteres (35 bytes).\nDecodificação e Verificação strip the \u0026#34;.b32.i2p\u0026#34; from the hostname data = Base32.decode(hostname) Calculate checksum = CRC-32(data[3:end]) Treat checksum as little-endian. flags = data[0] ^ (byte) checksum if 1 byte sigtypes: pubkey sigtype = data[1] ^ (byte) (checksum \u0026gt;\u0026gt; 8) blinded sigtype = data[2] ^ (byte) (checksum \u0026gt;\u0026gt; 16) else (2 byte sigtypes): pubkey sigtype = data[1] ^ ((byte) (checksum \u0026gt;\u0026gt; 8)) || data[2] ^ ((byte) (checksum \u0026gt;\u0026gt; 16)) blinded sigtype = data[3] || data[4] parse the remainder based on the flags to get the public key Bits de Chaves Secretas e Privadas Os bits de chave secreta e de chave privada são usados para indicar a clientes, proxies ou a outro código do lado do cliente que a chave secreta e/ou a chave privada serão necessárias para descriptografar o leaseset. Implementações específicas podem solicitar ao usuário que forneça os dados necessários ou rejeitar tentativas de conexão se os dados necessários estiverem ausentes.\nEsses bits servem apenas como indicadores. A chave secreta ou privada nunca deve ser incluída no próprio endereço B32, pois isso comprometeria a segurança.\nDetalhes Criptográficos Esquema de Cegamento O esquema de cegamento usa RedDSA (um esquema de assinatura digital) baseado em Ed25519 e no design do ZCash, produzindo assinaturas Red25519 na curva Ed25519 usando SHA-512. Essa abordagem garante que as chaves públicas cegadas permaneçam no subgrupo de ordem prima, evitando as preocupações de segurança presentes em alguns projetos alternativos.\nBlinded keys (chaves cegadas) são rotacionadas diariamente com base na data UTC usando a fórmula:\nblinded_key = BLIND(unblinded_key, date, optional_secret) O local de armazenamento na DHT (tabela hash distribuída) é calculado como:\nSHA256(type_byte || blinded_public_key) Criptografia O leaseset criptografado utiliza a cifra de fluxo ChaCha20 para a criptografia, escolhida por oferecer desempenho superior em dispositivos sem aceleração de hardware para AES. A especificação emprega HKDF para derivação de chaves e X25519 para operações de Diffie-Hellman.\nOs leasesets (conjuntos de lease) criptografados têm uma estrutura de três camadas: - Camada externa: metadados em texto simples - Camada intermediária: autenticação do cliente (métodos DH ou PSK) - Camada interna: dados LS2 propriamente ditos com informações de lease\nMétodos de Autenticação A autenticação por cliente suporta dois métodos:\nAutenticação DH: Utiliza o acordo de chaves X25519. Cada cliente autorizado fornece sua chave pública ao servidor, e o servidor criptografa a camada intermediária usando um segredo compartilhado derivado de ECDH.\nAutenticação PSK: Usa chaves pré-compartilhadas diretamente para criptografia.\nO bit 2 da flag (indicador) no endereço B32 indica se a autenticação por cliente é necessária.\nCache Embora esteja fora do escopo desta especificação, routers e clientes devem lembrar e armazenar em cache (recomenda-se que seja persistente) o mapeamento de chave pública para destino, e vice-versa.\nO serviço de nomenclatura em blockfile, o sistema de livro de endereços padrão do I2P desde a versão 0.9.8, mantém vários livros de endereços com um mapa dedicado de busca reversa que fornece consultas rápidas por hash. Essa funcionalidade é crítica para a resolução de leaseset (metadados de roteamento de um destino no I2P) criptografado quando apenas um hash é conhecido inicialmente.\nTipos de Assinatura A partir da versão 2.10.0 do I2P, estão definidos os tipos de assinatura de 0 a 11. A codificação de um byte continua sendo o padrão, com a codificação de dois bytes disponível, mas não utilizada na prática.\nTipos Comumente Usados: - Tipo 0 (DSA_SHA1): Obsoleto para routers, suportado para destinos - Tipo 7 (EdDSA_SHA512_Ed25519): Padrão atual para identidades de router e destinos - Tipo 11 (RedDSA_SHA512_Ed25519): Exclusivamente para leaseSets LS2 criptografados com suporte a blinding (cegamento criptográfico)\nNota importante: Apenas Ed25519 (tipo 7) e Red25519 (tipo 11) suportam o blinding (cegamento) necessário para leasesets criptografados. Outros tipos de assinatura não podem ser usados com este recurso.\nTipos 9-10 (algoritmos GOST) permanecem reservados, mas não implementados. Os tipos 4-6 e 8 estão marcados como \u0026ldquo;apenas offline\u0026rdquo; para chaves de assinatura offline.\nNotas Distinga as variações antigas das novas pelo comprimento. Endereços b32 antigos são sempre {52 chars}.b32.i2p. Os novos são {56+ chars}.b32.i2p A codificação base32 segue os padrões da RFC 4648, com decodificação sem distinção entre maiúsculas e minúsculas e preferência por saída em minúsculas Os endereços podem exceder 200 caracteres ao usar tipos de assinatura com chaves públicas maiores (por exemplo, ECDSA P521 com chaves de 132 bytes) O novo formato pode ser usado em jump links (links de salto) e servido por jump servers (servidores de jump), se desejado, assim como o b32 padrão Chaves cegadas rotacionam diariamente com base na data UTC para aumentar a privacidade Este formato diverge da abordagem do Tor no rend-spec-v3.txt, apêndice A.2, a qual tem potenciais implicações de segurança com chaves públicas cegadas fora da curva Compatibilidade de Versões Esta especificação é precisa para a versão do I2P 0.9.47 (agosto de 2020) até a versão 2.10.0 (setembro de 2025). Não ocorreram alterações incompatíveis ao formato de endereçamento B32 (endereços base32 do I2P), à estrutura LS2 criptografada (LS2: leaseSet versão 2) ou às implementações criptográficas durante esse período. Todos os endereços criados com a 0.9.47 permanecem totalmente compatíveis com as versões atuais.\nReferências CRC-32 - CRC-32 (Wikipédia) - RFC 3309: Checksum do Stream Control Transmission Protocol Especificações do I2P - Especificação de LeaseSet criptografado - Proposta 123: Novas entradas de netDB - Proposta 149: B32 para LS2 criptografado (LS2 é o formato v2 de LeaseSet) - Especificação de Estruturas Comuns - Nomenclatura e Livro de Endereços Comparação com o Tor - Tópico de discussão do Tor (contexto de projeto) Recursos adicionais - Projeto I2P - Fórum I2P - Documentação da API Java ","description":"Formato de endereço Base 32 para leasesets LS2 criptografados (LeaseSet versão 2 no I2P)","id":"cac162c86c1b599cb6bab03e6270c404","section":"docs","title":"B32 para Leasesets criptografados","url":"/pt/docs/specs/b32-for-encrypted-leasesets/"},{"categories":null,"content":" 1. Visão geral O netDb é um banco de dados distribuído especializado que contém apenas dois tipos de dados: - RouterInfos – informações de contato do router - LeaseSets – informações de contato do destino\nTodos os dados são assinados criptograficamente e verificáveis. Cada entrada inclui informações de liveness (indicadores de atividade) para descartar entradas obsoletas e substituir as desatualizadas, protegendo contra certas classes de ataque.\nA distribuição usa um mecanismo de floodfill (método de armazenamento e propagação da base de dados distribuída no I2P), no qual um subconjunto de routers mantém essa base de dados.\n2. RouterInfo Quando routers precisam se comunicar com outros routers, eles trocam pacotes RouterInfo contendo:\nIdentidade do router – chave de criptografia, chave de assinatura, certificado Endereços de contato – como alcançar o router Carimbo de data e hora da publicação – quando esta informação foi publicada Opções de texto arbitrárias – sinalizadores de capacidade e configurações Assinatura criptográfica – comprova a autenticidade 2.1 Sinalizadores de Capacidade Os Routers anunciam capacidades por meio de códigos de letras em seu RouterInfo:\nFlag Meaning f Floodfill participation R Reachable U Unreachable D, E, G, H Various capability indicators ### 2.2 Classificações de largura de banda Code Bandwidth K Under 12 KBps L 12–48 KBps (default) M 48–64 KBps N 64–128 KBps O 128–256 KBps P 256–2000 KBps X Over 2000 KBps ### 2.3 Valores de ID de Rede Value Purpose 0 Reserved 1 Current Network (default) 2 Reserved for Future Networks 3–15 Forks and Test Networks 16–254 Reserved 255 Reserved ### 2.4 Estatísticas do RouterInfo Routers publicam estatísticas opcionais de saúde para análise da rede: - Taxas de sucesso/rejeição/tempo limite na construção de tunnel exploratório - Média de 1 hora do número de tunnel participantes\nAs estatísticas seguem o formato stat_(statname).(statperiod) com valores separados por ponto e vírgula.\nEstatísticas de exemplo:\nstat_tunnel.buildExploratoryExpire.60m = 0;0;0;53.14 stat_tunnel.buildExploratoryReject.60m = 0;0;0;15.51 stat_tunnel.buildExploratorySuccess.60m = 0;0;0;31.35 stat_tunnel.participatingTunnels.60m = 289.20 Os Floodfill routers também podem publicar: netdb.knownLeaseSets e netdb.knownRouters\n2.5 Opções da Família A partir da versão 0.9.24, routers podem declarar que pertencem a uma família (mesmo operador):\nfamily: Nome da família family.key: Código do tipo de assinatura concatenado com a chave pública de assinatura codificada em base64 family.sig: Assinatura do nome da família e do hash do router de 32 bytes Múltiplos routers da mesma família não serão utilizados em tunnels individuais.\n2.6 Expiração do RouterInfo (informações do router) Sem expiração durante a primeira hora de tempo de atividade Sem expiração com 25 ou menos RouterInfos (informações de router) armazenados A expiração diminui conforme a contagem local cresce (72 horas em \u0026lt;120 routers; ~30 horas em 300 routers) Os SSU introducers (nós de introdução) expiram em ~1 hora Floodfills usam expiração de 1 hora para todos os RouterInfos locais 3. LeaseSet Os LeaseSets descrevem os pontos de entrada de tunnel para destinos específicos, especificando:\nIdentidade do router gateway do Tunnel ID do tunnel de 4 bytes Tempo de expiração do Tunnel LeaseSets incluem: - Destino – chave de criptografia, chave de assinatura, certificado - Chave pública de criptografia adicional – para garlic encryption de ponta a ponta (técnica do I2P que agrupa múltiplas mensagens criptografadas em um único pacote) - Chave pública de assinatura adicional – destinada à revogação (atualmente não utilizada) - Assinatura criptográfica\n3.1 Variantes de LeaseSet Type Description Unpublished Destinations used only for outgoing connections aren't published to floodfill routers Revoked Published with zero leases, signed by additional signing key (not fully implemented) LeaseSet2 (LS2) As of 0.9.38, supports new encryption types, multiple encryption types, options, offline signing keys ([Proposal 123](/proposals/123-new-netdb-entries/)) Meta LeaseSet Tree-like DHT structure for multihomed services, supporting hundreds/thousands of destinations with long expirations (up to 18.2 hours) Encrypted LeaseSet (LS1) All leases encrypted with separate key; only those with the key can decode and contact the destination Encrypted LeaseSet (LS2) As of 0.9.38, destination hidden with only blinded public key and expiration visible to floodfill ### 3.2 Expiração do LeaseSet LeaseSets regulares expiram quando ocorre a expiração do lease (alocação de túnel) mais tardio. A expiração do LeaseSet2 é especificada no cabeçalho. As expirações de EncryptedLeaseSet e MetaLeaseSet podem variar, com possível imposição de um limite máximo.\n4. Inicialização A netDb descentralizada requer pelo menos uma referência de par para se integrar. Reseeding (processo de obtenção inicial de referências de pares) recupera arquivos RouterInfo (routerInfo-$hash.dat) a partir dos diretórios netDb de voluntários. Na primeira inicialização, obtém automaticamente a partir de URLs embutidas no código, selecionadas aleatoriamente.\n5. Mecanismo de Floodfill O netDb floodfill usa armazenamento distribuído simples: envia os dados para o par floodfill mais próximo. Quando pares não-floodfill enviam store (mensagens de armazenamento), os floodfills encaminham para um subconjunto de pares floodfill mais próximos da chave específica.\nA participação em floodfill é indicada como uma flag de capacidade (f) no RouterInfo.\n5.1 Requisitos para participação no Floodfill Ao contrário dos servidores de diretório confiáveis pré-definidos no código do Tor, o conjunto de floodfill do I2P é não confiável e muda ao longo do tempo.\nFloodfill é ativado automaticamente apenas em routers de alta largura de banda que atendem a estes requisitos: - Largura de banda compartilhada mínima de 128 KBytes/sec (configurada manualmente) - Deve passar em testes de integridade adicionais (tempo da fila de mensagens de saída, atraso de tarefas)\nO opt-in automático atual resulta em aproximadamente 6% de participação floodfill na rede.\nFloodfills configurados manualmente coexistem com voluntários automáticos. Quando o número de floodfills cai abaixo do limiar, routers de alta largura de banda voluntariam-se automaticamente. Quando há floodfills em excesso, eles deixam de atuar como floodfill.\n5.2 Papéis do floodfill Além de aceitar armazenamentos do netDb e responder a consultas, os floodfills desempenham funções padrão de router. A maior largura de banda deles normalmente significa mais participação em tunnel, mas isso não está diretamente relacionado aos serviços de banco de dados.\n6. Métrica de proximidade do Kademlia O netDb usa medição de distância baseada em XOR ao estilo Kademlia. O hash SHA256 de RouterIdentity ou Destination cria a chave Kademlia (exceto para LS2 Encrypted LeaseSets, que usam SHA256 do byte de tipo 3 mais a chave pública cegada).\n6.1 Rotação do Espaço de Chaves Para aumentar os custos de um ataque Sybil, em vez de usar SHA256(key), o sistema usa:\nSHA256(key + yyyyMMdd) onde a data é uma data UTC em ASCII de 8 bytes. Isso cria a chave de roteamento, que muda diariamente à meia-noite UTC—processo chamado rotação do espaço de chaves.\nAs chaves de roteamento nunca são transmitidas em mensagens I2NP; são usadas apenas para determinação de distância local.\n7. Segmentação do Banco de Dados da Rede As Kademlia DHTs (tabelas de hash distribuídas Kademlia) tradicionais não preservam a desvinculabilidade das informações armazenadas. O I2P previne ataques que associam tunnels de cliente a routers ao implementar segmentação.\n7.1 Estratégia de Segmentação Routers acompanham: - Se as entradas chegaram via tunnels do cliente ou diretamente - Se via tunnel, qual tunnel do cliente/destino - Múltiplas chegadas via tunnel são acompanhadas - Respostas de armazenamento vs. de consulta são diferenciadas\nAmbas as implementações em Java e C++ utilizam: - Uma \u0026ldquo;Main\u0026rdquo; netDb para consultas diretas/operações de floodfill no contexto do router - \u0026ldquo;Client Network Databases\u0026rdquo; (Bancos de Dados de Rede do Cliente) ou \u0026ldquo;Sub-Databases\u0026rdquo; (Sub-bancos de dados) em contextos de cliente, capturando entradas enviadas para client tunnels\nAs netDbs do cliente existem apenas durante a vida útil do cliente, contendo apenas entradas de tunnel do cliente. Entradas provenientes de tunnels do cliente não podem se sobrepor a chegadas diretas.\nCada netDb rastreia se as entradas chegaram como armazenamentos (respondem a solicitações de consulta) ou como respostas de consulta (só respondem se previamente armazenadas para o mesmo destino). Os clientes nunca respondem a consultas com entradas do netDb principal, apenas com entradas do banco de dados de rede do cliente.\nEstratégias combinadas segmentam a netDb (base de dados da rede do I2P) contra ataques de associação cliente-router.\n8. Armazenamento, Verificação e Consulta 8.1 Armazenamento de RouterInfo (informações do router) para pares I2NP DatabaseStoreMessage contendo a troca local de RouterInfo (informações do router) durante a inicialização da conexão de transporte NTCP ou SSU.\n8.2 Armazenamento de LeaseSet para pares Mensagens I2NP DatabaseStoreMessage que contêm o LeaseSet local são trocadas periodicamente por meio de mensagens cifradas com garlic encryption, agrupadas com o tráfego da Destination (destino no I2P), permitindo respostas sem consultas ao LeaseSet.\n8.3 Seleção de Floodfill DatabaseStoreMessage envia para o floodfill mais próximo da chave de roteamento atual. O floodfill mais próximo é encontrado via busca no banco de dados local. Mesmo que não seja de fato o mais próximo, o flooding (difusão por inundação) o propaga \u0026ldquo;mais perto\u0026rdquo; ao enviá-lo para vários floodfills.\nO Kademlia tradicional usa uma pesquisa \u0026ldquo;find-closest\u0026rdquo; (encontrar os mais próximos) antes da inserção. Embora o I2NP careça de tais mensagens, routers podem realizar uma pesquisa iterativa com o bit menos significativo invertido (key ^ 0x01) para garantir a descoberta do par realmente mais próximo.\n8.4 Armazenamento de RouterInfo nos Floodfills Routers publicam RouterInfo (informações do router) conectando-se diretamente a um floodfill, enviando I2NP DatabaseStoreMessage com Reply Token (token de resposta) diferente de zero. A mensagem não é end-to-end garlic encrypted (conexão direta, sem intermediários). O floodfill responde com DeliveryStatusMessage usando o Reply Token como ID da mensagem.\nRouters também podem enviar RouterInfo (informações do router) via tunnel exploratório (limites de conexão, incompatibilidade, ocultação de IP). Floodfills podem rejeitar tais operações de armazenamento durante sobrecarga.\n8.5 Armazenamento de LeaseSet nos Floodfills O armazenamento de LeaseSet é mais sensível do que o RouterInfo (informações do roteador). Routers devem impedir a associação de LeaseSet a si próprios.\nRouters publicam LeaseSet via tunnel de cliente de saída DatabaseStoreMessage com Reply Token (token de resposta) diferente de zero. A mensagem é criptografada de ponta a ponta com garlic encryption usando o Session Key Manager (gerenciador de chaves de sessão) da Destination (destino), ocultando-a do endpoint de saída do tunnel. O floodfill responde com DeliveryStatusMessage retornado via tunnel de entrada.\n8.6 Processo de inundação Floodfills validam RouterInfo/LeaseSet antes de armazená-los localmente, usando critérios adaptativos dependentes da carga, do tamanho do netdb e de outros fatores.\nApós receberem dados mais recentes válidos, os floodfills (nós especiais na I2P que mantêm e propagam dados da netDb) \u0026ldquo;flood\u0026rdquo; esses dados procurando os 3 floodfill routers mais próximos da chave de roteamento. Conexões diretas enviam um I2NP DatabaseStoreMessage com Reply Token igual a zero. Outros routers não respondem nem fazem re-flood.\nRestrições importantes: - Floodfills não devem propagar via tunnels; apenas conexões diretas - Floodfills nunca propagam LeaseSet expirado ou RouterInfo (informações do router) publicado há mais de uma hora\n8.7 Consulta de RouterInfo (informações do router) e LeaseSet I2NP DatabaseLookupMessage solicita entradas do netDb aos routers floodfill. As consultas são enviadas via tunnel exploratório de saída; as respostas especificam o retorno pelo tunnel exploratório de entrada.\nAs consultas geralmente são enviadas para dois floodfill routers \u0026ldquo;bons\u0026rdquo; mais próximos da chave solicitada, em paralelo.\nCorrespondência local: recebe uma resposta I2NP DatabaseStoreMessage Sem correspondência local: recebe uma I2NP DatabaseSearchReplyMessage com referências a outros floodfill routers próximos à chave Consultas de LeaseSet usam garlic encryption de ponta a ponta (a partir da versão 0.9.5). Consultas de RouterInfo (registro de informações do router) não são criptografadas devido ao custo computacional do ElGamal, o que as torna vulneráveis à espionagem no ponto de saída.\nA partir da versão 0.9.7, as respostas de consulta incluem a chave de sessão e a tag, ocultando as respostas do inbound gateway (gateway de entrada).\n8.8 Consultas Iterativas Pré-0.8.9: Duas consultas redundantes em paralelo, sem roteamento recursivo ou iterativo.\nA partir da versão 0.8.9: Consultas iterativas implementadas sem redundância — mais eficientes, confiáveis e adequadas a um conhecimento de floodfill incompleto. À medida que as redes crescem e os routers conhecem menos floodfills, as consultas se aproximam da complexidade O(log n).\nBuscas iterativas continuam mesmo sem referências a pares mais próximos, prevenindo black-holing (descartar silenciosamente o tráfego) malicioso. Aplicam-se a contagem máxima de consultas e o tempo limite atuais.\n8.9 Verificação Verificação de RouterInfo: Desativada a partir da versão 0.9.7.1 para impedir ataques descritos no artigo \u0026ldquo;Practical Attacks Against the I2P Network\u0026rdquo;.\nVerificação do LeaseSet: Routers aguardam ~10 segundos e então consultam um floodfill diferente via tunnel de cliente de saída. A garlic encryption de ponta a ponta oculta as informações do ponto final de saída. As respostas retornam via tunnels de entrada.\nA partir da versão 0.9.7, as respostas são criptografadas de forma a ocultar a chave/tag de sessão do gateway de entrada.\n8.10 Exploração Exploração envolve uma consulta ao netdb (banco de dados da rede) com chaves aleatórias para descobrir novos routers (roteadores). Floodfills (roteadores especiais que mantêm o netdb) respondem com DatabaseSearchReplyMessage contendo hashes de routers não-floodfill próximos da chave solicitada. As consultas de exploração definem um sinalizador especial em DatabaseLookupMessage.\n9. MultiHoming (múltiplas conexões a provedores/redes) Destinations (destinos do I2P) que utilizam o mesmo par de chaves privada/pública (tradicional eepPriv.dat) podem hospedar em múltiplos routers simultaneamente. Cada instância publica periodicamente LeaseSets assinados; o LeaseSet publicado mais recentemente é retornado aos solicitantes de consulta. Com tempos de vida de LeaseSet de até 10 minutos, as interrupções duram no máximo ~10 minutos.\nA partir da versão 0.9.38, Meta LeaseSets oferecem suporte a serviços multihomed em grande escala usando Destinations (endereços I2P) separados que fornecem serviços comuns. As entradas de Meta LeaseSet são Destinations ou outros Meta LeaseSets com expiração de até 18,2 horas, permitindo que centenas/milhares de Destinations hospedem serviços comuns.\n10. Análise de Ameaças Aproximadamente 1700 floodfill routers (um tipo especial de router no I2P) operam atualmente. O crescimento da rede dificulta a maioria dos ataques ou reduz seu impacto.\n10.1 Mitigações Gerais Crescimento: Mais floodfills tornam os ataques mais difíceis ou menos impactantes Redundância: Todas as entradas do netdb são armazenadas em 3 routers floodfill mais próximos da chave via flooding (difusão em massa) Assinaturas: Todas as entradas são assinadas pelo criador; falsificações são impossíveis 10.2 Routers lentos ou sem resposta Routers mantêm estatísticas ampliadas do perfil dos pares para floodfills: - Tempo médio de resposta - Percentual de respostas a consultas - Percentual de sucesso na verificação de armazenamento - Último armazenamento bem-sucedido - Última consulta bem-sucedida - Última resposta\nOs routers usam essas métricas ao determinar a \u0026ldquo;qualidade\u0026rdquo; para selecionar o floodfill mais próximo. Routers que não respondem de forma alguma são rapidamente identificados e evitados; routers parcialmente maliciosos representam um desafio maior.\n10.3 Ataque Sybil (Espaço de Chaves Completo) Atacantes podem criar numerosos floodfill routers distribuídos por todo o espaço de chaves como um ataque de negação de serviço (DoS) eficaz.\nSe o comportamento inadequado não for suficiente para a designação \u0026ldquo;bad\u0026rdquo;, as possíveis respostas incluem: - Compilação de listas de hash/IP de router \u0026ldquo;bad\u0026rdquo; anunciadas via notícias do console, site, fórum - Habilitação de floodfill em toda a rede (\u0026ldquo;combater Sybil com mais Sybil\u0026rdquo;) - Novas versões de software com listas \u0026ldquo;bad\u0026rdquo; hardcoded (fixas no código) - Métricas e limiares de perfis de pares aprimorados para identificação automática - Qualificação por bloco de IP, desqualificando múltiplos floodfills em um único bloco de IP - Lista de bloqueio automática baseada em subscrição (semelhante ao consenso do Tor)\nRedes maiores tornam isso mais difícil.\n10.4 Ataque Sybil (Espaço de chaves parcial) Atacantes podem criar 8–15 floodfill routers agrupados de forma próxima no espaço de chaves. Todas as consultas/armazenamentos desse espaço de chaves são encaminhadas para os routers do atacante, possibilitando DOS (negação de serviço) em determinados sites I2P.\nComo o espaço de chaves indexa hashes criptográficos SHA256, os atacantes precisam usar força bruta para gerar routers com proximidade suficiente.\nDefesa: O algoritmo de proximidade do Kademlia varia ao longo do tempo usando SHA256(key + YYYYMMDD), mudando diariamente à meia-noite UTC. Essa rotação do espaço de chaves (keyspace) exige a regeneração diária do ataque.\nObservação: Pesquisas recentes mostram que a rotação do espaço de chaves não é particularmente eficaz — atacantes podem pré-calcular hashes de router, sendo necessários apenas alguns routers para eclipsar porções do espaço de chaves em até meia hora após a rotação.\nConsequência da rotação diária: o netDb distribuído fica instável por alguns minutos após a rotação—consultas falham antes que o novo router mais próximo receba as inserções.\n10.5 Ataques de Inicialização Atacantes poderiam assumir o controle de sites de reseed (sites que fornecem os dados iniciais da rede) ou enganar desenvolvedores a adicionar sites de reseed hostis, fazendo com que novos routers sejam inicializados em redes isoladas/controladas pela maioria.\nDefesas Implementadas: - Obter subconjuntos de RouterInfo de múltiplos sites de reseed (processo de inicialização da rede) em vez de um único site - Monitoramento de reseed fora da rede consultando periodicamente os sites - A partir da versão 0.9.14, pacotes de dados de reseed como arquivos zip assinados, com verificação da assinatura baixada (veja especificação su3 )\n10.6 Captura de Consultas Floodfill routers podem \u0026ldquo;direcionar\u0026rdquo; pares para routers controlados pelo atacante por meio de referências retornadas.\nImprovável via exploração devido à baixa frequência; routers adquirem referências de pares principalmente por meio da construção normal de tunnel.\nA partir da 0.8.9, foram implementadas pesquisas iterativas. Referências de floodfill em DatabaseSearchReplyMessage são seguidas se estiverem mais próximas da chave da consulta. Os routers solicitantes não confiam na proximidade das referências. As consultas continuam mesmo sem chaves mais próximas até o tempo limite/número máximo de consultas, evitando black-holing malicioso (descartar silenciosamente o tráfego).\n10.7 Vazamentos de Informação O vazamento de informações da DHT (tabela hash distribuída) no I2P requer investigação adicional. Os floodfill routers observam consultas, coletando informações. Com 20% de nós maliciosos, as ameaças Sybil descritas anteriormente tornam-se problemáticas por vários motivos.\n11. Trabalhos futuros Criptografia de ponta a ponta para consultas adicionais ao netDb e suas respostas Melhores métodos de rastreamento de respostas de consulta Métodos de mitigação para problemas de confiabilidade na rotação do espaço de chaves 12. Referências Especificação de Estruturas Comuns – Estruturas RouterInfo e LeaseSet Especificação do I2NP – Tipos de mensagens de banco de dados Proposta 123: Novas entradas do netDb – Especificação do LeaseSet2 Discussão histórica do netDb – Histórico de desenvolvimento e discussões arquivadas ","description":"Compreendendo o banco de dados de rede distribuído (netDb) do I2P - um DHT especializado para informações de contato de router e consultas de destinos","id":"ef0a5e8bee4372a50a7f4562af717b0c","section":"docs","title":"Banco de dados da rede","url":"/pt/docs/overview/network-database/"},{"categories":null,"content":" Obsoleto: A biblioteca ministreaming é anterior à biblioteca de streaming atual. Aplicações modernas devem usar a API de streaming completa ou SAM v3. As informações abaixo são mantidas para desenvolvedores que revisam código-fonte legado distribuído em ministreaming.jar.\nVisão geral Ministreaming (uma camada de streaming minimalista) opera sobre o I2CP para fornecer entrega confiável e em ordem na camada de mensagens do I2P—de forma semelhante ao TCP sobre IP. Ele foi originalmente extraído do aplicativo I2PTunnel inicial (sob licença BSD) para que transportes alternativos pudessem evoluir de forma independente.\nPrincipais restrições de projeto:\nEstabelecimento de conexão clássico em duas fases (SYN/ACK/FIN) emprestado do TCP Tamanho de janela fixo de 1 pacote Sem identificadores por pacote nem confirmações seletivas Essas escolhas mantiveram a implementação pequena, mas limitam a vazão—cada pacote geralmente espera quase dois RTT (tempo de ida e volta) antes que o próximo seja enviado. Para fluxos de longa duração, a penalidade é aceitável, mas trocas curtas no estilo HTTP sofrem de forma perceptível.\nRelação com a Biblioteca de Streaming A biblioteca de streaming atual permanece no mesmo pacote Java (net.i2p.client.streaming). Classes e métodos obsoletos permanecem na documentação Javadoc, claramente anotados para que os desenvolvedores possam identificar APIs da era do ministreaming (implementação anterior minimalista de streaming). Quando a biblioteca de streaming substituiu o ministreaming, ela adicionou:\nConfiguração de conexão mais inteligente, com menos viagens de ida e volta Janelas de congestionamento adaptativas e lógica de retransmissão Melhor desempenho em tunnels com perdas Quando o Ministreaming (biblioteca de streaming mínima do I2P) foi útil? Apesar de suas limitações, ministreaming (mecanismo de streaming minimalista) fornecia um transporte confiável nas primeiras implantações. A API foi intencionalmente pequena e preparada para o futuro, de modo que mecanismos alternativos de streaming pudessem ser trocados sem quebrar o código chamador. Aplicações Java o integravam diretamente; clientes não-Java acessavam a mesma funcionalidade por meio do suporte do SAM a sessões de streaming.\nHoje, considere ministreaming.jar apenas como uma camada de compatibilidade. Novos desenvolvimentos devem:\nTenha como alvo a biblioteca completa de streaming (Java) ou o SAM v3 (estilo STREAM) Remova quaisquer pressupostos remanescentes de janela fixa ao modernizar o código Prefira tamanhos de janela maiores e handshakes de conexão otimizados para melhorar cargas de trabalho sensíveis à latência Referência Documentação da Biblioteca de Streaming Javadoc de Streaming – inclui classes de ministreaming (implementação mínima de streaming) obsoletas Especificação do SAM v3 – suporte de streaming para aplicações não Java Se você encontrar código que ainda depende de ministreaming (biblioteca de streaming antiga do I2P), planeje portá-lo para a API de streaming moderna — a rede e suas ferramentas esperam o comportamento mais recente.\n","description":"Notas históricas sobre a primeira camada de transporte semelhante ao TCP do I2P","id":"3a258127f502d1974fadc514a60bf831","section":"docs","title":"Biblioteca de Ministreaming","url":"/pt/docs/legacy/ministreaming/"},{"categories":null,"content":"Visão Geral BitTorrent sobre I2P permite compartilhamento anônimo de arquivos através de túneis criptografados usando a camada de streaming do I2P. Todos os peers são identificados por destinos I2P criptográficos em vez de endereços IP. O sistema suporta trackers HTTP e UDP, links magnéticos híbridos e criptografia híbrida pós-quântica.\n1. Pilha de Protocolos Layer Function Example Application BitTorrent i2psnark, BiglyBT Transport Streaming / SAM v3 I2CP, NTCP2 Network Garlic routing I2NP Todas as conexões são executadas através da camada de transporte criptografada do I2P (NTCP2 ou SSU2). Até mesmo os pacotes de rastreador UDP são encapsulados dentro do streaming I2P. 2. Trackers Rastreadores HTTP Trackers .i2p padrão respondem a requisições HTTP GET como:\nhttp://tracker2.postman.i2p/announce?info_hash=\u0026lt;20-byte\u0026gt;\u0026amp;peer_id=\u0026lt;20-byte\u0026gt;\u0026amp;port=6881\u0026amp;uploaded=0\u0026amp;downloaded=0\u0026amp;left=1234\u0026amp;compact=1 As respostas são bencoded e usam hashes de destino I2P para peers.\nRastreadores UDP Os trackers UDP foram padronizados em 2025 (Proposta 160).\nRastreadores UDP Principais - udp://tracker2.postman.i2p/announce - udp://opentracker.simp.i2p/a - http://opentracker.skank.i2p/a - http://opentracker.dg2.i2p/a \u0026mdash;\n3. Links Magnet magnet:?xt=urn:btih:\u0026lt;infohash\u0026gt;\u0026amp;dn=\u0026lt;name\u0026gt;\u0026amp;tr=http://tracker2.postman.i2p/announce\u0026amp;tr=udp://denpa.i2p/announce\u0026amp;xs=i2p:\u0026lt;destination.b32.i2p\u0026gt; Parameter Meaning xs=i2p:\u0026lt;dest\u0026gt; Explicit I2P destination tr= Tracker URLs (HTTP or UDP) dn= Display name Links magnet suportam enxames híbridos através de I2P e clearnet quando configurados. 4. Implementações de DHT Implementation Type Status Java I2P Experimental overlay Stable i2pd UDP-based internal overlay Active BiglyBT SAM v3.3-based Fully supported --- 5. Implementações de Cliente I2PSnark Incluído com todos os routers Suporte apenas para tracker HTTP Tracker integrado em http://127.0.0.1:7658/ Sem suporte para tracker UDP BiglyBT Completo com plugin I2P Suporta rastreadores HTTP + UDP Suporte a torrents híbridos Usa interface SAM v3.3 Tixati / XD Clientes leves Tunelamento baseado em SAM Criptografia híbrida ML-KEM experimental 6. Configuração I2PSnark i2psnark.dir=/home/user/torrents i2psnark.autostart=true i2psnark.maxUpBW=128 i2psnark.maxDownBW=256 i2psnark.enableDHT=false BiglyBT SAMHost=127.0.0.1 SAMPort=7656 SAMNickname=BiglyBT-I2P SAMAutoStart=true DHTEnabled=true 7. Modelo de Segurança Component Description Encryption NTCP2 / SSU2 with X25519+ML-KEM hybrid Identity I2P destinations replace IP addresses Anonymity Peer info hidden; traffic multiplexed Leak Prevention Remove headers (X-Forwarded-For, Client-IP, Via) Torrents híbridos (clearnet + I2P) devem ser usados apenas se o anonimato não for crítico. 8. Desempenho Factor Impact Recommendation Tunnel length Adds latency 1-hop client, 2-hop server Peers Boosts speed 20+ active peers Compression Minimal gain Usually off Bandwidth Router-limited Default settings optimal As velocidades típicas variam entre **30–80 KB/s**, dependendo dos peers e das condições da rede. 9. Problemas Conhecidos Interoperabilidade parcial de DHT entre Java I2P e i2pd Atraso na busca de metadados Magnet sob carga pesada NTCP1 obsoleto mas ainda usado por peers antigos UDP simulado sobre streaming aumenta a latência 10. Roteiro Futuro Multiplexação tipo QUIC Integração completa do ML-KEM Lógica unificada de swarm híbrido Espelhos de reseed melhorados Tentativas adaptativas de DHT Referências BEP 15 – UDP Tracker Protocol Proposta 160 – UDP Tracker sobre I2P Documentação do I2PSnark Especificação da Biblioteca Streaming ","description":"Especificação detalhada e visão geral do ecossistema para BitTorrent dentro da rede I2P","id":"5d0ca50c8763996448d3099a14dc36b0","section":"docs","title":"BitTorrent sobre I2P","url":"/pt/docs/applications/bittorrent/"},{"categories":null,"content":" Aviso: BOB só oferece suporte ao tipo de assinatura legado DSA-SHA1. O Java I2P deixou de distribuir o BOB na 1.7.0 (2022-02); ele permanece apenas em instalações que começaram com a 1.6.1 ou anteriores e em algumas compilações do i2pd. Novas aplicações devem usar SAM v3 .\nBindings de linguagens Go – ccondom Python – i2py-bob Twisted – txi2p C++ – bobcpp Notas sobre o protocolo KEYS indica um destino em base64 (chave pública e chave privada). KEY é uma chave pública em base64. As respostas ERROR têm o formato ERROR \u0026lt;description\u0026gt;\\n. OK indica a conclusão do comando; dados opcionais seguem na mesma linha. Linhas DATA transmitem saída adicional antes de um OK final. O comando help é a única exceção: ele pode não retornar nada para sinalizar “nenhum comando desse tipo”.\nBanner de conexão BOB usa linhas ASCII terminadas por quebra de linha (LF ou CRLF). Ao conectar-se, emite:\nBOB \u0026lt;version\u0026gt; OK Versão atual: 00.00.10. Compilações anteriores usavam dígitos hexadecimais em maiúsculas e numeração não padronizada.\nBOB Version Router Version Notes 00.00.100.9.8Latest defined version 00.00.00 – 00.00.0F—Development builds ## Comandos principais Para obter detalhes completos dos comandos, conecte-se com telnet localhost 2827 e execute help.\nCOMMAND OPERAND RETURNS help [command] NOTHING | OK \u0026lt;info\u0026gt; clear ERROR | OK getdest ERROR | OK \u0026lt;KEY\u0026gt; getkeys ERROR | OK \u0026lt;KEYS\u0026gt; getnick \u0026lt;tunnelname\u0026gt; ERROR | OK inhost \u0026lt;hostname | IP\u0026gt; ERROR | OK inport \u0026lt;port\u0026gt; ERROR | OK list ERROR | DATA... + OK lookup \u0026lt;hostname\u0026gt; ERROR | OK \u0026lt;KEY\u0026gt; nick \u0026lt;friendlyname\u0026gt; ERROR | OK outhost \u0026lt;hostname | IP\u0026gt; ERROR | OK outport \u0026lt;port\u0026gt; ERROR | OK quit ERROR | OK setkey \u0026lt;base64 destination\u0026gt; ERROR | OK start ERROR | OK status ERROR | DATA... + OK stop ERROR | OK Resumo de descontinuação O BOB não oferece suporte a tipos de assinatura modernos, LeaseSets criptografados ou recursos de transporte. A API está congelada; nenhum novo comando será adicionado. Aplicativos que ainda dependem do BOB devem migrar para o SAM v3 o mais rápido possível. ","description":"API obsoleta para gerenciamento de destinos (obsoleta)","id":"97b881216518f8e2516b859bbca19c0b","section":"docs","title":"BOB – Basic Open Bridge (ponte aberta básica)","url":"/pt/docs/legacy/bob/"},{"categories":null,"content":" 1. Visão geral Um transporte no I2P é um método para comunicação direta, ponto a ponto, entre routers. Esses mecanismos garantem confidencialidade e integridade enquanto verificam a autenticação do router.\nCada transporte opera com paradigmas de conexão que incluem autenticação, controle de fluxo, confirmações de recebimento e recursos de retransmissão.\n2. Transportes atuais O I2P atualmente suporta dois transportes principais:\nTransport Protocol Description NTCP2 TCP Noise-based TCP transport with modern encryption (as of 0.9.36) SSU2 UDP Secure Semireliable UDP with modern encryption (as of 0.9.56) ### 2.1 Transportes legados (obsoletos) Transport Protocol Status NTCP TCP Replaced by NTCP2; removed in 0.9.62 SSU UDP Replaced by SSU2; removed in 0.9.62 --- 3. Serviços de Transporte O subsistema de transporte fornece os seguintes serviços:\n3.1 Entrega de Mensagens Entrega confiável de mensagens I2NP (os transportes tratam exclusivamente de mensagens I2NP) A entrega em ordem NÃO é garantida universalmente Enfileiramento de mensagens baseado em prioridade 3.2 Gerenciamento de Conexões Estabelecimento e encerramento de conexões Gerenciamento de limites de conexão com imposição de limiares Rastreamento do estado de cada par Aplicação automática e manual de lista de banimento de pares 3.3 Configuração de Rede Múltiplos endereços de router por transporte (suporte a IPv4 e IPv6 desde a v0.9.8) Abertura de portas no firewall via UPnP Suporte à travessia de NAT/Firewall Detecção de IP local via vários métodos 3.4 Segurança Criptografia para comunicações ponto a ponto Validação de endereços IP conforme regras locais Determinação de consenso de relógio (NTP como backup) 3.5 Gestão de Largura de Banda Limites de largura de banda de entrada e de saída Seleção ótima de transporte para mensagens de saída 4. Endereços de Transporte O subsistema mantém uma lista de pontos de contato do router:\nMétodo de transporte (NTCP2, SSU2) Endereço IP Número da porta Parâmetros opcionais É possível usar vários endereços para cada método de transporte.\n4.1 Configurações Comuns de Endereço Configuration Description Hidden Routers with no published addresses Firewalled Routers publishing SSU2 addresses with \"introducer\" peer lists for NAT traversal Unrestricted Routers advertising both NTCP2 and SSU2 addresses on IPv4 and/or IPv6 --- 5. Seleção de transporte O sistema seleciona transportes para mensagens I2NP independentemente dos protocolos de camadas superiores. A seleção emprega um sistema de lances em que cada transporte submete lances, e o menor valor vence.\n5.1 Fatores para Determinação de Lances Configurações de preferência de transporte Conexões existentes com pares Contagem de conexões atual versus limiar Histórico recente de tentativas de conexão Restrições de tamanho de mensagem Capacidades de transporte do RouterInfo do par (metadados do router) Diretividade da conexão (direta versus dependente de introducer (mediador)) Preferências de transporte anunciadas pelo par Em geral, dois routers mantêm conexões de transporte único simultaneamente, embora conexões multi-transporte simultâneas sejam possíveis.\n6. NTCP2 NTCP2 (Novo Protocolo de Transporte 2) é o transporte moderno baseado em TCP para o I2P, introduzido na versão 0.9.36.\n6.1 Principais funcionalidades Baseado no Noise Protocol Framework (padrão Noise_XK) Usa X25519 para troca de chaves Usa ChaCha20/Poly1305 para criptografia autenticada Usa BLAKE2s para funções de hash Ofuscação do protocolo para resistir à DPI (Inspeção Profunda de Pacotes) Preenchimento opcional para resistência à análise de tráfego 6.2 Estabelecimento de Conexão Solicitação de Sessão (Alice → Bob): Chave X25519 efêmera + carga útil criptografada Sessão Criada (Bob → Alice): Chave efêmera + confirmação criptografada Sessão Confirmada (Alice → Bob): Handshake final com RouterInfo (informações do router) Todos os dados posteriores são criptografados com chaves de sessão derivadas do handshake (negociação inicial).\nConsulte a Especificação do NTCP2 para obter todos os detalhes.\n7. SSU2 SSU2 (Secure Semireliable UDP 2) é o transporte moderno baseado em UDP do I2P, introduzido na versão 0.9.56.\n7.1 Principais Recursos Baseado no Noise Protocol Framework (padrão Noise_XK) Usa X25519 para troca de chaves Usa ChaCha20/Poly1305 para criptografia autenticada Entrega parcialmente confiável com confirmações seletivas Travessia de NAT via hole punching (perfuração de NAT) e retransmissão/introdução Suporte a migração de conexão Descoberta do MTU do caminho 7.2 Vantagens em relação ao SSU (Legado) Feature SSU (Legacy) SSU2 Encryption ElGamal + AES X25519 + ChaCha20/Poly1305 Header encryption Partial Full (ChaCha20) Connection ID Fixed Encrypted, rotatable NAT traversal Basic introduction Enhanced hole punching + relay Obfuscation Minimal Improved (variable padding) Consulte a [Especificação do SSU2](/docs/specs/ssu2/) para obter todos os detalhes. 8. Atravessamento de NAT Ambos os transportes suportam atravessamento de NAT para permitir que routers atrás de firewall participem da rede.\n8.1 Introdução ao SSU2 Quando um router não consegue receber conexões de entrada diretamente:\nRouter publica endereços de introducer (nó introdutor) no seu RouterInfo O par que se conecta envia uma solicitação de introdução ao introducer O introducer encaminha as informações de conexão ao router atrás de um firewall O router atrás de um firewall inicia uma conexão de saída (hole punch — perfuração de NAT) Comunicação direta estabelecida 8.2 NTCP2 e firewalls NTCP2 requer conectividade TCP de entrada. Routers atrás de NAT podem:\nUse o UPnP para abrir portas automaticamente Configure manualmente o redirecionamento de portas Confie no SSU2 para conexões de entrada enquanto usa o NTCP2 para conexões de saída 9. Ofuscação de Protocolo Ambos os transportes modernos incorporam recursos de ofuscação:\nPreenchimento aleatório em mensagens de negociação inicial Cabeçalhos criptografados que não revelam assinaturas de protocolo Mensagens de comprimento variável para resistir à análise de tráfego Sem padrões fixos no estabelecimento de conexão Observação: A ofuscação na camada de transporte complementa, mas não substitui o anonimato fornecido pela arquitetura de tunnel do I2P.\n10. Desenvolvimento futuro As pesquisas e melhorias planejadas incluem:\nTransportes plugáveis – plugins de ofuscação compatíveis com Tor Transporte baseado em QUIC – Investigação dos benefícios do protocolo QUIC Otimização dos limites de conexão – Pesquisa sobre limites ideais de conexões entre pares Estratégias de preenchimento aprimoradas – Maior resistência à análise de tráfego 11. Referências Especificação do NTCP2 – Transporte TCP baseado em Noise (framework de protocolos criptográficos) Especificação do SSU2 – UDP 2 seguro com confiabilidade parcial Especificação do I2NP – Mensagens do Protocolo de Rede do I2P Estruturas Comuns – RouterInfo e estruturas de endereço Discussão Histórica sobre NTCP – Histórico do desenvolvimento do transporte legado Documentação Legada do SSU – Especificação original do SSU (obsoleta) ","description":"Compreendendo a camada de transporte do I2P - métodos de comunicação ponto a ponto entre routers, incluindo NTCP2 e SSU2","id":"5fbac972dc212081634c49c5e6ac0004","section":"docs","title":"Camada de Transporte","url":"/pt/docs/overview/transport/"},{"categories":null,"content":" As versões 0.9.57 em diante são assinadas por idk. Sua chave pública atual é: Baixar chave pública PGP As versões 0.7.6 e 0.9.56 são assinadas por zzz. Sua chave pública atual é: Baixar chave pública PGP -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 Criei novas chaves GPG e subchaves e assinei as novas chaves com a chave antiga.\nChaves antigas:\npub 1024D/A76E0BED 2005-12-16 Key fingerprint = 4456 EBBE C805 63FE 57E6 B310 4155 76BA A76E 0BED uid zzz (zzz) \u0026lt;zzz@mail.i2p\u0026gt; sub 2048g/74C8122D 2005-12-16 Novas chaves:\npub 4096R/EE7256A8 2014-05-08 [expires: 2024-05-05] Key fingerprint = 2D3D 2D03 910C 6504 C121 0C65 EE60 C0C8 EE72 56A8 uid zzz on i2p (key signing) \u0026lt;zzz@mail.i2p\u0026gt; uid zzz on i2p (key signing) \u0026lt;zzz@i2pmail.org\u0026gt; sub 4096R/1AE988AB 2014-05-08 [expires: 2019-05-07] sub 4096R/01B5610C 2014-05-08 [expires: 2019-05-07] sub 4096R/59683006 2014-05-08 [expires: 2019-05-07] Usarei as novas chaves da seguinte forma:\nEE7256A8: key signing 1AE988AB: email signing 01B5610C email encryption 59683006 release signing A chave de assinatura de lançamento será usada a partir da versão 0.9.13. Esta mensagem está assinada com minha chave antiga.\nzzz 25 de maio de 2014\nNovas chaves seguem:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.14 (GNU/Linux)\nmQINBFNrjZsBEADMHWiucM8ES5VDfq6n4M9DJhMyG5jVoakzSFHfzVOEpHeDYR1E eaEIFt5CEx0mbpXWy6UBoj0E7o3se5RvF81VQQ4xO0MyHZLkpotGffZo7D34uKTd 1SFbirosXwnsOxjPGLF+PuwifV+mzSoE66XRmg5UJbOJj0ZitYBn4lDKMxU1Rext WX7D79qnJW2GXv/HuzTwZ/KV3fOVB782+fNdFBDZt4XHSM32ideXedTtTJ+FXjBv 1/eQ/Ls8PMYKaYUm/j0oTI2A5aNP+6BH8/NrVvF8xQWCibrOILASWFRJE7insciJ m9eeEPPOp1D4fRDWFyjABcn00fv7T7RDBgIdpuj3gBDvGXgx8SRiWxe9CwV9TcJl WNPTAKd9XGHT13XWwc1myO/yg+yQoJB6HO1jGjqxQuu3aHCw2i4gTHflq4qZoSDV oxJWeh+mNsfx4DgmoT1UeEmh2Uq64czMGh8wJC0FqSa+FmgCKa1FxcTnYlfIjR79 qwbEKK3JZ5PPkiK5Lh4hNvkXKLrUXpG1KHm6yNVPNIWCOMd7VCDziEhsbeNPCzQc 6af8dkyI9BUeQD3fGjeHCh/QHLju9Lde77GDddYaShXVI/Wiy4AWgN0KVUk8CnEZ Uu2JbazpJBLGGiB2CujP44eJzm9VPoBx8Xc9/Pk2RFbz2bN4uQtSD6lAjQARAQAB tCd6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6ekBtYWlsLmkycD6JAj4EEwEC ACgFAlNrjyYCGwMFCRLMAwAGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEO5g wMjuclaoxkEP/RQRz7kWfCWcDWtKSxq1zA3HEUKUHLxhBIl1C+tmMtJypyWwiP8Y hrO/Tuk8nsnVOl9wMMtz2ZxMpUS2gTsuquZ6pIUCNtEP+IAuKsZlCcsNB+yOoi2T i71cXLBPcN/rbxyoOUMpk+fJgdsustUnSMbXJQ2sLjieurD/YpUMJZw6KoNVrhU1 1nDaJqAq/zouhSvNMvx5+GBodQ41gvtb984xbrNc8B24upCBHSF1olczWYPUtaAi oMlZTNr5XFS//Q8X3sEKAoRMbAX6UvZVdtgqQajGilMg+HM3HnbPqsHoyPWx4f8O n134ITgrVwL24y+m9XHfY+JPjcBgg9uGLuLJqMrrjYfz7jVdUJQUsy/R2+yzg1Bm Ruf3SBhHpG2dSBOTxi9GD4aL/7wXuXj9uIuFtX80EwsT4XifnIaHTdtNNzVO+obF dJyiIpF1IFmFOTgJ3ba9gcILQIWXGIp1e5C8g2MtuYO/6/jZK1lhFCLbvhpA9C4q uUp6/WXnavd3beKltkzL1v2dOjC1EkjrsFF50olV4f3d56JdS7JEnFzx7gVeSQfF uLR/t22CluxzubcYoAk/hdIWM2Ufi6v6ONVWc7D5nYBW9onNRKEquA/qOHZr3C/M QbRxTYyhaMW4Nrwck9jmpcQBE1EzscX3DAr+3W+rnKDCZL5QuI2Yq5gkiEYEEBEC AAYFAlNrl+YACgkQQVV2uqduC+1XMwCcC24MIzSxDOEpX7c/ecTKm18bOQkAmwU9 WqqUgT37bQ+U9ME322JPrBsitCp6enogb24gaTJwIChrZXkgc2lnbmluZykgPHp6 ekBpMnBtYWlsLm9yZz6JAj4EEwECACgFAlNrjZsCGwMFCRLMAwAGCwkIBwMCBhUI AgkKCwQWAgMBAh4BAheAAAoJEO5gwMjuclaobxQP/0oU+/nhTx7NRUZ3Ay/LzD7v DHqX+A1iPos1Xzmz+vq9a7z/mjjiQn0wfFiMctFc5dRf+hSM+W7BUfcG5rML+416 rEgtCDsQ0KfaFYUPRObxxNRdDv4N0j6uw2hFmAZ+KkOxKf5Z5CV7A2dwpjsO+PSc Ed0BM1iAjzNbod5b5uAn6r/Z43GSH2omRdhE8Ne5UrH58kLFSg8+iAfnnV5SSEKo bkP0f5m91esbh+vAgq0nFRsB8PeBYklw20wnAkIy6rmKJngBpiF0KfC/V6NY3g63 NDqf4wbSO8WqnrS9QWqYFzJfDsARQvx3jBqLTcQ4SlpIVWKNeogkeSeuqCVKRgvN jWBHdfABkf+DHrzlf072PK8RtDZn6wn1D91MeFCvg+Ss6XV2d0JEd+bxdK6Aj1RR X4XGv0jcH1Ftm9JRNjzXsALzndvwvEKU2xgDA2LATA7ikKbIq19VoTf90uc7i1Os 6cOXZkezZatyuJzJITGeq4llek+PVFxU/5LnRLr6h6K5D0/5F9KlgtPJKgSDOipp TN1Vof8f+v1/zWmyxpw9jtkNjM9chtOY7xhQfNxQLZuHXjQtDT3+JGo6/gTqj105 Yg+HNTJjkDYl2Y5AHb0WFHUFSn2GiBtot4V/g2ojMeQIiw2a8v17H6HUZSKYBjgR L7ln7O4oBduvaSSyZE2jiEYEEBECAAYFAlNrl+YACgkQQVV2uqduC+3d7ACgpRpk 13FSAhz/RpPnqYwRSFUiQTsAoIewgMNIxgbPQGUVDO3FpzChAfUruQINBFNrj7YB EAC8GDV5JcAcktMYnUbPxpydlWSDzzBaDUvbOAtWbrmkwQUXyij0O4ZW1W81e0R+ APT26TLuqc6Q+v6b0rWlVoZkSKYaqzm0S3mtLWUvEgPjHfYXT7VaHtzu6QUPwmVa w+o8dxkbajl5C1i9CZyr8ACziD23FSPA5nd/WQ18EAbnIjnT4cV9dP7lLqZAWtzE Cp3ze4ZHt6kg5i6rhJBJWbycHAZK2SMclC37S6MtZAwW0pJJwn/qdj7UvmL72QoV qXNHe8dfKfnxzo0/HoCKn4rlIW0W3xHgqy6VQUnyigL0blrVmxzcH5bgttXr94yh MVV1Kg9ie1GfhPf1ui86NnGHczbZB2TmTc/d2Nl1/L3TwxiWX2fv9BF+mVczRiXc 9FZRTF5JsBN0BAyxIE9vDXK/yygiWRSD1ND/0eTmKJRqOplpXoCBSDCsfvFN6/63 mx70wP92bNMmDZ/zbjFApmbMCjf+0wCZljiBtkNgT4k2nOYjb6Kt+vOeEg1XBTqo WREHEUA23xsu2DMH5Ra0OA0NwA9jrp1dg4t7fKIkSlBLNlIsZ73lNV21uuA8lVFR KHRX7y394c5/T9c8zPtJSmIZnAY52KXBFfsM3h+ExaQIWclyU375kYi0IBE9tCfF 7VuX1JgvA/9SjjtgfEWWLkhkPUAUl82e8SYQRx5Ki3RIvQARAQABiQREBBgBAgAP BQJTa4+2AhsCBQkJZgGAAikJEO5gwMjuclaowV0gBBkBAgAGBQJTa4+2AAoJEA6+ gRoa6YirbtsQAKheBU6M3oAfyAJ7i13mPEY2EvZFXdY41ct89ebdLCe4revG5Tao Fj/OmD0W+eBvRbJvOglw+0wYjpjAsnl95kYCBRL/BAr9xWt/g9SCcQqxOaYI9gM0 pFAcPjicEF44xdSMDSWGpN0PT5M6omlz5EObxuU3vaZ8y2XWYdvW8p1AwST66y/M AoACZqJUsIo7HIsz607XzNa3evIkCuGGNbTrD0OCTNUxOhwtqMIt3bHE2h4I8Hwp hptTf2eDf2z587/32gs3yp/VAeP6dCeQF3+Wduc41aRsCru7HnE2w/BiW1nzePyK 6b3RA56bZcbANIS8k/+EVOakS4uRDnweqkwBVgkWsCk17+XNeIaRaY0pWJaFs+hO f7cdp/XK+z2eFO1brEJa3BmnHHMx/lUv5YS8MgD+CcdvHvb2dirthzvyb6yDKFNn ZkMz3/Z1wnlDkMp/fjJAwXfmKT7IOqPVN5fpLcXp27Jh2BSrafvLupkIzZhrGL7R hTg8X83rLuQ0ZSn8k9cFju1pECI1atXC/kPMlSC4VffoViqwSZDLFsniFSNTaBOw EfKCLxv4s0BNovaUQfY2DUkL2BHrU18HbpGkaD3Gmb6TnzBYRTWSz15/9w8cjOc9 rr9d5SZaUeMZkGmlUdEG5q43b0MwQxYSA4Y3ZZGMgbjzEa83YN2njV7U07MP/1C2 D/tpWM2SliCGQ9ioPZVnwB43sme7J0GWjLRR085Q8+4V3/buWNG0UBc+l3MNlO0m N/zPp8ZqKCe6tLIXiExgiMSfcv9/7G3AgKxfzY+t3wFC6ISZiG5JFQIx/NI6zR+F RPUXUf8ZWH+i49p3UY564wULQMLobMuxhO2+BkjZKPkHAiXB0FTdP9WW/Gt2vWgZ L6ogdmo2bo2BQCU0VOOlCp8MxL9MlQ0FGURT/2kGoFzNFUo63UGvJc2iFmICI//9 OGBkpEMuPGrZI9W/4NTh+yMYj1b176IssWU2PWvhpempaXbcgXnlZQ5x6qcszzrw m403O814RLkIljRdtjHWOJKygXpjj8qTbDFfLXWDZ6MTtZOgFOPHFpc+Drbyzgu0 Z3dpXBeoyXQaZGOtClVJTCUYMjE6AaWZrnvsjT2TSxK+oy4XXzI4vVvDMJh2Ibfs YKiRahGQnBiYEMIrefoj/wu2GaZ71y8P6tCfdvlv9DikIVTHajdG4G2K7Sr4glgk cB9M2IsSy7bw2OGrGFvkpqriL1aYvIF5Wf4KIsxpMZ2FIUeGP4YfT3ec7zfSC5bp /yBP8J/XXaCV8NkhLF4bD9tU+XRRK54LZkoDrJwmTreHknluF6hFuJl8d0+oHyjp kHp\niEYEARECAAYFAlOB3xkACgkQQVV2uqduC+3+UgCfYZiUtx7FDGdQDhdVP8MyRf0D ANIAn2YHOQh4yv84u2Kuars1gC0j3Nr2 =Zu9F \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; Versões a partir de 0.9.9 podem ser assinadas por str4d. Sua chave pública atual é: -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA512 Minhas chaves públicas atuais são as seguintes:\npub 4096R/0EC51FCDA94FB53E 2014-03-11 [expira: 2019-03-10] uid [completo] str4d (http://str4d.i 2p) str4d@mail.i2p uid [completo] str4d str4d@i2pmail.org sub 4096R/1CC61D9B33C3241B 2014-03-11 [expirado: 2015-03-11] sub 4096R/803DEE491A3473E7 2014-03-12 [expirado: 2015-03-12] sub 4096R/A1B84C9B733AAC82 2015-04-05 [expira: 2016-04-04] sub 4096R/13B5EE58C09FB3E0 2015-04-05 [expira: 2016-04-04]\nAtualmente uso as chaves da seguinte forma:\nA94FB53E: key signing 733AAC82: email encryption C09FB3E0: email and release signing Eu gero novas subchaves de criptografia e assinatura anualmente. Qualquer lançamento do I2P assinado por mim será sempre assinado com a subchave de assinatura mais recente no momento do lançamento.\nstr4d 20 de novembro de 2015\nAs chaves atuais (a partir da data acima) seguem:\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; mQINBFMfofkBEADlyw6v1hGBtnIISujt/18RJcVTLAxYtfe3DsGhWqYZN3iKGGWb NJ5vZcV65FVH/70NFnmKlvYp+tVNJcoRtEYpfwiNG7nIyOC4GgaSLwkNVgLcFZhV mNj2RIJphjN5qsWm6ut9p9CyhWkVNJYDP65gqwShZQ2lPboo9s0XjUF78SrSshy2 iVij0xu6oqdjwqn1B7L3lXVYCwxReCvSdFnBMpjGUEgGnbt7euhrViFk8FrUkAje 2tZA5FAUA/t2Mnc9JREe6WlbZ44mLApOjFdw0g415FdcnS2GGaYuXNG1lJ1yOA33 n9JXT7A31wPyiw5yz7fxgl7ZNYZr2TsRjBlqEhf2SCPfqU9UlhJ9NqApaPyCEr+8 oZQfZ9r6stc98MlnmdQ7p4SmKRwCLiBtgmrB8mbgYV+iOwaKztqEoma3FoO2EJ+j Gx+UrJ0bIFVr6sL0ulfneYlY76wWWRpB/pLLgIMmZw83uB+JDBQyZFXcAHj9jMQ7 ZNn0MNQ/I+qcmX+CRAyl2+cQHUVbbQWDjB3crZlpK5TGw/x7w0YxBYAH8Us5JqJH QOsact8ADnE4IiKm5gVefFmNX6vsljkNESdpAMxnB7Ckl2XV/r5sKwrdxxUbFSxp IKGx2uKGUs4oUffOzpKULhGBWypN+3fVwvP+q896Il9hgyx6SCQ8AgPHRwARAQAB tClzdHI0ZCAoaHR0cDovL3N0cjRkLmkycCkgPHN0cjRkQG1haWwuaTJwPokCQAQT AQoAKgIbAwUJCWYBgAULCgkIBwYVCgkIAwIEFgMCAQIeAQIXgAUCUx/ZQgIZAQAK CRAOxR/NqU+1Pk9EEADHdpsmrA6ZKU4EmBZNbw62D7tAo00Fh25m8OuIkXtOqEbF /guTZiZM4nbhZpPFG9sCN1bXS8VslA7isOedbznkKnSK0BJcrzldwKzW25cwptoQ CCqTUarYbhcIzEOKNetYqICWrVTy2Yuc37maA66PnRLphV7pP3Fj7eN6aMtqwtpJ YukIU4LAjKOMJ6gwy7tjsZYbAqgSE8wRJm7i1MfO1W864a1l2a68Gooz03NC6mfY J8aW0y1F87xMJIgZeN7OyHf2AC4/Tp/cL+Gd3HcUuoRjmWBgaxH8tVNgfxSIUMNH 5pTdDs5VlRolwlOEcTW5VxOSu5C7ZbuKyFmbI0DSevDVGS0rxSSizjlyGmnxkLU1 ozpeIwTbwTUzvd26+k8cidGodKqoNoyAXzjaiBXYKgIrVeXBMHxCGeQtGeEhQR+L OXs8cEX6xpt9g7nKbNki0Cfv/lx9Byn+0v9RvMJKDa1mOSKbNOx3NJ8+ewdTVkTs iYFTZwpJexbfovPYqTdisiO7dv0i5teE8sEj25icdPtKYvn/55JCT67E8MVZaeyU YOaMPtgsiOX0v68NtrC1L37UuBykQlm7FdobN4Sg5FnLTt4IWktf0/vsaLdhRozD KsbTmsumCrScAwZfa0H3S8WqK6yCEKjPi+J4xG1OZP1WptlV41wLnFKkeFaZRIkB HAQTAQoABgUCUx/Y+AAKCRDV3jiWlKRlsmU0B/96eiPHIIvapoXKoZSt23OFjXG+ 3xp/Zzf2Ug0384FYZJ1eX/R2IWsh64CVvOR0LMFvHvPU7SCMu2OreNHfPx/B/kn8 MmusGy6JHP25A4BWzs1eeyKgYQTFz7vSCeAnytmcdBot1s099upIRw4usCLhdxzv Qyx6TogAacGC3YFj7o0agz+ApPnCQZ68kZpDOCDrtOe/DRted1LLXM661Cp15d5R d+91ZSKfQ9xjK1d2k8iMYJqWYll50DalGtzPGDB335gX7agliI5dYiu2XSLyynhw /7f8d0Bz8KVj7pgCroAVjTSdHvZfVcZJU4HST/jHx5hilVUzkr9NK5YONJ8SiQQc BBABCgAGBQJTKlm2AAoJEPvivaOtdGgqmGAgALl0eAcUSF7IuloPT4VyJeNGMuOb 7aN4yYrGBM+y7Ij/dTWSS1yjlcixsqd+s0dqGse6RtJkyhkisEmNdS7Sf62okGDl ZbmhjvMQteUO1zw+CREdfx5oMpW/eCHq/Pzw8KRdp6qY0wBRj10GFMAaMX8XCNOh 6B6Ti0AQ/424yEvcPpA0zXwvLGylFozRxjK6qWEHEmW/+knxYYN/W+8TERuwVJSN F3jBYl73DTVBZ4bzpu5jMSydhRD02nV2LbnolhbCzGllLkhQw6iFW36br8600Tba loQhcJU+cmuCId/B6xXcF+fyWqmMmm+b0UFoHGRBnXCf4gBcjCK0UwJ1lUOTY5qg IYJTrBpCrGAoGTd9s+1CtnnZFlIcwFJB7NwMZEsTWvOvO6sZPYP33ktcUwWAKqNj 3sSjy43kdfUeVip0jzV0K5uStC+DiVq8VwH7uNIH2UbkQZato67WgShUCCaSvf2p HapSRdrmwIaoANQuEluhytdafX7yqJXGkhYI0Ylh2FH3oZyTnz1XoB5y5T1OpFpi I7CgjRO677aieRsf6HACHPX5mWcq8zJQ8fuxoHZ5GJ8FEyk6ULUgFJ3u9SgG5k5I vP4pK8+lP/d90Zf98Uaq4aMgAoIlrtwz68Bv/KUlpwVWhiIgo89C5UwcTUNQOmi3 0PxCpamM81NwGPxjZAqr/+0YP3NBtJOITL0oqRCxcHCJ9N8gmqUmUEgEffP+glsJ p/mQeJEacmR9loz6WAB6GT9mu5TvX6bZ5EawnluQ1mI6Tn+v6ltjhKzPzaVhOo6d iKriQFZhcelX1qDnE3zs7driBeacuKGt4URV8A+UDGJBeIAEfrlszor3FQ0qOUPs plbcbB4YudUOhlH1REtGx7zWVFefuy80ZC7abHsPhWkJow2axWlvPqjSsd/KgpjG IAHIZxiYAozNJqDNluGx1+qa1d7/YINthZKefhkG3XDLuhgxvD8rAovyAFW/8Vy0 S+GpzUVtC8HY9FZf2gRkVtZQGboZck2uFyIaU/Ni4ahX8Z9IvtsU9JPLzp0HRgAv 9kz9EyRZt1viueeIVcmadHirUe1IKqndeslcXOX4dUF0nrqP1+shYhebgq93rMPR yH3EsoXtAP1KCN8tWPdnlDnMY0Zpy32mfCL0hMMnH+CY5rARssSbiFP9HeWk/CN+ yES7FY705QmV/2SV4rEngqnIcrcqEJFp49JPihC1pSikHCItzSVFaODbUl4qhTjn Tjtl0pdFQc9ksA/6IEOH/bufDwtxCLwAjUpqyNGEH/8FnxtwotsTmhmTWMe9vxYe YStdTLkAvJFMVEU0W+H2ZZG481P5/8tqFS9cHEU++3VvuYxfipwjpIQhm5WJARwE EAEKAAYFAlMuEVwACgkQq+DDGd8KChpPGwf/QL66k12OzqI40KQL+UbzW25vxbmE OyZ1MT9SuUVt6Th9zdoNm9Cosi9kOiq+DPLFFT751Lmm1hcM0rDDNeN+l8wpLwX9 EifD/bQ7Q5esM8NJmGVyhA/Cd3wkp5yYNdZPOu9/0xpe/Px4YgficRErhgyVh2Vs svQRQ0WcTYbgbmQFpOUsjNVOchJMFERSJaQxWgN3olYd5DTDxPDLztt3vdBCIkz0 4OAotZqbqdnmvlkjKjzrJylfCkyo9bOU471v6Hs3mfUQXo9nXC9zGETFWsvB4WCC QdWEyj+2K+PcdZU0FEPonfTouVcsR9oTqQqqfg21M7HUHSmlrOyCLqNnZ4kCHAQQ AQIABgUCU2vk5AAKCRDuYMDI7nJWqGIzD/9vdI3uUUYGCaURAprGEo4kk6JP2TcS AmyO9Pr8bBdpmt/DVFK0zWllQ+69QAWLFoCmgjOgWUPRNWA+ldG5lzExjuuP38P1 4HupPMh0yOd+QUod4Gdi+hqPCuFT4/oErWZcOGGXAw4ZcvdEGKY9E975D+3yd7sG HGskvGB/UmLIBQ2XfQOoqk0A9eXz55wLN1ia1imHd/0NkPkQOHkjTdOtHhcBhuoc ttex9HcmYy2g5oorG+7wx0EtHxIhuCcRq1wQgXm2JtbiFHXiH0MpLfBr29kpzH7y 8jompGgAJsK8uRwTC8UFWHnx0VxnFQ+4vinqlgj7/O+WMZ/siDlOZDo2RC3ts+Ct 91kYNFHsycrkJYuoPzNcMy7mmixQFj5L2VIG1Ne3OTdEPVWE5jIQ/w5IX0aYxNt4 ANIZJA/r1AqDqDEhto6gdnkrVZSJN+Mvd7yj7XTbrErpTmQeNkGgb9ult4XaEOdm bjAjE6rTQqFD3Tn8SeXNgkJFr0Zb8lZypmOL6cxU4vTG66blJPLZGuaH3yCrtA1i ynZPrV2TYiET+fhg2TBEXbjLkWHQnA+7sFFOTgK5WOqc6vK29h5ssEQKIFodDh4a e88tiGLW9lSc+YWRpKHgEc8QDXIuBrV18hZEvbITvLZnnf5uIFXJV5ZCHG+o6I+Y jQrPY4oC2HGrMIkBIgQQAQoADAUCVRRYygWDB4YfgAAKCRCFZ1M6Yr7+XbxwB/42 Kbk6DpZueEK0qtdoLUh7H+dWfwA0Gsh/vCoS6RM9iXjKPBoQGlbCBpsBpqCJkGd/ iXH+tnkU2dq4BvGc/igSHadNYmYq077l1vu3pJjDjxfQ2qZSF9D27EUzlXLd4Q6s hysZ18HoTehxr3AG33N1tEm9kBUfZjeMZxk7zbty3Lo7tK/UYN+4mIgYqLc97XIe 40Z\niQIcBAEBCgAGBQJWT6iBAAoJEBO17ljAn7PgnxIP/RevbXaCm2Q3ildI0YLjQFDr vSIGKsCjD9nZY3ETk+CNFGOL4aYWp96HWuQoMq7B6qlb/sLejN/Ssu3M0sxf2hNK pCIagZClqRchSBK+0UpAEIs98sf0sPakqKg0FlOJhuCsKHMUOxpQJ4qCDh6f24b2 cqKR8GjyUAgSeiiyN+DkDyqRYingQGAU5vzKepYzX+DMHC/izqQhrwQLVImv20wr 5pKZJDjfOpYUZRTuScV5Qwcgc0JYcMOjfgA93ZUA2zDrGIpw3dcCSMrpNQcvM6Cg 1mfiLZzkvPH3UkUOWhHCn/N2XaAF58joCaS+/bVUaXx02IbxJ1TTjqtCiH9491mE aaHeRCFYbkKCXWjuxCx1+VZN2yRk24rSkis/+LFgZm850fXgYfrqiyPRDlCMApdo 5JDUBTioyZz24vhqWpe0OZueu11DXtpU1G0BiheGrweXAAx0Yki8dRiPTXkavAMj oMBND9G7a1564KOe+t6V2qUyH50+3NaANvIiDJZbspX7yl8eVzPbwcGvtHzmHdnV pDh+38XUQEID5YJ/mdZh6evzmmTnQR1HVqPVrzs8SwIDO++tqj8DXTjID47c3VIl YhCMNlucciFxVn/sYI5qiJzCEMLMbvG+EhnoLNU4JGjfzo6I0RCpPfbrDfOsWJNi zYMz9htqusCQsGwUZSTZ =XBC5 \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; str4d assinou as seguintes versões: 0.9.23 As versões 0.7.6 a 0.9.12 foram assinadas por zzz com a seguinte chave: -----BEGIN PGP PUBLIC KEY BLOCK----- Version: GnuPG v1.4.6 (GNU/Linux) mQGiBEOjTnURBADegKKrIP6pz4+n57dqo3l9QrKhIklCtIxgJkL06ZJq5fKAnMLv GPaGXmn5vRrbo6QzHs/lGLG+ySWFWr9SsVstNKrwk+F1yGIERutl0BqMwX1esfN2 ugiZ3wB1yRu0PIrkm5cuDAFASFE+2lBjr1lfOrhw/dV+lLTcWx4NzkMzlwCgxgIk 4cqQMGaVkmtuICQdYmmMicUD/AmNSVJEm2XUvaS5fYWsHJG3+oNkdNGcx5SOMUdk PFwcSozqvT9FeIP76OVHAshQKeftE3utOFANQ/YomXEnypmwMxLLR+GPw5pMbKlK 6p+87aJZz+SA95E3ekmh7MmndvRd5RJDboUZy2H0FKX+FgaBlpsLl0uhT6uDuM/s 7nb0A/9nEAgICOU5SeXtO3jKY+RQvKyE0AblK7xVaU+Sn8ly0zauOJD13rycVGhu vLcAUVR3FKEjxafpvZ0ZPBo7AACjSDqAoCw/s/vt9gmrhHKiqN31PhYYLhKdfKTs 4LzWKTWKIAOwErkbYsMAXWKFT3LXsrEYvxq5j5m/6zMOwz2N7rQYenp6ICh6enpA IDx6enpAbWFpbC5pMnA+iF8EExECAB8FAkOjTnUCGwMGCwkIBwMCBBUCCAMDFgIB Ah4BAheAAAoJEEFVdrqnbgvtxGsAn39SvQ3+ey87WDDG+TWArN6oU8gnAJ4zeAsA LUK37WZIt8OImZSxk37uQbkCDQRDo06VEAgAy2UeqsM5a+U6ZOWS9NQiILb3KbTL FeeAd2rn9oLSLpn5gDWycwUS0Q62JmbSMWy6m9aczpnxvwaBYXz6aCIvZmTNtaU6 vyR/6wfJDyiUWSHtCyjpyFFYJimANd8Y8dDCimvceI/ihEDVyBX0kkgUGRAn8t3e unaLXqhbfiLiFw/GG1MNxUMzHt55/+9AqLOfRZg0riZvDoV79K+1sYSs8n1WeaVc T3wTb+Cb7fKNN7GT1MUhcXIoYYY6FGwsy5EWFsxYBRervqHtBJog2SoNUa/6BFGr zX+LDjK9L3xMTr3+fHIt4gPR/Lt4nnfEzL+rjClz/Fazmv38BRwPuKahFwADBQgA nD/AvZCnbWSB6khAVMqva5ROaD0gV0/UejCelZdYfgfHeCmrcMNQ+wCyww2NPsih 9vB1w+AUE0pdH37k65VZN+2falUdzN+PFugJGuH2pmlVOprH2SuC5gKpGRvzUqV5 U0nJmT2okDpW/52asUDJJLu1g//A3qBP83WGvSKUZg/ZisZA0qTiHH4QpjklopXi sSxR2hT8Fr9gF9WmDa09wbxE2xh/EL7gvVg/vk0gwOJcsFd67bNC+KUMOnjhOP0T K0/Ah4TEEs/hHNe9RsyyWlMoIUsF8AhG71ISOrJ5lLSXNe151XEb5FzZRM8sD9Zq 0E3PjmLbdVhanYvsPnWK6YhJBBgRAgAJBQJDo06VAhsMAAoJEEFVdrqnbgvtXTwA njMu9ueCFbsjme7nwsz96PdazJcHAKCce17hGI25QNXDZyHohrjha6IxDg== =fAfi \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nAs versões 0.6.1.31 até 0.7.5 foram assinadas por Complication. Sua chave pública é: \u0026mdash;\u0026ndash;BEGIN PGP SIGNED MESSAGE\u0026mdash;\u0026ndash; Hash: SHA1\nOlá,\nCertifico que abaixo está minha nova chave pública, emitida em 24/11/2007, válida até 23/11/2009, e sua impressão digital da chave é:\n73CF 2862 87A7 E7D2 19FF DB66 FA1D FC6B 79FC CE33\nSe você tem minha chave pública antiga e a usa para verificar isso, notará que minha chave antiga expirou em 15-11-2007. Desculpas pelo atraso nesta atualização.\nPara pessoas que desejam copiar a chave diretamente desta mensagem, mas não estão lendo isto usando um programa de e-mail, lembre-se de excluir as sequências de escape \u0026ldquo;- \u0026quot; do marcador inicial e final do bloco de chave pública. Caso contrário, ela não será reconhecida.\nComplicação.\n\u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\nmQGiBEdH5SYRBACzCum9jIjq+/G7ckuZ/TcFmaVYeBRE6OXPQozyrmTYtoCM2qGj DmvMJvKYiNiQVM42KiwlnqvaNtlgnXIZ6rcyLyn+bCI5cdX1SD5Rr5tgsgcXYA6Z l7usiFv1bTjD67piBehF130o+LZAJnVzI7JdpbA9SBY0mUwgKXLi0DAo8wCgiKOV UXC8+9X9vU1Mh/GyIrD4c3kD/iQOkYH4ajNaehTHNB31K+61ltpK9tMmcWtUY30A Z3q38jg/nmqqup/MYCtkvOqY4X9kujKzu01eSWSNZIE+BQSSd1cSsVD17OY3TL6B EvE+UFxh8OnDKs3tzJ0COnT/2zbgTavbWwqovoUE0P0PSYOFm2Co0BEQiCt9Tabc CxU3BACRWDvq7LFMRnHT+/OOJS6M442CYzy3+tIuc3ZAmZ8QwGsh4r1kd+5P1JTN YJCun6MPQEllJbRyHRBby76vFkWearRgnkpAmk2l1T2SXw3lip/SdmI0GgIzPSfQ 8WyNbMjQXyH8/3k2Y9rgrC0DttrJPYOcTFMNKPpeTR+HN3ZnibQ+Q29tcGxpY2F0 aW9uIChodHRwOi8vY29tcGxpY2F0aW9uLmkycCkgPGNvbXBsaWNhdGlvbkBtYWls LmkycD6IZQQTEQIAJQUCR0flJgIbAwUJA8JnAAYLCQgHAwIEFQIIAwMWAgECHgEC F4AACgkQ+h38a3n8zjP1yACfWkF1zjmlD0EzLaJRnefW5OHr10MAn0fgMyElK6ee AoPl2mTfxQQYOophuQQNBEdH5SYQEACTcoMJQBhyrr+EunLmEGNMO7D6RSBAtEKZ i5ctmhr/TCXMV9qjXkWISLZ9AS6z88rKozeOOK+QPBnc2FcEf77N04O5hwSdAyPH Qt7+umhiNQFQpZycJ5W87Y0ryERJygA5XyU47g7CGvuuOLgKGk0dDGCNFZGSblwI xtSh1CsrjWp23grFiBS0xvlU2VyuYUyrBuH5ip04pxmOyeRcaelkQerFhEXSRIR7 XFxl6JpfqWt2oWHmYbYD3RT6WHU+rpSF1Hyey+zoF2zXfRb+JD90MpBL1xIkpieQ Y69Cj5U5VRjEppJJowSmwgz+UyMnT2KLl45vJesPrMUaSgduHiIQo4LM5BcbbV+2 SC5i9xqbSJ+rc19Ftt9IEUZVMLole9PJC5Ff/h1qsabyueFuMIQkbiaUiNLOKl31 I+JAiDt0Xku2PEVCERg7Jq5AsTLB9D+zKqxbvFu+JvqSdlaCvlas2BYU5rBosszH TStK2XW/+poTKnjnbJl6nGC06BNQPhRFAwuXboyUC5fyiuG1HohvPmPIi6IejLUY G8A5nZ+7um/XpKlt2i5rdVRfN1BX3+aKHQeLmrc+EIORZUU32TrP4ceLtSDf+JOW 8N3vwzqKIPu42Y5KB8vnXEFSOkyt36OfEd6CcPKmncDyA4wJmfC+X3eoKcj+Yrh7 UMr0elyw4wADBg/9F7g+bTpT4wPXj5ax1i+4BdedjVlO3YBdhc4LP6MXipNU6yLl l63TJ8q/l8pvSkUWZXrO3a7OibM/MHp0Te/7sTmKib2/3MFwHTrtjgcZBF6wx8LD T3oa6O0IK8IRnRwNqeu83SxojvVY0wLz/hpUbnIrOcHMZjWLMJEfHkNBHn+1HhT5 tk9LRGu3j1oTpGh+DpdoPF5fggNu48YJ6n7etJJGW2MXQ++33aKeQSFrx+KlMtFW DSzg3KKSroB8Ex9wiKKWybagaed0YoP9BW3vIAaOeDpqK92UuTFz1Bte1DYiYU1e Rqq1xoBVhJXE5xzGmvS4/PIZMOL/bpKcuNxAgmwOVoaYoWZuIgePUaBbNvNg84HE RBjFMyfpzRCdPlWPZ18KcLUki3T58KzXEZ7WS5hC5lezwC6ET+wJusAt0A+Ik146 igayKfVnvhedQdqufWhQWNr+hDc5Fb/az8nTyNOflAhD3yHldjxgkCOV8wjqyS+4 iO33P5wW7o2QkZNWq8pyjsKRRJCtZ/PJ7FRGkUOjoC/gwhnGvBi0KoDcyBmfnPXp 3MAgrzk9LwiA7PlS7PyhyMx5mYpa90xlXzszweCIXzGfbm6ciCUAM3G3Qb+qa2dW 0u1X5L6bVtHVpYnr+5JOxCS4qwQvoK0QnHu6ezu4+rFutUJN35z6rFquejiITwQY EQIADwUCR0flJgIbDAUJA8JnAAAKCRD6HfxrefzOMzSZAJ9PmYNkW4Ia1qPqowg9 z4Ja+hJ3dgCeL3mqvOEHG7AcUQrSlc6xlC1vbNY= =rGxK - \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;BEGIN PGP SIGNATURE\u0026mdash;\u0026ndash; Version: GnuPG v1.4.7 (GNU/Linux)\niD8DBQFHR/zm4tLxqYRsGn0RAtCfAJ9rz+tsyEbeUAHcogdzgSPfuiWOAwCfWaVn Aiib6V5wOPbYTy13ADmxhfE= =mPFq \u0026mdash;\u0026ndash;END PGP SIGNATURE\u0026mdash;\u0026ndash; ","description":"Chaves PGP usadas para assinar lançamentos do I2P e onde obtê-las","id":"ae494d28c5c0216d277398ccdcc21df5","section":"docs","title":"Chave de Assinatura de Lançamento","url":"/pt/docs/develop/release-signing-key/"},{"categories":null,"content":"Contato de Segurança Para relatar vulnerabilidades de segurança ou questões sensíveis de segurança, entre em contato com a Equipe de Segurança I2P em security@i2p.net Para comunicação segura, use nossa chave PGP abaixo.\nInformação da Chave PGP Email: security@i2p.net ID da Chave: 176E1941 Impressão digital: 40DF FE20 7D79 9BEC 3AE8 7DEA 5F98 BE91 176E 1941 Tipo de Chave: RSA 4096-bit Criada: 2025-10-19 Expira: 2030-11-19 UID: I2P Security \u0026lt;security@i2p.net\u0026gt; Chave Pública A seguir está a chave pública GPG para a Equipe de Segurança do I2P: \u0026mdash;\u0026ndash;BEGIN PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash;\nmQINBGj1TtUBEADKsCC54egdJgxMs4HWcsYlr4GbrevM5gjZ+QZYEDGjaz44duOc E9W+a/NNA8PsryCql893odYdqGrFX+WTUT3UuN7DbbS7qSDs7jWZzjj0lr4/pbzJ B28lC0aIx6SQTEbzsGr2hOlFq/+JD9x/fMFrHFX81cJdIz9yabcH1vg9wPuhwkUS 5v2GFtvODCmSxQEJHSWvL2PkGiYEEZMKVXF5msdqJZK5/Dwp3UgVNeAkUYEHU6px Vu/YUpGo07/LNW5FfGDGf0pWYQ/9Tu5ykno3q3EA7TwWoVwbDK0hh9mpbZYiWSoy PSbIWNpwVMwGri4+KFjCEyG8DLzDlM4UMrK3PnrPh4M4+4a+flR+CMNeM1lyioC3 +jJf3TEOjvUsMzbwoDEE6O0wxBtfFC0xzzDDCAVrPvEZ3lt0do3kVHLbYS6ZXHkX ZwZWNBDWr2mSG9GU4oWizPIlq7MIhRYKA+ADqNxznxm9rtdfidk1tcLdyNUDjOwC jk/vQ8PCORbUYfytMhHzlRk7zieK6wBwr3aFFVgE8HxhgIZkAaUEbeej+dNADo6Z IFY+OF8mjpErcfJscCNgPSDbNid87dA78qRrqL6HLU2sek9g72EFpx2OVV7drkEp +Zy9kuiML4wWfOpC+kQa1Ka66E520U8Hs++cpf1LUOUmn1ajQDSfGoJMMwARAQAB tB9JMlAgU2VjdXJpdHkgPHNlY3VyaXR5QGkycC5uZXQ+iQJXBBMBCABBFiEEQN/+ IH15m+w66H3qX5i+kRduGUEFAmj1TtUCGwMFCQmQP4EFCwkIBwICIgIGFQoJCAsC BBYCAwECHgMCF4AACgkQX5i+kRduGUEEJhAAuZECNIWnC2UbrW/AXF8nPvFjpvLe kK7VQmMgno6iHRB1HAMh5hk3ZOYSRcjghcOHRpMFT64Uuc5vc9eBoegi5TDxYDkF Y9/ciEG5j2TXk93R/rY14UiH/kjFIhBAmc2t6Fs9R1m1vHHJtgY+KLqRF9fh2hc9 43odXnCrn5nhONtW+nb086eJEnJ4vsG/yR4EGzbu+fbrMJlycA/gZS63Q0rIcEJ2 VbZPCEXAf8LmebwxPxlboEuhXJSjCt1gWZwoKZlELaWdHliL3fUrMd3ojM5y66q3 ClO+7nWuwzKxKtZGKzxvF78o0O+HR4BbC16oQGpkT0yAij7ps/3KD2FJVQ/GQLef mpNQABfdVCPgcDS1p9/hjUoVHlRSC4gyehKX/C+H8Qvem92tzmJZy8PvcXaCsK/u wRxRwkoGhv0H5rsMOxfnB06dvT1Mo+KHED5j4y8C5DOnNpzHqwxJh1nQlJvLUvh8 LWIxiiE4+CeQ5V5YH7KfJmGq5ho93GgFmOXJvAuoFCoOLwXbQt9rMpq8iXM1RHRG E1AbB+KA3zcvAdzbgPtXlrOMkIfYO9xCyc8M0sfHB8b4RgrUs2tFz1fw3g4yE7ax 5ljquRefDmqBjtvu15FcZ4CA+I8FyVnrEb9jDTXyW7DiyM2kB7ZFeLpYytShbPq3 oJQMJYaGMoxDk025Ag0EaPVO1QEQAOuZtLOlab2EnuR5St05MXBpwtQUSWJzRckf w3NpnOl55+BavqsPl63rZYiO2lH9rAkZvfcL7auddQZSjDdsuPbUpsrQgsi2P9ig a3QiJOwSZzJ1qNb4VZSXrq2AqkBhCdw9rjpXGFfPNlClgVRbWpsGaQ5KtflnOA+I RfymidNXH0mDROBQuRh+2lkEYfANshjFjIqbI05tDic0KOab46R5MRVF7cihaMWp qPdxeYmvFWZ9lAnx5lMGwDdnGgfWFkU57lAd3NuHUnYIr/ExB/YgMdDeie5lQHKu svbcws9tIucUME9n8lGY77+1HlmNOCU4V12i4ZURJ4TwjHpScMOovkumtO4nXGRq GS8j1zeG7V9+yvdkSrclHJC33Mu6SPFC5SJBqU1G39/VpTD6CZPSPowZ0RlH2AVh D77Snrn53R3gziv5uxq+LpSJoafAx5tgIrg7HB+iJYRB1YVwIIHoT4YrBF01YyH6 cclkf3TNBjKgmtsynVw/TGy56nvR5lmt2uMq0Wwl4ZEwYPp+8ZmFuLbEHsI9RSdD iAdHoK9pEsTSxvzpcDTcG0CLZ4By/4oIKra6KuLr7XcB5eBmgXxrFBw4kveNWGW0 iEdg0xUVp8dxNjdZucB8m9qXQUUSmUxVjFYu4ee8tpo8iEVzu4wm4kOiOBKlwCn2 nOI72oGxABEBAAGJAjwEGAEIACYWIQRA3/4gfXmb7DrofepfmL6RF24ZQQUCaPVO 1QIbDAUJCZA/gQAKCRBfmL6RF24ZQShLD/9BlA+nLmJvwL3FYXm8JOqN07gPKlyQ +gWdV8p22Gawoq6dJLJanWURjn5Kfy30x2CSX6QwiaQG5aHHudNBF2h4Z/qEMcO5 ml5Dq7BP9R5VKmG4vwrL5ccNwuey1/d9Rtjt1zsd+52+x6dfjFv95o9j8jviIEoS HhhbO9ujmx3QLRNlg0SkG6ZlTALGp3EcKNdrV1vpF6ccgt3pdWYFB62N7q8zObHf bfOFMITJIXJJVKICCxzw3xOW2fMashjqf4Ic2UTFsAG3Hqqf5ASGbu4TyjFS3VXV JSzvdhGnxb7qJUzBImK9mGPRXYSV5d4g7kCFfgUg6KSFxbfYreEjCZXWJyqCr/VB eLpIhUWce/AiDPD8lGVD6sNevsNw4HhO6IyQu0pqbRAo+fJZNi+wcqOUqYlMczNw tUKw73QmFj0IqvyBr8Rfq9JC9O6ipyzalwK8uO0gmqOiK79zfnNIJaZ1+LM3Gh6n 3yluwq1df40lEU171i70IbSON6ekGNLTrvhTlDg6vHCMRfQR2UjA5FYBAtFXqQNG c4IYbu2UQm/191P77oI0vBEh3YnrD9eXtdYxgyT+Lj8RBJ+aM+IykK7c2mgOmlqb vYv+KkVFCpOyXrvSwId+3jHiGP6jis7vuzTwiG0S9EyOjxf9XIDowULuY28ntBB0 hOLK7ID/AeaOxA== =39fn \u0026mdash;\u0026ndash;END PGP PUBLIC KEY BLOCK\u0026mdash;\u0026ndash; ","description":"Chave pública GPG para contatar a Equipe de Segurança do I2P","id":"c65864821d13039a727e933e7e6e2891","section":"docs","title":"Chave GPG de Segurança","url":"/pt/docs/develop/security-key/"},{"categories":null,"content":"1. Visão Geral As entradas em clients.config indicam ao router quais aplicações devem ser iniciadas na inicialização. Cada entrada pode ser executada como um cliente gerenciado (preferível) ou como um cliente não gerenciado. Os clientes gerenciados colaboram com o ClientAppManager, que:\nInstancia a aplicação e rastreia o estado do ciclo de vida para o console do roteador Expõe controles de iniciar/parar para o usuário e força encerramentos limpos na saída do roteador Hospeda um registro de clientes leve e um mapeador de portas para que as aplicações possam descobrir os serviços umas das outras Clientes não gerenciados simplesmente invocam um método main(); use-os apenas para código legado que não pode ser modernizado.\n2. Implementando um Cliente Gerenciado Os clientes gerenciados devem implementar net.i2p.app.ClientApp (para aplicações voltadas ao usuário) ou net.i2p.router.app.RouterApp (para extensões do router). Forneça um dos construtores abaixo para que o gerenciador possa fornecer contexto e argumentos de configuração:\npublic MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args) public MyRouterApp(RouterContext context, ClientAppManager manager, String[] args) O array args contém os valores configurados em clients.config ou arquivos individuais em clients.config.d/. Estenda as classes auxiliares ClientApp / RouterApp quando possível para herdar a conexão padrão do ciclo de vida.\n2.1 Lifecycle Methods Os clientes gerenciados devem implementar:\nstartup() - executa a inicialização e retorna prontamente. Deve chamar manager.notify() pelo menos uma vez para transicionar do estado INITIALIZED. shutdown(String[] args) - libera recursos e para threads em segundo plano. Deve chamar manager.notify() pelo menos uma vez para mudar o estado para STOPPING ou STOPPED. getState() - informa ao console se a aplicação está em execução, iniciando, parando ou falhou O gerenciador chama esses métodos conforme os usuários interagem com o console.\n2.2 Advantages Relatórios de status precisos no console do roteador Reinicializações limpas sem vazamento de threads ou referências estáticas Menor consumo de memória após a aplicação parar Registro centralizado e relatório de erros através do contexto injetado 3. Unmanaged Clients (Fallback Mode) Se a classe configurada não implementa uma interface gerenciada, o router a inicia invocando main(String[] args) e não consegue rastrear o processo resultante. O console exibe informações limitadas e os hooks de encerramento podem não ser executados. Reserve este modo para scripts ou utilitários de uso único que não podem adotar as APIs gerenciadas.\n4. Client Registry Clientes gerenciados e não gerenciados podem se registrar no gerenciador para que outros componentes possam obter uma referência por nome:\nmanager.register(this); O registo utiliza o valor de retorno do getName() do cliente como chave de registo. Os registos conhecidos incluem console, i2ptunnel, Jetty, outproxy e update. Obtenha um cliente com ClientAppManager.getRegisteredApp(String name) para coordenar funcionalidades (por exemplo, a consola consultando o Jetty para obter detalhes de estado).\nNote que o registro de clientes e o mapeador de portas são sistemas separados. O registro de clientes permite a comunicação entre aplicações por meio de pesquisa de nomes, enquanto o mapeador de portas mapeia nomes de serviços para combinações host:porta para descoberta de serviços.\n3. Clientes Não Gerenciados (Modo de Fallback) O mapeador de portas oferece um diretório simples para serviços TCP internos. Registre portas de loopback para que colaboradores evitem endereços codificados diretamente:\ncontext.portMapper().register(PortMapper.SVC_HTTPS_PROXY, 4445); Ou com especificação explícita do host:\ncontext.portMapper().register(PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444); Procure serviços usando PortMapper.getPort(String name) (retorna -1 se não for encontrado) ou getPort(String name, int defaultPort) (retorna o padrão se não for encontrado). Verifique o status de registro com isRegistered(String name) e recupere o host registrado com getActualHost(String name).\nConstantes comuns do serviço de mapeamento de portas de net.i2p.util.PortMapper:\nSVC_CONSOLE - Console do router (porta padrão 7657) SVC_HTTP_PROXY - Proxy HTTP (porta padrão 4444) SVC_HTTPS_PROXY - Proxy HTTPS (porta padrão 4445) SVC_I2PTUNNEL - Gerenciador I2PTunnel SVC_SAM - Bridge SAM (porta padrão 7656) SVC_SAM_SSL - Bridge SAM SSL SVC_SAM_UDP - SAM UDP SVC_BOB - Bridge BOB (porta padrão 2827) SVC_EEPSITE - Eepsite padrão (porta padrão 7658) SVC_HTTPS_EEPSITE - Eepsite HTTPS SVC_IRC - Túnel IRC (porta padrão 6668) SVC_SUSIDNS - SusiDNS Nota: httpclient, httpsclient e httpbidirclient são tipos de túnel i2ptunnel (usados na configuração tunnel.N.type), não constantes de serviço de mapeamento de portas.\n4. Registro de Clientes 2.1 Métodos de Ciclo de Vida A partir da versão 0.9.42, o router suporta a divisão da configuração em arquivos individuais dentro do diretório clients.config.d/. Cada arquivo contém propriedades para um único cliente com todas as propriedades prefixadas com clientApp.0.:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true Esta é a abordagem recomendada para novas instalações e plugins.\n2.2 Vantagens Para compatibilidade retroativa, o formato tradicional usa numeração sequencial:\nclientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.1.main=net.i2p.apps.systray.UrlLauncher clientApp.1.name=URL Launcher clientApp.1.delay=5 6.3 Configuration Properties Obrigatório: - main - Nome completo da classe que implementa ClientApp ou RouterApp, ou que contém o método estático main(String[] args)\nOpcional: - name - Nome de exibição para o console do router (padrão é o nome da classe) - args - Argumentos separados por espaço ou tabulação (suporta strings entre aspas) - delay - Segundos antes de iniciar (padrão 120) - onBoot - Força delay=0 se verdadeiro - startOnLoad - Habilita/desabilita o cliente (padrão verdadeiro)\nEspecífico do plugin: - stopargs - Argumentos passados durante o desligamento - uninstallargs - Argumentos passados durante a desinstalação do plugin - classpath - Entradas adicionais do classpath separadas por vírgula\nSubstituição de variáveis para plugins: - $I2P - Diretório base do I2P - $CONFIG - Diretório de configuração do usuário (ex., ~/.i2p) - $PLUGIN - Diretório do plugin - $OS - Nome do sistema operacional - $ARCH - Nome da arquitetura\n5. Mapeador de Portas Prefira clientes gerenciados; recorra a não gerenciados apenas quando absolutamente necessário. Mantenha a inicialização e encerramento leves para que as operações do console permaneçam responsivas. Use nomes descritivos de registro e porta para que ferramentas de diagnóstico (e usuários finais) entendam o que um serviço faz. Evite singletons estáticos - confie no contexto injetado e no gerenciador para compartilhar recursos. Chame manager.notify() em todas as transições de estado para manter o status do console preciso. Se você precisar executar em uma JVM separada, documente como logs e diagnósticos são expostos ao console principal. Para programas externos, considere usar ShellService (adicionado na versão 1.7.0) para obter os benefícios de cliente gerenciado. 6. Formato de Configuração Os clientes gerenciados foram introduzidos na versão 0.9.4 (17 de dezembro de 2012) e permanecem como a arquitetura recomendada até a versão 2.10.0 (9 de setembro de 2025). As APIs principais permaneceram estáveis com zero mudanças incompatíveis durante este período:\nAssinaturas de construtores inalteradas Métodos de ciclo de vida (startup, shutdown, getState) inalterados Métodos de registro do ClientAppManager inalterados Métodos de registro e busca do PortMapper inalterados Melhorias notáveis: - 0.9.42 (2019) - estrutura de diretório clients.config.d/ para arquivos de configuração individuais - 1.7.0 (2021) - ShellService adicionado para rastreamento de estado de programas externos - 2.10.0 (2025) - Versão atual sem alterações na API de cliente gerenciado\nA próxima versão principal exigirá Java 17+ como mínimo (requisito de infraestrutura, não uma mudança de API).\nReferences Especificação clients.config Especificação de Arquivo de Configuração Índice de Documentação Técnica I2P Javadoc do ClientAppManager (API 0.9.66) Javadoc do PortMapper (API 0.9.66) Interface ClientApp (API 0.9.66) Interface RouterApp (API 0.9.66) Javadoc Alternativo (estável) Javadoc Alternativo (espelho clearnet) Nota: A rede I2P hospeda documentação abrangente em http://idk.i 2p/javadoc-i2p/ que requer um router I2P para acesso. Para acesso pela clearnet, use o espelho do GitHub Pages acima.\n","description":"Como aplicações gerenciadas pelo roteador se integram com o ClientAppManager e o mapeador de portas","id":"f9e2324a49e9ed9bf413b4c636d5d1b6","section":"docs","title":"Clientes Gerenciados","url":"/pt/docs/applications/managed-clients/"},{"categories":null,"content":"A implementação principal do cliente I2P usa Java. Se você não pode ou prefere não usar Java em um sistema específico, existem implementações alternativas de cliente I2P desenvolvidas e mantidas por membros da comunidade. Esses programas fornecem a mesma funcionalidade principal usando diferentes linguagens de programação ou abordagens.\nTabela de Comparação Client Language Maturity Actively Maintained Suitable For Notes Java I2P Java Stable ✅ Yes (official) General users Standard full router; includes console, plugins, and tools i2pd C++ Stable ✅ Yes Low-resource systems, servers Lightweight, fully compatible with Java I2P, includes web console Go-I2P Go Experimental ⚙️ In development Developers, testing Early-stage Go implementation; not yet production ready I2P+ Java Stable (fork) ✅ Yes Advanced users Enhanced Java I2P fork with UI and performance improvements --- i2pd (C++) Website: https://i2pd.website Descrição: i2pd (o I2P Daemon) é um cliente I2P completo implementado em C++. Ele está estável para uso em produção há muitos anos (desde aproximadamente 2016) e é mantido ativamente pela comunidade. O i2pd implementa completamente os protocolos de rede e APIs do I2P, tornando-o totalmente compatível com a rede I2P Java. Este router em C++ é frequentemente usado como uma alternativa leve em sistemas onde o ambiente de execução Java não está disponível ou não é desejado. O i2pd inclui um console baseado na web integrado para configuração e monitoramento. É multiplataforma e está disponível em muitos formatos de pacote — existe até uma versão Android do i2pd disponível (por exemplo, via F-Droid).\nGo-I2P (Go) Repositório: https://github.com/go-i2p/go-i2p Descrição: Go-I2P é um cliente I2P escrito na linguagem de programação Go. É uma implementação independente do router I2P, com o objetivo de aproveitar a eficiência e portabilidade do Go. O projeto está em desenvolvimento ativo, mas ainda está em estágio inicial e não possui todos os recursos completos. Em 2025, o Go-I2P é considerado experimental — está sendo desenvolvido ativamente por programadores da comunidade, mas não é recomendado para uso em produção até que amadureça mais. O objetivo do Go-I2P é fornecer um router I2P moderno e leve com compatibilidade total com a rede I2P assim que o desenvolvimento estiver completo.\nI2P+ (fork Java) Website: https://i2pplus.github.io Descrição: I2P+ é um fork mantido pela comunidade do cliente Java I2P padrão. Não é uma reimplementação em uma nova linguagem, mas sim uma versão aprimorada do router Java com recursos adicionais e otimizações. O I2P+ concentra-se em oferecer uma experiência de usuário melhorada e melhor desempenho, mantendo total compatibilidade com a rede I2P oficial. Ele introduz uma interface de console web renovada, opções de configuração mais amigáveis e várias otimizações (por exemplo, desempenho aprimorado de torrent e melhor gerenciamento de peers da rede, especialmente para routers atrás de firewalls). O I2P+ requer um ambiente Java assim como o software I2P oficial, portanto não é uma solução para ambientes não-Java. No entanto, para usuários que possuem Java e desejam uma versão alternativa com capacidades extras, o I2P+ oferece uma opção atraente. Este fork é mantido atualizado com os lançamentos upstream do I2P (com sua numeração de versão incluindo um \u0026ldquo;+\u0026rdquo;) e pode ser obtido no site do projeto.\n","description":"Implementações de clientes I2P mantidas pela comunidade (atualizado para 2025)","id":"fdcfc5a7a482cf9fe8fe449e9198b146","section":"docs","title":"Clientes I2P Alternativos","url":"/pt/docs/overview/alternative-clients/"},{"categories":null,"content":"Visão geral Esta especificação estende o feed de assinatura de endereços com comandos, permitindo que servidores de nomes difundam atualizações de entradas provenientes dos detentores de nomes de host. Proposta originalmente na Proposta 112 (setembro de 2014), implementada na versão 0.9.26 (junho de 2016) e implantada em toda a rede com status ENCERRADO.\nO sistema permaneceu estável e inalterado desde a sua implementação inicial, continuando a operar de forma idêntica no I2P 2.10.0 (Router API 0.9.65, setembro de 2025).\nMotivação Anteriormente, os servidores de assinatura de hosts.txt enviavam dados apenas em um formato hosts.txt simples:\nexample.i2p=b64destination Este formato básico criou vários problemas:\nOs detentores de nomes de host não podem atualizar o Destino associado aos seus nomes de host (por exemplo, para atualizar a chave de assinatura para um tipo criptográfico mais forte). Os detentores de nomes de host não podem renunciar aos seus nomes de host arbitrariamente. Devem entregar as chaves privadas do Destino correspondentes diretamente ao novo titular. Não há como autenticar que um subdomínio é controlado pelo nome de host base correspondente. Isso atualmente é imposto apenas individualmente por alguns servidores de nomes. Projeto Esta especificação adiciona comandos ao formato do hosts.txt. Com esses comandos, os servidores de nomes podem ampliar seus serviços para oferecer recursos adicionais. Clientes que implementarem esta especificação podem receber esses recursos por meio do processo de assinatura normal.\nTodas as linhas de comando devem ser assinadas pela Destination correspondente (destino no I2P). Isso garante que as alterações sejam feitas apenas a pedido do titular do nome de host.\nImplicações de segurança Esta especificação não afeta o anonimato.\nHá um aumento do risco associado à perda do controle de uma Destination key (chave privada da Destination), pois quem a obtiver pode usar esses comandos para fazer alterações em quaisquer nomes de host associados. No entanto, isso não é mais problemático do que o status quo, em que alguém que obtenha uma Destination (identificador público no I2P) pode se passar por um nome de host e assumir (parcialmente) o controle do tráfego desse nome de host. O risco adicional é compensado ao conceder aos titulares de nomes de host a capacidade de alterar a Destination associada a um nome de host caso acreditem que a Destination foi comprometida. Isso é impossível no sistema atual.\nEspecificação Novos Tipos de Linha Há dois novos tipos de linhas:\nComandos Add e Change: example.i2p=b64destination#!key1=val1#key2=val2... Remover comandos: #!key1=val1#key2=val2... Ordenação Um feed não é necessariamente ordenado nem completo. Por exemplo, um change command pode aparecer em uma linha antes de um add command, ou sem um add command.\nAs chaves podem estar em qualquer ordem. Chaves duplicadas não são permitidas. Todas as chaves e valores são sensíveis a maiúsculas/minúsculas.\nChaves Comuns Obrigatório em todos os comandos:\nsig : Assinatura Base64, usando a chave de assinatura do destino\nReferências a um segundo nome de host e/ou destino:\noldname : Um segundo nome de host (novo ou alterado)\nolddest : Um segundo destino Base64 (novo ou alterado)\noldsig : Uma segunda assinatura Base64, usando a chave de assinatura de olddest\nOutras chaves comuns:\naction : Um comando\nname : O nome do host, presente apenas se não for precedido por example.i2p=b64dest\ndest : O destino em Base64, presente apenas se não for precedido por example.i2p=b64dest\ndate : Em segundos desde a época Unix\nexpires : Em segundos desde a época Unix\nComandos Todos os comandos, exceto o comando \u0026ldquo;Add\u0026rdquo;, devem conter o par chave/valor action=command.\nPara compatibilidade com clientes mais antigos, a maioria dos comandos é precedida por example.i2p=b64dest, conforme indicado abaixo. Em caso de alterações, os valores apresentados são sempre os novos. Quaisquer valores antigos são incluídos na seção de chave/valor.\nAs chaves listadas são obrigatórias. Todos os comandos podem conter itens chave/valor adicionais não definidos aqui.\nAdicionar nome de host Precedido por example.i2p=b64dest : SIM, este é o novo nome de host e destino.\nação : NÃO incluída, está implícita.\nsig : assinatura\nExemplo:\nexample.i2p=b64dest#!sig=b64sig Alterar nome do host Precedido por example.i2p=b64dest : SIM, este é o novo nome de host e o destino antigo.\nação : changename\noldname : o nome de host antigo, a ser substituído\nsig : assinatura\nExemplo:\nexample.i2p=b64dest#!action=changename#oldname=oldhostname#sig=b64sig Alterar Destino Precedido por example.i2p=b64dest : SIM, este é o antigo nome de host e o novo destino.\nação : changedest\nolddest : o destino antigo, a ser substituído\noldsig : assinatura utilizando o olddest\nsig : assinatura\nExemplo:\nexample.i2p=b64dest#!action=changedest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Adicionar apelido de nome do host Precedido por example.i2p=b64dest : SIM, este é o novo nome de host (apelido) e o destino antigo.\nação : addname\noldname : o nome de host antigo\nsig : assinatura\nExemplo:\nexample.i2p=b64dest#!action=addname#oldname=oldhostname#sig=b64sig Adicionar apelido de destino (Usado para atualização de criptografia)\nPrecedido por example.i2p=b64dest : SIM, isto é o antigo nome de host e o novo destino (alternativo).\nação : adddest\nolddest : o destino antigo\noldsig : assinatura usando olddest\nsig : assinatura usando dest\nExemplo:\nexample.i2p=b64dest#!action=adddest#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Adicionar subdomínio Precedido por subdomain.example.i2p=b64dest : SIM, este é o novo nome de subdomínio e o destino.\naction : addsubdomain\noldname : o nome de host de nível superior (example.i2p)\nolddest : o destino de nível superior (por exemplo, example.i2p)\noldsig : assinatura usando olddest\nsig : assinatura usando dest\nExemplo:\nsubdomain.example.i2p=b64dest#!action=addsubdomain#oldname=example.i2p#olddest=oldb64dest#oldsig=b64sig#sig=b64sig Atualizar Metadados Precedido por example.i2p=b64dest : SIM, isto é o antigo nome de host e destino.\nação : atualizar\nsig : assinatura\n(adicione quaisquer chaves atualizadas aqui)\nExemplo:\nexample.i2p=b64dest#!action=update#k1=v1#k2=v2#sig=b64sig Remover nome de host Precedido por example.i2p=b64dest : NÃO, estes são especificados nas opções\nação : remover\nname : o nome do host\ndest : o destino\nsig : assinatura\nExemplo:\n#!action=remove#name=example.i2p#dest=b64dest#sig=b64sig Remover todos com este destino Precedidos por example.i2p=b64dest : NÃO, são especificados nas opções\nação : removeall\ndest : o destino\nsig : assinatura\nExemplo:\n#!action=removeall#dest=b64dest#sig=b64sig Assinaturas Todos os comandos devem ser assinados pela Destination (destino no I2P) correspondente. Comandos com duas Destinations podem precisar de duas assinaturas.\noldsig é sempre a assinatura \u0026ldquo;interna\u0026rdquo;. Assine e verifique sem as chaves oldsig ou sig presentes. sig é sempre a assinatura \u0026ldquo;externa\u0026rdquo;. Assine e verifique com a chave oldsig presente, mas sem a chave sig.\nEntrada para Assinaturas Para gerar um fluxo de bytes para criar ou verificar a assinatura, serialize da seguinte forma:\nRemova a chave sig Se estiver verificando com oldsig, também remova a chave oldsig Somente para comandos Add ou Change, emita example.i2p=b64dest Se restarem chaves, emita #! Ordene as opções por chave UTF-8, falhe se houver chaves duplicadas Para cada par chave/valor, emita key=value, seguido (se não for o último par chave/valor) de um # Notas\nNão produza uma quebra de linha A codificação de saída é UTF-8 Toda a codificação de destination e de assinatura é em Base 64 usando o alfabeto I2P Chaves e valores são sensíveis a maiúsculas/minúsculas Os nomes de host devem estar em minúsculas Tipos de assinatura atuais A partir do I2P 2.10.0, os seguintes tipos de assinatura são suportados para destinos:\nEdDSA_SHA512_Ed25519 (Type 7): Mais comum para destinos desde 0.9.15. Usa uma chave pública de 32 bytes e uma assinatura de 64 bytes. Este é o tipo de assinatura recomendado para novos destinos. RedDSA_SHA512_Ed25519 (Type 13): Disponível apenas para destinos e leasesets (estruturas do I2P usadas para descoberta de destinos) criptografados (desde 0.9.39). Tipos legados (DSA_SHA1, variantes de ECDSA): Ainda suportados, porém desaconselhados para novas Identidades de Router a partir de 0.9.58. Nota: As opções criptográficas pós-quânticas estão disponíveis desde o I2P 2.10.0, mas ainda não são os tipos de assinatura padrão.\nCompatibilidade Todas as novas linhas no formato hosts.txt são implementadas usando caracteres de comentário iniciais (#!), assim, todas as versões mais antigas do I2P interpretarão os novos comandos como comentários e os ignorarão sem problemas.\nQuando os I2P routers atualizarem para a nova especificação, eles não reinterpretarão comentários antigos, mas passarão a atender a novos comandos nas buscas subsequentes de seus feeds de assinatura. Assim, é importante que os servidores de nomes persistam as entradas de comando de alguma forma, ou habilitem o suporte a ETag para que os routers possam buscar todos os comandos anteriores.\nEstado da implementação Implantação inicial: Versão 0.9.26 (7 de junho de 2016)\nEstado atual: Estável e inalterado até a versão I2P 2.10.0 (Router API 0.9.65, setembro de 2025)\nStatus da proposta: ENCERRADA (implantado com sucesso em toda a rede)\nLocal de implementação: apps/addressbook/java/src/net/i2p/addressbook/ no router Java do I2P\nPrincipais classes: - SubscriptionList.java: Gerencia o processamento de assinaturas - Subscription.java: Lida com feeds de assinatura individuais - AddressBook.java: Funcionalidade essencial do livro de endereços - Daemon.java: Serviço em segundo plano do livro de endereços\nURL de assinatura padrão: http://i2p-projekt.i2p/hosts.txt\nDetalhes do transporte Subscrições usam HTTP com suporte a GET condicional:\nCabeçalho ETag: Suporta detecção eficiente de alterações Cabeçalho Last-Modified: Acompanha os horários de atualização da assinatura 304 Not Modified: Os servidores devem retornar isso quando o conteúdo não tiver sido alterado Content-Length: Altamente recomendado para todas as respostas O I2P router usa o comportamento padrão de cliente HTTP com suporte adequado a cache.\nContexto da Versão Nota sobre o versionamento do I2P: Por volta da versão 1.5.0 (agosto de 2021), o I2P mudou do versionamento 0.9.x para o versionamento semântico (1.x, 2.x, etc.). No entanto, a versão interna da Router API continua a usar a numeração 0.9.x para compatibilidade com versões anteriores. Em outubro de 2025, a versão atual é I2P 2.10.0 com a versão da Router API 0.9.65.\nEste documento de especificação foi originalmente redigido para a versão 0.9.49 (fevereiro de 2021) e continua totalmente correto para a versão atual 0.9.65 (I2P 2.10.0), porque o sistema de feeds de subscrição não sofreu alterações desde a sua implementação original na versão 0.9.26.\nReferências Proposta 112 (Original) Especificação Oficial Documentação de Nomenclatura do I2P Especificação de Estruturas Comuns Repositório de Código-Fonte do I2P Repositório Gitea do I2P Desenvolvimentos relacionados Embora o próprio sistema de feed de assinaturas não tenha sido alterado, os seguintes desenvolvimentos relacionados na infraestrutura de nomes do I2P podem ser de interesse:\nNomes Base32 Estendidos (0.9.40+): Suporte a endereços base32 com 56+ caracteres para leasesets criptografados. Não afeta o formato do feed de assinatura. Registro do TLD .i2p.alt (RFC 9476, final de 2023): Registro oficial na GANA de .i2p.alt como um TLD alternativo. Atualizações futuras do router podem remover o sufixo .alt, mas não são necessárias alterações nos comandos de assinatura. Criptografia Pós-Quântica (2.10.0+): Disponível, mas não é o padrão. Consideração futura para algoritmos de assinatura nos feeds de assinatura. ","description":"Extensão para feeds de assinatura de endereços, permitindo que os titulares de nomes de host atualizem e gerenciem suas entradas","id":"fa3cedda5fbeac90d0dcf029a44ee945","section":"docs","title":"Comandos do Feed de Assinatura de Endereços","url":"/pt/docs/specs/subscription/"},{"categories":null,"content":"Este guia mostra como configurar navegadores comuns para enviar tráfego através do proxy HTTP integrado do I2P. Ele cobre os navegadores Safari, Firefox e Chrome/Chromium com instruções detalhadas passo a passo.\nNotas Importantes:\nO proxy HTTP padrão do I2P escuta em 127.0.0.1:4444. O I2P protege o tráfego dentro da rede I2P (sites .i2p). Certifique-se de que seu router I2P está em execução antes de configurar seu navegador. Safari (macOS) O Safari utiliza as configurações de proxy do sistema no macOS.\nStep 1: Open Network Settings Abra o Safari e vá em Safari → Ajustes (ou Preferências) Clique na aba Avançado Na seção Proxies, clique em Alterar Configurações\u0026hellip; Isso abrirá as Configurações de Rede do Sistema do seu Mac.\nPasso 1: Abrir as Configurações de Rede Nas configurações de Rede, marque a caixa para Proxy da Web (HTTP) Insira o seguinte: Servidor Proxy da Web: 127.0.0.1 Porta: 4444 Clique em OK para salvar suas configurações Agora você pode navegar em sites .i2p no Safari!\nNota: Estas configurações de proxy afetarão todas as aplicações que usam os proxies do sistema macOS. Considere criar uma conta de usuário separada ou usar um navegador diferente exclusivamente para I2P se quiser isolar a navegação I2P.\nFirefox (Desktop) O Firefox possui suas próprias configurações de proxy independentes do sistema, tornando-o ideal para navegação dedicada no I2P.\nPasso 2: Configurar o Proxy HTTP Clique no botão de menu (☰) no canto superior direito Selecione Configurações Step 2: Find Proxy Settings Na caixa de pesquisa de Configurações, digite \u0026ldquo;proxy\u0026rdquo; Role até Configurações de Rede Clique no botão Configurações\u0026hellip; Passo 1: Abrir Configurações Selecione Configuração manual de proxy Insira o seguinte: Proxy HTTP: 127.0.0.1 Porta: 4444 Deixe o campo Host SOCKS vazio (a menos que você especificamente precise de proxy SOCKS) Marque Usar proxy DNS ao usar SOCKS apenas se estiver usando proxy SOCKS Clique em OK para salvar Agora você pode navegar em sites .i2p no Firefox!\nDica: Considere criar um perfil separado do Firefox dedicado à navegação no I2P. Isso mantém sua navegação no I2P isolada da navegação regular. Para criar um perfil, digite about:profiles na barra de endereços do Firefox.\nChrome / Chromium (Desktop) Chrome e navegadores baseados em Chromium (Brave, Edge, etc.) normalmente utilizam as configurações de proxy do sistema no Windows e macOS. Este guia mostra a configuração no Windows.\nPasso 2: Encontrar as Configurações de Proxy Clique no menu de três pontos (⋮) no canto superior direito Selecione Configurações Passo 3: Configurar Proxy Manual Na caixa de pesquisa de Configurações, digite \u0026ldquo;proxy\u0026rdquo; Clique em Abrir as configurações de proxy do seu computador Step 3: Open Manual Proxy Setup Isso abrirá as configurações de Rede e Internet do Windows.\nRole para baixo até Configuração manual de proxy Clique em Configurar Passo 1: Abrir as Configurações do Chrome Alterne Usar um servidor proxy para Ativado Insira o seguinte: Endereço IP do proxy: 127.0.0.1 Porta: 4444 Opcionalmente, adicione exceções em \u0026ldquo;Não usar o servidor proxy para endereços começando com\u0026rdquo; (por exemplo, localhost;127.*) Clique em Salvar Agora você pode navegar em sites .i2p no Chrome!\nNota: Estas configurações afetam todos os navegadores baseados em Chromium e algumas outras aplicações no Windows. Para evitar isso, considere usar o Firefox com um perfil I2P dedicado.\nPasso 2: Abrir as Configurações de Proxy No Linux, você pode iniciar o Chrome/Chromium com flags de proxy para evitar alterar as configurações do sistema:\nchromium \\ --proxy-server=\u0026#34;http=127.0.0.1:4444 \\ --proxy-bypass-list=\u0026#34;\u0026lt;-loopback\u0026gt;\u0026#34; Ou crie um script de atalho para a área de trabalho:\n#!/bin/bash chromium --proxy-server=\u0026#34;http=127.0.0.1:4444\u0026#34; --user-data-dir=\u0026#34;$HOME/.config/chromium-i2p\u0026#34; A flag --user-data-dir cria um perfil separado do Chrome para navegação I2P.\nFirefox (Desktop) As versões modernas \u0026ldquo;Fenix\u0026rdquo; do Firefox limitam about:config e extensões por padrão. IceRaven é um fork do Firefox que habilita um conjunto curado de extensões, tornando a configuração de proxy simples.\nConfiguração baseada em extensão (IceRaven):\nSe você já usa o IceRaven, considere limpar o histórico de navegação primeiro (Menu → Histórico → Excluir Histórico). 2) Abra Menu → Complementos → Gerenciador de Complementos. 3) Instale a extensão \u0026ldquo;I2P Proxy for Android and Other Systems\u0026rdquo;. 4) O navegador agora fará proxy através do I2P. Esta extensão também funciona em navegadores baseados no Firefox pré-Fenix se instalada do AMO .\nHabilitar o suporte extenso a extensões no Firefox Nightly requer um processo separado documentado pela Mozilla .\nInternet Explorer / Windows System Proxy No Windows, a caixa de diálogo de proxy do sistema aplica-se ao IE e pode ser usada por navegadores baseados em Chromium quando herdam as configurações do sistema.\nAbra \u0026ldquo;Configurações de Rede e Internet\u0026rdquo; → \u0026ldquo;Proxy\u0026rdquo;. 2) Ative \u0026ldquo;Usar um servidor proxy para sua LAN\u0026rdquo;. 3) Defina o endereço 127.0.0.1, porta 4444 para HTTP. 4) Opcionalmente marque \u0026ldquo;Ignorar servidor proxy para endereços locais\u0026rdquo;. ","description":"Configure navegadores populares para usar os proxies HTTP/HTTPS do I2P no desktop e Android","id":"a40410c542dc82558c1c1a8be78d2e62","section":"docs","title":"Configuração do Navegador Web","url":"/pt/docs/guides/browser-config/"},{"categories":null,"content":"Visão geral Este documento fornece uma especificação técnica abrangente dos arquivos de configuração do I2P usados pelo router e por várias aplicações. Abrange especificações de formato de arquivo, definições de propriedades e detalhes de implementação validados em relação ao código-fonte do I2P e à documentação oficial.\nEscopo Arquivos e formatos de configuração do router Configurações de aplicativos cliente Configurações de tunnel do I2PTunnel Especificações do formato de arquivo e implementação Funcionalidades específicas de versão e descontinuações Notas de Implementação Os arquivos de configuração são lidos e escritos usando os métodos DataHelper.loadProps() e storeProps() na biblioteca principal do I2P. O formato do arquivo difere significativamente do formato serializado usado nos protocolos do I2P (consulte Especificação de Estruturas Comuns - Mapeamento de Tipos ).\nFormato geral do arquivo de configuração Os arquivos de configuração do I2P seguem um formato Java Properties modificado, com exceções e restrições específicas.\nEspecificação do Formato Baseado em Java Properties com as seguintes diferenças críticas:\nCodificação DEVE usar codificação UTF-8 (NÃO ISO-8859-1, como no Java Properties (propriedades do Java) padrão) Implementação: Usa os utilitários DataHelper.getUTF8() para todas as operações de arquivo Sequências de escape NÃO são reconhecidas sequências de escape (incluindo a barra invertida \\) A continuação de linha NÃO é suportada Caracteres de barra invertida são tratados como literais Caracteres de comentário # inicia um comentário em qualquer posição na linha ; inicia um comentário somente quando estiver na coluna 1 ! NÃO inicia um comentário (diferente de Java Properties) Separadores de chave-valor = é o ÚNICO separador válido de chave-valor : NÃO é reconhecido como separador Espaços em branco NÃO são reconhecidos como separador Tratamento de espaços em branco Espaços em branco no início e no fim NÃO são removidos nas chaves Espaços em branco no início e no fim SÃO removidos nos valores Processamento de linhas Linhas sem = são ignoradas (tratadas como comentários ou linhas em branco) Valores vazios (key=) são suportados a partir da versão 0.9.10 Chaves com valores vazios são armazenadas e recuperadas normalmente Restrições de caracteres As chaves NÃO podem conter: - # (sinal de cerquilha/jogo da velha) - = (sinal de igual) - \\n (caractere de nova linha) - Não podem começar com ; (ponto e vírgula)\nValores NÃO podem conter: - # (hash/sinal de número) - \\n (caractere de nova linha) - Não pode começar nem terminar com \\r (retorno de carro) - Não pode começar nem terminar com espaços em branco (removidos automaticamente)\nOrdenação de arquivos Os arquivos de configuração não precisam ser ordenados por chave. No entanto, a maioria dos aplicativos I2P ordena as chaves alfabeticamente ao escrever arquivos de configuração para facilitar: - Edição manual - Operações de diff de controle de versão - Legibilidade humana\nDetalhes de Implementação Leitura de arquivos de configuração // Method signature from net.i2p.data.DataHelper public static Properties loadProps(File file) Comportamento: - Lê arquivos codificados em UTF-8 - Aplica todas as regras de formato descritas acima - Valida as restrições de caracteres - Retorna um objeto Properties vazio se o arquivo não existir - Lança IOException em caso de erros de leitura\nEscrevendo arquivos de configuração // Method signature from net.i2p.data.DataHelper public static void storeProps(Properties props, File file) Comportamento: - Escreve arquivos codificados em UTF-8 - Ordena as chaves alfabeticamente (a menos que OrderedProperties seja usado) - Define as permissões do arquivo para o modo 600 (apenas leitura/gravação do usuário) a partir da versão 0.8.1 - Lança IllegalArgumentException para caracteres inválidos em chaves ou valores - Lança IOException em caso de erros de escrita\nValidação de formato A implementação realiza validação rigorosa: - Chaves e valores são verificados quanto a caracteres proibidos - Entradas inválidas causam exceções durante operações de escrita - A leitura ignora silenciosamente linhas malformadas (linhas sem =)\nExemplos de Formato Arquivo de configuração válido # This is a comment ; This is also a comment (column 1 only) key.with.dots=value with spaces another_key=value=with=equals empty.value= numeric.value=12345 unicode.value=こんにちは Exemplos de Configuração Inválida # INVALID: Key contains equals sign invalid=key=value # INVALID: Key contains hash invalid#key=value # INVALID: Value contains newline (implicit) key=value continues here # INVALID: Semicolon comment not in column 1 (treated as key) ; not.a.comment=value Biblioteca principal e configuração do router Configuração de clientes (clients.config) Localização: $I2P_CONFIG_DIR/clients.config (legado) ou $I2P_CONFIG_DIR/clients.config.d/ (moderno) Interface de configuração: Console do Router em /configclients Alteração de formato: Versão 0.9.42 (agosto de 2019)\nEstrutura de diretórios (Versão 0.9.42+) A partir da versão 0.9.42, o arquivo clients.config padrão é dividido automaticamente em arquivos de configuração individuais:\n$I2P_CONFIG_DIR/ ├── clients.config.d/ │ ├── 00-webConsole.config │ ├── 01-i2ptunnel.config │ ├── 02-i2psnark.config │ ├── 03-susidns.config │ └── ... └── clients.config (legacy, auto-migrated) Comportamento de migração: - Na primeira execução após a atualização para 0.9.42+, o arquivo monolítico é dividido automaticamente - As propriedades nos arquivos divididos são prefixadas com clientApp.0. - O formato legado ainda é suportado para compatibilidade com versões anteriores - O formato dividido permite empacotamento modular e gerenciamento de plugins\nFormato da propriedade As linhas têm a forma clientApp.x.prop=val, em que x é o número do aplicativo.\nRequisitos de numeração de aplicativos: - DEVE começar com 0 - DEVE ser consecutiva (sem intervalos) - A ordem determina a sequência de inicialização\nPropriedades Obrigatórias principal Tipo: String (nome totalmente qualificado da classe) Obrigatório: Sim Descrição: O construtor ou o método main() desta classe será invocado dependendo do tipo de cliente (gerenciado vs. não gerenciado) Exemplo: clientApp.0.main=net.i2p.router.web.RouterConsoleRunner Propriedades opcionais nome Tipo: String Obrigatório: Não Descrição: Nome exibido na console do router Exemplo: clientApp.0.name=Router Console argumentos Tipo: String (separada por espaço ou tabulação) Obrigatório: Não Descrição: Argumentos passados ao construtor da classe principal ou ao método main() Aspas: Argumentos que contêm espaços ou tabulações podem ser colocados entre aspas com ' ou \u0026quot; Exemplo: clientApp.0.args=-d $CONFIG/eepsite atraso Tipo: Inteiro (segundos) Obrigatório: Não Padrão: 120 Descrição: Segundos a esperar antes de iniciar o cliente Substituições: Substituído por onBoot=true (define o atraso como 0) Valores especiais: \u0026lt; 0: Aguarda o router chegar ao estado RUNNING e então inicia imediatamente em nova thread = 0: Executa imediatamente na mesma thread (exceções se propagam para o console) \u0026gt; 0: Inicia após o atraso em nova thread (exceções registradas, não propagadas) onBoot Tipo: Booleano Obrigatório: Não Padrão: false Descrição: Força atraso de 0, sobrepõe a configuração explícita de atraso Caso de uso: Iniciar serviços críticos imediatamente na inicialização do router startOnLoad Tipo: Booleano Obrigatório: Não Padrão: true Descrição: Se o cliente deve ser iniciado Caso de uso: Desativar clientes sem remover a configuração Propriedades Específicas do Plugin Estas propriedades são usadas apenas por plugins (não por clientes do núcleo):\nstopargs Tipo: String (separada por espaço ou tabulação) Descrição: Argumentos passados para encerrar o cliente Substituição de variáveis: Sim (veja abaixo) uninstallargs Tipo: String (separada por espaços ou tabulações) Descrição: Argumentos passados para desinstalar o cliente Substituição de variáveis: Sim (consulte abaixo) classpath (caminho de classes) Tipo: String (caminhos separados por vírgula) Descrição: Elementos adicionais no classpath do cliente Substituição de variáveis: Sim (veja abaixo) Substituição de variáveis (apenas para plugins) As seguintes variáveis são substituídas em args, stopargs, uninstallargs e classpath para plugins:\nVariable Expands To Example $I2P Base I2P installation directory /usr/share/i2p $CONFIG User configuration directory ~/.i2p $PLUGIN Plugin directory ~/.i2p/plugins/foo $OS Operating system name linux $ARCH Architecture name amd64 **Nota**: A substituição de variáveis é realizada apenas para plugins, não para clientes do núcleo. Tipos de clientes Clientes gerenciados O construtor é chamado com os parâmetros RouterContext e ClientAppManager O cliente deve implementar a interface ClientApp Ciclo de vida controlado pelo router Pode ser iniciado, parado e reiniciado dinamicamente Clientes não gerenciados O método main(String[] args) é chamado Executa em thread (linha de execução) separada Ciclo de vida não gerenciado pelo router Tipo de cliente legado Exemplo de Configuração # Router Console (core client) clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=-d $CONFIG/eepsite clientApp.0.delay=0 clientApp.0.onBoot=true clientApp.0.startOnLoad=true # I2PTunnel (core client) clientApp.1.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.1.name=I2PTunnel clientApp.1.args= clientApp.1.delay=120 clientApp.1.startOnLoad=true # Plugin Example clientApp.2.main=org.example.plugin.PluginMain clientApp.2.name=Example Plugin clientApp.2.args=-config $PLUGIN/config.properties clientApp.2.stopargs=-shutdown clientApp.2.uninstallargs=-remove $PLUGIN clientApp.2.classpath=$PLUGIN/lib/plugin.jar,$PLUGIN/lib/dep.jar clientApp.2.delay=240 clientApp.2.startOnLoad=true Configuração do Logger (logger.config) Localização: $I2P_CONFIG_DIR/logger.config Interface de configuração: console do router em /configlogging\nReferência de Propriedades Configuração do buffer do console logger.consoleBufferSize Tipo: Inteiro Padrão: 20 Descrição: Número máximo de mensagens de log a serem armazenadas em buffer no console Intervalo: 1-1000 recomendado Formatação de data e hora logger.dateFormat Tipo: String (padrão do SimpleDateFormat) Padrão: Da localidade do sistema Exemplo: HH:mm:ss.SSS Documentação: Java SimpleDateFormat Níveis de Log logger.defaultLevel Tipo: Enum Padrão: ERROR Valores: CRIT, ERROR, WARN, INFO, DEBUG Descrição: Nível de log padrão para todas as classes logger.minimumOnScreenLevel Tipo: Enumeração Padrão: CRIT Valores: CRIT, ERROR, WARN, INFO, DEBUG Descrição: Nível mínimo para mensagens exibidas na tela logger.record.{class} Tipo: Enumeração Valores: CRIT, ERROR, WARN, INFO, DEBUG Descrição: Sobrescrita do nível de log por classe Exemplo: logger.record.net.i2p.router.transport.udp=DEBUG Opções de Exibição logger.displayOnScreen Tipo: Booleano Padrão: true Descrição: Se deve exibir mensagens de log na saída do console logger.dropDuplicates Tipo: Booleano Padrão: true Descrição: Descarta mensagens de log duplicadas consecutivas logger.dropOnOverflow Tipo: Booleano Padrão: false Descrição: Descarta mensagens quando o buffer está cheio (em vez de bloquear) Comportamento de flushing (esvaziamento do buffer) logger.flushInterval Tipo: Inteiro (segundos) Padrão: 29 Desde: Versão 0.9.18 Descrição: Com que frequência gravar o buffer de log em disco Configuração do Formato logger.format Tipo: String (sequência de caracteres) Descrição: Modelo de formato de mensagem de log Caracteres de formato: d = data/hora c = nome da classe t = nome da thread p = prioridade (nível de log) m = mensagem Exemplo: dctpm produz [carimbo de data/hora] [classe] [thread] [nível] mensagem Compressão (Versão 0.9.56+) logger.gzip Tipo: Booleano Padrão: false Desde: Versão 0.9.56 Descrição: Ativar a compactação gzip para arquivos de log rotacionados logger.minGzipSize Tipo: Inteiro (bytes) Padrão: 65536 Desde: Versão 0.9.56 Descrição: Tamanho mínimo de arquivo para ativar a compressão (64 KB padrão) Gerenciamento de Arquivos logger.logBufferSize Tipo: Inteiro (bytes) Padrão: 1024 Descrição: Máximo de mensagens a armazenar em buffer antes de descarregar logger.logFileName Tipo: String (caminho de arquivo) Padrão: logs/log-@.txt Descrição: Padrão de nomenclatura do arquivo de log (@ substituído pelo número de rotação) logger.logFilenameOverride Tipo: String (caminho de arquivo) Descrição: Substituição do nome do arquivo de log (desativa o padrão de rotação) logger.logFileSize Tipo: String (tamanho com unidade) Padrão: 10M Unidades: K (quilobytes), M (megabytes), G (gigabytes) Exemplo: 50M, 1G logger.logRotationLimit Tipo: Inteiro Padrão: 2 Descrição: Maior número de arquivo na rotação (log-0.txt até log-N.txt) Exemplo de configuração # Basic logging configuration logger.consoleBufferSize=50 logger.dateFormat=yyyy-MM-dd HH:mm:ss.SSS logger.defaultLevel=WARN logger.displayOnScreen=true logger.dropDuplicates=true logger.dropOnOverflow=false # Flushing and format logger.flushInterval=30 logger.format=dctpm # File management logger.logBufferSize=2048 logger.logFileName=logs/log-@.txt logger.logFileSize=25M logger.logRotationLimit=5 # Compression (0.9.56+) logger.gzip=true logger.minGzipSize=131072 # On-screen filtering logger.minimumOnScreenLevel=ERROR # Per-class overrides logger.record.net.i2p.router.transport=INFO logger.record.net.i2p.router.tunnel=DEBUG logger.record.net.i2p.crypto=WARN Configuração do plugin Configuração individual do plugin (plugins/*/plugin.config) Localização: $I2P_CONFIG_DIR/plugins/{plugin-name}/plugin.config Formato: Formato padrão de arquivo de configuração do I2P Documentação: Especificação do Plugin Propriedades obrigatórias nome Tipo: String Obrigatório: Sim Descrição: Nome de exibição do plugin Exemplo: name=I2P Plugin Example chave Tipo: String (chave pública) Obrigatório: Sim (omitir para plugins assinados com SU3) Descrição: Chave pública de assinatura do plugin para verificação Formato: Chave de assinatura codificada em Base64 signatário Tipo: String Obrigatório: Sim Descrição: Identidade do assinante do plugin Exemplo: signer=user@example.i2p versão Tipo: String (formato VersionComparator) Obrigatório: Sim Descrição: Versão do plugin para verificação de atualizações Formato: Versionamento semântico ou formato comparável personalizado Exemplo: version=1.2.3 Propriedades de Exibição data Tipo: Long (timestamp Unix em milissegundos) Descrição: Data de lançamento do plugin autor Tipo: String Descrição: Nome do autor do plugin websiteURL Tipo: String (URL) Descrição: URL do site do plugin updateURL Tipo: String (URL) Descrição: URL de verificação de atualização do plugin updateURL.su3 Tipo: String (URL) Desde: Versão 0.9.15 Descrição: URL de atualização no formato SU3 (preferencial) descrição Tipo: String Descrição: Descrição do plugin em inglês description_{language} Tipo: String Descrição: Descrição localizada do plugin Exemplo: description_de=Deutsche Beschreibung licença Tipo: Cadeia de caracteres Descrição: Identificador de licença do plugin Exemplo: license=Apache 2.0 Propriedades de Instalação não iniciar na instalação Tipo: Booleano Padrão: false Descrição: Impedir início automático após a instalação É necessário reiniciar o router Tipo: Booleano Padrão: false Descrição: Exigir reinicialização do router após a instalação somente instalação Tipo: Booleano Padrão: false Descrição: Instalar apenas uma vez (sem atualizações) somente atualização Tipo: Booleano Padrão: false Descrição: Atualizar somente a instalação existente (sem instalação nova) Exemplo de Configuração de Plugin # Required properties name=Example I2P Plugin signer=developer@mail.i2p version=1.5.0 # Display properties author=Plugin Developer websiteURL=http://plugin.example.i2p updateURL=http://plugin.example.i2p/update.xpi2p updateURL.su3=http://plugin.example.i2p/update.su3 description=Example plugin demonstrating configuration description_de=Beispiel-Plugin zur Demonstration der Konfiguration license=MIT # Installation behavior dont-start-at-install=false router-restart-required=false Configuração Global de Plugins (plugins.config) Local: $I2P_CONFIG_DIR/plugins.config Finalidade: Ativar/desativar plugins instalados globalmente\nFormato de Propriedade plugin.{name}.startOnLoad=true|false {name}: Nome do plugin definido em plugin.config startOnLoad: Se deve iniciar o plugin na inicialização do router Exemplo plugin.i2psnark.startOnLoad=true plugin.susimail.startOnLoad=true plugin.susidns.startOnLoad=true plugin.i2pbote.startOnLoad=false Configuração de Aplicações Web (webapps.config) Localização: $I2P_CONFIG_DIR/webapps.config Finalidade: Ativar/desativar e configurar aplicações web\nFormato da Propriedade webapps.{name}.startOnLoad Tipo: Booleano Descrição: Indica se o aplicativo web deve ser iniciado na inicialização do router Formato: webapps.{name}.startOnLoad=true|false webapps.{name}.classpath Tipo: String (caminhos separados por espaço ou vírgula) Descrição: Elementos adicionais de classpath para a aplicação web Formato: webapps.{name}.classpath=[paths] Substituição de Variáveis Os caminhos oferecem suporte às seguintes substituições de variáveis:\nVariable Expands To Context $I2P Base I2P directory Core webapps $CONFIG User config directory All webapps $PLUGIN Plugin directory Plugin webapps #### Resolução do Classpath Aplicações web do núcleo: Caminhos relativos a $I2P/lib Aplicações web de plugins: Caminhos relativos a $CONFIG/plugins/{appname}/lib Exemplo de configuração # Router console webapps.routerconsole.startOnLoad=true webapps.routerconsole.classpath=routerconsole.jar # I2PSnark webapps.i2psnark.startOnLoad=true webapps.i2psnark.classpath=i2psnark.jar # SusiDNS webapps.susidns.startOnLoad=true webapps.susidns.classpath=susidns.jar # Plugin webapp example webapps.exampleplugin.startOnLoad=false webapps.exampleplugin.classpath=$PLUGIN/lib/webapp.jar,$PLUGIN/lib/deps.jar Configuração do Router (router.config) Localização: $I2P_CONFIG_DIR/router.config Interface de configuração: console do router em /configadvanced Finalidade: Configurações centrais do router e parâmetros de rede\nCategorias de configuração Configuração de Rede Configurações de largura de banda:\ni2np.bandwidth.inboundKBytesPerSecond=100 i2np.bandwidth.outboundKBytesPerSecond=50 i2np.bandwidth.share.percentage=80 Configuração de transporte:\n# NTCP (TCP-based transport) i2np.ntcp.port=8887 i2np.ntcp.enable=true i2np.ntcp.autoip=true # SSU (UDP-based transport) i2np.udp.port=8887 i2np.udp.enable=true # UPnP/NAT-PMP i2np.upnp.enable=true Comportamento do Router # Tunnel participation router.maxParticipatingTunnels=200 router.sharePercentage=80 # Updates router.updatePolicy=notify router.updateURL=http://update.i2p2.i2p/ # Network integration router.hiddenMode=false router.clockSkewOffset=0 Configuração do Console # Language and display routerconsole.lang=en routerconsole.country=US routerconsole.summaryRefresh=60 # Browser routerconsole.browser=default # Security routerconsole.enableCompression=true Configuração de horário # NTP time.disabled=false time.sntpServerList=0.pool.ntp.org,1.pool.ntp.org Nota: A configuração do router é extensa. Consulte o console do router em /configadvanced para a referência completa das propriedades.\nArquivos de configuração de aplicativos Configuração do Livro de Endereços (addressbook/config.txt) Localização: $I2P_CONFIG_DIR/addressbook/config.txt Aplicativo: SusiDNS Finalidade: Resolução de nomes de host e gerenciamento do livro de endereços\nLocais dos arquivos router_addressbook Padrão: ../hosts.txt Descrição: Livro de endereços principal (nomes de host em todo o sistema) Formato: Formato padrão do arquivo hosts privatehosts.txt Localização: $I2P_CONFIG_DIR/addressbook/privatehosts.txt Descrição: Mapeamentos privados de nomes de host Prioridade: Máxima (sobrepõe-se a todas as outras fontes) userhosts.txt Localização: $I2P_CONFIG_DIR/addressbook/userhosts.txt Descrição: Mapeamentos de nomes de host adicionados pelo usuário Gerenciamento: Via interface SusiDNS hosts.txt Localização: $I2P_CONFIG_DIR/addressbook/hosts.txt Descrição: Livro de endereços público baixado Fonte: feeds de assinatura Serviço de Nomes BlockfileNamingService (Padrão desde 0.8.8) Formato de armazenamento: - Arquivo: hostsdb.blockfile - Localização: $I2P_CONFIG_DIR/addressbook/ - Desempenho: ~10x consultas mais rápidas do que em hosts.txt - Formato: Formato de banco de dados binário\nServiço de nomes legado: - Formato: Texto simples hosts.txt - Status: Obsoleto, mas ainda suportado - Caso de uso: Edição manual, controle de versão\nRegras de nomes de host Os nomes de host do I2P devem estar em conformidade com:\nRequisito de TLD: Deve terminar com .i2p Comprimento máximo: 67 caracteres no total Conjunto de caracteres: [a-z], [0-9], . (ponto), - (hífen) Maiúsculas/minúsculas: Somente minúsculas Restrições de início: Não pode começar com . ou - Padrões proibidos: Não pode conter .., .- ou -. (desde 0.6.1.33) Reservado: Nomes de host Base32 *.b32.i2p (52 caracteres de base32.b32.i2p) Exemplos válidos example.i2p my-site.i2p test.example.i2p site123.i2p Exemplos inválidos example.com # Wrong TLD -invalid.i2p # Starts with hyphen invalid..i2p # Contains double dot invalid.-.i2p # Contains dot-hyphen UPPERCASE.I2P # Must be lowercase verylonghostnameover67charactersthatexceedsthemaximumlength.i2p # Too long Gerenciamento de Assinaturas subscriptions.txt Localização: $I2P_CONFIG_DIR/addressbook/subscriptions.txt Formato: Um URL por linha Padrão: http://i2p-projekt.i2p/hosts.txt Formato do Feed de Assinatura (Desde a versão 0.9.26) Formato avançado de feed com metadados:\n# # I2P Address Book Subscription Feed # Format: hostname=destination [#property=value ...] # example.i2p=base64destination #added=20250101 #src=manual another.i2p=base64destination #added=20250102 #src=feed1 Propriedades de metadados: - added: Data em que o nome de host foi adicionado (formato YYYYMMDD) - src: Identificador de origem - sig: Assinatura opcional\nRetrocompatibilidade: O formato simples hostname=destination ainda é suportado.\nExemplo de Configuração # Address book locations router_addressbook=../hosts.txt privatehosts.txt=$CONFIG/addressbook/privatehosts.txt userhosts.txt=$CONFIG/addressbook/userhosts.txt hosts.txt=$CONFIG/addressbook/hosts.txt # Naming service naming.service=BlockfileNamingService naming.service.blockfile.location=$CONFIG/addressbook/hostsdb.blockfile # Subscriptions subscriptions.txt=$CONFIG/addressbook/subscriptions.txt subscriptions.schedule=daily subscriptions.proxy=false Configuração do I2PSnark (i2psnark.config.d/i2psnark.config) Localização: $I2P_CONFIG_DIR/i2psnark.config.d/i2psnark.config Aplicativo: cliente BitTorrent I2PSnark Interface de Configuração: GUI Web em http://127.0.0.1:7657/i2psnark\nEstrutura de diretórios $I2P_CONFIG_DIR/i2psnark.config.d/ ├── i2psnark.config ├── [torrent-hash-1]/ │ └── *.config ├── [torrent-hash-2]/ │ └── *.config └── ... Configuração Principal (i2psnark.config) Configuração padrão mínima:\ni2psnark.dir=i2psnark Propriedades adicionais gerenciadas via interface web:\n# Basic settings i2psnark.dir=i2psnark i2psnark.autoStart=false i2psnark.openTrackers=true # Network settings i2psnark.uploaders=8 i2psnark.upBW=40 i2psnark.seedPct=100 # I2CP settings i2psnark.i2cpHost=127.0.0.1 i2psnark.i2cpPort=7654 Configuração individual de torrents Localização: $I2P_CONFIG_DIR/i2psnark.config.d/[torrent-hash]/*.config Formato: Configurações por torrent Gerenciamento: Automático (via interface web)\nAs propriedades incluem: - Configurações de upload/download específicas do torrent - Prioridades de arquivos - Informações do rastreador - Limites de pares\nNota: As configurações de torrent são gerenciadas principalmente pela interface web. A edição manual não é recomendada.\nOrganização de Dados de Torrent O armazenamento de dados é separado da configuração:\n$I2P_CONFIG_DIR/i2psnark/ # Data directory ├── *.torrent # Torrent metadata files ├── *.torrent.downloaded/ # Downloaded file directories ├── file1.dat # Direct file downloads └── ... $I2P_CONFIG_DIR/i2psnark.config.d/ # Configuration directory ├── i2psnark.config # Main config └── [hashes]/ # Per-torrent configs Configuração do I2PTunnel (i2ptunnel.config) Localização: $I2P_CONFIG_DIR/i2ptunnel.config (legado) ou $I2P_CONFIG_DIR/i2ptunnel.config.d/ (moderno) Interface de configuração: console do Router em /i2ptunnel Alteração de formato: Versão 0.9.42 (agosto de 2019)\nEstrutura de Diretórios (Versão 0.9.42+) A partir da versão 0.9.42, o arquivo padrão i2ptunnel.config é dividido automaticamente:\n$I2P_CONFIG_DIR/ ├── i2ptunnel.config.d/ │ ├── http-proxy/ │ │ └── tunnel.config │ ├── irc-proxy/ │ │ └── tunnel.config │ ├── ssh-service/ │ │ └── tunnel.config │ └── ... └── i2ptunnel.config (legacy, auto-migrated) Diferença crítica de formato: - Formato monolítico: Propriedades prefixadas com tunnel.N. - Formato dividido: Propriedades NÃO prefixadas (por exemplo, description=, não tunnel.0.description=)\nComportamento de Migração Na primeira execução após a atualização para a 0.9.42: 1. O i2ptunnel.config existente é lido 2. As configurações individuais de tunnel são criadas em i2ptunnel.config.d/ 3. As propriedades têm os prefixos removidos nos arquivos separados 4. É feito backup do arquivo original 5. O formato legado ainda é suportado para compatibilidade com versões anteriores\nSeções de Configuração A configuração do I2PTunnel está documentada em detalhes na seção Referência de Configuração do I2PTunnel abaixo. As descrições das propriedades são aplicáveis tanto ao formato monolítico (tunnel.N.property) quanto ao formato separado (property).\nReferência de Configuração do I2PTunnel Esta seção fornece uma referência técnica abrangente para todas as propriedades de configuração do I2PTunnel. As propriedades são exibidas no formato dividido (sem o prefixo tunnel.N.). No formato monolítico, adicione o prefixo tunnel.N. a todas as propriedades, em que N é o número do tunnel.\nImportante: As propriedades descritas como tunnel.N.option.i2cp.* são implementadas no I2PTunnel e NÃO são suportadas por outras interfaces, como o protocolo I2CP ou a SAM API.\nPropriedades básicas tunnel.N.description (descrição) Tipo: String Contexto: Todos os tunnels Descrição: Descrição de tunnel legível por humanos para exibição na interface do usuário Exemplo: description=HTTP Proxy for outproxy access tunnel.N.name (nome) Tipo: String Contexto: Todos os tunnels Obrigatório: Sim Descrição: Identificador de tunnel exclusivo e nome de exibição Exemplo: name=I2P HTTP Proxy tunnel.N.type (tipo) Tipo: Enumeração Contexto: Todos os tunnels Obrigatório: Sim Valores: client - Tunnel de cliente genérico httpclient - Cliente de proxy HTTP ircclient - Tunnel de cliente IRC socksirctunnel - Proxy SOCKS para IRC sockstunnel - Proxy SOCKS (versão 4, 4a, 5) connectclient - Cliente de proxy CONNECT streamrclient - Cliente Streamr server - Tunnel de servidor genérico httpserver - Tunnel de servidor HTTP ircserver - Tunnel de servidor IRC httpbidirserver - Servidor HTTP bidirecional streamrserver - Servidor Streamr tunnel.N.interface (interface) Tipo: String (endereço IP ou nome de host) Contexto: Apenas tunnels de cliente Padrão: 127.0.0.1 Descrição: Interface local à qual vincular para conexões de entrada Nota de segurança: Vincular a 0.0.0.0 permite conexões remotas Exemplo: interface=127.0.0.1 tunnel.N.listenPort (listenPort) Tipo: Inteiro Contexto: Apenas tunnels de cliente Intervalo: 1-65535 Descrição: Porta local para escutar conexões de clientes Exemplo: listenPort=4444 tunnel.N.targetHost (targetHost) Tipo: String (endereço IP ou nome de host) Contexto: Apenas para tunnels de servidor Descrição: Servidor local para o qual encaminhar conexões Exemplo: targetHost=127.0.0.1 tunnel.N.targetPort (targetPort) Tipo: Inteiro Contexto: Apenas tunnels de servidor Intervalo: 1-65535 Descrição: Porta no targetHost para se conectar Exemplo: targetPort=80 tunnel.N.targetDestination (targetDestination) Tipo: String (destinos separados por vírgula ou espaço) Contexto: Apenas client tunnels Formato: destination[:port][,destination[:port]] Descrição: destino(s) I2P para se conectar Exemplos: targetDestination=example.i2p targetDestination=example.i2p:8080 targetDestination=site1.i2p,site2.i2p:8080 tunnel.N.i2cpHost (i2cpHost) Tipo: String (endereço IP ou nome de host) Padrão: 127.0.0.1 Descrição: Endereço da interface I2CP do router I2P Observação: Ignorado quando executado no contexto do router Exemplo: i2cpHost=127.0.0.1 tunnel.N.i2cpPort (i2cpPort) Tipo: Inteiro Padrão: 7654 Intervalo: 1-65535 Descrição: porta I2CP do router I2P Observação: Ignorado quando executado no contexto do router Exemplo: i2cpPort=7654 tunnel.N.startOnLoad (startOnLoad) Tipo: Booleano Padrão: true Descrição: Se o tunnel (túnel) deve iniciar quando o I2PTunnel (ferramenta de túnel do I2P) for carregado Exemplo: startOnLoad=true Configuração do proxy tunnel.N.proxyList (proxyList) Tipo: String (nomes de host separados por vírgula ou espaço) Contexto: Apenas proxies HTTP e SOCKS Descrição: Lista de hosts de outproxy (proxy de saída) Exemplo: proxyList=outproxy.example.i2p,backup.example.i2p Configuração do Servidor tunnel.N.privKeyFile (privKeyFile) Tipo: String (caminho de arquivo) Contexto: Servidores e tunnels de cliente persistentes Descrição: Arquivo contendo chaves privadas de destino persistentes Caminho: Absoluto ou relativo ao diretório de configuração do I2P Exemplo: privKeyFile=eepsite/eepPriv.dat tunnel.N.spoofedHost (spoofedHost) Tipo: String (nome de host) Contexto: Somente servidores HTTP Padrão: nome de host Base32 do destino Descrição: Valor do cabeçalho Host passado ao servidor local Exemplo: spoofedHost=example.i2p tunnel.N.spoofedHost.NNNN (spoofedHost.NNNN) Tipo: String (nome do host) Contexto: Apenas servidores HTTP Descrição: Sobrescrita do host virtual para uma porta de escuta específica Caso de uso: Hospedar vários sites em portas diferentes Exemplo: spoofedHost.8080=site1.example.i2p Opções específicas do cliente tunnel.N.sharedClient (sharedClient) Tipo: Booleano Contexto: Somente Client tunnels Padrão: false Descrição: Se vários clientes podem compartilhar este tunnel Exemplo: sharedClient=false tunnel.N.option.persistentClientKey (persistentClientKey) Tipo: Booleano Contexto: Apenas tunnels do cliente Padrão: false Descrição: Armazena e reutiliza chaves de destino entre reinicializações Conflito: Mutuamente exclusivo com i2cp.newDestOnResume=true Exemplo: option.persistentClientKey=true Opções do I2CP (Implementação do I2PTunnel) Importante: Essas propriedades têm o prefixo option.i2cp., mas são implementadas no I2PTunnel, não na camada de protocolo I2CP. Elas não estão disponíveis via I2CP ou APIs do SAM.\ntunnel.N.option.i2cp.delayOpen (option.i2cp.delayOpen) Tipo: Booleano Contexto: Apenas tunnels de cliente Padrão: false Descrição: Atrasar a criação do tunnel até a primeira conexão Caso de uso: Poupar recursos em tunnels raramente usados Exemplo: option.i2cp.delayOpen=false tunnel.N.option.i2cp.newDestOnResume (option.i2cp.newDestOnResume) Tipo: Booleano Contexto: Somente para Client tunnels Padrão: false Requer: i2cp.closeOnIdle=true Conflito: Mutuamente exclusivo com persistentClientKey=true Descrição: Criar um novo destino após o tempo limite de inatividade Exemplo: option.i2cp.newDestOnResume=false tunnel.N.option.i2cp.leaseSetPrivateKey (option.i2cp.leaseSetPrivateKey) Tipo: String (chave codificada em base64) Contexto: Apenas server tunnels Descrição: Chave de criptografia privada persistente do leaseset Caso de uso: Manter o leaseset criptografado consistente após reinicializações Exemplo: option.i2cp.leaseSetPrivateKey=AAAA...base64... tunnel.N.option.i2cp.leaseSetSigningPrivateKey (option.i2cp.leaseSetSigningPrivateKey) Tipo: String (sigtype:base64) Contexto: Apenas Server tunnels Formato: sigtype:base64key Descrição: Chave privada de assinatura de leaseset persistente Exemplo: option.i2cp.leaseSetSigningPrivateKey=7:AAAA...base64... Opções Específicas do Servidor tunnel.N.option.enableUniqueLocal (option.enableUniqueLocal) Tipo: Booleano Contexto: Apenas para tunnels de servidor Padrão: false Descrição: Usar um IP local exclusivo por destino I2P remoto Caso de uso: Rastrear IPs de clientes nos logs do servidor Observação de segurança: Pode reduzir o anonimato Exemplo: option.enableUniqueLocal=false tunnel.N.option.targetForPort.NNNN (option.targetForPort.NNNN) Tipo: String (hostname:port) Contexto: Apenas tunnels de servidor Descrição: Substitui targetHost/targetPort para a porta de entrada NNNN Caso de uso: Roteamento baseado em porta para diferentes serviços locais Exemplo: option.targetForPort.8080=localhost:8080 Configuração do Pool de Threads tunnel.N.option.i2ptunnel.usePool (option.i2ptunnel.usePool) Tipo: Booleano Contexto: Apenas para server tunnels Padrão: true Descrição: Usar pool de threads para tratamento de conexões Observação: Sempre false para servidores padrão (ignorado) Exemplo: option.i2ptunnel.usePool=true tunnel.N.option.i2ptunnel.blockingHandlerCount (option.i2ptunnel.blockingHandlerCount) Tipo: Inteiro Contexto: Apenas para server tunnels Padrão: 65 Descrição: Tamanho máximo do pool de threads Nota: Ignorado para servidores padrão Exemplo: option.i2ptunnel.blockingHandlerCount=100 Opções do cliente HTTP tunnel.N.option.i2ptunnel.httpclient.allowInternalSSL (option.i2ptunnel.httpclient.allowInternalSSL) Tipo: Booleano Contexto: Apenas clientes HTTP Padrão: false Descrição: Permitir conexões SSL para endereços .i2p Exemplo: option.i2ptunnel.httpclient.allowInternalSSL=false tunnel.N.option.i2ptunnel.httpclient.disableAddressHelper (option.i2ptunnel.httpclient.disableAddressHelper) Tipo: Booleano Contexto: Apenas clientes HTTP Padrão: false Descrição: Desativar links de address helper (assistente de endereço) nas respostas do proxy Exemplo: option.i2ptunnel.httpclient.disableAddressHelper=false tunnel.N.option.i2ptunnel.httpclient.jumpServers (option.i2ptunnel.httpclient.jumpServers) Tipo: String (URLs separadas por vírgula ou espaço) Contexto: Somente clientes HTTP Descrição: URLs de jump server (servidor de salto) para resolução de nomes de host Exemplo: option.i2ptunnel.httpclient.jumpServers=http://jump.i2p/jump,http://stats.i2p/jump tunnel.N.option.i2ptunnel.httpclient.sendAccept (option.i2ptunnel.httpclient.sendAccept) Tipo: Booleano Contexto: apenas clientes HTTP Padrão: false Descrição: Repassar os cabeçalhos Accept-* (exceto Accept e Accept-Encoding) Exemplo: option.i2ptunnel.httpclient.sendAccept=false tunnel.N.option.i2ptunnel.httpclient.sendReferer (option.i2ptunnel.httpclient.sendReferer) Tipo: Booleano Contexto: Apenas clientes HTTP Padrão: false Descrição: Encaminhar os cabeçalhos Referer através do proxy Nota de privacidade: Pode expor informações Exemplo: option.i2ptunnel.httpclient.sendReferer=false tunnel.N.option.i2ptunnel.httpclient.sendUserAgent (option.i2ptunnel.httpclient.sendUserAgent) Tipo: Booleano Contexto: apenas clientes HTTP Padrão: false Descrição: Encaminhar cabeçalhos User-Agent pelo proxy Observação de privacidade: Pode vazar informações do navegador Exemplo: option.i2ptunnel.httpclient.sendUserAgent=false tunnel.N.option.i2ptunnel.httpclient.sendVia (option.i2ptunnel.httpclient.sendVia) Tipo: Booleano Contexto: Apenas clientes HTTP Padrão: false Descrição: Passar cabeçalhos Via através do proxy Exemplo: option.i2ptunnel.httpclient.sendVia=false tunnel.N.option.i2ptunnel.httpclient.SSLOutproxies (option.i2ptunnel.httpclient.SSLOutproxies) Tipo: String (destinos separados por vírgulas ou espaços) Contexto: Somente clientes HTTP Descrição: Outproxies SSL na rede (proxies de saída) para HTTPS Exemplo: option.i2ptunnel.httpclient.SSLOutproxies=ssl-outproxy.i2p tunnel.N.option.i2ptunnel.useLocalOutproxy (option.i2ptunnel.useLocalOutproxy) Tipo: Booleano Contexto: Somente clientes HTTP Padrão: true Descrição: Usar plugins de outproxy (proxy de saída) locais registrados Exemplo: option.i2ptunnel.useLocalOutproxy=true Autenticação do cliente HTTP tunnel.N.option.proxyAuth (option.proxyAuth) Tipo: Enumeração Contexto: Somente clientes HTTP Padrão: false Valores: true, false, basic, digest Descrição: Exigir autenticação local para acesso ao proxy Observação: true é equivalente a basic Exemplo: option.proxyAuth=basic tunnel.N.option.proxy.auth.USER.md5 (option.proxy.auth.USER.md5) Tipo: String (hexadecimal em minúsculas de 32 caracteres) Contexto: apenas clientes HTTP Requer: proxyAuth=basic ou proxyAuth=digest Descrição: hash MD5 da senha do usuário USER Obsoleto: Use SHA-256 em vez disso (0.9.56+) Exemplo: option.proxy.auth.alice.md5=5f4dcc3b5aa765d61d8327deb882cf99 tunnel.N.option.proxy.auth.USER.sha256 (option.proxy.auth.USER.sha256) Tipo: String (hexadecimal em minúsculas de 64 caracteres) Contexto: apenas clientes HTTP Requer: proxyAuth=digest Desde: Versão 0.9.56 Padrão: RFC 7616 Descrição: hash SHA-256 da senha do usuário USER Exemplo: option.proxy.auth.alice.sha256=5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8 Autenticação do outproxy (proxy de saída do I2P) tunnel.N.option.outproxyAuth (option.outproxyAuth) Tipo: Booleano Contexto: Apenas clientes HTTP Padrão: false Descrição: Enviar autenticação ao outproxy (proxy de saída) Exemplo: option.outproxyAuth=false tunnel.N.option.outproxyUsername (option.outproxyUsername) Tipo: String Contexto: Apenas clientes HTTP Requer: outproxyAuth=true Descrição: Nome de usuário para autenticação do outproxy Exemplo: option.outproxyUsername=user tunnel.N.option.outproxyPassword (option.outproxyPassword) Tipo: String Contexto: Somente clientes HTTP Requer: outproxyAuth=true Descrição: Senha para autenticação do outproxy Segurança: Armazenado em texto simples Exemplo: option.outproxyPassword=secret Opções do cliente SOCKS tunnel.N.option.i2ptunnel.socks.proxy.default (option.i2ptunnel.socks.proxy.default) Tipo: String (destinos separados por vírgula ou espaço) Contexto: Apenas clientes SOCKS Descrição: Outproxies (proxies de saída) na rede para portas não especificadas Exemplo: option.i2ptunnel.socks.proxy.default=outproxy.i2p tunnel.N.option.i2ptunnel.socks.proxy.NNNN (option.i2ptunnel.socks.proxy.NNNN) Tipo: String (destinos separados por vírgula ou espaço) Contexto: Apenas clientes SOCKS Descrição: Outproxies (proxies de saída) na rede especificamente para a porta NNNN Exemplo: option.i2ptunnel.socks.proxy.443=ssl-outproxy.i2p tunnel.N.option.outproxyType (option.outproxyType) Tipo: Enumeração Contexto: Somente para clientes SOCKS Padrão: socks Desde: Versão 0.9.57 Valores: socks, connect (HTTPS) Descrição: Tipo de outproxy (servidor proxy de saída) configurado Exemplo: option.outproxyType=connect Opções do Servidor HTTP tunnel.N.option.maxPosts (option.maxPosts) Tipo: Inteiro Contexto: Apenas servidores HTTP Padrão: 0 (ilimitado) Descrição: Máximo de POSTs de um único Destination (identificador de serviço no I2P) por postCheckTime Exemplo: option.maxPosts=10 tunnel.N.option.maxTotalPosts (option.maxTotalPosts) Tipo: Inteiro Contexto: Apenas servidores HTTP Padrão: 0 (ilimitado) Descrição: Máximo de POSTs de todos os destinos por postCheckTime Exemplo: option.maxTotalPosts=50 tunnel.N.option.postCheckTime (option.postCheckTime) Tipo: Inteiro (segundos) Contexto: apenas servidores HTTP Padrão: 300 Descrição: Janela de tempo para verificar limites de POST Exemplo: option.postCheckTime=600 tunnel.N.option.postBanTime (option.postBanTime) Tipo: Inteiro (segundos) Contexto: Somente servidores HTTP Padrão: 1800 Descrição: Duração do banimento após maxPosts ser excedido para um único destino Exemplo: option.postBanTime=3600 tunnel.N.option.postTotalBanTime (option.postTotalBanTime) Tipo: Inteiro (segundos) Contexto: Apenas servidores HTTP Padrão: 600 Descrição: Duração do banimento após maxTotalPosts ser excedido Exemplo: option.postTotalBanTime=1200 Opções de Segurança do Servidor HTTP tunnel.N.option.rejectInproxy (option.rejectInproxy) Tipo: Booleano Contexto: apenas servidores HTTP Padrão: false Descrição: Rejeita conexões que aparentemente vêm por um inproxy (proxy de entrada) Exemplo: option.rejectInproxy=false tunnel.N.option.rejectReferer (option.rejectReferer) Tipo: Booleano Contexto: Apenas servidores HTTP Padrão: false Desde: Versão 0.9.25 Descrição: Rejeita conexões com o cabeçalho Referer Exemplo: option.rejectReferer=false tunnel.N.option.rejectUserAgents (option.rejectUserAgents) Tipo: Booleano Contexto: Apenas servidores HTTP Padrão: false Desde: Versão 0.9.25 Requer: propriedade userAgentRejectList Descrição: Rejeita conexões com User-Agent correspondente Exemplo: option.rejectUserAgents=false tunnel.N.option.userAgentRejectList (option.userAgentRejectList) Tipo: String (strings de correspondência separadas por vírgulas) Contexto: apenas servidores HTTP Desde: Versão 0.9.25 Maiúsculas/minúsculas: correspondência sensível a maiúsculas/minúsculas Especial: \u0026ldquo;none\u0026rdquo; (desde 0.9.33) corresponde a um User-Agent vazio Descrição: Lista de padrões de User-Agent a rejeitar Exemplo: option.userAgentRejectList=Mozilla,Opera,none Opções do servidor IRC tunnel.N.option.ircserver.fakeHostname (option.ircserver.fakeHostname) Type: String (padrão de nome de host) Context: Apenas servidores IRC Default: %f.b32.i2p Tokens: %f = Hash de destino base32 completo %c = Hash de destino ofuscado (ver cloakKey) Description: Formato do nome de host enviado ao servidor IRC Example: option.ircserver.fakeHostname=%c.irc.i2p tunnel.N.option.ircserver.cloakKey (option.ircserver.cloakKey) Tipo: String (frase secreta) Contexto: Somente servidores IRC Padrão: Aleatório por sessão Restrições: Sem aspas nem espaços Descrição: Frase secreta para mascaramento consistente do nome de host Caso de uso: Rastreamento persistente de usuário entre reinicializações/servidores Exemplo: option.ircserver.cloakKey=mysecretkey tunnel.N.option.ircserver.method (option.ircserver.method) Tipo: Enum Contexto: Somente para servidores IRC Padrão: user Valores: user, webirc Descrição: Método de autenticação para o servidor IRC Exemplo: option.ircserver.method=webirc tunnel.N.option.ircserver.webircPassword (option.ircserver.webircPassword) Tipo: String (senha) Contexto: Apenas servidores IRC Requer: method=webirc Restrições: Sem aspas nem espaços Descrição: Senha para autenticação do protocolo WEBIRC Exemplo: option.ircserver.webircPassword=webircpass tunnel.N.option.ircserver.webircSpoofIP (option.ircserver.webircSpoofIP) Tipo: String (endereço IP) Contexto: apenas servidores IRC Requer: method=webirc Descrição: endereço IP falsificado para o protocolo WEBIRC Exemplo: option.ircserver.webircSpoofIP=10.0.0.1 Configuração de SSL/TLS tunnel.N.option.useSSL (option.useSSL) Tipo: Booleano Padrão: false Contexto: Todos os tunnels Comportamento: Servidores: Usar SSL para conexões com o servidor local Clientes: Exigir SSL de clientes locais Exemplo: option.useSSL=false tunnel.N.option.keystoreFile (option.keystoreFile) Tipo: String (caminho de arquivo) Contexto: Apenas client tunnels Padrão: i2ptunnel-(random).ks Caminho: Relativo a $(I2P_CONFIG_DIR)/keystore/ se não for absoluto Gerado automaticamente: Criado se não existir Descrição: Arquivo keystore (repositório de chaves) contendo a chave privada SSL Exemplo: option.keystoreFile=my-tunnel.ks tunnel.N.option.keystorePassword (option.keystorePassword) Tipo: String (senha) Contexto: Apenas client tunnels Padrão: changeit Gerado automaticamente: Senha aleatória se um novo keystore for criado Descrição: Senha para o keystore (repositório de chaves) SSL Exemplo: option.keystorePassword=secretpassword tunnel.N.option.keyAlias (option.keyAlias) Tipo: String (apelido) Contexto: Apenas tunnels de cliente Gerado automaticamente: Criado se uma nova chave for gerada Descrição: Apelido para a chave privada no keystore (repositório de chaves) Exemplo: option.keyAlias=mytunnel-key tunnel.N.option.keyPassword (option.keyPassword) Tipo: String (senha) Contexto: Apenas Client tunnels Gerado automaticamente: Senha aleatória se uma nova chave for criada Descrição: Senha para a chave privada no keystore Exemplo: option.keyPassword=keypass123 Opções genéricas de I2CP e de Streaming Todas as propriedades tunnel.N.option.* (não especificamente documentadas acima) são encaminhadas à interface I2CP e à biblioteca de streaming, com o prefixo tunnel.N.option. removido.\nImportante: Estas são distintas das opções específicas do I2PTunnel. Consulte: - Especificação do I2CP - Especificação da Biblioteca de Streaming Exemplos de opções de streaming:\noption.i2cp.messageReliability=BestEffort option.i2p.streaming.connectDelay=1000 option.i2p.streaming.maxWindowSize=128 Exemplo completo de Tunnel (túnel) # HTTP Proxy (split format without tunnel.N. prefix) name=I2P HTTP Proxy description=HTTP proxy for accessing I2P sites and outproxy type=httpclient interface=127.0.0.1 listenPort=4444 targetDestination= sharedClient=true startOnLoad=true # I2CP configuration i2cpHost=127.0.0.1 i2cpPort=7654 # HTTP client options option.i2ptunnel.httpclient.allowInternalSSL=false option.i2ptunnel.httpclient.disableAddressHelper=false option.i2ptunnel.httpclient.jumpServers=http://stats.i2p/cgi-bin/jump.cgi option.i2ptunnel.httpclient.sendAccept=false option.i2ptunnel.httpclient.sendReferer=false option.i2ptunnel.httpclient.sendUserAgent=false # Proxy authentication option.proxyAuth=false # Outproxy configuration option.i2ptunnel.httpclient.SSLOutproxies=false.i2p proxyList=false.i2p # Client behavior option.persistentClientKey=false option.i2cp.delayOpen=false # I2CP tunnel options option.inbound.length=3 option.outbound.length=3 option.inbound.quantity=2 option.outbound.quantity=2 Histórico de versões e cronologia de funcionalidades Versão 0.9.10 (2013) Funcionalidade: Suporte a valores vazios em arquivos de configuração - Chaves com valores vazios (key=) agora são suportadas - Anteriormente eram ignoradas ou causavam erros de análise\nVersão 0.9.18 (2015) Funcionalidade: Configuração do intervalo de flush (esvaziamento do buffer) do logger - Propriedade: logger.flushInterval (padrão de 29 segundos) - Reduz a E/S de disco mantendo uma latência de log aceitável\nVersão 0.9.23 (novembro de 2015) Alteração importante: Java 7 como requisito mínimo - fim do suporte ao Java 6 - necessário para continuar recebendo atualizações de segurança\nVersão 0.9.25 (2015) Recursos: opções de segurança do servidor HTTP - tunnel.N.option.rejectReferer - Rejeita conexões com cabeçalho Referer - tunnel.N.option.rejectUserAgents - Rejeita cabeçalhos User-Agent específicos - tunnel.N.option.userAgentRejectList - Padrões de User-Agent para rejeitar - Caso de uso: Mitigar rastreadores e clientes indesejados\nVersão 0.9.33 (janeiro de 2018) Recurso: Filtragem de User-Agent aprimorada - a cadeia \u0026ldquo;none\u0026rdquo; em userAgentRejectList corresponde a um User-Agent vazio - Correções de bugs adicionais para i2psnark, i2ptunnel, streaming, SusiMail\nVersão 0.9.41 (2019) Descontinuação: Protocolo BOB removido do Android - usuários do Android devem migrar para SAM ou I2CP\nVersão 0.9.42 (agosto de 2019) Mudança importante: Separação dos arquivos de configuração - clients.config separado em uma estrutura de diretórios clients.config.d/ - i2ptunnel.config separado em uma estrutura de diretórios i2ptunnel.config.d/ - Migração automática na primeira execução após a atualização - Permite empacotamento modular e gerenciamento de plugins - O formato monolítico legado ainda é suportado\nRecursos adicionais: - Melhorias de desempenho do SSU - Prevenção de interconexão entre redes (Proposta 147) - Suporte inicial a tipos de criptografia\nVersão 0.9.56 (2021) Funcionalidades: Melhorias de segurança e de registro em log - logger.gzip - Compressão Gzip para logs rotacionados (padrão: false) - logger.minGzipSize - Tamanho mínimo para compressão (padrão: 65536 bytes) - tunnel.N.option.proxy.auth.USER.sha256 - Autenticação digest SHA-256 (RFC 7616) - Segurança: SHA-256 substitui MD5 para autenticação digest\nVersão 0.9.57 (janeiro de 2023) Recurso: Configuração do tipo de outproxy SOCKS (proxy de saída) - tunnel.N.option.outproxyType - Seleciona o tipo de outproxy (socks|connect) - Padrão: socks - Suporte a HTTPS CONNECT para outproxies HTTPS\nVersão 2.6.0 (julho de 2024) Mudança incompatível: I2P-over-Tor bloqueado - Conexões provenientes de endereços IP de nós de saída do Tor agora são rejeitadas - Motivo: Degrada o desempenho do I2P, desperdiça recursos dos nós de saída do Tor - Impacto: Usuários que acessarem o I2P por meio de nós de saída do Tor serão bloqueados - Nós retransmissores não de saída e clientes Tor não são afetados\nVersão 2.10.0 (setembro de 2025 - atual) Principais recursos: - Criptografia pós-quântica disponível (ativação opcional via Hidden Service Manager) - Suporte a tracker UDP para o I2PSnark para reduzir a carga do tracker - Estabilidade do Modo Oculto melhorias para reduzir o esgotamento de RouterInfo - Melhorias de rede para routers congestionados - Atravessamento UPnP/NAT aprimorado - Melhorias no NetDB com remoção agressiva de leaseset - Reduções de observabilidade para eventos do router\nConfiguração: Nenhuma nova propriedade de configuração foi adicionada\nAlteração crítica iminente: A próxima versão (provavelmente 2.11.0 ou 3.0.0) exigirá Java 17 ou posterior\nFuncionalidades obsoletas e alterações incompatíveis Descontinuações Críticas Acesso ao I2P-over-Tor (Versão 2.6.0+) Status: BLOQUEADO desde julho de 2024 Impacto: Conexões provenientes de IPs de nós de saída do Tor rejeitadas Motivo: Prejudica o desempenho da rede I2P sem fornecer benefícios de anonimato Afeta: Apenas nós de saída do Tor, não nós de retransmissão nem clientes comuns do Tor Alternativa: Use I2P ou Tor separadamente, não em conjunto Autenticação Digest MD5 Status: Obsoleto (use SHA-256) Property: tunnel.N.option.proxy.auth.USER.md5 Reason: MD5 criptograficamente quebrado Replacement: tunnel.N.option.proxy.auth.USER.sha256 (desde 0.9.56) Timeline: MD5 ainda é suportado, mas desaconselhado Alterações na Arquitetura de Configuração Arquivos de Configuração Monolíticos (Versão 0.9.42+) Afetados: clients.config, i2ptunnel.config Status: Descontinuado em favor de uma estrutura de diretórios separada Migração: Automática na primeira execução após a atualização para a versão 0.9.42 Compatibilidade: O formato legado ainda funciona (compatível com versões anteriores) Recomendação: Use o formato separado para novas configurações Requisitos de versão do Java Suporte ao Java 6 Encerrada: Versão 0.9.23 (novembro de 2015) Mínimo: Java 7 necessário desde 0.9.23 Requisito do Java 17 (Em breve) Status: MUDANÇA CRÍTICA IMINENTE Alvo: Próxima versão principal após 2.10.0 (provavelmente 2.11.0 ou 3.0.0) Mínimo atual: Java 8 Ação necessária: Preparar-se para a migração para o Java 17 Cronograma: A ser anunciado com as notas de versão Funcionalidades removidas Protocolo BOB (Android) Removido: Versão 0.9.41 Plataforma: Somente Android Alternativa: protocolos SAM ou I2CP Desktop: BOB (ponte básica do I2P) ainda está disponível em plataformas desktop Migrações recomendadas Autenticação: Migrar de MD5 para autenticação digest com SHA-256 Formato de Configuração: Migrar para estrutura de diretórios separada para clientes e tunnels Ambiente de Execução Java: Planejar a atualização para Java 17 antes da próxima versão principal Integração com Tor: Não rotear o I2P por meio de nós de saída do Tor Referências Documentação oficial Especificação de Configuração do I2P - Especificação oficial do formato de arquivo de configuração Especificação de Plugin do I2P - Configuração e empacotamento de plugins Estruturas Comuns do I2P - Mapeamento de Tipos - Formato de serialização de dados do protocolo Formato de Propriedades do Java - Especificação do formato base Código-fonte Repositório do I2P Java Router - Espelho no GitHub Gitea dos Desenvolvedores do I2P - Repositório oficial do código-fonte do I2P DataHelper.java - Implementação de E/S (entrada/saída) de arquivo de configuração Recursos da comunidade Fórum I2P - Discussões ativas da comunidade e suporte Site do I2P - Site oficial do projeto Documentação da API DataHelper JavaDoc - Documentação da API para métodos de arquivos de configuração Status da Especificação Última atualização da especificação: Janeiro de 2023 (Versão 0.9.57) Versão atual do I2P: 2.10.0 (Setembro de 2025) Precisão técnica: A especificação permanece precisa até a versão 2.10.0 (sem alterações incompatíveis) Manutenção: Documento vivo atualizado quando o formato de configuração é modificado ","description":"Opções de configuração e formatos para routers e clientes do I2P","id":"b6b01c53245c0e36ca08c56f843abb7f","section":"docs","title":"Configuração do Router","url":"/pt/docs/specs/configuration/"},{"categories":null,"content":"Os hosts de reseed são infraestrutura crucial para a rede I2P, fornecendo aos novos routers um grupo inicial de nós durante o processo de bootstrap. Este guia irá orientá-lo na configuração e execução do seu próprio servidor de reseed.\nO que é um Servidor de Reseed I2P? Um servidor de reseed I2P ajuda a integrar novos routers na rede I2P ao:\nFornecendo descoberta inicial de peers: Novos roteadores recebem um conjunto inicial de nós de rede para se conectar Recuperação de bootstrap: Ajudando roteadores que estão com dificuldades para manter conexões Distribuição segura: O processo de reseeding é criptografado e assinado digitalmente para garantir a segurança da rede Quando um novo router I2P é iniciado pela primeira vez (ou perdeu todas as suas conexões com peers), ele contacta servidores de reseed para baixar um conjunto inicial de informações de routers. Isso permite que o novo router comece a construir a sua própria netDb e estabelecer tunnels.\nPré-requisitos Antes de começar, você precisará de:\nUm servidor Linux (Debian/Ubuntu recomendado) com acesso root Um nome de domínio apontando para o seu servidor Pelo menos 1GB de RAM e 10GB de espaço em disco Um router I2P em execução no servidor para popular o netDb Familiaridade básica com administração de sistemas Linux Preparando o Servidor Step 1: Update System and Install Dependencies Primeiro, atualize o seu sistema e instale os pacotes necessários:\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt-get install golang-go git make docker.io docker-compose -y Isto instala: - golang-go: Runtime da linguagem de programação Go - git: Sistema de controle de versão - make: Ferramenta de automação de build - docker.io \u0026amp; docker-compose: Plataforma de contêineres para executar o Nginx Proxy Manager\nStep 2: Clone and Build Reseed Tools Clone o repositório reseed-tools e compile a aplicação:\ncd /home/i2p git clone https://i2pgit.org/idk/reseed-tools cd reseed-tools make build sudo make install O pacote reseed-tools fornece a funcionalidade principal para executar um servidor de reseed. Ele cuida de: - Coletar informações de router do seu banco de dados de rede local - Empacotar informações de router em arquivos SU3 assinados - Servir esses arquivos via HTTPS\nStep 3: Generate SSL Certificate Gere o certificado SSL e a chave privada do seu servidor de reseed:\nsu - i2p -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Parâmetros importantes: - --signer: Seu endereço de email (substitua admin@stormycloud.org pelo seu próprio) - --netdb: Caminho para o banco de dados de rede do seu router I2P - --port: Porta interna (8443 é recomendada) - --ip: Vincular ao localhost (usaremos um proxy reverso para acesso público) - --trustProxy: Confiar nos cabeçalhos X-Forwarded-For do proxy reverso\nO comando irá gerar: - Uma chave privada para assinar arquivos SU3 - Um certificado SSL para conexões HTTPS seguras\nPasso 1: Atualizar o Sistema e Instalar Dependências Crítico: Faça backup seguro das chaves geradas localizadas em /home/i2p/.reseed/:\nsudo tar -czf reseed-keys-backup.tar.gz /home/i2p/.reseed/ Armazene este backup em um local seguro e criptografado com acesso limitado. Essas chaves são essenciais para a operação do seu servidor de reseed e devem ser protegidas cuidadosamente.\nConfiguring the Service Passo 2: Clonar e Compilar as Ferramentas de Reseed Crie um serviço systemd para executar o servidor de reseed automaticamente:\nsudo tee /etc/systemd/system/reseed.service \u0026lt;\u0026lt;EOF [Unit] Description=Reseed Service After=network.target [Service] User=i2p WorkingDirectory=/home/i2p ExecStart=/bin/bash -c \u0026#39;reseed-tools reseed --signer=admin@stormycloud.org --netdb=/home/i2p/.i2p/netDb --port=8443 --ip=127.0.0.1 --trustProxy\u0026#39; Restart=always RestartSec=10 [Install] WantedBy=multi-user.target EOF Lembre-se de substituir admin@stormycloud.org pelo seu próprio endereço de email.\nAgora ative e inicie o serviço:\nsudo systemctl daemon-reload sudo systemctl enable reseed sudo systemctl start reseed Verifique se o serviço está em execução:\nsudo systemctl status reseed Passo 3: Gerar Certificado SSL Para desempenho ideal, você pode querer reiniciar o serviço de reseed periodicamente para atualizar as informações do router:\nsudo crontab -e Adicione esta linha para reiniciar o serviço a cada 3 horas:\n0 */3 * * * systemctl restart reseed Setting Up Reverse Proxy O servidor de reseed é executado em localhost:8443 e precisa de um proxy reverso para lidar com o tráfego HTTPS público. Recomendamos o Nginx Proxy Manager pela sua facilidade de uso.\nPasso 4: Faça Backup das Suas Chaves Implantar o Nginx Proxy Manager usando Docker:\ndocker run -d \\ --name nginx-proxy-manager \\ -p 80:80 \\ -p 81:81 \\ -p 443:443 \\ -v $(pwd)/data:/data \\ -v $(pwd)/letsencrypt:/etc/letsencrypt \\ --restart unless-stopped \\ jc21/nginx-proxy-manager:latest Isto expõe: - Porta 80: Tráfego HTTP - Porta 81: Interface de administração - Porta 443: Tráfego HTTPS\nConfigure Proxy Manager Acesse a interface de administração em http://your-server-ip:81\nFaça login com as credenciais padrão:\nEmail: admin@example.com Senha: changeme Importante: Altere estas credenciais imediatamente após o primeiro login!\nNavegue até Proxy Hosts e clique em Add Proxy Host Configure o host proxy: Domain Name: Seu domínio de reseed (ex: reseed.example.com) Scheme: https Forward Hostname / IP: 127.0.0.1 Forward Port: 8443 Ative Cache Assets Ative Block Common Exploits Ative Websockets Support Na aba SSL: Selecione Request a new SSL Certificate (Let\u0026rsquo;s Encrypt) Ative Force SSL Ative HTTP/2 Support Aceite os Termos de Serviço do Let\u0026rsquo;s Encrypt Clique em Save O seu servidor de reseed deverá agora estar acessível em https://reseed.example.com\nRegistering Your Reseed Server Assim que o seu servidor de reseed estiver operacional, entre em contato com os desenvolvedores do I2P para adicioná-lo à lista oficial de servidores de reseed.\nPasso 5: Criar Serviço Systemd Envie um email para zzz (desenvolvedor líder do I2P) com as seguintes informações:\nEmail I2P: zzz@mail.i2p Email Clearnet: zzz@i2pmail.org Passo 6: Opcional - Configurar Reinicializações Periódicas Inclua no seu email:\nURL do servidor de reseed: A URL HTTPS completa (ex.: https://reseed.example.com) Certificado público de reseed: Localizado em /home/i2p/.reseed/ (anexe o arquivo .crt) Email de contato: Seu método de contato preferido para notificações de manutenção do servidor Localização do servidor: Opcional, mas útil (país/região) Tempo de atividade esperado: Seu compromisso em manter o servidor Verification Os desenvolvedores do I2P irão verificar se o seu servidor de reseed está: - Devidamente configurado e servindo informações de router - Usando certificados SSL válidos - Fornecendo arquivos SU3 corretamente assinados - Acessível e responsivo\nUma vez aprovado, seu servidor de reseed será adicionado à lista distribuída com os roteadores I2P, ajudando novos usuários a entrarem na rede!\nMonitoring and Maintenance Instalar o Nginx Proxy Manager Monitore seu serviço de reseed:\nsudo systemctl status reseed sudo journalctl -u reseed -f Configurar o Gestor de Proxy Fique de olho nos recursos do sistema:\nhtop df -h Update Reseed Tools Atualize periodicamente as reseed-tools para obter as últimas melhorias:\ncd /home/i2p/reseed-tools git pull make build sudo make install sudo systemctl restart reseed Informações de Contato Se estiver usando Let\u0026rsquo;s Encrypt através do Nginx Proxy Manager, os certificados renovarão automaticamente. Verifique se a renovação está funcionando:\ndocker logs nginx-proxy-manager | grep -i certificate Configurando o Serviço Informação Obrigatória Verifique os logs em busca de erros:\nsudo journalctl -u reseed -n 50 Problemas comuns: - Router I2P não está em execução ou a base de dados de rede está vazia - Porta 8443 já está em uso - Problemas de permissão com o diretório /home/i2p/.reseed/\nVerificação Certifique-se de que o seu router I2P está em execução e preencheu a sua base de dados de rede:\nls -lh /home/i2p/.i2p/netDb/ Você deverá ver muitos arquivos .dat. Se estiver vazio, aguarde até que o seu roteador I2P descubra peers.\nSSL Certificate Errors Verifique se seus certificados são válidos:\nopenssl s_client -connect reseed.example.com:443 -servername reseed.example.com Verificar Status do Serviço Verifique: - Os registros DNS estão apontando corretamente para o seu servidor - O firewall permite as portas 80 e 443 - O Nginx Proxy Manager está em execução: docker ps\nSecurity Considerations Mantenha suas chaves privadas seguras: Nunca compartilhe ou exponha o conteúdo de /home/i2p/.reseed/ Atualizações regulares: Mantenha os pacotes do sistema, Docker e reseed-tools atualizados Monitore os logs: Fique atento a padrões de acesso suspeitos Limitação de taxa: Considere implementar limitação de taxa para prevenir abuso Regras de firewall: Exponha apenas as portas necessárias (80, 443, 81 para admin) Interface administrativa: Restrinja a interface administrativa do Nginx Proxy Manager (porta 81) a IPs confiáveis Contributing to the Network Ao executar um servidor de reseed, você está fornecendo infraestrutura crítica para a rede I2P. Obrigado por contribuir para uma internet mais privada e descentralizada!\nPara dúvidas ou assistência, entre em contato com a comunidade I2P: - Fórum: i2pforum.net - IRC/Reddit: #i2p em várias redes - Desenvolvimento: i2pgit.org IMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um título ou pareça incompleto, traduza-o como está.\nGuia originalmente criado por Stormy Cloud , adaptado para a documentação I2P.\n","description":"Guia completo para configurar e operar um servidor de reseed I2P para ajudar novos routers a ingressarem na rede","id":"d360e14f0f61d776e3c0b0f5b1262be5","section":"docs","title":"Criando e Executando um Servidor de Reseed I2P","url":"/pt/docs/guides/criando-e-executando-um-servidor-de-reseed-i2p/"},{"categories":null,"content":"O que é um Eepsite (site acessível apenas pela rede I2P)? Um eepsite é um site que existe exclusivamente na rede I2P. Ao contrário dos sites tradicionais acessíveis pela clearnet (internet pública), os eepsites só podem ser alcançados por meio do I2P, oferecendo anonimato e privacidade tanto para o operador do site quanto para os visitantes. Os eepsites usam o pseudo-domínio de topo .i2p e são acessados por meio de endereços especiais .b32.i2p ou nomes legíveis por humanos registrados no livro de endereços do I2P.\nTodas as implantações do I2P em Java vêm com o Jetty , um servidor web leve baseado em Java, pré-instalado e pré-configurado. Isso torna simples começar a hospedar seu próprio eepsite em poucos minutos — sem necessidade de instalar software adicional.\nEste guia guiará você passo a passo pelo processo de criar e configurar seu primeiro eepsite usando as ferramentas integradas do I2P.\nPasso 1: Acesse o Gerenciador de Serviços Ocultos O Gerenciador de Serviços Ocultos (também chamado de I2P Tunnel Manager) é onde você configura todos os tunnels de servidor e de cliente do I2P, incluindo servidores HTTP (eepsites).\nAbra o seu I2P Router Console Navegue até o Gerenciador de Serviços Ocultos Você deve ver a interface do Gerenciador de Serviços Ocultos mostrando: - Mensagens de status - Estado atual do tunnel e do cliente - Controle Global de Tunnel - Botões para gerenciar todos os tunnels de uma vez - Serviços Ocultos do I2P - Lista de tunnels de servidor configurados\nPor padrão, você verá uma entrada existente de servidor web I2P configurada, mas não iniciada. Este é o servidor web Jetty pré-configurado, pronto para você usar.\nEtapa 2: Configure as configurações do servidor do seu Eepsite Clique no item I2P webserver na lista de Serviços Ocultos para abrir a página de configuração do servidor. É aqui que você personalizará as configurações do seu eepsite (site hospedado na rede I2P).\nOpções de Configuração Explicadas Nome - Este é um identificador interno para o seu tunnel - Útil se você estiver executando vários eepsites para manter o controle de qual é qual - Padrão: \u0026ldquo;I2P webserver\u0026rdquo;\nDescrição - Uma breve descrição do seu eepsite para sua própria referência - Visível apenas para você no Gerenciador de Serviços Ocultos - Exemplo: \u0026ldquo;Meu eepsite\u0026rdquo; ou \u0026ldquo;Blog pessoal\u0026rdquo;\nInício automático do Tunnel - Importante: Marque esta caixa para iniciar automaticamente sua eepsite quando seu router I2P iniciar - Garante que seu site permaneça disponível sem intervenção manual após reinicializações do router - Recomendado: Ativado\nDestino (Host e Porta) - Host: O endereço local onde seu servidor web está em execução (padrão: 127.0.0.1) - Porta: A porta em que seu servidor web escuta (padrão: 7658 para o Jetty) - Se você estiver usando o servidor web Jetty pré-instalado, deixe estes com os valores padrão - Só altere se estiver executando um servidor web personalizado em uma porta diferente\nNome de host do site - Este é o nome de domínio .i2p legível por humanos do seu eepsite - Padrão: mysite.i2p (exemplo) - Você pode registrar um domínio personalizado como stormycloud.i2p ou myblog.i2p - Deixe em branco se você quiser usar apenas o endereço .b32.i2p gerado automaticamente (para outproxies (proxies de saída)) - Veja Registrando seu domínio I2P abaixo para saber como reivindicar um nome de host personalizado\nDestino local - Este é o identificador criptográfico exclusivo do seu eepsite (endereço de destino) - Gerado automaticamente quando o tunnel é criado pela primeira vez - Pense nisso como o \u0026ldquo;endereço IP\u0026rdquo; permanente do seu site no I2P - A longa sequência alfanumérica é o endereço .b32.i2p do seu site em formato codificado\nArquivo de chave privada - Local onde as chaves privadas do seu eepsite são armazenadas - Padrão: eepsite/eepPriv.dat - Mantenha este arquivo seguro - qualquer pessoa com acesso a este arquivo pode assumir a identidade do seu eepsite - Nunca compartilhe nem exclua este arquivo\nNota importante A caixa de aviso amarela lembra você de que, para ativar a geração de códigos QR ou os recursos de registro e autenticação, você deve configurar um Nome de Host do Site com o sufixo .i2p (por exemplo, mynewsite.i2p).\nEtapa 3: Opções Avançadas de Rede (Opcional) Se você rolar para baixo na página de configuração, encontrará opções avançadas de rede. Essas configurações são opcionais - as configurações padrão funcionam bem para a maioria dos usuários. No entanto, você pode ajustá-las com base nos seus requisitos de segurança e necessidades de desempenho.\nOpções de Comprimento do Tunnel Comprimento do tunnel - Padrão: tunnel de 3 saltos (alto anonimato) - Controla quantos saltos de router uma solicitação atravessa antes de chegar ao seu eepsite - Mais saltos = Anonimato maior, mas desempenho mais lento - Menos saltos = Desempenho mais rápido, mas anonimato reduzido - As opções vão de 0 a 3 saltos, com configurações de variância - Recomendação: Mantenha em 3 saltos, a menos que você tenha requisitos específicos de desempenho\nVariação de tunnel - Padrão: 0 de variação de saltos (sem aleatoriedade, desempenho consistente) - Adiciona aleatoriedade ao comprimento do tunnel para maior segurança - Exemplo: \u0026ldquo;0-1 de variação de saltos\u0026rdquo; significa que os tunnels serão aleatoriamente de 3 ou 4 saltos - Aumenta a imprevisibilidade, mas pode causar tempos de carregamento inconsistentes\nOpções de Quantidade de Túneis Quantidade (tunnels de entrada/saída) - Padrão: 2 tunnels de entrada, 2 tunnels de saída (largura de banda e confiabilidade padrão) - Controla quantos tunnels paralelos são dedicados ao seu eepsite - Mais tunnels = Melhor disponibilidade e capacidade de lidar com carga, porém maior uso de recursos - Menos tunnels = Menor uso de recursos, porém menor redundância - Recomendado para a maioria dos usuários: 2/2 (padrão) - Sites de alto tráfego podem se beneficiar de 3/3 ou mais\nNúmero de tunnels de backup - Padrão: 0 backup tunnels (sem redundância, sem uso adicional de recursos) - tunnels em espera que são ativados se os tunnels primários falharem - Aumenta a confiabilidade, mas consome mais largura de banda e CPU - A maioria dos eepsites pessoais não precisa de backup tunnels\nLimites de POST Se o seu eepsite incluir formulários (formulários de contato, seções de comentários, envio de arquivos, etc.), você pode configurar limites para requisições POST para evitar abuso:\nLimites por Cliente - Por Período: Número máximo de solicitações de um único cliente (padrão: 6 a cada 5 minutos) - Duração do Bloqueio: Por quanto tempo bloquear clientes abusivos (padrão: 20 minutos)\nLimites Totais - Total: Número máximo de requisições POST de todos os clientes somadas (padrão: 20 a cada 5 minutos) - Duração do bloqueio: Por quanto tempo rejeitar todas as requisições POST se o limite for excedido (padrão: 10 minutos)\nPeríodo de Limite de POST - Intervalo de tempo para medir a taxa de requisições (padrão: 5 minutos)\nEsses limites ajudam a proteger contra spam, ataques de negação de serviço e abuso de envio automatizado de formulários.\nQuando Ajustar as Configurações Avançadas Site comunitário de alto tráfego: Aumente a quantidade de tunnels (3-4 de entrada/de saída) Aplicação com desempenho crítico: Reduza o comprimento do tunnel para 2 saltos (compromisso de privacidade) Anonimato máximo exigido: Mantenha 3 saltos, adicione 0-1 de variância Formulários com uso legítimo elevado: Aumente os limites de POST conforme necessário Blog/portfólio pessoal: Use todos os valores padrão Etapa 4: Adicionando conteúdo ao seu Eepsite Agora que seu eepsite está configurado, você precisa adicionar os arquivos do seu site (HTML, CSS, imagens, etc.) ao diretório raiz de documentos do servidor web. A localização varia dependendo do seu sistema operacional, do tipo de instalação e da implementação do I2P.\nEncontrando o diretório raiz do site A raiz do documento (frequentemente chamada de docroot) é o diretório onde você coloca todos os arquivos do seu site. Seu arquivo index.html deve ir diretamente nesse diretório.\nJava I2P (Distribuição Padrão) Linux - Instalação padrão: ~/.i2p/eepsite/docroot/ - Instalação por pacote (executando como serviço): /var/lib/i2p/i2p-config/eepsite/docroot/\nWindows - Instalação padrão: %LOCALAPPDATA%\\I2P\\eepsite\\docroot\\ - Caminho típico: C:\\Users\\YourUsername\\AppData\\Local\\I2P\\eepsite\\docroot\\ - Instalação como Serviço do Windows: %PROGRAMDATA%\\I2P\\eepsite\\docroot\\ - Caminho típico: C:\\ProgramData\\I2P\\eepsite\\docroot\\\nmacOS - Instalação padrão: /Users/YourUsername/Library/Application Support/i2p/eepsite/docroot/\nI2P+ (Distribuição I2P Aprimorada) O I2P+ usa a mesma estrutura de diretórios que o Java I2P. Siga os caminhos acima de acordo com o seu sistema operacional.\ni2pd (Implementação em C++) Linux/Unix - Padrão: /var/lib/i2pd/eepsite/ ou ~/.i2pd/eepsite/ - Verifique o arquivo de configuração i2pd.conf para a definição real de root no tunnel do seu servidor HTTP\nWindows - Verifique i2pd.conf no diretório de instalação do i2pd\nmacOS - Normalmente: ~/Library/Application Support/i2pd/eepsite/\nAdicionando os arquivos do seu site Navegue até o diretório raiz do seu site usando o seu gerenciador de arquivos ou o terminal Crie ou copie os arquivos do seu site para a pasta docroot No mínimo, crie um arquivo index.html (esta é a sua página inicial) Adicione CSS, JavaScript, imagens e outros recursos conforme necessário Organize os subdiretórios como você faria para qualquer site: docroot/ ├── index.html ├── about.html ├── css/ │ └── style.css ├── images/ │ └── logo.png └── js/ └── script.js Início rápido: Exemplo simples de HTML Se você está apenas começando, crie um arquivo básico index.html na sua pasta docroot:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My I2P Eepsite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to My Eepsite!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is my first website on the I2P network.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Privacy-focused and decentralized!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Permissões (Linux/Unix/macOS) Se você estiver executando o I2P como um serviço ou com um usuário diferente, certifique-se de que o processo do I2P tenha acesso de leitura aos seus arquivos:\n# Set appropriate ownership (if running as i2p user) sudo chown -R i2p:i2p /var/lib/i2p/i2p-config/eepsite/docroot/ # Or set readable permissions for all users chmod -R 755 ~/.i2p/eepsite/docroot/ Dicas Conteúdo padrão: Quando você instala o I2P pela primeira vez, já há conteúdo de exemplo na pasta docroot - sinta-se à vontade para substituí-lo Sites estáticos funcionam melhor: Embora o Jetty suporte servlets e JSP, sites simples em HTML/CSS/JavaScript são mais fáceis de manter Servidores web externos: Usuários avançados podem executar servidores web personalizados (Apache, Nginx, Node.js, etc.) em portas diferentes e apontar o I2P tunnel para eles Etapa 5: Iniciando seu Eepsite Agora que o seu eepsite está configurado e tem conteúdo, é hora de iniciá-lo e torná-lo acessível na rede I2P.\nIniciar o Tunnel Volte ao Gerenciador de Serviços Ocultos Encontre a sua entrada do servidor web I2P na lista Clique no botão Iniciar na coluna Controle Aguardar o estabelecimento do tunnel Depois de clicar em Iniciar, seu eepsite tunnel começará a ser construído. Esse processo normalmente leva 30-60 segundos. Observe o indicador de status:\nLuz vermelha = Tunnel iniciando/em construção Luz amarela = Tunnel parcialmente estabelecido Luz verde = Tunnel totalmente operacional e pronto Assim que você vir a luz verde, seu eepsite estará no ar na rede I2P!\nAcesse seu Eepsite Clique no botão Preview ao lado do seu eepsite em execução. Isso abrirá uma nova aba do navegador com o endereço do seu eepsite.\nSeu eepsite possui dois tipos de endereços:\nEndereço Base32 (.b32.i2p): Um endereço criptográfico longo que se parece com:\nhttp://fcyianvr325tdgiiueyg4rsq4r5iuibzovl26msox5ryoselykpq.b32.i2p Este é o endereço permanente, derivado criptograficamente, do seu eepsite Não pode ser alterado e está vinculado à sua chave privada Funciona sempre, mesmo sem registro de domínio Domínio legível por humanos (.i2p): Se você definir um Nome de host do site (por exemplo, testwebsite.i2p)\nSó funciona após o registro de domínio (veja a próxima seção) Mais fácil de lembrar e compartilhar Aponta para o seu endereço .b32.i2p O botão Copy Hostname permite copiar rapidamente o seu endereço .b32.i2p completo para compartilhamento.\n⚠️ Crítico: Faça backup da sua chave privada Antes de prosseguir, você deve fazer backup do arquivo de chave privada do seu eepsite. Isto é crucial por vários motivos:\nPor que fazer backup da sua chave? Sua chave privada (eepPriv.dat) é a identidade do seu eepsite. Ela determina o seu endereço .b32.i2p e comprova a propriedade do seu eepsite.\nChave = endereço .b32: Sua chave privada gera matematicamente seu endereço .b32.i2p exclusivo Não pode ser recuperada: Se você perder sua chave, perderá permanentemente o endereço da sua eepsite Não pode ser alterado: Se você registrou um domínio apontando para um endereço .b32, não há como atualizá-lo - o registro é permanente Necessária para migração: Migrar para um novo computador ou reinstalar o I2P requer essa chave para manter o mesmo endereço Suporte a multihoming (hospedagem a partir de múltiplas localizações): Executar sua eepsite a partir de múltiplos locais requer a mesma chave em cada servidor Onde está a chave privada? Por padrão, sua chave privada é armazenada em: - Linux: ~/.i2p/eepsite/eepPriv.dat (ou /var/lib/i2p/i2p-config/eepsite/eepPriv.dat para instalações como serviço) - Windows: %LOCALAPPDATA%\\I2P\\eepsite\\eepPriv.dat ou %PROGRAMDATA%\\I2P\\eepsite\\eepPriv.dat - macOS: /Users/YourUsername/Library/Application Support/i2p/eepsite/eepPriv.dat\nVocê também pode verificar/alterar esse caminho na configuração do seu tunnel em \u0026ldquo;Private Key File\u0026rdquo;.\nComo fazer backup Pare o seu tunnel (túnel do I2P; opcional, mas mais seguro) Copie eepPriv.dat para um local seguro: Unidade USB externa Unidade de backup criptografada Arquivo protegido por senha Armazenamento em nuvem seguro (criptografado) Mantenha vários backups em diferentes locais físicos Nunca compartilhe este arquivo - qualquer pessoa com ele pode se passar pelo seu eepsite (site hospedado no I2P) Restaurar a partir do backup Para restaurar seu eepsite em um novo sistema ou após uma reinstalação:\nInstale o I2P e crie/configure as configurações do seu tunnel Pare o tunnel antes de copiar a chave Copie o seu eepPriv.dat de backup para o local correto Inicie o tunnel - ele usará seu endereço .b32 original Se você não for registrar um domínio Parabéns! Se você não planeja registrar um nome de domínio .i2p personalizado, seu eepsite agora está completo e operacional.\nVocê pode: - Compartilhar seu endereço .b32.i2p com outras pessoas - Acessar seu site pela rede I2P usando qualquer navegador compatível com I2P - Atualizar os arquivos do seu site na pasta docroot a qualquer momento - Monitorar o status do seu tunnel no Gerenciador de Serviços Ocultos\nSe você quiser um domínio legível por humanos (como mysite.i2p em vez de um endereço .b32 longo), continue para a próxima seção.\nRegistrando seu domínio I2P Um domínio .i2p legível por humanos (como testwebsite.i2p) é muito mais fácil de lembrar e compartilhar do que um endereço .b32.i2p longo. O registro de domínio é gratuito e vincula o nome escolhido ao endereço criptográfico do seu eepsite.\nPré-requisitos Seu eepsite deve estar em execução com a luz verde acesa Você deve ter definido um Nome de host do site na configuração do seu tunnel (Etapa 2) Exemplo: testwebsite.i2p ou myblog.i2p Etapa 1: Gerar string de autenticação Volte para a configuração do seu tunnel no Hidden Services Manager Clique na sua entrada do servidor web I2P para abrir as configurações Role a página para baixo para encontrar o botão Registration Authentication Clique em Autenticação de Registro Copie toda a cadeia de autenticação mostrada para \u0026ldquo;Autenticação para adicionar o host [yourdomainhere]\u0026rdquo; A sequência de autenticação terá o seguinte formato:\ntestwebsite.i2p=I8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1iPForksdU3GALrQq4S73meoIIXarCCdb~Z6Ehj2-yLWI8WiuSx1TcYAutCrhLveZ6gghdqsIJ1v9noSGPb7ItYjxaK5LHVNxgC60KuEu95nqCCF2qwgnW~2ehIY9vsi1uNxFZ0HN7tQbbVj1pmbahepQZNxEW0ufwnMYAoFo8opBQAEAAcAAA==#!date=1762104890#sig=9DjEfrcNRxsoSxiE0Mp0-7rH~ktYWtgwU8c4J0eSo0VHbGxDxdiO9D1Cvwcx8hkherMO07UWOC9BWf-1wRyUAw== Esta cadeia de caracteres contém: - O seu nome de domínio (testwebsite.i2p) - O seu endereço de destino (o identificador criptográfico longo) - Um carimbo de data/hora - Uma assinatura criptográfica que comprova que você possui a chave privada\nGuarde esta cadeia de autenticação - você vai precisar dela para ambos os serviços de registro.\nEtapa 2: Registre-se em stats.i2p Acesse stats.i2p Adicionar chave (dentro do I2P) Cole a string de autenticação no campo \u0026ldquo;Authentication String\u0026rdquo; Adicione seu nome (opcional) - o padrão é \u0026ldquo;Anonymous\u0026rdquo; Adicione uma descrição (recomendado) - descreva brevemente do que se trata o seu eepsite Exemplo: \u0026ldquo;Novo I2P Eepsite\u0026rdquo;, \u0026ldquo;Blog pessoal\u0026rdquo;, \u0026ldquo;Serviço de compartilhamento de arquivos\u0026rdquo; Marque \u0026ldquo;HTTP Service?\u0026rdquo; se for um site (mantenha marcado para a maioria dos eepsites) Desmarque para IRC, NNTP, proxies, XMPP, git, etc. Clique em Submit Se for bem-sucedido, você verá uma confirmação de que seu domínio foi adicionado ao livro de endereços do stats.i2p.\nPasso 3: Registre-se no reg.i2p Para garantir a máxima disponibilidade, você também deve se registrar no serviço reg.i2p:\nAcesse reg.i2p Add Domain (dentro do I2P) Cole a mesma string de autenticação no campo \u0026ldquo;Auth string\u0026rdquo; Adicione uma descrição (opcional, mas recomendável) Isso ajuda outros usuários do I2P a entender o que o seu site oferece Clique em Submit Você deve receber uma confirmação de que seu domínio foi registrado.\nEtapa 4: Aguarde a propagação Após enviar para ambos os serviços, o registro do seu domínio se propagará pelo sistema de livro de endereços da rede I2P.\nCronograma de propagação: - Registro inicial: imediato nos serviços de registro - Propagação em toda a rede: de várias horas a mais de 24 horas - Disponibilidade total: pode levar até 48 horas para que todos os routers sejam atualizados\nIsso é normal! O sistema de livro de endereços do I2P é atualizado periodicamente, não instantaneamente. Seu eepsite está funcionando - outros usuários só precisam receber o livro de endereços atualizado.\nVerifique seu domínio Após algumas horas, você pode testar seu domínio:\nAbra uma nova aba do navegador no seu navegador I2P Tente acessar seu domínio diretamente: http://yourdomainname.i2p Se carregar, seu domínio está registrado e em propagação! Se ainda não funcionar: - Espere mais (os livros de endereços são atualizados no seu próprio cronograma) - O livro de endereços do seu router pode precisar de tempo para sincronizar - Tente reiniciar o seu router I2P para forçar uma atualização do livro de endereços\nNotas importantes O registro é permanente: Uma vez registrado e propagado, seu domínio aponta para o seu endereço .b32.i2p permanentemente Não é possível alterar o destino: Você não pode atualizar para qual endereço .b32.i2p o seu domínio aponta - por isso fazer backup do eepPriv.dat é fundamental Propriedade do domínio: Apenas o detentor da chave privada pode registrar ou atualizar o domínio Serviço gratuito: O registro de domínios no I2P é gratuito, mantido pela comunidade e descentralizado Múltiplos registradores: Registrar tanto no stats.i2p quanto no reg.i2p aumenta a confiabilidade e a velocidade de propagação Parabéns! Seu I2P eepsite agora está totalmente operacional com um domínio registrado!\nPróximos passos: - Adicione mais conteúdo à sua pasta docroot - Compartilhe seu domínio com a comunidade I2P - Mantenha seu backup eepPriv.dat em segurança - Monitore o status do seu tunnel (túnel do I2P) regularmente - Considere participar dos fóruns do I2P ou do IRC para divulgar seu site\nBem-vindo à rede I2P! 🎉\n","description":"Aprenda a criar e hospedar seu próprio site na rede I2P usando o servidor web Jetty integrado","id":"cdd089b486cced0cc2a37529ae0ace6b","section":"docs","title":"Criando um Eepsite no I2P","url":"/pt/docs/guides/criando-um-eepsite-no-i2p/"},{"categories":null,"content":"Um túnel SSH fornece uma conexão segura e criptografada para acessar o console do seu router I2P remoto ou outros serviços. Este guia mostra como criar túneis SSH em sistemas Windows, Linux e Mac.\nO que é um Túnel SSH? Um túnel SSH é um método de encaminhar dados e informações de forma segura através de uma conexão SSH criptografada. Pense nisso como criar um \u0026ldquo;canal\u0026rdquo; protegido através da internet - seus dados viajam através deste túnel criptografado, impedindo que qualquer pessoa os intercepte ou leia ao longo do caminho.\nO tunelamento SSH é particularmente útil para:\nAcessar routers I2P remotos: Conecte-se ao seu console I2P em execução em um servidor remoto Conexões seguras: Todo o tráfego é criptografado de ponta a ponta Contornar restrições: Acesse serviços em sistemas remotos como se fossem locais Redirecionamento de portas: Mapeie uma porta local para um serviço remoto No contexto do I2P, você pode usar um túnel SSH para acessar o console do seu router I2P (normalmente na porta 7657) em um servidor remoto, encaminhando-o para uma porta local no seu computador.\nPré-requisitos Antes de criar um túnel SSH, você precisará de:\nCliente SSH: Windows: PuTTY (download gratuito) Linux/Mac: Cliente SSH integrado (via Terminal) Acesso ao servidor remoto: Nome de usuário para o servidor remoto Endereço IP ou hostname do servidor remoto Senha SSH ou autenticação baseada em chave Porta local disponível: Escolha uma porta não utilizada entre 1-65535 (7657 é comumente usada para I2P) Compreendendo o Comando Tunnel O comando de túnel SSH segue este padrão:\nssh -L [local_port]:[destination_ip]:[destination_port] [username]@[remote_server] Parâmetros explicados: - local_port: A porta na sua máquina local (por exemplo, 7657) - destination_ip: Geralmente 127.0.0.1 (localhost no servidor remoto) - destination_port: A porta do serviço no servidor remoto (por exemplo, 7657 para I2P) - username: Seu nome de usuário no servidor remoto - remote_server: Endereço IP ou hostname do servidor remoto\nExemplo: ssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58\nIsto cria um túnel onde: - A porta local 7657 na sua máquina encaminha para\u0026hellip; - A porta 7657 no localhost do servidor remoto (onde o I2P está em execução) - Conectando como usuário i2p ao servidor 20.228.143.58\nCriando Túneis SSH no Windows Utilizadores Windows podem criar túneis SSH usando o PuTTY, um cliente SSH gratuito.\nStep 1: Download and Install PuTTY Baixe o PuTTY em putty.org e instale-o no seu sistema Windows.\nStep 2: Configure the SSH Connection Abra o PuTTY e configure sua conexão:\nNa categoria Session: Insira o endereço IP ou hostname do seu servidor remoto no campo Host Name Certifique-se de que Port está definido como 22 (porta SSH padrão) O tipo de conexão deve ser SSH Step 3: Configure the Tunnel Navegue para Connection → SSH → Tunnels na barra lateral esquerda:\nPorta de origem: Insira a porta local que você deseja usar (por exemplo, 7657) Destino: Insira 127.0.0.1:7657 (localhost:porta no servidor remoto) Clique em Adicionar para adicionar o tunnel O tunnel deve aparecer na lista \u0026ldquo;Portas encaminhadas\u0026rdquo; Step 4: Connect Clique em Abrir para iniciar a conexão Se esta for sua primeira vez conectando, você verá um alerta de segurança - clique em Sim para confiar no servidor Digite seu nome de usuário quando solicitado Digite sua senha quando solicitado Uma vez conectado, você pode acessar seu console I2P remoto abrindo um navegador e navegando até http://127.0.0.1:7657\nPasso 1: Baixar e Instalar o PuTTY Para evitar reconfigurar cada vez:\nRetorne à categoria Session Digite um nome em Saved Sessions (por exemplo, \u0026ldquo;I2P Tunnel\u0026rdquo;) Clique em Save Na próxima vez, apenas carregue esta sessão e clique em Open Creating SSH Tunnels on Linux Sistemas Linux possuem SSH integrado ao terminal, tornando a criação de túneis rápida e direta.\nPasso 2: Configurar a Conexão SSH Abra um terminal e execute o comando de túnel SSH:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Substituir: - 7657 (primeira ocorrência): A porta local desejada - 127.0.0.1:7657: O endereço de destino e porta no servidor remoto - i2p: Seu nome de usuário no servidor remoto - 20.228.143.58: O endereço IP do seu servidor remoto\nQuando solicitado, insira sua senha. Uma vez conectado, o túnel estará ativo.\nAcesse seu console I2P remoto em http://127.0.0.1:7657 no seu navegador.\nPasso 3: Configurar o Túnel O túnel permanece ativo enquanto a sessão SSH estiver em execução. Para mantê-lo em execução em segundo plano:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Flags adicionais: - -f: Executa o SSH em segundo plano - -N: Não executa comandos remotos (apenas túnel)\nPara fechar um túnel em segundo plano, encontre e encerre o processo SSH:\nps aux | grep ssh kill [process_id] Passo 4: Conectar Para maior segurança e conveniência, use autenticação por chave SSH:\nGere um par de chaves SSH (se você ainda não tiver um):\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; Copie sua chave pública para o servidor remoto:\nssh-copy-id i2p@20.228.143.58 Agora você pode conectar sem senha:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Creating SSH Tunnels on Mac Os sistemas Mac usam o mesmo cliente SSH que o Linux, portanto o processo é idêntico.\nOpcional: Salvar Sua Sessão Abra o Terminal (Aplicações → Utilitários → Terminal) e execute:\nssh -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Substituir: - 7657 (primeira ocorrência): A porta local desejada - 127.0.0.1:7657: O endereço de destino e porta no servidor remoto - i2p: Seu nome de usuário no servidor remoto - 20.228.143.58: O endereço IP do seu servidor remoto\nDigite sua senha quando solicitado. Uma vez conectado, acesse seu console I2P remoto em http://127.0.0.1:7657\nBackground Tunnels on Mac Assim como no Linux, você pode executar o túnel em segundo plano:\nssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Usando o Terminal A configuração de chaves SSH no Mac é idêntica à do Linux:\n# Generate key (if needed) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # Copy to remote server ssh-copy-id i2p@20.228.143.58 Common Use Cases Mantendo o Túnel Ativo O caso de uso mais comum - acessar o console do seu router I2P remoto:\nssh -L 7657:127.0.0.1:7657 user@remote-server Em seguida, abra http://127.0.0.1:7657 no seu navegador.\nUsando Chaves SSH (Recomendado) Encaminhar múltiplas portas de uma vez:\nssh -L 7657:127.0.0.1:7657 -L 7658:127.0.0.1:7658 user@remote-server Isso encaminha tanto a porta 7657 (console I2P) quanto a 7658 (outro serviço).\nCustom Local Port Use uma porta local diferente se a 7657 já estiver em uso:\nssh -L 8080:127.0.0.1:7657 user@remote-server Acesse o console I2P em http://127.0.0.1:8080 em vez disso.\nTroubleshooting Usando o Terminal Erro: \u0026ldquo;bind: Address already in use\u0026rdquo;\nSolução: Escolha uma porta local diferente ou encerre o processo que está usando essa porta:\n# Linux/Mac - find process on port 7657 lsof -i :7657 # Kill the process kill [process_id] Túneis em Segundo Plano no Mac Erro: \u0026ldquo;Connection refused\u0026rdquo; ou \u0026ldquo;channel 2: open failed\u0026rdquo;\nCausas possíveis: - O serviço remoto não está em execução (verifique se o router I2P está em execução no servidor remoto) - Firewall bloqueando a conexão - Porta de destino incorreta\nSolução: Verifique se o router I2P está em execução no servidor remoto:\nssh user@remote-server \u0026#34;systemctl status i2p\u0026#34; Configuração de Chave SSH no Mac Erro: \u0026ldquo;Permissão negada\u0026rdquo; ou \u0026ldquo;Falha na autenticação\u0026rdquo;\nCausas possíveis: - Nome de usuário ou senha incorretos - Chave SSH não configurada corretamente - Acesso SSH desabilitado no servidor remoto\nSolução: Verifique as credenciais e certifique-se de que o acesso SSH está habilitado no servidor remoto.\nTunnel Drops Connection Erro: Conexão cai após período de inatividade\nSolução: Adicione configurações de keep-alive ao seu arquivo de configuração SSH (~/.ssh/config):\nHost remote-server ServerAliveInterval 60 ServerAliveCountMax 3 Security Best Practices Use chaves SSH: Mais seguro que senhas, mais difícil de comprometer Desabilite a autenticação por senha: Uma vez que as chaves SSH estejam configuradas, desabilite o login por senha no servidor Use senhas fortes: Se usar autenticação por senha, use uma senha forte e única Limite o acesso SSH: Configure regras de firewall para limitar o acesso SSH a IPs confiáveis Mantenha o SSH atualizado: Atualize regularmente o software cliente e servidor SSH Monitore os logs: Verifique os logs SSH no servidor em busca de atividades suspeitas Use portas SSH não padrão: Altere a porta SSH padrão (22) para reduzir ataques automatizados Criando Túneis SSH no Linux Acessando o Console I2P Crie um script para estabelecer túneis automaticamente:\n#!/bin/bash # i2p-tunnel.sh ssh -f -N -L 7657:127.0.0.1:7657 i2p@20.228.143.58 echo \u0026#34;I2P tunnel established\u0026#34; Torne-o executável:\nchmod +x i2p-tunnel.sh ./i2p-tunnel.sh Múltiplos Túneis Crie um serviço systemd para criação automática de túneis:\nsudo nano /etc/systemd/system/i2p-tunnel.service Adicionar:\n[Unit] Description=I2P SSH Tunnel After=network.target [Service] ExecStart=/usr/bin/ssh -NT -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes -L 7657:127.0.0.1:7657 i2p@20.228.143.58 Restart=always RestartSec=10 User=your-username [Install] WantedBy=multi-user.target Ativar e iniciar:\nsudo systemctl enable i2p-tunnel sudo systemctl start i2p-tunnel Advanced Tunneling Porta Local Personalizada Crie um proxy SOCKS para encaminhamento dinâmico:\nssh -D 8080 user@remote-server Configure o seu navegador para usar 127.0.0.1:8080 como um proxy SOCKS5.\nReverse Tunneling Permitir que o servidor remoto acesse serviços na sua máquina local:\nssh -R 7657:127.0.0.1:7657 user@remote-server Porta Já em Uso Túnel através de um servidor intermediário:\nssh -J jumphost.example.com -L 7657:127.0.0.1:7657 user@final-server Conclusion O tunelamento SSH é uma ferramenta poderosa para acessar com segurança routers I2P remotos e outros serviços. Seja usando Windows, Linux ou Mac, o processo é direto e fornece criptografia forte para suas conexões.\nPara ajuda adicional ou dúvidas, visite a comunidade I2P: - Fórum: i2pforum.net - IRC: #i2p em várias redes - Documentação: I2P Docs IMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um título ou pareça incompleto, traduza-o como está.\nGuia originalmente criado por Stormy Cloud , adaptado para a documentação do I2P.\n","description":"Aprenda como criar túneis SSH seguros no Windows, Linux e Mac para acessar seu router I2P remoto","id":"7d461aaa86788adfcb07bfb98f6e4965","section":"docs","title":"Criando um Túnel SSH para Acessar o I2P Remotamente","url":"/pt/docs/guides/criando-um-t%C3%BAnel-ssh-para-acessar-o-i2p-remotamente/"},{"categories":null,"content":" Status: Esta página condensa a especificação legada \u0026ldquo;Low-level Cryptography Specification\u0026rdquo;. As versões modernas do I2P (2.10.0, outubro de 2025) concluíram a migração para novas primitivas criptográficas. Use especificações especializadas como ECIES , Encrypted LeaseSets , NTCP2 , Red25519 , SSU2 , e Tunnel Creation (ECIES) para detalhes de implementação.\nInstantâneo do Evolution Functional Area Legacy Primitive Current / Planned Primitive Migration Status Transport key exchange Diffie–Hellman over 2048-bit prime (NTCP / SSU) X25519 (NTCP2 / SSU2) Completed (NTCP2 and SSU2 fully deployed) End-to-end encryption ElGamal/AES+SessionTags ECIES-X25519-AEAD-Ratchet Completed (2.4.0+) Symmetric cipher AES-256/CBC + HMAC-MD5 ChaCha20/Poly1305 (AEAD) Active (tunnel layer remains AES-256) Default signatures DSA-SHA1 (1024-bit) EdDSA/RedDSA on Ed25519 Fully migrated Experimental / future — Hybrid post-quantum encryption (opt-in) In testing (2.10.0) ## Criptografia assimétrica X25519 (algoritmo de acordo de chaves de curva elíptica baseado na Curve25519) Usado para NTCP2, ECIES-X25519-AEAD-Ratchet, SSU2 e criação de tunnel baseada em X25519. Fornece chaves compactas, operações em tempo constante e sigilo futuro por meio do Noise protocol framework (estrutura do protocolo Noise). Oferece segurança de 128 bits com chaves de 32 bytes e troca de chaves eficiente. ElGamal (Legado) Mantido para compatibilidade com versões anteriores com routers mais antigos. Opera sobre o primo de 2048 bits do Oakley Group 14 (RFC 3526) com gerador 2. Cifra as chaves de sessão AES mais os IVs (vetores de inicialização) em textos cifrados de 514 bytes. Não possui criptografia autenticada nem sigilo de encaminhamento; todos os pontos finais modernos migraram para ECIES. Criptografia simétrica ChaCha20/Poly1305 Primitiva de criptografia autenticada padrão usada em NTCP2, SSU2 e ECIES. Fornece segurança AEAD (Criptografia Autenticada com Dados Associados) e alto desempenho sem suporte de hardware para AES. Implementado conforme a RFC 7539 (chave de 256 bits, nonce (número usado uma vez) de 96 bits, tag de 128 bits). AES‑256/CBC (Legado) Ainda é utilizado para a criptografia da camada de tunnel, em que sua estrutura de cifra de bloco se encaixa no modelo de criptografia em camadas do I2P. Usa preenchimento PKCS#5 e transformações de IV (vetor de inicialização) por salto. Programado para revisão de longo prazo, mas permanece criptograficamente sólido. Assinaturas Signature Type Usage Notes Status DSA‑SHA1 (1024‑bit) Original default; still accepted for legacy Destinations. Deprecated ECDSA‑SHA256/384/512 Used during 2014–2015 transition. Supported EdDSA‑SHA512‑Ed25519 Default for Router and Destination identities (since 0.9.15). Default RedDSA‑SHA512‑Ed25519 Used for encrypted LeaseSet signatures (0.9.39+). Specialized RSA‑SHA512‑4096 For out‑of‑band signing (su3 updates, reseeds, plugins). Application‑layer ## Hash e Derivação de Chaves SHA‑256: Usado para chaves DHT, HKDF e assinaturas legadas. SHA‑512: Usado por EdDSA/RedDSA e em derivações HKDF do Noise. HKDF‑SHA256: Deriva chaves de sessão em ECIES, NTCP2 e SSU2. Derivações de SHA‑256 com rotação diária protegem os locais de armazenamento de RouterInfo e LeaseSet na netDb. Resumo da Camada de Transporte Transport Key Exchange Encryption Authentication Status NTCP2 X25519 ChaCha20/Poly1305 AEAD Default TCP transport SSU2 X25519 ChaCha20/Poly1305 AEAD Default UDP transport SSU (Legacy) DH‑2048 AES‑256/CBC + HMAC‑MD5 Legacy Removed (2.4.0) Ambos os transportes oferecem forward secrecy (sigilo direto) e proteção contra repetição em nível de enlace, usando o padrão de handshake Noise_XK. Criptografia na Camada de Tunnel Continua a usar AES‑256/CBC para criptografia em camadas por salto. Gateways de saída realizam descriptografia AES iterativa; cada salto volta a criptografar usando sua chave de camada e sua chave de IV. A criptografia com IV duplo mitiga ataques de correlação e de confirmação. A migração para AEAD está em estudo, mas não está planejada no momento. Criptografia Pós‑Quântica I2P 2.10.0 introduz criptografia pós‑quântica híbrida experimental. Ativado manualmente via Hidden Service Manager (gerenciador de serviços ocultos) para testes. Combina X25519 com um KEM resistente a ataques quânticos (modo híbrido). Não é o padrão; destinado a pesquisa e avaliação de desempenho. Framework de Extensibilidade Os identificadores de tipo de criptografia e de assinatura permitem suporte paralelo a múltiplas primitivas. Os mapeamentos atuais incluem: Tipos de criptografia: 0 = ElGamal/AES+SessionTags, 4 = ECIES‑X25519‑AEAD‑Ratchet. Tipos de assinatura: 0 = DSA‑SHA1, 7 = EdDSA‑SHA512‑Ed25519, 11 = RedDSA‑SHA512‑Ed25519. Esta estrutura permite atualizações futuras, incluindo esquemas pós‑quânticos, sem divisão da rede. Composição Criptográfica Camada de transporte: X25519 + ChaCha20/Poly1305 (Noise framework). Camada de Tunnel: Criptografia em camadas AES‑256/CBC para anonimato. Fim‑a‑fim: ECIES‑X25519‑AEAD‑Ratchet para confidencialidade e sigilo futuro. Camada de banco de dados: Assinaturas EdDSA/RedDSA para autenticidade. Essas camadas se combinam para oferecer defesa em profundidade: mesmo que uma camada seja comprometida, as outras mantêm a confidencialidade e a não vinculabilidade.\nResumo A pilha criptográfica do I2P 2.10.0 concentra-se em:\nCurve25519 (X25519) para troca de chaves ChaCha20/Poly1305 para criptografia simétrica EdDSA / RedDSA para assinaturas SHA‑256 / SHA‑512 para hash e derivação Modos híbridos pós‑quânticos experimentais para compatibilidade futura As versões legadas de ElGamal, AES‑CBC e DSA permanecem para compatibilidade com versões anteriores, mas não são mais utilizadas nos transportes ativos ou nos caminhos de criptografia.\n","description":"Resumo das primitivas criptográficas simétricas, assimétricas e de assinatura utilizadas em todo o I2P","id":"f5b93f818161e04d49735c3df52fcbdc","section":"docs","title":"Criptografia de baixo nível","url":"/pt/docs/specs/cryptography/"},{"categories":null,"content":" Status: Este documento descreve o protocolo de criptografia legado ElGamal/AES+SessionTag. Ele continua sendo suportado apenas para compatibilidade com versões anteriores, pois versões modernas do I2P (2.10.0+) usam ECIES-X25519-AEAD-Ratchet (esquema de criptografia ECIES com X25519, AEAD e mecanismo de ratchet). O protocolo ElGamal está obsoleto e é mantido apenas para fins históricos e de interoperabilidade.\nVisão geral ElGamal/AES+SessionTag fornecia o mecanismo original de criptografia de ponta a ponta da I2P para mensagens garlic (mensagens agregadas da I2P). Ele combinava:\nElGamal (2048-bit) — para troca de chaves AES-256/CBC — para criptografia da carga útil SHA-256 — para cálculo de hash e derivação de IV (vetor de inicialização) Tags de Sessão (32 bytes) — para identificadores de mensagens de uso único O protocolo permitia que routers e destinos se comunicassem com segurança sem manter conexões persistentes. Cada sessão usava uma troca ElGamal assimétrica para estabelecer uma chave AES simétrica, seguida por mensagens leves \u0026ldquo;marcadas\u0026rdquo; que faziam referência a essa sessão.\nOperação do Protocolo Estabelecimento de Sessão (Nova Sessão) Uma nova sessão começou com uma mensagem contendo duas seções:\nSection Size Contents Purpose ElGamal-encrypted block 514 bytes 222 bytes of plaintext encrypted using the recipient's ElGamal public key Establishes the AES session key and IV seed AES-encrypted block Variable (≥128 bytes typical) Payload data, integrity hash, and session tags Carries the actual message and new tags O texto em claro dentro do bloco ElGamal consistia em: Field Size Description Session Key 32 bytes AES-256 key for the session Pre-IV 32 bytes Material for deriving the AES initialization vector (IV = first 16 bytes of SHA-256(Pre-IV)) Random Padding 158 bytes Filler to reach required ElGamal plaintext length ### Mensagens de Sessão Existentes Uma vez estabelecida a sessão, o remetente podia enviar mensagens existing-session usando tags de sessão em cache:\nField Size Description Session Tag 32 bytes Single-use identifier tied to the existing session key AES-Encrypted Block Variable Encrypted payload and metadata using the established AES key Os Routers armazenavam em cache as tags entregues por cerca de **15 minutos**, após esse período as tags não utilizadas expiravam. Cada tag era válida para exatamente **uma mensagem**, para evitar ataques de correlação. Formato de Bloco Criptografado com AES Field Size Description Tag Count 2 bytes Number (0–200) of new session tags included Session Tags 32 × N bytes Newly generated single-use tags Payload Size 4 bytes Length of the payload in bytes Payload Hash 32 bytes SHA-256 digest of the payload Flag 1 byte 0x00 normal, 0x01 = new session key follows (unused) New Session Key 32 bytes (optional) Replacement AES key (rarely used) Payload Variable Encrypted message data Padding Variable (16-byte aligned) Random padding to block boundary Routers decifram usando a chave de sessão e o IV (vetor de inicialização) derivados a partir do Pre-IV (para novas sessões) ou da tag de sessão (para sessões existentes). Após a decifragem, verificam a integridade recalculando o hash SHA-256 da carga útil em texto claro. Gerenciamento de Tags de Sessão As tags (etiquetas) são unidirecionais: tags de Alice → Bob não podem ser reutilizadas por Bob → Alice. As tags expiram após aproximadamente 15 minutos. Routers mantêm gerenciadores de chaves de sessão por destino para acompanhar tags, chaves e tempos de expiração. As aplicações podem controlar o comportamento das tags através das I2CP options : i2cp.tagThreshold — mínimo de tags em cache antes da reposição i2cp.tagCount — número de novas tags por mensagem Este mecanismo minimizou apertos de mão ElGamal onerosos, enquanto mantinha a desvinculação entre mensagens.\nConfiguração e Eficiência As tags de sessão foram introduzidas para melhorar a eficiência no transporte de alta latência e sem ordenação do I2P. Uma configuração típica entregava 40 tags por mensagem, adicionando cerca de 1,2 KB de sobrecarga. As aplicações podiam ajustar o comportamento de entrega com base no tráfego esperado:\nUse Case Recommended Tags Notes Short-lived requests (HTTP, datagrams) 0 – 5 Low overhead, may trigger ElGamal fallback Persistent streams or bulk transfer 20 – 50 Higher bandwidth use, avoids session re-establishment Long-term services 50+ Ensures steady tag supply despite loss or delay Os Routers periodicamente purgam tags expiradas e eliminam estado de sessão não utilizado para reduzir o uso de memória e mitigar ataques de inundação de tags. Limitações Category Limitation Performance 514-byte ElGamal block adds heavy overhead for new sessions; session tags consume 32 bytes each. Security No forward secrecy – compromise of ElGamal private key exposes past sessions. Integrity AES-CBC requires manual hash verification; no AEAD. Quantum Resistance Vulnerable to Shor's algorithm – will not survive quantum attacks. Complexity Requires stateful tag management and careful timeout tuning. Essas deficiências motivaram diretamente o projeto do protocolo [ECIES-X25519-AEAD-Ratchet](/docs/specs/ecies/), que fornece sigilo direto perfeito, criptografia autenticada e troca de chaves eficiente. Status de descontinuação e migração Introduzido: Versões iniciais do I2P (pré-0.6) Obsoleto: Com a introdução do ECIES-X25519 (0.9.46 → 0.9.48) Removido: Não é mais o padrão a partir da versão 2.4.0 (dezembro de 2023) Suportado: Apenas para compatibilidade legada Routers modernos e destinos agora anunciam tipo de criptografia 4 (ECIES-X25519) em vez de tipo 0 (ElGamal/AES). O protocolo legado continua a ser reconhecido para interoperabilidade com pares desatualizados, mas não deve ser usado em novas implantações.\nContexto histórico ElGamal/AES+SessionTag foi fundamental para a arquitetura criptográfica inicial do I2P. Seu design híbrido introduziu inovações como tags de sessão de uso único e sessões unidirecionais, que influenciaram protocolos subsequentes. Muitas dessas ideias evoluíram para construções modernas, como ratchets (mecanismos de avanço criptográfico) determinísticos e trocas de chaves pós‑quânticas híbridas.\n","description":"Criptografia de ponta a ponta legada que combina ElGamal, AES, SHA-256 e tags de sessão de uso único","id":"092d77bf065d0f13bb2b2a470f57a902","section":"docs","title":"Criptografia ElGamal/AES + SessionTag (etiqueta de sessão)","url":"/pt/docs/legacy/elgamal-aes/"},{"categories":null,"content":"Visão Geral Datagramas fornecem comunicação orientada a mensagens acima do I2CP e paralela à biblioteca de streaming. Eles permitem pacotes com capacidade de resposta, autenticados ou brutos sem exigir fluxos orientados a conexão. Os routers encapsulam datagramas em mensagens I2NP e mensagens de túnel, independentemente de o tráfego ser transportado por NTCP2 ou SSU2.\nA motivação principal é permitir que aplicações (como trackers, resolvedores DNS ou jogos) enviem pacotes autocontidos que identifiquem seu remetente.\nNovidade em 2025: O Projeto I2P aprovou Datagram2 (protocolo 19) e Datagram3 (protocolo 20), adicionando proteção contra replay e mensagens respondíveis com menor sobrecarga pela primeira vez em uma década.\n1. Constantes do Protocolo Protocol Value Description Introduced PROTO_DATAGRAM 17 Signed (repliable) datagram – “Datagram1” Original PROTO_DATAGRAM_RAW 18 Unsigned (raw) datagram – no sender info Original PROTO_DATAGRAM2 19 Signed + replay-protected datagram API 0.9.66 (2025) PROTO_DATAGRAM3 20 Repliable (no signature, hash only) API 0.9.66 (2025) Os protocolos 19 e 20 foram formalizados na **Proposta 163 (Abril de 2025)**. Eles coexistem com Datagram1 / RAW para compatibilidade retroativa. 2. Tipos de Datagramas Type Protocol Repliable Authenticated Replay Protection Min Overhead Notes Raw 18 No No No 0 Minimal size; spoofable. Datagram1 17 Yes Yes No ≈ 427 Full Destination + signature. Datagram2 19 Yes Yes Yes ≈ 457 Replay prevention + offline signatures; PQ-ready. Datagram3 20 Yes No No ≈ 34 Sender hash only; low overhead. ### Padrões de Design Típicos Requisição → Resposta: Envie um Datagram2 assinado (requisição + nonce), receba uma resposta raw ou Datagram3 (echo nonce). Alta frequência/baixo overhead: Prefira Datagram3 ou RAW. Mensagens de controle autenticadas: Datagram2. Compatibilidade legada: Datagram1 ainda totalmente suportado. 3. Detalhes do Datagram2 e Datagram3 (2025) Datagram2 (Protocolo 19) Substituto aprimorado para Datagram1. Recursos: - Prevenção de replay: token anti-replay de 4 bytes. - Suporte a assinatura offline: permite uso por Destinations assinados offline. - Cobertura de assinatura expandida: inclui hash de destination, flags, opções, bloco de assinatura offline, payload. - Preparado para pós-quântico: compatível com futuros híbridos ML-KEM. - Overhead: ≈ 457 bytes (chaves X25519).\nDatagram3 (Protocolo 20) Preenche a lacuna entre tipos brutos e assinados. Características: - Replicável sem assinatura: contém hash de 32 bytes do remetente + flags de 2 bytes. - Sobrecarga mínima: ≈ 34 bytes. - Sem defesa contra replay — a aplicação deve implementar.\nAmbos os protocolos são recursos da API 0.9.66 e implementados no router Java desde a versão 2.9.0; ainda não há implementações no i2pd ou Go (outubro de 2025).\n4. Limites de Tamanho e Fragmentação Tamanho da mensagem tunnel: 1 028 bytes (4 B Tunnel ID + 16 B IV + 1 008 B payload). Fragmento inicial: 956 B (entrega TUNNEL típica). Fragmento subsequente: 996 B. Fragmentos máximos: 63–64. Limite prático: ≈ 62 708 B (~61 KB). Limite recomendado: ≤ 10 KB para entrega confiável (perdas aumentam exponencialmente além deste limite). Resumo de overhead: - Datagram1 ≈ 427 B (mínimo). - Datagram2 ≈ 457 B. - Datagram3 ≈ 34 B. - Camadas adicionais (cabeçalho gzip I2CP, I2NP, Garlic, Tunnel): + ~5.5 KB no pior caso.\n5. Integração I2CP / I2NP Caminho da mensagem: 1. A aplicação cria um datagrama (via API I2P ou SAM). 2. I2CP envolve com cabeçalho gzip (0x1F 0x8B 0x08, RFC 1952) e checksum CRC-32. 3. Números de Protocolo + Porta armazenados nos campos do cabeçalho gzip. 4. Router encapsula como mensagem I2NP → Garlic clove → fragmentos de tunnel de 1 KB. 5. Fragmentos atravessam tunnel de saída → rede → tunnel de entrada. 6. Datagrama remontado entregue ao manipulador da aplicação com base no número do protocolo.\nIntegridade: CRC-32 (do I2CP) + assinatura criptográfica opcional (Datagram1/2). Não há um campo de checksum separado dentro do próprio datagrama.\n6. Interfaces de Programação API Java O pacote net.i2p.client.datagram inclui: - I2PDatagramMaker – constrói datagramas assinados. - I2PDatagramDissector – verifica e extrai informações do remetente. - I2PInvalidDatagramException – lançada em caso de falha na verificação.\nI2PSessionMuxedImpl (net.i2p.client.impl.I2PSessionMuxedImpl) gerencia a multiplexação de protocolo e porta para aplicações que compartilham um Destination.\nAcesso ao Javadoc: - idk.i2p Javadoc (somente rede I2P) - Espelho do Javadoc (espelho na clearnet) - Javadocs Oficiais (documentação oficial)\nSuporte SAM v3 SAM 3.2 (2016): adicionou parâmetros PORT e PROTOCOL. SAM 3.3 (2016): introduziu modelo PRIMARY/subsession; permite streams + datagramas em um Destination. Suporte para estilos de sessão Datagram2 / 3 adicionado à especificação em 2025 (implementação pendente). Especificação oficial: Especificação SAM v3 Módulos i2ptunnel udpTunnel: Base totalmente funcional para aplicações I2P UDP (net.i2p.i2ptunnel.udpTunnel). streamr: Operacional para streaming A/V (net.i2p.i2ptunnel.streamr). SOCKS UDP: Não funcional a partir da versão 2.10.0 (apenas stub UDP). Para UDP de uso geral, use a API Datagram ou udpTunnel diretamente—não dependa de SOCKS UDP.\n7. Ecossistema e Suporte a Linguagens (2025) Language Library / Package SAM Version Status Javacore API (net.i2p.client.datagram)3.3✓ full support C++i2pd / libsam33.2 partialLimited Gogo-i2p / sam33.1–3.2Active Pythoni2plib, i2p.socket, txi2p3.2Active Rusti2p-rs, i2p_client3.3Active C#I2PSharp3.3Active JS/TSnode-i2p, i2p-sam3.2Active Haskellnetwork-anonymous-i2p3.2Experimental Luamooni2p3.2Experimental Java I2P é o único router que suporta subsessões completas SAM 3.3 e API Datagram2 neste momento. 8. Exemplo de Uso – Rastreador UDP (I2PSnark 2.10.0) Primeira aplicação real do Datagram2/3:\nOperation Datagram Type Purpose Announce RequestDatagram3Repliable but low-overhead update ResponseRaw DatagramMinimal payload return O padrão demonstra o uso misto de datagramas autenticados e leves para equilibrar segurança e desempenho. 9. Segurança e Melhores Práticas Use Datagram2 para qualquer troca autenticada ou quando ataques de replay importarem. Prefira Datagram3 para respostas rápidas e replicáveis com confiança moderada. Use RAW para transmissões públicas ou dados anônimos. Mantenha payloads ≤ 10 KB para entrega confiável. Esteja ciente de que SOCKS UDP permanece não-funcional. Sempre verifique CRC gzip e assinaturas digitais no recebimento. 10. Especificação Técnica Esta seção aborda os formatos de datagrama de baixo nível, encapsulamento e detalhes do protocolo.\n10.1 Identificação de Protocolo Os formatos de datagrama não compartilham um cabeçalho comum. Os routers não podem inferir o tipo apenas a partir dos bytes do payload.\nAo misturar vários tipos de datagrama—ou ao combinar datagramas com streaming—defina explicitamente: - O número do protocolo (via I2CP ou SAM) - Opcionalmente o número da porta, se a sua aplicação multiplexa serviços\nDeixar o protocolo sem definição (0 ou PROTO_ANY) é desencorajado e pode levar a erros de roteamento ou entrega.\n10.2 Datagramas Brutos Datagramas não respondíveis não transportam dados do remetente ou de autenticação. São cargas úteis opacas, tratadas fora da API de datagrama de nível superior, mas suportadas via SAM e I2PTunnel.\nProtocolo: 18 (PROTO_DATAGRAM_RAW)\nFormato:\n+----+----+----+----+----// | payload... +----+----+----+----+----// O comprimento do payload é limitado pelos limites de transporte (≈32 KB máximo prático, frequentemente muito menor).\n10.3 Datagram1 (Datagramas Respondíveis) Incorpora o Destination do remetente e uma Signature para autenticação e endereçamento de resposta.\nProtocolo: 17 (PROTO_DATAGRAM)\nSobrecarga: ≥427 bytes Carga útil: até ~31,5 KB (limitado pelo transporte)\nFormato:\n+----+----+----+----+----+----+----+----+ | from | + + | | ~ Destination bytes ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | +----+----+----+----+----+----+----+----+ | payload... +----+----+----+----// from: um Destination (387+ bytes) signature: uma Signature correspondente ao tipo de chave Para DSA_SHA1: Signature do hash SHA-256 do payload Para outros tipos de chave: Signature diretamente sobre o payload Notas: - As assinaturas para tipos não-DSA foram padronizadas no I2P 0.9.14. - As assinaturas offline LS2 (Proposta 123) não são atualmente suportadas no Datagram1.\n10.4 Formato Datagram2 Um datagrama respondível aprimorado que adiciona resistência a replay conforme definido na Proposta 163 .\nProtocolo: 19 (PROTO_DATAGRAM2)\nA implementação está em andamento. As aplicações devem incluir verificações de nonce ou timestamp para redundância.\n10.5 Formato Datagram3 Fornece datagramas respondíveis mas não autenticados. Baseia-se na autenticação de sessão mantida pelo router em vez de destino e assinatura incorporados.\nProtocolo: 20 (PROTO_DATAGRAM3) Status: Em desenvolvimento desde 0.9.66\nÚtil quando: - Os destinos são grandes (por exemplo, chaves pós-quânticas) - A autenticação ocorre em outra camada - A eficiência de largura de banda é crítica\n10.6 Integridade de Dados A integridade do datagrama é protegida pelo checksum gzip CRC-32 na camada I2CP. Nenhum campo de checksum explícito existe dentro do próprio formato de payload do datagrama.\n10.7 Encapsulamento de Pacotes Cada datagrama é encapsulado como uma única mensagem I2NP ou como um cravo individual em uma Garlic Message. As camadas I2CP, I2NP e tunnel tratam o comprimento e o enquadramento — não há delimitador interno ou campo de comprimento no protocolo de datagrama.\n10.8 Considerações Pós-Quânticas (PQ) Se a Proposta 169 (assinaturas ML-DSA) for implementada, os tamanhos de assinatura e destino aumentarão drasticamente — de ~455 bytes para ≥3739 bytes. Esta mudança aumentará substancialmente a sobrecarga de datagramas e reduzirá a capacidade efetiva de payload.\nDatagram3, que depende de autenticação no nível de sessão (não assinaturas incorporadas), provavelmente se tornará o design preferido em ambientes I2P pós-quânticos.\n11. Referências Proposta 163 – Datagram2 e Datagram3 Proposta 160 – Integração de Tracker UDP Proposta 144 – Cálculos de MTU para Streaming Proposta 169 – Assinaturas Pós-Quânticas Especificação I2CP Especificação I2NP Especificação de Mensagem de Tunnel Especificação SAM v3 Documentação i2ptunnel 12. Destaques do Registro de Alterações (2019 – 2025) Year Release Change 20190.9.43Datagram API stabilization 20210.9.50Protocol port handling reworked 20222.0.0SSU2 adoption completed 20242.6.0Legacy transport removal simplified UDP code 20252.9.0Datagram2/3 support added (Java API) 20252.10.0UDP Tracker implementation released --- 13. Resumo O subsistema de datagramas agora suporta quatro variantes de protocolo oferecendo um espectro desde totalmente autenticado até transmissão bruta leve. Os desenvolvedores devem migrar para Datagram2 para casos de uso sensíveis à segurança e Datagram3 para tráfego respondível eficiente. Todos os tipos mais antigos permanecem compatíveis para garantir interoperabilidade de longo prazo.\n","description":"Formatos de mensagem autenticados, respondíveis e brutos acima do I2CP","id":"b3c644204c779b5d6fc6a41438a3eb1b","section":"docs","title":"Datagramas","url":"/pt/docs/api/datagrams/"},{"categories":null,"content":"Desempenho da Rede I2P: Velocidade, Conexões e Gestão de Recursos A rede I2P é totalmente dinâmica. Cada cliente é conhecido por outros nós e testa localmente os nós conhecidos quanto à acessibilidade e capacidade. Apenas os nós acessíveis e capazes são salvos em um NetDB local. Durante o processo de construção de túneis, os melhores recursos são selecionados deste conjunto para construir túneis. Como os testes acontecem continuamente, o conjunto de nós muda. Cada nó I2P conhece uma parte diferente do NetDB, o que significa que cada router possui um conjunto diferente de nós I2P a serem usados para túneis. Mesmo que dois routers tenham o mesmo subconjunto de nós conhecidos, os testes de acessibilidade e capacidade provavelmente mostrarão resultados diferentes, pois os outros routers podem estar sob carga justamente quando um router testa, mas estar livres quando o segundo router testa.\nIsto descreve por que cada nó I2P possui nós diferentes para construir túneis. Como cada nó I2P tem uma latência e largura de banda diferentes, os tunnels (que são construídos através desses nós) possuem valores diferentes de latência e largura de banda. E como cada nó I2P possui tunnels construídos de forma diferente, dois nós I2P nunca têm os mesmos conjuntos de túneis.\nUm servidor/cliente é conhecido como \u0026ldquo;destination\u0026rdquo; e cada destination tem pelo menos um tunnel de entrada e um de saída. O padrão é 3 hops por tunnel. Isso soma 12 hops (12 nós I2P diferentes) para uma ida e volta completa cliente → servidor → cliente.\nCada pacote de dados é enviado através de 6 outros nós I2P até alcançar o servidor:\ncliente - hop1 - hop2 - hop3 - hopa1 - hopa2 - hopa3 - servidor\ne no caminho de volta 6 nós I2P diferentes:\nservidor - hopb1 - hopb2 - hopb3 - hopc1 - hopc2 - hopc3 - cliente\nO tráfego na rede precisa de um ACK antes que novos dados sejam enviados; é necessário aguardar até que um ACK retorne do servidor: enviar dados, aguardar ACK, enviar mais dados, aguardar ACK. Como o RTT (Round Trip Time) se acumula a partir da latência de cada nó I2P individual e de cada conexão nesta ida e volta, geralmente leva de 1 a 3 segundos até que um ACK retorne ao cliente. Devido ao design do TCP e do transporte I2P, um pacote de dados tem um tamanho limitado. Juntas, essas condições estabelecem um limite de largura de banda máxima por tunnel de aproximadamente 20–50 kB/s. No entanto, se apenas um salto no tunnel tiver apenas 5 kB/s de largura de banda disponível, todo o tunnel fica limitado a 5 kB/s, independentemente da latência e de outras limitações.\nA criptografia, latência e como um túnel é construído torna bastante custoso em tempo de CPU construir um túnel. É por isso que um destino só tem permissão para ter no máximo 6 túneis de entrada e 6 túneis de saída para transportar dados. Com um máximo de 50 kB/s por túnel, um destino poderia usar aproximadamente 300 kB/s de tráfego combinado (na realidade poderia ser mais se túneis mais curtos forem usados com baixo ou nenhum anonimato disponível). Os túneis usados são descartados a cada 10 minutos e novos são construídos. Esta mudança de túneis, e às vezes clientes que desligam ou perdem sua conexão com a rede, às vezes irá quebrar túneis e conexões. Um exemplo disso pode ser visto na IRC2P Network na perda de conexão (ping timeout) ou ao usar eepget.\nCom um conjunto limitado de destinos e um conjunto limitado de túneis por destino, um nó I2P usa apenas um conjunto limitado de túneis através de outros nós I2P. Por exemplo, se um nó I2P é \u0026ldquo;hop1\u0026rdquo; no pequeno exemplo acima, ele vê apenas um participating tunnel originando-se do cliente. Se somarmos toda a rede I2P, apenas um número bastante limitado de participating tunnels poderia ser construído com uma quantidade limitada de largura de banda no total. Se distribuirmos esses números limitados pelo número de nós I2P, há apenas uma fração da largura de banda/capacidade disponível para uso.\nPara permanecer anónimo, um router não deve ser usado por toda a rede para construir túneis. Se um router atuar como router de túnel para todos os nós I2P, ele torna-se um ponto central de falha muito real, bem como um ponto central para coletar IPs e dados de clientes. É por isso que a rede distribui o tráfego através dos nós no processo de construção de túneis.\nOutra consideração para o desempenho é a forma como o I2P lida com mesh networking. Cada salto de conexão (hop-to-hop) utiliza uma conexão TCP ou UDP nos nós I2P. Com 1000 conexões, observa-se 1000 conexões TCP. Isso é bastante, e alguns roteadores domésticos e de pequenos escritórios permitem apenas um número pequeno de conexões. O I2P tenta limitar essas conexões para menos de 1500 por tipo UDP e por tipo TCP. Isso limita também a quantidade de tráfego roteado através de um nó I2P.\nSe um nó está acessível e possui uma configuração de largura de banda de \u0026gt;128 kB/s compartilhados e está acessível 24/7, ele deve ser usado após algum tempo para tráfego participante. Se ele ficar inativo no meio tempo, o teste de um nó I2P feito por outros nós irá informá-los de que não está acessível. Isso bloqueia um nó por pelo menos 24 horas em outros nós. Portanto, os outros nós que testaram aquele nó como inativo não irão usar esse nó por 24 horas para construir túneis. É por isso que seu tráfego é menor após uma reinicialização/desligamento do seu router I2P por um mínimo de 24 horas.\nAlém disso, outros nós I2P precisam conhecer um router I2P para testá-lo quanto à acessibilidade e capacidade. Este processo pode ser acelerado quando você interage com a rede, por exemplo, usando aplicações ou visitando sites I2P, o que resultará em mais construção de tunnels e, portanto, mais atividade e acessibilidade para testes por nós na rede.\nHistórico de Desempenho (selecionado) Ao longo dos anos, o I2P tem apresentado várias melhorias de desempenho notáveis:\nNative math Implementado via bindings JNI para a biblioteca GNU MP (GMP) para acelerar o modPow do BigInteger, que anteriormente dominava o tempo de CPU. Resultados iniciais mostraram aumentos dramáticos de velocidade na criptografia de chave pública. Veja: /misc/jbigi/\nGarlic wrapping a \u0026ldquo;reply\u0026rdquo; LeaseSet (tuned) Anteriormente, as respostas frequentemente exigiam uma consulta ao banco de dados de rede para o LeaseSet do remetente. Agrupar o LeaseSet do remetente no garlic inicial melhora a latência de resposta. Isso agora é feito seletivamente (início de uma conexão ou quando o LeaseSet muda) para reduzir a sobrecarga.\nMatemática nativa Movidos alguns passos de validação para antes no handshake de transporte para rejeitar peers ruins mais cedo (relógios incorretos, NAT/firewall inadequado, versões incompatíveis), economizando CPU e largura de banda.\nEnvolvendo com garlic um LeaseSet de \u0026ldquo;resposta\u0026rdquo; (ajustado) Use testes de túnel conscientes do contexto: evite testar túneis que já se sabe estarem passando dados; priorize testes quando ociosos. Isso reduz a sobrecarga e acelera a detecção de túneis com falhas.\nRejeição TCP mais eficiente Manter as seleções para uma determinada conexão reduz a entrega fora de ordem e permite que a biblioteca de streaming aumente o tamanho das janelas, melhorando o throughput.\nAjustes de teste de túnel GZip ou similar para estruturas verbosas (por exemplo, opções de RouterInfo) reduz a largura de banda onde apropriado.\nSeleção persistente de túnel/lease Substituto para o protocolo simplista \u0026ldquo;ministreaming\u0026rdquo;. O streaming moderno inclui ACKs seletivos e controle de congestionamento adaptado ao substrato anônimo e orientado a mensagens do I2P. Veja: /docs/api/streaming/\nFuture Performance Improvements (historical ideas) Abaixo estão ideias documentadas historicamente como potenciais melhorias. Muitas estão obsoletas, implementadas ou substituídas por mudanças arquiteturais.\nComprimir estruturas de dados selecionadas Melhorar como os routers escolhem peers para construção de túneis para evitar aqueles lentos ou sobrecarregados, mantendo-se resistente a ataques Sybil por adversários poderosos.\nProtocolo de streaming completo Reduza a exploração desnecessária quando o espaço de chaves estiver estável; ajuste quantos peers são retornados nas consultas e quantas pesquisas simultâneas são realizadas.\nSession Tag tuning and improvements (legacy) Para o esquema legado ElGamal/AES+SessionTag, estratégias mais inteligentes de expiração e reabastecimento reduzem os fallbacks de ElGamal e tags desperdiçadas.\nMelhor perfil e seleção de pares Gerar tags a partir de um PRNG sincronizado inicializado durante o estabelecimento de uma nova sessão, reduzindo a sobrecarga por mensagem das tags pré-entregues.\nAjuste da base de dados de rede Tempos de vida de túnel mais longos aliados à recuperação podem reduzir as sobrecargas de reconstrução; equilibre com anonimato e confiabilidade.\nAjuste e melhorias de Session Tag (legado) Rejeitar peers inválidos mais cedo e tornar os testes de tunnel mais sensíveis ao contexto para reduzir contenção e latência.\nMigrar SessionTag para PRNG sincronizado (legado) O agrupamento seletivo de LeaseSet, as opções comprimidas de RouterInfo e a adoção do protocolo de streaming completo contribuem para um melhor desempenho percebido.\nVeja também:\nRoteamento de Túneis Seleção de Pares Transportes Especificação SSU2 e Especificação NTCP2 ","description":"Desempenho da rede I2P: como se comporta hoje, melhorias históricas e ideias para ajustes futuros","id":"eb296d22dd7b2414170601d7c73a1613","section":"docs","title":"Desempenho","url":"/pt/docs/overview/performance/"},{"categories":null,"content":"Por que escrever código específico para I2P? Existem várias maneiras de usar aplicações no I2P. Usando o I2PTunnel , você pode usar aplicações regulares sem precisar programar suporte explícito ao I2P. Isso é muito eficaz para cenários cliente-servidor, onde você precisa se conectar a um único site. Você pode simplesmente criar um tunnel usando o I2PTunnel para se conectar a esse site, como mostrado na Figura 1.\nSe sua aplicação for distribuída, ela exigirá conexões com uma grande quantidade de peers. Usando I2PTunnel, você precisará criar um novo tunnel para cada peer que deseja contatar, conforme mostrado na Figura 2. Este processo pode, é claro, ser automatizado, mas executar muitas instâncias de I2PTunnel cria uma grande quantidade de sobrecarga. Além disso, com muitos protocolos você precisará forçar todos a usarem o mesmo conjunto de portas para todos os peers — por exemplo, se você quiser executar chat DCC de forma confiável, todos precisam concordar que a porta 10001 é Alice, a porta 10002 é Bob, a porta 10003 é Charlie, e assim por diante, já que o protocolo inclui informações específicas de TCP/IP (host e porta).\nAplicações de rede gerais frequentemente enviam muitos dados adicionais que podem ser usados para identificar usuários. Nomes de host, números de porta, fusos horários, conjuntos de caracteres, etc. são frequentemente enviados sem informar o usuário. Por isso, projetar o protocolo de rede especificamente com anonimato em mente pode evitar comprometer as identidades dos usuários.\nExistem também considerações de eficiência a serem revisadas ao determinar como interagir sobre o I2P. A biblioteca de streaming e as coisas construídas sobre ela operam com handshakes semelhantes ao TCP, enquanto os protocolos principais do I2P (I2NP e I2CP) são estritamente baseados em mensagens (como UDP ou, em alguns casos, IP bruto). A distinção importante é que com o I2P, a comunicação está operando sobre uma rede longa e ampla — cada mensagem ponto a ponto terá latências não triviais, mas pode conter cargas úteis de até vários KB. Uma aplicação que precisa de uma simples requisição e resposta pode eliminar qualquer estado e reduzir a latência incorrida pelos handshakes de inicialização e encerramento usando datagramas (melhor esforço) sem ter que se preocupar com detecção de MTU ou fragmentação de mensagens.\nFigure 1: Creating a server-client connection using I2PTunnel only requires creating a single tunnel. Figure 2: Setting up connections for a peer-to-peer applications requires a very large amount of tunnels. Em resumo, várias razões para escrever código específico para I2P: Criar uma grande quantidade de instâncias I2PTunnel consome uma quantidade não trivial de recursos, o que é problemático para aplicações distribuídas (um novo tunnel é necessário para cada peer). Protocolos de rede gerais frequentemente enviam muitos dados adicionais que podem ser usados para identificar usuários. Programar especificamente para I2P permite a criação de um protocolo de rede que não vaza tais informações, mantendo os usuários anônimos e seguros. Protocolos de rede projetados para uso na internet comum podem ser ineficientes no I2P, que é uma rede com latência muito maior. I2P suporta uma interface de plugins padrão para desenvolvedores, de modo que aplicações possam ser facilmente integradas e distribuídas.\nAplicações escritas em Java e acessíveis/executáveis usando uma interface HTML através do webapps/app.war padrão podem ser consideradas para inclusão na distribuição I2P.\nConceitos Importantes Existem algumas mudanças que exigem adaptação ao usar o I2P:\nDestinos Uma aplicação executada no I2P envia mensagens de e recebe mensagens para um ponto final único e criptograficamente seguro — um \u0026ldquo;destination\u0026rdquo; (destino). Em termos de TCP ou UDP, um destination pode (em grande parte) ser considerado o equivalente de um par de nome de host mais número de porta, embora existam algumas diferenças.\nUm destino I2P em si é uma construção criptográfica — todos os dados enviados para um são criptografados como se houvesse implementação universal de IPsec, com a localização (anonimizada) do ponto final assinada como se houvesse implementação universal de DNSSEC. Destinos I2P são identificadores móveis — eles podem ser movidos de um router I2P para outro (ou podem até fazer \u0026ldquo;multihome\u0026rdquo; — operar em múltiplos routers ao mesmo tempo). Isso é bastante diferente do mundo TCP ou UDP, onde um único ponto final (porta) deve permanecer em um único host. Destinos I2P são grandes e complexos — nos bastidores, eles contêm uma chave pública ElGamal de 2048 bits para criptografia, uma chave pública DSA de 1024 bits para assinatura e um certificado de tamanho variável, que pode conter prova de trabalho ou dados ofuscados. Existem formas de referenciar esses destinos grandes e feios através de nomes curtos e bonitos (por exemplo, \u0026ldquo;irc.duck.i2p\u0026rdquo;), mas essas técnicas não garantem exclusividade global (já que são armazenados localmente num banco de dados na máquina de cada pessoa) e o mecanismo atual não é especialmente escalável nem seguro (as atualizações da lista de hosts são geridas usando \u0026ldquo;subscrições\u0026rdquo; a serviços de nomes). Pode haver algum sistema de nomes seguro, legível por humanos, escalável e globalmente exclusivo algum dia, mas as aplicações não devem depender dele estar implementado. Mais informações sobre o sistema de nomes estão disponíveis.\nEmbora a maioria das aplicações não precise distinguir protocolos e portas, o I2P suporta isso. Aplicações complexas podem especificar um protocolo, porta de origem e porta de destino, por mensagem, para multiplexar o tráfego em um único destino. Consulte a página de datagramas para mais detalhes. Aplicações simples operam escutando \u0026ldquo;todos os protocolos\u0026rdquo; em \u0026ldquo;todas as portas\u0026rdquo; de um destino.\nAnonimato e Confidencialidade I2P possui criptografia e autenticação de ponta a ponta transparentes para todos os dados transmitidos pela rede — se Bob enviar para o destino de Alice, apenas o destino de Alice poderá recebê-los, e se Bob estiver usando a biblioteca de datagramas ou streaming, Alice sabe com certeza que o destino de Bob é aquele que enviou os dados.\nClaro, o I2P anonimiza de forma transparente os dados enviados entre Alice e Bob, mas não faz nada para anonimizar o conteúdo do que eles enviam. Por exemplo, se Alice enviar a Bob um formulário com seu nome completo, documentos de identificação governamentais e números de cartão de crédito, não há nada que o I2P possa fazer. Assim sendo, protocolos e aplicativos devem ter em mente quais informações estão tentando proteger e quais informações estão dispostos a expor.\nDatagramas I2P Podem Ter Até Vários KB Aplicações que usam datagramas I2P (seja brutos ou respondíveis) podem essencialmente ser pensadas em termos de UDP — os datagramas são desordenados, de melhor esforço e sem conexão — mas ao contrário do UDP, as aplicações não precisam se preocupar com detecção de MTU e podem simplesmente enviar datagramas grandes. Embora o limite superior seja nominalmente 32 KB, a mensagem é fragmentada para transporte, reduzindo assim a confiabilidade do todo. Datagramas acima de cerca de 10 KB não são recomendados atualmente. Consulte a página de datagramas para detalhes. Para muitas aplicações, 10 KB de dados é suficiente para uma solicitação ou resposta inteira, permitindo que elas operem de forma transparente no I2P como uma aplicação similar a UDP sem ter que escrever fragmentação, reenvios, etc.\nOpções de Desenvolvimento Existem várias formas de enviar dados através do I2P, cada uma com suas próprias vantagens e desvantagens. A streaming lib é a interface recomendada, utilizada pela maioria das aplicações I2P.\nBiblioteca de Streaming A biblioteca completa de streaming é agora a interface padrão. Ela permite programar usando sockets similares a TCP, como explicado no guia de desenvolvimento com Streaming .\nBOB BOB é a Basic Open Bridge , permitindo que uma aplicação em qualquer linguagem faça conexões streaming de e para I2P. Neste momento, não possui suporte a UDP, mas o suporte a UDP está planejado para o futuro próximo. BOB também contém várias ferramentas, como geração de chaves de destino e verificação de que um endereço está em conformidade com as especificações I2P. Informações atualizadas e aplicações que usam BOB podem ser encontradas neste I2P Site .\nSAM, SAM V2, SAM V3 SAM não é recomendado. SAM V2 é aceitável, SAM V3 é recomendado.\nSAM é o protocolo Simple Anonymous Messaging , permitindo que uma aplicação escrita em qualquer linguagem se comunique com uma ponte SAM através de um socket TCP simples e tenha essa ponte multiplexando todo o seu tráfego I2P, coordenando de forma transparente a criptografia/descriptografia e o tratamento baseado em eventos. SAM suporta três estilos de operação:\nstreams, para quando Alice e Bob querem enviar dados um para o outro de forma confiável e ordenada repliable datagrams, para quando Alice quer enviar a Bob uma mensagem à qual Bob pode responder raw datagrams, para quando Alice quer extrair o máximo de largura de banda e desempenho possível, e Bob não se importa se o remetente dos dados está autenticado ou não (por exemplo, os dados transferidos são auto-autenticados) O SAM V3 visa o mesmo objetivo que o SAM e SAM V2, mas não requer multiplexação/demultiplexação. Cada stream I2P é gerenciado por seu próprio socket entre a aplicação e a ponte SAM. Além disso, datagramas podem ser enviados e recebidos pela aplicação através de comunicações de datagrama com a ponte SAM.\nSAM V2 é uma nova versão usada pelo imule que corrige alguns dos problemas no SAM .\nSAM V3 é usado pelo imule desde a versão 1.4.0.\nI2PTunnel A aplicação I2PTunnel permite que aplicações construam túneis específicos semelhantes a TCP para peers, criando aplicações \u0026lsquo;cliente\u0026rsquo; I2PTunnel (que escutam numa porta específica e conectam-se a um destino I2P específico sempre que um socket para essa porta é aberto) ou aplicações \u0026lsquo;servidor\u0026rsquo; I2PTunnel (que escutam um destino I2P específico e sempre que recebem uma nova conexão I2P fazem outproxy para um host/porta TCP específico). Estes streams são 8-bit clean e são autenticados e protegidos através da mesma biblioteca de streaming que o SAM usa, mas há uma sobrecarga não trivial envolvida na criação de múltiplas instâncias únicas de I2PTunnel, uma vez que cada uma tem o seu próprio destino I2P exclusivo e o seu próprio conjunto de túneis, chaves, etc.\nSOCKS O I2P suporta proxy SOCKS V4 e V5. Conexões de saída funcionam bem. Funcionalidades de entrada (servidor) e UDP podem estar incompletas e não testadas.\nMinistreaming Removido\nCostumava haver uma biblioteca simples \u0026ldquo;ministreaming\u0026rdquo;, mas agora o ministreaming.jar contém apenas as interfaces para a biblioteca de streaming completa.\nDatagramas Recomendado para aplicações tipo UDP\nA biblioteca Datagram permite o envio de pacotes semelhantes a UDP. É possível usar:\nDatagramas replicáveis Datagramas brutos I2CP Não recomendado\nI2CP em si é um protocolo independente de linguagem, mas para implementar uma biblioteca I2CP em algo diferente de Java há uma quantidade significativa de código a ser escrito (rotinas de criptografia, marshalling de objetos, tratamento de mensagens assíncronas, etc). Embora alguém possa escrever uma biblioteca I2CP em C ou outra linguagem, provavelmente seria mais útil usar a biblioteca SAM em C.\nAplicações Web O I2P vem com o servidor web Jetty, e configurar para usar o servidor Apache é simples. Qualquer tecnologia padrão de aplicação web deve funcionar.\nComece a Desenvolver — Um Guia Simples Desenvolver usando I2P requer uma instalação funcional do I2P e um ambiente de desenvolvimento de sua escolha. Se você estiver usando Java, pode começar o desenvolvimento com a streaming library ou datagram library. Usando outra linguagem de programação, SAM ou BOB podem ser utilizados.\nDesenvolvimento com a Biblioteca Streaming Abaixo está uma versão simplificada e modernizada do exemplo na página original. Para o exemplo completo, consulte a página legada ou nossos exemplos em Java no código-fonte.\n// Server example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); I2PServerSocket server = manager.getServerSocket(); I2PSocket socket = server.accept(); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String s; while ((s = br.readLine()) != null) { System.out.println(\u0026#34;Received: \u0026#34; + s); } Exemplo de código: servidor básico recebendo dados.\n// Client example (excerpt) I2PSocketManager manager = I2PSocketManagerFactory.createManager(); Destination dest = new Destination(serverDestBase64); I2PSocket socket = manager.connect(dest); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(\u0026#34;Hello I2P!\\n\u0026#34;); bw.flush(); Exemplo de código: cliente conectando e enviando uma linha.\n","description":"Por que escrever aplicações específicas para I2P, conceitos-chave, opções de desenvolvimento e um guia simples de introdução","id":"d137fc4f3bedf693b877aa1ba9bde3eb","section":"docs","title":"Desenvolvimento de Aplicações","url":"/pt/docs/develop/applications/"},{"categories":null,"content":"Objetivo: Manter a consistência, a precisão e a acessibilidade em toda a documentação técnica do I2P\nPrincípios Fundamentais 1. Verifique tudo Nunca presuma nem adivinhe. Todas as afirmações técnicas devem ser verificadas em relação a: - Código-fonte atual do I2P (https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master ) - Documentação oficial da API (https://i2p.github.io/i2p.i2p/ - Especificações de configuração /docs/specs/ - Notas de versão recentes /releases/ Exemplo de verificação adequada:\n❌ BAD: \u0026#34;The ClientApp interface probably requires three constructor parameters.\u0026#34; ✅ GOOD: \u0026#34;The ClientApp interface requires this constructor signature: public MyClientApp(I2PAppContext context, ClientAppManager manager, String[] args)\u0026#34; 2. Clareza Acima da Brevidade Escreva para desenvolvedores que podem estar tendo contato com o I2P pela primeira vez. Explique os conceitos de forma completa, em vez de presumir conhecimento prévio.\nExemplo:\n❌ BAD: \u0026#34;Use the port mapper for service discovery.\u0026#34; ✅ GOOD: \u0026#34;The port mapper offers a simple directory for internal TCP services. Register loopback ports so other applications can discover your service without hardcoded addresses.\u0026#34; 3. Acessibilidade em primeiro lugar A documentação deve ser acessível aos desenvolvedores na clearnet (internet comum), embora o I2P seja um overlay de rede. Sempre forneça alternativas acessíveis pela clearnet para recursos internos do I2P.\nPrecisão técnica Documentação da API e da Interface Sempre inclua: 1. Nomes completos de pacotes na primeira menção: net.i2p.app.ClientApp 2. Assinaturas completas de métodos com tipos de retorno 3. Nomes e tipos de parâmetros 4. Parâmetros obrigatórios vs opcionais\nExemplo:\nThe `startup()` method has signature `void startup() throws IOException` and must execute without blocking. The method must call `ClientAppManager.notify()` at least once to transition from INITIALIZED state. Propriedades de Configuração Ao documentar arquivos de configuração: 1. Mostre os nomes exatos das propriedades 2. Especifique a codificação do arquivo (UTF-8 para configurações do I2P) 3. Forneça exemplos completos 4. Documente os valores padrão 5. Anote a versão em que as propriedades foram introduzidas/alteradas\nExemplo:\n### clients.config Properties **Required:** - `clientApp.N.main` - Full class name (no default) **Optional:** - `clientApp.N.delay` - Seconds before starting (default: 120) - `clientApp.N.onBoot` - Forces delay=0 if true (default: false, added in 0.9.4) Constantes e Enumerações Ao documentar constantes, use os nomes reais do código:\n❌ BAD: \u0026#34;Common registrations include console, i2ptunnel, Jetty, sam, and bob\u0026#34; ✅ GOOD: \u0026#34;Common port mapper service constants from `net.i2p.util.PortMapper`: - `SVC_CONSOLE` - Router console (default port 7657) - `SVC_HTTP_PROXY` - HTTP proxy (default port 4444) - `SVC_SAM` - SAM bridge (default port 7656)\u0026#34; Diferenciar Conceitos Semelhantes O I2P possui vários sistemas sobrepostos. Sempre esclareça qual sistema você está documentando:\nExemplo:\nNote that client registry and port mapper are separate systems: - **ClientAppManager registry** enables inter-application communication by name lookup - **PortMapper** maps service names to host:port combinations for service discovery - **i2ptunnel tunnel types** are configuration values (tunnel.N.type), not service registrations URLs e Referências da Documentação Regras de Acessibilidade de URLs Referências primárias devem usar URLs acessíveis na clearnet (internet pública) URLs internas do I2P (domínios .i2p) devem incluir notas de acessibilidade Sempre forneça alternativas ao criar links para recursos internos do I2P Modelo para URLs internas do I2P:\n\u0026gt; **Note:** The I2P network hosts comprehensive documentation at http://idk.i2p/javadoc-i2p/ \u0026gt; which requires an I2P router for access. For clearnet access, use the GitHub Pages \u0026gt; mirror at https://eyedeekay.github.io/javadoc-i2p/ URLs de referência do I2P recomendadas Especificações oficiais: - Configuração - Plugin - Índice de Documentos Documentação da API (escolha a mais atual): - Mais atual: https://i2p.github.io/i2p.i2p/ (API 0.9.66 a partir do I2P 2.10.0) - Espelho na clearnet: https://eyedeekay.github.io/javadoc-i2p/ Código-fonte: - GitLab (oficial): https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master - Espelho no GitHub: https://github.com/i2p/i2p.i2p Padrões de Formato de Links ✅ GOOD: [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) ✅ GOOD: [Configuration Specification](https://geti2p.net/spec/configuration) ❌ BAD: See the ClientApp docs at http://idk.i2p/... ❌ BAD: [link](url) with no descriptive text Rastreamento de Versões Metadados do Documento Todo documento técnico deve incluir metadados de versão no frontmatter (seção de cabeçalho no início do arquivo):\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Definições de campos: - lastUpdated: Ano-mês em que o documento foi revisado/atualizado pela última vez - accurateFor: Versão do I2P em relação à qual o documento foi verificado - reviewStatus: Um de \u0026ldquo;draft\u0026rdquo;, \u0026ldquo;needs-review\u0026rdquo;, \u0026ldquo;verified\u0026rdquo;, \u0026ldquo;outdated\u0026rdquo;\nReferências a versões no conteúdo Ao mencionar versões: 1. Use negrito para a versão atual: \u0026ldquo;versão 2.10.0 (setembro de 2025)\u0026rdquo; 2. Especifique tanto o número da versão quanto a data para referências históricas 3. Indique a versão da API separadamente da versão do I2P quando relevante\nExemplo:\nManaged clients were introduced in **version 0.9.4** (December 17, 2012) and remain the recommended architecture as of **version 2.10.0** (September 9, 2025). The current API version is **0.9.66**. Documentando mudanças ao longo do tempo Para funcionalidades que evoluíram:\n**Version history:** - **0.9.4 (December 2012)** - Managed clients introduced - **0.9.42 (2019)** - clients.config.d/ directory structure added - **1.7.0 (2021)** - ShellService added for external program tracking - **2.10.0 (September 2025)** - Current release, no API changes to managed clients Avisos de descontinuação Ao documentar recursos obsoletos:\n\u0026gt; **Deprecated:** This feature was deprecated in version X.Y.Z and will be removed \u0026gt; in version A.B.C. Use [alternative feature](link) instead. Padrões de Terminologia Termos oficiais do I2P Use estes termos exatos de forma consistente:\nCorrect Term Avoid I2P router I2P node, I2P client (ambiguous) eepsite I2P website, hidden service (Tor term) tunnel connection, circuit (Tor term) netDb network database, DHT lease set destination info destination address, endpoint base64 destination I2P address, .i2p address ### Terminologia de Cliente Gerenciado Ao documentar clientes gerenciados:\nUse This Not This managed client managed application unmanaged client legacy client, static client ClientAppManager application manager, client manager lifecycle methods state methods, control methods client registry application registry, name service port mapper port registry, service directory ### Terminologia de Configuração Correct Incorrect clients.config clients.cfg, client.config clients.config.d/ clients.d/, config.d/ router.config router.cfg i2ptunnel.config tunnel.config ### Nomes de Pacotes e Classes Use sempre nomes totalmente qualificados na primeira menção; depois, nomes curtos:\nThe `net.i2p.app.ClientApp` interface requires implementation of three lifecycle methods. When a ClientApp starts, the manager calls `startup()`... Exemplos de Código e Formatação Exemplos de código em Java Use realce de sintaxe adequado e exemplos completos:\n### Example: Registering with Port Mapper \\`\\`\\`java // Register HTTP proxy service context.portMapper().register( PortMapper.SVC_HTTP_PROXY, \u0026#34;127.0.0.1\u0026#34;, 4444 ); // Later, retrieve the port int port = context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY); if (port == -1) { // Service not registered } \\`\\`\\` Requisitos do exemplo de código: 1. Inclua comentários explicando as linhas-chave 2. Mostre tratamento de erros quando relevante 3. Use nomes de variáveis realistas 4. Siga as convenções de codificação do I2P (indentação de 4 espaços) 5. Mostre as importações se não estiverem óbvias pelo contexto\nExemplos de Configuração Mostre exemplos completos e válidos de configuração:\n### Example: clients.config.d/ Entry File: `clients.config.d/00-console.config` \\`\\`\\`properties # Router console configuration clientApp.0.main=net.i2p.router.web.RouterConsoleRunner clientApp.0.name=Router Console clientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ clientApp.0.delay=0 clientApp.0.onBoot=true \\`\\`\\` Exemplos de Linha de Comando Use $ para comandos do usuário, # para root:\n\\`\\`\\`bash # Install I2P on Debian/Ubuntu $ sudo apt-get install i2p # Start the router $ i2prouter start \\`\\`\\` Código em linha Use backticks para: - Nomes de métodos: startup() - Nomes de classes: ClientApp - Nomes de propriedades: clientApp.0.main - Nomes de arquivos: clients.config - Constantes: SVC_HTTP_PROXY - Nomes de pacotes: net.i2p.app\nTom e voz Profissional, porém acessível Escreva para um público técnico sem ser condescendente:\n❌ BAD: \u0026#34;Obviously, you should implement the startup() method.\u0026#34; ✅ GOOD: \u0026#34;Managed clients must implement the startup() method to initialize resources.\u0026#34; ❌ BAD: \u0026#34;Even a junior dev knows you need to call notify().\u0026#34; ✅ GOOD: \u0026#34;The manager requires at least one notify() call during startup to track state transitions.\u0026#34; Voz ativa Use a voz ativa para maior clareza:\n❌ PASSIVE: \u0026#34;The ClientAppManager is notified by the client when state changes.\u0026#34; ✅ ACTIVE: \u0026#34;The client notifies ClientAppManager when state changes.\u0026#34; Imperativos para Instruções Use imperativos diretos em conteúdo procedimental:\n✅ \u0026#34;Implement these three lifecycle methods:\u0026#34; ✅ \u0026#34;Call manager.notify() after changing state.\u0026#34; ✅ \u0026#34;Register services using context.portMapper().register()\u0026#34; Evite jargão desnecessário Explique os termos na primeira vez em que forem usados:\n✅ GOOD: \u0026#34;The netDb (network database) stores information about I2P routers and destinations.\u0026#34; ❌ BAD: \u0026#34;Query the netDb for peer info.\u0026#34; (no explanation) Diretrizes de Pontuação Sem travessões (em-dashes) - use hífens comuns, vírgulas ou ponto e vírgula Use Oxford comma (vírgula de Oxford) em listas: \u0026ldquo;console, i2ptunnel, and Jetty\u0026rdquo; Pontos finais dentro de blocos de código apenas quando gramaticalmente necessário Listas em série usam ponto e vírgula quando os itens contêm vírgulas Estrutura do Documento Ordem Padrão das Seções Para a documentação da API:\nVisão geral - o que a funcionalidade faz, por que ela existe Implementação - como implementar/usar Configuração - como configurá-la Referência da API - descrições detalhadas de métodos/propriedades Exemplos - exemplos completos e funcionais Boas práticas - dicas e recomendações Histórico de versões - quando foi introduzida, mudanças ao longo do tempo Referências - links para documentação relacionada Hierarquia de Cabeçalhos Use níveis de cabeçalho semânticos:\n# Document Title (h1 - only one per document) ## Major Section (h2) ### Subsection (h3) #### Detail Section (h4) **Bold text for emphasis within sections** Caixas de informação Use citações em bloco para avisos especiais:\n\u0026gt; **Note:** Additional information that clarifies the main content. \u0026gt; **Warning:** Important information about potential issues or breaking changes. \u0026gt; **Deprecated:** This feature is deprecated and will be removed in version X.Y.Z. \u0026gt; **Status:** Current implementation status or version information. Listas e Organização Listas não ordenadas para itens não sequenciais:\n- First item - Second item - Third item Listas ordenadas para etapas sequenciais:\n1. First step 2. Second step 3. Third step Listas de definições para explicações de termos:\n**Term One** : Explanation of term one **Term Two** : Explanation of term two Armadilhas Comuns a Evitar 1. Confundir sistemas semelhantes Não confunda: - registro do ClientAppManager vs. PortMapper - tipos de tunnel do i2ptunnel vs. constantes de serviço do PortMapper - ClientApp vs. RouterApp (contextos diferentes) - clientes gerenciados vs. não gerenciados\nSempre esclareça qual sistema você está discutindo:\n✅ \u0026#34;Register with ClientAppManager using manager.register(this) for name-based lookup.\u0026#34; ✅ \u0026#34;Register with PortMapper using context.portMapper().register() for port discovery.\u0026#34; 2. Referências a versões desatualizadas Não faça: - Referir-se a versões antigas como \u0026ldquo;atuais\u0026rdquo; - Criar links para documentação da API desatualizada - Usar assinaturas de métodos descontinuadas em exemplos\nFaça: - Verifique as notas de versão antes de publicar - Verifique se a documentação da API corresponde à versão atual - Atualize os exemplos para usar as melhores práticas atuais\n3. URLs inacessíveis Não faça: - Vincular apenas a domínios .i2p sem alternativas na clearnet (internet aberta) - Usar URLs de documentação quebradas ou desatualizadas - Vincular para caminhos locais file://\nFaça: - Forneça alternativas na clearnet (internet pública/aberta) para todos os links internos do I2P - Verifique se os URLs estão acessíveis antes de publicar - Use URLs persistentes (geti2p.net, não hospedagem temporária)\n4. Exemplos de Código Incompletos Não faça: - Mostrar trechos sem contexto - Omitir tratamento de erros - Usar variáveis não definidas - Pular instruções de import quando não for óbvio\nFaça: - Mostre exemplos completos e compiláveis - Inclua o tratamento de erros necessário - Explique o que cada linha significativa faz - Teste os exemplos antes de publicar\n5. Declarações Ambíguas ❌ \u0026#34;Some applications register services.\u0026#34; ✅ \u0026#34;Applications implementing ClientApp may register with ClientAppManager using manager.register(this) to enable name-based lookup.\u0026#34; ❌ \u0026#34;Configuration files go in the config directory.\u0026#34; ✅ \u0026#34;Modern I2P installations store client configurations in $I2P/clients.config.d/ as individual files.\u0026#34; Convenções do Markdown Nomenclatura de arquivos Use kebab-case (palavras separadas por hífens) para nomes de arquivos: - managed-clients.md - port-mapper-guide.md - configuration-reference.md\nFormato do Frontmatter (metadados iniciais de um documento) Sempre inclua o front matter YAML (metadados no início do arquivo):\n--- title: \u0026#34;Document Title\u0026#34; description: \u0026#34;Brief description under 160 characters\u0026#34; slug: \u0026#34;url-slug\u0026#34; lastUpdated: \u0026#34;2025-10\u0026#34; accurateFor: \u0026#34;2.10.0\u0026#34; reviewStatus: \u0026#34;verified\u0026#34; --- Formatação de links Links internos (na documentação):\nSee [clients.config specification](https://geti2p.net/spec/configuration#clients-config) Links externos (para outros recursos):\nFor more details, see [ClientApp Javadoc](https://i2p.github.io/i2p.i2p/net/i2p/app/ClientApp.html) Links para repositórios de código:\nView source: [ClientApp.java](https://i2pgit.org/I2P_Developers/i2p.i2p/src/branch/master/core/java/src/net/i2p/app/ClientApp.java) Formatação de Tabelas Use tabelas em GitHub-flavored Markdown (dialeto de Markdown do GitHub):\n| Property | Type | Default | Description | |----------|------|---------|-------------| | `main` | String | (required) | Full class name | | `delay` | Integer | 120 | Seconds before start | | `onBoot` | Boolean | false | Force immediate start | Tags de linguagem para blocos de código Sempre especifique a linguagem para o realce de sintaxe:\n\\`\\`\\`java // Java code \\`\\`\\` \\`\\`\\`bash # Shell commands \\`\\`\\` \\`\\`\\`properties # Configuration files \\`\\`\\` \\`\\`\\`xml \u0026lt;!-- XML files --\u0026gt; \\`\\`\\` Lista de verificação de revisão Antes de publicar a documentação, verifique:\nTodas as afirmações técnicas verificadas em relação ao código-fonte ou à documentação oficial Os números de versão e as datas estão atualizados Todos os URLs são acessíveis a partir do clearnet (internet aberta) (ou alternativas fornecidas) Os exemplos de código estão completos e testados A terminologia segue as convenções do I2P Sem travessões (use hífens simples ou outra pontuação) O frontmatter (cabeçalho de metadados) está completo e correto A hierarquia de títulos é semântica (h1 → h2 → h3) Listas e tabelas estão devidamente formatadas A seção de referências inclui todas as fontes citadas O documento segue as diretrizes de estrutura O tom é profissional, mas acessível Conceitos semelhantes são claramente diferenciados Sem links quebrados nem referências quebradas Os exemplos de configuração são válidos e atuais Feedback: Se encontrar problemas ou tiver sugestões para estas diretrizes, envie-os por meio dos canais oficiais de desenvolvimento do I2P.\n","description":"Manter a consistência, a precisão e a acessibilidade em toda a documentação técnica do I2P","id":"797e1cb5256ec022a3d99eefd7eda1f4","section":"docs","title":"Diretrizes de Redação da Documentação do I2P","url":"/pt/docs/writing-guidelines/"},{"categories":null,"content":"Leia primeiro o Guia para Novos Desenvolvedores .\nDiretrizes Básicas e Estilo de Codificação A maioria dos pontos a seguir deve ser senso comum para qualquer pessoa que tenha trabalhado em código aberto ou em um ambiente de programação comercial. O seguinte se aplica principalmente ao ramo de desenvolvimento principal i2p.i2p. As diretrizes para outros ramos, plugins e aplicativos externos podem ser substancialmente diferentes; consulte o desenvolvedor apropriado para orientação.\nComunidade Por favor, não apenas escreva código. Se puder, participe de outras atividades de desenvolvimento, incluindo: discussões de desenvolvimento e suporte no IRC e i2pforum.i2p; testes; relatórios de bugs e respostas; documentação; revisões de código; etc. Desenvolvedores ativos devem estar disponíveis periodicamente no IRC #i2p-dev. Esteja ciente do ciclo de lançamento atual. Respeite os marcos de lançamento, como congelamento de funcionalidades, congelamento de tags e o prazo de check-in para um lançamento. Ciclo de Lançamento O ciclo normal de lançamento é de 10–16 semanas, quatro lançamentos por ano. A seguir estão os prazos aproximados dentro de um ciclo típico de 13 semanas. Os prazos reais para cada lançamento são definidos pelo gerente de lançamento após consulta com a equipe completa.\n1–2 dias após o lançamento anterior: Check-ins no trunk são permitidos. 2–3 semanas após o lançamento anterior: Prazo para propagar mudanças importantes de outros branches para o trunk. 4–5 semanas antes do lançamento: Prazo para solicitar novos links na página inicial. 3–4 semanas antes do lançamento: Feature freeze. Prazo para novos recursos importantes. 2–3 semanas antes do lançamento: Realizar reunião do projeto para revisar solicitações de novos links na página inicial, se houver. 10–14 dias antes do lançamento: String freeze. Não são permitidas mais alterações em strings traduzidas (marcadas). Enviar strings para o Transifex, anunciar prazo de tradução no Transifex. 10–14 dias antes do lançamento: Prazo para recursos. Apenas correções de bugs após este momento. Não são permitidos mais recursos, refatoração ou limpeza. 3–4 dias antes do lançamento: Prazo para tradução. Obter traduções do Transifex e fazer check-in. 3–4 dias antes do lançamento: Prazo para check-in. Não são permitidos check-ins após este momento sem a permissão do responsável pelo lançamento. Horas antes do lançamento: Prazo para revisão de código. Git Tenha uma compreensão básica de sistemas de controle de código distribuído, mesmo que você nunca tenha usado git antes. Peça ajuda se precisar. Uma vez enviado, os commits são para sempre; não há como desfazer. Por favor, tenha cuidado. Se você nunca usou git antes, comece com passos pequenos. Faça commit de algumas pequenas alterações e veja como funciona. Teste suas alterações antes de fazer commit delas. Se você preferir o modelo de desenvolvimento de commit‑antes‑de‑testar, use seu próprio branch de desenvolvimento na sua própria conta e crie um MR assim que o trabalho estiver pronto. Não quebre a build. Não cause regressões. Caso você faça isso (acontece), por favor não desapareça por um longo período após enviar sua alteração. Se sua alteração for não trivial, ou se você quiser que as pessoas a testem e precisar de bons relatórios de teste para saber se sua alteração foi testada ou não, adicione um comentário de check-in ao history.txt e incremente a revisão da build em RouterVersion.java. Não faça commit de alterações importantes no branch principal i2p.i2p no final do ciclo de lançamento. Se um projeto levará mais de alguns dias, crie seu próprio branch no git, na sua própria conta, e faça o desenvolvimento lá para não bloquear os lançamentos. Para grandes alterações (geralmente falando, mais de 100 linhas, ou tocando mais de três arquivos), faça commit em um novo branch na sua própria conta do GitLab, crie um MR e atribua um revisor. Atribua o MR a você mesmo. Faça merge do MR você mesmo assim que o revisor aprovar. Não crie branches WIP na conta principal I2P_Developers (exceto para i2p.www). WIP pertence à sua própria conta. Quando o trabalho estiver concluído, crie um MR. Os únicos branches na conta principal devem ser para forks verdadeiros, como um lançamento pontual. Faça desenvolvimento de forma transparente e com a comunidade em mente. Faça commit frequentemente. Faça commit ou merge no branch principal com a maior frequência possível, dados os diretrizes acima. Se você estiver trabalhando em algum grande projeto no seu próprio branch/conta, avise as pessoas para que elas possam acompanhar e revisar/testar/comentar. Estilo de Código O estilo de codificação em grande parte do código é de 4 espaços para indentação. Não use tabs. Não reformate o código. Se sua IDE ou editor quiser reformatar tudo, controle-o. Em alguns lugares, o estilo de codificação é diferente. Use o bom senso. Emule o estilo no arquivo que você está modificando. Todas as novas classes e métodos públicos e package-private requerem Javadocs. Adicione @since número-da-versão. Javadocs para novos métodos privados são desejáveis. Para quaisquer Javadocs adicionados, não deve haver erros ou avisos de doclint. Execute ant javadoc com Oracle Java 14 ou superior para verificar. Todos os parâmetros devem ter linhas @param, todos os métodos não-void devem ter linhas @return, todas as exceções declaradas como lançadas devem ter linhas @throws, e nenhum erro HTML. Classes em core/ (i2p.jar) e porções do i2ptunnel fazem parte da nossa API oficial. Existem vários plugins externos e outras aplicações que dependem desta API. Tenha cuidado para não fazer alterações que quebrem a compatibilidade. Não adicione métodos à API a menos que sejam de utilidade geral. Javadocs para métodos da API devem ser claros e completos. Se você adicionar ou alterar a API, também atualize a documentação no site (branch i2p.www). Marque strings para tradução quando apropriado, o que é verdade para todas as strings de UI. Não altere strings marcadas existentes a menos que seja realmente necessário, pois isso quebrará as traduções existentes. Não adicione ou altere strings marcadas após o congelamento de tags no ciclo de lançamento para que os tradutores tenham a chance de atualizar antes do lançamento. Use genéricos e classes concorrentes sempre que possível. I2P é uma aplicação altamente multi-threaded. Familiarize-se com armadilhas comuns de Java que são detectadas pelo FindBugs/SpotBugs. Execute ant findbugs para saber mais. Java 8 é necessário para construir e executar I2P a partir da versão 0.9.47. Não use classes ou métodos Java 7 ou 8 em subsistemas embarcados: addressbook, core, i2ptunnel.jar (não-UI), mstreaming, router, routerconsole (apenas news), streaming. Esses subsistemas são usados por Android e aplicações embarcadas que requerem apenas Java 6. Todas as classes devem estar disponíveis na API 14 do Android. Recursos de linguagem Java 7 são aceitáveis nesses subsistemas se suportados pela versão atual do Android SDK e eles compilam para código compatível com Java 6. Try-with-resources não pode ser usado em subsistemas embarcados, pois requer java.lang.AutoCloseable no runtime, e isso não está disponível até a API 19 do Android (KitKat 4.4). O pacote java.nio.file não pode ser usado em subsistemas embarcados, pois não está disponível até a API 26 do Android (Oreo 8). Além das limitações acima, classes, métodos e construções Java 8 podem ser usados apenas nos seguintes subsistemas: BOB, desktopgui, i2psnark, i2ptunnel.war (UI), jetty-i2p.jar, jsonrpc, routerconsole (exceto news), SAM, susidns, susimail, systray. Autores de plugins podem requerer qualquer versão mínima de Java através do arquivo plugin.config. Converta explicitamente entre tipos primitivos e classes; não confie em autoboxing/unboxing. Não use URL. Use URI. Não capture Exception. Capture RuntimeException e exceções verificadas individualmente. Não use String.getBytes() sem um argumento de charset UTF-8. Você também pode usar DataHelper.getUTF8() ou DataHelper.getASCII(). Sempre especifique um charset UTF-8 ao ler ou escrever arquivos. Os utilitários DataHelper podem ser úteis. Sempre especifique um locale (por exemplo Locale.US) ao usar String.toLowerCase() ou String.toUpperCase(). Não use String.equalsIgnoreCase(), pois um locale não pode ser especificado. Não use String.split(). Use DataHelper.split(). Não adicione código para formatar datas e horas. Use DataHelper.formatDate() e DataHelper.formatTime(). Certifique-se de que InputStreams e OutputStreams sejam fechados em blocos finally. Use {} para todos os blocos for e while, mesmo que sejam de apenas uma linha. Se você usar {} para o bloco if, else, ou if-else, use para todos os blocos. Coloque } else { em uma única linha. Especifique campos como final sempre que possível. Não armazene I2PAppContext, RouterContext, Log, ou quaisquer outras referências a router ou itens de contexto em campos estáticos. Não inicie threads em construtores. Use I2PAppThread em vez de Thread. Registro de Logs As seguintes diretrizes aplicam-se ao router, webapps e todos os plugins.\nPara quaisquer mensagens não exibidas no nível de log padrão (WARN, INFO e DEBUG), a menos que a mensagem seja uma string estática (sem concatenação), sempre use log.shouldWarn(), log.shouldInfo() ou log.shouldDebug() antes da chamada de log para evitar a criação desnecessária de objetos. Mensagens de log que podem ser exibidas no nível de log padrão (ERROR, CRIT e logAlways()) devem ser breves, claras e compreensíveis para um usuário não técnico. Isso inclui o texto de razão da exceção que também pode ser exibido. Considere traduzir se o erro provavelmente acontecerá (por exemplo, em erros de envio de formulário). Caso contrário, a tradução não é necessária, mas pode ser útil procurar e reutilizar uma string que já esteja marcada para tradução em outro lugar. Mensagens de log não exibidas no nível de log padrão (WARN, INFO e DEBUG) são destinadas ao uso do desenvolvedor e não têm os requisitos acima. No entanto, mensagens WARN estão disponíveis na aba de log do Android e podem ser úteis para usuários que estão depurando problemas, então use algum cuidado com mensagens WARN também. Mensagens de log INFO e DEBUG devem ser usadas com moderação, especialmente em caminhos de código frequentemente executados. Embora sejam úteis durante o desenvolvimento, considere removê-las ou comentá-las após a conclusão dos testes. Não registre logs em stdout ou stderr (wrapper log). Licenças Apenas faça commit de código que você mesmo escreveu. Antes de fazer commit de qualquer código ou JARs de bibliotecas de outras fontes, justifique por que é necessário, verifique se a licença é compatível e obtenha aprovação do gerente de lançamento. Se você obtiver aprovação para adicionar código externo ou JARs, e binários estiverem disponíveis em qualquer pacote Debian ou Ubuntu, você deve implementar opções de compilação e empacotamento para usar o pacote externo em vez disso. Lista de verificação de arquivos a modificar: build.properties, build.xml, debian/control, debian/i2p-router.install, debian/i2p-router.links, debian/rules, sub-build.xml. Para quaisquer imagens enviadas de fontes externas, é sua responsabilidade primeiro verificar se a licença é compatível. Inclua a licença e informações da fonte no comentário do commit. Bugs Gerenciar issues é trabalho de todos; por favor, ajude. Monitore o GitLab para encontrar issues com as quais você pode ajudar. Comente, corrija e feche issues se puder. Novos desenvolvedores devem começar corrigindo issues. Quando tiver uma correção, anexe seu patch à issue e adicione a palavra-chave review-needed. Não feche a issue até que ela tenha sido revisada com sucesso e você tenha verificado suas alterações. Depois de fazer isso sem problemas para alguns tickets, você pode seguir o procedimento normal acima. Feche uma issue quando achar que a corrigiu. Não temos um departamento de testes para verificar e fechar tickets. Se não tiver certeza de que corrigiu, feche-a e adicione uma nota dizendo \u0026ldquo;Acho que corrigi, por favor teste e reabra se ainda estiver quebrado\u0026rdquo;. Adicione um comentário com o número da dev build ou revisão e defina o milestone para o próximo lançamento. ","description":"Diretrizes completas para contribuir com o I2P: fluxo de trabalho, ciclo de lançamento, estilo de código, registro de logs, licenciamento e tratamento de problemas","id":"6c8fe691caf216ba9024152afc39c5c6","section":"docs","title":"Diretrizes para Desenvolvedores e Estilo de Código","url":"/pt/docs/develop/dev-guidelines/"},{"categories":null,"content":" Contexto: Esta página arquiva debates de longa duração do período inicial do design do I2P. Ela explica por que o projeto privilegiou livros de endereços localmente confiáveis em vez de consultas no estilo DNS ou registros por votação majoritária. Para orientações de uso atuais, consulte a documentação de nomenclatura .\nAlternativas Descartadas Os objetivos de segurança do I2P tornam inviáveis os esquemas de nomenclatura familiares:\nResolução no estilo DNS. Qualquer resolvedor no caminho de resolução poderia forjar ou censurar respostas. Mesmo com DNSSEC, registradores comprometidos ou autoridades certificadoras permanecem um ponto único de falha. No I2P, os destinos são chaves públicas—sequestrar uma consulta comprometeria completamente uma identidade. Nomeação baseada em votação. Um adversário pode criar identidades ilimitadas (um ataque Sybil) e “vencer” votos para nomes populares. Mitigações por prova de trabalho aumentam o custo, mas introduzem uma sobrecarga pesada de coordenação. Em vez disso, o I2P mantém deliberadamente o sistema de nomes acima da camada de transporte. A biblioteca de nomes incluída oferece uma interface de provedor de serviços para que esquemas alternativos possam coexistir — os usuários decidem em quais livros de endereços ou jump services (serviços de salto) confiam.\nNomes Locais vs Globais (jrandom, 2005) Os nomes no I2P são localmente exclusivos, porém legíveis por humanos. O seu boss.i2p pode não corresponder ao boss.i2p de outra pessoa, e isso é intencional. Se um ator malicioso o enganasse para mudar o destino por trás de um nome, ele efetivamente sequestraria um serviço. Rejeitar a unicidade global previne esse tipo de ataque. Trate os nomes como favoritos/marcadores ou apelidos de IM (mensagens instantâneas)—você escolhe em quais destinos confiar assinando catálogos de endereços específicos ou adicionando chaves manualmente. Objeções Comuns e Respostas (zzz) Concern Response “Downloading hosts.txt is inefficient.” At ~400\u0026nbsp;KB for ~800 hosts the bandwidth impact is minor (~10\u0026nbsp;B/s if refreshed twice daily). ETags already avoid unnecessary transfers. Alternate formats (for example recenthosts.cgi) can deliver only new entries. “It won’t scale.” A hosts.txt entry is ~500\u0026nbsp;bytes; storing thousands locally is practical. Real-time lookups would dramatically slow browsing. “Requires trust and manual setup.” True—and intentional. Users must choose address book providers they trust. Trust is not binary; forcing configuration encourages users to think about it. “Why not just use DNS?” DNS depends on short TTLs and can be hijacked mid-path. I2P destinations are immutable public keys, so DNS semantics map poorly. “Subscriptions rely on specific servers.” Subscriptions are decentralised—you can add multiple providers or run your own. Completely decentralised systems struggle with conflict resolution and hijacking. “Jump services and hosts.txt feel awkward.” They are pragmatic trade-offs. Jump services provide just-in-time lookups; subscriptions keep a local cache for performance. ## Ideias de eficiência discutidas Forneça atualizações incrementais (apenas os destinos adicionados desde a última obtenção). Ofereça feeds suplementares (recenthosts.cgi) juntamente com arquivos completos de hosts. Explore ferramentas scriptáveis (por exemplo, i2host.i2p) para mesclar feeds ou filtrar por níveis de confiança. Principais pontos A segurança prevalece sobre o consenso global: livros de endereços mantidos localmente minimizam o risco de sequestro. Múltiplas abordagens de nomenclatura podem coexistir por meio da API de nomenclatura—os usuários decidem em que confiar. A nomenclatura global completamente descentralizada permanece um problema de pesquisa em aberto; os compromissos entre segurança, memorização humana e unicidade global ainda refletem o triângulo de Zooko . Referências Documentação de nomenclatura “Nomes: Descentralizados, Seguros e Significativos para humanos: Escolha dois”, de Zooko Exemplo de feed incremental: stats.i2p/cgi-bin/newhosts.txt ","description":"Debate histórico sobre o modelo de nomenclatura do I2P e por que esquemas globais ao estilo do DNS foram rejeitados","id":"952b10ba82200ff92e5ddeed512d6afb","section":"docs","title":"Discussão sobre Nomenclatura","url":"/pt/docs/legacy/naming/"},{"categories":null,"content":"NTCP vs. SSU Debate (março de 2007) Perguntas sobre NTCP Adaptado de uma conversa no IRC entre zzz e cervantes.\nPor que o NTCP tem prioridade sobre o SSU quando o NTCP parece adicionar sobrecarga e latência?\nO NTCP geralmente oferece melhor confiabilidade do que a implementação original do SSU. O streaming sobre NTCP incorre no colapso clássico de TCP sobre TCP?\nPossivelmente, mas o SSU foi concebido para ser a opção leve baseada em UDP e mostrou-se pouco confiável na prática. “NTCP considerado prejudicial” (zzz, 25 de março de 2007) Resumo: a maior latência e a sobrecarga do NTCP podem causar congestionamento, ainda assim, o roteamento prefere NTCP porque suas pontuações de lance são hard-coded (codificado fixo) como menores do que as do SSU. A análise levantou vários pontos:\nAtualmente, o NTCP faz um lance (bid) menor do que o SSU, portanto os routers preferem o NTCP, a menos que uma sessão SSU já esteja estabelecida. O SSU implementa confirmações (ACKs) com tempos limite (timeouts) estritamente limitados e coleta de estatísticas; o NTCP depende do Java NIO TCP com tempos limite ao estilo RFC que podem ser muito mais longos. A maior parte do tráfego (HTTP, IRC, BitTorrent) usa a biblioteca de streaming do I2P, efetivamente empilhando TCP sobre NTCP. Quando ambas as camadas retransmitem, é possível ocorrer colapso. Referências clássicas incluem TCP sobre TCP é uma má ideia . Os tempos limite da biblioteca de streaming aumentaram de 10 s para 45 s na versão 0.8; o tempo limite máximo do SSU é 3 s, enquanto os tempos limite do NTCP presumivelmente se aproximam de 60 s (recomendação da RFC). Os parâmetros do NTCP são difíceis de inspecionar externamente. Observações de campo em 2007 mostraram a taxa de upload do i2psnark oscilando, sugerindo colapso de congestionamento periódico. Testes de eficiência (forçando preferência por SSU) reduziram as razões de overhead do tunnel de aproximadamente 3.5:1 para 3:1 e melhoraram métricas de streaming (tamanho de janela, RTT, relação envio/ack). Propostas do tópico de 2007 Inverter as prioridades de transporte para que routers prefiram SSU (restaurando i2np.udp.alwaysPreferred). Marcar o tráfego de streaming para que o SSU atribua prioridade menor apenas às mensagens marcadas, sem comprometer o anonimato. Restringir os limites de retransmissão do SSU para reduzir o risco de colapso. Estudar underlays (camadas subjacentes da rede) semi-confiáveis para determinar se retransmissões abaixo da biblioteca de streaming trazem benefício líquido. Revisar filas de prioridade e tempos limite—por exemplo, aumentar os tempos limite de streaming além de 45 s para alinhar com o NTCP. Resposta de jrandom (27 de março de 2007) Principais contrapontos:\nNTCP existe porque as primeiras implantações de SSU sofreram colapso por congestionamento. Mesmo taxas modestas de retransmissão por salto podem explodir ao longo de tunnels multi-salto. Sem confirmações em nível de tunnel, apenas uma fração das mensagens recebe status de entrega fim a fim; falhas podem ser silenciosas. O controle de congestionamento do TCP tem décadas de otimizações; o NTCP aproveita isso por meio de pilhas TCP maduras. Os ganhos de eficiência observados ao preferir SSU podem refletir o comportamento de enfileiramento do router, em vez de vantagens intrínsecas do protocolo. Timeouts de streaming maiores já estavam melhorando a estabilidade; recomendou-se mais observação e dados antes de mudanças significativas. O debate ajudou a aprimorar os ajustes de transporte posteriores, mas não reflete a arquitetura moderna NTCP2/SSU2 (protocolos de transporte do I2P).\n","description":"Notas históricas comparando os transportes NTCP e SSU e propostas de ajuste fino","id":"6fe94dc04faadfde27bcfeaaf9da5f71","section":"docs","title":"Discussão sobre NTCP","url":"/pt/docs/ntcp/"},{"categories":null,"content":" Observação: Esta discussão arquivada descreve abordagens históricas para o banco de dados da rede (netDb). Consulte a documentação principal do netDb para conhecer o comportamento atual e as orientações.\nHistórico A netDb do I2P é distribuída usando um algoritmo floodfill simples. Versões iniciais também mantinham uma implementação de Kademlia DHT (tabela de hash distribuída Kademlia) como alternativa, mas ela se mostrou pouco confiável e foi completamente desativada na versão 0.6.1.20. O design floodfill encaminha uma entrada publicada para um router participante, aguarda confirmação e tenta novamente com outros pares floodfill, se necessário. Pares floodfill difundem mensagens de armazenamento de routers não-floodfill para todos os demais participantes floodfill.\nNo final de 2009, as consultas Kademlia foram parcialmente reintroduzidas para reduzir a carga de armazenamento em floodfill routers individuais.\nIntrodução ao Floodfill (nó especial da netDb que armazena e difunde entradas) Floodfill surgiu pela primeira vez na versão 0.6.0.4, enquanto Kademlia permaneceu disponível como opção de backup. Na época, a alta perda de pacotes e as rotas restritas dificultavam a obtenção de confirmações de recebimento dos quatro pares mais próximos, frequentemente exigindo dezenas de tentativas redundantes de armazenamento. Migrar para um subconjunto floodfill de routers acessíveis externamente forneceu uma solução pragmática de curto prazo.\nRepensando Kademlia Algumas alternativas consideradas incluíam:\nExecutar o netDb como uma Kademlia DHT (tabela hash distribuída Kademlia) limitada a routers alcançáveis que optem por participar Manter o modelo floodfill, mas limitar a participação a routers capazes e verificar a distribuição com verificações aleatórias A abordagem floodfill prevaleceu porque era mais fácil de implantar e a netDb transporta apenas metadados, não dados de usuário. A maioria dos destinos nunca publica um LeaseSet porque o remetente normalmente agrega o seu LeaseSet em garlic messages (mensagens compostas no I2P).\nEstado Atual (Perspectiva Histórica) Os algoritmos do netDb estão ajustados às necessidades da rede e historicamente deram conta confortavelmente de algumas centenas de routers. Estimativas iniciais sugeriam que 3–5 floodfill routers poderiam suportar cerca de 10.000 nós.\nCálculos Atualizados (Março de 2008) recvKBps = N * (L + 1) * (1 + F) * (1 + R) * S / T Onde:\nN: Routers na rede L: Número médio de destinos de cliente por router (mais um para o RouterInfo) F: Percentual de falhas de Tunnel R: Período de reconstrução do Tunnel como fração da vida útil do tunnel S: Tamanho médio de entrada no netDb T: Vida útil do Tunnel Usando valores de 2008 (N = 700, L = 0.5, F = 0.33, R = 0.5, S = 4 KB, T = 10 minutes) produz:\nrecvKBps ≈ 700 * (0.5 + 1) * (1 + 0.33) * (1 + 0.5) * 4 KB / 10m ≈ 28 KBps Kademlia voltará? Os desenvolvedores discutiram reintroduzir Kademlia (um protocolo DHT) por volta do início de 2007. O consenso foi que a capacidade de floodfill poderia ser ampliada incrementalmente conforme necessário, enquanto Kademlia acrescentava complexidade significativa e requisitos de recursos para a população básica de routers. O fallback (mecanismo de reserva) permanece inativo, a menos que a capacidade de floodfill se torne insuficiente.\nPlanejamento de Capacidade do Floodfill A inclusão automática de routers de classe de largura de banda O no floodfill, embora tentadora, implica riscos de cenários de negação de serviço se nós hostis aderirem. Análises históricas sugeriram que limitar o pool de floodfill (por exemplo, 3–5 pares lidando com ~10K routers) era mais seguro. Operadores confiáveis ou heurísticas automáticas têm sido utilizados para manter um conjunto de floodfill adequado, porém controlado.\nFloodfill TODO (Histórico) Esta seção é mantida para a posteridade. A página principal do netDb acompanha o roteiro atual e as considerações de design.\nIncidentes operacionais, como um período em 13 de março de 2008 com apenas um floodfill router disponível, levaram a várias melhorias entregues entre as versões 0.6.1.33 e 0.7.x, incluindo:\nAleatorizando a seleção de floodfill para buscas e priorizando pares responsivos Exibindo métricas adicionais de floodfill na página \u0026ldquo;Profiles\u0026rdquo; do console do router Reduções progressivas no tamanho das entradas do netDb para reduzir o uso de largura de banda do floodfill Opt-in automático para um subconjunto de routers de classe O, com base no desempenho coletado por meio de dados de perfil Aprimoramentos em listas de bloqueio, na seleção de pares de floodfill e nas heurísticas de exploração As ideias remanescentes do período incluíam:\nUsando estatísticas de dbHistory para avaliar e selecionar melhor pares floodfill (routers que mantêm e distribuem a netDb) Melhorando o comportamento de novas tentativas para evitar contatar repetidamente pares com falhas Tirando partido de métricas de latência e pontuações de integração na seleção Detectando e reagindo mais rapidamente a routers floodfill com falhas Continuando a reduzir as exigências de recursos em nós de alta largura de banda e floodfill Mesmo na data destas notas, a rede era considerada resiliente, com infraestrutura pronta para responder rapidamente a floodfills (routers especiais que mantêm e propagam a netDb) hostis ou a ataques de negação de serviço direcionados contra floodfill.\nNotas adicionais A console do router há muito tempo exibe dados de perfil aprimorados para ajudar na análise da confiabilidade do floodfill. Embora comentários históricos tenham especulado sobre Kademlia ou esquemas de DHT (tabela hash distribuída) alternativos, o floodfill tem permanecido o algoritmo principal para redes de produção. A pesquisa prospectiva concentrou-se em tornar a admissão ao floodfill adaptativa, ao mesmo tempo em que limita as oportunidades de abuso. ","description":"Notas históricas sobre floodfill, experimentos com Kademlia (protocolo de tabela de hash distribuída), e ajustes futuros para o netDb","id":"0ddefeec5b7108b36649c4d989bf474e","section":"docs","title":"Discussão sobre o Banco de Dados da Rede","url":"/pt/docs/netdb/"},{"categories":null,"content":" Observação: Este arquivo reúne trabalho de design especulativo anterior ao I2P 0.9.41. Para a implementação de produção, consulte a documentação de tunnel .\nAlternativas de configuração As ideias consideradas para futuros ajustes do tunnel incluíram:\nLimitadores de frequência para entrega de mensagens Políticas de preenchimento (incluindo injeção de chaff, ruído falso) Controles de vida útil de Tunnel Estratégias de lote e de fila para envio de carga útil Nenhuma dessas opções foi incluída na implementação legada.\nEstratégias de preenchimento Abordagens potenciais de preenchimento discutidas:\nSem preenchimento Preenchimento de comprimento aleatório Preenchimento de comprimento fixo Preenchimento até o quilobyte mais próximo Preenchimento para potências de dois (2^n bytes) Medições iniciais (versão 0.4) resultaram no tamanho fixo atual de 1024 bytes para mensagens de tunnel. Garlic messages (mensagens \u0026ldquo;garlic\u0026rdquo;) de nível superior podem adicionar seu próprio preenchimento.\nFragmentação Para evitar ataques de marcação por meio do tamanho da mensagem, as mensagens de tunnel são fixadas em 1024 bytes. Cargas úteis I2NP maiores são fragmentadas pelo gateway (porta de entrada); o endpoint (ponto final) remonta os fragmentos dentro de um curto tempo limite. Routers podem reorganizar os fragmentos para maximizar a eficiência de empacotamento antes do envio.\nAlternativas adicionais Ajustar o processamento do Tunnel em trânsito Três possibilidades foram examinadas:\nPermitir que um salto intermediário encerre temporariamente um tunnel ao conceder acesso às cargas úteis descriptografadas. Permitir que os routers participantes “remixem” mensagens, enviando-as por um dos seus próprios tunnels de saída antes de continuar para o próximo salto. Permitir que o criador do tunnel redefina dinamicamente o próximo salto de um par. Tunnels Bidirecionais Usar tunnels de entrada e de saída separados limita as informações que qualquer conjunto individual de pares pode observar (por exemplo, uma requisição GET vs. uma resposta grande). Tunnels bidirecionais simplificam o gerenciamento de pares, mas expõem padrões completos de tráfego em ambas as direções simultaneamente. Tunnels unidirecionais, portanto, permaneceram o design preferido.\nCanais de retorno e tamanhos variáveis Permitir tamanhos variáveis de mensagens de tunnel possibilitaria canais encobertos entre pares em conluio (por exemplo, codificando dados por meio de tamanhos ou frequências selecionados). Mensagens de tamanho fixo mitigam esse risco ao custo de sobrecarga adicional de padding (preenchimento).\nAlternativas para a construção de Tunnel Referência: Hashing it out in Public Método de Construção “Paralelo” Legado Antes da versão 0.6.1.10, as solicitações de construção de tunnel eram enviadas em paralelo para cada participante. Esse método está documentado na página antiga de tunnel .\nConstrução Telescópica em Um Único Passo (Método Atual) A abordagem moderna envia mensagens de construção salto a salto através do tunnel parcialmente construído. Embora semelhante ao telescoping (técnica de construção incremental de circuitos) do Tor, rotear mensagens de construção através de tunnels exploratórios reduz o vazamento de informações.\nTelescopagem “interativa” Construir um salto de cada vez com ciclos de ida e volta explícitos permite que os pares contem as mensagens e infiram sua posição no tunnel, portanto, essa abordagem foi rejeitada.\nTunnels de gerenciamento não exploratórios Uma proposta foi manter um pool separado de tunnels de gerenciamento para o tráfego de construção (build traffic). Embora pudesse ajudar routers particionados, considerou-se desnecessário com uma integração adequada à rede.\nEntrega Exploratória (Legado) Antes da versão 0.6.1.10, solicitações individuais de tunnel eram garlic-encrypted e entregues via tunnels exploratórios, com as respostas retornando separadamente. Essa estratégia foi substituída pelo one-shot telescoping method (método telescópico de uma só vez) atual.\nPrincipais pontos Mensagens de tunnel de tamanho fixo protegem contra marcação baseada em tamanho e canais encobertos, apesar do custo adicional de preenchimento. Estratégias alternativas de preenchimento, fragmentação e construção foram exploradas, mas não adotadas quando ponderadas em relação aos compromissos de anonimato. O design de tunnel continua a equilibrar eficiência, observabilidade e resistência a ataques de predecessor e de congestionamento. ","description":"Exploração histórica do padding (preenchimento) de tunnel, da fragmentação de tunnel e das estratégias de construção de tunnel","id":"e5773155afe129d73b1384e5c116ec56","section":"docs","title":"Discussão sobre Tunnel","url":"/pt/docs/legacy/tunnel/"},{"categories":null,"content":"Status da Implementação Implantação atual: - i2pd (implementação em C++): Totalmente implementado na versão 2.58.0 (setembro de 2025) com suporte a ML-KEM-512, ML-KEM-768 e ML-KEM-1024. Criptografia de ponta a ponta pós-quântica habilitada por padrão quando o OpenSSL 3.5.0 ou posterior estiver disponível. - Java I2P: Ainda não implementado nas versões 0.9.67 / 2.10.0 (setembro de 2025). Especificação aprovada e implementação planejada para versões futuras.\nEsta especificação descreve a funcionalidade aprovada que está atualmente implantada no i2pd e planejada para implementações em Java do I2P.\nVisão geral Esta é a variante híbrida pós-quântica do protocolo ECIES-X25519-AEAD-Ratchet ECIES . Ela representa a primeira fase da Proposta 169 Prop169 a ser aprovada. Consulte essa proposta para objetivos gerais, modelos de ameaça, análise, alternativas e informações adicionais.\nStatus da Proposta 169: Aberta (primeira fase aprovada para implementação híbrida de ECIES).\nEsta especificação contém apenas as diferenças em relação ao ECIES padrão e deve ser lida em conjunto com aquela especificação.\nProjeto Utilizamos o padrão NIST FIPS 203 FIPS203 , que se baseia em, mas não é compatível com, o CRYSTALS-Kyber (versões 3.1, 3 e anteriores).\nHandshakes híbridos combinam X25519 Diffie-Hellman clássico com mecanismos de encapsulamento de chaves pós-quânticos ML-KEM. Essa abordagem baseia-se em conceitos de sigilo futuro híbrido (hybrid forward secrecy) documentados na pesquisa PQNoise e em implementações semelhantes no TLS 1.3, IKEv2 e WireGuard.\nTroca de Chaves Definimos uma troca de chaves híbrida para o Ratchet (mecanismo de avanço criptográfico). O KEM pós-quântico fornece apenas chaves efêmeras e não oferece suporte direto a handshakes de chave estática, como o Noise IK.\nDefinimos as três variantes de ML-KEM (mecanismo de encapsulamento de chaves baseado em reticulados modulares) conforme especificado em FIPS203 , totalizando 3 novos tipos de criptografia. Os tipos híbridos só são definidos em combinação com X25519.\nOs novos tipos de criptografia são:\nType Code Security Level ML-KEM Variant MLKEM512_X25519 5 NIST Category 1 (AES-128 equivalent) ML-KEM-512 MLKEM768_X25519 6 NIST Category 3 (AES-192 equivalent) ML-KEM-768 (Recommended) MLKEM1024_X25519 7 NIST Category 5 (AES-256 equivalent) ML-KEM-1024 **Nota:** MLKEM768_X25519 (Type 6) é a variante padrão recomendada, oferecendo forte segurança pós-quântica com sobrecarga razoável. A sobrecarga é substancial em comparação com a criptografia somente com X25519. Os tamanhos típicos das mensagens 1 e 2 (para o IK pattern (padrão IK do Noise)) estão atualmente em torno de 96-103 bytes (antes da carga útil adicional). Isso aumentará aproximadamente 9-12x para MLKEM512 (KEM pós-quântico ML-KEM), 13-16x para MLKEM768 e 17-23x para MLKEM1024, dependendo do tipo de mensagem.\nNova criptografia necessária ML-KEM (anteriormente CRYSTALS-Kyber) FIPS203 - Padrão de Mecanismo de Encapsulamento de Chaves baseado em reticulados de módulos SHA3-256 (anteriormente Keccak-512) FIPS202 - Parte do Padrão SHA-3 SHAKE128 e SHAKE256 (extensões XOF ao SHA3) FIPS202 - Funções de Saída Extensível Vetores de teste para SHA3-256, SHAKE128 e SHAKE256 estão disponíveis no NIST Cryptographic Algorithm Validation Program .\nSuporte de bibliotecas: - Java: a biblioteca Bouncycastle versão 1.79 e posteriores oferece suporte a todas as variantes de ML-KEM (mecanismo de encapsulamento de chaves pós-quântico) e às funções SHA3/SHAKE (algoritmos SHA-3 e SHAKE) - C++: OpenSSL 3.5 e posteriores incluem suporte completo a ML-KEM (lançado em abril de 2025) - Go: Várias bibliotecas disponíveis para implementação de ML-KEM e SHA3\nEspecificação Estruturas Comuns Consulte a Especificação de Estruturas Comuns para comprimentos de chaves e identificadores.\nPadrões de Handshake Os handshakes usam padrões de handshake do Noise Protocol Framework (framework de protocolo Noise) com adaptações específicas do I2P para segurança pós-quântica híbrida.\nO seguinte mapeamento de letras é utilizado:\ne = chave efêmera de uso único (X25519) s = chave estática p = carga útil da mensagem e1 = chave PQ (pós-quântica) efêmera de uso único, enviada de Alice para Bob (token específico do I2P) ekem1 = o texto cifrado do KEM (mecanismo de encapsulamento de chaves), enviado de Bob para Alice (token específico do I2P) Nota importante: Os nomes de padrão \u0026ldquo;IKhfs\u0026rdquo; e \u0026ldquo;IKhfselg2\u0026rdquo; e os tokens \u0026ldquo;e1\u0026rdquo; e \u0026ldquo;ekem1\u0026rdquo; são adaptações específicas do I2P não documentadas na especificação oficial do Noise Protocol Framework. Elas representam definições personalizadas para integrar o ML-KEM ao padrão Noise IK. Embora a abordagem híbrida X25519 + ML-KEM seja amplamente reconhecida na pesquisa em criptografia pós-quântica e em outros protocolos, a nomenclatura específica usada aqui é própria do I2P.\nAs seguintes modificações ao IK (padrão de aperto de mão do Noise) para sigilo de encaminhamento híbrido são aplicadas:\nStandard IK: I2P IKhfs (Hybrid): \u0026lt;- s \u0026lt;- s ... ... -\u0026gt; e, es, s, ss, p -\u0026gt; e, es, e1, s, ss, p \u0026lt;- e, ee, se, p \u0026lt;- e, ee, ekem1, se, p \u0026lt;- p \u0026lt;- p p -\u0026gt; p -\u0026gt; Note: e1 and ekem1 are encrypted within ChaCha20-Poly1305 AEAD blocks. Note: e1 (ML-KEM public key) and ekem1 (ML-KEM ciphertext) have different sizes. O padrão e1 é definido da seguinte forma:\nFor Alice (sender): (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) ciphertext = ENCRYPT(k, n, encap_key, ad) n++ MixHash(ciphertext) For Bob (receiver): // DecryptAndHash(ciphertext) encap_key = DECRYPT(k, n, ciphertext, ad) n++ MixHash(ciphertext) O padrão ekem1 é definido da seguinte forma:\nFor Bob (receiver of encap_key): (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) MixHash(ciphertext) // MixKey MixKey(kem_shared_key) For Alice (sender of encap_key): // DecryptAndHash(ciphertext) kem_ciphertext = DECRYPT(k, n, ciphertext, ad) MixHash(ciphertext) // MixKey kem_shared_key = DECAPS(kem_ciphertext, decap_key) MixKey(kem_shared_key) Operações Definidas do ML-KEM Definimos as seguintes funções correspondentes às primitivas criptográficas, conforme especificado em FIPS203 .\n(encap_key, decap_key) = PQ_KEYGEN() : Alice cria as chaves de encapsulamento e desencapsulamento. A chave de encapsulamento é enviada na mensagem NS. Tamanhos das chaves: - ML-KEM-512: encap_key = 800 bytes, decap_key = 1632 bytes - ML-KEM-768: encap_key = 1184 bytes, decap_key = 2400 bytes - ML-KEM-1024: encap_key = 1568 bytes, decap_key = 3168 bytes\n(ciphertext, kem_shared_key) = ENCAPS(encap_key) : Bob calcula o texto cifrado e a chave compartilhada usando a chave de encapsulação recebida na mensagem NS. O texto cifrado é enviado na mensagem NSR. Tamanhos do texto cifrado: - ML-KEM-512: 768 bytes - ML-KEM-768: 1088 bytes - ML-KEM-1024: 1568 bytes\nO kem_shared_key tem sempre 32 bytes em todas as três variantes.\nkem_shared_key = DECAPS(ciphertext, decap_key) : Alice calcula a chave compartilhada usando o ciphertext recebido na mensagem NSR. O kem_shared_key é sempre 32 bytes.\nImportante: Tanto o encap_key quanto o texto cifrado são criptografados dentro de blocos ChaCha20-Poly1305 nas mensagens 1 e 2 do handshake (aperto de mão) Noise. Ambos serão descriptografados como parte do processo de handshake.\nO kem_shared_key é integrado à chave de encadeamento com MixKey(). Veja abaixo para mais detalhes.\nKDF (função de derivação de chave) do Noise Handshake Visão geral O handshake híbrido combina o X25519 ECDH clássico com o ML-KEM pós-quântico. A primeira mensagem, de Alice para Bob, contém e1 (a chave de encapsulamento do ML-KEM) antes da carga útil da mensagem. Isso é tratado como material de chave adicional; aplique EncryptAndHash() a e1 (como Alice) ou DecryptAndHash() (como Bob). Em seguida, processe a carga útil da mensagem como de costume.\nA segunda mensagem, de Bob para Alice, contém ekem1 (o texto cifrado ML-KEM) antes da carga útil da mensagem. Isso é tratado como material de chave adicional; chame EncryptAndHash() nele (como Bob) ou DecryptAndHash() (como Alice). Em seguida, calcule kem_shared_key e chame MixKey(kem_shared_key). Depois, processe a carga útil da mensagem como de costume.\nIdentificadores do Noise (framework de protocolos criptográficos) Estas são as strings de inicialização do Noise (específicas do I2P):\nNoise_IKhfselg2_25519+MLKEM512_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM768_ChaChaPoly_SHA256 Noise_IKhfselg2_25519+MLKEM1024_ChaChaPoly_SHA256 KDF (função de derivação de chaves) de Alice para a mensagem NS Após o padrão de mensagem \u0026rsquo;es\u0026rsquo; e antes do padrão de mensagem \u0026rsquo;s\u0026rsquo;, adicione:\nThis is the \u0026#34;e1\u0026#34; message pattern: (encap_key, decap_key) = PQ_KEYGEN() // EncryptAndHash(encap_key) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, encap_key, ad) n++ // MixHash(ciphertext) h = SHA256(h || ciphertext) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). KDF de Bob para a Mensagem NS Após o padrão de mensagem \u0026rsquo;es\u0026rsquo; e antes do padrão de mensagem \u0026rsquo;s\u0026rsquo;, adicione:\nThis is the \u0026#34;e1\u0026#34; message pattern: // DecryptAndHash(encap_key_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h encap_key = DECRYPT(k, n, encap_key_section, ad) n++ // MixHash(encap_key_section) h = SHA256(h || encap_key_section) End of \u0026#34;e1\u0026#34; message pattern. NOTE: For the next section (payload for XK or static key for IK), the keydata and chain key remain the same, and n now equals 1 (instead of 0 for non-hybrid). KDF de Bob para a Mensagem NSR Após o padrão de mensagem \u0026rsquo;ee\u0026rsquo; e antes do padrão de mensagem \u0026lsquo;se\u0026rsquo;, adicione:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: (kem_ciphertext, kem_shared_key) = ENCAPS(encap_key) // EncryptAndHash(kem_ciphertext) // AEAD parameters k = keydata[32:63] n = 0 ad = h ciphertext = ENCRYPT(k, n, kem_ciphertext, ad) // MixHash(ciphertext) h = SHA256(h || ciphertext) // MixKey(kem_shared_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. Função de derivação de chaves (KDF) de Alice para a mensagem NSR Depois do padrão de mensagem \u0026rsquo;ee\u0026rsquo; e antes do padrão de mensagem \u0026lsquo;ss\u0026rsquo;, adicione:\nThis is the \u0026#34;ekem1\u0026#34; message pattern: // DecryptAndHash(kem_ciphertext_section) // AEAD parameters k = keydata[32:63] n = 0 ad = h kem_ciphertext = DECRYPT(k, n, kem_ciphertext_section, ad) // MixHash(kem_ciphertext_section) h = SHA256(h || kem_ciphertext_section) // MixKey(kem_shared_key) kem_shared_key = DECAPS(kem_ciphertext, decap_key) keydata = HKDF(chainKey, kem_shared_key, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] End of \u0026#34;ekem1\u0026#34; message pattern. KDF para split() A função split() permanece inalterada em relação à especificação padrão do ECIES. Após a conclusão do handshake (negociação inicial):\nkeydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] k_ba = keydata[32:63] Estas são as chaves de sessão bidirecionais para a comunicação em andamento.\nFormato da Mensagem Formato NS (New Session - nova sessão) Alterações: O ratchet (mecanismo de avanço) atual contém a chave estática na primeira seção ChaCha20-Poly1305 e a carga útil na segunda seção. Com o ML-KEM, agora há três seções. A primeira seção contém a chave pública do ML-KEM criptografada (encap_key). A segunda seção contém a chave estática. A terceira seção contém a carga útil.\nTamanhos de mensagens:\nType Type Code X25519 len NS len NS Enc len NS Dec len PQ key len pl len X25519 4 32 96+pl 64+pl pl -- pl MLKEM512_X25519 5 32 912+pl 880+pl 800+pl 800 pl MLKEM768_X25519 6 32 1296+pl 1264+pl 1184+pl 1184 pl MLKEM1024_X25519 7 32 1680+pl 1648+pl 1568+pl 1568 pl **Nota:** A carga útil deve conter um bloco DateTime (bloco de data e hora) (mínimo de 7 bytes: tipo de 1 byte, tamanho de 2 bytes, carimbo de data/hora de 4 bytes). Os tamanhos mínimos de NS podem ser calculados de acordo. O tamanho mínimo prático de NS é, portanto, de 103 bytes para X25519 e varia de 919 a 1687 bytes para variantes híbridas. Os aumentos de tamanho de 816, 1200 e 1584 bytes para as três variantes de ML-KEM (mecanismo de encapsulamento de chaves) devem-se à chave pública do ML-KEM mais um MAC Poly1305 de 16 bytes para criptografia autenticada.\nFormato do NSR (New Session Reply, resposta de nova sessão) Alterações: O ratchet (mecanismo de avanço) atual tem uma carga útil vazia para a primeira seção de ChaCha20-Poly1305 e a carga útil na segunda seção. Com o ML-KEM, agora há três seções. A primeira seção contém o texto cifrado do ML-KEM. A segunda seção tem uma carga útil vazia. A terceira seção contém a carga útil.\nTamanhos de mensagens:\nType Type Code X25519 len NSR len NSR Enc len NSR Dec len PQ ct len pl len X25519 4 32 72+pl 40+pl pl -- pl MLKEM512_X25519 5 32 856+pl 824+pl 784+pl 768 pl MLKEM768_X25519 6 32 1176+pl 1144+pl 1104+pl 1088 pl MLKEM1024_X25519 7 32 1656+pl 1624+pl 1584+pl 1568 pl Os aumentos de tamanho de 784, 1104 e 1584 bytes para as três variantes do ML-KEM (mecanismo de encapsulamento de chaves baseado em reticulados modulares) devem-se ao texto cifrado do ML-KEM mais um MAC Poly1305 de 16 bytes para criptografia autenticada. Análise de Sobrecarga Troca de chaves A sobrecarga da criptografia híbrida é substancial em comparação com o uso somente de X25519:\nMLKEM512_X25519: Aproximadamente 9-12x de aumento no tamanho da mensagem de handshake (aperto de mão) (NS: 9,5x, NSR: 11,9x) MLKEM768_X25519: Aproximadamente 13-16x de aumento no tamanho da mensagem de handshake (NS: 13,5x, NSR: 16,3x) MLKEM1024_X25519: Aproximadamente 17-23x de aumento no tamanho da mensagem de handshake (NS: 17,5x, NSR: 23x) Essa sobrecarga é aceitável pelos benefícios adicionais de segurança pós-quântica. Os multiplicadores variam conforme o tipo de mensagem porque os tamanhos base das mensagens diferem (NS mínimo 96 bytes, NSR mínimo 72 bytes).\nConsiderações sobre largura de banda Para um estabelecimento de sessão típico com cargas úteis mínimas: - Apenas X25519: ~200 bytes no total (NS + NSR) - MLKEM512_X25519: ~1,800 bytes no total (aumento de 9x) - MLKEM768_X25519: ~2,500 bytes no total (aumento de 12.5x) - MLKEM1024_X25519: ~3,400 bytes no total (aumento de 17x)\nApós o estabelecimento da sessão, a criptografia contínua das mensagens utiliza o mesmo formato de transporte de dados que as sessões que usam apenas X25519, de modo que não há sobrecarga para as mensagens subsequentes.\nAnálise de segurança Apertos de mão O handshake (procedimento inicial de negociação) híbrido fornece segurança clássica (X25519) e pós-quântica (ML-KEM). Um atacante deve quebrar ambos o ECDH clássico e o KEM (Mecanismo de Encapsulamento de Chaves) pós-quântico para comprometer as chaves de sessão.\nIsso oferece: - Segurança atual: X25519 ECDH fornece segurança contra atacantes clássicos (nível de segurança de 128 bits) - Segurança futura: ML-KEM fornece segurança contra atacantes quânticos (varia conforme o conjunto de parâmetros) - Segurança híbrida: Ambos devem ser quebrados para comprometer a sessão (nível de segurança = máximo entre os dois componentes)\nNíveis de segurança Variant NIST Category Classical Security PQ Security Hybrid Security MLKEM512_X25519 Category 1 128-bit (X25519) AES-128 equivalent 128-bit MLKEM768_X25519 Category 3 128-bit (X25519) AES-192 equivalent 128-bit MLKEM1024_X25519 Category 5 128-bit (X25519) AES-256 equivalent 128-bit **Nota:** O nível de segurança híbrido é limitado pelo mais fraco dos dois componentes. Em todos os casos, X25519 oferece segurança clássica de 128 bits. Se um computador quântico criptograficamente relevante se tornar disponível, o nível de segurança dependerá do conjunto de parâmetros ML-KEM escolhido. Sigilo Direto A abordagem híbrida mantém as propriedades de sigilo direto (forward secrecy). As chaves de sessão são derivadas a partir de ambas as trocas de chaves efêmeras X25519 e ML-KEM. Se as chaves privadas efêmeras X25519 ou ML-KEM forem destruídas após o handshake (negociação inicial), sessões anteriores não poderão ser descriptografadas mesmo que as chaves estáticas de longo prazo sejam comprometidas.\nO padrão IK fornece sigilo de encaminhamento completo (Confidencialidade do Noise nível 5) após a segunda mensagem (NSR) ser enviada.\nPreferências de Tipo As implementações devem oferecer suporte a vários tipos híbridos e negociar a variante mutuamente suportada mais forte. A ordem de preferência deve ser:\nMLKEM768_X25519 (Tipo 6) - Padrão recomendado, melhor equilíbrio entre segurança e desempenho MLKEM1024_X25519 (Tipo 7) - Máxima segurança para aplicações sensíveis MLKEM512_X25519 (Tipo 5) - Segurança pós-quântica básica para cenários com recursos limitados X25519 (Tipo 4) - Apenas clássico, alternativa para compatibilidade Justificativa: MLKEM768_X25519 é recomendado como padrão porque fornece segurança de Categoria 3 do NIST (equivalente ao AES-192), o que é considerado proteção suficiente contra computadores quânticos, mantendo tamanhos de mensagem razoáveis. MLKEM1024_X25519 oferece segurança superior, porém com uma sobrecarga substancialmente maior.\nNotas de Implementação Suporte a bibliotecas Java: A partir da versão 1.79 (agosto de 2024), a biblioteca Bouncycastle oferece suporte a todas as variantes necessárias de ML-KEM e às funções SHA3/SHAKE. Use org.bouncycastle.pqc.crypto.mlkem.MLKEMEngine para conformidade com a FIPS 203. C++: OpenSSL 3.5 (abril de 2025) e versões posteriores incluem suporte a ML-KEM por meio da interface EVP_KEM. Esta é uma versão Long Term Support (suporte de longo prazo) mantida até abril de 2030. Go: Várias bibliotecas de terceiros estão disponíveis para ML-KEM e SHA3, incluindo a biblioteca CIRCL da Cloudflare. Estratégia de Migração Implementações devem: 1. Suportar tanto a variante apenas X25519 (algoritmo de acordo de chaves de curva elíptica) quanto as variantes híbridas ML-KEM (mecanismo de encapsulamento de chaves baseado em reticulados de módulo) durante o período de transição 2. Preferir as variantes híbridas quando ambos os pares as suportarem 3. Manter fallback para apenas X25519 para compatibilidade com versões anteriores 4. Considerar as restrições de largura de banda da rede ao selecionar a variante padrão\nTunnels Compartilhados O aumento dos tamanhos de mensagem pode impactar o uso de tunnel compartilhado. As implementações devem considerar: - Agrupar handshakes quando possível para amortizar a sobrecarga - Usar tempos de expiração mais curtos para sessões híbridas a fim de reduzir o estado armazenado - Monitorar o uso de largura de banda e ajustar os parâmetros conforme necessário - Implementar controle de congestionamento para o tráfego de estabelecimento de sessão\nConsiderações sobre o tamanho de novas sessões Devido ao maior tamanho das mensagens de handshake, as implementações podem precisar de: - Aumentar os tamanhos de buffer para a negociação de sessão (mínimo de 4KB recomendado) - Ajustar os valores de tempo limite para conexões mais lentas (considerar mensagens ~3-17x maiores) - Considerar compressão para os dados de carga útil em mensagens NS/NSR - Implementar tratamento de fragmentação se exigido pela camada de transporte\nTestes e Validação As implementações devem verificar: - Geração correta de chaves ML-KEM, encapsulamento e decapsulamento - Integração adequada de kem_shared_key no Noise KDF - Cálculos do tamanho da mensagem em conformidade com a especificação - Interoperabilidade com outras implementações de I2P router - Comportamento de fallback (mecanismo de contingência) quando ML-KEM não estiver disponível\nVetores de teste para operações de ML-KEM (mecanismo de encapsulamento de chaves) estão disponíveis no Programa de Validação de Algoritmos Criptográficos do NIST.\nCompatibilidade de Versões Numeração de versões do I2P: O I2P mantém dois números de versão paralelos: - Versão de lançamento do Router: formato 2.x.x (por exemplo, 2.10.0 lançado em setembro de 2025) - Versão da API/protocolo: formato 0.9.x (por exemplo, 0.9.67 corresponde ao router 2.10.0)\nEsta especificação faz referência à versão do protocolo 0.9.67, que corresponde à versão 2.10.0 do router e posteriores.\nMatriz de compatibilidade:\nImplementation Version ML-KEM Support Status i2pd 2.58.0+ Full (512/768/1024) Deployed September 2025 Java I2P 0.9.67 / 2.10.0 Not yet Planned for future release ## Referências [ECIES]: Especificação ECIES-X25519-AEAD-Ratchet [Prop169]: Proposta 169: Criptografia Pós-Quântica [FIPS203]: NIST FIPS 203 - Padrão ML-KEM [FIPS202]: NIST FIPS 202 - Padrão SHA-3 [Noise]: Framework do Protocolo Noise [COMMON]: Especificação de Estruturas Comuns [RFC7539]: RFC 7539 - ChaCha20 e Poly1305 [RFC5869]: RFC 5869 - HKDF [OpenSSL]: Documentação do OpenSSL 3.5 - ML-KEM [Bouncycastle]: Biblioteca de Criptografia Java Bouncycastle ","description":"Variante híbrida pós-quântica do protocolo de criptografia ECIES (Esquema de Criptografia Integrada por Curvas Elípticas) usando ML-KEM (mecanismo de encapsulamento de chaves baseado em reticulados modulares)","id":"f6a66a37875c5b108bc5a8ea027dc0e2","section":"docs","title":"ECIES-X25519-AEAD-Ratchet Criptografia Híbrida","url":"/pt/docs/specs/ecies-hybrid/"},{"categories":null,"content":"Visão geral Routers verificam automaticamente a existência de atualizações consultando periodicamente um feed de notícias assinado distribuído pela rede I2P. Quando uma versão mais recente é anunciada, o router baixa um arquivo de atualização assinado criptograficamente (.su3) e o prepara para instalação. Este sistema garante distribuição autenticada, resistente à adulteração e multicanal de versões oficiais.\nA partir da versão 2.10.0 do I2P, o sistema de atualização utiliza: - RSA-4096 / SHA-512 assinaturas - formato de contêiner SU3 (substituindo os legados SUD/SU2) - Espelhos redundantes: HTTP na rede, HTTPS na clearnet e BitTorrent\n1. Feed de Notícias Routers verificam o feed Atom assinado a cada algumas horas para descobrir novas versões e avisos de segurança. O feed é assinado e distribuído como um arquivo .su3, que pode incluir:\n\u0026lt;i2p:version\u0026gt; — novo número de versão \u0026lt;i2p:minVersion\u0026gt; — versão mínima do router suportada \u0026lt;i2p:minJavaVersion\u0026gt; — ambiente de execução Java mínimo obrigatório \u0026lt;i2p:update\u0026gt; — lista vários espelhos de download (I2P, HTTPS, torrent) \u0026lt;i2p:revocations\u0026gt; — dados de revogação de certificados \u0026lt;i2p:blocklist\u0026gt; — listas de bloqueio no nível da rede para pares comprometidos Distribuição do feed Channel Description Usage I2P HTTP (eepsite) Primary update source Private, resilient Clearnet HTTPS Fallback mirror Public fallback BitTorrent magnet Distributed channel Reduces mirror load Os routers preferem o feed via I2P, mas podem recorrer à distribuição via clearnet ou via torrent, se necessário. 2. Formatos de Arquivo SU3 (Padrão atual) Introduzido na versão 0.9.9, o SU3 substituiu os formatos legados SUD e SU2. Cada arquivo contém um cabeçalho, uma carga útil e uma assinatura final.\nEstrutura do Cabeçalho \u0026lt;tr\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Field\u0026lt;/th\u0026gt; \u0026lt;th style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem; text-align:left; background:var(--color-bg-secondary);\u0026quot;\u0026gt;Description\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Magic\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;\u0026quot;I2Psu3\u0026quot;\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Format Version\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;0\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;e.g., \u0026lt;code\u0026gt;0x000B\u0026lt;/code\u0026gt; (RSA-SHA512-4096)\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signature Length\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;\u0026lt;code\u0026gt;512 bytes\u0026lt;/code\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Version String\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Router version\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Signer ID\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Certificate name\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;Content Type\u0026lt;/td\u0026gt; \u0026lt;td style=\u0026quot;border:1px solid var(--color-border); padding:0.6rem;\u0026quot;\u0026gt;1 = router update, 3 = reseed, 4 = news feed\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Etapas de verificação da assinatura 1. Analisar o cabeçalho e identificar o algoritmo de assinatura. 2. Verificar o hash e a assinatura usando o certificado do signatário armazenado. 3. Confirmar que o certificado do signatário não foi revogado. 4. Comparar a string de versão incorporada com os metadados da carga útil.\nRouters vêm com certificados de assinadores confiáveis (atualmente zzz e str4d) e rejeitam quaisquer fontes não assinadas ou revogadas.\nSU2 (Obsoleto) Usava a extensão .su2 com JARs comprimidos com Pack200. Removido após o Java 14 ter marcado o Pack200 como obsoleto (JEP 367). Desativado no I2P 0.9.48+; agora totalmente substituído por compressão ZIP. SUD (Legado) Formato ZIP inicial assinado com DSA-SHA1 (pré-0.9.9). Sem ID do signatário nem cabeçalho, integridade limitada. Substituído devido a criptografia fraca e falta de imposição de versão. 3. Fluxo de trabalho de atualização 3.1 Verificação do Cabeçalho Os routers obtêm apenas o cabeçalho SU3 para verificar a string de versão antes de baixar os arquivos completos. Isso evita desperdiçar largura de banda com espelhos desatualizados ou versões antigas.\n3.2 Download completo Após verificar o cabeçalho, o router baixa o arquivo .su3 completo de: - Espelhos de eepsite na rede (preferencial) - Espelhos HTTPS na clearnet (alternativa) - BitTorrent (distribuição opcional assistida por pares)\nAs transferências usam clientes HTTP padrão do I2PTunnel, com novas tentativas, tratamento de tempo limite e recurso a espelhos.\n3.3 Verificação de Assinatura Cada arquivo baixado passa por: - Verificação de assinatura: verificação RSA-4096/SHA512 - Correspondência de versões: verificação da versão do cabeçalho vs. da carga útil - Prevenção de downgrade: garante que a atualização seja mais recente do que a versão instalada\nArquivos inválidos ou incompatíveis são descartados imediatamente.\n3.4 Preparação da Instalação Uma vez verificado: 1. Extraia o conteúdo do ZIP para um diretório temporário 2. Remova os arquivos listados em deletelist.txt 3. Substitua as bibliotecas nativas se lib/jbigi.jar estiver incluído 4. Copie os certificados do signatário para ~/.i2p/certificates/ 5. Mova a atualização para i2pupdate.zip para aplicação na próxima reinicialização\nA atualização é instalada automaticamente na próxima inicialização ou quando “Install update now” é acionado manualmente.\n4. Gerenciamento de arquivos deletelist.txt Uma lista em texto simples de arquivos obsoletos para remover antes de descompactar os novos conteúdos.\nRegras: - Um caminho por linha (apenas caminhos relativos) - Linhas que começam com # são ignoradas - .. e caminhos absolutos rejeitados\nBibliotecas Nativas Para evitar binários nativos obsoletos ou incompatíveis: - Se lib/jbigi.jar existir, arquivos .so ou .dll antigos são excluídos - Garante que as bibliotecas específicas da plataforma sejam extraídas novamente\n5. Gerenciamento de Certificados Routers podem receber novos certificados de assinante por meio de atualizações ou revogações do feed de notícias.\nNovos arquivos .crt são copiados para o diretório de certificados. Certificados revogados são excluídos antes de futuras verificações. Suporta rotação de chaves sem exigir intervenção manual do usuário. Todas as atualizações são assinadas offline usando air-gapped signing systems (sistemas de assinatura isolados fisicamente). As chaves privadas nunca são armazenadas nos servidores de compilação.\n6. Diretrizes para Desenvolvedores Topic Details Signing Use RSA-4096 (SHA-512) via apps/jetty/news SU3 tooling. Mirror Policy I2P eepsite preferred, clearnet HTTPS fallback, torrent optional. Testing Validate updates from prior releases, across all OS platforms. Version Enforcement minVersion prevents incompatible upgrades. Certificate Rotation Distribute new certs in updates and revocation lists. Versões futuras explorarão a integração de assinaturas pós-quânticas (consulte a Proposal 169) e compilações reprodutíveis. 7. Visão geral de segurança Threat Mitigation Tampering Cryptographic signature (RSA-4096/SHA512) Key Compromise Feed-based certificate revocation Downgrade Attack Version comparison enforcement Mirror Hijack Signature verification, multiple mirrors DoS Fallback to alternate mirrors/torrents MITM HTTPS transport + signature-level integrity --- 8. Versionamento Router: 2.10.0 (API 0.9.67) Versionamento semântico com Major.Minor.Patch. A imposição de versão mínima evita atualizações inseguras. Java com suporte: Java 8–17. No futuro, as versões 2.11.0 e superiores exigirão Java 17+. ","description":"Mecanismo seguro de atualização assinada e estrutura de feed para I2P routers","id":"aea843f73d809c9546b3d675324af161","section":"docs","title":"Especificação de Atualização de Software","url":"/pt/docs/specs/updates/"},{"categories":null,"content":"Visão geral Objetivo ECIES-X25519-AEAD-Ratchet é o protocolo moderno de criptografia de ponta a ponta do I2P, substituindo o sistema legado ElGamal/AES+SessionTags. Ele fornece sigilo de encaminhamento (forward secrecy), criptografia autenticada e melhorias significativas em desempenho e segurança.\nPrincipais melhorias em relação a ElGamal/AES+SessionTags (etiquetas de sessão) Chaves menores: chaves de 32 bytes vs chaves públicas ElGamal de 256 bytes (redução de 87,5%) Sigilo Direto: alcançado por meio de DH ratcheting (mecanismo de \u0026ldquo;ratchet\u0026rdquo; Diffie-Hellman) (não disponível no protocolo legado) Criptografia moderna: X25519 DH, ChaCha20-Poly1305 AEAD, SHA-256 Criptografia autenticada: autenticação integrada via construção AEAD Protocolo bidirecional: sessões de entrada/saída emparelhadas vs protocolo legado unidirecional Tags eficientes: tags de sessão de 8 bytes vs tags de 32 bytes (redução de 75%) Ofuscação de tráfego: a codificação Elligator2 torna os handshakes indistinguíveis de dados aleatórios Status de Implantação Lançamento inicial: Versão 0.9.46 (25 de maio de 2020) Implantação na rede: Concluída em 2020 Status atual: Maduro, amplamente implantado (5+ anos em produção) Suporte do router: Requer a versão 0.9.46 ou superior Requisitos de floodfill (nós especializados que armazenam e propagam dados no netDb): Adoção próxima de 100% para consultas criptografadas Estado da Implementação Totalmente implementado: - Mensagens New Session (NS) com associação - Mensagens New Session Reply (NSR) - Mensagens Existing Session (ES) - Mecanismo DH ratchet (mecanismo de catraca Diffie-Hellman) - Ratchets de Session tag e de chave simétrica - Blocos DateTime, NextKey, ACK, ACK Request, Garlic Clove (elemento de garlic encryption), e Padding\nNão implementado (até a versão 0.9.50): - MessageNumbers block (bloco MessageNumbers) (tipo 6) - Options block (bloco Options) (tipo 5) - Termination block (bloco Termination) (tipo 4) - respostas automáticas na camada de protocolo - modo de chave estática zero - sessões multicast\nObservação: O status de implementação para as versões 1.5.0 até 2.10.0 (2021-2025) requer verificação, pois alguns recursos podem ter sido adicionados.\nFundamentos do Protocolo Noise Protocol Framework (estrutura de protocolos criptográficos Noise) ECIES-X25519-AEAD-Ratchet é baseado no Noise Protocol Framework (Revisão 34, 2018-07-11), especificamente no padrão de handshake IK (Interativo, chave estática remota conhecida) com extensões específicas do I2P.\nIdentificador do Protocolo Noise Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256 Componentes do identificador: - Noise - Framework base - IK - Padrão de handshake (aperto de mão) interativo com chave estática remota conhecida - elg2 - Codificação Elligator2 para chaves efêmeras (extensão do I2P) - +hs2 - MixHash chamado antes da segunda mensagem para incorporar a tag (extensão do I2P) - 25519 - Função Diffie-Hellman X25519 - ChaChaPoly - Cifra AEAD ChaCha20-Poly1305 - SHA256 - Função de hash SHA-256\nPadrão de Handshake do Noise Notação do padrão IK:\n\u0026lt;- s (Bob\u0026#39;s static key known to Alice) ... -\u0026gt; e, es, s, ss (Alice sends ephemeral, DH es, static key, DH ss) \u0026lt;- e, ee, se (Bob sends ephemeral, DH ee, DH se) Significados dos tokens: - e - Transmissão de chave efêmera - s - Transmissão de chave estática - es - DH entre a chave efêmera de Alice e a chave estática de Bob - ss - DH entre a chave estática de Alice e a chave estática de Bob - ee - DH entre a chave efêmera de Alice e a chave efêmera de Bob - se - DH entre a chave estática de Bob e a chave efêmera de Alice\nPropriedades de Segurança do Noise Usando a terminologia do Noise, o padrão IK fornece:\nMessage Authentication Level Confidentiality Level Message\u0026nbsp;1 (NS) Level\u0026nbsp;1 (sender auth, KCI vulnerable) Level\u0026nbsp;2 (weak forward secrecy) Message\u0026nbsp;2 (NSR) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;4 (weak forward secrecy) Transport (ES) Level\u0026nbsp;2 (mutual auth) Level\u0026nbsp;5 (strong forward secrecy) **Níveis de autenticação:** - **Nível 1**: A carga útil é autenticada como pertencente ao proprietário da chave estática do remetente, mas é vulnerável a Key Compromise Impersonation (KCI, impersonação por comprometimento de chave) - **Nível 2**: Resistente a ataques de KCI após NSR Níveis de confidencialidade: - Nível 2: Forward secrecy (sigilo futuro) se a chave estática do remetente for posteriormente comprometida - Nível 4: Forward secrecy se a chave efêmera do remetente for posteriormente comprometida - Nível 5: Forward secrecy total após a exclusão de ambas as chaves efêmeras\nDiferenças entre IK e XK O padrão IK difere do padrão XK usado no NTCP2 e no SSU2:\nQuatro operações DH: IK usa 4 operações DH (es, ss, ee, se) vs 3 para XK Autenticação imediata: Alice é autenticada na primeira mensagem (Nível de autenticação 1) Sigilo futuro mais rápido: Sigilo futuro completo (Nível 5) atingido após a segunda mensagem (1-RTT) Compromisso: A carga útil da primeira mensagem não possui sigilo futuro (vs XK onde todas as cargas úteis possuem sigilo futuro) Resumo: IK permite a entrega em 1-RTT da resposta de Bob com forward secrecy (sigilo futuro) total, ao custo de a requisição inicial não possuir forward secrecy.\nConceitos do Signal Double Ratchet (algoritmo de catraca dupla) ECIES (Esquema Integrado de Criptografia com Curvas Elípticas) incorpora conceitos do Signal Double Ratchet Algorithm :\nDH Ratchet: (ratchet: mecanismo de atualização irreversível) Fornece sigilo futuro ao trocar periodicamente novas chaves DH Symmetric Key Ratchet: Deriva novas chaves de sessão para cada mensagem Session Tag Ratchet: Gera tags de sessão de uso único de forma determinística Principais diferenças em relação ao Signal: - Ratcheting (mecanismo de avanço do estado criptográfico) menos frequente: O I2P aplica o ratcheting apenas quando necessário (perto da exaustão de tags (identificadores de sessão) ou por política) - Tags de sessão em vez de criptografia do cabeçalho: Usa tags determinísticas em vez de cabeçalhos criptografados - ACKs (confirmações de recebimento) explícitos: Usa blocos de ACK em banda em vez de depender apenas do tráfego de retorno - Ratcheting de tag e de chave separados: Mais eficiente para o receptor (pode adiar o cálculo da chave)\nExtensões do I2P para o Noise (estrutura de protocolos criptográficos) Codificação Elligator2: Chaves efêmeras codificadas para serem indistinguíveis de dados aleatórios Tag anteposta ao NSR: Tag de sessão adicionada antes da mensagem NSR para correlação Formato de payload definido: Estrutura de payload baseada em blocos para todos os tipos de mensagem Encapsulamento I2NP: Todas as mensagens encapsuladas em cabeçalhos I2NP Garlic Message (tipo de mensagem \u0026ldquo;garlic\u0026rdquo; do I2P) Fase de dados separada: Mensagens de transporte (ES) divergem da fase de dados padrão do Noise Primitivas Criptográficas Diffie-Hellman X25519 Especificação: RFC 7748 Propriedades da chave: - Tamanho da chave privada: 32 bytes - Tamanho da chave pública: 32 bytes - Tamanho do segredo compartilhado: 32 bytes - Endianidade: Little-endian - Curva: Curve25519\nOperações:\nX25519 GENERATE_PRIVATE() Gera uma chave privada aleatória de 32 bytes:\nprivkey = CSRNG(32) X25519 DERIVE_PUBLIC(privkey) Deriva a chave pública correspondente:\npubkey = curve25519_scalarmult_base(privkey) Retorna uma chave pública de 32 bytes em little-endian (ordem de bytes do menos significativo para o mais significativo).\nX25519 DH(privkey, pubkey) Realiza o acordo de chaves Diffie-Hellman:\nsharedSecret = curve25519_scalarmult(privkey, pubkey) Retorna um segredo compartilhado de 32 bytes.\nNota de segurança: Implementadores devem validar que o segredo compartilhado não seja composto apenas por zeros (chave fraca). Rejeite e aborte o handshake (negociação inicial) se isso ocorrer.\nChaCha20-Poly1305 AEAD (Criptografia Autenticada com Dados Associados) Especificação: RFC 7539 seção 2.8\nParâmetros: - Tamanho da Chave: 32 bytes (256 bits) - Tamanho do Nonce: 12 bytes (96 bits) - Tamanho do MAC: 16 bytes (128 bits) - Tamanho do Bloco: 64 bytes (interno)\nFormato de Nonce (número usado uma vez):\nByte 0-3: 0x00 0x00 0x00 0x00 (always zero) Byte 4-11: Little-endian counter (message number N) Construção de AEAD (Cifra Autenticada com Dados Associados):\nO AEAD (criptografia autenticada com dados associados) combina a cifra de fluxo ChaCha20 com o MAC Poly1305:\nGerar o fluxo de chave ChaCha20 a partir da chave e do nonce (número usado uma vez) Cifrar o texto plano via XOR com o fluxo de chave Calcular o MAC Poly1305 sobre (dados associados || texto cifrado) Anexar o MAC de 16 bytes ao texto cifrado ChaCha20-Poly1305 ENCRYPT(k, n, plaintext, ad) Criptografa o texto em claro com autenticação:\n# Inputs k = 32-byte cipher key n = 12-byte nonce (first 4 bytes zero, last 8 bytes = message number) plaintext = data to encrypt (0 to 65519 bytes) ad = associated data (optional, used in MAC calculation) # Output ciphertext = chacha20_encrypt(k, n, plaintext) mac = poly1305(ad || ciphertext, poly1305_key_gen(k, n)) return ciphertext || mac # Total length = len(plaintext) + 16 Propriedades: - O texto cifrado tem o mesmo tamanho que o texto em claro (cifra de fluxo) - A saída é plaintext_length + 16 bytes (inclui MAC) - Toda a saída é indistinguível de dados aleatórios se a chave for secreta - O MAC autentica tanto os dados associados quanto o texto cifrado\nChaCha20-Poly1305 DECRYPT(k, n, ciphertext, ad) Descriptografa e verifica a autenticação:\n# Split ciphertext and MAC ct_without_mac = ciphertext[0:-16] received_mac = ciphertext[-16:] # Verify MAC expected_mac = poly1305(ad || ct_without_mac, poly1305_key_gen(k, n)) if not constant_time_compare(received_mac, expected_mac): raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) # Decrypt plaintext = chacha20_decrypt(k, n, ct_without_mac) return plaintext Requisitos Críticos de Segurança: - Nonces (números de uso único) DEVEM ser únicos para cada mensagem com a mesma chave - Nonces NÃO DEVEM ser reutilizados (falha catastrófica se reutilizados) - A verificação do MAC DEVE usar comparação em tempo constante para impedir ataques de temporização - Falha na verificação do MAC DEVE resultar na rejeição completa da mensagem (sem descriptografia parcial)\nFunção de hash SHA-256 Especificação: NIST FIPS 180-4\nPropriedades: - Tamanho de saída: 32 bytes (256 bits) - Tamanho do bloco: 64 bytes (512 bits) - Nível de segurança: 128 bits (resistência a colisões)\nOperações:\nSHA-256 H(p, d) Hash SHA-256 com string de personalização:\nH(p, d) := SHA256(p || d) Onde || denota concatenação, p é a string de personalização e d representa os dados.\nSHA-256 MixHash(d) Atualiza o hash incremental com novos dados:\nh = SHA256(h || d) Usado ao longo do handshake do Noise para manter o hash da transcrição.\nDerivação de Chaves com HKDF (função de derivação de chaves baseada em hash) Especificação: RFC 5869 Descrição: Função de derivação de chaves baseada em HMAC usando SHA-256\nParâmetros: - Função de hash: HMAC-SHA256 - Comprimento do salt: Até 32 bytes (tamanho da saída do SHA-256) - Comprimento da saída: Variável (até 255 * 32 bytes)\nFunção HKDF (função de derivação de chaves baseada em HMAC):\ndef HKDF(salt, ikm, info, length): \u0026#34;\u0026#34;\u0026#34; Args: salt: Salt value (32 bytes max for SHA-256) ikm: Input key material (any length) info: Context-specific info string length: Desired output length in bytes Returns: output: Derived key material (length bytes) \u0026#34;\u0026#34;\u0026#34; # Extract phase prk = HMAC-SHA256(salt, ikm) # Expand phase n = ceil(length / 32) t = b\u0026#39;\u0026#39; okm = b\u0026#39;\u0026#39; for i in range(1, n + 1): t = HMAC-SHA256(prk, t || info || byte(i)) okm = okm || t return okm[0:length] Padrões comuns de uso:\n# Generate two keys (64 bytes total) keydata = HKDF(chainKey, sharedSecret, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey = keydata[32:63] # Generate session tag (8 bytes) tagdata = HKDF(chainKey, CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) nextChainKey = tagdata[0:31] sessionTag = tagdata[32:39] # Generate symmetric key (32 bytes) keydata = HKDF(chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) nextChainKey = keydata[0:31] sessionKey = keydata[32:63] Strings de informação usadas no ECIES: - \u0026quot;KDFDHRatchetStep\u0026quot; - derivação de chave do ratchet (mecanismo de avanço criptográfico) DH - \u0026quot;TagAndKeyGenKeys\u0026quot; - inicializar as chaves de tag e da cadeia de chaves - \u0026quot;STInitialization\u0026quot; - inicialização do ratchet de tags de sessão - \u0026quot;SessionTagKeyGen\u0026quot; - geração de tags de sessão - \u0026quot;SymmetricRatchet\u0026quot; - geração de chave simétrica - \u0026quot;XDHRatchetTagSet\u0026quot; - chave do conjunto de tags do ratchet DH - \u0026quot;SessionReplyTags\u0026quot; - geração do conjunto de tags NSR - \u0026quot;AttachPayloadKDF\u0026quot; - derivação da chave da carga útil do NSR\nCodificação Elligator2 (método de mapeamento de curvas elípticas que torna pontos indistinguíveis de dados aleatórios) Objetivo: Codificar chaves públicas X25519 de modo que sejam indistinguíveis de cadeias aleatórias uniformes de 32 bytes.\nEspecificação: Artigo Elligator2 Problema: As chaves públicas X25519 padrão têm uma estrutura reconhecível. Um observador pode identificar mensagens de handshake (negociação inicial) ao detectar essas chaves, mesmo que o conteúdo esteja criptografado.\nSolução: Elligator2 fornece um mapeamento bijetivo entre ~50% das chaves públicas X25519 válidas e sequências de 254 bits com aparência aleatória.\nGeração de chaves com Elligator2:\nElligator2 GENERATE_PRIVATE_ELG2() Gera uma chave privada que corresponde a uma chave pública codificável pelo Elligator2:\nwhile True: privkey = CSRNG(32) pubkey = DERIVE_PUBLIC(privkey) # Test if public key is Elligator2-encodable try: encoded = ENCODE_ELG2(pubkey) # Success - this key pair is suitable return privkey except NotEncodableError: # Try again with new random key continue Importante: Aproximadamente 50% das chaves privadas geradas aleatoriamente produzirão chaves públicas não codificáveis. Essas devem ser descartadas e deve-se tentar a regeneração.\nOtimização de Desempenho: Gere chaves antecipadamente em uma thread de segundo plano para manter um pool de pares de chaves adequados, evitando atrasos durante o handshake (negociação inicial).\nElligator2 ENCODE_ELG2(pubkey) Codifica uma chave pública em 32 bytes com aparência aleatória:\ndef ENCODE_ELG2(pubkey): \u0026#34;\u0026#34;\u0026#34; Encodes X25519 public key using Elligator2. Args: pubkey: 32-byte X25519 public key (little-endian) Returns: encoded: 32-byte encoded key indistinguishable from random Raises: NotEncodableError: If pubkey cannot be encoded \u0026#34;\u0026#34;\u0026#34; # Perform Elligator2 representative calculation # Returns 254-bit value (31.75 bytes) encodedKey = elligator2_encode(pubkey) # Add 2 random bits to MSB to make full 32 bytes randomByte = CSRNG(1) encodedKey[31] |= (randomByte \u0026amp; 0xc0) return encodedKey Detalhes de codificação: - Elligator2 (método para mapear pontos de curvas elípticas para bytes indistinguíveis de aleatórios) produz 254 bits (não os 256 completos) - Os 2 bits superiores do byte 31 são preenchimento aleatório - O resultado é distribuído uniformemente no espaço de 32 bytes - Codifica com sucesso aproximadamente 50% das chaves públicas X25519 (algoritmo de acordo de chaves baseado em curva elíptica) válidas\nElligator2 DECODE_ELG2(encodedKey) Decodifica de volta para a chave pública original:\ndef DECODE_ELG2(encodedKey): \u0026#34;\u0026#34;\u0026#34; Decodes Elligator2-encoded key back to X25519 public key. Args: encodedKey: 32-byte encoded key Returns: pubkey: 32-byte X25519 public key (little-endian) \u0026#34;\u0026#34;\u0026#34; # Mask out 2 random padding bits from MSB encodedKey[31] \u0026amp;= 0x3f # Perform Elligator2 representative inversion pubkey = elligator2_decode(encodedKey) return pubkey Propriedades de Segurança: - Chaves codificadas são indistinguíveis computacionalmente de bytes aleatórios - Nenhum teste estatístico pode detectar de forma confiável chaves codificadas com Elligator2 - A decodificação é determinística (a mesma chave codificada sempre produz a mesma chave pública) - A codificação é bijetiva para ~50% das chaves no subconjunto codificável\nNotas de implementação: - Armazene as chaves codificadas na fase de geração para evitar recodificação durante o handshake - Chaves inadequadas da geração pelo Elligator2 (método que torna chaves públicas indistinguíveis de dados aleatórios) podem ser usadas para NTCP2 (que não requer Elligator2) - A geração de chaves em segundo plano é essencial para o desempenho - O tempo médio de geração dobra devido à taxa de rejeição de 50%\nFormatos de Mensagem Visão geral ECIES define três tipos de mensagem:\nNova Sessão (NS): Mensagem inicial de handshake (negociação inicial) de Alice para Bob Resposta de Nova Sessão (NSR): Resposta de handshake de Bob para Alice Sessão Existente (ES): Todas as mensagens subsequentes em ambas as direções Todas as mensagens são encapsuladas no formato I2NP Garlic Message (formato de mensagem \u0026ldquo;garlic\u0026rdquo; do I2NP) com camadas adicionais de criptografia.\nContêiner de Mensagem Garlic do I2NP Todas as mensagens ECIES são encapsuladas em cabeçalhos padrão de I2NP Garlic Message (mensagem \u0026ldquo;garlic\u0026rdquo;):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ | length | | +----+----+----+----+ + | encrypted data | ~ ~ Campos: - type: 0x26 (Garlic Message, tipo de mensagem do I2NP) - msg_id: ID de mensagem do I2NP de 4 bytes - expiration: carimbo de tempo Unix de 8 bytes (milissegundos) - size: tamanho da carga útil de 2 bytes - chks: soma de verificação de 1 byte - length: comprimento dos dados criptografados de 4 bytes - encrypted data: carga útil criptografada com ECIES\nFinalidade: Fornece identificação e roteamento de mensagens na camada I2NP. O campo length permite que os receptores saibam o tamanho total da carga útil criptografada.\nMensagem de Nova Sessão (NS) A mensagem de Nova Sessão inicia uma nova sessão de Alice para Bob. Ela tem três variantes:\nCom Vinculação (1b): Inclui a chave estática de Alice para comunicação bidirecional Sem Vinculação (1c): Omite a chave estática para comunicação unidirecional De Uso Único (1d): Modo de mensagem única sem estabelecimento de sessão Mensagem NS com Vinculação (Tipo 1b) Caso de uso: streaming, datagramas com suporte a resposta, qualquer protocolo que exija respostas\nComprimento total: 96 + payload_length bytes\nFormato:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Static Key Section + | ChaCha20 encrypted data | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Static Key Section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Detalhes do Campo:\nChave Pública Efêmera (32 bytes, texto claro): - Chave pública X25519 de uso único de Alice - Codificada com Elligator2 (indistinguível de dados aleatórios) - Gerada novamente para cada mensagem NS (nunca reutilizada) - Formato little-endian\nSeção de Chave Estática (32 bytes criptografados, 48 bytes com MAC): - Contém a chave pública estática X25519 de Alice (32 bytes) - Criptografada com ChaCha20 - Autenticada com MAC Poly1305 (16 bytes) - Usada por Bob para vincular a sessão ao destino de Alice\nSeção de carga útil (criptografada de comprimento variável, +16 bytes MAC): - Contém garlic cloves (submensagens do esquema garlic) e outros blocos - Deve incluir o bloco DateTime como primeiro bloco - Geralmente inclui blocos Garlic Clove com dados da aplicação - Pode incluir o bloco NextKey para ratchet imediato (mecanismo de avanço criptográfico) - Criptografada com ChaCha20 - Autenticada com MAC Poly1305 (16 bytes)\nPropriedades de Segurança: - Chave efêmera fornece componente de sigilo direto - Chave estática autentica Alice (vinculação ao destino) - Ambas as seções têm MACs separados para separação de domínios - O handshake total realiza 2 operações de DH (es, ss)\nMensagem NS sem Vinculação (Tipo 1c) Caso de uso: Datagramas brutos em que não se espera nem se deseja resposta\nComprimento total: 96 + payload_length bytes\nFormato:\n+----+----+----+----+----+----+----+----+ | | + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | | + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | All zeros | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for above section + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Diferença principal: A seção Flags contém 32 bytes de zero em vez de uma chave estática.\nDetecção: Bob determina o tipo de mensagem descriptografando a seção de 32 bytes e verificando se todos os bytes estão em zero: - Todos em zero → Sessão não vinculada (tipo 1c) - Diferente de zero → Sessão vinculada com chave estática (tipo 1b)\nPropriedades: - Sem chave estática, não há associação ao destino de Alice - Bob não pode enviar respostas (nenhum destino conhecido) - Executa apenas 1 operação de DH (es) - Segue o padrão \u0026ldquo;N\u0026rdquo; do Noise em vez de \u0026ldquo;IK\u0026rdquo; - Mais eficiente quando respostas nunca são necessárias\nSeção de Flags (reservado para uso futuro): Atualmente, todos são zeros. Pode ser usada para negociação de funcionalidades em versões futuras.\nMensagem NS de uso único (Tipo 1d) Caso de uso: Mensagem anônima única sem sessão ou resposta esperada\nComprimento total: 96 + payload_length bytes\nFormato: Idêntico a NS sem vinculação (tipo 1c)\nDistinção: - O Tipo 1c pode enviar várias mensagens na mesma sessão (ES messages (mensagens ES) subsequentes) - O Tipo 1d envia exatamente uma mensagem sem estabelecimento de sessão - Na prática, as implementações podem tratar ambos de forma idêntica inicialmente\nPropriedades: - Anonimato máximo (sem chave estática, sem sessão) - Nenhuma das partes mantém estado de sessão - Segue o padrão \u0026ldquo;N\u0026rdquo; do Noise - Uma única operação DH\nMensagem de Resposta de Nova Sessão (NSR) Bob envia uma ou mais mensagens NSR em resposta à mensagem NS de Alice. O NSR conclui o aperto de mão Noise IK e estabelece uma sessão bidirecional.\nComprimento total: 72 + payload_length bytes\nFormato:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Ephemeral Public Key + | | + 32 bytes + | Encoded with Elligator2 | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Key Section (empty) + | 16 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) for Payload Section + | 16 bytes | +----+----+----+----+----+----+----+----+ Detalhes do campo:\nTag de Sessão (8 bytes, em claro): - Gerado a partir do conjunto de tags NSR (consulte as seções de KDF) - Correlaciona esta resposta com a mensagem NS de Alice - Permite que Alice identifique a qual NS este NSR responde - Uso único (nunca reutilizado)\nChave Pública Efêmera (32 bytes, em claro): - Chave pública X25519 de uso único de Bob - Codificada com Elligator2 (técnica de codificação para curvas elípticas) - Gerada novamente para cada mensagem NSR - Deve ser diferente para cada NSR enviada\nKey Section MAC (MAC da seção de chave) (16 bytes): - Autentica dados vazios (ZEROLEN) - Parte do protocolo Noise IK (padrão se) - Usa o hash da transcrição como dados associados - Crítico para vincular NSR a NS\nSeção de Carga Útil (comprimento variável): - Contém garlic cloves (submensagens \u0026ldquo;garlic\u0026rdquo;) e blocos - Geralmente inclui respostas na camada de aplicação - Pode estar vazia (ACK-only NSR) - Tamanho máximo: 65519 bytes (65535 - MAC de 16 bytes)\nMúltiplas mensagens NSR:\nBob pode enviar várias mensagens NSR em resposta a uma NS: - Cada NSR tem uma chave efêmera exclusiva - Cada NSR tem uma tag de sessão exclusiva - Alice usa a primeira NSR recebida para concluir o handshake (negociação inicial) - As outras NSR servem como redundância (em caso de perda de pacotes)\nTemporização Crítica: - Alice deve receber um NSR antes de enviar mensagens ES - Bob deve receber uma mensagem ES antes de enviar mensagens ES - NSR estabelece chaves de sessão bidirecionais por meio da operação split()\nPropriedades de Segurança: - Conclui o Noise IK handshake (handshake do protocolo Noise no padrão IK) - Realiza 2 operações DH adicionais (ee, se) - Total de 4 operações DH em NS+NSR - Alcança autenticação mútua (Nível 2) - Fornece sigilo futuro fraco (Nível 4) para a carga útil do NSR\nMensagem de Sessão Existente (ES) Todas as mensagens após o handshake NS/NSR usam o formato de Sessão Existente. As mensagens ES são usadas bidirecionalmente por Alice e Bob.\nComprimento total: 8 + payload_length + 16 bytes (mínimo 24 bytes)\nFormato:\n+----+----+----+----+----+----+----+----+ | Session Tag 8 bytes | +----+----+----+----+----+----+----+----+ | | + Payload Section + | ChaCha20 encrypted data | ~ Variable length ~ | | + + | | +----+----+----+----+----+----+----+----+ | Poly1305 Message Authentication Code | + (MAC) + | 16 bytes | +----+----+----+----+----+----+----+----+ Detalhes do campo:\nTag de sessão (8 bytes, em claro): - Gerada a partir do conjunto de tags de saída atual - Identifica a sessão e o número da mensagem - O receptor consulta a tag para encontrar a chave de sessão e o nonce (valor de uso único) - Uso único (cada tag é usada exatamente uma vez) - Formato: primeiros 8 bytes da saída do HKDF\nSeção de carga útil (comprimento variável): - Contém garlic cloves (submensagens do I2P) e blocos - Sem blocos obrigatórios (pode estar vazio) - Blocos comuns: Garlic Clove, NextKey, ACK, ACK Request, Padding - Tamanho máximo: 65519 bytes (65535 - MAC de 16 bytes)\nMAC (16 bytes): - Tag de autenticação Poly1305 - Calculada sobre toda a carga útil - Dados associados: a tag de sessão de 8 bytes - Deve ser verificada corretamente ou a mensagem é rejeitada\nProcesso de Consulta de Tags:\nO receptor extrai a tag de 8 bytes Procura a tag em todos os conjuntos de tags de entrada atuais Recupera a chave de sessão associada e o número da mensagem N Constrói o nonce (número único): [0x00, 0x00, 0x00, 0x00, N (8 bytes little-endian)] Descriptografa a carga útil usando AEAD com a tag como dados associados Remove a tag do conjunto de tags (uso único) Processa os blocos descriptografados Session Tag (etiqueta de sessão) não encontrada:\nSe a tag não for encontrada em nenhum tagset (conjunto de tags): - Pode ser uma mensagem NS (New Session, nova sessão) → tentar a descriptografia de NS - Pode ser uma mensagem NSR (New Session Reply, resposta de nova sessão) → tentar a descriptografia de NSR - Pode ser ES fora de ordem (ElGamal Session, sessão ElGamal) → aguardar brevemente a atualização do tagset - Pode ser um ataque de repetição → rejeitar - Podem ser dados corrompidos → rejeitar\nCarga útil vazia:\nMensagens ES podem ter cargas úteis vazias (0 bytes): - Serve como ACK (confirmação) explícito quando um ACK Request (solicitação de confirmação) foi recebido - Fornece uma resposta na camada de protocolo sem dados da aplicação - Ainda consome uma session tag (rótulo de sessão) - Útil quando a camada superior não tem dados imediatos para enviar\nPropriedades de Segurança: - Sigilo direto completo (Nível 5) após o recebimento do NSR - Criptografia autenticada com dados associados (AEAD) - A tag atua como dados associados adicionais - Máximo de 65535 mensagens por tagset (conjunto de tags) antes de ser necessário o ratchet (mecanismo de avanço criptográfico)\nFunções de Derivação de Chaves Esta seção documenta todas as operações de KDF (função de derivação de chaves) usadas no ECIES (Esquema de Criptografia de Curva Elíptica Integrado), mostrando as derivações criptográficas completas.\nNotação e Constantes Constantes: - ZEROLEN - Array de bytes de comprimento zero (string vazia) - || - Operador de concatenação\nVariáveis: - h - Hash acumulado do transcrito (32 bytes) - chainKey - Chave de encadeamento para HKDF (32 bytes) - k - Chave de cifra simétrica (32 bytes) - n - Nonce (número único aleatório) / número da mensagem\nChaves: - ask / apk - Chave privada/pública estática de Alice - aesk / aepk - Chave privada/pública efêmera de Alice - bsk / bpk - Chave privada/pública estática de Bob - besk / bepk - Chave privada/pública efêmera de Bob\nKDFs da Mensagem NS KDF (função de derivação de chaves) 1: Chave de Cadeia Inicial Executado uma vez na inicialização do protocolo (pode ser pré-calculado):\n# Protocol name (40 bytes, ASCII, no null termination) protocol_name = \u0026#34;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256\u0026#34; # Initialize hash h = SHA256(protocol_name) # Initialize chaining key chainKey = h # MixHash with empty prologue h = SHA256(h) # State: chainKey and h initialized # Can be precalculated for all outbound sessions Resultado: - chainKey = Chave de encadeamento inicial para todas as KDFs (funções de derivação de chaves) subsequentes - h = Hash de transcrição inicial\nKDF (função de derivação de chaves) 2: Mistura da chave estática de Bob Bob executa isso uma vez (pode ser pré-calculado para todas as sessões de entrada):\n# Bob\u0026#39;s static keys (published in LeaseSet) bsk = GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk) # Mix Bob\u0026#39;s public key into hash h = SHA256(h || bpk) # State: h updated with Bob\u0026#39;s identity # Can be precalculated by Bob for all inbound sessions KDF 3: Geração da Chave Efêmera de Alice Alice gera chaves novas para cada mensagem NS:\n# Generate ephemeral key pair suitable for Elligator2 aesk = GENERATE_PRIVATE_ELG2() aepk = DERIVE_PUBLIC(aesk) # Mix ephemeral public key into hash h = SHA256(h || aepk) # Elligator2 encode for transmission elg2_aepk = ENCODE_ELG2(aepk) # State: h updated with Alice\u0026#39;s ephemeral key # Send elg2_aepk as first 32 bytes of NS message KDF 4: Seção de Chave Estática NS (es DH) Deriva chaves para criptografar a chave estática de Alice:\n# Perform first DH (ephemeral-static) sharedSecret = DH(aesk, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, aepk) # Bob computes # Derive cipher key from shared secret keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption parameters nonce = 0 associated_data = h # Current hash transcript # Encrypt static key section if binding_requested: plaintext = apk # Alice\u0026#39;s static public key (32 bytes) else: plaintext = bytes(32) # All zeros for unbound ciphertext = ENCRYPT(k, nonce, plaintext, associated_data) # ciphertext = 32 bytes encrypted + 16 bytes MAC = 48 bytes # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Static key section encrypted, h updated # Send ciphertext (48 bytes) as next part of NS message KDF 5: Seção de carga útil NS (ss DH (Diffie-Hellman estático-estático), apenas vinculado) Para sessões vinculadas, execute um segundo DH (Diffie-Hellman, protocolo de troca de chaves) para a criptografia da carga útil:\nif binding_requested: # Alice\u0026#39;s static keys ask = GENERATE_PRIVATE() # Alice\u0026#39;s long-term key apk = DERIVE_PUBLIC(ask) # Perform second DH (static-static) sharedSecret = DH(ask, bpk) # Alice computes # Equivalent: sharedSecret = DH(bsk, apk) # Bob computes # Derive cipher key keydata = HKDF(chainKey, sharedSecret, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] nonce = 0 associated_data = h else: # Unbound: reuse keys from static key section # chainKey and k unchanged nonce = 1 # Increment nonce (reusing same key) associated_data = h # Encrypt payload payload = build_payload() # DateTime + Garlic Cloves + etc. ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Payload encrypted, h contains complete NS transcript # Save chainKey and h for NSR processing # Send ciphertext as final part of NS message Notas importantes:\nVinculado vs Não vinculado:\nVinculado realiza 2 operações DH (es + ss) Não vinculado realiza 1 operação DH (apenas es) Não vinculado incrementa o nonce (número aleatório de uso único) em vez de derivar uma nova chave Segurança contra reutilização de chaves:\nNonces (nonce: número usado uma vez) diferentes (0 vs 1) evitam a reutilização de chave/nonce Dados associados diferentes (h é diferente) fornecem separação de domínios Transcrição de Hash:\nh agora contém: protocol_name, prólogo vazio, bpk, aepk, static_key_ciphertext, payload_ciphertext Esta transcrição vincula todas as partes da mensagem NS entre si KDF (função de derivação de chaves) do conjunto de tags de resposta NSR Bob gera tags para mensagens NSR (um tipo de mensagem):\n# Chain key from NS payload section # chainKey = final chainKey from NS KDF # Generate tagset key tagsetKey = HKDF(chainKey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) # Initialize NSR tagset (see DH_INITIALIZE below) tagset_nsr = DH_INITIALIZE(chainKey, tagsetKey) # Get tag for this NSR tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes # State: tag available for NSR message # Send tag as first 8 bytes of NSR KDFs (funções de derivação de chaves) de mensagens NSR KDF 6: Geração de Chaves Efêmeras do NSR Bob gera uma nova chave efêmera para cada NSR:\n# Mix tag into hash (I2P extension to Noise) h = SHA256(h || tag) # Generate ephemeral key pair besk = GENERATE_PRIVATE_ELG2() bepk = DERIVE_PUBLIC(besk) # Mix ephemeral public key into hash h = SHA256(h || bepk) # Elligator2 encode for transmission elg2_bepk = ENCODE_ELG2(bepk) # State: h updated with tag and Bob\u0026#39;s ephemeral key # Send elg2_bepk as bytes 9-40 of NSR message KDF 7: Seção de Chaves NSR (ee e se DH) Deriva chaves para a seção de chaves NSR:\n# Perform third DH (ephemeral-ephemeral) sharedSecret_ee = DH(aesk, bepk) # Alice computes # Equivalent: sharedSecret_ee = DH(besk, aepk) # Bob computes # Mix ee into chain keydata = HKDF(chainKey, sharedSecret_ee, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # Perform fourth DH (static-ephemeral) sharedSecret_se = DH(ask, bepk) # Alice computes # Equivalent: sharedSecret_se = DH(besk, apk) # Bob computes # Derive cipher key from se keydata = HKDF(chainKey, sharedSecret_se, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k = keydata[32:63] # AEAD encryption of empty data (key section has no payload) nonce = 0 associated_data = h ciphertext = ENCRYPT(k, nonce, ZEROLEN, associated_data) # ciphertext = 16 bytes (MAC only, no plaintext) # Mix ciphertext into hash h = SHA256(h || ciphertext) # State: Key section encrypted, chainKey contains all 4 DH results # Send ciphertext (16 bytes MAC) as bytes 41-56 of NSR Crítico: Isto conclui o handshake IK do Noise. chainKey agora contém contribuições de todas as quatro operações DH (es, ss, ee, se).\nKDF 8: Seção de Carga Útil do NSR Deriva chaves para a criptografia da carga útil do NSR:\n# Split chainKey into bidirectional keys keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob key k_ba = keydata[32:63] # Bob → Alice key # Initialize ES tagsets for both directions tagset_ab = DH_INITIALIZE(chainKey, k_ab) # Alice → Bob tagset_ba = DH_INITIALIZE(chainKey, k_ba) # Bob → Alice # Derive NSR payload key (Bob → Alice) k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) # Encrypt NSR payload nonce = 0 associated_data = h # Binds payload to entire NSR payload = build_payload() # Usually application reply ciphertext = ENCRYPT(k_nsr, nonce, payload, associated_data) # State: Bidirectional ES sessions established # tagset_ab and tagset_ba ready for ES messages # Send ciphertext as bytes 57+ of NSR message Notas importantes:\nOperação de separação:\nCria chaves independentes para cada direção Evita a reutilização de chaves entre Alice→Bob e Bob→Alice Vinculação de Carga Útil NSR:\nUsa h como dados associados para vincular a carga útil ao handshake Uma KDF (\u0026ldquo;AttachPayloadKDF\u0026rdquo;) separada fornece separação de domínios Prontidão para ES:\nApós o NSR, ambas as partes podem enviar mensagens ES Alice deve receber o NSR antes de enviar ES Bob deve receber ES antes de enviar ES KDFs (funções de derivação de chaves) para Mensagens ES As mensagens ES usam chaves de sessão pré-geradas provenientes de tagsets (conjuntos de tags):\n# Sender gets next tag and key tagsetEntry = outbound_tagset.GET_NEXT_ENTRY() tag = tagsetEntry.SESSION_TAG # 8 bytes k = tagsetEntry.SESSION_KEY # 32 bytes N = tagsetEntry.INDEX # Message number # Construct nonce (12 bytes) nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD encryption associated_data = tag # Tag is associated data payload = build_payload() ciphertext = ENCRYPT(k, nonce, payload, associated_data) # Send: tag || ciphertext (8 + len(ciphertext) bytes) Processo do receptor:\n# Extract tag tag = message[0:8] # Look up tag in inbound tagsets tagsetEntry = inbound_tagset.GET_SESSION_KEY(tag) if tagsetEntry is None: # Not an ES message, try NS/NSR decryption return try_handshake_decryption(message) k = tagsetEntry.SESSION_KEY N = tagsetEntry.INDEX # Construct nonce nonce = [0x00, 0x00, 0x00, 0x00] + little_endian_8_bytes(N) # AEAD decryption associated_data = tag ciphertext = message[8:] try: payload = DECRYPT(k, nonce, ciphertext, associated_data) except AuthenticationError: # MAC verification failed, reject message return reject_message() # Process payload blocks process_payload(payload) # Remove tag from tagset (one-time use) inbound_tagset.remove(tag) Função DH_INITIALIZE Cria um conjunto de tags para uma única direção:\ndef DH_INITIALIZE(rootKey, k): \u0026#34;\u0026#34;\u0026#34; Initializes a tagset with session tag and symmetric key ratchets. Args: rootKey: Chain key from previous DH ratchet (32 bytes) k: Key material from split() or DH ratchet (32 bytes) Returns: tagset: Initialized tagset object \u0026#34;\u0026#34;\u0026#34; # Derive next root key and chain key keydata = HKDF(rootKey, k, \u0026#34;KDFDHRatchetStep\u0026#34;, 64) nextRootKey = keydata[0:31] chainKey_tagset = keydata[32:63] # Derive separate chain keys for tags and keys keydata = HKDF(chainKey_tagset, ZEROLEN, \u0026#34;TagAndKeyGenKeys\u0026#34;, 64) sessTag_ck = keydata[0:31] # Session tag chain key symmKey_ck = keydata[32:63] # Symmetric key chain key # Create tagset object tagset = Tagset() tagset.nextRootKey = nextRootKey tagset.sessTag_chainKey = sessTag_ck tagset.symmKey_chainKey = symmKey_ck tagset.lastIndex = -1 return tagset Contextos de uso:\nNSR Tagset (conjunto de etiquetas): DH_INITIALIZE(chainKey_from_NS, tagsetKey_NSR) ES Tagsets: DH_INITIALIZE(chainKey_from_NSR, k_ab or k_ba) Ratcheted Tagsets: DH_INITIALIZE(nextRootKey_from_previous, tagsetKey_from_DH) Mecanismos de catraca ECIES usa três mecanismos ratchet (mecanismos de avanço criptográfico) sincronizados para fornecer sigilo futuro e gerenciamento eficiente de sessões.\nVisão geral do Ratchet Três tipos de Ratchet (mecanismo de catraca criptográfica):\nDH Ratchet (mecanismo de catraca Diffie-Hellman): Realiza trocas de chaves Diffie-Hellman para gerar novas chaves raiz Session Tag Ratchet (mecanismo de catraca para tags de sessão): Deriva tags de sessão de uso único de forma determinística Symmetric Key Ratchet (mecanismo de catraca para chaves simétricas): Deriva chaves de sessão para a criptografia de mensagens Relação:\nDH Ratchet (periodic) ↓ Creates new tagset ↓ Session Tag Ratchet (per message) ← synchronized → Symmetric Key Ratchet (per message) ↓ ↓ Session Tags (8 bytes each) Session Keys (32 bytes each) Propriedades principais:\nRemetente: Gera tags e chaves sob demanda (sem necessidade de armazenamento) Receptor: Pré-gera tags para a janela look-ahead (requer armazenamento) Sincronização: O índice da tag determina o índice da chave (N_tag = N_key) Sigilo Futuro: Obtido por meio de DH ratchet (mecanismo de avanço de Diffie-Hellman) Eficiência: O receptor pode adiar o cálculo da chave até que a tag seja recebida DH Ratchet (mecanismo de atualização contínua de chaves com Diffie-Hellman) O DH ratchet (mecanismo de catraca Diffie-Hellman) proporciona sigilo futuro ao trocar periodicamente novas chaves efêmeras.\nFrequência do DH Ratchet (mecanismo de catraca Diffie-Hellman) Condições necessárias de Ratchet (mecanismo de atualização progressiva de chaves): - Conjunto de tags aproximando-se da exaustão (a tag 65535 é o máximo) - Políticas específicas da implementação: - Limite de contagem de mensagens (por exemplo, a cada 4096 mensagens) - Limite de tempo (por exemplo, a cada 10 minutos) - Limite de volume de dados (por exemplo, a cada 100 MB)\nPrimeiro Ratchet recomendado (mecanismo de avanço de chaves): Por volta do número de tag 4096 para evitar atingir o limite\nValores máximos: - ID máximo do conjunto de tags: 65535 - ID máximo de chave: 32767 - Máximo de mensagens por conjunto de tags: 65535 - Máximo teórico de dados por sessão: ~6,9 TB (64K conjuntos de tags × 64K mensagens × 1730 bytes em média)\nIDs de Tag e de Chave do DH Ratchet (catraca Diffie–Hellman) Conjunto Inicial de Tags (pós-handshake (negociação inicial)): - ID do conjunto de tags: 0 - Nenhum bloco NextKey (próxima chave) foi enviado ainda - Nenhum ID de chave atribuído\nApós o primeiro Ratchet (mecanismo de catraca de chaves): - ID do conjunto de tags: 1 = (1 + ID da chave da Alice + ID da chave do Bob) = (1 + 0 + 0) - Alice envia NextKey (mensagem de próxima chave) com ID da chave 0 - Bob responde com NextKey com ID da chave 0\nConjuntos de tags subsequentes: - ID do conjunto de tags = 1 + ID da chave do remetente + ID da chave do destinatário - Exemplo: Conjunto de tags 5 = (1 + sender_key_2 + receiver_key_2)\nTabela de progressão do conjunto de tags:\nTag Set ID Sender Key ID Receiver Key ID Notes 0 n/a n/a Initial tag set (post-NSR) 1 0 * 0 * First ratchet (both generate new keys) 2 1 * 0 Sender generates new key 3 1 1 * Receiver generates new key 4 2 * 1 Sender generates new key 5 2 2 * Receiver generates new key ... ... ... Pattern repeats 65534 32767 * 32766 Second-to-last tag set 65535 32767 32767 * Final tag set \\* = Nova chave gerada neste ciclo do ratchet (mecanismo de avanço criptográfico) Regras de ID da chave: - Os IDs são sequenciais a partir de 0 - Os IDs só aumentam quando uma nova chave é gerada - O ID de chave máximo é 32767 (15 bits) - Após o ID de chave 32767, é necessária uma nova sessão\nFluxo de Mensagens do DH Ratchet (mecanismo de avanço criptográfico) Papéis: - Tag Sender (Remetente de tags): Possui o conjunto de tags de saída, envia mensagens - Tag Receiver (Receptor de tags): Possui o conjunto de tags de entrada, recebe mensagens\nPadrão: O remetente de tags inicia o ratchet (mecanismo de atualização de chaves) quando o conjunto de tags está quase esgotado.\nDiagrama de Fluxo de Mensagens:\nTag Sender Tag Receiver ... using tag set #0 ... (Tag set #0 approaching exhaustion) (Generate new key #0) NextKey forward, request reverse, with key #0 --------\u0026gt; (Repeat until NextKey ACK received) (Generate new key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create inbound tag set #1) \u0026lt;--------------- NextKey reverse, with key #0 (Repeat until tag from tag set #1 received) (Receive NextKey with key #0) (Perform DH: sender_key_0 × receiver_key_0) (Create outbound tag set #1) ... using tag set #1 ... (Tag set #1 approaching exhaustion) (Generate new key #1) NextKey forward, with key #1 --------\u0026gt; (Repeat until NextKey ACK received) (Reuse existing key #0) (Perform DH: sender_key_1 × receiver_key_0) (Create inbound tag set #2) \u0026lt;-------------- NextKey reverse, id 0 (ACK) (Repeat until tag from tag set #2 received) (Receive NextKey with id 0) (Perform DH: sender_key_1 × receiver_key_0) (Create outbound tag set #2) ... using tag set #2 ... (Tag set #2 approaching exhaustion) (Reuse existing key #1) NextKey forward, request reverse, id 1 --------\u0026gt; (Repeat until NextKey received) (Generate new key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create inbound tag set #3) \u0026lt;-------------- NextKey reverse, with key #1 (Receive NextKey with key #1) (Perform DH: sender_key_1 × receiver_key_1) (Create outbound tag set #3) ... using tag set #3 ... (Pattern repeats: even-numbered tag sets use forward key, odd-numbered use reverse key) Padrões de Ratchet (mecanismo de atualização de chaves):\nCriando conjuntos de tags com numeração par (2, 4, 6, \u0026hellip;): 1. O remetente gera uma nova chave 2. O remetente envia o NextKey block (bloco NextKey) com a nova chave 3. O receptor envia o NextKey block com o ID da chave antiga (ACK, confirmação) 4. Ambos realizam DH (Diffie-Hellman) com (nova chave do remetente × chave antiga do receptor)\nCriando conjuntos de tags com contagem ímpar (3, 5, 7, \u0026hellip;): 1. O Remetente solicita a chave de retorno (envia NextKey com a flag de solicitação) 2. O Receptor gera uma nova chave 3. O Receptor envia um bloco NextKey com a nova chave 4. Ambos executam DH (Diffie-Hellman, troca de chaves) com (chave antiga do remetente × nova chave do receptor)\nFormato do bloco NextKey (próxima chave) Consulte a seção Payload Format para obter a especificação detalhada do bloco NextKey.\nElementos-chave: - Byte de flags: - Bit 0: Chave presente (1) ou apenas ID (0) - Bit 1: Chave reversa (1) ou chave direta (0) - Bit 2: Solicitar chave reversa (1) ou sem solicitação (0) - ID da chave: 2 bytes, big-endian (mais significativo primeiro) (0-32767) - Chave pública: 32 bytes X25519 (se o bit 0 = 1)\nExemplos de NextKey Blocks (blocos NextKey):\n# Sender initiates ratchet with new key (key ID 0, tag set 1) NextKey(flags=0x01, key_id=0, pubkey=sender_key_0) # Receiver replies with new key (key ID 0, tag set 1) NextKey(flags=0x03, key_id=0, pubkey=receiver_key_0) # Sender ratchets again with new key (key ID 1, tag set 2) NextKey(flags=0x01, key_id=1, pubkey=sender_key_1) # Receiver ACKs with old key ID (tag set 2) NextKey(flags=0x02, key_id=0) # Sender requests reverse key (tag set 3) NextKey(flags=0x04, key_id=1) # Receiver sends new reverse key (key ID 1, tag set 3) NextKey(flags=0x03, key_id=1, pubkey=receiver_key_1) KDF do DH Ratchet (catraca Diffie-Hellman) Quando novas chaves são trocadas:\n# Tag sender generates or reuses key if generating_new: sender_sk = GENERATE_PRIVATE() sender_pk = DERIVE_PUBLIC(sender_sk) else: # Reuse existing key pair sender_pk = existing_sender_pk # Tag receiver generates or reuses key if generating_new: receiver_sk = GENERATE_PRIVATE() receiver_pk = DERIVE_PUBLIC(receiver_sk) else: # Reuse existing key pair receiver_pk = existing_receiver_pk # Both parties perform DH sharedSecret = DH(sender_sk, receiver_pk) # Derive tagset key tagsetKey = HKDF(sharedSecret, ZEROLEN, \u0026#34;XDHRatchetTagSet\u0026#34;, 32) # Get next root key from previous tagset rootKey = previous_tagset.nextRootKey # Initialize new tagset new_tagset = DH_INITIALIZE(rootKey, tagsetKey) # Tag sender: outbound tagset # Tag receiver: inbound tagset Temporização Crítica:\nRemetente de Tags: - Cria um novo conjunto de tags de saída imediatamente - Passa a usar as novas tags imediatamente - Exclui o antigo conjunto de tags de saída\nReceptor de tags: - Cria novo conjunto de tags de entrada - Mantém o conjunto de tags de entrada antigo por um período de carência (3 minutos) - Aceita tags de ambos os conjuntos (antigo e novo) durante o período de carência - Exclui o conjunto de tags de entrada antigo após o período de carência\nGerenciamento de estado do DH Ratchet (mecanismo de avanço Diffie-Hellman) Estado do remetente: - Conjunto de tags de saída atual - ID do conjunto de tags e IDs de chaves - Próxima chave raiz (para o próximo ratchet (mecanismo de avanço de chaves)) - Número de mensagens no conjunto de tags atual\nEstado do receptor: - Conjunto(s) de tags de entrada em uso (pode haver 2 durante o período de carência) - Números de mensagens anteriores (PN) para detecção de lacunas - Janela de antecipação de tags pré-geradas - Próxima chave raiz (para a próxima ratchet (mecanismo de avanço criptográfico))\nRegras de Transição de Estado:\nAntes do primeiro ratchet (mecanismo de avanço criptográfico):\nUsando o conjunto de tags 0 (do NSR) Nenhum ID de chave atribuído Iniciando Ratchet (mecanismo de catraca criptográfica):\nGerar nova chave (se o remetente estiver gerando nesta rodada) Enviar o bloco NextKey na mensagem ES Aguardar a resposta NextKey antes de criar um novo conjunto de tags de saída Recebendo Ratchet Request (pedido de ratchet):\nGerar nova chave (se o receptor estiver gerando nesta rodada) Executar DH com a chave recebida Criar novo conjunto de tags de entrada Enviar resposta NextKey Reter o conjunto de tags de entrada antigo por um período de carência Concluindo o Ratchet (mecanismo de catraca criptográfica):\nReceber a resposta NextKey Executar DH Criar novo conjunto de tags de saída Começar a usar as novas tags Ratchet de Tag de Sessão (mecanismo de avanço criptográfico) O session tag ratchet (mecanismo de avanço de tags de sessão) gera tags de sessão de uso único de 8 bytes de forma determinística.\nFinalidade do Session Tag Ratchet (mecanismo de avanço das tags de sessão) Substitui a transmissão explícita de tags (ElGamal enviava tags de 32 bytes) Permite ao receptor pré-gerar tags para uma janela de antecipação O emissor gera sob demanda (sem necessidade de armazenamento) Sincroniza com o symmetric key ratchet (mecanismo de avanço de chaves simétricas) via índice Fórmula do Ratchet (mecanismo de avanço) de Tags de Sessão Inicialização:\n# From DH_INITIALIZE sessTag_ck = initial_chain_key # 32 bytes # Initialize session tag ratchet keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) sessTag_chainKey = keydata[0:31] # First chain key SESSTAG_CONSTANT = keydata[32:63] # Constant for all tags in this tagset Geração de tag (para a tag N):\n# Generate tag N keydata = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata[0:31] # Chain key for next tag tag_N = keydata[32:39] # Session tag (8 bytes) # Chain continues for each tag # tag_0, tag_1, tag_2, ..., tag_65535 Sequência completa:\n# Tag 0 keydata_0 = HKDF(sessTag_chainKey, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_0 = keydata_0[0:31] tag_0 = keydata_0[32:39] # Tag 1 keydata_1 = HKDF(sessTag_chainKey_0, SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_1 = keydata_1[0:31] tag_1 = keydata_1[32:39] # Tag N keydata_N = HKDF(sessTag_chainKey_(N-1), SESSTAG_CONSTANT, \u0026#34;SessionTagKeyGen\u0026#34;, 64) sessTag_chainKey_N = keydata_N[0:31] tag_N = keydata_N[32:39] Implementação do Remetente do Session Tag Ratchet (mecanismo de atualização progressiva de tags de sessão) class OutboundTagset: def __init__(self, sessTag_ck): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 def get_next_tag(self): # Increment index self.index += 1 if self.index \u0026gt; 65535: raise TagsetExhausted(\u0026#34;Ratchet required\u0026#34;) # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] return (tag, self.index) Processo do Remetente: 1. Chame get_next_tag() para cada mensagem 2. Use a tag retornada na ES message (mensagem ES) 3. Armazene o índice N para possível rastreamento de ACK (confirmação) 4. Não é necessário armazenar tags (geradas sob demanda)\nImplementação do receptor do Session Tag Ratchet (mecanismo de catraca de tags de sessão) class InboundTagset: def __init__(self, sessTag_ck, look_ahead=32): # Initialize keydata = HKDF(sessTag_ck, ZEROLEN, \u0026#34;STInitialization\u0026#34;, 64) self.chainKey = keydata[0:31] self.constant = keydata[32:63] self.index = -1 self.look_ahead = look_ahead self.tags = {} # Dictionary: tag -\u0026gt; index # Pre-generate initial tags self.extend(look_ahead) def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Generate \u0026#39;count\u0026#39; more tags\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 if self.index \u0026gt; 65535: return # Cannot exceed maximum # Generate tag keydata = HKDF(self.chainKey, self.constant, \u0026#34;SessionTagKeyGen\u0026#34;, 64) self.chainKey = keydata[0:31] tag = keydata[32:39] # Store tag self.tags[tag] = self.index def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Look up tag and return index\u0026#34;\u0026#34;\u0026#34; if tag in self.tags: index = self.tags[tag] # Remove tag (one-time use) del self.tags[tag] return index return None def check_and_extend(self): \u0026#34;\u0026#34;\u0026#34;Extend if tag count is low\u0026#34;\u0026#34;\u0026#34; current_count = len(self.tags) if current_count \u0026lt; self.look_ahead // 2: # Extend to restore window self.extend(self.look_ahead - current_count) Processo do receptor: 1. Pré-gerar tags para a look-ahead window (janela de antecipação) (por exemplo, 32 tags) 2. Armazenar as tags em uma tabela hash ou dicionário 3. Quando a mensagem chegar, consultar a tag para obter o índice N 4. Remover a tag do armazenamento (uso único) 5. Estender a janela se a contagem de tags cair abaixo do limiar\nEstratégia de antecipação de tags de sessão Objetivo: Equilibrar o uso de memória vs. o tratamento de mensagens fora de ordem\nTamanhos de Look-Ahead (antecipação) recomendados:\nTagset Type Initial Size Maximum Size Notes NSR tagset 12 12 Short-lived ES tagset 0 24 160 Initial ES tagset ES tagset 1+ 160 160 Ratcheted tagsets **Antecipação Adaptativa:** # Dynamic look-ahead based on highest tag received look_ahead = min(tsmax, tsmin + N // 4) # Example: # tsmin = 24, tsmax = 160 # N = 0: look_ahead = min(160, 24 + 0/4) = 24 # N = 100: look_ahead = min(160, 24 + 100/4) = 49 # N = 500: look_ahead = min(160, 24 + 500/4) = 149 # N = 544: look_ahead = min(160, 24 + 544/4) = 160 Aparar por trás:\n# Trim tags far behind highest received trim_behind = look_ahead // 2 # If highest received tag is N=100, trim tags below N=50 Cálculo de memória:\n# Per tag: 8 bytes (tag) + 2 bytes (index) + overhead ≈ 16 bytes # Look-ahead of 160 tags ≈ 2.5 KB per inbound tagset # With multiple sessions: # 100 inbound sessions × 2.5 KB = 250 KB total Tratamento de Session Tag (tag de sessão) fora de ordem Cenário: Mensagens chegam fora de ordem\nExpected: tag_5, tag_6, tag_7, tag_8 Received: tag_5, tag_7, tag_6, tag_8 Comportamento do receptor:\nReceber tag_5:\nConsultar: encontrado no índice 5 Processar mensagem Remover tag_5 Maior recebido: 5 Receber tag_7 (fora de ordem):\nConsultar: encontrado no índice 7 Processar mensagem Remover tag_7 Maior recebido: 7 Observação: tag_6 ainda armazenado (ainda não recebido) Receber tag_6 (atrasado):\nConsultar: encontrado no índice 6 Processar mensagem Remover tag_6 Maior recebido: 7 (inalterado) Receber tag_8:\nConsultar: encontrado no índice 8 Processar a mensagem Remover tag_8 Maior recebido: 8 Manutenção da Janela: - Acompanhar o maior índice recebido - Manter lista de índices ausentes (gaps, lacunas) - Estender a janela com base no maior índice - Opcional: Expirar gaps antigos após o tempo limite\nCatraca de Chave Simétrica O symmetric key ratchet (mecanismo de atualização progressiva de chaves simétricas) gera chaves de criptografia de 32 bytes sincronizadas com tags de sessão.\nFinalidade do Symmetric Key Ratchet (mecanismo de avanço criptográfico com chave simétrica) Fornece uma chave de criptografia exclusiva para cada mensagem Sincronizada com o session tag ratchet (mecanismo de catraca para tags de sessão; mesmo índice) O remetente pode gerar sob demanda O destinatário pode adiar a geração até que a tag seja recebida Fórmula do Symmetric Key Ratchet (mecanismo de catraca de chave simétrica) Inicialização:\n# From DH_INITIALIZE symmKey_ck = initial_chain_key # 32 bytes # No additional initialization needed # Unlike session tag ratchet, no constant is derived Geração de chave (para a chave N):\n# Generate key N SYMMKEY_CONSTANT = ZEROLEN # Empty string keydata = HKDF(symmKey_chainKey_(N-1), SYMMKEY_CONSTANT, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata[0:31] # Chain key for next key key_N = keydata[32:63] # Session key (32 bytes) Sequência Completa:\n# Key 0 keydata_0 = HKDF(symmKey_ck, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_0 = keydata_0[0:31] key_0 = keydata_0[32:63] # Key 1 keydata_1 = HKDF(symmKey_chainKey_0, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_1 = keydata_1[0:31] key_1 = keydata_1[32:63] # Key N keydata_N = HKDF(symmKey_chainKey_(N-1), ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) symmKey_chainKey_N = keydata_N[0:31] key_N = keydata_N[32:63] Implementação do remetente do Symmetric Key Ratchet (mecanismo de catraca de chave simétrica) class OutboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Fast-forward to desired index if needed while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] # Should not reach here if called correctly raise ValueError(\u0026#34;Key already generated\u0026#34;) Processo do Remetente: 1. Obter a próxima tag e seu índice N 2. Gerar a chave para o índice N 3. Usar a chave para criptografar a mensagem 4. Não é necessário armazenar a chave\nImplementação do Receptor do Symmetric Key Ratchet (mecanismo de avanço de chave simétrica) Estratégia 1: Geração Adiada (Recomendado)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = {} # Optional: cache recently used keys def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Generate key for specific index\u0026#34;\u0026#34;\u0026#34; # Check cache first (optional optimization) if index in self.cache: key = self.cache[index] del self.cache[index] return key # Fast-forward to desired index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: return keydata[32:63] raise ValueError(\u0026#34;Index already passed\u0026#34;) Processo de Geração Diferida: 1. Receber mensagem ES com tag 2. Consultar a tag para obter o índice N 3. Gerar as chaves de 0 a N (se ainda não tiverem sido geradas) 4. Usar a chave N para descriptografar a mensagem 5. chain key (chave da cadeia) agora posicionada no índice N\nVantagens: - Uso mínimo de memória - Chaves geradas apenas quando necessário - Implementação simples\nDesvantagens: - Deve gerar todas as chaves de 0 a N no primeiro uso - Não consegue lidar com mensagens fora de ordem sem armazenamento em cache\nEstratégia 2: Pré-geração com janela de tags (Alternativa)\nclass InboundKeyRatchet: def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.keys = {} # Dictionary: index -\u0026gt; key def extend(self, count): \u0026#34;\u0026#34;\u0026#34;Pre-generate \u0026#39;count\u0026#39; more keys\u0026#34;\u0026#34;\u0026#34; for _ in range(count): self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] key = keydata[32:63] self.keys[self.index] = key def get_key(self, index): \u0026#34;\u0026#34;\u0026#34;Retrieve pre-generated key\u0026#34;\u0026#34;\u0026#34; if index in self.keys: key = self.keys[index] del self.keys[index] return key return None Processo de pré-geração: 1. Pré-gerar chaves que correspondam à janela de tags (por exemplo, 32 chaves) 2. Armazenar chaves indexadas pelo número da mensagem 3. Quando a tag for recebida, procurar a chave correspondente 4. Estender a janela à medida que as tags forem usadas\nVantagens: - Lida naturalmente com mensagens fora de ordem - Recuperação rápida de chaves (sem atraso de geração)\nDesvantagens: - Maior uso de memória (32 bytes por chave vs 8 bytes por tag) - Deve manter as chaves sincronizadas com as tags\nComparação de memória:\n# Look-ahead of 160: # Tags only: 160 × 16 bytes = 2.5 KB # Tags+Keys: 160 × (16 + 32) bytes = 7.5 KB # # For 100 sessions: # Tags only: 250 KB # Tags+Keys: 750 KB Sincronização do Ratchet (mecanismo de avanço criptográfico) simétrico com tags de sessão Requisito Crítico: O índice da tag de sessão DEVE ser igual ao índice da chave simétrica\n# Sender tag, index = outbound_tagset.get_next_tag() key = outbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) ciphertext = ENCRYPT(key, nonce, payload, tag) # Receiver index = inbound_tagset.lookup_tag(tag) key = inbound_keyratchet.get_key(index) # Same index nonce = construct_nonce(index) plaintext = DECRYPT(key, nonce, ciphertext, tag) Modos de falha:\nSe a sincronização falhar: - Chave incorreta usada para descriptografia - Falha na verificação do MAC - Mensagem rejeitada\nPrevenção: - Sempre use o mesmo índice para a tag e a chave - Nunca pule índices em nenhum dos ratchets (mecanismo de catraca criptográfica) - Trate mensagens fora de ordem com cuidado\nConstrução do Nonce do Ratchet Simétrico (mecanismo de catraca criptográfica) Nonce (número usado uma vez) é derivado do número da mensagem:\ndef construct_nonce(index): \u0026#34;\u0026#34;\u0026#34; Construct 12-byte nonce for ChaCha20-Poly1305 Args: index: Message number (0-65535) Returns: nonce: 12-byte nonce \u0026#34;\u0026#34;\u0026#34; # First 4 bytes are always zero nonce = bytearray(12) nonce[0:4] = b\u0026#39;\\x00\\x00\\x00\\x00\u0026#39; # Last 8 bytes are little-endian message number nonce[4:12] = index.to_bytes(8, byteorder=\u0026#39;little\u0026#39;) return bytes(nonce) Exemplos:\nindex = 0: nonce = 0x00000000 0000000000000000 index = 1: nonce = 0x00000000 0100000000000000 index = 255: nonce = 0x00000000 FF00000000000000 index = 256: nonce = 0x00000000 0001000000000000 index = 65535: nonce = 0x00000000 FFFF000000000000 Propriedades Importantes: - Nonces (valores únicos usados uma vez) são exclusivos para cada mensagem em um tagset (conjunto de tags) - Nonces nunca se repetem (tags de uso único garantem isso) - Um contador de 8 bytes permite 2^64 mensagens (nós só usamos 2^16) - O formato do Nonce corresponde à construção baseada em contador da RFC 7539\nGerenciamento de Sessões Contexto da Sessão Todas as sessões de entrada e de saída devem pertencer a um contexto específico:\nContexto do Router: Sessões para o próprio router Contexto de Destino: Sessões para um destino local específico (aplicação cliente) Regra Crítica: As sessões NÃO DEVEM ser compartilhadas entre contextos para evitar ataques de correlação.\nImplementação:\nclass SessionKeyManager: \u0026#34;\u0026#34;\u0026#34;Context for managing sessions (router or destination)\u0026#34;\u0026#34;\u0026#34; def __init__(self, context_id): self.context_id = context_id self.inbound_sessions = {} # far_end_dest -\u0026gt; [sessions] self.outbound_sessions = {} # far_end_dest -\u0026gt; session self.static_keypair = generate_keypair() # Context\u0026#39;s identity def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session to destination\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: self.outbound_sessions[destination] = create_outbound_session(destination) return self.outbound_sessions[destination] def add_inbound_session(self, session, destination=None): \u0026#34;\u0026#34;\u0026#34;Add inbound session, optionally bound to destination\u0026#34;\u0026#34;\u0026#34; if destination: if destination not in self.inbound_sessions: self.inbound_sessions[destination] = [] self.inbound_sessions[destination].append(session) else: # Unbound session self.inbound_sessions[None].append(session) Implementação do I2P em Java:\nNo I2P em Java, a classe SessionKeyManager fornece esta funcionalidade: - Um SessionKeyManager por router - Um SessionKeyManager por destino local - Gerenciamento separado das sessões ECIES e ElGamal em cada contexto\nVinculação de Sessão Binding (vinculação) associa uma sessão a um destino remoto específico.\nSessões Vinculadas Características: - Incluir a chave estática do remetente na NS message (mensagem NS) - O destinatário pode identificar o destino do remetente - Permite comunicação bidirecional - Uma única sessão de saída por destino - Pode haver várias sessões de entrada (durante transições)\nCasos de uso: - Conexões de streaming (semelhantes ao TCP) - Datagramas com suporte a resposta - Qualquer protocolo que exija requisição/resposta\nProcesso de associação:\n# Alice creates bound outbound session outbound_session = OutboundSession( destination=bob_destination, static_key=alice_static_key, bound=True ) # Alice sends NS with static key ns_message = build_ns_message( ephemeral_key=alice_ephemeral_key, static_key=alice_static_key, # Included for binding payload=data ) # Bob receives NS bob_receives_ns(ns_message) # Bob extracts Alice\u0026#39;s static key alice_static_key = decrypt_static_key_section(ns_message) # Bob looks up Alice\u0026#39;s destination (from bundled LeaseSet) alice_destination = lookup_destination_by_static_key(alice_static_key) # Bob creates bound inbound session inbound_session = InboundSession( destination=alice_destination, bound=True ) # Bob pairs with outbound session outbound_session = OutboundSession( destination=alice_destination, bound=True ) Benefícios: 1. DH Efêmero-Efêmero: A resposta usa ee DH (sigilo de encaminhamento perfeito) 2. Continuidade de sessão: Ratchets (mecanismo de avanço criptográfico) mantêm o vínculo com o mesmo destino 3. Segurança: Impede sequestro de sessão (autenticado por chave estática) 4. Eficiência: Uma única sessão por destino (sem duplicação)\nSessões não vinculadas Características: - Sem chave estática na mensagem NS (a seção de flags contém apenas zeros) - O destinatário não pode identificar o remetente - Comunicação apenas unidirecional - Várias sessões para o mesmo destino são permitidas\nCasos de uso: - Datagramas brutos (fire-and-forget, enviar e não esperar resposta) - Publicação anônima - Mensagens no estilo broadcast\nPropriedades: - Mais anônimo (sem identificação do remetente) - Mais eficiente (1 DH vs 2 DH no handshake) - Não é possível responder (o destinatário não sabe para onde responder) - Sem ratcheting de sessão (mecanismo de atualização progressiva de chaves; uso único ou limitado)\nEmparelhamento de Sessão Emparelhamento conecta uma sessão de entrada com uma sessão de saída para comunicação bidirecional.\nCriando Sessões Emparelhadas Perspectiva de Alice (iniciadora):\n# Create outbound session to Bob outbound_session = create_outbound_session(bob_destination) # Create paired inbound session inbound_session = create_inbound_session( paired_with=outbound_session, bound_to=bob_destination ) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NS message send_ns_message(outbound_session, payload) Perspectiva de Bob (respondente):\n# Receive NS message ns_message = receive_ns_message() # Create inbound session inbound_session = create_inbound_session_from_ns(ns_message) # If NS contains static key (bound): if ns_message.has_static_key(): alice_destination = extract_destination(ns_message) inbound_session.bind_to(alice_destination) # Create paired outbound session outbound_session = create_outbound_session(alice_destination) # Link them outbound_session.paired_inbound = inbound_session inbound_session.paired_outbound = outbound_session # Send NSR send_nsr_message(inbound_session, outbound_session, payload) Benefícios do Emparelhamento de Sessão ACKs no próprio canal: Pode confirmar mensagens sem um clove separado (submensagem no esquema garlic) Ratcheting eficiente (mecanismo de avanço de chaves): Ambas as direções avançam em conjunto Controle de fluxo: Pode implementar back-pressure (propagação de pressão/limitação de origem) entre sessões emparelhadas Consistência de estado: Mais fácil manter o estado sincronizado Regras de Emparelhamento de Sessão A sessão de saída pode estar desemparelhada (NS sem vínculo; \u0026lsquo;NS\u0026rsquo; mantido em inglês como termo técnico) A sessão de entrada para NS vinculado deve ser pareada O pareamento ocorre na criação da sessão, não depois Sessões pareadas têm o mesmo vínculo de destino Ratchets ocorrem de forma independente, mas são coordenados (ratchets: mecanismo de atualização criptográfica) Ciclo de vida da sessão Ciclo de vida da sessão: fase de criação Criação da sessão de saída (Alice):\ndef create_outbound_session(destination, bound=True): session = OutboundSession() session.destination = destination session.bound = bound session.state = SessionState.NEW session.created_time = now() # Generate keys for NS message session.ephemeral_keypair = generate_elg2_keypair() if bound: session.static_key = context.static_keypair.public_key # Will be populated after NSR received session.outbound_tagset = None session.inbound_tagset = None return session Criação de Sessão de Entrada (Bob):\ndef create_inbound_session_from_ns(ns_message): session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() # Extract from NS session.remote_ephemeral_key = ns_message.ephemeral_key session.remote_static_key = ns_message.static_key if session.remote_static_key: session.bound = True session.destination = lookup_destination(session.remote_static_key) else: session.bound = False session.destination = None # Generate keys for NSR session.ephemeral_keypair = generate_elg2_keypair() # Create tagsets from KDF session.inbound_tagset = create_tagset_from_nsr() session.outbound_tagset = create_tagset_from_nsr() return session Ciclo de Vida da Sessão: Fase Ativa Transições de Estado:\nNEW (outbound only) ↓ NS sent ↓ PENDING_REPLY (outbound only) ↓ NSR received ↓ ESTABLISHED ↓ ES messages exchanged ↓ ESTABLISHED (ongoing) ↓ (optional) RATCHETING ↓ ESTABLISHED Manutenção de Sessões Ativas:\ndef maintain_active_session(session): # Update last activity time session.last_activity = now() # Check for ratchet needed if session.outbound_tagset.needs_ratchet(): initiate_ratchet(session) # Check for incoming ratchet if received_nextkey_block(): process_ratchet(session) # Trim old tags from inbound tagset session.inbound_tagset.expire_old_tags() # Check session health if session.idle_time() \u0026gt; SESSION_TIMEOUT: mark_session_idle(session) Ciclo de Vida da Sessão: Fase de Expiração Valores de tempo limite da sessão:\nSession Type Sender Timeout Receiver Timeout Notes NSR tagset N/A 3 minutes Short-lived ES tagset 0 8 minutes 10 minutes Initial ES tagset 1+ 8 minutes 10 minutes Ratcheted Old tagset N/A 3 minutes After ratchet **Lógica de expiração:** def check_session_expiration(): for session in active_sessions: # Outbound session expiration (sender) if session.is_outbound(): if session.idle_time() \u0026gt; 8 * 60: # 8 minutes expire_outbound_session(session) # Inbound session expiration (receiver) else: if session.idle_time() \u0026gt; 10 * 60: # 10 minutes expire_inbound_session(session) # Old tagsets (after ratchet) for tagset in old_tagsets: if tagset.age() \u0026gt; 3 * 60: # 3 minutes delete_tagset(tagset) Regra Crítica: As sessões de saída DEVEM expirar antes das sessões de entrada para evitar dessincronização.\nFinalização ordenada:\ndef terminate_session(session, reason=0): # Send Termination block (if implemented) send_termination_block(session, reason) # Mark session for deletion session.state = SessionState.TERMINATED # Keep session briefly for final messages schedule_deletion(session, delay=30) # 30 seconds # Notify paired session if session.paired_session: session.paired_session.mark_remote_terminated() Múltiplas mensagens NS Cenário: A mensagem NS de Alice se perde ou a resposta NSR se perde.\nComportamento de Alice:\nclass OutboundSession: def __init__(self): self.ns_messages_sent = [] self.ns_timer = None self.max_ns_attempts = 5 def send_ns_message(self, payload): # Generate new ephemeral key for each NS ephemeral_key = generate_elg2_keypair() ns_message = build_ns_message( ephemeral_key=ephemeral_key, static_key=self.static_key, payload=payload ) # Store state for this NS ns_state = { \u0026#39;ephemeral_key\u0026#39;: ephemeral_key, \u0026#39;chainkey\u0026#39;: compute_chainkey(ns_message), \u0026#39;hash\u0026#39;: compute_hash(ns_message), \u0026#39;tagset\u0026#39;: derive_nsr_tagset(ns_message), \u0026#39;sent_time\u0026#39;: now() } self.ns_messages_sent.append(ns_state) # Send message send_message(ns_message) # Set timer for retry if not self.ns_timer: self.ns_timer = set_timer(1.0, self.on_ns_timeout) def on_ns_timeout(self): if len(self.ns_messages_sent) \u0026gt;= self.max_ns_attempts: # Give up fail_session(\u0026#34;No NSR received after {self.max_ns_attempts} attempts\u0026#34;) return # Retry with new NS message send_ns_message(self.payload) def on_nsr_received(self, nsr_message): # Cancel timer cancel_timer(self.ns_timer) # Find which NS this NSR responds to tag = nsr_message.tag for ns_state in self.ns_messages_sent: if tag in ns_state[\u0026#39;tagset\u0026#39;]: # This NSR corresponds to this NS self.active_ns_state = ns_state break # Process NSR and complete handshake complete_handshake(nsr_message, self.active_ns_state) # Discard other NS states self.ns_messages_sent = [] Propriedades importantes:\nChaves Efêmeras Exclusivas: Cada NS utiliza uma chave efêmera diferente Handshakes (negociação) Independentes: Cada NS cria um estado de handshake separado Correlação NSR: A tag NSR identifica a qual NS ela responde Limpeza de Estado: Estados de NS não utilizados são descartados após uma NSR bem-sucedida Prevenção de ataques:\nPara evitar o esgotamento de recursos:\n# Limit NS sending rate max_ns_rate = 5 per 10 seconds per destination # Limit total NS attempts max_ns_attempts = 5 # Limit total pending NS states max_pending_ns = 10 per context Múltiplas mensagens NSR Cenário: Bob envia múltiplas NSRs (por exemplo, dados de resposta divididos em várias mensagens).\nComportamento de Bob:\nclass InboundSession: def send_nsr_replies(self, payload_chunks): # One NS received, multiple NSRs to send for chunk in payload_chunks: # Generate new ephemeral key for each NSR ephemeral_key = generate_elg2_keypair() # Get next tag from NSR tagset tag = self.nsr_tagset.get_next_tag() nsr_message = build_nsr_message( tag=tag, ephemeral_key=ephemeral_key, payload=chunk ) send_message(nsr_message) # Wait for ES message from Alice self.state = SessionState.AWAITING_ES Comportamento de Alice:\nclass OutboundSession: def on_nsr_received(self, nsr_message): if self.state == SessionState.PENDING_REPLY: # First NSR received complete_handshake(nsr_message) self.state = SessionState.ESTABLISHED # Create ES sessions self.es_outbound_tagset = derive_es_outbound_tagset() self.es_inbound_tagset = derive_es_inbound_tagset() # Send ES message (ACK) send_es_message(empty_payload) elif self.state == SessionState.ESTABLISHED: # Additional NSR received # Decrypt and process payload payload = decrypt_nsr_payload(nsr_message) process_payload(payload) # These NSRs are from other NS attempts, ignore handshake Limpeza de Bob:\nclass InboundSession: def on_es_received(self, es_message): # First ES received from Alice # This confirms which NSR Alice used # Clean up other handshake states for other_ns_state in self.pending_ns_states: if other_ns_state != self.active_ns_state: delete_ns_state(other_ns_state) # Delete unused NSR tagsets for tagset in self.nsr_tagsets: if tagset != self.active_nsr_tagset: delete_tagset(tagset) self.state = SessionState.ESTABLISHED Propriedades importantes:\nMúltiplos NSRs permitidos: Bob pode enviar vários NSRs para cada NS Chaves efêmeras diferentes: Cada NSR deve usar uma chave efêmera exclusiva Mesmo tagset (conjunto de tags) do NSR: Todos os NSRs para um NS usam o mesmo tagset O primeiro ES vence: O primeiro ES de Alice determina qual NSR foi bem-sucedido Limpeza após ES: Bob descarta estados não utilizados após o recebimento do ES Máquina de estados da sessão Diagrama de Estados Completo:\nOutbound Session Inbound Session NEW | send NS | PENDING_REPLY -------------------- receive NS ---\u0026gt; ESTABLISHED | | receive NSR send NSR | | ESTABLISHED \u0026lt;---------- receive ES ------------- AWAITING_ES | | | ┌─────┴─────┐ | receive ES | | | | send ES receive ES | ESTABLISHED | | | | └─────┬─────┘ | ┌─────────┴─────────┐ | | | | | | send ES receive ES | | | | | | └─────────┬─────────┘ | | | └─────────────────────┴──────────────────────────┘ ACTIVE | idle timeout | EXPIRED Descrições dos estados:\nNEW: Sessão de saída criada, nenhum NS enviado ainda PENDING_REPLY: NS enviado, aguardando NSR AWAITING_ES: NSR enviado, aguardando o primeiro ES de Alice ESTABLISHED: Handshake concluído, pode enviar/receber ES ACTIVE: Trocando ativamente mensagens ES RATCHETING: DH ratchet (mecanismo de avanço de chaves Diffie-Hellman) em andamento (subconjunto de ACTIVE) EXPIRED: Sessão expirada, aguardando exclusão TERMINATED: Sessão encerrada explicitamente Formato da Carga Útil A seção de carga útil de todas as mensagens ECIES (NS, NSR, ES) usa um formato baseado em blocos semelhante ao NTCP2.\nEstrutura de Blocos Formato geral:\n+----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ |blk | size | data | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Campos:\nblk: 1 byte - Número do tipo de bloco size: 2 bytes - Tamanho, em big-endian, do campo de dados (0-65516) data: Tamanho variável - Dados específicos do bloco Restrições:\nQuadro ChaChaPoly (algoritmo AEAD ChaCha20-Poly1305) máximo: 65535 bytes Poly1305 MAC (código de autenticação de mensagem): 16 bytes Máximo total de blocos: 65519 bytes (65535 - 16) Tamanho máximo de um único bloco: 65519 bytes (incluindo cabeçalho de 3 bytes) Tamanho máximo de dados de um único bloco: 65516 bytes Tipos de Bloco Tipos de Blocos Definidos:\nType Name Size Status Usage 0 DateTime 7 bytes Implemented Required in NS 1-3 Reserved - - Future use 4 Termination 9+ bytes Unimplemented Session termination 5 Options 21+ bytes Unimplemented Session options 6 MessageNumbers 5 bytes Unimplemented PN value 7 NextKey 3 or 35 bytes Implemented DH ratchet 8 ACK 4+ bytes Implemented Message acknowledgment 9 ACK Request 3 bytes Implemented Request ACK 10 Reserved - - Future use 11 Garlic Clove Variable Implemented Application data 12-223 Reserved - - Future use 224-253 Experimental Variable - Testing features 254 Padding Variable Implemented Traffic shaping 255 Reserved - - Future extension **Tratamento de blocos desconhecidos:** As implementações DEVEM ignorar blocos com números de tipo desconhecido e tratá-los como preenchimento. Isso garante compatibilidade futura.\nRegras de Ordenação de Blocos Ordenação de mensagens NS Obrigatório: - O bloco DateTime DEVE ser o primeiro\nPermitidos: - Garlic Clove (tipo 11) - Opções (tipo 5) - se implementado - Preenchimento (tipo 254)\nProibidos: - NextKey, ACK, ACK Request, Termination, MessageNumbers\nExemplo de carga útil NS válida:\nDateTime (0) | Garlic Clove (11) | Garlic Clove (11) | Padding (254) Ordenação de mensagens do NSR Obrigatório: - Nenhum (a carga útil pode estar vazia)\nPermitidos: - Garlic Clove (unidade de mensagem do garlic encryption) (tipo 11) - Opções (tipo 5) - se implementado - Preenchimento (tipo 254)\nProibidos: - DateTime, NextKey, ACK, ACK Request, Termination, MessageNumbers\nExemplo de carga útil NSR válida:\nGarlic Clove (11) | Garlic Clove (11) | Padding (254) ou\n(empty - ACK only) Ordenação de mensagens ES Obrigatório: - Nenhum (a carga útil pode estar vazia)\nPermitidos (em qualquer ordem): - Garlic Clove (submensagem do garlic encryption) (tipo 11) - NextKey (tipo 7) - ACK (tipo 8) - ACK Request (tipo 9) - Termination (tipo 4) - se implementado - MessageNumbers (tipo 6) - se implementado - Options (tipo 5) - se implementado - Padding (tipo 254)\nRegras Especiais: - Termination DEVE ser o último bloco (exceto Padding) - Padding DEVE ser o último bloco - Múltiplos Garlic Cloves (submensagens) permitidos - Até 2 blocos NextKey permitidos (direto e reverso) - Múltiplos blocos Padding NÃO são permitidos\nExemplos válidos de cargas úteis ES:\nGarlic Clove (11) | ACK (8) | Padding (254) NextKey (7) | Garlic Clove (11) | Garlic Clove (11) NextKey (7) forward | NextKey (7) reverse | Garlic Clove (11) ACK Request (9) | Garlic Clove (11) | Termination (4) | Padding (254) DateTime Block (bloco de data e hora) (Tipo 0) Finalidade: Carimbo de data/hora para prevenção de repetição e validação do desvio do relógio\nTamanho: 7 bytes (3 bytes de cabeçalho + 4 bytes de dados)\nFormato:\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Campos:\nblk: 0 size: 4 (big-endian, ordem de bytes com o mais significativo primeiro) timestamp: 4 bytes - carimbo de tempo Unix em segundos (sem sinal, big-endian) Formato do carimbo de data e hora:\ntimestamp = int(time.time()) # Seconds since 1970-01-01 00:00:00 UTC # Wraps around in year 2106 (4-byte unsigned maximum) Regras de validação:\nMAX_CLOCK_SKEW_PAST = 5 * 60 # 5 minutes MAX_CLOCK_SKEW_FUTURE = 2 * 60 # 2 minutes def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: return False # Too far in future if age \u0026gt; MAX_CLOCK_SKEW_PAST: return False # Too old return True Prevenção de Repetição:\nclass ReplayFilter: def __init__(self, duration=5*60): self.duration = duration # 5 minutes self.seen_messages = BloomFilter(size=100000, false_positive_rate=0.001) self.cleanup_timer = RepeatTimer(60, self.cleanup) def check_replay(self, ephemeral_key, timestamp): # Check timestamp validity if not validate_datetime(timestamp): return False # Check if ephemeral key seen recently if ephemeral_key in self.seen_messages: return False # Replay attack # Add to seen messages self.seen_messages.add(ephemeral_key) return True def cleanup(self): # Expire old entries (Bloom filter automatically ages out) pass Notas de Implementação:\nMensagens NS: DateTime DEVE ser o primeiro bloco Mensagens NSR/ES: Normalmente, o DateTime não é incluído Janela de Replay: 5 minutos é o mínimo recomendado Filtro de Bloom: Recomendado para detecção eficiente de replay Desvio do Relógio: Permitir 5 minutos no passado, 2 minutos no futuro Bloco de Dente de Alho (Tipo 11) Objetivo: Encapsula mensagens I2NP para entrega\nFormato:\n+----+----+----+----+----+----+----+----+ | 11 | size | | +----+----+----+ + | Delivery Instructions | ~ ~ | | +----+----+----+----+----+----+----+----+ |type| Message_ID | Expiration | +----+----+----+----+----+----+----+----+ | I2NP Message body | +----+ + ~ ~ | | +----+----+----+----+----+----+----+----+ Campos:\nblk: 11 size: Tamanho total do clove (submensagem no I2P; variável) Delivery Instructions: Conforme a especificação do I2NP type: Tipo de mensagem I2NP (1 byte) Message_ID: ID da mensagem I2NP (4 bytes) Expiration: Timestamp Unix em segundos (4 bytes) I2NP Message body: Dados da mensagem de comprimento variável Formatos de instruções de entrega:\nEntrega local (1 byte):\n+----+ |0x00| +----+ Entrega ao Destino (33 bytes):\n+----+----+----+----+----+----+----+----+ |0x01| | +----+ Destination Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Entrega ao Router (33 bytes):\n+----+----+----+----+----+----+----+----+ |0x02| | +----+ Router Hash + | 32 bytes | + + | | +----+----+----+----+----+----+----+----+ Entrega via Tunnel (37 bytes):\n+----+----+----+----+----+----+----+----+ |0x03| Tunnel ID | +----+----+----+----+----+ + | Router Hash | + 32 bytes + | | + + | | +----+----+----+----+----+----+----+----+ Cabeçalho de Mensagem do I2NP (9 bytes no total):\n+----+----+----+----+----+----+----+----+ |type| msg_id | expiration | +----+----+----+----+----+----+----+----+ | | type: tipo de mensagem I2NP (Database Store, Database Lookup, Data, etc.) msg_id: identificador de mensagem de 4 bytes expiration: timestamp Unix de 4 bytes (segundos) Diferenças importantes em relação ao ElGamal Clove Format (formato Clove do ElGamal):\nSem Certificado: campo Certificate omitido (não utilizado em ElGamal) Sem Clove ID: Clove ID omitido (Clove = submensagem em uma mensagem de garlic encryption; sempre foi 0) Sem Clove Expiration: usa a expiração da mensagem I2NP em vez disso Cabeçalho compacto: cabeçalho I2NP de 9 bytes em comparação com o formato ElGamal maior Cada Clove é um bloco separado: sem a estrutura CloveSet Múltiplos Cloves (dentes de alho):\n# Multiple Garlic Cloves in one message payload = [ build_datetime_block(), build_garlic_clove(i2np_message_1), build_garlic_clove(i2np_message_2), build_garlic_clove(i2np_message_3), build_padding_block() ] Tipos comuns de mensagens I2NP em Cloves (submensagens em garlic encryption):\nType Name Usage 1 DatabaseStore Publishing LeaseSet 2 DatabaseLookup Requesting LeaseSet 5 DeliveryStatus ACK (legacy, avoid in ECIES) 20 Data Streaming data 21 Garlic Nested garlic messages **Processamento de Clove (submensagem dentro de uma mensagem de garlic encryption):** def process_garlic_clove(clove_data): # Parse delivery instructions delivery_type = clove_data[0] if delivery_type == 0x00: # Local delivery offset = 1 elif delivery_type == 0x01: # Destination delivery dest_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x02: # Router delivery router_hash = clove_data[1:33] offset = 33 elif delivery_type == 0x03: # Tunnel delivery tunnel_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[1:5])[0] router_hash = clove_data[5:37] offset = 37 # Parse I2NP header i2np_type = clove_data[offset] msg_id = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+1:offset+5])[0] expiration = struct.unpack(\u0026#39;\u0026gt;I\u0026#39;, clove_data[offset+5:offset+9])[0] # Extract I2NP body i2np_body = clove_data[offset+9:] # Process message process_i2np_message(i2np_type, msg_id, expiration, i2np_body) Bloco NextKey (chave seguinte) (Tipo 7) Objetivo: troca de chaves via DH ratchet (mecanismo de avanço de Diffie-Hellman)\nFormato (Chave presente - 38 bytes):\n+----+----+----+----+----+----+----+----+ | 7 | 35 |flag| key ID | | +----+----+----+----+----+----+ + | | + Next DH Ratchet Public Key + | 32 bytes | + + | | + +----+----+ | | +----+----+----+----+----+----+ Formato (apenas ID da chave - 6 bytes):\n+----+----+----+----+----+----+ | 7 | 3 |flag| key ID | +----+----+----+----+----+----+ Campos:\nblk: 7 size: 3 (apenas ID) ou 35 (com chave) flag: 1 byte - Bits de flag key ID: 2 bytes - Identificador de chave Big-endian (0-32767) Public Key: 32 bytes - Chave pública X25519 (little-endian), se o bit 0 de flag = 1 Bits de sinalização:\nBit 7 6 5 4 3 2 1 0 | | | | | | | | | | | | | | | +-- Bit 0: Key present (1) or ID only (0) | | | | | | +---- Bit 1: Reverse key (1) or forward key (0) | | | | | +------ Bit 2: Request reverse key (1) or no request (0) | | | | | +-+-+-+-+-------- Bits 3-7: Reserved (set to 0) Exemplos de flags:\n# Forward key present flags = 0x01 # Binary: 00000001 # Reverse key present flags = 0x03 # Binary: 00000011 # Forward key ID only (ACK) flags = 0x00 # Binary: 00000000 # Reverse key ID only (ACK) flags = 0x02 # Binary: 00000010 # Forward key ID with reverse request flags = 0x04 # Binary: 00000100 Regras de ID da chave:\nIDs são sequenciais: 0, 1, 2, \u0026hellip;, 32767 O ID só incrementa quando uma nova chave é gerada O mesmo ID é usado para várias mensagens até o próximo ratchet (mecanismo de avanço) O ID máximo é 32767 (é necessário iniciar uma nova sessão depois) Exemplos de uso:\n# Initiating ratchet (sender generates new key) nextkey = NextKeyBlock( flags=0x01, # Key present, forward key_id=0, public_key=sender_new_pk ) # Replying to ratchet (receiver generates new key) nextkey = NextKeyBlock( flags=0x03, # Key present, reverse key_id=0, public_key=receiver_new_pk ) # Acknowledging ratchet (no new key from sender) nextkey = NextKeyBlock( flags=0x02, # ID only, reverse key_id=0 ) # Requesting reverse ratchet nextkey = NextKeyBlock( flags=0x04, # Request reverse, forward ID key_id=1 ) Lógica de processamento:\ndef process_nextkey_block(block): flags = block.flags key_id = block.key_id key_present = (flags \u0026amp; 0x01) != 0 is_reverse = (flags \u0026amp; 0x02) != 0 request_reverse = (flags \u0026amp; 0x04) != 0 if key_present: public_key = block.public_key if is_reverse: # Reverse key received perform_dh_ratchet(receiver_key=public_key, key_id=key_id) # Sender should ACK with own key ID else: # Forward key received perform_dh_ratchet(sender_key=public_key, key_id=key_id) # Receiver should reply with reverse key send_reverse_key(generate_new_key()) else: # Key ID only (ACK) if is_reverse: # Reverse key ACK confirm_reverse_ratchet(key_id) else: # Forward key ACK confirm_forward_ratchet(key_id) if request_reverse: # Sender requests receiver to generate new key send_reverse_key(generate_new_key()) Múltiplos NextKey Blocks:\nUma única ES message (mensagem do tipo ES) pode conter até 2 NextKey blocks (blocos NextKey) quando ambas as direções estiverem realizando ratcheting (avanço de chaves) simultaneamente:\n# Both directions ratcheting payload = [ NextKeyBlock(flags=0x01, key_id=2, public_key=forward_key), # Forward NextKeyBlock(flags=0x03, key_id=1, public_key=reverse_key), # Reverse build_garlic_clove(data) ] Bloco ACK (Tipo 8) Objetivo: Acusar o recebimento de mensagens no mesmo canal\nFormato (ACK único - 7 bytes):\n+----+----+----+----+----+----+----+ | 8 | 4 |tagsetid | N | +----+----+----+----+----+----+----+ Formato (múltiplos ACKs):\n+----+----+----+----+----+----+----+----+ | 8 | size |tagsetid | N | | +----+----+----+----+----+----+----+ + | more ACKs | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Campos:\nblk: 8 size: 4 * número de ACKs (mínimo 4) Para cada ACK: tagsetid: 2 bytes - ID do conjunto de tags em big-endian (0-65535) N: 2 bytes - número da mensagem em big-endian (0-65535) Determinação do ID do conjunto de tags:\n# Tag set 0 (initial, after NSR) tagset_id = 0 # After first ratchet (tag set 1) # Both Alice and Bob sent key ID 0 tagset_id = 1 + 0 + 0 = 1 # After second ratchet (tag set 2) # Alice sent key ID 1, Bob still using key ID 0 tagset_id = 1 + 1 + 0 = 2 # After third ratchet (tag set 3) # Alice still using key ID 1, Bob sent key ID 1 tagset_id = 1 + 1 + 1 = 3 Exemplo de ACK (confirmação) único:\n# ACK message from tag set 5, message number 127 ack_block = ACKBlock( tagset_id=5, message_number=127 ) # Wire format (7 bytes): # 08 00 04 00 05 00 7F # | | | | | | | # | | | | | | +-- N (127) # | | | | +--------- N high byte # | | | +------------ tagset_id (5) # | | +--------------- tagset_id high byte # | +------------------ size (4) # +--------------------- type (8) Exemplo de múltiplos ACKs (confirmações):\n# ACK three messages ack_block = ACKBlock([ (tagset_id=3, N=42), (tagset_id=3, N=43), (tagset_id=4, N=0) ]) # Wire format (15 bytes): # 08 00 0C 00 03 00 2A 00 03 00 2B 00 04 00 00 # (ts=3, N=42) (ts=3, N=43) (ts=4, N=0) Processamento:\ndef process_ack_block(block): num_acks = block.size // 4 for i in range(num_acks): offset = i * 4 tagset_id = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset:offset+2])[0] message_num = struct.unpack(\u0026#39;\u0026gt;H\u0026#39;, block.data[offset+2:offset+4])[0] # Mark message as acknowledged mark_acked(tagset_id, message_num) # May trigger retransmission timeout cancellation cancel_retransmit_timer(tagset_id, message_num) Quando enviar ACKs (confirmações):\nSolicitação explícita de ACK: Sempre responder ao bloco de Solicitação de ACK Entrega de LeaseSet: Quando o remetente inclui o LeaseSet na mensagem Estabelecimento de sessão: Pode enviar ACK de NS/NSR (embora o protocolo prefira ACK implícito via ES) Confirmação do ratchet (mecanismo de avanço criptográfico): Pode enviar ACK do recebimento de NextKey Camada de aplicação: Conforme exigido pelo protocolo da camada superior (por exemplo, Streaming) Temporização de ACK:\nclass ACKManager: def __init__(self): self.pending_acks = [] self.ack_timer = None def request_ack(self, tagset_id, message_num): self.pending_acks.append((tagset_id, message_num)) if not self.ack_timer: # Delay ACK briefly to allow higher layer to respond self.ack_timer = set_timer(0.1, self.send_acks) # 100ms def send_acks(self): if self.pending_acks and not has_outbound_data(): # No higher layer data, send explicit ACK send_es_message(build_ack_block(self.pending_acks)) # Otherwise, ACK will piggyback on next ES message self.pending_acks = [] self.ack_timer = None Bloco de Solicitação de ACK (Tipo 9) Finalidade: Solicitar confirmação em banda do recebimento da mensagem atual\nFormato:\n+----+----+----+----+ | 9 | 1 |flg | +----+----+----+----+ Campos:\nblk: 9 size: 1 flg: 1 byte - Sinalizadores (todos os bits atualmente não utilizados, definidos como 0) Uso:\n# Request ACK for this message payload = [ build_ack_request_block(), build_garlic_clove(important_data) ] Resposta do receptor:\nQuando um ACK Request (pedido de ACK) é recebido:\nCom dados imediatos: Incluir bloco ACK na resposta imediata Sem dados imediatos: Iniciar um temporizador (por exemplo, 100 ms) e enviar ES vazio com ACK se o temporizador expirar Tag Set ID: Usar o ID do conjunto de tags de entrada atual Número da mensagem: Usar o número da mensagem associado à tag de sessão recebida Processamento:\ndef process_ack_request(message): # Extract message identification tagset_id = message.tagset_id message_num = message.message_num # Schedule ACK schedule_ack(tagset_id, message_num) # If no data to send immediately, start timer if not has_pending_data(): set_timer(0.1, lambda: send_ack_only(tagset_id, message_num)) Quando usar o ACK Request:\nMensagens Críticas: Mensagens que devem ser confirmadas Entrega de LeaseSet: Ao agrupar um LeaseSet Session Ratchet (mecanismo de avanço da sessão): Após enviar o bloco NextKey Fim da Transmissão: Quando o remetente não tem mais dados para enviar, mas deseja confirmação Quando NÃO usar:\nProtocolo de Streaming: A camada de streaming lida com ACKs (confirmações) Mensagens de alta frequência: Evite solicitação de ACK em cada mensagem (sobrecarga) Datagramas sem importância: Datagramas brutos normalmente não precisam de ACKs Bloco de Terminação (Tipo 4) Estado: NÃO IMPLEMENTADO\nFinalidade: Encerrar a sessão de forma limpa\nFormato:\n+----+----+----+----+----+----+----+----+ | 4 | size | rsn| addl data | +----+----+----+----+ + ~ ... ~ +----+----+----+----+----+----+----+----+ Campos:\nblk: 4 size: 1 ou mais bytes rsn: 1 byte - código do motivo addl data: Dados adicionais opcionais (o formato depende do motivo) Códigos de motivo:\nCode Meaning Additional Data 0 Normal close / unspecified None 1 Termination received None 2 Idle timeout None (implementation-specific) 3 Resource exhaustion None (implementation-specific) 4+ Reserved Implementation-specific **Uso (quando estiver implementado):** # Normal session close termination = TerminationBlock( reason=0, additional_data=b\u0026#39;\u0026#39; ) # Session termination due to received termination termination = TerminationBlock( reason=1, additional_data=b\u0026#39;\u0026#39; ) Regras:\nDEVE ser o último bloco, exceto por Padding (preenchimento) Padding DEVE seguir Termination (finalização) se presente Não é permitido em mensagens NS ou NSR Apenas é permitido em mensagens ES Bloco de Opções (Tipo 5) Status: NÃO IMPLEMENTADO\nObjetivo: Negociar parâmetros de sessão\nFormato:\n+----+----+----+----+----+----+----+----+ | 5 | size |ver |flg |STL |STimeout | +----+----+----+----+----+----+----+----+ | SOTW | RITW |tmin|tmax|rmin|rmax| +----+----+----+----+----+----+----+----+ | tdmy | rdmy | tdelay | rdelay | +----+----+----+----+----+----+----+----+ | more_options | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Campos:\nblk: 5 size: 21 bytes ou mais ver: 1 byte - Versão do protocolo (deve ser 0) flg: 1 byte - Flags (todos os bits atualmente não utilizados) STL: 1 byte - Comprimento da tag de sessão (deve ser 8) STimeout: 2 bytes - Tempo limite de inatividade da sessão em segundos (big-endian) SOTW: 2 bytes - Janela de Tags de Saída do Remetente (big-endian) RITW: 2 bytes - Janela de Tags de Entrada do Receptor (big-endian) tmin, tmax, rmin, rmax: 1 byte cada - Parâmetros de preenchimento (ponto fixo 4.4) tdmy: 2 bytes - Tráfego fictício máximo que está disposto a enviar (bytes/sec, big-endian) rdmy: 2 bytes - Tráfego fictício solicitado (bytes/sec, big-endian) tdelay: 2 bytes - Atraso intra-mensagem máximo que está disposto a inserir (msec, big-endian) rdelay: 2 bytes - Atraso intra-mensagem solicitado (msec, big-endian) more_options: Variável - Extensões futuras Parâmetros de Preenchimento (4.4 em ponto fixo):\ndef encode_padding_ratio(ratio): \u0026#34;\u0026#34;\u0026#34; Encode padding ratio as 4.4 fixed-point ratio: 0.0 to 15.9375 returns: 0x00 to 0xFF \u0026#34;\u0026#34;\u0026#34; return int(ratio * 16) def decode_padding_ratio(encoded): \u0026#34;\u0026#34;\u0026#34; Decode 4.4 fixed-point to ratio encoded: 0x00 to 0xFF returns: 0.0 to 15.9375 \u0026#34;\u0026#34;\u0026#34; return encoded / 16.0 # Examples: # 0x00 = 0.0 (no padding) # 0x01 = 0.0625 (6.25% padding) # 0x10 = 1.0 (100% padding - double traffic) # 0x80 = 8.0 (800% padding - 9x traffic) # 0xFF = 15.9375 (1593.75% padding) Negociação da Janela de Tags:\n# SOTW: Sender\u0026#39;s recommendation for receiver\u0026#39;s inbound window # RITW: Sender\u0026#39;s declaration of own inbound window # Receiver calculates actual inbound window: inbound_window = calculate_window( sender_suggestion=SOTW, own_constraints=MAX_INBOUND_TAGS, own_resources=available_memory() ) # Sender uses: # - RITW to know how far ahead receiver will accept # - Own SOTW to hint optimal window size Valores padrão (quando as opções não são negociadas):\nDEFAULT_OPTIONS = { \u0026#39;version\u0026#39;: 0, \u0026#39;session_tag_length\u0026#39;: 8, \u0026#39;session_timeout\u0026#39;: 600, # 10 minutes \u0026#39;sender_outbound_tag_window\u0026#39;: 160, \u0026#39;receiver_inbound_tag_window\u0026#39;: 160, \u0026#39;tmin\u0026#39;: 0x00, # No minimum padding \u0026#39;tmax\u0026#39;: 0x10, # Up to 100% padding \u0026#39;rmin\u0026#39;: 0x00, # No minimum requested \u0026#39;rmax\u0026#39;: 0x10, # Up to 100% requested \u0026#39;tdmy\u0026#39;: 0, # No dummy traffic \u0026#39;rdmy\u0026#39;: 0, # No dummy traffic requested \u0026#39;tdelay\u0026#39;: 0, # No delay \u0026#39;rdelay\u0026#39;: 0 # No delay requested } Bloco de Números de Mensagem (Tipo 6) Status: NÃO IMPLEMENTADO\nObjetivo: Indicar a última mensagem enviada no conjunto de tags anterior (permite detecção de lacunas)\nFormato:\n+----+----+----+----+----+ | 6 | 2 | PN | +----+----+----+----+----+ Campos:\nblk: 6 size: 2 PN: 2 bytes - Número da última mensagem do conjunto de tags anterior (big-endian (ordem de bytes com o mais significativo primeiro), 0-65535) Definição de PN (Previous Number, número anterior):\nPN é o índice da última tag enviada no conjunto de tags anterior.\nUso (quando implementado):\n# After ratcheting to new tag set # Old tag set: sent messages 0-4095 # New tag set: sending first message payload = [ MessageNumbersBlock(PN=4095), build_garlic_clove(data) ] Benefícios para o receptor:\ndef process_message_numbers(pn_value): # Receiver can now: # 1. Determine if any messages were skipped highest_received_in_old_tagset = 4090 if pn_value \u0026gt; highest_received_in_old_tagset: missing_count = pn_value - highest_received_in_old_tagset # 5 messages were never received # 2. Delete tags higher than PN from old tagset for tag_index in range(pn_value + 1, MAX_TAG_INDEX): delete_tag(old_tagset, tag_index) # 3. Expire tags ≤ PN after grace period (e.g., 2 minutes) schedule_deletion(old_tagset, delay=120) Regras:\nNÃO DEVE ser enviado no tag set (conjunto de tags) 0 (sem tag set anterior) Enviado apenas em ES messages (mensagens ES) Enviado apenas nas primeiras mensagens de um novo tag set PN value (valor PN) é do ponto de vista do remetente (último tag (etiqueta) enviado pelo remetente) Relação com o Signal:\nNo Signal Double Ratchet (protocolo de troca de chaves Double Ratchet do Signal), o PN está no cabeçalho da mensagem. No ECIES (Esquema de Criptografia Integrada baseado em Curvas Elípticas), o PN fica na carga útil criptografada e é opcional.\nBloco de preenchimento (Tipo 254) Objetivo: Resistência à análise de tráfego e ofuscação do tamanho das mensagens\nFormato:\n+----+----+----+----+----+----+----+----+ |254 | size | padding | +----+----+----+ + | | ~ ... ~ | | +----+----+----+----+----+----+----+----+ Campos:\nblk: 254 size: 0-65516 bytes (big-endian, ordem de bytes com o mais significativo primeiro) padding: Dados aleatórios ou zerados Regras:\nDEVE ser o último bloco na mensagem Múltiplos blocos de preenchimento NÃO são permitidos Pode ter comprimento zero (apenas cabeçalho de 3 bytes) Os dados de preenchimento podem ser zeros ou bytes aleatórios Preenchimento padrão:\nDEFAULT_PADDING_MIN = 0 DEFAULT_PADDING_MAX = 15 def generate_default_padding(): size = random.randint(DEFAULT_PADDING_MIN, DEFAULT_PADDING_MAX) data = random.bytes(size) # or zeros return PaddingBlock(size, data) Estratégias de resistência à análise de tráfego:\nEstratégia 1: Tamanho aleatório (Padrão)\n# Add 0-15 bytes random padding to each message padding_size = random.randint(0, 15) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Estratégia 2: Arredondar para um múltiplo\n# Round total message size to next multiple of 64 target_size = ((message_size + 63) // 64) * 64 padding_size = target_size - message_size - 3 # -3 for block header padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Estratégia 3: Tamanhos Fixos de Mensagens\n# Always send 1KB messages TARGET_MESSAGE_SIZE = 1024 padding_size = TARGET_MESSAGE_SIZE - message_size - 3 padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Estratégia 4: Preenchimento Negociado (bloco de opções)\n# Calculate padding based on negotiated parameters # tmin, tmax from Options block min_padding = int(payload_size * tmin_ratio) max_padding = int(payload_size * tmax_ratio) padding_size = random.randint(min_padding, max_padding) padding_block = PaddingBlock(padding_size, random.bytes(padding_size)) Mensagens apenas de preenchimento:\nAs mensagens podem consistir inteiramente de preenchimento (sem dados de aplicação):\n# Dummy traffic message payload = [ PaddingBlock(random.randint(100, 500), random.bytes(...)) ] Notas de implementação:\nPreenchimento com zeros: Aceitável (será criptografado por ChaCha20) Preenchimento aleatório: Não oferece segurança adicional após a criptografia, mas usa mais entropia Desempenho: A geração de preenchimento aleatório pode ser custosa; considere usar zeros Memória: Blocos grandes de preenchimento consomem largura de banda; seja cauteloso com o tamanho máximo Guia de Implementação Pré-requisitos Bibliotecas criptográficas:\nX25519: libsodium, NaCl ou Bouncy Castle ChaCha20-Poly1305: libsodium, OpenSSL 1.1.0+ ou Bouncy Castle SHA-256: OpenSSL, Bouncy Castle ou suporte nativo da linguagem Elligator2 (técnica para ocultar pontos de curva elíptica): Suporte limitado em bibliotecas; pode exigir implementação personalizada Implementação do Elligator2 (técnica criptográfica para mapear pontos de curva elíptica para dados indistinguíveis de aleatórios):\nO Elligator2 (método criptográfico para camuflar chaves públicas como dados aleatórios) não é amplamente implementado. Opções:\nOBFS4: O transporte plugável obfs4 do Tor inclui uma implementação do Elligator2 (técnica para disfarçar chaves públicas em curvas elípticas) Implementação personalizada: Baseada no artigo Elligator2 kleshni/Elligator: Implementação de referência no GitHub Nota do Java I2P: O Java I2P usa a biblioteca net.i2p.crypto.eddsa com adições personalizadas de Elligator2 (técnica de hashing para curvas elípticas).\nOrdem de Implementação Recomendada Fase 1: Criptografia Essencial 1. geração e troca de chaves DH X25519 2. cifragem/decifragem AEAD ChaCha20-Poly1305 3. hash SHA-256 e MixHash (operação de mistura de hash) 4. derivação de chaves HKDF 5. codificação/decodificação Elligator2 (pode usar vetores de teste inicialmente)\nFase 2: Formatos de Mensagem 1. Mensagem NS (não vinculada) - formato mais simples 2. Mensagem NS (vinculada) - adiciona chave estática 3. Mensagem NSR 4. Mensagem ES 5. Análise e geração de blocos\nFase 3: Gerenciamento de Sessão 1. Criação e armazenamento da sessão 2. Gerenciamento do conjunto de tags (remetente e destinatário) 3. Ratchet de tag de sessão (mecanismo de avanço criptográfico) 4. Ratchet de chave simétrica 5. Busca de tags e gerenciamento de janela\nFase 4: DH Ratcheting (mecanismo de catraca DH) 1. Tratamento do bloco NextKey 2. KDF do DH ratchet 3. Criação do conjunto de tags após a catraca 4. Gerenciamento de múltiplos conjuntos de tags\nFase 5: Lógica do Protocolo 1. Máquina de estados NS/NSR/ES 2. Prevenção de replay (DateTime, filtro de Bloom) 3. Lógica de retransmissão (múltiplos NS/NSR) 4. Tratamento de ACK\nFase 6: Integração 1. Processamento de I2NP Garlic Clove (dente de alho no contexto do I2P) 2. Empacotamento de LeaseSet 3. Integração do protocolo de streaming 4. Integração do protocolo de datagrama\nImplementação do Remetente Ciclo de Vida da Sessão de Saída:\nclass OutboundSession: def __init__(self, destination, bound=True): self.destination = destination self.bound = bound self.state = SessionState.NEW # Keys for NS message self.ephemeral_keypair = generate_elg2_keypair() if bound: self.static_key = context.static_keypair # Will be populated after NSR self.outbound_tagset = None self.outbound_keyratchet = None self.inbound_tagset = None self.inbound_keyratchet = None # Timing self.created_time = now() self.last_activity = now() # Retransmission self.ns_attempts = [] self.ns_timer = None def send_initial_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send NS message\u0026#34;\u0026#34;\u0026#34; # Build NS message ns_message = self.build_ns_message(payload) # Send send_to_network(self.destination, ns_message) # Track for retransmission self.ns_attempts.append({ \u0026#39;message\u0026#39;: ns_message, \u0026#39;time\u0026#39;: now(), \u0026#39;ephemeral_key\u0026#39;: self.ephemeral_keypair, \u0026#39;kdf_state\u0026#39;: self.save_kdf_state() }) # Start timer self.ns_timer = set_timer(1.0, self.on_ns_timeout) self.state = SessionState.PENDING_REPLY def build_ns_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Construct NS message\u0026#34;\u0026#34;\u0026#34; # KDF initialization chainKey, h = self.initialize_kdf() # Ephemeral key section elg2_ephemeral = ENCODE_ELG2(self.ephemeral_keypair.public_key) h = SHA256(h || self.destination.static_key) h = SHA256(h || self.ephemeral_keypair.public_key) # es DH es_shared = DH(self.ephemeral_keypair.private_key, self.destination.static_key) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Encrypt static key section if self.bound: static_section = self.static_key.public_key else: static_section = bytes(32) static_ciphertext = ENCRYPT(k_static, 0, static_section, h) h = SHA256(h || static_ciphertext) # ss DH (if bound) if self.bound: ss_shared = DH(self.static_key.private_key, self.destination.static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 else: k_payload = k_static nonce = 1 # Build payload blocks payload_data = self.build_ns_payload(payload) # Encrypt payload payload_ciphertext = ENCRYPT(k_payload, nonce, payload_data, h) h = SHA256(h || payload_ciphertext) # Save KDF state for NSR processing self.ns_chainkey = chainKey self.ns_hash = h # Assemble message return elg2_ephemeral + static_ciphertext + payload_ciphertext def build_ns_payload(self, application_data): \u0026#34;\u0026#34;\u0026#34;Build NS payload blocks\u0026#34;\u0026#34;\u0026#34; blocks = [] # DateTime block (required, first) blocks.append(build_datetime_block()) # Garlic Clove(s) with application data blocks.append(build_garlic_clove(application_data)) # Optionally bundle LeaseSet if should_send_leaseset(): blocks.append(build_garlic_clove(build_leaseset_store())) # Padding blocks.append(build_padding_block(random.randint(0, 15))) return encode_blocks(blocks) def on_nsr_received(self, nsr_message): \u0026#34;\u0026#34;\u0026#34;Process NSR and establish ES session\u0026#34;\u0026#34;\u0026#34; # Cancel retransmission timer cancel_timer(self.ns_timer) # Parse NSR tag = nsr_message[0:8] elg2_bob_ephemeral = nsr_message[8:40] key_section_mac = nsr_message[40:56] payload_ciphertext = nsr_message[56:] # Find corresponding NS attempt ns_state = self.find_ns_by_tag(tag) if not ns_state: raise ValueError(\u0026#34;NSR tag doesn\u0026#39;t match any NS\u0026#34;) # Restore KDF state chainKey = ns_state[\u0026#39;chainkey\u0026#39;] h = ns_state[\u0026#39;hash\u0026#39;] # Decode Bob\u0026#39;s ephemeral key bob_ephemeral = DECODE_ELG2(elg2_bob_ephemeral) # Mix tag and Bob\u0026#39;s ephemeral into hash h = SHA256(h || tag) h = SHA256(h || bob_ephemeral) # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, bob_ephemeral) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(self.static_key.private_key, bob_ephemeral) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Verify key section MAC try: DECRYPT(k_key_section, 0, key_section_mac, h) except AuthenticationError: raise ValueError(\u0026#34;NSR key section MAC verification failed\u0026#34;) h = SHA256(h || key_section_mac) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.outbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.inbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Decrypt NSR payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) try: payload = DECRYPT(k_nsr, 0, payload_ciphertext, h) except AuthenticationError: raise ValueError(\u0026#34;NSR payload MAC verification failed\u0026#34;) # Process NSR payload blocks self.process_payload_blocks(payload) # Session established self.state = SessionState.ESTABLISHED self.last_activity = now() # Send ES message (implicit ACK) self.send_es_ack() def send_es_message(self, payload): \u0026#34;\u0026#34;\u0026#34;Send ES message\u0026#34;\u0026#34;\u0026#34; if self.state != SessionState.ESTABLISHED: raise ValueError(\u0026#34;Session not established\u0026#34;) # Get next tag and key tag, index = self.outbound_tagset.get_next_tag() key = self.outbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Build payload blocks payload_data = self.build_es_payload(payload) # AEAD encryption ciphertext = ENCRYPT(key, nonce, payload_data, tag) # Assemble message es_message = tag + ciphertext # Send send_to_network(self.destination, es_message) # Update activity self.last_activity = now() # Check if ratchet needed if self.outbound_tagset.should_ratchet(): self.initiate_ratchet() Implementação do receptor Ciclo de Vida da Sessão de Entrada:\nclass InboundSession: def __init__(self): self.state = None self.bound = False self.destination = None # Keys self.remote_ephemeral_key = None self.remote_static_key = None self.ephemeral_keypair = None # Tagsets self.inbound_tagset = None self.outbound_tagset = None # Timing self.created_time = None self.last_activity = None # Paired session self.paired_outbound = None @staticmethod def try_decrypt_ns(message): \u0026#34;\u0026#34;\u0026#34;Attempt to decrypt as NS message\u0026#34;\u0026#34;\u0026#34; # Parse NS structure elg2_ephemeral = message[0:32] static_ciphertext = message[32:80] # 32 + 16 payload_ciphertext = message[80:] # Decode ephemeral key try: alice_ephemeral = DECODE_ELG2(elg2_ephemeral) except: return None # Not a valid Elligator2 encoding # Check replay if is_replay(alice_ephemeral): return None # KDF initialization chainKey, h = initialize_kdf() # Mix keys h = SHA256(h || context.static_keypair.public_key) h = SHA256(h || alice_ephemeral) # es DH es_shared = DH(context.static_keypair.private_key, alice_ephemeral) keydata = HKDF(chainKey, es_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_static = keydata[32:63] # Decrypt static key section try: static_data = DECRYPT(k_static, 0, static_ciphertext, h) except AuthenticationError: return None # Not a valid NS message h = SHA256(h || static_ciphertext) # Check if bound or unbound if static_data == bytes(32): # Unbound alice_static_key = None k_payload = k_static nonce = 1 else: # Bound - perform ss DH alice_static_key = static_data ss_shared = DH(context.static_keypair.private_key, alice_static_key) keydata = HKDF(chainKey, ss_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_payload = keydata[32:63] nonce = 0 # Decrypt payload try: payload = DECRYPT(k_payload, nonce, payload_ciphertext, h) except AuthenticationError: return None h = SHA256(h || payload_ciphertext) # Create session session = InboundSession() session.state = SessionState.ESTABLISHED session.created_time = now() session.last_activity = now() session.remote_ephemeral_key = alice_ephemeral session.remote_static_key = alice_static_key session.bound = (alice_static_key is not None) session.ns_chainkey = chainKey session.ns_hash = h # Extract destination if bound if session.bound: session.destination = extract_destination_from_payload(payload) # Process payload session.process_payload_blocks(payload) return session def send_nsr_reply(self, reply_payload): \u0026#34;\u0026#34;\u0026#34;Send NSR message\u0026#34;\u0026#34;\u0026#34; # Generate NSR tagset tagsetKey = HKDF(self.ns_chainkey, ZEROLEN, \u0026#34;SessionReplyTags\u0026#34;, 32) nsr_tagset = DH_INITIALIZE(self.ns_chainkey, tagsetKey) # Get tag tag, _ = nsr_tagset.get_next_tag() # Mix tag into hash h = SHA256(self.ns_hash || tag) # Generate ephemeral key self.ephemeral_keypair = generate_elg2_keypair() bob_ephemeral = self.ephemeral_keypair.public_key elg2_bob_ephemeral = ENCODE_ELG2(bob_ephemeral) # Mix ephemeral key h = SHA256(h || bob_ephemeral) chainKey = self.ns_chainkey # ee DH ee_shared = DH(self.ephemeral_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, ee_shared, \u0026#34;\u0026#34;, 32) chainKey = keydata[0:31] # se DH se_shared = DH(context.static_keypair.private_key, self.remote_ephemeral_key) keydata = HKDF(chainKey, se_shared, \u0026#34;\u0026#34;, 64) chainKey = keydata[0:31] k_key_section = keydata[32:63] # Encrypt key section (empty) key_section_ciphertext = ENCRYPT(k_key_section, 0, ZEROLEN, h) h = SHA256(h || key_section_ciphertext) # Split for bidirectional ES keydata = HKDF(chainKey, ZEROLEN, \u0026#34;\u0026#34;, 64) k_ab = keydata[0:31] # Alice → Bob k_ba = keydata[32:63] # Bob → Alice # Initialize ES tagsets self.inbound_tagset = DH_INITIALIZE(chainKey, k_ab) self.outbound_tagset = DH_INITIALIZE(chainKey, k_ba) # Build reply payload payload_data = build_payload_blocks(reply_payload) # Encrypt payload k_nsr = HKDF(k_ba, ZEROLEN, \u0026#34;AttachPayloadKDF\u0026#34;, 32) payload_ciphertext = ENCRYPT(k_nsr, 0, payload_data, h) # Assemble NSR nsr_message = tag + elg2_bob_ephemeral + key_section_ciphertext + payload_ciphertext # Send send_to_network(self.destination, nsr_message) # Wait for ES self.state = SessionState.AWAITING_ES self.last_activity = now() def on_es_received(self, es_message): \u0026#34;\u0026#34;\u0026#34;Process first ES message\u0026#34;\u0026#34;\u0026#34; if self.state == SessionState.AWAITING_ES: # First ES received, confirms session self.state = SessionState.ESTABLISHED # Process ES message self.process_es_message(es_message) def process_es_message(self, es_message): \u0026#34;\u0026#34;\u0026#34;Decrypt and process ES message\u0026#34;\u0026#34;\u0026#34; # Extract tag tag = es_message[0:8] ciphertext = es_message[8:] # Look up tag index = self.inbound_tagset.lookup_tag(tag) if index is None: raise ValueError(\u0026#34;Tag not found\u0026#34;) # Get key key = self.inbound_keyratchet.get_key(index) # Construct nonce nonce = construct_nonce(index) # Decrypt try: payload = DECRYPT(key, nonce, ciphertext, tag) except AuthenticationError: raise ValueError(\u0026#34;ES MAC verification failed\u0026#34;) # Process blocks self.process_payload_blocks(payload) # Update activity self.last_activity = now() Classificação de mensagens Diferenciando Tipos de Mensagem:\ndef classify_message(message): \u0026#34;\u0026#34;\u0026#34;Determine message type\u0026#34;\u0026#34;\u0026#34; # Minimum lengths if len(message) \u0026lt; 24: return None # Too short # Check for session tag (8 bytes) tag = message[0:8] # Try ES decryption first (most common) session = lookup_session_by_tag(tag) if session: return (\u0026#39;ES\u0026#39;, session) # Try NSR decryption (tag + Elligator2 key) if len(message) \u0026gt;= 72: # Check if bytes 8-40 are valid Elligator2 try: nsr_ephemeral = DECODE_ELG2(message[8:40]) nsr_session = find_pending_nsr_by_tag(tag) if nsr_session: return (\u0026#39;NSR\u0026#39;, nsr_session) except: pass # Try NS decryption (starts with Elligator2 key) if len(message) \u0026gt;= 96: try: ns_ephemeral = DECODE_ELG2(message[0:32]) ns_session = InboundSession.try_decrypt_ns(message) if ns_session: return (\u0026#39;NS\u0026#39;, ns_session) except: pass # Check ElGamal/AES (for dual-key compatibility) if len(message) \u0026gt;= 514: if (len(message) - 2) % 16 == 0: # Might be ElGamal NS return (\u0026#39;ELGAMAL_NS\u0026#39;, None) elif len(message) % 16 == 0: # Might be ElGamal ES return (\u0026#39;ELGAMAL_ES\u0026#39;, None) return None # Unknown message type Boas práticas de gerenciamento de sessões Armazenamento de sessão:\nclass SessionKeyManager: def __init__(self): # Outbound sessions (one per destination) self.outbound_sessions = {} # destination -\u0026gt; OutboundSession # Inbound sessions (multiple per destination during transition) self.inbound_sessions = [] # [InboundSession] # Session tag lookup (fast path for ES messages) self.tag_to_session = {} # tag -\u0026gt; InboundSession # Limits self.max_inbound_sessions = 1000 self.max_tags_per_session = 160 def get_outbound_session(self, destination): \u0026#34;\u0026#34;\u0026#34;Get or create outbound session\u0026#34;\u0026#34;\u0026#34; if destination not in self.outbound_sessions: session = OutboundSession(destination) self.outbound_sessions[destination] = session return self.outbound_sessions[destination] def add_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Add new inbound session\u0026#34;\u0026#34;\u0026#34; # Check limits if len(self.inbound_sessions) \u0026gt;= self.max_inbound_sessions: self.expire_oldest_session() self.inbound_sessions.append(session) # Add tags to lookup table self.register_session_tags(session) def register_session_tags(self, session): \u0026#34;\u0026#34;\u0026#34;Register session\u0026#39;s tags in lookup table\u0026#34;\u0026#34;\u0026#34; for tag in session.inbound_tagset.get_all_tags(): self.tag_to_session[tag] = session def lookup_tag(self, tag): \u0026#34;\u0026#34;\u0026#34;Fast tag lookup\u0026#34;\u0026#34;\u0026#34; return self.tag_to_session.get(tag) def expire_sessions(self): \u0026#34;\u0026#34;\u0026#34;Periodic session expiration\u0026#34;\u0026#34;\u0026#34; now_time = now() # Expire outbound sessions for dest, session in list(self.outbound_sessions.items()): if session.idle_time(now_time) \u0026gt; 8 * 60: del self.outbound_sessions[dest] # Expire inbound sessions expired = [] for session in self.inbound_sessions: if session.idle_time(now_time) \u0026gt; 10 * 60: expired.append(session) for session in expired: self.remove_inbound_session(session) def remove_inbound_session(self, session): \u0026#34;\u0026#34;\u0026#34;Remove inbound session and clean up tags\u0026#34;\u0026#34;\u0026#34; self.inbound_sessions.remove(session) # Remove tags from lookup for tag in session.inbound_tagset.get_all_tags(): if tag in self.tag_to_session: del self.tag_to_session[tag] Gerenciamento de memória:\nclass TagMemoryManager: def __init__(self, max_memory_kb=10240): # 10 MB default self.max_memory = max_memory_kb * 1024 self.current_memory = 0 self.max_tags_per_session = 160 self.min_tags_per_session = 32 def calculate_tag_memory(self, session): \u0026#34;\u0026#34;\u0026#34;Calculate memory used by session tags\u0026#34;\u0026#34;\u0026#34; tag_count = len(session.inbound_tagset.tags) # Each tag: 8 bytes (tag) + 2 bytes (index) + 32 bytes (key, optional) # + overhead bytes_per_tag = 16 if session.defer_keys else 48 return tag_count * bytes_per_tag def check_pressure(self): \u0026#34;\u0026#34;\u0026#34;Check if under memory pressure\u0026#34;\u0026#34;\u0026#34; return self.current_memory \u0026gt; (self.max_memory * 0.9) def handle_pressure(self): \u0026#34;\u0026#34;\u0026#34;Reduce memory usage when under pressure\u0026#34;\u0026#34;\u0026#34; if not self.check_pressure(): return # Strategy 1: Reduce look-ahead windows for session in all_sessions: if session.look_ahead \u0026gt; self.min_tags_per_session: session.reduce_look_ahead(self.min_tags_per_session) # Strategy 2: Trim old tags aggressively for session in all_sessions: session.inbound_tagset.trim_behind(aggressive=True) # Strategy 3: Refuse new ratchets for session in all_sessions: if session.outbound_tagset.should_ratchet(): session.defer_ratchet = True # Strategy 4: Expire idle sessions early expire_idle_sessions(threshold=5*60) # 5 min instead of 10 Estratégias de Teste Testes unitários:\ndef test_x25519_dh(): \u0026#34;\u0026#34;\u0026#34;Test X25519 key exchange\u0026#34;\u0026#34;\u0026#34; alice_sk = GENERATE_PRIVATE() alice_pk = DERIVE_PUBLIC(alice_sk) bob_sk = GENERATE_PRIVATE() bob_pk = DERIVE_PUBLIC(bob_sk) # Both sides compute same shared secret alice_shared = DH(alice_sk, bob_pk) bob_shared = DH(bob_sk, alice_pk) assert alice_shared == bob_shared def test_elligator2_encode_decode(): \u0026#34;\u0026#34;\u0026#34;Test Elligator2 roundtrip\u0026#34;\u0026#34;\u0026#34; sk = GENERATE_PRIVATE_ELG2() pk = DERIVE_PUBLIC(sk) encoded = ENCODE_ELG2(pk) decoded = DECODE_ELG2(encoded) assert decoded == pk def test_chacha_poly_encrypt_decrypt(): \u0026#34;\u0026#34;\u0026#34;Test ChaCha20-Poly1305 AEAD\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(42) plaintext = b\u0026#34;Hello, I2P!\u0026#34; ad = b\u0026#34;associated_data\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) decrypted = DECRYPT(key, nonce, ciphertext, ad) assert decrypted == plaintext def test_session_tag_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test session tag generation\u0026#34;\u0026#34;\u0026#34; sessTag_ck = CSRNG(32) tagset = SessionTagRatchet(sessTag_ck) # Generate 100 tags tags = [tagset.get_next_tag() for _ in range(100)] # All tags should be unique assert len(set(tags)) == 100 # Each tag should be 8 bytes for tag in tags: assert len(tag) == 8 Testes de Integração:\ndef test_ns_nsr_handshake(): \u0026#34;\u0026#34;\u0026#34;Test NS/NSR handshake\u0026#34;\u0026#34;\u0026#34; # Alice creates outbound session alice_session = OutboundSession(bob_destination, bound=True) # Alice sends NS ns_message = alice_session.build_ns_message(b\u0026#34;Hello Bob\u0026#34;) # Bob receives NS bob_session = InboundSession.try_decrypt_ns(ns_message) assert bob_session is not None assert bob_session.bound == True # Bob sends NSR nsr_message = bob_session.build_nsr_message(b\u0026#34;Hello Alice\u0026#34;) # Alice receives NSR alice_session.on_nsr_received(nsr_message) assert alice_session.state == SessionState.ESTABLISHED # Both should have matching ES tagsets # (Cannot directly compare, but can test by sending ES messages) def test_es_bidirectional(): \u0026#34;\u0026#34;\u0026#34;Test ES messages in both directions\u0026#34;\u0026#34;\u0026#34; # (After NS/NSR handshake) # Alice sends ES to Bob es_alice_to_bob = alice_session.send_es_message(b\u0026#34;Data from Alice\u0026#34;) # Bob receives ES bob_session.process_es_message(es_alice_to_bob) # Bob sends ES to Alice es_bob_to_alice = bob_session.send_es_message(b\u0026#34;Data from Bob\u0026#34;) # Alice receives ES alice_session.process_es_message(es_bob_to_alice) def test_dh_ratchet(): \u0026#34;\u0026#34;\u0026#34;Test DH ratchet\u0026#34;\u0026#34;\u0026#34; # (After established session) # Alice initiates ratchet alice_session.initiate_ratchet() nextkey_alice = build_nextkey_block( flags=0x01, key_id=0, public_key=alice_new_key ) # Send to Bob bob_session.process_nextkey_block(nextkey_alice) # Bob replies nextkey_bob = build_nextkey_block( flags=0x03, key_id=0, public_key=bob_new_key ) # Send to Alice alice_session.process_nextkey_block(nextkey_bob) # Both should now be using new tagsets assert alice_session.outbound_tagset.id == 1 assert bob_session.inbound_tagset.id == 1 Vetores de teste:\nImplementar vetores de teste da especificação:\nNoise IK Handshake (padrão de handshake IK do protocolo Noise): Use vetores de teste padronizados do Noise HKDF (função de derivação de chaves baseada em HMAC): Use vetores de teste da RFC 5869 ChaCha20-Poly1305 (cifra AEAD que combina ChaCha20 e Poly1305): Use vetores de teste da RFC 7539 Elligator2 (técnica de mapeamento para ofuscação de chaves públicas): Use vetores de teste do artigo do Elligator2 ou do OBFS4 Testes de interoperabilidade:\nJava I2P: Testar contra a implementação de referência do Java I2P i2pd: Testar contra a implementação do i2pd em C++ Capturas de pacotes: Usar o dissector do Wireshark (se disponível) para verificar os formatos de mensagem Entre implementações: Criar um test harness (infraestrutura de testes) que possa enviar/receber entre implementações Considerações de Desempenho Geração de Chaves:\nA geração de chaves Elligator2 (técnica criptográfica que torna chaves públicas indistinguíveis de dados aleatórios) é dispendiosa (taxa de rejeição de 50%):\nclass KeyPool: \u0026#34;\u0026#34;\u0026#34;Pre-generate keys in background thread\u0026#34;\u0026#34;\u0026#34; def __init__(self, pool_size=10): self.pool = Queue(maxsize=pool_size) self.generator_thread = Thread(target=self.generate_keys, daemon=True) self.generator_thread.start() def generate_keys(self): while True: if not self.pool.full(): keypair = generate_elg2_keypair() # Also compute encoded form encoded = ENCODE_ELG2(keypair.public_key) self.pool.put((keypair, encoded)) else: sleep(0.1) def get_keypair(self): try: return self.pool.get(timeout=1.0) except Empty: # Pool exhausted, generate inline return generate_elg2_keypair() Consulta de tags:\nUse tabelas hash para busca de tags em O(1):\nclass FastTagLookup: def __init__(self): self.tag_to_session = {} # Python dict is hash table def add_tag(self, tag, session, index): # 8-byte tag as bytes is hashable self.tag_to_session[tag] = (session, index) def lookup_tag(self, tag): return self.tag_to_session.get(tag) Otimização de Memória:\nAdiar a geração de chave simétrica:\nclass DeferredKeyRatchet: \u0026#34;\u0026#34;\u0026#34;Only generate keys when needed\u0026#34;\u0026#34;\u0026#34; def __init__(self, symmKey_ck): self.chainKey = symmKey_ck self.index = -1 self.cache = LRUCache(maxsize=32) # Cache recent keys def get_key(self, index): # Check cache first if index in self.cache: return self.cache[index] # Generate keys up to index while self.index \u0026lt; index: self.index += 1 keydata = HKDF(self.chainKey, ZEROLEN, \u0026#34;SymmetricRatchet\u0026#34;, 64) self.chainKey = keydata[0:31] if self.index == index: key = keydata[32:63] self.cache[index] = key return key Processamento em lote:\nProcessar várias mensagens em lote:\ndef process_message_batch(messages): \u0026#34;\u0026#34;\u0026#34;Process multiple messages efficiently\u0026#34;\u0026#34;\u0026#34; results = [] # Group by type ns_messages = [] nsr_messages = [] es_messages = [] for msg in messages: msg_type = classify_message(msg) if msg_type[0] == \u0026#39;NS\u0026#39;: ns_messages.append(msg) elif msg_type[0] == \u0026#39;NSR\u0026#39;: nsr_messages.append(msg) elif msg_type[0] == \u0026#39;ES\u0026#39;: es_messages.append(msg) # Process in batches # ES messages are most common, process first for msg in es_messages: results.append(process_es_message(msg)) for msg in nsr_messages: results.append(process_nsr_message(msg)) for msg in ns_messages: results.append(process_ns_message(msg)) return results Considerações de Segurança Modelo de Ameaça Capacidades do Adversário:\nObservador Passivo: Pode observar todo o tráfego da rede Atacante Ativo: Pode injetar, modificar, descartar, repetir mensagens Nó Comprometido: Pode comprometer um router ou destino Análise de Tráfego: Pode realizar análise estatística dos padrões de tráfego Objetivos de segurança:\nConfidencialidade: Conteúdo das mensagens oculto para observadores Autenticação: Identidade do remetente verificada (para sessões vinculadas) Forward Secrecy (sigilo direto): Mensagens anteriores permanecem secretas mesmo que as chaves sejam comprometidas Prevenção de Repetição: Não é possível repetir mensagens antigas Ofuscação de Tráfego: Negociações iniciais indistinguíveis de dados aleatórios Pressupostos criptográficos Hipóteses de dureza:\nX25519 CDH: O problema Diffie-Hellman computacional é difícil na Curve25519 ChaCha20 PRF: ChaCha20 é uma função pseudorrandômica Poly1305 MAC: Poly1305 é inforjável sob ataque de mensagem escolhida SHA-256 CR: SHA-256 é resistente a colisões HKDF Security: HKDF extrai e expande chaves distribuídas uniformemente Níveis de segurança:\nX25519: ~128 bits de segurança (ordem da curva 2^252) ChaCha20: chaves de 256 bits, segurança de 256 bits Poly1305: segurança de 128 bits (probabilidade de colisão) SHA-256: resistência a colisões de 128 bits, resistência à pré-imagem de 256 bits Gerenciamento de Chaves Geração de Chaves:\n# CRITICAL: Use cryptographically secure RNG def CSRNG(length): # GOOD: os.urandom, secrets.token_bytes (Python) # GOOD: /dev/urandom (Linux) # GOOD: BCryptGenRandom (Windows) # BAD: random.random(), Math.random() (NOT cryptographically secure) return os.urandom(length) # CRITICAL: Validate keys def validate_x25519_key(pubkey): # Check for weak keys (all zeros, small order points) if pubkey == bytes(32): raise WeakKeyError(\u0026#34;All-zero public key\u0026#34;) # Perform DH to check for weak shared secrets test_shared = DH(test_private_key, pubkey) if test_shared == bytes(32): raise WeakKeyError(\u0026#34;Results in zero shared secret\u0026#34;) Armazenamento de chaves:\n# CRITICAL: Protect private keys class SecureKeyStorage: def __init__(self): # Store in memory with protection self.keys = {} # Option 1: Memory locking (prevent swapping to disk) # mlock(self.keys) # Option 2: Encrypted storage # self.encryption_key = derive_from_password() def store_key(self, key_id, private_key): # Option: Encrypt before storage # encrypted = encrypt(private_key, self.encryption_key) # self.keys[key_id] = encrypted self.keys[key_id] = private_key def delete_key(self, key_id): # Securely wipe memory if key_id in self.keys: key = self.keys[key_id] # Overwrite with zeros before deletion for i in range(len(key)): key[i] = 0 del self.keys[key_id] Rotação de chaves:\n# CRITICAL: Rotate keys regularly class KeyRotationPolicy: def __init__(self): self.max_messages_per_tagset = 4096 # Ratchet before 65535 self.max_tagset_age = 10 * 60 # 10 minutes self.max_session_age = 60 * 60 # 1 hour def should_ratchet(self, tagset): return (tagset.messages_sent \u0026gt;= self.max_messages_per_tagset or tagset.age() \u0026gt;= self.max_tagset_age) def should_replace_session(self, session): return session.age() \u0026gt;= self.max_session_age Mitigações de ataques Mitigações de Ataques de Repetição Validação de data e hora:\nMAX_CLOCK_SKEW_PAST = 5 * 60 MAX_CLOCK_SKEW_FUTURE = 2 * 60 def validate_datetime(timestamp): now = int(time.time()) age = now - timestamp if age \u0026lt; -MAX_CLOCK_SKEW_FUTURE: raise ReplayError(\u0026#34;Timestamp too far in future\u0026#34;) if age \u0026gt; MAX_CLOCK_SKEW_PAST: raise ReplayError(\u0026#34;Timestamp too old\u0026#34;) return True Filtro de Bloom para mensagens NS:\nclass ReplayFilter: def __init__(self, capacity=100000, error_rate=0.001, duration=5*60): self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate) self.duration = duration self.entries = [] # (timestamp, ephemeral_key) def check_replay(self, ephemeral_key, timestamp): # Validate timestamp if not validate_datetime(timestamp): return False # Check Bloom filter if ephemeral_key in self.bloom: # Potential replay (or false positive) # Check exact match in entries for ts, key in self.entries: if key == ephemeral_key: return False # Definite replay # Add to filter self.bloom.add(ephemeral_key) self.entries.append((timestamp, ephemeral_key)) # Expire old entries self.expire_old_entries() return True def expire_old_entries(self): now = int(time.time()) self.entries = [(ts, key) for ts, key in self.entries if now - ts \u0026lt; self.duration] Uso único do Session Tag (etiqueta de sessão):\ndef process_session_tag(tag): # Look up tag entry = tagset.lookup_tag(tag) if entry is None: raise ValueError(\u0026#34;Invalid session tag\u0026#34;) # CRITICAL: Remove tag immediately (one-time use) tagset.remove_tag(tag) # Use associated key return entry.key, entry.index Mitigações contra Impersonação por Comprometimento de Chave (KCI) Problema: a autenticação de mensagens do NS é vulnerável a KCI (Key Compromise Impersonation, personificação por comprometimento de chave) (Nível de Autenticação 1)\nMitigação:\nMigre para NSR (Nível de Autenticação 2) o mais rapidamente possível Não confie na carga útil de NS para operações críticas de segurança Aguarde a confirmação de NSR antes de realizar ações irreversíveis def process_ns_message(ns_message): # NS authenticated at Level 1 (KCI vulnerable) # Do NOT perform security-critical operations yet # Extract sender\u0026#39;s static key sender_key = ns_message.static_key # Mark session as pending Level 2 authentication session.auth_level = 1 session.sender_key = sender_key # Send NSR send_nsr_reply(session) def process_first_es_message(es_message): # Now we have Level 2 authentication (KCI resistant) session.auth_level = 2 # Safe to perform security-critical operations process_security_critical_operation(es_message) Mitigações contra ataques de negação de serviço Proteção contra inundação de NS:\nclass NSFloodProtection: def __init__(self): self.ns_count = defaultdict(int) # source -\u0026gt; count self.ns_timestamps = defaultdict(list) # source -\u0026gt; [timestamps] self.max_ns_per_source = 5 self.rate_window = 10 # seconds self.max_concurrent_ns = 100 def check_ns_allowed(self, source): # Global limit total_pending = sum(self.ns_count.values()) if total_pending \u0026gt;= self.max_concurrent_ns: return False # Per-source rate limit now = time.time() timestamps = self.ns_timestamps[source] # Remove old timestamps timestamps = [ts for ts in timestamps if now - ts \u0026lt; self.rate_window] self.ns_timestamps[source] = timestamps # Check rate if len(timestamps) \u0026gt;= self.max_ns_per_source: return False # Allow NS timestamps.append(now) self.ns_count[source] += 1 return True def on_session_established(self, source): # Decrease pending count if self.ns_count[source] \u0026gt; 0: self.ns_count[source] -= 1 Limites de armazenamento de tags:\nclass TagStorageLimit: def __init__(self, max_tags=1000000): self.max_tags = max_tags self.current_tags = 0 def can_create_session(self, look_ahead): if self.current_tags + look_ahead \u0026gt; self.max_tags: return False return True def add_tags(self, count): self.current_tags += count def remove_tags(self, count): self.current_tags -= count Gerenciamento de Recursos Adaptativo:\nclass AdaptiveResourceManager: def __init__(self): self.load_level = 0 # 0 = low, 1 = medium, 2 = high, 3 = critical def adjust_parameters(self): if self.load_level == 0: # Normal operation return { \u0026#39;max_look_ahead\u0026#39;: 160, \u0026#39;max_sessions\u0026#39;: 1000, \u0026#39;session_timeout\u0026#39;: 10 * 60 } elif self.load_level == 1: # Moderate load return { \u0026#39;max_look_ahead\u0026#39;: 80, \u0026#39;max_sessions\u0026#39;: 800, \u0026#39;session_timeout\u0026#39;: 8 * 60 } elif self.load_level == 2: # High load return { \u0026#39;max_look_ahead\u0026#39;: 32, \u0026#39;max_sessions\u0026#39;: 500, \u0026#39;session_timeout\u0026#39;: 5 * 60 } else: # load_level == 3 # Critical load return { \u0026#39;max_look_ahead\u0026#39;: 16, \u0026#39;max_sessions\u0026#39;: 200, \u0026#39;session_timeout\u0026#39;: 3 * 60 } Resistência à Análise de Tráfego Codificação Elligator2:\nGarante que mensagens de handshake (negociação inicial) sejam indistinguíveis de dados aleatórios:\n# NS and NSR start with Elligator2-encoded ephemeral keys # Observer cannot distinguish from random 32-byte string Estratégias de Preenchimento:\n# Resist message size fingerprinting def add_padding(payload, strategy=\u0026#39;random\u0026#39;): if strategy == \u0026#39;random\u0026#39;: # Random padding 0-15 bytes size = random.randint(0, 15) elif strategy == \u0026#39;round\u0026#39;: # Round to next 64-byte boundary target = ((len(payload) + 63) // 64) * 64 size = target - len(payload) - 3 # -3 for block header elif strategy == \u0026#39;fixed\u0026#39;: # Always 1KB messages size = 1024 - len(payload) - 3 return build_padding_block(size) Ataques de temporização:\n# CRITICAL: Use constant-time operations def constant_time_compare(a, b): \u0026#34;\u0026#34;\u0026#34;Constant-time byte string comparison\u0026#34;\u0026#34;\u0026#34; if len(a) != len(b): return False result = 0 for x, y in zip(a, b): result |= x ^ y return result == 0 # CRITICAL: Constant-time MAC verification def verify_mac(computed_mac, received_mac): if not constant_time_compare(computed_mac, received_mac): # Always take same time regardless of where comparison fails raise AuthenticationError(\u0026#34;MAC verification failed\u0026#34;) Armadilhas na Implementação Erros comuns:\nReutilização de Nonce (número usado uma vez): NUNCA reutilize pares (key, nonce) # BAD: Reusing nonce with same key ciphertext1 = ENCRYPT(key, nonce, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce, plaintext2, ad2) # CATASTROPHIC CORRETO: nonce (número usado uma vez) exclusivo para cada mensagem ciphertext1 = ENCRYPT(key, nonce1, plaintext1, ad1) ciphertext2 = ENCRYPT(key, nonce2, plaintext2, ad2) 2. **Ephemeral Key Reuse**: Generate fresh ephemeral key for each NS/NSR ```python # RUIM: Reutilizando chave efêmera ephemeral_key = generate_elg2_keypair() send_ns_message(ephemeral_key) send_ns_message(ephemeral_key) # RUIM # CORRETO: Nova chave para cada mensagem send_ns_message(generate_elg2_keypair()) send_ns_message(generate_elg2_keypair()) Weak RNG: Use cryptographically secure random number generator RUIM: Gerador de números aleatórios não criptográfico import random key = bytes([random.randint(0, 255) for _ in range(32)]) # INSEGURO BOM: Gerador de números aleatórios criptograficamente seguro import os key = os.urandom(32) 4. **Timing Attacks**: Use constant-time comparisons ```python # RUIM: Comparação com saída antecipada if computed_mac == received_mac: # Vazamento de temporização pass # BOM: Comparação em tempo constante if constant_time_compare(computed_mac, received_mac): pass Incomplete MAC Verification: Always verify before using data RUIM: Descriptografando antes da verificação plaintext = chacha20_decrypt(key, nonce, ciphertext) mac_ok = verify_mac(mac, plaintext) # TARDE DEMAIS if not mac_ok: return error CORRETO: AEAD verifica antes de decifrar try: plaintext = DECRYPT(key, nonce, ciphertext, ad) # Verifies MAC first except AuthenticationError:\nreturn error 6. **Key Deletion**: Securely wipe keys from memory ```python # RUIM: Exclusão simples del private_key # Ainda na memória # CORRETO: Sobrescrever antes da exclusão for i in range(len(private_key)): private_key[i] = 0 del private_key Security Audits Recommended Audits:\nCryptographic Review: Expert review of KDF chains and DH operations Implementation Audit: Code review for timing attacks, key management, RNG usage Protocol Analysis: Formal verification of handshake security properties Side-Channel Analysis: Timing, power, and cache attacks Fuzzing: Random input testing for parser robustness Test Cases:\n# Casos de teste críticos para a segurança def test_nonce_uniqueness(): \u0026#34;\u0026#34;\u0026#34;Ensure nonces are never reused\u0026#34;\u0026#34;\u0026#34; nonces = set() for i in range(10000): nonce = construct_nonce(i) assert nonce not in nonces nonces.add(nonce) def test_key_isolation(): \u0026#34;\u0026#34;\u0026#34;Ensure sessions don\u0026#39;t share keys\u0026#34;\u0026#34;\u0026#34; session1 = create_session(destination1) session2 = create_session(destination2) assert session1.key != session2.key def test_replay_prevention(): \u0026#34;\u0026#34;\u0026#34;Ensure replay attacks are detected\u0026#34;\u0026#34;\u0026#34; ns_message = create_ns_message() # First delivery succeeds assert process_ns_message(ns_message) == True # Replay fails assert process_ns_message(ns_message) == False def test_mac_verification(): \u0026#34;\u0026#34;\u0026#34;Ensure MAC verification is enforced\u0026#34;\u0026#34;\u0026#34; key = CSRNG(32) nonce = construct_nonce(0) plaintext = b\u0026#34;test\u0026#34; ad = b\u0026#34;test_ad\u0026#34; ciphertext = ENCRYPT(key, nonce, plaintext, ad) # Correct MAC verifies assert DECRYPT(key, nonce, ciphertext, ad) == plaintext # Corrupted MAC fails corrupted = ciphertext[:-1] + bytes([ciphertext[-1] ^ 0xFF]) with pytest.raises(AuthenticationError): DECRYPT(key, nonce, corrupted, ad) Configuration and Deployment I2CP Configuration Enable ECIES Encryption:\n# Somente ECIES (recomendado para novas implantações) i2cp.leaseSetEncType=4 # Chave dupla (ECIES + ElGamal para compatibilidade) i2cp.leaseSetEncType=4,0 # Somente ElGamal (legado, não recomendado) i2cp.leaseSetEncType=0 LeaseSet Type:\n# LS2 padrão (mais comum) i2cp.leaseSetType=3 # LS2 criptografado (blinded destinations — destinos cegos) i2cp.leaseSetType=5 # Meta LS2 (múltiplos destinos; versão 2 de leaseSet) i2cp.leaseSetType=7 Additional Options:\n# Chave estática para ECIES (esquema de criptografia integrada de curva elíptica) (opcional, gerada automaticamente se não for especificada) # Chave pública X25519 de 32 bytes, codificada em base64 i2cp.leaseSetPrivateKey=\u0026lt;base64-encoded-key\u0026gt; # Tipo de assinatura (para LeaseSet) i2cp.leaseSetSigningPrivateKey=\u0026lt;base64-encoded-key\u0026gt; i2cp.leaseSetSigningType=7 # Ed25519 Java I2P Configuration router.config:\n# ECIES de router para router i2p.router.useECIES=true Build Properties:\n// Para clientes I2CP (Java) Properties props = new Properties(); props.setProperty(\u0026#34;i2cp.leaseSetEncType\u0026#34;, \u0026#34;4\u0026#34;); props.setProperty(\u0026#34;i2cp.leaseSetType\u0026#34;, \u0026#34;3\u0026#34;); I2PSession session = i2pClient.createSession(props); i2pd Configuration i2pd.conf:\n[limites] # Limite de memória das sessões de ECIES (Esquema Integrado de Criptografia com Curvas Elípticas) ecies.memory = 128M [ecies] # Ativar ECIES (Esquema de Criptografia Integrada de Curvas Elípticas) enabled = true # Apenas ECIES (esquema integrado de criptografia com curvas elípticas) ou dual-key (chave dupla) compatibility = true # true = chave dupla, false = apenas ECIES Tunnels Configuration:\n[my-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Apenas ECIES (Esquema Integrado de Criptografia com Curvas Elípticas) ecies = true Compatibility Matrix Router Version Support:\nVersion ECIES Support LS2 Support Dual-Key Notes \u0026lt; 0.9.38 ❌ No ❌ No N/A Legacy only 0.9.38-0.9.45 ❌ No ✅ Yes N/A LS2 only 0.9.46-0.9.50 ✅ Yes ✅ Yes ✅ Yes Initial ECIES 1.5.0+ ✅ Yes ✅ Yes ✅ Yes Current 2.0.0+ ✅ Yes ✅ Yes ✅ Yes Current Destination Compatibility:\nDestination Type Can Connect To Notes ECIES-only ECIES-only, Dual-key Requires 0.9.46+ routers Dual-key Any Maximum compatibility ElGamal-only ElGamal-only, Dual-key Legacy FloodFill Requirements:\nECIES-only destinations: Require majority of floodfills on 0.9.46+ for encrypted lookups Dual-key destinations: Work with any floodfill version Current status: Near 100% floodfill adoption as of 2025 Migration Guide Migrating from ElGamal to ECIES:\nStep 1: Enable Dual-Key Mode\n# Adicionar ECIES (Esquema de Criptografia Integrado de Curvas Elípticas) mantendo ElGamal (esquema de criptografia de chave pública ElGamal) i2cp.leaseSetEncType=4,0 Step 2: Monitor Connections\n# Verifique os tipos de conexão i2prouter.exe status # ou http://127.0.0.1:7657/peers Step 3: Switch to ECIES-Only (after testing)\n# Remover ElGamal i2cp.leaseSetEncType=4 Step 4: Restart Application\n# Reinicie o I2P router ou o aplicativo systemctl restart i2p # ou i2prouter.exe restart Rollback Plan:\n# Reverter para apenas ElGamal em caso de problemas i2cp.leaseSetEncType=0 Performance Tuning Session Limits:\n# Número máximo de sessões de entrada i2p.router.maxInboundSessions=1000 # Máximo de sessões de saída i2p.router.maxOutboundSessions=1000 # Tempo limite da sessão (segundos) i2p.router.sessionTimeout=600 Memory Limits:\n# Limite de armazenamento de tags (KB) i2p.ecies.maxTagMemory=10240 # 10 MB # Janela de antecipação i2p.ecies.tagLookAhead=160 i2p.ecies.tagLookAheadMin=32 Ratchet Policy:\n# Mensagens anteriores ao ratchet (mecanismo de catraca criptográfica) i2p.ecies.ratchetThreshold=4096 # Tempo antes do ratchet (mecanismo de avanço de chaves) (segundos) i2p.ecies.ratchetTimeout=600 # 10 minutos Monitoring and Debugging Logging:\n# Ativar o registro de depuração do ECIES (esquema de criptografia integrada de curvas elípticas) logger.i2p.router.transport.ecies=DEBUG Metrics:\nMonitor these metrics:\nNS Success Rate: Percentage of NS messages receiving NSR Session Establishment Time: Time from NS to first ES Tag Storage Usage: Current memory usage for tags Ratchet Frequency: How often sessions ratchet Session Lifetime: Average session duration Common Issues:\nNS Timeout: No NSR received\nCheck destination is online Check floodfill availability Verify LeaseSet published correctly High Memory Usage: Too many tags stored\nReduce look-ahead window Decrease session timeout Implement aggressive expiration Frequent Ratchets: Sessions ratcheting too often\nIncrease ratchet threshold Check for retransmissions Session Failures: ES messages failing to decrypt\nVerify tag synchronization Check for replay attacks Validate nonce construction References Specifications ECIES Proposal: Proposal 144 I2NP: I2NP Specification Common Structures: Common Structures Specification NTCP2: NTCP2 Specification SSU2: SSU2 Specification I2CP: I2CP Specification ElGamal/AES+SessionTags: ElGamal/AES Specification Cryptographic Standards Noise Protocol Framework: Noise Specification (Revision 34, 2018-07-11) Signal Double Ratchet: Signal Specification RFC 7748: Elliptic Curves for Security (X25519) RFC 7539: ChaCha20 and Poly1305 for IETF Protocols RFC 5869: HKDF (HMAC-based Key Derivation Function) RFC 2104: HMAC: Keyed-Hashing for Message Authentication Elligator2: Elligator Paper Implementation Resources Java I2P: i2p.i2p Repository i2pd (C++): i2pd Repository OBFS4 (Elligator2): obfs4proxy Repository Additional Information I2P Website: / I2P Forum: https://i2pforum.net I2P Wiki: https://wiki.i2p-projekt.de Appendix A: KDF Summary All KDF Operations in ECIES:\nOperation Input Info String Output NS Initial ChainKey protocol_name (none - SHA256) h, chainKey NS Static Key Section chainKey, es_shared \"\" chainKey, k NS Payload Section (bound) chainKey, ss_shared \"\" chainKey, k NSR Tagset chainKey \"SessionReplyTags\" tagsetKey NSR ee DH chainKey, ee_shared \"\" chainKey NSR se DH chainKey, se_shared \"\" chainKey, k NSR Split chainKey \"\" k_ab, k_ba NSR Payload k_ba \"AttachPayloadKDF\" k_nsr DH Initialize rootKey, k \"KDFDHRatchetStep\" nextRootKey, chainKey Tag and Key Chain Keys chainKey \"TagAndKeyGenKeys\" sessTag_ck, symmKey_ck Session Tag Init sessTag_ck \"STInitialization\" chainKey, CONSTANT Session Tag Gen chainKey, CONSTANT \"SessionTagKeyGen\" chainKey, tag Symmetric Key Gen chainKey \"SymmetricRatchet\" chainKey, key DH Ratchet sharedSecret \"XDHRatchetTagSet\" tagsetKey Appendix B: Message Size Calculator Calculate message sizes for capacity planning:\ndef calculate_ns_size(payload_size, bound=True): \u0026#34;\u0026#34;\u0026#34;Calculate New Session message size\u0026#34;\u0026#34;\u0026#34; ephemeral_key = 32 static_section = 32 + 16 # encrypted + MAC payload_encrypted = payload_size + 16 # + MAC return ephemeral_key + static_section + payload_encrypted def calculate_nsr_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate New Session Reply message size\u0026#34;\u0026#34;\u0026#34; tag = 8 ephemeral_key = 32 key_section_mac = 16 payload_encrypted = payload_size + 16 # + MAC return tag + ephemeral_key + key_section_mac + payload_encrypted def calculate_es_size(payload_size): \u0026#34;\u0026#34;\u0026#34;Calculate Existing Session message size\u0026#34;\u0026#34;\u0026#34; tag = 8 payload_encrypted = payload_size + 16 # + MAC return tag + payload_encrypted # Exemplos print(\u0026#34;NS (bound, 1KB payload):\u0026#34;, calculate_ns_size(1024, bound=True), \u0026#34;bytes\u0026#34;) # Saída: 1120 bytes print(\u0026#34;NSR (1KB payload):\u0026#34;, calculate_nsr_size(1024), \u0026#34;bytes\u0026#34;) # Saída: 1096 bytes print(\u0026#34;ES (carga útil de 1KB):\u0026#34;, calculate_es_size(1024), \u0026#34;bytes\u0026#34;) # Saída: 1048 bytes Appendix C: Glossary AEAD: Authenticated Encryption with Associated Data - encryption mode that provides both confidentiality and authenticity\nAuthentication Level: Noise protocol security property indicating strength of sender identity verification\nBinding: Association of a session with a specific far-end destination\nChaCha20: Stream cipher designed by Daniel J. Bernstein\nChainKey: Cryptographic key used in HKDF chains to derive subsequent keys\nConfidentiality Level: Noise protocol security property indicating strength of forward secrecy\nDH: Diffie-Hellman key agreement protocol\nElligator2: Encoding technique to make elliptic curve points indistinguishable from random\nEphemeral Key: Short-lived key used only for a single handshake\nES: Existing Session message (used after handshake completion)\nForward Secrecy: Property ensuring past communications remain secure if keys are compromised\nGarlic Clove: I2NP message container for end-to-end delivery\nHKDF: HMAC-based Key Derivation Function\nIK Pattern: Noise handshake pattern where initiator sends static key immediately\nKCI: Key Compromise Impersonation attack\nKDF: Key Derivation Function - cryptographic function for generating keys from other keys\nLeaseSet: I2P structure containing a destination\u0026rsquo;s public keys and tunnel information\nLS2: LeaseSet version 2 with encryption type support\nMAC: Message Authentication Code - cryptographic checksum proving authenticity\nMixHash: Noise protocol function for maintaining running hash transcript\nNS: New Session message (initiates new session)\nNSR: New Session Reply message (response to NS)\nNonce: Number used once - ensures unique encryption even with same key\nPairing: Linking an inbound session with an outbound session for bidirectional communication\nPoly1305: Message authentication code designed by Daniel J. Bernstein\nRatchet: Cryptographic mechanism for deriving sequential keys\nSession Tag: 8-byte one-time identifier for existing session messages\nStatic Key: Long-term key associated with a destination\u0026rsquo;s identity\nTag Set: Collection of session tags derived from a common root\nX25519: Elliptic curve Diffie-Hellman key agreement using Curve25519\n","description":"Esquema de Criptografia Integrada de Curvas Elípticas para o I2P (X25519 + AEAD (Criptografia Autenticada com Dados Associados))","id":"82b727dd29ed7e2e04873dac8c2acf51","section":"docs","title":"Especificação de Criptografia do ECIES-X25519-AEAD-Ratchet","url":"/pt/docs/specs/ecies/"},{"categories":null,"content":"Visão geral Este documento especifica o formato de arquivo blockfile do I2P e as tabelas no hostsdb.blockfile usadas pelo Blockfile Naming Service (serviço de nomes Blockfile). Para contexto, consulte Nomes no I2P e Livro de Endereços .\nO blockfile (arquivo em blocos) possibilita consultas rápidas de destinos em um formato binário compacto. Em comparação com o sistema legado hosts.txt:\nDestinos são armazenados em binário, não em Base64. Metadados arbitrários (por exemplo, data de adição, origem, comentários) podem ser anexados. Os tempos de consulta são aproximadamente 10× mais rápidos. O uso de disco aumenta modestamente. Um blockfile (arquivo de blocos) é uma coleção em disco de mapas ordenados (pares chave-valor) implementada como skiplists (listas de salto). Foi derivado do Metanotion Blockfile Database . Esta especificação primeiro define a estrutura do arquivo, depois descreve como ela é usada pelo BlockfileNamingService.\nO Blockfile Naming Service (serviço de nomes Blockfile) substituiu a implementação antiga de hosts.txt no I2P 0.8.8. \u0026gt; Na inicialização, ele importa entradas de privatehosts.txt, userhosts.txt e hosts.txt.\nFormato do Blockfile (arquivo de blocos) O formato é composto por páginas de 1024 bytes, cada uma prefixada por um número mágico para integridade. As páginas são numeradas a partir de 1:\nPage Description 1 Superblock (starts at byte 0) 2 Metaindex skiplist (starts at byte 1024) Todos os inteiros usam **ordem de bytes de rede (big-endian, byte mais significativo primeiro)**. Os valores de 2 bytes são sem sinal; os valores de 4 bytes (números de página) são com sinal e devem ser positivos. Uso de threads: O banco de dados é projetado para acesso por uma única thread; BlockfileNamingService fornece sincronização.\nFormato do Superbloco Byte Contents 0-5 Magic number 0x3141de493250 (\"1A\" 0xde \"I2P\") 6 Major version 0x01 7 Minor version 0x02 8-15 File length (in bytes) 16-19 First free list page 20-21 Mounted flag (0x01 = yes) 22-23 Span size (max key/value pairs per span, 16 for hostsdb) 24-27 Page size (as of v1.2; 1024 before that) 28-1023 Unused --- Formato da página de bloco de lista de saltos Byte Contents 0-7 Magic 0x536b69704c697374 (\"SkipList\") 8-11 First span page 12-15 First level page 16-19 Size (total keys, valid at startup) 20-23 Spans (total spans, valid at startup) 24-27 Levels (total levels, valid at startup) 28-29 Span size (as of v1.2; used for new spans) 30-1023 Unused --- Formato da Página de Bloqueio de Skip Level (pular nível) Todo nível tem um intervalo, mas nem todos os intervalos têm níveis.\nByte Contents 0-7 Magic 0x42534c6576656c73 (\"BSLevels\") 8-9 Max height 10-11 Current height 12-15 Span page 16-… Next level pages (current height × 4 bytes, lowest first) \u0026mdash; Remaining bytes unused --- Formato da Página do Bloco Skip Span Pares chave/valor são ordenados pela chave entre spans (segmentos). Spans não iniciais não podem estar vazios.\nByte Contents 0-3 Magic 0x5370616e (\"Span\") 4-7 First continuation page or 0 8-11 Previous span page or 0 12-15 Next span page or 0 16-17 Max keys (16 for hostsdb) 18-19 Size (current keys) 20-1023 Key/value structures --- Formato de Página do Bloco de Continuação de Span (elemento HTML span) Byte Contents 0-3 Magic 0x434f4e54 (\"CONT\") 4-7 Next continuation page or 0 8-1023 Key/value structures --- Formato da Estrutura Chave/Valor Os campos de comprimento de chave e de valor não podem atravessar páginas (todos os 4 bytes devem caber). Se não restar espaço suficiente, preencha com até 3 bytes de padding e continue no deslocamento 8 da próxima página.\nByte Contents 0-1 Key length (bytes) 2-3 Value length (bytes) 4-… Key data → Value data \u0026mdash; Max length = 65535 bytes each --- Formato da Página de Blocos da Lista Livre Byte Contents 0-7 Magic 0x2366724c69737423 (\"#frList#\") 8-11 Next free list block or 0 12-15 Number of valid free pages (0 – 252) 16-1023 Free page numbers (4 bytes each) --- Formato do Bloco de Página Livre Byte Contents 0-7 Magic 0x7e2146524545217e (\"~!FREE!~\") 8-1023 Unused --- Metaíndice Localizado na página 2. Mapeia strings US-ASCII → inteiros de 4 bytes. A chave é o nome do skiplist (lista de salto); o valor é o índice da página.\nTabelas do Blockfile Naming Service (serviço de nomes baseado em arquivo de blocos) O serviço define várias skiplists (listas de salto). Cada span (intervalo) suporta até 16 elementos.\nLista de salto de propriedades %%__INFO__%% contém uma entrada:\nKey Value info A Properties object (UTF-8 String / String map) serialized as a Mapping Campos típicos: Property Description version \"4\" created Java long (ms since epoch) upgraded Java long (ms since epoch, since DB v2) lists Comma-separated host DBs (e.g. privatehosts.txt,userhosts.txt,hosts.txt) listversion_* Version of each DB (used to detect partial upgrades, since v4) --- Skiplist de Consulta Reversa (lista de saltos) %%__REVERSE__%% contém entradas do tipo Inteiro → Propriedades (desde o DB v2).\nChave: Primeiros 4 bytes do hash SHA-256 da Destination (identificador criptográfico do serviço no I2P). Valor: objeto Properties (mapeamento serializado). Várias entradas tratam colisões e Destinations com múltiplos nomes de host. Cada chave de propriedade = hostname; valor = string vazia. Skiplists (listas de salto) do banco de dados de hosts Cada um de hosts.txt, userhosts.txt e privatehosts.txt mapeia nomes de host → Destinos.\nA versão 4 oferece suporte a vários Destinos por nome de host (introduzido no I2P 0.9.26). Os bancos de dados da versão 3 são migrados automaticamente.\nChave string UTF-8 (nome de host, em minúsculas, terminando em .i2p)\nValor Versão 4: 1 byte contendo a contagem de pares Propriedade/Destino Para cada par: Propriedades → Destino (binário) Versão 3: Propriedades → Destino (binário) Propriedades de DestEntry Key Meaning a Time added (Java long ms) m Last modified (Java long ms) notes User comments s Source (file or subscription URL) v Signature verified (true/false) --- Notas de Implementação A classe Java BlockfileNamingService implementa esta especificação.\nFora do contexto do router, o banco de dados abre como somente leitura a menos que i2p.naming.blockfile.writeInAppContext=true. Não é destinado a acesso por múltiplas instâncias ou múltiplas JVMs. Mantém três mapas principais (privatehosts, userhosts, hosts) e um mapa reverso para buscas rápidas. Referências Documentação de Nomes e Livro de Endereços do I2P Especificação de Estruturas Comuns Banco de dados Blockfile da Metanotion JavaDoc de BlockfileNamingService ","description":"Formato de armazenamento em disco do tipo blockfile (arquivo em blocos) usado pelo I2P para resolução de nomes de host","id":"5cbdbb030530ec5e0200cc202d4bff7f","section":"docs","title":"Especificação do Blockfile","url":"/pt/docs/specs/blockfile/"},{"categories":null,"content":"1. Visão geral SSU2 é um protocolo de camada de transporte baseado em UDP usado para comunicação segura e semi-confiável entre routers no I2P. Não é um transporte de uso geral; é especializado na troca de mensagens I2NP.\nCapacidades essenciais Troca de chaves autenticada via Noise XK pattern (padrão XK de handshake do Noise) Cabeçalhos criptografados para resistência a DPI (inspeção profunda de pacotes) Travessia de NAT usando relés e hole punching (perfuração de NAT) Migração de conexão e validação de endereço Validação de caminho opcional Sigilo futuro (forward secrecy) e proteção contra ataques de repetição Legado e Compatibilidade Implementation SSU2 Default SSU1 Removed i2pd2.44.02.44.0 Java I2P0.9.560.9.61 SSU1 (versão 1 do protocolo SSU do I2P) não está mais em uso na rede pública do I2P. 2. Criptografia SSU2 utiliza Noise_XK_25519_ChaChaPoly_SHA256 (suíte criptográfica do Noise: X25519, ChaCha20-Poly1305 e SHA-256) com extensões específicas do I2P.\nFunction Algorithm Notes Diffie-HellmanX25519 (RFC 7748)32-byte keys CipherChaCha20/Poly1305 (RFC 7539)AEAD encryption HashSHA-256Used for key derivation and message integrity KDFHKDF-SHA256 (RFC 5869)For session and header keys Os cabeçalhos e as cargas úteis são vinculados criptograficamente via `mixHash()`. Todas as primitivas criptográficas são compartilhadas com NTCP2 e ECIES para eficiência na implementação. 3. Visão geral da mensagem 3.1 Regras de Datagramas UDP Cada datagrama UDP transporta exatamente uma mensagem SSU2. Mensagens Session Confirmed (confirmação de sessão) podem ser fragmentadas em vários datagramas. Tamanho mínimo: 40 bytes Tamanho máximo: 1472 bytes (IPv4) / 1452 bytes (IPv6)\n3.2 Tipos de Mensagem Type Message Header Description 0Session Request32BHandshake initiation 1Session Created32BHandshake response 2Session Confirmed16BFinal handshake, may be fragmented 6Data16BEncrypted I2NP message blocks 7Peer Test32BNAT reachability testing 9Retry32BToken or rejection notice 10Token Request32BRequest for validation token 11Hole Punch32BNAT traversal signaling --- 4. Estabelecimento de Sessão 4.1 Fluxo Padrão (Token Válido) Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.2 Aquisição de token Alice Bob TokenRequest ───────────────\u0026gt; \u0026lt;────────────── Retry (Token) SessionRequest ─────────────\u0026gt; \u0026lt;────────────── SessionCreated SessionConfirmed ────────────\u0026gt; 4.3 Token inválido Alice Bob SessionRequest ─────────────\u0026gt; \u0026lt;────────────── Retry (Termination) 5. Estruturas de Cabeçalho 5.1 Cabeçalho longo (32 bytes) Usado antes do estabelecimento da sessão (SessionRequest, Created, Retry, PeerTest, TokenRequest, HolePunch).\nField Size Description Destination Connection ID8Random unique ID Packet Number4Random (ignored during handshake) Type1Message type Version1Always 2 NetID12 = main I2P network Flags1Reserved (0) Source Connection ID8Random ID distinct from destination Token8Token for address validation ### 5.2 Cabeçalho curto (16 bytes) Utilizado durante sessões estabelecidas (SessionConfirmed, Data).\nField Size Description Destination Connection ID8Stable throughout session Packet Number4Incrementing per message Type1Message type (2 or 6) Flags3ACK/fragment flags --- 6. Criptografia 6.1 AEAD (Criptografia autenticada com dados associados) Todas as cargas úteis são criptografadas com ChaCha20/Poly1305 AEAD:\nciphertext = ChaCha20_Poly1305_Encrypt(key, nonce, plaintext, associated_data) Nonce: 12 bytes (4 zeros + 8 de contador) Tag: 16 bytes Dados Associados: inclui o cabeçalho para vinculação de integridade 6.2 Proteção do Cabeçalho Os cabeçalhos são mascarados utilizando um fluxo de chaves ChaCha20 derivado das chaves do cabeçalho da sessão. Isso garante que todos os IDs de conexão e os campos dos pacotes pareçam aleatórios, proporcionando resistência à inspeção profunda de pacotes (DPI).\n6.3 Derivação de Chaves Phase Input Output InitialintroKey + salthandshake header key HandshakeDH(X25519)chainKey + AEAD key Data phasechainKeyTX/RX keys Key rotationoldKeynewKey --- 7. Segurança e Prevenção de Ataques de Repetição Tokens são por endereço IP, expirando em ~60 segundos. Ataques de repetição são evitados por meio de filtros de Bloom por sessão. Chaves efêmeras duplicadas são rejeitadas. Cabeçalhos e cargas úteis estão criptograficamente vinculados. Routers devem descartar qualquer pacote que falhe na autenticação AEAD ou que tenha versão ou NetID inválidos.\n8. Numeração de Pacotes e Duração da Sessão Cada direção mantém seu próprio contador de 32 bits. - Inicia em 0, incrementa a cada pacote. - Não deve dar volta; faça rekey da sessão (troca de chaves) ou encerre antes de atingir 2³².\nOs IDs de conexão permanecem estáticos durante toda a sessão, inclusive durante a migração.\n9. Fase de Dados Tipo = 6 (Dados) Cabeçalho curto (16 bytes) A carga útil contém um ou mais blocos criptografados: Listas de ACK/NACK Fragmentos de mensagens I2NP Preenchimento (0–31 bytes aleatórios) Blocos de terminação (opcional) Retransmissão seletiva e entrega fora de ordem são suportadas. A confiabilidade permanece “semi-confiável” — pacotes perdidos podem ser descartados silenciosamente após atingir os limites de tentativas.\n10. Retransmissão e NAT Traversal (travessia de NAT) Message Type Purpose Peer Test7Determines inbound reachability Retry9Issues new token or rejection Token Request10Requests new address token Hole Punch11Coordinates NAT hole punching Routers de retransmissão auxiliam pares atrás de NATs restritivos usando estas mensagens de controle. 11. Encerramento da Sessão Qualquer par pode encerrar a sessão usando um Termination block (bloco de terminação) dentro de uma mensagem de dados. Os recursos devem ser liberados imediatamente após o recebimento. Pacotes de terminação repetidos podem ser ignorados após a confirmação.\n12. Diretrizes de Implementação Routers DEVEM: - Validar versão = 2 e NetID = 2. - Descartar pacotes \u0026lt;40 bytes ou AEAD inválido. - Impor cache de replay de 120s. - Rejeitar tokens reutilizados ou chaves efêmeras.\nRouters DEVERIAM: - Randomizar o tamanho do preenchimento entre 0 e 31 bytes. - Usar retransmissão adaptativa (RFC 6298). - Implementar validação de caminho por par antes da migração.\n13. Resumo de segurança Property Achieved By Forward secrecyX25519 ephemeral keys Replay protectionTokens + Bloom filter Authenticated encryptionChaCha20/Poly1305 KCI resistanceNoise XK pattern DPI resistanceEncrypted headers NAT traversalRelay + Hole Punch MigrationStatic connection IDs --- 14. Referências Proposta 159 – SSU2 Framework do Protocolo Noise RFC 9000 – Transporte QUIC RFC 9001 – TLS do QUIC RFC 7539 – ChaCha20/Poly1305 AEAD (Autenticação e Criptografia com Dados Associados) RFC 7748 – X25519 ECDH (Diffie-Hellman de Curvas Elípticas) RFC 5869 – HKDF-SHA256 (Função de Derivação de Chaves baseada em HMAC com SHA-256) ","description":"Protocolo de Transporte UDP Seguro e Semi-Confiável Versão 2","id":"b45756033b706b68daaee09f536f3c91","section":"docs","title":"Especificação do SSU2","url":"/pt/docs/specs/ssu2/"},{"categories":null,"content":"Visão geral Este documento especifica um esquema de assinatura re-randomizável, adequado para criar Destinations (endereços de destino do I2P) que podem ser cegados. Além disso, pode ser usado para cegar Destinations Ed25519 existentes, com uma ligeira redução de eficácia.\nRed25519 tem estado totalmente operacional em I2P routers desde a versão 0.9.39 (lançada em 21 de março de 2019). Esta especificação foi finalizada na versão 0.9.47 (agosto de 2020) após 17 meses de implantação em produção. O esquema de assinatura opera como o tipo de assinatura 11 (RedDSA_SHA512_Ed25519) na rede I2P.\nMotivação A Proposta 123 (Novas entradas no netDB) define um formato de LeaseSet2 criptografado que incorpora o Princípio da Menor Autoridade: cada participante da rede recebe apenas as informações necessárias para sua função. Em particular, um LeaseSet2 criptografado publicado em um floodfill não revela o Destino ao qual se destina, e as Leases (registros temporários de túnel) só podem ser visualizadas por alguém com conhecimento prévio do Destino. No entanto, os floodfills ainda precisam ser capazes de autenticar os LeaseSet2 criptografados quando são publicados, e os clientes precisam, adicionalmente, garantir que a autenticação foi aplicada pelo próprio Destino.\nA Proposta 123 realiza isso aplicando cegamento às chaves de assinatura de Destinations (identidade/endereço de serviço no I2P). As chaves cegadas podem ser usadas para criar assinaturas verificáveis pelos floodfills, e os clientes podem ter certeza de que somente a Destination poderia ter criado as assinaturas. Portanto, é necessário especificar um esquema de assinatura que possa ser usado para cegamento.\nNota sobre o status da Proposta 123: Partes da Proposta 123 foram implementadas e implantadas progressivamente desde a versão 0.9.38, com suporte a Red25519 adicionado na 0.9.39. A funcionalidade de LeaseSet2 criptografado está pronta para produção e é usada ativamente na rede I2P para serviços ocultos com privacidade aprimorada.\nProjeto Esquema de assinatura principal O esquema de assinatura especificado aqui, Red25519, é uma instanciação de RedDSA conforme definido na Seção 5.4.6 da Especificação do Protocolo Zcash (Sapling e posteriores). RedDSA é um esquema de assinatura baseado em Schnorr que suporta re-randomização de chaves. Ele possui as seguintes funções:\nGENERATE_PRIVATE() : Retorna uma chave privada aleatória com distribuição uniforme.\nDERIVE_PUBLIC(sk) : Retorna a chave pública correspondente à chave privada fornecida.\nGENERATE_RANDOM() : Retorna um escalar aleatório adequado para re-randomizar um par de chaves.\nRANDOMIZE_PRIVATE(sk, alpha) : Aleatoriza novamente uma chave privada, usando um escalar secreto alpha.\nRANDOMIZE_PUBLIC(vk, alpha) : Re-randomiza uma chave pública, usando um escalar secreto alpha.\nSIGN(sk, m) : Retorna uma assinatura com a chave privada sk sobre a mensagem m fornecida.\nVERIFY(vk, m, sig) : Verifica a assinatura sig com base na chave pública vk e na mensagem m. Retorna verdadeiro se a assinatura for válida, falso caso contrário.\nPara um dado par de chaves (sk, vk), verifica-se a seguinte relação:\nRANDOMIZE_PUBLIC(vk, alpha) == DERIVE_PUBLIC(RANDOMIZE_PRIVATE(sk, alpha)) Convertendo chaves Ed25519 para Red25519 As chaves Ed25519 PODEM ser convertidas, de forma transitória e unidirecional, em chaves Red25519, a fim de suportar a rerandomização de Destinos Ed25519 existentes. Outros tipos de assinatura não são compatíveis.\nDefinimos as seguintes funções de conversão:\nCONVERT_ED25519_PRIVATE(privkey) : Retorna a chave privada Red25519 (forma derivada de Ed25519) correspondente à chave privada Ed25519 fornecida.\nCONVERT_ED25519_PUBLIC(pubkey) : Retorna a chave pública Red25519 correspondente à chave pública Ed25519 fornecida.\nPara um determinado par de chaves Ed25519 (algoritmo de assinatura digital de curva elíptica) (privkey, pubkey), verifica-se a seguinte relação:\nCONVERT_ED25519_PUBLIC(pubkey) == DERIVE_PUBLIC(CONVERT_ED25519_PRIVATE(privkey)) Especificação Definições B : O ponto base do Ed25519 conforme definido no RFC 8032 .\nL : A ordem de Ed25519 é 2^252 + 27742317777372353535851937790883648493, como no RFC 8032 .\n[s] B : Multiplicação escalar de base fixa do ponto base por s.\n[s] A : Multiplicação escalar de base variável de A por s.\nx || y : Concatenar dois arrays de bytes x e y.\nRed25519 (algoritmo de assinatura digital baseado em Ed25519 utilizado no I2P) O esquema Red25519 especializa o RedDSA com:\nG := o grupo de pontos na forma de Edwards da Curve25519. Em particular, isso significa que a Red25519 usa o subgrupo de ordem L (sendo L primo), e o cofator h_G é 8. P_G := o ponto base B da Ed25519. l_H := 512 H(x) := SHA-512(\u0026ldquo;I2P_Red25519H(x)\u0026rdquo; || x) Nota sobre a escolha da função de hash: Red25519 usa SHA-512 em vez de BLAKE2b-512 (como usado em Zcash RedDSA). Essa escolha de design é compensada pela proteção por prefixação de comprimento descrita abaixo. I2P Proposal 148 sugere uma migração futura para BLAKE2b-512 para oferecer proteção aprimorada contra identificação de mensagens duplicadas (DMI) e ataques de extensão de comprimento (LEA), além de desempenho aprimorado.\nRedDSA pressupõe que H(x) é instanciada com uma função hash criptográfica que é segura contra ataques de extensão de comprimento. SHA-512 não satisfaz isso por si só. Para corrigir isso, exigimos que as mensagens sejam precedidas por uma codificação livre de prefixo do seu comprimento:\nlen_u16(M) || M onde len_u16(M) é a representação de 2 bytes do comprimento de M, em little-endian (para ser consistente com a codificação little-endian de escalares e pontos).\nAs mensagens não devem exceder 65534 bytes. Um tamanho de 65535 está reservado para possíveis extensões futuras.\nNota de Segurança: A inclusão da chave pública (vk) na função de hash, combinada com 80 bytes aleatórios na assinatura, garante proteção contra vulnerabilidades de SURK-CMA (Strong Unforgeability with Re-randomized Keys under Chosen Message Attack — inforgeabilidade forte com chaves re-randomizadas sob ataque de mensagem escolhida) descobertas em projetos iniciais do RedDSA. Esta implementação incorpora as correções de segurança da auditoria do NCC Group sobre o Zcash (Achado NCC-Zcash2018-009).\nCodificação e decodificação As chaves privadas Red25519 são escalares mod L, codificadas na representação little-endian (ordem de bytes do menos significativo para o mais significativo). Definimos as funções DECODE_SCALAR e ENCODE_SCALAR para converter entre o array de bytes e a forma inteira de um escalar.\nAs chaves públicas Red25519 são pontos na forma de Edwards da Curve25519. Elas são codificadas como a representação little-endian de 255 bits da coordenada y, seguida por um único bit indicando o sinal da coordenada x. É a mesma codificação usada em Ed25519. Definimos as funções DECODE_POINT e ENCODE_POINT para converter entre o array de bytes e a forma em coordenadas de um ponto.\nFunções do RedDSA Para facilitar a implementação, apresentamos explicitamente abaixo as funções RedDSA (bem como várias funções auxiliares) já especializadas para Red25519. Os implementadores devem consultar a seção 5.4.6 da Zcash Protocol Specification para a especificação geral das funções RedDSA.\nHStar(prefix1, prefix2, m) := h = SHA-512() h.input(\u0026#34;I2P_Red25519H(x)\u0026#34;) h.input(prefix1) h.input(prefix2) h.input(len(m) \u0026amp; 0xff) h.input((len(m) \u0026gt;\u0026gt; 8) \u0026amp; 0xff) h.input(m) s = h.digest() return s mod L GENERATE_PRIVATE := s = 64 random bytes return s mod L DERIVE_PUBLIC(sk) := [sk] B GENERATE_RANDOM := s = 64 random bytes return s mod L RANDOMIZE_PRIVATE(sk, alpha) := (sk + alpha) mod L RANDOMIZE_PUBLIC(vk, alpha) := vk + [alpha] B SIGN(sk, m) := T = 80 random bytes vkBytes = ENCODE_POINT(DERIVE_PUBLIC(sk)) r = HStar(T, vkBytes, m) R = [r] B Rbytes = ENCODE_POINT(R) c = HStar(Rbytes, vkBytes, m) S = (r + (c * sk)) mod L return Rbytes || ENCODE_SCALAR(S) VERIFY(vk, m, sig) := Rbytes = sig[0..32] Sbytes = sig[32..64] R = DECODE_POINT(Rbytes) if R is invalid: return false S = DECODE_SCALAR(Sbytes) if S \u0026gt;= L: return false vkBytes = ENCODE_POINT(vk) c = HStar(Rbytes, vkBytes, m) return ((-[S] B) + R + ([c] vk)).multiplyByCofactor().isIdentity() Funções de conversão CONVERT_ED25519_PRIVATE(privkey) := s = SHA-512(privkey)[0..32] s[0] = s[0] \u0026amp; 248 s[31] = (s[31] \u0026amp; 63) | 64 return s CONVERT_ED25519_PUBLIC(pubkey) := pubkey Observe que a implementação de CONVERT_ED25519_PRIVATE é equivalente ao cálculo do escalar secreto s ao derivar uma chave pública Ed25519 a partir de uma chave privada Ed25519, conforme especificado nas etapas 1-3 da seção 5.1.5 do RFC 8032 .\nImplicações de segurança Re-randomizar um Destino Red25519 e, em seguida, gerar assinaturas com ele não revela nenhuma informação sobre o Destino, porque a distribuição de chaves privadas Red25519 geradas via RANDOMIZE_PRIVATE é idêntica à distribuição de chaves privadas geradas via GENERATE_PRIVATE, e DERIVE_PUBLIC é determinístico.\nConverter chaves privadas Ed25519 para Red25519 via CONVERT_ED25519_PRIVATE não resulta na mesma distribuição. No entanto, consideramos a redução na segurança aceitável pelos seguintes motivos:\nO espaço de escalares de Ed25519 (algoritmo de assinatura de curva elíptica) é aproximadamente metade do tamanho do espaço de escalares de Red25519 (há 2^251 escalares possíveis de Ed25519, e L ~= 2^252 escalares possíveis de Red25519). Assim, a perda de segurança é, no máximo, um fator de aproximadamente 2, ou cerca de 1 bit (porque poderíamos ter escolhido por coincidência um escalar de Red25519 que também é um escalar válido de Ed25519). Destinos Ed25519 existentes já foram expostos historicamente na rede, e deve-se presumir que floodfills maliciosos já os enumeraram. Importante: Usuários que estejam preocupados com essa redução de segurança devem usar Red25519 (tipo de assinatura 11) como o tipo de assinatura para seus Destinos em vez de Ed25519 (tipo de assinatura 7).\nObserve que o argumento acima não se aplica ao escalar de re-aleatorização alpha; informação sobre a chave é revelada toda vez que um alpha enviesado é escolhido, porque a re-aleatorização aditiva se comporta como uma cifra de uso único.\nStatus da auditoria de segurança Divulgação Importante: O I2P, incluindo Red25519, nunca passou por uma auditoria formal de segurança por terceiros. O design subjacente do RedDSA passou por uma revisão de segurança pelo NCC Group como parte da auditoria do protocolo Zcash Sapling em 2018, na qual problemas de segurança foram identificados e corrigidos. No entanto, a instanciação específica do I2P com SHA-512 (em vez de BLAKE2b-512) e a separação de domínio do I2P não passaram por análise independente.\nA implementação de referência ed25519-java, de str4d, passou por uma auditoria independente de terceiros, mas isso antecedeu a implementação do Red25519 e cobriu apenas a funcionalidade do Ed25519, não as extensões do Red25519.\nUsuários que estiverem implantando Red25519 (um esquema de assinatura criptográfica) devem compreender essa limitação e avaliar os compromissos de segurança com base no seu modelo de ameaça.\nCompatibilidade As versões do I2P que suportam Red25519 (algoritmo de assinatura) (versão 0.9.39 e posteriores) poderão verificar estruturas de dados de rede assinadas com Red25519. As versões do I2P que não suportam Red25519 irão tratá-la como uma assinatura desconhecida e PODEM descartar as estruturas de dados.\nCronograma de implantação: - 0.9.39 (março de 2019): Primeira implementação com suporte a Encrypted LS2 (LS2 = versão 2 de leaseSet) em floodfills - 0.9.40 (maio de 2019): Autorização por cliente para Encrypted LS2 - 0.9.41 (agosto de 2019): Meta LS2 e Encrypted LS2 com chaves offline - 0.9.43 (fevereiro de 2020): Suporte a b32 para Encrypted LS2 - 0.9.47 (agosto de 2020): Finalização da especificação - 2.10.0 (outubro de 2025): Versão atual da rede (equivalente a 0.9.67+)\nOs usuários devem esperar que a confiabilidade das estruturas de dados assinadas com Red25519 seja boa para casos de uso do LeaseSet2 criptografado, já que a rede teve mais de seis anos para se atualizar desde a implementação inicial. No entanto, métricas de adoção para o uso geral de destinos não estão publicamente disponíveis.\nCaso de uso principal: Red25519 é usado principalmente para a funcionalidade de LeaseSet2 criptografado, onde o cegamento de chave é necessário. Para destinos padrão sem requisitos de leaseset criptografado, Ed25519 (tipo de assinatura 7) continua sendo a escolha recomendada devido à compatibilidade mais ampla e ao histórico mais longo e comprovado.\nNotas de implementação Red25519 é implementado no router Java do I2P em net.i2p.crypto.eddsa.RedDSAEngine e utiliza a biblioteca ed25519-java de str4d (Jack Grigg) como dependência do Maven net.i2p.crypto:eddsa (versões 0.1.0 a 0.3.0).\nA implementação do i2pd em C++ também suporta Red25519 (signaturetype=11) para a publicação de LeaseSet criptografados.\nExemplo de configuração para o i2pd:\nsignaturetype=11 i2cp.leaseSetType=5 Compatibilidade do Encrypted LeaseSet2: A especificação de Encrypted LeaseSet exige que a chave pública de assinatura no unblinded destination (destino não cegado) seja Ed25519 (tipo de assinatura 7) ou Red25519 (tipo de assinatura 11). Nenhum outro tipo de assinatura é suportado para a funcionalidade de leaseSet criptografado.\nVetores de teste Os vetores de teste a seguir são fornecidos para validação da implementação. Cada vetor inclui:\nedsk: chave privada Ed25519 (aleatória) edpk: chave pública Ed25519 correspondente a edsk sk: CONVERT_ED25519_PRIVATE(edsk) vk: CONVERT_ED25519_PUBLIC(edpk) msg: Mensagem a ser assinada sig: SIGN(sk, msg) alpha: GENERATE_RANDOM() rsk: RANDOMIZE_PRIVATE(sk, alpha) rvk: RANDOMIZE_PUBLIC(vk, alpha) rsig: SIGN(rsk, msg) Nota de Implementação: Esses vetores de teste devem ser integrados a suítes de testes unitários automatizadas para validação contínua. Os implementadores devem verificar se todas as conversões, assinaturas e operações de re-randomization (realeatorização) correspondem a esses valores esperados.\nVetor de teste 1 edsk: 0101010101010101010101010101010101010101010101010101010101010101 edpk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c sk: 58e86efb75fa4e2c410f46e16de9f6acae1a1703528651b69bc176c088bef36e vk: 8a88e3dd7409f195fd52db2d3cba5d72ca6709bf1d94121bf3748801b40f6f5c msg: 0202020202020202020202020202020202020202020202020202020202020202 sig: 61f5527f4d3b46de4b2c234390370bf715ae9098907a0d191ba1b44b23a8ac1a 6a40437a5294e9503faaf9bd2b7f2fe7ba44dec487b3185aba7ff7d7a17cd40f alpha: ae9ba9cbbc047c442448fca7c9f4e288a202ed520bfad0c784b792b7773cee08 rsk: 8bb85f3c7a494a08890d7d142109c1a3501d04565d80227e2079097800fbe107 rvk: 6fe128737b8e76fa66698a748b0dc0a89168dd8a0601c2b1c0b26835d323e9b3 rsig: 533053074d3b44f08723aab988ede9880a001b7a684d4a98f2d1b88fabee07a5 b5c9430c69a690321e0cb8365d7aeb6688bcbad2c0780e0c69e8a1b4a45f3001 Vetor de teste 2 edsk: 0202020202020202020202020202020202020202020202020202020202020202 edpk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 sk: a83c626bc9c38c8c201878ebb1d5b0b50ac40e8986c78793db1d4ef369fca14e vk: 8139770ea87d175f56a35466c34c7ecccb8d8a91b4ee37a25df60f5b8fc9b394 msg: 0303030303030303030303030303030303030303030303030303030303030303 sig: 0829e58eb5399870f009bd1f0270264e556424bda7a93fbcec99f6d9d75db46d 5c3cb546d9947ca7c1200876c8775a90c357a2aef3d2f16388242ee1914b1a0a alpha: 98b615d9027e996cc2796c019d9c8beb46aa7d2b6eea2e5d98eb29eb1584c203 rsk: 9fcfaa734852ca40b3810ebef590e138516e8cb4f4b1b6f0730978de7f806402 rvk: 527e121090158419609e4a0d8de6f7d3271b353a8cd0b8172fe41468ea1e9177 rsig: 9a6961f35ed264a946cd6214b2326a6e6caa426c2a61bc14367fd278e0b5fb51 3ac065a69210a457f17d12ba8a496cfd835002691affa8efcdecae48135c090f Observação: Os vetores de teste adicionais 3 a 10 seguem o mesmo formato e podem ser encontrados na implementação de referência.\nReferências Proposta 123: Novas entradas no netDB - Partes implementadas e implantadas nas versões 0.9.38, 0.9.39 e posteriores Especificação do Protocolo Zcash, Seção 5.4.6: RedDSA, RedJubjub e RedPallas - RedDSA é definido como parte da especificação do protocolo Zcash; auditoria de segurança realizada pela NCC Group (janeiro de 2019) RFC 8032: Algoritmo de Assinatura Digital de Curva de Edwards (EdDSA) Proposta 148: RedDSA-BLAKE2b-Ed25519 - Proposta, mas ainda não implementada; sugere migração futura para BLAKE2b-512 Especificação de LeaseSet Criptografado Especificação de Criptografia de Baixo Nível ","description":"Esquema de assinatura re-aleatorizável para a criação de Destinos cegos","id":"31b087e2977ad9f01f6b3b93e6af1f20","section":"docs","title":"Esquema de assinatura Red25519","url":"/pt/docs/specs/red25519-signature-scheme/"},{"categories":null,"content":"Visão geral Este documento especifica as estruturas de dados fundamentais usadas em todos os protocolos do I2P, incluindo I2NP , I2CP , SSU2 , NTCP2 , entre outros. Essas estruturas comuns garantem a interoperabilidade entre diferentes implementações do I2P e camadas de protocolo.\nPrincipais mudanças desde 0.9.58 ElGamal e DSA-SHA1 marcados como obsoletos para Identidades do Router (use X25519 + EdDSA) Suporte a ML-KEM pós-quântico em testes beta (opt-in a partir da versão 2.10.0) Opções de registros de serviço padronizadas (Proposal 167 , implementado na versão 0.9.66) Especificações de preenchimento comprimível finalizadas (Proposal 161 , implementado na versão 0.9.57) Especificações de Tipos Comuns Inteiro Descrição: Representa um inteiro não negativo em ordem de bytes de rede (big-endian, mais significativo primeiro).\nConteúdo: 1 a 8 bytes representando um inteiro sem sinal.\nUso: Comprimentos de campos, contagens, identificadores de tipo e valores numéricos em todos os protocolos do I2P.\nData Descrição: Carimbo de data/hora representando milissegundos desde a época Unix (1º de janeiro de 1970 00:00:00 GMT).\nConteúdo: Inteiro de 8 bytes (unsigned long)\nValores especiais: - 0 = Data indefinida ou nula - Valor máximo: 0xFFFFFFFFFFFFFFFF (ano 584,942,417,355)\nNotas de Implementação: - Sempre no fuso horário UTC/GMT - Precisão em milissegundos obrigatória - Usado para expiração de lease (entrada temporária em um leaseSet do I2P), publicação de RouterInfo e validação de carimbo de data/hora\nCadeia de caracteres Descrição: Cadeia de caracteres codificada em UTF-8 com prefixo de tamanho.\nFormato:\n+----+----+----+----+----+----+ |len | UTF-8 encoded data... | +----+----+----+----+----+----+ len :: Integer (1 byte) Value: 0-255 (string length in bytes, NOT characters) data :: UTF-8 encoded bytes Length: 0-255 bytes Restrições: - Comprimento máximo: 255 bytes (não caracteres - sequências UTF-8 de múltiplos bytes contam como vários bytes) - O comprimento pode ser zero (string vazia) - Terminador nulo NÃO incluído - A string NÃO possui terminador nulo\nImportante: Sequências UTF-8 podem usar vários bytes por caractere. Uma string com 100 caracteres pode exceder o limite de 255 bytes se usar caracteres de múltiplos bytes.\nEstruturas de Chaves Criptográficas Chave pública Descrição: Chave pública para criptografia assimétrica. O tipo e o tamanho da chave dependem do contexto ou são especificados em um Certificado de Chave.\nTipo padrão: ElGamal (obsoleto para Router Identities a partir da versão 0.9.58)\nTipos suportados:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations only (unused field)Deprecated for RIs P256164TBDBigReservedSee Proposal 145 P384296TBDBigReservedSee Proposal 145 P5213132TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-8000.9.67TBDHandshakes onlyBeta MLKEM768-11840.9.67TBDHandshakes onlyBeta MLKEM1024-15680.9.67TBDHandshakes onlyBeta MLKEM512_CT-7680.9.67TBDHandshakes onlyBeta MLKEM768_CT-10880.9.67TBDHandshakes onlyBeta MLKEM1024_CT-15680.9.67TBDHandshakes onlyBeta **Requisitos de Implementação:** X25519 (Tipo 4) - Padrão atual:\nUsado para criptografia ECIES-X25519-AEAD-Ratchet Obrigatório para Identidades do router desde a versão 0.9.48 Codificação little-endian (ordem de bytes do menos significativo para o mais significativo; ao contrário de outros tipos) Consulte ECIES e ECIES-ROUTERS ElGamal (Tipo 0) - Legado:\nDescontinuado para Identidades de router desde a versão 0.9.58 Ainda válido para Destinos (campo não utilizado desde 0.6/2005) Usa primos constantes definidos na especificação ElGamal Suporte mantido para compatibilidade com versões anteriores MLKEM (Pós-Quântico) - Beta:\nA abordagem híbrida combina ML-KEM com X25519 NÃO está habilitado por padrão na 2.10.0 Requer ativação manual via Hidden Service Manager (Gerenciador de Serviços Ocultos) Consulte ECIES-HYBRID e Proposal 169 Códigos de tipo e especificações estão sujeitos a alterações JavaDoc: PublicKey Chave privada Descrição: Chave privada para descriptografia assimétrica, correspondente aos tipos PublicKey.\nArmazenamento: Tipo e comprimento inferidos a partir do contexto ou armazenados separadamente em estruturas de dados/arquivos de chave.\nTipos suportados:\nType Code Length (bytes) Since Endianness Usage Status ElGamal0256-BigDestinations onlyDeprecated for RIs P256132TBDBigReservedSee Proposal 145 P384248TBDBigReservedSee Proposal 145 P521366TBDBigReservedSee Proposal 145 X255194320.9.38LittleCurrent standardRecommended MLKEM512_X255195320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM768_X255196320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM1024_X255197320.9.67MixedHybrid PQ, LeaseSets onlyBeta MLKEM512-16320.9.67TBDHandshakes onlyBeta MLKEM768-24000.9.67TBDHandshakes onlyBeta MLKEM1024-31680.9.67TBDHandshakes onlyBeta **Notas de segurança:** - Chaves privadas DEVEM ser geradas usando geradores de números aleatórios criptograficamente seguros - Chaves privadas X25519 usam \"scalar clamping\" (ajuste do escalar) conforme definido na RFC 7748 - O material de chave DEVE ser apagado de forma segura da memória quando não for mais necessário JavaDoc: PrivateKey Chave de sessão Descrição: Chave simétrica para criptografia e descriptografia AES-256 no tunnel e na garlic encryption do I2P.\nConteúdo: 32 bytes (256 bits)\nUso: - Criptografia na camada de tunnel (AES-256/CBC com IV) - Criptografia de mensagens Garlic - Criptografia de sessão ponta a ponta\nGeração: DEVE usar gerador de números aleatórios criptograficamente seguro.\nJavaDoc: SessionKey SigningPublicKey Descrição: Chave pública para verificação de assinatura. Tipo e tamanho especificados no Certificado de Chave do Destino ou inferidos a partir do contexto.\nTipo padrão: DSA_SHA1 (obsoleto a partir da 0.9.58)\nTipos suportados:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA10128-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized Reserved (GOST)964-BigReservedProposal 134 Reserved (GOST)10128-BigReservedProposal 134 Reserved (MLDSA)12-20TBD-TBDReservedProposal 169 Experimental65280-65534Varies-VariesTesting onlyNever production Reserved65535---Future expansion- **Requisitos de Implementação:** EdDSA_SHA512_Ed25519 (Type 7) - Padrão atual:\nPadrão para todas as novas Identidades do Router e Destinos desde o final de 2015 Usa a curva Ed25519 com hash SHA-512 Chaves públicas de 32 bytes, assinaturas de 64 bytes Codificação little-endian (ao contrário da maioria dos outros tipos) Alto desempenho e segurança RedDSA_SHA512_Ed25519 (Type 11) - Especializado:\nUsado APENAS para leasesets criptografados e cegamento Nunca usado para Identidades de Router ou Destinos padrão Principais diferenças em relação ao EdDSA: Chaves privadas via redução modular (não clamping (ajuste de bits)) Assinaturas incluem 80 bytes de dados aleatórios Usa chaves públicas diretamente (não hashes de chaves privadas) Consulte a [especificação Red25519](//docs/specs/red25519-signature-scheme/ DSA_SHA1 (Tipo 0) - Legado:\nDescontinuado para Identidades de router a partir da versão 0.9.58 Não recomendado para novos Destinos DSA de 1024 bits com SHA-1 (vulnerabilidades conhecidas) Suporte mantido apenas para compatibilidade Chaves multi-elemento:\nQuando composta por dois elementos (por exemplo, pontos ECDSA X,Y) Cada elemento preenchido até length/2 com zeros à esquerda Exemplo: chave ECDSA de 64 bytes = 32 bytes de X + 32 bytes de Y JavaDoc: SigningPublicKey SigningPrivateKey Descrição: Chave privada para criar assinaturas, correspondente aos tipos de SigningPublicKey (chave pública de assinatura).\nArmazenamento: Tipo e tamanho especificados no momento da criação.\nTipos suportados:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1020-BigLegacy onlyDeprecated ECDSA_SHA256_P2561320.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842480.9.12BigRareDeprecated ECDSA_SHA512_P5213660.9.12BigRareDeprecated RSA_SHA256_204845120.9.12BigOffline signing onlyDeprecated RSA_SHA384_307257680.9.12BigOffline signing onlyDeprecated RSA_SHA512_4096610240.9.12BigOffline signing onlyRecommended for SU3 EdDSA_SHA512_Ed255197320.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8320.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911320.9.39LittleEncrypted leasesets onlySpecialized **Requisitos de Segurança:** - Gerar usando uma fonte de aleatoriedade criptograficamente segura - Proteger com controles de acesso apropriados - Apagar com segurança da memória quando terminar - Para EdDSA: semente de 32 bytes submetida a hash com SHA-512, os primeiros 32 bytes tornam-se o escalar (clamped: ajuste de bits conforme a especificação) - Para RedDSA: geração de chave diferente (redução modular em vez de clamping) JavaDoc: SigningPrivateKey Assinatura Descrição: Assinatura criptográfica sobre os dados, usando o algoritmo de assinatura correspondente ao tipo SigningPrivateKey.\nTipo e Comprimento: Inferidos a partir do tipo de chave usado para assinar.\nTipos suportados:\nType Code Length (bytes) Since Endianness Usage Status DSA_SHA1040-BigLegacy onlyDeprecated ECDSA_SHA256_P2561640.9.12BigOlder DestinationsDeprecated ECDSA_SHA384_P3842960.9.12BigRareDeprecated ECDSA_SHA512_P52131320.9.12BigRareDeprecated RSA_SHA256_204842560.9.12BigOffline signing onlyDeprecated RSA_SHA384_307253840.9.12BigOffline signing onlyDeprecated RSA_SHA512_409665120.9.12BigOffline signing onlyCurrent for SU3 EdDSA_SHA512_Ed255197640.9.15LittleCurrent standardRecommended EdDSA_SHA512_Ed25519ph8640.9.25LittleOffline signing onlyRare RedDSA_SHA512_Ed2551911640.9.39LittleEncrypted leasesets onlySpecialized **Notas de Formato:** - Assinaturas com múltiplos elementos (por exemplo, valores R,S de ECDSA) são preenchidas até length/2 para cada elemento com zeros à esquerda - EdDSA e RedDSA usam codificação little-endian - Todos os outros tipos usam codificação big-endian Verificação: - Use a SigningPublicKey (chave pública de assinatura) correspondente - Siga as especificações do algoritmo de assinatura para o tipo de chave - Verifique se o tamanho da assinatura corresponde ao tamanho esperado para o tipo de chave\nJavaDoc: Signature Hash Descrição: Hash SHA-256 de dados, usado em todo o I2P para verificação de integridade e identificação.\nConteúdo: 32 bytes (256 bits)\nUso: - hashes de Identidade do Router (chaves do banco de dados da rede) - hashes de Destino (chaves do banco de dados da rede) - identificação do gateway de Tunnel em Leases - verificação da integridade dos dados - geração de ID de Tunnel\nAlgoritmo: SHA-256 como definido no FIPS 180-4\nJavaDoc: Hash Tag de sessão Descrição: Número aleatório usado para identificação de sessão e criptografia baseada em tags.\nImportante: O tamanho do Session Tag (etiqueta de sessão) varia conforme o tipo de criptografia: - ElGamal/AES+SessionTag: 32 bytes (legado) - ECIES-X25519: 8 bytes (padrão atual)\nPadrão atual (ECIES):\nContents: 8 bytes Usage: Ratchet-based encryption for Destinations and Routers Consulte ECIES e ECIES-ROUTERS para especificações detalhadas.\nLegado (ElGamal/AES):\nContents: 32 bytes Usage: Deprecated encryption scheme Geração: DEVE usar um gerador de números aleatórios criptograficamente seguro.\nJavaDoc: SessionTag TunnelId Descrição: Identificador único da posição de um router em um tunnel. Cada salto em um tunnel tem seu próprio TunnelId.\nFormato:\nContents: 4-byte Integer (unsigned 32-bit) Range: Generally \u0026gt; 0 (zero reserved for special cases) Uso: - Identifica conexões de tunnel de entrada/saída em cada router - TunnelId diferente em cada salto na cadeia de tunnels - Usado em estruturas Lease (estrutura de concessão temporária) para identificar tunnels de gateway\nValores Especiais: - 0 = Reservado para usos especiais do protocolo (evite durante a operação normal) - TunnelIds (identificadores de tunnel) são localmente significativos para cada router\nJavaDoc: TunnelId Especificações de Certificados Certificado Descrição: Contêiner para recibos, prova de trabalho ou metadados criptográficos usados em todo o I2P.\nFormato:\n+----+----+----+----+----+----+-// |type| length | payload +----+----+----+----+----+----+-// type :: Integer (1 byte) Values: 0-5 (see types below) length :: Integer (2 bytes, big-endian) Size of payload in bytes payload :: data length -\u0026gt; $length bytes Tamanho total: 3 bytes no mínimo (NULL certificate; certificado vazio), até 65538 bytes no máximo\nTipos de Certificado Type Code Payload Length Total Size Status Usage NULL003CurrentDefault/empty certificate HASHCASH1VariesVariesDeprecatedUnused (was for proof-of-work) HIDDEN203DeprecatedUnused (hidden routers don't advertise) SIGNED340 or 7243 or 75DeprecatedUnused (DSA signature ± destination hash) MULTIPLE4VariesVariesDeprecatedUnused (multiple certificates) KEY54+7+CurrentSpecifies key types (see below) ### Certificado de Chave (Tipo 5) Introdução: Versão 0.9.12 (Dezembro de 2013)\nObjetivo: Especifica tipos de chave não padrão e armazena dados de chave excedentes além da estrutura KeysAndCert padrão de 384 bytes.\nEstrutura da carga útil:\n+----+----+----+----+----+----+----+----+-// |SPKtype|CPKtype| Excess SPK data | +----+----+----+----+----+----+----+----+-// | Excess CPK data... | +----+----+----+----+----+----+----+----+ SPKtype :: Signing Public Key Type (2 bytes) See SigningPublicKey table above CPKtype :: Crypto Public Key Type (2 bytes) See PublicKey table above Excess SPK data :: Signing key bytes beyond 128 bytes Length: 0 to 65531 bytes Excess CPK data :: Crypto key bytes beyond 256 bytes Length: 0 to remaining space Notas Críticas de Implementação:\nOrdem dos tipos de chave:\nAVISO: tipo de chave de assinatura vem ANTES do tipo de chave criptográfica Isso é contraintuitivo, mas é mantido por compatibilidade Ordem: SPKtype, CPKtype (não CPKtype, SPKtype) Disposição dos dados de chave em KeysAndCert (estrutura de dados):\n[Crypto Public Key (partial/complete)] [Padding (if total key lengths \u0026lt; 384)] [Signing Public Key (partial/complete)] [Certificate Header (3 bytes)] [Key Certificate (4+ bytes)] [Excess Signing Key Data] [Excess Crypto Key Data] Calculando dados de chave excedentes:\nSe Crypto Key \u0026gt; 256 bytes: Excess = (Crypto Length - 256) Se Signing Key \u0026gt; 128 bytes: Excess = (Signing Length - 128) Padding = max(0, 384 - Crypto Length - Signing Length) Exemplos (chave criptográfica ElGamal):\nSigning Key Type Total SPK Length Padding Excess in Cert Total Structure Size DSA_SHA112800387 + 7 = 394 ECDSA_P25664640387 + 7 = 394 ECDSA_P38496320387 + 7 = 394 ECDSA_P52113204387 + 11 = 398 RSA_20482560128387 + 135 = 522 RSA_40965120384387 + 391 = 778 EdDSA32960387 + 7 = 394 **Requisitos de Identidade do Router:** - Certificado NULL usado até a versão 0.9.15 - Certificado de Chave obrigatório para tipos de chave não padrão desde a versão 0.9.16 - Chaves de criptografia X25519 suportadas desde a versão 0.9.48 Requisitos do Destino: - certificado NULL OU Key Certificate (certificado de chave) (conforme necessário) - Key Certificate obrigatório para tipos de chave de assinatura não padrão desde 0.9.12 - Campo de chave pública criptográfica não utilizado desde 0.6 (2005), mas ainda deve estar presente\nAvisos Importantes:\nNULL vs KEY Certificate (NULL = certificado vazio; KEY = certificado com informações de chave):\nUm certificado KEY com tipos (0,0) especificando ElGamal+DSA_SHA1 é permitido, mas não é recomendado Use sempre certificado NULL para ElGamal+DSA_SHA1 (representação canônica) Um certificado KEY com (0,0) é 4 bytes mais longo e pode causar problemas de compatibilidade Algumas implementações podem não lidar corretamente com certificados KEY (0,0) Validação de Excesso de Dados:\nAs implementações DEVEM verificar se o comprimento do certificado corresponde ao comprimento esperado para cada tipo de chave Rejeitar certificados com dados em excesso que não correspondam aos tipos de chave Proibir dados lixo ao final de uma estrutura de certificado válida JavaDoc: Certificate Mapeamento Descrição: Coleção de propriedades chave-valor utilizada para configuração e metadados.\nFormato:\n+----+----+----+----+----+----+----+----+ | size | key_string (len + data)| = | +----+----+----+----+----+----+----+----+ | val_string (len + data) | ; | ... +----+----+----+----+----+----+----+ size :: Integer (2 bytes, big-endian) Total number of bytes that follow (not including size field) Range: 0 to 65535 key_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes = :: Single byte (0x3D, \u0026#39;=\u0026#39; character) val_string :: String Format: 1-byte length + UTF-8 data Length: 0-255 bytes ; :: Single byte (0x3B, \u0026#39;;\u0026#39; character) [Repeat key_string = val_string ; for additional entries] Limites de tamanho: - Comprimento da chave: 0-255 bytes (+ 1 byte de comprimento) - Comprimento do valor: 0-255 bytes (+ 1 byte de comprimento) - Tamanho total do mapeamento: 0-65535 bytes (+ 2 bytes do campo de tamanho) - Tamanho máximo da estrutura: 65537 bytes\nRequisito crítico de ordenação:\nQuando mapeamentos aparecem em estruturas assinadas (RouterInfo, RouterAddress, propriedades de Destination, I2CP SessionConfig), as entradas DEVEM ser ordenadas pela chave para garantir a invariância da assinatura:\nMétodo de ordenação: Ordenação lexicográfica usando valores de ponto de código Unicode (equivalente a Java String.compareTo()) Sensibilidade a maiúsculas/minúsculas: Chaves e valores são geralmente sensíveis a maiúsculas/minúsculas (dependente da aplicação) Chaves duplicadas: NÃO são permitidas em estruturas assinadas (causarão falha na verificação da assinatura) Codificação de caracteres: Comparação em nível de byte em UTF-8 Por que a ordenação importa: - As assinaturas são calculadas sobre a representação em bytes - Diferentes ordens de chaves produzem assinaturas diferentes - Mapeamentos não assinados não exigem ordenação, mas devem seguir a mesma convenção\nNotas de implementação:\nRedundância de codificação:\nTanto os delimitadores = e ; quanto os bytes de comprimento da string (cadeia de caracteres) estão presentes Isso é ineficiente, mas é mantido por compatibilidade Os bytes de comprimento prevalecem; os delimitadores são obrigatórios, mas redundantes Suporte a caracteres:\nApesar da documentação, = e ; SÃO suportados dentro de strings (os bytes de comprimento tratam disso) A codificação UTF-8 suporta todo o Unicode Aviso: I2CP usa UTF-8, mas historicamente o I2NP não tratava UTF-8 corretamente Use ASCII para os mapeamentos do I2NP quando possível, para máxima compatibilidade Contextos Especiais:\nRouterInfo/RouterAddress: DEVE ser ordenado, sem duplicados I2CP SessionConfig: DEVE ser ordenado, sem duplicados Mapeamentos de aplicações: Ordenação recomendada, mas nem sempre obrigatória Exemplo (opções de RouterInfo):\nMapping size: 45 bytes Sorted entries: caps=L (capabilities) netId=2 (network ID) router.version=0.9.67 JavaDoc: DataHelper Especificação da Estrutura Comum Chaves e Certificado Descrição: Estrutura fundamental que combina a chave de criptografia, a chave de assinatura e o certificado. Usada tanto como RouterIdentity quanto como Destination.\nEstrutura:\n+----+----+----+----+----+----+----+----+ | public_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | padding (optional) | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | certificate | +----+----+----+-// public_key :: PublicKey (partial or full) Default: 256 bytes (ElGamal) Other sizes: As specified in Key Certificate padding :: Random data Length: 0 bytes or as needed CONSTRAINT: public_key + padding + signing_key = 384 bytes signing_key :: SigningPublicKey (partial or full) Default: 128 bytes (DSA_SHA1) Other sizes: As specified in Key Certificate certificate :: Certificate Minimum: 3 bytes (NULL certificate) Common: 7 bytes (Key Certificate with default keys) TOTAL LENGTH: 387+ bytes (never assume exactly 387!) Alinhamento de Chaves: - Chave Pública Criptográfica: Alinhada no início (byte 0) - Preenchimento: No meio (se necessário) - Chave Pública de Assinatura: Alinhada no final (do byte 256 ao byte 383) - Certificado: Começa no byte 384\nCálculo do tamanho:\nTotal size = 384 + 3 + key_certificate_length For NULL certificate (ElGamal + DSA_SHA1): Total = 384 + 3 = 387 bytes For Key Certificate (EdDSA + X25519): Total = 384 + 3 + 4 = 391 bytes For larger keys (e.g., RSA_4096): Total = 384 + 3 + 4 + excess_key_data_length Diretrizes para Geração de Preenchimento (Proposta 161 ) Versão da implementação: 0.9.57 (janeiro de 2023, lançamento 2.1.0)\nContexto: - Para chaves que não sejam ElGamal+DSA, o preenchimento está presente na estrutura fixa de 384 bytes - Para Destinos, o campo de chave pública de 256 bytes não é usado desde a versão 0.6 (2005) - O preenchimento deve ser gerado de forma a ser compressível, mantendo-se seguro\nRequisitos:\nDados Aleatórios Mínimos:\nUse pelo menos 32 bytes de dados aleatórios criptograficamente seguros Isso fornece entropia suficiente para a segurança Estratégia de compressão:\nRepetir os 32 bytes ao longo de todo o campo de padding/chave pública Protocolos como I2NP Database Store, Streaming SYN e o handshake do SSU2 usam compressão Economia significativa de largura de banda sem comprometer a segurança Exemplos:\nIdentidade do Router (X25519 + EdDSA):\nStructure: - 32 bytes X25519 public key - 320 bytes padding (10 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~288 bytes when compressed Destino (ElGamal-unused + EdDSA):\nStructure: - 256 bytes unused ElGamal field (11 copies of 32-byte random data, truncated to 256) - 96 bytes padding (3 copies of 32-byte random data) - 32 bytes EdDSA public key - 7 bytes Key Certificate Compression savings: ~320 bytes when compressed Por que isso funciona:\nO hash SHA-256 da estrutura completa ainda inclui toda a entropia A distribuição na DHT do banco de dados da rede depende apenas do hash A chave de assinatura (32 bytes EdDSA/X25519) fornece 256 bits de entropia 32 bytes adicionais de dados aleatórios repetidos = 512 bits de entropia total Mais do que suficiente para força criptográfica Notas de Implementação:\nDEVE armazenar e transmitir a estrutura completa de 387+ bytes hash SHA-256 calculado sobre a estrutura completa não compactada Compressão aplicada na camada de protocolo (I2NP, Streaming, SSU2) Retrocompatível com todas as versões desde a 0.6 (2005) JavaDoc: KeysAndCert Identidade do router Descrição: Identifica de forma exclusiva um router na rede I2P. Estrutura idêntica a KeysAndCert.\nFormato: Consulte a estrutura KeysAndCert acima\nRequisitos atuais (a partir da versão 0.9.58):\nTipos de chave obrigatórios:\nCriptografia: X25519 (tipo 4, 32 bytes) Assinatura: EdDSA_SHA512_Ed25519 (tipo 7, 32 bytes) Certificado: Certificado de chave (tipo 5) Tipos de chave descontinuados:\nElGamal (tipo 0) descontinuado para Identidades de Router a partir da versão 0.9.58 DSA_SHA1 (tipo 0) descontinuado para Identidades de Router a partir da versão 0.9.58 Estes não devem ser usados em novos routers Tamanho típico:\nX25519 + EdDSA com certificado de chave = 391 bytes 32 bytes de chave pública X25519 320 bytes de preenchimento (compressível conforme Proposal 161 ) 32 bytes de chave pública EdDSA 7 bytes de certificado (cabeçalho de 3 bytes + 4 bytes de tipos de chave) Evolução histórica: - Pré-0.9.16: Sempre certificado NULL (ElGamal + DSA_SHA1) - 0.9.16-0.9.47: Suporte a certificado de chave adicionado - 0.9.48+: Chaves de criptografia X25519 suportadas - 0.9.58+: ElGamal e DSA_SHA1 obsoletos\nChave do Banco de Dados da Rede: - RouterInfo (registro de informações do router) indexado pelo hash SHA-256 da RouterIdentity (identidade criptográfica do router) completa - Hash calculada sobre toda a estrutura de 391+ bytes (incluindo preenchimento)\nConsulte também: - Diretrizes para geração de preenchimento (Proposal 161 ) - Especificação do Certificado de Chave acima\nJavaDoc: RouterIdentity Destino Descrição: Identificador de ponto de extremidade para a entrega segura de mensagens. Estruturalmente idêntico a KeysAndCert, mas com semântica de uso diferente.\nFormato: Consulte a estrutura KeysAndCert acima\nDiferença crítica em relação ao RouterIdentity: - O campo de chave pública NÃO É UTILIZADO e pode conter dados aleatórios - Este campo não é usado desde a versão 0.6 (2005) - Originalmente era para a antiga criptografia I2CP-para-I2CP (desativada) - Atualmente, só é usado como IV para a criptografia de LeaseSet descontinuada\nRecomendações atuais:\nChave de assinatura:\nRecomendado: EdDSA_SHA512_Ed25519 (tipo 7, 32 bytes) Alternativa: tipos ECDSA para compatibilidade com versões mais antigas Evitar: DSA_SHA1 (obsoleto, desaconselhado) Chave de criptografia:\nO campo não é utilizado, mas deve estar presente Recomendado: Preencher com dados aleatórios conforme Proposta 161 (compressível) Tamanho: Sempre 256 bytes (slot do ElGamal, embora não seja utilizado para ElGamal) Certificado:\nCertificado NULL para ElGamal + DSA_SHA1 (apenas legado) Certificado de chave para todos os outros tipos de chave de assinatura Destino moderno típico:\nStructure: - 256 bytes unused field (random data, compressible) - 96 bytes padding (random data, compressible) - 32 bytes EdDSA signing public key - 7 bytes Key Certificate Total: 391 bytes Compression savings: ~320 bytes Chave de criptografia efetiva: - A chave de criptografia para o Destination (destino no I2P) está no LeaseSet, não no Destination - O LeaseSet contém as chaves públicas de criptografia atuais - Consulte a especificação LeaseSet2 para o tratamento de chaves de criptografia\nChave do Banco de Dados da Rede: - LeaseSet indexado pelo hash SHA-256 da Destination (destino no I2P) completa - Hash calculado sobre a estrutura completa de 387+ bytes\nJavaDoc: Destination Estruturas do Banco de Dados de Rede Lease (descritor temporário de túnel) Descrição: Autoriza um tunnel específico a receber mensagens para um Destino. Parte do formato original de LeaseSet (tipo 1).\nFormato:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date +----+----+----+----+----+----+----+----+ | +----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of the gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at the gateway router end_date :: Date (8 bytes) Expiration timestamp in milliseconds since epoch Tamanho total: 44 bytes\nUso: - Usado apenas no LeaseSet original (tipo 1, obsoleto) - Para o LeaseSet2 e variantes posteriores, use o Lease2 em vez disso\nJavaDoc: Lease LeaseSet (Tipo 1) Descrição: Formato LeaseSet original. Contém tunnels autorizados e chaves para um Destino. Armazenado no banco de dados da rede. Status: Obsoleto (use LeaseSet2 em vez disso).\nEstrutura:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | encryption_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signing_key | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease ($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes encryption_key :: PublicKey (256 bytes, ElGamal) Used for end-to-end ElGamal/AES+SessionTag encryption Generated anew at each router startup (not persistent) signing_key :: SigningPublicKey (128+ bytes) Same type as Destination signing key Used for LeaseSet revocation (unimplemented) Generated anew at each router startup (not persistent) num :: Integer (1 byte) Number of Leases to follow Range: 0-16 leases :: Array of Lease structures Length: $num × 44 bytes Each Lease is 44 bytes signature :: Signature (40+ bytes) Length determined by Destination signing key type Signed by Destination\u0026#39;s SigningPrivateKey Armazenamento do banco de dados: - Tipo de banco de dados: 1 - Chave: hash SHA-256 do Destino - Valor: Estrutura completa de LeaseSet (estrutura I2P que descreve os túneis de entrada de um Destino)\nNotas importantes:\nChave pública do Destino não utilizada:\nO campo de chave pública de criptografia no Destino não é utilizado A chave de criptografia no LeaseSet é a chave de criptografia efetiva Chaves temporárias:\nencryption_key é temporária (regenerada na inicialização do router) signing_key é temporária (regenerada na inicialização do router) Nenhuma das chaves é persistente entre reinicializações Revogação (Não implementada):\nPretendia-se usar signing_key para a revogação de LeaseSet O mecanismo de revogação nunca foi implementado LeaseSet com zero leases (leases: entradas temporárias de túnel) estava previsto para revogação, mas não é utilizado Versionamento/Carimbo de data/hora:\nLeaseSet não possui um campo de carimbo de data/hora published explícito A versão é a data de expiração mais cedo entre todos os leases Um novo LeaseSet deve ter uma data de expiração mais cedo dos leases para ser aceito Publicação da expiração de lease (entrada de túnel):\nPré-0.9.7: Todos os leases publicados com a mesma expiração (a mais próxima) 0.9.7+: Expirações individuais reais de lease publicadas Isto é um detalhe de implementação, não faz parte da especificação Zero Leases:\nLeaseSet com zero leases é tecnicamente permitido Destinado à revogação (não implementada) Não usado na prática As variantes de LeaseSet2 exigem pelo menos um Lease Descontinuação: LeaseSet tipo 1 está obsoleto. Novas implementações devem usar LeaseSet2 (tipo 3) que oferece: - Campo de carimbo de data/hora de publicação (melhor versionamento) - Suporte a múltiplas chaves de criptografia - Capacidade de assinatura offline - Expirações de leases (períodos de concessão) de 4 bytes (vs 8 bytes) - Opções mais flexíveis\nJavaDoc: LeaseSet Variantes de LeaseSet Lease2 Descrição: Formato de lease (concessão) aprimorado com expiração de 4 bytes. Usado em LeaseSet2 (tipo 3) e MetaLeaseSet (tipo 7).\nIntrodução: Versão 0.9.38 (consulte Proposta 123 )\nFormato:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | tunnel_id | end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of gateway RouterIdentity tunnel_id :: TunnelId (4 bytes) Tunnel identifier at gateway end_date :: 4-byte timestamp (seconds since epoch) Rolls over in year 2106 Tamanho total: 40 bytes (4 bytes menor do que o Lease original)\nComparação com o Lease (entrada do leaseSet) original:\nFeature Lease (Type\u0026nbsp;1) Lease2 (Type\u0026nbsp;3+) Size44 bytes40 bytes Expiration Size8 bytes (ms)4 bytes (seconds) PrecisionMillisecondSecond RolloverYear\u0026nbsp;292,277,026,596Year\u0026nbsp;2106 Used InLeaseSet (deprecated)LeaseSet2, MetaLeaseSet **JavaDoc:** [Lease2](http://docs.i2p-projekt.de/javadoc/net/i2p/data/Lease2.html) OfflineSignature (assinatura offline) Descrição: Estrutura opcional para chaves efêmeras pré-assinadas, permitindo a publicação de LeaseSet sem acesso online à chave privada de assinatura do Destino.\nIntrodução: Versão 0.9.38 (consulte Proposta 123 )\nFormato:\n+----+----+----+----+----+----+----+----+ | expires | sigtype | | +----+----+----+----+----+----+ + | transient_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ expires :: 4-byte timestamp (seconds since epoch) Expiration of transient key validity Rolls over in year 2106 sigtype :: 2-byte signature type Type of transient_public_key (see SigningPublicKey types) transient_public_key :: SigningPublicKey Length determined by sigtype Temporary signing key for LeaseSet signature :: Signature Length determined by Destination\u0026#39;s signing key type Signature of (expires || sigtype || transient_public_key) Signed by Destination\u0026#39;s permanent SigningPrivateKey Finalidade: - Permite a geração offline de LeaseSet - Protege a chave mestra do Destination (identidade de serviço no I2P) contra exposição online - A chave transitória pode ser revogada ao publicar um novo LeaseSet sem assinatura offline\nCenários de uso:\nDestinos de Alta Segurança:\nChave mestra de assinatura armazenada offline (HSM (módulo de segurança de hardware), armazenamento a frio) Chaves temporárias geradas offline por períodos limitados Uma chave temporária comprometida não expõe a chave mestra Publicação de LeaseSet criptografado:\nEncryptedLeaseSet pode incluir assinatura offline Chave pública cega + assinatura offline fornecem segurança adicional Considerações de Segurança:\nGerenciamento de expiração:\nDefina um prazo de expiração razoável (de dias a semanas, não anos) Gere novas chaves temporárias antes da expiração Expiração mais curta = melhor segurança, mais manutenção Geração de Chaves:\nGerar chaves transitórias offline em ambiente seguro Assinar com a chave mestra offline Transferir apenas a chave transitória assinada + a assinatura para o router online Revogação:\nPublicar novo LeaseSet sem assinatura offline para revogar implicitamente Ou publicar novo LeaseSet com chave transitória diferente Verificação de Assinatura:\nData to sign: expires (4 bytes) || sigtype (2 bytes) || transient_public_key Verification: 1. Extract Destination from LeaseSet 2. Get Destination\u0026#39;s SigningPublicKey 3. Verify signature over (expires || sigtype || transient_public_key) 4. Check that current time \u0026lt; expires 5. If valid, use transient_public_key to verify LeaseSet signature Notas de implementação: - O tamanho total varia com base no sigtype e no tipo de chave de assinatura da Destination (destino no I2P) - Tamanho mínimo: 4 + 2 + 32 (chave EdDSA) + 64 (assinatura EdDSA) = 102 bytes - Tamanho máximo prático: ~600 bytes (chave efêmera RSA-4096 + assinatura RSA-4096)\nCompatível com: - LeaseSet2 (tipo 3) - EncryptedLeaseSet (tipo 5) - MetaLeaseSet (tipo 7)\nVeja também: Proposta 123 para um protocolo de assinatura offline detalhado.\nLeaseSet2Header (cabeçalho do LeaseSet2) Descrição: Estrutura de cabeçalho comum para LeaseSet2 (tipo 3) e MetaLeaseSet (tipo 7).\nIntrodução: Versão 0.9.38 (consulte Proposta 123 )\nFormato:\n+----+----+----+----+----+----+----+----+ | destination | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ destination :: Destination Length: 387+ bytes published :: 4-byte timestamp (seconds since epoch) Publication time of this LeaseSet Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published timestamp Maximum: 65535 seconds (18.2 hours) flags :: 2 bytes (bit flags) See flag definitions below offline_signature :: OfflineSignature (optional) Present only if flags bit 0 is set Variable length Tamanho total mínimo: 395 bytes (sem assinatura offline)\nDefinições de flags (ordem dos bits: 15 14 \u0026hellip; 3 2 1 0):\nBit Name Description 0Offline Keys0 = No offline keys, 1 = Offline signature present 1Unpublished0 = Standard published, 1 = Unpublished (client-side only) 2Blinded0 = Standard, 1 = Will be blinded when published 3-15ReservedMust be 0 for compatibility **Detalhes da flag:** Bit 0 - Chaves offline: - 0: Sem assinatura offline, use a chave de assinatura do Destino para verificar a assinatura do LeaseSet - 1: A estrutura OfflineSignature (estrutura de assinatura offline) vem após o campo de flags\nBit 1 - Não publicado: - 0: LeaseSet publicado padrão, deve ser propagado aos floodfills - 1: LeaseSet não publicado (somente no lado do cliente) - NÃO deve ser propagado, publicado ou enviado em resposta a consultas - Se expirar, NÃO consultar o netdb para substituição (a menos que o bit 2 também esteja definido) - Usado para tunnels locais ou testes\nBit 2 - Ofuscado (desde 0.9.42): - 0: LeaseSet padrão - 1: Este LeaseSet não criptografado será ofuscado e criptografado quando publicado - A versão publicada será EncryptedLeaseSet (tipo 5) - Se expirar, consulte a blinded location (localização ofuscada) em netdb para substituição - Também deve definir o bit 1 como 1 (não publicado + ofuscado) - Usado para serviços ocultos criptografados\nLimites de Expiração:\nLeaseSet Type Maximum Expires Value Maximum Actual Time LeaseSet2 (type 3)≈660 seconds≈11 minutes MetaLeaseSet (type 7)65,535 seconds≈18.2 hours **Requisitos do carimbo de data/hora de publicação:** LeaseSet (tipo 1) não tinha um campo published, o que exigia buscar a expiração de lease (concessão) mais antiga para versionamento. LeaseSet2 adiciona um carimbo de data/hora published explícito com resolução de 1 segundo.\nNota crítica de implementação: - Routers DEVEM limitar a taxa de publicação de LeaseSet a muito mais lenta do que uma vez por segundo por Destino - Se publicar mais rapidamente, garanta que cada novo LeaseSet tenha published time pelo menos 1 segundo depois - Floodfills rejeitarão o LeaseSet se o published time não for mais recente do que a versão atual - Intervalo mínimo recomendado: 10-60 segundos entre publicações\nExemplos de cálculo:\nLeaseSet2 (máximo de 11 minutos):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 660 (seconds) Actual expiration = 1704067200 + 660 = 1704067860 (2024-01-01 00:11:00 UTC) MetaLeaseSet (máximo de 18,2 horas):\npublished = 1704067200 (2024-01-01 00:00:00 UTC) expires = 65535 (seconds) Actual expiration = 1704067200 + 65535 = 1704132735 (2024-01-01 18:12:15 UTC) Versionamento: - LeaseSet é considerado \u0026ldquo;mais recente\u0026rdquo; se o carimbo de data/hora published for maior - Floodfills armazenam e disseminam apenas a versão mais recente - Tenha cuidado quando a Lease (alocação temporária de túnel) mais antiga corresponder à Lease mais antiga do LeaseSet anterior\nLeaseSet2 (Tipo 3) Descrição: Formato moderno de LeaseSet com múltiplas chaves de criptografia, assinaturas offline e registros de serviço. Padrão atual para serviços ocultos no I2P.\nIntrodução: Versão 0.9.38 (ver Proposta 123 )\nEstrutura:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numk| keytype0| keylen0 | | +----+----+----+----+----+ + | encryption_key_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | keytypen| keylenn | | +----+----+----+----+ + | encryption_key_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| Lease2 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | Lease2($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes (varies with offline signature) options :: Mapping Key-value pairs for service records and metadata Length: 2+ bytes (size field + data) numk :: Integer (1 byte) Number of encryption keys Range: 1 to (implementation-defined maximum, typically 8) keytype :: 2-byte encryption type See PublicKey type table keylen :: 2-byte key length Must match keytype specification encryption_key :: PublicKey Length: keylen bytes Type: keytype [Repeat keytype/keylen/encryption_key for each key] num :: Integer (1 byte) Number of Lease2s Range: 1-16 (at least one required) leases :: Array of Lease2 structures Length: $num × 40 bytes signature :: Signature Length determined by signing key type Signed over entire structure including database type prefix Armazenamento do banco de dados: - Tipo de banco de dados: 3 - Chave: hash SHA-256 de Destination (destino I2P) - Valor: estrutura LeaseSet2 completa\nCálculo da Assinatura:\nData to sign: database_type (1 byte, value=3) || complete LeaseSet2 data Verification: 1. Prepend database type byte (0x03) to LeaseSet2 data 2. If offline signature present: - Verify offline signature against Destination key - Verify LeaseSet2 signature against transient key 3. Else: - Verify LeaseSet2 signature against Destination key Ordem de preferência de chaves de criptografia Para LeaseSet Publicado (Servidor): - Chaves listadas em ordem de preferência do servidor (mais preferidas primeiro) - Clientes que suportam vários tipos DEVERIAM respeitar a preferência do servidor - Selecione o primeiro tipo suportado da lista - Em geral, tipos de chaves com numeração mais alta (mais novos) são mais seguros/eficientes - Ordem recomendada: Liste as chaves em ordem inversa pelo código do tipo (as mais novas primeiro)\nExemplo de Preferência do Servidor:\nnumk = 2 Key 0: X25519 (type 4, 32 bytes) [Most preferred] Key 1: ElGamal (type 0, 256 bytes) [Legacy compatibility] Para LeaseSet não publicado (cliente): - A ordem das chaves efetivamente não importa (raramente são feitas tentativas de conexão a clientes) - Siga a mesma convenção para manter a consistência\nSeleção de chave do cliente: - Respeitar a preferência do servidor (selecionar o primeiro tipo suportado) - Ou usar preferência definida pela implementação - Ou determinar uma preferência combinada com base nas capacidades de ambas as partes\nMapeamento de Opções Requisitos: - As opções DEVEM ser ordenadas por chave (lexicográfica, ordem de bytes UTF-8) - A ordenação garante a invariância da assinatura - Chaves duplicadas NÃO são permitidas\nFormato Padrão (Proposta 167 ):\nA partir da API 0.9.66 (junho de 2025, versão 2.9.0), as opções de service record (registro de serviço) seguem um formato padronizado. Consulte Proposta 167 para a especificação completa.\nFormato da Opção de Registro de Serviço:\nKey: _service._proto Value: record_type ttl [priority weight] port target [appoptions] service :: Symbolic name of service (lowercase, [a-z0-9-]) Examples: smtp, http, irc, mumble Use standard identifiers from IANA Service Name Registry or Linux /etc/services when available proto :: Transport protocol (lowercase, [a-z0-9-]) \u0026#34;tcp\u0026#34; = streaming protocol \u0026#34;udp\u0026#34; = repliable datagrams Protocol indicators for raw datagrams may be defined later record_type :: \u0026#34;0\u0026#34; (self-reference) or \u0026#34;1\u0026#34; (SRV record) ttl :: Time to live in seconds (positive integer) Recommended minimum: 86400 (one day) Prevents frequent re-queries For record_type = 0 (self-reference): port :: I2CP port number (non-negative integer) appoptions :: Optional application-specific data (no spaces or commas) For record_type = 1 (SRV record): priority :: Lower value = more preferred (non-negative integer) weight :: Relative weight for same priority, higher = more likely (non-negative) port :: I2CP port number (non-negative integer) target :: Hostname or b32 of destination (lowercase) Format: \u0026#34;example.i2p\u0026#34; or \u0026#34;aaaaa...aaaa.b32.i2p\u0026#34; Recommend b32 unless hostname is \u0026#34;well known\u0026#34; appoptions :: Optional application-specific data (no spaces or commas) Exemplos de Registros de Serviço:\n1. Servidor SMTP autorreferenciado:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;0 999999 25\u0026#34; Meaning: This destination provides SMTP service on I2CP port 25 2. Servidor SMTP Externo Único:\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p\u0026#34; Meaning: SMTP service provided by bbbb...bbbb on port 25 TTL = 1 day, single server (priority=0, weight=0) 3. Vários servidores SMTP (balanceamento de carga):\nDestination: aaaa...aaaa.b32.i2p (this LeaseSet) Option: \u0026#34;_smtp._tcp\u0026#34; = \u0026#34;1 86400 0 0 25 bbbb...bbbb.b32.i2p,1 86400 1 0 25 cccc...cccc.b32.i2p\u0026#34; Meaning: Two SMTP servers bbbb...bbbb (priority=0, preferred) cccc...cccc (priority=1, backup) 4. Serviço HTTP com Opções do Aplicativo:\nOption: \u0026#34;_http._tcp\u0026#34; = \u0026#34;0 86400 80 tls=1.3;cert=ed25519\u0026#34; Meaning: HTTP on port 80 with TLS 1.3 and EdDSA certificates Recomendações de TTL (tempo de vida): - Mínimo: 86400 segundos (1 dia) - TTL mais longo reduz a carga de consultas no netdb - Equilíbrio entre a redução de consultas e a propagação de atualizações do serviço - Para serviços estáveis: 604800 (7 dias) ou mais\nNotas de Implementação:\nChaves de criptografia (a partir da versão 0.9.44):\nElGamal (tipo 0, 256 bytes): compatibilidade com versões antigas X25519 (tipo 4, 32 bytes): padrão atual Variantes MLKEM: pós-quânticas (beta, não finalizadas) Validação do Comprimento da Chave:\nFloodfills e clientes DEVEM ser capazes de analisar tipos de chave desconhecidos Use o campo keylen para ignorar chaves desconhecidas Não falhe ao analisar se o tipo de chave for desconhecido Carimbo de data/hora de publicação:\nConsulte as notas do LeaseSet2Header sobre limitação de taxa Incremento mínimo de 1 segundo entre publicações Recomendado: 10-60 segundos entre publicações Migração do tipo de criptografia:\nMúltiplas chaves permitem migração gradual Liste as chaves antigas e as novas durante o período de transição Remova a chave antiga após um período suficiente para atualização dos clientes JavaDoc: LeaseSet2 MetaLease (termo específico do I2P sem tradução estabelecida) Descrição: Estrutura de Lease para MetaLeaseSet que pode referenciar outros LeaseSets em vez de tunnels. Usado para balanceamento de carga e redundância.\nIntrodução: Versão 0.9.38, funcionamento previsto para a 0.9.40 (veja Proposta 123 )\nFormato:\n+----+----+----+----+----+----+----+----+ | tunnel_gw | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | flags |cost| end_date | +----+----+----+----+----+----+----+----+ tunnel_gw :: Hash (32 bytes) SHA-256 hash of: - Gateway RouterIdentity (for type 1), OR - Another MetaLeaseSet destination (for type 3/5/7) flags :: 3 bytes Bit order: 23 22 ... 3 2 1 0 Bits 3-0: Entry type (see table below) Bits 23-4: Reserved (must be 0) cost :: 1 byte (0-255) Lower value = higher priority Used for load balancing end_date :: 4-byte timestamp (seconds since epoch) Expiration time Rolls over in year 2106 Tamanho total: 40 bytes\nTipo de entrada (bits de flags 3-0):\nType Code Description Unknown0Unknown/invalid entry LeaseSet1Points to LeaseSet (type 1, deprecated) LeaseSet23Points to LeaseSet2 (type 3) EncryptedLeaseSet5Points to EncryptedLeaseSet (type 5) MetaLeaseSet7Points to another MetaLeaseSet (type 7) **Cenários de uso:** Balanceamento de carga:\nMetaLeaseSet (estrutura que referencia vários LeaseSet2) com várias entradas MetaLease Cada entrada aponta para um LeaseSet2 diferente Os clientes selecionam com base no campo cost Redundância:\nMúltiplas entradas apontando para LeaseSets de backup Alternativa caso o LeaseSet principal esteja indisponível Migração de Serviço:\nMetaLeaseSet aponta para um novo LeaseSet Permite uma transição suave entre destinos Uso do Campo de Custo: - Custo mais baixo = prioridade mais alta - Custo 0 = prioridade máxima - Custo 255 = prioridade mínima - Os clientes DEVERIAM preferir entradas de menor custo - Entradas de custo igual podem ser balanceadas aleatoriamente\nComparação com Lease2:\nFeature Lease2 MetaLease Size40 bytes40 bytes Tunnel ID4 bytesReplaced by flags (3 bytes) + cost (1 byte) Points ToSpecific tunnelLeaseSet or MetaLeaseSet UsageDirect tunnel referenceIndirection/load balancing **JavaDoc:** [MetaLease](http://docs.i2p-projekt.de/javadoc/net/i2p/data/MetaLease.html) MetaLeaseSet (Tipo 7) Descrição: Variante de LeaseSet que contém entradas MetaLease, fornecendo indireção para outros LeaseSets. Utilizado para balanceamento de carga, redundância e migração de serviço.\nIntrodução: Definido na 0.9.38, funcionamento previsto para a 0.9.40 (ver Proposta 123 )\nStatus: Especificação concluída. O status de implantação em produção deve ser verificado em relação às versões atuais do I2P.\nEstrutura:\n+----+----+----+----+----+----+----+----+ | ls2_header | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | num| MetaLease 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | MetaLease($num-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ |numr| | +----+ + | revocation_0 | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | revocation_n | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ ls2header :: LeaseSet2Header Length: 395+ bytes options :: Mapping Length: 2+ bytes (size + data) MUST be sorted by key num :: Integer (1 byte) Number of MetaLease entries Range: 1 to (implementation-defined, recommend 1-16) metaleases :: Array of MetaLease structures Length: $num × 40 bytes numr :: Integer (1 byte) Number of revocation hashes Range: 0 to (implementation-defined, recommend 0-16) revocations :: Array of Hash structures Length: $numr × 32 bytes SHA-256 hashes of revoked LeaseSet Destinations Armazenamento de banco de dados: - Tipo de banco de dados: 7 - Chave: hash SHA-256 do Destination (destino no I2P) - Valor: estrutura MetaLeaseSet completa\nCálculo da assinatura:\nData to sign: database_type (1 byte, value=7) || complete MetaLeaseSet data Verification: 1. Prepend database type byte (0x07) to MetaLeaseSet data 2. If offline signature present in header: - Verify offline signature against Destination key - Verify MetaLeaseSet signature against transient key 3. Else: - Verify MetaLeaseSet signature against Destination key Cenários de uso:\n1. Balanceamento de carga:\nMetaLeaseSet for primary.i2p: MetaLease 0: cost=0, points to server1.i2p LeaseSet2 MetaLease 1: cost=0, points to server2.i2p LeaseSet2 MetaLease 2: cost=0, points to server3.i2p LeaseSet2 Clients randomly select among equal-cost entries 2. Comutação por falha:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to primary.i2p LeaseSet2 MetaLease 1: cost=100, points to backup.i2p LeaseSet2 Clients prefer cost=0 (primary), fall back to cost=100 (backup) 3. Migração de Serviço:\nMetaLeaseSet for old-domain.i2p: MetaLease 0: cost=0, points to new-domain.i2p LeaseSet2 Transparently redirects clients from old to new destination 4. Arquitetura Multicamadas:\nMetaLeaseSet for service.i2p: MetaLease 0: cost=0, points to region1-meta.i2p (another MetaLeaseSet) MetaLease 1: cost=0, points to region2-meta.i2p (another MetaLeaseSet) Each region MetaLeaseSet points to regional servers Allows hierarchical load balancing Lista de Revogação:\nA lista de revogação permite que o MetaLeaseSet (termo técnico do I2P) revogue explicitamente LeaseSets publicados anteriormente:\nFinalidade: Marcar determinadas Destinations (identificadores de destino no I2P) como não mais válidas Conteúdo: Hashes SHA-256 de estruturas de Destination revogadas Uso: Clientes NÃO DEVEM usar LeaseSets cujo hash de Destination conste na lista de revogação Valor típico: Vazio (numr=0) na maioria das implantações Exemplo de Revogação:\nService migrates from dest-v1.i2p to dest-v2.i2p: MetaLease 0: points to dest-v2.i2p Revocations: [hash(dest-v1.i2p)] Clients will use v2 and ignore v1 even if cached Tratamento de expiração:\nMetaLeaseSet usa LeaseSet2Header com expires=65535 seconds no máximo (~18,2 horas):\nMuito mais longo que o LeaseSet2 (estrutura que anuncia como alcançar um destino no I2P; versão 2) (máx. ~11 minutos) Adequado para indirecionamento relativamente estático LeaseSets referenciados podem ter expiração mais curta Os clientes devem verificar a expiração tanto do MetaLeaseSet (um LeaseSet que aponta para outros LeaseSets) E dos LeaseSets referenciados Mapeamento de Opções:\nUse o mesmo formato das opções de LeaseSet2 Pode incluir registros de serviço (Proposta 167 ) DEVE ser ordenado por chave Registros de serviço normalmente descrevem o serviço final, não a estrutura de indireção Notas de Implementação do Cliente:\nProcesso de resolução:\n1. Query netdb for MetaLeaseSet using SHA-256(Destination) 2. Parse MetaLeaseSet, extract MetaLease entries 3. Sort entries by cost (lower = better) 4. For each entry in cost order: a. Extract LeaseSet hash from tunnel_gw field b. Determine entry type from flags c. Query netdb for referenced LeaseSet (may be another MetaLeaseSet) d. Check revocation list e. Check expiration f. If valid, use the LeaseSet; else try next entry Armazenamento em cache:\nArmazene em cache tanto o MetaLeaseSet (estrutura de metadados que referencia LeaseSets) quanto os LeaseSets referenciados Verifique a expiração de ambos os níveis Monitore a publicação atualizada do MetaLeaseSet Failover (comutação por falha):\nSe a entrada preferida falhar, tente a próxima opção de menor custo Considere marcar as entradas com falha como temporariamente indisponíveis Verifique novamente periodicamente para detectar recuperação Estado da implementação:\nProposal 123 observa que algumas partes ainda estão \u0026ldquo;em desenvolvimento\u0026rdquo;. Implementadores devem:\nVerificar a prontidão para produção na versão alvo do I2P Testar o suporte a MetaLeaseSet (tipo de LeaseSet com metadados) antes da implantação Verificar se há especificações atualizadas em versões mais recentes do I2P JavaDoc: MetaLeaseSet EncryptedLeaseSet (Tipo 5) Descrição: LeaseSet criptografado e cegado para privacidade aprimorada. Somente a chave pública cegada e os metadados são visíveis; os leases (entradas do LeaseSet) reais e as chaves de criptografia estão criptografados.\nIntrodução: Definido na 0.9.38, operacional a partir da 0.9.39 (ver Proposta 123 )\nEstrutura:\n+----+----+----+----+----+----+----+----+ | sigtype | | +----+----+ + | blinded_public_key | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | expires | flags | +----+----+----+----+----+----+----+----+ | offline_signature (optional) | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | len | | +----+----+ + | encrypted_data | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | signature | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ sigtype :: 2-byte signature type Type of blinded_public_key MUST be RedDSA_SHA512_Ed25519 (type 11) blinded_public_key :: SigningPublicKey (32 bytes for RedDSA) Blinded version of Destination signing key Used to verify signature on EncryptedLeaseSet published :: 4-byte timestamp (seconds since epoch) Publication time Rolls over in year 2106 expires :: 2-byte offset (seconds) Offset from published Maximum: 65535 seconds (18.2 hours) Practical maximum for LeaseSet data: ~660 seconds (~11 min) flags :: 2 bytes Bit 0: Offline signature present (0=no, 1=yes) Bit 1: Unpublished (0=published, 1=client-side only) Bits 15-2: Reserved (must be 0) offline_signature :: OfflineSignature (optional) Present only if flags bit 0 = 1 Variable length len :: 2-byte integer Length of encrypted_data Range: 1 to 65535 encrypted_data :: Encrypted payload Length: len bytes Contains encrypted LeaseSet2 or MetaLeaseSet signature :: Signature (64 bytes for RedDSA) Length determined by sigtype Signed by blinded_public_key or transient key Armazenamento de banco de dados: - Tipo de banco de dados: 5 - Chave: Hash SHA-256 da Destination ofuscada (não da Destination original) - Valor: Estrutura completa de EncryptedLeaseSet\nDiferenças cruciais em relação ao LeaseSet2:\nNÃO usa a estrutura LeaseSet2Header (tem campos semelhantes, mas disposição diferente) Chave pública ofuscada em vez da Destination (identidade criptográfica do I2P) completa Carga útil cifrada em vez de leases e chaves em claro A chave de base de dados é o hash da Destination ofuscada, não da Destination original Cálculo da Assinatura:\nData to sign: database_type (1 byte, value=5) || complete EncryptedLeaseSet data Verification: 1. Prepend database type byte (0x05) to EncryptedLeaseSet data 2. If offline signature present (flags bit 0 = 1): - Verify offline signature against blinded public key - Verify EncryptedLeaseSet signature against transient key 3. Else: - Verify EncryptedLeaseSet signature against blinded public key Requisito do tipo de assinatura:\nDEVE usar RedDSA_SHA512_Ed25519 (tipo 11): - Chaves públicas cegadas de 32 bytes - Assinaturas de 64 bytes - Necessário para as propriedades de segurança do cegamento - Consulte [especificação Red25519](//docs/specs/red25519-signature-scheme/\nPrincipais diferenças em relação ao EdDSA: - Chaves privadas por redução modular (não por clamping (mascaramento de bits)) - Assinaturas incluem 80 bytes de dados aleatórios - Usa chaves públicas diretamente (sem hashes) - Permite operação de blinding (cegamento) segura\nCegamento e Criptografia:\nConsulte a especificação do EncryptedLeaseSet (leaseSet criptografado) para detalhes completos:\n1. Cegamento de Chave:\nBlinding process (daily rotation): secret = HKDF(original_signing_private_key, date_string, \u0026#34;i2pblinding1\u0026#34;) alpha = SHA-256(secret) mod L (where L is Ed25519 group order) blinded_private_key = alpha * original_private_key blinded_public_key = alpha * original_public_key 2. Localização da base de dados:\nClient publishes to: Key = SHA-256(blinded_destination) Where blinded_destination uses: - Blinded public key (signing key) - Same unused public key field (random) - Same certificate structure 3. Camadas de Criptografia (Três Camadas):\nCamada 1 - Camada de Autenticação (Acesso do Cliente): - Criptografia: cifra de fluxo ChaCha20 - Derivação de chaves: HKDF com segredos específicos de cada cliente - Clientes autenticados podem descriptografar a camada externa\nCamada 2 - Camada de Criptografia: - Criptografia: ChaCha20 - Chave: derivada do DH (Diffie-Hellman) entre cliente e servidor - Contém o LeaseSet2 ou o MetaLeaseSet propriamente dito\nCamada 3 - LeaseSet Interno (descritor de destino do I2P): - LeaseSet2 (formato mais recente de LeaseSet) completo ou MetaLeaseSet (LeaseSet que referencia outros LeaseSets) - Inclui todos os tunnels, chaves de criptografia, opções - Apenas acessível após descriptografia bem-sucedida\nDerivação de Chave de Criptografia:\nClient has: ephemeral_client_private_key Server has: ephemeral_server_public_key (in encrypted_data) Shared secret = X25519(client_private, server_public) Encryption key = HKDF(shared_secret, context_info, \u0026#34;i2pblinding2\u0026#34;) Processo de descoberta:\nPara clientes autorizados:\n1. Client knows original Destination 2. Client computes current blinded Destination (based on current date) 3. Client computes database key: SHA-256(blinded_destination) 4. Client queries netdb for EncryptedLeaseSet using blinded key 5. Client decrypts layer 1 using authorization credentials 6. Client decrypts layer 2 using DH shared secret 7. Client extracts inner LeaseSet2/MetaLeaseSet 8. Client uses tunnels from inner LeaseSet for communication Para clientes não autorizados: - Não podem descriptografar mesmo que encontrem o EncryptedLeaseSet - Não podem determinar o Destination original a partir da versão blinded (cegamento) - Não podem vincular EncryptedLeaseSets entre diferentes períodos de blinding (rotação diária)\nPrazos de expiração:\nContent Type Maximum Expires Notes EncryptedLeaseSet (outer)65,535 sec (≈18.2 hr)Full 2-byte expires field Inner LeaseSet2≈660 sec (≈11 min)Actual lease data practical maximum Inner MetaLeaseSet65,535 sec (≈18.2 hr)Indirection can be longer-lived **Carimbo de data/hora da publicação:** Mesmos requisitos que o LeaseSet2Header: - Deve aumentar em pelo menos 1 segundo entre publicações - Os Floodfills rejeitam se não for mais recente do que a versão atual - Recomendado: 10-60 segundos entre publicações\nAssinaturas offline com Encrypted LeaseSets:\nConsiderações especiais ao usar assinaturas offline: - A chave pública cegada é rotacionada diariamente - A assinatura offline deve ser regenerada diariamente com uma nova chave cegada - OU use a assinatura offline no LeaseSet interno, não no EncryptedLeaseSet externo - Veja as notas da Proposta 123 Notas de Implementação:\nAutorização de clientes:\nVários clientes podem ser autorizados com chaves diferentes Cada cliente autorizado possui credenciais de descriptografia exclusivas Revogue um cliente alterando as chaves de autorização Rotação Diária de Chaves:\nBlinded keys (chaves cegadas) mudam à meia-noite UTC Os clientes devem recalcular diariamente o Destino cegado EncryptedLeaseSets antigos deixam de poder ser descobertos após a rotação Propriedades de Privacidade:\nFloodfills não podem determinar o Destino original Clientes não autorizados não podem acessar o serviço Períodos de blinding (ofuscação) diferentes não podem ser vinculados Sem metadados em claro além dos tempos de expiração Desempenho:\nClientes devem realizar o cálculo de cegamento diário A criptografia em três camadas adiciona sobrecarga computacional Considere armazenar em cache o LeaseSet (estrutura de metadados que descreve um destino no I2P) interno descriptografado Considerações de Segurança:\nGerenciamento de chaves de autorização:\nDistribua com segurança as credenciais de autorização do cliente Use credenciais exclusivas por cliente para revogação granular Rotacione as chaves de autorização periodicamente Sincronização do relógio:\nO blinding (cegamento criptográfico) diário depende de datas UTC sincronizadas O desvio de relógio pode causar falhas de consulta Considere oferecer suporte ao blinding do dia anterior/seguinte para tolerância Vazamento de metadados:\nOs campos Published e expires estão em texto claro A análise de padrões pode revelar características do serviço Aleatorize os intervalos de publicação, se for motivo de preocupação JavaDoc: EncryptedLeaseSet Estruturas do Router RouterAddress Descrição: Define as informações de conexão para um router por meio de um protocolo de transporte específico.\nFormato:\n+----+----+----+----+----+----+----+----+ |cost| expiration +----+----+----+----+----+----+----+----+ | transport_style | +----+----+----+----+-//-+----+----+----+ | | + + | options | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ cost :: Integer (1 byte) Relative cost, 0=free, 255=expensive Typical values: 5-6: SSU2 10-11: NTCP2 expiration :: Date (8 bytes) MUST BE ALL ZEROS (see critical note below) transport_style :: String (1-256 bytes) Transport protocol name Current values: \u0026#34;SSU2\u0026#34;, \u0026#34;NTCP2\u0026#34; Legacy: \u0026#34;SSU\u0026#34;, \u0026#34;NTCP\u0026#34; (removed) options :: Mapping Transport-specific configuration Common options: \u0026#34;host\u0026#34;, \u0026#34;port\u0026#34; Transport-specific options vary CRÍTICO - Campo de Expiração:\n⚠️ O campo de expiração DEVE ser definido para todos os zeros (8 bytes com valor zero).\nMotivo: Desde a versão 0.9.3, expiração diferente de zero causa falha na verificação da assinatura Histórico: A expiração originalmente não era usada, sempre nula Estado atual: O campo voltou a ser reconhecido a partir da 0.9.12, mas é necessário aguardar uma atualização da rede Implementação: Sempre definir como 0x0000000000000000 Qualquer valor de expiração diferente de zero fará com que a assinatura do RouterInfo falhe na validação.\nProtocolos de Transporte Protocolos atuais (a partir da versão 2.10.0):\nProtocol Status Introduced Removed Notes SSU2Current0.9.54 (May 2022)-Default since 0.9.56 NTCP2Current0.9.36 (Aug 2018)-Active NTCPRemoved-0.9.50 (May 2021)Use NTCP2 SSURemoved-2.4.0 (Dec 2023)Use SSU2 **Valores do estilo de transporte:** - `\"SSU2\"`: Transporte atual baseado em UDP - `\"NTCP2\"`: Transporte atual baseado em TCP - `\"NTCP\"`: Legado, removido (não usar) - `\"SSU\"`: Legado, removido (não usar) Opções comuns Todos os transportes normalmente incluem:\n\u0026#34;host\u0026#34; = IPv4 or IPv6 address or hostname \u0026#34;port\u0026#34; = Port number (1-65535) Opções específicas do SSU2 Consulte a especificação SSU2 (protocolo de transporte do I2P) para detalhes completos.\nOpções obrigatórias:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = UDP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Introduction key X25519 (Base64, 44 characters = 32 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Opções opcionais:\n\u0026#34;caps\u0026#34; = Capability string (e.g., \u0026#34;B\u0026#34; for bandwidth tier) \u0026#34;ihost0\u0026#34;, \u0026#34;ihost1\u0026#34;, ... = Introducer IP addresses \u0026#34;iport0\u0026#34;, \u0026#34;iport1\u0026#34;, ... = Introducer ports \u0026#34;ikey0\u0026#34;, \u0026#34;ikey1\u0026#34;, ... = Introducer static keys (Base64, 44 chars) \u0026#34;itag0\u0026#34;, \u0026#34;itag1\u0026#34;, ... = Introducer relay tags \u0026#34;iexp0\u0026#34;, \u0026#34;iexp1\u0026#34;, ... = Introducer expiration timestamps \u0026#34;mtu\u0026#34; = Maximum transmission unit (default 1500, min 1280) \u0026#34;mtu6\u0026#34; = IPv6 MTU (if different from IPv4) Exemplo SSU2 RouterAddress:\ncost: 5 expiration: 0x0000000000000000 transport_style: \u0026#34;SSU2\u0026#34; options: host=198.51.100.42 port=12345 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=QW5vdGhlciBTYW1wbGUgS2V5IGZvciBJbnRyb2R1Y3Rpb24= v=2 caps=BC mtu=1472 Opções Específicas do NTCP2 Consulte a especificação do NTCP2 para obter detalhes completos.\nOpções obrigatórias:\n\u0026#34;host\u0026#34; = IP address (IPv4 or IPv6) \u0026#34;port\u0026#34; = TCP port number \u0026#34;s\u0026#34; = Static X25519 public key (Base64, 44 characters = 32 bytes) \u0026#34;i\u0026#34; = Initialization vector (Base64, 24 characters = 16 bytes) \u0026#34;v\u0026#34; = \u0026#34;2\u0026#34; (protocol version) Opções opcionais (desde 0.9.50):\n\u0026#34;caps\u0026#34; = Capability string Exemplo de NTCP2 RouterAddress:\ncost: 10 expiration: 0x0000000000000000 transport_style: \u0026#34;NTCP2\u0026#34; options: host=198.51.100.42 port=23456 s=SGVsbG8gV29ybGQhIFRoaXMgaXMgYSBzYW1wbGUga2V5IQ== i=U2FtcGxlIElWIGhlcmU= v=2 Notas de Implementação Valores de custo:\nUDP (SSU2) normalmente tem custo menor (5-6) devido à eficiência TCP (NTCP2) normalmente tem custo mais alto (10-11) devido à sobrecarga Menor custo = transporte preferido Múltiplos Endereços:\nRouters podem publicar múltiplas entradas de RouterAddress (estrutura de endereço do router) Diferentes transportes (SSU2 e NTCP2) Diferentes versões de IP (IPv4 e IPv6) Os clientes selecionam com base em custo e capacidades Nome de host vs IP:\nEndereços IP são preferidos para melhor desempenho Nomes de host são suportados, mas adicionam sobrecarga de resolução de DNS Considere usar IP para RouterInfos publicados (metadados do router no I2P) Codificação Base64:\nTodas as chaves e os dados binários codificados em Base64 Base64 padrão (RFC 4648) Sem preenchimento ou caracteres não padrão JavaDoc: RouterAddress RouterInfo (informações do router) Descrição: Informações publicadas completas sobre um router, armazenadas no banco de dados da rede. Contém identidade, endereços e capacidades.\nFormato:\n+----+----+----+----+----+----+----+----+ | router_ident | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | published | +----+----+----+----+----+----+----+----+ |size| RouterAddress 0 | +----+ + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress 1 | + + | | ~ ~ ~ ~ | | +----+----+----+----+----+----+----+----+ | RouterAddress ($size-1) | + + | | ~ ~ ~ ~ | | +----+----+----+----+-//-+----+----+----+ |psiz| options | +----+----+----+----+-//-+----+----+----+ | signature | + + | | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ router_ident :: RouterIdentity Length: 387+ bytes (typically 391 for X25519+EdDSA) published :: Date (8 bytes) Publication timestamp (milliseconds since epoch) size :: Integer (1 byte) Number of RouterAddress entries Range: 0-255 addresses :: Array of RouterAddress Variable length Each RouterAddress has variable size peer_size :: Integer (1 byte) Number of peer hashes (ALWAYS 0) Historical, unused feature options :: Mapping Router capabilities and metadata MUST be sorted by key signature :: Signature Length determined by router_ident signing key type Typically 64 bytes (EdDSA) Signed by router_ident\u0026#39;s SigningPrivateKey Armazenamento do banco de dados: - Tipo de banco de dados: 0 - Chave: hash SHA-256 de RouterIdentity (identidade do roteador) - Valor: estrutura RouterInfo (informações do roteador) completa\nCarimbo de tempo publicado: - Data de 8 bytes (milissegundos desde a época Unix) - Usado para controle de versão do RouterInfo - Routers publicam novo RouterInfo periodicamente - Floodfills mantêm a versão mais recente com base no carimbo de tempo publicado\nOrdenação de endereços: - Histórico: routers muito antigos exigiam endereços ordenados pelo SHA-256 de seus dados - Atual: Ordenação NÃO é necessária, não vale a pena implementar por compatibilidade - Os endereços podem estar em qualquer ordem\nCampo Tamanho de Par (Histórico): - Sempre 0 no I2P moderno - Era destinado a rotas restritas (não implementado) - Se implementado, seria seguido por esse número de Router Hashes - Algumas implementações antigas podem ter exigido uma lista de pares ordenada\nMapeamento de Opções:\nAs opções DEVEM ser ordenadas por chave. As opções padrão incluem:\nOpções de capacidade:\n\u0026#34;caps\u0026#34; = Capability string Common values: f = Floodfill (network database) L or M or N or O = Bandwidth tier (L=lowest, O=highest) R = Reachable U = Unreachable/firewalled Example: \u0026#34;fLRU\u0026#34; = Floodfill, Low bandwidth, Reachable, Unreachable Opções de Rede:\n\u0026#34;netId\u0026#34; = Network ID (default \u0026#34;2\u0026#34; for main I2P network) Different values for test networks \u0026#34;router.version\u0026#34; = I2P version string Example: \u0026#34;0.9.67\u0026#34; or \u0026#34;2.10.0\u0026#34; Opções estatísticas:\n\u0026#34;stat_uptime\u0026#34; = Uptime in milliseconds \u0026#34;coreVersion\u0026#34; = Core I2P version \u0026#34;router.version\u0026#34; = Full router version string Consulte a documentação do RouterInfo do Banco de Dados da Rede para a lista completa de opções padrão.\nCálculo da Assinatura:\nData to sign: Complete RouterInfo structure from router_ident through options Verification: 1. Extract RouterIdentity from RouterInfo 2. Get SigningPublicKey from RouterIdentity (type determines algorithm) 3. Verify signature over all data preceding signature field 4. Signature must match signing key type and length RouterInfo moderno típico (estrutura de informações do router):\nRouterIdentity: 391 bytes (X25519+EdDSA with Key Certificate) Published: 8 bytes Size: 1 byte (typically 1-4 addresses) RouterAddress × N: Variable (typically 200-500 bytes each) Peer Size: 1 byte (value=0) Options: Variable (typically 50-200 bytes) Signature: 64 bytes (EdDSA) Total: ~1000-2500 bytes typical Notas de implementação:\nVários endereços:\nRouters normalmente publicam 1-4 endereços Variantes IPv4 e IPv6 Transportes SSU2 e/ou NTCP2 Cada endereço é independente Versionamento:\nUm RouterInfo (metadados do router) mais recente tem carimbo de data/hora published posterior Routers republicam a cada ~2 horas ou quando os endereços mudam Floodfills armazenam e difundem apenas a versão mais recente Validação:\nVerifique a assinatura antes de aceitar o RouterInfo (informações do router) Verifique se o campo de expiração é composto apenas por zeros em cada RouterAddress (endereço do router) Valide se o mapeamento de opções está ordenado por chave Verifique se os tipos de certificado e de chave são conhecidos/suportados Base de Dados da Rede:\nOs floodfills armazenam RouterInfo indexados por Hash(RouterIdentity) Armazenados por ~2 dias após a última publicação Routers consultam os floodfills para descobrir outros Routers JavaDoc: RouterInfo Notas de Implementação Ordem de bytes (Endianness) Padrão: Big-Endian (ordem de bytes de rede)\nA maioria das estruturas do I2P usa ordem de bytes big-endian (byte mais significativo primeiro): - Todos os tipos inteiros (1-8 bytes) - Carimbos de data e hora - TunnelId - Prefixo de tamanho de String - Tipos e comprimentos de certificado - Códigos de tipo de chave - Campos de tamanho de mapeamento\nExceção: Little-Endian (ordem de bytes onde o menos significativo vem primeiro)\nOs seguintes tipos de chave usam codificação little-endian: - X25519 chaves de criptografia (tipo 4) - EdDSA_SHA512_Ed25519 chaves de assinatura (tipo 7) - EdDSA_SHA512_Ed25519ph chaves de assinatura (tipo 8) - RedDSA_SHA512_Ed25519 chaves de assinatura (tipo 11)\nImplementação:\n// Big-endian (most structures) int value = ((bytes[0] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[3] \u0026amp; 0xFF); // Little-endian (X25519, EdDSA, RedDSA) int value = (bytes[0] \u0026amp; 0xFF) | ((bytes[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24); Versionamento de Estruturas Nunca presuma tamanhos fixos:\nMuitas estruturas têm tamanho variável: - RouterIdentity: 387+ bytes (nem sempre é 387) - Destination: 387+ bytes (nem sempre é 387) - LeaseSet2: Varia significativamente - Certificate: 3+ bytes\nSempre leia os campos de tamanho: - Tamanho do certificado nos bytes 1-2 - Tamanho do mapeamento no início - KeysAndCert sempre é calculado como 384 + 3 + certificate_length\nVerifique se há dados em excesso: - Proibir dados residuais após estruturas válidas - Validar se os comprimentos dos certificados correspondem aos tipos de chave - Impor os comprimentos exatos esperados para tipos de tamanho fixo\nRecomendações atuais (outubro de 2025) Para novas identidades de router:\nEncryption: X25519 (type 4, 32 bytes) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/pt/proposals/161-ri-dest-padding/) Para novos destinos:\nUnused Public Key Field: 256 bytes random (compressible) Signing: EdDSA_SHA512_Ed25519 (type 7, 32 bytes) Certificate: Key Certificate (type 5) Total Size: 391 bytes Padding: Compressible per [Proposal 161](/pt/proposals/161-ri-dest-padding/) Para novos LeaseSets:\nType: LeaseSet2 (type 3) Encryption Keys: X25519 (type 4, 32 bytes) Leases: At least 1, typically 3-5 Options: Include service records per [Proposal 167](/proposals/167-service-records/) Signature: EdDSA (64 bytes) Para serviços criptografados:\nType: EncryptedLeaseSet (type 5) Blinding: RedDSA_SHA512_Ed25519 (type 11) Inner LeaseSet: LeaseSet2 (type 3) Rotation: Daily blinding key rotation Authorization: Per-client encryption keys Funcionalidades obsoletas - Não utilizar Criptografia obsoleta: - ElGamal (tipo 0) para Identidades de Router (obsoleto desde 0.9.58) - Criptografia ElGamal/AES+SessionTag (rótulo de sessão) (use ECIES-X25519)\nAssinaturas descontinuadas: - DSA_SHA1 (tipo 0) para Identidades do Router (descontinuado em 0.9.58) - Variantes ECDSA (tipos 1-3) para novas implementações - Variantes RSA (tipos 4-6) exceto para arquivos SU3\nFormatos de Rede Obsoletos: - LeaseSet tipo 1 (use LeaseSet2) - Lease (44 bytes, use Lease2) - Formato Original de Expiração do Lease\nTransportes obsoletos: - NTCP (removido na versão 0.9.50) - SSU (removido na versão 2.4.0)\nCertificados obsoletos: - HASHCASH (tipo 1) - HIDDEN (tipo 2) - SIGNED (tipo 3) - MULTIPLE (tipo 4)\nConsiderações de Segurança Geração de Chaves: - Use sempre geradores de números aleatórios criptograficamente seguros - Nunca reutilize chaves em diferentes contextos - Proteja as chaves privadas com controles de acesso apropriados - Apague com segurança o material das chaves da memória quando terminar\nVerificação de Assinaturas: - Sempre verifique as assinaturas antes de confiar nos dados - Verifique se o tamanho da assinatura corresponde ao tipo de chave - Valide se os dados assinados incluem os campos esperados - Para mapeamentos ordenados, verifique a ordem de classificação antes de assinar/verificar\nValidação de carimbo de data/hora: - Verifique se as datas/horários publicados são razoáveis (não muito no futuro) - Valide se as expirações dos leases (alocações temporárias de túnel) não estão vencidas - Considere a tolerância ao desvio de relógio (±30 segundos típico)\nNetwork Database: - Validar todas as estruturas antes de armazenar - Aplicar limites de tamanho para evitar DoS - Limitar a taxa de consultas e publicações - Verificar se as chaves do banco de dados correspondem aos hashes das estruturas\nNotas de Compatibilidade Compatibilidade com versões anteriores: - ElGamal e DSA_SHA1 ainda são suportados para routers legados - Tipos de chave obsoletos continuam funcionais, mas são desaconselhados - Preenchimento compressível (Proposal 161 ) é retrocompatível até a versão 0.6\nCompatibilidade futura: - Tipos de chave desconhecidos podem ser analisados usando campos de comprimento - Tipos de certificado desconhecidos podem ser ignorados usando o comprimento - Tipos de assinatura desconhecidos devem ser tratados de forma adequada - Implementadores não devem falhar diante de recursos opcionais desconhecidos\nEstratégias de migração: - Suportar tanto tipos de chave antigos quanto novos durante a transição - LeaseSet2 pode listar várias chaves de criptografia - Assinaturas offline permitem rotação segura de chaves - MetaLeaseSet permite migração transparente de serviços\nTestes e Validação Validação da Estrutura: - Verifique se todos os campos de tamanho estão dentro dos intervalos esperados - Verifique se estruturas de tamanho variável são analisadas corretamente - Valide se as assinaturas são verificadas com sucesso - Teste com estruturas de tamanho mínimo e máximo\nCasos limite: - Strings de comprimento zero - Mapeamentos vazios - Número mínimo e máximo de leases (descritor de túnel de entrada do I2P) - Certificado com carga útil de comprimento zero - Estruturas muito grandes (próximas aos tamanhos máximos)\nInteroperabilidade: - Testar contra a implementação oficial do I2P em Java - Verificar a compatibilidade com i2pd - Testar com vários conteúdos do banco de dados da rede - Validar contra vetores de teste conhecidos como válidos\nReferências Especificações Protocolo I2NP Protocolo I2CP Transporte SSU2 Transporte NTCP2 Protocolo de Tunnel Protocolo de Datagramas Criptografia Visão geral da criptografia Criptografia ElGamal/AES Criptografia ECIES-X25519 ECIES para Routers ECIES híbrido (pós-quântico) Assinaturas Red25519 LeaseSet criptografado Propostas Proposta 123: Novas entradas no netDB Proposta 134: Tipos de assinatura GOST Proposta 136: Tipos de assinatura experimentais Proposta 145: ECIES-P256 Proposta 156: ECIES Routers Proposta 161: Geração de Padding (preenchimento) Proposta 167: Registros de serviço Proposta 169: Criptografia pós-quântica Índice de todas as propostas Banco de Dados da Rede Visão geral do banco de dados da rede Opções padrão do RouterInfo Referência da API do JavaDoc Pacote de dados do núcleo PublicKey PrivateKey SessionKey SigningPublicKey SigningPrivateKey Signature Hash SessionTag TunnelId Certificate DataHelper KeysAndCert RouterIdentity Destination Lease LeaseSet Lease2 LeaseSet2 MetaLease MetaLeaseSet EncryptedLeaseSet RouterAddress RouterInfo Padrões Externos RFC 7748 (X25519): Curvas elípticas para segurança RFC 7539 (ChaCha20): ChaCha20 e Poly1305 para protocolos da IETF RFC 4648 (Base64): As codificações de dados Base16, Base32 e Base64 FIPS 180-4 (SHA-256): Padrão de Hash Seguro FIPS 204 (ML-DSA): Padrão de Assinatura Digital baseado em reticulados modulares Registro de Serviços da IANA Recursos da comunidade Site do I2P Fórum do I2P GitLab do I2P Espelho do I2P no GitHub Índice da Documentação Técnica Informações de lançamento Lançamento do I2P 2.10.0 Histórico de lançamentos Registro de alterações Apêndice: Tabelas de Referência Rápida Referência Rápida de Tipos de Chave Padrão atual (recomendado para todas as novas implementações): - Criptografia: X25519 (tipo 4, 32 bytes, little-endian) - Assinatura: EdDSA_SHA512_Ed25519 (tipo 7, 32 bytes, little-endian)\nLegado (suportado, mas obsoleto): - Criptografia: ElGamal (tipo 0, 256 bytes, big-endian) - Assinatura: DSA_SHA1 (tipo 0, 20 bytes (privada) / 128 bytes (pública), big-endian)\nEspecializado: - Assinatura (LeaseSet criptografado): RedDSA_SHA512_Ed25519 (tipo 11, 32 bytes, little-endian)\nPós-quântico (Beta, não finalizado): - Criptografia híbrida: variantes MLKEM_X25519 (tipos 5-7) - Criptografia pós-quântica pura: variantes MLKEM (ainda sem códigos de tipo atribuídos)\nReferência rápida de tamanhos de estruturas Structure Minimum Size Typical Size Maximum Size Integer1 byteVaries8 bytes Date8 bytes8 bytes8 bytes String1 byteVaries256 bytes SessionKey32 bytes32 bytes32 bytes Hash32 bytes32 bytes32 bytes TunnelId4 bytes4 bytes4 bytes Certificate3 bytes7 bytes65,538 bytes KeysAndCert387 bytes391 bytes≈1000+ bytes RouterIdentity387 bytes391 bytes≈1000+ bytes Destination387 bytes391 bytes≈1000+ bytes Lease44 bytes44 bytes44 bytes Lease240 bytes40 bytes40 bytes LeaseSet≈1000 bytes≈1200 bytes≈2000+ bytes LeaseSet2≈500 bytes≈800 bytes≈2000+ bytes EncryptedLeaseSet≈600 bytes≈1000 bytes≈3000+ bytes RouterAddress≈150 bytes≈300 bytes≈600 bytes RouterInfo≈1000 bytes≈1500 bytes≈3000+ bytes ### Referência rápida de tipos de banco de dados Type Structure Status Notes 0RouterInfoCurrentStored under Hash(RouterIdentity) 1LeaseSetDeprecatedUse LeaseSet2 instead 3LeaseSet2CurrentStored under Hash(Destination) 5EncryptedLeaseSetCurrentStored under Hash(Blinded Destination) 7MetaLeaseSetDefinedVerify production status ### Referência Rápida do Protocolo de Transporte Protocol Status Port Type Since Notes SSU2CurrentUDP0.9.54Default since 0.9.56 NTCP2CurrentTCP0.9.36Active SSURemovedUDP-Removed in 2.4.0 NTCPRemovedTCP-Removed in 0.9.50 ### Referência rápida de marcos de versão Version API Date Key Changes 0.60.6.x2005Destination encryption disabled 0.9.120.9.12Dec 2013Key Certificates introduced 0.9.150.9.15Sep 2015EdDSA support added 0.9.160.9.16Nov 2015Router Key Certificates 0.9.360.9.36Aug 2018NTCP2 introduced 0.9.380.9.38Nov 2018LeaseSet2, X25519 for Destinations 0.9.390.9.39Dec 2018EncryptedLeaseSet working 0.9.480.9.48Jul 2020X25519 for Router Identities 0.9.500.9.50May 2021NTCP removed 0.9.540.9.54May 2022SSU2 testing 0.9.570.9.57Jan 2023[Proposal 161](/pt/proposals/161-ri-dest-padding/) padding (release 2.1.0) 0.9.580.9.58Mar 2023ElGamal/DSA deprecated for RIs (2.2.0) 0.9.660.9.66Jun 2025[Proposal 167](/proposals/167-service-records/) service records (2.9.0) 0.9.670.9.67Sep 2025ML-KEM beta support (2.10.0) --- ","description":"Tipos de dados compartilhados e formatos de serialização utilizados nas especificações do I2P","id":"178a1cfe9e5d2970a6e9f8d07c374b78","section":"docs","title":"Estruturas Comuns","url":"/pt/docs/specs/common-structures/"},{"categories":null,"content":"Hospedar o GitLab dentro do I2P é simples: execute o container omnibus do GitLab, exponha-o no loopback e encaminhe o tráfego através de um túnel I2P. Os passos abaixo refletem a configuração usada para git.idk.i2p, mas funcionam para qualquer instância auto-hospedada.\n1. Pré-requisitos Debian ou outra distribuição Linux com Docker Engine instalado (sudo apt install docker.io ou docker-ce do repositório do Docker). Um router I2P (Java I2P ou i2pd) com largura de banda suficiente para servir seus usuários. Opcional: uma VM dedicada para que o GitLab e o router permaneçam isolados do seu ambiente desktop. 2. Baixar a Imagem do GitLab docker pull gitlab/gitlab-ce:latest A imagem oficial é construída a partir de camadas base do Ubuntu e atualizada regularmente. Audite o Dockerfile se você precisar de garantias adicionais.\n3. Decidir entre Bridging e I2P-Only Somente I2P instâncias nunca contactam hosts da clearnet. Os utilizadores podem espelhar repositórios de outros serviços I2P, mas não do GitHub/GitLab.com. Isto maximiza o anonimato. Com ponte instâncias acedem a hosts Git da clearnet através de um proxy HTTP. Isto é útil para espelhar projetos públicos para a I2P, mas desanonimiza as requisições de saída do servidor. Se você escolher o modo bridged, configure o GitLab para usar um proxy HTTP I2P vinculado ao host Docker (por exemplo http://172.17.0.1:4446). O proxy padrão do router escuta apenas em 127.0.0.1; adicione um novo túnel proxy vinculado ao endereço do gateway Docker.\n4. Iniciar o Container docker run --detach \\ --env HTTP_PROXY=http://172.17.0.1:4446 \\ # omit for I2P-only --publish 127.0.0.1:8443:443 \\ --publish 127.0.0.1:8080:80 \\ --publish 127.0.0.1:8022:22 \\ --name gitlab \\ --restart always \\ --volume /srv/gitlab/config:/etc/gitlab:Z \\ --volume /srv/gitlab/logs:/var/log/gitlab:Z \\ --volume /srv/gitlab/data:/var/opt/gitlab:Z \\ gitlab/gitlab-ce:latest Vincule as portas publicadas ao loopback; os túneis I2P irão expô-las conforme necessário. Substitua /srv/gitlab/... por caminhos de armazenamento adequados ao seu host. Quando o container estiver em execução, visite https://127.0.0.1:8443/, defina uma senha de administrador e configure os limites da conta.\n5. Expor o GitLab Através do I2P Crie três túneis servidor I2PTunnel:\nPurpose Local target Suggested inbound port HTTPS web UI 127.0.0.1:8443 auto-generated HTTP web UI (optional) 127.0.0.1:8080 auto-generated SSH push/pull 127.0.0.1:8022 auto-generated Configure cada túnel com comprimentos de túnel e largura de banda apropriados. Para instâncias públicas, 3 saltos com 4–6 túneis por direção é um bom ponto de partida. Publique os destinos Base32/Base64 resultantes em sua página inicial para que os usuários possam configurar túneis cliente. Destination Enforcement Se você usar túneis HTTP(S), ative a imposição de destino para que apenas o hostname pretendido possa alcançar o serviço. Isso impede que o túnel seja usado indevidamente como um proxy genérico.\n6. Maintenance Tips Execute docker exec gitlab gitlab-ctl reconfigure sempre que alterar as configurações do GitLab. Monitore o uso de disco (/srv/gitlab/data)—repositórios Git crescem rapidamente. Faça backup dos diretórios de configuração e dados regularmente. As tarefas rake de backup do GitLab funcionam dentro do contêiner. Considere colocar um tunnel de monitoramento externo em modo cliente para garantir que o serviço seja acessível a partir da rede mais ampla. 6. Dicas de Manutenção Incorporar I2P na sua aplicação Git sobre I2P (guia do cliente) Git bundles para redes offline/lentas Uma instância GitLab bem configurada oferece um hub de desenvolvimento colaborativo totalmente dentro do I2P. Mantenha o router saudável, mantenha-se atualizado com as atualizações de segurança do GitLab e coordene com a comunidade à medida que sua base de usuários cresce.\n","description":"Implantando GitLab dentro do I2P usando Docker e um roteador I2P","id":"0c6aba5984de265324df6360a00204c9","section":"docs","title":"Executando o GitLab sobre I2P","url":"/pt/docs/guides/gitlab/"},{"categories":null,"content":"Filtros de acesso permitem aos operadores de servidores I2PTunnel autorizar, negar ou limitar conexões de entrada com base na Destination (identificador de destino no I2P) de origem e na taxa recente de conexões. O filtro é um arquivo de texto simples com regras. O arquivo é lido de cima para baixo e a primeira regra correspondente prevalece.\nAlterações na definição do filtro entram em vigor na reinicialização do tunnel. Algumas compilações podem reler listas baseadas em arquivos em tempo de execução, mas planeje uma reinicialização para garantir que as alterações sejam aplicadas.\nFormato de arquivo Uma regra por linha. Linhas em branco são ignoradas. # inicia um comentário que vai até o fim da linha. As regras são avaliadas em ordem; a primeira correspondência é usada. Limiares Um limiar define quantas tentativas de conexão de uma única Destination (identificador de destino no I2P) são permitidas em uma janela de tempo móvel.\nNumérico: N/S significa permitir N conexões a cada S segundos. Exemplo: 15/5 permite até 15 conexões a cada 5 segundos. A tentativa N+1 dentro da janela é rejeitada. Palavras-chave: allow significa sem limite. deny significa sempre rejeitar. Sintaxe de regras As regras têm o seguinte formato:\n\u0026lt;threshold\u0026gt; \u0026lt;scope\u0026gt; \u0026lt;target\u0026gt; Onde:\n\u0026lt;threshold\u0026gt; é N/S, allow ou deny \u0026lt;scope\u0026gt; é um dentre default, explicit, file ou record (veja abaixo) \u0026lt;target\u0026gt; depende do escopo Regra padrão Aplica-se quando nenhuma outra regra corresponde. Apenas uma regra padrão é permitida. Se omitida, Destinos desconhecidos são permitidos sem restrições.\n15/5 default allow default deny default Regra explícita Aponta para um Destino específico pelo endereço Base32 (por exemplo example1.b32.i2p) ou pela chave completa.\n15/5 explicit example1.b32.i2p deny explicit example2.b32.i2p allow explicit example3.b32.i2p Regra baseada em arquivo Aplica-se a todos os Destinos listados em um arquivo externo. Cada linha contém um Destino; comentários iniciados por # e linhas em branco são permitidos.\n15/5 file /var/i2p/throttled.txt deny file /var/i2p/blocked.txt allow file /var/i2p/trusted.txt Nota operacional: Algumas implementações releem listas de arquivos periodicamente. Se você editar uma lista enquanto o tunnel estiver em execução, espere um pequeno atraso até que as alterações sejam detectadas. Reinicie para aplicar imediatamente.\nGravador (controle progressivo) Um recorder (registrador) monitora tentativas de conexão e grava em um arquivo os Destinos que excedem um limite. Você pode então referenciar esse arquivo em uma regra file para aplicar limitações ou bloqueios a tentativas futuras.\n# Start permissive allow default # Record Destinations exceeding 30 connections in 5 seconds 30/5 record /var/i2p/aggressive.txt # Apply throttling to recorded Destinations 15/5 file /var/i2p/aggressive.txt Verifique o suporte ao gravador no seu build antes de depender dele. Use listas file para um comportamento garantido.\nOrdem de avaliação Coloque as regras específicas primeiro, depois as gerais. Um padrão comum:\nPermissões explícitas para pares confiáveis Negações explícitas para abusadores conhecidos Listas de permissão/bloqueio baseadas em arquivos Registradores para limitação progressiva Regra padrão para cobrir todos os casos Exemplo completo # Moderate limits by default 30/10 default # Always allow trusted peers allow explicit friend1.b32.i2p allow explicit friend2.b32.i2p # Block known bad actors deny file /var/i2p/blocklist.txt # Throttle aggressive sources 15/5 file /var/i2p/throttle.txt # Automatically populate the throttle list 60/5 record /var/i2p/throttle.txt Notas de implementação O filtro de acesso opera na camada de tunnel, antes do tratamento pela aplicação, para que o tráfego abusivo possa ser rejeitado logo no início. Coloque o arquivo de filtro no seu diretório de configuração do I2PTunnel e reinicie o tunnel para aplicar as alterações. Compartilhe listas baseadas em arquivo entre vários tunnels se quiser uma política consistente entre serviços. ","description":"Sintaxe dos arquivos de filtro de controle de acesso do tunnel","id":"d8b5745531fca07ea47765403a9a4d0c","section":"docs","title":"Formato do filtro de acesso","url":"/pt/docs/specs/filter-format/"},{"categories":null,"content":"Visão geral Os plugins do I2P são arquivos assinados que ampliam a funcionalidade do router. Eles são distribuídos como arquivos .xpi2p ou .su3, instalam-se em ~/.i2p/plugins/\u0026lt;name\u0026gt;/ (ou %APPDIR%\\I2P\\plugins\\\u0026lt;name\u0026gt;\\ no Windows) e executam com permissões completas do router, sem sandboxing (sem ambiente de isolamento).\nTipos de plugins suportados Aplicativos web do Console Novos eepsites com cgi-bin, aplicativos web Temas do Console Traduções do Console Programas Java (no mesmo processo ou em uma JVM separada) Scripts de shell e binários nativos Modelo de Segurança CRÍTICO: Plugins são executados na mesma JVM (Máquina Virtual Java) com permissões idênticas às do I2P router. Têm acesso irrestrito a: - Sistema de arquivos (leitura e escrita) - APIs do router e estado interno - Conexões de rede - Execução de programas externos\nPlugins devem ser tratados como código de total confiança. Os usuários devem verificar as origens e as assinaturas dos plugins antes da instalação.\nFormatos de arquivo Formato SU3 (Altamente recomendado) Status: Ativo, formato preferido desde o I2P 0.9.15 (setembro de 2014)\nO formato .su3 oferece: - chaves de assinatura RSA-4096 (vs. DSA-1024 em xpi2p) - Assinatura armazenada no cabeçalho do arquivo - Número mágico: I2Psu3 - Melhor compatibilidade futura\nEstrutura:\n[SU3 Header with RSA-4096 signature] [ZIP Archive] ├── plugin.config (required) ├── console/ ├── lib/ ├── webapps/ └── [other plugin files] Formato XPI2P (Legado, Obsoleto) Status: Suportado para compatibilidade com versões anteriores, não recomendado para novos plugins\nO formato .xpi2p usa assinaturas criptográficas mais antigas: - Assinaturas DSA-1024 (obsoletas segundo a NIST-800-57) - Assinatura DSA de 40 bytes anteposta ao ZIP - Requer o campo key em plugin.config\nEstrutura:\n[40-byte DSA signature] [16-byte version string (UTF-8, zero-padded)] [ZIP Archive] Caminho de migração: Ao migrar de xpi2p para su3, forneça tanto updateURL quanto updateURL.su3 durante a transição. Os routers modernos (0.9.15+) priorizam automaticamente SU3.\nEstrutura do arquivo e plugin.config Arquivos necessários plugin.config - Arquivo de configuração padrão do I2P com pares chave-valor\nPropriedades obrigatórias Property Description Format nameInstallation directory name, must match for updatesAlphanumeric, no spaces signerDeveloper contact informationuser@mail.i2p format recommended versionPlugin version for update comparisonMax 16 bytes, parsed by VersionComparator keyDSA public key (172 B64 chars ending with '=')Omit for SU3 format **Exemplos de formato de versão:** - `1.2.3` - `1.2.3-4` - `2.0.0-beta.1` Separadores válidos: . (ponto), - (hífen), _ (sublinhado)\nPropriedades de Metadados Opcionais Informações de exibição date - Data de lançamento (carimbo de data/hora long do Java) author - Nome do desenvolvedor (recomendado user@mail.i2p) description - Descrição em inglês description_xx - Descrição localizada (xx = código de idioma) websiteURL - Página inicial do plugin (http://foo.i2p/) license - Identificador da licença (por exemplo, \u0026ldquo;Apache-2.0\u0026rdquo;, \u0026ldquo;GPL-3.0\u0026rdquo;) Configuração de Atualização updateURL - Local de atualização do XPI2P (legado) updateURL.su3 - Local de atualização do SU3 (preferido) min-i2p-version - Versão mínima do I2P exigida max-i2p-version - Versão máxima do I2P compatível min-java-version - Versão mínima do Java (por exemplo, 1.7, 17) min-jetty-version - Versão mínima do Jetty (use 6 para Jetty 6+) max-jetty-version - Versão máxima do Jetty (use 5.99999 para Jetty 5) Comportamento da Instalação dont-start-at-install - Padrão false. Se true, exige início manual router-restart-required - Padrão false. Informa ao usuário que é necessário reiniciar após a atualização update-only - Padrão false. Falha se o plugin ainda não estiver instalado install-only - Padrão false. Falha se o plugin já estiver instalado min-installed-version - Versão mínima necessária para a atualização max-installed-version - Versão máxima que pode ser atualizada disableStop - Padrão false. Oculta o botão de parar se true Integração com o Console consoleLinkName - Texto para o link da barra de resumo do console consoleLinkName_xx - Texto do link localizado (xx = código de idioma) consoleLinkURL - Destino do link (por exemplo, /appname/index.jsp) consoleLinkTooltip - Texto exibido ao passar o mouse (suportado desde 0.7.12-6) consoleLinkTooltip_xx - Dica de ferramenta localizada console-icon - Caminho para o ícone de 32x32 (suportado desde 0.9.20) icon-code - PNG 32x32 codificado em Base64 para plugins sem recursos web (desde 0.9.25) Requisitos de Plataforma (somente exibição) required-platform-OS - Requisito do sistema operacional (não imposto) other-requirements - Requisitos adicionais (por exemplo, \u0026ldquo;Python 3.8+\u0026rdquo;) Gerenciamento de dependências (Não implementado) depends - Dependências do plugin, separadas por vírgulas depends-version - Requisitos de versão para as dependências langs - Conteúdo do pacote de idiomas type - Tipo de plugin (app/theme/locale/webapp) Substituição de variáveis na URL de atualização Estado da funcionalidade: Disponível desde I2P 1.7.0 (0.9.53)\nTanto updateURL quanto updateURL.su3 suportam variáveis específicas da plataforma:\nVariáveis: - $OS - Sistema operacional: windows, linux, mac - $ARCH - Arquitetura: 386, amd64, arm64\nExemplo:\nupdateURL.su3=http://foo.i2p/downloads/foo-$OS-$ARCH.su3 Resultado no Windows AMD64:\nhttp://foo.i2p/downloads/foo-windows-amd64.su3 Isso permite um único arquivo plugin.config para compilações específicas da plataforma.\nEstrutura de diretórios Layout padrão plugins/ └── pluginname/ ├── plugin.config (required) ├── console/ │ ├── locale/ # Translation JARs │ ├── themes/ # Console themes │ ├── webapps/ # Web applications │ └── webapps.config # Webapp configuration ├── eepsite/ │ ├── cgi-bin/ │ ├── docroot/ │ ├── logs/ │ ├── webapps/ │ └── jetty.xml ├── lib/ │ └── *.jar # Plugin libraries └── clients.config # Client startup configuration Finalidades do Diretório console/locale/ - Arquivos JAR com conjuntos de recursos para as traduções básicas do I2P - As traduções específicas de plugins devem estar em console/webapps/*.war ou lib/*.jar\nconsole/themes/ - Cada subdiretório contém um tema completo do console - Adicionado automaticamente ao caminho de busca de temas\nconsole/webapps/ - arquivos .war para integração com o console - Iniciados automaticamente, a menos que desativados em webapps.config - O nome do WAR não precisa corresponder ao nome do plugin\neepsite/ - eepsite completo com sua própria instância do Jetty - Requer configuração de jetty.xml com substituição de variáveis - Veja exemplos de zzzot e do plugin pebble\nlib/ - Bibliotecas JAR de plug-ins - Especifique no classpath via clients.config ou webapps.config\nConfiguração do aplicativo web Formato de webapps.config Arquivo de configuração padrão do I2P que controla o comportamento do aplicativo web.\nSintaxe:\n# Disable autostart webapps.warname.startOnLoad=false # Add classpath JARs (as of API 0.9.53, works for any warname) webapps.warname.classpath=$PLUGIN/lib/foo.jar,$I2P/lib/bar.jar Notas importantes: - Antes do router 0.7.12-9, use plugin.warname.startOnLoad para compatibilidade - Antes da API 0.9.53, classpath só funcionava se o warname (nome do WAR) correspondesse ao nome do plugin - A partir da 0.9.53+, classpath funciona para qualquer nome de webapp (aplicativo web)\nBoas práticas para aplicações web Implementação de ServletContextListener\nImplemente javax.servlet.ServletContextListener para limpeza Ou sobrescreva destroy() no servlet Garante o encerramento adequado durante atualizações e a parada do router Gerenciamento de Bibliotecas\nColoque JARs compartilhados em lib/, não dentro do WAR Referencie pelo classpath em webapps.config Permite a instalação/atualização separada de plugins Evite bibliotecas conflitantes\nNunca empacote Jetty, Tomcat ou JARs de servlet Nunca empacote JARs da instalação padrão do I2P Verifique a seção classpath para bibliotecas padrão Requisitos de Compilação\nNão incluir arquivos de código-fonte .java ou .jsp Pré-compilar todas as JSPs para evitar atrasos na inicialização Não se pode presumir a disponibilidade de um compilador Java/JSP Compatibilidade com a Servlet API\nO I2P suporta Servlet 3.0 (desde 0.9.30) Varredura de anotações NÃO é suportada (@WebContent) É necessário fornecer o descritor de implantação tradicional web.xml Versão do Jetty\nAtual: Jetty 9 (I2P 0.9.30+) Use net.i2p.jetty.JettyStart como camada de abstração Protege contra alterações na API do Jetty Configuração do Cliente Formato de clients.config Define os clientes (serviços) iniciados com o plugin.\nCliente básico:\nclientApp.0.main=com.example.PluginMain clientApp.0.name=Example Plugin Service clientApp.0.delay=30 clientApp.0.args=arg1 arg2 $PLUGIN/config.properties Cliente com Parar/Desinstalar:\nclientApp.0.stopargs=stop clientApp.0.uninstallargs=uninstall clientApp.0.classpath=$PLUGIN/lib/plugin.jar,$I2P/lib/i2p.jar Referência de Propriedades Property Description mainFully qualified class name implementing ClientApp interface nameDisplay name for user interface delayStartup delay in seconds (default: 0) argsSpace-separated arguments passed to constructor stopargsArguments for shutdown (must handle gracefully) uninstallargsArguments called before plugin deletion classpathComma-separated JAR paths ### Substituição de Variáveis As seguintes variáveis são substituídas em args, stopargs, uninstallargs e classpath:\nVariable Replacement $I2PI2P base installation directory $CONFIGI2P configuration directory (typically ~/.i2p) $PLUGINThis plugin's directory ($CONFIG/plugins/name) $OSOperating system: windows, linux, mac $ARCHArchitecture: 386, amd64, arm64 ### Clientes Gerenciados vs. Não Gerenciados Clientes gerenciados (Recomendados, desde 0.9.4): - Instanciados por ClientAppManager - Mantêm rastreamento de referências e de estado - Gerenciamento do ciclo de vida mais fácil - Melhor gerenciamento de memória\nClientes não gerenciados: - Iniciados pelo router, sem rastreamento de estado - Devem lidar de forma adequada com múltiplas chamadas de início/parada - Use estado estático ou arquivos PID para coordenação - Chamados no desligamento do router (a partir da versão 0.7.12-3)\nShellService (desde 0.9.53 / 1.7.0) Solução generalizada para executar programas externos com rastreamento automático de estado.\nRecursos: - Gerencia o ciclo de vida do processo - Comunica-se com o ClientAppManager - Gerenciamento automático de PID - Suporte multiplataforma\nUso:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myservice.sh Para scripts específicos da plataforma:\nclientApp.0.args=$PLUGIN/bin/myservice-$OS.$ARCH Alternativa (legado): Escreva um wrapper (camada de encapsulamento) em Java que verifique o tipo de sistema operacional e chame ShellCommand com o arquivo .bat ou .sh apropriado.\nProcesso de Instalação Fluxo de Instalação do Usuário O usuário cola a URL do plugin na Página de Configuração de Plugins do Console do Router (/configplugins) O Router faz o download do arquivo do plugin Verificação da assinatura (falha se a chave for desconhecida e o modo estrito estiver ativado) Verificação de integridade do ZIP Extrair e analisar plugin.config Verificação de compatibilidade de versão (min-i2p-version, min-java-version, etc.) Detecção de conflito de nome de aplicação web Parar o plugin existente em caso de atualização Validação do diretório (deve estar sob plugins/) Extrair todos os arquivos para o diretório do plugin Atualizar plugins.config Iniciar o plugin (a menos que dont-start-at-install=true) Segurança e Confiança Gerenciamento de chaves: - Modelo de confiança First-key-seen (primeira chave vista) para novos signatários - Apenas as chaves de jrandom e zzz vêm pré-incluídas - A partir da 0.9.14.1, chaves desconhecidas são rejeitadas por padrão - Uma propriedade avançada pode sobrescrever para desenvolvimento\nRestrições de Instalação: - Arquivos compactados devem ser extraídos apenas no diretório do plugin - O instalador rejeita caminhos fora de plugins/ - Os plugins podem acessar arquivos em outros locais após a instalação - Sem sandboxing (ambiente isolado) ou isolamento de privilégios\nMecanismo de Atualização Processo de verificação de atualizações Router lê updateURL.su3 (preferido) ou updateURL de plugin.config Solicitação HTTP HEAD ou GET parcial para obter os bytes 41-56 Extrair a string de versão do arquivo remoto Comparar com a versão instalada usando VersionComparator Se for mais recente, solicitar ao usuário ou baixar automaticamente (com base nas configurações) Parar o plugin Instalar a atualização Iniciar o plugin (a menos que a preferência do usuário tenha sido alterada) Comparação de versões Versões interpretadas como componentes separados por ponto/hífen/sublinhado: - 1.2.3 \u0026lt; 1.2.4 - 1.2.3 \u0026lt; 1.2.3-1 - 2.0.0 \u0026gt; 1.9.9\nComprimento máximo: 16 bytes (deve corresponder ao cabeçalho SUD/SU3)\nBoas práticas de atualização Sempre incremente a versão a cada lançamento Teste o caminho de atualização a partir da versão anterior Considere router-restart-required para alterações importantes Forneça tanto updateURL quanto updateURL.su3 durante a migração Use o sufixo do número de compilação para testes (1.2.3-456) Classpath (caminho de classes) e Bibliotecas Padrão Sempre disponível no Classpath Os seguintes arquivos JAR de $I2P/lib estão sempre no classpath no I2P 0.9.30+:\nJAR Contents Plugin Usage i2p.jarCore APIRequired for all plugins mstreaming.jarStreaming APIMost plugins need streaming.jarStreaming implementationMost plugins need i2ptunnel.jarI2PTunnelHTTP/server plugins router.jarRouter internalsRarely needed, avoid if possible javax.servlet.jarServlet 3.1, JSP 2.3 APIPlugins with servlets/JSPs jasper-runtime.jarJasper compiler/runtimePlugins with JSPs commons-el.jarEL 3.0 APIJSPs using expression language jetty-i2p.jarJetty utilitiesPlugins starting Jetty org.mortbay.jetty.jarJetty 9 baseCustom Jetty instances sam.jarSAM APIRarely needed addressbook.jarSubscription/blockfileUse NamingService instead routerconsole.jarConsole librariesNot public API, avoid jbigi.jarNative cryptoPlugins should not need systray.jarURL launcherRarely needed wrapper.jarService wrapperPlugins should not need ### Notas especiais commons-logging.jar: - Vazio desde 0.9.30 - Antes da 0.9.30: Apache Tomcat JULI (implementação do java.util.logging do Tomcat) - Antes da 0.9.24: Commons Logging (biblioteca Apache Commons Logging) + JULI - Antes da 0.9: Apenas Commons Logging\njasper-compiler.jar: - Vazio desde o Jetty 6 (0.9)\nsystray4j.jar: - Removido na versão 0.9.26\nNão está no Classpath (é necessário especificar) JAR Contents Usage jstl.jarStandard TaglibJSP tag libraries standard.jarStandard TaglibJSP tag libraries ### Especificação do Classpath (lista de caminhos de classes do Java) Em clients.config:\nclientApp.0.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/i2p.jar Em webapps.config:\nwebapps.mywebapp.classpath=$PLUGIN/lib/mylib.jar,$I2P/lib/jstl.jar Importante: A partir da 0.7.13-3, os classpaths (lista de caminhos de classes) são específicos a cada thread, não em toda a JVM. Especifique o classpath completo para cada cliente.\nRequisitos de versão do Java Requisitos atuais (outubro de 2025) I2P 2.10.0 e anteriores: - Mínimo: Java 7 (necessário desde 0.9.24, janeiro de 2016) - Recomendado: Java 8 ou superior\nI2P 2.11.0 e posteriores (EM BREVE): - Mínimo: Java 17+ (anunciado nas notas de lançamento da versão 2.9.0) - Aviso prévio de duas versões emitido (2.9.0 → 2.10.0 → 2.11.0)\nEstratégia de compatibilidade de plugins Para máxima compatibilidade (até o I2P 2.10.x):\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; /\u0026gt; min-java-version=1.7 Para recursos do Java 8+:\n\u0026lt;javac source=\u0026#34;1.8\u0026#34; target=\u0026#34;1.8\u0026#34; /\u0026gt; min-java-version=1.8 Para recursos do Java 11+:\n\u0026lt;javac source=\u0026#34;11\u0026#34; target=\u0026#34;11\u0026#34; /\u0026gt; min-java-version=11 Preparando-se para 2.11.0+:\n\u0026lt;javac source=\u0026#34;17\u0026#34; target=\u0026#34;17\u0026#34; /\u0026gt; min-java-version=17 min-i2p-version=2.11.0 Boas práticas de compilação Ao compilar com um JDK mais recente para uma versão de destino mais antiga:\n\u0026lt;javac source=\u0026#34;1.7\u0026#34; target=\u0026#34;1.7\u0026#34; bootclasspath=\u0026#34;${java7.home}/jre/lib/rt.jar\u0026#34; includeantruntime=\u0026#34;false\u0026#34; /\u0026gt; Isso impede o uso de APIs que não estão disponíveis na versão de destino do Java.\nCompressão Pack200 - OBSOLETA Atualização crítica: Não use Pack200 (formato de compactação do Java) Estado: OBSOLETO E REMOVIDO\nA especificação original recomendava fortemente a compressão Pack200 (método de compressão do Java) para uma redução de tamanho de 60-65%. Isso não é mais válido.\nLinha do tempo: - JEP 336: Pack200 marcado como obsoleto no Java 11 (setembro de 2018) - JEP 367: Pack200 removido no Java 14 (março de 2020)\nA especificação oficial de atualizações do I2P afirma: \u0026gt; \u0026ldquo;Arquivos JAR e WAR no arquivo ZIP não são mais compactados com o pack200 (ferramenta de compactação do Java), conforme documentado acima para arquivos \u0026lsquo;su2\u0026rsquo;, porque os ambientes de execução Java recentes não o suportam mais.\u0026rdquo;\nO que fazer:\nRemova o pack200 dos processos de compilação imediatamente Use a compressão ZIP padrão Considere alternativas: ProGuard/R8 para redução de código UPX para binários nativos Algoritmos de compressão modernos (zstd, brotli) se for fornecido um descompactador personalizado Para plugins existentes: - routers antigos (0.7.11-5 até o Java 10) ainda podem descompactar pack200 - routers novos (Java 11+) não podem descompactar pack200 - Relançar plugins sem compressão pack200\nChaves de Assinatura e Segurança Geração de chaves (Formato SU3) Use o script makeplugin.sh do repositório i2p.scripts:\n# Generate new signing key ./makeplugin.sh keygen # Keys stored in ~/.i2p-plugin-keys/ Principais detalhes: - Algoritmo: RSA_SHA512_4096 - Formato: certificado X.509 - Armazenamento: formato de keystore do Java\nAssinando plugins # Create signed su3 file ./makeplugin.sh sign myplugin.zip myplugin.su3 keyname # Verify signature ./makeplugin.sh verify myplugin.su3 Boas práticas de gerenciamento de chaves Gere uma vez, proteja para sempre\nRouters rejeitam nomes de chave duplicados com chaves diferentes Routers rejeitam chaves duplicadas com nomes de chave diferentes Atualizações são rejeitadas se houver incompatibilidade entre chave e nome Armazenamento seguro\nFazer backup do keystore (repositório de chaves) com segurança Usar uma frase-senha forte Nunca fazer commit no controle de versão Rotação de chaves\nNão é suportado pela arquitetura atual Planeje o uso de chaves a longo prazo Considere esquemas de multiassinatura para desenvolvimento em equipe Assinatura DSA legada (XPI2P) Estado: Funcional, mas obsoleto\nAssinaturas DSA-1024 usadas pelo formato xpi2p: - assinatura de 40 bytes - chave pública de 172 caracteres em base64 - NIST-800-57 recomenda (L=2048, N=224) no mínimo - o I2P usa parâmetros mais fracos (L=1024, N=160)\nRecomendação: Use SU3 com RSA-4096 em vez disso.\nDiretrizes de Desenvolvimento de Plugins Boas Práticas Essenciais Documentação\nFornecer um README claro com instruções de instalação Documentar as opções de configuração e os valores padrão Incluir um registro de alterações em cada versão Especificar as versões requeridas de I2P/Java Otimização do tamanho\nIncluir apenas os arquivos necessários Nunca empacote os JARs do router Separe pacotes de instalação vs. atualização (bibliotecas em lib/) Use a compactação Pack200 OBSOLETO - Use ZIP padrão Configuração\nNunca modifique plugin.config em tempo de execução Use um arquivo de configuração separado para configurações de tempo de execução Documente as configurações necessárias do router (portas SAM, tunnels, etc.) Respeite a configuração existente do usuário Uso de recursos\nEvite consumo agressivo de largura de banda por padrão Implemente limites razoáveis para o uso de CPU Libere recursos no encerramento Use daemon threads (threads em segundo plano que não impedem o encerramento do processo) quando apropriado Testes\nTestar instalação/atualização/desinstalação em todas as plataformas Testar atualizações a partir da versão anterior Verificar interrupção/reinício da aplicação web durante as atualizações Testar com a versão mínima suportada do I2P Sistema de arquivos\nNunca escreva em $I2P (pode ser somente leitura) Grave dados em tempo de execução em $PLUGIN ou $CONFIG Use I2PAppContext para descoberta de diretórios Não presuma a localização de $CWD Compatibilidade\nNão duplique classes padrão do I2P Estenda classes se necessário, não as substitua Verifique min-i2p-version, min-jetty-version em plugin.config Teste com versões mais antigas do I2P se pretende suportá-las Tratamento do encerramento\nImplementar stopargs adequados em clients.config Registrar ganchos de encerramento: I2PAppContext.addShutdownTask() Lidar com múltiplas chamadas de iniciar/parar de forma adequada Definir todas as threads para o modo daemon (processo em segundo plano) Segurança\nValide toda a entrada externa Nunca chame System.exit() Respeite a privacidade do usuário Siga práticas de codificação segura Licenciamento\nEspecifique claramente a licença do plugin Respeite as licenças das bibliotecas incluídas Inclua os créditos exigidos Forneça acesso ao código-fonte, se exigido Considerações avançadas Tratamento de fuso horário: - Router configura o fuso horário da JVM para UTC - Fuso horário real do usuário: propriedade i2p.systemTimeZone de I2PAppContext\nDescoberta de diretório:\n// Plugin directory String pluginDir = I2PAppContext.getGlobalContext() .getAppDir().getAbsolutePath() + \u0026#34;/plugins/\u0026#34; + pluginName; // Or use $PLUGIN variable in clients.config args Numeração de versão: - Use versionamento semântico (major.minor.patch) - Adicione número de build (compilação) para testes (1.2.3-456) - Garanta aumento monotônico nas atualizações\nAcesso às classes do router: - De modo geral, evite dependências de router.jar - Use as APIs públicas em i2p.jar em vez disso - Versões futuras do I2P podem restringir o acesso às classes do router\nPrevenção de falhas da JVM (Histórico): - Corrigido na versão 0.7.13-3 - Use os carregadores de classes corretamente - Evite atualizar JARs em plugin em execução - Projete para reinicialização na atualização, se necessário\nPlugins do Eepsite Visão geral Plugins podem fornecer eepsites completos com suas próprias instâncias do Jetty (servidor web Java) e do I2PTunnel.\nArquitetura Não tente: - Instalar em um eepsite existente - Mesclar com o eepsite padrão do router - Assumir a disponibilidade de um único eepsite\nEm vez disso: - Iniciar uma nova instância do I2PTunnel (via CLI) - Iniciar uma nova instância do Jetty - Configurar ambos em clients.config\nEstrutura de exemplo plugins/myeepsite/ ├── plugin.config ├── clients.config # Starts Jetty + I2PTunnel ├── eepsite/ │ ├── jetty.xml # Requires variable substitution │ ├── docroot/ │ ├── webapps/ │ └── logs/ └── lib/ └── [dependencies] Substituição de variáveis em jetty.xml Use a variável $PLUGIN para caminhos:\n\u0026lt;Set name=\u0026#34;resourceBase\u0026#34;\u0026gt;$PLUGIN/eepsite/docroot\u0026lt;/Set\u0026gt; O Router realiza substituições durante a inicialização do plugin.\nExemplos Implementações de referência: - zzzot plugin - Rastreador de torrents - pebble plugin - Plataforma de blog\nAmbos disponíveis na página de plugins do zzz (interna ao I2P).\nIntegração com o Console Links da Barra de Resumo Adicionar link clicável à barra de resumo do console do router:\nconsoleLinkName=My Plugin consoleLinkURL=/myplugin/ consoleLinkTooltip=Open My Plugin Interface Versões localizadas:\nconsoleLinkName_de=Mein Plugin consoleLinkTooltip_de=Öffne Mein Plugin Schnittstelle Ícones do Console Arquivo de imagem (desde 0.9.20):\nconsole-icon=/myicon.png Caminho relativo a consoleLinkURL, se especificado (desde 0.9.53); caso contrário, relativo ao nome da aplicação web.\nÍcone incorporado (desde 0.9.25):\nicon-code=iVBORw0KGgoAAAANSUhEUgAAA...Base64EncodedPNG... Gerar com:\nbase64 -w 0 icon-32x32.png Ou Java:\njava -cp i2p.jar net.i2p.data.Base64 encode icon.png Requisitos: - 32x32 pixels - formato PNG - codificado em Base64 (sem quebras de linha)\nInternacionalização Pacotes de Tradução Para traduções básicas do I2P: - Coloque os JARs em console/locale/ - Contêm pacotes de recursos para os aplicativos I2P existentes - Nomenclatura: messages_xx.properties (xx = código do idioma)\nPara traduções específicas de plugins: - Inclua em console/webapps/*.war - Ou inclua em lib/*.jar - Use a abordagem padrão do Java ResourceBundle (conjunto de recursos do Java)\nStrings localizadas no plugin.config description=My awesome plugin description_de=Mein tolles Plugin description_fr=Mon plugin génial description_es=Mi plugin increíble Campos suportados: - description_xx - consoleLinkName_xx - consoleLinkTooltip_xx\nTradução do Tema do Console Temas em console/themes/ são adicionados automaticamente ao caminho de pesquisa de temas.\nPlugins específicos da plataforma Abordagem de Pacotes Separados Use nomes de plug-in diferentes para cada plataforma:\n# Windows package name=myplugin-windows # Linux package name=myplugin-linux # macOS package name=myplugin-mac Abordagem de Substituição de Variáveis Único plugin.config com variáveis de plataforma:\nname=myplugin updateURL.su3=http://myplugin.i2p/downloads/myplugin-$OS-$ARCH.su3 Em clients.config:\nclientApp.0.main=net.i2p.apps.ShellService clientApp.0.args=$PLUGIN/bin/myapp-$OS-$ARCH Detecção do sistema operacional em tempo de execução Abordagem em Java para execução condicional:\nString os = System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase(); if (os.contains(\u0026#34;win\u0026#34;)) { // Windows-specific code } else if (os.contains(\u0026#34;nix\u0026#34;) || os.contains(\u0026#34;nux\u0026#34;)) { // Linux-specific code } else if (os.contains(\u0026#34;mac\u0026#34;)) { // macOS-specific code } Solução de problemas Problemas Comuns O plugin não inicia: 1. Verifique a compatibilidade com a versão do I2P (min-i2p-version) 2. Verifique a versão do Java (min-java-version) 3. Verifique os logs do router em busca de erros 4. Verifique se todos os JARs necessários estão no classpath\nWebapp Não Acessível: 1. Confirme que webapps.config não o desativa 2. Verifique a compatibilidade da versão do Jetty (min-jetty-version) 3. Verifique se web.xml está presente (a varredura de anotações não é suportada) 4. Verifique se há nomes de webapps conflitantes\nFalhas na atualização: 1. Verifique se o número da versão foi incrementado 2. Verifique se a assinatura corresponde à chave de assinatura 3. Certifique-se de que o nome do plugin corresponda à versão instalada 4. Revise as configurações de update-only/install-only\nPrograma externo não encerra: 1. Use ShellService para gerenciamento automático do ciclo de vida 2. Implemente o tratamento adequado de stopargs 3. Verifique a limpeza do arquivo PID 4. Verifique o encerramento do processo\nRegistro de depuração Ativar o log de depuração no router:\nlogger.record.net.i2p.router.web.ConfigPluginsHandler=DEBUG Verifique os logs:\n~/.i2p/logs/log-router-0.txt Informações de referência Especificações oficiais Especificação do Plugin Formato de Configuração Especificação de Atualização Criptografia Histórico de versões do I2P Versão atual: - I2P 2.10.0 (8 de setembro de 2025)\nPrincipais lançamentos desde 0.9.53: - 2.10.0 (set 2025) - anúncio do Java 17+ - 2.9.0 (jun 2025) - aviso sobre o Java 17+ - 2.8.0 (out 2024) - testes de criptografia pós-quântica - 2.6.0 (mai 2024) - bloqueio de I2P-over-Tor (I2P através do Tor) - 2.4.0 (dez 2023) - melhorias de segurança no NetDB (banco de dados da rede) - 2.2.0 (mar 2023) - controle de congestionamento - 2.1.0 (jan 2023) - melhorias de rede - 2.0.0 (nov 2022) - protocolo de transporte SSU2 - 1.7.0/0.9.53 (fev 2022) - ShellService (serviço de shell), substituição de variáveis - 0.9.15 (set 2014) - introdução do formato SU3\nNumeração de versões: - série 0.9.x: até a versão 0.9.53 - série 2.x: a partir da 2.0.0 (introdução do SSU2)\nRecursos para Desenvolvedores Código-fonte: - Repositório principal: https://i2pgit.org/I2P_Developers/i2p.i2p - Espelho no GitHub: https://github.com/i2p/i2p.i2p Exemplos de plugins: - zzzot (rastreador BitTorrent) - pebble (plataforma de blog) - i2p-bote (e-mail sem servidor) - orchid (cliente Tor) - seedless (troca de pares)\nFerramentas de compilação: - makeplugin.sh - Geração e assinatura de chaves - Disponível no repositório i2p.scripts - Automatiza a criação e a verificação de su3\nSuporte da Comunidade Fóruns: - I2P Forum - zzz.i2p (interno ao I2P)\nIRC/Bate-papo: - #i2p-dev na OFTC - IRC do I2P dentro da rede\nApêndice A: Exemplo completo de plugin.config # Required fields name=example-plugin signer=developer@mail.i2p version=1.2.3 # Update configuration updateURL.su3=http://example.i2p/plugins/example-$OS-$ARCH.su3 min-i2p-version=2.0.0 min-java-version=17 # Display information date=1698796800000 author=Example Developer \u0026lt;developer@mail.i2p\u0026gt; websiteURL=http://example.i2p/ license=Apache-2.0 description=An example I2P plugin demonstrating best practices description_de=Ein Beispiel-I2P-Plugin zur Demonstration bewährter Praktiken description_es=Un plugin I2P de ejemplo que demuestra las mejores prácticas # Console integration consoleLinkName=Example Plugin consoleLinkName_de=Beispiel-Plugin consoleLinkURL=/example/ consoleLinkTooltip=Open the Example Plugin control panel consoleLinkTooltip_de=Öffne das Beispiel-Plugin-Kontrollfeld console-icon=/icon.png # Installation behavior dont-start-at-install=false router-restart-required=false # Platform requirements (informational) required-platform-OS=All platforms supported other-requirements=Requires 512MB free disk space Apêndice B: Exemplo completo de clients.config # Main service client (managed) clientApp.0.main=com.example.plugin.MainService clientApp.0.name=Example Plugin Main Service clientApp.0.delay=30 clientApp.0.args=$PLUGIN/config.properties --port=7656 clientApp.0.stopargs=shutdown clientApp.0.uninstallargs=cleanup clientApp.0.classpath=$PLUGIN/lib/example.jar,$I2P/lib/i2p.jar,$I2P/lib/mstreaming.jar # External program via ShellService clientApp.1.main=net.i2p.apps.ShellService clientApp.1.name=Example Native Helper clientApp.1.delay=35 clientApp.1.args=$PLUGIN/bin/helper-$OS-$ARCH --config $PLUGIN/helper.conf clientApp.1.classpath=$I2P/lib/i2p.jar # Jetty eepsite clientApp.2.main=net.i2p.jetty.JettyStart clientApp.2.name=Example Eepsite clientApp.2.delay=40 clientApp.2.args=$PLUGIN/eepsite/jetty.xml clientApp.2.stopargs=$PLUGIN/eepsite/jetty.xml stop clientApp.2.classpath=$PLUGIN/lib/example-web.jar,$I2P/lib/i2p.jar # I2PTunnel for eepsite clientApp.3.main=net.i2p.i2ptunnel.TunnelControllerGroup clientApp.3.name=Example Eepsite Tunnel clientApp.3.delay=45 clientApp.3.args=$PLUGIN/eepsite/i2ptunnel.config Apêndice C: Exemplo completo de webapps.config # Disable autostart for admin webapp webapps.example-admin.startOnLoad=false # Main webapp with classpath webapps.example.startOnLoad=true webapps.example.classpath=$PLUGIN/lib/example-core.jar,$PLUGIN/lib/commons-utils.jar,$I2P/lib/jstl.jar,$I2P/lib/standard.jar # Legacy support (pre-0.7.12-9) plugin.example.startOnLoad=true Apêndice D: Lista de Verificação de Migração (de 0.9.53 para 2.10.0) Alterações necessárias Remover a compressão Pack200 do processo de build\nRemover as tarefas pack200 dos scripts Ant/Maven/Gradle Republicar os plugins existentes sem pack200 Revisar os requisitos de versão do Java\nConsiderar exigir Java 11+ para novos recursos Planejar a exigência de Java 17+ no I2P 2.11.0 Atualizar min-java-version em plugin.config Atualizar a documentação\nRemover referências a Pack200 (formato de compressão de JAR do Java) Atualizar os requisitos de versão do Java Atualizar referências de versão do I2P (0.9.x → 2.x) Alterações recomendadas Reforçar as assinaturas criptográficas\nMigrar de XPI2P (formato antigo de pacote de plugin do I2P) para SU3 (formato atual de pacote assinado do I2P) se ainda não tiver sido feito Usar chaves RSA-4096 para novos plugins Aproveite os novos recursos (se estiver usando 0.9.53+)\nUse as variáveis $OS / $ARCH para atualizações específicas da plataforma Use o ShellService (serviço de shell) para programas externos Use o classpath aprimorado para webapps (funciona com qualquer nome de WAR) Testar compatibilidade\nTestar no I2P 2.10.0 Verificar com Java 8, 11 e 17 Verificar no Windows, no Linux e no macOS Aprimoramentos Opcionais Implementar corretamente o ServletContextListener Adicionar descrições localizadas Fornecer ícone do console Melhorar o tratamento do encerramento Adicionar registro de logs abrangente Escrever testes automatizados ","description":"Regras de empacotamento em .xpi2p / .su3 para plugins do I2P","id":"b25aafc3542216f9bbc2f124d1943fbc","section":"docs","title":"Formato do Pacote de Plugin","url":"/pt/docs/specs/plugin/"},{"categories":null,"content":"Visão geral NOTA: OBSOLETO - Agora suportamos três formatos, em ordem de preferência:\nMaxmind geoip2 (GeoLite2-Country.mmdb) incluído em todas as instalações, exceto nos pacotes do Debian e no Android Maxmind geoip1 (GeoIP.dat) no pacote geoip-database do Debian O formato IPv4 do Tor (geoip.txt) e o formato IPv6 personalizado (geoipv6.dat.gz) documentados abaixo, ainda são suportados, mas não são utilizados. Esta página especifica o formato dos vários arquivos GeoIP, usados pelo router para determinar o país de um endereço IP.\nFormato do nome do país (countries.txt) Este formato é facilmente gerado a partir de arquivos de dados disponíveis em muitas fontes públicas. Por exemplo:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Especificações de formato:\nA codificação é UTF-8 \u0026lsquo;#\u0026rsquo; na coluna 1 indica uma linha de comentário As linhas de entrada são CountryCode,CountryName CountryCode é o código ISO de duas letras, em maiúsculas CountryName está em inglês Formato IPv4 (geoip.txt) Este formato foi adotado do Tor e é facilmente gerado a partir de arquivos de dados disponíveis em muitas fontes públicas. Por exemplo:\n$ wget http://geolite.maxmind.com/download/geoip/database/GeoIPCountryCSV.zip $ unzip GeoIPCountryCSV.zip $ cut -d, -f3-5 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; \u0026gt; geoip.txt $ cut -d, -f5,6 \u0026lt; GeoIPCountryWhois.csv | sed \u0026#39;s/\u0026#34;//g\u0026#39; | sort | uniq \u0026gt; countries.txt Especificações de formato:\nA codificação é ASCII \u0026lsquo;#\u0026rsquo; na coluna 1 indica uma linha de comentário As linhas de entrada são FromIP,ToIP,CountryCode FromIP e ToIP são representações inteiras sem sinal do IP de 4 bytes CountryCode é o código ISO de duas letras, em maiúsculas As linhas de entrada devem ser ordenadas por FromIP numérico IPv6 (geoipv6.dat.gz) Formato Este é um formato binário compactado projetado para o I2P. O arquivo está compactado com gzip. Formato descompactado:\nBytes 0-9: Magic number \u0026#34;I2PGeoIPv6\u0026#34; Bytes 10-11: Version (0x0001) Bytes 12-15 Options (0x00000000) (future use) Bytes 16-23: Creation date (ms since 1970-01-01) Bytes 24-xx: Optional comment (UTF-8) terminated by zero byte Bytes xx-255: null padding Bytes 256-: 18 byte records: 8 byte from (/64) 8 byte to (/64) 2 byte ISO country code LOWER case (ASCII) NOTAS:\nOs dados devem estar ordenados (long com sinal em complemento de dois), sem sobreposição. Portanto, a ordem é 80000000 \u0026hellip; FFFFFFFF 00000000 \u0026hellip; 7FFFFFFF. A classe GeoIPv6.java contém um programa para gerar este formato a partir de fontes públicas, como os dados Maxmind GeoLite. A consulta GeoIP IPv6 é suportada a partir da versão 0.9.8. ","description":"Especificações do formato de arquivo GeoIP legado para consultas de IP para país","id":"b5f34a4f13210a8caf4c4d0b5e62a828","section":"docs","title":"Formatos de arquivo GeoIP","url":"/pt/docs/legacy/formatos-de-arquivo-geoip/"},{"categories":null,"content":"Quando as condições da rede tornam o git clone não confiável, você pode distribuir repositórios como git bundles pelo BitTorrent ou qualquer outro transporte de arquivos. Um bundle é um único arquivo contendo todo o histórico do repositório. Uma vez baixado, você faz fetch dele localmente e depois volta para o remote upstream.\n1. Antes de Começar Gerar um bundle requer um clone Git completo. Clones superficiais criados com --depth 1 irão produzir silenciosamente bundles quebrados que parecem funcionar, mas falham quando outros tentam usá-los. Sempre busque de uma fonte confiável (GitHub em github.com/i2p/i2p.i2p , a instância Gitea do I2P em i2pgit.org , ou git.idk.i2p sobre I2P) e execute git fetch --unshallow se necessário para converter qualquer clone superficial em um clone completo antes de criar bundles.\nSe você está apenas consumindo um pacote existente, basta baixá-lo. Nenhuma preparação especial é necessária.\n2. Baixando um Bundle Obtaining the Bundle File Baixe o arquivo bundle via BitTorrent usando o I2PSnark (o cliente torrent integrado no I2P) ou outros clientes compatíveis com I2P como o BiglyBT com o plugin I2P.\nImportante: I2PSnark funciona apenas com torrents especificamente criados para a rede I2P. Torrents padrão da clearnet não são compatíveis porque o I2P usa Destinations (endereços de 387+ bytes) em vez de endereços IP e portas.\nA localização do arquivo bundle depende do tipo de instalação do I2P:\nInstalações de usuário/manuais (instaladas com instalador Java): ~/.i2p/i2psnark/ Instalações de sistema/daemon (instaladas via apt-get ou gerenciador de pacotes): /var/lib/i2p/i2p-config/i2psnark/ Os usuários do BiglyBT encontrarão os arquivos baixados no diretório de downloads configurado.\nCloning from the Bundle Método padrão (funciona na maioria dos casos):\ngit clone ~/.i2p/i2psnark/i2p.i2p.bundle Se você encontrar erros fatal: multiple updates for ref (um problema conhecido no Git 2.21.0 e versões posteriores quando a configuração global do Git contém refspecs de fetch conflitantes), use a abordagem de inicialização manual:\nmkdir i2p.i2p \u0026amp;\u0026amp; cd i2p.i2p git init git fetch ~/.i2p/i2psnark/i2p.i2p.bundle Alternativamente, você pode usar a flag --update-head-ok:\ngit fetch --update-head-ok ~/.i2p/i2psnark/i2p.i2p.bundle \u0026#39;*:*\u0026#39; Obtendo o Arquivo Bundle Após clonar a partir do pacote, aponte o seu clone para o repositório remoto ativo para que as futuras buscas ocorram sobre I2P ou clearnet:\ngit remote set-url origin git@127.0.0.1:I2P_Developers/i2p.i2p Ou para acesso clearnet:\ngit remote set-url origin https://github.com/i2p/i2p.i2p Para acesso SSH via I2P, você precisa de um túnel cliente SSH configurado no console do seu roteador I2P (tipicamente porta 7670) apontando para g6u4vqiuy6bdc3dbu6a7gmi3ip45sqwgtbgrr6uupqaaqfyztrka.b32.i2p. Se estiver usando uma porta não padrão:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7670\u0026#34; git clone git@127.0.0.1:I2P_Developers/i2p.i2p 3. Creating a Bundle Clonando a partir do Bundle Certifique-se de que o seu repositório está totalmente atualizado com um clone completo (não superficial):\ngit fetch --all Se você tem um clone superficial, converta-o primeiro:\ngit fetch --unshallow Mudando para o Remoto Ativo Usando o target de build do Ant (recomendado para a árvore de código-fonte do I2P):\nant git-bundle Isso cria tanto i2p.i2p.bundle (o arquivo bundle) quanto i2p.i2p.bundle.torrent (metadados BitTorrent).\nUsando git bundle diretamente:\ngit bundle create i2p.i2p.bundle --all Para pacotes mais seletivos:\ngit bundle create i2p.i2p.bundle --branches --tags Verifying Your Bundle Sempre verifique o pacote antes de distribuir:\ngit bundle verify i2p.i2p.bundle Isto confirma que o bundle é válido e mostra quaisquer commits de pré-requisito necessários.\nPré-requisitos Copie o pacote e seus metadados de torrent para o seu diretório I2PSnark:\nPara instalações de usuário:\ncp i2p.i2p.bundle* ~/.i2p/i2psnark/ Para instalações de sistema:\ncp i2p.i2p.bundle* /var/lib/i2p/i2p-config/i2psnark/ O I2PSnark detecta e carrega automaticamente arquivos .torrent em segundos. Acesse a interface web em http://127.0.0.1:7657/i2psnark para começar a semear.\n4. Creating Incremental Bundles Para atualizações periódicas, crie bundles incrementais contendo apenas novos commits desde o último bundle:\ngit tag lastBundleTag git bundle create update.bundle lastBundleTag..master Os usuários podem buscar do pacote incremental se já tiverem o repositório base:\ngit fetch /path/to/update.bundle Sempre verifique se os pacotes incrementais mostram os commits de pré-requisito esperados:\ngit bundle verify update.bundle 5. Updating After the Initial Clone Assim que tiver um repositório funcional a partir do bundle, trate-o como qualquer outro clone Git:\ngit remote add upstream git@127.0.0.1:I2P_Developers/i2p.i2p git fetch upstream git merge upstream/master Ou para fluxos de trabalho mais simples:\ngit fetch origin git pull origin master 3. Criando um Pacote Distribuição resiliente: Repositórios grandes podem ser compartilhados via BitTorrent, que lida automaticamente com novas tentativas, verificação de partes e retomada. Bootstrap peer-to-peer: Novos contribuidores podem fazer bootstrap do seu clone a partir de peers próximos na rede I2P, e então buscar mudanças incrementais diretamente dos hosts Git. Redução de carga no servidor: Espelhos podem publicar pacotes periódicos para aliviar a pressão nos hosts Git ativos, especialmente útil para repositórios grandes ou condições de rede lentas. Transporte offline: Pacotes funcionam em qualquer transporte de arquivos (drives USB, transferências diretas, sneakernet), não apenas BitTorrent. Os bundles não substituem remotes ativos. Eles simplesmente fornecem um método de bootstrapping mais resiliente para clones iniciais ou atualizações importantes.\n7. Troubleshooting Gerando o Pacote Problema: A criação do bundle é bem-sucedida, mas outros não conseguem clonar a partir do bundle.\nCausa: Seu clone de origem é superficial (criado com --depth).\nSolução: Converter para clone completo antes de criar bundles:\ngit fetch --unshallow Verificando Seu Pacote Problema: fatal: multiple updates for ref ao clonar a partir do bundle.\nCausa: Git 2.21.0+ entra em conflito com refspecs de fetch globais em ~/.gitconfig.\nSoluções: 1. Use inicialização manual: mkdir repo \u0026amp;\u0026amp; cd repo \u0026amp;\u0026amp; git init \u0026amp;\u0026amp; git fetch /path/to/bundle 2. Use a flag --update-head-ok: git fetch --update-head-ok /path/to/bundle '*:*' 3. Remova a configuração conflitante: git config --global --unset remote.origin.fetch\nDistribuindo via I2PSnark Problema: git bundle verify reporta pré-requisitos ausentes.\nCausa: Bundle incremental ou clone de fonte incompleto.\nSolução: Busque os commits de pré-requisito ou use o bundle base primeiro, depois aplique as atualizações incrementais.\n","description":"Buscar e distribuir repositórios grandes com git bundle e BitTorrent","id":"555586cb7b43c73ad912bbb01f20326b","section":"docs","title":"Git Bundles para I2P","url":"/pt/docs/applications/git-bundle/"},{"categories":null,"content":"Clonar e enviar repositórios dentro do I2P usa os mesmos comandos Git que você já conhece—seu cliente simplesmente conecta através de túneis I2P em vez de TCP/IP. Este guia explica como configurar uma conta, configurar túneis e lidar com conexões lentas.\nInício rápido: O acesso somente leitura funciona através do proxy HTTP: http_proxy=http://127.0.0.1:4444 git clone http://example.i2p/project.git. Siga os passos abaixo para acesso de leitura/escrita via SSH.\n1. Criar uma Conta Escolha um serviço Git I2P e registre-se:\nDentro do I2P: http://git.idk.i2p Mirror clearnet: https://i2pgit.org O registro pode exigir aprovação manual; verifique a página inicial para obter instruções. Após a aprovação, faça um fork ou crie um repositório para ter algo com que testar.\n2. Configurar um Cliente I2PTunnel (SSH) Abra o console do router → I2PTunnel e adicione um novo túnel Client. Insira o destino do serviço (Base32 ou Base64). Para git.idk.i2p você encontrará ambos os destinos HTTP e SSH na página inicial do projeto. Escolha uma porta local (por exemplo localhost:7442). Ative o início automático se você planeja usar o túnel com frequência. A interface confirmará o novo túnel e mostrará seu status. Quando estiver em execução, os clientes SSH podem se conectar a 127.0.0.1 na porta escolhida.\n3. Clonar via SSH Use a porta do tunnel com GIT_SSH_COMMAND ou um bloco de configuração SSH:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone git@127.0.0.1:your-project/example.git Se a primeira tentativa falhar (os túneis podem ser lentos), tente uma clonagem superficial:\nGIT_SSH_COMMAND=\u0026#34;ssh -p 7442\u0026#34; \\ git clone --depth 1 git@127.0.0.1:your-project/example.git cd example git fetch --unshallow Configure o Git para buscar todas as branches:\ngit config remote.origin.fetch \u0026#34;+refs/heads/*:refs/remotes/origin/*\u0026#34; git fetch origin Dicas de Desempenho Adicione um ou dois tunnels de backup no editor de tunnels para melhorar a resiliência. Para testes ou repositórios de baixo risco, você pode reduzir o comprimento do tunnel para 1 hop, mas esteja ciente do compromisso com o anonimato. Mantenha GIT_SSH_COMMAND em seu ambiente ou adicione uma entrada em ~/.ssh/config: Host git.i2p HostName 127.0.0.1 Port 7442 User git Então clone usando git clone git@git.i2p:namespace/project.git.\n4. Sugestões de Fluxo de Trabalho Adote um fluxo de trabalho de fork e branch comum no GitLab/GitHub:\nDefina um remote upstream: git remote add upstream git@git.i2p:I2P_Developers/i2p.i2p Mantenha seu master sincronizado: git pull upstream master Crie branches de funcionalidade para alterações: git checkout -b feature/new-thing Envie branches para seu fork: git push origin feature/new-thing Envie um merge request e depois atualize o master do seu fork a partir do upstream. 5. Lembretes de Privacidade O Git armazena os timestamps de commit no seu fuso horário local. Para forçar timestamps em UTC: git config --global alias.utccommit \u0026#39;!git commit --date=\u0026#34;$(date --utc +%Y-%m-%dT%H:%M:%S%z)\u0026#34;\u0026#39; Use git utccommit em vez de git commit quando a privacidade for importante.\nEvite incorporar URLs da clearnet ou IPs em mensagens de commit ou metadados do repositório se o anonimato for uma preocupação. 6. Resolução de Problemas Symptom Fix connection closed during clone Retry with --depth 1, add backup tunnels, or increase tunnel quantities. ssh: connect to host 127.0.0.1 port …: Connection refused Ensure the I2PTunnel client is running and SAM is enabled. Slow performance Lower tunnel length, increase bandwidth limits, or schedule large fetches during off-peak hours. Para cenários avançados (espelhamento de repositórios externos, distribuição de bundles), consulte os guias complementares: [Fluxos de trabalho com Git bundle](/docs/applications/git-bundle/) e [Hospedagem do GitLab via I2P](/docs/guides/gitlab/). ","description":"Conectando clientes Git a serviços hospedados em I2P como i2pgit.org","id":"17704a86e8676ba273355af4fa703c15","section":"docs","title":"Git sobre I2P","url":"/pt/docs/applications/git/"},{"categories":null,"content":"Este glossário define termos comuns utilizados na documentação e discussões do I2P.\nB Blockchain Um livro-razão distribuído que pode registrar transações entre múltiplas partes de forma eficiente, verificável e permanente.\nD Descentralização Arquitetura de rede que evita dependência de uma única parte. Abrange tecnologias peer-to-peer, blockchain, federadas e distribuídas.\nDestination A identidade criptográfica de um túnel. Estas são as identidades de clientes e servidores dentro da rede I2P.\nDHT (Distributed Hash Table) Utilizado em alguns projetos para conectar peers entre si através do armazenamento de informações na forma de pares chave-valor de maneira distribuída.\nSistemas Distribuídos Tópico acadêmico dentro da Ciência da Computação relacionado ao design de sistemas de computadores que consistem em muitos computadores individuais conectados através de uma rede.\nF Federado Federação permite que implementações separadas de um serviço se comuniquem entre si através de um protocolo comum.\nH Hash Um número, geralmente exibido como uma sequência de letras e números. Pode servir como uma \u0026ldquo;impressão digital\u0026rdquo; que identifica dados de forma única.\nI I2P Invisible Internet Project: um projeto destinado a fornecer uma camada de anonimato, para que os usuários possam se comunicar anonimamente usando uma variedade de aplicações.\nEndereço IP Um número de um computador ou rede que é único e, portanto, pode ser usado para endereçá-lo.\nL LeaseSet Uma coleção de informações necessárias para comunicar com um cliente ou servidor num Destination específico.\nP Peer-to-Peer (P2P) Os peers disponibilizam uma parte dos seus recursos diretamente a outros participantes da rede, sem a necessidade de coordenação central por servidores ou hosts estáveis.\nR Router O software central do I2P, que roteia pacotes criptografados na rede I2P.\nRouterIdentity Uma coleção de informações necessárias para comunicar diretamente com um router.\nT TCP/UDP Os dois protocolos de transporte fundamentais usados na Internet.\nTunnel Um caminho de comunicação anônimo entre um cliente ou servidor e a rede I2P.\nU UX Experiência do usuário (User experience), a experiência geral de uma pessoa ao usar um produto ou serviço.\nW WebRTC Um padrão de protocolo para estabelecer conexões em um navegador web onde os dados passam diretamente entre os usuários.\n","description":"Termos e definições comuns usados na documentação I2P","id":"2235ec8f316773700ef08dd43b19a1c0","section":"docs","title":"Glossário","url":"/pt/docs/overview/gloss%C3%A1rio/"},{"categories":null,"content":"Este guia fornece uma visão geral do Console do Router I2P e suas páginas de configuração. Cada seção explica o que a página faz e para que serve, ajudando você a entender como monitorar e configurar seu router I2P.\nAcessando o Console do Router O Console do Router I2P é o centro de controle para gerenciar e monitorar o seu router I2P. Por padrão, pode ser acessado através do Console do Router I2P assim que o seu router I2P estiver em execução.\nA página inicial exibe várias seções principais:\nAplicações - Acesso rápido às aplicações integradas do I2P como Email, Torrents, Gestor de Serviços Ocultos e Servidor Web Sites da Comunidade I2P - Links para recursos importantes da comunidade incluindo fóruns, documentação e websites do projeto Configuração e Ajuda - Ferramentas para configurar definições de largura de banda, gerir plugins e aceder a recursos de ajuda Informações de Rede e Programador - Acesso a gráficos, logs, documentação técnica e estatísticas de rede Livro de Endereços URL: Catálogo de Endereços O I2P Address Book funciona de forma similar ao DNS na clearnet, permitindo que você gerencie nomes legíveis para destinos I2P (eepsites). É aqui que você pode visualizar e adicionar endereços I2P ao seu catálogo de endereços pessoal.\nO sistema de livro de endereços funciona através de múltiplas camadas:\nRegistros Locais - Seus catálogos de endereços pessoais que são armazenados apenas no seu router\nCatálogo de Endereços Local - Hosts que você adiciona manualmente ou salva para seu próprio uso Catálogo de Endereços Privado - Endereços que você não quer compartilhar com outros; nunca distribuídos publicamente Subscrições - Fontes remotas de catálogo de endereços (como http://i2p-projekt.i2p/hosts.txt) que atualizam automaticamente o catálogo de endereços do seu router com sites I2P conhecidos\nRouter Addressbook - O resultado consolidado dos seus registros locais e subscrições, pesquisável por todas as aplicações I2P no seu router\nPublished Addressbook - Compartilhamento público opcional do seu catálogo de endereços para que outros possam usá-lo como fonte de subscrição (útil se você estiver executando um site I2P)\nO address book realiza consultas regulares às suas subscrições e mescla o conteúdo no address book do seu router, mantendo o seu arquivo hosts.txt atualizado com a rede I2P.\nConfiguração URL: Configuração Avançada A seção de Configuração fornece acesso a todas as definições do router através de múltiplos separadores especializados.\nAdvanced A página de configuração Avançada fornece acesso a configurações de baixo nível do router que normalmente não são necessárias para operação normal. A maioria dos usuários não deve modificar estas configurações a menos que compreendam a opção de configuração específica e seu impacto no comportamento do router.\nCaracterísticas principais:\nConfiguração Floodfill - Controle se o seu roteador participa como um peer floodfill, que auxilia a rede ao armazenar e distribuir informações da base de dados da rede. Isso pode usar mais recursos do sistema, mas fortalece a rede I2P.\nConfiguração Avançada do I2P - Acesso direto ao arquivo router.config, exibindo todos os parâmetros de configuração avançados, incluindo:\nLimites de largura de banda e configurações de burst Configurações de transporte (NTCP2, SSU2, portas UDP e chaves) Informações de identificação e versão do router Preferências do console e configurações de atualização A maioria das opções avançadas de configuração não são expostas na interface do usuário porque raramente são necessárias. Para habilitar a edição dessas configurações, você deve adicionar routerconsole.advanced=true ao seu arquivo router.config manualmente.\nAviso: Modificar incorretamente as configurações avançadas pode afetar negativamente o desempenho ou a conectividade do seu router. Apenas altere essas configurações se souber o que está fazendo.\nBandwidth URL: Configuração de Largura de Banda A página de configuração de Largura de Banda permite que você controle quanta largura de banda o seu router contribui para a rede I2P. O I2P funciona melhor quando você configura suas taxas para corresponder à velocidade da sua conexão de internet.\nConfigurações Principais:\nKBps In - Largura de banda máxima de entrada que seu roteador aceitará (velocidade de download) KBps Out - Largura de banda máxima de saída que seu roteador utilizará (velocidade de upload) Share - Percentual da sua largura de banda de saída dedicado ao tráfego participante (ajudando a rotear tráfego para outros) Notas Importantes:\nTodos os valores são em bytes por segundo (KBps), não bits por segundo Quanto mais largura de banda você disponibilizar, mais ajuda a rede e melhora seu próprio anonimato A quantidade de compartilhamento upstream (KBps Out) determina sua contribuição geral para a rede Se não tiver certeza da velocidade da sua rede, use o Teste de Largura de Banda para medi-la Maior largura de banda compartilhada melhora tanto seu anonimato quanto ajuda a fortalecer a rede I2P A página de configuração mostra a transferência de dados mensal estimada com base nas suas configurações, ajudando você a planejar a alocação de largura de banda de acordo com os limites do seu plano de internet.\nClient Configuration URL: Configuração do Cliente A página de Configuração do Cliente permite que você controle quais aplicações e serviços I2P são executados na inicialização. É aqui que você pode ativar ou desativar clientes I2P integrados sem desinstalá-los.\nAviso Importante: Tenha cuidado ao alterar configurações aqui. O console do router e os túneis de aplicação são necessários para a maioria dos usos do I2P. Apenas usuários avançados devem modificar essas configurações.\nClientes Disponíveis:\nApplication tunnels - O sistema I2PTunnel que gerencia túneis de cliente e servidor (proxy HTTP, IRC, etc.) I2P Router Console - A interface de administração baseada na web que você está usando atualmente I2P webserver (eepsite) - Servidor web Jetty integrado para hospedar seu próprio site I2P Open Router Console in web browser at startup - Abre automaticamente seu navegador na página inicial do console SAM application bridge - Ponte de API para aplicações de terceiros se conectarem ao I2P Cada cliente mostra: - Executar na Inicialização? - Caixa de seleção para ativar/desativar início automático - Controle - Botões Iniciar/Parar para controle imediato - Classe e argumentos - Detalhes técnicos sobre como o cliente é iniciado\nAlterações na configuração \u0026ldquo;Executar na Inicialização?\u0026rdquo; requerem uma reinicialização do router para que tenham efeito. Todas as modificações são salvas em /var/lib/i2p/i2p-config/clients.config.d/.\nAvançado URL: Configuração I2CP A página de configuração do I2CP (I2P Client Protocol) permite que você configure como aplicações externas se conectam ao seu roteador I2P. O I2CP é o protocolo que as aplicações usam para se comunicar com o router e criar tunnels e enviar/receber dados através do I2P.\nImportante: As configurações padrão funcionarão para a maioria das pessoas. Quaisquer alterações feitas aqui também devem ser configuradas na aplicação cliente externa. Muitos clientes não suportam SSL ou autorização. Todas as alterações requerem reinicialização para entrar em vigor.\nOpções de Configuração:\nConfiguração da Interface I2CP Externa\nAtivada sem SSL - Acesso I2CP padrão (padrão e mais compatível) Ativada com SSL obrigatório - Apenas conexões I2CP criptografadas Desativada - Bloqueia clientes externos de se conectarem via I2CP Interface I2CP - A interface de rede na qual escutar (padrão: 127.0.0.1 apenas para localhost)\nPorta I2CP - O número da porta para conexões I2CP (padrão: 7654)\nAutorização\nRequerer nome de usuário e senha - Ativa autenticação para conexões I2CP Nome de usuário - Define o nome de usuário necessário para acesso I2CP Senha - Define a senha necessária para acesso I2CP Nota de Segurança: Se você está executando aplicativos apenas na mesma máquina que o seu router I2P, mantenha a interface configurada como 127.0.0.1 para prevenir acesso remoto. Altere essas configurações apenas se você precisar permitir que aplicativos I2P de outros dispositivos se conectem ao seu router.\nLargura de Banda URL: Configuração de Rede A página de Configuração de Rede permite configurar como o seu router I2P se conecta à internet, incluindo detecção de endereço IP, preferências IPv4/IPv6 e configurações de porta para os transportes UDP e TCP.\nEndereço IP Externamente Acessível:\nUsar todos os métodos de detecção automática - Detecta automaticamente seu IP público usando múltiplos métodos (recomendado) Desativar detecção de endereço IP via UPnP - Impede o uso de UPnP para descobrir seu IP Ignorar endereço IP da interface local - Não usar o IP da sua rede local Usar apenas detecção de endereço IP via SSU - Usar apenas o transporte SSU2 para detecção de IP Modo oculto - não publicar IP - Impede a participação no tráfego da rede (reduz o anonimato) Especificar hostname ou IP - Definir manualmente seu IP público ou hostname Configuração IPv4:\nDesabilitar entrada (Atrás de firewall) - Marque esta opção se você estiver atrás de um firewall, rede doméstica, ISP, DS-Lite ou NAT de grau de operadora que bloqueia conexões de entrada Configuração IPv6:\nPreferir IPv4 em vez de IPv6 - Prioriza conexões IPv4 Preferir IPv6 em vez de IPv4 - Prioriza conexões IPv6 (padrão para redes dual-stack) Habilitar IPv6 - Permite conexões IPv6 Desabilitar IPv6 - Desabilita toda conectividade IPv6 Usar apenas IPv6 (desabilitar IPv4) - Modo experimental apenas IPv6 Desabilitar entrada (Com firewall) - Marque se seu IPv6 estiver bloqueado por firewall Ação Quando o IP Muda:\nModo laptop - Funcionalidade experimental que altera a identidade do router e a porta UDP quando o seu IP muda para maior anonimato Configuração UDP:\nEspecificar Porta - Define uma porta UDP específica para o transporte SSU2 (deve ser aberta no seu firewall) Desativar completamente - Selecione apenas se estiver atrás de um firewall que bloqueia todo o tráfego UDP de saída Configuração TCP:\nEspecificar Porta - Define uma porta TCP específica para o transporte NTCP2 (deve estar aberta no seu firewall) Usar a mesma porta configurada para UDP - Simplifica a configuração ao usar uma porta para ambos os transportes Usar endereço IP auto-detectado - Detecta automaticamente o seu IP público (mostra \u0026ldquo;currently unknown\u0026rdquo; se ainda não foi detectado ou está bloqueado por firewall) Sempre usar endereço IP auto-detectado (Not firewalled) - Melhor opção para routers com acesso direto à internet Desabilitar entrada (Firewalled) - Marque se as conexões TCP estão bloqueadas pelo seu firewall Desabilitar completamente - Selecione apenas se estiver atrás de um firewall que limita ou bloqueia TCP de saída Especificar hostname ou IP - Configure manualmente o seu endereço acessível externamente Importante: Alterações nas configurações de rede podem exigir uma reinicialização do router para terem efeito completo. A configuração adequada de encaminhamento de portas melhora significativamente o desempenho do seu router e ajuda a rede I2P.\nConfiguração do Cliente URL: Configuração de Pares A página de Configuração de Peers fornece controles manuais para gerenciar peers individuais na rede I2P. Este é um recurso avançado normalmente usado apenas para solucionar problemas com peers problemáticos.\nControles Manuais de Peers:\nHash do Router - Insira o hash do router em base64 de 44 caracteres do peer que deseja gerenciar Banir / Desbanir Manualmente um Peer:\nBanir um peer impede que ele participe de quaisquer túneis que você criar. Esta ação: - Impede que o peer seja usado em seus túneis de cliente ou exploratórios - Entra em vigor imediatamente sem exigir reinicialização - Persiste até que você desbanique manualmente o peer ou reinicie seu router - Banir peer até reiniciar - Bloqueia temporariamente o peer - Desbanir peer - Remove o banimento de um peer previamente bloqueado\nAjustar Bônus de Perfil:\nOs bônus de perfil afetam como os peers são selecionados para participação em túneis. Os bônus podem ser positivos ou negativos: - Peers rápidos - Usados para túneis de cliente que exigem alta velocidade - Peers de alta capacidade - Usados para alguns túneis exploratórios que exigem roteamento confiável - Os bônus atuais são exibidos na página de perfis\nConfiguração: - Velocidade - Ajustar o bônus de velocidade para este peer (0 = neutro) - Capacidade - Ajustar o bônus de capacidade para este peer (0 = neutro) - Ajustar bônus de peers - Aplicar as configurações de bônus\nCasos de Uso: - Banir um peer que consistentemente causa problemas de conexão - Excluir temporariamente um peer que você suspeita ser malicioso - Ajustar bônus para despriorizar peers com baixo desempenho - Depurar problemas de construção de túnel excluindo peers específicos\nNota: A maioria dos usuários nunca precisará usar este recurso. O router I2P gerencia automaticamente a seleção e criação de perfis de peers com base em métricas de desempenho.\nConfiguração I2CP URL: Configuração de Reseed A página de Configuração de Reseed permite que você faça o reseed manual do seu router se o reseed automático falhar. Reseed é o processo de inicialização usado para encontrar outros routers quando você instala o I2P pela primeira vez, ou quando seu router tem poucas referências de routers restantes.\nQuando Usar Reseed Manual:\nSe o reseed falhou, você deve primeiro verificar sua conexão de rede\nSe um firewall está bloqueando suas conexões aos hosts de reseed, você pode ter acesso a um proxy:\nO proxy pode ser um proxy público remoto, ou pode estar rodando no seu computador (localhost) Para usar um proxy, configure o tipo, host e porta na seção Reseeding Configuration Se você está executando o Tor Browser, faça reseed através dele configurando SOCKS 5, localhost, porta 9150 Se você está executando o Tor em linha de comando, faça reseed através dele configurando SOCKS 5, localhost, porta 9050 Se você tem alguns peers mas precisa de mais, você pode tentar a opção I2P Outproxy. Deixe o host e a porta em branco. Isso não funcionará para um reseed inicial quando você não tem peers Em seguida, clique em \u0026ldquo;Save changes and reseed now\u0026rdquo; As configurações padrão funcionarão para a maioria das pessoas. Altere-as apenas se HTTPS estiver bloqueado por um firewall restritivo e o reseed tiver falhado Se você conhece e confia em alguém que executa o I2P, peça para essa pessoa enviar um arquivo de reseed gerado usando esta página no console do router dela. Depois, use esta página para fazer o reseed com o arquivo que você recebeu. Primeiro, selecione o arquivo abaixo. Em seguida, clique em \u0026ldquo;Reseed from file\u0026rdquo;\nSe você conhece e confia em alguém que publica arquivos de reseed, peça a eles o URL. Em seguida, use esta página para fazer reseed com o URL que você recebeu. Primeiro, insira o URL abaixo. Depois, clique em \u0026ldquo;Reseed from URL\u0026rdquo;\nConsulte as FAQ para instruções sobre como fazer reseed manualmente\nOpções de Reseed Manual:\nRessincronizar a partir de URL - Insira uma URL zip ou su3 de uma fonte confiável e clique em \u0026ldquo;Ressincronizar a partir de URL\u0026rdquo;\nO formato su3 é preferível, pois será verificado como assinado por uma fonte confiável O formato zip não é assinado; use um arquivo zip apenas de uma fonte em que você confie Reseed a partir de Arquivo - Navegue e selecione um arquivo zip ou su3 local, depois clique em \u0026ldquo;Reseed from file\u0026rdquo;\nVocê pode encontrar arquivos de reseed em checki2p.com/reseed Criar Arquivo de Reseed - Gera um novo arquivo zip de reseed que você pode compartilhar para que outros façam reseed manualmente\nEste arquivo nunca conterá a identidade do seu próprio router ou IP Configuração de Reseeding:\nAs configurações padrão funcionarão para a maioria das pessoas. Altere-as apenas se HTTPS estiver bloqueado por um firewall restritivo e o reseed tiver falhado.\nURLs de Reseed - Lista de URLs HTTPS para servidores de reseed (a lista padrão está integrada e é atualizada regularmente) Configuração de Proxy - Configure proxy HTTP/HTTPS/SOCKS se você precisar acessar servidores de reseed através de um proxy Redefinir lista de URLs - Restaurar a lista padrão de servidores de reseed Importante: O resseeding manual só deve ser necessário em casos raros onde o resseeding automático falha repetidamente. A maioria dos usuários nunca precisará usar esta página.\nConfiguração de Rede URL: Configuração de Família de Routers A página de Configuração de Família de Roteadores permite que você gerencie famílias de roteadores. Roteadores na mesma família compartilham uma chave de família, que os identifica como sendo operados pela mesma pessoa ou organização. Isso impede que múltiplos roteadores que você controla sejam selecionados para o mesmo tunnel, o que reduziria o anonimato.\nO que é uma Família de Roteadores?\nQuando você opera múltiplos roteadores I2P, você deve configurá-los para fazer parte da mesma família. Isso garante: - Seus roteadores não serão usados juntos no mesmo caminho de túnel - Outros usuários mantêm o anonimato adequado quando seus túneis usam seus roteadores - A rede pode distribuir adequadamente a participação nos túneis\nFamília Atual:\nA página exibe o nome da família atual do seu router. Se você não faz parte de uma família, este campo estará vazio.\nExportar Chave da Família:\nExporte a chave secreta da família para ser importada em outros roteadores que você controla Clique em \u0026ldquo;Export Family Key\u0026rdquo; para baixar o arquivo de chave da sua família Importe esta chave em seus outros roteadores para adicioná-los à mesma família Deixar Família de Routers:\nDeixar de ser membro da família Clique em \u0026ldquo;Sair da Família\u0026rdquo; para remover este roteador de sua família atual Esta ação não pode ser desfeita sem reimportar a chave da família Considerações Importantes:\nRegistro Público Necessário: Para que sua família seja reconhecida em toda a rede, sua chave de família deve ser adicionada à base de código do I2P pela equipe de desenvolvimento. Isso garante que todos os routers da rede saibam sobre sua família. Entre em contato com a equipe do I2P para registrar sua chave de família se você operar múltiplos routers públicos A maioria dos usuários que executam apenas um router nunca precisará usar este recurso A configuração de família é usada principalmente por operadores de múltiplos routers públicos ou provedores de infraestrutura Casos de Uso:\nOperar múltiplos roteadores I2P para redundância Executar infraestrutura como servidores reseed ou outproxies em múltiplas máquinas Gerenciar uma rede de roteadores I2P para uma organização Configuração de Peers URL: Configuração de Túneis A página de Configuração de Túneis permite ajustar as configurações padrão de túneis tanto para túneis exploratórios (usados para comunicação do router) quanto para túneis de cliente (usados por aplicações). As configurações padrão funcionam para a maioria das pessoas e só devem ser alteradas se você entender as compensações.\nAvisos Importantes:\n⚠️ Compensação entre Anonimato e Desempenho: Existe uma compensação fundamental entre anonimato e desempenho. Tunnels com mais de 3 hops (por exemplo, 2 hops + 0-2 hops, 3 hops + 0-1 hops, 3 hops + 0-2 hops), ou uma quantidade alta + quantidade de backup, podem reduzir severamente o desempenho ou a confiabilidade. Pode resultar em alto uso de CPU e/ou alta largura de banda de saída. Altere essas configurações com cuidado e ajuste-as se tiver problemas.\n⚠️ Persistência: As alterações nas configurações de túneis exploratórios são armazenadas no arquivo router.config. As alterações em túneis de cliente são temporárias e não são salvas. Para fazer alterações permanentes em túneis de cliente, consulte a página I2PTunnel .\nTúneis Exploratórios:\nTúneis exploratórios são usados pelo seu router para comunicar com a base de dados de rede e participar na rede I2P.\nOpções de configuração para Inbound e Outbound: - Length - Número de saltos no tunnel (padrão: 2-3 saltos) - Randomization - Variação aleatória no comprimento do tunnel (padrão: 0-1 saltos) - Quantity - Número de tunnels ativos (padrão: 2 tunnels) - Backup quantity - Número de tunnels de backup prontos para ativar (padrão: 0 tunnels)\nTúneis Cliente para Servidor Web I2P:\nEstas configurações controlam os túneis para o servidor web I2P integrado (eepsite).\n⚠️ AVISO DE ANONIMATO - As configurações incluem túneis de 1 salto. ⚠️ AVISO DE DESEMPENHO - As configurações incluem grandes quantidades de túneis.\nOpções de configuração para Entrada e Saída: - Comprimento - Comprimento do tunnel (padrão: 1 hop para servidor web) - Aleatorização - Variação aleatória no comprimento do tunnel - Quantidade - Número de tunnels ativos - Quantidade de backup - Número de tunnels de backup\nTúneis de Cliente para Clientes Compartilhados:\nEstas configurações aplicam-se a aplicações cliente partilhadas (proxy HTTP, IRC, etc.).\nOpções de configuração para Inbound e Outbound: - Length - Comprimento do túnel (padrão: 3 saltos) - Randomization - Variação aleatória no comprimento do túnel - Quantity - Número de túneis ativos - Backup quantity - Número de túneis de backup\nCompreendendo os Parâmetros de Tunnel:\nComprimento: Túneis mais longos fornecem maior anonimato, mas reduzem o desempenho e a confiabilidade Aleatorização: Adiciona imprevisibilidade aos caminhos dos túneis, melhorando a segurança Quantidade: Mais túneis melhoram a confiabilidade e a distribuição de carga, mas aumentam o uso de recursos Quantidade de backup: Túneis pré-construídos prontos para substituir túneis com falha, melhorando a resiliência Melhores Práticas:\nMantenha as configurações padrão a menos que tenha necessidades específicas Apenas aumente o comprimento do tunnel se o anonimato for crítico e você puder aceitar desempenho mais lento Aumente a quantidade/backup apenas se estiver enfrentando falhas frequentes de tunnel Monitore o desempenho do router após fazer alterações Clique em \u0026ldquo;Save changes\u0026rdquo; para aplicar as modificações Configuração de Reseed URL: Configuração da Interface A página de Configuração da UI permite que você personalize a aparência e acessibilidade do console do seu router, incluindo seleção de tema, preferências de idioma e proteção por senha.\nTema da Console do Router:\nEscolha entre temas escuros e claros para a interface do console do router:\nEscuro - Tema de modo escuro (mais confortável para os olhos em ambientes com pouca luz) Claro - Tema de modo claro (aparência tradicional) Opções adicionais de tema: - Definir tema universalmente em todos os aplicativos - Aplicar o tema selecionado a todos os aplicativos I2P, não apenas ao console do router - Forçar o uso do console móvel - Usar a interface otimizada para dispositivos móveis mesmo em navegadores desktop - Incorporar aplicativos de Email e Torrent no console - Integrar o Susimail e o I2PSnark diretamente na interface do console em vez de abri-los em abas separadas\nIdioma do Console do Router:\nSelecione seu idioma preferido para a interface do console do router no menu suspenso. O I2P suporta muitos idiomas incluindo inglês, alemão, francês, espanhol, russo, chinês, japonês e outros.\nContribuições de tradução são bem-vindas: Se você notar traduções incompletas ou incorretas, pode ajudar a melhorar o I2P contribuindo para o projeto de tradução. Entre em contato com os desenvolvedores em #i2p-dev no IRC ou verifique o relatório de status da tradução (link disponível na página).\nSenha do Console do Router:\nAdicione autenticação de nome de usuário e senha para proteger o acesso ao seu console do router:\nNome de usuário - Insira o nome de usuário para acesso ao console Senha - Insira a senha para acesso ao console Adicionar usuário - Crie um novo usuário com as credenciais especificadas Excluir selecionados - Remova contas de usuário existentes Por que Adicionar uma Senha?\nImpede o acesso local não autorizado ao seu console do router Essencial se várias pessoas usam o seu computador Recomendado se o seu console do router está acessível na sua rede local Protege a sua configuração I2P e definições de privacidade contra adulteração Nota de Segurança: A proteção por senha afeta apenas o acesso à interface web do console do router em I2P Router Console . Ela não criptografa o tráfego I2P nem impede que aplicações utilizem o I2P. Se você é o único usuário do seu computador e o console do router escuta apenas em localhost (padrão), uma senha pode não ser necessária.\nConfiguração de Família de Routers URL: Configuração de WebApp A página de Configuração do WebApp permite gerenciar as aplicações web Java que são executadas dentro do seu roteador I2P. Essas aplicações são iniciadas pelo cliente webConsole e executam na mesma JVM que o roteador, fornecendo funcionalidade integrada acessível através do console do roteador.\nO que são WebApps?\nWebApps são aplicações baseadas em Java que podem ser: - Aplicações completas (ex: I2PSnark para torrents) - Interfaces front-end para outros clientes que devem ser habilitados separadamente (ex: Susidns, I2PTunnel) - Aplicações web sem interface web (ex: address book)\nNotas Importantes:\nUma webapp pode ser completamente desativada, ou pode apenas ser desativada de execução na inicialização Remover um arquivo war do diretório webapps desativa a webapp completamente No entanto, o arquivo .war e o diretório da webapp reaparecerão quando você atualizar seu router para uma versão mais recente Para desativar permanentemente uma webapp: Desative-a aqui, que é o método preferido WebApps Disponíveis:\nWebApp Description i2psnark Torrents - Built-in BitTorrent client for I2P i2ptunnel Hidden Services Manager - Configure client and server tunnels imagegen Identification Image Generator - Creates unique identicons jsonrpc jsonrpc.war - JSON-RPC API interface (disabled by default) routerconsole I2P Router Console - The main administrative interface susidns Address Book - Manage I2P addresses and subscriptions susimail Email - Web-based email client for I2P Controles: Para cada webapp: - Executar na Inicialização? - Caixa de seleção para ativar/desativar a inicialização automática - Controle - Botões Iniciar/Parar para controle imediato - Parar - Para a webapp atualmente em execução - Iniciar - Inicia uma webapp parada\nBotões de Configuração:\nCancelar - Descartar alterações e retornar à página anterior Salvar Configuração do WebApp - Salvar suas alterações e aplicá-las Casos de Uso:\nPare o I2PSnark se você não usa torrents para economizar recursos Desabilite o jsonrpc se você não precisa de acesso à API Pare o Susimail se você usa um cliente de email externo Pare temporariamente webapps para liberar memória ou solucionar problemas Dica de Desempenho: Desabilitar webapps não utilizadas pode reduzir o uso de memória e melhorar o desempenho do router, especialmente em sistemas com recursos limitados.\nHelp URL: Ajuda A página de Ajuda fornece documentação abrangente e recursos para ajudá-lo a entender e usar o I2P de forma eficaz. Ela serve como um centro central para solução de problemas, aprendizado e obtenção de suporte.\nO Que Você Encontrará:\nGuia de Início Rápido - Informações essenciais para novos usuários começarem a usar o I2P Perguntas Frequentes (FAQ) - Respostas para questões comuns sobre instalação, configuração e uso do I2P Solução de Problemas - Soluções para problemas comuns e questões de conectividade Documentação Técnica - Informações detalhadas sobre protocolos, arquitetura e especificações do I2P Guias de Aplicações - Instruções para usar aplicações I2P como torrents, email e serviços ocultos Informações sobre a Rede - Compreendendo como o I2P funciona e o que o torna seguro Recursos de Suporte - Links para fóruns, canais IRC e suporte da comunidade Obtendo Ajuda:\nSe você está enfrentando problemas com o I2P: 1. Consulte o FAQ para perguntas e respostas comuns 2. Revise a seção de solução de problemas para seu problema específico 3. Visite o fórum I2P em i2pforum.i2p ou i2pforum.net 4. Entre no canal IRC #i2p para suporte da comunidade em tempo real 5. Pesquise a documentação para informações técnicas detalhadas\nDica: A página de ajuda está sempre acessível pela barra lateral do console do router, facilitando encontrar assistência sempre que precisar.\nPerformance Graphs URL: Gráficos de Desempenho A página de Gráficos de Desempenho fornece monitoramento visual em tempo real do desempenho do seu router I2P e da atividade de rede. Esses gráficos ajudam você a entender o uso de largura de banda, conexões de peers, consumo de memória e a saúde geral do router.\nGráficos Disponíveis:\nUso de Largura de Banda\nTaxa de envio de baixo nível (bytes/seg) - Taxa de tráfego de saída Taxa de recebimento de baixo nível (bytes/seg) - Taxa de tráfego de entrada Mostra a utilização de largura de banda atual, média e máxima Ajuda a monitorar se você está se aproximando dos seus limites de largura de banda configurados Pares Ativos\nrouter.activePeers com média de 60 seg - Número de pares com os quais você está ativamente se comunicando Mostra a saúde da sua conectividade de rede Mais pares ativos geralmente significa melhor construção de túneis e participação na rede Uso de Memória do Router\nrouter.memoryUsed média de 60 seg - Consumo de memória da JVM Mostra o uso de memória atual, médio e máximo em MB Útil para identificar vazamentos de memória ou determinar se você precisa aumentar o tamanho do heap do Java Configurar Exibição de Gráfico:\nPersonalize como os gráficos são exibidos e atualizados:\nTamanho do gráfico - Define largura (padrão: 400 pixels) e altura (padrão: 100 pixels) Período de exibição - Intervalo de tempo a ser exibido (padrão: 60 minutos) Intervalo de atualização - Frequência de atualização dos gráficos (padrão: 5 minutos) Tipo de gráfico - Escolha entre exibição de Médias ou Eventos Ocultar legenda - Remove a legenda dos gráficos para economizar espaço UTC - Usa horário UTC em vez do horário local nos gráficos Persistência - Armazena dados do gráfico em disco para análise histórica Opções Avançadas:\nClique em [Select Stats] para escolher quais estatísticas exibir no gráfico: - Métricas de túnel (taxa de sucesso de construção, contagem de túneis, etc.) - Estatísticas da base de dados de rede - Estatísticas de transporte (NTCP2, SSU2) - Desempenho de túneis de cliente - E muitas outras métricas detalhadas\nCasos de Uso:\nMonitore a largura de banda para garantir que você não está excedendo os limites configurados Verifique a conectividade com peers ao solucionar problemas de rede Acompanhe o uso de memória para otimizar as configurações de heap do Java Identifique padrões de desempenho ao longo do tempo Diagnostique problemas de construção de túneis correlacionando os gráficos Dica: Clique em \u0026ldquo;Salvar configurações e redesenhar gráficos\u0026rdquo; após fazer alterações para aplicar sua configuração. Os gráficos serão atualizados automaticamente com base na sua configuração de intervalo de atualização.\n","description":"Um guia completo para compreender e configurar o Console do Router I2P","id":"c46f1b6edeab9b686fd57cf9b311df1c","section":"docs","title":"Guia de Configuração do Console do Router","url":"/pt/docs/guides/router-console-config/"},{"categories":null,"content":" Escopo: Este guia consolida a implementação de tunnel, o formato de mensagem e ambas as especificações de criação de tunnel (ECIES e ElGamal legado). Os links profundos existentes continuam funcionando por meio dos apelidos acima.\nModelo de Tunnel I2P encaminha cargas úteis por meio de tunnels unidirecionais: conjuntos ordenados de routers que transportam o tráfego em uma única direção. Uma ida e volta completa entre dois destinos requer quatro tunnels (dois de saída, dois de entrada).\nComece com a Visão geral de Tunnel para a terminologia e, em seguida, use este guia para os detalhes operacionais.\nCiclo de vida da mensagem O tunnel gateway (porta de entrada) agrupa uma ou mais mensagens I2NP, as fragmenta e escreve instruções de entrega. O gateway encapsula a carga útil em uma mensagem de tunnel de tamanho fixo (1024 B), adicionando preenchimento se necessário. Cada participante verifica o salto anterior, aplica sua camada de criptografia e encaminha {nextTunnelId, nextIV, encryptedPayload} para o próximo salto. O tunnel endpoint (ponto final) remove a camada final, consome as instruções de entrega, remonta os fragmentos e despacha as mensagens I2NP reconstruídas. A detecção de duplicatas usa um filtro de Bloom com decaimento, indexado pela XOR entre o vetor de inicialização (IV) e o primeiro bloco de cifra, para impedir ataques de marcação baseados em trocas de IV.\nResumo dos Papéis Role Pre-processing Crypto Operation Post-processing Outbound gateway (creator) Fragment, batch, pad Iteratively decrypt using every hop’s keys (so downstream peers encrypt) Forward to first hop Participant — Encrypt IV and payload with hop keys Forward to next hop Outbound endpoint — Encrypt once more to reveal plaintext payload Deliver to target tunnel/destination Inbound gateway Fragment, batch, pad Encrypt with local keys Forward to next hop Inbound endpoint (creator) — Iteratively decrypt using stored hop keys Reassemble and deliver locally ### Fluxo de criptografia {#encryption-workflow} Inbound tunnels: o gateway criptografa uma vez com sua chave de camada; os participantes a jusante continuam criptografando até o criador decifrar a carga útil final. Outbound tunnels: o gateway pré-aplica o inverso da criptografia de cada salto, de modo que cada participante criptografe. Quando o ponto final criptografa, o texto em claro original do gateway é revelado. Ambas as direções encaminham {tunnelId, IV, encryptedPayload} para o próximo salto.\nFormato de Mensagem de Tunnel Os gateways de tunnel fragmentam as mensagens I2NP em envelopes de tamanho fixo para ocultar o comprimento da carga útil e simplificar o processamento em cada salto.\nLayout Criptografado +----------------+----------------+-------------------+ | Tunnel ID (4B) | IV (16B) | Encrypted payload | +----------------+----------------+-------------------+ Tunnel ID – identificador de 32 bits para o próximo salto (diferente de zero, é renovado a cada ciclo de construção). IV – IV de 16 bytes do AES escolhido por mensagem. Encrypted payload – 1008 bytes de texto cifrado em AES-256-CBC. Tamanho total: 1028 bytes.\nLayout descriptografado Depois que um salto remove sua camada de criptografia:\n[Checksum (4B)][Padding ... 0x00 terminator] [Delivery Instructions 1][I2NP fragment 1] [Delivery Instructions 2][I2NP fragment 2] ... Soma de verificação valida o bloco descriptografado. Preenchimento são bytes aleatórios não nulos terminados por um byte zero. Instruções de entrega dizem ao ponto final como lidar com cada fragmento (entregar localmente, encaminhar para outro tunnel, etc.). Fragmentos transportam as mensagens I2NP subjacentes; o ponto final os remonta antes de passá-los para camadas superiores. Etapas de Processamento Gateways fragmentam e enfileiram mensagens I2NP, retendo fragmentos parciais por um breve período para remontagem. O gateway cifra a carga útil com as chaves de camada apropriadas e insere o tunnel ID e o IV. Cada participante cifra o IV (AES-256/ECB) e depois a carga útil (AES-256/CBC), antes de recifrar o IV e encaminhar a mensagem. O endpoint decifra na ordem inversa, verifica o checksum, consome as instruções de entrega e remonta os fragmentos. Criação de Tunnel (ECIES-X25519) Routers modernos constroem tunnels com chaves ECIES-X25519, reduzindo o tamanho das mensagens de criação e permitindo sigilo direto.\nMensagem de construção: uma única mensagem I2NP TunnelBuild (ou VariableTunnelBuild) carrega de 1–8 registros de construção criptografados, um por salto. Chaves de camada: os criadores derivam, para cada salto, as chaves de camada, IV e de resposta via HKDF, usando a identidade X25519 estática do salto e a chave efêmera do criador. Processamento: cada salto descriptografa seu registro, valida os flags da solicitação, escreve o bloco de resposta (sucesso ou código de falha detalhado), recriptografa os registros restantes e encaminha a mensagem. Respostas: o criador recebe uma mensagem de resposta garlic-wrapped (encapsulada usando garlic encryption). Registros marcados como falhos incluem um código de severidade para que o router possa traçar um perfil do par. Compatibilidade: routers ainda podem aceitar construções legadas em ElGamal para retrocompatibilidade, mas novos tunnels usam ECIES por padrão. Para constantes campo a campo e notas de derivação de chaves, consulte o histórico da proposta ECIES e o código-fonte do router; este guia aborda o fluxo operacional.\nCriação legada de Tunnel (ElGamal-2048) O formato original de construção de tunnel usava chaves públicas ElGamal. Os routers modernos mantêm suporte limitado para retrocompatibilidade.\nStatus: Obsoleto. Mantido aqui para referência histórica e para quem mantém ferramentas compatíveis com versões legadas.\nTelescoping não interativo: uma única mensagem de construção percorre todo o caminho. Cada salto decifra seu registro de 528 bytes, atualiza a mensagem e a encaminha. Comprimento variável: a Variable Tunnel Build Message (VTBM, Mensagem de construção de tunnel variável) permitia 1–8 registros. A mensagem fixa anterior sempre continha oito registros para obscurecer o comprimento do tunnel. Layout do registro de solicitação: Bytes 0–3 : Tunnel ID (receiving ID) Bytes 4–35 : Current hop router hash Bytes 36–39 : Next tunnel ID Bytes 40–71 : Next hop router hash Bytes 72–103 : AES-256 layer key Bytes 104–135: AES-256 IV key Bytes 136–167: AES-256 reply key Bytes 168–183: AES-256 reply IV Byte 184 : Flags (bit7=IBGW, bit6=OBEP) Bytes 185–188: Request time (hours since epoch) Bytes 189–192: Next message ID Bytes 193–221: Padding Sinalizadores: o bit 7 indica um gateway de entrada (IBGW); o bit 6 marca uma extremidade de saída (OBEP). Eles são mutuamente exclusivos. Criptografia: cada registro é cifrado com ElGamal-2048 usando a chave pública do salto. O encadeamento simétrico em camadas com AES-256-CBC garante que apenas o salto destinado possa ler seu registro. Fatos-chave: os IDs de tunnel são valores de 32 bits não nulos; os criadores podem inserir registros fictícios para ocultar o comprimento real do tunnel; a confiabilidade depende de refazer construções de tunnel que falharam. Tunnel Pools e Ciclo de Vida Routers mantêm pools de tunnel de entrada e de saída independentes para o tráfego exploratório e para cada sessão I2CP.\nSeleção de pares: tunnels exploratórios usam o balde de pares \u0026ldquo;ativos, sem falhas\u0026rdquo; para incentivar diversidade; tunnels de cliente preferem pares rápidos e de alta capacidade. Ordenação determinística: os pares são ordenados pela distância XOR entre SHA256(peerHash || poolKey) e a chave aleatória do pool. A chave é rotacionada na reinicialização, dando estabilidade dentro de uma execução enquanto dificulta ataques de predecessor entre execuções. Ciclo de vida: routers rastreiam tempos históricos de construção por tupla {modo, direção, comprimento, variância}. À medida que os tunnels se aproximam da expiração, as substituições começam cedo; o router aumenta as construções paralelas quando ocorrem falhas, enquanto limita as tentativas pendentes. Ajustes de configuração: contagens de tunnels ativos/de backup, comprimento de salto e variância, permissões de zero salto e limites de taxa de construção são todos ajustáveis por pool. Congestionamento e Confiabilidade Embora tunnels se assemelhem a circuitos, routers os tratam como filas de mensagens. O Descarte Aleatório Ponderado Antecipado (WRED) é usado para manter a latência limitada:\nA probabilidade de descarte aumenta à medida que a utilização se aproxima dos limites configurados. Os participantes consideram fragmentos de tamanho fixo; gateways/endpoints descartam com base no tamanho combinado dos fragmentos, penalizando primeiro cargas úteis grandes. Os endpoints de saída descartam antes de outros papéis para desperdiçar o mínimo possível de esforço de rede. A entrega garantida fica a cargo de camadas superiores, como a biblioteca de streaming . As aplicações que requerem fiabilidade devem tratar elas próprias da retransmissão e das confirmações de receção.\nLeitura adicional Seleção de Pares Visão Geral de Tunnels Implementação Antiga de Tunnel ","description":"Especificação unificada para construir, criptografar e transportar tráfego com I2P tunnels.","id":"6fb0b76b8bc10fa3e571b748f502baaa","section":"docs","title":"Guia de Operações de Tunnels","url":"/pt/docs/specs/implementation/"},{"categories":null,"content":"Os routers do I2P falham mais comumente devido a problemas de redirecionamento de portas, alocação de largura de banda insuficiente e tempo de bootstrap (inicialização da rede) inadequado. Esses três fatores respondem por mais de 70% dos problemas relatados. O router requer pelo menos 10-15 minutos após a inicialização para se integrar completamente à rede, largura de banda mínima de 128 KB/sec (256 KB/sec recomendado), e redirecionamento de portas UDP/TCP adequado para alcançar status não bloqueado por firewall. Usuários novos frequentemente esperam conectividade imediata e reiniciam prematuramente, o que reinicia o progresso de integração e cria um ciclo frustrante. Este guia fornece soluções detalhadas para todos os principais problemas do I2P que afetam as versões 2.10.0 e posteriores.\nA arquitetura de anonimato do I2P intrinsecamente sacrifica velocidade em favor da privacidade por meio de tunnel criptografado de múltiplos saltos. Compreender esse design fundamental ajuda os usuários a estabelecer expectativas realistas e a solucionar problemas de forma eficaz, em vez de confundir comportamento normal com problemas.\nRouter não inicia ou falha imediatamente As falhas de inicialização mais comuns geralmente decorrem de conflitos de portas, incompatibilidade de versão do Java ou arquivos de configuração corrompidos. Verifique se outra instância do I2P já está em execução antes de investigar problemas mais profundos.\nVerifique se não há processos em conflito:\nLinux: ps aux | grep i2p ou netstat -tulpn | grep 7657\nWindows: Gerenciador de Tarefas → Detalhes → procure por java.exe com i2p na linha de comando\nmacOS: Monitor de Atividade → pesquise por \u0026ldquo;i2p\u0026rdquo;\nSe existir um processo zumbi, finalize-o: pkill -9 -f i2p (Linux/Mac) ou taskkill /F /IM javaw.exe (Windows)\nVerifique a compatibilidade da versão do Java:\nI2P 2.10.0+ requer Java 8 mínimo, com Java 11 ou posterior recomendado. Verifique se sua instalação mostra \u0026ldquo;mixed mode\u0026rdquo; (não \u0026ldquo;interpreted mode\u0026rdquo;):\njava -version Deve exibir: OpenJDK ou Oracle Java, versão 8+, \u0026ldquo;mixed mode\u0026rdquo;\nEvite: GNU GCJ, implementações desatualizadas do Java, modos somente interpretados\nConflitos comuns de portas ocorrem quando vários serviços competem pelas portas padrão do I2P. O console do router (7657), I2CP (7654), SAM (7656) e o proxy HTTP (4444) devem estar disponíveis. Verifique se há conflitos: netstat -ano | findstr \u0026quot;7657 4444 7654\u0026quot; (Windows) ou lsof -i :7657,4444,7654 (Linux/Mac).\nCorrupção do arquivo de configuração se manifesta como falhas imediatas com erros de análise nos logs. Router.config exige codificação UTF-8 sem BOM, usa = como separador (não :) e proíbe certos caracteres especiais. Faça backup e depois examine: ~/.i2p/router.config (Linux), %LOCALAPPDATA%\\I2P\\router.config (Windows), ~/Library/Application Support/i2p/router.config (macOS).\nPara redefinir a configuração preservando a identidade: Pare o I2P, faça backup de router.keys e do diretório keyData, apague router.config, reinicie. O router regenera a configuração padrão.\nAlocação de heap do Java muito baixa causa falhas por OutOfMemoryError. Edite o arquivo wrapper.config e aumente wrapper.java.maxmemory do padrão 128 ou 256 para mínimo 512 (1024 para routers de alta largura de banda). Isso exige um desligamento completo, aguardar 11 minutos e então reiniciar - clicar em \u0026ldquo;Restart\u0026rdquo; no console não aplicará a alteração.\nResolvendo o status \u0026ldquo;Network: Firewalled\u0026rdquo; O estado de bloqueio por firewall significa que o router não consegue receber conexões de entrada diretas, obrigando a depender de introducers (pares introdutores). Embora o router funcione nesse estado, o desempenho se degrada significativamente e a contribuição para a rede permanece mínima. Alcançar o estado sem bloqueio por firewall requer configurar corretamente o redirecionamento de portas.\nO router seleciona aleatoriamente uma porta entre 9000-31000 para comunicações. Encontre sua porta em http://127.0.0.1:7657/confignet - procure por \u0026ldquo;UDP Port\u0026rdquo; e \u0026ldquo;TCP Port\u0026rdquo; (normalmente o mesmo número). Você deve encaminhar tanto UDP quanto TCP para obter desempenho ideal, embora apenas o UDP permita a funcionalidade básica.\nAtivar o redirecionamento automático de portas via UPnP (método mais simples):\nAcesse http://127.0.0.1:7657/confignet Marque \u0026ldquo;Enable UPnP\u0026rdquo; Salve as alterações e reinicie o router Aguarde 5-10 minutos e verifique se o status muda de \u0026ldquo;Network: Firewalled\u0026rdquo; para \u0026ldquo;Network: OK\u0026rdquo; O UPnP requer suporte do router (ativado por padrão na maioria dos routers de consumo fabricados após 2010) e uma configuração de rede adequada.\nRedirecionamento manual de portas (necessário quando o UPnP falha):\nAnote sua porta do I2P em http://127.0.0.1:7657/confignet (por exemplo, 22648) Encontre seu endereço IP local: ipconfig (Windows), ip addr (Linux), Preferências do Sistema → Rede (macOS) Acesse a interface de administração do seu router (normalmente 192.168.1.1 ou 192.168.0.1) Navegue até Redirecionamento de Portas (pode estar em Avançado, NAT ou Servidores Virtuais) Crie duas regras: Porta Externa: [sua porta do I2P] → IP Interno: [seu computador] → Porta Interna: [mesma] → Protocolo: UDP Porta Externa: [sua porta do I2P] → IP Interno: [seu computador] → Porta Interna: [mesma] → Protocolo: TCP Salve as configurações e reinicie seu router se necessário Verifique o redirecionamento de portas usando verificadores online após a configuração. Se a detecção falhar, verifique as configurações do firewall - tanto o firewall do sistema quanto qualquer firewall do antivírus devem permitir a porta do I2P.\nAlternativa \u0026ldquo;Hidden mode\u0026rdquo; para redes restritivas onde o redirecionamento de portas é impossível: Ative em http://127.0.0.1:7657/confignet → marque \u0026ldquo;Hidden mode\u0026rdquo;. O router permanece atrás de firewall, mas otimiza-se para esse estado usando exclusivamente SSU introducers (pares intermediários do SSU). O desempenho será mais lento, porém funcional.\nRouter travado nos estados \u0026ldquo;Iniciando\u0026rdquo; ou \u0026ldquo;Testando\u0026rdquo; Esses estados transitórios durante a inicialização normalmente se resolvem em 10-15 minutos para novas instalações ou 3-5 minutos para routers estabelecidos. Intervenções prematuras frequentemente pioram os problemas.\n\u0026ldquo;Network: Testing\u0026rdquo; indica que o router está verificando a capacidade de ser alcançado por meio de vários tipos de conexão (direta, introducers (nós introdutores), várias versões de protocolo). Isso é normal nos primeiros 5-10 minutos após a inicialização. O router testa vários cenários para determinar a configuração ideal.\n\u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; aparece durante a inicialização enquanto o router não tiver informações suficientes sobre pares. O router não participará do tráfego de retransmissão até estar adequadamente integrado. Esta mensagem deve desaparecer após 10-20 minutos, assim que o netDb estiver populado com mais de 50 routers.\nO desvio do relógio compromete os testes de alcançabilidade. I2P exige que o horário do sistema esteja dentro de ±60 segundos do horário da rede. Uma diferença superior a 90 segundos causa rejeição automática da conexão. Sincronize o relógio do sistema:\nLinux: sudo timedatectl set-ntp true \u0026amp;\u0026amp; sudo systemctl restart systemd-timesyncd\nWindows: Painel de Controle → Data e Hora → Hora da Internet → Atualizar agora → Ativar sincronização automática\nmacOS: Preferências do Sistema → Data e Hora → Ativar \u0026ldquo;Definir data e hora automaticamente\u0026rdquo;\nApós corrigir o desvio de relógio, reinicie o I2P completamente para uma integração adequada.\nAlocação de largura de banda insuficiente impede testes bem-sucedidos. O router precisa de capacidade adequada para construir tunnels de teste. Configure em http://127.0.0.1:7657/config:\nMínimo viável: Entrada 96 KB/sec, Saída 64 KB/sec Padrão recomendado: Entrada 256 KB/sec, Saída 128 KB/sec Desempenho ideal: Entrada 512+ KB/sec, Saída 256+ KB/sec Percentual de compartilhamento: 80% (permite ao router contribuir com largura de banda para a rede) Uma largura de banda mais baixa pode funcionar, mas prolonga o tempo de integração de minutos para horas.\nnetDb corrompido devido a encerramento incorreto ou erros de disco causa loops de teste intermináveis. O router não consegue concluir os testes sem dados de pares válidos:\n# Stop I2P completely i2prouter stop # or systemctl stop i2p # Delete corrupted database (safe - will reseed automatically) rm -rf ~/.i2p/netDb/* # Restart and allow 10-15 minutes for reseed i2prouter start Windows: Apague o conteúdo de %APPDATA%\\I2P\\netDb\\ ou %LOCALAPPDATA%\\I2P\\netDb\\\nFirewall bloqueando o reseed (obtenção inicial de pares) impede a obtenção de pares iniciais. Durante a inicialização, o I2P obtém informações do router em servidores de reseed via HTTPS. Firewalls corporativos ou de provedores (ISP) podem bloquear essas conexões. Configure o proxy de reseed em http://127.0.0.1:7657/configreseed se estiver operando por trás de redes restritivas.\nVelocidades lentas, timeouts (tempo esgotado) e falhas na construção de tunnel A arquitetura do I2P produz inerentemente velocidades 3-10x mais lentas do que a clearnet (internet aberta) devido à criptografia de múltiplos saltos, à sobrecarga de pacotes e à imprevisibilidade das rotas. O estabelecimento de um tunnel percorre múltiplos routers, cada um adicionando latência. Entender isso evita confundir o comportamento normal com problemas.\nExpectativas típicas de desempenho:\nNavegação na web em sites .i2p: tempos de carregamento de página de 10-30 segundos inicialmente, mais rápido após o estabelecimento do tunnel Torrenting via I2PSnark: 10-100 KB/s por torrent, dependendo dos semeadores e das condições da rede Downloads de arquivos grandes: Requer paciência - arquivos de megabytes podem levar minutos; de gigabytes, horas A primeira conexão é a mais lenta: a construção do tunnel leva 30-90 segundos; conexões subsequentes usam tunnels existentes Taxa de sucesso na construção de Tunnel indica a saúde da rede. Verifique em http://127.0.0.1:7657/tunnels:\nAcima de 60%: Funcionamento normal e saudável 40-60%: Marginal, considere aumentar a largura de banda ou reduzir a carga Abaixo de 40%: Problemático - indica largura de banda insuficiente, problemas de rede ou seleção de pares deficiente Aumente a alocação de largura de banda como primeira otimização. A maior parte do desempenho lento decorre de escassez de largura de banda. Em http://127.0.0.1:7657/config, aumente os limites incrementalmente e monitore os gráficos em http://127.0.0.1:7657/graphs.\nPara DSL/Cabo (conexões de 1-10 Mbps): - Entrada: 400 KB/sec - Saída: 200 KB/sec - Compartilhamento: 80% - Memória: 384 MB (edite wrapper.config)\nPara alta velocidade (conexões de 10-100+ Mbps): - Entrada: 1500 KB/sec - Saída: 1000 KB/sec - Compartilhamento: 80-100% - Memória: 512-1024 MB - Considere: aumentar o número de tunnels participantes para 2000-5000 em http://127.0.0.1:7657/configadvanced\nOtimize a configuração do tunnel para melhor desempenho. Acesse as configurações específicas de tunnel em http://127.0.0.1:7657/i2ptunnel e edite cada tunnel:\nQuantidade de tunnel: Aumente de 2 para 3-4 (mais caminhos disponíveis) Quantidade de backup: Defina para 1-2 (failover (comutação por falha) rápido se o tunnel falhar) Comprimento do tunnel: O padrão de 3 saltos oferece bom equilíbrio; reduzir para 2 melhora a velocidade, mas diminui o anonimato Biblioteca nativa de criptografia (jbigi) oferece desempenho 5-10x melhor do que a criptografia em Java puro. Verifique se foi carregada em http://127.0.0.1:7657/logs - procure por \u0026ldquo;jbigi loaded successfully\u0026rdquo; ou \u0026ldquo;Using native CPUID implementation\u0026rdquo;. Se ausente:\nLinux: Normalmente é detectado automaticamente e carregado a partir de ~/.i2p/jbigi-*.so Windows: Verifique se há jbigi.dll no diretório de instalação do I2P Se ausente: Instale as ferramentas de compilação e compile a partir do código-fonte, ou faça download de binários pré-compilados dos repositórios oficiais\nMantenha o router em execução continuamente. Cada reinício redefine a integração, exigindo 30-60 minutos para reconstruir a rede de tunnel e os relacionamentos com pares. Routers estáveis com alto tempo de atividade são preferidos para a construção de tunnel, criando um feedback positivo para o desempenho.\nAlto consumo de CPU e memória Uso excessivo de recursos normalmente indica alocação de memória inadequada, ausência de bibliotecas nativas de criptografia ou compromisso excessivo com a participação na rede. Routers bem configurados devem consumir 10–30% de CPU durante o uso ativo e manter o uso de memória estável abaixo de 80% do heap alocado.\nProblemas de memória manifestam-se como: - Gráficos de memória com topo plano (fixados no máximo) - Coleta de lixo frequente (padrão em dente de serra com quedas acentuadas) - OutOfMemoryError nos logs - Router ficando sem resposta sob carga - Desligamento automático devido ao esgotamento de recursos\nAumente a alocação de heap do Java no wrapper.config (requer encerramento completo):\n# Linux: ~/.i2p/wrapper.config # Windows: %APPDATA%\\I2P\\wrapper.config # Find and modify: wrapper.java.maxmemory=512 # Recommendations by usage: # Light browsing only: 256 # Standard use (browsing + light torrenting): 512 # Heavy use (multiple applications, active torrenting): 768-1024 # Floodfill or very high bandwidth: 1024-2048 Crítico: Após editar o wrapper.config, você deve encerrar completamente (não reiniciar), aguardar 11 minutos para uma finalização limpa e então iniciar do zero. O botão \u0026ldquo;Restart\u0026rdquo; do console do Router não recarrega as configurações do wrapper.\nA otimização da CPU requer uma biblioteca de criptografia nativa. Operações de BigInteger em Java puro consomem 10-20x mais CPU do que implementações nativas. Verifique o status do jbigi em http://127.0.0.1:7657/logs durante a inicialização. Sem o jbigi, a CPU terá picos de 50-100% durante a construção de tunnel e operações de criptografia.\nReduza a carga de tunnels participantes se o router estiver sobrecarregado:\nAcesse http://127.0.0.1:7657/configadvanced Defina router.maxParticipatingTunnels=1000 (padrão 8000) Reduza o percentual de compartilhamento em http://127.0.0.1:7657/config de 80% para 50% Desative o modo floodfill (nó que mantém e distribui a netDb) se estiver ativado: router.floodfillParticipant=false Limite a largura de banda do I2PSnark e o número de torrents simultâneos. O uso de torrents consome muitos recursos. Em http://127.0.0.1:7657/i2psnark:\nLimite o número de torrents ativos a no máximo 3-5 Defina \u0026ldquo;Up BW Limit\u0026rdquo; e \u0026ldquo;Down BW Limit\u0026rdquo; para valores razoáveis (50-100 KB/sec cada) Pare os torrents quando não forem necessários Evite semear dezenas de torrents simultaneamente Monitore o uso de recursos por meio de gráficos integrados em http://127.0.0.1:7657/graphs. A memória deve mostrar folga, não um topo achatado. Picos de CPU durante a construção de tunnel são normais; CPU alta sustentada indica problemas de configuração.\nPara sistemas com recursos severamente limitados (Raspberry Pi, hardware antigo), considere o i2pd (implementação em C++) como alternativa. O i2pd requer ~130 MB de RAM contra 350+ MB do Java I2P e usa ~7% de CPU contra 70% sob cargas semelhantes. Observe que o i2pd não inclui aplicativos integrados e requer ferramentas externas.\nProblemas com torrents no I2PSnark A integração do I2PSnark com a arquitetura do router I2P exige compreender que o uso de torrents depende inteiramente da saúde dos router tunnels. Os torrents não começarão até que o router alcance integração adequada com 10+ pares ativos e tunnels em funcionamento.\nTorrents travados em 0% geralmente indicam:\nRouter não totalmente integrado: Aguarde 10-15 minutos após a inicialização do I2P antes de esperar atividade de torrent DHT desativado: Ative em http://127.0.0.1:7657/i2psnark → Configuration → marque \u0026ldquo;Enable DHT\u0026rdquo; (habilitado por padrão desde a versão 0.9.2) Rastreadores inválidos ou inativos: Torrents do I2P exigem rastreadores específicos do I2P - rastreadores da clearnet não funcionarão Configuração de tunnel insuficiente: Aumente os tunnels em I2PSnark Configuration → Tunnels section Configure os tunnels do I2PSnark para melhor desempenho:\nTunnels de entrada: 3-5 (padrão: 2 no Java I2P, 5 no i2pd) Tunnels de saída: 3-5 Comprimento do tunnel: 3 saltos (reduza para 2 para maior velocidade, menos anonimato) Quantidade de tunnels: 3 (fornece desempenho consistente) Trackers de torrent essenciais do I2P para incluir: - tracker2.postman.i2p (principal, mais confiável) - w7tpbzncbcocrqtwwm3nezhnnsw4ozadvi2hmvzdhrqzfxfum7wa.b32.i2p/a\nRemova quaisquer rastreadores clearnet (internet pública; não-.i2p) - eles não têm utilidade e geram tentativas de conexão que excedem o tempo limite.\n\u0026ldquo;Torrent not registered\u0026rdquo; erros ocorrem quando a comunicação com o tracker falha. Clique com o botão direito no torrent → \u0026ldquo;Start\u0026rdquo; para forçar um novo anúncio. Se persistir, verifique a acessibilidade do tracker acessando http://tracker2.postman.i 2p em um navegador configurado para o I2P. Trackers inativos devem ser substituídos por alternativas funcionais.\nNenhum par se conectando apesar do sucesso do tracker (rastreador) sugere: - Router bloqueado por firewall (melhora com redirecionamento de portas, mas não é obrigatório) - Largura de banda insuficiente (aumente para 256+ KB/sec) - Swarm (enxame de pares) muito pequeno (alguns torrents têm 1-2 seeders (semeadores); paciência necessária) - DHT (Tabela de Hash Distribuída) desativada (ative para descoberta de pares sem tracker)\nAtivar DHT e PEX (Peer Exchange) nas configurações do I2PSnark. A DHT permite encontrar pares sem depender de um rastreador. O PEX descobre pares a partir dos pares conectados, acelerando a descoberta do enxame.\nCorrupção de arquivos baixados raramente ocorre com a verificação de integridade integrada do I2PSnark. Se detectada:\nClique com o botão direito no torrent → \u0026ldquo;Verificar\u0026rdquo; força o recálculo do hash de todas as partes Exclua os dados corrompidos do torrent (mantém o arquivo .torrent) Clique com o botão direito → \u0026ldquo;Iniciar\u0026rdquo; para baixar novamente com verificação das partes Verifique o disco em busca de erros se a corrupção persistir: chkdsk (Windows), fsck (Linux) Diretório monitorado não está funcionando requer configuração adequada:\nConfiguração do I2PSnark → \u0026ldquo;Watch directory\u0026rdquo;: Defina um caminho absoluto (por exemplo, /home/user/torrents/watch) Garanta que o processo do I2P tenha permissões de leitura: chmod 755 /path/to/watch Coloque arquivos .torrent no diretório de monitoramento - o I2PSnark os adiciona automaticamente Configure \u0026ldquo;Auto start\u0026rdquo;: Defina se os torrents devem iniciar imediatamente ao serem adicionados Otimização de desempenho para uso de torrents:\nLimite o número de torrents ativos simultâneos: no máximo 3-5 para conexões padrão Priorize downloads importantes: interrompa temporariamente os torrents de baixa prioridade Aumente a alocação de largura de banda do router: mais largura de banda = melhor desempenho de torrents Tenha paciência: torrents no I2P são por natureza mais lentos do que o BitTorrent na clearnet (internet pública) Semeie após o download: a rede prospera com a reciprocidade Configuração e solução de problemas do Git via I2P Operações do Git via I2P requerem configuração de proxy SOCKS ou I2P tunnels dedicados para acesso SSH/HTTP. O design do Git pressupõe conexões de baixa latência, o que torna desafiadora a arquitetura de alta latência do I2P.\nConfigurar o Git para usar um proxy SOCKS do I2P:\nEdite ~/.ssh/config (crie se não existir):\nHost *.i2p ProxyCommand nc -X 5 -x 127.0.0.1:4447 %h %p ServerAliveInterval 60 ServerAliveCountMax 3 Compression yes Isso encaminha todas as conexões SSH para hosts .i2p através do proxy SOCKS do I2P (porta 4447). As configurações ServerAlive (opções do SSH para manter a sessão ativa) mantêm a conexão durante a latência do I2P.\nPara operações HTTP/HTTPS do git, configure o git globalmente:\ngit config --global http.proxy socks5h://127.0.0.1:4447 git config --global https.proxy socks5h://127.0.0.1:4447 Nota: socks5h realiza a resolução de DNS através do proxy - crucial para domínios .i2p.\nCriar tunnel I2P dedicado para SSH do Git (mais confiável que SOCKS):\nAcesse http://127.0.0.1:7657/i2ptunnel \u0026ldquo;Novo tunnel cliente\u0026rdquo; → \u0026ldquo;Padrão\u0026rdquo; Configure: Nome: Git-SSH Tipo: Cliente Porta: 2222 (porta local para acesso ao Git) Destino: [seu-servidor-git].i2p:22 Inicialização automática: Ativado Contagem de tunnel: 3-4 (valores mais altos aumentam a confiabilidade) Salve e inicie o tunnel Configure o SSH para usar o tunnel: ssh -p 2222 git@127.0.0.1 Erros de autenticação SSH via I2P geralmente decorrem de:\nChave não adicionada ao ssh-agent: ssh-add ~/.ssh/id_rsa Permissões incorretas do arquivo da chave: chmod 600 ~/.ssh/id_rsa Tunnel não está em execução: Verifique em http://127.0.0.1:7657/i2ptunnel se o status está verde Servidor Git requer tipo de chave específico: gere uma chave ed25519 se RSA falhar O tempo limite nas operações do Git está relacionado às características de latência do I2P:\nAumente o tempo limite do Git: git config --global http.postBuffer 524288000 (buffer de 500 MB) Aumente o limite de baixa velocidade: git config --global http.lowSpeedLimit 1000 e git config --global http.lowSpeedTime 600 (aguarda 10 minutos) Use um clone raso para o checkout inicial: git clone --depth 1 [url] (busca apenas o commit mais recente, mais rápido) Clone durante períodos de baixa atividade: O congestionamento da rede afeta o desempenho do I2P Operações lentas de git clone/fetch são inerentes à arquitetura do I2P. Um repositório de 100MB pode levar 30-60 minutos via I2P, contra segundos na clearnet (internet comum). Estratégias:\nUse clones superficiais: --depth 1 reduz drasticamente a transferência inicial de dados Busque incrementalmente: Em vez de um clone completo, busque ramificações específicas: git fetch origin branch:branch Considere rsync sobre I2P: Para repositórios muito grandes, o rsync pode ter melhor desempenho Aumente a quantidade de tunnels: Mais tunnels proporcionam melhor taxa de transferência para transferências grandes e de longa duração Erros \u0026ldquo;Connection refused\u0026rdquo; indicam configuração incorreta do tunnel:\nVerifique se o I2P router está em execução: acesse http://127.0.0.1:7657 Confirme que o tunnel está ativo e verde em http://127.0.0.1:7657/i2ptunnel Teste o tunnel: nc -zv 127.0.0.1 2222 (deve conectar se o tunnel estiver funcionando) Verifique se o destino está acessível: acesse a interface HTTP do destino, se disponível Revise os logs do tunnel em http://127.0.0.1:7657/logs para erros específicos Melhores práticas para usar Git via I2P:\nMantenha o I2P router em execução continuamente para acesso estável ao Git Use chaves SSH em vez de autenticação por senha (menos solicitações interativas) Configure tunnels persistentes em vez de conexões SOCKS efêmeras Considere hospedar seu próprio servidor Git no I2P para maior controle Documente seus pontos de extremidade Git .i2p para colaboradores Acessando eepsites e resolvendo domínios .i2p A razão mais frequente pela qual os usuários não conseguem acessar sites .i2p é configuração incorreta do proxy do navegador. Os sites I2P existem apenas dentro da rede I2P e exigem encaminhamento por meio do proxy HTTP do I2P.\nConfigure as configurações de proxy do navegador exatamente:\nFirefox (recomendado para I2P):\nMenu → Configurações → Configurações de rede → botão Configurações Selecione \u0026ldquo;Configuração manual de proxy\u0026rdquo; Proxy HTTP: 127.0.0.1 Porta: 4444 Proxy SSL: 127.0.0.1 Porta: 4444 Proxy SOCKS: 127.0.0.1 Porta: 4447 (opcional, para aplicativos SOCKS) Marque \u0026ldquo;Proxy DNS ao usar SOCKS v5\u0026rdquo; Clique em OK para salvar Configurações críticas do Firefox em about:config:\nNavegue até about:config e modifique:\nmedia.peerconnection.ice.proxy_only = true (impede vazamentos de IP via WebRTC) keyword.enabled = false (impede que endereços .i2p redirecionem para mecanismos de busca) network.proxy.socks_remote_dns = true (DNS através do proxy) Limitações do Chrome/Chromium:\nO Chrome usa as configurações de proxy do sistema em vez de específicas do aplicativo. No Windows: Configurações → pesquise por \u0026ldquo;proxy\u0026rdquo; → \u0026ldquo;Abrir as configurações de proxy do seu computador\u0026rdquo; → Configure HTTP: 127.0.0.1:4444 e HTTPS: 127.0.0.1:4445.\nMelhor abordagem: use as extensões FoxyProxy ou Proxy SwitchyOmega para roteamento seletivo de .i2p.\nErros \u0026ldquo;Website Not Found In Address Book\u0026rdquo; significam que o router não tem o endereço criptográfico do domínio .i2p. O I2P usa livros de endereços locais em vez de DNS centralizado. Soluções:\nMétodo 1: Use os jump services (mais fácil para sites novos):\nAcesse http://stats.i 2p e pesquise pelo site. Clique no link addresshelper (auxiliar de endereço): http://example.i2p/?i2paddresshelper=base64destination. Seu navegador mostra \u0026ldquo;Salvar no livro de endereços?\u0026rdquo; - confirme para adicionar.\nMétodo 2: Atualizar as assinaturas do livro de endereços:\nAcesse http://127.0.0.1:7657/dns (SusiDNS) Clique na guia \u0026ldquo;Subscriptions\u0026rdquo; Verifique as assinaturas ativas (padrão: http://i2p-projekt.i 2p/hosts.txt) Adicione as assinaturas recomendadas: http://stats.i 2p/cgi-bin/newhosts.txt http://notbob.i 2p/hosts.txt http://reg.i 2p/export/hosts.txt Clique em \u0026ldquo;Update Now\u0026rdquo; para forçar a atualização imediata das assinaturas Aguarde 5-10 minutos para o processamento Método 3: Use endereços base32 (sempre funciona se o site estiver online):\nCada site .i2p tem um endereço base32: 52 caracteres aleatórios seguidos de .b32.i2p (por exemplo, ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p). Endereços base32 ignoram o livro de endereços - o router realiza uma consulta criptográfica direta.\nErros comuns na configuração do navegador:\nTentando HTTPS em sites somente HTTP: A maioria dos sites .i2p usa apenas HTTP - tentar https://example.i2p falha Esquecendo o prefixo http://: O navegador pode pesquisar em vez de se conectar - sempre use http://example.i2p WebRTC (tecnologia de comunicação em tempo real do navegador) habilitado: Pode vazar o endereço IP real - desative nas configurações do Firefox ou via extensões DNS sem proxy: O DNS da Clearnet (internet pública) não consegue resolver .i2p - é necessário passar as consultas DNS por um proxy Porta do proxy incorreta: 4444 para HTTP (não 4445, que é um outproxy (proxy de saída) HTTPS para a clearnet) Router não totalmente integrado impede o acesso a qualquer site. Verifique se há integração adequada:\nVerifique se http://127.0.0.1:7657 mostra \u0026ldquo;Network: OK\u0026rdquo; ou \u0026ldquo;Network: Firewalled\u0026rdquo; (não \u0026ldquo;Network: Testing\u0026rdquo;) \u0026ldquo;Active peers\u0026rdquo; mostra 10+ no mínimo (50+ ideal) Sem a mensagem \u0026ldquo;Rejecting tunnels: starting up\u0026rdquo; Aguarde de 10 a 15 minutos completos após a inicialização do router antes de esperar acesso a .i2p Configuração de IRC e de cliente de e-mail segue padrões de proxy semelhantes:\nIRC: Clientes conectam-se a 127.0.0.1:6668 (tunnel de proxy IRC do I2P). Desative as configurações de proxy do cliente IRC - a conexão com localhost:6668 já é encaminhada por proxy através do I2P.\nE-mail (Postman): - SMTP: 127.0.0.1:7659 - POP3: 127.0.0.1:7660 - Sem SSL/TLS (criptografia gerenciada pelo I2P tunnel) - Credenciais do registro da conta em postman.i2p\nTodos esses tunnels devem exibir o status \u0026ldquo;running\u0026rdquo; (verde) em http://127.0.0.1:7657/i2ptunnel.\nFalhas de instalação e problemas de pacotes Instalações baseadas em pacotes (Debian, Ubuntu, Arch) ocasionalmente falham devido a alterações no repositório, expiração da chave GPG ou conflitos de dependências. Os repositórios oficiais foram alterados de deb.i2p2.de/deb.i2p2.no (fim de vida) para deb.i2p.net em versões recentes.\nAtualize o repositório do Debian/Ubuntu para a versão atual:\n# Remove old repository entries sudo rm /etc/apt/sources.list.d/i2p.list # Add current repository echo \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/i2p.list # Download and install current signing key curl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg sudo cp i2p-archive-keyring.gpg /usr/share/keyrings/ # Update and install sudo apt update sudo apt install i2p i2p-keyring Falhas na verificação de assinaturas GPG ocorrem quando as chaves do repositório expiram ou são alteradas:\n# Error: \u0026#34;The following signatures were invalid\u0026#34; # Solution: Install current keyring package sudo apt install i2p-keyring # Manual key import if package unavailable wget https://geti2p.net/_static/i2p-debian-repo.key.asc sudo apt-key add i2p-debian-repo.key.asc O serviço não inicia após a instalação do pacote geralmente se deve a problemas nos perfis do AppArmor no Debian/Ubuntu:\n# Check service status sudo systemctl status i2p.service # Common error: \u0026#34;Failed at step APPARMOR spawning\u0026#34; # Solution: Reconfigure without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; for AppArmor when prompted # Alternative: Set profile to complain mode sudo aa-complain /usr/sbin/wrapper # Check logs for specific errors sudo journalctl -xe -u i2p.service Problemas de permissão no I2P instalado via pacote:\n# Fix ownership (package install uses \u0026#39;i2psvc\u0026#39; user) sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p # Set file descriptor limits (add to /etc/security/limits.conf) i2psvc soft nofile 4096 i2psvc hard nofile 8192 Problemas de compatibilidade com Java:\nI2P 2.10.0 requer Java 8 no mínimo. Sistemas mais antigos podem ter Java 7 ou anterior:\n# Check Java version java -version # Install appropriate Java (Debian/Ubuntu) sudo apt install openjdk-11-jre-headless # Set default Java if multiple versions installed sudo update-alternatives --config java Erros de configuração do Wrapper impedem a inicialização do serviço:\nA localização do Wrapper.config varia conforme o método de instalação: - Instalação do usuário: ~/.i2p/wrapper.config - Instalação por pacote: /etc/i2p/wrapper.config ou /var/lib/i2p/wrapper.config\nProblemas comuns no wrapper.config:\nCaminhos incorretos: wrapper.java.command deve apontar para uma instalação válida do Java Memória insuficiente: wrapper.java.maxmemory definido muito baixo (aumente para 512+) Localização incorreta do pidfile: wrapper.pidfile deve ser um local gravável Binário do wrapper ausente: Algumas plataformas não possuem wrapper pré-compilado (use runplain.sh como alternativa) Falhas de atualização e atualizações corrompidas:\nOcasionalmente, as atualizações da console do router falham no meio do download devido a interrupções na rede. Procedimento de atualização manual:\nBaixe i2pupdate_X.X.X.zip de https://geti2p.net/en/download Verifique se o checksum SHA256 corresponde ao hash publicado Copie para o diretório de instalação do I2P como i2pupdate.zip Reinicie o router - detecta e extrai a atualização automaticamente Aguarde 5-10 minutos para a instalação da atualização Verifique a nova versão em http://127.0.0.1:7657 Migração a partir de versões muito antigas (pré-0.9.47) para versões atuais pode falhar devido a chaves de assinatura incompatíveis ou funcionalidades removidas. Atualizações incrementais necessárias:\nVersões anteriores à 0.9.9: Não é possível verificar as assinaturas atuais - é necessária atualização manual Versões com Java 6/7: É necessário atualizar o Java antes de atualizar o I2P para a versão 2.x Grandes saltos de versão: Atualize primeiro para uma versão intermediária (0.9.47 é a recomendada) Quando usar instalador vs pacote:\nPacotes (apt/yum): Melhor para servidores, atualizações automáticas de segurança, integração ao sistema, gerenciamento com o systemd Instalador (.jar): Melhor para instalação no nível do usuário, Windows, macOS, instalações personalizadas, disponibilidade da versão mais recente Corrupção do arquivo de configuração e recuperação A persistência da configuração do I2P depende de vários arquivos críticos. A corrupção geralmente resulta de desligamento inadequado, erros de disco ou erros de edição manual. Compreender a finalidade de cada arquivo permite um reparo cirúrgico em vez de uma reinstalação completa.\nArquivos críticos e suas funções:\nrouter.keys (516+ bytes): Identidade criptográfica do router - perder isso cria uma nova identidade router.info (gerado automaticamente): Informações do router publicadas - é seguro apagar, regenera-se router.config (texto): Configuração principal - largura de banda, configurações de rede, preferências i2ptunnel.config (texto): Definições de tunnel - tunnels cliente/servidor, chaves, destinos netDb/ (diretório): Base de dados de pares - informações do router para participantes da rede peerProfiles/ (diretório): Estatísticas de desempenho dos pares - influencia a seleção de tunnels keyData/ (diretório): Chaves de destino para eepsites e serviços - perder isto altera endereços addressbook/ (diretório): Mapeamentos locais de nomes de host .i2p Procedimento de backup completo antes de qualquer modificação:\n# Stop I2P first i2prouter stop # or: systemctl stop i2p # Backup directory BACKUP_DIR=~/i2p-backup-$(date +%Y%m%d-%H%M) mkdir -p $BACKUP_DIR # Copy critical files cp -r ~/.i2p/router.keys $BACKUP_DIR/ cp -r ~/.i2p/*.config $BACKUP_DIR/ cp -r ~/.i2p/keyData $BACKUP_DIR/ cp -r ~/.i2p/addressbook $BACKUP_DIR/ cp -r ~/.i2p/eepsite $BACKUP_DIR/ # if hosting sites # Optional but recommended tar -czf $BACKUP_DIR.tar.gz $BACKUP_DIR Sintomas de corrupção do Router.config:\nO router não inicia, com erros de análise sintática nos logs As configurações não persistem após a reinicialização Valores padrão inesperados aparecem Caracteres ilegíveis ao visualizar o arquivo Reparar router.config corrompido:\nFaça backup do existente: cp router.config router.config.broken Verifique a codificação do arquivo: Deve ser UTF-8 sem BOM (marca de ordem de bytes) Valide a sintaxe: As chaves usam o separador \u0026lsquo;=\u0026rsquo; (não \u0026lsquo;:\u0026rsquo;), sem espaços à direita nas chaves, \u0026lsquo;#\u0026rsquo; apenas para comentários Problemas comuns de corrupção: caracteres não ASCII nos valores, problemas de final de linha (CRLF vs LF) Se não for possível corrigir: Exclua router.config - o router gera uma configuração padrão, preservando a identidade Configurações essenciais do router.config que devem ser preservadas:\ni2np.bandwidth.inboundKBytesPerSecond=512 i2np.bandwidth.outboundKBytesPerSecond=256 router.updatePolicy=notify routerconsole.lang=en router.hiddenMode=false router.keys perdido ou inválido cria uma nova identidade do router (roteador do I2P). Isso é aceitável, a menos que:\nExecutando floodfill (perde o status de floodfill) Hospedando eepsites com endereço publicado (perde a continuidade) Reputação estabelecida na rede Sem cópia de segurança, não é possível recuperar - crie uma nova: apague router.keys, reinicie o I2P; uma nova identidade será criada.\nDistinção crítica: router.keys (identidade) vs keyData/* (serviços). Perder router.keys altera a identidade do router. Perder keyData/mysite-keys.dat altera o endereço .i2p do seu eepsite - catastrófico se o endereço tiver sido publicado.\nFaça backup das chaves do eepsite/serviço separadamente:\n# Identify your service keys ls -la ~/.i2p/keyData/ # Backup with descriptive names cp ~/.i2p/keyData/myservice-keys.dat ~/backups/myservice-keys-$(date +%Y%m%d).dat # Store securely (encrypted if sensitive) gpg -c ~/backups/myservice-keys-*.dat Corrupção em NetDb e peerProfiles (perfis de pares):\nSintomas: Zero pares ativos, não é possível construir tunnels, \u0026ldquo;Database corruption detected\u0026rdquo; nos logs\nCorreção segura (todos farão reseed (obter novamente os dados iniciais da rede) e reconstruirão automaticamente):\ni2prouter stop rm -rf ~/.i2p/netDb/* rm -rf ~/.i2p/peerProfiles/* i2prouter start # Wait 10-15 minutes for reseed and integration Esses diretórios contêm apenas informações de rede em cache - excluí-los força uma nova inicialização (bootstrap), mas não resulta em perda de dados críticos.\nEstratégias de prevenção:\nSempre desligue corretamente: Use i2prouter stop ou o botão \u0026ldquo;Shutdown\u0026rdquo; do console do router - nunca mate o processo à força Backups automatizados: Tarefa cron de backup semanal de ~/.i2p para um disco separado Monitoramento da integridade do disco: Verifique periodicamente o status SMART - discos com falhas corrompem dados Espaço em disco suficiente: Mantenha 1+ GB livre - discos cheios causam corrupção Nobreak (UPS) recomendado: Falhas de energia durante gravações corrompem arquivos Controle de versão das configurações críticas: Repositório Git para router.config, i2ptunnel.config permite reversão As permissões de arquivo são importantes:\n# Correct permissions (user install) chmod 600 ~/.i2p/router.keys chmod 600 ~/.i2p/*.config chmod 700 ~/.i2p/keyData chmod 755 ~/.i2p # Never run as root - creates permission problems Mensagens de erro comuns decodificadas O sistema de logs do I2P fornece mensagens de erro específicas que localizam exatamente os problemas. Compreender essas mensagens acelera a solução de problemas.\n\u0026ldquo;No tunnels available\u0026rdquo; aparece quando o router ainda não construiu tunnels suficientes para o funcionamento. Isso é normal durante os primeiros 5-10 minutos após a inicialização. Se persistir por mais de 15 minutos:\nVerifique se os pares ativos \u0026gt; 10 em http://127.0.0.1:7657 Verifique se a alocação de largura de banda é adequada (mínimo de 128+ KB/sec) Examine a taxa de sucesso do tunnel em http://127.0.0.1:7657/tunnels (deve ser \u0026gt;40%) Revise os logs para identificar os motivos de rejeição na construção do tunnel \u0026ldquo;Desvio de relógio detectado\u0026rdquo; ou \u0026ldquo;NTCP2 disconnect code 7\u0026rdquo; indicam que a hora do sistema difere do consenso da rede em mais de 90 segundos. O I2P exige precisão de ±60 segundos. Conexões com routers com desvio de horário são rejeitadas automaticamente.\nCorrigir imediatamente:\n# Linux sudo timedatectl set-ntp true sudo systemctl restart systemd-timesyncd date # Verify correct time # Windows # Control Panel → Date and Time → Internet Time → Update now # Verify after sync http://127.0.0.1:7657/logs # Should no longer show clock skew warnings \u0026ldquo;Build timeout\u0026rdquo; ou \u0026ldquo;Tunnel build timeout exceeded\u0026rdquo; significa que a construção do tunnel através da cadeia de pares não foi concluída dentro da janela de tempo limite (geralmente 60 segundos). Causas:\nPares lentos: Router selecionou participantes sem resposta para o tunnel Congestionamento de rede: A rede I2P está enfrentando alta carga Largura de banda insuficiente: Seus limites de largura de banda impedem a construção de tunnel em tempo hábil Router sobrecarregado: Tunnels participantes em excesso consumindo recursos Soluções: aumentar a largura de banda, reduzir os tunnels participantes (router.maxParticipatingTunnels em http://127.0.0.1:7657/configadvanced), ativar o redirecionamento de portas para melhorar a seleção de pares.\n\u0026ldquo;Router is shutting down\u0026rdquo; ou \u0026ldquo;Graceful shutdown in progress\u0026rdquo; aparecem durante o encerramento normal ou a recuperação após uma falha. Um encerramento controlado pode levar até 10 minutos enquanto o router fecha os tunnels, notifica os pares e salva o estado.\nSe ficar preso no estado de encerramento por mais de 11 minutos, force a finalização:\n# Linux kill -9 $(pgrep -f i2p) # Windows taskkill /F /IM javaw.exe \u0026ldquo;java.lang.OutOfMemoryError: Java heap space\u0026rdquo; indica esgotamento do heap (área de memória dinâmica). Soluções imediatas:\nEdite wrapper.config: wrapper.java.maxmemory=512 (ou superior) Encerramento completo obrigatório - reiniciar não aplicará a alteração Aguarde 11 minutos para o encerramento completo Inicie o router do zero Verifique a alocação de memória em http://127.0.0.1:7657/graphs - deve mostrar folga Erros de memória relacionados:\n\u0026ldquo;GC overhead limit exceeded\u0026rdquo;: Gastando tempo excessivo na coleta de lixo - aumente o heap \u0026ldquo;Metaspace\u0026rdquo; (área de metadados da JVM): Espaço de metadados de classes Java esgotado - adicione wrapper.java.additional.X=-XX:MaxMetaspaceSize=256M Específico do Windows: O Kaspersky Antivirus limita o heap (área de memória dinâmica) do Java a 512MB independentemente das configurações do wrapper.config - desinstale-o ou adicione o I2P às exclusões.\n\u0026ldquo;Tempo limite de conexão\u0026rdquo; ou \u0026ldquo;Erro do I2CP - porta 7654\u0026rdquo; quando os aplicativos tentam se conectar ao router:\nVerifique se o router está em execução: http://127.0.0.1:7657 deve responder Verifique a porta I2CP: netstat -an | grep 7654 deve mostrar LISTENING Certifique-se de que o firewall do localhost permite: sudo ufw allow from 127.0.0.1 Verifique se a aplicação está usando a porta correta (I2CP=7654, SAM=7656) \u0026ldquo;Certificate validation failed\u0026rdquo; ou \u0026ldquo;RouterInfo corrupt\u0026rdquo; durante o reseed (processo de obtenção inicial da netDb):\nCausas-raiz: Desvio de relógio (corrigir primeiro), netDb corrompida, certificados de reseed (processo de inicialização da rede) inválidos\n# After fixing clock: i2prouter stop rm -rf ~/.i2p/netDb/* # Delete corrupted database i2prouter start # Auto-reseeds with fresh data \u0026ldquo;Corrupção de banco de dados detectada\u0026rdquo; indica corrupção de dados em nível de disco em netDb ou em peerProfiles:\n# Safe fix - all will rebuild i2prouter stop rm -rf ~/.i2p/netDb/* ~/.i2p/peerProfiles/* i2prouter start Verifique a saúde do disco com ferramentas SMART - corrupção recorrente sugere falha iminente no armazenamento.\nDesafios específicos da plataforma Diferentes sistemas operacionais apresentam desafios específicos de implantação do I2P relacionados a permissões, políticas de segurança e integração com o sistema.\nProblemas de permissões e serviços no Linux O I2P instalado via pacote é executado como o usuário do sistema i2psvc (Debian/Ubuntu) ou i2p (outras distribuições), exigindo permissões específicas:\n# Fix package install permissions sudo chown -R i2psvc:i2psvc /var/lib/i2p /var/log/i2p /run/i2p sudo chmod 750 /var/log/i2p /var/lib/i2p sudo chmod 644 /var/lib/i2p/*.config # User install permissions (should be your user) chown -R $USER:$USER ~/.i2p chmod 700 ~/.i2p chmod 600 ~/.i2p/router.keys ~/.i2p/*.config Limites de descritores de arquivo afetam a capacidade do router para conexões. Os limites padrão (1024) são insuficientes para routers de alta largura de banda:\n# Check current limits ulimit -n # Temporary increase ulimit -n 4096 # Permanent fix: Edit /etc/security/limits.conf i2psvc soft nofile 4096 i2psvc hard nofile 8192 # Systemd override sudo mkdir -p /etc/systemd/system/i2p.service.d/ sudo nano /etc/systemd/system/i2p.service.d/override.conf # Add: [Service] LimitNOFILE=8192 sudo systemctl daemon-reload sudo systemctl restart i2p Conflitos do AppArmor comuns no Debian/Ubuntu impedem a inicialização do serviço:\n# Error: \u0026#34;Failed at step APPARMOR spawning /usr/sbin/wrapper\u0026#34; # Cause: AppArmor profile missing or misconfigured # Solution 1: Disable AppArmor for I2P sudo aa-complain /usr/sbin/wrapper # Solution 2: Reconfigure package without AppArmor sudo dpkg-reconfigure -plow i2p # Select \u0026#34;No\u0026#34; when asked about AppArmor # Solution 3: LXC/Proxmox containers - disable AppArmor in container config lxc.apparmor.profile: unconfined Problemas com o SELinux em RHEL/CentOS/Fedora:\n# Temporary: Set permissive mode sudo setenforce 0 # Permanent: Generate custom policy sudo ausearch -c \u0026#39;java\u0026#39; --raw | audit2allow -M i2p_policy sudo semodule -i i2p_policy.pp # Or disable SELinux for I2P process (less secure) sudo semanage permissive -a i2p_t Solução de problemas de serviços do SystemD:\n# Detailed service status sudo systemctl status i2p.service -l # Full logs sudo journalctl -xe -u i2p.service # Follow logs live sudo journalctl -f -u i2p.service # Restart with logging sudo systemctl restart i2p.service \u0026amp;\u0026amp; sudo journalctl -f -u i2p.service Interferência do Firewall do Windows e de programas antivírus O Windows Defender e produtos antivírus de terceiros frequentemente sinalizam o I2P devido a padrões de comportamento de rede. Uma configuração adequada evita bloqueios desnecessários, mantendo a segurança.\nConfigurar o Firewall do Windows Defender:\n# Run PowerShell as Administrator # Find Java path (adjust for your Java installation) $javaPath = \u0026#34;C:\\Program Files\\Eclipse Adoptium\\jdk-11.0.16.101-hotspot\\bin\\javaw.exe\u0026#34; # Create inbound rules New-NetFirewallRule -DisplayName \u0026#34;I2P Java\u0026#34; -Direction Inbound -Program $javaPath -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P UDP\u0026#34; -Direction Inbound -Protocol UDP -LocalPort 22648 -Action Allow New-NetFirewallRule -DisplayName \u0026#34;I2P TCP\u0026#34; -Direction Inbound -Protocol TCP -LocalPort 22648 -Action Allow # Add exclusions to Windows Defender Add-MpPreference -ExclusionPath \u0026#34;C:\\Program Files\\i2p\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:APPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionPath \u0026#34;$env:LOCALAPPDATA\\I2P\u0026#34; Add-MpPreference -ExclusionProcess \u0026#34;javaw.exe\u0026#34; Substitua a porta 22648 pela sua porta I2P correta indicada em http://127.0.0.1:7657/confignet.\nProblema específico do Kaspersky Antivirus: O \u0026ldquo;Application Control\u0026rdquo; da Kaspersky limita o heap do Java a 512MB, independentemente das configurações do wrapper.config. Isso causa OutOfMemoryError em routers de alta largura de banda.\nSoluções: 1. Adicione o I2P às exclusões do Kaspersky: Configurações → Adicional → Ameaças e Exclusões → Gerenciar Exclusões 2. Ou desinstale o Kaspersky (recomendado para o funcionamento do I2P)\nOrientações gerais para antivírus de terceiros:\nAdicione o diretório de instalação do I2P às exclusões Adicione %APPDATA%\\I2P e %LOCALAPPDATA%\\I2P às exclusões Exclua o javaw.exe da análise comportamental Desative os recursos de \u0026ldquo;Network Attack Protection\u0026rdquo; que possam interferir com os protocolos do I2P Gatekeeper do macOS bloqueando a instalação O Gatekeeper do macOS impede a execução de aplicativos não assinados. Os instaladores do I2P não são assinados com um Apple Developer ID, o que gera alertas de segurança.\nIgnorar o Gatekeeper para o instalador do I2P:\n# Method 1: Remove quarantine attribute xattr -d com.apple.quarantine ~/Downloads/i2pinstall_*.jar java -jar ~/Downloads/i2pinstall_*.jar # Method 2: Use System Settings (macOS 13+) # Try to open installer → macOS blocks it # System Settings → Privacy \u0026amp; Security → scroll down # Click \u0026#34;Open Anyway\u0026#34; next to I2P warning # Confirm in dialog # Method 3: Control-click installer # Control-click (right-click) i2pinstall_*.jar # Select \u0026#34;Open\u0026#34; from menu → \u0026#34;Open\u0026#34; again in dialog # Bypasses Gatekeeper for this specific file Após a instalação, a execução ainda pode gerar avisos:\n# If I2P won\u0026#39;t start due to Gatekeeper: xattr -dr com.apple.quarantine ~/i2p/ Nunca desative permanentemente o Gatekeeper (recurso de segurança do macOS) - risco de segurança para outros aplicativos. Use apenas exceções específicas por arquivo.\nConfiguração do firewall no macOS:\nPreferências do Sistema → Segurança e Privacidade → Firewall → Opções do Firewall Clique em \u0026ldquo;+\u0026rdquo; para adicionar o aplicativo Navegue até a instalação do Java (por exemplo, /Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home/bin/java) Adicione e defina como \u0026ldquo;Permitir conexões de entrada\u0026rdquo; Problemas do aplicativo I2P para Android As restrições de versão do Android e as limitações de recursos criam desafios únicos.\nRequisitos mínimos: - Android 5.0+ (nível de API 21+) obrigatório para as versões atuais - 512 MB de RAM no mínimo, 1 GB+ recomendado - 100 MB de armazenamento para o aplicativo + dados do router - Restrições de aplicativos em segundo plano desativadas para o I2P\nO aplicativo falha imediatamente:\nVerifique a versão do Android: Configurações → Sobre o telefone → Versão do Android (deve ser 5.0+) Desinstale todas as versões do I2P: Instale apenas uma variante: net.i2p.android (Google Play) net.i2p.android.router (F-Droid)\nInstalações múltiplas entram em conflito Limpe os dados do app: Configurações → Apps → I2P → Armazenamento → Limpar dados Reinstale a partir de um estado limpo Otimização de bateria encerrando o router:\nO Android encerra agressivamente aplicativos em segundo plano para economizar bateria. O I2P precisa ser excluído:\nConfigurações → Bateria → Otimização da bateria (ou Uso da bateria do app) Localize I2P → Não otimizar (ou Permitir atividade em segundo plano) Configurações → Apps → I2P → Bateria → Permitir atividade em segundo plano + Remover restrições Problemas de conexão em dispositivos móveis:\nBootstrap (inicialização) requer WiFi: O processo de reseed inicial (obtenção inicial de pares) baixa uma quantidade significativa de dados - use WiFi, não dados móveis Mudanças na rede: O I2P não lida bem com trocas de rede - reinicie o aplicativo após uma transição WiFi/celular Largura de banda para dispositivos móveis: Configure de forma conservadora em 64-128 KB/sec para evitar o esgotamento dos dados móveis Otimização de desempenho para dispositivos móveis:\nApp I2P → Menu → Configurações → Largura de banda Defina limites apropriados: 64 KB/sec de entrada, 32 KB/sec de saída para dados móveis Reduza os tunnels participantes: Configurações → Avançado → Máximo de tunnels participantes: 100-200 Ative \u0026ldquo;Parar o I2P quando a tela estiver desligada\u0026rdquo; para economizar bateria Uso de torrents no Android:\nLimite para no máximo 2-3 torrents simultâneos Reduza a agressividade do DHT Use apenas WiFi para transferências por torrent Aceite velocidades mais baixas em hardware móvel Problemas de reseed e bootstrap Novas instalações do I2P exigem reseeding (processo inicial de obtenção de pares) - buscar informações iniciais de pares em servidores HTTPS públicos para ingressar na rede. Problemas de reseeding deixam os usuários com zero pares e sem acesso à rede.\n\u0026ldquo;No active peers\u0026rdquo; após uma instalação limpa normalmente indica falha no reseed (processo de obtenção inicial de pares). Sintomas:\nPares conhecidos: 0 ou fica abaixo de 5 \u0026ldquo;Network: Testing\u0026rdquo; permanece por mais de 15 minutos Os logs mostram \u0026ldquo;Reseed failed\u0026rdquo; ou erros de conexão com servidores de reseed Por que o reseed (processo inicial de obtenção de pares) falha:\nFirewall bloqueando HTTPS: Firewalls corporativos/ISPs bloqueiam conexões aos reseed servers (servidores de inicialização da rede) (porta 443) Erros de certificado SSL: O sistema não possui certificados raiz atualizados Requisito de proxy: A rede exige um proxy HTTP/SOCKS para conexões externas Desvio de relógio: A validação do certificado SSL falha quando o horário do sistema está errado Censura geográfica: Alguns países/ISPs bloqueiam reseed servers conhecidos Forçar reseed manual (carregamento inicial da rede):\nAcesse http://127.0.0.1:7657/configreseed Clique em \u0026ldquo;Save changes and reseed now\u0026rdquo; Monitore http://127.0.0.1:7657/logs em busca de \u0026ldquo;Reseed got XX router infos\u0026rdquo; Aguarde 5-10 minutos para o processamento Verifique http://127.0.0.1:7657 - os pares conhecidos devem aumentar para 50+ Configurar proxy de reseed para redes restritivas:\nhttp://127.0.0.1:7657/configreseed → Configuração do proxy:\nProxy HTTP: [proxy-server]:[port] Ou SOCKS5: [socks-server]:[port] Ative \u0026ldquo;Usar proxy apenas para reseed (processo de inicialização/bootstrapping da rede)\u0026rdquo; Credenciais, se necessário Salve e force o reseed Alternativa: proxy do Tor para reseed (processo de inicialização da netDb):\nSe o Tor Browser ou o daemon do Tor estiver em execução:\nTipo de proxy: SOCKS5 Host: 127.0.0.1 Porta: 9050 (porta SOCKS padrão do Tor) Ativar e reseed (obter novamente os pares iniciais da rede) Reseed manual (processo de obtenção de pares iniciais) via arquivo su3 (último recurso):\nQuando todas as tentativas de reseed (obtenção inicial de entradas do netDb) automatizado falharem, obtenha o arquivo de reseed por um canal fora de banda:\nBaixe i2pseeds.su3 de uma fonte confiável em uma conexão sem restrições (https://reseed.i2p.rocks/i2pseeds.su3 , https://reseed-fr.i2pd.xyz/i2pseeds.su3 ) Encerre o I2P completamente Copie i2pseeds.su3 para o diretório ~/.i2p/ Inicie o I2P - extrai e processa o arquivo automaticamente Exclua i2pseeds.su3 após o processamento Verifique se o número de pares aumenta em http://127.0.0.1:7657 Erros de certificado SSL durante o reseed (processo inicial de obtenção de pares do netDb):\nError: \u0026#34;Reseed: Certificate verification failed\u0026#34; Cause: System root certificates outdated or missing Soluções:\n# Linux - update certificates sudo apt install ca-certificates sudo update-ca-certificates # Windows - install KB updates for root certificate trust # Or install .NET Framework (includes certificate updates) # macOS - update system # Software Update includes certificate trust updates Travado em 0 pares conhecidos por mais de 30 minutos:\nIndica falha completa de reseed (processo de obtenção inicial de pares). Procedimento de solução de problemas:\nVerifique se a data e hora do sistema estão corretas (problema mais comum - corrija PRIMEIRO) Teste a conectividade HTTPS: Tente acessar https://reseed.i2p.rocks no navegador - se falhar, é um problema de rede Verifique os logs do I2P em http://127.0.0.1:7657/logs para erros específicos de reseed (bootstrap inicial da rede do I2P) Tente uma URL de reseed diferente: http://127.0.0.1:7657/configreseed → adicione uma URL de reseed personalizada: https://reseed-fr.i2pd.xyz/ Use o método manual com arquivo su3 se as tentativas automatizadas estiverem esgotadas Reseed servers ocasionalmente fora do ar (servidores que fornecem os pares iniciais): I2P inclui vários reseed servers pré-configurados no código. Se um falhar, o router tenta outros automaticamente. A falha completa de todos os reseed servers é extremamente rara, mas possível.\nreseed servers (servidores de inicialização da rede) ativos no momento (em outubro de 2025):\nhttps://reseed.i2p.rocks/ https://reseed-fr.i2pd.xyz/ https://i2p.novg.net/ https://i2p-projekt.de/ Adicione como URLs personalizadas se tiver problemas com os valores padrão.\nPara usuários em regiões fortemente censuradas:\nConsidere usar as pontes Snowflake/Meek através do Tor para o reseed inicial (processo de obtenção inicial de pares e endereços da rede), e depois alternar para acesso direto ao I2P assim que estiver integrado à rede. Ou obtenha i2pseeds.su3 por meio de esteganografia, e-mail ou USB de fora da zona de censura.\nQuando procurar ajuda adicional Este guia abrange a vasta maioria dos problemas do I2P, mas alguns exigem a atenção de desenvolvedores ou o conhecimento especializado da comunidade.\nProcure ajuda da comunidade I2P quando:\nO router trava repetidamente após seguir todas as etapas de solução de problemas Vazamentos de memória provocando crescimento contínuo além do heap (área de memória dinâmica) alocado A taxa de sucesso do tunnel permanece abaixo de 20% apesar de uma configuração adequada Novos erros nos logs não cobertos por este guia Vulnerabilidades de segurança descobertas Solicitações de funcionalidades ou sugestões de melhoria Antes de solicitar ajuda, reúna informações de diagnóstico:\nVersão do I2P: http://127.0.0.1:7657 (por exemplo, \u0026ldquo;2.10.0\u0026rdquo;) Versão do Java: saída de java -version Sistema operacional e versão Status do router: estado da rede, contagem de pares ativos, tunnels participantes Configuração de largura de banda: limites de entrada/saída Status do encaminhamento de portas: bloqueado por firewall ou OK Trechos relevantes do log: últimas 50 linhas mostrando erros de http://127.0.0.1:7657/logs Canais oficiais de suporte:\nFórum: https://i2pforum.net (clearnet) ou http://i2pforum.i 2p (dentro do I2P) IRC: #i2p em Irc2P (irc.postman.i2p via I2P) ou irc.freenode.net (clearnet) Reddit: https://reddit.com/r/i2p para discussões da comunidade Rastreador de bugs: https://i2pgit.org/i2p-hackers/i2p.i2p/-/issues para bugs confirmados Lista de discussão: i2p-dev@lists.i2p-projekt.de para perguntas sobre desenvolvimento Expectativas realistas importam. I2P é mais lento do que a clearnet (internet aberta) por design fundamental - o tunneling (encapsulamento em túnel) criptografado de múltiplos saltos cria latência inerente. Um router I2P funcionando com carregamentos de página de 30 segundos e velocidades de torrent de 50 KB/sec está funcionando corretamente, não está com defeito. Usuários que esperam velocidades de clearnet ficarão desapontados independentemente da otimização da configuração.\nConclusão A maioria dos problemas no I2P decorre de três categorias: paciência insuficiente durante o bootstrap (processo de inicialização; requer 10-15 minutos), alocação de recursos inadequada (mínimo de 512 MB de RAM, 256 KB/sec de largura de banda) ou redirecionamento de portas mal configurado. Compreender a arquitetura distribuída do I2P e o design voltado ao anonimato ajuda os usuários a distinguir o comportamento esperado de problemas reais.\nO status \u0026ldquo;Firewalled\u0026rdquo; do router, embora não seja o ideal, não impede o uso do I2P — apenas limita a contribuição para a rede e degrada ligeiramente o desempenho. Novos usuários devem priorizar a estabilidade em vez da otimização: execute o router continuamente por vários dias antes de ajustar configurações avançadas, pois a integração melhora naturalmente com o tempo de atividade.\nAo solucionar problemas, verifique primeiro o básico: hora correta do sistema, largura de banda adequada, router em execução contínua e 10 ou mais pares ativos. A maioria dos problemas se resolve ao tratar desses fundamentos, em vez de ajustar parâmetros de configuração obscuros. O I2P recompensa a paciência e a operação contínua com desempenho aprimorado, à medida que o router constrói reputação e otimiza a seleção de pares ao longo de dias e semanas de tempo de atividade.\n","description":"Guia abrangente de solução de problemas para problemas comuns do I2P router, incluindo problemas de conectividade, desempenho e configuração","id":"2ff67fee0173608876ccc012bf3ff6ce","section":"docs","title":"Guia de Solução de Problemas do I2P Router","url":"/pt/docs/troubleshooting/"},{"categories":null,"content":"Então você quer começar a trabalhar no I2P? Ótimo! Aqui está um guia rápido para começar a contribuir com o site ou o software, fazer desenvolvimento ou criar traduções.\nAinda não está pronto para programar? Tente envolver-se primeiro.\nConheça Java O router I2P e suas aplicações integradas usam Java como linguagem principal de desenvolvimento. Se você não tem experiência com Java, pode sempre consultar Thinking in Java Estude a introdução \u0026ldquo;como\u0026rdquo;, outros documentos \u0026ldquo;como\u0026rdquo;, a introdução técnica e documentos associados:\nComo introdução: Introdução ao I2P Central de documentação: Documentação Introdução técnica: Introdução Técnica Estes recursos fornecerão uma boa visão geral de como o I2P é estruturado e das diferentes funcionalidades que ele oferece.\nObtendo o Código do I2P Para desenvolvimento no router I2P ou nas aplicações incorporadas, você precisa obter o código-fonte.\nNossa forma atual: Git I2P tem serviços Git oficiais e aceita contribuições via Git em nosso próprio GitLab:\nDentro do I2P: http://git.idk.i2p Fora do I2P: https://i2pgit.org Clone o repositório principal:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git Um espelho somente leitura também está disponível no GitHub:\nEspelho no GitHub: github.com/i2p/i2p.i2p git clone https://github.com/i2p/i2p.i2p.git Compilando I2P Para compilar o código, você precisa do Sun/Oracle Java Development Kit 6 ou superior, ou JDK equivalente (Sun/Oracle JDK 6 fortemente recomendado) e Apache Ant versão 1.7.0 ou superior. Se você estiver trabalhando no código principal do I2P, entre no diretório i2p.i2p e execute ant para ver as opções de compilação.\nPara compilar ou trabalhar em traduções do console, você precisa das ferramentas xgettext, msgfmt e msgmerge do pacote GNU gettext.\nPara o desenvolvimento de novas aplicações, consulte o guia de desenvolvimento de aplicações .\nIdeias de Desenvolvimento Veja a lista TODO do projeto ou a lista de issues no GitLab para ideias:\nProblemas do GitLab: i2pgit.org/I2P_Developers/i2p.i2p/issues Disponibilizando os Resultados Veja o final da página de licenças para os requisitos de privilégio de commit. Você precisa destes para colocar código no i2p.i2p (não é necessário para o site!).\nPágina de licenças Conheça-nos! Os desenvolvedores estão disponíveis no IRC. Eles podem ser contactados em várias redes e nas redes internas do I2P. O local habitual é o #i2p-dev. Entre no canal e diga olá! Também temos diretrizes adicionais para desenvolvedores regulares .\nTraduções Tradutores do site e do console do roteador: Consulte o Guia para Novos Tradutores para os próximos passos.\nFerramentas I2P é um software de código aberto que é desenvolvido principalmente usando ferramentas de código aberto. O projeto I2P adquiriu recentemente uma licença para o YourKit Java Profiler. Projetos de código aberto são elegíveis para receber uma licença gratuita desde que o YourKit seja referenciado no site do projeto. Entre em contato se você estiver interessado em fazer profiling da base de código do I2P.\nA YourKit está gentilmente apoiando projetos de código aberto com seus profilers completos. YourKit, LLC é a criadora de ferramentas inovadoras e inteligentes para criação de perfis de aplicações Java e .NET. Dê uma olhada nos produtos de software líderes da YourKit:\nYourKit Java Profiler YourKit .NET Profiler ","description":"Como começar a contribuir para o I2P: materiais de estudo, código-fonte, compilação, ideias, publicação, comunidade, traduções e ferramentas","id":"e74ff72be9767cc925c6712e11e5e1c5","section":"docs","title":"Guia do Novo Desenvolvedor","url":"/pt/docs/develop/new-developers/"},{"categories":null,"content":"Quer ajudar a tornar o I2P acessível a mais pessoas ao redor do mundo? A tradução é uma das contribuições mais valiosas que você pode fazer ao projeto. Este guia irá orientá-lo na tradução do console do router.\nMétodos de Tradução Existem duas maneiras de contribuir com traduções:\nMétodo 1: Transifex (Recomendado) Esta é a forma mais fácil de traduzir o I2P. O Transifex fornece uma interface baseada na web que torna a tradução simples e acessível.\nInscreva-se em Transifex Solicite participação na equipe de tradução do I2P Comece a traduzir diretamente no seu navegador Nenhum conhecimento técnico necessário - basta se inscrever e começar a traduzir!\nMétodo 2: Tradução Manual Para tradutores que preferem trabalhar com git e arquivos locais, ou para idiomas ainda não configurados no Transifex.\nRequisitos: - Familiaridade com controle de versão git - Editor de texto ou ferramenta de tradução (POEdit recomendado) - Ferramentas de linha de comando: git, gettext\nConfiguração: 1. Entre no #i2p-dev no IRC e apresente-se 2. Atualize o status da tradução na wiki (peça acesso no IRC) 3. Clone o repositório apropriado (veja as seções abaixo)\nTradução do Console do Router O console do router é a interface web que você vê ao executar o I2P. Traduzi-lo ajuda usuários que não se sentem confortáveis com inglês.\nUsando o Transifex (Recomendado) Acesse I2P no Transifex Selecione o projeto do router console Escolha seu idioma Comece a traduzir Tradução Manual do Console do Roteador Pré-requisitos: - Iguais aos da tradução de website (git, gettext) - Chave GPG (para acesso de commit) - Acordo de desenvolvedor assinado\nClone o repositório principal do I2P:\ngit clone https://i2pgit.org/I2P_Developers/i2p.i2p.git cd i2p.i2p Arquivos para traduzir:\nO console do roteador tem aproximadamente 15 arquivos que precisam de tradução:\nArquivos de interface principais:\napps/routerconsole/locale/messages_*.po - Mensagens principais do console apps/routerconsole/locale-news/messages_*.po - Mensagens de notícias Arquivos de proxy:\napps/i2ptunnel/locale/messages_*.po - Interface de configuração de tunnel Locales de aplicação:\napps/susidns/locale/messages_*.po - Interface do catálogo de endereços apps/susimail/locale/messages_*.po - Interface de e-mail Outros diretórios de locales específicos de aplicações Arquivos de documentação:\ninstaller/resources/readme/readme_*.html - Leia-me da instalação Arquivos de ajuda em vários aplicativos Fluxo de trabalho de tradução:\n# Update .po files from source ant extractMessages # Edit .po files with POEdit or text editor poedit apps/routerconsole/locale/messages_es.po # Build and test ant updaters # Install the update and check translations in the console Envie seu trabalho: - Crie uma solicitação de mesclagem no GitLab - Ou compartilhe arquivos com a equipe de desenvolvimento no IRC\nFerramentas de Tradução POEdit (Altamente Recomendado) POEdit é um editor especializado para arquivos de tradução .po.\nRecursos: - Interface visual para trabalho de tradução - Mostra o contexto da tradução - Validação automática - Disponível para Windows, macOS e Linux\nEditores de Texto Você também pode usar qualquer editor de texto: - VS Code (com extensões i18n) - Sublime Text - vim/emacs (para usuários de terminal)\nVerificações de Qualidade Antes de submeter: 1. Verifique a formatação: Certifique-se de que os marcadores como %s e {0} permanecem inalterados 2. Teste suas traduções: Instale e execute o I2P para ver como ficam 3. Consistência: Mantenha a terminologia consistente entre os arquivos 4. Comprimento: Algumas strings têm restrições de espaço na interface\nDicas para Tradutores Diretrizes Gerais Mantenha a consistência: Use as mesmas traduções para termos comuns em todo o documento Preserve a formatação: Mantenha tags HTML, marcadores de posição (%s, {0}) e quebras de linha O contexto importa: Leia o texto original em inglês cuidadosamente para entender o contexto Faça perguntas: Use IRC ou fóruns se algo não estiver claro Termos Comuns do I2P Alguns termos devem permanecer em inglês ou ser transliterados cuidadosamente:\nI2P - Keep as is eepsite - Site I2P (website na rede I2P) tunnel - Caminho de conexão (evite terminologia do Tor como \u0026ldquo;circuito\u0026rdquo;) netDb - Base de dados da rede floodfill - Tipo de router destination - Ponto final de endereço I2P Testando Suas Traduções Compile o I2P com suas traduções Altere o idioma nas configurações do console do router Navegue por todas as páginas para verificar: O texto se ajusta aos elementos da interface Não há caracteres ilegíveis (problemas de codificação) As traduções fazem sentido no contexto Perguntas Frequentes Por que o processo de tradução é tão complexo? O processo usa controle de versão (git) e ferramentas de tradução padrão (arquivos .po) porque:\nResponsabilidade: Rastrear quem alterou o quê e quando Qualidade: Revisar alterações antes de entrarem em produção Consistência: Manter formatação e estrutura adequadas dos arquivos Escalabilidade: Gerenciar traduções em vários idiomas de forma eficiente Colaboração: Vários tradutores podem trabalhar no mesmo idioma Preciso de habilidades de programação? Não! Se você usar o Transifex, você só precisa de: - Fluência em inglês e no seu idioma de destino - Um navegador web - Habilidades básicas de informática\nPara tradução manual, você precisará de conhecimento básico de linha de comando, mas nenhuma programação é necessária.\nQuanto tempo leva? Console do roteador: Aproximadamente 15-20 horas para todos os arquivos Manutenção: Algumas horas por mês para atualizar novas strings Várias pessoas podem trabalhar em um idioma? Sim! A coordenação é fundamental: - Use o Transifex para coordenação automática - Para trabalho manual, comunique-se no canal IRC #i2p-dev - Divida o trabalho por seções ou arquivos\nE se meu idioma não estiver listado? Solicite no Transifex ou entre em contato com a equipe no IRC. A equipe de desenvolvimento pode configurar um novo idioma rapidamente.\nComo posso testar minhas traduções antes de enviar? Compilar I2P a partir do código-fonte com suas traduções Instalar e executar localmente Alterar idioma nas configurações do console Obtendo Ajuda Suporte IRC Junte-se ao #i2p-dev no IRC para: - Ajuda técnica com ferramentas de tradução - Perguntas sobre terminologia do I2P - Coordenação com outros tradutores - Suporte direto dos desenvolvedores\nFóruns Discussões sobre tradução nos Fóruns I2P Inside I2P: fórum de Tradução em zzz.i2p (requer router I2P) Documentação Documentação do Transifex Documentação do POEdit Manual do gettext Reconhecimento Todos os tradutores são creditados em: - O console do router I2P (página Sobre) - Página de créditos do site - Histórico de commits do Git - Anúncios de lançamento\nO seu trabalho ajuda diretamente pessoas ao redor do mundo a usar o I2P de forma segura e privada. Obrigado por contribuir!\nPróximos Passos Pronto para começar a traduzir?\nEscolha seu método:\nInício rápido: Inscreva-se no Transifex Abordagem manual: Participe do #i2p-dev no IRC Comece aos poucos: Traduza algumas strings para se familiarizar com o processo\nPeça ajuda: Não hesite em entrar em contato no IRC ou nos fóruns\nObrigado por ajudar a tornar o I2P acessível a todos!\n","description":"Como contribuir com traduções para o site I2P e console do router usando Transifex ou métodos manuais","id":"a436f7ab16669c43b076458496d70009","section":"docs","title":"Guia para Novos Tradutores","url":"/pt/docs/develop/new-translators/"},{"categories":null,"content":"Sobre os hosts de reseed Novos routers precisam de um pequeno número de pares para entrar na rede I2P. Os hosts de reseed (reseed: processo de obter um conjunto inicial de pares para iniciar ou recuperar a participação na rede) fornecem esse conjunto inicial por meio de downloads HTTPS criptografados. Cada pacote de reseed é assinado pelo host, evitando adulterações por partes não autenticadas. Routers já estabelecidos podem, ocasionalmente, fazer reseed se seu conjunto de pares ficar desatualizado.\nProcesso de Inicialização da Rede Quando um router I2P é iniciado pela primeira vez ou fica offline por um período prolongado, ele precisa de dados RouterInfo para se conectar à rede. Como o router não tem pares existentes, ele não pode obter essas informações a partir da própria rede I2P. O mecanismo de reseed (mecanismo de inicialização) resolve esse problema de inicialização ao fornecer arquivos RouterInfo provenientes de servidores HTTPS externos confiáveis.\nO processo de reseed (inicialização da rede) entrega de 75 a 100 arquivos RouterInfo em um único pacote assinado criptograficamente. Isso garante que novos routers possam estabelecer conexões rapidamente sem expô-los a ataques man-in-the-middle que poderiam isolá-los em partições de rede separadas e não confiáveis.\nEstado atual da rede Em outubro de 2025, a rede I2P opera com a versão 2.10.0 do router (versão da API 0.9.67). O protocolo de reseed (processo de obtenção inicial de pares) introduzido na versão 0.9.14 permanece estável e inalterado em sua funcionalidade central. A rede mantém múltiplos servidores de reseed independentes distribuídos globalmente para garantir disponibilidade e resistência à censura.\nO serviço checki2p monitora todos os servidores de reseed do I2P a cada 4 horas, fornecendo verificações de status em tempo real e métricas de disponibilidade para a infraestrutura de reseed.\nEspecificação do Formato de Arquivo SU3 O formato de arquivo SU3 é a base do protocolo de reseed (inicialização de pares da rede) do I2P, proporcionando entrega de conteúdo assinada criptograficamente. Compreender este formato é essencial para implementar servidores e clientes de reseed.\nEstrutura de arquivos O formato SU3 consiste em três componentes principais: cabeçalho (40+ bytes), conteúdo (tamanho variável) e assinatura (tamanho especificado no cabeçalho).\nFormato do cabeçalho (mínimo: Bytes 0-39) Byte Range Field Description 0-5Magic NumberASCII string \"I2Psu3\" (0x493250737533) 6ReservedUnused, must be 0x00 7File Format VersionCurrent version: 0x00 8-9Signature TypeBig-endian 16-bit integer. Type 6 = RSA-4096-SHA512 (reseed standard) 10-11Signature LengthBig-endian 16-bit integer. 512 bytes (0x0200) for RSA-4096 12ReservedUnused, must be 0x00 13Version LengthMinimum 16 bytes (0x10) for compatibility 14ReservedUnused, must be 0x00 15Signer ID LengthLength of UTF-8 signer identifier string 16-23Content LengthBig-endian 64-bit integer, length of content in bytes 24ReservedUnused, must be 0x00 25File Type0x00 = ZIP, 0x01 = XML, 0x02 = HTML, 0x03 = XML.GZ, 0x04 = TXT.GZ, 0x05 = DMG, 0x06 = EXE 26ReservedUnused, must be 0x00 27Content Type0x00 = unknown, 0x01 = router update, 0x02 = plugin, 0x03 = reseed, 0x04 = news, 0x05 = blocklist 28-39PaddingUnused, must be all zeros 40-55Version StringASCII version string, padded with zeros (minimum 16 bytes) 56-...Signer IDUTF-8 encoded signer identifier (e.g., \"user@mail.i2p\") ### Parâmetros SU3 Específicos de Reseed Para pacotes de reseed (inicialização/obtenção inicial de pares), o arquivo SU3 deve ter as seguintes características:\nNome do arquivo: Deve ser exatamente i2pseeds.su3 Tipo de Conteúdo (byte 27): 0x03 (RESEED) Tipo de Arquivo (byte 25): 0x00 (ZIP) Tipo de Assinatura (bytes 8-9): 0x0006 (RSA-4096-SHA512) String de Versão: Carimbo de data/hora Unix em ASCII (segundos desde a época, formato date +%s) ID do Signatário: Identificador no estilo de e-mail correspondente ao CN do certificado X.509 Parâmetro de consulta do ID da rede Desde a versão 0.9.42, routers acrescentam ?netid=2 às solicitações de reseed (processo de inicialização/obtenção inicial de pares). Isso impede conexões entre redes, pois redes de teste usam IDs de rede diferentes. A rede de produção atual do I2P usa o ID de rede 2.\nExemplo de solicitação: https://reseed.example.com/i2pseeds.su3?netid=2\nEstrutura do conteúdo do ZIP A seção de conteúdo (após o cabeçalho, antes da assinatura) contém um arquivo ZIP padrão com os seguintes requisitos:\nCompressão: Compressão ZIP padrão (DEFLATE) Contagem de arquivos: Normalmente 75-100 arquivos RouterInfo (informações do router) Estrutura de diretórios: Todos os arquivos devem estar no nível superior (sem subdiretórios) Nomenclatura de arquivos: routerInfo-{44-character-base64-hash}.dat Alfabeto Base64: Deve usar o alfabeto base64 modificado do I2P O alfabeto base64 do I2P difere do base64 padrão ao usar - e ~ em vez de + e / para garantir compatibilidade com sistemas de arquivos e URLs.\nAssinatura criptográfica A assinatura abrange o arquivo inteiro, do byte 0 até o final da seção de conteúdo. A própria assinatura é anexada após o conteúdo.\nAlgoritmo de Assinatura (RSA-4096-SHA512) Calcule o hash SHA-512 dos bytes 0 até o final do conteúdo Assine o hash usando RSA \u0026ldquo;raw\u0026rdquo; (NONEwithRSA na terminologia do Java) Preencha a assinatura com zeros à esquerda, se necessário, até atingir 512 bytes Anexe a assinatura de 512 bytes ao arquivo Processo de Verificação de Assinatura Os clientes devem:\nLer os bytes 0-11 para determinar o tipo e o tamanho da assinatura Ler todo o cabeçalho para localizar os limites do conteúdo Fazer streaming do conteúdo enquanto calcula o hash SHA-512 Extrair a assinatura do final do arquivo Verificar a assinatura usando a chave pública RSA-4096 do signatário Rejeitar o arquivo se a verificação da assinatura falhar Modelo de Confiança de Certificados As chaves de assinatura de reseed (processo de bootstrap para obter peers iniciais) são distribuídas na forma de certificados X.509 autoassinados com chaves RSA-4096. Esses certificados estão incluídos nos pacotes do router I2P no diretório certificates/reseed/.\nFormato do certificado: - Tipo de chave: RSA-4096 - Assinatura: autossinada - CN do Sujeito: Deve corresponder ao ID do signatário no cabeçalho SU3 - Datas de validade: Os clientes devem respeitar os períodos de validade do certificado\nOperando um servidor Reseed (servidor de bootstrap da rede I2P) Operar um serviço de reseed (processo de bootstrap para novos routers) exige atenção cuidadosa à segurança, confiabilidade e requisitos de diversidade da rede. Mais hosts de reseed independentes aumentam a resiliência e dificultam que atacantes ou censores bloqueiem a entrada de novos routers.\nRequisitos técnicos Especificações do Servidor Sistema Operacional: Unix/Linux (Ubuntu, Debian, FreeBSD testados e recomendados) Conectividade: Endereço IPv4 estático obrigatório, IPv6 recomendado mas opcional CPU: No mínimo 2 núcleos RAM: No mínimo 2 GB Largura de banda: Aproximadamente 15 GB por mês Tempo de atividade: Operação 24/7 requerida I2P Router: I2P router bem integrado em execução contínua Requisitos de Software Java: JDK 8 ou posterior (Java 17+ será obrigatório a partir do I2P 2.11.0) Servidor Web: nginx ou Apache com suporte a proxy reverso (Lighttpd não é mais suportado devido a limitações do cabeçalho X-Forwarded-For) TLS/SSL: Certificado TLS válido (Let\u0026rsquo;s Encrypt, autoassinado ou autoridade certificadora comercial) Proteção contra DDoS: fail2ban ou equivalente (obrigatório, não opcional) Ferramentas de Reseed (processo de bootstrap da rede): reseed-tools oficiais de https://i2pgit.org/idk/reseed-tools Requisitos de Segurança Configuração de HTTPS/TLS Protocolo: Somente HTTPS, sem fallback para HTTP Versão do TLS: No mínimo TLS 1.2 Suítes de cifras: Devem suportar cifras fortes compatíveis com Java 8+ CN/SAN do certificado: Deve corresponder ao nome do host da URL servida Tipo de certificado: Pode ser autoassinado se comunicado à equipe de desenvolvimento, ou emitido por uma autoridade certificadora reconhecida (CA) Gerenciamento de Certificados Certificados de assinatura SU3 e certificados TLS têm finalidades diferentes:\nCertificado TLS (certificates/ssl/): Protege o transporte HTTPS Certificado de Assinatura SU3 (certificates/reseed/): Assina pacotes de reseed Ambos os certificados devem ser fornecidos ao reseed coordinator (zzz@mail.i2p ) (coordenador do processo de inicialização da rede) para inclusão nos pacotes do router.\nProteção contra DDoS e raspagem de dados Servidores Reseed (servidores de provisionamento inicial) enfrentam ataques periódicos provenientes de implementações com bugs, botnets e atores maliciosos que tentam raspar o netDb (banco de dados da rede). As medidas de proteção incluem:\nfail2ban: Necessário para limitação de taxa e mitigação de ataques Diversidade de Conjuntos: Entregar conjuntos diferentes de RouterInfo a solicitantes diferentes Consistência do Conjunto: Entregar o mesmo conjunto para solicitações repetidas do mesmo IP dentro de uma janela de tempo configurável Restrições de registro de IP: Não divulgar logs ou endereços IP (requisito da política de privacidade) Métodos de Implementação Método 1: reseed-tools oficial (Recomendado) A implementação canônica mantida pelo projeto I2P. Repositório: https://i2pgit.org/idk/reseed-tools Instalação:\n# Install dependencies sudo apt-get install golang git # Clone repository git clone https://i2pgit.org/idk/reseed-tools.git cd reseed-tools # Build make # Generate keys and start server (first run) ./reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/path/to/i2p/netDb \\ --tlsHost=your-domain.tld \\ --port=8443 Na primeira execução, a ferramenta gerará: - your-email@mail.i2p.crt (certificado de assinatura SU3) - your-email@mail.i2p.pem (chave privada de assinatura SU3) - your-email@mail.i2p.crl (lista de revogação de certificados) - arquivos de certificado e chave TLS\nRecursos: - Geração automática de pacotes SU3 (350 variações, 77 RouterInfos (objetos de informação do router) cada) - Servidor HTTPS integrado - Reconstrói o cache a cada 9 horas via cron - Suporte ao cabeçalho X-Forwarded-For com a flag --trustProxy - Compatível com configurações de proxy reverso\nImplantação em Produção:\n# Create systemd service cat \u0026gt; /etc/systemd/system/i2p-reseed.service \u0026lt;\u0026lt; EOF [Unit] Description=I2P Reseed Server After=network.target [Service] Type=simple User=i2p-reseed WorkingDirectory=/opt/i2p-reseed ExecStart=/opt/i2p-reseed/reseed-tools reseed \\ --signer=your-email@mail.i2p \\ --netdb=/var/lib/i2p/netDb \\ --port=8443 \\ --ip=127.0.0.1 \\ --trustProxy Restart=always [Install] WantedBy=multi-user.target EOF systemctl enable i2p-reseed systemctl start i2p-reseed Método 2: Implementação em Python (pyseeder) Implementação alternativa do projeto PurpleI2P: https://github.com/PurpleI2P/pyseeder pip install pyseeder # Generate SU3 file echo \u0026#34;your_password\u0026#34; | pyseeder reseed \\ --netdb /path/to/netDb \\ --private-key priv_key.pem \\ --outfile i2pseeds.su3 \\ --signer-id user@mail.i2p # Serve via built-in server pyseeder serve \\ --port 8443 \\ --host 0.0.0.0 \\ --private-key priv_key.pem \\ --cert user_at_mail.i2p.crt \\ --file i2pseeds.su3 Método 3: Implantação com Docker Para ambientes em contêineres, existem várias implementações prontas para Docker:\nDivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd/i2p-tools-1: Adiciona serviço onion do Tor e suporte a IPFS Configuração de proxy reverso Configuração do nginx upstream i2p_reseed { server 127.0.0.1:8443; } server { listen 443 ssl http2; server_name reseed.example.com; ssl_certificate /path/to/tls-cert.crt; ssl_certificate_key /path/to/tls-key.key; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / { proxy_pass http://i2p_reseed; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; } } Configuração do Apache \u0026lt;VirtualHost *:443\u0026gt; ServerName reseed.example.com SSLEngine on SSLCertificateFile /path/to/tls-cert.crt SSLCertificateKeyFile /path/to/tls-key.key SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 ProxyRequests Off \u0026lt;Proxy *\u0026gt; Order deny,allow Allow from all \u0026lt;/Proxy\u0026gt; ProxyPass / http://127.0.0.1:8443/ ProxyPassReverse / http://127.0.0.1:8443/ \u0026lt;/VirtualHost\u0026gt; Registro e Coordenação Para incluir seu servidor de reseed (processo de inicialização da rede) no pacote oficial do I2P:\nConclua a configuração e os testes Envie ambos os certificados (SU3 signing (assinatura SU3) e TLS) ao reseed coordinator (coordenador de reseed) Contato: zzz@mail.i2p ou zzz@i2pmail.org Junte-se a #i2p-dev no IRC2P para coordenação com outros operadores Melhores Práticas Operacionais Monitoramento e Registro em Log Ativar o formato de log combinado do Apache/nginx para estatísticas Implementar rotação de logs (os logs crescem rapidamente) Monitorar o sucesso da geração de bundle (pacote) e os tempos de reconstrução Acompanhar o uso de largura de banda e os padrões de solicitações Nunca divulgar endereços IP ou logs de acesso detalhados Cronograma de Manutenção A cada 9 horas: Reconstruir o cache de bundles SU3 (automatizado via cron) Semanalmente: Revisar os logs em busca de padrões de ataque Mensalmente: Atualizar o I2P router e reseed-tools (ferramentas de resemeadura) Conforme necessário: Renovar certificados TLS (automatizar com Let\u0026rsquo;s Encrypt) Seleção de portas Padrão: 8443 (recomendado) Alternativa: Qualquer porta entre 1024-49151 Porta 443: Requer privilégios de root ou redirecionamento de portas (iptables redirect recomendado) Exemplo de redirecionamento de portas:\niptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-port 8443 Métodos alternativos de Reseed Outras opções de bootstrap (inicialização) ajudam usuários em redes restritivas:\nReseed Baseado em Arquivo Introduzido na versão 0.9.16, o reseeding baseado em arquivos (procedimento de bootstrap/obtenção inicial de pares) permite que os usuários carreguem manualmente pacotes de RouterInfo. Esse método é particularmente útil para usuários em regiões censuradas onde os servidores de reseed HTTPS estão bloqueados.\nProcesso: 1. Um contato confiável gera um pacote SU3 usando seu router 2. O pacote é transferido por e-mail, unidade USB ou outro canal fora de banda 3. O usuário coloca i2pseeds.su3 no diretório de configuração do I2P 4. O router detecta e processa automaticamente o pacote ao reiniciar\nDocumentação: /blog/2020/06/07/help-your-friends-join-i2p-by-sharing-reseed-bundles/\nCasos de uso: - Usuários por trás de firewalls nacionais que bloqueiam reseed servers (servidores de bootstrap) - Redes isoladas que exigem inicialização manual - Ambientes de teste e desenvolvimento\nReseeding (processo de inicialização para obter pares da rede) com proxy do Cloudflare Encaminhar o tráfego de reseed (processo de inicialização da rede) pela CDN da Cloudflare oferece várias vantagens para operadores em regiões de alta censura.\nBenefícios: - Endereço IP do servidor de origem oculto dos clientes - Proteção contra DDoS via infraestrutura da Cloudflare - Distribuição geográfica de carga via cache na borda - Desempenho aprimorado para clientes globais\nRequisitos de Implementação: - parâmetro --trustProxy ativado no reseed-tools - proxy da Cloudflare ativado para o registro DNS - Tratamento adequado do cabeçalho X-Forwarded-For\nConsiderações importantes: - As restrições de portas da Cloudflare se aplicam (é necessário usar portas suportadas) - Same-client bundle consistency (consistência do agrupamento para o mesmo cliente) exige suporte a X-Forwarded-For - Configuração de SSL/TLS gerenciada pela Cloudflare\nDocumentação: https://homepage.np-tokumei.net/post/notes-i2p-reseed-over-cloudflare/ Estratégias resistentes à censura A pesquisa de Nguyen Phong Hoang (USENIX FOCI 2019) identifica métodos adicionais de inicialização para redes censuradas:\nProvedores de Armazenamento em Nuvem Box, Dropbox, Google Drive, OneDrive: Hospedar arquivos SU3 em links públicos Vantagem: Difícil de bloquear sem interromper serviços legítimos Limitação: Requer distribuição manual de URLs para os usuários Distribuição via IPFS Hospedar pacotes de reseed (obtenção inicial de pares para se conectar à rede) no InterPlanetary File System Armazenamento endereçado por conteúdo impede adulterações Resiliente a tentativas de remoção Serviços Onion do Tor Reseed servers (servidores que fornecem pares iniciais para iniciar a participação na rede) acessíveis via endereços .onion Resistente ao bloqueio baseado em IP Requer cliente Tor no sistema do usuário Documentação de pesquisa: https://homepage.np-tokumei.net/post/notes-censorship-resistant-i2p-reseeding/ Países com bloqueio conhecido do I2P Em 2025, há confirmação de que os seguintes países bloqueiam I2P reseed servers (servidores usados para inicializar o I2P): - China - Irã - Omã - Catar - Kuwait\nOs usuários nessas regiões devem utilizar métodos alternativos de bootstrap ou estratégias de reseed resistentes à censura.\nDetalhes do Protocolo para Implementadores Especificação da Solicitação de Reseed (processo de obtenção inicial de pares) Comportamento do Cliente Seleção do servidor: Router mantém uma lista codificada de forma fixa de URLs de reseed (processo de inicialização/obtenção de pares do I2P) Seleção aleatória: O cliente seleciona aleatoriamente um servidor da lista disponível Formato da requisição: GET /i2pseeds.su3?netid=2 HTTP/1.1 User-Agent: Deve imitar navegadores comuns (por exemplo, \u0026ldquo;Wget/1.11.4\u0026rdquo;) Lógica de nova tentativa: Se a requisição SU3 falhar, usar como alternativa a análise da página índice Validação de certificado: Verificar o certificado TLS contra o repositório de confiança do sistema Validação da assinatura SU3: Verificar a assinatura em relação aos certificados de reseed conhecidos Comportamento do Servidor Seleção do conjunto: Selecionar subconjunto pseudoaleatório de RouterInfos (registros de metadados de router no I2P) do netDb Rastreamento do cliente: Identificar solicitações pelo IP de origem (respeitando X-Forwarded-For) Consistência do conjunto: Retornar o mesmo conjunto para solicitações repetidas dentro de uma janela de tempo (tipicamente 8-12 horas) Diversidade de conjuntos: Retornar conjuntos diferentes para clientes diferentes para diversidade de rede Content-Type: application/octet-stream ou application/x-i2p-reseed Formato do arquivo RouterInfo Cada arquivo .dat no reseed bundle (pacote de reseed usado para inicialização) contém uma estrutura RouterInfo:\nNomenclatura de arquivos: routerInfo-{base64-hash}.dat - O hash tem 44 caracteres usando o alfabeto base64 do I2P - Exemplo: routerInfo-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmn.dat\nConteúdo do arquivo: - RouterIdentity (hash do router, chave de criptografia, chave de assinatura) - Carimbo de data e hora da publicação - Endereços do router (IP, porta, tipo de transporte) - Capacidades e opções do router - Assinatura que cobre todos os dados acima\nRequisitos de Diversidade da Rede Para evitar a centralização da rede e permitir a detecção de Sybil attack (ataque Sybil, em que um adversário cria múltiplas identidades falsas):\nSem dumps completos do NetDb: Nunca forneça todas as RouterInfos (informações de roteadores) a um único cliente Amostragem aleatória: Cada lote contém um subconjunto diferente dos pares disponíveis Tamanho mínimo do lote: 75 RouterInfos (aumentado em relação aos 50 originais) Tamanho máximo do lote: 100 RouterInfos Atualidade: As RouterInfos devem ser recentes (em até 24 horas de sua geração) Considerações sobre IPv6 Status atual (2025): - Vários servidores de reseed não respondem via IPv6 - Os clientes devem preferir ou forçar IPv4 para maior confiabilidade - O suporte a IPv6 é recomendado para novas implantações, mas não é crítico\nNota de Implementação: Ao configurar servidores dual-stack (dupla pilha), garanta que os endereços de escuta IPv4 e IPv6 funcionem corretamente, ou desative o IPv6 se ele não puder ser suportado adequadamente.\nConsiderações de Segurança Modelo de Ameaças O protocolo de reseed protege contra:\nAtaques Man-in-the-Middle (ataque de intermediário): Assinaturas RSA-4096 impedem a adulteração do pacote Particionamento da rede: Múltiplos servidores de reseed (servidores de inicialização) independentes evitam um único ponto de controle Ataques Sybil (múltiplas identidades falsas): A diversidade de pacotes limita a capacidade do atacante de isolar usuários Censura: Múltiplos servidores e métodos alternativos fornecem redundância O protocolo de reseed (processo de inicialização do netDb) NÃO defende contra:\nReseed servers comprometidos (servidores de bootstrap da rede): Se o atacante controla as chaves privadas dos certificados de reseed Bloqueio completo da rede: Se todos os métodos de reseed estiverem bloqueados em uma região Monitoramento de longo prazo: Solicitações de reseed revelam o endereço IP que tenta ingressar no I2P Gerenciamento de Certificados Segurança de Chaves Privadas: - Armazene as chaves de assinatura SU3 offline quando não estiverem em uso - Use senhas fortes para a criptografia das chaves - Mantenha backups seguros das chaves e certificados - Considere módulos de segurança de hardware (HSMs) para implantações de alto valor\nRevogação de Certificados: - Listas de Revogação de Certificados (CRLs) distribuídas via feed de notícias - Certificados comprometidos podem ser revogados pelo coordenador - Routers atualizam automaticamente as CRLs com as atualizações de software\nMitigação de Ataques Proteção contra DDoS: - regras do fail2ban para solicitações excessivas - Limitação de taxa no nível do servidor web - Limites de conexão por endereço IP - Cloudflare ou CDN semelhante para camada adicional\nPrevenção de scraping (raspagem automatizada de dados): - Pacotes diferentes por IP solicitante - Armazenamento em cache de pacotes baseado no tempo por IP - Registro de padrões que indiquem tentativas de scraping - Coordenação com outros operadores sobre ataques detectados\nTestes e Validação Testando seu servidor de reseed (inicialização da rede) Método 1: Instalação Limpa do Router Instale o I2P em um sistema limpo Adicione sua URL de reseed (obtenção inicial de pares da rede) à configuração Remova ou desative outras URLs de reseed Inicie o router e monitore os logs para confirmar o reseed bem-sucedido Verifique a conexão com a rede em até 5-10 minutos Saída de log esperada:\nReseed got 77 router infos from https://your-reseed.example.com/i2pseeds.su3?netid=2 with 0 errors Reseed complete, 77 received Método 2: Validação Manual de SU3 # Download bundle curl -k -A \u0026#34;Wget/1.11.4\u0026#34; https://your-reseed.example.com/i2pseeds.su3 \u0026gt; test.su3 # Verify it\u0026#39;s a valid SU3 file hexdump -C test.su3 | head -n 3 # Should show: 49 32 50 73 75 33 (I2Psu3) # Extract content (requires su3 tools) java -cp /path/to/i2p.jar net.i2p.crypto.SU3File verify test.su3 your-cert.crt # Unzip content # (Extract content section, skip header+signature, then unzip) Método 3: monitoramento do checki2p O serviço em https://checki2p.com/reseed realiza verificações automatizadas a cada 4 horas em todos os servidores de reseed do I2P (processo de inicialização da rede para obter pares inicialmente). Isso fornece:\nMonitoramento de disponibilidade Métricas de tempo de resposta Validação de certificado TLS Verificação da assinatura SU3 Dados históricos de tempo de atividade Assim que o seu reseed (servidor de inicialização) for registrado junto ao projeto I2P, ele aparecerá automaticamente no checki2p dentro de 24 horas.\nSolução de problemas comuns Problema: \u0026ldquo;Unable to read signing key\u0026rdquo; na primeira execução - Solução: Isso é esperado. Responda \u0026lsquo;y\u0026rsquo; para gerar novas chaves.\nProblema: router não consegue verificar a assinatura - Causa: certificado não está no repositório de confiança do router - Solução: coloque o certificado no diretório ~/.i2p/certificates/reseed/\nProblema: Mesmo bundle entregue a clientes diferentes - Causa: Cabeçalho X-Forwarded-For não encaminhado corretamente - Solução: Ative --trustProxy e configure os cabeçalhos do proxy reverso\nProblema: erros \u0026ldquo;Connection refused\u0026rdquo; - Causa: porta não acessível a partir da Internet - Solução: verifique as regras do firewall, verifique o encaminhamento de portas\nProblema: Uso elevado de CPU durante a reconstrução do bundle - Causa: Comportamento normal ao gerar mais de 350 variações de SU3 (formato de atualização assinado do I2P) - Solução: Garanta recursos de CPU adequados, considere reduzir a frequência de reconstrução\nInformações de referência Documentação Oficial Guia de Contribuidores do Reseed (inicialização do netDb do I2P): /guides/creating-and-running-an-i2p-reseed-server/ Requisitos da Política de Reseed: /guides/reseed-policy/ Especificação SU3: /docs/specs/updates/ Repositório das Ferramentas de Reseed: https://i2pgit.org/idk/reseed-tools Documentação das Ferramentas de Reseed: https://eyedeekay.github.io/reseed-tools/ Implementações alternativas PurpleI2P pyseeder: https://github.com/PurpleI2P/pyseeder DivaExchange i2p-reseed: https://github.com/diva-exchange/i2p-reseed RTradeLtd i2p-tools-1: https://github.com/RTradeLtd/i2p-tools-1 Reseeder WSGI em Python (servidor de distribuição inicial de pares): https://github.com/torbjo/i2p-reseeder Recursos da Comunidade Fórum I2P: https://i2pforum.net/ Repositório Gitea: https://i2pgit.org/I2P_Developers/i2p.i2p IRC: #i2p-dev no IRC2P Monitoramento de Status: https://checki2p.com/reseed Histórico de versões 0.9.14 (2014): Formato de reseed SU3 introduzido 0.9.16 (2014): Reseeding baseado em arquivos adicionado 0.9.42 (2019): Exigência do parâmetro de consulta Network ID 2.0.0 (2022): Protocolo de transporte SSU2 introduzido 2.4.0 (2024): Melhorias de isolamento e segurança do NetDB 2.6.0 (2024): Conexões I2P-over-Tor bloqueadas 2.10.0 (2025): Versão estável atual (em setembro de 2025) Referência dos Tipos de Assinatura Type Code Algorithm Key Size Signature Size Hash DSA-SHA10DSA1024-bit40 bytesSHA-1 ECDSA-SHA256-P2561ECDSAP-25664 bytesSHA-256 ECDSA-SHA384-P3842ECDSAP-38496 bytesSHA-384 ECDSA-SHA512-P5213ECDSAP-521132 bytesSHA-512 RSA-SHA256-20484RSA2048-bit256 bytesSHA-256 RSA-SHA384-30725RSA3072-bit384 bytesSHA-384 RSA-SHA512-40966RSA4096-bit512 bytesSHA-512 EdDSA-SHA512-Ed255197EdDSAEd2551964 bytesSHA-512 **Padrão de Reseed**: Tipo 6 (RSA-SHA512-4096) é obrigatório para pacotes de reseed. Apreço Agradecemos a todos os reseed operators (operadores que fornecem os dados iniciais para a rede) por manterem a rede acessível e resiliente. Reconhecimento especial aos seguintes colaboradores e projetos:\nzzz: Desenvolvedor do I2P de longa data e coordenador de reseed (processo de inicialização do I2P para começar a se conectar à rede) idk: Mantenedor atual do reseed-tools e responsável pelos lançamentos Nguyen Phong Hoang: Pesquisa sobre estratégias de reseed resistentes à censura Equipe PurpleI2P: Implementações alternativas do I2P e ferramentas checki2p: Serviço automatizado de monitoramento da infraestrutura de reseed A infraestrutura descentralizada de reseed (processo inicial de descoberta de pares) da rede I2P representa um esforço colaborativo de dezenas de operadores em todo o mundo, garantindo que novos usuários possam sempre encontrar um caminho para ingressar na rede, independentemente da censura local ou de barreiras técnicas.\n","description":"Operando serviços de reseed (semeadura inicial da rede) e métodos alternativos de bootstrap (inicialização)","id":"02dba83ad9e38e1355d624c0d4fa28aa","section":"docs","title":"Hosts de Reseed (inicialização da rede)","url":"/pt/docs/misc/reseed/"},{"categories":null,"content":"Introdução O I2P fornece mensagens privadas no estilo e-mail através do serviço Postman\u0026rsquo;s Mail.i2p combinado com o SusiMail, um cliente de webmail integrado. Este sistema permite que os usuários enviem e recebam e-mails tanto dentro da rede I2P quanto de/para a internet regular (clearnet) através de uma ponte gateway.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um título ou pareça incompleto, traduza-o como está.\nPostman / Mail.i2p + SusiMail What it is Mail.i2p é um provedor de e-mail hospedado dentro do I2P, operado pelo \u0026ldquo;Postman\u0026rdquo; SusiMail é o cliente webmail integrado no console do router I2P. Ele foi projetado para evitar vazamento de metadados (por exemplo, hostname) para servidores SMTP externos. Através dessa configuração, os usuários do I2P podem enviar/receber mensagens tanto dentro do I2P quanto de/para a clearnet (por exemplo, Gmail) via ponte Postman. How Addressing Works O email I2P usa um sistema de endereço duplo:\nDentro da rede I2P: username@mail.i2p (por exemplo, idk@mail.i2p) Da clearnet: username@i2pmail.org (por exemplo, idk@i2pmail.org) O gateway i2pmail.org permite que usuários regulares da internet enviem e-mails para endereços I2P, e usuários I2P enviem para endereços da clearnet. E-mails da internet são roteados através do gateway antes de serem encaminhados através do I2P para sua caixa de entrada do SusiMail.\nQuota de envio para clearnet: 20 emails por dia ao enviar para endereços de internet regulares.\nO que é Para registar uma conta mail.i2p:\nCertifique-se de que seu roteador I2P está em execução Visite http://hq.postman.i2p dentro do I2P Siga o processo de registro Acesse seu e-mail através do SusiMail no console do roteador Nota: hq.postman.i2p é um endereço de rede I2P (eepsite) e só pode ser acessado enquanto conectado ao I2P. Para mais informações sobre configuração de email, segurança e uso, visite o Postman HQ.\nComo o Endereçamento Funciona Remoção automática de cabeçalhos identificadores (User-Agent:, X-Mailer:) para privacidade Sanitização de metadados para prevenir vazamentos para servidores SMTP externos Criptografia ponta a ponta para emails internos I2P-para-I2P Primeiros Passos Interoperabilidade com email \u0026ldquo;normal\u0026rdquo; (SMTP/POP) via ponte Postman Experiência de usuário simples (webmail integrado ao console do roteador) Integrado com a distribuição principal do I2P (SusiMail incluído no I2P Java) Remoção de cabeçalhos para proteção de privacidade Recursos de Privacidade A ponte para email externo requer confiança na infraestrutura do Postman A ponte para clearnet reduz a privacidade comparada à comunicação puramente interna do I2P Dependente da disponibilidade e segurança do servidor de email Postman Technical Details Serviço SMTP: localhost:7659 (fornecido pelo Postman) Serviço POP3: localhost:7660 Acesso ao Webmail: Integrado no console do roteador em http://127.0.0.1:7657/susimail/\nImportante: O SusiMail é apenas para ler e enviar emails. A criação e gestão de contas devem ser feitas em hq.postman.i2p.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nBest Practices Altere sua senha após registrar sua conta mail.i2p Use e-mail I2P-para-I2P sempre que possível para máxima privacidade (sem ponte para clearnet) Esteja atento ao limite de 20/dia ao enviar para endereços clearnet Compreenda as compensações: A ponte para clearnet oferece conveniência, mas reduz o anonimato em comparação com comunicações puramente internas do I2P Mantenha o I2P atualizado para beneficiar-se das melhorias de segurança no SusiMail IMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\n","description":"Uma visão geral dos sistemas de email dentro da rede I2P — histórico, opções e status atual","id":"31217ea91c11f98bd1997466684f9fb3","section":"docs","title":"I2P Mail (Email Anônimo sobre I2P)","url":"/pt/docs/applications/i2p-mail/"},{"categories":null,"content":"Visão Geral Existem hoje várias redes importantes de privacidade e anonimato, cada uma com objetivos de design e modelos de ameaça diferentes. Embora Tor, Lokinet, GNUnet e Freenet contribuam com abordagens valiosas para comunicação que preserva a privacidade, I2P se destaca como a única rede comutada por pacotes, pronta para produção e totalmente otimizada para serviços ocultos dentro da rede e aplicações peer-to-peer.\nA tabela abaixo resume as principais distinções arquiteturais e operacionais entre essas redes a partir de 2025.\nComparação de Redes de Privacidade (2025) Feature / Network I2P Tor Lokinet Freenet (Hyphanet) GNUnet Primary Focus Hidden services, P2P applications Clearnet anonymity via exits Hybrid VPN + hidden services Distributed storage \u0026 publishing Research framework, F2F privacy Architecture Fully distributed, packet-switched Centralized directory, circuit-switched Packet-switched LLARP with blockchain coordination DHT-based content routing DHT \u0026 F2F topology (R5N) Routing Model Unidirectional tunnels (inbound/outbound) Bidirectional circuits (3 hops) Packet-switched over staked nodes Key-based routing Random walk + DHT hybrid Directory / Peer Discovery Distributed Kademlia netDB with floodfills 9 hardcoded directory authorities Blockchain + Oxen staking Heuristic routing Distributed hash routing (R5N) Encryption ECIES-X25519-AEAD-Ratchet (ChaCha20/Poly1305) AES + RSA/ECDH Curve25519/ChaCha20 Custom symmetric encryption Ed25519/Curve25519 Participation Model All routers route traffic (democratic) Small relay subset, majority are clients Only staked nodes User-selectable trust mesh Optional F2F restriction Traffic Handling Packet-switched, multi-path, load-balanced Circuit-switched, fixed path per circuit Packet-switched, incentivized File chunk propagation Message batching and proof-of-work Garlic Routing ✅ Yes (message bundling \u0026 tagging) ❌ No Partial (message batches) ❌ No ❌ No Exit to Clearnet Limited (discouraged) Core design goal Supported (VPN-style exits) Not applicable Not applicable Built-In Apps I2PSnark, I2PTunnel, SusiMail, I2PBote Tor Browser, OnionShare Lokinet GUI, SNApps Freenet UI GNUnet CLI tools Performance Optimized for internal services, 1–3s RTT Optimized for exits, ~200–500ms RTT Low latency, staked node QoS High latency (minutes) Experimental, inconsistent Anonymity Set Size ~55,000 active routers Millions of daily users \u0026lt;1,000 service nodes Thousands (small core) Hundreds (research only) Scalability Horizontal via floodfill rotation Centralized bottleneck (directory) Dependent on token economics Limited by routing heuristics Research-scale only Funding Model Volunteer-driven nonprofit Major institutional grants Crypto-incentivized (OXEN) Volunteer community Academic research License / Codebase Open source (Java/C++/Go) Open source (C) Open source (C++) Open source (Java) Open source (C) --- Por que o I2P Lidera em Design com Foco na Privacidade 1. Packet Switching \u0026gt; Circuit Switching O modelo de circuitos comutados do Tor vincula o tráfego a caminhos fixos de três saltos—eficiente para navegação, mas frágil para serviços internos de longa duração. Os túneis de comutação de pacotes do I2P enviam mensagens através de múltiplos caminhos simultâneos, roteando automaticamente em torno de congestionamento ou falhas para melhor tempo de atividade e distribuição de carga.\n2. Unidirectional Tunnels O I2P separa o tráfego de entrada e de saída. Isso significa que cada participante vê apenas metade de um fluxo de comunicação, tornando os ataques de correlação temporal significativamente mais difíceis. O Tor, Lokinet e outros usam circuitos bidirecionais onde requisições e respostas compartilham o mesmo caminho—mais simples, mas mais rastreável.\n3. Fully Distributed netDB As nove autoridades de diretório do Tor definem sua topologia de rede. O I2P usa uma Kademlia DHT auto-organizada mantida por routers floodfill rotativos, eliminando quaisquer pontos de controle central ou servidores de coordenação.\n1. Comutação de Pacotes \u0026gt; Comutação de Circuitos O I2P estende o roteamento onion com garlic routing (roteamento em alho), agrupando múltiplas mensagens criptografadas em um único contêiner. Isso reduz o vazamento de metadados e a sobrecarga de largura de banda, melhorando a eficiência para mensagens de confirmação, dados e controle.\n2. Túneis Unidirecionais Cada router I2P roteia para outros. Não há operadores de relay dedicados ou nós privilegiados—a largura de banda e a confiabilidade determinam automaticamente quanto roteamento um nó contribui. Esta abordagem democrática constrói resiliência e escala naturalmente à medida que a rede cresce.\n3. netDB Totalmente Distribuído O trajeto de ida e volta de 12 saltos do I2P (6 de entrada + 6 de saída) cria uma desvinculação mais forte do que os circuitos de 6 saltos dos serviços ocultos do Tor. Como ambas as partes são internas, as conexões evitam completamente o gargalo de saída, proporcionando hospedagem interna mais rápida e integração nativa de aplicações (I2PSnark, I2PTunnel, I2PBote).\nArchitectural Takeaways Design Principle I2P Advantage Decentralization No trusted authorities; netDB managed by floodfill peers Traffic Separation Unidirectional tunnels prevent request/response correlation Adaptability Packet-switching allows per-message load balancing Efficiency Garlic routing reduces metadata and increases throughput Inclusiveness All peers route traffic, strengthening anonymity set Focus Built specifically for hidden services and in-network communication --- When to Use Each Network Use Case Recommended Network Anonymous web browsing (clearnet access) I2P Anonymous hosting, P2P, or DApps I2P Anonymous file publishing and storage Freenet (Hyphanet) VPN-style private routing with staking Lokinet Academic experimentation and research GNUnet --- Summary A arquitetura do I2P é exclusivamente focada na privacidade—sem servidores de diretório, sem dependências de blockchain, sem confiança centralizada. Sua combinação de tunnels unidirecionais, roteamento por comutação de pacotes, agrupamento de mensagens garlic e descoberta distribuída de peers torna-o o sistema tecnicamente mais avançado para hospedagem anônima e comunicação peer-to-peer atualmente.\nI2P não é \u0026ldquo;uma alternativa ao Tor.\u0026rdquo; É uma classe diferente de rede—construída para o que acontece dentro da rede de privacidade, não fora dela.\n","description":"Uma comparação técnica e filosófica moderna destacando as vantagens únicas do design do I2P","id":"bc3abab13910824c59b1550aa1ce69df","section":"docs","title":"I2P vs Outras Redes de Privacidade","url":"/pt/docs/overview/comparison/"},{"categories":null,"content":"Introdução I2P é uma camada de rede anônima escalável, auto-organizada e resiliente baseada em comutação de pacotes, sobre a qual qualquer número de aplicações diferentes conscientes de anonimato ou segurança podem operar. Cada uma dessas aplicações pode fazer suas próprias compensações entre anonimato, latência e throughput (taxa de transferência) sem se preocupar com a implementação adequada de uma mixnet (rede de mistura) de rota livre, permitindo que elas mesclem sua atividade com o conjunto maior de anonimato dos usuários já em execução sobre o I2P.\nAs aplicações já disponíveis fornecem toda a gama de atividades típicas da Internet — navegação web anônima, hospedagem de sites, chat, compartilhamento de arquivos, e-mail, blogs e distribuição de conteúdo, bem como várias outras aplicações em desenvolvimento.\nNavegação web: usando qualquer navegador existente que suporte um proxy Chat: IRC e outros protocolos Compartilhamento de arquivos: I2PSnark e outras aplicações E-mail: Susimail e outras aplicações Blog: usando qualquer servidor web local, ou plugins disponíveis Ao contrário de sites hospedados em redes de distribuição de conteúdo como Freenet ou GNUnet , os serviços hospedados no I2P são totalmente interativos — existem motores de busca tradicionais estilo web, fóruns de discussão, blogs nos quais você pode comentar, sites baseados em banco de dados e pontes para consultar sistemas estáticos como Freenet sem precisar instalá-los localmente.\nCom todas essas aplicações habilitadas para anonimato, o I2P atua como middleware orientado a mensagens — as aplicações especificam os dados a serem enviados para um identificador criptográfico (um \u0026ldquo;destination\u0026rdquo;), e o I2P garante que cheguem de forma segura e anônima. O I2P também inclui uma biblioteca de streaming simples para permitir que as mensagens anônimas de melhor esforço do I2P sejam transferidas como fluxos confiáveis e ordenados, oferecendo controle de congestionamento baseado em TCP ajustado para o alto produto largura de banda-atraso da rede.\nEmbora proxies SOCKS simples tenham sido desenvolvidos para conectar aplicações existentes, seu valor é limitado, pois a maioria das aplicações vaza informações sensíveis em um contexto anônimo. A abordagem mais segura é auditar e adaptar a aplicação para usar as APIs do I2P diretamente.\nI2P não é um projeto de pesquisa — acadêmico, comercial ou governamental — mas um esforço de engenharia voltado para fornecer anonimato utilizável. Está em desenvolvimento contínuo desde o início de 2003 por um grupo distribuído de colaboradores em todo o mundo. Todo o trabalho do I2P é open source no site oficial , principalmente lançado em domínio público, com alguns componentes sob licenças permissivas estilo BSD. Várias aplicações cliente licenciadas sob GPL estão disponíveis, como I2PTunnel , Susimail e I2PSnark . O financiamento vem exclusivamente de doações de usuários.\nOperação Overview O I2P distingue claramente entre routers (nós participantes da rede) e destinos (endpoints anônimos para aplicações). Executar o I2P em si não é secreto; o que é oculto é o que o usuário está fazendo e qual router seus destinos utilizam. Os usuários finais geralmente executam vários destinos (por exemplo, um para navegação web, outro para hospedagem, outro para IRC).\nUm conceito-chave no I2P é o tunnel — um caminho criptografado unidirecional através de uma série de routers. Cada router descriptografa apenas uma camada e conhece apenas o próximo salto. Os tunnels expiram a cada 10 minutos e devem ser reconstruídos.\nFigura 1: Existem dois tipos de túneis — de entrada e de saída.\nTúneis de saída enviam mensagens para longe do criador. Túneis de entrada trazem mensagens de volta para o criador. Combinar estes elementos permite a comunicação bidirecional. Por exemplo, \u0026ldquo;Alice\u0026rdquo; usa um tunnel de saída para enviar para o tunnel de entrada de \u0026ldquo;Bob\u0026rdquo;. Alice criptografa sua mensagem com instruções de roteamento para o gateway de entrada de Bob.\nOutro conceito fundamental é o network database ou netDb, que distribui metadados sobre routers e destinos:\nRouterInfo: Contém informações de contato do router e material de chaves. LeaseSet: Contém informações necessárias para contactar um destino (gateways de túnel, tempos de expiração, chaves de criptografia). Os routers publicam suas RouterInfo diretamente no netDb; os LeaseSets são enviados através de túneis de saída para anonimato.\nPara construir tunnels, Alice consulta o netDb em busca de entradas RouterInfo para escolher peers, e envia mensagens criptografadas de construção de tunnel hop-by-hop até que o tunnel esteja completo.\nFigura 2: Informações do router são usadas para construir tunnels.\nPara enviar dados para Bob, Alice procura o LeaseSet de Bob e usa um dos seus túneis de saída para rotear os dados através do gateway do túnel de entrada de Bob.\nFigura 3: LeaseSets conectam túneis de saída e de entrada.\nComo o I2P é baseado em mensagens, ele adiciona criptografia garlic ponta-a-ponta para proteger mensagens até mesmo do endpoint de saída ou gateway de entrada. Uma mensagem garlic encapsula múltiplos \u0026ldquo;dentes\u0026rdquo; (mensagens) criptografados para ocultar metadados e melhorar o anonimato.\nAs aplicações podem usar a interface de mensagens diretamente ou depender da biblioteca de streaming para conexões confiáveis.\nTunnels Tanto os túneis de entrada quanto os de saída usam criptografia em camadas, mas diferem na construção:\nNos túneis de entrada (inbound tunnels), o criador (o endpoint) descriptografa todas as camadas. Nos túneis de saída (outbound tunnels), o criador (o gateway) pré-descriptografa as camadas para garantir clareza no endpoint. O I2P cria perfis de peers através de métricas indiretas como latência e confiabilidade, sem sondagem direta. Com base nesses perfis, os peers são agrupados dinamicamente em quatro níveis:\nRápido e alta capacidade Alta capacidade Não falhando Falhando A seleção de pares de túnel normalmente prefere pares de alta capacidade, escolhidos aleatoriamente para equilibrar anonimato e desempenho, com estratégias adicionais de ordenação baseadas em XOR para mitigar ataques de predecessor e coleta de netDb.\nPara mais detalhes, consulte a Especificação de Tunnel .\nVisão Geral Routers que participam na tabela hash distribuída (DHT) floodfill armazenam e respondem a consultas de LeaseSet. A DHT utiliza uma variante de Kademlia . Routers floodfill são selecionados automaticamente se tiverem capacidade e estabilidade suficientes, ou podem ser configurados manualmente.\nRouterInfo: Descreve as capacidades e transportes de um router. LeaseSet: Descreve os tunnels e chaves de criptografia de um destino. Todos os dados no netDb são assinados pelo editor e possuem carimbo de data/hora para prevenir ataques de repetição ou entradas obsoletas. A sincronização de tempo é mantida através de SNTP e detecção de desvio na camada de transporte.\nAdditional concepts LeaseSets não publicados e criptografados:\nUm destino pode permanecer privado ao não publicar seu LeaseSet, compartilhando-o apenas com peers confiáveis. O acesso requer a chave de descriptografia apropriada.\nBootstrapping (reseeding):\nPara se juntar à rede, um novo router busca arquivos RouterInfo assinados de servidores reseed HTTPS confiáveis.\nEscalabilidade de pesquisa:\nO I2P usa pesquisas iterativas, não recursivas, para melhorar a escalabilidade e segurança da DHT.\nTúneis A comunicação moderna do I2P utiliza dois transportes totalmente criptografados:\nNTCP2 : Protocolo baseado em TCP criptografado SSU2 : Protocolo baseado em UDP criptografado Ambos são construídos no moderno Noise Protocol Framework , fornecendo autenticação forte e resistência à impressão digital de tráfego. Eles substituíram os protocolos legados NTCP e SSU (completamente descontinuados desde 2023).\nNTCP2 oferece streaming criptografado e eficiente sobre TCP.\nSSU2 fornece confiabilidade baseada em UDP, travessia de NAT e perfuração de firewall opcional. O SSU2 é conceitualmente semelhante ao WireGuard ou QUIC, equilibrando confiabilidade e anonimato.\nOs routers podem suportar tanto IPv4 quanto IPv6, publicando seus endereços de transporte e custos no netDb. O transporte de uma conexão é selecionado dinamicamente por um sistema de lances que otimiza para condições e links existentes.\nBase de Dados da Rede (netDb) I2P utiliza criptografia em camadas para todos os componentes: transportes, tunnels, mensagens garlic e o netDb.\nAs primitivas atuais incluem:\nX25519 para troca de chaves EdDSA (Ed25519) para assinaturas ChaCha20-Poly1305 para criptografia autenticada SHA-256 para hashing AES256 para criptografia de camada de túnel Os algoritmos legados (ElGamal, DSA-SHA1, ECDSA) permanecem para compatibilidade retroativa.\nO I2P está atualmente introduzindo esquemas criptográficos híbridos pós-quânticos (PQ) que combinam X25519 com ML-KEM para resistir a ataques de \u0026ldquo;coletar agora, descriptografar depois\u0026rdquo;.\nGarlic Messages Mensagens garlic estendem o roteamento cebola ao agrupar múltiplos \u0026ldquo;cravos\u0026rdquo; criptografados com instruções de entrega independentes. Isso permite flexibilidade de roteamento no nível de mensagem e preenchimento uniforme de tráfego.\nSession Tags Dois sistemas criptográficos são suportados para criptografia ponta a ponta:\nElGamal/AES+SessionTags (legado):\nUsa tags de sessão pré-entregues como nonces de 32 bytes. Agora obsoleto devido à ineficiência.\nECIES-X25519-AEAD-Ratchet (atual):\nUsa ChaCha20-Poly1305 e PRNGs baseados em HKDF sincronizados para gerar chaves de sessão efêmeras e tags de 8 bytes dinamicamente, reduzindo a sobrecarga de CPU, memória e largura de banda enquanto mantém o sigilo perfeito para frente (forward secrecy).\nFuture of the Protocol As principais áreas de pesquisa concentram-se em manter a segurança contra adversários de nível estatal e introduzir proteções pós-quânticas. Dois conceitos de design iniciais — rotas restritas e latência variável — foram substituídos por desenvolvimentos modernos.\nRestricted Route Operation Os conceitos originais de roteamento restrito visavam ocultar endereços IP. Esta necessidade foi amplamente mitigada por:\nUPnP para encaminhamento automático de portas Travessia robusta de NAT no SSU2 Suporte a IPv6 Introdutores cooperativos e perfuração de NAT Conectividade opcional por overlay (ex.: Yggdrasil) Assim, o I2P moderno alcança os mesmos objetivos de forma mais prática, sem roteamento restrito complexo.\nSimilar Systems O I2P integra conceitos de middleware orientado a mensagens, DHTs e mixnets. Sua inovação reside em combinar esses elementos em uma plataforma de anonimato utilizável e auto-organizável.\nProtocolos de Transporte Website Tor e I2P compartilham objetivos mas diferem arquiteturalmente:\nTor: Comutação de circuitos; depende de autoridades de diretório confiáveis. (~10k relays) I2P: Comutação de pacotes; rede totalmente distribuída baseada em DHT. (~50k routers) Os túneis unidirecionais do I2P expõem menos metadados e permitem caminhos de roteamento flexíveis, enquanto o Tor foca no acesso anônimo à Internet (outproxying). O I2P, em vez disso, suporta hospedagem anônima dentro da rede.\nCriptografia Website Freenet foca-se na publicação e recuperação anônima e persistente de arquivos. I2P, em contraste, fornece uma camada de comunicações em tempo real para uso interativo (web, chat, torrents). Juntos, os dois sistemas complementam-se — Freenet fornece armazenamento resistente à censura; I2P fornece anonimato no transporte.\nOther Networks Lokinet: Overlay baseado em IP usando nós de serviço incentivados. Nym: Mixnet de próxima geração enfatizando proteção de metadados com tráfego de cobertura em latência mais alta. Appendix A: Application Layer O I2P em si apenas gerencia o transporte de mensagens. A funcionalidade da camada de aplicação é implementada externamente através de APIs e bibliotecas.\nStreaming Library A biblioteca de streaming funciona como o análogo TCP do I2P, com um protocolo de janela deslizante e controle de congestionamento ajustado para transporte anônimo de alta latência.\nPadrões típicos de requisição/resposta HTTP frequentemente podem ser concluídos em uma única viagem de ida e volta devido a otimizações de agrupamento de mensagens.\nNaming Library and Address Book Desenvolvido por: mihi, Ragnarok Consulte a página Nomenclatura e Catálogo de Endereços .\nO sistema de nomenclatura do I2P é local e descentralizado, evitando nomes globais no estilo DNS. Cada router mantém um mapeamento local de nomes legíveis por humanos para destinos. Catálogos de endereços opcionais baseados em rede de confiança podem ser compartilhados ou importados de pares confiáveis.\nEsta abordagem evita autoridades centralizadas e contorna vulnerabilidades Sybil inerentes a sistemas de nomenclatura globais ou baseados em votação.\nOperação de Rota Restrita Desenvolvido por: mihi\nI2PTunnel é a principal interface da camada cliente que permite proxy TCP anônimo. Ele suporta:\nTúneis cliente (saída para destinos I2P) Cliente HTTP (eepproxy) para domínios \u0026ldquo;.i2p\u0026rdquo; Túneis servidor (entrada do I2P para um serviço local) Túneis servidor HTTP (proxy seguro de serviços web) O outproxying (para a Internet regular) é opcional, implementado por túneis \u0026ldquo;servidor\u0026rdquo; operados por voluntários.\nI2PSnark Desenvolvido por: jrandom, et al — portado de Snark Incluído com I2P, I2PSnark é um cliente BitTorrent anônimo multi-torrent com suporte a DHT e UDP, acessível através de uma interface web.\nTor Desenvolvido por: postman, susi23, mastiejaner\nI2Pmail fornece email anônimo através de conexões I2PTunnel. Susimail é um cliente baseado na web construído especificamente para prevenir vazamentos de informação comuns em clientes de email tradicionais. O serviço mail.i2p possui filtragem de vírus, quotas de hashcash e separação de outproxy para proteção adicional.\n","description":"Introdução técnica à arquitetura e operação do I2P","id":"75218044125880755dabbc53c9ce4b06","section":"docs","title":"I2P: Uma estrutura escalável para comunicação anônima","url":"/pt/docs/overview/tech-intro/"},{"categories":null,"content":"Documentação da API I2PControl I2PControl é uma API JSON-RPC 2.0 incluída no router I2P (desde a versão 0.9.39). Ela permite monitoramento e controle autenticado do router através de requisições JSON estruturadas.\nSenha padrão: itoopie — esta é a senha de fábrica e deve ser alterada imediatamente por segurança.\n1. Visão Geral e Acesso Implementation Default Endpoint Protocol Enabled by Default Notes Java I2P (2.10.0+) http://127.0.0.1:7657/jsonrpc/ HTTP ❌ Must be enabled via WebApps (Router Console) Bundled webapp i2pd (C++ implementation) https://127.0.0.1:7650/ HTTPS ✅ Enabled by default Legacy plugin behavior No caso do I2P Java, você deve ir para **Console do Router → WebApps → I2PControl** e habilitá-lo (configurar para iniciar automaticamente). Uma vez ativo, todos os métodos exigem que você primeiro se autentique e receba um token de sessão. 2. Formato JSON-RPC Todas as requisições seguem a estrutura JSON-RPC 2.0:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;MethodName\u0026#34;, \u0026#34;params\u0026#34;: { /* named parameters */ } } Uma resposta bem-sucedida inclui um campo result; em caso de falha, um objeto error é retornado:\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { /* data */ } } ou\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;error\u0026#34;: { \u0026#34;code\u0026#34;: -32001, \u0026#34;message\u0026#34;: \u0026#34;Invalid password\u0026#34; } } 3. Fluxo de Autenticação Solicitação (Autenticar) curl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;Authenticate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;API\u0026#34;: 1, \u0026#34;Password\u0026#34;: \u0026#34;itoopie\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Resposta Bem-Sucedida { \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;API\u0026#34;: 1 } } Você deve incluir esse Token em todas as solicitações subsequentes nos params.\n4. Métodos e Endpoints 4.1 RouterInfo Obtém telemetria chave sobre o router.\nExemplo de Requisição\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterInfo\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.version\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.status\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.tunnels.participating\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.inbound.1s\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;i2p.router.net.bw.outbound.1s\u0026#34;: \u0026#34;\u0026#34; } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Campos de Resposta (result) De acordo com a documentação oficial (GetI2P): - i2p.router.status (String) — um status legível - i2p.router.uptime (long) — milissegundos (ou string para i2pd mais antigo) :contentReference[oaicite:0]{index=0} - i2p.router.version (String) — string de versão :contentReference[oaicite:1]{index=1} - i2p.router.net.bw.inbound.1s, i2p.router.net.bw.inbound.15s (double) — largura de banda de entrada em B/s :contentReference[oaicite:2]{index=2} - i2p.router.net.bw.outbound.1s, i2p.router.net.bw.outbound.15s (double) — largura de banda de saída em B/s :contentReference[oaicite:3]{index=3} - i2p.router.net.status (long) — código de status numérico (veja enum abaixo) :contentReference[oaicite:4]{index=4} - i2p.router.net.tunnels.participating (long) — número de tunnels participantes :contentReference[oaicite:5]{index=5} - i2p.router.netdb.activepeers, fastpeers, highcapacitypeers (long) — estatísticas de peers do netDB :contentReference[oaicite:6]{index=6} - i2p.router.netdb.isreseeding (boolean) — se o reseed está ativo :contentReference[oaicite:7]{index=7} - i2p.router.netdb.knownpeers (long) — total de peers conhecidos :contentReference[oaicite:8]{index=8}\nEnumeração de Código de Status (i2p.router.net.status) Code Meaning 0 OK 1 TESTING 2 FIREWALLED 3 HIDDEN 4 WARN_FIREWALLED_AND_FAST 5 WARN_FIREWALLED_AND_FLOODFILL 6 WARN_FIREWALLED_WITH_INBOUND_TCP 7 WARN_FIREWALLED_WITH_UDP_DISABLED 8 ERROR_I2CP 9 ERROR_CLOCK_SKEW 10 ERROR_PRIVATE_TCP_ADDRESS 11 ERROR_SYMMETRIC_NAT 12 ERROR_UDP_PORT_IN_USE 13 ERROR_NO_ACTIVE_PEERS_CHECK_CONNECTION_AND_FIREWALL 14 ERROR_UDP_DISABLED_AND_TCP_UNSET --- 4.2 GetRate Usado para obter métricas de taxa (por exemplo, largura de banda, sucesso de túnel) durante uma janela de tempo específica.\nExemplo de Requisição\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GetRate\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Stat\u0026#34;: \u0026#34;bw.combined\u0026#34;, \u0026#34;Period\u0026#34;: 60000 } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Resposta de Exemplo\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Rate\u0026#34;: 12345.67 } } 4.3 RouterManager Executar ações administrativas.\nParâmetros / métodos permitidos - Restart, RestartGraceful - Shutdown, ShutdownGraceful - Reseed, FindUpdates, Update :contentReference[oaicite:10]{index=10}\nExemplo de Requisição\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;RouterManager\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Restart\u0026#34;: true } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Resposta Bem-Sucedida\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Restart\u0026#34;: null } } 4.4 ConfiguraçãoDeRede Obter ou definir parâmetros de configuração de rede (portas, upnp, compartilhamento de largura de banda, etc.)\nExemplo de Requisição (obter valores atuais)\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;NetworkSetting\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;i2p.router.net.ntcp.port\u0026#34;: null, \u0026#34;i2p.router.net.ssu.port\u0026#34;: null, \u0026#34;i2p.router.net.bw.share\u0026#34;: null, \u0026#34;i2p.router.net.upnp\u0026#34;: null } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Exemplo de Resposta\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;i2p.router.net.ntcp.port\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;i2p.router.net.ssu.port\u0026#34;: \u0026#34;5678\u0026#34;, \u0026#34;i2p.router.net.bw.share\u0026#34;: \u0026#34;50\u0026#34;, \u0026#34;i2p.router.net.upnp\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;SettingsSaved\u0026#34;: true, \u0026#34;RestartNeeded\u0026#34;: false } } Nota: versões do i2pd anteriores à 2.41 podem retornar tipos numéricos em vez de strings — os clientes devem lidar com ambos. :contentReference[oaicite:11]{index=11}\n4.5 Configurações Avançadas Permite manipular parâmetros internos do router.\nExemplo de Requisição\ncurl -s -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;AdvancedSettings\u0026#34;, \u0026#34;params\u0026#34;: { \u0026#34;Token\u0026#34;: \u0026#34;a1b2c3d4e5\u0026#34;, \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } }\u0026#39; \\ http://127.0.0.1:7657/jsonrpc/ Exemplo de Resposta\n{ \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;result\u0026#34;: { \u0026#34;Set\u0026#34;: { \u0026#34;router.sharePercentage\u0026#34;: \u0026#34;75\u0026#34;, \u0026#34;i2np.flushInterval\u0026#34;: \u0026#34;6000\u0026#34; } } } 5. Códigos de Erro Além dos erros JSON-RPC padrão (-32700, -32600, etc.), o I2PControl define:\nCode Meaning -32001 Invalid password -32002 Missing token -32003 Token does not exist -32004 Token expired -32005 API version missing -32006 API version unsupported --- 6. Uso e Melhores Práticas Sempre inclua o parâmetro Token (exceto ao autenticar). Altere a senha padrão (itoopie) no primeiro uso. Para Java I2P, certifique-se de que a webapp I2PControl esteja habilitada via WebApps. Esteja preparado para pequenas variações: alguns campos podem ser números ou strings, dependendo da versão do I2P. Quebre strings de status longas para uma saída amigável à exibição. ","description":"API de gerenciamento remoto de router através da webapp I2PControl","id":"f0e7aa57ce714931128f06f6bdb94db3","section":"docs","title":"I2PControl JSON-RPC","url":"/pt/docs/api/i2pcontrol/"},{"categories":null,"content":"Visão Geral I2PTunnel é um componente central do I2P para interface e fornecimento de serviços na rede I2P. Ele permite que aplicações baseadas em TCP e streaming de mídia operem anonimamente através de abstração de túnel. O destino de um túnel pode ser definido por um hostname , Base32 , ou uma chave de destino completa.\nCada tunnel estabelecido escuta localmente (por exemplo, localhost:port) e conecta-se internamente aos destinos I2P. Para hospedar um serviço, crie um tunnel apontando para o IP e porta desejados. Uma chave de destino I2P correspondente é gerada, permitindo que o serviço se torne globalmente acessível dentro da rede I2P. A interface web do I2PTunnel está disponível em I2P Router Tunnel Manager .\nServiços Padrão Túnel de servidor I2P Webserver – Um tunnel para um servidor web Jetty em localhost:7658 para hospedagem fácil no I2P. Unix: $HOME/.i2p/eepsite/docroot Windows: %LOCALAPPDATA%\\I2P\\I2P Site\\docroot → C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\I2P\\I2P Site\\docroot Túneis de cliente I2P HTTP Proxy – localhost:4444 – Usado para navegar na I2P e na Internet através de outproxies. I2P HTTPS Proxy – localhost:4445 – Variante segura do proxy HTTP. Irc2P – localhost:6668 – Tunnel padrão da rede IRC anônima. Git SSH (gitssh.idk.i2p) – localhost:7670 – Client tunnel para acesso SSH a repositórios. Postman SMTP – localhost:7659 – Client tunnel para envio de e-mail. Postman POP3 – localhost:7660 – Client tunnel para recebimento de e-mail. Nota: Apenas o Webserver I2P é um túnel de servidor padrão; todos os outros são túneis de cliente que se conectam a serviços I2P externos.\nConfiguração A especificação de configuração do I2PTunnel está documentada em /spec/configuration .\nModos de Cliente Padrão Abre uma porta TCP local que se conecta a um serviço em um destino I2P. Suporta múltiplas entradas de destino separadas por vírgulas para redundância.\nHTTP Um túnel proxy para requisições HTTP/HTTPS. Suporta outproxies locais e remotos, remoção de cabeçalhos, cache, autenticação e compressão transparente.\nProteções de privacidade: - Remove cabeçalhos: Accept-*, Referer, Via, From - Substitui cabeçalhos de host por destinos Base32 - Aplica remoção hop-by-hop conforme RFC - Adiciona suporte para descompressão transparente - Fornece páginas de erro internas e respostas localizadas\nComportamento de compressão: - Requisições podem usar cabeçalho personalizado X-Accept-Encoding: x-i2p-gzip - Respostas com Content-Encoding: x-i2p-gzip são descomprimidas transparentemente - Compressão avaliada por tipo MIME e comprimento da resposta para eficiência\nPersistência (novo desde 2.5.0): HTTP Keepalive e conexões persistentes agora são suportados para serviços hospedados no I2P através do Hidden Services Manager. Isso reduz a latência e a sobrecarga de conexão, mas ainda não habilita sockets persistentes totalmente compatíveis com RFC 2616 em todos os saltos.\nPipelining: Permanece sem suporte e desnecessário; navegadores modernos o descontinuaram.\nComportamento do User-Agent: - Outproxy: Usa um User-Agent atual do Firefox ESR. - Interno: MYOB/6.66 (AN/ON) para consistência de anonimato.\nCliente IRC Conecta-se a servidores IRC baseados em I2P. Permite um subconjunto seguro de comandos enquanto filtra identificadores para privacidade.\nSOCKS 4/4a/5 Fornece capacidade de proxy SOCKS para conexões TCP. UDP permanece não implementado no Java I2P (apenas no i2pd).\nCONECTAR Implementa tunelamento HTTP CONNECT para conexões SSL/TLS.\nStreamr Habilita streaming estilo UDP via encapsulamento baseado em TCP. Suporta streaming de mídia quando emparelhado com um túnel servidor Streamr correspondente.\nModos de Servidor Servidor Padrão Cria um destino TCP mapeado para um IP:porta local.\nServidor HTTP Cria um destino que se conecta com um servidor web local. Suporta compressão (x-i2p-gzip), remoção de cabeçalhos e proteções contra DDoS. Agora beneficia-se de suporte a conexões persistentes (v2.5.0+) e otimização de pool de threads (v2.7.0–2.9.0).\nHTTP Bidirecional Descontinuado – Ainda funcional mas desencorajado. Atua como servidor e cliente HTTP sem outproxying. Utilizado principalmente para testes de diagnóstico em loopback.\nServidor IRC Cria um destino filtrado para serviços IRC, passando as chaves de destino do cliente como nomes de host.\nServidor Streamr Combina-se com um túnel cliente Streamr para manipular fluxos de dados no estilo UDP sobre I2P.\nNovos Recursos (2.4.0–2.10.0) Feature Introduced Summary Keepalive/Persistent Connections 2.5.0 HTTP tunnels now support persistent sockets for I2P-hosted services, improving performance. Thread Pooling Optimization 2.7.0-2.9.0 Reduced CPU overhead and latency by improving thread management. Post-Quantum Encryption (ML-KEM) 2.10.0 Optional hybrid X25519+ML-KEM encryption to resist future quantum attacks. NetDB Segmentation 2.4.0 Isolates I2PTunnel contexts for improved security and privacy. SSU1 Removal / SSU2 Adoption 2.4.0-2.6.0 Upgraded transport layer; transparent to users. I2P-over-Tor Blocking 2.6.0 Prevents inefficient and unstable I2P-over-Tor routing. Browser Proxy (Proposal 166) 2.7.0 Introduced identity-aware proxy mode; details pending confirmation. Java 17 Requirement (upcoming) 2.11.0 Future release will require Java 17+. --- Recursos de Segurança Remoção de cabeçalhos para anonimato (Accept, Referer, From, Via) Randomização do User-Agent dependendo do in/outproxy Limitação de taxa de POST e proteção contra Slowloris Controle de conexões nos subsistemas de streaming Tratamento de congestionamento de rede na camada de tunnel Isolamento do NetDB prevenindo vazamentos entre aplicações Detalhes Técnicos Tamanho padrão da chave de destino: 516 bytes (pode exceder para certificados LS2 estendidos) Endereços Base32: {52–56+ chars}.b32.i2p Túneis de servidor permanecem compatíveis com Java I2P e i2pd Recurso descontinuado: apenas httpbidirserver; nenhuma remoção desde 0.9.59 Verificadas portas padrão corretas e raízes de documentos para todas as plataformas Resumo I2PTunnel permanece a espinha dorsal da integração de aplicações com I2P. Entre 0.9.59 e 2.10.0, ganhou suporte a conexões persistentes, criptografia pós-quântica e grandes melhorias no gerenciamento de threads. A maioria das configurações permanece compatível, mas os desenvolvedores devem verificar suas configurações para garantir conformidade com os padrões modernos de transporte e segurança.\n","description":"Ferramenta para interagir e fornecer serviços na I2P","id":"7e5d426e3eead28c1767764107b1f3d1","section":"docs","title":"I2PTunnel","url":"/pt/docs/api/i2ptunnel/"},{"categories":null,"content":" Status legado: Este conteúdo é mantido apenas para referência histórica. Ele documenta o sistema de tunnels que foi distribuído antes do I2P 0.6.1.10 e não deve ser usado para desenvolvimento moderno. Consulte a implementação atual para orientações de produção.\nO subsistema de tunnel original também usava tunnels unidirecionais, mas diferia no formato das mensagens, na detecção de duplicados e na estratégia de construção. Muitas seções abaixo espelham a estrutura do documento descontinuado para facilitar a comparação.\n1. Visão geral do Tunnel Os tunnels eram construídos como sequências ordenadas de pares selecionados pelo criador. Os comprimentos dos tunnels variavam de 0–7 saltos, com vários ajustes para padding (preenchimento), throttling (limitação de taxa) e geração de chaff (tráfego falso). Os tunnels de entrada entregavam mensagens de um gateway não confiável ao criador (ponto final); os tunnels de saída direcionavam os dados para longe do criador. A vida útil dos tunnels era de 10 minutos; depois disso, novos tunnels eram construídos (frequentemente usando os mesmos pares, mas IDs de tunnel diferentes). 2. Operação no Design Legado 2.1 Pré-processamento de mensagens Os gateways acumularam ≤32 KB de carga útil I2NP, selecionaram o preenchimento e produziram uma carga útil contendo:\nUm campo de comprimento de preenchimento de dois bytes e o mesmo número de bytes aleatórios Uma sequência de pares {instructions, I2NP message} descrevendo destinos de entrega, fragmentação e atrasos opcionais Mensagens I2NP completas preenchidas até um limite de 16 bytes As instruções de entrega compactavam as informações de roteamento em campos de bits (tipo de entrega, flags de atraso, flags de fragmentação e extensões opcionais). Mensagens fragmentadas incluíam um ID de mensagem de 4 bytes, além de uma flag de índice/último fragmento.\n2.2 Criptografia no Gateway O design legado fixava o comprimento do tunnel em oito saltos para a fase de criptografia. Os gateways aplicavam camadas de AES-256/CBC mais blocos de soma de verificação, de modo que cada salto pudesse verificar a integridade sem reduzir a carga útil. A própria soma de verificação era um bloco derivado de SHA-256 incorporado na mensagem.\n2.3 Comportamento dos Participantes Os participantes rastreavam os IDs de tunnel de entrada, verificavam a integridade logo no início e descartavam duplicatas antes de encaminhar. Como o preenchimento e os blocos de verificação estavam incorporados, o tamanho da mensagem permanecia constante, independentemente do número de saltos.\n2.4 Processamento do ponto de extremidade Os pontos de extremidade descriptografaram os blocos em camadas sequencialmente, validaram as somas de verificação e separaram a carga útil novamente em instruções codificadas e mensagens I2NP para entrega posterior.\n3. Criação de tunnel (processo obsoleto) Seleção de pares: Os pares eram escolhidos a partir de perfis mantidos localmente (exploratório vs. cliente). O documento original já enfatizava a mitigação do ataque do predecessor ao reutilizar listas ordenadas de pares por pool de tunnel. Entrega de solicitações: As mensagens de construção eram encaminhadas salto a salto, com seções criptografadas para cada par. Ideias alternativas, como telescopic extension (extensão telescópica), midstream rerouting (reroteamento em meio ao fluxo) ou a remoção de blocos de checksum, foram discutidas como experimentos, mas nunca adotadas. Agrupamento: Cada destino local mantinha pools separados de entrada e de saída. As configurações incluíam quantidade desejada, tunnels de reserva, variação de comprimento, limitação de taxa e políticas de padding (preenchimento). 4. Conceitos de Limitação e Mixagem O texto antigo propôs várias estratégias que orientaram lançamentos posteriores:\nDescarte Antecipado Aleatório Ponderado (WRED) para controle de congestionamento Limitações de taxa por tunnel baseadas em médias móveis do uso recente Controles opcionais de chaff (tráfego de enchimento) e batching (agrupamento em lotes) (não totalmente implementados) 5. Alternativas Arquivadas Seções do documento original exploravam ideias que nunca foram implementadas:\nRemover blocos de checksum para reduzir o processamento por salto Aplicar telescoping (construção incremental) de tunnels no meio do fluxo para alterar a composição dos pares Adotar tunnels bidirecionais (acabou sendo rejeitado) Usar hashes mais curtos ou diferentes regimes de padding Essas ideias continuam sendo um contexto histórico valioso, mas não refletem a base de código moderna.\nReferências Arquivo original de documentos legados (pré-0.6.1.10) Visão geral de Tunnel para a terminologia atual Perfilamento e seleção de pares para heurísticas modernas ","description":"Descrição arquivada do projeto do tunnel utilizado antes do I2P 0.6.1.10.","id":"0970f5387a965fe6857e4afbb03bdc8f","section":"docs","title":"Implementação antiga do Tunnel (Legado)","url":"/pt/docs/legacy/old-implementation/"},{"categories":null,"content":"Incluir o I2P com sua aplicação é uma forma poderosa de integrar usuários—mas apenas se o router estiver configurado de forma responsável.\n1. Coordenar com as Equipes de Router Contacte os mantenedores do Java I2P e i2pd antes de empacotar. Eles podem revisar suas configurações padrão e destacar questões de compatibilidade. Escolha a implementação de router que se adequa à sua stack: Java/Scala → Java I2P C/C++ → i2pd Outras linguagens → empacote um router e integre usando SAM v3 ou I2CP Verifique os termos de redistribuição para binários do router e dependências (runtime Java, ICU, etc.). 2. Padrões de Configuração Recomendados Busque \u0026ldquo;contribuir mais do que consumir.\u0026rdquo; Os padrões modernos priorizam a saúde e estabilidade da rede.\nSetting Recommended Default (2025) Bandwidth share 80% for participating tunnels Tunnel quantities i2pd: 3 inbound / 3 outbound; Java I2P: 2 inbound / 2 outbound. Signature \u0026amp; encryption Use Ed25519 (SIGNATURE_TYPE=7) and advertise ECIES-X25519 + ElGamal (i2cp.leaseSetEncType=4,0). Client protocols Use SAM v3 or I2CP. API listeners Bind SAM/I2CP to 127.0.0.1 only. Disable if not needed. UI toggles Expose bandwidth controls, logs, and an opt-in checkbox for participating tunnels. ### Túneis Participantes Permanecem Essenciais Não desative os túneis de participação.\nRoteadores que não retransmitem têm pior desempenho. A rede depende do compartilhamento voluntário de capacidade. Tráfego de cobertura (tráfego retransmitido) melhora o anonimato. Mínimos oficiais: - Largura de banda compartilhada: ≥ 12 KB/s - Ativação automática de floodfill: ≥ 128 KB/s - Recomendado: 2 túneis de entrada / 2 túneis de saída (padrão do Java I2P)\n3. Persistência e Reseeding Diretórios de estado persistente (netDb/, perfis, certificados) devem ser preservados entre execuções.\nSem persistência, seus usuários vão acionar reseeds a cada inicialização—degradando o desempenho e aumentando a carga nos servidores de reseed.\nSe a persistência for impossível (por exemplo, contêineres ou instalações efêmeras):\nInclua 1.000–2.000 router infos no instalador. Opere um ou mais servidores de reseed personalizados para desafogar os públicos. Variáveis de configuração: - Diretório base: i2p.dir.base - Diretório de configuração: i2p.dir.config - Inclui certificates/ para reseed (ressemeadura).\n4. Segurança e Exposição Mantenha o console do router (127.0.0.1:7657) apenas local. Use HTTPS se expor a UI externamente. Desative SAM/I2CP externo a menos que necessário. Revise os plugins incluídos—distribua apenas o que sua aplicação suporta. Sempre inclua autenticação para acesso remoto ao console. Recursos de segurança introduzidos desde a versão 2.5.0: - Isolamento de NetDB entre aplicações (2.4.0+) - Mitigação de DoS e listas de bloqueio Tor (2.5.1) - Resistência a sondagem NTCP2 (2.9.0) - Melhorias na seleção de roteadores floodfill (2.6.0+)\n5. APIs Suportadas (2025) API Status Notes SAM v3 (3.3) ✅ Active Recommended bridge for non-Java apps. I2CP ✅ Active Stable protocol core, used internally by Java I2P. I2PControl ✅ Active JSON-RPC API; plugin maintained. BOB ⚠️ Deprecated Removed from Java I2P since 1.7.0; use SAM v3 instead. Toda a documentação oficial está localizada em `/docs/api/` — o caminho antigo `/spec/samv3/` **não** existe. 6. Redes e Portas Portas padrão típicas: - 4444 – Proxy HTTP - 4445 – Proxy HTTPS - 7654 – I2CP - 7656 – SAM Bridge - 7657 – Console do Router - 7658 – Site I2P local - 6668 – Proxy IRC - 9000–31000 – Porta aleatória do router (UDP/TCP entrada)\nOs roteadores selecionam uma porta de entrada aleatória na primeira execução. O encaminhamento melhora o desempenho, mas o UPnP pode lidar com isso automaticamente.\n7. Mudanças Modernas (2024–2025) Change Status Details SSU1 Transport Removed SSU2 is now the exclusive UDP transport. I2P-over-Tor Blocked Since 2.6.0 (July 2024). Datagram2/3 Added Authenticated, repliable datagram formats (2.9.0). LeaseSet service records Added Enables service discovery (Proposal 167). Tunnel build parameters Improved Adaptive congestion handling (2.9.0+). Post-quantum crypto Introduced (beta) ML-KEM hybrid ratchet, opt-in from 2.10.0. Java 17 requirement Announced Becomes mandatory in 2.11.0 (early 2026). ## 8. Experiência do Usuário e Testes Comunicar o que o I2P faz e por que a largura de banda é compartilhada. Fornecer diagnósticos do router (largura de banda, tunnels, status de reseed). Testar pacotes no Windows, macOS e Linux (incluindo baixa RAM). Verificar interoperabilidade com peers do Java I2P e i2pd. Testar recuperação de quedas de rede e saídas abruptas. 9. Recursos da Comunidade Fórum: i2pforum.net ou http://i2pforum.i2p dentro do I2P. Código: i2pgit.org/I2P_Developers/i2p.i2p . IRC (rede Irc2P): #i2p-dev, #i2pd. #i2papps não verificado; pode não existir. Esclareça qual rede (Irc2P vs ilita.i2p) hospeda seu canal. Incorporar de forma responsável significa equilibrar a experiência do usuário, o desempenho e a contribuição para a rede. Use esses padrões, mantenha-se sincronizado com os mantenedores do router e teste sob carga real antes do lançamento.\n","description":"Orientação prática atualizada para incluir um roteador I2P com sua aplicação de forma responsável","id":"f67f27efbc9bb7bff8d34001c14105ff","section":"docs","title":"Incorporando I2P na Sua Aplicação","url":"/pt/docs/applications/embedding/"},{"categories":null,"content":"O projeto I2P mantém pacotes oficiais para Debian, Ubuntu e suas distribuições derivadas. Este guia fornece instruções abrangentes para instalar o I2P usando nossos repositórios oficiais.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\n🚀 Beta: Instalação Automática (Experimental) Para usuários avançados que desejam uma instalação automatizada rápida:\nEste comando único detectará automaticamente sua distribuição e instalará o I2P. Use com cautela - revise o script de instalação antes de executar.\ncurl -fsSL https://i2p.net/installlinux.sh | sudo bash O que isto faz: - Detecta a sua distribuição Linux (Ubuntu/Debian) - Adiciona o repositório I2P apropriado - Instala as chaves GPG e os pacotes necessários - Instala o I2P automaticamente\n⚠️ Este é um recurso beta. Se preferir a instalação manual ou quiser entender cada etapa, use os métodos de instalação manual abaixo.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nPlataformas Suportadas Os pacotes Debian são compatíveis com:\nUbuntu 18.04 (Bionic) e mais recente Linux Mint 19 (Tara) e mais recente Debian Buster (10) e mais recente Knoppix Outras distribuições baseadas em Debian (LMDE, ParrotOS, Kali Linux, etc.) Arquiteturas suportadas: amd64, i386, armhf, arm64, powerpc, ppc64el, s390x\nOs pacotes I2P podem funcionar em outros sistemas baseados em Debian não explicitamente listados acima. Se você encontrar problemas, por favor reporte-os em nosso GitLab .\nMétodos de Instalação Escolha o método de instalação que corresponde à sua distribuição:\nOpção 1: Ubuntu e derivados (Linux Mint, elementary OS, Pop!_OS, etc.) Opção 2: Debian e distribuições baseadas em Debian (incluindo LMDE, Kali, ParrotOS) IMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nInstalação no Ubuntu Ubuntu e seus derivados oficiais (Linux Mint, elementary OS, Trisquel, etc.) podem usar o PPA (Personal Package Archive) do I2P para instalação fácil e atualizações automáticas.\nMethod 1: Command Line Installation (Recommended) Este é o método mais rápido e confiável para instalar o I2P em sistemas baseados em Ubuntu.\nPasso 1: Adicionar o PPA do I2P\nAbra um terminal e execute:\nsudo apt-add-repository ppa:i2p-maintainers/i2p Este comando adiciona o PPA do I2P a /etc/apt/sources.list.d/ e importa automaticamente a chave GPG que assina o repositório. A assinatura GPG garante que os pacotes não foram adulterados desde que foram compilados.\nPasso 2: Atualizar a lista de pacotes\nAtualize a base de dados de pacotes do seu sistema para incluir o novo PPA:\nsudo apt-get update Isso recupera as informações mais recentes dos pacotes de todos os repositórios habilitados, incluindo o PPA do I2P que você acabou de adicionar.\nPasso 3: Instalar o I2P\nAgora instale o I2P:\nsudo apt-get install i2p É isso! Pule para a seção Configuração Pós-Instalação para aprender como iniciar e configurar o I2P.\nMethod 2: Using the Software Center GUI Se você preferir uma interface gráfica, pode adicionar o PPA usando a Central de Programas do Ubuntu.\nPasso 1: Abrir Software e Atualizações\nInicie \u0026ldquo;Software e Atualizações\u0026rdquo; a partir do seu menu de aplicativos.\nPasso 2: Navegue para Outros Programas\nSelecione a aba \u0026ldquo;Outro Software\u0026rdquo; e clique no botão \u0026ldquo;Adicionar\u0026rdquo; na parte inferior para configurar um novo PPA.\nPasso 3: Adicionar o PPA do I2P\nNa caixa de diálogo PPA, insira:\nppa:i2p-maintainers/i2p Passo 4: Recarregar informações do repositório\nClique no botão \u0026ldquo;Reload\u0026rdquo; para baixar as informações atualizadas do repositório.\nPasso 5: Instalar o I2P\nAbra a aplicação \u0026ldquo;Software\u0026rdquo; do seu menu de aplicações, procure por \u0026ldquo;i2p\u0026rdquo; e clique em Instalar.\nAssim que a instalação for concluída, prossiga para Configuração Pós-Instalação .\nDebian Installation Debian e suas distribuições derivadas (LMDE, Kali Linux, ParrotOS, Knoppix, etc.) devem usar o repositório oficial I2P Debian em deb.i2p.net.\nImportant Notice Nossos repositórios antigos em deb.i2p2.de e deb.i2p2.no estão descontinuados. Se você está usando esses repositórios legados, siga as instruções abaixo para migrar para o novo repositório em deb.i2p.net.\nPrerequisites Todos os passos abaixo requerem acesso root. Alterne para o usuário root com su, ou adicione o prefixo sudo a cada comando.\nMétodo 1: Instalação por Linha de Comando (Recomendado) Passo 1: Instalar os pacotes necessários\nCertifique-se de ter as ferramentas necessárias instaladas:\nsudo apt-get update sudo apt-get install apt-transport-https lsb-release curl Estes pacotes permitem acesso seguro ao repositório via HTTPS, detecção de distribuição e downloads de arquivos.\nPasso 2: Adicionar o repositório I2P\nO comando que você usa depende da sua versão do Debian. Primeiro, determine qual versão você está executando:\ncat /etc/debian_version Faça referência cruzada com as informações de lançamento do Debian para identificar o codinome da sua distribuição (ex.: Bookworm, Bullseye, Buster).\nPara Debian Bullseye (11) ou mais recente:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Para derivados do Debian (LMDE, Kali, ParrotOS, etc.) no Bullseye-equivalente ou mais recente:\necho \u0026#34;deb [signed-by=/usr/share/keyrings/i2p-archive-keyring.gpg] https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Para Debian Buster (10) ou mais antigo:\necho \u0026#34;deb https://deb.i2p.net/ $(lsb_release -sc) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Para derivados do Debian equivalentes ao Buster ou mais antigos:\necho \u0026#34;deb https://deb.i2p.net/ $(dpkg --status tzdata | grep Provides | cut -f2 -d\u0026#39;-\u0026#39;) main\u0026#34; \\ | sudo tee /etc/apt/sources.list.d/i2p.list Passo 3: Baixar a chave de assinatura do repositório\ncurl -o i2p-archive-keyring.gpg https://geti2p.net/_static/i2p-archive-keyring.gpg Passo 4: Verificar a impressão digital da chave\nAntes de confiar na chave, verifique se sua impressão digital corresponde à chave de assinatura oficial do I2P:\ngpg --keyid-format long --import --import-options show-only --with-fingerprint i2p-archive-keyring.gpg Verifique se a saída mostra esta impressão digital:\n7840 E761 0F28 B904 7535 49D7 67EC E560 5BCF 1346 ⚠️ Não prossiga se a impressão digital não corresponder. Isso pode indicar um download comprometido.\nPasso 5: Instalar a chave do repositório\nCopie o keyring verificado para o diretório de keyrings do sistema:\nsudo cp i2p-archive-keyring.gpg /usr/share/keyrings Apenas para Debian Buster ou versões anteriores, você também precisa criar um link simbólico:\nsudo ln -sf /usr/share/keyrings/i2p-archive-keyring.gpg /etc/apt/trusted.gpg.d/i2p-archive-keyring.gpg Passo 6: Atualizar listas de pacotes\nAtualize a base de dados de pacotes do seu sistema para incluir o repositório I2P:\nsudo apt-get update Passo 7: Instalar o I2P\nInstale tanto o router I2P quanto o pacote keyring (que garante que você receberá futuras atualizações de chaves):\nsudo apt-get install i2p i2p-keyring Ótimo! O I2P está agora instalado. Continue para a seção Configuração Pós-Instalação .\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nPost-Installation Configuration Após instalar o I2P, você precisará iniciar o router e realizar algumas configurações iniciais.\nMétodo 2: Usando a Interface Gráfica da Central de Software Os pacotes I2P fornecem três formas de executar o router I2P:\nOption 1: On-Demand (Basic) Inicie o I2P manualmente quando necessário usando o script i2prouter:\ni2prouter start Importante: Não use sudo ou execute isso como root! O I2P deve ser executado como seu usuário regular.\nPara parar o I2P:\ni2prouter stop Option 2: On-Demand (Without Java Service Wrapper) Se você estiver em um sistema não-x86 ou o Java Service Wrapper não funcionar na sua plataforma, use:\ni2prouter-nowrapper Novamente, não use sudo ou execute como root.\nOption 3: System Service (Recommended) Para a melhor experiência, configure o I2P para iniciar automaticamente quando o sistema inicializar, mesmo antes do login:\nsudo dpkg-reconfigure i2p Isso abre uma caixa de diálogo de configuração. Selecione \u0026ldquo;Sim\u0026rdquo; para ativar o I2P como um serviço do sistema.\nEste é o método recomendado porque: - O I2P inicia automaticamente na inicialização - Seu router mantém melhor integração com a rede - Você contribui para a estabilidade da rede - O I2P está disponível imediatamente quando você precisar\nInitial Router Configuration Após iniciar o I2P pela primeira vez, levará alguns minutos para integrar na rede. Enquanto isso, configure estas definições essenciais:\n1. Configure NAT/Firewall Para desempenho ideal e participação na rede, encaminhe as portas I2P através do seu NAT/firewall:\nAbra o Console do Router I2P Navegue até a página de Configuração de Rede Anote os números de porta listados (geralmente portas aleatórias entre 9000-31000) Encaminhe essas portas UDP e TCP no seu roteador/firewall Se você precisar de ajuda com encaminhamento de portas, portforward.com fornece guias específicos para roteadores.\n2. Adjust Bandwidth Settings As configurações padrão de largura de banda são conservadoras. Ajuste-as com base na sua conexão de internet:\nVisite a página de Configuração Encontre a seção de configurações de largura de banda Os padrões são 96 KB/s de download / 40 KB/s de upload Aumente esses valores se você tiver internet mais rápida (por exemplo, 250 KB/s de download / 100 KB/s de upload para uma conexão banda larga típica) Nota: Definir limites mais altos ajuda a rede e melhora o seu próprio desempenho.\n3. Configure Your Browser Para aceder a sites I2P (eepsites) e serviços, configure o seu navegador para utilizar o proxy HTTP do I2P:\nConsulte nosso Guia de Configuração de Navegador para instruções detalhadas de configuração para Firefox, Chrome e outros navegadores.\nInstalação no Debian Aviso Importante Certifique-se de que não está a executar o I2P como root: ps aux | grep i2p Verifique os logs: tail -f ~/.i2p/wrapper.log Verifique se o Java está instalado: java -version Pré-requisitos Se você receber erros de chave GPG durante a instalação:\nFaça o download novamente e verifique a impressão digital da chave (Passos 3-4 acima) Certifique-se de que o arquivo keyring possui as permissões corretas: sudo chmod 644 /usr/share/keyrings/i2p-archive-keyring.gpg Passos de Instalação Se o I2P não estiver recebendo atualizações:\nVerifique se o repositório está configurado: cat /etc/apt/sources.list.d/i2p.list Atualize as listas de pacotes: sudo apt-get update Verifique se há atualizações do I2P: sudo apt-get upgrade Migrating from old repositories Se você está usando os antigos repositórios deb.i2p2.de ou deb.i2p2.no:\nRemova o repositório antigo: sudo rm /etc/apt/sources.list.d/i2p.list Siga os passos de Instalação no Debian acima Atualize: sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install i2p i2p-keyring IMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nNext Steps Agora que o I2P está instalado e em execução:\nConfigure seu navegador para acessar sites I2P Explore o console do router I2P para monitorar seu router Conheça as aplicações I2P que você pode usar Leia sobre como o I2P funciona para entender a rede Bem-vindo à Internet Invisível!\n","description":"Guia completo para instalar o I2P no Debian, Ubuntu e seus derivados usando repositórios oficiais","id":"88fb5f6d2f5129ce7be2a42b1e9fb9af","section":"docs","title":"Instalando o I2P no Debian e Ubuntu","url":"/pt/docs/guides/instalando-o-i2p-no-debian-e-ubuntu/"},{"categories":null,"content":"O Que Você Vai Precisar Um Mac executando macOS 10.14 (Mojave) ou posterior Acesso de administrador para instalar aplicativos Cerca de 15-20 minutos de tempo Conexão à internet para baixar os instaladores Visão Geral Este processo de instalação tem quatro etapas principais:\nInstalar Java - Baixe e instale o Oracle Java Runtime Environment Instalar I2P - Baixe e execute o instalador do I2P Configurar Aplicativo I2P - Configure o launcher e adicione ao seu dock Configurar Largura de Banda do I2P - Execute o assistente de configuração para otimizar sua conexão Parte Um: Instalar Java O I2P requer Java para funcionar. Se você já tem o Java 8 ou posterior instalado, pode pular para a Parte Dois .\nStep 1: Download Java Visite a página de download do Oracle Java e baixe o instalador para macOS do Java 8 ou posterior.\nStep 2: Run the Installer Localize o arquivo .dmg baixado na sua pasta Downloads e clique duas vezes para abri-lo.\nStep 3: Allow Installation O macOS pode exibir um aviso de segurança porque o instalador é de um desenvolvedor identificado. Clique em Abrir para continuar.\nPasso 1: Baixar o Java Clique em Install para iniciar o processo de instalação do Java.\nPasso 2: Execute o Instalador O instalador copiará os arquivos e configurará o Java no seu sistema. Isso geralmente leva de 1 a 2 minutos.\nPasso 3: Permitir a Instalação Quando você ver a mensagem de sucesso, o Java está instalado! Clique em Fechar para finalizar.\nPart Two: Download and Install I2P Agora que o Java está instalado, você pode instalar o router I2P.\nPasso 4: Instalar o Java Visite a página de Downloads e baixe o instalador I2P para Unix/Linux/BSD/Solaris (o arquivo .jar).\nPasso 5: Aguarde a Instalação Clique duas vezes no arquivo i2pinstall_X.X.X.jar baixado. O instalador será iniciado e solicitará que você selecione seu idioma preferido.\nPasso 6: Instalação Concluída Leia a mensagem de boas-vindas e clique em Next para continuar.\nStep 4: Important Notice O instalador exibirá um aviso importante sobre atualizações. As atualizações do I2P são assinadas ponta a ponta e verificadas, embora o próprio instalador não seja assinado. Clique em Próximo.\nPasso 1: Baixar o I2P Leia o acordo de licença do I2P (licença estilo BSD). Clique em Próximo para aceitar.\nPasso 2: Execute o Instalador Escolha onde instalar o I2P. A localização padrão (/Applications/i2p) é recomendada. Clique em Próximo.\nPasso 3: Tela de Boas-Vindas Deixe todos os componentes selecionados para uma instalação completa. Clique em Next.\nPasso 4: Aviso Importante Revise suas escolhas e clique em Next para começar a instalar o I2P.\nPasso 5: Acordo de Licença O instalador copiará os arquivos do I2P para o seu sistema. Isso leva cerca de 1-2 minutos.\nPasso 6: Selecionar Diretório de Instalação O instalador cria scripts de lançamento para iniciar o I2P.\nPasso 7: Selecionar Componentes O instalador oferece a criação de atalhos na área de trabalho e entradas no menu. Faça suas seleções e clique em Avançar.\nPasso 8: Iniciar a Instalação Sucesso! O I2P está agora instalado. Clique em Concluído para finalizar.\nPart Three: Configure I2P App Agora vamos facilitar o lançamento do I2P adicionando-o à sua pasta Aplicações e ao Dock.\nPasso 9: Instalando Arquivos Abra o Finder e navegue até a sua pasta Aplicações.\nPasso 10: Gerar Scripts de Inicialização Procure a pasta I2P ou a aplicação Start I2P Router dentro de /Applications/i2p/.\nPasso 11: Atalhos de Instalação Arraste o aplicativo Start I2P Router para o seu Dock para facilitar o acesso. Você também pode criar um alias na sua área de trabalho.\nDica: Clique com o botão direito no ícone do I2P no Dock e selecione Opções → Manter no Dock para torná-lo permanente.\nPart Four: Configure I2P Bandwidth Quando você iniciar o I2P pela primeira vez, passará por um assistente de configuração para definir suas configurações de largura de banda. Isso ajuda a otimizar o desempenho do I2P para sua conexão.\nPasso 12: Instalação Concluída Clique no ícone I2P no seu Dock (ou clique duas vezes no lançador). Seu navegador web padrão abrirá o Console do Router I2P.\nStep 2: Welcome Wizard O assistente de configuração irá cumprimentá-lo. Clique em Next para começar a configurar o I2P.\nPasso 1: Abrir a Pasta de Aplicativos Selecione seu idioma de interface preferido e escolha entre o tema claro ou escuro. Clique em Próximo.\nPasso 2: Encontrar o Lançador I2P O assistente explicará o teste de largura de banda. Este teste conecta ao serviço M-Lab para medir a velocidade da sua internet. Clique em Avançar para prosseguir.\nPasso 3: Adicionar ao Dock Clique em Run Test para medir suas velocidades de upload e download. O teste leva cerca de 30-60 segundos.\nStep 6: Test Results Revise os resultados do seu teste. O I2P recomendará configurações de largura de banda com base na velocidade da sua conexão.\nPasso 1: Iniciar o I2P Escolha quanta largura de banda você deseja compartilhar com a rede I2P:\nAutomático (Recomendado): O I2P gerencia a largura de banda com base no seu uso Limitado: Defina limites específicos de upload/download Ilimitado: Compartilhe o máximo possível (para conexões rápidas) Clique em Next para salvar suas configurações.\nPasso 2: Assistente de Boas-vindas O seu router I2P está agora configurado e em execução! A consola do router mostrará o estado da sua conexão e permitirá navegar em sites I2P.\nGetting Started with I2P Agora que o I2P está instalado e configurado, você pode:\nNavegue por sites I2P: Visite a página inicial do I2P para ver links para serviços populares do I2P Configure seu navegador: Configure um perfil de navegador para acessar sites .i2p Explore serviços: Confira email I2P, fóruns, compartilhamento de arquivos e muito mais Monitore seu router: O console mostra o status da sua rede e estatísticas Passo 3: Idioma e Tema Router Console: http://127.0.0.1:7657/ Configuração: http://127.0.0.1:7657/config Catálogo de Endereços: http://127.0.0.1:7657/susidns/addressbook Configurações de Largura de Banda: http://127.0.0.1:7657/config Re-running the Setup Wizard Se você quiser alterar suas configurações de largura de banda ou reconfigurar o I2P posteriormente, você pode executar novamente o assistente de boas-vindas a partir do Router Console:\nVá para o Assistente de Configuração do I2P Siga os passos do assistente novamente Troubleshooting Passo 4: Informações do Teste de Largura de Banda Verificar Java: Certifique-se de que o Java está instalado executando java -version no Terminal Verificar permissões: Garanta que a pasta do I2P tenha as permissões corretas Verificar logs: Consulte ~/.i2p/wrapper.log para mensagens de erro Passo 5: Executar Teste de Largura de Banda Certifique-se de que o I2P está em execução (verifique o Router Console) Configure as definições de proxy do seu navegador para usar o proxy HTTP 127.0.0.1:4444 Aguarde 5-10 minutos após iniciar para o I2P se integrar à rede Passo 6: Resultados dos Testes Execute o teste de largura de banda novamente e ajuste suas configurações Certifique-se de que você está compartilhando alguma largura de banda com a rede Verifique o status da sua conexão no Router Console Parte Dois: Baixar e Instalar o I2P Para remover o I2P do seu Mac:\nEncerre o roteador I2P se estiver em execução Exclua a pasta /Applications/i2p Exclua a pasta ~/.i2p (sua configuração e dados do I2P) Remova o ícone do I2P do seu Dock Next Steps Junte-se à comunidade: Visite i2pforum.net ou confira o I2P no Reddit Saiba mais: Leia a documentação do I2P para entender como a rede funciona Envolva-se: Considere contribuir para o desenvolvimento do I2P ou executar infraestrutura Parabéns! Agora você faz parte da rede I2P. Bem-vindo à internet invisível!\n","description":"Guia passo a passo para instalar manualmente o I2P e suas dependências no macOS","id":"f88100195c365b18735e1ea12826a97e","section":"docs","title":"Instalando o I2P no macOS (O Caminho Longo)","url":"/pt/docs/guides/instalando-o-i2p-no-macos-o-caminho-longo/"},{"categories":null,"content":"Escolha o Seu Método de Instalação Existem duas maneiras de instalar o I2P no Windows. Escolha o método que melhor se adapta às suas necessidades:\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um título ou pareça incompleto, traduza-o como está.\n🚀 Easy Install Bundle (Recommended) Melhor para a maioria dos usuários\n✅ Instalador completo ✅ Java incluído (sem instalação separada) ✅ Perfis do Firefox incluídos ✅ Configuração mais rápida\nEscolha esta opção se: - Você quer a instalação mais simples - Você não tem Java instalado - Você é novo no I2P\nGuia de Instalação Fácil →\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\n🚀 Pacote de Instalação Fácil (Recomendado) Para usuários avançados\n📦 Instalador JAR baseado em Java 🔧 Mais controle sobre a instalação 💾 Tamanho de download menor\nEscolha esta opção se: - Você já tem o Java instalado - Você quer mais controle - Você prefere o método tradicional\nGuia de Instalação Padrão →\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nEasy Install Bundle ⚙️ Instalação Padrão O I2P Easy Install Bundle é o método de instalação recomendado para usuários Windows. Este instalador tudo-em-um inclui tudo o que você precisa para começar a usar o I2P:\nI2P Router - O software central do I2P Embedded Java Runtime - Nenhuma instalação separada de Java necessária Perfis e extensões do Firefox - Perfis e extensões de navegador otimizados para I2P para navegação segura Instalador simples - Nenhuma configuração manual necessária Atualizações automáticas - Mantenha seu software I2P atualizado Este instalador beta simplifica o processo de instalação ao incluir o Java diretamente, para que você não precise baixar ou configurar o Java separadamente.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nStep 1: Select Your Language Após iniciar o instalador do Easy Install Bundle, você será recebido com a tela de seleção de idioma.\nEscolha o seu idioma preferido no menu suspenso Os idiomas disponíveis incluem inglês, alemão, espanhol, francês e muitos outros Clique em OK para continuar A interface do instalador usará o idioma selecionado para todas as etapas subsequentes.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um título ou pareça incompleto, traduza-o como está.\nPacote de Instalação Fácil Em seguida, você verá as informações sobre a licença do I2P. O Easy Install Bundle inclui componentes sob várias licenças livres e de código aberto.\nPara continuar a instalação: 1. Revise as informações de licença (opcional, mas recomendado) 2. Clique em Eu Concordo para aceitar as licenças e prosseguir 3. Clique em Cancelar se não desejar instalar\nStep 3: Choose Installation Folder Agora você selecionará onde instalar o I2P no seu computador.\nOpções de instalação:\nUse o local padrão (recomendado)\nCaminho padrão: C:\\Users\\[YourUsername]\\AppData\\Local\\I2peasy\\ Isso instala o I2P no diretório do seu perfil de usuário Não requer privilégios de administrador para atualizações Escolha um local personalizado\nClique em Procurar\u0026hellip; para selecionar uma pasta diferente Útil se você quiser instalar em uma unidade diferente Certifique-se de que você tem permissões de escrita na pasta selecionada Requisitos de espaço: - O instalador mostra quanto espaço é necessário (tipicamente menos de 1 GB) - Verifique se você tem espaço livre suficiente disponível na unidade selecionada\nClique em Instalar para iniciar o processo de instalação O instalador irá agora copiar todos os ficheiros necessários para a localização escolhida. Isto pode demorar alguns minutos.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um título ou pareça incompleto, traduza-o como está.\nPasso 1: Selecione o Seu Idioma Assim que a instalação terminar, você verá a tela de conclusão.\nO assistente de configuração confirma que \u0026ldquo;I2P - i2peasy foi instalado no seu computador.\u0026rdquo;\nImportante: Certifique-se de que a caixa de seleção \u0026ldquo;Iniciar o I2P?\u0026rdquo; esteja marcada (ela deve estar marcada por padrão).\nMarcado (recomendado): O I2P será iniciado automaticamente quando você clicar em Concluir Desmarcado: Você precisará iniciar o I2P manualmente mais tarde a partir do Menu Iniciar ou atalho na área de trabalho Clique em Concluir para completar a instalação e iniciar o I2P.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um título ou pareça incompleto, traduza-o como está.\nPasso 2: Aceitar o Contrato de Licença Após clicar em Finalizar com \u0026ldquo;Iniciar I2P?\u0026rdquo; marcado:\nO Router I2P inicia - O router I2P começa a executar em segundo plano Ícone da bandeja do sistema aparece - Procure pelo ícone do I2P na bandeja do sistema do Windows (canto inferior direito) Console do router abre - Seu navegador web padrão abrirá automaticamente no Console do Router I2P (normalmente em http://127.0.0.1:7657) Conexão inicial - O I2P começará a conectar-se à rede e construir tunnels (isso pode levar de 5 a 10 minutos na primeira execução) Parabéns! O I2P está agora instalado e em execução no seu computador Windows.\nPasso 3: Escolher Pasta de Instalação Embora não seja estritamente necessário, o encaminhamento de portas melhora significativamente sua experiência com I2P ao permitir que seu router se comunique de forma mais eficaz com outros routers I2P. Sem o encaminhamento de portas, você ainda poderá usar o I2P, mas com desempenho reduzido e menor contribuição para a rede.\nWhy Forward a Port? Melhor conectividade: Permite conexões de entrada de outros roteadores I2P Integração mais rápida: Ajuda você a integrar-se à rede mais rapidamente Contribuição para a rede: Torna você um participante melhor na rede I2P Desempenho aprimorado: Geralmente resulta em melhor confiabilidade e velocidade dos túneis O que é o Easy Install Bundle? Primeiro, você precisa identificar qual porta o I2P está usando (ela é atribuída aleatoriamente por padrão).\nLocalize o ícone do I2P na bandeja do sistema do Windows (área de notificação) no canto inferior direito da sua tela Clique com o botão direito no ícone do I2P para abrir o menu de contexto Clique em \u0026ldquo;Launch I2P Browser\u0026rdquo; para abrir o console do router I2P O menu também mostra opções úteis como: - Network: Firewalled - Mostra o status atual da sua rede - Configure I2P System Tray - Personalizar configurações do ícone da bandeja - Stop I2P / Stop I2P Immediately - Opções de desligamento\nFinding Your Port Numbers Assim que o navegador I2P abrir, você precisa verificar quais portas o I2P está usando:\nNavegue até a página de configuração de rede:\nAcesse Configuração de Rede do Router I2P no seu navegador Ou através da barra lateral do console do router: Configuração → Rede Role para baixo até a seção de configuração de portas\nAnote os números de porta exibidos: Configuração UDP: - Porta UDP: A porta mostrada aqui (exemplo: 13697) - Por padrão, está configurada como \u0026ldquo;Especificar Porta\u0026rdquo; com um número atribuído aleatoriamente\nConfiguração TCP: - Porta TCP acessível externamente: Normalmente configurada para usar a mesma porta que UDP - No exemplo acima: \u0026ldquo;Usar a mesma porta configurada para UDP (atualmente 13697)\u0026rdquo;\nImportante: Você precisa encaminhar tanto UDP quanto TCP no mesmo número de porta (neste exemplo, porta 13697) no seu roteador/firewall.\nHow to Forward Your Port Como cada router e firewall é diferente, não podemos fornecer instruções universais. No entanto, portforward.com possui guias detalhados para milhares de modelos de routers:\nVisite portforward.com Selecione o fabricante e modelo do seu roteador Siga o guia passo a passo para encaminhar sua porta Encaminhe ambos os protocolos UDP e TCP no número de porta exibido na sua configuração I2P Passos gerais (varia por router): - Faça login na interface de administração do seu router (geralmente em 192.168.1.1 ou 192.168.0.1) - Encontre a seção \u0026ldquo;Encaminhamento de Portas\u0026rdquo; ou \u0026ldquo;Servidores Virtuais\u0026rdquo; - Crie uma nova regra de encaminhamento de porta para o número da sua porta I2P - Configure ambos os protocolos UDP e TCP - Direcione a regra para o endereço IP local do seu computador - Salve a configuração\nApós encaminhar sua porta, o I2P deve mudar de \u0026ldquo;Network: Firewalled\u0026rdquo; para \u0026ldquo;Network: OK\u0026rdquo; no menu da bandeja do sistema (isso pode levar alguns minutos).\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nPasso 4: Completar a Instalação e Iniciar o I2P Aguarde a integração: Dê ao I2P de 5 a 10 minutos para se integrar à rede e construir tunnels Configure seu navegador: Use o perfil incluído do Firefox para navegação I2P Encaminhe sua porta: Consulte portforward.com para instruções específicas do seu roteador sobre como encaminhar a porta que o I2P está usando Explore o console do router: Aprenda sobre os recursos, serviços e opções de configuração do I2P Visite eepsites: Tente acessar sites .i2p através da rede I2P Leia a documentação: Confira a documentação do I2P para mais informações Bem-vindo à rede I2P! 🎉\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nO Que Acontece a Seguir What is the Standard Installation? A instalação padrão do I2P é o método tradicional de instalar o I2P no Windows. Ao contrário do Easy Install Bundle, este método requer que você:\nInstale o Java separadamente - Faça o download e instale o Java Runtime Environment (JRE) antes de instalar o I2P Execute o instalador JAR - Use o instalador gráfico baseado em Java Configure manualmente - Defina as configurações do navegador você mesmo (opcional) Este método é recomendado para: - Usuários que já têm o Java instalado - Usuários avançados que desejam mais controle sobre a instalação - Usuários que preferem o método de instalação tradicional - Sistemas onde o Easy Install Bundle não é compatível\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nRecomendado: Encaminhamento de Portas (Opcional mas Importante) Antes de instalar o I2P, você precisa ter o Java instalado no seu sistema.\nJava Requirements Versão do Java: Java 8 (1.8) ou superior necessário Recomendado: Java 11 ou posterior (versão LTS) Tipo: Java Runtime Environment (JRE) ou Java Development Kit (JDK) Installing Java Se você ainda não tem o Java instalado, pode baixá-lo de várias fontes:\nOpção 1: Oracle Java - Fonte oficial: java.com/download - Distribuição mais amplamente utilizada\nOpção 2: OpenJDK - Implementação de código aberto: openjdk.org - Gratuito e de código aberto\nOpção 3: Adoptium (Eclipse Temurin) - Alternativa recomendada: adoptium.net - Lançamentos LTS gratuitos, de código aberto e bem mantidos\nPara verificar se o Java está instalado: 1. Abra o Prompt de Comando (pressione Windows + R, digite cmd, pressione Enter) 2. Digite: java -version 3. Você deverá ver uma saída mostrando a sua versão do Java\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um título ou pareça incompleto, traduza-o como está.\nStep 1: Install Java Antes de instalar o I2P, você precisa instalar o Java no seu sistema.\nEscolha uma distribuição Java:\nOracle Java: java.com/download OpenJDK: openjdk.org Adoptium: adoptium.net Baixe o instalador do Windows para a distribuição escolhida\nExecute o instalador e siga as instruções de instalação\nVerifique a instalação:\nAbra o Prompt de Comando Digite java -version e pressione Enter Confirme que o Java 8 ou superior está instalado Depois de instalar o Java, você está pronto para instalar o I2P.\nStep 2: Download and Launch the I2P Installer Baixe o instalador do I2P:\nVisite a página de downloads do I2P Baixe o instalador para Windows (arquivo JAR): i2pinstall_X.X.X.jar Salve-o em um local de fácil acesso (por exemplo, pasta Downloads) Inicie o instalador:\nClique duas vezes no arquivo JAR baixado para iniciar o instalador Se clicar duas vezes não funcionar, clique com o botão direito no arquivo e selecione \u0026ldquo;Abrir com → Java(TM) Platform SE binary\u0026rdquo; Como alternativa, abra o Prompt de Comando e execute: java -jar i2pinstall_X.X.X.jar Step 3: Select Your Language Após executar o instalador, você verá a caixa de diálogo de Seleção de Idioma.\nSelecione o seu idioma preferido no menu suspenso Os idiomas disponíveis incluem inglês, alemão, espanhol, francês e muitos outros Clique em OK para continuar O instalador usará o idioma selecionado para todos os passos subsequentes.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nStep 4: Welcome to I2P Installation Este é o Passo 1 de 8 no processo de instalação.\nClique em Next para continuar com a instalação.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nPróximos Passos Este é o Passo 2 de 8 no processo de instalação.\nClique em Avançar para aceitar a licença e continuar.\nInstalação Padrão Escolha onde você deseja instalar o I2P no seu computador.\nCaminho de instalação padrão: C:\\Program Files (x86)\\i2p\\\nVocê pode: - Usar a localização padrão (recomendado) - Clicar em Procurar\u0026hellip; para selecionar uma pasta diferente\nEste é o Passo 3 de 8 no processo de instalação.\nClique em Próximo para continuar.\nNota: Se esta é a primeira vez que instala o I2P, verá um popup a confirmar a criação do diretório:\nClique em OK para criar o diretório de instalação.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nStep 7: Select Installation Packs Escolha quais componentes instalar.\nImportante: Certifique-se de que ambos os pacotes estão selecionados: - Base (obrigatório) - Software principal do I2P (27.53 MB) - Windows Service (recomendado) - Inicia o I2P automaticamente na inicialização do sistema\nA opção Windows Service garante que o I2P inicie automaticamente quando o seu computador inicializa, para que você não precise iniciá-lo manualmente todas as vezes.\nEste é o Passo 4 de 8 no processo de instalação.\nClique em Next para continuar.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nPré-requisitos O instalador irá agora copiar os arquivos para o seu sistema.\nVocê verá duas barras de progresso: - Progresso da instalação do pacote: Mostra o pacote atual sendo instalado - Progresso geral da instalação: Mostra o progresso geral (por exemplo, \u0026ldquo;2 / 2\u0026rdquo;)\nEste é o Passo 5 de 8 do processo de instalação.\nAguarde a conclusão da instalação e clique em Próximo.\nStep 9: Setup Shortcuts Configure onde você deseja que os atalhos do I2P sejam criados.\nOpções de atalhos: - ✓ Criar atalhos no Menu Iniciar (recomendado) - ✓ Criar atalhos adicionais na área de trabalho (opcional)\nGrupo de Programas: Selecione ou crie um nome de pasta para os atalhos - Padrão: I2P - Você pode escolher um grupo de programas existente ou criar um novo\nCriar atalho para: - Usuário atual - Apenas você pode acessar os atalhos - Todos os usuários - Todos os usuários do sistema podem acessar os atalhos (requer privilégios de administrador)\nEste é o Passo 6 de 8 no processo de instalação.\nClique em Next para continuar.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nStep 10: Installation Complete A instalação está concluída!\nVocê verá: - ✓ A instalação foi concluída com sucesso - Um desinstalador será criado em: C:\\Program Files (x86)\\i2p\\Uninstaller\nEste é o Passo 8 de 8 - o passo final no processo de instalação.\nClique em Concluído para finalizar.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um título ou pareça incompleto, traduza-o como está.\nPasso 1: Instalar Java Depois de clicar em Concluído:\nO Router I2P inicia - Se você instalou o Serviço do Windows, o I2P iniciará automaticamente O console do router abre - Seu navegador web padrão abrirá o Console do Router I2P em http://127.0.0.1:7657 Conexão inicial - O I2P começará a conectar-se à rede e construir tunnels (isso pode levar de 5 a 10 minutos na primeira execução) Parabéns! O I2P está agora instalado no seu computador Windows.\nPasso 2: Baixar e Executar o Instalador do I2P Se o I2P não iniciar automaticamente, ou se você precisar iniciá-lo manualmente no futuro, você tem duas opções:\nOption 1: Start Menu Abra o Menu Iniciar do Windows Navegue até a pasta I2P Escolha uma das opções de inicialização: I2P router console - Abre o console do router no seu navegador Start I2P (no window) - Inicia o I2P silenciosamente em segundo plano Start I2P (restartable) - Inicia o I2P com capacidade de reinicialização automática Você também pode acessar a Pasta de Perfil Aberta do I2P (serviço) para visualizar os arquivos de configuração do I2P.\nPor que Encaminhar uma Porta? Pressione Windows + R para abrir o diálogo Executar Digite services.msc e pressione Enter Role para baixo para encontrar I2P Service Clique com o botão direito em I2P Service e selecione: Iniciar - Inicia o serviço I2P Parar - Para o serviço I2P Reiniciar - Reinicia o serviço I2P Propriedades - Configura as definições do serviço (tipo de inicialização, etc.) O método de Serviços do Windows é útil para gerenciar o I2P como um serviço em segundo plano, especialmente se você o instalou como um Serviço do Windows.\nIMPORTANTE: NÃO faça perguntas, forneça explicações ou adicione qualquer comentário. Mesmo que o texto seja apenas um cabeçalho ou pareça incompleto, traduza-o como está.\nPasso 3: Selecione o Seu Idioma Aguarde a integração: Dê ao I2P 5-10 minutos para se integrar à rede e construir túneis (tunnels) Configure o encaminhamento de portas: Consulte o guia de encaminhamento de portas para instruções Configure seu navegador: Configure seu navegador web para usar o proxy HTTP do I2P Explore o console do router: Conheça os recursos, serviços e opções de configuração do I2P Visite eepsites: Experimente acessar sites .i2p através da rede I2P Leia a documentação: Confira a documentação do I2P para mais informações Bem-vindo à rede I2P! 🎉\n","description":"Escolha o seu método de instalação para Windows: Pacote de Instalação Fácil ou Instalação Padrão","id":"4aa0b74199a71c11718a9986e74b3a26","section":"docs","title":"Instalando o I2P no Windows","url":"/pt/docs/guides/instalando-o-i2p-no-windows/"},{"categories":null,"content":"O framework de plugins do I2P permite que você estenda o router sem tocar na instalação principal. Os plugins disponíveis cobrem e-mail, blogs, IRC, armazenamento, wikis, ferramentas de monitoramento e muito mais.\nNota de segurança: Os plugins são executados com as mesmas permissões do router. Trate downloads de terceiros da mesma forma que trataria qualquer atualização de software assinada—verifique a fonte antes de instalar.\n1. Instalar um Plugin Copie o URL de download do plugin da página do projeto.\nAbra a página de Configuração de Plugins do console do router.\nCole o URL no campo de instalação e clique em Install Plugin.\nO router obtém o arquivo assinado, verifica a assinatura e ativa o plugin imediatamente. A maioria dos plugins adiciona links no console ou serviços em segundo plano sem exigir uma reinicialização do router.\n2. Por Que os Plugins São Importantes Distribuição com um clique para utilizadores finais—sem edições manuais em wrapper.config ou clients.config Mantém o pacote central i2pupdate.su3 pequeno enquanto fornece funcionalidades grandes ou de nicho sob demanda JVMs opcionais por plugin fornecem isolamento de processos quando necessário Verificações automáticas de compatibilidade com a versão do router, runtime Java e Jetty Mecanismo de atualização espelha o router: pacotes assinados e downloads incrementais Integrações na consola, pacotes de idiomas, temas de UI e aplicações não-Java (via scripts) são todos suportados Permite diretórios de \u0026ldquo;loja de aplicações\u0026rdquo; curados como plugins.i2p 3. Gerenciar Plugins Instalados Use os controles no Plugin do Roteador I2P para:\nVerificar atualizações de um único plugin Verificar todos os plugins de uma vez (acionado automaticamente após atualizações do router) Instalar quaisquer atualizações disponíveis com um clique\nAtivar/desativar início automático para plugins que registram serviços Desinstalar plugins de forma limpa 4. Construa Seu Próprio Plugin Revise a especificação de plugin para requisitos de empacotamento, assinatura e metadados. Use makeplugin.sh para empacotar um binário ou webapp existente em um arquivo instalável. Publique URLs tanto de instalação quanto de atualização para que o router possa distinguir instalações iniciais de atualizações incrementais. Forneça checksums e chaves de assinatura de forma destacada na página do seu projeto para ajudar os usuários a verificar a autenticidade. Procurando exemplos? Navegue pelo código-fonte dos plugins da comunidade em plugins.i2p (por exemplo, o exemplo snowman).\n5. Limitações Conhecidas Atualizar um plugin que fornece arquivos JAR simples pode exigir uma reinicialização do router porque o carregador de classes Java mantém classes em cache. O console pode exibir um botão Parar mesmo que o plugin não tenha nenhum processo ativo. Plugins lançados em uma JVM separada criam um diretório logs/ no diretório de trabalho atual. Na primeira vez que uma chave de assinante aparece, ela é automaticamente confiável; não há autoridade central de assinatura. O Windows às vezes deixa diretórios vazios para trás após desinstalar um plugin. Instalar um plugin exclusivo para Java 6 em uma JVM Java 5 reporta \u0026ldquo;plugin está corrompido\u0026rdquo; devido à compressão Pack200. Plugins de tema e tradução permanecem amplamente não testados. Flags de início automático nem sempre persistem para plugins não gerenciados. 6. Requisitos e Melhores Práticas O suporte a plugins está disponível no I2P 0.7.12 e versões mais recentes. Mantenha seu router e plugins atualizados para receber correções de segurança. Distribua notas de lançamento concisas para que os usuários entendam o que muda entre versões. Quando possível, hospede arquivos de plugin via HTTPS dentro do I2P para minimizar a exposição de metadados na clearnet. 7. Leitura Adicional Especificação de plugin Framework de aplicação cliente Repositório de scripts I2P para utilitários de empacotamento ","description":"Instalando, atualizando e desenvolvendo plugins de roteador","id":"f8687b90431c32a8ee7e10be9f7c44e0","section":"docs","title":"Instalando Plugins Personalizados","url":"/pt/docs/guides/plugins/"},{"categories":null,"content":"O que é o I2P? O Invisible Internet Project (I2P) é uma camada de rede anônima que permite comunicação peer-to-peer resistente à censura. Conexões anônimas são alcançadas através da criptografia do tráfego do usuário e seu envio através de uma rede distribuída operada por voluntários ao redor do mundo.\nFuncionalidades Principais Anonymity O I2P oculta tanto o remetente quanto o destinatário das mensagens. Ao contrário das conexões tradicionais de internet onde seu endereço IP fica visível para sites e serviços, o I2P usa múltiplas camadas de criptografia e roteamento para manter sua identidade privada.\nDecentralization Não há autoridade central no I2P. A rede é mantida por voluntários que doam largura de banda e recursos computacionais. Isso a torna resistente à censura e a pontos únicos de falha.\nAnonimato Todo o tráfego dentro do I2P é criptografado ponta a ponta. As mensagens são criptografadas múltiplas vezes conforme passam pela rede, semelhante a como o Tor funciona, mas com diferenças importantes na implementação.\nHow It Works Descentralização O I2P usa \u0026ldquo;tunnels\u0026rdquo; para rotear o tráfego. Quando você envia ou recebe dados:\nSeu roteador cria um túnel de saída (para envio) Seu roteador cria um túnel de entrada (para recebimento) Mensagens são criptografadas e enviadas através de múltiplos roteadores Cada roteador conhece apenas o salto anterior e o próximo, não o caminho completo Criptografia Ponta a Ponta I2P aprimora o roteamento em cebola tradicional com \u0026ldquo;garlic routing\u0026rdquo;:\nMúltiplas mensagens podem ser agrupadas juntas (como dentes em um bulbo de alho) Isso proporciona melhor desempenho e anonimato adicional Torna a análise de tráfego mais difícil Network Database I2P mantém uma base de dados de rede distribuída contendo:\nInformações do roteador Endereços de destino (semelhante aos websites .i2p) Dados de roteamento criptografados Common Use Cases Túneis Hospede ou visite sites que terminam em .i2p - estes são acessíveis apenas dentro da rede I2P e fornecem fortes garantias de anonimato tanto para os anfitriões quanto para os visitantes.\nRoteamento Garlic Compartilhe arquivos anonimamente usando BitTorrent sobre I2P. Muitos aplicativos de torrent têm suporte I2P integrado.\nBase de Dados da Rede Envie e receba e-mails anônimos usando I2P-Bote ou outras aplicações de e-mail projetadas para I2P.\nMessaging Use IRC, mensagens instantâneas ou outras ferramentas de comunicação de forma privada através da rede I2P.\nGetting Started Pronto para experimentar o I2P? Confira nossa página de downloads para instalar o I2P no seu sistema.\nPara mais detalhes técnicos, consulte a Introdução Técnica ou explore a documentação completa.\nComo Funciona Introdução Técnica - Conceitos técnicos mais profundos Modelo de Ameaças - Compreendendo o modelo de segurança do I2P Comparação com Tor - Como o I2P difere do Tor Criptografia - Detalhes sobre os algoritmos criptográficos do I2P ","description":"Uma introdução menos técnica à rede anônima I2P","id":"b4dafae75d4a04b2eac73ebf531f1d1b","section":"docs","title":"Introdução ao I2P","url":"/pt/docs/overview/intro/"},{"categories":null,"content":"Visão Geral Pontos-chave\nO I2P fornece criptografia ponta a ponta para o tráfego IRC através de seus túneis. Desative SSL/TLS nos clientes IRC, a menos que você esteja usando outproxy para a clearnet. O túnel cliente Irc2P pré-configurado escuta em 127.0.0.1:6668 por padrão. Conecte seu cliente IRC a esse endereço e porta. Não use o termo \u0026ldquo;TLS fornecido pelo router.\u0026rdquo; Use \u0026ldquo;criptografia nativa do I2P\u0026rdquo; ou \u0026ldquo;criptografia ponta a ponta.\u0026rdquo; Início rápido (Java I2P) Abra o Hidden Services Manager em http://127.0.0.1:7657/i2ptunnel/ e certifique-se de que o túnel Irc2P está em execução. No seu cliente IRC, defina servidor = 127.0.0.1, porta = 6668, SSL/TLS = desativado. Conecte-se e entre em canais como #i2p, #i2p-dev, #i2p-help. Para usuários do i2pd (router em C++), crie um túnel cliente no tunnels.conf (veja os exemplos abaixo).\nRedes e servidores IRC2P (main community network) Servidores federados: irc.postman.i2p:6667, irc.echelon.i2p:6667, irc.dg.i2p:6667. O túnel Irc2P em 127.0.0.1:6668 conecta-se automaticamente a um destes. Canais típicos: #i2p, #i2p-chat, #i2p-dev, #i2p-help. Ilita network Servidores: irc.ilita.i2p:6667, irc.r4sas.i2p:6667, irc.acetone.i2p:6667, rusirc.ilita.i2p:6667. Idiomas principais: Russo e Inglês. Interfaces web existem em alguns hosts. Client setup Recommended, actively maintained WeeChat (terminal) — forte suporte a SOCKS; fácil de programar. Pidgin (desktop) — ainda mantido; funciona bem no Windows/Linux. Thunderbird Chat (desktop) — suportado no ESR 128+. The Lounge (auto-hospedado web) — cliente web moderno. IRC2P (rede comunitária principal) LimeChat (gratuito, código aberto). Textual (pago na App Store; código-fonte disponível para compilação). Rede Ilita WeeChat via SOCKS5 /proxy add i2p socks5 127.0.0.1 4447 /set irc.server.i2p.addresses \u0026#34;127.0.0.1/6668\u0026#34; /set irc.server.i2p.proxy \u0026#34;i2p\u0026#34; /connect i2p Pidgin Protocolo: IRC Servidor: 127.0.0.1 Porta: 6668 Criptografia: desativada Nome de usuário/apelido: qualquer Thunderbird Chat Tipo de conta: IRC Servidor: 127.0.0.1 Porta: 6668 SSL/TLS: desativado Opcional: entrar automaticamente em canais ao conectar Dispatch (SAM v3) Exemplo de valores padrão do config.toml:\n[defaults] name = \u0026#34;Irc2P\u0026#34; host = \u0026#34;irc.postman.i2p\u0026#34; port = 6667 channels = [\u0026#34;#i2p\u0026#34;,\u0026#34;#i2p-dev\u0026#34;] ssl = false Tunnel configuration Java I2P defaults Túnel cliente Irc2P: 127.0.0.1:6668 → servidor upstream na porta 6667. Gerenciador de Serviços Ocultos: http://127.0.0.1:7657/i2ptunnel/. Recomendado, mantido ativamente ~/.i2pd/tunnels.conf:\n[IRC-IRC2P] type = client address = 127.0.0.1 port = 6668 destination = irc.postman.i2p destinationport = 6667 keys = irc-keys.dat Túnel separado para Ilita (exemplo):\n[IRC-ILITA] type = client address = 127.0.0.1 port = 6669 destination = irc.ilita.i2p destinationport = 6667 keys = irc-ilita-keys.dat Opções para macOS Ative o SAM no I2P Java (desativado por padrão) em /configclients ou clients.config. Padrões: 127.0.0.1:7656/TCP e 127.0.0.1:7655/UDP. Criptografia recomendada: SIGNATURE_TYPE=7 (Ed25519) e i2cp.leaseSetEncType=4,0 (ECIES‑X25519 com fallback ElGamal) ou apenas 4 para somente modernos. Configurações de exemplo Padrão do Java I2P: 2 de entrada / 2 de saída. Padrão do i2pd: 5 de entrada / 5 de saída. Para IRC: 2–3 de cada é suficiente; configure explicitamente para comportamento consistente entre routers. Configuração do cliente Não ative SSL/TLS para conexões IRC internas do I2P. O I2P já fornece criptografia ponta a ponta. TLS adicional aumenta sobrecarga sem ganhos de anonimato. Use chaves persistentes para identidade estável; evite regenerar chaves a cada reinicialização, a menos que esteja testando. Se múltiplas aplicações usam IRC, prefira tunnels separados (não compartilhados) para reduzir correlação entre serviços. Se você precisar permitir controle remoto (SAM/I2CP), vincule ao localhost e proteja o acesso com tunnels SSH ou proxies reversos autenticados. Alternative connection method: SOCKS5 Alguns clientes podem conectar via proxy SOCKS5 do I2P: 127.0.0.1:4447. Para melhores resultados, prefira um túnel IRC dedicado na porta 6668; SOCKS não consegue sanitizar identificadores da camada de aplicação e pode vazar informações se o cliente não foi projetado para anonimato.\nTroubleshooting Não consegue conectar — certifique-se de que o túnel Irc2P está em execução e o router está totalmente bootstrapped. Trava em resolve/join — verifique novamente se SSL está desabilitado e o cliente aponta para 127.0.0.1:6668. Alta latência — I2P tem latência mais alta por design. Mantenha as quantidades de túneis modestas (2–3) e evite loops de reconexão rápida. Usando aplicativos SAM — confirme que SAM está habilitado (Java) ou não está bloqueado por firewall (i2pd). Sessões de longa duração são recomendadas. Appendix: Ports and naming Portas comuns de túnel IRC: 6668 (padrão do Irc2P), 6667 e 6669 como alternativas. Nomes de host .b32.i2p: forma padrão de 52 caracteres; formas estendidas de 56+ caracteres existem para LS2/certificados avançados. Use nomes de host .i2p a menos que você explicitamente precise de endereços b32. ","description":"Guia completo de redes IRC I2P, clientes, túneis e configuração de servidor (atualizado 2025)","id":"f8c49a6509b36124b90dbaa1d0fbbc4b","section":"docs","title":"IRC sobre I2P","url":"/pt/docs/applications/irc/"},{"categories":null,"content":"Visão geral Este documento especifica o blinding (cegamento criptográfico), a criptografia e a descriptografia de LeaseSet2 (LS2) criptografado. LeaseSets criptografados fornecem a publicação com controle de acesso de informações de serviços ocultos no banco de dados de rede do I2P.\nPrincipais recursos: - Rotação diária de chaves para sigilo futuro - Autorização de clientes em dois níveis (baseada em DH e em PSK) - Criptografia ChaCha20 para desempenho em dispositivos sem hardware AES - Assinaturas Red25519 com cegamento de chaves - Associação de clientes com preservação de privacidade\nDocumentação relacionada: - Especificação de Estruturas Comuns - Estrutura de LeaseSet (conjunto de informações de roteamento de entrada) criptografado - Proposta 123: Novas entradas no netDB (banco de dados da rede) - Contexto sobre LeaseSets criptografados - Documentação do NetDB - Uso do NetDB\nHistórico de versões e status de implementação Linha do tempo do desenvolvimento do protocolo Nota importante sobre a numeração de versões: O I2P usa dois esquemas distintos de numeração de versões: - Versão da API/Router: série 0.9.x (usada nas especificações técnicas) - Versão de Lançamento do Produto: série 2.x.x (usada para lançamentos públicos)\nAs especificações técnicas fazem referência às versões da API (por exemplo, 0.9.41), enquanto os utilizadores finais veem as versões do produto (por exemplo, 2.10.0).\nMarcos de Implementação Version Release Date Features 0.9.38January 2019Floodfill support for standard LS2, offline keys 0.9.39March 2019Full encrypted LS2 support, Red25519 (sig type\u0026nbsp;11) 0.9.40May 2019Per-client authorization, encrypted LS2 with offline keys, B32 support 0.9.41June 2019Protocol finalized as stable 2.10.0September 2025Latest Java implementation (API version 0.9.61) i2pd 2.58.0September 2025Full C++ implementation compatibility ### Estado atual ✅ Status do protocolo: Estável e inalterado desde junho de 2019 ✅ Java I2P: Totalmente implementado a partir da versão 0.9.40+ ✅ i2pd (C++): Totalmente implementado a partir da versão 2.58.0+ ✅ Interoperabilidade: Completa entre as implementações ✅ Implantação na rede: Pronta para produção, com mais de 6 anos de experiência operacional Definições Criptográficas Notação e Convenções || denota concatenação mod L denota a redução modular pela ordem do Ed25519 Todos os arrays de bytes estão em ordem de bytes de rede (big-endian), a menos que especificado de outra forma Valores little-endian são indicados explicitamente gerador de números aleatórios criptograficamente seguro (CSRNG)(n) Gerador de números aleatórios criptograficamente seguro\nProduz n bytes de dados aleatórios criptograficamente seguros, adequados para a geração de material de chave.\nRequisitos de Segurança: - Deve ser criptograficamente seguro (adequado para a geração de chaves) - Deve ser seguro quando sequências de bytes adjacentes são expostas na rede - As implementações deveriam aplicar hash na saída proveniente de fontes potencialmente não confiáveis\nReferências: - Considerações de segurança sobre PRNG - Discussão dos desenvolvedores do Tor H(p, d) Hash SHA-256 com personalização\nFunção de hash com separação de domínios que recebe: - p: string de personalização (fornece separação de domínios) - d: dados a serem processados pelo hash\nImplementação:\nH(p, d) := SHA-256(p || d) Uso: Fornece separação de domínios criptográfica para evitar ataques de colisão entre diferentes utilizações do SHA-256 em protocolos.\nFLUXO: ChaCha20 Cifra de fluxo: ChaCha20 conforme especificado na RFC 7539 Seção 2.4\nParâmetros: - S_KEY_LEN = 32 (chave de 256 bits) - S_IV_LEN = 12 (nonce de 96 bits) - Contador inicial: 1 (A RFC 7539 permite 0 ou 1; 1 é recomendado para contextos AEAD (criptografia autenticada com dados associados))\nCIFRAR(k, iv, plaintext)\nCifra o texto em claro usando: - k: chave de cifra de 32 bytes - iv: nonce (valor único usado uma vez) de 12 bytes (DEVE ser único para cada chave) - Retorna texto cifrado do mesmo tamanho que o texto em claro\nPropriedade de segurança: Todo o texto cifrado deve ser indistinguível de dados aleatórios se a chave for secreta.\nDECIFRAR(k, iv, ciphertext)\nDescriptografa o texto cifrado usando: - k: chave de cifra de 32 bytes - iv: nonce (número usado uma vez) de 12 bytes - Retorna o texto em claro\nJustificativa de design: ChaCha20 foi escolhido em vez de AES porque: - 2.5-3x mais rápido que AES em dispositivos sem aceleração por hardware - Implementação em tempo constante mais fácil de obter - Segurança e velocidade comparáveis quando o AES-NI está disponível\nReferências: - RFC 7539 - ChaCha20 e Poly1305 para Protocolos do IETF\nAssinatura: Red25519 (variante do Ed25519 usando o esquema RedDSA) Esquema de Assinatura: Red25519 (SigType 11) com Cegamento de Chave\nRed25519 é baseado em assinaturas Ed25519 sobre a curva Ed25519, usando SHA-512 para hash, com suporte a key blinding (cegamento de chave) conforme especificado em ZCash RedDSA.\nFunções:\nDERIVE_PUBLIC(privkey) Retorna a chave pública correspondente à chave privada fornecida. - Usa a multiplicação escalar padrão do Ed25519 pelo ponto base\nSIGN(privkey, m) Retorna uma assinatura da mensagem m gerada pela chave privada privkey.\nDiferenças de assinatura do Red25519 em relação ao Ed25519: 1. Nonce aleatório: Usa 80 bytes de dados aleatórios adicionais\nT = CSRNG(80) // 80 random bytes r = H*(T || publickey || message) Isso torna cada assinatura Red25519 única, mesmo para a mesma mensagem e chave.\nGeração de chaves privadas: chaves privadas Red25519 são geradas a partir de números aleatórios e reduzidas mod L, em vez de usar a abordagem de \u0026ldquo;bit-clamping\u0026rdquo; (fixação de bits) do Ed25519. VERIFY(pubkey, m, sig) Verifica a assinatura sig contra a chave pública pubkey e a mensagem m. - Retorna true se a assinatura for válida, false caso contrário - A verificação é idêntica à de Ed25519\nOperações de Cegamento de Chaves:\nGENERATE_ALPHA(data, secret) Gera alpha para cegamento de chave. - data: Normalmente contém a chave pública de assinatura e os tipos de assinatura - secret: Segredo adicional opcional (comprimento zero se não for usado) - O resultado é distribuído de forma idêntica às chaves privadas Ed25519 (após a redução módulo L)\nBLIND_PRIVKEY(privkey, alpha) Aplica cegamento a uma chave privada utilizando o segredo alpha. - Implementação: blinded_privkey = (privkey + alpha) mod L - Usa aritmética escalar no campo\nBLIND_PUBKEY(pubkey, alpha) Cega uma chave pública usando o segredo alpha. - Implementação: blinded_pubkey = pubkey + DERIVE_PUBLIC(alpha) - Usa a adição de elementos do grupo (ponto) na curva\nPropriedade crítica:\nBLIND_PUBKEY(pubkey, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(privkey, alpha)) Considerações de segurança:\nDa Seção 5.4.6.1 da Especificação do Protocolo ZCash: Por segurança, alpha deve ter distribuição idêntica à das chaves privadas sem cegamento. Isso garante que \u0026ldquo;a combinação de uma chave pública re-randomizada e assinatura(s) sob essa chave não revela a chave a partir da qual ela foi re-randomizada.\u0026rdquo;\nTipos de assinatura suportados: - Tipo 7 (Ed25519): Suportado para destinos existentes (compatibilidade com versões anteriores) - Tipo 11 (Red25519): Recomendado para novos destinos que usam criptografia - Blinded keys (chaves cegas): Sempre use o tipo 11 (Red25519)\nReferências: - Especificação do Protocolo ZCash - Seção 5.4.6 RedDSA - Especificação Red25519 do I2P DH: X25519 Diffie-Hellman de Curva Elíptica: X25519\nSistema de acordo de chaves públicas baseado na Curve25519 (curva elíptica).\nParâmetros: - Chaves privadas: 32 bytes - Chaves públicas: 32 bytes - Saída do segredo compartilhado: 32 bytes\nFunções:\nGENERATE_PRIVATE() Gera uma nova chave privada de 32 bytes usando CSRNG (gerador de números aleatórios criptograficamente seguro).\nDERIVE_PUBLIC(privkey) Deriva a chave pública de 32 bytes a partir da chave privada fornecida. - Utiliza multiplicação escalar na Curve25519 (uma curva elíptica)\nDH(privkey, pubkey) Realiza o acordo de chaves Diffie-Hellman. - privkey: Chave privada local de 32 bytes - pubkey: Chave pública remota de 32 bytes - Retorna: Segredo compartilhado de 32 bytes\nPropriedades de Segurança: - Hipótese de Diffie-Hellman computacional na Curve25519 - Sigilo de encaminhamento quando chaves efêmeras são usadas - Implementação em tempo constante necessária para prevenir ataques de temporização\nReferências: - RFC 7748 - Curvas Elípticas para Segurança\nHKDF (função de derivação de chaves baseada em HMAC) Função de Derivação de Chaves baseada em HMAC\nExtrai e expande o material de chave a partir do material de chave de entrada.\nParâmetros: - salt: máximo de 32 bytes (normalmente 32 bytes para SHA-256) - ikm: material de chave de entrada (qualquer comprimento, deve ter boa entropia) - info: informação específica do contexto (separação de domínios) - n: comprimento da saída em bytes\nImplementação:\nUtiliza HKDF (função de derivação de chaves baseada em HMAC) conforme especificado na RFC 5869 com: - Função de hash: SHA-256 - HMAC: Conforme especificado na RFC 2104 - Comprimento do sal: Máximo de 32 bytes (HashLen para SHA-256)\nPadrão de uso:\nkeys = HKDF(salt, ikm, info, n) Separação de domínios: O parâmetro info fornece separação de domínios criptográfica entre diferentes usos do HKDF (função de derivação de chaves baseada em HMAC) no protocolo.\nValores de Informações Verificados: - \u0026quot;ELS2_L1K\u0026quot; - criptografia da camada 1 (externa) - \u0026quot;ELS2_L2K\u0026quot; - criptografia da camada 2 (interna) - \u0026quot;ELS2_XCA\u0026quot; - autorização do cliente DH - \u0026quot;ELS2PSKA\u0026quot; - autorização do cliente PSK - \u0026quot;i2pblinding1\u0026quot; - geração alfa\nReferências: - RFC 5869 - Especificação do HKDF - RFC 2104 - Especificação do HMAC\nEspecificação de Formato LS2 criptografado consiste em três camadas aninhadas:\nCamada 0 (Externa): Informações em texto claro para armazenamento e recuperação Camada 1 (Intermediária): Dados de autenticação do cliente (criptografados) Camada 2 (Interna): Dados efetivos do LeaseSet2 (criptografados) Estrutura geral:\nLayer 0 data + Enc(layer 1 data + Enc(layer 2 data)) + Signature Importante: O LS2 criptografado usa chaves cegadas. A Destination não está no cabeçalho. O local de armazenamento na DHT é SHA-256(sig type || blinded public key), com rotação diária.\nCamada 0 (Externa) - Texto em claro A Camada 0 NÃO usa o cabeçalho LS2 padrão. Ela tem um formato personalizado otimizado para chaves cegadas.\nEstrutura:\nField Size Description Type1 byteNot in header, from DatabaseStore message field Blinded Public Key Sig Type2 bytesBig endian, always 0x000b (Red25519 type 11) Blinded Public Key32 bytesRed25519 blinded public key Published Timestamp4 bytesBig endian, seconds since epoch (rolls over in 2106) Expires2 bytesBig endian, offset from published in seconds (max 65,535 \u0026asymp; 18.2 hours) Flags2 bytesBit flags (see below) [Optional] Transient Key DataVariablePresent if flag bit\u0026nbsp;0 is set lenOuterCiphertext2 bytesBig endian, length of outer ciphertext outerCiphertextlenOuterCiphertextEncrypted Layer\u0026nbsp;1 data Signature64 bytesRed25519 signature over all preceding data **Campo de Flags (2 bytes, bits 15-0):** - **Bit 0:** indicador de chaves offline - `0` = Sem chaves offline - `1` = Chaves offline presentes (dados de chaves transitórios a seguir) - **Bits 1-15:** Reservados, devem ser 0 para compatibilidade futura Dados de chave transitória (presente se o bit de flag 0 = 1):\nField Size Description Expires Timestamp4 bytesBig endian, seconds since epoch Transient Sig Type2 bytesBig endian, signature type Transient Signing Public KeyVariableLength implied by signature type Signature64 bytesSigned by blinded public key; covers expires timestamp, transient sig type, and transient public key **Verificação de assinatura:** - **Sem chaves offline:** Verifique com chave pública cega - **Com chaves offline:** Verifique com chave pública temporária A assinatura abrange todos os dados de Type até outerCiphertext (inclusive).\nCamada 1 (Intermediária) - Autorização do Cliente Descriptografia: Consulte a seção Criptografia da Camada 1 .\nEstrutura:\nField Size Description Flags1 byteAuthorization flags (see below) [Optional] Auth DataVariablePresent based on flags innerCiphertextVariableEncrypted Layer\u0026nbsp;2 data (remainder) **Campo de flags (1 byte, bits 7-0):** - **Bit 0:** Modo de autorização - `0` = Sem autorização por cliente (todos) - `1` = Autorização por cliente (a seção de autenticação vem a seguir) - **Bits 3-1:** Esquema de autenticação (somente se o bit 0 = 1) - `000` = autenticação de cliente DH - `001` = autenticação de cliente PSK - Outros reservados - **Bits 7-4:** Não utilizados, devem ser 0 Dados de Autorização do Cliente DH (flags = 0x01, bits 3-1 = 000):\nField Size Description ephemeralPublicKey32 bytesServer's ephemeral X25519 public key clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **Entrada authClient (40 bytes):** - `clientID_i`: 8 bytes - `clientCookie_i`: 32 bytes (authCookie criptografado) Dados de Autorização do Cliente com PSK (flags = 0x03, bits 3-1 = 001):\nField Size Description authSalt32 bytesSalt for PSK key derivation clients2 bytesBig endian, number of client entries authClient[]40 bytes eachArray of client authorization entries **Entrada authClient (40 bytes):** - `clientID_i`: 8 bytes - `clientCookie_i`: 32 bytes (authCookie criptografado) Camada 2 (Interna) - Dados do LeaseSet Descriptografia: Consulte a seção Criptografia da Camada 2 .\nEstrutura:\nField Size Description Type1 byte3 (LS2) or 7 (Meta LS2) DataVariableComplete LeaseSet2 or MetaLeaseSet2 A camada interna contém a estrutura completa do LeaseSet2, incluindo: - cabeçalho LS2 - informações de Lease (registro de um tunnel com expiração no I2P) - assinatura LS2 Requisitos de Verificação: Após a descriptografia, as implementações devem verificar: 1. O carimbo de data/hora interno corresponde ao carimbo de data/hora externo publicado 2. A expiração interna corresponde à expiração externa 3. A assinatura do LS2 (versão 2 do LeaseSet) é válida 4. Os dados de Lease estão bem formados\nReferências: - Especificação de Estruturas Comuns - detalhes do formato do LeaseSet2\nDerivação da Chave de Cegamento Visão geral I2P usa um esquema aditivo de cegamento de chaves baseado em Ed25519 e ZCash RedDSA. As chaves cegadas são rotacionadas diariamente (à meia-noite UTC) para garantir sigilo perfeito futuro.\nJustificativa de Design:\nO I2P optou explicitamente por NÃO usar a abordagem do Apêndice A.2 do rend-spec-v3.txt do Tor. De acordo com a especificação:\n\u0026ldquo;Não usamos o apêndice A.2 do rend-spec-v3.txt do Tor, que tem objetivos de projeto semelhantes, porque, nele, as chaves públicas cegas podem estar fora do subgrupo de ordem prima, com implicações de segurança desconhecidas.\u0026rdquo;\nO cegamento aditivo do I2P garante que as chaves cegadas permaneçam no subgrupo de ordem prima da curva Ed25519.\nDefinições Matemáticas Parâmetros do Ed25519: - B: ponto base do Ed25519 (gerador) = 2^255 - 19 - L: ordem do Ed25519 = 2^252 + 27742317777372353535851937790883648493\nVariáveis-chave: - A: Chave pública de assinatura de 32 bytes não cegada (em Destination) - a: Chave privada de assinatura de 32 bytes não cegada - A': Chave pública de assinatura de 32 bytes cegada (usada em LeaseSet criptografado) - a': Chave privada de assinatura de 32 bytes cegada - alpha: Fator de cegamento de 32 bytes (secreto)\nFunções auxiliares:\nLEOS2IP(x) \u0026ldquo;Cadeia de octetos Little-Endian (ordem de bytes do menos significativo primeiro) para inteiro\u0026rdquo;\nConverte um array de bytes em little-endian para representação inteira.\nH*(x) \u0026ldquo;Hash e Redução\u0026rdquo;\nH*(x) = (LEOS2IP(SHA512(x))) mod L Mesma operação que na geração de chaves Ed25519.\nGeração Alfa Rotação diária: Um novo alpha e chaves cegadas DEVEM ser gerados todos os dias à meia-noite UTC (00:00:00 UTC).\nGENERATE_ALPHA(destination, date, secret) Algoritmo:\n# Input parameters A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes, big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes, big endian) # Always 0x000b (Red25519) datestring = \u0026#34;YYYYMMDD\u0026#34; (8 bytes ASCII from current UTC date) secret = optional UTF-8 encoded string (zero-length if not used) # Computation keydata = A || stA || stA\u0026#39; # 36 bytes total seed = HKDF( salt=H(\u0026#34;I2PGenerateAlpha\u0026#34;, keydata), ikm=datestring || secret, info=\u0026#34;i2pblinding1\u0026#34;, n=64 ) # Treat seed as 64-byte little-endian integer and reduce alpha = seed mod L Parâmetros verificados: - Personalização do salt: \u0026ldquo;I2PGenerateAlpha\u0026rdquo; - Parâmetro info do HKDF (campo de contexto): \u0026ldquo;i2pblinding1\u0026rdquo; - Saída: 64 bytes antes da redução - Distribuição de Alpha: Idêntica à das chaves privadas Ed25519 após mod L\nCegamento de chave privada Algoritmo BLIND_PRIVKEY(a, alpha):\nPara o proprietário do destino ao publicar o LeaseSet criptografado:\n# For Ed25519 private key (type 7) if sigtype == 7: seed = destination\u0026#39;s signing private key (32 bytes) a = left_half(SHA512(seed)) # 32 bytes a = clamp(a) # Ed25519 clamping # For Red25519 private key (type 11) elif sigtype == 11: a = destination\u0026#39;s signing private key (32 bytes) # No clamping for Red25519 # Additive blinding using scalar arithmetic blinded_privkey = a\u0026#39; = (a + alpha) mod L # Derive blinded public key blinded_pubkey = A\u0026#39; = DERIVE_PUBLIC(a\u0026#39;) Crítico: A redução mod L é essencial para manter a relação algébrica correta entre a chave privada e a chave pública.\nCegamento de Chave Pública Algoritmo BLIND_PUBKEY(A, alpha):\nPara clientes que recuperam e verificam o LeaseSet criptografado:\nalpha = GENERATE_ALPHA(destination, date, secret) A = destination\u0026#39;s signing public key (32 bytes) # Additive blinding using group elements (curve points) blinded_pubkey = A\u0026#39; = A + DERIVE_PUBLIC(alpha) Equivalência Matemática:\nAmbos os métodos produzem resultados idênticos:\nBLIND_PUBKEY(A, alpha) == DERIVE_PUBLIC(BLIND_PRIVKEY(a, alpha)) Isso ocorre porque:\nA\u0026#39; = A + [alpha]B = [a]B + [alpha]B = [a + alpha]B (group operation) = DERIVE_PUBLIC(a + alpha mod L) Assinatura com Chaves Cegadas Assinatura de LeaseSet sem cegamento:\nO LeaseSet não cegado (enviado diretamente a clientes autenticados) é assinado usando: - Assinatura Ed25519 padrão (tipo 7) ou Red25519 (tipo 11) - Chave privada de assinatura não cegada - Verificado com a chave pública não cegada\nCom chaves offline: - Assinado com chave privada transitória sem cegamento - Verificado com chave pública transitória sem cegamento - Ambas devem ser do tipo 7 ou 11\nAssinatura do LeaseSet criptografado:\nA parte externa do LeaseSet criptografado usa assinaturas Red25519 (variante aleatorizada do Ed25519) com chaves cegadas.\nAlgoritmo de Assinatura Red25519:\n# Generate per-signature random nonce T = CSRNG(80) # 80 random bytes # Calculate r (differs from Ed25519) r = H*(T || blinded_pubkey || message) # Rest is same as Ed25519 R = [r]B S = (r + H(R || A\u0026#39; || message) * a\u0026#39;) mod L signature = R || S # 64 bytes total Principais diferenças em relação ao Ed25519: 1. Usa 80 bytes de dados aleatórios T (não o hash da chave privada) 2. Usa o valor da chave pública diretamente (não o hash da chave privada) 3. Cada assinatura é única mesmo para a mesma mensagem e chave\nVerificação:\nIgual a Ed25519 (algoritmo de assinatura digital baseado em curva elíptica):\n# Parse signature R = signature[0:32] S = signature[32:64] # Verify equation: [S]B = R + [H(R || A\u0026#39; || message)]A\u0026#39; return [S]B == R + [H(R || A\u0026#39; || message)]A\u0026#39; Considerações de Segurança Distribuição Alfa:\nPor motivos de segurança, alpha deve ter a mesma distribuição que as chaves privadas não cegadas. Ao aplicar cegamento de Ed25519 (tipo 7) para Red25519 (tipo 11), as distribuições diferem ligeiramente.\nRecomendação: Use Red25519 (tipo 11) para chaves descegadas e cegadas a fim de atender aos requisitos do ZCash: \u0026ldquo;a combinação de uma chave pública re-aleatorizada e de assinatura(s) sob essa chave não revela a chave a partir da qual foi re-aleatorizada.\u0026rdquo;\nSuporte ao Tipo 7: Ed25519 (algoritmo de assinatura EdDSA) é suportado para manter compatibilidade com versões anteriores em destinos existentes, mas o tipo 11 é recomendado para novos destinos criptografados.\nBenefícios da Rotação Diária: - Sigilo futuro (forward secrecy): Comprometer a blinded key (chave cegada) de hoje não revela a de ontem - Não vinculabilidade: A rotação diária evita o rastreamento de longo prazo via DHT (tabela hash distribuída) - Separação de chaves: Chaves diferentes para períodos de tempo diferentes\nReferências: - Especificação do Protocolo ZCash - Seção 5.4.6.1 - Discussão sobre cegamento de chaves no Tor - Ticket do Tor nº 8106 Criptografia e Processamento Derivação de Subcredencial Antes da criptografia, derivamos uma credencial e uma subcredencial para vincular as camadas criptografadas ao conhecimento da chave pública de assinatura do Destino.\nObjetivo: Garantir que apenas aqueles que conhecem a chave pública de assinatura do Destino possam descriptografar o LeaseSet criptografado. O Destino completo não é necessário.\nCálculo de Credenciais A = destination\u0026#39;s signing public key (32 bytes) stA = signature type of A (2 bytes big endian) # 0x0007 for Ed25519 or 0x000b for Red25519 stA\u0026#39; = signature type of blinded key A\u0026#39; (2 bytes big endian) # Always 0x000b (Red25519) keydata = A || stA || stA\u0026#39; # 36 bytes credential = H(\u0026#34;credential\u0026#34;, keydata) # 32 bytes Separação de domínios: A string de personalização \u0026quot;credential\u0026quot; garante que este hash não colida com quaisquer chaves de consulta da DHT ou outros usos do protocolo.\nCálculo da Subcredencial blindedPublicKey = A\u0026#39; (32 bytes, from blinding process) subcredential = H(\u0026#34;subcredential\u0026#34;, credential || blindedPublicKey) # 32 bytes Finalidade: A subcredencial vincula o LeaseSet criptografado a: 1. A Destination (destino no I2P) específica (via credential) 2. A chave cegada específica (via blindedPublicKey) 3. O dia específico (via rotação diária de blindedPublicKey)\nIsso impede ataques de repetição e vinculação entre dias.\nCriptografia da Camada 1 Contexto: A Camada 1 contém dados de autorização do cliente e é criptografada com uma chave derivada da subcredential (subcredencial).\nAlgoritmo de Criptografia # Prepare input outerInput = subcredential || publishedTimestamp # publishedTimestamp: 4 bytes from Layer 0 # Generate random salt outerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) outerKey = keys[0:31] # 32 bytes (indices 0-31 inclusive) outerIV = keys[32:43] # 12 bytes (indices 32-43 inclusive) # Encrypt and prepend salt outerPlaintext = [Layer 1 data] outerCiphertext = outerSalt || ENCRYPT(outerKey, outerIV, outerPlaintext) Saída: outerCiphertext é de 32 + len(outerPlaintext) bytes.\nPropriedades de Segurança: - O salt garante pares exclusivos de chave/IV (vetor de inicialização) mesmo com a mesma subcredencial - A string de contexto \u0026quot;ELS2_L1K\u0026quot; fornece separação de domínios - ChaCha20 fornece segurança semântica (texto cifrado indistinguível de dados aleatórios)\nAlgoritmo de Descriptografia # Parse salt from ciphertext outerSalt = outerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV (same process as encryption) outerInput = subcredential || publishedTimestamp keys = HKDF( salt=outerSalt, ikm=outerInput, info=\u0026#34;ELS2_L1K\u0026#34;, n=44 ) outerKey = keys[0:31] # 32 bytes outerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) outerPlaintext = DECRYPT(outerKey, outerIV, outerCiphertext[32:end]) Verificação: Após a descriptografia, verifique se a estrutura da Camada 1 está bem formada antes de prosseguir para a Camada 2.\nCriptografia da Camada 2 Contexto: A Camada 2 contém os dados efetivos de LeaseSet2 e é criptografada com uma chave derivada do authCookie (se a autenticação por cliente estiver ativada) ou uma string vazia (se não estiver).\nAlgoritmo de criptografia # Determine authCookie based on authorization mode if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Prepare input innerInput = authCookie || subcredential || publishedTimestamp # Generate random salt innerSalt = CSRNG(32) # 32 bytes # Derive encryption key and IV keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, # Domain separation n=44 # 32 bytes key + 12 bytes IV ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Encrypt and prepend salt innerPlaintext = [Layer 2 data: LS2 type byte + LeaseSet2 data] innerCiphertext = innerSalt || ENCRYPT(innerKey, innerIV, innerPlaintext) Saída: innerCiphertext tem 32 + len(innerPlaintext) bytes.\nVinculação de chave: - Se não houver autenticação do cliente: Vinculada apenas à subcredencial e ao carimbo de data/hora - Se a autenticação do cliente estiver ativada: Além disso vinculada a authCookie (diferente para cada cliente autorizado)\nAlgoritmo de descriptografia # Determine authCookie (same as encryption) if per_client_auth_enabled: authCookie = [32-byte cookie from client authorization process] else: authCookie = b\u0026#39;\u0026#39; # Zero-length byte array # Parse salt from ciphertext innerSalt = innerCiphertext[0:31] # First 32 bytes # Derive decryption key and IV innerInput = authCookie || subcredential || publishedTimestamp keys = HKDF( salt=innerSalt, ikm=innerInput, info=\u0026#34;ELS2_L2K\u0026#34;, n=44 ) innerKey = keys[0:31] # 32 bytes innerIV = keys[32:43] # 12 bytes # Decrypt (skip salt bytes) innerPlaintext = DECRYPT(innerKey, innerIV, innerCiphertext[32:end]) Verificação: Após a descriptografia: 1. Verifique se o byte de tipo do LS2 é válido (3 ou 7) 2. Analisar a estrutura LeaseSet2 3. Verifique se o carimbo de data/hora interno corresponde ao carimbo de data/hora de publicação externo 4. Verifique se a expiração interna corresponde à expiração externa 5. Verifique a assinatura do LeaseSet2\nResumo da Camada de Criptografia ┌─────────────────────────────────────────────────┐ │ Layer 0 (Plaintext) │ │ - Blinded public key │ │ - Timestamps │ │ - Signature │ │ │ │ ┌─────────────────────────────────────────┐ │ │ │ Layer 1 (Encrypted with subcredential) │ │ │ │ - Authorization flags │ │ │ │ - Client auth data (if enabled) │ │ │ │ │ │ │ │ ┌────────────────────────────────┐ │ │ │ │ │ Layer 2 (Encrypted with │ │ │ │ │ │ authCookie + subcred) │ │ │ │ │ │ - LeaseSet2 type │ │ │ │ │ │ - LeaseSet2 data │ │ │ │ │ │ - Leases │ │ │ │ │ │ - LS2 signature │ │ │ │ │ └────────────────────────────────┘ │ │ │ └─────────────────────────────────────────┘ │ └─────────────────────────────────────────────────┘ Fluxo de Descriptografia: 1. Verifique a assinatura da Camada 0 com a chave pública cegada 2. Descriptografe a Camada 1 usando subcredential (subcredencial) 3. Processe os dados de autorização (se presentes) para obter o authCookie (cookie de autenticação) 4. Descriptografe a Camada 2 usando o authCookie e a subcredential 5. Verifique e analise o LeaseSet2\nAutorização por Cliente Visão geral Quando a autorização por cliente está ativada, o servidor mantém uma lista de clientes autorizados. Cada cliente possui material de chave que deve ser transmitido com segurança fora de banda.\nDois mecanismos de autorização: 1. Autorização de cliente DH (Diffie-Hellman): Mais segura, usa acordo de chaves X25519 2. Autorização por PSK (Pre-Shared Key, chave pré-compartilhada): Mais simples, usa chaves simétricas\nPropriedades de Segurança Comuns: - Privacidade de associação de clientes: observadores veem a contagem de clientes, mas não podem identificar clientes específicos - Adição/revogação anônima de clientes: não é possível rastrear quando clientes específicos são adicionados ou removidos - Probabilidade de colisão do identificador de cliente de 8 bytes: ~1 em 18 quintilhões (desprezível)\nAutorização de Cliente DH (Diffie-Hellman) Visão geral: Cada cliente gera um par de chaves X25519 e envia sua chave pública ao servidor por meio de um canal seguro fora de banda. O servidor usa Diffie-Hellman efêmero para criptografar um authCookie exclusivo para cada cliente.\nGeração de chaves do cliente # Client generates keypair csk_i = GENERATE_PRIVATE() # 32-byte X25519 private key cpk_i = DERIVE_PUBLIC(csk_i) # 32-byte X25519 public key # Client sends cpk_i to server via secure out-of-band channel # Client KEEPS csk_i secret (never transmitted) Vantagem de segurança: A chave privada do cliente nunca deixa o dispositivo. Um adversário que intercepte a transmissão fora de banda não pode descriptografar futuros LeaseSets criptografados sem quebrar o X25519 DH.\nProcessamento do Servidor # Server generates new auth cookie and ephemeral keypair authCookie = CSRNG(32) # 32-byte cookie esk = GENERATE_PRIVATE() # 32-byte ephemeral private key epk = DERIVE_PUBLIC(esk) # 32-byte ephemeral public key # For each authorized client i for cpk_i in authorized_clients: # Perform DH key agreement sharedSecret = DH(esk, cpk_i) # 32 bytes # Derive client-specific encryption key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, # Ephemeral public key as salt ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Estrutura de Dados da Camada 1:\nephemeralPublicKey (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Recomendações para o servidor: - Gerar um novo par de chaves efêmero para cada LeaseSet criptografado publicado - Aleatorizar a ordem dos clientes para evitar rastreamento baseado em posição - Considerar adicionar entradas falsas para ocultar o número real de clientes\nProcessamento do Cliente # Client has: csk_i (their private key), destination, date, secret # Client receives: encrypted LeaseSet with epk in Layer 1 # Perform DH key agreement with server\u0026#39;s ephemeral public key sharedSecret = DH(csk_i, epk) # 32 bytes # Derive expected client identifier and decryption key cpk_i = DERIVE_PUBLIC(csk_i) # Client\u0026#39;s own public key authInput = sharedSecret || cpk_i || subcredential || publishedTimestamp okm = HKDF( salt=epk, ikm=authInput, info=\u0026#34;ELS2_XCA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Tratamento de erros do cliente: - Se clientID_i não for encontrado: O cliente foi revogado ou nunca foi autorizado - Se a descriptografia falhar: Dados corrompidos ou chaves incorretas (extremamente raro) - Os clientes devem efetuar nova busca periodicamente para detectar revogação\nAutorização do Cliente com PSK Visão geral: Cada cliente possui uma chave simétrica pré-compartilhada de 32 bytes. O servidor criptografa o mesmo authCookie usando a PSK (chave pré-compartilhada) de cada cliente.\nGeração de Chaves # Option 1: Client generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Client sends psk_i to server via secure out-of-band channel # Option 2: Server generates key psk_i = CSRNG(32) # 32-byte pre-shared key # Server sends psk_i to one or more clients via secure out-of-band channel Nota de segurança: A mesma PSK (chave pré-compartilhada) pode ser compartilhada entre múltiplos clientes, se desejado (cria uma autorização \u0026ldquo;de grupo\u0026rdquo;).\nProcessamento do servidor # Server generates new auth cookie and salt authCookie = CSRNG(32) # 32-byte cookie authSalt = CSRNG(32) # 32-byte salt # For each authorized client i for psk_i in authorized_clients: # Derive client-specific encryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, # Domain separation n=52 # 32 key + 12 IV + 8 ID ) # Extract components clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Encrypt authCookie for this client clientCookie_i = ENCRYPT(clientKey_i, clientIV_i, authCookie) # Store [clientID_i, clientCookie_i] entry in Layer 1 Estrutura de Dados da Camada 1:\nauthSalt (32 bytes) clients (2 bytes) = N [clientID_1 (8 bytes) || clientCookie_1 (32 bytes)] [clientID_2 (8 bytes) || clientCookie_2 (32 bytes)] ... [clientID_N (8 bytes) || clientCookie_N (32 bytes)] Processamento do cliente # Client has: psk_i (their pre-shared key), destination, date, secret # Client receives: encrypted LeaseSet with authSalt in Layer 1 # Derive expected client identifier and decryption key authInput = psk_i || subcredential || publishedTimestamp okm = HKDF( salt=authSalt, ikm=authInput, info=\u0026#34;ELS2PSKA\u0026#34;, n=52 ) clientKey_i = okm[0:31] # 32 bytes clientIV_i = okm[32:43] # 12 bytes clientID_i = okm[44:51] # 8 bytes # Search Layer 1 authorization data for clientID_i for (clientID, clientCookie) in layer1_auth_entries: if clientID == clientID_i: # Found matching entry, decrypt authCookie authCookie = DECRYPT(clientKey_i, clientIV_i, clientCookie) # Use authCookie to decrypt Layer 2 break else: # No matching entry - client not authorized or revoked raise AuthorizationError(\u0026#34;Client not authorized\u0026#34;) Comparação e Recomendações Feature DH Authorization PSK Authorization Key ExchangeAsymmetric (X25519)Symmetric (shared secret) SecurityHigher (forward secrecy)Lower (depends on PSK secrecy) Client PrivacyPrivate key never transmittedPSK must be transmitted securely PerformanceN+1 DH operationsNo DH operations Key SharingOne key per clientCan share key among multiple clients Revocation DetectionAdversary cannot tell when revokedAdversary can track revocation if PSK intercepted Use CaseHigh security requirementsPerformance-critical or group access **Recomendação:** - **Use a autorização DH (Diffie-Hellman)** para aplicações de alta segurança em que o sigilo futuro (forward secrecy) é importante - **Use a autorização por PSK (chave pré-compartilhada)** quando o desempenho for crítico ou ao gerenciar grupos de clientes - **Nunca reutilize PSKs** entre serviços diferentes ou em períodos de tempo distintos - **Sempre use canais seguros** para a distribuição de chaves (por exemplo, Signal, OTR, PGP) Considerações de segurança Privacidade da filiação do cliente:\nAmbos os mecanismos fornecem privacidade para a associação de clientes por meio de: 1. Identificadores de cliente criptografados: clientID de 8 bytes derivado da saída do HKDF (função de derivação de chaves baseada em HMAC) 2. Cookies indistinguíveis: Todos os valores clientCookie de 32 bytes parecem aleatórios 3. Sem metadados específicos do cliente: Não há como identificar qual entrada pertence a qual cliente\nUm observador pode ver: - Número de clientes autorizados (do campo clients) - Mudanças na contagem de clientes ao longo do tempo\nUm observador NÃO PODE ver: - Quais clientes específicos estão autorizados - Quando clientes específicos são adicionados ou removidos (se a contagem permanecer a mesma) - Qualquer informação que identifique clientes\nRecomendações de Aleatorização:\nServidores DEVERIAM aleatorizar a ordem dos clientes sempre que gerarem um LeaseSet criptografado:\nimport random # Before serializing auth_entries = [(clientID_i, clientCookie_i) for each client] random.shuffle(auth_entries) # Now serialize in randomized order Benefícios: - Impede que os clientes saibam sua posição na lista - Evita ataques de inferência com base em mudanças de posição - Torna indistinguível a adição/revogação de clientes\nOcultando a contagem de clientes:\nServidores PODEM inserir entradas fictícias aleatórias:\n# Add dummy entries num_dummies = random.randint(0, max_dummies) for _ in range(num_dummies): dummy_id = CSRNG(8) dummy_cookie = CSRNG(32) auth_entries.append((dummy_id, dummy_cookie)) # Randomize all entries (real + dummy) random.shuffle(auth_entries) Custo: Entradas fictícias aumentam o tamanho do LeaseSet criptografado (40 bytes cada).\nRotação do AuthCookie (cookie de autenticação):\nOs servidores DEVERIAM gerar um novo authCookie: - Cada vez que um LeaseSet criptografado for publicado (a cada poucas horas, tipicamente) - Imediatamente após revogar a autorização de um cliente - Em um cronograma regular (por exemplo, diariamente), mesmo que não haja alterações de clientes\nBenefícios: - Limita a exposição se o authCookie for comprometido - Garante que clientes revogados percam o acesso rapidamente - Fornece sigilo de encaminhamento para a Camada 2\nEndereçamento Base32 para LeaseSets Criptografados Visão geral Endereços base32 tradicionais do I2P contêm apenas o hash do Destination (destino no I2P) (32 bytes → 52 caracteres). Isso é insuficiente para LeaseSets criptografados porque:\nOs clientes precisam da chave pública não cegada para derivar a chave pública cegada Os clientes precisam dos tipos de assinatura (não cegada e cegada) para a derivação correta da chave O hash por si só não fornece essa informação Solução: Um novo formato base32 que inclui a chave pública e os tipos de assinatura.\nEspecificação do Formato de Endereço Estrutura decodificada (35 bytes):\n┌─────────────────────────────────────────────────────┐ │ Byte 0 │ Byte 1 │ Byte 2 │ Bytes 3-34 │ │ Flags │ Unblind │ Blinded │ Public Key │ │ (XOR) │ SigType │ SigType │ (32 bytes) │ │ │ (XOR) │ (XOR) │ │ └─────────────────────────────────────────────────────┘ Primeiros 3 bytes (XOR com checksum):\nOs 3 primeiros bytes contêm metadados combinados via XOR com partes de uma soma de verificação CRC-32:\n# Data structure before XOR flags = 0x00 # 1 byte (reserved for future use) unblinded_sigtype = 0x07 or 0x0b # 1 byte (7 or 11) blinded_sigtype = 0x0b # 1 byte (always 11) # Compute CRC-32 checksum of public key checksum = crc32(pubkey) # 4-byte CRC-32 of bytes 3-34 # XOR first 3 bytes with parts of checksum data[0] = flags XOR (checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF data[1] = unblinded_sigtype XOR (checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF data[2] = blinded_sigtype XOR (checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF # Bytes 3-34 contain the unmodified 32-byte public key data[3:34] = pubkey Propriedades da soma de verificação: - Usa o polinômio padrão CRC-32 - Taxa de falsos negativos: ~1 em 16 milhões - Fornece detecção de erros de digitação em endereços - Não pode ser usado como autenticação (não é criptograficamente seguro)\nFormato codificado:\nBase32Encode(35 bytes) || \u0026#34;.b32.i2p\u0026#34; Características: - Total de caracteres: 56 (35 bytes × 8 bits ÷ 5 bits por caractere) - Sufixo: \u0026ldquo;.b32.i2p\u0026rdquo; (igual ao base32 tradicional) - Comprimento total: 56 + 8 = 64 caracteres (excluindo o terminador nulo)\nCodificação Base32: - Alfabeto: abcdefghijklmnopqrstuvwxyz234567 (padrão RFC 4648) - 5 bits não utilizados no final DEVEM ser 0 - Não diferencia maiúsculas de minúsculas (por convenção, minúsculas)\nGeração de Endereços import struct from zlib import crc32 import base64 def generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype): \u0026#34;\u0026#34;\u0026#34; Generate base32 address for encrypted LeaseSet. Args: pubkey: 32-byte public key (bytes) unblinded_sigtype: Unblinded signature type (7 or 11) blinded_sigtype: Blinded signature type (always 11) Returns: String address ending in .b32.i2p \u0026#34;\u0026#34;\u0026#34; # Verify inputs assert len(pubkey) == 32, \u0026#34;Public key must be 32 bytes\u0026#34; assert unblinded_sigtype in [7, 11], \u0026#34;Unblinded sigtype must be 7 or 11\u0026#34; assert blinded_sigtype == 11, \u0026#34;Blinded sigtype must be 11\u0026#34; # Compute CRC-32 of public key checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Ensure 32-bit unsigned # Prepare metadata bytes flags = 0x00 # XOR metadata with checksum parts byte0 = flags ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) byte1 = unblinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) byte2 = blinded_sigtype ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Construct 35-byte data data = bytes([byte0, byte1, byte2]) + pubkey # Base32 encode (standard alphabet) # Python\u0026#39;s base64 module uses uppercase by default b32 = base64.b32encode(data).decode(\u0026#39;ascii\u0026#39;).lower().rstrip(\u0026#39;=\u0026#39;) # Construct full address address = b32 + \u0026#34;.b32.i2p\u0026#34; return address Análise de Endereços import struct from zlib import crc32 import base64 def parse_encrypted_b32_address(address): \u0026#34;\u0026#34;\u0026#34; Parse base32 address for encrypted LeaseSet. Args: address: String address ending in .b32.i2p Returns: Tuple of (pubkey, unblinded_sigtype, blinded_sigtype) Raises: ValueError: If address is invalid or checksum fails \u0026#34;\u0026#34;\u0026#34; # Remove suffix if not address.endswith(\u0026#39;.b32.i2p\u0026#39;): raise ValueError(\u0026#34;Invalid address suffix\u0026#34;) b32 = address[:-8] # Remove \u0026#34;.b32.i2p\u0026#34; # Verify length (56 characters for 35 bytes) if len(b32) != 56: raise ValueError(f\u0026#34;Invalid length: {len(b32)} (expected 56)\u0026#34;) # Base32 decode # Add padding if needed padding_needed = (8 - (len(b32) % 8)) % 8 b32_padded = b32.upper() + \u0026#39;=\u0026#39; * padding_needed try: data = base64.b32decode(b32_padded) except Exception as e: raise ValueError(f\u0026#34;Invalid base32 encoding: {e}\u0026#34;) # Verify decoded length if len(data) != 35: raise ValueError(f\u0026#34;Invalid decoded length: {len(data)} (expected 35)\u0026#34;) # Extract public key pubkey = data[3:35] # Compute CRC-32 for verification checksum = crc32(pubkey) \u0026amp; 0xFFFFFFFF # Un-XOR metadata bytes flags = data[0] ^ ((checksum \u0026gt;\u0026gt; 24) \u0026amp; 0xFF) unblinded_sigtype = data[1] ^ ((checksum \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) blinded_sigtype = data[2] ^ ((checksum \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) # Verify expected values if flags != 0x00: raise ValueError(f\u0026#34;Invalid flags: {flags:#x} (expected 0x00)\u0026#34;) if unblinded_sigtype not in [7, 11]: raise ValueError(f\u0026#34;Invalid unblinded sigtype: {unblinded_sigtype} (expected 7 or 11)\u0026#34;) if blinded_sigtype != 11: raise ValueError(f\u0026#34;Invalid blinded sigtype: {blinded_sigtype} (expected 11)\u0026#34;) return pubkey, unblinded_sigtype, blinded_sigtype Comparação com o Base32 tradicional Feature Traditional B32 Encrypted LS2 B32 ContentSHA-256 hash of DestinationPublic key + signature types Decoded Size32 bytes35 bytes Encoded Length52 characters56 characters Suffix.b32.i2p.b32.i2p Total Length60 chars64 chars ChecksumNoneCRC-32 (XOR'd into first 3 bytes) Use CaseRegular destinationsEncrypted LeaseSet destinations ### Restrições de Uso Incompatibilidade com BitTorrent:\nEndereços LS2 criptografados NÃO PODEM ser usados com as respostas compactas de announce do BitTorrent:\nCompact announce reply format: ┌────────────────────────────┐ │ 32-byte destination hash │ ← Only hash, no signature types │ 2-byte port │ └────────────────────────────┘ Problema: O formato compacto contém apenas o hash (32 bytes), sem espaço para tipos de assinatura ou informações da chave pública.\nSolução: Utilize respostas completas de announce ou rastreadores baseados em HTTP que suportem endereços completos.\nIntegração com o Livro de Endereços Se um cliente tiver o Destination (identificador de destino no I2P) completo em um livro de endereços:\nArmazenar Destination completo (Destino no I2P, inclui a chave pública) Suportar consulta reversa por hash Quando um LS2 criptografado for encontrado, recuperar a chave pública do livro de endereços Não há necessidade de um novo formato base32 se o Destination completo já for conhecido Formatos de livro de endereços que suportam LS2 criptografado (LeaseSet v2, termo do I2P para um conjunto de informações de destino): - hosts.txt com cadeias de caracteres de destino completas - bancos de dados SQLite com coluna de destino - formatos JSON/XML com dados de destino completos\nExemplos de Implementação Exemplo 1: Gerar endereço\n# Ed25519 destination example pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) # 32-byte public key unblinded_type = 7 # Ed25519 blinded_type = 11 # Red25519 (always) address = generate_encrypted_b32_address(pubkey, unblinded_type, blinded_type) print(f\u0026#34;Address: {address}\u0026#34;) # Output: 56 base32 characters + .b32.i2p Exemplo 2: Analisar e Validar\naddress = \u0026#34;abc...xyz.b32.i2p\u0026#34; # 56 chars + suffix try: pubkey, unblinded, blinded = parse_encrypted_b32_address(address) print(f\u0026#34;Public Key: {pubkey.hex()}\u0026#34;) print(f\u0026#34;Unblinded SigType: {unblinded}\u0026#34;) print(f\u0026#34;Blinded SigType: {blinded}\u0026#34;) except ValueError as e: print(f\u0026#34;Invalid address: {e}\u0026#34;) Exemplo 3: Converter a partir de Destination (destino do I2P)\ndef destination_to_encrypted_b32(destination): \u0026#34;\u0026#34;\u0026#34; Convert full Destination to encrypted LS2 base32 address. Args: destination: I2P Destination object Returns: Base32 address string \u0026#34;\u0026#34;\u0026#34; # Extract public key and signature type from destination pubkey = destination.signing_public_key # 32 bytes sigtype = destination.sig_type # 7 or 11 # Blinded type is always 11 (Red25519) blinded_type = 11 # Generate address return generate_encrypted_b32_address(pubkey, sigtype, blinded_type) Considerações de Segurança Privacidade: - O endereço Base32 revela a chave pública - Isso é intencional e necessário para o protocolo - NÃO revela a chave privada nem compromete a segurança - Chaves públicas são, por definição, informações públicas\nResistência a colisões: - CRC-32 fornece apenas 32 bits de resistência a colisões - Não é criptograficamente seguro (use apenas para detecção de erros) - NÃO confie no checksum para autenticação - A verificação completa do destino ainda é necessária\nValidação de Endereço: - Sempre valide a soma de verificação antes do uso - Rejeite endereços com tipos de assinatura inválidos - Verifique se a chave pública está na curva (específico da implementação)\nReferências: - Proposta 149: B32 para LS2 (versão 2 do leaseSet) criptografado - Especificação de Endereçamento B32 - Especificação de Nomes do I2P Suporte a Chaves Offline Visão geral Chaves offline permitem que a chave de assinatura principal permaneça offline (armazenamento a frio) enquanto uma chave de assinatura transitória é usada nas operações do dia a dia. Isso é fundamental para serviços de alta segurança.\nRequisitos Específicos do LS2 criptografado: - Chaves transitórias devem ser geradas offline - Chaves privadas cegadas devem ser pré-geradas (uma por dia) - Tanto as chaves transitórias quanto as cegadas devem ser entregues em lotes - Ainda não há um formato de arquivo padronizado definido (TODO na especificação)\nEstrutura de Chave Offline Dados de Chave Transitória da Camada 0 (quando o bit 0 do flag = 1):\n┌───────────────────────────────────────────────────┐ │ Expires Timestamp │ 4 bytes (seconds) │ │ Transient Sig Type │ 2 bytes (big endian) │ │ Transient Signing Pubkey│ Variable (sigtype len) │ │ Signature (by blinded) │ 64 bytes (Red25519) │ └───────────────────────────────────────────────────┘ Cobertura da Assinatura: A assinatura no bloco de chave offline cobre: - Carimbo de data/hora de expiração (4 bytes) - Tipo de assinatura transitória (2 bytes) - Chave pública de assinatura transitória (variável)\nEsta assinatura é verificada com a chave pública cegada, provando que a entidade com a chave privada cegada autorizou esta chave temporária.\nProcesso de Geração de Chaves Para LeaseSet criptografado com chaves offline:\nGerar pares de chaves efêmeros (offline, em armazenamento a frio):\n# For each day in future for date in future_dates: # Generate daily transient keypair transient_privkey = generate_red25519_privkey() # Type 11 transient_pubkey = derive_public(transient_privkey) # Store for later delivery keys[date] = (transient_privkey, transient_pubkey) Generate daily blinded keypairs (offline, in cold storage):\nPara cada dia for date in future_dates: # Derive alpha for this date datestring = date.strftime(\u0026quot;%Y%m%d\u0026quot;) # \u0026quot;YYYYMMDD\u0026quot; alpha = GENERATE_ALPHA(destination, datestring, secret) # Blind the signing private key a = destination_signing_privkey # Type 7 or 11 blinded_privkey = BLIND_PRIVKEY(a, alpha) # Result is type 11 blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Store for later delivery blinded_keys[date] = (blinded_privkey, blinded_pubkey) 3. **Sign transient keys with blinded keys** (offline): ```python for date in future_dates: transient_pubkey = keys[date][1] blinded_privkey = blinded_keys[date][0] # Create signature data expires = int((date + timedelta(days=1)).timestamp()) sig_data = struct.pack(\u0026#39;\u0026gt;I\u0026#39;, expires) # 4 bytes sig_data += struct.pack(\u0026#39;\u0026gt;H\u0026#39;, 11) # Transient type (Red25519) sig_data += transient_pubkey # 32 bytes # Sign with blinded private key signature = RED25519_SIGN(blinded_privkey, sig_data) # Package for delivery offline_sig_blocks[date] = { \u0026#39;expires\u0026#39;: expires, \u0026#39;transient_type\u0026#39;: 11, \u0026#39;transient_pubkey\u0026#39;: transient_pubkey, \u0026#39;signature\u0026#39;: signature } Package for delivery to router: Para cada data delivery_package[date] = { 'transient_privkey': keys[date][0], 'transient_pubkey': keys[date][1], 'blinded_privkey': blinded_keys[date][0], 'blinded_pubkey': blinded_keys[date][1], 'offline_sig_block': offline_sig_blocks[date] }\n### Router Usage **Daily Key Loading:** ```python # À meia-noite UTC (ou antes da publicação) date = datetime.utcnow().date() # Carregar as chaves de hoje today_keys = load_delivery_package(date) transient_privkey = today_keys[\u0026#39;transient_privkey\u0026#39;] transient_pubkey = today_keys[\u0026#39;transient_pubkey\u0026#39;] blinded_privkey = today_keys[\u0026#39;blinded_privkey\u0026#39;] blinded_pubkey = today_keys[\u0026#39;blinded_pubkey\u0026#39;] offline_sig_block = today_keys[\u0026#39;offline_sig_block\u0026#39;] # Use estas chaves para o LeaseSet criptografado de hoje Publishing Process:\n# 1. Criar LeaseSet2 interno inner_ls2 = create_leaseset2( destinations, leases, expires, signing_key=transient_privkey # Use transient key ) # 2. Criptografar a Camada 2 layer2_ciphertext = encrypt_layer2(inner_ls2, authCookie, subcredential, timestamp) # 3. Crie a Camada 1 com dados de autorização layer1_plaintext = create_layer1(authorization_data, layer2_ciphertext) # 4. Criptografar a Camada 1 layer1_ciphertext = encrypt_layer1(layer1_plaintext, subcredential, timestamp) # 5. Crie a Camada 0 com um bloco de assinatura offline layer0 = create_layer0( blinded_pubkey, timestamp, expires, flags=0x0001, # Bit 0 set (offline keys present) offline_sig_block=offline_sig_block, layer1_ciphertext=layer1_ciphertext ) # 6. Assine a Camada 0 com uma chave privada transitória signature = RED25519_SIGN(transient_privkey, layer0) # 7. Anexar a assinatura e publicar encrypted_leaseset = layer0 + signature publish_to_netdb(encrypted_leaseset) Security Considerations Tracking via Offline Signature Block:\nThe offline signature block is in plaintext (Layer 0). An adversary scraping floodfills could:\nTrack the same encrypted LeaseSet across multiple days Correlate encrypted LeaseSets even though blinded keys change daily Mitigation: Generate new transient keys daily (in addition to blinded keys):\n# Gerar tanto novas chaves temporárias quanto novas chaves cegadas todos os dias for date in future_dates: # New transient keypair for this day transient_privkey = generate_red25519_privkey() transient_pubkey = derive_public(transient_privkey) # New blinded keypair for this day alpha = GENERATE_ALPHA(destination, datestring, secret) blinded_privkey = BLIND_PRIVKEY(signing_privkey, alpha) blinded_pubkey = DERIVE_PUBLIC(blinded_privkey) # Sign new transient key with new blinded key sig = RED25519_SIGN(blinded_privkey, transient_pubkey || metadata) # Now offline sig block changes daily Benefits:\nPrevents tracking across days via offline signature block Provides same security as encrypted LS2 without offline keys Each day appears completely independent Cost:\nMore keys to generate and store More complex key management File Format (TODO) Current Status: No standardized file format defined for batch key delivery.\nRequirements for Future Format:\nMust support multiple dates:\nBatch delivery of 30+ days worth of keys Clear date association for each key set Must include all necessary data:\nTransient private key Transient public key Blinded private key Blinded public key Pre-computed offline signature block Expiration timestamps Should be tamper-evident:\nChecksums or signatures over entire file Integrity verification before loading Should be encrypted:\nKeys are sensitive material Encrypt file with router\u0026rsquo;s key or passphrase Proposed Format Example (JSON, encrypted):\n{ \u0026#34;version\u0026#34;: 1, \u0026#34;destination_hash\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;keys\u0026#34;: [ { \u0026#34;date\u0026#34;: \u0026#34;2025-10-15\u0026#34;, \u0026#34;transient\u0026#34;: { \u0026#34;type\u0026#34;: 11, \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;blinded\u0026#34;: { \u0026#34;privkey\u0026#34;: \u0026#34;base64...\u0026#34;, \u0026#34;pubkey\u0026#34;: \u0026#34;base64...\u0026#34; }, \u0026#34;offline_sig_block\u0026#34;: { \u0026#34;expires\u0026#34;: 1729123200, \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; } } ], \u0026#34;signature\u0026#34;: \u0026#34;base64...\u0026#34; // Signature over entire structure } I2CP Protocol Enhancement (TODO) Current Status: No I2CP protocol enhancement defined for offline keys with encrypted LeaseSet.\nRequirements:\nKey delivery mechanism:\nUpload batch of keys from client to router Acknowledgment of successful key loading Key expiration notification:\nRouter notifies client when keys running low Client can generate and upload new batch Key revocation:\nEmergency revocation of future keys if compromise suspected Proposed I2CP Messages:\nUPLOAD_OFFLINE_KEYS - Lote de material de chave criptografado - Intervalo de datas abrangido OFFLINE_KEY_STATUS - Número de dias restantes - Data de expiração da próxima chave REVOKE_OFFLINE_KEYS - Intervalo de datas a revogar - Novas chaves para substituir (opcional) Implementation Status Java I2P:\n✅ Offline keys for standard LS2: Fully supported (since 0.9.38) ⚠️ Offline keys for encrypted LS2: Implemented (since 0.9.40) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced i2pd (C++):\n✅ Offline keys for standard LS2: Fully supported ✅ Offline keys for encrypted LS2: Fully supported (since 2.58.0) ❌ File format: Not standardized ❌ I2CP protocol: Not enhanced References:\nOffline Signatures Proposal I2CP Specification Security Considerations Cryptographic Security Algorithm Selection:\nAll cryptographic primitives are based on well-studied algorithms:\nChaCha20: Modern stream cipher, constant-time, no timing attacks SHA-256: NIST-approved hash, 128-bit security level HKDF: RFC 5869 standard, proven security bounds Ed25519/Red25519: Curve25519-based, ~128-bit security level X25519: Diffie-Hellman over Curve25519, ~128-bit security level Key Sizes:\nAll symmetric keys: 256 bits (32 bytes) All public/private keys: 256 bits (32 bytes) All nonces/IVs: 96 bits (12 bytes) All signatures: 512 bits (64 bytes) These sizes provide adequate security margins against current and near-future attacks.\nForward Secrecy Daily Key Rotation:\nEncrypted LeaseSets rotate keys daily (UTC midnight):\nNew blinded public/private key pair New storage location in DHT New encryption keys for both layers Benefits:\nCompromising today\u0026rsquo;s blinded key doesn\u0026rsquo;t reveal yesterday\u0026rsquo;s Limits exposure window to 24 hours Prevents long-term tracking via DHT Enhanced with Ephemeral Keys:\nDH client authorization uses ephemeral keys:\nServer generates new ephemeral DH keypair for each publication Compromising ephemeral key only affects that publication True forward secrecy even if long-term keys compromised Privacy Properties Destination Blinding:\nThe blinded public key:\nIs unlinkable to the original destination (without knowing the secret) Changes daily, preventing long-term correlation Cannot be reversed to find the original public key Client Membership Privacy:\nPer-client authorization provides:\nAnonymity: No way to identify which clients are authorized Untraceability: Cannot track when specific clients added/revoked Size obfuscation: Can add dummy entries to hide true count DHT Privacy:\nStorage location rotates daily:\nlocation = SHA-256(sig_type || blinded_public_key) This prevents:\nCorrelation across days via DHT lookups Long-term monitoring of service availability Traffic analysis of DHT queries Threat Model Adversary Capabilities:\nNetwork Adversary:\nCan monitor all DHT traffic Can observe encrypted LeaseSet publications Cannot decrypt without proper keys Floodfill Adversary:\nCan store and analyze all encrypted LeaseSets Can track publication patterns over time Cannot decrypt Layer 1 or Layer 2 Can see client count (but not identities) Authorized Client Adversary:\nCan decrypt specific encrypted LeaseSets Can access inner LeaseSet2 data Cannot determine other clients\u0026rsquo; identities Cannot decrypt past LeaseSets (with ephemeral keys) Out of Scope:\nMalicious router implementations Compromised router host systems Side-channel attacks (timing, power analysis) Physical access to keys Social engineering attacks Attack Scenarios 1. Offline Keys Tracking Attack:\nAttack: Adversary tracks encrypted LeaseSets via unchanging offline signature block.\nMitigation: Generate new transient keys daily (in addition to blinded keys).\nStatus: Documented recommendation, implementation-specific.\n2. Client Position Inference Attack:\nAttack: If client order is static, clients can infer their position and detect when other clients added/removed.\nMitigation: Randomize client order in authorization list for each publication.\nStatus: Documented recommendation in specification.\n3. Client Count Analysis Attack:\nAttack: Adversary monitors client count changes over time to infer service popularity or client churn.\nMitigation: Add random dummy entries to authorization list.\nStatus: Optional feature, deployment-specific trade-off (size vs. privacy).\n4. PSK Interception Attack:\nAttack: Adversary intercepts PSK during out-of-band exchange and can decrypt all future encrypted LeaseSets.\nMitigation: Use DH client authorization instead, or ensure secure key exchange (Signal, OTR, PGP).\nStatus: Known limitation of PSK approach, documented in specification.\n5. Timing Correlation Attack:\nAttack: Adversary correlates publication times across days to link encrypted LeaseSets.\nMitigation: Randomize publication times, use delayed publishing.\nStatus: Implementation-specific, not addressed in core specification.\n6. Long-term Secret Compromise:\nAttack: Adversary compromises the blinding secret and can compute all past and future blinded keys.\nMitigation:\nUse optional secret parameter (not empty) Rotate secret periodically Use different secrets for different services Status: Secret parameter is optional; using it is highly recommended.\nOperational Security Key Management:\nSigning Private Key:\nStore offline in cold storage Use only for generating blinded keys (batch process) Never expose to online router Blinded Private Keys:\nGenerate offline, deliver in batches Rotate daily automatically Delete after use (forward secrecy) Transient Private Keys (with offline keys):\nGenerate offline, deliver in batches Can be longer-lived (days/weeks) Rotate regularly for enhanced privacy Client Authorization Keys:\nDH: Client private keys never leave client device PSK: Use unique keys per client, secure exchange Revoke immediately upon client removal Secret Management:\nThe optional secret parameter in GENERATE_ALPHA:\nSHOULD be used for high-security services MUST be transmitted securely to authorized clients SHOULD be rotated periodically (e.g., monthly) CAN be different for different client groups Monitoring and Auditing:\nPublication Monitoring:\nVerify encrypted LeaseSets published successfully Monitor floodfill acceptance rates Alert on publication failures Client Access Monitoring:\nLog client authorization attempts (without identifying clients) Monitor for unusual patterns Detect potential attacks early Key Rotation Auditing:\nVerify daily key rotation occurs Check blinded key changes daily Ensure old keys are deleted Implementation Security Constant-Time Operations:\nImplementations MUST use constant-time operations for:\nAll scalar arithmetic (mod L operations) Private key comparisons Signature verification DH key agreement Memory Security:\nZero sensitive key material after use Use secure memory allocation for keys Prevent keys from being paged to disk Clear stack variables containing key material Random Number Generation:\nUse cryptographically secure RNG (CSRNG) Properly seed RNG from OS entropy source Do not use predictable RNGs for key material Verify RNG output quality periodically Input Validation:\nValidate all public keys are on the curve Check all signature types are supported Verify all lengths before parsing Reject malformed encrypted LeaseSets early Error Handling:\nDo not leak information via error messages Use constant-time comparison for authentication Do not expose timing differences in decryption Log security-relevant events properly Recommendations For Service Operators:\n✅ Use Red25519 (type 11) for new destinations ✅ Use DH client authorization for high-security services ✅ Generate new transient keys daily when using offline keys ✅ Use the optional secret parameter in GENERATE_ALPHA ✅ Randomize client order in authorization lists ✅ Monitor publication success and investigate failures ⚠️ Consider dummy entries to hide client count (size trade-off) For Client Implementers:\n✅ Validate blinded public keys are on prime-order subgroup ✅ Verify all signatures before trusting data ✅ Use constant-time operations for cryptographic primitives ✅ Zero key material immediately after use ✅ Implement proper error handling without information leaks ✅ Support both Ed25519 and Red25519 destination types For Network Operators:\n✅ Accept encrypted LeaseSets in floodfill routers ✅ Enforce reasonable size limits to prevent abuse ✅ Monitor for anomalous patterns (extremely large, frequent updates) ⚠️ Consider rate limiting encrypted LeaseSet publications Implementation Notes Java I2P Implementation Repository: https://github.com/i2p/i2p.i2p Key Classes:\nnet.i2p.data.LeaseSet2 - LeaseSet2 structure net.i2p.data.EncryptedLeaseSet - Encrypted LS2 implementation net.i2p.crypto.eddsa.EdDSAEngine - Ed25519/Red25519 signatures net.i2p.crypto.HKDF - HKDF implementation net.i2p.crypto.ChaCha20 - ChaCha20 cipher Configuration:\nEnable encrypted LeaseSet in clients.config:\n# Ativar LeaseSet criptografado i2cp.encryptLeaseSet=true # Opcional: Ativar a autorização do cliente i2cp.enableAccessList=true # Opcional: Use a autorização DH (Diffie-Hellman) (o padrão é PSK (chave pré-compartilhada)) i2cp.accessListType=0 # Opcional: Blinding secret (segredo de cegamento) (altamente recomendado) i2cp.blindingSecret=seu-segredo-aqui API Usage Example:\n// Crie um LeaseSet criptografado EncryptedLeaseSet els = new EncryptedLeaseSet(); // Defina o destino els.setDestination(destination); // Ativar autorização por cliente els.setAuthorizationEnabled(true); els.setAuthType(EncryptedLeaseSet.AUTH_DH); // Adicionar clientes autorizados (chaves públicas DH) for (byte[] clientPubKey : authorizedClients) { els.addClient(clientPubKey); } // Defina os parâmetros de cegamento els.setBlindingSecret(\u0026#34;your-secret\u0026#34;); // Assine e publique els.sign(signingPrivateKey); netDb.publish(els); i2pd (C++) Implementation Repository: https://github.com/PurpleI2P/i2pd Key Files:\nlibi2pd/LeaseSet.h/cpp - LeaseSet implementations libi2pd/Crypto.h/cpp - Cryptographic primitives libi2pd/Ed25519.h/cpp - Ed25519/Red25519 signatures libi2pd/ChaCha20.h/cpp - ChaCha20 cipher Configuration:\nEnable in tunnel configuration (tunnels.conf):\n[my-hidden-service] type = http host = 127.0.0.1 port = 8080 keys = my-service-keys.dat # Ativar LeaseSet criptografado encryptleaseset = true # Opcional: Tipo de autorização do cliente (0=DH, 1=PSK) authtype = 0 # Opcional: Blinding secret (segredo de cegamento) secret = seu-segredo-aqui # Opcional: Clientes autorizados (um por linha, chaves públicas codificadas em Base64) client.1 = base64-encoded-client-pubkey-1 client.2 = base64-encoded-client-pubkey-2 API Usage Example:\n// Criar LeaseSet criptografado auto encryptedLS = std::make_shared\u0026lt;i2p::data::EncryptedLeaseSet\u0026gt;( destination, blindingSecret ); // Habilitar a autorização por cliente encryptedLS-\u0026gt;SetAuthType(i2p::data::AUTH_TYPE_DH); // Adicionar clientes autorizados for (const auto\u0026amp; clientPubKey : authorizedClients) { encryptedLS-\u0026gt;AddClient(clientPubKey); } // Assinar e publicar encryptedLS-\u0026gt;Sign(signingPrivKey); netdb.Publish(encryptedLS); Testing and Debugging Test Vectors:\nGenerate test vectors for implementation verification:\n# Vetor de teste 1: Cegamento de chave destination_pubkey = bytes.fromhex(\u0026#39;a\u0026#39; * 64) sigtype = 7 blinded_sigtype = 11 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; alpha = generate_alpha(destination_pubkey, sigtype, blinded_sigtype, date, secret) print(f\u0026#34;Alpha: {alpha.hex()}\u0026#34;) # Esperado: (verificar em relação à implementação de referência) Unit Tests:\nKey areas to test:\nHKDF derivation with various inputs ChaCha20 encryption/decryption Red25519 signature generation and verification Key blinding (private and public) Layer 1/2 encryption/decryption Client authorization (DH and PSK) Base32 address generation and parsing Integration Tests:\nPublish encrypted LeaseSet to test network Retrieve and decrypt from client Verify daily key rotation Test client authorization (add/remove clients) Test offline keys (if supported) Common Implementation Errors:\nIncorrect mod L reduction: Must use proper modular arithmetic Endianness errors: Most fields are big-endian, but some crypto uses little-endian Off-by-one in array slicing: Verify indices are inclusive/exclusive as needed Missing constant-time comparisons: Use constant-time for all sensitive comparisons Not zeroing key material: Always zero keys after use Performance Considerations Computational Costs:\nOperation Cost Notes Key blinding (server)1 scalar multPer publication Key blinding (client)1 point add + 1 scalar multPer retrieval Layer 1 encryption1 HKDF + 1 ChaCha20Fast Layer 2 encryption1 HKDF + 1 ChaCha20Fast DH client auth (server)N+1 X25519 opsN = number of clients DH client auth (client)1 X25519 opPer retrieval PSK client auth0 DH opsOnly HKDF + ChaCha20 Signature (Red25519)1 signature opSimilar cost to Ed25519 Size Overhead:\nComponent Size Frequency Blinded public key32 bytesPer LeaseSet Layer 1 encryption overhead32 bytes (salt)Per LeaseSet Layer 2 encryption overhead32 bytes (salt)Per LeaseSet DH auth per client40 bytesPer client per LeaseSet DH ephemeral pubkey32 bytesPer LeaseSet (if DH auth) PSK auth per client40 bytesPer client per LeaseSet PSK salt32 bytesPer LeaseSet (if PSK auth) Signature64 bytesPer LeaseSet Offline sig block≈100 bytesPer LeaseSet (if offline keys) Typical Sizes:\nNo client auth: ~200 bytes overhead With 10 DH clients: ~600 bytes overhead With 100 DH clients: ~4200 bytes overhead Optimization Tips:\nBatch key generation: Generate blinded keys for multiple days in advance Cache subcredentials: Compute once per day, reuse for all publications Reuse ephemeral keys: Can reuse ephemeral DH key for short period (minutes) Parallel client encryption: Encrypt client cookies in parallel Fast path for no auth: Skip authorization layer entirely when disabled Compatibility Backward Compatibility:\nEd25519 (type 7) destinations supported for unblinded keys Red25519 (type 11) required for blinded keys Traditional LeaseSets still fully supported Encrypted LeaseSets do not break existing network Forward Compatibility:\nReserved flag bits for future features Extensible authorization scheme (3 bits allow 8 types) Version field in various structures Interoperability:\nJava I2P and i2pd fully interoperable since: Java I2P 0.9.40 (May 2019) i2pd 2.58.0 (September 2025) Encrypted LeaseSets work across implementations Client authorization works across implementations References IETF RFCs RFC 2104 - HMAC: Keyed-Hashing for Message Authentication (February 1997) RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF) (May 2010) RFC 7539 - ChaCha20 and Poly1305 for IETF Protocols (May 2015) RFC 7748 - Elliptic Curves for Security (January 2016) I2P Specifications Common Structures Specification - LeaseSet2 and EncryptedLeaseSet structures Proposal 123: New netDB Entries - Background and design of LeaseSet2 Proposal 146: Red25519 - Red25519 signature scheme specification Proposal 149: B32 for Encrypted LS2 - Base32 addressing for encrypted LeaseSets Red25519 Specification - Detailed Red25519 implementation B32 Addressing Specification - Base32 address format Network Database Documentation - NetDB usage and operations I2CP Specification - I2P Client Protocol Cryptographic References Ed25519 Paper - \u0026ldquo;High-speed high-security signatures\u0026rdquo; by Bernstein et al. ZCash Protocol Specification - Section 5.4.6: RedDSA signature scheme Tor Rendezvous Specification v3 - Tor\u0026rsquo;s onion service specification (for comparison) Security References Key Blinding Security Discussion - Tor Project mailing list discussion Tor Ticket #8106 - Key blinding implementation discussion PRNG Security - Random number generator security considerations Tor PRNG Discussion - Discussion of PRNG usage in Tor Implementation References Java I2P Repository - Official Java implementation i2pd Repository - C++ implementation I2P Website - Official I2P project website I2P Specifications - Complete specification index Version History I2P Release Notes - Official release announcements Java I2P Releases - GitHub release history i2pd Releases - GitHub release history Appendix A: Cryptographic Constants Ed25519 / Red25519 Constants # Ponto base (gerador) do Ed25519 B = 2**255 - 19 # Ordem do Ed25519 (tamanho do campo escalar) L = 2**252 + 27742317777372353535851937790883648493 # Valores de tipos de assinatura SIGTYPE_ED25519 = 7 # 0x0007 SIGTYPE_RED25519 = 11 # 0x000b # Tamanhos de chave PRIVKEY_SIZE = 32 # bytes PUBKEY_SIZE = 32 # bytes SIGNATURE_SIZE = 64 # bytes ChaCha20 Constants # Parâmetros do ChaCha20 CHACHA20_KEY_SIZE = 32 # bytes (256 bits) CHACHA20_NONCE_SIZE = 12 # bytes (96 bits) CHACHA20_INITIAL_COUNTER = 1 # RFC 7539 permite 0 ou 1 HKDF Constants # Parâmetros do HKDF (função de derivação de chaves baseada em HMAC) HKDF_HASH = \u0026#34;SHA-256\u0026#34; HKDF_SALT_MAX = 32 # bytes (HashLen) # Strings do parâmetro info do HKDF (separação de domínios) HKDF_INFO_ALPHA = b\u0026#34;i2pblinding1\u0026#34; HKDF_INFO_LAYER1 = b\u0026#34;ELS2_L1K\u0026#34; HKDF_INFO_LAYER2 = b\u0026#34;ELS2_L2K\u0026#34; HKDF_INFO_DH_AUTH = b\u0026#34;ELS2_XCA\u0026#34; HKDF_INFO_PSK_AUTH = b\u0026#34;ELS2PSKA\u0026#34; Hash Personalization Strings # Strings de personalização do SHA-256 HASH_PERS_ALPHA = b\u0026#34;I2PGenerateAlpha\u0026#34; HASH_PERS_RED25519 = b\u0026#34;I2P_Red25519H(x)\u0026#34; HASH_PERS_CREDENTIAL = b\u0026#34;credential\u0026#34; HASH_PERS_SUBCREDENTIAL = b\u0026#34;subcredential\u0026#34; Structure Sizes # Tamanhos da Camada 0 (externa) BLINDED_SIGTYPE_SIZE = 2 # bytes BLINDED_PUBKEY_SIZE = 32 # bytes (para Red25519) PUBLISHED_TS_SIZE = 4 # bytes EXPIRES_SIZE = 2 # bytes FLAGS_SIZE = 2 # bytes LEN_OUTER_CIPHER_SIZE = 2 # bytes SIGNATURE_SIZE = 64 # bytes (Red25519) # Tamanhos dos blocos de chaves offline OFFLINE_EXPIRES_SIZE = 4 # bytes OFFLINE_SIGTYPE_SIZE = 2 # bytes OFFLINE_SIGNATURE_SIZE = 64 # bytes # Tamanhos da camada 1 (intermediária) AUTH_FLAGS_SIZE = 1 # byte EPHEMERAL_PUBKEY_SIZE = 32 # bytes (autenticação DH) AUTH_SALT_SIZE = 32 # bytes (autenticação PSK) NUM_CLIENTS_SIZE = 2 # bytes CLIENT_ID_SIZE = 8 # bytes CLIENT_COOKIE_SIZE = 32 # bytes AUTH_CLIENT_ENTRY_SIZE = 40 # bytes (CLIENT_ID + CLIENT_COOKIE) # Sobrecarga de criptografia SALT_SIZE = 32 # bytes (anteposto a cada camada criptografada) # Endereço Base32 B32_ENCRYPTED_DECODED_SIZE = 35 # bytes B32_ENCRYPTED_ENCODED_LEN = 56 # caracteres B32_SUFFIX = \u0026#34;.b32.i2p\u0026#34; Appendix B: Test Vectors Test Vector 1: Alpha Generation Input:\n# Chave pública de destino (Ed25519) A = bytes.fromhex(\u0026#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#39;) stA = 0x0007 # Ed25519 stA_prime = 0x000b # Red25519 date = \u0026#34;20251015\u0026#34; secret = \u0026#34;\u0026#34; # Segredo vazio Computation:\nkeydata = A || bytes([0x00, 0x07]) || bytes([0x00, 0x0b]) # keydata = 36 bytes salt = SHA256(b\u0026#34;I2PGenerateAlpha\u0026#34; + keydata) ikm = b\u0026#34;20251015\u0026#34; info = b\u0026#34;i2pblinding1\u0026#34; seed = HKDF(salt, ikm, info, 64) alpha = LEOS2IP(seed) mod L Expected Output:\n(Verifique contra a implementação de referência) alpha = [valor hexadecimal de 64 bytes] Test Vector 2: ChaCha20 Encryption Input:\nkey = bytes([i for i in range(32)]) # 0x00..0x1f nonce = bytes([i for i in range(12)]) # 0x00..0x0b plaintext = b\u0026#34;Hello, I2P!\u0026#34; Computation:\nciphertext = ChaCha20_Encrypt(key, nonce, plaintext, counter=1) Expected Output:\nciphertext = [verificar contra os vetores de teste da RFC 7539] Test Vector 3: HKDF Input:\nsalt = bytes(32) # All zeros ikm = b\u0026#34;test input keying material\u0026#34; info = b\u0026#34;ELS2_L1K\u0026#34; n = 44 Computation:\nkeys = HKDF(salt, ikm, info, n) Expected Output:\nkeys = [valor hexadecimal de 44 bytes] Test Vector 4: Base32 Address Input:\npubkey = bytes.fromhex(\u0026#39;bbbb\u0026#39; + \u0026#39;bb\u0026#39; * 30) # 32 bytes unblinded_sigtype = 11 # Red25519 blinded_sigtype = 11 # Red25519 Computation:\naddress = generate_encrypted_b32_address(pubkey, unblinded_sigtype, blinded_sigtype) Expected Output:\naddress = [56 caracteres base32].b32.i2p # Verifique se a soma de verificação é validada corretamente Appendix C: Glossary Alpha (α): The secret blinding factor used to blind public and private keys. Generated from the destination, date, and optional secret.\nAuthCookie: A 32-byte random value encrypted for each authorized client, used as input to Layer 2 encryption.\nB (Base Point): The generator point for the Ed25519 elliptic curve.\nBlinded Key: A public or private key that has been transformed using the alpha blinding factor. Blinded keys cannot be linked to the original keys without knowing alpha.\nChaCha20: A stream cipher providing fast, secure encryption without requiring AES hardware support.\nClientID: An 8-byte identifier derived from HKDF output, used to identify authorization entries for clients.\nClientCookie: A 32-byte encrypted value containing the authCookie for a specific client.\nCredential: A 32-byte value derived from the destination\u0026rsquo;s public key and signature types, binding encryption to knowledge of the destination.\nCSRNG: Cryptographically Secure Random Number Generator. Must provide unpredictable output suitable for key generation.\nDH (Diffie-Hellman): A cryptographic protocol for securely establishing shared secrets. I2P uses X25519.\nEd25519: An elliptic curve signature scheme providing fast signatures with 128-bit security level.\nEphemeral Key: A short-lived cryptographic key, typically used once and then discarded.\nFloodfill: I2P routers that store and serve network database entries, including encrypted LeaseSets.\nHKDF: HMAC-based Key Derivation Function, used to derive multiple cryptographic keys from a single source.\nL (Order): The order of the Ed25519 scalar field (approximately 2^252).\nLayer 0 (Outer): The plaintext portion of an encrypted LeaseSet, containing blinded key and metadata.\nLayer 1 (Middle): The first encrypted layer, containing client authorization data.\nLayer 2 (Inner): The innermost encrypted layer, containing the actual LeaseSet2 data.\nLeaseSet2 (LS2): Second version of I2P\u0026rsquo;s network database entry format, introducing encrypted variants.\nNetDB: The I2P network database, a distributed hash table storing router and destination information.\nOffline Keys: A feature allowing the main signing key to remain in cold storage while a transient key handles daily operations.\nPSK (Pre-Shared Key): A symmetric key shared in advance between two parties, used for PSK client authorization.\nRed25519: An Ed25519-based signature scheme with key blinding support, based on ZCash RedDSA.\nSalt: Random data used as input to key derivation functions to ensure unique outputs.\nSigType: A numeric identifier for signature algorithms (e.g., 7 = Ed25519, 11 = Red25519).\nSubcredential: A 32-byte value derived from the credential and blinded public key, binding encryption to a specific encrypted LeaseSet.\nTransient Key: A temporary signing key used with offline keys, with a limited validity period.\nX25519: An elliptic curve Diffie-Hellman protocol over Curve25519, providing key agreement.\nDocument Information Status: This document represents the current stable encrypted LeaseSet specification as implemented in I2P since June 2019. The protocol is mature and widely deployed.\nContributing: For corrections or improvements to this documentation, please submit issues or pull requests to the I2P specifications repository.\nSupport: For questions about implementing encrypted LeaseSets:\nI2P Forum: https://i2pforum.net/ IRC: #i2p-dev on OFTC Matrix: #i2p-dev:matrix.org Acknowledgments: This specification builds on work by the I2P development team, ZCash cryptography research, and Tor Project\u0026rsquo;s key blinding research.\n","description":"Formato de LeaseSet com controle de acesso para Destinations (destinos no I2P) privadas","id":"14f2a4c0bb3f459df8db8dbce45508ff","section":"docs","title":"LeaseSet criptografado","url":"/pt/docs/specs/encryptedleaseset/"},{"categories":null,"content":"Conforme exigido pelo nosso modelo de ameaças (entre outras razões), o software desenvolvido para suportar a rede de comunicação anônima que chamamos de I2P deve estar livremente disponível, ser de código aberto e modificável pelo usuário. Para atender a esses critérios, fazemos uso de uma variedade de técnicas jurídicas e de engenharia de software para remover o maior número possível de barreiras de entrada para aqueles que consideram usar ou contribuir para o esforço do I2P.\nEmbora as informações abaixo possam ser mais confusas do que simplesmente afirmar \u0026ldquo;I2P é BSD\u0026rdquo;, \u0026ldquo;I2P é GPL\u0026rdquo; ou \u0026ldquo;I2P é domínio público\u0026rdquo;, a resposta curta para a pergunta \u0026ldquo;Como o I2P é licenciado?\u0026rdquo; é esta:\nTodo o software incluído nas distribuições do I2P permitirá: usar sem taxa usar sem restrições sobre como, quando, onde, por que, ou por quem está sendo executado acesso ao código-fonte sem taxa modificações no código-fonte A maioria do software garante muito mais - a capacidade de qualquer pessoa distribuir o código-fonte modificado da forma que escolher. No entanto, nem todo o software incluído no pacote oferece esta liberdade - a GPL restringe a capacidade de desenvolvedores que desejam integrar o I2P com suas próprias aplicações que não são, elas mesmas, aplicações de código aberto. Embora aplaudamos os nobres objetivos de aumentar os recursos comuns, o I2P é melhor servido ao remover quaisquer barreiras que impeçam sua adoção - se um desenvolvedor considerando se pode integrar o I2P com sua aplicação tem que parar e consultar seu advogado, ou conduzir uma auditoria de código para garantir que seu próprio código-fonte pode ser liberado como compatível com GPL, perdemos essa oportunidade.\nLicenças de componentes A distribuição I2P contém vários recursos, refletindo a divisão do código-fonte em componentes. Cada componente possui sua própria licença, com a qual todos os desenvolvedores que contribuem para ele concordam - seja declarando explicitamente a liberação do código submetido sob uma licença compatível com aquele componente, ou liberando implicitamente o código submetido sob a licença principal do componente. Cada um desses componentes tem um desenvolvedor líder que tem a palavra final sobre qual licença é compatível com a licença principal do componente, e o gerente do projeto I2P tem a palavra final sobre quais licenças atendem às quatro garantias mencionadas acima para inclusão na distribuição I2P.\nComponent Source path Resource Primary license Alternate licenses Lead developer I2P SDK core i2p.jar Public domain BSD, Cryptix, MIT zzz I2P Router router router.jar Public domain BSD, Cryptix, MIT zzz Ministreaming apps/ministreaming mstreaming.jar BSD Public domain, Cryptix, MIT zzz Streaming apps/streaming streaming.jar Public domain BSD, Cryptix, MIT zzz I2PTunnel apps/i2ptunnel i2ptunnel.jar GPL + exception Public domain, BSD, Cryptix, MIT zzz Routerconsole apps/routerconsole routerconsole.war Public domain — zzz Address Book apps/addressbook addressbook.war MIT Public domain, Cryptix, BSD — Susidns apps/susidns susidns.war GPL + exception — — Susimail apps/susimail susimail.war GPL + exception — — I2PSnark apps/i2psnark i2psnark.jar GPL + exception — zzz [BOB](/docs/legacy/bob/) Bridge apps/BOB BOB.jar WTFPL — sponge [SAM](/docs/api/samv3/) Bridge apps/sam sam.jar Public domain Cryptix, BSD, MIT zzz [SAM v1](/docs/legacy/sam/) Perl library apps/sam/perl SAM.pm GPL Public domain, Cryptix, BSD, MIT BrianR [SAM v1](/docs/legacy/sam/) C library apps/sam/c libSAM BSD Public domain, Cryptix, MIT Nightblade [SAM v1](/docs/legacy/sam/) Python library apps/sam/python i2p.py Public domain BSD, Cryptix, MIT Connelly [SAM v1](/docs/legacy/sam/) C# library apps/sam/csharp/ n/a Public domain BSD, Cryptix, MIT smeghead Other apps not mentioned apps/ ... Probably Public domain but check the source — — Installer installer install.jar, guiinstall.jar Public domain GPL + exception, BSD, Cryptix, MIT — Exceção GPL Embora possa ser redundante, apenas para maior clareza, o código sob GPL incluído no I2PTunnel e outros aplicativos deve ser disponibilizado sob a GPL com uma \u0026ldquo;exceção\u0026rdquo; adicional autorizando explicitamente o uso das bibliotecas padrão do Java:\nIn addition, as a special exception, XXXX gives permission to link the code of this program with the proprietary Java implementation provided by Sun (or other vendors as well), and distribute linked combinations including the two. You must obey the GNU General Public License in all respects for all of the code used other than the proprietary Java implementation. If you modify this file, you may extend this exception to your version of the file, but you are not obligated to do so. If you do not wish to do so, delete this exception statement from your version. Todo o código-fonte sob cada componente será, por padrão, licenciado sob a licença primária, a menos que marcado de outra forma no código. Todo o exposto acima é um resumo dos termos de licença - por favor, consulte a licença específica para o componente ou código-fonte em questão para termos definitivos. As localizações do código-fonte dos componentes e o empacotamento de recursos podem ser alterados se o repositório for reorganizado.\nLicença do Site Exceto onde indicado o contrário, o conteúdo deste site está licenciado sob uma Licença Creative Commons Atribuição-CompartilhaIgual 4.0 Internacional .\nAcesso de Commit Os desenvolvedores podem enviar alterações para um repositório git distribuído se receberem permissão da pessoa que administra esse repositório. Consulte o Guia para Novos Desenvolvedores para mais detalhes.\nNo entanto, para que as alterações sejam incluídas numa versão, os desenvolvedores devem ser considerados de confiança pelo gestor de lançamento (atualmente zzz). Além disso, devem concordar explicitamente com os termos acima para serem considerados de confiança. Isso significa que devem enviar a um dos gestores de lançamento uma mensagem assinada afirmando que:\nA menos que marcado de outra forma, todo o código que eu envio está implicitamente licenciado sob a licença primária do componente Se especificado no código-fonte, o código pode ser explicitamente licenciado sob uma das licenças alternativas do componente Tenho o direito de liberar o código que envio sob os termos que estou enviando Se alguém tiver conhecimento de qualquer situação em que as condições acima não sejam atendidas, por favor, entre em contato com o responsável do componente e/ou um gerente de lançamento do I2P com mais informações.\n","description":"Política de licença e licenças de componentes para software incluído com I2P","id":"74bb6af167b1176b4058e46e5f8ca568","section":"docs","title":"Licenças de Software do I2P","url":"/pt/docs/develop/licenses/"},{"categories":null,"content":"1. O que \u0026ldquo;Anônimo\u0026rdquo; Significa O I2P fornece anonimato prático—não invisibilidade. Anonimato é definido como a dificuldade para um adversário obter informações que você deseja manter privadas: quem você é, onde você está ou com quem você fala. Anonimato absoluto é impossível; em vez disso, o I2P visa anonimato suficiente contra adversários globais passivos e ativos.\nSeu anonimato depende de como você configura o I2P, como escolhe peers e assinaturas, e quais aplicações você expõe.\n2. Evolução Criptográfica e de Transporte (2003 → 2025) Era Primary Algorithms Notes 0.3 – 0.9 ElGamal + AES-256 + DSA-SHA1 Legacy stack (2003–2015) 0.9.15 Ed25519 signatures Replaced DSA 0.9.36 (2018) NTCP2 introduced Noise XK_25519_ChaChaPoly_SHA256 0.9.56 (2022) SSU2 enabled by default Noise-based UDP transport 2.4.0 (2023) NetDB Sub-DB isolation Prevents router↔client linkage 2.8.0+ (2025) Congestion-aware routing / observability reductions DoS hardening 2.10.0 (2025) Post-quantum hybrid ML-KEM support (optional) Experimental **Conjunto criptográfico atual (Noise XK):** - **X25519** para troca de chaves - **ChaCha20/Poly1305 AEAD** para criptografia - **Ed25519 (EdDSA-SHA512)** para assinaturas - **SHA-256** para hashing e HKDF - **Híbridos ML-KEM** opcionais para testes pós-quânticos Todos os usos de ElGamal e AES-CBC foram descontinuados. O transporte é inteiramente NTCP2 (TCP) e SSU2 (UDP); ambos suportam IPv4/IPv6, forward secrecy e ofuscação DPI.\n3. Resumo da Arquitetura de Rede Mixnet de rota livre: Remetentes e destinatários definem seus próprios tunnels. Sem autoridade central: Roteamento e nomenclatura são descentralizados; cada router mantém confiança local. Tunnels unidirecionais: Entrada e saída são separados (tempo de vida de 10 min). Tunnels exploratórios: 2 saltos por padrão; tunnels de cliente 2–3 saltos. Routers floodfill: ~1 700 de ~55 000 nós (~6 %) mantêm o NetDB distribuído. Rotação do NetDB: O espaço de chaves rotaciona diariamente à meia-noite UTC. Isolamento de sub-DB: Desde a versão 2.4.0, cada cliente e router usam bancos de dados separados para evitar vinculação. 4. Categorias de Ataque e Defesas Atuais Category Current Status (2025) Primary Defenses Brute Force / Cryptanalysis Impractical with modern primitives (X25519, ChaCha20). Strong crypto, key rotation, Noise handshakes. Timing Attacks Still unsolved for low-latency systems. Unidirectional tunnels, 1024\u0026nbsp;B cells, profile recalc (45\u0026nbsp;s). Research continues for non-trivial delays (3.0+). Intersection Attacks Inherent weakness of low latency mixnets. Tunnel rotation (10\u0026nbsp;min), leaseset expirations, multihoming. Predecessor Attacks Partially mitigated. Tiered peer selection, strict XOR ordering, variable length tunnels. Sybil Attacks No comprehensive defense. IP /16 limits, profiling, diversity rules; HashCash infra exists but not required. Floodfill / NetDB Attacks Improved but still a concern. One /16 per lookup, limit 500 active, daily rotation, randomized verification delay, Sub-DB isolation. DoS / Flooding Frequent (esp. 2023 incidents). Congestion-aware routing (2.4+), aggressive leaseset removal (2.8+). Traffic ID / Fingerprinting Greatly reduced. Noise obfuscation, random padding, no plaintext headers. Censorship / Partitioning Possible with state-level blocking. Hidden mode, IPv6, multiple reseeds, mirrors. Development / Supply Chain Mitigated. Open source, signed SU3 releases (RSA-4096), multi-signer trust model. --- 5. Banco de Dados de Rede Moderno (NetDB) Fatos principais (ainda precisos): - DHT Kademlia modificado armazena RouterInfo e LeaseSets. - Hashing de chave SHA-256; consultas paralelas aos 2 floodfills mais próximos com timeout de 10 s. - Tempo de vida do LeaseSet ≈ 10 min (LeaseSet2) ou 18 h (MetaLeaseSet).\nNovos tipos (desde 0.9.38): - LeaseSet2 (Tipo 3) – múltiplos tipos de criptografia, com timestamp. - EncryptedLeaseSet2 (Tipo 5) – destino ofuscado para serviços privados (autenticação DH ou PSK). - MetaLeaseSet (Tipo 7) – multihoming e expirações estendidas.\nGrande atualização de segurança – Isolamento de Sub-DB (2.4.0): - Impede a associação router↔cliente. - Cada cliente e router utilizam segmentos netDb separados. - Verificado e auditado (2.5.0).\n6. Modo Oculto e Rotas Restritas Modo Oculto: Implementado (automático em países rigorosos segundo pontuações da Freedom House).\nOs routers não publicam RouterInfo nem encaminham tráfego. Rotas Restritas: Parcialmente implementado (tunnels básicos somente para confiáveis).\nO roteamento abrangente por pares confiáveis permanece planejado (3.0+). Compromisso: Melhor privacidade ↔ redução da contribuição para a capacidade da rede.\n7. Ataques DoS e Floodfill Histórico: Pesquisa da UCSB de 2013 mostrou que ataques Eclipse e tomadas de controle de Floodfill eram possíveis. Defesas modernas incluem: - Rotação diária do espaço de chaves. - Limite de Floodfill ≈ 500, um por /16. - Atrasos de verificação de armazenamento aleatorizados. - Preferência por routers mais recentes (2.6.0). - Correção de inscrição automática (2.9.0). - Roteamento com reconhecimento de congestionamento e limitação de leases (2.4.0+).\nAtaques floodfill permanecem teoricamente possíveis, mas praticamente mais difíceis.\n8. Análise de Tráfego e Censura O tráfego I2P é difícil de identificar: sem porta fixa, sem handshake em texto simples e padding aleatório. Os pacotes NTCP2 e SSU2 imitam protocolos comuns e usam ofuscação de cabeçalho ChaCha20. As estratégias de padding são básicas (tamanhos aleatórios), tráfego fictício não está implementado (custoso). Conexões de nós de saída Tor são bloqueadas desde a versão 2.6.0 (para proteger recursos).\n9. Limitações Persistentes (reconhecidas) Correlação de temporização para aplicativos de baixa latência permanece um risco fundamental. Ataques de interseção ainda são poderosos contra destinos públicos conhecidos. Ataques Sybil carecem de defesa completa (HashCash não aplicado). Tráfego de taxa constante e atrasos não triviais permanecem não implementados (planejado para 3.0). A transparência sobre esses limites é intencional — ela impede que os usuários superestimem o anonimato.\n10. Estatísticas da Rede (2025) ~55 000 routers ativos em todo o mundo (↑ de 7 000 em 2013) ~1 700 routers floodfill (~6 %) 95 % participam no roteamento de tunnel por padrão Níveis de largura de banda: K (\u0026lt;12 KB/s) → X (\u0026gt;2 MB/s) Taxa mínima para floodfill: 128 KB/s Console do router Java 8+ (necessário), Java 17+ planejado para o próximo ciclo 11. Desenvolvimento e Recursos Centrais Site oficial: geti2p.net Documentação: Documentation Repositório Debian: https://deb.i2pgit.org ( substituiu deb.i2p2.de em outubro de 2023 ) Código fonte: https://i2pgit.org/I2P_Developers/i2p.i2p (Gitea) + espelho no GitHub Todas as versões são containers SU3 assinados (RSA-4096, chaves zzz/str4d) Sem listas de discussão ativas; comunidade via https://i2pforum.net e IRC2P. Ciclo de atualização: versões estáveis a cada 6–8 semanas. 12. Resumo das Melhorias de Segurança Desde a Versão 0.8.x Year Feature Effect 2015 Ed25519 signatures Removed SHA1/DSA weakness 2018 NTCP2 Noise-based TCP transport 2019 LeaseSet2 / EncryptedLeaseSet2 Hidden services privacy 2022 SSU2 Noise-based UDP transport 2023 Sub-DB Isolation + Congestion-Aware Routing Stopped NetDB linkage / improved resilience 2024 Floodfill selection improvements Reduced long-term node influence 2025 Observability reductions + PQ hybrid crypto Harder timing analysis / future-proofing --- 13. Trabalho Não Resolvido Conhecido ou Planejado Rotas restritas abrangentes (roteamento de pares confiáveis) → planejado para 3.0. Atraso/agrupamento não-trivial para resistência temporal → planejado para 3.0. Padding avançado e tráfego fictício → não implementado. Verificação de identidade HashCash → infraestrutura existe mas inativa. Substituição DHT R5N → apenas proposta. 14. Referências Principais Practical Attacks Against the I2P Network (Egger et al., RAID 2013) Privacy Implications of Performance-Based Peer Selection (Herrmann \u0026amp; Grothoff, PETS 2011) Resilience of the Invisible Internet Project (Muntaka et al., Wiley 2025) Documentação Oficial do I2P 15. Conclusão O modelo central de anonimato do I2P mantém-se há duas décadas: sacrificar a unicidade global em favor da confiança e segurança locais. De ElGamal a X25519, de NTCP a NTCP2, e de reseeds manuais ao isolamento de Sub-DB, o projeto evoluiu mantendo sua filosofia de defesa em profundidade e transparência.\nMuitos ataques permanecem teoricamente possíveis contra qualquer mixnet de baixa latência, mas o fortalecimento contínuo do I2P os torna cada vez mais impraticáveis. A rede é maior, mais rápida e mais segura do que nunca — mas ainda assim honesta sobre suas limitações.\n","description":"Catálogo de ataques considerados no design do I2P e as mitigações implementadas","id":"8433fa179e266d091a906a9059db53f4","section":"docs","title":"Modelo de Ameaças do I2P","url":"/pt/docs/overview/threat-model/"},{"categories":null,"content":"Os endereços I2P são longas chaves criptográficas. O sistema de nomenclatura fornece uma camada mais amigável sobre essas chaves sem introduzir uma autoridade central. Todos os nomes são locais—cada router decide independentemente a qual destino um nome de host se refere.\nPrecisa de contexto? A discussão sobre nomenclatura documenta os debates originais de design, propostas alternativas e fundamentos filosóficos por trás da nomenclatura descentralizada do I2P.\n1. Componentes A camada de nomenclatura do I2P é composta por vários subsistemas independentes mas cooperantes:\nServiço de nomes – resolve nomes de host para destinos e trata nomes de host Base32 . Proxy HTTP – repassa consultas .i2p para o router e sugere serviços jump quando um nome é desconhecido. Serviços host-add – formulários estilo CGI que adicionam novas entradas no catálogo de endereços local. Serviços jump – auxiliares remotos que retornam o destino para um nome de host fornecido. Catálogo de endereços – busca e mescla periodicamente listas de hosts remotas usando uma \u0026ldquo;rede de confiança\u0026rdquo; (web of trust) localmente confiável. SusiDNS – uma interface web para gerenciar catálogos de endereços, assinaturas e substituições locais. Este design modular permite que os usuários definam seus próprios limites de confiança e automatizem o quanto quiserem do processo de nomenclatura.\n2. Serviços de Nomenclatura A API de nomenclatura do router (net.i2p.client.naming) suporta múltiplos backends através da propriedade configurável i2p.naming.impl=\u0026lt;class\u0026gt;. Cada implementação pode oferecer diferentes estratégias de busca, mas todas compartilham o mesmo modelo de confiança e resolução.\n2.1 Hosts.txt (legacy format) O modelo legado usava três arquivos de texto simples verificados em ordem:\nprivatehosts.txt userhosts.txt hosts.txt Cada linha armazena um mapeamento hostname=base64-destination. Este formato de texto simples permanece totalmente suportado para importação/exportação, mas não é mais o padrão devido ao baixo desempenho quando a lista de hosts excede algumas milhares de entradas.\n2.2 Blockfile Naming Service (default backend) Introduzido na versão 0.8.8, o Blockfile Naming Service é agora o backend padrão. Ele substitui arquivos planos por uma skiplist de alto desempenho baseada em armazenamento chave/valor em disco (hostsdb.blockfile) que oferece buscas aproximadamente 10× mais rápidas.\nCaracterísticas principais: - Armazena múltiplos catálogos de endereços lógicos (privado, usuário e hosts) em um único banco de dados binário. - Mantém compatibilidade com importação/exportação do formato legado hosts.txt. - Suporta buscas reversas, metadados (data de adição, origem, comentários) e cache eficiente. - Usa a mesma ordem de busca em três níveis: privado → usuário → hosts.\nEsta abordagem preserva a compatibilidade com versões anteriores enquanto melhora drasticamente a velocidade de resolução e a escalabilidade.\n2.1 Hosts.txt (formato legado) Os desenvolvedores podem implementar backends personalizados como: - Meta – agrega múltiplos sistemas de nomenclatura. - PetName – suporta petnames armazenados em um petnames.txt. - AddressDB, Exec, Eepget e Dummy – para resolução externa ou alternativa.\nA implementação blockfile permanece como o backend recomendado para uso geral devido ao desempenho e confiabilidade.\n3. Base32 Hostnames Nomes de host Base32 (*.b32.i2p) funcionam de forma semelhante aos endereços .onion do Tor. Quando você acessa um endereço .b32.i2p:\nO router decodifica o payload Base32. Ele reconstrói o destino diretamente a partir da chave—nenhuma consulta ao address-book é necessária. Isso garante a acessibilidade mesmo se não existir um nome de host legível por humanos. Os nomes Base32 estendidos introduzidos na versão 0.9.40 suportam LeaseSet2 e destinos criptografados.\n4. Address Book \u0026amp; Subscriptions A aplicação de livro de endereços recupera listas de hosts remotos via HTTP e as mescla localmente de acordo com as regras de confiança configuradas pelo usuário.\n2.2 Serviço de Nomeação Blockfile (backend padrão) As subscrições são URLs .i2p padrão que apontam para hosts.txt ou feeds de atualização incremental. As atualizações são obtidas periodicamente (por hora, por padrão) e validadas antes da mesclagem. Os conflitos são resolvidos por ordem de chegada, seguindo a ordem de prioridade:\nprivatehosts.txt → userhosts.txt → hosts.txt. Default Providers Desde I2P 2.3.0 (junho de 2023), dois provedores de subscrição padrão estão incluídos: - http://i2p-projekt.i2p/hosts.txt - http://notbob.i2p/hosts.txt\nEsta redundância melhora a confiabilidade enquanto preserva o modelo de confiança local. Os usuários podem adicionar ou remover assinaturas através do SusiDNS.\nIncremental Updates Atualizações incrementais são obtidas via newhosts.txt (substituindo o conceito mais antigo de recenthosts.cgi). Este endpoint fornece atualizações delta eficientes baseadas em ETag—retornando apenas novas entradas desde a última requisição ou 304 Not Modified quando não houver alterações.\n2.3 Backends Alternativos e Plug-ins Serviços Host-add (add*.cgi) permitem o envio manual de mapeamentos nome-para-destino. Sempre verifique o destino antes de aceitar. Serviços Jump respondem com a chave apropriada e podem redirecionar através do proxy HTTP com um parâmetro ?i2paddresshelper=.\nExemplos comuns: stats.i2p, identiguy.i2p, e notbob.i2p.\nEstes serviços não são autoridades confiáveis—os usuários devem decidir quais usar. 5. Managing Entries Locally (SusiDNS) O SusiDNS está disponível em: http://127.0.0.1:7657/susidns/\nVocê pode: - Visualizar e editar catálogos de endereços locais. - Gerenciar e priorizar assinaturas. - Importar/exportar listas de hosts. - Configurar agendamentos de busca.\nNovidades no I2P 2.8.1 (Março de 2025): - Adicionado recurso \u0026ldquo;ordenar por mais recente\u0026rdquo;. - Melhoria no tratamento de assinaturas (correção para inconsistências de ETag).\nTodas as alterações permanecem locais—o livro de endereços de cada router é único.\n3. Nomes de host Base32 Seguindo a RFC 9476, o I2P registrou .i2p.alt junto à GNUnet Assigned Numbers Authority (GANA) em março de 2025 (I2P 2.8.1).\nPropósito: Prevenir vazamentos acidentais de DNS de software mal configurado.\nResolvedores DNS compatíveis com RFC 9476 não encaminharão domínios .alt para o DNS público. O software I2P trata .i2p.alt como equivalente a .i2p, removendo o sufixo .alt durante a resolução. .i2p.alt não se destina a substituir .i2p; é uma proteção técnica, não uma mudança de marca. 4. Livro de Endereços \u0026amp; Assinaturas Chaves de destino: 516–616 bytes (Base64) Hostnames: Máximo 67 caracteres (incluindo .i2p) Caracteres permitidos: a–z, 0–9, -, . (sem pontos duplos, sem maiúsculas) Reservado: *.b32.i2p ETag e Last-Modified: utilizados ativamente para minimizar largura de banda Tamanho médio de hosts.txt: ~400 KB para ~800 hosts (valor de exemplo) Uso de largura de banda: ~10 bytes/seg se obtido a cada 12 horas 8. Security Model and Philosophy O I2P intencionalmente sacrifica a unicidade global em troca de descentralização e segurança—uma aplicação direta do Triângulo de Zooko.\nPrincípios fundamentais: - Sem autoridade central: todas as consultas são locais. - Resistência ao sequestro de DNS: as consultas são criptografadas para chaves públicas de destino. - Prevenção de ataques Sybil: sem votação ou nomenclatura baseada em consenso. - Mapeamentos imutáveis: uma vez que existe uma associação local, ela não pode ser sobrescrita remotamente.\nSistemas de nomenclatura baseados em blockchain (por exemplo, Namecoin, ENS) têm explorado a resolução dos três lados do triângulo de Zooko, mas o I2P intencionalmente os evita devido à latência, complexidade e incompatibilidade filosófica com seu modelo de confiança local.\n9. Compatibility and Stability Nenhum recurso de nomenclatura foi descontinuado entre 2023–2025. O formato hosts.txt, serviços de salto, assinaturas e todas as implementações de API de nomenclatura permanecem funcionais. O Projeto I2P mantém compatibilidade retroativa rigorosa ao mesmo tempo que introduz melhorias de desempenho e segurança (isolamento NetDB, separação Sub-DB, etc.). 10. Best Practices Mantenha apenas assinaturas confiáveis; evite listas de hosts grandes e desconhecidas. Faça backup de hostsdb.blockfile e privatehosts.txt antes de atualizar ou reinstalar. Revise regularmente os serviços de jump e desative qualquer um em que você não confie mais. Lembre-se: seu catálogo de endereços define sua versão do mundo I2P—cada hostname é local. Further Reading Discussão sobre Nomenclatura Especificação de Blockfile Formato de Arquivo de Configuração Javadoc do Serviço de Nomenclatura ","description":"Como o I2P mapeia nomes de host legíveis para destinos","id":"fc2ecb5df890709d0740d866d03a6250","section":"docs","title":"Nomenclatura e Livro de Endereços","url":"/pt/docs/overview/naming/"},{"categories":null,"content":"Esta implementação do I2P (a implementação Java distribuída neste site) inclui uma \u0026ldquo;Lista de Países Restritos\u0026rdquo; usada para ajustar o comportamento do router em regiões onde participar no roteamento para outros pode ser restrito por lei. Embora não tenhamos conhecimento de jurisdições que proíbam o uso do I2P, várias têm proibições amplas sobre retransmissão de tráfego. Routers que parecem estar em países \u0026ldquo;restritos\u0026rdquo; são automaticamente colocados em modo Oculto.\nO Projeto faz referência a pesquisas de organizações de direitos civis e digitais ao tomar essas decisões. Em particular, as pesquisas contínuas da Freedom House informam nossas escolhas. A orientação geral é incluir países com uma pontuação de Liberdades Civis (CL) de 16 ou menos, ou uma pontuação de Liberdade na Internet de 39 ou menos (não livre).\nResumo do Modo Oculto Quando um router é colocado no modo Hidden, três aspectos principais mudam no seu comportamento:\nNão publica um RouterInfo no netDb. Não aceita túneis de participação. Rejeita conexões diretas a roteadores no mesmo país. Essas defesas tornam os routers mais difíceis de enumerar de forma confiável e reduzem o risco de violar proibições locais sobre retransmitir tráfego para outros.\nLista de Países com Restrições Rigorosas (a partir de 2024) /* Afghanistan */ \u0026#34;AF\u0026#34;, /* Azerbaijan */ \u0026#34;AZ\u0026#34;, /* Bahrain */ \u0026#34;BH\u0026#34;, /* Belarus */ \u0026#34;BY\u0026#34;, /* Brunei */ \u0026#34;BN\u0026#34;, /* Burundi */ \u0026#34;BI\u0026#34;, /* Cameroon */ \u0026#34;CM\u0026#34;, /* Central African Republic */ \u0026#34;CF\u0026#34;, /* Chad */ \u0026#34;TD\u0026#34;, /* China */ \u0026#34;CN\u0026#34;, /* Cuba */ \u0026#34;CU\u0026#34;, /* Democratic Republic of the Congo */ \u0026#34;CD\u0026#34;, /* Egypt */ \u0026#34;EG\u0026#34;, /* Equatorial Guinea */ \u0026#34;GQ\u0026#34;, /* Eritrea */ \u0026#34;ER\u0026#34;, /* Ethiopia */ \u0026#34;ET\u0026#34;, /* Iran */ \u0026#34;IR\u0026#34;, /* Iraq */ \u0026#34;IQ\u0026#34;, /* Kazakhstan */ \u0026#34;KZ\u0026#34;, /* Laos */ \u0026#34;LA\u0026#34;, /* Libya */ \u0026#34;LY\u0026#34;, /* Myanmar */ \u0026#34;MM\u0026#34;, /* North Korea */ \u0026#34;KP\u0026#34;, /* Palestinian Territories */ \u0026#34;PS\u0026#34;, /* Pakistan */ \u0026#34;PK\u0026#34;, /* Rwanda */ \u0026#34;RW\u0026#34;, /* Saudi Arabia */ \u0026#34;SA\u0026#34;, /* Somalia */ \u0026#34;SO\u0026#34;, /* South Sudan */ \u0026#34;SS\u0026#34;, /* Sudan */ \u0026#34;SD\u0026#34;, /* Eswatini (Swaziland) */ \u0026#34;SZ\u0026#34;, /* Syria */ \u0026#34;SY\u0026#34;, /* Tajikistan */ \u0026#34;TJ\u0026#34;, /* Thailand */ \u0026#34;TH\u0026#34;, /* Turkey */ \u0026#34;TR\u0026#34;, /* Turkmenistan */ \u0026#34;TM\u0026#34;, /* Venezuela */ \u0026#34;VE\u0026#34;, /* United Arab Emirates */ \u0026#34;AE\u0026#34;, /* Uzbekistan */ \u0026#34;UZ\u0026#34;, /* Vietnam */ \u0026#34;VN\u0026#34;, /* Western Sahara */ \u0026#34;EH\u0026#34;, /* Yemen */ \u0026#34;YE\u0026#34; Se você acredita que um país deve ser adicionado ou removido da lista restrita, por favor abra uma issue: https://i2pgit.org/i2p/i2p.i2p/ Referência: Freedom House – https://freedomhouse.org/ ","description":"Como o I2P se comporta em jurisdições com restrições sobre ferramentas de roteamento ou anonimato (Modo Oculto e lista restrita)","id":"483dc8380c381981cff8df178412f086","section":"docs","title":"Países Estritos/Restritivos","url":"/pt/docs/overview/restrictive-countries/"},{"categories":null,"content":"Ajuda do Router I2P Em que sistemas o I2P funciona? O I2P é escrito na linguagem de programação Java. Foi testado no Windows, Linux, FreeBSD e OSX. Uma versão para Android também está disponível.\nEm termos de uso de memória, o I2P é configurado para usar 128 MB de RAM por padrão. Isso é suficiente para navegação e uso de IRC. No entanto, outras atividades podem exigir maior alocação de memória. Por exemplo, se alguém deseja executar um router de alta largura de banda, participar de torrents I2P ou servir serviços ocultos de alto tráfego, uma quantidade maior de memória é necessária.\nEm termos de uso de CPU, o I2P foi testado para funcionar em sistemas modestos, como os computadores de placa única da linha Raspberry Pi. Como o I2P faz uso intenso de técnicas criptográficas, uma CPU mais potente será mais adequada para lidar com a carga de trabalho gerada pelo I2P, bem como com tarefas relacionadas ao resto do sistema (ou seja, Sistema Operacional, Interface Gráfica, Outros processos, por exemplo, Navegação Web).\nÉ recomendado usar Sun/Oracle Java ou OpenJDK.\nÉ necessário instalar Java para usar o I2P? Sim, o Java é necessário para usar o I2P Core. Incluímos o Java nos nossos instaladores fáceis para Windows, Mac OSX e Linux. Se você estiver executando o aplicativo I2P Android, também precisará de um runtime Java como Dalvik ou ART instalado na maioria dos casos.\nO que é um \u0026ldquo;I2P Site\u0026rdquo; e como configuro meu navegador para usá-los? Um Site I2P é um site normal, exceto que está hospedado dentro do I2P. Os sites I2P têm endereços que se parecem com endereços normais da internet, terminando em \u0026ldquo;.i2p\u0026rdquo; de forma legível para humanos e não criptográfica, para benefício das pessoas. Na verdade, conectar-se a um Site I2P requer criptografia, o que significa que os endereços de Sites I2P também são os longos Destinations em \u0026ldquo;Base64\u0026rdquo; e os endereços \u0026ldquo;B32\u0026rdquo; mais curtos. Você pode precisar fazer configurações adicionais para navegar corretamente. Navegar em Sites I2P exigirá ativar o Proxy HTTP na sua instalação do I2P e então configurar seu navegador para usá-lo. Para mais informações, consulte a seção \u0026ldquo;Navegadores\u0026rdquo; abaixo ou o Guia de \u0026ldquo;Configuração de Navegador\u0026rdquo;.\nO que significam os números Ativos x/y no console do roteador? Na página Peers no console do seu router, você pode ver dois números - Active x/y. O primeiro número é a quantidade de peers para os quais você enviou ou de quem recebeu uma mensagem nos últimos minutos. O segundo número é a quantidade de peers vistos recentemente, que será sempre maior ou igual ao primeiro número.\nMeu roteador tem muito poucos peers ativos, isso é normal? Sim, isso pode ser normal, especialmente quando o router acabou de ser iniciado. Novos routers precisarão de tempo para inicializar e conectar-se ao resto da rede. Para ajudar a melhorar a integração na rede, tempo de atividade e desempenho, revise estas configurações:\nCompartilhar largura de banda - Se um router estiver configurado para compartilhar largura de banda, ele roteará mais tráfego para outros routers, o que ajuda a integrá-lo ao resto da rede, além de melhorar o desempenho da conexão local. Isso pode ser configurado na página http://localhost:7657/config . Interface de rede - Certifique-se de que não há uma interface especificada na página http://localhost:7657/confignet . Isso pode reduzir o desempenho, a menos que seu computador seja multi-homed com múltiplos endereços IP externos. Protocolo I2NP - Certifique-se de que o router está configurado para esperar conexões em um protocolo válido para o sistema operacional do host e configurações de rede vazias (Avançado). Não insira um endereço IP no campo \u0026lsquo;Hostname\u0026rsquo; na página de configuração de Rede. O Protocolo I2NP que você selecionar aqui só será usado se você ainda não tiver um endereço acessível. A maioria das conexões sem fio Verizon 4G e 5G nos Estados Unidos, por exemplo, bloqueiam UDP e não podem ser alcançadas por ele. Outros usariam UDP à força mesmo que esteja disponível para eles. Escolha uma configuração razoável dos Protocolos I2NP listados. Sou contra certos tipos de conteúdo. Como posso evitar distribuí-los, armazená-los ou acessá-los? Nenhum deste material é instalado por padrão. No entanto, como o I2P é uma rede peer-to-peer, é possível que você encontre conteúdo proibido acidentalmente. Aqui está um resumo de como o I2P evita que você se envolva desnecessariamente em violações de suas convicções.\nDistribuição - O tráfego é interno à rede I2P, você não é um nó de saída (referido como outproxy em nossa documentação). Armazenamento - A rede I2P não faz armazenamento distribuído de conteúdo, isso tem que ser especificamente instalado e configurado pelo usuário (com Tahoe-LAFS, por exemplo). Essa é uma característica de uma rede anônima diferente, Freenet . Ao executar um router I2P, você não está armazenando conteúdo para ninguém. Acesso - Seu router não solicitará nenhum conteúdo sem sua instrução específica para fazê-lo. É possível bloquear o I2P? Sim, de longe a maneira mais fácil e comum é bloqueando o bootstrap, ou servidores de \u0026ldquo;Reseed\u0026rdquo;. Bloquear completamente todo o tráfego ofuscado também funcionaria (embora isso quebrasse muitas, muitas outras coisas que não são I2P e a maioria não está disposta a ir tão longe). No caso do bloqueio de reseed, existe um pacote de reseed no Github, bloqueá-lo também bloqueará o Github. Você pode fazer reseed através de um proxy (muitos podem ser encontrados na Internet se você não quiser usar Tor) ou compartilhar pacotes de reseed com amigos de forma offline.\nNo wrapper.log vejo um erro que diz \u0026ldquo;Protocol family unavailable\u0026rdquo; ao carregar o Router Console Frequentemente, este erro ocorrerá com qualquer software java habilitado para rede em alguns sistemas que estão configurados para usar IPv6 por padrão. Existem algumas maneiras de resolver isso:\nEm sistemas baseados em Linux, você pode executar echo 0 \u0026gt; /proc/sys/net/ipv6/bindv6only Procure pelas seguintes linhas em wrapper.config: #wrapper.java.additional.5=-Djava.net.preferIPv4Stack=true #wrapper.java.additional.6=-Djava.net.preferIPv6Addresses=false Se as linhas estiverem presentes, descomente-as removendo os \u0026ldquo;#\u0026ldquo;s. Se as linhas não estiverem presentes, adicione-as sem os \u0026ldquo;#\u0026ldquo;s. Outra opção seria remover o ::1 de ~/.i2p/clients.config\nAVISO: Para que quaisquer alterações no wrapper.config tenham efeito, você deve parar completamente o router e o wrapper. Clicar em Reiniciar no console do router NÃO irá reler este arquivo! Você deve clicar em Desligar, aguardar 11 minutos e então iniciar o I2P.\nA maioria dos Sites I2P dentro do I2P estão fora do ar? Se você considerar todos os I2P Sites que já foram criados, sim, a maioria deles está fora do ar. Pessoas e I2P Sites vêm e vão. Uma boa maneira de começar no I2P é verificar uma lista de I2P Sites que estão atualmente ativos. identiguy.i2p rastreia I2P Sites ativos.\nPor que o I2P está escutando na porta 32000? O wrapper de serviço Java Tanuki que usamos abre esta porta — vinculada ao localhost — para se comunicar com o software rodando dentro da JVM. Quando a JVM é iniciada, ela recebe uma chave para poder se conectar ao wrapper. Após a JVM estabelecer sua conexão com o wrapper, o wrapper recusa quaisquer conexões adicionais.\nMais informações podem ser encontradas na documentação do wrapper .\nComo configuro meu navegador? A configuração de proxy para diferentes navegadores está em uma página separada com capturas de tela. Configurações mais avançadas com ferramentas externas, como o plug-in de navegador FoxyProxy ou o servidor proxy Privoxy, são possíveis, mas podem introduzir vazamentos na sua configuração.\nComo me conecto ao IRC dentro do I2P? Um túnel para o servidor IRC principal dentro do I2P, Irc2P, é criado quando o I2P é instalado (veja a página de configuração do I2PTunnel ), e é iniciado automaticamente quando o router I2P inicia. Para se conectar a ele, configure seu cliente IRC para conectar em localhost 6668. Usuários de clientes semelhantes ao HexChat podem criar uma nova rede com o servidor localhost/6668 (lembre-se de marcar \u0026ldquo;Ignorar servidor proxy\u0026rdquo; se você tiver um servidor proxy configurado). Usuários do Weechat podem usar o seguinte comando para adicionar uma nova rede:\n/server add irc2p localhost/6668 Como configurar meu próprio site I2P? O método mais fácil é clicar no link i2ptunnel no console do router e criar um novo \u0026lsquo;Server Tunnel\u0026rsquo; (túnel servidor). Você pode servir conteúdo dinâmico configurando o destino do tunnel para a porta de um servidor web existente, como Tomcat ou Jetty. Você também pode servir conteúdo estático. Para isso, configure o destino do tunnel para: 0.0.0.0 port 7659 e coloque o conteúdo no diretório ~/.i2p/eepsite/docroot/. (Em sistemas não-Linux, isso pode estar em um local diferente. Verifique o console do router.) O software \u0026rsquo;eepsite\u0026rsquo; vem como parte do pacote de instalação do I2P e está configurado para iniciar automaticamente quando o I2P é iniciado. O site padrão criado pode ser acessado em http://127.0.0.1:7658. No entanto, seu \u0026rsquo;eepsite\u0026rsquo; também está acessível a outros através do seu arquivo de chave eepsite, localizado em: ~/.i2p/eepsite/i2p/eepsite.keys. Para saber mais, leia o arquivo readme em: ~/.i2p/eepsite/README.txt.\nSe eu hospedar um site no I2P em casa, contendo apenas HTML e CSS, é perigoso? Depende do seu adversário e do seu modelo de ameaça. Se você está apenas preocupado com violações \u0026ldquo;de privacidade\u0026rdquo; corporativas, criminosos típicos e censura, então não é realmente perigoso. As autoridades policiais provavelmente vão te encontrar de qualquer forma se realmente quiserem. Apenas hospedar quando você tiver um navegador de usuário doméstico normal (internet) em execução tornará realmente difícil saber quem está hospedando aquela parte. Por favor, considere a hospedagem do seu site I2P da mesma forma que hospedar qualquer outro serviço - é tão perigoso - ou seguro - quanto você mesmo o configurar e gerenciar.\nNota: Já existe uma forma de separar a hospedagem de um serviço i2p (destination) do router i2p. Se você entender como funciona, então pode simplesmente configurar uma máquina separada como servidor para o site (ou serviço) que será publicamente acessível e encaminhar isso para o servidor web através de um túnel SSH [muito] seguro ou usar um sistema de arquivos compartilhado seguro.\nComo o I2P encontra sites \u0026ldquo;.i2p\u0026rdquo;? A aplicação de Livro de Endereços do I2P mapeia nomes legíveis por humanos para destinos de longo prazo, associados a serviços, tornando-a mais parecida com um arquivo hosts ou uma lista de contatos do que com uma base de dados de rede ou um serviço DNS. É também local-primeiro, não há um namespace global reconhecido, você decide a que qualquer domínio .i2p corresponde no final. O meio-termo é algo chamado \u0026ldquo;Jump Service\u0026rdquo; (serviço de redirecionamento) que fornece um nome legível por humanos ao redirecioná-lo para uma página onde será perguntado \u0026ldquo;Você autoriza o router I2P a chamar $SITE_CRYPTO_KEY de $SITE_NAME.i2p\u0026rdquo; ou algo nesse sentido. Uma vez que esteja no seu livro de endereços, você pode gerar seus próprios URL\u0026rsquo;s de redirecionamento para ajudar a compartilhar o site com outros.\nComo adiciono endereços ao Catálogo de Endereços? Você não pode adicionar um endereço sem conhecer pelo menos o base32 ou base64 do site que deseja visitar. O \u0026ldquo;hostname\u0026rdquo; que é legível por humanos é apenas um alias para o endereço criptográfico, que corresponde ao base32 ou base64. Sem o endereço criptográfico, não há como acessar um I2P Site, isso é por design. Distribuir o endereço para pessoas que ainda não o conhecem geralmente é responsabilidade do provedor de serviço Jump. Visitar um I2P Site desconhecido acionará o uso de um serviço Jump. stats.i2p é o serviço Jump mais confiável.\nSe você está hospedando um site via i2ptunnel, então ele ainda não terá um registro em um serviço de jump. Para dar a ele uma URL localmente, visite a página de configuração e clique no botão que diz \u0026ldquo;Add to Local Address Book.\u0026rdquo; Em seguida, vá para http://127.0.0.1:7657/dns para consultar a URL addresshelper e compartilhá-la.\nQuais portas o I2P utiliza? As portas que são usadas pelo I2P podem ser divididas em 2 seções:\nPortas voltadas para a Internet, que são usadas para comunicação com outros roteadores I2P Portas locais, para conexões locais Estes são descritos em detalhe abaixo.\n1. Portas voltadas para a Internet Nota: Desde a versão 0.7.8, novas instalações não utilizam a porta 8887; uma porta aleatória entre 9000 e 31000 é selecionada quando o programa é executado pela primeira vez. A porta selecionada é exibida na página de configuração do router.\nSAÍDA\nUDP da porta aleatória listada na página de configuração para portas UDP remotas arbitrárias, permitindo respostas TCP de portas altas aleatórias para portas TCP remotas arbitrárias UDP de saída na porta 123, permitindo respostas. Isto é necessário para a sincronização de tempo interna do I2P (via SNTP - consultando um host SNTP aleatório em pool.ntp.org ou outro servidor que você especificar) ENTRADA\n(Opcional, recomendado) UDP para a porta indicada na página de configuração de locais arbitrários (Opcional, recomendado) TCP para a porta indicada na página de configuração de locais arbitrários O TCP de entrada pode ser desativado na página de configuração 2. Portas I2P locais As portas I2P locais escutam apenas conexões locais por padrão, exceto quando indicado:\nPORT PURPOSE DESCRIPTION 1900 UPnP SSDP UDP multicast listener Cannot be changed. Binds to all interfaces. May be disabled on confignet. 2827 BOB bridge A higher level socket API for clients. Disabled by default. May be enabled/disabled on configclients. May be changed in the bob.config file. 4444 HTTP proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTP Proxy to configure it. Include in your browser's proxy configuration for HTTP 4445 HTTPS proxy Configured on configclients, go to the page i2ptunnel to start/stop it and on the page I2P HTTPS Proxy to configure it. Include in your browser's proxy configuration for HTTPS 6668 IRC proxy A tunnel to the inside-the-I2P IRC network. Disabled by default. Configured on the page irc.postman.i2p (IRC proxy) and may be enabled/disabled on the page i2ptunnel 7654 I2CP (client protocol) port For advanced client usage. Do not expose to an external network. 7656 SAM bridge A socket API for clients. Disabled by default. May be enabled/disabled on configclients and configured on sam. 7657 (or 7658 via SSL) Router console The router console provides valuable information about your router and the network, in addition to giving you access to configure your router and its associated applications. 7659 'eepsite' - an example webserver (Jetty) Included in the i2pinstall and i2pupdate packages - may be disabled if another webserver is available. May be configured on the page eepsite and disabled on the page i2ptunnel 7660 I2PTunnel UDP port for SSH Required for Grizzled's/novg's UDP support. Instances disabled by default. May be enabled/disabled and configured to use a different port on the page i2ptunnel. 123 NTP Port Used by NTP Time Sync. May be disabled/changed. ### Estão faltando muitos hosts no meu livro de endereços. Quais são alguns bons links de subscrição? {#subscriptions} O livro de endereços está localizado em http://localhost:7657/dns onde mais informações podem ser encontradas.\nQuais são alguns bons links de subscrição para o livro de endereços?\nVocê pode tentar o seguinte:\nhttp://stats.i2p/cgi-bin/newhosts.txt http://identiguy.i2p/hosts.txt Como posso acessar o console web a partir de outras máquinas ou protegê-lo com senha? Por motivos de segurança, o console de administração do router por padrão apenas escuta conexões na interface local.\nExistem dois métodos para acessar o console remotamente:\nTúnel SSH Configurando seu console para estar disponível em um endereço IP público com nome de usuário e senha Estes são detalhados abaixo:\nMétodo 1: Túnel SSH\nSe você está executando um Sistema Operacional tipo Unix, este é o método mais fácil para acessar remotamente seu console I2P. (Nota: software de servidor SSH está disponível para sistemas executando Windows, por exemplo https://github.com/PowerShell/Win32-OpenSSH )\nApós configurar o acesso SSH ao seu sistema, a flag \u0026lsquo;-L\u0026rsquo; é passada ao SSH com os argumentos apropriados - por exemplo:\nssh -L 7657:localhost:7657 (System_IP) onde \u0026lsquo;(System_IP)\u0026rsquo; é substituído pelo endereço IP do seu Sistema. Este comando encaminha a porta 7657 (o número antes dos dois pontos) para a porta 7657 do sistema remoto (conforme especificado pela string \u0026rsquo;localhost\u0026rsquo; entre os primeiros e segundos dois pontos) (o número após os segundos dois pontos). O seu console I2P remoto estará agora disponível no seu sistema local como \u0026lsquo;http://localhost:7657\u0026rsquo; e permanecerá disponível enquanto a sua sessão SSH estiver ativa.\nSe você quiser iniciar uma sessão SSH sem iniciar um shell no sistema remoto, pode adicionar a flag \u0026lsquo;-N\u0026rsquo;:\nssh -NL 7657:localhost:7657 (System_IP) Método 2: Configurando seu console para estar disponível em um endereço IP público com nome de usuário e senha\nAbra ~/.i2p/clients.config e substitua:\nclientApp.0.args=7657 ::1,127.0.0.1 ./webapps/ por:\nclientApp.0.args=7657 ::1,127.0.0.1,(System_IP) ./webapps/ onde você substitui (System_IP) pelo endereço IP público do seu sistema\nAcesse http://localhost:7657/configui e adicione um nome de usuário e senha para o console, se desejar - Adicionar um nome de usuário e senha é altamente recomendado para proteger seu console I2P contra adulterações, o que poderia levar à desanonimização.\nVá para http://localhost:7657/index e clique em \u0026ldquo;Graceful restart\u0026rdquo;, que reinicia a JVM e recarrega as aplicações cliente\nDepois que isso iniciar, você agora deve ser capaz de acessar seu console remotamente. Carregue o console do router em http://(IP_do_Sistema):7657 e você será solicitado a fornecer o nome de usuário e senha que você especificou no passo 2 acima, se o seu navegador suportar o popup de autenticação.\nNOTA: Você pode especificar 0.0.0.0 na configuração acima. Isso especifica uma interface, não uma rede ou máscara de rede. 0.0.0.0 significa \u0026ldquo;vincular a todas as interfaces\u0026rdquo;, portanto pode ser acessível em 127.0.0.1:7657 bem como em qualquer IP LAN/WAN. Tenha cuidado ao usar esta opção, pois o console estará disponível em TODOS os endereços configurados no seu sistema.\nComo posso usar aplicações de outras máquinas? Consulte a resposta anterior para instruções sobre como usar o Encaminhamento de Porta SSH e também veja esta página no seu console: http://localhost:7657/configi2cp É possível usar o I2P como proxy SOCKS? O proxy SOCKS está funcional desde a versão 0.7.1. SOCKS 4/4a/5 são suportados. O I2P não possui um outproxy SOCKS, portanto está limitado ao uso apenas dentro do I2P.\nMuitas aplicações vazam informações sensíveis que podem identificá-lo na Internet e este é um risco que deve estar ciente ao usar o proxy SOCKS do I2P. O I2P filtra apenas os dados de conexão, mas se o programa que você pretende executar enviar essas informações como conteúdo, o I2P não tem como proteger seu anonimato. Por exemplo, algumas aplicações de e-mail enviarão o endereço IP da máquina em que estão sendo executadas para um servidor de e-mail. Recomendamos ferramentas ou aplicações específicas do I2P (como I2PSnark para torrents), ou aplicações que são conhecidas por serem seguras de usar com I2P, incluindo plugins populares encontrados no Firefox .\nComo faço para acessar IRC, BitTorrent ou outros serviços na Internet normal? Existem serviços chamados Outproxies que fazem a ponte entre o I2P e a Internet, como os Tor Exit Nodes. A funcionalidade padrão de outproxy para HTTP e HTTPS é fornecida por exit.stormycloud.i2p e é operada pela StormyCloud Inc. Ela é configurada no HTTP Proxy. Além disso, para ajudar a proteger o anonimato, o I2P não permite que você faça conexões anônimas para a Internet regular por padrão. Consulte a página Socks Outproxy para mais informações.\nReseeds Meu roteador está ativo há vários minutos e tem zero ou muito poucas conexões Primeiro verifique a página http://127.0.0.1:7657/netdb no Console do Router – seu banco de dados de rede (netDb). Se você não vir nenhum router listado de dentro do I2P, mas o console indicar que você deveria estar protegido por firewall, então provavelmente você não consegue se conectar aos servidores de reseed. Se você vir outros routers I2P listados, tente diminuir o número máximo de conexões em http://127.0.0.1:7657/config , talvez seu router não consiga lidar com muitas conexões.\nComo faço o reseed manualmente? Em circunstâncias normais, o I2P irá conectá-lo à rede automaticamente usando nossos links de bootstrap. Se uma conexão de internet interrompida fizer com que o bootstrap a partir dos servidores de reseed falhe, uma maneira fácil de fazer o bootstrap é usando o navegador Tor (Por padrão ele abre localhost), que funciona muito bem com http://127.0.0.1:7657/configreseed . Também é possível fazer o reseed de um router I2P manualmente.\nAo usar o navegador Tor para ressemear, você pode selecionar vários URLs de uma vez e prosseguir. Embora o valor padrão que é 2 (dos vários urls) também funcione, será lento.\nPrivacidade-Segurança O meu router é um \u0026ldquo;nó de saída\u0026rdquo; (outproxy) para a Internet regular? Não quero que seja. Não, o seu router participa no transporte de tráfego cifrado e2e através da rede i2p para um endpoint de tunnel aleatório, normalmente não um outproxy, mas nenhum tráfego é passado entre o seu router e a Internet na camada de transporte. Como utilizador final, não deve executar um outproxy se não tiver competências em administração de sistemas e redes.\nÉ fácil detectar o uso do I2P analisando o tráfego de rede? O tráfego I2P geralmente se assemelha ao tráfego UDP, e nada além disso – e fazer com que pareça não muito mais do que isso é um objetivo. Ele também suporta TCP. Com algum esforço, a análise passiva de tráfego pode ser capaz de classificar o tráfego como \u0026ldquo;I2P\u0026rdquo;, mas esperamos que o desenvolvimento contínuo da ofuscação de tráfego reduza isso ainda mais. Até mesmo uma camada de ofuscação de protocolo bastante simples como obfs4 impedirá que censores bloqueiem o I2P (é um objetivo que o I2P implante).\nÉ seguro usar o I2P? Depende do seu modelo de ameaça pessoal. Para a maioria das pessoas, o I2P é muito mais seguro do que não usar nenhuma proteção. Algumas outras redes (como Tor, mixminion/mixmaster), são provavelmente mais seguras contra certos adversários. Por exemplo, o tráfego I2P não usa TLS/SSL, então não tem os problemas de \u0026ldquo;elo mais fraco\u0026rdquo; que o Tor tem. O I2P foi usado por muitas pessoas na Síria durante a \u0026ldquo;Primavera Árabe\u0026rdquo;, e recentemente o projeto tem visto maior crescimento em instalações linguísticas menores do I2P no Oriente Próximo e Médio. O mais importante a notar aqui é que o I2P é uma tecnologia e você precisa de um guia/tutorial para melhorar sua privacidade/anonimato na Internet. Também verifique seu navegador ou importe o mecanismo de busca de impressão digital para bloquear ataques de fingerprinting com um conjunto de dados muito grande (significando: caudas longas típicas / estrutura de dados diversificada muito precisa) sobre muitas características do ambiente e não use VPN para reduzir todos os riscos que vêm dela mesma, como o comportamento do próprio cache TLS e a construção técnica do negócio do provedor que pode ser hackeado mais facilmente do que um sistema desktop próprio. Talvez usar um Tor V-Browser isolado com suas excelentes proteções anti-fingerprint e uma proteção geral de tempo de vida appguard permitindo apenas as comunicações de sistema necessárias e um último uso de vm com scripts anti-espionagem desabilitados e live-cd para remover qualquer \u0026ldquo;risco quase permanente possível\u0026rdquo; e reduzir todos os riscos por uma probabilidade decrescente sejam uma boa opção em rede pública e modelo de risco individual elevado e pode ser o melhor que você pode fazer com esse objetivo para uso do i2p.\nVejo endereços IP de todos os outros nós I2P no console do router. Isso significa que meu endereço IP está visível para outros? Sim, para outros nós I2P que conhecem o seu router. Usamos isso para conectar com o resto da rede I2P. Os endereços estão fisicamente localizados em \u0026ldquo;routerInfos (objetos chave,valor)\u0026rdquo;, seja obtidos remotamente ou recebidos de peers. Os \u0026ldquo;routerInfos\u0026rdquo; contêm algumas informações (algumas opcionais oportunisticamente adicionadas), \u0026ldquo;publicadas pelo peer\u0026rdquo;, sobre o próprio router para bootstrapping. Nenhum dado está neste objeto sobre clientes. Olhando mais de perto sob o capô, você verá que todos são contados com o tipo mais recente de criação de IDs chamado \u0026ldquo;SHA-256 Hashes (baixo=hash Positivo(-chave), alto=hash Negativo(+chave))\u0026rdquo;. A rede I2P possui um banco de dados próprio de dados de routerInfos criados durante upload e indexação, mas isso depende profundamente da realização das tabelas chave/valor e da topologia da rede e estado de carga / estado de largura de banda e probabilidades de roteamento para armazenamentos nos componentes do DB.\nÉ seguro usar um outproxy? Depende da sua definição de \u0026ldquo;seguro\u0026rdquo;. Os outproxies são ótimos quando funcionam, mas infelizmente são executados voluntariamente por pessoas que podem perder o interesse ou podem não ter os recursos para mantê-los 24/7 – esteja ciente de que você pode experimentar períodos de tempo durante os quais os serviços ficam indisponíveis, interrompidos ou não confiáveis, e não estamos associados a este serviço e não temos influência sobre ele.\nOs próprios outproxys podem ver o seu tráfego entrar e sair, com exceção de dados HTTPS/SSL criptografados de ponta a ponta, assim como o seu provedor de internet (ISP) pode ver o seu tráfego entrar e sair do seu computador. Se você confia no seu provedor de internet, não seria pior com o outproxy.\nE quanto aos ataques de \u0026ldquo;Desanonimização\u0026rdquo;? Para uma explicação mais detalhada, leia mais em nossos artigos sobre Modelo de Ameaças . Em geral, a desanonimização não é trivial, mas é possível se você não for cauteloso o suficiente.\nAcesso à Internet/Desempenho Não consigo acessar sites normais da Internet através do I2P. O proxy para sites da Internet (eepsites que estão voltados para a Internet) é fornecido como um serviço aos usuários do I2P por provedores sem bloqueio. Este serviço não é o foco principal do desenvolvimento do I2P, e é fornecido de forma voluntária. Eepsites que estão hospedados no I2P devem sempre funcionar sem um outproxy (proxy de saída). Outproxies são uma conveniência, mas por design não são perfeitos nem uma parte importante do projeto. Esteja ciente de que eles podem não ser capazes de fornecer o serviço de alta qualidade que outros serviços do I2P podem oferecer.\nNão consigo acessar sites https:// ou ftp:// através do I2P. O proxy HTTP padrão suporta apenas outproxying HTTP e HTTPS.\nPor que meu router está usando muita CPU? Primeiro, certifique-se de ter a versão mais recente de cada componente relacionado ao I2P – versões antigas possuíam seções de código que consumiam CPU desnecessariamente. Há também um registro de desempenho que documenta algumas das melhorias no desempenho do I2P ao longo do tempo.\nMeus pares ativos / pares conhecidos / túneis participantes / conexões / largura de banda variam drasticamente ao longo do tempo! Há algo errado? A estabilidade geral da rede I2P é uma área de pesquisa contínua. Uma parte considerável dessa pesquisa está focada em como pequenas mudanças nas configurações alteram o comportamento do router. Como o I2P é uma rede peer-to-peer, as ações de outros peers influenciarão o desempenho do seu router.\nO que torna downloads, torrents, navegação web e tudo o mais mais lento no I2P em comparação com a internet comum? O I2P possui diferentes proteções que adicionam roteamento extra e camadas adicionais de criptografia. Ele também redireciona o tráfego através de outros peers (Tunnels) que têm sua própria velocidade e qualidade, alguns são lentos, outros rápidos. Isso resulta em muita sobrecarga e tráfego em ritmos diferentes em direções diferentes. Por design, todas essas coisas o tornarão mais lento em comparação com uma conexão direta na internet, mas muito mais anônimo e ainda rápido o suficiente para a maioria das coisas.\nAbaixo está um exemplo apresentado com uma explicação para ajudar a fornecer algum contexto sobre as considerações de latência e largura de banda ao usar o I2P.\nConsidere o diagrama abaixo. Ele representa uma conexão entre um cliente fazendo uma requisição via I2P, um servidor recebendo a requisição via I2P e então respondendo de volta também via I2P. O circuito pelo qual a requisição trafega também está representado.\nA partir do diagrama, considere que as caixas rotuladas \u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo; e \u0026lsquo;R\u0026rsquo; representam um tunnel de saída para \u0026lsquo;A\u0026rsquo; e que as caixas rotuladas \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; e \u0026lsquo;Z\u0026rsquo; representam um tunnel de saída para \u0026lsquo;B\u0026rsquo;. Da mesma forma, as caixas rotuladas \u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo; e \u0026lsquo;Z\u0026rsquo; representam um tunnel de entrada para \u0026lsquo;B\u0026rsquo; enquanto as caixas rotuladas \u0026lsquo;P_1\u0026rsquo;, \u0026lsquo;Q_1\u0026rsquo; e \u0026lsquo;R_1\u0026rsquo; representam um tunnel de entrada para \u0026lsquo;A\u0026rsquo;. As setas entre as caixas mostram a direção do tráfego. O texto acima e abaixo das setas detalha alguns exemplos de largura de banda entre um par de saltos, bem como exemplos de latências.\nQuando tanto o cliente quanto o servidor estão usando tunnels de 3 saltos, um total de 12 outros routers I2P estão envolvidos no relay do tráfego. 6 peers fazem relay do tráfego do cliente para o servidor, que é dividido em um tunnel de saída de 3 saltos de \u0026lsquo;A\u0026rsquo; (\u0026lsquo;P\u0026rsquo;, \u0026lsquo;Q\u0026rsquo;, \u0026lsquo;R\u0026rsquo;) e um tunnel de entrada de 3 saltos para \u0026lsquo;B\u0026rsquo; (\u0026lsquo;X\u0026rsquo;, \u0026lsquo;Y\u0026rsquo;, \u0026lsquo;Z\u0026rsquo;). Da mesma forma, 6 peers fazem relay do tráfego do servidor de volta para o cliente.\nPrimeiro, podemos considerar a latência - o tempo que leva para uma solicitação de um cliente atravessar a rede I2P, alcançar o servidor e retornar ao cliente. Somando todas as latências, vemos que:\n40 + 100 + 20 + 60 + 80 + 10 + 30 ms (client to server) + 60 + 40 + 80 + 60 + 100 + 20 + 40 ms (server to client) ----------------------------------- TOTAL: 740 ms O tempo total de ida e volta no nosso exemplo soma 740 ms - certamente muito maior do que normalmente se veria ao navegar em sites regulares da internet.\nEm segundo lugar, podemos considerar a largura de banda disponível. Isso é determinado pelo link mais lento entre os saltos do cliente e do servidor, bem como quando o tráfego está sendo transmitido pelo servidor para o cliente. Para o tráfego indo do cliente para o servidor, vemos que a largura de banda disponível em nosso exemplo entre os saltos \u0026lsquo;R\u0026rsquo; \u0026amp; \u0026lsquo;X\u0026rsquo;, assim como os saltos \u0026lsquo;X\u0026rsquo; \u0026amp; \u0026lsquo;Y\u0026rsquo;, é de 32 KB/s. Apesar da maior largura de banda disponível entre os outros saltos, esses saltos atuarão como um gargalo e limitarão a largura de banda máxima disponível para o tráfego de \u0026lsquo;A\u0026rsquo; para \u0026lsquo;B\u0026rsquo; em 32 KB/s. Da mesma forma, rastreando o caminho do servidor para o cliente, vemos que há uma largura de banda máxima de 64 KB/s - entre os saltos \u0026lsquo;Z_1\u0026rsquo; \u0026amp; \u0026lsquo;Y_1, \u0026lsquo;Y_1\u0026rsquo; \u0026amp; \u0026lsquo;X_1\u0026rsquo; e \u0026lsquo;Q_1\u0026rsquo; \u0026amp; \u0026lsquo;P_1\u0026rsquo;.\nRecomendamos aumentar os seus limites de largura de banda. Isso ajuda a rede ao aumentar a quantidade de largura de banda disponível, o que por sua vez melhorará a sua experiência no I2P. As configurações de largura de banda estão localizadas na página http://localhost:7657/config . Por favor, esteja ciente dos limites da sua conexão de internet conforme determinado pelo seu provedor de internet (ISP) e ajuste suas configurações de acordo.\nTambém recomendamos definir uma quantidade suficiente de largura de banda compartilhada - isso permite que tunnels participantes sejam roteados através do seu router I2P. Permitir tráfego participante mantém seu router bem integrado na rede e melhora suas velocidades de transferência.\nO I2P é um trabalho em andamento. Muitas melhorias e correções estão sendo implementadas e, de modo geral, executar a versão mais recente ajudará no seu desempenho. Se você ainda não o fez, instale a versão mais recente.\nAcho que encontrei um bug, onde posso reportá-lo? Você pode reportar quaisquer bugs/problemas que encontrar no nosso rastreador de bugs, que está disponível tanto pela internet não-privada quanto pelo I2P. Temos um fórum de discussão, também disponível no I2P e na internet não-privada. Você também pode participar do nosso canal IRC: através da nossa rede IRC, IRC2P, ou no Freenode.\nNosso Bugtracker: Internet não-privada: https://i2pgit.org/I2P_Developers/i2p.i2p/issues No I2P: http://git.idk.i2p/I2P_Developers/i2p.i2p/issues Nossos fóruns: i2pforum.i2p Colar logs: Você pode colar logs interessantes em um serviço de paste como os serviços de internet não-privada listados no PrivateBin Wiki , ou um serviço de paste I2P como esta instância PrivateBin ou este serviço de paste sem Javascript e acompanhar no IRC em #i2p IRC: Entre em #i2p-dev para discutir com os desenvolvedores no IRC Por favor, inclua informações relevantes da página de logs do router disponível em: http://127.0.0.1:7657/logs . Solicitamos que você compartilhe todo o texto da seção \u0026lsquo;I2P Version and Running Environment\u0026rsquo; (Versão do I2P e Ambiente de Execução), bem como quaisquer erros ou avisos exibidos nos diversos logs mostrados na página.\nTenho uma pergunta! Ótimo! Encontre-nos no IRC:\nno irc.freenode.net canal #i2p no IRC2P canal #i2p ou poste no fórum e nós publicaremos aqui (com a resposta, esperamos).\n","description":"FAQ Completo do I2P: ajuda do router, configuração, reseeds, privacidade/segurança, desempenho e solução de problemas","id":"b0f8e4ee3509d229b406a0b0bb933ca4","section":"docs","title":"Perguntas Frequentes","url":"/pt/docs/overview/faq/"},{"categories":null,"content":"Visão geral O I2P Network Protocol (I2NP, protocolo de rede do I2P) define como routers trocam mensagens, selecionam transportes e misturam o tráfego preservando o anonimato. Ele opera entre I2CP (API do cliente) e os protocolos de transporte (NTCP2 e SSU2).\nI2NP é a camada acima dos protocolos de transporte do I2P. É um protocolo de router-para-router usado para: - Consultas e respostas ao banco de dados da rede - Criação de tunnels - Mensagens de dados de router e cliente criptografadas\nMensagens I2NP podem ser enviadas ponto a ponto para outro router, ou enviadas anonimamente através de tunnels para esse router.\nOs Routers enfileiram o trabalho de saída usando prioridades locais. Números de prioridade mais altos são processados primeiro. Qualquer coisa acima da prioridade padrão de dados de tunnel (400) é tratada como urgente.\nTransportes Atuais I2P agora usa NTCP2 (TCP) e SSU2 (UDP) tanto para IPv4 quanto para IPv6. Ambos os transportes utilizam: - X25519 troca de chaves (Noise protocol framework — framework de protocolos Noise) - ChaCha20/Poly1305 criptografia autenticada (AEAD) - SHA-256 para cálculo de hash\nTransportes legados removidos: - NTCP (TCP original) foi removido do Java router na versão 0.9.50 (maio de 2021) - SSU v1 (UDP original) foi removido do Java router na versão 2.4.0 (dezembro de 2023) - SSU v1 foi removido do i2pd na versão 2.44.0 (novembro de 2022)\nA partir de 2025, a rede concluiu a transição para transportes baseados em Noise (framework de protocolos criptográficos), sem qualquer suporte a transportes legados.\nSistema de numeração de versões IMPORTANTE: I2P usa um sistema de versionamento duplo que deve ser claramente compreendido:\nVersões de Lançamento (voltadas para o usuário) Estas são as versões que os usuários veem e baixam: - 0.9.50 (maio de 2021) - Última versão 0.9.x - 1.5.0 (agosto de 2021) - Primeira versão 1.x - 1.6.0, 1.7.0, 1.8.0, 1.9.0 (ao longo de 2021-2022) - 2.0.0 (novembro de 2022) - Primeira versão 2.x - 2.1.0 até 2.9.0 (ao longo de 2023-2025) - 2.10.0 (8 de setembro de 2025) - Versão atual\nVersões da API (Compatibilidade de Protocolo) Estes são números de versão internos publicados no campo \u0026ldquo;router.version\u0026rdquo; nas propriedades do RouterInfo: - 0.9.50 (maio de 2021) - 0.9.51 (agosto de 2021) - Versão da API para o lançamento 1.5.0 - 0.9.52 até 0.9.66 (continuando ao longo dos lançamentos 2.x) - 0.9.67 (setembro de 2025) - Versão da API para o lançamento 2.10.0\nPonto-chave: NÃO houve versões numeradas de 0.9.51 a 0.9.67. Esses números existem apenas como identificadores de versão da API. I2P passou da versão 0.9.50 diretamente para a 1.5.0.\nTabela de Mapeamento de Versões Release Version API Version Date Key Features 0.9.50 0.9.50 May 2021 Last 0.9.x release, removed NTCP1 1.5.0 0.9.51 August 2021 Short tunnel build messages (218 bytes) 1.6.0 0.9.52 November 2021 Various improvements 1.7.0 0.9.53 January 2022 Performance enhancements 1.8.0 0.9.54 May 2022 SSU2 introduced 1.9.0 0.9.55 August 2022 SSU2 improvements 2.0.0 0.9.56 November 2022 SSU2 enabled by default 2.1.0 0.9.57 January 2023 Stability improvements 2.2.0 0.9.58 March 2023 ElGamal routers deprecated 2.3.0 0.9.59 May 2023 Various improvements 2.4.0 0.9.61 December 2023 Removed SSU1 support 2.5.0 0.9.62 February 2024 Performance improvements 2.6.0 0.9.63 May 2024 Network optimizations 2.7.0 0.9.64 October 2024 Post-quantum preparation work 2.8.0 0.9.65 February 2025 Tunnel bandwidth parameters 2.9.0 0.9.66 June 2025 LeaseSet service records 2.10.0 0.9.67 September 2025 Post-quantum hybrid cryptography (beta) **Em breve:** Versão 2.11.0 (prevista para dezembro de 2025) exigirá Java 17+ e habilitará a criptografia pós-quântica por padrão. Versões de Protocolo Todos os routers devem publicar sua versão do protocolo I2NP no campo \u0026ldquo;router.version\u0026rdquo; nas propriedades do RouterInfo. Esse campo de versão é a versão da API, indicando o nível de suporte para vários recursos do protocolo I2NP, e não é necessariamente a versão real do router.\nSe routers alternativos (não Java) desejarem publicar qualquer informação de versão sobre a implementação real do router, devem fazê-lo em outra propriedade. São permitidas versões diferentes das listadas abaixo. O suporte será determinado por meio de uma comparação numérica; por exemplo, 0.9.13 implica suporte para os recursos da 0.9.12.\nObservação: A propriedade \u0026ldquo;coreVersion\u0026rdquo; não é mais publicada nas informações do router e nunca foi utilizada para determinar a versão do protocolo I2NP.\nResumo de funcionalidades por versão da API API Version Required I2NP Features 0.9.67Post-quantum hybrid cryptography (MLKEM ratchet) support (beta), UDP tracker support 0.9.66LeaseSet2 service record options (see proposal 167) 0.9.65Tunnel build bandwidth parameters (see proposal 168) 0.9.59Minimum peers will build tunnels through (as of 0.9.63), minimum floodfill peers will send DSM to (as of 0.9.63) 0.9.58Minimum peers will build tunnels through (as of 0.9.62), ElGamal routers deprecated 0.9.55SSU2 transport support (if published in router info) 0.9.51Short tunnel build messages for ECIES-X25519 routers, minimum peers will build tunnels through (as of 0.9.58), minimum floodfill peers will send DSM to (as of 0.9.58) 0.9.49Garlic messages to ECIES-X25519 routers 0.9.48ECIES-X25519 routers, ECIES-X25519 build request/response records 0.9.46DatabaseLookup flag bit 4 for AEAD reply 0.9.44ECIES-X25519 keys in LeaseSet2 0.9.40MetaLeaseSet may be sent in a DSM 0.9.39EncryptedLeaseSet may be sent in a DSM, RedDSA_SHA512_Ed25519 signature type supported 0.9.38DSM type bits 3-0 now contain the type; LeaseSet2 may be sent in a DSM 0.9.36NTCP2 transport support (if published in router info), minimum peers will build tunnels through (as of 0.9.46) 0.9.28RSA signature types disallowed, minimum floodfill peers will send DSM to (as of 0.9.34) 0.9.18DSM type bits 7-1 ignored 0.9.16RI key certs / ECDSA and EdDSA signature types, DLM lookup types (flag bits 3-2), minimum version compatible with the current network 0.9.15Destination/LeaseSet key certificates with EdDSA Ed25519 signature type (if floodfill) 0.9.12Destination/LeaseSet key certificates with ECDSA P-256, P-384, and P-521 signature types (if floodfill); non-zero expiration allowed in RouterAddress 0.9.7Encrypted DSM/DSRM replies supported (DLM flag bit 1) for floodfill routers 0.9.6Non-zero DLM flag bits 7-1 allowed 0.9.3Requires zero expiration in RouterAddress 0.9Supports up to 16 leases in a DSM LeaseSet store (previously 6) 0.7.12VTBM and VTBRM message support 0.7.10Floodfill supports encrypted DSM stores 0.6.1.10TBM and TBRM messages introduced; minimum version compatible with the current network **Observação:** Há também recursos relacionados ao transporte e problemas de compatibilidade. Consulte a documentação de transporte do NTCP2 e do SSU2 para obter detalhes. Cabeçalho da Mensagem O I2NP usa uma estrutura de cabeçalho lógica de 16 bytes, enquanto os transportes modernos (NTCP2 e SSU2) usam um cabeçalho reduzido de 9 bytes, omitindo campos redundantes de tamanho e soma de verificação. Os campos continuam conceitualmente idênticos.\nComparação do Formato do Cabeçalho Formato Padrão (16 bytes):\nUsado no transporte NTCP legado e quando mensagens I2NP são incorporadas em outras mensagens (TunnelData, TunnelGateway, GarlicClove).\nBytes 0-15: +----+----+----+----+----+----+----+----+ |type| msg_id | expiration +----+----+----+----+----+----+----+----+ | size |chks| +----+----+----+----+----+----+----+----+ type :: Integer (1 byte) Identifies the message type (see message type table) msg_id :: Integer (4 bytes) Uniquely identifies this message (for some time at least) Usually a locally-generated random number, but for outgoing tunnel build messages may be derived from the incoming message expiration :: Date (8 bytes) Unix timestamp in milliseconds when this message expires size :: Integer (2 bytes) Length of the payload (0 to ~61.2 KB for tunnel messages) chks :: Integer (1 byte) SHA256 hash of payload truncated to first byte Deprecated - NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity Formato curto para SSU (obsoleto, 5 bytes):\n+----+----+----+----+----+ |type| short_expiration | +----+----+----+----+----+ type :: Integer (1 byte) short_expiration :: Integer (4 bytes, seconds since epoch) Formato curto para NTCP2, SSU2 e ECIES-Ratchet Garlic Cloves (unidades de mensagem \u0026lsquo;garlic\u0026rsquo;) (9 bytes):\nUtilizado em transportes modernos e em mensagens garlic (mensagens agregadas no I2P) criptografadas com ECIES.\n+----+----+----+----+----+----+----+----+ |type| msg_id | short_expira- +----+----+----+----+----+----+----+----+ tion| +----+ type :: Integer (1 byte) msg_id :: Integer (4 bytes) short_expiration :: Integer (4 bytes, seconds since epoch, unsigned) Detalhes do campo de cabeçalho Field Bytes Description Type 1 Identifies the message class (0\u0026ndash;255, see message types below) Unique ID 4 Locally unique identifier for matching replies Expiration 8 (standard) / 4 (short) Timestamp when the message expires. Routers discard expired messages. Short format uses seconds since epoch (unsigned, wraps February 7, 2106) Payload Length 2 Size in bytes (0 to ~61.2 KB for tunnel messages). NTCP2 and SSU2 encode this in their frame headers Checksum 1 Deprecated. First byte of SHA-256 hash of the payload. NTCP2/SSU2 use ChaCha20/Poly1305 AEAD for integrity ### Notas de Implementação Ao ser transmitido via SSU (obsoleto), apenas o tipo e a expiração de 4 bytes foram incluídos Ao ser transmitido via NTCP2 ou SSU2, usa-se o formato curto de 9 bytes O cabeçalho padrão de 16 bytes é obrigatório para mensagens I2NP contidas em outras mensagens (Data, TunnelData, TunnelGateway, GarlicClove) A partir da versão 0.8.12, a verificação de checksum está desativada em alguns pontos da pilha do protocolo por eficiência, mas a geração de checksum ainda é necessária para compatibilidade A expiração curta é sem sinal e sofrerá wrap-around (reinício/estouro de contagem) em 7 de fevereiro de 2106. Após essa data, deve-se adicionar um deslocamento para obter a hora correta Por compatibilidade com versões antigas, sempre gere checksums, mesmo que possam não ser verificados Restrições de tamanho Mensagens de tunnel fragmentam as cargas úteis do I2NP em partes de tamanho fixo: - Primeiro fragmento: aproximadamente 956 bytes - Fragmentos subsequentes: aproximadamente 996 bytes cada - Máximo de fragmentos: 64 (numerados de 0 a 63) - Carga útil máxima: aproximadamente 61.200 bytes (61,2 KB)\nCálculo: 956 + (63 × 996) = 63.704 bytes como máximo teórico, com limite prático em torno de 61.200 bytes devido à sobrecarga.\nContexto histórico Os transportes antigos tinham limites mais rígidos de tamanho de quadro: - NTCP: quadros de 16 KB - SSU: quadros de aproximadamente 32 KB\nO NTCP2 suporta quadros de aproximadamente 65 KB, mas o limite de fragmentação do tunnel ainda se aplica.\nConsiderações sobre Dados da Aplicação Mensagens garlic (mensagens compostas) podem agrupar LeaseSets, tags de sessão ou variantes de LeaseSet2 criptografadas, reduzindo o espaço disponível para os dados da carga útil.\nRecomendação: Datagramas devem ficar ≤ 10 KB para garantir entrega confiável. Mensagens que se aproximam do limite de 61 KB podem apresentar: - Maior latência devido à remontagem de fragmentos - Maior probabilidade de falha na entrega - Maior exposição à análise de tráfego\nDetalhes técnicos da fragmentação Cada mensagem de tunnel tem exatamente 1.024 bytes (1 KB) e contém: - ID de tunnel de 4 bytes - vetor de inicialização (IV) de 16 bytes - 1.004 bytes de dados criptografados\nDentro dos dados criptografados, as mensagens de tunnel transportam mensagens I2NP fragmentadas com cabeçalhos de fragmento indicando: - Número do fragmento (0-63) - Se este é o primeiro fragmento ou um fragmento subsequente - ID total da mensagem para remontagem\nO primeiro fragmento inclui o cabeçalho completo da mensagem I2NP (16 bytes), deixando aproximadamente 956 bytes para a carga útil. Os fragmentos subsequentes não incluem o cabeçalho da mensagem, permitindo aproximadamente 996 bytes de carga útil por fragmento.\nTipos Comuns de Mensagens Routers usam o tipo de mensagem e a prioridade para agendar o trabalho de saída. Valores de prioridade mais altos são processados primeiro. Os valores abaixo correspondem aos padrões atuais do Java I2P (a partir da versão da API 0.9.67).\nNota: As prioridades dependem da implementação. Para valores de prioridade definitivos, consulte a documentação da classe OutNetMessage no código-fonte do I2P em Java.\nMessage Type Priority Typical Size Purpose DatabaseStore 1 460 Varies (LeaseSet ≈ 898\u0026nbsp;B, RouterInfo ≈ 2\u0026ndash;4\u0026nbsp;KB compressed) Publishes RouterInfo or LeaseSet objects. Supports LeaseSet2, EncryptedLeaseSet, and MetaLeaseSet DatabaseLookup 2 500 Varies Queries the network database for RouterInfo or LeaseSet entries DatabaseSearchReply 3 300 ≈161\u0026nbsp;B (5 hashes) Returns candidate floodfill router hashes (typically 3\u0026ndash;16 hashes, recommended maximum 16) DeliveryStatus 10 Varies 12\u0026nbsp;B Receipts for tunnel tests or acknowledgements inside GarlicMessages GarlicMessage 11 100 (local) Varies Bundles multiple message cloves (e.g., DataMessage, LeaseSets). Supports ElGamal/AES (deprecated) and ECIES-X25519-AEAD-Ratchet encryption TunnelData 18 400 1,028\u0026nbsp;B (fixed) Encrypted tunnel message exchanged between hops. Contains a 4-byte tunnel ID, 16-byte IV, and 1,004 bytes of encrypted data TunnelGateway 19 300\u0026ndash;400 Varies Encapsulates messages at the tunnel gateway before fragmentation DataMessage 20 425 4\u0026ndash;62\u0026nbsp;KB Carries end-to-end garlic payloads (application traffic) TunnelBuild (deprecated) 21 500 4,224\u0026nbsp;B Requests tunnel participation from routers (8 × 528-byte records). Replaced by VariableTunnelBuild for ECIES TunnelBuildReply (deprecated) 22 300 4,224\u0026nbsp;B Replies to TunnelBuild with accept/reject status per hop VariableTunnelBuild 23 500 1,057\u0026ndash;4,225\u0026nbsp;B Variable-length tunnel build for ElGamal or ECIES-X25519 routers (1\u0026ndash;8 records, API 0.9.12+) VariableTunnelBuildReply 24 300 1,057\u0026ndash;4,225\u0026nbsp;B Replies to VariableTunnelBuild ShortTunnelBuild 25 500 873\u0026ndash;1,745\u0026nbsp;B Short tunnel build messages for ECIES-X25519 routers only (1\u0026ndash;8 × 218-byte records, API 0.9.51+) OutboundTunnelBuildReply 26 300 873\u0026ndash;1,745\u0026nbsp;B Sent from outbound endpoint to originator for ECIES-X25519 routers (API 0.9.51+) **Tipos de mensagem reservados:** - Tipo 0: Reservado - Tipos 4-9: Reservados para uso futuro - Tipos 12-17: Reservados para uso futuro - Tipos 224-254: Reservados para mensagens experimentais - Tipo 255: Reservado para expansão futura Notas sobre Tipos de Mensagem Mensagens do plano de controle (DatabaseLookup, TunnelBuild, etc.) normalmente trafegam através de tunnels exploratórios, não de tunnels de cliente, permitindo priorização independente Os valores de prioridade são aproximados e podem variar conforme a implementação TunnelBuild (21) e TunnelBuildReply (22) estão obsoletos, mas ainda são implementados por compatibilidade com tunnels muito longos (\u0026gt;8 saltos) A prioridade padrão de dados de tunnel é 400; qualquer valor acima disso é tratado como urgente O comprimento típico de um tunnel na rede atual é de 3-4 saltos, portanto a maioria das construções de tunnel usa ShortTunnelBuild (registros de 218 bytes) ou VariableTunnelBuild (registros de 528 bytes) Criptografia e Encapsulamento de Mensagens Routers frequentemente encapsulam mensagens I2NP antes da transmissão, criando múltiplas camadas de criptografia. Uma mensagem DeliveryStatus (confirmação de entrega) pode estar: 1. Encapsulada em um GarlicMessage (criptografada) 2. Dentro de um DataMessage 3. Dentro de uma mensagem TunnelData (criptografada novamente)\nCada salto apenas decifra sua camada; o destino final revela a carga útil mais interna.\nAlgoritmos de Criptografia Legado (em fase de descontinuação): - ElGamal/AES + SessionTags (marcadores de sessão) - ElGamal-2048 para criptografia assimétrica - AES-256 para criptografia simétrica - session tags de 32 bytes\nAtual (Padrão desde a API 0.9.48): - ECIES-X25519 + ChaCha20/Poly1305 AEAD com sigilo direto por meio de ratcheting (mecanismo de rotação de chaves) - framework do protocolo Noise (Noise_IK_25519_ChaChaPoly_SHA256 para destinos) - tags de sessão de 8 bytes (reduzidas de 32 bytes) - algoritmo Signal Double Ratchet para sigilo direto - Introduzido na versão 0.9.46 da API (2020) - Obrigatório para todos os routers a partir da versão 0.9.58 da API (2023)\nFuturo (Beta a partir da 2.10.0): - Criptografia híbrida pós-quântica usando MLKEM (ML-KEM-768) combinada com X25519 - Hybrid ratchet (mecanismo de atualização de chaves) combinando acordo de chaves clássico e pós-quântico - Retrocompatível com ECIES-X25519 - Se tornará o padrão na versão 2.11.0 (dezembro de 2025)\nDescontinuação do Router ElGamal CRÍTICO: Os routers ElGamal foram descontinuados a partir da versão 0.9.58 da API (versão 2.2.0, março de 2023). Como a versão mínima recomendada de floodfill para consulta agora é 0.9.58, as implementações não precisam implementar criptografia para routers de floodfill ElGamal.\nNo entanto: destinos ElGamal ainda são suportados para compatibilidade com versões anteriores. Clientes que usam criptografia ElGamal ainda podem se comunicar por meio de ECIES routers.\nDetalhes do ECIES-X25519-AEAD-Ratchet Este é o tipo de criptografia 4 na especificação de criptografia do I2P. Ele fornece:\nPrincipais recursos: - Sigilo futuro por meio de ratcheting (mecanismo de catraca criptográfica; novas chaves para cada mensagem) - Armazenamento reduzido de tags de sessão (8 bytes vs. 32 bytes) - Vários tipos de sessão (Nova sessão, Sessão existente, Uso único) - Baseado no protocolo Noise Noise_IK_25519_ChaChaPoly_SHA256 - Integrado ao algoritmo Double Ratchet do Signal\nPrimitivas criptográficas: - X25519 para acordo de chaves Diffie-Hellman - ChaCha20 para criptografia de fluxo - Poly1305 para autenticação de mensagens (AEAD) - SHA-256 para cálculo de hash - HKDF para derivação de chaves\nGerenciamento de Sessão: - Nova Sessão: Conexão inicial usando chave de destino estática - Sessão Existente: Mensagens subsequentes usando tags de sessão - Sessão de Uso Único: Sessões de mensagem única para menor sobrecarga\nConsulte a Especificação ECIES e a Proposta 144 para obter detalhes técnicos completos.\nEstruturas Comuns As estruturas a seguir são elementos de múltiplas mensagens I2NP. Elas não são mensagens completas.\nRegistro de Solicitação de Construção (ElGamal) OBSOLETO. Utilizado apenas na rede atual quando um tunnel contém um ElGamal router. Veja Criação de ECIES Tunnel para o formato moderno.\nFinalidade: Um registro dentro de um conjunto de vários registros para solicitar a criação de um salto no tunnel.\nFormato:\nCriptografado com ElGamal e AES (528 bytes no total):\n+----+----+----+----+----+----+----+----+ | encrypted data (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Estrutura criptografada ElGamal (528 bytes):\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ElGamal encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity encrypted_data :: ElGamal-2048 encrypted (bytes 1-256 and 258-513 of the 514-byte ElGamal block, with padding bytes at positions 0 and 257 removed) Estrutura de texto em claro (222 bytes antes da criptografia):\n+----+----+----+----+----+----+----+----+ | receive_tunnel (4) | our_ident (32) | +----+----+----+----+ + | | + +----+----+----+----+ | | next_tunnel (4) | +----+----+----+----+----+----+----+----+ | next_ident (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | layer_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | iv_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | reply_iv (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ |flag| request_time (4) | send_msg_id | +----+----+----+----+----+----+----+----+ (4) | padding (29) | +----+----+----+----+----+ + | | + +----+----+ | | +----+----+----+----+----+----+ receive_tunnel :: TunnelId (4 bytes, nonzero) our_ident :: Hash (32 bytes) next_tunnel :: TunnelId (4 bytes, nonzero) next_ident :: Hash (32 bytes) layer_key :: SessionKey (32 bytes) iv_key :: SessionKey (32 bytes) reply_key :: SessionKey (32 bytes) reply_iv :: 16 bytes flag :: Integer (1 byte) request_time :: Integer (4 bytes, hours since epoch = time / 3600) send_message_id :: Integer (4 bytes) padding :: 29 bytes random data Notas: - A criptografia ElGamal-2048 produz um bloco de 514 bytes, mas os dois bytes de preenchimento (nas posições 0 e 257) são removidos, resultando em 512 bytes - Consulte a Especificação de Criação de Tunnel para detalhes dos campos - Código-fonte: net.i2p.data.i2np.BuildRequestRecord - Constante: EncryptedBuildRecord.RECORD_SIZE = 528\nBuildRequestRecord (ECIES-X25519 Longo) Para routers ECIES-X25519, introduzidos na versão 0.9.48 da API. Usam 528 bytes para compatibilidade com versões anteriores em tunnels mistos.\nFormato:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (464 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (464 bytes) mac :: Poly1305 message authentication code (16 bytes) Tamanho total: 528 bytes (igual ao ElGamal para compatibilidade)\nConsulte ECIES Tunnel Creation para obter detalhes sobre a estrutura do texto em claro e sobre a criptografia.\nBuildRequestRecord (ECIES-X25519 Short) Somente para routers ECIES-X25519, a partir da versão 0.9.51 da API (lançamento 1.5.0). Este é o formato padrão atual.\nFormato:\n+----+----+----+----+----+----+----+----+ | toPeer (16 bytes) | +----+----+----+----+----+----+----+----+ | ephemeral_key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (154 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ toPeer :: First 16 bytes of SHA-256 hash of peer\u0026#39;s RouterIdentity ephemeral_key :: X25519 ephemeral public key (32 bytes) encrypted_data :: ChaCha20 encrypted (154 bytes) mac :: Poly1305 message authentication code (16 bytes) Tamanho total: 218 bytes (redução de 59% em relação a 528 bytes)\nDiferença principal: Registros curtos derivam TODAS as chaves via HKDF (função de derivação de chaves) em vez de incluí-las explicitamente no registro. Isso inclui: - Chaves de camada (para criptografia do tunnel) - Chaves IV (para criptografia do tunnel) - Chaves de resposta (para build reply (resposta de construção)) - IVs de resposta (para build reply)\nTodas as chaves são derivadas usando o mecanismo HKDF do Noise protocol (protocolo Noise), com base no segredo compartilhado proveniente da troca de chaves X25519.\nBenefícios: - 4 registros curtos cabem em uma mensagem de tunnel (873 bytes) - construções de tunnel em 3 mensagens em vez de mensagens separadas para cada registro - Redução de largura de banda e latência - Mesmas propriedades de segurança que o formato longo\nConsulte Proposta 157 para a justificativa e ECIES Tunnel Creation para a especificação completa.\nCódigo-fonte: - net.i2p.data.i2np.ShortEncryptedBuildRecord - Constante: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nBuildResponseRecord (registro de resposta de construção) (ElGamal) OBSOLETO. Usado apenas quando o tunnel contém um router ElGamal.\nFinalidade: Um registro em um conjunto de múltiplos registros com respostas a uma solicitação de construção.\nFormato:\nCriptografado (528 bytes, mesmo tamanho que BuildRequestRecord (registro de requisição de construção)):\nbytes 0-527 :: AES-encrypted record Estrutura não criptografada:\n+----+----+----+----+----+----+----+----+ | SHA-256 hash (32 bytes) | + + | (hash of bytes 32-527) | + + | | +----+----+----+----+----+----+----+----+ | random data (495 bytes) | ~ ~ | |ret | +----+----+----+----+----+----+----+----+ bytes 0-31 :: SHA-256 hash of bytes 32-527 bytes 32-526 :: Random data (could be used for congestion info) byte 527 :: Reply code (0 = accept, 30 = reject) Códigos de resposta: - 0 - Aceito - 30 - Rejeitado (largura de banda excedida)\nConsulte Especificação de Criação do Tunnel para obter detalhes sobre o campo de resposta.\nBuildResponseRecord (registro de resposta de construção) (ECIES-X25519) Para routers ECIES-X25519, versão da API 0.9.48+. Tamanho igual ao da solicitação correspondente (528 para o tipo longo, 218 para o tipo curto).\nFormato:\nFormato longo (528 bytes):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (512 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Formato curto (218 bytes):\n+----+----+----+----+----+----+----+----+ | ChaCha20 encrypted data (202 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ Estrutura do texto em claro (ambos os formatos):\nContém uma estrutura de mapeamento (formato de pares chave-valor do I2P) com: - Código de status de resposta (obrigatório) - Parâmetro de largura de banda disponível (\u0026ldquo;b\u0026rdquo;) (opcional, adicionado na API 0.9.65) - Outros parâmetros opcionais para futuras extensões\nCódigos de Status de Resposta: - 0 - Sucesso - 30 - Rejeitado: largura de banda excedida\nConsulte Criação do ECIES Tunnel para a especificação completa.\nGarlicClove (ElGamal/AES) — submensagem usada no esquema garlic encryption AVISO: Este é o formato usado para garlic cloves (submensagens encapsuladas) dentro de garlic messages (mensagens compostas) criptografadas com ElGamal. O formato para garlic messages e garlic cloves ECIES-AEAD-X25519-Ratchet é significativamente diferente. Consulte a Especificação ECIES para o formato moderno.\nObsoleto para routers (API 0.9.58+), ainda suportado para destinos.\nFormato:\nNão criptografado:\n+----+----+----+----+----+----+----+----+ | Delivery Instructions (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message (variable) | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (8) |Cert| +----+----+----+----+----+----+----+----+ (3) | +----+----+----+----+----+----+----+----+ Delivery Instructions :: Variable length (typically 1, 33, or 37 bytes) I2NP Message :: Any I2NP message Clove ID :: 4-byte Integer (random, checked for duplicates) Expiration :: Date (8 bytes) Certificate :: Always NULL (3 bytes total, all zeroes) Notas: - Cloves (submensagens) nunca são fragmentados - Quando o primeiro bit do byte de flag das Instruções de Entrega é 0, o clove não é criptografado - Quando o primeiro bit é 1, o clove é criptografado (recurso não implementado) - O comprimento máximo é uma função dos comprimentos totais dos cloves e do comprimento máximo de GarlicMessage - O certificado poderia possivelmente ser usado com HashCash para \u0026ldquo;pagar\u0026rdquo; pelo roteamento (possibilidade futura) - Mensagens usadas na prática: DataMessage, DeliveryStatusMessage, DatabaseStoreMessage - GarlicMessage pode conter GarlicMessage (garlic aninhado), mas isso não é usado na prática\nVeja Garlic Routing (roteamento Garlic) para uma visão geral conceitual.\nGarlicClove (ECIES-X25519-AEAD-Ratchet) Para routers e destinos ECIES-X25519, versão da API 0.9.46+. Este é o formato padrão atual.\nDIFERENÇA CRÍTICA: ECIES garlic usa uma estrutura totalmente diferente baseada em blocos do Noise protocol (protocolo Noise), em vez de estruturas de clove (submensagens do garlic) explícitas.\nFormato:\nAs mensagens garlic ECIES contêm uma série de blocos:\nBlock structure: +----+----+----+----+----+----+----+----+ |type| length | data ... +----+----+----+----+----+-//- type :: 1 byte block type length :: 2 bytes block length data :: variable length data Tipos de Blocos: - 0 - Garlic Clove Block (submensagem garlic; contém uma mensagem I2NP) - 1 - Bloco de Data e Hora (carimbo de data/hora) - 2 - Bloco de Opções (opções de entrega) - 3 - Bloco de Preenchimento - 254 - Bloco de Terminação (não implementado)\nGarlic Clove Block (tipo 0 — bloco \u0026lsquo;clove\u0026rsquo; de garlic):\n+----+----+----+----+----+----+----+----+ | 0 | length | Delivery Instructions | +----+----+----+----+ + ~ ~ +----+----+----+----+----+----+----+----+ | I2NP Message | ~ ~ +----+----+----+----+----+----+----+----+ | Clove ID (4) | Expiration (4) | +----+----+----+----+----+----+----+----+ Principais diferenças em relação ao formato ElGamal: - Usa expiração de 4 bytes (segundos desde a época Unix) em vez de data de 8 bytes - Sem campo de certificado - Envolvido em uma estrutura de bloco com tipo e comprimento - Mensagem inteira criptografada com ChaCha20/Poly1305 AEAD - Gerenciamento de sessão via ratcheting (mecanismo de atualização progressiva de chaves)\nConsulte a Especificação do ECIES para obter detalhes completos sobre o framework do protocolo Noise e as estruturas de bloco.\nInstruções de Entrega do Garlic Clove (submensagem individual em uma mensagem garlic) Este formato é usado tanto para garlic cloves (submensagens no esquema garlic encryption) de ElGamal quanto de ECIES. Ele especifica como entregar a mensagem contida.\nAVISO CRÍTICO: Esta especificação é APENAS para instruções de entrega dentro de Garlic Cloves (submensagens encapsuladas no esquema garlic encryption). As \u0026ldquo;instruções de entrega\u0026rdquo; também são usadas dentro de Tunnel Messages (mensagens transmitidas via tunnel), onde o formato é significativamente diferente. Consulte a Tunnel Message Specification para instruções de entrega de tunnel. NÃO confunda esses dois formatos.\nFormato:\nA chave de sessão e o atraso não são usados e nunca estão presentes, portanto, os três comprimentos possíveis são: - 1 byte (LOCAL) - 33 bytes (ROUTER e DESTINO) - 37 bytes (TUNNEL)\n+----+----+----+----+----+----+----+----+ |flag| | +----+ + | Session Key (optional, 32) | + + | | + +----+----+----+----+--------------+ | | | +----+ + | To Hash (optional, 32) | + + | | + +----+----+----+----+--------------+ | | Tunnel ID (4, opt)| Delay (4, opt)| +----+----+----+----+----+----+----+----+ flag :: 1 byte Bit order: 76543210 bit 7: encrypted? (Unimplemented, always 0) If 1, a 32-byte encryption session key follows bits 6-5: delivery type 0x0 = LOCAL (0) 0x1 = DESTINATION (1) 0x2 = ROUTER (2) 0x3 = TUNNEL (3) bit 4: delay included? (Not fully implemented, always 0) If 1, four delay bytes are included bits 3-0: reserved, set to 0 for compatibility Session Key :: 32 bytes (Optional, unimplemented) Present if encrypt flag bit is set To Hash :: 32 bytes (Optional) Present if delivery type is DESTINATION, ROUTER, or TUNNEL - DESTINATION: SHA256 hash of the destination - ROUTER: SHA256 hash of the router identity - TUNNEL: SHA256 hash of the gateway router identity Tunnel ID :: 4 bytes (Optional) Present if delivery type is TUNNEL The destination tunnel ID (nonzero) Delay :: 4 bytes (Optional, unimplemented) Present if delay included flag is set Specifies delay in seconds Tamanhos típicos: - entrega LOCAL: 1 byte (apenas flag) - entrega ROUTER / DESTINO: 33 bytes (flag + hash) - entrega TUNNEL: 37 bytes (flag + hash + ID do tunnel)\nDescrições dos Tipos de Entrega:\nType Value Description LOCAL 0 Deliver to the local router (this router) DESTINATION 1 Deliver to a destination (client) identified by hash ROUTER 2 Deliver to another router identified by hash TUNNEL 3 Deliver to a tunnel gateway router **Notas de Implementação:** - A criptografia com chave de sessão não está implementada e o bit de flag é sempre 0 - O atraso não está totalmente implementado e o bit de flag é sempre 0 - Para entrega TUNNEL, o hash identifica o gateway router e o tunnel ID especifica qual tunnel de entrada - Para entrega DESTINATION, o hash é o SHA-256 da chave pública do destino - Para entrega ROUTER, o hash é o SHA-256 da identidade do router Mensagens do I2NP Especificações completas de mensagens para todos os tipos de mensagens do I2NP.\nResumo dos Tipos de Mensagem Message Type Since Status DatabaseStore10.6.1.10Active DatabaseLookup20.6.1.10Active DatabaseSearchReply30.6.1.10Active DeliveryStatus100.6.1.10Active Garlic110.6.1.10Active TunnelData180.6.1.10Active TunnelGateway190.6.1.10Active Data200.6.1.10Active TunnelBuild210.6.1.10Deprecated TunnelBuildReply220.6.1.10Deprecated VariableTunnelBuild230.7.12Active VariableTunnelBuildReply240.7.12Active ShortTunnelBuild250.9.51Active OutboundTunnelBuildReply260.9.51Active **Reservado:** - Tipo 0: Reservado - Tipos 4-9: Reservado para uso futuro - Tipos 12-17: Reservado para uso futuro - Tipos 224-254: Reservado para mensagens experimentais - Tipo 255: Reservado para expansão futura DatabaseStore (Tipo 1) Finalidade: Um armazenamento no banco de dados não solicitado, ou a resposta a uma mensagem DatabaseLookup bem-sucedida.\nConteúdo: Um LeaseSet, LeaseSet2, MetaLeaseSet ou EncryptedLeaseSet não compactado, ou um RouterInfo compactado.\nFormato com token de resposta:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |type| reply token (4) | reply_tunnelId +----+----+----+----+----+----+----+----+ (4) | reply gateway | +----+----+----+----+----+ + | SHA256 hash (32 bytes) | + + | | + +----+ | | +----+----+----+----+----+----+----+ | data ... +----+-// key :: 32 bytes SHA256 hash (the \u0026#34;real\u0026#34; hash, not routing key) type :: 1 byte Type identifier bit 0: 0 = RouterInfo 1 = LeaseSet or variants bits 3-1: (as of 0.9.38) 0: RouterInfo or LeaseSet (types 0 or 1) 1: LeaseSet2 (type 3) 2: EncryptedLeaseSet (type 5) 3: MetaLeaseSet (type 7) 4-7: Unsupported, invalid bits 7-4: Reserved, set to 0 reply token :: 4 bytes If greater than zero, a DeliveryStatusMessage is requested with the Message ID set to the reply token A floodfill router is also expected to flood the data to the closest floodfill peers reply_tunnelId :: 4 bytes (only if reply token \u0026gt; 0) TunnelId of the inbound gateway of the tunnel for the response If 0, reply is sent directly to reply gateway reply gateway :: 32 bytes (only if reply token \u0026gt; 0) SHA256 hash of the RouterInfo If reply_tunnelId is nonzero: inbound gateway router If reply_tunnelId is zero: router to send reply to data :: Variable length If type == 0: 2-byte Integer length + gzip-compressed RouterInfo If type == 1: Uncompressed LeaseSet If type == 3: Uncompressed LeaseSet2 If type == 5: Uncompressed EncryptedLeaseSet If type == 7: Uncompressed MetaLeaseSet Formato com token de resposta == 0:\n+----+----+----+----+----+----+----+----+ | SHA256 Hash as key (32 bytes) | + + | | +----+----+----+----+----+----+----+----+ |type| 0 | data ... +----+----+----+----+----+-// Código-fonte: - net.i2p.data.i2np.DatabaseStoreMessage - net.i2p.data.RouterInfo (para a estrutura RouterInfo) - net.i2p.data.LeaseSet (para a estrutura LeaseSet)\nDatabaseLookup (Tipo 2) Objetivo: Uma solicitação para consultar um item no banco de dados da rede. A resposta pode ser um DatabaseStore ou um DatabaseSearchReply.\nFormato:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as the key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | SHA256 hash of the from router (32) | + or reply tunnel gateway + | | + + | | + + | | +----+----+----+----+----+----+----+----+ |flag| reply_tunnelId (4)| size (2)| | +----+----+----+----+----+----+----+ + | SHA256 of key1 to exclude (32 bytes) | + + | | + +----+ | | | +----+----+----+----+----+----+----+ + | SHA256 of key2 to exclude (32) | + + ~ ~ | | + +----+ | | | +----+----+----+----+----+----+----+ + | Session key if reply encryption | + requested (32 bytes) + | | + +----+ | |tags| +----+----+----+----+----+----+----+----+ | Session tags if reply encryption | + requested (variable) + ~ ~ | | +----+----+----+----+----+----+----+----+ key :: 32 bytes SHA256 hash of the object to lookup from :: 32 bytes If deliveryFlag == 0: SHA256 hash of RouterInfo (sender) If deliveryFlag == 1: SHA256 hash of reply tunnel gateway flags :: 1 byte Bit order: 76543210 bit 0: deliveryFlag 0 = send reply directly 1 = send reply to some tunnel bit 1: encryptionFlag Through 0.9.5: must be 0 As of 0.9.6: ignored As of 0.9.7: 0 = send unencrypted reply 1 = send AES encrypted reply using key and tag bits 3-2: lookup type flags Through 0.9.5: must be 00 As of 0.9.6: ignored As of 0.9.16: 00 = ANY (deprecated, use LS or RI as of 0.9.16) 01 = LS lookup (LeaseSet or variants) 10 = RI lookup (RouterInfo) 11 = exploration lookup (RouterInfo, non-floodfill) bit 4: ECIESFlag Before 0.9.46: ignored As of 0.9.46: 0 = send unencrypted or ElGamal reply 1 = send ChaCha/Poly encrypted reply using key bits 7-5: Reserved, set to 0 reply_tunnelId :: 4 bytes (only if deliveryFlag == 1) TunnelId of the tunnel to send reply to (nonzero) size :: 2 bytes Integer (valid range: 0-512) Number of peers to exclude from DatabaseSearchReply excludedPeers :: $size SHA256 hashes of 32 bytes each If lookup fails, exclude these peers from the reply If includes a hash of all zeroes, the request is exploratory (return non-floodfill routers only) reply_key :: 32 bytes (conditional, see encryption modes below) reply_tags :: 1 byte count + variable length tags (conditional) Modos de Criptografia de Resposta:\nNOTA: Os routers ElGamal estão obsoletos a partir da API 0.9.58. Como a versão mínima recomendada de floodfill para consultar agora é 0.9.58, as implementações não precisam implementar criptografia para routers de floodfill ElGamal. Os destinos ElGamal ainda são suportados.\nO bit 4 de flag (ECIESFlag) é usado em combinação com o bit 1 (encryptionFlag) para determinar o modo de criptografia da resposta:\nFlag bits 4,1 From To Router Reply DH? Notes 0 0 Any Any No encryption n/a No encryption 0 1 ElG ElG AES No As of 0.9.7, deprecated 0.9.58 1 0 ECIES ElG AEAD No As of 0.9.46, deprecated 0.9.58 1 0 ECIES ECIES AEAD No As of 0.9.49, current standard 1 1 ElG ECIES AES Yes TBD, future 1 1 ECIES ECIES AEAD Yes TBD, future **Sem criptografia (flags 0,0):** reply_key, tags e reply_tags não estão presentes.\nElG para ElG (flags 0,1) - OBSOLETO:\nSuportado a partir da versão 0.9.7, obsoleto a partir da versão 0.9.58.\nreply_key :: 32 byte SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (1-32, typically 1) Number of reply tags that follow reply_tags :: One or more 32-byte SessionTags Each is CSRNG(32) random data ECIES para ElG (flags 1,0) - OBSOLETO:\nSuportado a partir da versão 0.9.46, obsoleto a partir da versão 0.9.58.\nreply_key :: 32 byte ECIES SessionKey (big-endian) CSRNG(32) random data tags :: 1 byte Integer (required value: 1) Number of reply tags that follow reply_tags :: One 8-byte ECIES SessionTag CSRNG(8) random data A resposta é uma mensagem ECIES Existing Session (sessão existente), conforme definida em ECIES Specification :\n+----+----+----+----+----+----+----+----+ | Session Tag (8 bytes) | +----+----+----+----+----+----+----+----+ | ChaCha20 encrypted payload | ~ ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | + + | | +----+----+----+----+----+----+----+----+ tag :: 8 byte reply_tag k :: 32 byte session key (the reply_key) n :: 0 (nonce) ad :: The 8 byte reply_tag payload :: Plaintext data (DSM or DSRM) ciphertext = ENCRYPT(k, n, payload, ad) ECIES para ECIES (flags 1,0) - PADRÃO ATUAL:\nUm destino ECIES (esquema de criptografia integrado por curvas elípticas) ou um router envia uma consulta a um router ECIES. Suportado a partir da versão 0.9.49.\nMesmo formato que \u0026ldquo;ECIES to ElG\u0026rdquo; acima. A criptografia da mensagem de consulta é especificada em ECIES Routers . O solicitante é anônimo.\nECIES para ECIES com DH (flags 1,1) - FUTURO:\nAinda não está totalmente definido. Consulte Proposta 156 .\nNotas: - Antes da 0.9.16, a chave podia ser para um RouterInfo ou um LeaseSet (mesmo espaço de chaves, sem flag para distinguir) - Respostas criptografadas só são úteis quando a resposta é através de um tunnel - O número de tags incluídas pode ser maior que um se forem implementadas estratégias alternativas de busca na DHT (tabela hash distribuída) - A chave de busca e as chaves de exclusão são os hashes \u0026ldquo;reais\u0026rdquo;, NÃO chaves de roteamento - Tipos 3, 5 e 7 (variantes de LeaseSet2) podem ser retornados a partir da 0.9.38. Consulte Proposta 123 - Notas sobre consulta exploratória: Uma consulta exploratória é definida para retornar uma lista de hashes não-floodfill próximos da chave. No entanto, as implantações variam: Java de fato procura a chave de busca para um RI (RouterInfo) e retorna um DatabaseStore se presente; i2pd não. Portanto, não é recomendado usar uma consulta exploratória para hashes recebidos anteriormente\nCódigo-fonte: - net.i2p.data.i2np.DatabaseLookupMessage - Criptografia: net.i2p.crypto.SessionKeyManager\nDatabaseSearchReply (Tipo 3) Finalidade: A resposta a uma mensagem DatabaseLookup (consulta ao banco de dados) com falha.\nConteúdo: Uma lista de hashes de routers mais próximos da chave solicitada.\nFormato:\n+----+----+----+----+----+----+----+----+ | SHA256 hash as query key (32 bytes) | + + | | + + | | + + | | +----+----+----+----+----+----+----+----+ | num| peer_hashes (variable) | +----+ + | | ~ ~ | | + +----+----+----+----+----+----+----+ | | from (32 bytes) | +----+ + | | + + | | + + | | + +----+----+----+----+----+----+----+ | | +----+ key :: 32 bytes SHA256 of the object being searched num :: 1 byte Integer Number of peer hashes that follow (0-255) peer_hashes :: $num SHA256 hashes of 32 bytes each (total $num*32 bytes) SHA256 of the RouterIdentity that the sender thinks is close to the key from :: 32 bytes SHA256 of the RouterInfo of the router this reply was sent from Notas: - O hash \u0026lsquo;from\u0026rsquo; não é autenticado e não pode ser considerado confiável - Os hashes de pares retornados não são necessariamente mais próximos da chave do que o router consultado. Para respostas a consultas normais, isso facilita a descoberta de novos floodfills e a pesquisa \u0026ldquo;ao contrário\u0026rdquo; (mais distante da chave) para maior robustez - Para consultas de exploração, a chave geralmente é gerada aleatoriamente. Os peer_hashes não-floodfill da resposta podem ser selecionados usando um algoritmo otimizado (por exemplo, pares próximos, mas não necessariamente os mais próximos) para evitar a ordenação ineficiente de todo o banco de dados local. Estratégias de cache também podem ser usadas. Isso é dependente da implementação - Número típico de hashes retornados: 3 - Número máximo recomendado de hashes a retornar: 16 - A chave da consulta, os hashes de pares e o hash from são hashes \u0026ldquo;reais\u0026rdquo;, NÃO chaves de roteamento - Se num for 0, isso indica que não foram encontrados pares mais próximos (beco sem saída)\nCódigo-fonte: - net.i2p.data.i2np.DatabaseSearchReplyMessage\nDeliveryStatus (Tipo 10) Finalidade: Uma confirmação simples de recebimento de mensagem. Geralmente criada pelo remetente da mensagem e encapsulada em uma Garlic Message (mensagem do tipo \u0026ldquo;garlic\u0026rdquo; no I2P) junto com a própria mensagem, para ser retornada pelo destino.\nConteúdo: O ID da mensagem entregue e o horário de criação ou de chegada.\nFormato:\n+----+----+----+----+----+----+----+----+----+----+----+----+ | msg_id (4) | time_stamp (8) | +----+----+----+----+----+----+----+----+----+----+----+----+ msg_id :: Integer (4 bytes) Unique ID of the message we deliver the DeliveryStatus for (see I2NP Message Header for details) time_stamp :: Date (8 bytes) Time the message was successfully created or delivered Notas: - O carimbo de data/hora é sempre definido pelo criador para o momento atual. No entanto, há vários usos disso no código, e mais podem ser adicionados no futuro - Esta mensagem também é usada como confirmação de sessão estabelecida no SSU. Nesse caso, o ID da mensagem é definido como um número aleatório, e o \u0026ldquo;arrival time\u0026rdquo; é definido como o ID atual de toda a rede, que é 2 (isto é, 0x0000000000000002) - DeliveryStatus geralmente é encapsulado em um GarlicMessage (tipo de mensagem \u0026lsquo;garlic\u0026rsquo; no I2P) e enviado através de um tunnel para fornecer confirmação de recebimento sem revelar o remetente - Usado para testes de tunnel a fim de medir latência e confiabilidade\nCódigo-fonte: - net.i2p.data.i2np.DeliveryStatusMessage - Usado em: net.i2p.router.tunnel.InboundEndpointProcessor para testes de tunnel\nGarlicMessage (mensagem de garlic encryption do I2P; Tipo 11) AVISO: Este é o formato usado para garlic messages criptografadas com ElGamal (mensagens \u0026ldquo;garlic\u0026rdquo;, um formato de encapsulamento em camadas do I2P). O formato das garlic messages do ECIES-AEAD-X25519-Ratchet é significativamente diferente. Consulte Especificação do ECIES para o formato moderno.\nFinalidade: Usado para encapsular várias mensagens I2NP criptografadas.\nConteúdo: Quando decifrado, consiste em uma série de Garlic Cloves (submensagens \u0026lsquo;clove\u0026rsquo;) e dados adicionais, também conhecidos como um Clove Set (conjunto de \u0026lsquo;cloves\u0026rsquo;).\nFormato criptografado:\n+----+----+----+----+----+----+----+----+ | length (4) | data | +----+----+----+----+----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ length :: 4 byte Integer Number of bytes that follow (0 to 64 KB) data :: $length bytes ElGamal encrypted data Dados descriptografados (Clove Set — conjunto de submensagens):\n+----+----+----+----+----+----+----+----+ | num| clove 1 (variable) | +----+ + | | ~ ~ | | +----+----+----+----+----+----+----+----+ | clove 2 (variable) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Certificate (3) | Message_ID (4) | +----+----+----+----+----+----+----+----+ Expiration (8) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Number of GarlicCloves to follow clove :: GarlicClove (see GarlicClove structure above) Certificate :: Always NULL (3 bytes total, all zeroes) Message_ID :: 4 byte Integer Expiration :: Date (8 bytes) Para o formato ECIES-X25519-AEAD-Ratchet (padrão atual para routers):\nConsulte Especificação ECIES e Proposta 144 .\nCódigo-fonte: - net.i2p.data.i2np.GarlicMessage - Criptografia: net.i2p.crypto.elgamal.ElGamalAESEngine (obsoleto) - Criptografia moderna: net.i2p.crypto.ECIES pacotes\nTunnelData (Tipo 18) Finalidade: Uma mensagem enviada a partir do gateway do tunnel ou de um participante para o próximo participante ou endpoint. Os dados têm comprimento fixo, contendo mensagens I2NP que são fragmentadas, agrupadas em lotes, preenchidas e criptografadas.\nFormato:\n+----+----+----+----+----+----+----+----+ | tunnelID (4) | data (1024) | +----+----+----+----+----+ + | | ~ ~ | | + +----+----+----+----+ | | +----+----+----+----+ tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero data :: 1024 bytes Payload data, fixed to 1024 bytes Estrutura da carga útil (1024 bytes):\nBytes 0-15: Initialization Vector (IV) for AES encryption Bytes 16-1023: Encrypted tunnel message data (1008 bytes) Notas: - O ID de mensagem I2NP para TunnelData é definido como um novo número aleatório a cada salto - O formato da mensagem de tunnel (dentro dos dados criptografados) é especificado em Especificação de Mensagens de Tunnel - Cada salto descriptografa uma camada usando AES-256 em modo CBC - O IV é atualizado a cada salto usando os dados descriptografados - O tamanho total é exatamente 1,028 bytes (4 tunnelId + 1024 dados) - Esta é a unidade fundamental do tráfego de tunnel - Mensagens TunnelData transportam mensagens I2NP fragmentadas (GarlicMessage, DatabaseStore, etc.)\nCódigo-fonte: - net.i2p.data.i2np.TunnelDataMessage - Constante: TunnelDataMessage.DATA_LENGTH = 1024 - Processamento: net.i2p.router.tunnel.InboundGatewayProcessor\nTunnelGateway (Tipo 19) Objetivo: Encapsula outra mensagem I2NP para ser enviada para dentro de um tunnel no gateway de entrada do tunnel.\nFormato:\n+----+----+----+----+----+----+----+-// | tunnelId (4) | length (2)| data... +----+----+----+----+----+----+----+-// tunnelId :: 4 bytes TunnelId identifying the tunnel this message is directed at Nonzero length :: 2 byte Integer Length of the payload data :: $length bytes Actual payload of this message Notas: - A carga útil é uma mensagem I2NP com um cabeçalho padrão de 16 bytes - Usado para injetar mensagens em tunnels a partir do router local - O gateway (ponto de entrada) fragmenta a mensagem contida, se necessário - Após a fragmentação, os fragmentos são encapsulados em mensagens TunnelData (tipo de mensagem de dados de tunnel) - TunnelGateway (tipo de mensagem do gateway de tunnel) nunca é enviado pela rede; é um tipo de mensagem interno usado antes do processamento do tunnel\nCódigo-fonte: - net.i2p.data.i2np.TunnelGatewayMessage - Processamento: net.i2p.router.tunnel.OutboundGatewayProcessor\nDataMessage (Tipo 20) Finalidade: Usado por Garlic Messages (mensagens \u0026ldquo;garlic\u0026rdquo;, no I2P) e Garlic Cloves (submensagens \u0026ldquo;cloves\u0026rdquo;) para encapsular dados arbitrários (normalmente dados de aplicação criptografados de ponta a ponta).\nFormato:\n+----+----+----+----+----+----+-//-+ | length (4) | data... | +----+----+----+----+----+----+-//-+ length :: 4 bytes Length of the payload data :: $length bytes Actual payload of this message Notas: - Esta mensagem não contém informações de roteamento e nunca será enviada \u0026ldquo;sem encapsulamento\u0026rdquo; - Usada apenas dentro de mensagens Garlic - Normalmente contém dados de aplicação criptografados de ponta a ponta (HTTP, IRC, e-mail, etc.) - Os dados geralmente consistem em uma carga útil criptografada com ElGamal/AES ou ECIES - O comprimento máximo prático é de cerca de 61.2 KB devido aos limites de fragmentação de mensagens de tunnel\nCódigo-fonte: - net.i2p.data.i2np.DataMessage\nTunnelBuild (Tipo 21) OBSOLETO. Use VariableTunnelBuild (tipo 23) ou ShortTunnelBuild (tipo 25).\nFinalidade: Solicitação de construção de tunnel com comprimento fixo para 8 saltos.\nFormato:\n+----+----+----+----+----+----+----+----+ | Record 0 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 1 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ | Record 7 (528 bytes) | ~ ~ | | +----+----+----+----+----+----+----+----+ Just 8 BuildRequestRecords attached together Record size: 528 bytes Total size: 8 × 528 = 4,224 bytes Notas: - A partir da versão 0.9.48, pode conter ECIES-X25519 BuildRequestRecords (registros de solicitação de construção). Veja ECIES Tunnel Creation - Consulte Tunnel Creation Specification para detalhes - O ID de mensagem I2NP para esta mensagem deve ser definido de acordo com a especificação de criação de tunnel - Embora raramente visto na rede atual (substituído por VariableTunnelBuild (construção de tunnel variável)), ainda pode ser usado para tunnels muito longos e não foi formalmente descontinuado - Routers ainda devem implementar isto para compatibilidade - O formato fixo de 8 registros é inflexível e desperdiça largura de banda para tunnels mais curtos\nCódigo-fonte: - net.i2p.data.i2np.TunnelBuildMessage - Constante: TunnelBuildMessageBase.MAX_RECORD_COUNT = 8\nTunnelBuildReply (Tipo 22) OBSOLETO. Use VariableTunnelBuildReply (tipo 24) ou OutboundTunnelBuildReply (tipo 26).\nFinalidade: Resposta de construção de tunnel de comprimento fixo para 8 saltos.\nFormato:\nMesmo formato que TunnelBuildMessage, com BuildResponseRecords em vez de BuildRequestRecords.\nTotal size: 8 × 528 = 4,224 bytes Notas: - A partir da versão 0.9.48, pode conter ECIES-X25519 BuildResponseRecords. Veja Criação de tunnel ECIES - Veja Especificação de Criação de tunnel para detalhes - O ID de mensagem I2NP para esta mensagem deve ser definido de acordo com a especificação de criação de tunnel - Embora raramente visto na rede atual (substituído por VariableTunnelBuildReply (resposta de construção de tunnel variável)), ainda pode ser usado para tunnels muito longos e não foi formalmente descontinuado - Routers ainda devem implementar isso para compatibilidade\nCódigo-fonte: - net.i2p.data.i2np.TunnelBuildReplyMessage\nVariableTunnelBuild (Tipo 23) Objetivo: Criação de tunnel com comprimento variável de 1 a 8 saltos. Suporta ambos os routers ElGamal e ECIES-X25519.\nFormato:\n+----+----+----+----+----+----+----+----+ | num| BuildRequestRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildRequestRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Notas: - A partir da 0.9.48, pode conter ECIES-X25519 BuildRequestRecords (registros de solicitação de construção). Veja Criação de tunnel com ECIES (esquema integrado de criptografia de curva elíptica) - Introduzido na versão 0.7.12 do router (2009) - Pode não ser enviado a participantes do tunnel com versões anteriores à 0.7.12 - Veja Especificação de Criação de Tunnel para detalhes - O ID de mensagem I2NP deve ser definido de acordo com a especificação de criação de tunnel - Número típico de registros: 4 (para um tunnel de 4 saltos) - Tamanho total típico: 1 + (4 × 528) = 2,113 bytes - Esta é a mensagem padrão de construção de tunnel para routers ElGamal (algoritmo de criptografia assimétrica ElGamal) - Routers ECIES geralmente usam ShortTunnelBuild (mensagem de construção de tunnel curta) (type 25) em vez disso\nCódigo-fonte: - net.i2p.data.i2np.VariableTunnelBuildMessage\nVariableTunnelBuildReply (Tipo 24) Finalidade: Resposta de construção de tunnel de comprimento variável para 1-8 saltos. Suporta ambos os routers ElGamal e ECIES-X25519.\nFormato:\nMesmo formato que VariableTunnelBuildMessage, com BuildResponseRecords em vez de BuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| BuildResponseRecords (variable) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 BuildResponseRecords :: $num records of 528 bytes each Record size: 528 bytes Total size: 1 + ($num × 528) bytes Notas: - A partir da versão 0.9.48, pode conter ECIES-X25519 BuildResponseRecords (registros de resposta de construção). Consulte Criação de Tunnel ECIES - Introduzido na versão 0.7.12 do router (2009) - Não deve ser enviado a participantes do tunnel com versões anteriores à 0.7.12 - Consulte Especificação de Criação de Tunnel para detalhes - O ID de mensagem I2NP deve ser definido de acordo com a especificação de criação de tunnel - Número típico de registros: 4 - Tamanho total típico: 2,113 bytes\nCódigo-fonte: - net.i2p.data.i2np.VariableTunnelBuildReplyMessage\nShortTunnelBuild (Tipo 25) Finalidade: Mensagens curtas de construção de tunnel apenas para routers ECIES-X25519. Introduzidas na versão 0.9.51 da API (lançamento 1.5.0, agosto de 2021). Este é o padrão atual para construções de tunnel ECIES.\nFormato:\n+----+----+----+----+----+----+----+----+ | num| ShortBuildRequestRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildRequestRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Notas: - Introduzido na versão 0.9.51 do router (release 1.5.0, agosto de 2021) - Não deve ser enviado a participantes do tunnel com versão da API anterior à 0.9.51 - Consulte ECIES Tunnel Creation para a especificação completa - Consulte Proposal 157 para a justificativa - Número típico de registros: 4 - Tamanho total típico: 1 + (4 × 218) = 873 bytes - Economia de largura de banda: 59% menor que VariableTunnelBuild (873 vs. 2.113 bytes) - Benefício de desempenho: 4 registros curtos cabem em uma mensagem de tunnel; VariableTunnelBuild requer 3 mensagens de tunnel - Este é agora o formato padrão de construção de tunnel para tunnels ECIES-X25519 puros - Os registros derivam chaves via HKDF em vez de incluí-las explicitamente\nCódigo-fonte: - net.i2p.data.i2np.ShortTunnelBuildMessage - Constante: ShortEncryptedBuildRecord.RECORD_SIZE = 218\nOutboundTunnelBuildReply (resposta de construção de tunnel de saída) (Tipo 26) Finalidade: Enviado da extremidade de saída de um novo tunnel para o originador. Apenas para routers ECIES-X25519. Introduzido na versão da API 0.9.51 (release 1.5.0, agosto de 2021).\nFormato:\nMesmo formato que ShortTunnelBuildMessage, com ShortBuildResponseRecords em vez de ShortBuildRequestRecords.\n+----+----+----+----+----+----+----+----+ | num| ShortBuildResponseRecords (var) | +----+----+----+----+----+----+----+----+ num :: 1 byte Integer Valid values: 1-8 ShortBuildResponseRecords :: $num records of 218 bytes each Record size: 218 bytes Total size: 1 + ($num × 218) bytes Notas: - Introduzido na versão do router 0.9.51 (release 1.5.0, agosto de 2021) - Consulte ECIES Tunnel Creation para a especificação completa - Número típico de registros: 4 - Tamanho total típico: 873 bytes - Esta resposta é enviada do endpoint de saída (OBEP) de volta ao criador do tunnel através do tunnel de saída recém-criado - Fornece confirmação de que todos os saltos aceitaram a construção do tunnel\nCódigo-fonte: - net.i2p.data.i2np.OutboundTunnelBuildReplyMessage\nReferências Especificações Oficiais Especificação do I2NP - Especificação completa do formato de mensagens do I2NP Estruturas Comuns - Tipos de dados e estruturas utilizados em todo o I2P Criação de tunnel - Criação de tunnel ElGamal (obsoleta) Criação de tunnel ECIES - Criação de tunnel ECIES-X25519 (atual) Mensagem de tunnel - Formato de mensagem de tunnel e instruções de entrega Especificação do NTCP2 - Protocolo de transporte TCP Especificação do SSU2 - Protocolo de transporte UDP Especificação do ECIES - Criptografia ECIES-X25519-AEAD-Ratchet Especificação de Criptografia - Primitivas criptográficas de baixo nível Especificação do I2CP - Especificação do protocolo do cliente Especificação de Datagramas - Formatos Datagram2 e Datagram3 Propostas Proposal 123 - Novas entradas no netDB (LeaseSet2, EncryptedLeaseSet, MetaLeaseSet) Proposal 144 - Criptografia ECIES-X25519-AEAD-Ratchet Proposal 154 - Consulta criptografada ao banco de dados Proposal 156 - ECIES routers Proposal 157 - Mensagens de criação de tunnel (formato curto) Proposal 159 - Transporte SSU2 Proposal 161 - Preenchimento compressível Proposal 163 - Datagram2 e Datagram3 Proposal 167 - Parâmetros do registro de serviço do LeaseSet Proposal 168 - Parâmetros de largura de banda para a criação de tunnel Proposal 169 - Criptografia híbrida pós-quântica Documentação Garlic Routing (roteamento garlic) - Agrupamento de mensagens em camadas ElGamal/AES - Esquema de criptografia obsoleto Implementação de Tunnel - Fragmentação e processamento Banco de dados da rede - Tabela hash distribuída Transporte NTCP2 - Especificação de transporte TCP Transporte SSU2 - Especificação de transporte UDP Introdução técnica - Visão geral da arquitetura do I2P Código-fonte Java I2P Repository - Implementação oficial em Java GitHub Mirror - Espelho no GitHub do Java I2P i2pd Repository - Implementação em C++ Principais locais do código-fonte Java I2P (i2pgit.org/I2P_Developers/i2p.i2p): - core/java/src/net/i2p/data/i2np/ - Implementações de mensagens I2NP (protocolo de rede da I2P) - core/java/src/net/i2p/crypto/ - Implementações criptográficas - router/java/src/net/i2p/router/tunnel/ - Processamento de tunnel (túnel da I2P) - router/java/src/net/i2p/router/transport/ - Implementações de transporte\nConstantes e valores: - I2NPMessage.MAX_SIZE = 65536 - Tamanho máximo da mensagem I2NP - I2NPMessageImpl.HEADER_LENGTH = 16 - Tamanho padrão do cabeçalho - TunnelDataMessage.DATA_LENGTH = 1024 - Carga útil da mensagem de tunnel - EncryptedBuildRecord.RECORD_SIZE = 528 - Build record (registro de construção) longo - ShortEncryptedBuildRecord.RECORD_SIZE = 218 - Build record curto - TunnelBuildMessageBase.MAX_RECORD_COUNT = 8 - Máximo de registros por build\nApêndice A: Estatísticas da Rede e Estado Atual Composição da Rede (em outubro de 2025) Total de routers: Aproximadamente 60.000-70.000 (varia) Floodfill routers: Aproximadamente 500-700 ativos Tipos de criptografia: ECIES-X25519: \u0026gt;95% dos routers ElGamal: \u0026lt;5% dos routers (obsoleto, apenas legado) Adoção de transportes: SSU2: \u0026gt;60% como transporte principal NTCP2: ~40% como transporte principal Transportes legados (SSU1, NTCP): 0% (removidos) Tipos de assinatura: EdDSA (Ed25519): Imensa maioria ECDSA: Pequena porcentagem RSA: Não permitido (removido) Requisitos mínimos do Router Versão da API: 0.9.16+ (para compatibilidade do EdDSA com a rede) Mínimo recomendado: API 0.9.51+ (compilações ECIES para short tunnel) Mínimo atual para floodfills: API 0.9.58+ (obsolescência do router ElGamal) Requisito futuro: Java 17+ (a partir da versão 2.11.0, dezembro de 2025) Requisitos de Largura de Banda Mínimo: 128 KBytes/sec (flag N ou superior) para floodfill Recomendado: 256 KBytes/sec (flag O) ou superior Requisitos de floodfill: Largura de banda mínima de 128 KB/sec Tempo de atividade estável (\u0026gt;95% recomendado) Baixa latência (\u0026lt;500ms para os pares) Aprovar nos testes de integridade (tempo de fila, atraso de tarefas) Estatísticas de Tunnel Comprimento típico do tunnel: 3-4 saltos Comprimento máximo do tunnel: 8 saltos (teórico, raramente utilizado) Tempo de vida típico do tunnel: 10 minutos Taxa de sucesso de construção de tunnel: \u0026gt;85% para routers bem conectados Formato da mensagem de construção de tunnel: routers ECIES: ShortTunnelBuild (registros de 218 bytes) tunnels mistos: VariableTunnelBuild (registros de 528 bytes) Métricas de Desempenho Tempo de construção do Tunnel: 1-3 segundos (típico) Latência fim a fim: 0.5-2 segundos (típica, 6-8 saltos no total) Taxa de transferência: Limitada pela largura de banda do tunnel (tipicamente 10-50 KB/sec por tunnel) Tamanho máximo do datagrama: 10 KB recomendado (61.2 KB de máximo teórico) Apêndice B: Funcionalidades Obsoletas e Removidas Completamente removido (não é mais suportado) Transporte NTCP - Removido na versão 0.9.50 (maio de 2021) Transporte SSU v1 - Removido do Java I2P na versão 2.4.0 (dezembro de 2023) Transporte SSU v1 - Removido do i2pd na versão 2.44.0 (novembro de 2022) Tipos de assinatura RSA - Não permitidos a partir da API 0.9.28 Obsoleto (Suportado mas Não Recomendado) ElGamal routers - Obsoletos desde a API 0.9.58 (março de 2023) Destinos ElGamal ainda suportados para compatibilidade com versões anteriores Novos routers devem usar ECIES-X25519 exclusivamente TunnelBuild (tipo 21) - Obsoleto em favor de VariableTunnelBuild e ShortTunnelBuild Ainda implementado para tunnels muito longos (\u0026gt;8 saltos) TunnelBuildReply (tipo 22) - Obsoleto em favor de VariableTunnelBuildReply e OutboundTunnelBuildReply Criptografia ElGamal/AES - Obsoleta em favor de ECIES-X25519-AEAD-Ratchet Ainda usada para destinos legados ECIES BuildRequestRecords (registros de solicitação de construção) longos (528 bytes) - Obsoletos em favor do formato curto (218 bytes) Ainda usados para tunnels mistos com saltos ElGamal Cronograma de suporte legado Feature Introduced Deprecated Removed Notes NTCP 2003 2018 (0.9.36) 2021 (0.9.50) Replaced by NTCP2 SSU v1 2004 2022 (0.9.54) 2023 (Java) / 2022 (i2pd) Replaced by SSU2 ElGamal routers 2003 2023 (0.9.58) TBD Destinations still supported RSA signatures 2015 2017 2017 (0.9.28) Never widely used TunnelBuild 2004 2009 (0.7.12) Not removed Still supported for long tunnels --- Apêndice C: Desenvolvimentos futuros Criptografia pós-quântica Status: Beta desde a versão 2.10.0 (setembro de 2025), passará a ser o padrão na 2.11.0 (dezembro de 2025)\nImplementação: - Abordagem híbrida que combina X25519 clássico e MLKEM pós-quântico (ML-KEM-768) - Retrocompatível com a infraestrutura ECIES-X25519 existente - Usa o Signal Double Ratchet (algoritmo Double Ratchet do Signal) com material de chave tanto clássico quanto pós-quântico - Veja Proposta 169 para detalhes\nCaminho de migração: 1. Versão 2.10.0 (setembro de 2025): Disponível como opção beta 2. Versão 2.11.0 (dezembro de 2025): Habilitado por padrão 3. Versões futuras: Passará a ser obrigatório\nFuncionalidades planejadas Melhorias no IPv6 - Melhor suporte a IPv6 e mecanismos de transição Limitação de taxa por tunnel - Controle granular de largura de banda por tunnel Métricas aprimoradas - Melhor monitoramento de desempenho e diagnóstico Otimizações de protocolo - Menor sobrecarga e eficiência aprimorada Seleção de floodfill aprimorada - Melhor distribuição do banco de dados da rede Áreas de Pesquisa Otimização do comprimento do tunnel - Comprimento de tunnel dinâmico baseado no modelo de ameaça Preenchimento avançado - Melhorias na resistência à análise de tráfego Novos esquemas de criptografia - Preparação para ameaças da computação quântica Controle de congestionamento - Melhor gerenciamento da carga de rede Suporte móvel - Otimizações para dispositivos e redes móveis Apêndice D: Diretrizes de Implementação Para novas implementações Requisitos mínimos: 1. Suporte aos recursos da API versão 0.9.51+ 2. Implementar criptografia ECIES-X25519-AEAD-Ratchet (ratchet: mecanismo de avanço progressivo do estado criptográfico) 3. Suporte aos transportes NTCP2 e SSU2 4. Implementar mensagens ShortTunnelBuild (construção abreviada de tunnel) (registros de 218 bytes) 5. Suporte às variantes LeaseSet2 (tipos 3, 5, 7) 6. Usar assinaturas EdDSA (Ed25519)\nRecomendado: 1. Suportar criptografia híbrida pós-quântica (a partir da versão 2.11.0) 2. Implementar parâmetros de largura de banda por tunnel 3. Suportar os formatos Datagram2 e Datagram3 4. Implementar opções de registro de serviço em LeaseSets 5. Seguir as especificações oficiais em /docs/specs/\nNão obrigatório: 1. Suporte ao router ElGamal (obsoleto) 2. Suporte a transportes legados (SSU1, NTCP) 3. BuildRequestRecords ECIES longos (registros de solicitação de construção) (528 bytes para tunnels ECIES puros) 4. Mensagens TunnelBuild/TunnelBuildReply (use as variantes Variable ou Short)\nTestes e Validação Conformidade com o Protocolo: 1. Testar interoperabilidade com o router I2P oficial em Java 2. Testar interoperabilidade com o router i2pd em C++ 3. Validar os formatos de mensagem conforme as especificações 4. Testar ciclos de construção/desmontagem de tunnel 5. Verificar criptografia/descriptografia com vetores de teste\nTestes de Desempenho: 1. Medir as taxas de sucesso da construção de tunnel (devem ser \u0026gt;85%) 2. Testar com vários comprimentos de tunnel (2-8 saltos) 3. Validar fragmentação e remontagem 4. Testar sob carga (múltiplos tunnels simultâneos) 5. Medir a latência de ponta a ponta\nTestes de segurança: 1. Verifique a implementação da criptografia (use vetores de teste) 2. Teste a prevenção de ataques de repetição 3. Valide o tratamento da expiração de mensagens 4. Teste contra mensagens malformadas 5. Verifique a geração adequada de números aleatórios\nArmadilhas comuns na implementação Formatos de instruções de entrega confusos - garlic clove (submensagem encapsulada) vs mensagem de tunnel Derivação de chave incorreta - Uso de HKDF para registros de construção curtos Tratamento do ID da mensagem - Não definido corretamente para construções de tunnel Problemas de fragmentação - Não respeitar o limite prático de 61,2 KB Erros de endianness (ordem dos bytes) - Java usa big-endian para todos os inteiros Tratamento de expiração - O formato curto transborda em 7 de fevereiro de 2106 Geração de checksum - Ainda é obrigatória mesmo que não seja verificada ","description":"Formatos de mensagens de router para router, prioridades e limites de tamanho dentro do I2P.","id":"917124900b0896942323b4effccf9b55","section":"docs","title":"Protocolo de Rede I2P (I2NP)","url":"/pt/docs/specs/i2np/"},{"categories":null,"content":"Visão Geral A I2P Streaming Library fornece transporte confiável, ordenado e autenticado sobre a camada de mensagens do I2P, semelhante ao TCP sobre IP. Ela fica acima do protocolo I2CP e é usada por quase todas as aplicações interativas do I2P, incluindo proxies HTTP, IRC, BitTorrent e email.\nCaracterísticas Principais Configuração de conexão em uma fase usando flags SYN, ACK e FIN que podem ser agrupadas com dados de payload para reduzir ida e volta. Controle de congestionamento por janela deslizante, com início lento e prevenção de congestionamento ajustados para o ambiente de alta latência do I2P. Compressão de pacotes (segmentos comprimidos de 4KB por padrão) equilibrando custo de retransmissão e latência de fragmentação. Abstração de canal totalmente autenticado, criptografado e confiável entre destinos I2P. Este design permite que pequenas requisições e respostas HTTP sejam concluídas em uma única ida e volta. Um pacote SYN pode transportar a carga útil da requisição, enquanto o SYN/ACK/FIN do respondedor pode conter o corpo completo da resposta.\nConceitos Básicos da API A API de streaming Java espelha a programação padrão de sockets Java:\nI2PSocketManager mgr = I2PSocketManagerFactory.createManager(host, port, options); I2PSocket socket = mgr.connect(destination); I2PServerSocket server = mgr.getServerSocket(); I2PSocketManagerFactory negocia ou reutiliza uma sessão de router via I2CP. Se nenhuma chave for fornecida, um novo destino é gerado automaticamente. Desenvolvedores podem passar opções I2CP (por exemplo, comprimentos de tunnel, tipos de criptografia ou configurações de conexão) através do mapa options. I2PSocket e I2PServerSocket espelham as interfaces padrão Socket do Java, tornando a migração direta. Os Javadocs completos estão disponíveis no console do roteador I2P ou aqui .\nConfiguração e Ajuste Você pode passar propriedades de configuração ao criar um gerenciador de socket através de:\nI2PSocketManagerFactory.createManager(host, port, properties); Opções de Chave Option Description Default i2p.streaming.maxWindowSize Maximum send window (bytes) 128 KB i2p.streaming.initialRTO Initial retransmission timeout 9s i2p.streaming.inactivityTimeout Timeout before connection close 90s i2p.streaming.enforceProtocol Enforce protocol ID (prevents confusion) true i2p.streaming.congestionAlgorithm Congestion control method Default (AIMD TCP-like) i2p.streaming.disableRejectLogging Disable logging rejected packets false ### Comportamento por Carga de Trabalho Workload Recommended Settings HTTP-like Default parameters are ideal. Bulk Transfer Increase window size to 256 KB or 512 KB; lengthen timeouts. Real-time Streaming Lower tunnel length to 1-2 hops; adjust RTO downwards. Recursos mais recentes desde a versão 0.9.4 incluem supressão de log de rejeição, suporte à lista DSA (0.9.21) e aplicação obrigatória de protocolo (0.9.36). Routers desde a versão 2.10.0 incluem criptografia híbrida pós-quântica (ML-KEM + X25519) na camada de transporte. Detalhes do Protocolo Cada stream é identificado por um Stream ID. Os pacotes transportam sinalizadores de controle semelhantes ao TCP: SYNCHRONIZE, ACK, FIN e RESET. Os pacotes podem conter simultaneamente dados e sinalizadores de controle, melhorando a eficiência para conexões de curta duração.\nCiclo de Vida da Conexão SYN enviado — o iniciador inclui dados opcionais. Resposta SYN/ACK — o respondedor inclui dados opcionais. Finalização ACK — estabelece confiabilidade e estado de sessão. FIN/RESET — usado para fechamento ordenado ou terminação abrupta. Fragmentação e Reordenação Como os túneis I2P introduzem latência e reordenação de mensagens, a biblioteca armazena em buffer os pacotes de streams desconhecidos ou que chegam antecipadamente. As mensagens armazenadas em buffer são mantidas até que a sincronização seja concluída, garantindo entrega completa e em ordem.\nAplicação de Protocolo A opção i2p.streaming.enforceProtocol=true (padrão desde a versão 0.9.36) garante que as conexões usem o número de protocolo I2CP correto, prevenindo conflitos entre múltiplos subsistemas que compartilham um mesmo destino.\nInteroperabilidade e Boas Práticas O protocolo de streaming coexiste com a API de Datagramas, dando aos desenvolvedores a escolha entre transportes orientados a conexão e sem conexão.\nUse Case Recommended Transport Reliable, ordered data (HTTP, IRC, FTP) Streaming Connectionless or lossy data (DNS, telemetry) Datagram ### Clientes Compartilhados As aplicações podem reutilizar túneis existentes executando como clientes compartilhados, permitindo que múltiplos serviços compartilhem o mesmo destino. Embora isso reduza a sobrecarga, aumenta o risco de correlação entre serviços—use com cuidado.\nControle de Congestionamento A camada de streaming se adapta continuamente à latência e vazão da rede através de feedback baseado em RTT. As aplicações têm melhor desempenho quando os routers são peers contribuintes (túneis participantes habilitados). Mecanismos de controle de congestionamento semelhantes ao TCP previnem a sobrecarga de peers lentos e ajudam a equilibrar o uso de largura de banda através dos túneis. Considerações sobre Latência Como o I2P adiciona várias centenas de milissegundos de latência base, as aplicações devem minimizar as viagens de ida e volta. Agrupe dados com a configuração de conexão sempre que possível (por exemplo, requisições HTTP no SYN). Evite designs que dependam de muitas trocas sequenciais pequenas.\nTestes e Compatibilidade Sempre teste contra Java I2P e i2pd para garantir compatibilidade total. Embora o protocolo seja padronizado, pequenas diferenças de implementação podem existir. Lide com routers mais antigos de forma adequada—muitos peers ainda executam versões anteriores à 2.0. Monitore estatísticas de conexão usando I2PSocket.getOptions() e getSession() para ler métricas de RTT e retransmissão. O desempenho depende fortemente da configuração do tunnel: - Tunnels curtos (1–2 hops) → menor latência, anonimato reduzido. - Tunnels longos (3+ hops) → maior anonimato, RTT aumentado.\nMelhorias Principais (2.0.0–2.10.0) Feature Introduced Description Persistent ACK Bundling 2.0.0 Optimized round-trip reduction for HTTP workloads. Adaptive Window Scaling 2.3.0 Improved large file transfer stability. Thread Pooling and Socket Reuse 2.5.0 Reduced per-connection overhead. Protocol Enforcement Default 0.9.36 Ensures correct stream usage. Hybrid ML-KEM Ratchet 2.10.0 Adds post-quantum hybrid encryption layer. i2pd Streaming API Compatibility Fixes 2.9.0 Full parity with Java I2P library behavior. --- Resumo A Biblioteca de Streaming I2P é a espinha dorsal de toda comunicação confiável dentro do I2P. Ela garante entrega de mensagens ordenada, autenticada e criptografada, e fornece uma substituição quase direta para TCP em ambientes anônimos.\nPara obter desempenho ideal: - Minimize idas e voltas com agrupamento SYN+payload. - Ajuste os parâmetros de janela e timeout para sua carga de trabalho. - Prefira tunnels mais curtos para aplicações sensíveis à latência. - Use designs amigáveis ao congestionamento para evitar sobrecarregar peers.\n","description":"Transporte similar ao TCP usado pela maioria das aplicações I2P","id":"d5eaf45dea26928a910e0f2b8a0e1037","section":"docs","title":"Protocolo de Streaming","url":"/pt/docs/api/streaming/"},{"categories":null,"content":"Visão geral A Biblioteca de Streaming do I2P fornece entrega de dados confiável, em ordem e autenticada sobre a camada de mensagens não confiável do I2P — análoga ao TCP sobre IP. Ela é usada por quase todas as aplicações interativas do I2P, como navegação na web, IRC, e-mail e compartilhamento de arquivos.\nIsso garante transmissão confiável, controle de congestionamento, retransmissão e controle de fluxo através dos tunnels anônimos de alta latência do I2P. Cada fluxo é totalmente criptografado de ponta a ponta entre os destinos.\nPrincípios Fundamentais de Design A biblioteca de streaming implementa um estabelecimento de conexão em uma única fase, em que as flags SYN, ACK e FIN podem transportar cargas úteis de dados na mesma mensagem. Isso minimiza as idas e voltas em ambientes de alta latência — uma pequena transação HTTP pode ser concluída em uma única ida e volta.\nO controle de congestionamento e a retransmissão são modelados a partir do TCP, mas adaptados ao ambiente do I2P. Os tamanhos de janela são baseados em mensagens, não em bytes, e ajustados para a latência do tunnel e a sobrecarga. O protocolo oferece suporte a início lento, evitação de congestionamento e retrocesso exponencial, semelhantes ao algoritmo AIMD do TCP (Aumento Aditivo e Diminuição Multiplicativa).\nArquitetura A biblioteca de streaming opera entre as aplicações e a interface I2CP.\nLayer Responsibility Application Standard I2PSocket and I2PServerSocket usage Streaming Library Connection setup, sequencing, retransmission, and flow control I2CP Tunnel creation, routing, and message handling I2NP / Router Layer Transport through tunnels A maioria dos usuários o acessa via I2PSocketManager, I2PTunnel ou SAMv3. A biblioteca lida de forma transparente com o gerenciamento de destinos, o uso de tunnel e as retransmissões. Formato do Pacote +-----------------------------------------------+ | Send Stream ID (4B) | Receive Stream ID (4B) | +-----------------------------------------------+ | Sequence Number (4B) | Ack Through (4B) | +-----------------------------------------------+ | NACK Count (1B) | optional NACK list (4B each) +-----------------------------------------------+ | Flags (1B) | Option Size (1B) | Options ... | +-----------------------------------------------+ | Payload ... | Detalhes do cabeçalho IDs de fluxo: Valores de 32 bits que identificam exclusivamente fluxos locais e remotos. Número de sequência: Começa em 0 para SYN (sinal de sincronização do TCP), incrementa a cada mensagem. Ack Through: Confirma todas as mensagens até N, excluindo as da lista de NACK (negação de recebimento). Flags: Máscara de bits que controla o estado e o comportamento. Opções: Lista de comprimento variável para RTT (tempo de ida e volta), MTU (unidade máxima de transmissão) e negociação de protocolo. Sinalizadores de chave Flag Purpose SYN Connection initiation ACK Acknowledge received packets FIN Graceful close RST Reset connection FROM_INCLUDED Sender’s destination included SIGNATURE_INCLUDED Message signed by sender ECHO / ECHO_REPLY Ping/Pong keepalive --- Controle de Fluxo e Confiabilidade O Streaming usa controle de janela baseado em mensagens, ao contrário da abordagem baseada em bytes do TCP. O número de pacotes não confirmados permitidos em trânsito é igual ao tamanho atual da janela (padrão 128).\nMecanismos Controle de congestionamento: Início lento e evitação baseada em AIMD (Aumento Aditivo, Diminuição Multiplicativa). Choke/Unchoke (estrangular/liberar): Sinalização de controle de fluxo baseada na ocupação do buffer. Retransmissão: Cálculo de RTO (tempo limite de retransmissão) baseado na RFC 6298 com backoff exponencial. Filtragem de duplicatas: Garante confiabilidade sobre mensagens potencialmente reordenadas. Valores típicos de configuração:\nParameter Default Description maxWindowSize 128 Max unacknowledged messages maxMessageSize 1730 Maximum payload bytes per message initialRTO 9000 ms Initial retransmission timeout inactivityTimeout 90000 ms Idle connection timeout connectTimeout 300000 ms Connection establishment timeout --- Estabelecimento de conexão Iniciador envia um SYN (opcionalmente com carga útil e FROM_INCLUDED). Respondente responde com SYN+ACK (pode incluir carga útil). Iniciador envia o ACK final confirmando o estabelecimento. Cargas úteis iniciais opcionais permitem a transmissão de dados antes da conclusão completa do handshake (negociação inicial).\nDetalhes de Implementação Retransmissão e tempo limite O algoritmo de retransmissão segue a RFC 6298. - RTO inicial: 9s - RTO mínimo: 100ms - RTO máximo: 45s - Alfa: 0.125 - Beta: 0.25\nCompartilhamento de Bloco de Controle Conexões recentes com o mesmo par reutilizam o RTT e os dados de janela anteriores para um ramp-up (aceleração inicial) mais rápido, evitando a latência de “cold start” (arranque a frio). Blocos de controle expiram após alguns minutos.\nMTU e Fragmentação MTU padrão: 1730 bytes (acomoda duas mensagens I2NP). Destinos ECIES (Esquema Integrado de Criptografia com Curvas Elípticas): 1812 bytes (sobrecarga reduzida). MTU mínimo suportado: 512 bytes. O tamanho da carga útil exclui o cabeçalho mínimo de streaming de 22 bytes.\nHistórico de versões Router Version Feature 0.7.1 Protocol numbers defined in I2CP 0.9.11 Variable-length signatures 0.9.12 ECDSA signature support 0.9.15 Ed25519 signature support 0.9.18 Ping/Pong payloads 0.9.20 FROM_INCLUDED not required in RESET 0.9.36 Protocol enforcement enabled by default 0.9.39 OFFLINE_SIGNATURE support 0.9.58 Bob’s hash added to NACK field in SYN 2.10.0 Post-Quantum hybrid encryption (experimental) --- Uso em nível de aplicação Exemplo em Java Properties props = new Properties(); props.setProperty(\u0026#34;i2p.streaming.maxWindowSize\u0026#34;, \u0026#34;512\u0026#34;); I2PSocketManager mgr = I2PSocketManagerFactory.createManager(props); I2PSocket socket = mgr.connect(destination); InputStream in = socket.getInputStream(); OutputStream out = socket.getOutputStream(); Suporte a SAMv3 e i2pd SAMv3: Fornece modos STREAM (fluxo) e DATAGRAM (datagrama) para clientes que não usam Java. i2pd: Expõe parâmetros de streaming idênticos por meio de opções no arquivo de configuração (por exemplo, i2p.streaming.maxWindowSize, profile, etc.). Escolhendo entre Streaming e Datagramas Use Case Recommended Transport Reason HTTP, IRC, Email Streaming Requires reliability DNS Repliable Datagram Single request/response Telemetry, Logging Raw Datagram Best-effort acceptable P2P DHT Datagram High connection churn --- Segurança e Futuro Pós-Quântico As sessões de streaming são criptografadas de ponta a ponta na camada I2CP. A criptografia híbrida pós-quântica (ML-KEM + X25519) é suportada experimentalmente na versão 2.10.0, mas está desativada por padrão.\nReferências Visão geral da API de Streaming Especificação do Protocolo de Streaming Especificação do I2CP Proposta 144: Cálculos de MTU para Streaming Notas de versão do I2P 2.10.0 ","description":"Transporte confiável, semelhante ao TCP, usado pela maioria das aplicações do I2P","id":"100837c91cc0808ee048c86902b36251","section":"docs","title":"Protocolo de Streaming","url":"/pt/docs/specs/streaming/"},{"categories":null,"content":"Visão geral I2CP é o protocolo de controle de baixo nível entre um router I2P e qualquer processo cliente. Ele define uma separação rigorosa de responsabilidades:\nRouter: Gerencia o roteamento, a criptografia, os ciclos de vida dos tunnels e as operações do banco de dados da rede Cliente: Seleciona propriedades de anonimato, configura tunnels e envia/recebe mensagens Toda a comunicação flui por um único socket TCP (opcionalmente encapsulado em TLS), permitindo operações assíncronas e full-duplex (transmissão bidirecional simultânea).\nVersão do Protocolo: I2CP usa um byte de versão de protocolo 0x2A (42 decimal) enviado durante o estabelecimento inicial da conexão. Esse byte de versão permaneceu estável desde a criação do protocolo.\nEstado atual: Esta especificação aplica-se à versão do router 0.9.67 (versão da API 0.9.67), lançada em 2025-09.\nContexto de Implementação Implementação em Java A implementação de referência está no Java I2P: - SDK do cliente: pacote i2p.jar - Implementação do Router: pacote router.jar - Javadocs Quando o cliente e o router executam na mesma JVM, as mensagens I2CP são passadas como objetos Java sem serialização. Clientes externos usam o protocolo serializado sobre TCP.\nImplementação em C++ i2pd (o router I2P em C++) também implementa o I2CP externamente para conexões de clientes.\nClientes não Java Não há implementações não-Java conhecidas de uma biblioteca de cliente I2CP completa. Aplicações não-Java devem usar, em vez disso, protocolos de nível mais alto:\nSAM (Simple Anonymous Messaging) v3: Interface baseada em socket com bibliotecas em várias linguagens de programação BOB (Basic Open Bridge): Alternativa mais simples ao SAM Esses protocolos de nível superior lidam com a complexidade do I2CP internamente e também fornecem a biblioteca de streaming (para conexões semelhantes ao TCP) e a biblioteca de datagramas (para conexões semelhantes ao UDP).\nEstabelecimento de Conexão 1. Conexão TCP Conecte-se à porta I2CP do router: - Padrão: 127.0.0.1:7654 - Configurável nas configurações do router - Encapsulador TLS opcional (altamente recomendado para conexões remotas)\n2. Negociação de Protocolo Etapa 1: Envie o byte de versão do protocolo 0x2A\nEtapa 2: Sincronização do relógio\nClient → Router: GetDateMessage Router → Client: SetDateMessage O router retorna o carimbo de data e hora atual e a string de versão da API I2CP (desde 0.8.7).\nEtapa 3: Autenticação (se ativada)\nA partir da versão 0.9.11, a autenticação pode ser incluída em GetDateMessage por meio de um Mapping (mapeamento) contendo: - i2cp.username - i2cp.password\nA partir da versão 0.9.16, quando a autenticação estiver ativada, ela deve ser concluída por meio de GetDateMessage antes que quaisquer outras mensagens sejam enviadas.\nEtapa 4: Criação da sessão\nClient → Router: CreateSessionMessage (contains SessionConfig) Router → Client: SessionStatusMessage (status=Created) Etapa 5: Sinal de Prontidão do Tunnel\nRouter → Client: RequestVariableLeaseSetMessage Esta mensagem sinaliza que os tunnels de entrada foram construídos. O router NÃO enviará isto até que exista pelo menos um tunnel de entrada E um tunnel de saída.\nEtapa 6: Publicação do LeaseSet\nClient → Router: CreateLeaseSet2Message Neste ponto, a sessão está totalmente operacional para enviar e receber mensagens.\nPadrões de Fluxo de Mensagens Mensagem de saída (o cliente envia para o destino remoto) Com i2cp.messageReliability=none:\nClient → Router: SendMessageMessage (nonce=0) [No acknowledgments] Com i2cp.messageReliability=BestEffort:\nClient → Router: SendMessageMessage (nonce\u0026gt;0) Router → Client: MessageStatusMessage (status=Accepted) Router → Client: MessageStatusMessage (status=Success or Failure) Mensagem recebida (Router entrega ao cliente) Com i2cp.fastReceive=true (padrão desde 0.9.4):\nRouter → Client: MessagePayloadMessage [No acknowledgment required] Com i2cp.fastReceive=false (OBSOLETO):\nRouter → Client: MessageStatusMessage (status=Available) Client → Router: ReceiveMessageBeginMessage Router → Client: MessagePayloadMessage Client → Router: ReceiveMessageEndMessage Clientes modernos devem sempre usar o modo de recebimento rápido.\nEstruturas de Dados Comuns Cabeçalho da Mensagem I2CP Todas as mensagens I2CP utilizam este cabeçalho comum:\n+----+----+----+----+----+----+----+----+ | Body Length (4 bytes) | +----+----+----+----+----+----+----+----+ |Type| Message Body (variable) | +----+----+----+----+----+----+----+----+ Comprimento do Corpo: inteiro de 4 bytes, comprimento apenas do corpo da mensagem (exclui o cabeçalho) Tipo: inteiro de 1 byte, identificador do tipo de mensagem Corpo da Mensagem: 0+ bytes, o formato varia conforme o tipo de mensagem Limite de tamanho da mensagem: Aproximadamente 64 KB no máximo.\nID da sessão Inteiro de 2 bytes que identifica exclusivamente uma sessão em um router.\nValor especial: 0xFFFF indica \u0026ldquo;sem sessão\u0026rdquo; (usado para consultas de nome de host sem uma sessão estabelecida).\nID da mensagem Inteiro de 4 bytes gerado pelo router para identificar univocamente uma mensagem dentro de uma sessão.\nImportante: Os IDs de mensagem não são globalmente únicos, apenas únicos dentro de uma sessão. Eles também são distintos do nonce (número arbitrário usado apenas uma vez) gerado pelo cliente.\nFormato da carga útil As cargas úteis das mensagens são comprimidas com gzip, com um cabeçalho gzip padrão de 10 bytes: - Começa com: 0x1F 0x8B 0x08 (RFC 1952) - Desde a versão 0.7.1: As partes não utilizadas do cabeçalho gzip contêm informações de protocolo, porta de origem e porta de destino - Isso permite streaming e datagramas no mesmo destino\nControle de compressão: Defina i2cp.gzip=false para desativar a compressão (define o esforço do gzip para 0). O cabeçalho gzip ainda é incluído, mas com sobrecarga mínima de compressão.\nEstrutura de SessionConfig Define a configuração para uma sessão de cliente:\n+----------------------------------+ | Destination | +----------------------------------+ | Mapping (configuration options) | +----------------------------------+ | Creation Date | +----------------------------------+ | Signature | +----------------------------------+ Requisitos críticos: 1. O mapeamento deve estar ordenado por chave para validação da assinatura 2. Data de criação deve estar dentro de ±30 segundos da hora atual do router 3. Assinatura é criada pela SigningPrivateKey do Destination (destino no I2P)\nAssinaturas offline (a partir da versão 0.9.38):\nSe estiver usando assinatura offline, o mapeamento deve conter: - i2cp.leaseSetOfflineExpiration - i2cp.leaseSetTransientPublicKey - i2cp.leaseSetOfflineSignature\nA Signature é então gerada pela SigningPrivateKey temporária.\nOpções de Configuração do Núcleo Configuração do Tunnel Option Default Description inbound.length 3 Number of hops for inbound tunnels outbound.length 3 Number of hops for outbound tunnels inbound.lengthVariance 0 Random variance in hop count (since 0.7.6) outbound.lengthVariance 0 Random variance in hop count (since 0.7.6) inbound.quantity 2 Number of concurrent inbound tunnels outbound.quantity 2 Number of concurrent outbound tunnels inbound.backupQuantity 0 Standby inbound tunnels (hot spares) outbound.backupQuantity 0 Standby outbound tunnels (hot spares) inbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) outbound.allowZeroHop true Allow 0-hop tunnels (disable for full anonymity) **Notas**: - Valores para `quantity` \u003e 6 requerem pares executando 0.9.0+ e aumentam significativamente o consumo de recursos - Defina `backupQuantity` como 1-2 para serviços de alta disponibilidade - Zero-hop tunnels sacrificam o anonimato em favor da latência mas são úteis para testes Tratamento de Mensagens Option Default Description clientMessageTimeout 60000\u0026nbsp;ms Legacy timeout for message delivery i2cp.messageReliability BestEffort None, BestEffort, or Guaranteed i2cp.fastReceive true Skip ReceiveMessageBegin/End handshake (default since 0.9.4) i2cp.gzip true Enable gzip compression of message payloads outbound.priority 0 Priority for outbound scheduling (-25 to +25) **Confiabilidade de Mensagens**: - `None`: Sem confirmações do router (padrão da biblioteca de streaming desde 0.8.1) - `BestEffort`: O router envia aceitação + notificações de sucesso/falha - `Guaranteed`: Não implementado (atualmente comporta-se como BestEffort) Substituição por mensagem (desde 0.9.14): - Em uma sessão com messageReliability=none, definir um nonce (número usado uma vez) diferente de zero solicita notificação de entrega para essa mensagem específica - Definir nonce=0 em uma sessão BestEffort desativa as notificações para essa mensagem\nConfiguração do LeaseSet Option Default Description i2cp.dontPublishLeaseSet false Disable automatic LeaseSet publication (for client-only destinations) i2cp.leaseSetType 1 LeaseSet variant: 1 = standard, 3 = LS2, 5 = encrypted, 7 = meta i2cp.leaseSetEncType 0 Comma-separated encryption type codes (see below) ### Tags de Sessão ElGamal/AES legadas Essas opções são relevantes apenas para a criptografia ElGamal legada:\nOption Default Description crypto.lowTagThreshold 30 Minimum session tags before replenishing crypto.tagsToSend 40 Number of tags to send in a batch **Observação**: Os clientes ECIES-X25519 utilizam um mecanismo de ratchet (mecanismo de avanço criptográfico) diferente e ignoram estas opções. Tipos de criptografia I2CP oferece suporte a múltiplos esquemas de criptografia de ponta a ponta por meio da opção i2cp.leaseSetEncType. Podem ser especificados vários tipos (separados por vírgula) para oferecer suporte tanto a pares modernos quanto a pares legados.\nTipos de Criptografia Suportados Type Algorithm Key Size Since Status 0 ElGamal/AES+SessionTags 2048-bit ElGamal Original Legacy 1-3 Reserved - - Unused 4 ECIES-X25519-AEAD-Ratchet 32-byte X25519 0.9.46 Current Standard 5 ECIES-X25519-AEAD-Ratchet + ML-KEM-768 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 6 ECIES-X25519-AEAD-Ratchet + ML-KEM-1024 hybrid 32\u0026nbsp;+\u0026nbsp;PQ 0.9.67 Beta 7 Reserved (likely ML-KEM-512 hybrid) 32\u0026nbsp;+\u0026nbsp;PQ Future Planned **Configuração recomendada**: i2cp.leaseSetEncType=4,0 Isso oferece X25519 (preferido), com ElGamal como opção de reserva para compatibilidade.\nDetalhes do Tipo de Criptografia Tipo 0 - ElGamal/AES+SessionTags: - chaves públicas ElGamal de 2048 bits (256 bytes) - criptografia simétrica AES-256 - tags de sessão de 32 bytes enviadas em lotes - alta sobrecarga de CPU, largura de banda e memória - está sendo gradualmente descontinuado em toda a rede\nTipo 4 - ECIES-X25519-AEAD-Ratchet: - Troca de chaves X25519 (chaves de 32 bytes) - ChaCha20/Poly1305 AEAD - Double Ratchet ao estilo Signal (mecanismo de catraca dupla) - Tags de sessão de 8 bytes (vs 32 bytes para ElGamal) - Tags geradas via PRNG sincronizado (não enviadas com antecedência) - ~92% de redução de sobrecarga vs ElGamal - Padrão para o I2P moderno (a maioria dos routers utiliza isto)\nTipos 5-6 - Híbrido pós-quântico: - Combina X25519 com ML-KEM (NIST FIPS 203, mecanismo de encapsulamento de chaves) - Oferece segurança resistente a ataques quânticos - ML-KEM-768 para equilíbrio entre segurança e desempenho - ML-KEM-1024 para máxima segurança - Tamanhos de mensagem maiores devido ao material de chaves pós-quânticas (PQ) - Suporte na rede ainda em implantação\nEstratégia de Migração A rede I2P está migrando ativamente de ElGamal (tipo 0) para X25519 (tipo 4): - NTCP → NTCP2 (concluído) - SSU → SSU2 (concluído) - ElGamal tunnels → X25519 tunnels (concluído) - ElGamal fim a fim → ECIES-X25519 (em grande parte concluído)\nLeaseSet2 e Recursos Avançados Opções do LeaseSet2 (desde 0.9.38) Option Since Purpose i2cp.leaseSetType 0.9.38 Specifies LeaseSet variant (1, 3, 5, 7) i2cp.leaseSetEncType 0.9.38 Encryption types supported (comma-separated) i2cp.leaseSetAuthType 0.9.41 Per-client authentication: 0 = none, 1 = DH, 2 = PSK i2cp.leaseSetPrivKey 0.9.41 X25519 private key for decrypting LS2 with auth i2cp.leaseSetSecret 0.9.39 Base64 secret for blinded addresses i2cp.leaseSetTransientPublicKey 0.9.38 Transient signing key for offline signatures i2cp.leaseSetPrivateKey 0.9.18 Persistent LeaseSet encryption keys (type:key pairs) i2cp.leaseSetOption.nnn 0.9.66 Service records (proposal 167) i2cp.leaseSetClient.dh.nnn 0.9.41 DH client auth material (indexed from 0) i2cp.leaseSetClient.psk.nnn 0.9.41 PSK client auth material (indexed from 0) ### Blinded Addresses (endereços cegos) A partir da versão 0.9.39, os destinos podem usar endereços \u0026ldquo;blinded\u0026rdquo; (endereços cegados) (formato b33) que mudam periodicamente:\nRequer i2cp.leaseSetSecret para proteção por senha Autenticação opcional por cliente Consulte as propostas 123 e 149 para obter detalhes Registros de Serviço (desde 0.9.66) LeaseSet2 suporta opções de registro de serviço (proposta 167):\ni2cp.leaseSetOption.0=_smtp._tcp=1 86400 0 0 25 mail.example.b32.i2p O formato segue o estilo do registro SRV do DNS, mas adaptado para o I2P.\nMúltiplas sessões (desde a versão 0.9.21) Uma única conexão I2CP pode manter várias sessões:\nSessão Primária: A primeira sessão criada em uma conexão Subsessões: Sessões adicionais que compartilham o tunnel pool da sessão primária\nCaracterísticas da subsessão Tunnels compartilhados: Use os mesmos pools de inbound/outbound tunnel que a sessão primária Chaves de criptografia compartilhadas: Deve usar chaves de criptografia do LeaseSet idênticas Chaves de assinatura diferentes: Deve usar chaves de assinatura distintas da Destination (destino no I2P) Sem garantia de anonimato: Claramente vinculado à sessão primária (mesmo router, mesmos tunnels) Caso de uso de Subsession (subsessão) Permitir comunicação com destinos usando diferentes tipos de assinatura: - Principal: assinatura EdDSA (moderna) - Subsession (subsessão): assinatura DSA (para compatibilidade com legado)\nCiclo de vida da subsessão Criação:\nClient → Router: CreateSessionMessage Router → Client: SessionStatusMessage (unique Session ID) Router → Client: RequestVariableLeaseSetMessage (separate for each destination) Client → Router: CreateLeaseSet2Message (separate for each destination) Destruição: - Destruir uma subsessão: Mantém a sessão principal intacta - Destruir a sessão principal: Destrói todas as subsessões e fecha a conexão - DisconnectMessage (mensagem de desconexão): Destrói todas as sessões\nTratamento do ID de sessão A maioria das mensagens I2CP contém um campo de ID de sessão. Exceções: - DestLookup / DestReply (obsoleto, use HostLookup / HostReply) - GetBandwidthLimits / BandwidthLimits (resposta não específica da sessão)\nImportante: Os clientes não devem ter várias mensagens CreateSession (comando de criação de sessão) pendentes simultaneamente, pois as respostas não podem ser correlacionadas inequivocamente às solicitações.\nCatálogo de Mensagens Resumo dos Tipos de Mensagem Type Name Direction Since Status 1 CreateSession C → R Original Current 2 ReconfigureSession C → R 0.7.1 Current 3 DestroySession C → R Original Current 4 CreateLeaseSet C → R Original Deprecated 5 SendMessage C → R Original Current 6 ReceiveMessageBegin C → R Original Deprecated 7 ReceiveMessageEnd C → R Original Deprecated 8 GetBandwidthLimits C → R 0.7.2 Current 20 SessionStatus R → C Original Current 21 RequestLeaseSet R → C Original Deprecated 22 MessageStatus R → C Original Current 23 BandwidthLimits R → C 0.7.2 Current 29 ReportAbuse Bidirectional Original Unused 30 Disconnect Bidirectional Original Current 31 MessagePayload R → C Original Current 32 GetDate C → R Original Current 33 SetDate R → C Original Current 34 DestLookup C → R 0.7 Deprecated 35 DestReply R → C 0.7 Deprecated 36 SendMessageExpires C → R 0.7.1 Current 37 RequestVariableLeaseSet R → C 0.9.7 Current 38 HostLookup C → R 0.9.11 Current 39 HostReply R → C 0.9.11 Current 41 CreateLeaseSet2 C → R 0.9.39 Current 42 BlindingInfo C → R 0.9.43 Current **Legenda**: C = Cliente, R = Router Detalhes da Mensagem-chave CreateSessionMessage (mensagem de criação de sessão, Tipo 1) Objetivo: Iniciar uma nova sessão I2CP\nConteúdo: estrutura de SessionConfig\nResposta: SessionStatusMessage (status=Created ou Invalid)\nRequisitos: - A data em SessionConfig deve estar dentro de ±30 segundos do relógio do router - O mapeamento deve estar ordenado por chave para validação da assinatura - Destination (destino no I2P) não deve já ter uma sessão ativa\nRequestVariableLeaseSetMessage (Tipo 37) Objetivo: Router solicita autorização do cliente para tunnels de entrada\nConteúdo: - ID da sessão - Número de leases (entradas de túnel) - Array de estruturas Lease (cada uma com expiração individual)\nResposta: CreateLeaseSet2Message\nSignificado: Este é o sinal de que a sessão está operacional. O router envia isto apenas depois de: 1. Pelo menos um tunnel de entrada ter sido construído 2. Pelo menos um tunnel de saída ter sido construído\nRecomendação de tempo limite: Os clientes devem encerrar a sessão se esta mensagem não for recebida em até 5+ minutos após a criação da sessão.\nCreateLeaseSet2Message (Tipo 41) Finalidade: O cliente publica o LeaseSet no netDb (base de dados da rede)\nConteúdo: - ID de sessão - byte do tipo de LeaseSet (1, 3, 5 ou 7) - LeaseSet ou LeaseSet2 ou EncryptedLeaseSet ou MetaLeaseSet - Número de chaves privadas - Lista de chaves privadas (uma por chave pública no LeaseSet, na mesma ordem)\nChaves Privadas: Necessárias para descriptografar garlic messages (mensagens \u0026ldquo;garlic\u0026rdquo; do I2P, formato de mensagem agregada) recebidas. Formato:\nEncryption type (2 bytes) Key length (2 bytes) Private key data (variable) Nota: Substitui o CreateLeaseSetMessage obsoleto (tipo 4), que não oferece suporte a: - variantes de LeaseSet2 - criptografia não-ElGamal - múltiplos tipos de criptografia - LeaseSets criptografados - chaves de assinatura offline\nSendMessageExpiresMessage (Tipo 36) Finalidade: Enviar mensagem para o destino com expiração e opções avançadas\nConteúdo: - ID da sessão - Destino - Carga útil (compactado com gzip) - Nonce (valor único de uso único) (4 bytes) - Flags (2 bytes) - veja abaixo - Data de expiração (6 bytes, truncada de 8)\nCampo de Flags (2 bytes, ordem dos bits 15\u0026hellip;0):\nBits 15-11: Não utilizados, devem ser 0\nBits 10-9: Substituição da confiabilidade da mensagem (não utilizado, use nonce (número usado uma vez) em vez disso)\nBit 8: Não incluir o LeaseSet - 0: Router pode incluir o LeaseSet em garlic (técnica de encapsulamento do I2P) - 1: Não incluir o LeaseSet\nBits 7-4: Limiar baixo de tags (apenas para ElGamal, ignorado para ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 3 tags ... 1111 = 192 tags Bits 3-0: Tags a enviar se necessário (apenas para ElGamal, ignorado para ECIES)\n0000 = Use session settings 0001 = 2 tags 0010 = 4 tags ... 1111 = 160 tags MessageStatusMessage (Tipo 22) Finalidade: Notificar o cliente sobre o status de entrega da mensagem\nConteúdo: - ID de sessão - ID da mensagem (gerado pelo router) - Código de status (1 byte) - Tamanho (4 bytes, relevante apenas para status=0) - Nonce (4 bytes, corresponde ao nonce de SendMessage do cliente)\nCódigos de status (Mensagens de saída):\nCode Name Meaning Result 1 Accepted Router accepted message Success 2 Best Effort Success Probable delivery Success 4 Guaranteed Success Probable delivery Success 6 Local Success Delivered to local client Success 3 Best Effort Failure Probable failure Failure 5 Guaranteed Failure Generic failure Failure 7 Local Failure Local delivery failed Failure 8 Router Failure Router shutdown/error Failure 9 Network Failure No network connectivity Failure 10 Bad Session Invalid/closed session Failure 11 Bad Message Invalid payload Failure 12 Bad Options Invalid options/expiration Failure 13 Overflow Failure Queue/buffer full Failure 14 Message Expired Expired before send Failure 15 Bad Local LeaseSet Local LeaseSet problem Failure 16 No Local Tunnels No tunnels available Failure 17 Unsupported Encryption Incompatible encryption Failure 18 Bad Destination Invalid remote destination Failure 19 Bad Leaseset Invalid remote LeaseSet Failure 20 Expired Leaseset Remote LeaseSet expired Failure 21 No Leaseset Remote LeaseSet not found Failure 22 Meta Leaseset Cannot send to meta LS Failure 23 Loopback Denied Same source and destination Failure **Códigos de sucesso**: 1, 2, 4, 6 **Códigos de falha**: Todos os demais Código de status 0 (OBSOLETO): Mensagem disponível (entrada, recebimento rápido desativado)\nHostLookupMessage (Tipo 38) Finalidade: Consultar o destino por nome de host ou hash (substitui DestLookup)\nConteúdo: - ID de sessão (ou 0xFFFF para nenhuma sessão) - ID da solicitação (4 bytes) - Tempo limite em milissegundos (4 bytes, mínimo recomendado: 10000) - Tipo de solicitação (1 byte) - Chave de consulta (Hash, String de nome de host, ou Destino)\nTipos de solicitação:\nType Lookup Key Returns Since 0 Hash Destination Original 1 Hostname String Destination Original 2 Hash Destination + Options 0.9.66 3 Hostname String Destination + Options 0.9.66 4 Destination Destination + Options 0.9.66 Tipos 2–4 retornam opções de LeaseSet (proposta 167) se disponíveis. Resposta: HostReplyMessage\nHostReplyMessage (mensagem de resposta do host) (Tipo 39) Finalidade: Resposta ao HostLookupMessage (mensagem de consulta de host)\nConteúdo: - ID da sessão - ID da solicitação - Código de resultado (1 byte) - Destino (presente em caso de sucesso, às vezes em falhas específicas) - Mapeamento (apenas para os tipos de consulta 2-4, pode estar vazio)\nCódigos de Resultado:\nCode Name Meaning 0 Success Lookup succeeded 1 Failure Generic failure 2 Lookup Password Required Blinded address requires password 3 Private Key Required Blinded address requires private key 4 Password and Key Required Blinded address requires both 5 LeaseSet Decryption Failure Cannot decrypt LeaseSet 6 LeaseSet Lookup Failure LeaseSet not found in netdb 7 Lookup Type Unsupported Router doesn't support this type #### BlindingInfoMessage (Tipo 42) Finalidade: Informar o router sobre os requisitos de autenticação de blinded destination (destino cego) (desde 0.9.43)\nConteúdo: - ID da sessão - Flags (1 byte) - Tipo de endpoint (1 byte): 0=Hash, 1=hostname, 2=Destino, 3=TipoAssinatura+Chave - Tipo de assinatura cega (2 bytes) - Expiração (4 bytes, segundos desde a época Unix) - Dados do endpoint (varia conforme o tipo) - Chave privada (32 bytes, somente se o bit 0 do flag estiver definido) - Senha de consulta (String, somente se o bit 4 do flag estiver definido)\nSinalizadores (ordem dos bits 76543210):\nBit 0: 0=todos, 1=por cliente Bits 3-1: Esquema de autenticação (se o bit 0=1): 000=DH, 001=PSK Bit 4: 1=segredo obrigatório Bits 7-5: Não utilizados, definir como 0 Sem resposta: Router processa silenciosamente\nCaso de uso: Antes de enviar para um blinded destination (destino ofuscado) (b33 address), o cliente deve: 1. Consultar o b33 via HostLookup, OU 2. Enviar a mensagem BlindingInfo\nSe o destino exigir autenticação, BlindingInfo (informação de cegamento) é obrigatório.\nReconfigureSessionMessage (Tipo 2) Objetivo: Atualizar a configuração da sessão após a criação\nConteúdo: - ID da sessão - SessionConfig (apenas as opções alteradas são necessárias)\nResposta: SessionStatusMessage (mensagem de status da sessão) (status=Updated or Invalid)\nNotas: - O Router mescla a nova configuração com a configuração existente - As opções de Tunnel (inbound.*, outbound.*) são sempre aplicadas - Algumas opções podem ser imutáveis após a criação da sessão - A data deve estar dentro de ±30 segundos do horário do router - O mapeamento deve ser ordenado por chave\nDestroySessionMessage (mensagem de destruição de sessão) (Tipo 3) Propósito: Encerrar uma sessão\nConteúdo: ID da sessão\nResposta esperada: SessionStatusMessage (status=Destroyed)\nComportamento atual (Java I2P até a 0.9.66): - Router nunca envia SessionStatus(Destroyed) - Se não restarem sessões: Envia DisconnectMessage - Se restarem subsessões: Sem resposta\nImportante: O comportamento do Java I2P difere da especificação. As implementações devem ser cautelosas ao destruir subsessões individuais.\nDisconnectMessage (Tipo 30) Finalidade: Notificar que a conexão está prestes a ser encerrada\nConteúdo: String do motivo\nEfeito: Todas as sessões na conexão são destruídas, o socket é fechado\nImplementação: Principalmente router → cliente no Java I2P\nHistórico de versões do protocolo Detecção de Versão A versão do protocolo I2CP é trocada em mensagens Get/SetDate (desde a versão 0.8.7). Para routers mais antigos, as informações de versão não estão disponíveis.\nString de versão: Indica a versão da API \u0026ldquo;core\u0026rdquo;, não necessariamente a versão do router.\nCronologia de funcionalidades Version Key Features 0.9.67 PQ Hybrid ML-KEM (enc types 5-7) in LeaseSet 0.9.66 Host lookup/reply extensions (proposal 167), service records 0.9.62 MessageStatus loopback error code 0.9.46 X25519 (enc type 4) in LeaseSet, ECIES end-to-end 0.9.43 BlindingInfo message, extended HostReply failure codes 0.9.41 EncryptedLeaseSet options, Meta LS error code 0.9.39 CreateLeaseSet2 message, RedDSA Ed25519 support 0.9.38 Preliminary LS2 support (format changed in 0.9.39) 0.9.21 Multiple sessions on single connection 0.9.20 Additional SetDate messages for clock shifts 0.9.16 Authentication required before other messages (when enabled) 0.9.15 EdDSA Ed25519 signature type 0.9.14 Per-message reliability override with nonzero nonce 0.9.12 ECDSA P-256/384/521 signature types, RSA support 0.9.11 HostLookup/HostReply messages, auth in GetDate 0.9.7 RequestVariableLeaseSet message 0.9.5 Additional MessageStatus codes 0.9.4 Fast receive mode default, nonce=0 allowed 0.9.2 SendMessageExpires flag tag bits 0.9 16 leases per LeaseSet (up from 6) 0.8.7 Version strings in Get/SetDate 0.8.4 SendMessageExpires flag bits 0.8.3 DestLookup in standard session, concurrent lookups 0.8.1 messageReliability=none 0.7.2 GetBandwidthLimits, BandwidthLimits 0.7.1 SendMessageExpires, ReconfigureSession, ports in gzip header 0.7 DestLookup, DestReply 0.6.5- Original protocol features ## Considerações de Segurança Autenticação Padrão: Nenhuma autenticação necessária Opcional: Autenticação por nome de usuário/senha (desde 0.9.11) Obrigatório: Quando ativada, a autenticação deve ser concluída antes de outras mensagens (desde 0.9.16)\nConexões Remotas: Sempre use TLS (i2cp.SSL=true) para proteger credenciais e chaves privadas.\nDefasagem do relógio SessionConfig Date deve estar com diferença de no máximo ±30 segundos em relação à hora do router, ou a sessão será rejeitada. Use Get/SetDate para sincronizar.\nManipulação de Chaves Privadas CreateLeaseSet2Message contém chaves privadas para descriptografar mensagens recebidas. Estas chaves devem ser: - Transmitidas com segurança (TLS para conexões remotas) - Armazenadas com segurança pelo router - Rotacionadas quando comprometidas\nExpiração de mensagens Use sempre SendMessageExpires (não SendMessage) para definir uma expiração explícita. Isto: - Impede que mensagens sejam enfileiradas indefinidamente - Reduz o consumo de recursos - Melhora a confiabilidade\nGerenciamento de Tags de Sessão ElGamal (obsoleto): - As tags devem ser transmitidas em lotes - Tags perdidas causam falhas de descriptografia - Elevada sobrecarga de memória\nECIES-X25519 (atual): - Tags geradas via PRNG (gerador de números pseudoaleatórios) sincronizado - Não é necessária transmissão antecipada - Resiliente à perda de mensagens - Sobrecarga significativamente menor\nBoas práticas Para desenvolvedores de clientes Use o modo de recebimento rápido: Sempre defina i2cp.fastReceive=true (ou mantenha o padrão)\nPrefira ECIES-X25519 (ECIES com X25519, esquema de criptografia): Configure i2cp.leaseSetEncType=4,0 para obter o melhor desempenho mantendo a compatibilidade\nDefina uma expiração explícita: Use SendMessageExpires, não SendMessage\nLide com Subsessions (subsessões) com cuidado: Esteja ciente de que as Subsessions não oferecem anonimato entre destinos\nTempo limite para criação de sessão: Destrua a sessão se RequestVariableLeaseSet (solicitação de LeaseSet variável) não for recebido dentro de 5 minutos\nOrdenar mapeamentos de configuração: Sempre ordene as chaves do Mapping (estrutura de chave/valor) antes de assinar o SessionConfig (mensagem de configuração de sessão)\nUse números apropriados de Tunnel: Não defina quantity \u0026gt; 6 a menos que seja necessário\nConsidere SAM/BOB (interfaces para aplicações se comunicarem com o router I2P) para não-Java: Implemente SAM em vez de I2CP diretamente\nPara desenvolvedores de Router Validar Datas: Impor uma janela de ±30 segundos nas datas do SessionConfig\nLimitar o tamanho da mensagem: Impor um tamanho máximo de ~64 KB por mensagem\nSuporte a Múltiplas Sessões: Implementar suporte a subsessões conforme a especificação 0.9.21\nEnvie RequestVariableLeaseSet imediatamente: Somente depois que ambos os tunnels de entrada e de saída existirem\nTratar Mensagens Obsoletas: Aceitar, mas desencorajar ReceiveMessageBegin/End\nSuporte a ECIES-X25519: Priorize a criptografia do tipo 4 para novas implantações\nDepuração e Resolução de Problemas Problemas comuns Sessão rejeitada (inválida): - Verifique o desvio do relógio (deve estar dentro de ±30 segundos) - Verifique se o Mapping está ordenado por chave - Certifique-se de que a Destination (destino do I2P) não está em uso\nSem RequestVariableLeaseSet (pedido de leaseSet variável): - Router pode estar construindo tunnels (aguarde até 5 minutos) - Verifique se há problemas de conectividade de rede - Verifique se há conexões com pares suficientes\nFalhas na Entrega de Mensagens: - Verifique os códigos MessageStatus para identificar o motivo específico da falha - Verifique se o LeaseSet remoto está publicado e atual - Certifique-se de que os tipos de criptografia são compatíveis\nProblemas de Subsessão: - Verifique se a sessão principal foi criada primeiro - Confirme que as chaves de criptografia são as mesmas - Verifique se as chaves de assinatura são distintas\nMensagens de diagnóstico GetBandwidthLimits: Consultar a capacidade do router HostLookup: Testar a resolução de nomes e a disponibilidade do LeaseSet MessageStatus: Acompanhar a entrega de mensagens de ponta a ponta\nEspecificações relacionadas Estruturas Comuns: /docs/specs/common-structures/ I2NP (Protocolo de Rede): /docs/specs/i2np/ ECIES-X25519: /docs/specs/ecies/ Criação de Tunnel: /docs/specs/implementation/ Biblioteca de Streaming: /docs/specs/streaming/ Biblioteca de Datagramas: /docs/api/datagrams/ SAM v3: /docs/api/samv3/ Propostas Referenciadas Proposta 123 : LeaseSets criptografados e autenticação Proposta 144 : ECIES-X25519-AEAD-Ratchet Proposta 149 : Formato de endereço cego (b33) Proposta 152 : Criação de tunnel com X25519 Proposta 154 : Consultas ao banco de dados a partir de destinos ECIES Proposta 156 : Migração do router para ECIES-X25519 Proposta 161 : Compressão do preenchimento de destino Proposta 167 : Registros de serviço de LeaseSet Proposta 169 : Criptografia híbrida pós-quântica (ML-KEM) Referência do Javadoc Pacote I2CP MessageStatusMessage API do Cliente Resumo de Obsolescência Mensagens obsoletas (não usar) CreateLeaseSetMessage (tipo 4): Use CreateLeaseSet2Message RequestLeaseSetMessage (tipo 21): Use RequestVariableLeaseSetMessage ReceiveMessageBeginMessage (tipo 6): Use o modo de recebimento rápido ReceiveMessageEndMessage (tipo 7): Use o modo de recebimento rápido DestLookupMessage (tipo 34): Use HostLookupMessage DestReplyMessage (tipo 35): Use HostReplyMessage ReportAbuseMessage (tipo 29): Nunca implementado Opções obsoletas Criptografia ElGamal (tipo 0): Migrar para ECIES-X25519 (tipo 4) Assinaturas DSA: Migrar para EdDSA ou ECDSA i2cp.fastReceive=false: Sempre usar o modo de recebimento rápido ","description":"Como as aplicações negociam sessões, tunnels e LeaseSets com o I2P router.","id":"ed43fc9da2a03819fd3c8f71e9e9a5a3","section":"docs","title":"Protocolo do Cliente do I2P (I2CP)","url":"/pt/docs/specs/i2cp/"},{"categories":null,"content":" Atenção: O túnel SOCKS encaminha payloads de aplicações sem sanitizá-los. Muitos protocolos expõem IPs, nomes de host ou outros identificadores. Use SOCKS apenas com software que você tenha auditado para anonimato.\n1. Visão Geral O I2P fornece suporte para proxy SOCKS 4, 4a e 5 para conexões de saída através de um cliente I2PTunnel. Ele permite que aplicações padrão alcancem destinos I2P, mas não pode acessar a clearnet. Não há outproxy SOCKS, e todo o tráfego permanece dentro da rede I2P.\nResumo da Implementação Parameter Java I2P i2pd Default Port User-defined 127.0.0.1:4447 Supported SOCKS Versions 4, 4a, 5 4, 4a, 5 UDP Mode Stubbed (non-functional) Stubbed (non-functional) Persistent Keys ✅ Since 0.9.9 ✅ Shared Client Tunnels Supported Supported Outproxy Support ❌ None ❌ None **Tipos de endereço suportados:** - Nomes de host `.i2p` (entradas do catálogo de endereços) - Hashes Base32 (`.b32.i2p`) - Sem suporte para Base64 ou clearnet 2. Riscos de Segurança e Limitações Vazamento na Camada de Aplicação SOCKS opera abaixo da camada de aplicação e não consegue sanitizar protocolos. Muitos clientes (por exemplo, navegadores, IRC, email) incluem metadados que revelam seu endereço IP, nome do host ou detalhes do sistema.\nVazamentos comuns incluem: - IPs em cabeçalhos de e-mail ou respostas CTCP do IRC - Nomes reais/nomes de usuário em cargas úteis de protocolo - Strings de user-agent com impressões digitais do SO - Consultas DNS externas - WebRTC e telemetria do navegador\nI2P não pode prevenir estes vazamentos—eles ocorrem acima da camada de tunnel. Use apenas SOCKS para clientes auditados projetados para anonimato.\nIdentidade de Túnel Compartilhado Se múltiplas aplicações compartilham um túnel SOCKS, elas compartilham a mesma identidade de destino I2P. Isso permite correlação ou fingerprinting entre diferentes serviços.\nMitigação: Use tunnels não compartilhados para cada aplicação e ative chaves persistentes para manter identidades criptográficas consistentes entre reinicializações.\nModo UDP Desabilitado O suporte UDP no SOCKS5 não está implementado. O protocolo anuncia capacidade UDP, mas as chamadas são ignoradas. Use clientes somente TCP.\nSem Outproxy por Design Ao contrário do Tor, o I2P não oferece outproxies para a clearnet baseados em SOCKS. Tentativas de alcançar IPs externos falharão ou exporão a identidade. Use proxies HTTP ou HTTPS se for necessário usar outproxy.\n3. Contexto Histórico Os desenvolvedores há muito tempo desaconselham o uso de SOCKS para uso anônimo. De discussões internas de desenvolvedores e da Reunião 81 e Reunião 82 de 2004:\n\u0026ldquo;Encaminhar tráfego arbitrário é inseguro, e cabe a nós, como desenvolvedores de software de anonimato, ter a segurança dos nossos utilizadores finais em primeiro lugar nas nossas mentes.\u0026rdquo;\nO suporte SOCKS foi incluído por compatibilidade, mas não é recomendado para ambientes de produção. Quase todas as aplicações de internet vazam metadados sensíveis inadequados para roteamento anônimo.\n4. Configuração Java I2P Abra o I2PTunnel Manager Crie um novo tunnel cliente do tipo \u0026ldquo;SOCKS 4/4a/5\u0026rdquo; Configure as opções: Porta local (qualquer disponível) Cliente compartilhado: desabilitar para identidade separada por aplicativo Chave persistente: habilitar para reduzir correlação de chaves Inicie o tunnel i2pd O i2pd inclui suporte SOCKS5 ativado por padrão em 127.0.0.1:4447. A configuração em i2pd.conf na seção [SOCKSProxy] permite ajustar a porta, o host e os parâmetros do tunnel.\n5. Cronograma de Desenvolvimento Version Change Date 0.7.1 Initial SOCKS 4/4a/5 support 2010 0.9.9 Added persistent keying 2013 1.7.0 BOB API deprecated and removed 2022 2.6.0 I2P-over-Tor blocked to improve network health 2024 2.10.0 Post-quantum hybrid encryption introduced 2025 O próprio módulo SOCKS não recebeu atualizações importantes no protocolo desde 2013, mas a pilha de túneis circundante recebeu melhorias de desempenho e criptográficas. 6. Alternativas Recomendadas Para qualquer aplicação de produção, voltada ao público, ou crítica em termos de segurança, use uma das APIs oficiais do I2P em vez de SOCKS:\nAPI Description Recommended For SAM v3 (3.3) Simple Anonymous Messaging API Cross-language apps needing socket-like I/O Streaming Library TCP-like sockets for Java Native Java integrations I2CP Low-level router communication Custom protocols, router-level integration BOB Deprecated (removed 2022) Legacy only; migrate to SAM Essas APIs fornecem isolamento adequado de destino, controle de identidade criptográfica e melhor desempenho de roteamento. 7. OnionCat / GarliCat OnionCat suporta I2P através do seu modo GarliCat (intervalo IPv6 fd60:db4d:ddb5::/48). Ainda funcional, mas com desenvolvimento limitado desde 2019.\nRessalvas de uso: - Requer configuração manual de .oc.b32.i2p no SusiDNS - Necessita atribuição estática de IPv6 - Não é oficialmente suportado pelo projeto I2P\nRecomendado apenas para configurações avançadas de VPN-over-I2P.\n8. Melhores Práticas Se você precisa usar SOCKS: 1. Crie tunnels separados por aplicação. 2. Desative o modo de cliente compartilhado. 3. Ative chaves persistentes. 4. Force a resolução DNS do SOCKS5. 5. Audite o comportamento do protocolo para vazamentos. 6. Evite conexões clearnet. 7. Monitore o tráfego de rede para vazamentos.\n9. Resumo Técnico Parameter Value Supported SOCKS Versions 4, 4a, 5 Transport TCP only UDP Support Stubbed (non-functional) Clearnet Access Not supported Default Ports Java I2P: user-set; i2pd: 127.0.0.1:4447 Persistent Keying Supported since 0.9.9 Shared Tunnels Supported (discouraged) --- 10. Conclusão O proxy SOCKS no I2P oferece compatibilidade básica com aplicações TCP existentes, mas não é projetado para garantias fortes de anonimato. Deve ser usado apenas em ambientes de teste controlados e auditados.\nPara implantações sérias, migre para SAM v3 ou a API Streaming. Essas APIs isolam as identidades das aplicações, usam criptografia moderna e recebem desenvolvimento contínuo.\nRecursos Adicionais Documentação Oficial SOCKS Especificação SAMv3 Documentação da Biblioteca Streaming Referência I2PTunnel Documentação para Desenvolvedores I2P Fórum da Comunidade ","description":"Usando o túnel SOCKS do I2P com segurança (atualizado para 2.10.0)","id":"e71093f25f593f15b6820398338abc89","section":"docs","title":"Proxy SOCKS","url":"/pt/docs/api/socks/"},{"categories":null,"content":"Visão Geral I2P constrói túneis temporários e unidirecionais — sequências ordenadas de routers que encaminham tráfego criptografado. Os túneis são classificados como inbound (mensagens fluem em direção ao criador) ou outbound (mensagens fluem para longe do criador).\nUma troca típica roteia a mensagem de Alice através de um dos seus túneis de saída (outbound tunnels), instrui o ponto final de saída a encaminhá-la para o gateway de um dos túneis de entrada (inbound tunnels) de Bob, e então Bob a recebe no seu ponto final de entrada.\nA: Outbound Gateway (Alice) B: Outbound Participant C: Outbound Endpoint D: Inbound Gateway E: Inbound Participant F: Inbound Endpoint (Bob) Os túneis têm um tempo de vida fixo de 10 minutos e transportam mensagens de tamanho fixo de 1024 bytes (1028 bytes incluindo o cabeçalho do túnel) para evitar análise de tráfego baseada em tamanho de mensagem ou padrões de temporização.\nVocabulário de Tunnel Tunnel gateway: Primeiro router em um tunnel. Para tunnels de entrada (inbound), a identidade deste router aparece no LeaseSet publicado. Para tunnels de saída (outbound), o gateway é o router de origem (A e D acima). Tunnel endpoint: Último router em um tunnel (C e F acima). Tunnel participant: Router intermediário em um tunnel (B e E acima). Os participantes não conseguem determinar sua posição ou a direção do tunnel. n-hop tunnel: Número de saltos entre routers. 0-hop: Gateway e endpoint são o mesmo router – anonimato mínimo. 1-hop: Gateway conecta diretamente ao endpoint – baixa latência, baixo anonimato. 2-hop: Padrão para tunnels exploratórios; segurança/desempenho equilibrados. 3-hop: Recomendado para aplicações que requerem anonimato forte. Tunnel ID: Inteiro de 4 bytes único por router e por salto, escolhido aleatoriamente pelo criador. Cada salto recebe e encaminha usando IDs diferentes. Informações de Construção de Túnel Routers desempenhando funções de gateway, participante e endpoint recebem diferentes registros dentro da Mensagem de Construção de Túnel. O I2P moderno suporta dois métodos:\nElGamal (legado, registros de 528 bytes) ECIES-X25519 (atual, registros de 218 bytes via Short Tunnel Build Message – STBM) Information Distributed to Participants Gateway recebe: - Chave da camada do túnel (chave AES-256 ou ChaCha20 dependendo do tipo de túnel) - Chave IV do túnel (para criptografar vetores de inicialização) - Chave de resposta e IV de resposta (para criptografia de resposta de construção) - ID do túnel (apenas gateways de entrada) - Hash de identidade do próximo salto e ID do túnel (se não-terminal)\nParticipantes intermediários recebem: - Chave da camada de túnel e chave IV para o seu salto - ID do túnel e informações do próximo salto - Chave de resposta e IV para criptografia da resposta de construção\nOs endpoints recebem: - Chaves da camada de tunnel e IV - Router de resposta e ID do tunnel (apenas endpoints de saída) - Chave de resposta e IV (apenas endpoints de saída)\nPara detalhes completos, consulte a Especificação de Criação de Túnel e a Especificação de Criação de Túnel ECIES .\nTunnel Pooling Os routers agrupam túneis em pools de túneis para redundância e distribuição de carga. Cada pool mantém múltiplos túneis paralelos, permitindo failover quando um falha. Pools usados internamente são exploratory tunnels, enquanto pools específicos de aplicação são client tunnels.\nCada destino mantém pools de entrada e saída separados configurados pelas opções I2CP (contagem de túneis, contagem de backup, comprimento e parâmetros de QoS). Os roteadores monitoram a saúde dos túneis, executam testes periódicos e reconstroem túneis com falha automaticamente para manter o tamanho do pool.\nAgrupamento de Túneis Túneis de 0 saltos: Oferecem apenas negação plausível. O tráfego sempre se origina e termina no mesmo router — desencorajado para qualquer uso anônimo.\nTúneis de 1 salto: Fornecem anonimato básico contra observadores passivos, mas são vulneráveis se um adversário controlar esse único salto.\nTúneis de 2 saltos : Incluem dois routers remotos e aumentam substancialmente o custo de ataque. Padrão para pools exploratórios.\nTúneis de 3 saltos: Recomendado para aplicações que exigem proteção robusta de anonimato. Saltos extras adicionam latência sem ganho significativo de segurança.\nPadrões : Os routers usam túneis exploratórios de 2 saltos e túneis cliente específicos de aplicação de 2 ou 3 saltos, equilibrando desempenho e anonimato.\nComprimento do Túnel Os routers testam periodicamente os tunnels enviando uma DeliveryStatusMessage através de um tunnel de saída para um tunnel de entrada. Se o teste falhar, ambos os tunnels recebem peso negativo no perfil. Falhas consecutivas marcam um tunnel como inutilizável; o router então reconstrói um substituto e publica um novo LeaseSet. Os resultados alimentam as métricas de capacidade de peers usadas pelo sistema de seleção de peers .\nTeste de Túnel Os routers constroem túneis usando um método telescópico não interativo: uma única Mensagem de Construção de Túnel se propaga salto a salto. Cada salto descriptografa seu registro, adiciona sua resposta e encaminha a mensagem adiante. O salto final retorna a resposta agregada de construção por um caminho diferente, prevenindo correlação. Implementações modernas usam Short Tunnel Build Messages (STBM) para ECIES e Variable Tunnel Build Messages (VTBM) para caminhos legados. Cada registro é criptografado por salto usando ElGamal ou ECIES-X25519.\nCriação de Túnel O tráfego dos túneis usa criptografia multicamadas. Cada salto adiciona ou remove uma camada de criptografia conforme as mensagens atravessam o túnel.\nTúneis ElGamal: AES-256/CBC para payloads com preenchimento PKCS#5. Túneis ECIES: ChaCha20 ou ChaCha20-Poly1305 para criptografia autenticada. Cada salto tem duas chaves: uma chave de camada e uma chave IV. Os routers descriptografam o IV, usam-no para processar a carga útil e depois criptografam novamente o IV antes de encaminhar. Este esquema duplo de IV previne a marcação de mensagens.\nOs gateways de saída pré-descriptografam todas as camadas para que os endpoints recebam texto simples depois que todos os participantes adicionaram criptografia. Os túneis de entrada criptografam na direção oposta. Os participantes não conseguem determinar a direção ou o comprimento do túnel.\nCriptografia de Túnel Tempos de vida dinâmicos de túneis e dimensionamento adaptativo de pool para balanceamento de carga da rede Estratégias alternativas de teste de túneis e diagnósticos individuais de saltos Validação opcional de proof-of-work ou certificado de largura de banda (implementado na API 0.9.65+) Pesquisa sobre modelagem de tráfego e inserção de chaff para mistura de endpoints Aposentadoria contínua do ElGamal e migração para ECIES-X25519 Desenvolvimento Contínuo Especificação de Implementação de Tunnel Especificação de Criação de Tunnel (ElGamal) Especificação de Criação de Tunnel (ECIES-X25519) Especificação de Mensagem de Tunnel Garlic Routing I2P Network Database Criação de Perfis e Seleção de Pares Modelo de Ameaças do I2P Criptografia ElGamal/AES + SessionTag Opções I2CP ","description":"Visão geral da terminologia, construção e ciclo de vida dos túneis I2P","id":"d2bb4d16ccaaecd4bfaae8d5b1356800","section":"docs","title":"Roteamento de Tunnel","url":"/pt/docs/overview/tunnel-routing/"},{"categories":null,"content":" 1. Visão Geral Garlic routing permanece como uma das inovações centrais do I2P, combinando criptografia em camadas, agrupamento de mensagens e túneis unidirecionais. Embora conceitualmente semelhante ao onion routing, ele estende o modelo para agrupar múltiplas mensagens criptografadas (\u0026ldquo;cloves\u0026rdquo;) em um único envelope (\u0026ldquo;garlic\u0026rdquo;), melhorando eficiência e anonimato.\nO termo garlic routing foi cunhado por Michael J. Freedman na Tese de Mestrado Free Haven de Roger Dingledine (junho de 2000, §8.1.1). Os desenvolvedores do I2P adotaram o termo no início dos anos 2000 para refletir suas melhorias de empacotamento e modelo de transporte unidirecional, distinguindo-o do design de comutação de circuito do Tor.\nResumo: Garlic routing = criptografia em camadas + agrupamento de mensagens + entrega anônima através de túneis unidirecionais.\n2. A Terminologia \u0026ldquo;Garlic\u0026rdquo; Historicamente, o termo garlic tem sido usado em três contextos diferentes dentro do I2P:\nCriptografia em camadas – proteção estilo onion ao nível do tunnel Agrupamento de múltiplas mensagens – múltiplos \u0026ldquo;cloves\u0026rdquo; dentro de uma \u0026ldquo;garlic message\u0026rdquo; Criptografia ponta a ponta – anteriormente ElGamal/AES+SessionTags, agora ECIES‑X25519‑AEAD‑Ratchet Embora a arquitetura permaneça intacta, o esquema de criptografia foi completamente modernizado.\n3. Criptografia em Camadas O garlic routing compartilha seu princípio fundamental com o roteamento cebola: cada router descriptografa apenas uma camada de criptografia, conhecendo apenas o próximo salto e não o caminho completo.\nNo entanto, o I2P implementa túneis unidirecionais, não circuitos bidirecionais:\nTúnel de saída (Outbound tunnel): envia mensagens para longe do criador Túnel de entrada (Inbound tunnel): transporta mensagens de volta para o criador Uma ida e volta completa (Alice ↔ Bob) usa quatro tunnels: outbound de Alice → inbound de Bob, depois outbound de Bob → inbound de Alice. Este design reduz pela metade a exposição de dados de correlação em comparação com circuitos bidirecionais.\nPara detalhes da implementação de tunnel, consulte a Especificação de Tunnel e a especificação de Criação de Tunnel (ECIES) .\n4. Agrupamento de Múltiplas Mensagens (Os \u0026ldquo;Cloves\u0026rdquo;) O garlic routing original de Freedman previa agrupar múltiplos \u0026ldquo;bulbos\u0026rdquo; criptografados dentro de uma mensagem. O I2P implementa isso como cloves (dentes de alho) dentro de uma garlic message (mensagem garlic) — cada clove tem suas próprias instruções de entrega criptografadas e destino (router, destination ou tunnel).\nO garlic bundling permite que o I2P:\nCombinar confirmações e metadados com mensagens de dados Reduzir padrões de tráfego observáveis Suportar estruturas de mensagem complexas sem conexões extras Figura 1: Uma Garlic Message contendo múltiplos cloves (dentes), cada um com suas próprias instruções de entrega.\nOs dentes típicos incluem:\nMensagem de Status de Entrega — confirmações que atestam sucesso ou falha na entrega.\nEstas são encapsuladas em sua própria camada garlic para preservar confidencialidade. Mensagem de Armazenamento de Banco de Dados — LeaseSets agrupados automaticamente para que os pares possam responder sem consultar novamente o netDb. Os cravo-da-índias são agrupados quando:\nUm novo LeaseSet deve ser publicado Novas tags de sessão são entregues Nenhum agrupamento ocorreu recentemente (~1 minuto por padrão) Mensagens garlic alcançam entrega eficiente ponta-a-ponta de múltiplos componentes criptografados em um único pacote.\n5. Evolução da Criptografia 5.1 Historical Context A documentação inicial (≤ v0.9.12) descreveu a encriptação ElGamal/AES+SessionTags: - ElGamal 2048‑bit para encapsular chaves de sessão AES - AES‑256/CBC para encriptação de payload - session tags de 32 bytes utilizadas uma vez por mensagem\nEsse sistema criptográfico está descontinuado.\n5.2 ECIES‑X25519‑AEAD‑Ratchet (Current Standard) Entre 2019 e 2023, o I2P migrou completamente para ECIES‑X25519‑AEAD‑Ratchet. A stack moderna padroniza os seguintes componentes:\nLayer ECIES Primitive or Concept Transport Layer (NTCP2, SSU2) Noise_NX → X25519, ChaCha20/Poly1305, BLAKE2s I2NP Delivery ECIES‑X25519‑AEAD (ChaCha20/Poly1305) Session Management Ratchet with rekey records, per-clove key material Offline Authentication EdDSA (Ed25519) with LeaseSet2/MetaLeaseSet chains Benefícios da migração ECIES: Sigilo futuro via chaves de ratcheting por mensagem Tamanho de payload reduzido comparado ao ElGamal Resiliência contra avanços criptoanalíticos Compatibilidade com futuros híbridos pós-quânticos (veja Proposta 169) Detalhes adicionais: consulte a Especificação ECIES e a especificação EncryptedLeaseSet .\n6. LeaseSets and Garlic Bundling Os envelopes garlic frequentemente incluem LeaseSets para publicar ou atualizar a acessibilidade do destino.\nVersion Type Key Capabilities Distribution Notes 1 LeaseSet (legacy) Single encryption/signature pair Accepted for backward compatibility 3 LeaseSet2 Multiple crypto suites, offline signing keys Default for modern routers 5 EncryptedLeaseSet Access-controlled, destination hidden from floodfill Requires shared decryption key 7 MetaLeaseSet Aggregates multiple destinations or multi-homed services Extends LeaseSet2 fields recursively Todos os LeaseSets são distribuídos através da *floodfill DHT* mantida por roteadores especializados. As publicações são verificadas, registradas com timestamp e limitadas por taxa para reduzir correlação de metadados. Veja a documentação da Base de Dados de Rede para mais detalhes.\n7. Modern “Garlic” Applications within I2P A criptografia baseada em garlic encryption e o agrupamento de mensagens são usados em toda a pilha de protocolos do I2P:\nCriação e uso de túneis — criptografia em camadas por salto Entrega de mensagens ponta a ponta — mensagens garlic agrupadas com confirmação clonada e cloves de LeaseSet Publicação no Network Database — LeaseSets encapsulados em envelopes garlic para privacidade Transportes SSU2 e NTCP2 — criptografia de subcamada usando framework Noise e primitivas X25519/ChaCha20 O garlic routing é, portanto, tanto um método de camadas de criptografia quanto um modelo de mensagens de rede.\n6. LeaseSets e Garlic Bundling O centro de documentação do I2P está disponível aqui , mantido continuamente. As especificações relevantes em desenvolvimento incluem:\nEspecificação ECIES — ECIES‑X25519‑AEAD‑Ratchet Criação de Tunnel (ECIES) — protocolo moderno de construção de tunnel Especificação I2NP — formatos de mensagem I2NP Especificação SSU2 — transporte UDP SSU2 Estruturas Comuns — comportamento de netDb e floodfill Validação académica: Hoang et al. (IMC 2018, USENIX FOCI 2019) e Muntaka et al. (2025) confirmam a estabilidade arquitetural e a resiliência operacional do design do I2P.\n7. Aplicações Modernas \u0026ldquo;Garlic\u0026rdquo; dentro do I2P Propostas em andamento:\nProposta 169: Híbrido pós-quântico (ML-KEM 512/768/1024 + X25519) Proposta 168: Otimização de largura de banda de transporte Atualizações de datagrama e streaming: Gerenciamento aprimorado de congestionamento Adaptações futuras podem incluir estratégias adicionais de atraso de mensagens ou redundância multi-tunnel ao nível de garlic-message, baseando-se em opções de entrega não utilizadas originalmente descritas por Freedman.\n8. Documentação Atual e Referências Freedman, M. J. \u0026amp; Dingledine, R. (2000). Free Haven Master\u0026rsquo;s Thesis, § 8.1.1. Free Haven Papers Onion Router Publications Garlic Routing (Wikipedia) Tor Project Free Haven Anonbib Goldschlag, D. M., Reed, M. G., Syverson, P. F. (1996). Hiding Routing Information. NRL Publication. ","description":"Compreendendo a terminologia, arquitetura e implementação moderna do garlic routing no I2P","id":"ba07d93d883918641f4a69832e497bb8","section":"docs","title":"Roteamento Garlic","url":"/pt/docs/overview/garlic-routing/"},{"categories":null,"content":" Obsoleto: SAM v1 é mantido apenas para referência histórica. Novas aplicações devem usar SAM v3 ou BOB . A ponte original suporta apenas destinos DSA-SHA1 e um conjunto limitado de opções.\nBibliotecas A árvore de código-fonte do I2P em Java ainda inclui bindings (vinculações) legados para C, C#, Perl e Python. Eles não são mais mantidos e são distribuídos principalmente por motivos de compatibilidade de arquivamento.\nNegociação de Versão Clientes conectam-se via TCP (padrão 127.0.0.1:7656) e trocam:\nClient → HELLO VERSION MIN=1 MAX=1 Bridge → HELLO REPLY RESULT=OK VERSION=1.0 A partir da versão 0.9.14 do Java I2P, o parâmetro MIN é opcional e ambos MIN/MAX aceitam formas de um único dígito (\u0026quot;3\u0026quot; etc.) para pontes atualizadas.\nCriação de sessão SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value]* DESTINATION=name carrega ou cria uma entrada em sam.keys; TRANSIENT sempre cria um destino temporário. STYLE seleciona fluxos virtuais (semelhantes ao TCP), datagramas assinados ou datagramas brutos. DIRECTION aplica-se apenas a sessões de fluxo; o padrão é BOTH. Pares adicionais de chave/valor são encaminhados como opções de I2CP (por exemplo, tunnels.quantityInbound=3). A ponte responde com:\nSESSION STATUS RESULT=OK DESTINATION=name Falhas retornam DUPLICATED_DEST, I2P_ERROR ou INVALID_KEY, além de uma mensagem opcional.\nFormatos de mensagens As mensagens SAM são ASCII de linha única, com pares chave/valor separados por espaço. As chaves estão em UTF‑8; os valores podem ser colocados entre aspas se contiverem espaços. Não há mecanismo de escape definido.\nTipos de comunicação:\nFluxos – encaminhados por proxy através da biblioteca de streaming do I2P Datagramas com possibilidade de resposta – cargas úteis assinadas (Datagram1) Datagramas brutos – cargas úteis sem assinatura (Datagram RAW) Opções adicionadas na versão 0.9.14 DEST GENERATE aceita SIGNATURE_TYPE=... (permitindo Ed25519, etc.) HELLO VERSION trata MIN como opcional e aceita strings de versão de um dígito Quando usar o SAM v1 Apenas para interoperabilidade com software legado que não pode ser atualizado. Para todo novo desenvolvimento, use:\nSAM v3 para acesso a stream/datagram com todos os recursos BOB para gerenciamento de destino (ainda limitado, mas suporta recursos mais modernos) Referências SAM v2 SAM v3 Especificação de Datagramas Protocolo de Streaming SAM v1 lançou as bases para o desenvolvimento de aplicações independente do router, mas o ecossistema já seguiu em frente. Trate este documento como um auxílio de compatibilidade, e não como um ponto de partida.\n","description":"Protocolo legado de Mensagens Anônimas Simples (obsoleto)","id":"d6c20329db11e9b5a1eff3a8709b3294","section":"docs","title":"SAM v1","url":"/pt/docs/legacy/sam/"},{"categories":null,"content":" Obsoleto: SAM v2 foi distribuído com o I2P 0.6.1.31 e não é mais mantido. Use SAM v3 para novos desenvolvimentos. A única melhoria do v2 em relação ao v1 foi o suporte a múltiplos sockets multiplexados sobre uma única conexão SAM.\nNotas da versão A string de versão informada permanece \u0026quot;2.0\u0026quot;. Desde a versão 0.9.14, a mensagem HELLO VERSION aceita valores de um dígito para MIN/MAX e o parâmetro MIN é opcional. DEST GENERATE suporta SIGNATURE_TYPE, assim destinos Ed25519 podem ser criados. Noções básicas de sessão SESSION CREATE STYLE={STREAM|DATAGRAM|RAW} DESTINATION={name|TRANSIENT} [DIRECTION={BOTH|RECEIVE|CREATE}] [option=value] Cada destino pode ter apenas uma sessão SAM ativa (fluxos, datagramas ou raw (bruto)). STYLE seleciona fluxos virtuais, datagramas assinados ou datagramas brutos. Opções adicionais são passadas ao I2CP (por exemplo, tunnels.quantityInbound=3). As respostas refletem a v1: SESSION STATUS RESULT=OK|DUPLICATED_DEST|I2P_ERROR|INVALID_KEY. Codificação de Mensagens ASCII orientado por linhas com pares key=value separados por espaços (os valores podem estar entre aspas). Os tipos de comunicação são os mesmos da v1:\nFluxos via a biblioteca de streaming do I2P Datagramas respondíveis (PROTO_DATAGRAM) Datagramas brutos (PROTO_DATAGRAM_RAW) Quando usar Apenas para clientes legados que não podem migrar. SAM v3 oferece:\nTransferência de destino binário (DEST GENERATE BASE64) Suporte a subsessões e a DHT (tabela de hash distribuída) (v3.3) Relato de erros aprimorado e negociação de opções Consulte:\nSAM v1 SAM v3 API de Datagramas Protocolo de Streaming ","description":"Protocolo Simple Anonymous Messaging legado","id":"a21e46f2603ba3051f18eff26aa5084d","section":"docs","title":"SAM v2","url":"/pt/docs/legacy/samv2/"},{"categories":null,"content":"SAM v3 (\u0026ldquo;Simple Anonymous Messaging\u0026rdquo;) é a atual API estável e agnóstica de router que permite que aplicações externas se comuniquem com a rede I2P sem incorporar o router em si. Fornece acesso unificado a streams, datagrams e mensagens brutas, e permanece como a camada de ponte canônica para software não-Java.\n1. Visão Geral e Propósito SAM v3 permite que desenvolvedores construam software com suporte a I2P em qualquer linguagem usando um protocolo TCP/UDP leve. Ele abstrai os componentes internos do router, expondo um conjunto mínimo de comandos via TCP (7656) e UDP (7655). Tanto o Java I2P quanto o i2pd implementam subconjuntos da especificação SAM v3, embora o i2pd ainda careça da maioria das extensões 3.2 e 3.3 até 2025.\n2. Histórico de Versões Version Introduced Key Features 3.00.7.3 (May 2009)Streams + Datagrams; binary destinations; `SESSION CREATE STYLE=` parameter. 3.10.9.14 (Jul 2014)Signature type negotiation via `SIGNATURE_TYPE`; improved `DEST GENERATE`. 3.20.9.24 (Jan 2016)Per session encryption + tunnel options; `STREAM CONNECT ID` support. 3.30.9.25 (Mar 2016)PRIMARY / SUBSESSION architecture; multiplexing; improved datagrams. ### Nota sobre Nomenclatura Java I2P usa PRIMARY/SUBSESSION. i2pd e I2P+ continuam a usar a terminologia legada MASTER/SUBSESSION para compatibilidade retroativa. 3. Fluxo de Trabalho Principal Negociação de Versão HELLO VERSION MIN=3.1 MAX=3.3 HELLO REPLY RESULT=OK VERSION=3.3 Criação de Destino DEST GENERATE SIGNATURE_TYPE=7 SIGNATURE_TYPE=7 → Ed25519 (EdDSA SHA512). Fortemente recomendado desde I2P 0.9.15. Criação de Sessão SESSION CREATE STYLE=STREAM DESTINATION=NAME OPTION=i2cp.leaseSetEncType=4,0 OPTION=inbound.quantity=3 OPTION=outbound.quantity=3 i2cp.leaseSetEncType=4,0 → 4 é X25519 (ECIES X25519 AEAD Ratchet) e 0 é fallback ElGamal para compatibilidade. Quantidades explícitas de tunnel para consistência: padrão Java I2P 2, padrão i2pd 5. Operações do Protocolo STREAM CONNECT ID=1 DESTINATION=b32address.i2p STREAM SEND ID=1 SIZE=128 STREAM CLOSE ID=1 Os tipos de mensagem principais incluem: STREAM CONNECT, STREAM ACCEPT, STREAM FORWARD, DATAGRAM SEND, RAW SEND, NAMING LOOKUP, DEST LOOKUP, PING, QUIT.\nDesligamento Gracioso QUIT 4. Diferenças de Implementação (Java I2P vs i2pd) Feature Java I2P 2.10.0 i2pd 2.58.0 (Sept\u0026nbsp;2025) SAM enabled by default❌ Requires manual enable in router console✅ Enabled via `enabled=true` in `i2pd.conf` Default portsTCP 7656 / UDP 7655Same AUTH / USER / PASSWORD✓ Supported✗ Not implemented PING / PONG keepalive✓ Supported✗ Not implemented QUIT / STOP / EXIT commands✓ Supported✗ Not implemented FROM_PORT / TO_PORT / PROTOCOL✓ Supported✗ Not implemented PRIMARY/SUBSESSION support✓ (since 0.9.47)✗ Absent SESSION ADD / REMOVE✓ Supported✗ Not implemented Datagram2 / Datagram3 support✓ (since 2.9.0)✗ Not implemented SSL/TLSOptional✗ None Default tunnel quantitiesInbound/outbound=2Inbound/outbound=5 **Recomendação:** Sempre especifique as quantidades de tunnel explicitamente para garantir consistência entre roteadores. 5. Bibliotecas Suportadas (Panorama 2025) Library Language SAM Support Maintenance Status (2025) libsam3C3.1Maintained by I2P Project (eyedeekay) i2psamC++3.1Minimal updates since 2019 sam3Go3.3Active; migrated from `eyedeekay/sam3` onrampGo3.3Actively maintained (2025) i2plibPython3.1Modern async replacement for `i2p.socket` i2p.socketPython3.2Abandoned (last release 2017) Py2pPython3.3Unverified/inactive i2p-rsRust3.1Experimental; unstable API @diva.exchange/i2p-samTypeScript / JS3.3Most actively maintained (2024–2025) I2PSharpC#3.3Functional; light maintenance ## 6. Recursos Novos e Futuros (2024–2025) Feature Status Introduced NAMING LOOKUP `OPTIONS=true`✓ Supported2.8.0 Datagram2 / Datagram3 formats✓ (Java only)2.9.0 Post-quantum hybrid crypto (ML KEM)Optional2.10.0 Java 17+ runtime requirementPlanned2.11.0 I2P over Tor blockingActive2.6.0 Improved floodfill selectionActive2.8.0+ ## 7. Notas de Segurança e Configuração Vincule o SAM apenas a 127.0.0.1. Para serviços persistentes, use sessões PRIMARY com chaves estáticas. Use HELLO VERSION para testar o suporte de recursos. Use PING ou NAMING LOOKUP para verificar a disponibilidade do router. Evite conexões SAM remotas não autenticadas (sem TLS no i2pd). 8. Referências e Especificações Especificação SAMv3 SAM v2 (Legado) Especificação de Streaming Datagramas Central de Documentação Documentação i2pd 9. Resumo SAM v3 continua sendo o protocolo de ponte recomendado para todas as aplicações I2P não Java. Oferece estabilidade, bibliotecas para múltiplas linguagens e desempenho consistente em diferentes tipos de routers.\nAo desenvolver com SAM: - Use assinaturas Ed25519 e criptografia X25519. - Verifique o suporte a recursos dinamicamente via HELLO VERSION. - Projete para compatibilidade, especialmente ao suportar tanto roteadores Java I2P quanto i2pd.\n","description":"Protocolo de ponte estável para aplicações I2P não-Java","id":"dd6d27c1d72fe7c4333dc148d132f546","section":"docs","title":"SAM v3","url":"/pt/docs/api/samv3/"},{"categories":null,"content":" Obsoleto: SSU foi substituído por SSU2. O suporte foi removido no i2pd 2.44.0 (API 0.9.56, nov 2022) e no Java I2P 2.4.0 (API 0.9.61, dez 2023).\nSSU fornecia entrega semiconfiável baseada em UDP, com controle de congestionamento, atravessamento de NAT e suporte a introducer (nó introdutor usado no SSU para facilitar conexões a pares atrás de NAT). Complementava o NTCP ao lidar com routers atrás de NAT/firewalls e ao coordenar a descoberta de IP.\nElementos de endereço transport: SSU caps: flags de capacidade (B, C, 4, 6, etc.) host / port: ouvinte IPv4 ou IPv6 (opcional quando atrás de firewall) key: chave de introdução em Base64 mtu: Opcional; padrão 1484 (IPv4) / 1488 (IPv6) ihost/ikey/iport/itag/iexp: entradas de introducer (nó introdutor) quando o router está atrás de firewall Recursos Atravessamento de NAT cooperativo usando introducers (nós introdutores) Detecção de IP local por meio de testes com pares e inspeção de pacotes de entrada Estado do firewall encaminhado automaticamente a outros transportes e ao console do router Entrega semiconfiável: mensagens retransmitidas até um limite, depois descartadas Controle de congestionamento com aumento aditivo / diminuição multiplicativa e campos de bits de ACK de fragmentos SSU também cuidava de tarefas de metadados, como sinais de temporização e negociação de MTU. Toda a funcionalidade agora é fornecida (com criptografia moderna) pelo SSU2 .\n","description":"Transporte UDP original, seguro e semiconfiável","id":"15d4d0ea2bfc8074b5a7981b8673c420","section":"docs","title":"SSU (legado)","url":"/pt/docs/legacy/ssu/"},{"categories":null,"content":"Visão geral NTCP2 substitui o transporte NTCP legado por um aperto de mão baseado no Noise (framework de protocolos criptográficos) que resiste à impressão digital de tráfego, criptografa os campos de comprimento e oferece suporte a suítes criptográficas modernas. Routers podem executar NTCP2 juntamente com SSU2 como os dois protocolos de transporte obrigatórios na rede I2P. NTCP (versão 1) foi descontinuado na versão 0.9.40 (maio de 2019) e removido completamente na versão 0.9.50 (maio de 2021).\nFramework do Protocolo Noise NTCP2 usa o Noise Protocol Framework Revisão 33, 2017-10-04 com extensões específicas do I2P:\nPadrão: Noise_XK_25519_ChaChaPoly_SHA256 Identificador estendido: Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256 (para a inicialização do KDF (função de derivação de chaves)) Função DH: X25519 (RFC 7748) - chaves de 32 bytes, codificação little-endian Cifra: AEAD_CHACHA20_POLY1305 (RFC 7539/RFC 8439) nonce de 12 bytes: os primeiros 4 bytes iguais a zero, os últimos 8 bytes são um contador (little-endian) Valor máximo do nonce: 2^64 - 2 (a conexão deve ser encerrada antes de atingir 2^64 - 1) Função de hash: SHA-256 (saída de 32 bytes) MAC: Poly1305 (tag de autenticação de 16 bytes) Extensões específicas do I2P Ofuscação AES: Chaves efêmeras criptografadas com AES-256-CBC usando o hash do router de Bob e IV publicado Padding aleatório: Padding em texto claro nas mensagens 1-2 (autenticado), padding AEAD a partir da mensagem 3 (criptografado) Ofuscação de comprimento com SipHash-2-4: Comprimentos de frames de dois bytes são combinados por XOR com a saída do SipHash Estrutura de frames: Frames com prefixo de comprimento para a fase de dados (compatibilidade com streaming TCP) Payloads baseados em blocos: Formato de dados estruturado com blocos tipados Fluxo de Handshake (negociação inicial) Alice (Initiator) Bob (Responder) SessionRequest ──────────────────────► ◄────────────────────── SessionCreated SessionConfirmed ──────────────────────► Handshake de três mensagens SessionRequest - chave efêmera ofuscada de Alice, opções, indicações de preenchimento SessionCreated - chave efêmera ofuscada de Bob, opções criptografadas, preenchimento SessionConfirmed - chave estática criptografada de Alice e RouterInfo (dois quadros AEAD) Padrões de Mensagens do Noise XK(s, rs): Authentication Confidentiality \u0026lt;- s (Bob\u0026#39;s static key known in advance) -\u0026gt; e, es 0 2 \u0026lt;- e, ee 2 1 -\u0026gt; s, se 2 5 \u0026lt;- 2 5 Níveis de autenticação: - 0: Sem autenticação (qualquer parte poderia ter enviado) - 2: Autenticação do remetente resistente a key-compromise impersonation (impersonação por comprometimento de chave, KCI)\nNíveis de Confidencialidade: - 1: Destinatário efêmero (sigilo direto, sem autenticação do destinatário) - 2: Destinatário conhecido, sigilo direto apenas no caso de comprometimento do remetente - 5: Sigilo direto forte (ephemeral-ephemeral + ephemeral-static DH)\nEspecificações de Mensagens Notação de Chaves RH_A = Hash do router de Alice (32 bytes, SHA-256) RH_B = Hash do router de Bob (32 bytes, SHA-256) || = Operador de concatenação byte(n) = Um único byte com valor n Todos os inteiros de múltiplos bytes são big-endian (mais significativo primeiro), a menos que especificado em contrário As chaves X25519 são little-endian (menos significativo primeiro) (32 bytes) Criptografia autenticada (ChaCha20-Poly1305) Função de criptografia:\nAEAD_ChaCha20_Poly1305(key, nonce, associatedData, plaintext) → (ciphertext || MAC) Parâmetros: - key: chave de cifra de 32 bytes proveniente da KDF (função de derivação de chaves) - nonce: 12 bytes (4 bytes nulos + contador de 8 bytes, little-endian) - associatedData: hash de 32 bytes na fase de handshake; comprimento zero na fase de dados - plaintext: Dados a cifrar (0+ bytes)\nSaída: - Texto cifrado: Mesmo tamanho do texto em claro - MAC: 16 bytes (tag de autenticação Poly1305)\nGerenciamento de nonce (número usado uma vez): - O contador começa em 0 para cada instância de cifra - É incrementado a cada operação AEAD (Criptografia Autenticada com Dados Associados) naquela direção - Contadores separados para Alice→Bob e Bob→Alice na fase de dados - Deve encerrar a conexão antes que o contador atinja 2^64 - 1\nMensagem 1: SessionRequest (solicitação de sessão) Alice inicia uma conexão com Bob.\nOperações do Noise: e, es (geração e troca de chaves efêmeras)\nFormato bruto +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted X (32B) + | Key: RH_B, IV: Bob\u0026#39;s published IV | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (X + options) | + k from KDF-1, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Restrições de tamanho: - Mínimo: 80 bytes (32 AES + 48 AEAD) - Máximo: 65535 bytes no total - Caso especial: Máx. 287 bytes ao conectar-se a endereços \u0026ldquo;NTCP\u0026rdquo; (detecção de versão)\nConteúdo descriptografado +----+----+----+----+----+----+----+----+ | | + X (Alice ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Bloco de Opções (16 bytes, big-endian (mais significativo primeiro)) +----+----+----+----+----+----+----+----+ | id | ver| padLen | m3p2len | Rsvd(0) | +----+----+----+----+----+----+----+----+ | tsA | Reserved (0) | +----+----+----+----+----+----+----+----+ id : 1 byte - Network ID (2 for mainnet, 16-254 for testnets) ver : 1 byte - Protocol version (currently 2) padLen : 2 bytes - Padding length in this message (0-65455) m3p2len : 2 bytes - Length of SessionConfirmed part 2 frame Rsvd : 2 bytes - Reserved, set to 0 tsA : 4 bytes - Unix timestamp (seconds since epoch) Reserved: 4 bytes - Reserved, set to 0 Campos críticos: - Network ID (desde 0.9.42): Rejeição rápida de conexões entre redes - m3p2len: Tamanho exato da parte 2 da mensagem 3 (deve corresponder ao valor enviado)\nFunção de Derivação de Chave (KDF-1) Inicializar protocolo:\nprotocol_name = \u0026#34;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256\u0026#34; h = SHA256(protocol_name) ck = h // Chaining key initialized to hash Operações de MixHash:\nh = SHA256(h) // Null prologue h = SHA256(h || rs) // Bob\u0026#39;s static key (known) h = SHA256(h || e.pubkey) // Alice\u0026#39;s ephemeral key X // h is now the associated data for message 1 AEAD Operação MixKey (padrão es):\ndh_result = X25519(Alice.ephemeral_private, Bob.static_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 1 // ck is retained for message 2 KDF Notas de Implementação Ofuscação AES: Usada apenas para resistência a DPI; qualquer pessoa com o hash do router do Bob e o IV pode descriptografar X Prevenção de repetição: Bob deve armazenar em cache valores de X (ou equivalentes criptografados) por pelo menos 2*D segundos (D = desvio máximo de relógio) Validação do carimbo de tempo: Bob deve rejeitar conexões com |tsA - current_time| \u0026gt; D (tipicamente D = 60 segundos) Validação da curva: Bob deve verificar se X é um ponto X25519 válido Rejeição rápida: Bob pode verificar X[31] \u0026amp; 0x80 == 0 antes da descriptografia (chaves X25519 válidas têm o bit mais significativo (MSB) limpo) Tratamento de erros: Em qualquer falha, Bob fecha com TCP RST após um tempo limite aleatório e a leitura de um número aleatório de bytes Bufferização: Alice deve enviar a mensagem inteira (incluindo o padding) de uma vez para eficiência Mensagem 2: SessionCreated (Sessão criada) Bob responde a Alice.\nOperações do Noise: e, ee (DH efêmero-efêmero)\nFormato bruto +----+----+----+----+----+----+----+----+ | | + AES-256-CBC Encrypted Y (32B) + | Key: RH_B, IV: AES state from msg1 | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame (48 bytes) + | Plaintext: 32B (Y + options) | + k from KDF-2, n=0, ad=h + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | + Length specified in options + | 0 to 65535 - 80 bytes | ~ . . . ~ +----+----+----+----+----+----+----+----+ Conteúdo descriptografado +----+----+----+----+----+----+----+----+ | | + Y (Bob ephemeral public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ | Options Block | + (16 bytes) + | | +----+----+----+----+----+----+----+----+ | Cleartext Padding (optional) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Bloco de Opções (16 bytes, big-endian) +----+----+----+----+----+----+----+----+ | Rsvd(0) | padLen | Reserved (0) | +----+----+----+----+----+----+----+----+ | tsB | Reserved (0) | +----+----+----+----+----+----+----+----+ Rsvd : 2 bytes - Reserved, set to 0 padLen : 2 bytes - Padding length in this message Reserved: 10 bytes - Reserved, set to 0 tsB : 4 bytes - Unix timestamp (seconds since epoch) Função de Derivação de Chaves (KDF-2) Operações do MixHash:\nh = SHA256(h || encrypted_payload_msg1) // 32-byte ciphertext if (msg1_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg1) h = SHA256(h || e.pubkey) // Bob\u0026#39;s ephemeral key Y // h is now the associated data for message 2 AEAD MixKey Operation (operação de mistura de chave) (ee pattern):\ndh_result = X25519(Bob.ephemeral_private, Alice.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 2 // ck is retained for message 3 KDF Limpeza de memória:\n// Overwrite ephemeral keys after ee DH Alice.ephemeral_public = zeros(32) Alice.ephemeral_private = zeros(32) // Bob side Bob.received_ephemeral = zeros(32) // Bob side Notas de implementação Encadeamento AES: A criptografia de Y usa o estado do AES-CBC da mensagem 1 (não reinicializado) Prevenção de repetição (replay): Alice deve armazenar em cache os valores de Y por pelo menos 2*D segundos Validação do carimbo de data/hora: Alice deve rejeitar |tsB - current_time| \u0026gt; D Validação da curva: Alice deve verificar se Y é um ponto X25519 válido Tratamento de erros: Alice encerra com TCP RST em qualquer falha Armazenamento em buffer: Bob deve descarregar a mensagem inteira de uma só vez Mensagem 3: SessionConfirmed (confirmação de sessão) Alice confirma a sessão e envia RouterInfo (informações do router).\nOperações do Noise: s, se (revelação da chave estática e DH estático-efêmero)\nEstrutura em duas partes A mensagem 3 consiste em dois quadros AEAD separados: (AEAD: criptografia autenticada com dados associados)\nParte 1: Quadro fixo de 48 bytes com a chave estática criptografada de Alice Parte 2: Quadro de comprimento variável com RouterInfo (informações do router), opções e preenchimento Formato bruto +----+----+----+----+----+----+----+----+ | ChaChaPoly Frame 1 (48 bytes) | + Plaintext: Alice static key (32B) + | k from KDF-2, n=1, ad=h | + + | | +----+----+----+----+----+----+----+----+ | | + ChaChaPoly Frame 2 (variable) + | Length specified in msg1.m3p2len | + k from KDF-3, n=0, ad=h + | Plaintext: RouterInfo + padding | + + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Restrições de tamanho: - Parte 1: Exatamente 48 bytes (32 de texto em claro + 16 MAC) - Parte 2: Comprimento especificado na mensagem 1 (campo m3p2len) - Máximo total: 65535 bytes (parte 1 máx. 48, então parte 2 máx. 65487)\nConteúdo decifrado Parte 1:\n+----+----+----+----+----+----+----+----+ | | + S (Alice static public key) + | 32 bytes, X25519, little-endian | + + | | +----+----+----+----+----+----+----+----+ Parte 2:\n+----+----+----+----+----+----+----+----+ | Block: RouterInfo (required) | + Type=2, contains Alice\u0026#39;s RI + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ | Block: Options (optional) | + Type=1, padding parameters + | | +----+----+----+----+----+----+----+----+ | Block: Padding (optional) | + Type=254, random data + | MUST be last block if present | ~ . . . ~ +----+----+----+----+----+----+----+----+ Função de Derivação de Chaves (KDF-3) Parte 1 (padrão s):\nh = SHA256(h || encrypted_payload_msg2) // 32-byte ciphertext if (msg2_padding_length \u0026gt; 0): h = SHA256(h || padding_from_msg2) // Encrypt static key with message 2 cipher key ciphertext = AEAD_ChaCha20_Poly1305(k_msg2, n=1, h, Alice.static_public) h = SHA256(h || ciphertext) // 48 bytes (32 + 16) // h is now the associated data for message 3 part 2 Parte 2 (padrão se):\ndh_result = X25519(Alice.static_private, Bob.ephemeral_public) temp_key = HMAC-SHA256(ck, dh_result) ck = HMAC-SHA256(temp_key, byte(0x01)) k = HMAC-SHA256(temp_key, ck || byte(0x02)) // k is the cipher key for message 3 part 2 // ck is retained for data phase KDF ciphertext = AEAD_ChaCha20_Poly1305(k, n=0, h, payload) h = SHA256(h || ciphertext) // h is retained for SipHash KDF Limpeza de memória:\n// Overwrite Bob\u0026#39;s ephemeral key after se DH Alice.received_ephemeral = zeros(32) // Alice side Bob.ephemeral_public = zeros(32) // Bob side Bob.ephemeral_private = zeros(32) // Bob side Notas de Implementação Validação do RouterInfo: Bob deve verificar a assinatura, o carimbo de data e hora e a consistência da chave Correspondência de chave: Bob deve verificar se a chave estática de Alice na parte 1 corresponde à chave em RouterInfo Local da chave estática: Procure o parâmetro \u0026ldquo;s\u0026rdquo; correspondente em NTCP ou NTCP2 RouterAddress Ordem dos blocos: RouterInfo deve vir primeiro, Options em segundo (se presente), Padding por último (se presente) Planejamento do tamanho: Alice deve garantir que m3p2len na mensagem 1 corresponda exatamente ao tamanho da parte 2 Armazenamento em buffer: Alice deve enviar ambas as partes juntas em um único envio TCP Encadeamento opcional: Alice pode anexar imediatamente um data phase frame (quadro da fase de dados) para eficiência Fase de Dados Após a conclusão do handshake, todas as mensagens usam quadros AEAD (criptografia autenticada com dados associados) de comprimento variável com campos de comprimento ofuscados.\nFunção de Derivação de Chaves (Fase de Dados) Função Split (Noise):\n// Generate transmit and receive keys zerolen = \u0026#34;\u0026#34; // Zero-length byte array temp_key = HMAC-SHA256(ck, zerolen) // Alice transmits to Bob k_ab = HMAC-SHA256(temp_key, byte(0x01)) // Bob transmits to Alice k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) // Cleanup ck = zeros(32) temp_key = zeros(32) Derivação de chave com SipHash (função de hash autenticado com chave):\n// Generate additional symmetric key for SipHash ask_master = HMAC-SHA256(temp_key, \u0026#34;ask\u0026#34; || byte(0x01)) // \u0026#34;siphash\u0026#34; is 7 bytes US-ASCII temp_key2 = HMAC-SHA256(ask_master, h || \u0026#34;siphash\u0026#34;) sip_master = HMAC-SHA256(temp_key2, byte(0x01)) // Alice to Bob SipHash keys temp_key3 = HMAC-SHA256(sip_master, zerolen) sipkeys_ab = HMAC-SHA256(temp_key3, byte(0x01)) sipk1_ab = sipkeys_ab[0:7] // 8 bytes, little-endian sipk2_ab = sipkeys_ab[8:15] // 8 bytes, little-endian sipiv_ab = sipkeys_ab[16:23] // 8 bytes, IV // Bob to Alice SipHash keys sipkeys_ba = HMAC-SHA256(temp_key3, sipkeys_ab || byte(0x02)) sipk1_ba = sipkeys_ba[0:7] // 8 bytes, little-endian sipk2_ba = sipkeys_ba[8:15] // 8 bytes, little-endian sipiv_ba = sipkeys_ba[16:23] // 8 bytes, IV Estrutura do Quadro +----+----+----+----+----+----+----+----+ |Obfs Len | | +----+----+ ChaChaPoly Frame + | Encrypted Block Data | + k_ab (Alice→Bob) or k_ba (Bob→Alice)| | Nonce starts at 0, increments | + No associated data (empty string) + | | ~ . . . ~ | | +----+----+----+----+----+----+----+----+ | Poly1305 MAC (16 bytes) | +----+----+----+----+----+----+----+----+ Restrições de quadro: - Mínimo: 18 bytes (2 de comprimento ofuscado + 0 em texto claro + 16 MAC) - Máximo: 65537 bytes (2 de comprimento ofuscado + 65535 do quadro) - Recomendado: Poucos KB por quadro (minimizar a latência do receptor)\nOfuscação do Comprimento com SipHash Finalidade: Impedir que a DPI (inspeção profunda de pacotes) identifique os limites de quadros\nAlgoritmo:\n// Initialization (per direction) IV[0] = sipiv // From KDF // For each frame: IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] // First 2 bytes of IV ObfuscatedLength = ActualLength XOR Mask[n] // Send 2-byte ObfuscatedLength, then ActualLength bytes Decodificação:\n// Receiver maintains identical IV chain IV[n] = SipHash-2-4(sipk1, sipk2, IV[n-1]) Mask[n] = IV[n][0:1] ActualLength = ObfuscatedLength XOR Mask[n] // Read ActualLength bytes (includes 16-byte MAC) Notas: - Separe cadeias de IV para cada direção (Alice→Bob e Bob→Alice) - Se SipHash retornar uint64, use os 2 bytes menos significativos como máscara - Converta o uint64 no próximo IV em bytes little-endian\nFormato de bloco Cada quadro contém zero ou mais blocos:\n+----+----+----+----+----+----+----+----+ |Type| Length | Data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 byte - Block type identifier Length: 2 bytes - Big-endian, data size (0-65516) Data : Variable length payload Limites de tamanho: - Quadro máximo: 65535 bytes (incluindo MAC) - Espaço máximo do bloco: 65519 bytes (quadro - MAC de 16 bytes) - Bloco único máximo: 65519 bytes (cabeçalho de 3 bytes + 65516 de dados)\nTipos de Blocos Type Name Description 0DateTimeTime synchronization (4-byte timestamp) 1OptionsPadding parameters, dummy traffic 2RouterInfoRouterInfo delivery/flooding 3I2NPI2NP message with shortened header 4TerminationExplicit connection close 224-253ReservedExperimental features 254PaddingRandom padding (must be last) 255ReservedFuture extensions **Regras de Ordenação de Blocos:** - **Mensagem 3 parte 2**: RouterInfo, Options (opcional), Padding (opcional) - NENHUM outro tipo - **Fase de dados**: Qualquer ordem, exceto: - Padding DEVE ser o último bloco, se presente - Termination DEVE ser o último bloco (exceto Padding), se presente - Múltiplos blocos I2NP são permitidos por quadro - Múltiplos blocos Padding NÃO são permitidos por quadro Tipo de Bloco 0: DateTime Sincronização de tempo para detecção de desvio do relógio.\n+----+----+----+----+----+----+----+ | 0 | 4 | timestamp | +----+----+----+----+----+----+----+ Type : 0 Length : 4 (big-endian) Timestamp: 4 bytes, Unix seconds (big-endian) Implementação: Arredonde para o segundo mais próximo para evitar o acúmulo de viés do relógio.\nTipo de Bloco 1: Opções Parâmetros de preenchimento e modelagem de tráfego.\n+----+----+----+----+----+----+----+----+ | 1 | size |tmin|tmax|rmin|rmax|tdmy| +----+----+----+----+----+----+----+----+ |tdmy| rdmy | tdelay | rdelay | | +----+----+----+----+----+----+----+ + | more_options (TBD) | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 1 Length: 12+ bytes (big-endian) Proporções de preenchimento (número de ponto fixo 4.4, valor/16.0): - tmin: Proporção mínima de preenchimento na transmissão (0.0 - 15.9375) - tmax: Proporção máxima de preenchimento na transmissão (0.0 - 15.9375) - rmin: Proporção mínima de preenchimento na recepção (0.0 - 15.9375) - rmax: Proporção máxima de preenchimento na recepção (0.0 - 15.9375)\nExemplos: - 0x00 = 0% de preenchimento - 0x01 = 6.25% de preenchimento - 0x10 = 100% de preenchimento (proporção de 1:1) - 0x80 = 800% de preenchimento (proporção de 8:1)\nTráfego de preenchimento (dummy traffic): - tdmy: Máximo que está disposto a enviar (2 bytes, média em bytes/seg) - rdmy: Solicitado para receber (2 bytes, média em bytes/seg)\nInserção de atraso: - tdelay: Máximo disposto a inserir (2 bytes, média em milissegundos) - rdelay: Atraso solicitado (2 bytes, média em milissegundos)\nDiretrizes: - Valores mínimos indicam a resistência desejada à análise de tráfego - Valores máximos indicam restrições de largura de banda - O emissor deve respeitar o limite máximo do receptor - O emissor pode respeitar o mínimo do receptor dentro das restrições - Não há mecanismo de imposição; as implementações podem variar\nTipo de bloco 2: RouterInfo (informações do router) Entrega de RouterInfo (informações do router) para preenchimento e difusão do netdb.\n+----+----+----+----+----+----+----+----+ | 2 | size |flg | RouterInfo | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 2 Length: Flag (1 byte) + RouterInfo size Flag : Bit 0 = flood request (1) or local store (0) Bits 1-7 = Reserved, set to 0 Uso:\nNa Mensagem 3 Parte 2 (handshake): - Alice envia seu RouterInfo para Bob - Bit de Flood tipicamente 0 (armazenamento local) - RouterInfo NÃO comprimido com gzip\nNa Fase de Dados: - Qualquer das partes pode enviar seu RouterInfo atualizado - Bit de flood = 1: Solicitar distribuição via floodfill (se o receptor for floodfill) - Bit de flood = 0: Apenas armazenamento local no netdb\nRequisitos de Validação: 1. Verificar se o tipo de assinatura é suportado 2. Verificar a assinatura do RouterInfo (registro de informações do router no I2P) 3. Verificar se o carimbo de data/hora está dentro de limites aceitáveis 4. Para o handshake (negociação inicial): Verificar se a chave estática corresponde ao parâmetro \u0026ldquo;s\u0026rdquo; do endereço NTCP2 5. Para a fase de dados: Verificar se o hash do router corresponde ao par da sessão 6. Somente propague RouterInfos com endereços publicados\nNotas: - Sem mecanismo de ACK (use I2NP DatabaseStore com token de resposta, se necessário) - Pode conter RouterInfos (informações do router) de terceiros (uso de floodfill) - NÃO compactado com gzip (ao contrário de I2NP DatabaseStore)\nTipo de Bloco 3: Mensagem I2NP Mensagem I2NP com cabeçalho reduzido de 9 bytes.\n+----+----+----+----+----+----+----+----+ | 3 | size |type| msg_id | +----+----+----+----+----+----+----+----+ | expiration | I2NP payload | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 3 Length : 9 + payload_size (big-endian) Type : 1 byte, I2NP message type Msg_ID : 4 bytes, big-endian, I2NP message ID Expiration: 4 bytes, big-endian, Unix timestamp (seconds) Payload : I2NP message body (length = size - 9) Diferenças em relação ao NTCP1: - Expiração: 4 bytes (segundos) vs 8 bytes (milissegundos) - Tamanho: Omitido (derivável a partir do tamanho do bloco) - Checksum: Omitido (AEAD fornece integridade) - Cabeçalho: 9 bytes vs 16 bytes (redução de 44%)\nFragmentação: - mensagens I2NP NÃO DEVEM ser fragmentadas entre blocos - mensagens I2NP NÃO DEVEM ser fragmentadas entre frames - Múltiplos blocos I2NP permitidos por frame\nTipo de Bloco 4: Encerramento Encerramento explícito da conexão com código de motivo.\n+----+----+----+----+----+----+----+----+ | 4 | size | valid_frames_recv | +----+----+----+----+----+----+----+----+ | (continued) |rsn | additional_data | +----+----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type : 4 Length : 9+ bytes (big-endian) Valid_Frames_Recv: 8 bytes, big-endian (receive nonce value) 0 if error in handshake phase Reason : 1 byte (see table below) Additional_Data : Optional (format unspecified, for debugging) Códigos de motivo:\nCode Reason Phase 0Normal close / unspecifiedAny 1Termination receivedData 2Idle timeoutData 3Router shutdownData 4Data phase AEAD failureData 5Incompatible optionsHandshake 6Incompatible signature typeHandshake 7Clock skewHandshake 8Padding violationAny 9AEAD framing errorData 10Payload format errorData 11Message 1 errorHandshake 12Message 2 errorHandshake 13Message 3 errorHandshake 14Intra-frame read timeoutData 15RouterInfo signature verification failHandshake 16Static key parameter mismatchHandshake 17BannedAny **Regras:** - A terminação DEVE ser o último bloco não de preenchimento no quadro - No máximo um bloco de terminação por quadro - O emissor deveria fechar a conexão após o envio - O receptor deveria fechar a conexão após o recebimento Tratamento de erros: - Erros de handshake: Normalmente encerrar com TCP RST (sem bloco de terminação) - Erros de AEAD (cifra autenticada com dados associados) na fase de dados: Tempo limite aleatório + leitura aleatória, em seguida, enviar a terminação - Veja a seção \u0026ldquo;AEAD Error Handling\u0026rdquo; para procedimentos de segurança\nTipo de bloco 254: Preenchimento Preenchimento aleatório para resistência à análise de tráfego.\n+----+----+----+----+----+----+----+----+ |254 | size | random_data | +----+----+----+ + | | ~ . . . ~ +----+----+----+----+----+----+----+----+ Type: 254 Length: 0-65516 bytes (big-endian) Data: Cryptographically random bytes Regras: - O padding (preenchimento) DEVE ser o último bloco no quadro, se presente - Padding de comprimento zero é permitido - Apenas um bloco de padding por quadro - Quadros apenas de padding são permitidos - Deve respeitar os parâmetros negociados do bloco Options\nPreenchimento nas mensagens 1-2: - Fora do quadro AEAD (criptografia autenticada com dados associados) (texto em claro) - Incluído na cadeia de hash da próxima mensagem (autenticado) - Manipulação detectada quando o AEAD da próxima mensagem falha\nPreenchimento em Message 3+ e Fase de Dados: - Dentro do quadro AEAD (criptografado e autenticado) - Usado para modelagem de tráfego e ofuscação do tamanho\nTratamento de erros de AEAD (criptografia autenticada com dados associados) Requisitos de Segurança Críticos:\nFase de Handshake (negociação inicial) (Mensagens 1-3) Tamanho de Mensagem Conhecido: - Os tamanhos de mensagem são predefinidos ou especificados antecipadamente - A falha de autenticação em AEAD (autenticação e criptografia com dados associados) é inequívoca\nResposta de Bob à falha na Mensagem 1: 1. Definir tempo limite aleatório (faixa dependente da implementação, sugere-se 100-500ms) 2. Ler uma quantidade aleatória de bytes (faixa dependente da implementação, sugere-se 1KB-64KB) 3. Fechar a conexão com TCP RST (sem resposta) 4. Bloquear temporariamente o IP de origem 5. Registrar falhas repetidas para banimentos de longo prazo\nResposta de Alice à falha da Mensagem 2: 1. Fechar a conexão imediatamente com TCP RST 2. Nenhuma resposta para Bob\nResposta de Bob à falha da Mensagem 3: 1. Fechar a conexão imediatamente com TCP RST 2. Não responder a Alice\nFase de dados Tamanho da Mensagem Ofuscado: - O campo de comprimento é ofuscado com SipHash - Comprimento inválido ou falha de AEAD podem indicar: - Sondagem por um atacante - Corrupção na rede - IV de SipHash dessincronizado - Par malicioso\nResposta a erro de AEAD (Autenticação e Criptografia com Dados Associados) ou Erro de Comprimento: 1. Defina um tempo limite aleatório (sugestão: 100-500ms) 2. Leia um número aleatório de bytes (sugestão: 1KB-64KB) 3. Envie um bloco de término com código de motivo 4 (falha de AEAD) ou 9 (erro de enquadramento) 4. Feche a conexão\nPrevenção de Oráculo de Descriptografia: - Nunca revele o tipo de erro ao par antes de um tempo limite aleatório - Nunca omita a validação do tamanho antes da verificação de AEAD (criptografia autenticada com dados associados) - Trate um tamanho inválido da mesma forma que uma falha de AEAD - Use um caminho de tratamento de erros idêntico para ambos os erros\nConsiderações de Implementação: - Algumas implementações podem continuar após erros de AEAD (criptografia autenticada com dados associados) se forem infrequentes - Encerrar após erros repetidos (limiar sugerido: 3-5 erros por hora) - Equilíbrio entre a recuperação de erros e a segurança\nRouterInfo (metadados do router no I2P) publicado Formato de Endereço do Router O suporte a NTCP2 é anunciado por meio de entradas RouterAddress (endereço do router) publicadas com opções específicas.\nEstilo de Transporte: - \u0026quot;NTCP2\u0026quot; - NTCP2 apenas nesta porta - \u0026quot;NTCP\u0026quot; - Tanto NTCP quanto NTCP2 nesta porta (detecção automática) - Nota: suporte a NTCP (v1) removido na 0.9.50 (maio de 2021) - o estilo \u0026ldquo;NTCP\u0026rdquo; agora está obsoleto; use \u0026ldquo;NTCP2\u0026rdquo;\nOpções obrigatórias Todos os endereços NTCP2 publicados:\nhost - Endereço IP (IPv4 ou IPv6) ou nome do host\nFormato: Notação IP padrão ou nome de domínio Pode ser omitido em routers somente de saída ou ocultos port - Número da porta TCP\nFormato: Inteiro, 1-65535 Pode ser omitida para routers outbound-only (apenas de saída) ou ocultos s - Chave pública estática (X25519)\nFormato: codificado em Base64, 44 caracteres Codificação: alfabeto Base64 do I2P Origem: chave pública X25519 de 32 bytes, little-endian (ordem de bytes do menos significativo primeiro) i - Vetor de inicialização (IV) para AES\nFormato: codificado em Base64, 24 caracteres Codificação: alfabeto Base64 do I2P Origem: IV de 16 bytes, big-endian v - Versão do protocolo\nFormato: inteiro ou inteiros separados por vírgula Atual: \u0026quot;2\u0026quot; Futuro: \u0026quot;2,3\u0026quot; (deve estar em ordem numérica) Opções opcionais:\ncaps - Capacidades (desde 0.9.50)\nFormato: Cadeia de caracteres de capacidades Valores: \u0026quot;4\u0026quot; - Capacidade de saída IPv4 \u0026quot;6\u0026quot; - Capacidade de saída IPv6 \u0026quot;46\u0026quot; - Ambos IPv4 e IPv6 (ordem recomendada) Não é necessário se host estiver publicado Útil para routers ocultos/atrás de firewall cost - Prioridade do endereço\nFormato: inteiro, 0-255 Valores menores = prioridade mais alta Sugerido: 5-10 para endereços normais Sugerido: 14 para endereços não publicados Exemplos de entradas de RouterAddress Endereço IPv4 publicado:\n\u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Router oculto (somente de saída):\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;caps\u0026gt;4\u0026lt;/caps\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Router Dual-Stack (pilha dupla):\n\u0026lt;!-- IPv4 Address --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;192.0.2.1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; \u0026lt;!-- IPv6 Address (same keys, same port) --\u0026gt; \u0026lt;Address cost=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;host\u0026gt;2001:db8::1\u0026lt;/host\u0026gt; \u0026lt;port\u0026gt;8887\u0026lt;/port\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;i\u0026gt;MDEyMzQ1Njc4OUFCQ0RFRg==\u0026lt;/i\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Regras importantes: - Vários endereços NTCP2 com a mesma porta DEVEM usar valores idênticos s, i e v - Portas diferentes podem usar chaves diferentes - Routers dual-stack (pilha dupla) devem publicar endereços IPv4 e IPv6 separados\nEndereço NTCP2 não publicado Para Routers somente de saída:\nSe um router não aceita conexões NTCP2 de entrada, mas inicia conexões de saída, ele DEVE ainda assim publicar um RouterAddress (estrutura de endereço do router) com:\n\u0026lt;Address cost=\u0026#34;14\u0026#34;\u0026gt; \u0026lt;transport_style\u0026gt;NTCP2\u0026lt;/transport_style\u0026gt; \u0026lt;options\u0026gt; \u0026lt;s\u0026gt;9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo=\u0026lt;/s\u0026gt; \u0026lt;v\u0026gt;2\u0026lt;/v\u0026gt; \u0026lt;/options\u0026gt; \u0026lt;/Address\u0026gt; Objetivo: - Permite que Bob valide a chave estática de Alice durante o handshake (negociação inicial) - Necessária para a verificação de RouterInfo (informações do router) na mensagem 3, parte 2 - Não é necessário i, host ou port (somente saída)\nAlternativa: - Adicione s e v ao endereço \u0026ldquo;NTCP\u0026rdquo; ou SSU já publicado\nRotação da chave pública e do vetor de inicialização (IV) Política de Segurança Crítica:\nRegras gerais: 1. Nunca realizar a rotação enquanto o router estiver em execução 2. Armazene de forma persistente a chave e o IV (vetor de inicialização) entre reinicializações 3. Acompanhe o tempo de inatividade anterior para determinar a elegibilidade para rotação\nTempo mínimo de inatividade antes da rotação:\nRouter Type Min Downtime Reason Published NTCP2 address1 monthMany routers cache RouterInfo Published SSU only (no NTCP2)1 dayModerate caching No published addresses (hidden)2 hoursMinimal impact **Gatilhos adicionais:** - Alteração do endereço IP local: Pode rotacionar independentemente do tempo de inatividade - Router \"rekey\" (novo Router Hash): Gera novas chaves Justificativa: - Evita expor horários de reinício por meio de alterações de chave - Permite que RouterInfos (informações do router) em cache expirem naturalmente - Mantém a estabilidade da rede - Reduz tentativas de conexão malsucedidas\nImplementação: 1. Armazenar de forma persistente a chave, o IV (vetor de inicialização) e o timestamp do último desligamento 2. Na inicialização, calcular downtime = current_time - last_shutdown 3. Se downtime \u0026gt; mínimo para o tipo de router, pode rotacionar 4. Se o IP mudou ou rekeying (troca de chaves), pode rotacionar 5. Caso contrário, reutilizar a chave anterior e o IV\nRotação do IV: - Sujeita às mesmas regras que a rotação de chaves - Presente apenas em endereços publicados (não em routers ocultos) - Recomenda-se alterar o IV sempre que a chave mudar\nDetecção de Versão Contexto: Quando transportStyle=\u0026quot;NTCP\u0026quot; (legado), Bob oferece suporte a NTCP v1 e v2 na mesma porta e deve detectar automaticamente a versão do protocolo.\nAlgoritmo de detecção:\n1. Wait for at least 64 bytes (minimum NTCP2 message 1 size) 2. If received ≥ 288 bytes: → Connection is NTCP version 1 (NTCP1 message 1 is 288 bytes) 3. If received \u0026lt; 288 bytes: Option A (conservative, pre-NTCP2 majority): a. Wait additional short time (e.g., 100-500ms) b. If total received ≥ 288 bytes → NTCP1 c. Otherwise → Attempt NTCP2 decode Option B (aggressive, post-NTCP2 majority): a. Attempt NTCP2 decode immediately: - Decrypt first 32 bytes (X key) with AES-256-CBC - Verify valid X25519 point (X[31] \u0026amp; 0x80 == 0) - Verify AEAD frame b. If decode succeeds → NTCP2 c. If decode fails → Wait for more data or NTCP1 Verificação rápida do MSB (bit mais significativo): - Antes da descriptografia AES, verifique: encrypted_X[31] \u0026amp; 0x80 == 0 - Chaves X25519 válidas têm o MSB limpo - Falha indica provável NTCP1 (ou ataque) - Implemente resistência a sondagens (tempo limite aleatório + leitura) em caso de falha\nRequisitos de Implementação:\nResponsabilidade de Alice:\nAo conectar-se ao endereço \u0026ldquo;NTCP\u0026rdquo;, limitar a mensagem 1 a, no máximo, 287 bytes Armazenar em buffer e enviar toda a mensagem 1 de uma vez Aumenta a probabilidade de entrega em um único pacote TCP Responsabilidades de Bob:\nArmazenar em buffer os dados recebidos antes de decidir a versão Implementar tratamento adequado de tempo limite (timeout) Usar TCP_NODELAY para detecção rápida da versão Armazenar em buffer e descarregar toda a mensagem 2 de uma vez após detectar a versão Considerações de Segurança: - Ataques de segmentação: Bob deve ser resiliente à segmentação de TCP - Ataques de sondagem: Implementar atrasos aleatórios e leituras de bytes em caso de falhas - Prevenção de DoS: Limitar o número de conexões pendentes simultâneas - Tempos limite de leitura: Tanto por leitura quanto total (proteção contra \u0026ldquo;slowloris\u0026rdquo;)\nDiretrizes sobre desvio de relógio Campos de carimbo de data/hora: - Mensagem 1: tsA (carimbo de data/hora de Alice) - Mensagem 2: tsB (carimbo de data/hora de Bob) - Mensagem 3+: blocos DateTime (data e hora) opcionais\nDesvio Máximo (D): - Típico: ±60 segundos - Configurável conforme a implementação - Desvio \u0026gt; D é geralmente fatal\nTratamento de Bob (Mensagem 1) 1. Receive tsA from Alice 2. skew = tsA - current_time 3. If |skew| \u0026gt; D: a. Still send message 2 (allows Alice to calculate skew) b. Include tsB in message 2 c. Do NOT initiate handshake completion d. Optionally: Temporary ban Alice\u0026#39;s IP e. After message 2 sent, close connection 4. If |skew| ≤ D: a. Continue handshake normally Justificativa: Enviar a mensagem 2 mesmo em caso de defasagem do relógio permite que Alice diagnostique problemas de relógio.\nTratamento de Alice (Mensagem 2) 1. Receive tsB from Bob 2. RTT = (current_time_now - tsA_sent) 3. adjusted_skew = (tsB - current_time_now) - (RTT / 2) 4. If |adjusted_skew| \u0026gt; D: a. Close connection immediately b. If local clock suspect: Adjust clock or use external time source c. If Bob\u0026#39;s clock suspect: Temporary ban Bob d. Log for operator review 5. If |adjusted_skew| ≤ D: a. Continue handshake normally b. Optionally: Track skew for time synchronization Ajuste de RTT: - Subtrair metade do RTT do desvio calculado - Leva em conta o atraso de propagação da rede - Estimativa de desvio mais precisa\nProcessamento por Bob (Mensagem 3) 1. If message 3 received (unlikely if skew exceeded in message 1) 2. Recalculate skew = tsA_received - current_time 3. If |adjusted_skew| \u0026gt; D: a. Send termination block (reason code 7: clock skew) b. Close connection c. Ban Alice for period (e.g., 1-24 hours) Sincronização de Tempo Blocos DateTime (Fase de Dados): - Enviar periodicamente o bloco DateTime (tipo 0) - O receptor pode usar para ajuste do relógio - Arredondar o carimbo de data/hora para o segundo mais próximo (evitar viés)\nFontes Externas de Tempo: - NTP (Protocolo de Tempo de Rede) - Sincronização do relógio do sistema - Tempo de consenso da rede I2P\nEstratégias de Ajuste do Relógio: - Se o relógio local estiver incorreto: ajuste a hora do sistema ou use um offset (deslocamento) - Se os relógios dos peers (pares) estiverem consistentemente incorretos: sinalize o problema no peer - Acompanhe estatísticas de desvio para monitoramento da saúde da rede\nPropriedades de Segurança Sigilo Direto Obtido por meio de: - Troca de chaves Diffie-Hellman efêmera (X25519) - Três operações DH: es, ee, se (padrão Noise XK) - Chaves efêmeras destruídas após a conclusão do handshake (negociação inicial)\nProgressão de Confidencialidade: - Mensagem 1: Nível 2 (sigilo de encaminhamento em caso de comprometimento do remetente) - Mensagem 2: Nível 1 (destinatário efêmero) - Mensagem 3+: Nível 5 (sigilo de encaminhamento forte)\nSigilo de Encaminhamento Perfeito: - O comprometimento de chaves estáticas de longo prazo NÃO revela chaves de sessões passadas - Cada sessão usa chaves efêmeras exclusivas - As chaves privadas efêmeras nunca são reutilizadas - Limpeza de memória após o acordo de chaves\nLimitações: - Mensagem 1 vulnerável se a chave estática de Bob for comprometida (mas há sigilo futuro (forward secrecy) em caso de comprometimento de Alice) - Ataques de repetição possíveis para a mensagem 1 (mitigados por carimbo de tempo e cache de repetição)\nAutenticação Autenticação Mútua: - Alice autenticada por chave estática na mensagem 3 - Bob autenticado pela posse da chave privada estática (implícito a partir de handshake bem-sucedido)\nResistência a Key Compromise Impersonation (KCI, impersonação por comprometimento de chave): - Nível de autenticação 2 (resistente a KCI) - O atacante não pode se passar por Alice mesmo com a chave privada estática de Alice (sem a chave efêmera de Alice) - O atacante não pode se passar por Bob mesmo com a chave privada estática de Bob (sem a chave efêmera de Bob)\nVerificação de Chave Estática: - Alice sabe a chave estática de Bob com antecedência (do RouterInfo (informações do router)) - Bob verifica se a chave estática de Alice corresponde ao RouterInfo na mensagem 3 - Evita ataques man-in-the-middle\nResistência à Análise de Tráfego Contramedidas de DPI (Inspeção profunda de pacotes): 1. Ofuscação com AES: Chaves efêmeras criptografadas; parece aleatório 2. Ofuscação de comprimento com SipHash: Comprimentos dos quadros não em claro 3. Preenchimento aleatório: Tamanhos de mensagem variáveis, sem padrões fixos 4. Quadros criptografados: Toda a carga útil criptografada com ChaCha20\nPrevenção contra ataques de repetição: - Validação de carimbo de tempo (±60 segundos) - Cache de repetição de chaves efêmeras (tempo de vida 2*D) - Incrementos de nonce (número único de uso único) evitam a repetição de pacotes dentro da sessão\nResistência a sondagens: - Tempos limite aleatórios em falhas de AEAD - Leituras aleatórias de bytes antes do encerramento da conexão - Nenhuma resposta em falhas de handshake - Bloqueio de IP por falhas repetidas\nDiretrizes de preenchimento: - Mensagens 1-2: preenchimento em texto claro (autenticado) - Mensagem 3+: preenchimento criptografado dentro de quadros AEAD - Parâmetros de preenchimento negociados (Options block – bloco de Opções) - Quadros somente de preenchimento permitidos\nMitigação de Ataques de Negação de Serviço Limites de conexão: - Máximo de conexões ativas (dependente da implementação) - Máximo de handshakes (negociação inicial) pendentes (por exemplo, 100-1000) - Limites de conexão por IP (por exemplo, 3-10 simultâneas)\nProteção de Recursos: - Operações DH com limitação de taxa (custosas) - Tempos limite de leitura por soquete e no total - Proteção contra \u0026ldquo;Slowloris\u0026rdquo; (limites de tempo totais) - Bloqueio de IP por abuso\nRejeição rápida: - Incompatibilidade de ID de rede → encerramento imediato - Ponto X25519 inválido → verificação rápida de MSB (bit mais significativo) antes da descriptografia - Carimbo de data e hora fora dos limites → encerrar sem processamento - Falha de AEAD (criptografia autenticada com dados associados) → sem resposta, atraso aleatório\nResistência a sondagens: - Tempo limite aleatório: 100-500ms (dependente da implementação) - Leitura aleatória: 1KB-64KB (dependente da implementação) - Nenhuma informação de erro para o atacante - Encerrar com TCP RST (sem handshake FIN)\nSegurança Criptográfica Algoritmos: - X25519: segurança de 128 bits, DH de curva elíptica (Curve25519) - ChaCha20: cifra de fluxo com chave de 256 bits - Poly1305: MAC seguro do ponto de vista da teoria da informação - SHA-256: resistência a colisões de 128 bits, resistência à pré-imagem de 256 bits - HMAC-SHA256: função pseudorrandômica (PRF) para derivação de chaves\nTamanhos de chave: - Chaves estáticas: 32 bytes (256 bits) - Chaves efêmeras: 32 bytes (256 bits) - Chaves de cifra: 32 bytes (256 bits) - MAC: 16 bytes (128 bits)\nProblemas conhecidos: - A reutilização de nonce (valor único não repetível) no ChaCha20 é catastrófica (evitada pelo incremento do contador) - X25519 tem problemas com subgrupos pequenos (mitigados pela validação da curva) - SHA-256 é teoricamente vulnerável à extensão de comprimento (não explorável em HMAC)\nNenhuma vulnerabilidade conhecida (em outubro de 2025): - Noise Protocol Framework amplamente analisado - ChaCha20-Poly1305 utilizado no TLS 1.3 - X25519 padrão em protocolos modernos - Sem ataques práticos à construção\nReferências Especificações Principais Especificação do NTCP2 - Especificação oficial do I2P Proposta 111 - Documento de projeto original com fundamentação Noise Protocol Framework - Revisão 33 (2017-10-04) Padrões criptográficos RFC 7748 - Curvas Elípticas para Segurança (X25519) RFC 7539 - ChaCha20 e Poly1305 para Protocolos da IETF RFC 8439 - ChaCha20-Poly1305 (torna o RFC 7539 obsoleto) RFC 2104 - HMAC: Hash com chave para autenticação de mensagens SipHash - SipHash-2-4 para aplicações de funções de hash Especificações relacionadas do I2P Especificação do I2NP - formato de mensagem do I2P Network Protocol (protocolo de rede do I2P) Estruturas Comuns - formatos de RouterInfo e RouterAddress Transporte SSU - transporte UDP (original, agora SSU2) Proposta 147 - Verificação do ID da rede de transporte (0.9.42) Referências de Implementação I2P Java - Implementação de referência (Java) i2pd - Implementação em C++ Notas de Lançamento do I2P - Histórico de versões e atualizações Contexto histórico Station-To-Station Protocol (STS) - Inspiração para o Noise framework (estrutura para negociações de chaves criptográficas) obfs4 - Transporte plugável (precedente de ofuscação do comprimento com SipHash) Diretrizes de Implementação Requisitos obrigatórios Para conformidade:\nImplementar handshake completo:\nSuportar todas as três mensagens com cadeias KDF corretas Validar todas as tags AEAD Verificar se os pontos X25519 são válidos Implementar a Fase de Dados:\nOfuscação do comprimento com SipHash (em ambas as direções) Todos os tipos de bloco: 0 (DateTime), 1 (Options), 2 (RouterInfo), 3 (I2NP), 4 (Termination), 254 (Padding) Gerenciamento adequado de nonce (número usado uma vez) (contadores separados) Recursos de segurança:\nPrevenção de replay (armazenar em cache chaves efêmeras por 2*D) Validação de carimbo de tempo (±60 segundos por padrão) Preenchimento aleatório nas mensagens 1-2 Tratamento de erros em AEAD (Authenticated Encryption with Associated Data — criptografia autenticada com dados associados) com tempos limite aleatórios Publicação do RouterInfo (metadados do router):\nPublicar chave estática (\u0026ldquo;s\u0026rdquo;), vetor de inicialização (IV) (\u0026ldquo;i\u0026rdquo;) e versão (\u0026ldquo;v\u0026rdquo;) Rotacionar chaves conforme a política Suportar o campo de capacidades (\u0026ldquo;caps\u0026rdquo;) para routers ocultos Compatibilidade de rede:\nSuportar o campo de ID da rede (atualmente 2 para a rede principal) Interoperar com as implementações existentes em Java e i2pd Suportar IPv4 e IPv6 Práticas Recomendadas Otimização de desempenho:\nEstratégia de armazenamento em buffer:\nDescarregar mensagens inteiras de uma vez (mensagens 1, 2, 3) Usar TCP_NODELAY para mensagens de handshake (negociação inicial) Agrupar vários blocos de dados em um único quadro Limitar o tamanho do quadro a poucos KB (minimizar a latência no receptor) Gerenciamento de conexões:\nReutilize conexões quando possível Implemente pool de conexões Monitore a saúde da conexão (DateTime blocks, bloqueios de DateTime) Gerenciamento de memória:\nZerar dados sensíveis após o uso (chaves efêmeras, resultados de DH (Diffie-Hellman)) Limitar handshakes simultâneos (prevenção de DoS) Usar pools de memória para alocações frequentes Fortalecimento de segurança:\nResistência a sondagens:\nTempos limite aleatórios: 100-500ms Leituras aleatórias de bytes: 1KB-64KB Bloqueio de IP por falhas repetidas Sem detalhes de erro para os pares Limites de recursos:\nMáximo de conexões por IP: 3-10 Máximo de handshakes (negociações iniciais) pendentes: 100-1000 Tempo limite de leitura: 30-60 segundos por operação Tempo limite total de conexão: 5 minutos para handshake Gerenciamento de chaves:\nArmazenamento persistente da chave estática e do vetor de inicialização (IV) Geração aleatória segura (RNG criptográfico) Cumprir rigorosamente as políticas de rotação Nunca reutilizar chaves efêmeras Monitoramento e Diagnóstico:\nMétricas:\nTaxas de sucesso/falha do handshake (negociação inicial) Taxas de erro de AEAD Distribuição do desvio de relógio Estatísticas de duração da conexão Registro em log:\nRegistrar falhas de handshake (negociação inicial) com códigos de motivo Registrar eventos de desvio de relógio Registrar IPs banidos Nunca registrar material de chave sensível Testes:\nTestes de unidade para cadeias de KDF Testes de integração com outras implementações Fuzzing para tratamento de pacotes Testes de carga para resistência a DoS Armadilhas comuns Erros críticos a evitar:\nReutilização de Nonce (número usado uma vez):\nNunca redefina o contador de nonce no meio da sessão Use contadores separados para cada direção Encerre antes de atingir 2^64 - 1 Rotação de chaves:\nNunca rotacione chaves enquanto o router estiver em execução Nunca reutilize chaves efêmeras entre sessões Siga as regras de tempo mínimo de inatividade Manipulação de carimbos de data/hora:\nNunca aceite carimbos de data/hora expirados Sempre ajuste em função do RTT (tempo de ida e volta) ao calcular o desvio Arredonde os carimbos de data/hora DateTime para segundos Erros de AEAD:\nNunca revele o tipo de erro ao atacante Sempre use um tempo limite aleatório antes de fechar Trate um comprimento inválido da mesma forma que uma falha de AEAD Padding (preenchimento):\nNunca enviar preenchimento fora dos limites negociados Sempre colocar o bloco de preenchimento por último Nunca múltiplos blocos de preenchimento por quadro RouterInfo:\nSempre verifique se a chave estática corresponde ao RouterInfo Nunca propague RouterInfos sem endereços publicados Sempre valide as assinaturas Metodologia de Testes Testes unitários:\nPrimitivas criptográficas:\nVetores de teste para X25519, ChaCha20, Poly1305, SHA-256 Vetores de teste de HMAC-SHA256 Vetores de teste de SipHash-2-4 Cadeias KDF (função de derivação de chaves):\nTestes de resposta conhecida para todas as três mensagens Verificar a propagação da chave de encadeamento Testar a geração do IV (vetor de inicialização) do SipHash Análise de mensagens:\nDecodificação de mensagens válidas Rejeição de mensagens inválidas Condições de fronteira (vazio, tamanho máximo) Testes de Integração:\nAperto de mão:\nTroca de três mensagens bem-sucedida Rejeição por desvio de relógio Detecção de ataque de repetição Rejeição de chave inválida Fase de Dados:\nTransferência de mensagens do I2NP Troca de RouterInfo Tratamento do preenchimento Mensagens de encerramento Interoperabilidade:\nTestar com o Java I2P Testar com o i2pd Testar IPv4 e IPv6 Testar routers publicados e ocultos Testes de Segurança:\nTestes Negativos:\nTags AEAD inválidas Mensagens repetidas Ataques de desvio de relógio Quadros malformados Testes de DoS:\nInundação de conexões Ataques Slowloris Exaustão de CPU (DH excessivo) Exaustão de memória Fuzzing (teste por mutação):\nMensagens de handshake aleatórias Quadros aleatórios da fase de dados Tipos e tamanhos de blocos aleatórios Valores criptográficos inválidos Migração do NTCP Para o suporte legado ao NTCP (um protocolo de transporte do I2P) (agora removido):\nNTCP (versão 1) foi removido na versão 0.9.50 do I2P (maio de 2021). Todas as implementações atuais devem oferecer suporte a NTCP2. Notas históricas:\nPeríodo de Transição (2018-2021):\n0.9.36: NTCP2 introduzido (desativado por padrão) 0.9.37: NTCP2 ativado por padrão 0.9.40: NTCP obsoleto 0.9.50: NTCP removido Detecção de versão:\n\u0026ldquo;NTCP\u0026rdquo; transportStyle (estilo de transporte) indicava suporte a ambas as versões \u0026ldquo;NTCP2\u0026rdquo; transportStyle indicava apenas NTCP2 Detecção automática via tamanho da mensagem (287 vs 288 bytes) Estado atual:\nTodos os routers devem suportar NTCP2 \u0026ldquo;NTCP\u0026rdquo; transportStyle está obsoleto Use \u0026ldquo;NTCP2\u0026rdquo; transportStyle exclusivamente Apêndice A: Padrão Noise XK Padrão Noise XK Pattern (padrão de handshake do framework Noise):\nXK(s, rs): \u0026lt;- s ... -\u0026gt; e, es \u0026lt;- e, ee -\u0026gt; s, se Interpretação:\n\u0026lt;- : Mensagem do respondente (Bob) para o iniciador (Alice) -\u0026gt; : Mensagem do iniciador (Alice) para o respondente (Bob) s : Chave estática (chave de identidade de longo prazo) rs : Chave estática remota (chave estática do par, conhecida de antemão) e : Chave efêmera (específica da sessão, gerada sob demanda) es : DH Efêmero-Estático (efêmero de Alice × estático de Bob) ee : DH Efêmero-Efêmero (efêmero de Alice × efêmero de Bob) se : DH Estático-Efêmero (estático de Alice × efêmero de Bob) Sequência de Acordo de Chaves:\nPré-mensagem: Alice conhece a chave pública estática de Bob (do RouterInfo, metadados do router) Mensagem 1: Alice envia a chave efêmera, executa es DH Mensagem 2: Bob envia a chave efêmera, executa ee DH Mensagem 3: Alice revela a chave estática, executa se DH Propriedades de Segurança:\nAlice autenticada: Sim (pela mensagem 3) Bob autenticado: Sim (por possuir a chave privada estática) Sigilo de encaminhamento: Sim (chaves efêmeras destruídas) KCI resistance (Key Compromise Impersonation - resistência a personificação após comprometimento de chave): Sim (nível de autenticação 2) Apêndice B: Codificação Base64 Alfabeto Base64 do I2P:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-~ Diferenças em relação ao Base64 padrão: - Caracteres 62-63: -~ em vez de +/ - Preenchimento: Igual (=) ou omitido dependendo do contexto\nUso no NTCP2: - Chave estática (\u0026ldquo;s\u0026rdquo;): 32 bytes → 44 caracteres (sem preenchimento) - IV (\u0026ldquo;i\u0026rdquo;): 16 bytes → 24 caracteres (sem preenchimento)\nExemplo de codificação:\n# 32-byte static key (hex): # f4489e1bb0597b39ca6cbf5ad9f5f1f09043e02d96cb9aa6a63742b3462429aa # I2P Base64 encoded: # 9EjeG7BZeznKbL9a2fXx8JBDPgLZbLmKbqY3QrNGJCo= Apêndice C: Análise de Captura de Pacotes Identificando o tráfego NTCP2:\nHandshake TCP:\nSYN, SYN-ACK, ACK padrão do TCP Porta de destino normalmente 8887 ou similar Mensagem 1 (SessionRequest - pedido de sessão):\nPrimeiros dados da aplicação enviados por Alice 80-65535 bytes (tipicamente algumas centenas) Parece aleatório (chave efêmera criptografada com AES) 287 bytes no máximo ao conectar-se a um endereço \u0026ldquo;NTCP\u0026rdquo; Mensagem 2 (SessionCreated):\nResposta de Bob 80-65535 bytes (tipicamente algumas centenas) Também parece aleatório Mensagem 3 (SessionConfirmed — confirmação da sessão):\nDe Alice 48 bytes + variável (tamanho do RouterInfo (informações do router) + preenchimento) Normalmente 1-4 KB Fase de Dados:\nQuadros de tamanho variável Campo de comprimento ofuscado (parece aleatório) Carga útil criptografada Preenchimento torna o tamanho imprevisível Evasão de DPI (inspeção profunda de pacotes): - Sem cabeçalhos em texto claro - Sem padrões fixos - Campos de comprimento ofuscados - Preenchimento aleatório quebra heurísticas baseadas em tamanho\nComparação com NTCP: - Mensagem 1 do NTCP tem sempre 288 bytes (identificável) - Mensagem 1 do NTCP2 tem tamanho variável (não identificável) - NTCP tinha padrões reconhecíveis - NTCP2 projetado para resistir à inspeção profunda de pacotes (DPI)\nApêndice D: Histórico de versões Principais marcos:\n0.9.36 (23 de agosto de 2018): NTCP2 introduzido, desativado por padrão 0.9.37 (4 de outubro de 2018): NTCP2 ativado por padrão 0.9.40 (20 de maio de 2019): NTCP tornado obsoleto 0.9.42 (27 de agosto de 2019): campo Network ID adicionado (Proposta 147) 0.9.50 (17 de maio de 2021): NTCP removido, suporte a capacidades adicionado 2.10.0 (9 de setembro de 2025): Versão estável mais recente Estabilidade do Protocolo: - Sem alterações incompatíveis desde 0.9.50 - Melhorias contínuas na resistência a sondagens - Foco em desempenho e confiabilidade - Criptografia pós-quântica em desenvolvimento (não ativada por padrão)\nEstado atual dos transportes: - NTCP2: Transporte TCP obrigatório - SSU2: Transporte UDP obrigatório - NTCP (v1): Removido - SSU (v1): Removido\n","description":"Transporte TCP baseado no Noise (framework de protocolos criptográficos) para links router-to-router","id":"4882afdd530d8c7e8da14bb97487aecc","section":"docs","title":"Transporte NTCP2","url":"/pt/docs/specs/ntcp2/"},{"categories":null,"content":" Obsoleto: SSU (UDP seguro semi-confiável) foi substituído por SSU2 . O Java I2P removeu o SSU na versão 2.4.0 (API 0.9.61) e o i2pd o removeu na 2.44.0 (API 0.9.56). Este documento é mantido apenas para referência histórica.\nDestaques Transporte UDP que fornece entrega ponto a ponto criptografada e autenticada de mensagens I2NP. Baseava-se em uma negociação Diffie–Hellman de 2048 bits (mesmo primo que o ElGamal). Cada datagrama continha um HMAC-MD5 de 16 bytes (variante truncada não padrão) + IV (vetor de inicialização) de 16 bytes, seguido por uma carga útil criptografada com AES-256-CBC. A prevenção de repetição (replay) e o estado da sessão eram rastreados dentro da carga útil criptografada. Cabeçalho da mensagem [16-byte MAC][16-byte IV][encrypted payload] Cálculo de MAC utilizado: HMAC-MD5(ciphertext || IV || (len ^ version ^ ((netid-2)\u0026lt;\u0026lt;8))) com uma chave MAC de 32 bytes. O tamanho da carga útil (payload) era um valor de 16 bits em big-endian, acrescentado aos dados considerados no cálculo do MAC. Por padrão, a versão do protocolo era 0; o netId era 2 (rede principal).\nChaves de Sessão e MAC Derivado do segredo compartilhado de Diffie-Hellman:\nConverta o valor compartilhado em um array de bytes big-endian (prefixe 0x00 se o bit mais significativo estiver definido). Chave de sessão: primeiros 32 bytes (preencha com zeros se for mais curto). Chave MAC: bytes 33–64; se insuficiente, recorra ao hash SHA-256 do valor compartilhado. Estado Routers não anunciam mais endereços SSU. Os clientes devem migrar para os transportes SSU2 ou NTCP2. Implementações históricas podem ser encontradas em versões mais antigas:\nCódigo-fonte Java anterior à versão 2.4.0 em router/transport/udp Código-fonte do i2pd anterior à versão 2.44.0 Para o comportamento atual do transporte UDP, consulte a especificação do SSU2 .\n","description":"Transporte UDP original utilizado antes do SSU2","id":"1eefecf66e3adc6ea013d5a5e58326da","section":"docs","title":"Transporte SSU (Obsoleto)","url":"/pt/docs/legacy/ssu/"},{"categories":null,"content":" Aviso histórico: Esta página preserva a discussão legada sobre “Unidirectional Tunnels” (túneis unidirecionais) para referência. Consulte a documentação de implementação de tunnel ativa para o comportamento atual.\nVisão geral O I2P constrói tunnels unidirecionais: um tunnel transporta o tráfego de saída e outro tunnel separado transporta as respostas de entrada. Essa estrutura remonta aos primeiros projetos de rede e continua sendo um importante diferencial em relação a sistemas de circuito bidirecional como o Tor. Para terminologia e detalhes de implementação, consulte a visão geral de tunnel e a especificação de tunnel .\nRevisão Tunnels unidirecionais mantêm separados os tráfegos de requisição e de resposta, de modo que um único grupo de pares em conluio observa apenas metade de um trajeto de ida e volta. Ataques de temporização precisam cruzar dois pools de tunnels (saída e entrada) em vez de analisar um único circuito, elevando a dificuldade de correlação. Pools independentes de entrada e de saída permitem que routers ajustem latência, capacidade e características de tratamento de falhas por direção. Desvantagens incluem maior complexidade no gerenciamento de pares e a necessidade de manter múltiplos conjuntos de tunnels para uma entrega de serviço confiável. Anonimato O artigo de Hermann e Grothoff, I2P is Slow… and What to Do About It , analisa ataques de predecessor contra tunnels unidirecionais, sugerindo que adversários determinados podem, eventualmente, confirmar pares de longa duração. O feedback da comunidade observa que o estudo se baseia em suposições específicas sobre a paciência e os poderes legais do adversário e não compara a abordagem com ataques de temporização (timing attacks) que afetam projetos bidirecionais. Pesquisas contínuas e a experiência prática seguem reforçando os tunnels unidirecionais como uma escolha deliberada de anonimato, e não um descuido.\n","description":"Resumo histórico do projeto de tunnel unidirecional do I2P.","id":"37ac13877a690f9c4635959a57451755","section":"docs","title":"Tunnels Unidirecionais","url":"/pt/docs/legacy/unidirectional/"},{"categories":null,"content":" O branch principal de desenvolvimento do I2P (i2p.i2p) foi configurado para permitir que os desenvolvedores configurem facilmente duas das IDEs mais comumente usadas para desenvolvimento Java: Eclipse e NetBeans. Eclipse Os principais ramos de desenvolvimento do I2P (i2p.i2p e ramos derivados dele) contêm build.gradle para permitir que o ramo seja facilmente configurado no Eclipse. Certifique-se de ter uma versão recente do Eclipse. Qualquer versão mais recente que 2017 deve funcionar. Faça o checkout do branch I2P em algum diretório (por exemplo, $HOME/dev/i2p.i2p). Selecione \"File → Import...\" e então sob \"Gradle\" selecione \"Existing Gradle Project\". Para \"Project root directory:\" escolha o diretório onde o branch I2P foi baixado. No diálogo \"Import Options\", selecione \"Gradle Wrapper\" e pressione Continue. No diálogo \"Import Preview\" você pode revisar a estrutura do projeto. Múltiplos projetos devem aparecer sob \"i2p.i2p\". Pressione \"Finish\". Pronto! Seu workspace agora deve conter todos os projetos dentro do branch I2P, e suas dependências de build devem estar configuradas corretamente. NetBeans Os principais branches de desenvolvimento do I2P (i2p.i2p e branches derivados dele) contêm arquivos de projeto do NetBeans. ","description":"Configurar o Eclipse e o NetBeans para desenvolver o I2P com Gradle e arquivos de projeto incluídos","id":"59847e4ae7ce8d8ccadb441422ecc856","section":"docs","title":"Usando uma IDE com I2P","url":"/pt/docs/guides/ides/"},{"categories":null,"content":" Status: Esta é uma referência concisa para o utilitário v3dgsend. Ele complementa a documentação da API de Datagramas e SAM v3 .\nVisão Geral v3dgsend é um auxiliar de linha de comando para enviar datagramas I2P usando a interface SAM v3. É útil para testar a entrega de datagramas, prototipar serviços e verificar o comportamento ponta a ponta sem escrever um cliente completo.\nUsos típicos incluem:\nTeste de verificação básica de alcance de datagramas para um Destino Validação de firewall e configuração do catálogo de endereços Experimentação com datagramas brutos vs. assinados (com resposta) Uso A invocação básica varia de acordo com a plataforma e empacotamento. As opções comuns incluem:\nDestination: Destination em base64 ou nome .i2p Protocol: raw (PROTOCOL 18) ou signed (PROTOCOL 17) Payload: string inline ou entrada de arquivo Consulte a documentação da sua distribuição ou a saída --help para ver as flags exatas.\nVeja Também API de Datagram SAM v3 Biblioteca de Streaming (alternativa aos datagramas) ","description":"Utilitário CLI para enviar datagramas I2P via SAM v3","id":"3fe6f64806c4c692f530bf7fa6eb9c45","section":"docs","title":"v3dgsend","url":"/pt/docs/api/v3dgsend/"}]
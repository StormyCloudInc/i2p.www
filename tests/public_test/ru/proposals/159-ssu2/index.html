<!DOCTYPE html>
<html lang="ru" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>SSU2 | I2P - Проект невидимого интернета</title>

    <meta name="description" content="The Invisible Internet Project - A privacy-focused, anonymous network layer">
    <meta name="keywords" content="i2p, privacy, anonymity, dark net, encryption, security">

    
    <meta property="og:title" content="SSU2 | I2P - Проект невидимого интернета">
    <meta property="og:description" content="The Invisible Internet Project - A privacy-focused, anonymous network layer">
    <meta property="og:type" content="website">
    <meta property="og:url" content="/ru/proposals/159-ssu2/">

    
    <link rel="icon" type="image/svg+xml" href="../../../images/favicon.svg">
    <link rel="icon" type="image/png" href="../../../images/i2plogo.png" sizes="32x32">

    
    
    
    
    <link rel="stylesheet" href="../../../css/main.min.be6880f32f5ff44e57579da7b11513b973319944ebe38748e3ac7f3268662d18.css" integrity="sha256-vmiA8y9f9E5XV52nsRUTuXMxmUTr44dI46x/MmhmLRg=">
    


    
</head>

<body>
    
    <input type="checkbox" id="theme-toggle-checkbox" class="theme-checkbox" aria-hidden="true">

    
<div class="site-banner" id="site-banner" data-banner-id="banner-3" role="alert" aria-live="polite">
    <div class="container">
        <div class="banner-content">
            <span class="banner-message">Бета-сайт I2P теперь доступен Сообщайте о проблемах с E-Mail на stormycloud@mail.i2p</span>
            
        </div>
        
        <form method="GET" action="../../../api/banner/dismiss" style="display: inline;">
            <input type="hidden" name="id" value="banner-3">
            <button type="submit" class="banner-close" aria-label="Закрыть баннер" title="Закрыть баннер">
                <span aria-hidden="true">&times;</span>
            </button>
        </form>
        
    </div>
</div>


    <header class="site-header">
    <div class="container">
        <nav class="main-nav">
            <div class="nav-brand">
                <a href="../../../ru/" class="logo-link">
                    <img src="../../../images/i2plogo_lightmode.svg" alt="I2P Logo" class="logo logo-light">
                    <img src="../../../images/i2plogo_darkmode.svg" alt="I2P Logo" class="logo logo-dark">
                </a>
            </div>

            
            <input type="checkbox" id="mobile-menu-checkbox" class="mobile-menu-checkbox"
                aria-label="Toggle navigation menu">
            <label for="mobile-menu-checkbox" class="mobile-menu-toggle" aria-label="Toggle navigation menu">
                <span class="hamburger"></span>
            </label>

            <div class="nav-menu">
                <ul class="nav-links">
                    <li class="nav-dropdown">
                        <a href="../../../ru/about/" class="">О проекте</a>
                        <ul class="dropdown-menu">
                            <li><a href="../../../ru/about/">Обзор</a></li>
                            <li><a href="../../../ru/papers/">Научные статьи</a></li>
                            <li><a href="../../../ru/about/media/">Пресса</a></li>
                            <li><a href="../../../ru/contact/">Связаться с нами</a></li>
                        </ul>
                    </li>
                    <li><a href="../../../ru/docs/" class="">Документы</a></li>
                    <li><a href="../../../ru/downloads/" class="">Загрузки</a></li>
                    <li><a href="../../../ru/blog/" class="">Блог</a></li>
                    <li class="nav-dropdown">
                        <a href="../../../ru/get-involved/" class="">Присоединиться</a>
                        <ul class="dropdown-menu">
                            <li><a href="../../../ru/get-involved/">Обзор</a></li>
                            <li><a href="../../../ru/feedback/">Предложения по функциям</a></li>
                        </ul>
                    </li>
                </ul>

                <div class="nav-actions">
                    
                    <div class="language-selector">
                        <button class="language-toggle" aria-label="Select language" title="Language">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2" />
                                <path
                                    d="M2 12h20M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10 15.3 15.3 0 014-10z"
                                    stroke="currentColor" stroke-width="2" />
                            </svg>
                            <span class="current-lang">ru</span>
                        </button>
                        <div class="language-dropdown">
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../en/proposals/159-ssu2/"
                                class="lang-option">Английский</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../es/proposals/159-ssu2/"
                                class="lang-option">Испанский</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../ko/proposals/159-ssu2/"
                                class="lang-option">Корейский</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../zh/proposals/159-ssu2/"
                                class="lang-option">Китайский</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../ru/proposals/159-ssu2/"
                                class="lang-option active">Русский</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../cs/proposals/159-ssu2/"
                                class="lang-option">Чешский</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../de/proposals/159-ssu2/"
                                class="lang-option">Немецкий</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../fr/proposals/159-ssu2/"
                                class="lang-option">Французский</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../tr/proposals/159-ssu2/"
                                class="lang-option">Турецкий</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../vi/proposals/159-ssu2/"
                                class="lang-option">Вьетнамский</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../hi/proposals/159-ssu2/"
                                class="lang-option">Хинди</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../ar/proposals/159-ssu2/"
                                class="lang-option">Арабский</a>
                            
                            
                            
                            
                            
                            
                            
                            
                            <a href="../../../pt/proposals/159-ssu2/"
                                class="lang-option">Португальский</a>
                            
                            
                        </div>
                    </div>

                    
                    <label for="theme-toggle-checkbox" class="theme-toggle" aria-label="Toggle dark mode"
                        title="Toggle theme">
                        <svg class="sun-icon" width="20" height="20" viewBox="0 0 20 20" fill="none"
                            xmlns="http://www.w3.org/2000/svg">
                            <circle cx="10" cy="10" r="4" stroke="currentColor" stroke-width="2" />
                            <path
                                d="M10 2V4M10 16V18M18 10H16M4 10H2M15.657 4.343L14.243 5.757M5.757 14.243L4.343 15.657M15.657 15.657L14.243 14.243M5.757 5.757L4.343 4.343"
                                stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                        </svg>
                        <svg class="moon-icon" width="20" height="20" viewBox="0 0 20 20" fill="none"
                            xmlns="http://www.w3.org/2000/svg">
                            <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"
                                stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
                        </svg>
                    </label>

                    
                    <a href="../../../ru/financial-support/" class="btn btn-primary" id="donate-btn">Donate</a>

                    
                    <a href="../../../ru/downloads/" class="btn btn-primary">Загрузить I2P</a>
                </div>
            </div>
        </nav>
    </div>
</header>

    <main id="main-content">
        



<div class="proposals-page">
    <div class="container">
        
        <nav class="breadcrumbs">
            <a href="../../../ru/">Home</a>
            <span class="separator">/</span>
            <a href="../../../ru/proposals/">Proposals</a>
            <span class="separator">/</span>
            <span class="current">SSU2</span>
        </nav>

        
<div class="translation-disclaimer" role="note">
    <span class="disclaimer-message">Этот перевод был создан с помощью машинного обучения и может быть не на 100% точным.</span>
    
    
    <a href="../../../en/proposals/159-ssu2/" class="disclaimer-link">Просмотреть английскую версию</a>
    
</div>



        
        <header class="proposal-header">
            <div class="proposal-title-section">
                <h1 class="proposal-title">SSU2</h1>
                <div class="proposal-number">Proposal 159</div>
            </div>

            
            <div class="proposal-meta-box">
                <div class="proposal-status status-закрыто">
                    Закрыто
                </div>

                
                <div class="proposal-info-grid">
                    
                    <div class="info-item">
                        <span class="info-label">Author</span>
                        <span class="info-value">eyedeekay, orignal, zlatinb, zzz</span>
                    </div>
                    

                    
                    <div class="info-item">
                        <span class="info-label">Created</span>
                        <span class="info-value">2021-09-12</span>
                    </div>
                    

                    
                    <div class="info-item">
                        <span class="info-label">Last Updated</span>
                        <span class="info-value">2025-03-05</span>
                    </div>
                    

                    
                    <div class="info-item">
                        <span class="info-label">Target Version</span>
                        <span class="info-value">0.9.56</span>
                    </div>
                    

                    
                </div>

                
                
            </div>
        </header>

        
        <div class="proposal-layout proposal-layout--with-toc">
            
            
            <aside class="proposal-toc-sidebar">
                <nav class="toc-nav">
                    <div class="toc-header">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                            <path d="M4 6h16M4 12h16M4 18h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        On This Page
                    </div>
                    <div class="toc-content">
                        <nav id="TableOfContents">
  <ul>
    <li><a href="#статус">Статус</a></li>
    <li><a href="#обзор">Обзор</a></li>
    <li><a href="#мотивация">Мотивация</a></li>
    <li><a href="#цели-проектирования">Цели проектирования</a>
      <ul>
        <li><a href="#non-goals">Non-Goals</a></li>
      </ul>
    </li>
    <li><a href="#security-goals">Security Goals</a>
      <ul>
        <li><a href="#additional-dpi-discussion">Additional DPI Discussion</a></li>
        <li><a href="#address-validation">Address Validation</a></li>
        <li><a href="#connection-migration">Connection Migration</a></li>
        <li><a href="#не-цели">Не-цели</a></li>
        <li><a href="#relay-security">Relay Security</a></li>
        <li><a href="#дополнительное-обсуждение-dpi">Дополнительное обсуждение DPI</a></li>
        <li><a href="#relay-and-peer-test-design-goals">Relay and Peer Test Design Goals</a></li>
      </ul>
    </li>
    <li><a href="#цели-безопасности">Цели безопасности</a>
      <ul>
        <li><a href="#summary">Summary</a></li>
        <li><a href="#валидация-адресов">Валидация адресов</a></li>
        <li><a href="#noise-protocol-framework">Noise Protocol Framework</a></li>
        <li><a href="#additions-to-the-framework">Additions to the Framework</a></li>
        <li><a href="#processing-overhead-estimate">Processing overhead estimate</a></li>
      </ul>
    </li>
    <li><a href="#definitions">Definitions</a></li>
    <li><a href="#messages">Messages</a>
      <ul>
        <li><a href="#session-establishment">Session Establishment</a></li>
        <li><a href="#packet-header">Packet Header</a></li>
        <li><a href="#packet-integrity">Packet Integrity</a></li>
        <li><a href="#authenticated-encryption">Authenticated Encryption</a></li>
        <li><a href="#kdf-for-session-request">KDF for Session Request</a></li>
        <li><a href="#sessionrequest-type-0">SessionRequest (Type 0)</a></li>
        <li><a href="#kdf-for-session-created-and-session-confirmed-part-1">KDF for Session Created and Session Confirmed part 1</a></li>
        <li><a href="#миграция-соединений-1">Миграция соединений</a></li>
        <li><a href="#kdf-for-session-confirmed-part-1-using-session-created-kdf">KDF for Session Confirmed part 1, using Session Created KDF</a></li>
        <li><a href="#kdf-for-session-confirmed-part-2">KDF for Session Confirmed part 2</a></li>
        <li><a href="#sessionconfirmed-type-2">SessionConfirmed (Type 2)</a></li>
        <li><a href="#kdf-for-data-phase">KDF for data phase</a></li>
        <li><a href="#data-message-type-6">Data Message (Type 6)</a></li>
        <li><a href="#kdf-for-peer-test">KDF for Peer Test</a></li>
        <li><a href="#peer-test-type-7">Peer Test (Type 7)</a></li>
        <li><a href="#kdf-for-retry">KDF for Retry</a></li>
        <li><a href="#retry-type-9">Retry (Type 9)</a></li>
        <li><a href="#kdf-for-token-request">KDF for Token Request</a></li>
        <li><a href="#token-request-type-10">Token Request (Type 10)</a></li>
        <li><a href="#kdf-for-hole-punch">KDF for Hole Punch</a></li>
        <li><a href="#hole-punch-type-11">Hole Punch (Type 11)</a></li>
      </ul>
    </li>
    <li><a href="#noise-payload">Noise Payload</a>
      <ul>
        <li><a href="#соображения-безопасности">Соображения безопасности</a></li>
        <li><a href="#block-ordering-rules">Block Ordering Rules</a></li>
        <li><a href="#block-specifications">Block Specifications</a></li>
      </ul>
    </li>
    <li><a href="#replay-prevention">Replay Prevention</a></li>
    <li><a href="#handshake-retransmission">Handshake Retransmission</a>
      <ul>
        <li><a href="#session-request">Session Request</a></li>
        <li><a href="#session-created">Session Created</a></li>
        <li><a href="#session-confirmed">Session Confirmed</a></li>
        <li><a href="#token-request">Token Request</a></li>
        <li><a href="#retry">Retry</a></li>
        <li><a href="#total-timeout">Total Timeout</a></li>
        <li><a href="#duplicates-and-error-handling">Duplicates and Error Handling</a></li>
      </ul>
    </li>
    <li><a href="#tokens">Tokens</a></li>
    <li><a href="#i2np-message-fragmentation">I2NP Message Fragmentation</a></li>
    <li><a href="#i2np-message-duplication">I2NP Message Duplication</a></li>
    <li><a href="#congestion-control">Congestion Control</a>
      <ul>
        <li><a href="#packet-numbers">Packet Numbers</a></li>
        <li><a href="#session-confirmed-ack">Session Confirmed ACK</a></li>
        <li><a href="#generating-acks">Generating ACKs</a></li>
        <li><a href="#handshake-acks">Handshake ACKs</a></li>
        <li><a href="#sending-ack-blocks">Sending ACK Blocks</a></li>
        <li><a href="#ack-frequency">ACK Frequency</a></li>
        <li><a href="#immediate-ack-flag">Immediate ACK Flag</a></li>
        <li><a href="#ack-block-size">ACK Block Size</a></li>
        <li><a href="#limiting-ranges-by-tracking-ack-blocks">Limiting Ranges by Tracking ACK Blocks</a></li>
        <li><a href="#congestion-1">Congestion</a></li>
        <li><a href="#retransmission">Retransmission</a></li>
        <li><a href="#window">Window</a></li>
      </ul>
    </li>
    <li><a href="#connection-migration-1">Connection Migration</a>
      <ul>
        <li><a href="#threat-model">Threat Model</a></li>
        <li><a href="#initiating-path-validation">Initiating Path Validation</a></li>
        <li><a href="#message-contents">Message Contents</a></li>
        <li><a href="#routing-during-path-validation">Routing during Path Validation</a></li>
        <li><a href="#responding-to-path-challenge">Responding to Path Challenge</a></li>
        <li><a href="#successful-path-validation">Successful Path Validation</a></li>
        <li><a href="#cancelling-path-validation">Cancelling Path Validation</a></li>
        <li><a href="#failed-path-validation">Failed Path Validation</a></li>
        <li><a href="#validation-after-local-change">Validation After Local Change</a></li>
        <li><a href="#безопасность-релея">Безопасность релея</a></li>
      </ul>
    </li>
    <li><a href="#multiple-sessions">Multiple Sessions</a></li>
    <li><a href="#session-termination">Session Termination</a>
      <ul>
        <li><a href="#безопасность-тестирования-пиров">Безопасность тестирования пиров</a></li>
        <li><a href="#цели-проектирования-relay-и-peer-test">Цели проектирования Relay и Peer Test</a></li>
        <li><a href="#cleanup">Cleanup</a></li>
      </ul>
    </li>
    <li><a href="#mtu">MTU</a>
      <ul>
        <li><a href="#резюме">Резюме</a></li>
        <li><a href="#гарантии-доставки">Гарантии доставки</a></li>
        <li><a href="#фреймворк-протокола-noise">Фреймворк протокола Noise</a></li>
        <li><a href="#дополнения-к-framework">Дополнения к Framework</a></li>
        <li><a href="#оценка-накладных-расходов-на-обработку">Оценка накладных расходов на обработку</a></li>
        <li><a href="#max-i2np-message-size">Max I2NP Message Size</a></li>
      </ul>
    </li>
    <li><a href="#peer-test-process">Peer Test Process</a>
      <ul>
        <li><a href="#versions">Versions</a></li>
        <li><a href="#установка-сессии">Установка сессии</a></li>
        <li><a href="#заголовок-пакета">Заголовок пакета</a></li>
        <li><a href="#processing-by-bob">Processing by Bob</a></li>
      </ul>
    </li>
    <li><a href="#relay-process">Relay Process</a>
      <ul>
        <li><a href="#retransmissions">Retransmissions</a></li>
        <li><a href="#ipv4v6">IPv4/v6</a></li>
        <li><a href="#processing-by-alice">Processing by Alice</a></li>
        <li><a href="#tag-requests-by-bob">Tag Requests by Bob</a></li>
      </ul>
    </li>
    <li><a href="#published-router-info">Published Router Info</a>
      <ul>
        <li><a href="#address-properties">Address Properties</a></li>
        <li><a href="#published-addresses">Published Addresses</a></li>
        <li><a href="#unpublished-ssu2-address">Unpublished SSU2 Address</a></li>
        <li><a href="#целостность-пакетов">Целостность пакетов</a></li>
      </ul>
    </li>
    <li><a href="#packet-guidelines">Packet Guidelines</a>
      <ul>
        <li><a href="#аутентифицированное-шифрование">Аутентифицированное шифрование</a></li>
        <li><a href="#inbound-packet-handling">Inbound Packet Handling</a></li>
        <li><a href="#notes-5">Notes</a></li>
        <li><a href="#version-detection">Version Detection</a></li>
      </ul>
    </li>
    <li><a href="#recommended-constants">Recommended Constants</a></li>
    <li><a href="#variants-fallbacks-and-general-issues">Variants, Fallbacks, and General Issues</a></li>
    <li><a href="#packet-overhead-analysis">Packet Overhead Analysis</a></li>
  </ul>
</nav>
                    </div>
                </nav>
            </aside>
            

            
            <div class="proposal-main">
                <article class="proposal-content">
                    <h2 id="статус">Статус</h2>
<p>План развертывания:</p>
<table>
  <thead>
      <tr>
          <th>Feature</th>
          <th>Testing (not default)</th>
          <th>Enabled by default</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Local test code</td>
          <td>2022-02</td>
          <td></td>
      </tr>
      <tr>
          <td>Joint test code</td>
          <td>2022-03</td>
          <td></td>
      </tr>
      <tr>
          <td>Joint test in-net</td>
          <td>0.9.54  2022-05</td>
          <td></td>
      </tr>
      <tr>
          <td>Freeze basic protocol</td>
          <td>0.9.54  2022-05</td>
          <td></td>
      </tr>
      <tr>
          <td>Basic Session</td>
          <td>0.9.55  2022-08</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Address Validation (Retry)</td>
          <td>0.9.55  2022-08</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Fragmented RI in handshake</td>
          <td>0.9.55  2022-08</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>New Token</td>
          <td>0.9.55  2022-08</td>
          <td>0.9.57  2022-11</td>
      </tr>
      <tr>
          <td>Freeze extended protocol</td>
          <td>0.9.55  2022-08</td>
          <td></td>
      </tr>
      <tr>
          <td>Relay</td>
          <td>0.9.55  2022-08</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Peer Test</td>
          <td>0.9.55  2022-08</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Enable for random 2%</td>
          <td>0.9.55  2022-08</td>
          <td></td>
      </tr>
      <tr>
          <td>Path Validation</td>
          <td>0.9.55+ dev</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Connection Migration</td>
          <td>0.9.55+ dev</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Immediate ACK flag</td>
          <td>0.9.55+ dev</td>
          <td>0.9.56  2022-11</td>
      </tr>
      <tr>
          <td>Key Rotation</td>
          <td>0.9.57  2023-02</td>
          <td>0.9.58  2023-05</td>
      </tr>
      <tr>
          <td>Disable SSU 1 (i2pd)</td>
          <td>0.9.56  2022-11</td>
          <td></td>
      </tr>
      <tr>
          <td>Disable SSU 1 (Java I2P)</td>
          <td>0.9.58  2023-05</td>
          <td>0.9.61  2023-12</td>
      </tr>
      <tr>
          <td>Базовая сессия включает фазу рукопожатия и фазу данных. Расширенный протокол включает relay и peer test.</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<h2 id="обзор">Обзор</h2>
<p>Данное предложение описывает протокол аутентифицированного согласования ключей для повышения устойчивости <a href="../../../ru/docs/specs/ssu2/">SSU</a>
 к различным формам автоматической идентификации и атак.</p>
<p>Предложение организовано следующим образом: представлены цели безопасности, затем следует обсуждение основного протокола. Далее дается полная спецификация всех сообщений протокола. В заключение рассматриваются адреса router и идентификация версий.</p>
<p>Как и другие транспорты I2P, SSU2 предназначен для передачи I2NP сообщений между точками (роутер-к-роутеру). Это не универсальный канал передачи данных. Как и <a href="../../../ru/docs/specs/ssu2/">SSU</a>
, он также предоставляет два дополнительных сервиса: Relaying для преодоления NAT и Peer Testing для определения доступности входящих соединений. Он также предоставляет третий сервис, которого нет в SSU, для миграции соединений когда узел меняет IP или порт.</p>
<h2 id="мотивация">Мотивация</h2>
<p>SSU является единственным оставшимся протокольным слоем, который требует ElGamal, что очень медленно. Управление потоком для SSU сложное и работает плохо. Части SSU уязвимы для атак подмены адресов. Рукопожатие не использует Noise.</p>
<h2 id="цели-проектирования">Цели проектирования</h2>
<ul>
<li>
<p>Снизить использование CPU, исключив ElGamal. Использовать X25519 для DH.</p>
</li>
<li>
<p>Поддерживать функции Peer Test и Relay, а также повысить их безопасность.</p>
</li>
<li>
<p>Упростить реализацию, позволив использовать стандартные алгоритмы управления потоком.</p>
</li>
<li>
<p>Уменьшить задержку установки соединения.
Медианное время установки соединения в настоящее время составляет около 135 мс для NTCP2 и 187 мс для SSU,
хотя NTCP2 требует дополнительный цикл обмена; замена ElGamal в
SSU2 должна это сократить, но другие изменения также могут помочь.</p>
</li>
<li>
<p>Поддерживать или увеличивать максимальную пропускную способность по сравнению с SSU 1,
измеряемую в диапазоне смоделированных задержек и процентов потери пакетов в тестовой сети.</p>
</li>
<li>
<p>Предотвращать атаки усиления трафика и неправильной маршрутизации с поддельных адресов-источников через &ldquo;валидацию адресов&rdquo;.</p>
</li>
<li>
<p>Упростить идентификацию пакетов, чтобы уменьшить зависимость от резервных механизмов и эвристик, которые делают код излишне сложным.</p>
</li>
<li>
<p>Формализовать и улучшить миграцию соединений при изменении IP-адреса или порта пира.
Не выполнять миграцию соединений до завершения валидации адреса во избежание атак.
Некоторые реализации SSU 1 используют ресурсозатратные эвристики для обработки изменений портов
из-за NAT rebinding. Ни одна из известных реализаций SSU 1 не может обрабатывать изменения IP-адресов вообще.</p>
</li>
<li>
<p>Поддержка SSU 1 и 2 на одном порту, автоопределение, и публикация как единый
&ldquo;transport&rdquo; (т.е. RouterAddress) в <a href="../../../ru/docs/overview/network-database/">NetDB</a>
.</p>
</li>
<li>
<p>Публиковать поддержку только версии 1, только версии 2, или 1+2 в NetDB в отдельном поле, и по умолчанию использовать только версию 1 (не привязывать поддержку версий к конкретной версии роутера)</p>
</li>
<li>
<p>Убедиться, что все реализации (Java/i2pd/Go) могут добавить поддержку версии 2 (или не добавлять) по своему собственному графику</p>
</li>
<li>
<p>Добавлять случайное заполнение ко всем сообщениям, включая сообщения рукопожатия и данных.
Все заполнение должно покрываться MAC, в отличие от заполнения в конце пакета в SSU 1.
Предоставить механизм опций для обеих сторон для запроса минимального и максимального заполнения
и/или распределения заполнения. Особенности распределения заполнения зависят от
реализации и могут быть или не быть указаны в самом протоколе.</p>
</li>
<li>
<p>Обфускация заголовков и содержимого сообщений, которые не полностью зашифрованы,
в достаточной степени, чтобы DPI-устройства и антивирусные сигнатуры не могли их легко классифицировать.
Также обеспечение того, чтобы сообщения, направляемые одному peer&rsquo;у или набору peer&rsquo;ов, не
имели схожих битовых паттернов.</p>
</li>
<li>
<p>Исправить потерю битов в DH из-за формата Java <a href="https://trac.i2p2.i2p/ticket/1112">Ticket1112</a>
, и ускорить DH
переключением на X25519.</p>
</li>
<li>
<p>Переключиться на настоящую функцию вывода ключей (KDF) вместо использования результата DH как есть</p>
</li>
<li>
<p>Добавить &ldquo;устойчивость к зондированию&rdquo; (как это называется в Tor); это включает устойчивость к replay-атакам.</p>
</li>
<li>
<p>Поддерживать двустороннюю аутентификацию обмена ключами (2W-AKE). 1W-AKE недостаточно
для нашего приложения.</p>
</li>
<li>
<p>Полагаться на статический публичный ключ, опубликованный в RouterInfo, как на другую часть аутентификации.</p>
</li>
<li>
<p>Добавить options/version в handshake для будущей расширяемости.</p>
</li>
<li>
<p>Не должен существенно увеличивать нагрузку на CPU, требуемую для установки соединения; по возможности,
должен значительно её снижать.</p>
</li>
<li>
<p>Убрать требование дополнения до кратного 16 байтам
наложенное AES шифрованием в SSU 1.</p>
</li>
<li>
<p>Использовать стандартный ChaCha/Poly1305 для шифрования и MAC,
заменив шифрование AES и нестандартный HMAC-MD5-128 MAC, используемый в SSU 1.</p>
</li>
<li>
<p>Используйте отдельные ключи шифрования для отправки и получения вместо
общих ключей для обоих направлений, используемых в SSU 1.</p>
</li>
<li>
<p>Использовать 3-сообщенное рукопожатие в одну поездку, как в <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
.
Устранить задержку ожидания сообщений данных, которая делает
<a href="../../../ru/docs/specs/ssu2/">SSU</a>
 фактически рукопожатием в две поездки.</p>
</li>
<li>
<p>Кардинально улучшить эффективность ACK и NACK,
которая ужасна в SSU 1. Снизить требуемую пропускную способность
для ACK и NACK, и увеличить размер пакета, доступный для данных.
Эффективно кодировать NACK для пакетной передачи пропущенных сообщений,
что часто происходит через WiFi.</p>
</li>
<li>
<p>Уменьшить сложность, требуемую для реализации фрагментации I2NP сообщений.
Обойти механизмы фрагментации и кодирования для полных I2NP сообщений.</p>
</li>
<li>
<p>Минимизируйте служебные данные протокола до padding, особенно для ACK.
Хотя padding будет добавлен,
служебные данные до padding всё равно остаются служебными данными.
Узлы с низкой пропускной способностью должны иметь возможность использовать SSU2.</p>
</li>
<li>
<p>Поддерживать временные метки для обнаружения повторов и отклонений.</p>
</li>
<li>
<p>Избегать любых проблем 2038 года в временных метках, должно работать как минимум до 2106 года.</p>
</li>
<li>
<p>Увеличить минимальный MTU с 620 до 1280 для повышения эффективности, простоты реализации
и увеличения максимального размера I2NP сообщений.
Фрагментация и реассемблирование довольно затратны.
Предоставляя место для tunnel сообщений размером 1028 байт, большинство I2NP
сообщений не потребует фрагментации.</p>
</li>
<li>
<p>Увеличить максимальный MTU с 1488 (1484 для IPv6) до 1500 для повышения эффективности.
Убрать требование, чтобы MTU был кратен 16.</p>
</li>
<li>
<p>Увеличить максимальный размер I2NP сообщения с приблизительно 32K в SSU 1
до приблизительно 64 КБ как в NTCP2.</p>
</li>
<li>
<p>Удалить подпись полей IP и порта из handshake,
чтобы router&rsquo;ы, которые не знают
свой внешний IP и порт, могли подключаться.</p>
</li>
<li>
<p>Сохранить механизм обнаружения IP/порта из SSU 1 в рукопожатии,
чтобы роутеры могли узнать свой внешний IP и порт.</p>
</li>
<li>
<p>Включить представителей разработчиков router на Java, C++ и Go в процесс проектирования.</p>
</li>
</ul>
<h3 id="non-goals">Non-Goals</h3>
<ul>
<li>
<p>Защита от DPI, устойчивая к любым попыткам обнаружения&hellip; это будут подключаемые транспорты,
<a href="../../../ru/proposals/109-pt-transport/">Предложение 109</a>
.</p>
</li>
<li>
<p>TLS-основанный (или похожий на HTTPS) транспорт&hellip; это будет <a href="../../../ru/proposals/104-tls-transport/">Proposal 104</a>
.</p>
</li>
<li>
<p>Сопротивление DPI на основе временных характеристик (время между сообщениями/задержки могут зависеть от реализации; задержки внутри сообщения могут быть введены в любой точке, включая, например, перед отправкой случайного заполнения). Искусственные задержки (то, что obfs4 называет IAT или межпакетным интервалом) не зависят от самого протокола.</p>
</li>
<li>
<p>Отрицаемость участия в сессии (там есть подписи).</p>
</li>
</ul>
<p>Не-цели, которые могут быть частично пересмотрены или обсуждены:</p>
<ul>
<li>
<p>Степень защиты от глубокой проверки пакетов (Deep Packet Inspection, DPI)</p>
</li>
<li>
<p>Постквантовая (PQ) безопасность</p>
</li>
<li>
<p>Отрицаемость</p>
</li>
</ul>
<h2 id="security-goals">Security Goals</h2>
<p>Мы рассматриваем три стороны:</p>
<ul>
<li>Алиса, которая хочет установить новую сессию.</li>
<li>Боб, с которым Алиса хочет установить сессию.</li>
<li>Мэллори, &ldquo;человек посередине&rdquo; между Алисой и Бобом.</li>
</ul>
<p>Не более двух участников могут участвовать в активных атаках.</p>
<p>Алиса и Боб оба обладают статической парой ключей, которая содержится в их RouterIdentity.</p>
<p>Предлагаемый протокол пытается позволить Алисе и Бобу договориться о совместном секретном ключе (K) при следующих требованиях:</p>
<ol>
<li>
<p>Безопасность закрытого ключа: ни Боб, ни Мэллори не узнают ничего о статическом закрытом ключе Алисы. Симметрично, Алиса не узнает ничего о статическом закрытом ключе Боба.</p>
</li>
<li>
<p>Ключ сессии K известен только Алисе и Бобу.</p>
</li>
<li>
<p>Совершенная прямая секретность: согласованный сессионный ключ остается секретным в будущем, даже когда статические приватные ключи Алисы и/или Боба раскрываются после того, как ключ был согласован.</p>
</li>
<li>
<p>Двусторонняя аутентификация: Алиса уверена, что она установила сессию с Бобом, и наоборот.</p>
</li>
<li>
<p>Защита от онлайн DPI: Обеспечить, чтобы не было тривиально обнаружить, что Алиса и Боб участвуют в протоколе, используя только простые методы глубокой проверки пакетов (DPI). См. ниже.</p>
</li>
<li>
<p>Ограниченная возможность отрицания: ни Алиса, ни Боб не могут отрицать участие в протоколе, но если одна из сторон раскроет общий ключ, другая сторона может отрицать подлинность содержимого передаваемых данных.</p>
</li>
</ol>
<p>Данное предложение пытается обеспечить все пять требований на основе протокола Station-To-Station (STS). Обратите внимание, что этот протокол также является основой для протокола <a href="../../../ru/docs/specs/ssu2/">SSU</a>
.</p>
<h3 id="additional-dpi-discussion">Additional DPI Discussion</h3>
<p>Мы предполагаем два компонента DPI:</p>
<h4 id="online-dpi">Online DPI</h4>
<p>Онлайн DPI инспектирует все потоки в режиме реального времени. Соединения могут быть заблокированы или иным образом нарушены. Данные соединений или метаданные могут быть идентифицированы и сохранены для офлайн анализа. Онлайн DPI не имеет доступа к сетевой базе данных I2P. Онлайн DPI обладает лишь ограниченными вычислительными возможностями в реальном времени, включая вычисление длины, инспекцию полей и простые вычисления, такие как XOR. Онлайн DPI действительно обладает возможностями быстрых криптографических функций в реальном времени, таких как ChaCha20, AEAD и хеширование, но их применение к большинству или всем потокам было бы слишком дорогостоящим. Любое применение этих криптографических операций распространялось бы только на потоки по комбинациям IP/Port, предварительно идентифицированным офлайн анализом. Онлайн DPI не обладает возможностями высокозатратных криптографических функций, таких как DH или elligator2. Онлайн DPI не предназначен специально для обнаружения I2P, хотя может иметь ограниченные правила классификации для этой цели.</p>
<p>Цель состоит в том, чтобы предотвратить идентификацию протокола с помощью онлайн DPI.</p>
<p>Понятие онлайн или &ldquo;прямого&rdquo; DPI здесь включает в себя следующие возможности противника:</p>
<ol>
<li>
<p>Возможность проверять все данные, отправляемые или получаемые целью.</p>
</li>
<li>
<p>Способность выполнять операции над наблюдаемыми данными, такие как применение блочных шифров или хеш-функций.</p>
</li>
<li>
<p>Возможность сохранения и сравнения с ранее отправленными сообщениями.</p>
</li>
<li>
<p>Возможность модифицировать, задерживать или фрагментировать пакеты.</p>
</li>
</ol>
<p>Однако предполагается, что онлайн DPI имеет следующие ограничения:</p>
<ol start="5">
<li>
<p>Невозможность сопоставления IP-адресов с хешами router. Хотя это тривиально при наличии доступа к базе данных сети в реальном времени, это потребовало бы системы DPI, специально разработанной для таргетинга I2P.</p>
</li>
<li>
<p>Невозможность использования информации о времени для обнаружения протокола.</p>
</li>
<li>
<p>Вообще говоря, онлайн-набор инструментов DPI не содержит каких-либо встроенных инструментов, которые специально разработаны для обнаружения I2P. Это включает создание &ldquo;honeypot&rdquo;, которые, например, включали бы неслучайное заполнение в своих сообщениях. Обратите внимание, что это не исключает системы машинного обучения или высококонфигурируемые инструменты DPI, пока они соответствуют другим требованиям.</p>
</li>
</ol>
<p>Для противодействия анализу полезной нагрузки обеспечивается, чтобы все сообщения были неотличимы от случайных данных. Это также требует, чтобы их длина была случайной, что сложнее, чем просто добавление случайного заполнения. Фактически, в Приложении A авторы утверждают, что наивная (т.е. равномерная) схема заполнения не решает проблему. Поэтому Приложение A предлагает включить либо случайные задержки, либо разработать альтернативную схему заполнения, которая может обеспечить разумную защиту от предлагаемой атаки.</p>
<p>Для защиты от шестого пункта выше, реализации должны включать случайные задержки в протокол. Такие методы не рассматриваются в данном предложении, но они также могут решить проблемы с длиной padding. В заключение, предложение обеспечивает хорошую защиту от анализа полезной нагрузки (при учете соображений из Приложения A), но лишь ограниченную защиту от анализа трафика.</p>
<h4 id="offline-dpi">Offline DPI</h4>
<p>Офлайн DPI, анализирующий данные, сохраненные онлайн DPI для последующего анализа. Офлайн DPI может быть специально разработан для обнаружения I2P. Офлайн DPI не имеет доступа к базе данных сети I2P в реальном времени. Офлайн DPI имеет доступ к этой и другим спецификациям I2P. Офлайн DPI обладает неограниченными вычислительными возможностями, включая все криптографические функции, определенные в данной спецификации.</p>
<p>Офлайновая DPI не имеет возможности блокировать существующие соединения. Офлайновая DPI имеет возможность отправлять в режиме близком к реальному времени (в течение минут после настройки) на хост/порт сторон путем внедрения пакетов. Офлайновая DPI имеет возможность в режиме близком к реальному времени (в течение минут после настройки) воспроизводить предыдущие сообщения (модифицированные или нет) для &ldquo;зондирования&rdquo; или других целей.</p>
<p>Это не является целью предотвратить идентификацию протокола с помощью автономного DPI. Все декодирование обфусцированных данных в первых двух сообщениях, которое реализовано I2P router&rsquo;ами, также может быть реализовано автономным DPI.</p>
<p>Целью является отклонение попыток подключения с использованием повтора предыдущих сообщений.</p>
<h3 id="address-validation">Address Validation</h3>
<p>Далее скопировано из QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
. Для каждого раздела проведите анализ и редактирование.</p>
<p>Валидация адреса гарантирует, что конечная точка не может быть использована для атаки усиления трафика. В такой атаке пакет отправляется на сервер с поддельной информацией об адресе источника, которая идентифицирует жертву. Если сервер генерирует больше или более крупные пакеты в ответ на этот пакет, атакующий может использовать сервер для отправки большего объема данных в сторону жертвы, чем он смог бы отправить самостоятельно.</p>
<p>Основная защита от атак усиления заключается в проверке того, что узел способен получать пакеты по транспортному адресу, который он заявляет. Поэтому после получения пакетов с адреса, который еще не подтвержден, конечная точка ДОЛЖНА ограничить объем данных, отправляемых на неподтвержденный адрес, тремя размерами объема данных, полученных с этого адреса. Это ограничение на размер ответов известно как лимит защиты от усиления.</p>
<p>Валидация адресов выполняется как во время установления соединения (см. раздел 8.1), так и во время миграции соединения (см. раздел 8.2).</p>
<h4 id="address-validation-during-connection-establishment">Address Validation during Connection Establishment</h4>
<p>Установление соединения неявно обеспечивает валидацию адреса для обеих конечных точек. В частности, получение пакета, защищенного ключами Handshake, подтверждает, что узел успешно обработал пакет Initial. Как только конечная точка успешно обработала пакет Handshake от узла, она может считать адрес узла валидированным.</p>
<p>Кроме того, конечная точка МОЖЕТ считать адрес пира проверенным, если пир использует connection ID, выбранный конечной точкой, и connection ID содержит не менее 64 битов энтропии.</p>
<p>Для клиента значение поля Destination Connection ID в его первом Initial пакете позволяет ему проверить адрес сервера как часть успешной обработки любого пакета. Initial пакеты от сервера защищены ключами, которые получены из этого значения (см. Section 5.2 в <a href="https://datatracker.ietf.org/doc/html/rfc9001">QUIC-TLS</a>
). Альтернативно, это значение возвращается сервером в пакетах Version Negotiation (Section 6) или включается в Integrity Tag в пакетах Retry (Section 5.8 в <a href="https://datatracker.ietf.org/doc/html/rfc9001">QUIC-TLS</a>
).</p>
<p>До валидации адреса клиента серверы НЕ ДОЛЖНЫ отправлять более чем в три раза больше байт, чем количество байт, которое они получили. Это ограничивает масштаб любой атаки усиления, которая может быть осуществлена с использованием поддельных адресов источника. В целях предотвращения усиления до валидации адреса серверы ДОЛЖНЫ учитывать все байты полезной нагрузки, полученные в датаграммах, которые однозначно относятся к одному соединению. Это включает датаграммы, содержащие пакеты, которые успешно обработаны, и датаграммы, содержащие пакеты, которые все отброшены.</p>
<p>Клиенты ДОЛЖНЫ обеспечить, чтобы UDP дейтаграммы, содержащие Initial пакеты, имели UDP полезную нагрузку не менее 1200 байт, добавляя PADDING фреймы по мере необходимости. Клиент, который отправляет дополненные дейтаграммы, позволяет серверу отправлять больше данных до завершения проверки адреса.</p>
<p>Потеря пакета Initial или Handshake от сервера может вызвать взаимоблокировку, если клиент не отправляет дополнительные пакеты Initial или Handshake. Взаимоблокировка может возникнуть, когда сервер достигает своего лимита защиты от усиления атак, а клиент получил подтверждения для всех отправленных им данных. В этом случае, когда у клиента нет причин отправлять дополнительные пакеты, сервер не сможет отправить больше данных, поскольку он не проверил адрес клиента. Для предотвращения этой взаимоблокировки клиенты ДОЛЖНЫ отправить пакет по истечении Probe Timeout (PTO); см. раздел 6.2 <a href="https://datatracker.ietf.org/doc/html/rfc9002">QUIC-RECOVERY</a>
. В частности, клиент ДОЛЖЕН отправить пакет Initial в UDP датаграмме, содержащей не менее 1200 байт, если у него нет ключей Handshake, и в противном случае отправить пакет Handshake.</p>
<p>Сервер может захотеть проверить адрес клиента перед началом криптографического рукопожатия. QUIC использует токен в пакете Initial для обеспечения проверки адреса до завершения рукопожатия. Этот токен доставляется клиенту во время установления соединения с помощью пакета Retry (см. Раздел 8.1.2) или в предыдущем соединении с использованием фрейма NEW_TOKEN (см. Раздел 8.1.3).</p>
<p>Помимо ограничений на отправку, налагаемых до проверки адреса, серверы также ограничены в том, что они могут отправлять, лимитами, установленными контроллером перегрузки. Клиенты ограничены только контроллером перегрузки.</p>
<h4 id="token-construction">Token Construction</h4>
<p>Токен, отправленный в кадре NEW_TOKEN или пакете Retry, ДОЛЖЕН быть сконструирован таким образом, чтобы сервер мог определить, как он был предоставлен клиенту. Эти токены передаются в одном и том же поле, но требуют разной обработки со стороны серверов.</p>
<h4 id="address-validation-using-retry-packets">Address Validation Using Retry Packets</h4>
<p>После получения пакета Initial от клиента, сервер может запросить валидацию адреса, отправив пакет Retry (Раздел 17.2.5), содержащий токен. Этот токен ДОЛЖЕН повторяться клиентом во всех пакетах Initial, которые он отправляет для данного соединения после получения пакета Retry.</p>
<p>В ответ на обработку Initial пакета, содержащего токен, который был предоставлен в Retry пакете, сервер не может отправить другой Retry пакет; он может только отклонить соединение или разрешить его продолжение.</p>
<p>Пока атакующий не может сгенерировать действительный токен для своего собственного адреса (см. Раздел 8.1.4) и клиент способен вернуть этот токен, это доказывает серверу, что он получил токен.</p>
<p>Сервер также может использовать пакет Retry для отсрочки затрат на состояние и обработку при установлении соединения. Требование к серверу предоставить другой ID соединения вместе с транспортным параметром original_destination_connection_id, определенным в разделе 18.2, заставляет сервер продемонстрировать, что он или сущность, с которой он сотрудничает, получил исходный Initial пакет от клиента. Предоставление другого ID соединения также дает серверу некоторый контроль над тем, как маршрутизируются последующие пакеты. Это может использоваться для направления соединений к другому экземпляру сервера.</p>
<p>Если сервер получает клиентский Initial, который содержит недействительный Retry токен, но в остальном является корректным, он знает, что клиент не примет другой Retry токен. Сервер может отбросить такой пакет и позволить клиенту достичь таймаута для обнаружения сбоя рукопожатия, но это может наложить значительную задержку на клиента. Вместо этого сервер ДОЛЖЕН немедленно закрыть (Раздел 10.2) соединение с ошибкой INVALID_TOKEN. Обратите внимание, что сервер не установил никакого состояния для соединения на этом этапе и поэтому не входит в период закрытия.</p>
<p>Поток, показывающий использование пакета Retry, представлен на рисунке 9.</p>
<pre tabindex="0"><code>Client                                                  Server

Initial[0]: CRYPTO[CH] -&gt;

                                                &lt;- Retry+Token

Initial+Token[1]: CRYPTO[CH] -&gt;

                                 Initial[0]: CRYPTO[SH] ACK[1]
                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                 &lt;- 1-RTT[0]: STREAM[1, &#34;...&#34;]

                Figure 9: Example Handshake with Retry
</code></pre><h4 id="address-validation-for-future-connections">Address Validation for Future Connections</h4>
<p>Сервер МОЖЕТ предоставить клиентам токен валидации адреса во время одного соединения, который можно использовать при последующем соединении. Валидация адреса особенно важна при 0-RTT, поскольку сервер потенциально отправляет значительный объем данных клиенту в ответ на 0-RTT данные.</p>
<p>Сервер использует фрейм NEW_TOKEN (Раздел 19.7) для предоставления клиенту токена валидации адреса, который может быть использован для валидации будущих соединений. В будущем соединении клиент включает этот токен в пакеты Initial для обеспечения валидации адреса. Клиент ДОЛЖЕН включать токен во все отправляемые им пакеты Initial, если только Retry не заменит токен более новым. Клиент НЕ ДОЛЖЕН использовать токен, предоставленный в Retry, для будущих соединений. Серверы МОГУТ отбрасывать любой пакет Initial, который не содержит ожидаемый токен.</p>
<p>В отличие от токена, который создается для пакета Retry и используется немедленно, токен, отправленный в кадре NEW_TOKEN, может быть использован после того, как прошел некоторый период времени. Таким образом, токен ДОЛЖЕН иметь время истечения срока действия, которое может быть либо явным временем истечения срока действия, либо временной меткой выдачи, которая может использоваться для динамического вычисления времени истечения срока действия. Сервер может сохранить время истечения срока действия или включить его в зашифрованном виде в токен.</p>
<p>Токен, выданный с NEW_TOKEN, НЕ ДОЛЖЕН содержать информацию, которая позволила бы наблюдателю связать значения с соединением, на котором он был выдан. Например, он не может включать предыдущий идентификатор соединения или адресную информацию, если только значения не зашифрованы. Сервер ДОЛЖЕН гарантировать, что каждый отправляемый им NEW_TOKEN фрейм является уникальным для всех клиентов, за исключением тех, которые отправляются для восстановления потерь ранее отправленных NEW_TOKEN фреймов. Информация, которая позволяет серверу различать токены от Retry и NEW_TOKEN, МОЖЕТ быть доступна сущностям, отличным от сервера.</p>
<p>Маловероятно, что номер порта клиента будет одинаковым для двух разных соединений; поэтому проверка порта, скорее всего, будет неуспешной.</p>
<p>Токен, полученный во фрейме NEW_TOKEN, применим к любому серверу, для которого соединение считается авторитетным (например, имена серверов, включенные в сертификат). При подключении к серверу, для которого клиент сохраняет применимый и неиспользованный токен, он ДОЛЖЕН включить этот токен в поле Token своего Initial пакета. Включение токена может позволить серверу проверить адрес клиента без дополнительного круга обмена сообщениями. Клиент НЕ ДОЛЖЕН включать токен, который не применим к серверу, к которому он подключается, если только клиент не знает, что сервер, который выдал токен, и сервер, к которому подключается клиент, совместно управляют токенами. Клиент МОЖЕТ использовать токен из любого предыдущего соединения с этим сервером.</p>
<p>Токен позволяет серверу коррелировать активность между соединением, где токен был выдан, и любым соединением, где он используется. Клиенты, которые хотят нарушить непрерывность идентичности с сервером, могут отбросить токены, предоставленные с помощью фрейма NEW_TOKEN. В сравнении с этим, токен, полученный в пакете Retry, ДОЛЖЕН быть использован немедленно во время попытки соединения и не может быть использован в последующих попытках соединения.</p>
<p>Клиент НЕ ДОЛЖЕН повторно использовать токен из фрейма NEW_TOKEN для различных попыток соединения. Повторное использование токена позволяет объектам на сетевом пути связывать соединения; см. Раздел 9.5.</p>
<p>Клиенты могут получать несколько токенов в рамках одного соединения. Помимо предотвращения возможности связывания, любой токен может быть использован при любой попытке подключения. Серверы могут отправлять дополнительные токены либо для обеспечения валидации адреса при множественных попытках подключения, либо для замены старых токенов, которые могут стать недействительными. Для клиента эта неопределенность означает, что отправка самого недавнего неиспользованного токена наиболее вероятно будет эффективной. Хотя сохранение и использование старых токенов не имеет негативных последствий, клиенты могут рассматривать старые токены как менее вероятно полезные для сервера при валидации адреса.</p>
<p>Когда сервер получает пакет Initial с токеном валидации адреса, он ДОЛЖЕН попытаться проверить токен, если только он уже не завершил валидацию адреса. Если токен недействителен, то сервер СЛЕДУЕТ действовать так, как если бы у клиента не было проверенного адреса, включая потенциальную отправку пакета Retry. Токены, предоставляемые с фреймами NEW_TOKEN и пакетами Retry, могут быть различены серверами (см. Раздел 8.1.1), и последние могут быть проверены более строго. Если валидация успешна, сервер СЛЕДУЕТ затем разрешить продолжение handshake.</p>
<p>Примечание: Обоснование для обработки клиента как непроверенного, а не отбрасывания пакета, заключается в том, что клиент мог получить токен в предыдущем соединении с использованием фрейма NEW_TOKEN, и если сервер потерял состояние, он может быть не в состоянии проверить токен вообще, что приведет к сбою соединения при отбрасывании пакета.</p>
<p>В stateless-дизайне сервер может использовать зашифрованные и аутентифицированные токены для передачи информации клиентам, которую сервер впоследствии может восстановить и использовать для валидации адреса клиента. Токены не интегрированы в криптографический handshake, и поэтому они не аутентифицированы. Например, клиент может повторно использовать токен. Чтобы избежать атак, которые эксплуатируют это свойство, сервер может ограничить использование токенов только информацией, необходимой для валидации адресов клиентов.</p>
<p>Клиенты МОГУТ использовать токены, полученные в одном соединении, для любой попытки подключения с использованием той же версии. При выборе токена для использования клиентам не нужно учитывать другие свойства устанавливаемого соединения, включая выбор возможных протоколов приложений, сессионные билеты или другие свойства соединения.</p>
<h4 id="address-validation-token-integrity">Address Validation Token Integrity</h4>
<p>Токен валидации адреса ДОЛЖЕН быть сложным для угадывания. Включение случайного значения с энтропией не менее 128 бит в токен было бы достаточным, но это зависит от того, что сервер запоминает значение, которое он отправляет клиентам.</p>
<p>Схема на основе токенов позволяет серверу передавать клиенту любое состояние, связанное с проверкой. Для работы этой схемы токен ДОЛЖЕН быть защищен от изменения или фальсификации клиентами средствами обеспечения целостности. Без защиты целостности злонамеренные клиенты могли бы генерировать или угадывать значения токенов, которые были бы приняты сервером. Только сервер требует доступа к ключу защиты целостности для токенов.</p>
<p>Нет необходимости в едином четко определенном формате для токена, поскольку сервер, который генерирует токен, также его потребляет. Токены, отправляемые в пакетах Retry, ДОЛЖНЫ включать информацию, которая позволяет серверу проверить, что IP-адрес источника и порт в клиентских пакетах остаются постоянными.</p>
<p>Токены, отправляемые в кадрах NEW_TOKEN, ДОЛЖНЫ включать информацию, позволяющую серверу проверить, что IP-адрес клиента не изменился с момента выдачи токена. Серверы могут использовать токены из кадров NEW_TOKEN при принятии решения не отправлять пакет Retry, даже если адрес клиента изменился. Если IP-адрес клиента изменился, сервер ДОЛЖЕН соблюдать ограничение по защите от усиления; см. раздел 8. Обратите внимание, что при наличии NAT это требование может быть недостаточным для защиты других хостов, использующих общий NAT, от атак усиления.</p>
<p>Злоумышленники могут повторно использовать токены для применения серверов в качестве усилителей в DDoS-атаках. Для защиты от таких атак серверы ДОЛЖНЫ обеспечивать предотвращение или ограничение повторного использования токенов. Серверы ДОЛЖНЫ обеспечивать, чтобы токены, отправленные в пакетах Retry, принимались только в течение короткого времени, поскольку они немедленно возвращаются клиентами. Токены, предоставляемые во фреймах NEW_TOKEN (Раздел 19.7), должны быть действительны дольше, но НЕ ДОЛЖНЫ приниматься несколько раз. Серверам рекомендуется разрешать использование токенов только один раз, если это возможно; токены МОГУТ включать дополнительную информацию о клиентах для дальнейшего сужения применимости или повторного использования.</p>
<h4 id="онлайн-dpi">Онлайн DPI</h4>
<p>Валидация пути используется обеими сторонами во время миграции соединения (см. Раздел 9) для проверки достижимости после изменения адреса. При валидации пути конечные точки тестируют достижимость между конкретным локальным адресом и конкретным адресом узла, где адрес представляет собой кортеж из IP-адреса и порта.</p>
<p>Проверка пути тестирует, что пакеты, отправленные по пути к узлу, получены этим узлом. Проверка пути используется для обеспечения того, что пакеты, полученные от мигрирующего узла, не содержат поддельный адрес источника.</p>
<p>Валидация пути не проверяет, что узел может отправлять данные в обратном направлении. Подтверждения не могут использоваться для валидации обратного пути, поскольку они содержат недостаточную энтропию и могут быть подделаны. Конечные точки независимо определяют достижимость в каждом направлении пути, и поэтому обратная достижимость может быть установлена только самим узлом.</p>
<p>Проверка пути может быть использована в любое время любой конечной точкой. Например, конечная точка может проверить, что peer всё ещё владеет своим адресом после периода бездействия.</p>
<p>Проверка пути не предназначена как механизм обхода NAT. Хотя описанный здесь механизм может быть эффективным для создания NAT-привязок, которые поддерживают обход NAT, ожидается, что одна из конечных точек способна принимать пакеты без предварительной отправки пакета по этому пути. Эффективный обход NAT требует дополнительных механизмов синхронизации, которые здесь не предоставляются.</p>
<p>Конечная точка МОЖЕТ включать другие фреймы вместе с фреймами PATH_CHALLENGE и PATH_RESPONSE, используемыми для проверки пути. В частности, конечная точка может включать фреймы PADDING с фреймом PATH_CHALLENGE для обнаружения максимального размера передаваемого блока пути (PMTUD); см. раздел 14.2.1. Конечная точка также может включать свой собственный фрейм PATH_CHALLENGE при отправке фрейма PATH_RESPONSE.</p>
<p>Конечная точка использует новый ID соединения для проб, отправляемых с нового локального адреса; см. Раздел 9.5. При проверке нового пути конечная точка может убедиться, что у её узла есть доступный неиспользуемый ID соединения для ответов. Отправка фреймов NEW_CONNECTION_ID и PATH_CHALLENGE в одном пакете, если active_connection_id_limit узла это позволяет, гарантирует, что неиспользуемый ID соединения будет доступен узлу при отправке ответа.</p>
<p>Конечная точка может выбрать одновременное зондирование нескольких путей. Количество одновременных путей, используемых для зондирования, ограничено числом дополнительных идентификаторов соединения, которые ранее предоставил её пир, поскольку каждый новый локальный адрес, используемый для зондирования, требует ранее неиспользованный идентификатор соединения.</p>
<h4 id="автономная-dpi">Автономная DPI</h4>
<p>Для инициации валидации пути конечная точка отправляет кадр PATH_CHALLENGE, содержащий непредсказуемую полезную нагрузку, по пути, который необходимо проверить.</p>
<p>Конечная точка МОЖЕТ отправлять несколько фреймов PATH_CHALLENGE для защиты от потери пакетов. Однако конечная точка НЕ ДОЛЖНА отправлять несколько фреймов PATH_CHALLENGE в одном пакете.</p>
<p>Конечная точка НЕ ДОЛЖНА зондировать новый путь пакетами, содержащими фрейм PATH_CHALLENGE, чаще, чем она отправляла бы пакет Initial. Это гарантирует, что миграция соединения не создает большей нагрузки на новый путь, чем установление нового соединения.</p>
<p>Конечная точка ДОЛЖНА использовать непредсказуемые данные в каждом кадре PATH_CHALLENGE, чтобы она могла связать ответ узла с соответствующим PATH_CHALLENGE.</p>
<p>Эндпоинт ДОЛЖЕН расширять датаграммы, содержащие фрейм PATH_CHALLENGE, до минимального допустимого максимального размера датаграммы в 1200 байт, если только ограничение анти-усиления для пути не запрещает отправку датаграммы такого размера. Отправка UDP-датаграмм этого размера гарантирует, что сетевой путь от эндпоинта к пиру может использоваться для QUIC; см. Раздел 14.</p>
<p>Когда конечная точка не может расширить размер датаграммы до 1200 байт из-за ограничения анти-амплификации, MTU пути не будет проверено. Чтобы обеспечить достаточный размер MTU пути, конечная точка ДОЛЖНА выполнить вторую проверку пути, отправив фрейм PATH_CHALLENGE в датаграмме размером не менее 1200 байт. Эта дополнительная проверка может быть выполнена после успешного получения PATH_RESPONSE или когда на пути получено достаточно байт, чтобы отправка более крупной датаграммы не привела к превышению лимита анти-амплификации.</p>
<p>В отличие от других случаев, когда датаграммы расширяются, конечные точки НЕ ДОЛЖНЫ отбрасывать датаграммы, которые кажутся слишком маленькими, если они содержат PATH_CHALLENGE или PATH_RESPONSE.</p>
<h4 id="path-validation-responses">Path Validation Responses</h4>
<p>При получении фрейма PATH_CHALLENGE конечная точка ДОЛЖНА ответить, отправив данные, содержащиеся во фрейме PATH_CHALLENGE, во фрейме PATH_RESPONSE. Конечная точка НЕ ДОЛЖНА задерживать передачу пакета, содержащего фрейм PATH_RESPONSE, если только это не ограничено управлением перегрузкой.</p>
<p>Фрейм PATH_RESPONSE ДОЛЖЕН быть отправлен по сетевому пути, где был получен фрейм PATH_CHALLENGE. Это обеспечивает, что валидация пути peer&rsquo;ом успешна только в том случае, если путь функционален в обоих направлениях. Это требование НЕ ДОЛЖНО применяться конечной точкой, которая инициирует валидацию пути, так как это позволило бы атаку на миграцию; см. Раздел 9.3.3.</p>
<p>Конечная точка ДОЛЖНА расширять датаграммы, содержащие кадр PATH_RESPONSE, до минимального допустимого максимального размера датаграммы в 1200 байт. Это подтверждает, что путь способен передавать датаграммы такого размера в обоих направлениях. Однако конечная точка НЕ ДОЛЖНА расширять датаграмму, содержащую PATH_RESPONSE, если полученные данные превышают лимит защиты от усиления. Ожидается, что это произойдет только в том случае, если полученный PATH_CHALLENGE не был отправлен в расширенной датаграмме.</p>
<p>Конечная точка НЕ ДОЛЖНА отправлять более одного кадра PATH_RESPONSE в ответ на один кадр PATH_CHALLENGE; см. Раздел 13.3. Ожидается, что узел будет отправлять дополнительные кадры PATH_CHALLENGE по мере необходимости для вызова дополнительных кадров PATH_RESPONSE.</p>
<h4 id="проверка-адреса-при-установлении-соединения">Проверка адреса при установлении соединения</h4>
<p>Валидация пути завершается успешно, когда получен фрейм PATH_RESPONSE, содержащий данные, которые были отправлены в предыдущем фрейме PATH_CHALLENGE. Фрейм PATH_RESPONSE, полученный по любому сетевому пути, валидирует путь, по которому был отправлен PATH_CHALLENGE.</p>
<p>Если конечная точка отправляет кадр PATH_CHALLENGE в датаграмме, которая не расширена до размера не менее 1200 байт, и если ответ на неё подтверждает адрес узла, путь проверяется, но не MTU пути. В результате конечная точка теперь может отправить более чем в три раза больше данных, чем было получено. Однако конечная точка ДОЛЖНА инициировать другую проверку пути с расширенной датаграммой, чтобы убедиться, что путь поддерживает требуемый MTU.</p>
<p>Получение подтверждения для пакета, содержащего кадр PATH_CHALLENGE, не является достаточной проверкой, поскольку подтверждение может быть подделано вредоносным узлом.</p>
<h4 id="конструкция-токенов">Конструкция токенов</h4>
<p>Валидация пути завершается неудачей только тогда, когда конечная точка, пытающаяся валидировать путь, отказывается от попытки валидации пути.</p>
<p>Конечные точки ДОЛЖНЫ прекращать валидацию пути на основе таймера. При установке этого таймера реализациям следует учитывать, что новый путь может иметь более длительное время приёма-передачи, чем исходный. РЕКОМЕНДУЕТСЯ значение, равное трём значениям большего из текущего PTO или PTO для нового пути (используя kInitialRtt, как определено в <a href="https://datatracker.ietf.org/doc/html/rfc9002">QUIC-RECOVERY</a>
).</p>
<p>Этот таймаут позволяет истечь нескольким PTO перед признанием проверки пути неудачной, так что потеря одного кадра PATH_CHALLENGE или PATH_RESPONSE не приводит к сбою проверки пути.</p>
<p>Обратите внимание, что конечная точка может получать пакеты, содержащие другие фреймы, по новому пути, но для успешной проверки пути требуется фрейм PATH_RESPONSE с соответствующими данными.</p>
<p>Когда конечная точка прекращает валидацию пути, она определяет, что путь непригоден для использования. Это не обязательно означает сбой соединения &ndash; конечные точки могут продолжать отправку пакетов по другим путям при необходимости. Если пути недоступны, конечная точка может ожидать, пока новый путь станет доступным, или закрыть соединение. Конечная точка, которая не имеет действительного сетевого пути к своему узлу, МОЖЕТ сигнализировать об этом, используя ошибку соединения NO_VIABLE_PATH, отмечая, что это возможно только в том случае, если сетевой путь существует, но не поддерживает требуемый MTU (Раздел 14).</p>
<p>Проверка пути может быть прекращена по другим причинам, помимо сбоя. В первую очередь это происходит, если инициируется миграция соединения на новый путь, пока выполняется проверка пути на старом пути.</p>
<h3 id="connection-migration">Connection Migration</h3>
<p>Далее скопировано из QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
. Для каждого раздела просмотрите и отредактируйте.</p>
<p>Использование идентификатора соединения позволяет соединениям выживать при изменениях адресов конечных точек (IP-адрес и порт), таких как те, которые вызваны миграцией конечной точки в новую сеть. Этот раздел описывает процесс, посредством которого конечная точка мигрирует на новый адрес.</p>
<p>Дизайн QUIC опирается на то, что конечные точки сохраняют стабильный адрес в течение всего процесса установления соединения. Конечная точка НЕ ДОЛЖНА инициировать миграцию соединения до подтверждения установления соединения, как определено в разделе 4.1.2 <a href="https://datatracker.ietf.org/doc/html/rfc9001">QUIC-TLS</a>
.</p>
<p>Если узел отправил транспортный параметр disable_active_migration, конечная точка также НЕ ДОЛЖНА отправлять пакеты (включая зондирующие пакеты; см. раздел 9.1) с другого локального адреса на адрес, который узел использовал во время handshake, если только конечная точка не действовала на основании транспортного параметра preferred_address от узла. Если узел нарушает это требование, конечная точка ДОЛЖНА либо отбросить входящие пакеты на этом пути без генерации Stateless Reset, либо продолжить валидацию пути и разрешить узлу выполнить миграцию. Генерация Stateless Reset или закрытие соединения позволило бы третьим сторонам в сети вызывать закрытие соединений путем подмены или другого манипулирования наблюдаемым трафиком.</p>
<p>Не все изменения адреса узла являются намеренными или активными миграциями. Узел может столкнуться с повторной привязкой NAT: изменением адреса из-за промежуточного устройства, обычно NAT, выделяющего новый исходящий порт или даже новый исходящий IP-адрес для потока. Конечная точка ДОЛЖНА выполнить проверку пути (Раздел 8.2), если она обнаруживает любое изменение адреса узла, если только она ранее не проверила этот адрес.</p>
<p>Когда конечная точка не имеет проверенного пути для отправки пакетов, она МОЖЕТ отбросить состояние соединения. Конечная точка, поддерживающая миграцию соединения, МОЖЕТ ожидать доступности нового пути перед отбрасыванием состояния соединения.</p>
<p>Данный документ ограничивает миграцию соединений на новые адреса клиентов, за исключением случаев, описанных в разделе 9.6. Клиенты несут ответственность за инициацию всех миграций. Серверы не отправляют не-пробные пакеты (см. раздел 9.1) на адрес клиента до тех пор, пока не увидят не-пробный пакет с этого адреса. Если клиент получает пакеты с неизвестного адреса сервера, клиент ДОЛЖЕН отбросить эти пакеты.</p>
<h4 id="валидация-адресов-с-использованием-повторных-пакетов">Валидация адресов с использованием повторных пакетов</h4>
<p>Конечная точка МОЖЕТ проверить доступность узла с нового локального адреса, используя валидацию пути (Раздел 8.2), до миграции соединения на новый локальный адрес. Неудача валидации пути просто означает, что новый путь не пригоден для использования с данным соединением. Неспособность валидировать путь не приводит к завершению соединения, если только не отсутствуют другие валидные альтернативные пути.</p>
<p>Кадры PATH_CHALLENGE, PATH_RESPONSE, NEW_CONNECTION_ID и PADDING являются &ldquo;зондирующими кадрами&rdquo;, а все остальные кадры являются &ldquo;незондирующими кадрами&rdquo;. Пакет, содержащий только зондирующие кадры, является &ldquo;зондирующим пакетом&rdquo;, а пакет, содержащий любой другой кадр, является &ldquo;незондирующим пакетом&rdquo;.</p>
<h4 id="валидация-адресов-для-будущих-соединений">Валидация адресов для будущих соединений</h4>
<p>Конечная точка может мигрировать соединение на новый локальный адрес, отправляя пакеты, содержащие не-пробные фреймы с этого адреса.</p>
<p>Каждая конечная точка проверяет адрес своего peer&rsquo;а во время установления соединения. Поэтому мигрирующая конечная точка может отправлять данные своему peer&rsquo;у, зная, что peer готов получать данные по своему текущему адресу. Таким образом, конечная точка может мигрировать на новый локальный адрес без предварительной проверки адреса peer&rsquo;а.</p>
<p>Для установления достижимости по новому пути, конечная точка инициирует проверку пути (Раздел 8.2) на новом пути. Конечная точка МОЖЕТ отложить проверку пути до тех пор, пока партнер не отправит следующий не-зондирующий кадр на свой новый адрес.</p>
<p>При миграции новый путь может не поддерживать текущую скорость отправки конечной точки. Поэтому конечная точка сбрасывает свой контроллер перегрузки и оценку RTT, как описано в разделе 9.4.</p>
<p>Новый путь может не иметь такой же возможности ECN. Поэтому конечная точка проверяет возможность ECN, как описано в разделе 13.4.</p>
<h4 id="целостность-токена-валидации-адреса">Целостность токена валидации адреса</h4>
<p>Получение пакета с нового адреса пира, содержащего не-зондирующий кадр, указывает на то, что пир мигрировал на этот адрес.</p>
<p>Если получатель разрешает миграцию, он ДОЛЖЕН отправлять последующие пакеты на новый адрес узла и ДОЛЖЕН инициировать валидацию пути (Раздел 8.2) для проверки владения узлом этим адресом, если валидация еще не выполняется. Если у получателя нет неиспользованных идентификаторов соединения от узла, он не сможет отправить что-либо по новому пути до тех пор, пока узел не предоставит такой идентификатор; см. Раздел 9.5.</p>
<p>Конечная точка изменяет адрес, на который она отправляет пакеты, только в ответ на пакет без зондирования с наивысшим номером. Это гарантирует, что конечная точка не отправляет пакеты на старый адрес узла в случае получения пакетов в неправильном порядке.</p>
<p>Конечная точка МОЖЕТ отправлять данные на неподтвержденный адрес узла, но ДОЛЖНА защищаться от потенциальных атак, как описано в разделах 9.3.1 и 9.3.2. Конечная точка МОЖЕТ пропустить проверку адреса узла, если этот адрес был замечен недавно. В частности, если конечная точка возвращается к ранее подтвержденному пути после обнаружения какой-либо формы ложной миграции, пропуск проверки адреса и восстановление состояния обнаружения потерь и управления перегрузкой может снизить влияние атаки на производительность.</p>
<p>После изменения адреса, на который отправляются не-зондирующие пакеты, конечная точка может отказаться от любой проверки пути для других адресов.</p>
<p>Получение пакета с нового адреса узла может быть результатом NAT rebinding у узла.</p>
<p>После верификации нового адреса клиента, сервер ДОЛЖЕН отправить клиенту новые токены валидации адреса (Раздел 8).</p>
<h4 id="валидация-пути">Валидация пути</h4>
<p>Возможно, что пир подделывает свой исходящий адрес, чтобы заставить конечную точку отправлять чрезмерные объемы данных нежелающему хосту. Если конечная точка отправляет значительно больше данных, чем подделывающий пир, миграция соединения может использоваться для усиления объема данных, который злоумышленник может генерировать в направлении жертвы.</p>
<p>Как описано в разделе 9.3, конечная точка обязана проверить новый адрес партнера, чтобы подтвердить владение партнером новым адресом. До тех пор пока адрес партнера не будет признан действительным, конечная точка ограничивает объем данных, отправляемых на этот адрес; см. раздел 8. При отсутствии этого ограничения конечная точка рискует быть использованной для атаки типа &ldquo;отказ в обслуживании&rdquo; против ничего не подозревающей жертвы.</p>
<p>Если конечная точка пропускает валидацию адреса узла, как описано выше, ей не нужно ограничивать скорость отправки.</p>
<h4 id="инициация-валидации-пути">Инициация валидации пути</h4>
<p>Атакующий на пути соединения может вызвать ложную миграцию соединения, копируя и пересылая пакет с подделанным адресом таким образом, чтобы он прибыл раньше оригинального пакета. Пакет с подделанным адресом будет восприниматься как приходящий от мигрирующего соединения, а оригинальный пакет будет расценен как дубликат и отброшен. После ложной миграции проверка исходного адреса завершится неудачей, поскольку объект по исходному адресу не обладает необходимыми криптографическими ключами для чтения или ответа на фрейм PATH_CHALLENGE, который ему отправляется, даже если бы он этого хотел.</p>
<p>Чтобы защитить соединение от сбоя из-за такой ложной миграции, конечная точка ДОЛЖНА вернуться к использованию последнего проверенного адреса партнера, когда проверка нового адреса партнера завершается неудачей. Кроме того, получение пакетов с более высокими номерами пакетов с легитимного адреса партнера запустит другую миграцию соединения. Это приведет к тому, что проверка адреса ложной миграции будет прекращена, тем самым ограничивая миграции, инициированные злоумышленником, вводящим один пакет.</p>
<p>Если endpoint не имеет состояния о последнем проверенном адресе узла, он ДОЛЖЕН закрыть соединение молча, отбросив все состояние соединения. Это приводит к тому, что новые пакеты на соединении обрабатываются обобщенно. Например, endpoint МОЖЕТ отправить Stateless Reset в ответ на любые дальнейшие входящие пакеты.</p>
<h4 id="ответы-на-валидацию-пути">Ответы на валидацию пути</h4>
<p>Атакующий вне маршрута, который может наблюдать пакеты, может перенаправлять копии подлинных пакетов на конечные точки. Если скопированный пакет прибудет раньше подлинного пакета, это будет выглядеть как NAT rebinding. Любой подлинный пакет будет отброшен как дубликат. Если атакующий сможет продолжать перенаправление пакетов, он может вызвать миграцию на путь через себя. Это помещает атакующего на маршрут, давая ему возможность наблюдать или отбрасывать все последующие пакеты.</p>
<p>Этот тип атаки основывается на том, что атакующий использует путь с приблизительно теми же характеристиками, что и прямой путь между конечными точками. Атака более надежна, если отправляется относительно мало пакетов или если потеря пакетов совпадает с попыткой атаки.</p>
<p>Пакет без зондирования, полученный по исходному пути, который увеличивает максимальный номер полученного пакета, приведет к тому, что конечная точка вернется к этому пути. Вызов пакетов на этом пути повышает вероятность того, что атака будет неуспешной. Поэтому смягчение этой атаки зависит от инициирования обмена пакетами.</p>
<p>В ответ на очевидную миграцию, конечные точки ДОЛЖНЫ проверить ранее активный путь, используя кадр PATH_CHALLENGE. Это вызывает отправку новых пакетов по этому пути. Если путь больше не является жизнеспособным, попытка проверки истечет по времени и завершится неудачей; если путь жизнеспособен, но больше не желателен, проверка будет успешной, но приведет только к отправке зондирующих пакетов по пути.</p>
<p>Конечная точка, которая получает PATH_CHALLENGE на активном пути, ДОЛЖНА отправить непробный пакет в ответ. Если непробный пакет прибывает раньше любой копии, созданной злоумышленником, это приводит к миграции соединения обратно на исходный путь. Любая последующая миграция на другой путь перезапускает весь этот процесс.</p>
<p>Эта защита несовершенна, но это не считается серьёзной проблемой. Если путь через атаку надёжно быстрее исходного пути несмотря на множественные попытки использовать этот исходный путь, невозможно отличить атаку от улучшения в маршрутизации.</p>
<p>Конечная точка также может использовать эвристику для улучшения обнаружения атак такого типа. Например, NAT rebinding маловероятен, если пакеты недавно были получены по старому пути; аналогично, rebinding редко происходит на IPv6 путях. Конечные точки также могут искать дублированные пакеты. И наоборот, изменение connection ID с большей вероятностью указывает на намеренную миграцию, а не на атаку.</p>
<h4 id="успешная-валидация-пути">Успешная валидация пути</h4>
<p>Пропускная способность, доступная на новом пути, может не совпадать со старым путем. Пакеты, отправленные по старому пути, НЕ ДОЛЖНЫ влиять на управление перегрузкой или оценку RTT для нового пути.</p>
<p>При подтверждении права собственности узла на его новый адрес, конечная точка ДОЛЖНА немедленно сбросить контроллер перегрузок и оценщик времени круговой задержки для нового пути к начальным значениям (см. Приложения A.3 и B.3 в <a href="https://datatracker.ietf.org/doc/html/rfc9002">QUIC-RECOVERY</a>
), если только единственное изменение в адресе узла не касается номера порта. Поскольку изменения только порта обычно являются результатом повторного связывания NAT или другой активности промежуточных устройств, конечная точка МОЖЕТ вместо этого сохранить свое состояние управления перегрузками и оценку времени круговой задержки в таких случаях вместо возврата к начальным значениям. В случаях, когда состояние управления перегрузками, сохраненное со старого пути, используется на новом пути с существенно отличающимися характеристиками, отправитель может передавать слишком агрессивно до тех пор, пока контроллер перегрузок и оценщик RTT не адаптируются. В целом, реализациям рекомендуется проявлять осторожность при использовании предыдущих значений на новом пути.</p>
<p>На стороне получателя может наблюдаться видимое переупорядочивание, когда конечная точка отправляет данные и зонды с/на несколько адресов в период миграции, поскольку два получившихся пути могут иметь разное время кругового обхода. Получатель пакетов по нескольким путям по-прежнему будет отправлять ACK-фреймы, покрывающие все полученные пакеты.</p>
<p>Хотя во время миграции соединения могут использоваться несколько путей, одного контекста управления перегрузкой и одного контекста восстановления после потерь (как описано в <a href="https://datatracker.ietf.org/doc/html/rfc9002">QUIC-RECOVERY</a>
) может быть достаточно. Например, конечная точка может отложить переключение на новый контекст управления перегрузкой до тех пор, пока не будет подтверждено, что старый путь больше не нужен (например, в случае, описанном в разделе 9.3.3).</p>
<p>Отправитель может делать исключения для зондирующих пакетов, чтобы их обнаружение потерь было независимым и не приводило к неоправданному снижению скорости отправки контроллером перегрузок. Конечная точка может установить отдельный таймер при отправке PATH_CHALLENGE, который отменяется при получении соответствующего PATH_RESPONSE. Если таймер срабатывает до получения PATH_RESPONSE, конечная точка может отправить новый PATH_CHALLENGE и перезапустить таймер на более длительный период времени. Этот таймер ДОЛЖЕН быть установлен как описано в разделе 6.2.1 <a href="https://datatracker.ietf.org/doc/html/rfc9002">QUIC-RECOVERY</a>
 и НЕ ДОЛЖЕН быть более агрессивным.</p>
<h4 id="неудачная-проверка-пути">Неудачная проверка пути</h4>
<p>Использование стабильного идентификатора соединения на нескольких сетевых путях позволило бы пассивному наблюдателю коррелировать активность между этими путями. Конечная точка, которая перемещается между сетями, может не желать, чтобы их активность коррелировалась каким-либо субъектом, кроме их партнера, поэтому используются разные идентификаторы соединений при отправке с разных локальных адресов, как обсуждается в разделе 5.1. Для эффективности этого подхода конечным точкам необходимо обеспечить, чтобы предоставляемые ими идентификаторы соединений не могли быть связаны никаким другим субъектом.</p>
<p>В любое время конечные точки МОГУТ изменить Destination Connection ID, который они передают, на значение, которое не использовалось на другом пути.</p>
<p>Конечная точка НЕ ДОЛЖНА повторно использовать идентификатор соединения при отправке с более чем одного локального адреса &ndash; например, при инициации миграции соединения, как описано в разделе 9.2, или при зондировании нового сетевого пути, как описано в разделе 9.1.</p>
<p>Аналогично, конечная точка НЕ ДОЛЖНА повторно использовать connection ID при отправке на более чем один адрес назначения. Из-за изменений в сети, находящихся вне контроля её партнёра, конечная точка может получить пакеты с нового адреса источника с тем же значением поля Destination Connection ID, в этом случае она МОЖЕТ продолжить использовать текущий connection ID с новым удалённым адресом, продолжая при этом отправку с того же локального адреса.</p>
<p>Эти требования касательно повторного использования connection ID применяются только к отправке пакетов, поскольку возможны непреднамеренные изменения пути без изменения connection ID. Например, после периода сетевой неактивности NAT rebinding может привести к тому, что пакеты будут отправляться по новому пути, когда клиент возобновит отправку. Конечная точка отвечает на такое событие, как описано в разделе 9.3.</p>
<p>Использование различных connection ID для пакетов, отправляемых в обоих направлениях на каждом новом сетевом пути, исключает использование connection ID для связывания пакетов одного и того же соединения через разные сетевые пути. Защита заголовков гарантирует, что номера пакетов не могут использоваться для корреляции активности. Это не препятствует использованию других свойств пакетов, таких как время и размер, для корреляции активности.</p>
<p>Конечная точка НЕ ДОЛЖНА инициировать миграцию с узлом, который запросил идентификатор соединения нулевой длины, поскольку трафик по новому пути может быть тривиально связан с трафиком по старому. Если сервер способен ассоциировать пакеты с идентификатором соединения нулевой длины с правильным соединением, это означает, что сервер использует другую информацию для демультиплексирования пакетов. Например, сервер может предоставлять уникальный адрес каждому клиенту &ndash; например, используя альтернативные службы HTTP <a href="https://datatracker.ietf.org/doc/html/rfc7838">ALTSVC</a>
. Информация, которая может позволить корректную маршрутизацию пакетов через множественные сетевые пути, также позволит связать активность на этих путях сущностями, отличными от узла.</p>
<p>Клиент может захотеть снизить возможность связывания путем переключения на новый connection ID, исходный UDP-порт или IP-адрес (см. <a href="https://datatracker.ietf.org/doc/html/rfc8981">RFC8981</a>
) при отправке трафика после периода неактивности. Изменение адреса, с которого отправляются пакеты, в то же время может привести к тому, что сервер обнаружит миграцию соединения. Это обеспечивает использование механизмов поддержки миграции даже для клиентов, которые не сталкиваются с NAT rebinding или реальными миграциями. Изменение адреса может привести к сбросу состояния контроля перегрузки узла (см. раздел 9.4), поэтому адреса СЛЕДУЕТ изменять нечасто.</p>
<p>Конечная точка, которая исчерпала доступные идентификаторы соединения, не может исследовать новые пути или инициировать миграцию, а также не может отвечать на зондирование или попытки миграции со стороны своего партнера. Чтобы обеспечить возможность миграции и невозможность корреляции пакетов, отправленных по разным путям, конечные точки ДОЛЖНЫ предоставлять новые идентификаторы соединения до миграции партнеров; см. раздел 5.1.1. Если партнер мог исчерпать доступные идентификаторы соединения, мигрирующая конечная точка могла бы включать фрейм NEW_CONNECTION_ID во все пакеты, отправляемые по новому сетевому пути.</p>
<h4 id="servers-preferred-address">Server&rsquo;s Preferred Address</h4>
<p>QUIC позволяет серверам принимать соединения на одном IP-адресе и пытаться перенести эти соединения на более предпочтительный адрес вскоре после handshake. Это особенно полезно, когда клиенты изначально подключаются к адресу, который используется несколькими серверами совместно, но предпочли бы использовать unicast-адрес для обеспечения стабильности соединения. Данный раздел описывает протокол миграции соединения на предпочтительный адрес сервера.</p>
<p>Миграция соединения на новый адрес сервера в процессе соединения не поддерживается версией QUIC, указанной в данном документе. Если клиент получает пакеты с нового адреса сервера, когда клиент не инициировал миграцию на этот адрес, клиент ДОЛЖЕН отбросить эти пакеты.</p>
<h4 id="исследование-нового-пути">Исследование нового пути</h4>
<p>Сервер передает предпочтительный адрес, включив параметр транспорта preferred_address в TLS handshake.</p>
<p>Серверы МОГУТ сообщать предпочтительный адрес для каждого семейства адресов (IPv4 и IPv6), чтобы позволить клиентам выбрать наиболее подходящий для их сетевого подключения.</p>
<p>После подтверждения рукопожатия клиент ДОЛЖЕН выбрать один из двух адресов, предоставленных сервером, и инициировать валидацию пути (см. Раздел 8.2). Клиент конструирует пакеты, используя любой ранее не использованный активный connection ID, взятый либо из транспортного параметра preferred_address, либо из фрейма NEW_CONNECTION_ID.</p>
<p>Как только валидация пути завершается успешно, клиент ДОЛЖЕН начать отправлять все будущие пакеты на новый адрес сервера, используя новый connection ID, и прекратить использование старого адреса сервера. Если валидация пути не удается, клиент ДОЛЖЕН продолжать отправлять все будущие пакеты на исходный IP-адрес сервера.</p>
<h4 id="инициация-миграции-соединения">Инициация миграции соединения</h4>
<p>Клиент, который мигрирует на предпочтительный адрес, ДОЛЖЕН проверить адрес, который он выбирает, перед миграцией; см. Раздел 21.5.3.</p>
<p>Сервер может получить пакет, адресованный на его предпочитаемый IP-адрес, в любое время после того, как он принимает соединение. Если этот пакет содержит кадр PATH_CHALLENGE, сервер отправляет пакет, содержащий кадр PATH_RESPONSE, согласно разделу 8.2. Сервер ДОЛЖЕН отправлять не-зондирующие пакеты со своего исходного адреса до тех пор, пока он не получит не-зондирующий пакет от клиента на свой предпочитаемый адрес и пока сервер не проверит новый путь.</p>
<p>Сервер ДОЛЖЕН выполнить зондирование по пути к клиенту со своего предпочтительного адреса. Это помогает защититься от ложной миграции, инициированной атакующим.</p>
<p>После того как сервер завершил проверку пути и получил непробный пакет с новым наибольшим номером пакета на своем предпочтительном адресе, сервер начинает отправлять непробные пакеты клиенту исключительно со своего предпочтительного IP-адреса. Сервер ДОЛЖЕН отбрасывать более новые пакеты для данного соединения, которые получены на старом IP-адресе. Сервер МОЖЕТ продолжать обрабатывать задержанные пакеты, которые получены на старом IP-адресе.</p>
<p>Адреса, которые сервер предоставляет в транспортном параметре preferred_address, действительны только для соединения, в котором они предоставляются. Клиент НЕ ДОЛЖЕН использовать их для других соединений, включая соединения, которые возобновляются из текущего соединения.</p>
<h4 id="ответ-на-миграцию-соединения">Ответ на миграцию соединения</h4>
<p>Клиенту может потребоваться выполнить миграцию соединения до того, как он мигрирует на предпочитаемый адрес сервера. В этом случае клиент ДОЛЖЕН одновременно выполнять валидацию пути как к исходному, так и к предпочитаемому адресу сервера с нового адреса клиента.</p>
<p>Если проверка пути предпочтительного адреса сервера прошла успешно, клиент ДОЛЖЕН прекратить проверку исходного адреса и перейти к использованию предпочтительного адреса сервера. Если проверка пути предпочтительного адреса сервера не удалась, но проверка исходного адреса сервера прошла успешно, клиент МОЖЕТ перейти на свой новый адрес и продолжить отправку на исходный адрес сервера.</p>
<p>Если пакеты, полученные по предпочтительному адресу сервера, имеют исходный адрес, отличающийся от наблюдаемого со стороны клиента во время handshake, сервер ДОЛЖЕН защищаться от потенциальных атак, как описано в разделах 9.3.1 и 9.3.2. Помимо преднамеренной одновременной миграции, это также может произойти из-за того, что сеть доступа клиента использовала другую привязку NAT для предпочтительного адреса сервера.</p>
<p>Серверы ДОЛЖНЫ инициировать валидацию пути к новому адресу клиента при получении пробного пакета с другого адреса; см. Раздел 8.</p>
<p>Клиент, который переходит на новый адрес, ДОЛЖЕН использовать предпочтительный адрес из того же семейства адресов для сервера.</p>
<p>ID соединения, предоставленный в транспортном параметре preferred_address, не является специфичным для предоставленных адресов. Этот ID соединения предоставляется для обеспечения того, чтобы у клиента был доступный ID соединения для миграции, но клиент МОЖЕТ использовать этот ID соединения на любом пути.</p>
<h4 id="подмена-адресов-узлов">Подмена адресов узлов</h4>
<p>QUIC рекомендует, чтобы конечные точки, которые отправляют данные с использованием IPv6, ДОЛЖНЫ применять метку потока IPv6 в соответствии с <a href="https://tools.ietf.org/html/rfc6437">RFC 6437</a>
, если только локальный API не позволяет устанавливать метки потоков IPv6.</p>
<p>К сожалению, Java API не позволяет устанавливать метки потока IPv6.</p>
<h3 id="не-цели">Не-цели</h3>
<p>Следующее скопировано из QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
. Для каждого раздела проведите обзор и редактирование.</p>
<p>Целью QUIC является обеспечение безопасного транспортного соединения. Раздел 21.1 предоставляет обзор этих свойств; последующие разделы обсуждают ограничения и предостережения относительно этих свойств, включая описания известных атак и контрмер.</p>
<h4 id="подделка-адресов-на-пути-передачи-данных">Подделка адресов на пути передачи данных</h4>
<p>Полный анализ безопасности QUIC выходит за рамки данного документа. Данный раздел представляет неформальное описание желаемых свойств безопасности в качестве помощи разработчикам и для содействия анализу протокола.</p>
<p>QUIC предполагает модель угроз, описанную в <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-21">SEC-CONS</a>
, и обеспечивает защиту от многих атак, которые возникают из этой модели.</p>
<p>Для этой цели атаки делятся на пассивные и активные атаки. Пассивные атакующие имеют возможность читать пакеты из сети, в то время как активные атакующие также имеют возможность записывать пакеты в сеть. Однако пассивная атака может включать в себя атакующего с возможностью вызвать изменение маршрутизации или другую модификацию в пути, по которому следуют пакеты, составляющие соединение.</p>
<p>Злоумышленники дополнительно классифицируются как атакующие на пути следования пакетов (on-path attackers) или атакующие вне пути следования пакетов (off-path attackers). Атакующий на пути может читать, изменять или удалять любой наблюдаемый им пакет таким образом, что пакет больше не достигает места назначения, в то время как атакующий вне пути наблюдает пакеты, но не может предотвратить доставку исходного пакета к предполагаемому получателю. Оба типа злоумышленников также могут передавать произвольные пакеты. Это определение отличается от определения в разделе 3.5 <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-21">SEC-CONS</a>
 тем, что атакующий вне пути способен наблюдать пакеты.</p>
<p>Свойства рукопожатия, защищенных пакетов и миграции соединения рассматриваются отдельно.</p>
<h4 id="перенаправление-пакетов-вне-маршрута">Перенаправление пакетов вне маршрута</h4>
<p>Handshake QUIC включает в себя handshake TLS 1.3 и наследует криптографические свойства, описанные в Приложении E.1 <a href="https://datatracker.ietf.org/doc/html/rfc8446">TLS13</a>
. Многие свойства безопасности QUIC зависят от того, что handshake TLS обеспечивает эти свойства. Любая атака на handshake TLS может повлиять на QUIC.</p>
<p>Любая атака на TLS-рукопожатие, которая компрометирует секретность или уникальность сессионных ключей, или аутентификацию участвующих узлов, влияет на другие гарантии безопасности, предоставляемые QUIC, которые зависят от этих ключей. Например, миграция (Раздел 9) зависит от эффективности защиты конфиденциальности, как для согласования ключей с использованием TLS-рукопожатия, так и для защиты QUIC-пакетов, чтобы избежать возможности связывания между сетевыми путями.</p>
<p>Атака на целостность TLS-handshake может позволить злоумышленнику повлиять на выбор протокола приложения или версии QUIC.</p>
<p>В дополнение к свойствам, предоставляемым TLS, рукопожатие QUIC обеспечивает некоторую защиту от DoS-атак на рукопожатие.</p>
<h4 id="обнаружение-потерь-и-управление-перегрузкой">Обнаружение потерь и управление перегрузкой</h4>
<p>Валидация адреса (Раздел 8) используется для проверки того, что сущность, заявляющая о владении данным адресом, способна получать пакеты по этому адресу. Валидация адреса ограничивает цели атак усиления адресами, для которых атакующий может наблюдать пакеты.</p>
<p>До валидации адреса конечные точки ограничены в том, что они могут отправлять. Конечные точки не могут отправлять данные на неподтверждённый адрес в объёме, превышающем в три раза данные, полученные с этого адреса.</p>
<p>Примечание: Ограничение против усиления применяется только когда конечная точка отвечает на пакеты, полученные с непроверенного адреса. Ограничение против усиления не применяется к клиентам при установлении нового соединения или при инициировании миграции соединения.</p>
<h4 id="влияние-миграции-соединений-на-приватность">Влияние миграции соединений на приватность</h4>
<p>Вычисление первого полета сервера для полного handshake потенциально является дорогостоящим, требуя как вычисления подписи, так и обмена ключами. Чтобы предотвратить вычислительные DoS-атаки, пакет Retry предоставляет дешевый механизм обмена токенами, который позволяет серверам проверить IP-адрес клиента перед выполнением любых дорогостоящих вычислений ценой одного кругового обмена. После успешного handshake серверы могут выдать новые токены клиенту, что позволит установить новые соединения без этих затрат.</p>
<h4 id="предпочтительный-адрес-сервера">Предпочтительный адрес сервера</h4>
<p>Злоумышленник на пути следования трафика или вне его может принудительно прервать handshake, заменив или перехватив Initial пакеты. После обмена валидными Initial пакетами последующие Handshake пакеты защищаются ключами Handshake, и злоумышленник на пути следования трафика не может принудительно прервать handshake иначе как отбросив пакеты, чтобы заставить конечные точки прекратить попытку соединения.</p>
<p>Атакующий, находящийся на пути передачи данных, также может заменить адреса пакетов с любой стороны и тем самым заставить клиента или сервер иметь неправильное представление об удаленных адресах. Такая атака неотличима от функций, выполняемых NAT.</p>
<h4 id="передача-предпочтительного-адреса">Передача Предпочтительного Адреса</h4>
<p>Весь handshake криптографически защищен: Initial пакеты шифруются с помощью ключей для конкретной версии, а Handshake и последующие пакеты шифруются ключами, полученными из обмена ключами TLS. Кроме того, согласование параметров включается в TLS transcript и таким образом обеспечивает те же гарантии целостности, что и обычное TLS согласование. Атакующий может наблюдать транспортные параметры клиента (если он знает salt для конкретной версии), но не может наблюдать транспортные параметры сервера и не может влиять на согласование параметров.</p>
<p>Идентификаторы соединений не шифруются, но защищены по целостности во всех пакетах.</p>
<p>Эта версия QUIC не включает механизм согласования версий; реализации несовместимых версий просто не смогут установить соединение.</p>
<h4 id="миграция-на-предпочтительный-адрес">Миграция на предпочтительный адрес</h4>
<p>Защита пакетов (Раздел 12.1) применяет аутентифицированное шифрование ко всем пакетам, за исключением пакетов Version Negotiation, хотя пакеты Initial и Retry имеют ограниченную защиту из-за использования материала для формирования ключей, зависящего от версии; см. <a href="https://datatracker.ietf.org/doc/html/rfc9001">QUIC-TLS</a>
 для более подробной информации. В данном разделе рассматриваются пассивные и активные атаки на защищенные пакеты.</p>
<p>Как атакующие, находящиеся на пути передачи данных, так и атакующие вне пути могут осуществлять пассивную атаку, при которой они сохраняют наблюдаемые пакеты для последующей офлайн-атаки на защиту пакетов; это справедливо для любого наблюдателя любого пакета в любой сети.</p>
<p>Злоумышленник, который внедряет пакеты без возможности наблюдать действительные пакеты для соединения, вряд ли будет успешным, поскольку защита пакетов обеспечивает, что действительные пакеты создаются только конечными точками, которые обладают ключевым материалом, установленным во время handshake; см. разделы 7 и 21.1.1. Аналогично, любой активный злоумышленник, который наблюдает пакеты и пытается вставить новые данные или изменить существующие данные в этих пакетах, не должен быть способен создать пакеты, считающиеся действительными принимающей конечной точкой, за исключением Initial пакетов.</p>
<p>Атака подмены (spoofing attack), при которой активный атакующий переписывает незащищенные части пакета, который он пересылает или внедряет, такие как адрес источника или назначения, эффективна только в том случае, если атакующий может пересылать пакеты к исходной конечной точке. Защита пакетов гарантирует, что полезная нагрузка пакетов может быть обработана только конечными точками, которые завершили handshake, а недействительные пакеты игнорируются этими конечными точками.</p>
<p>Атакующий также может изменить границы между пакетами и UDP датаграммами, заставляя несколько пакетов объединиться в одну датаграмму или разделяя объединённые пакеты на несколько датаграмм. За исключением датаграмм, содержащих Initial пакеты, которые требуют заполнения, изменение способа размещения пакетов в датаграммах не имеет функционального влияния на соединение, хотя это может изменить некоторые характеристики производительности.</p>
<h4 id="взаимодействие-миграции-клиента-и-предпочтительного-адреса">Взаимодействие миграции клиента и предпочтительного адреса</h4>
<p>Миграция соединения (Раздел 9) предоставляет конечным точкам возможность переключаться между IP-адресами и портами по нескольким путям, используя один путь за раз для передачи и получения фреймов, не являющихся пробными. Валидация пути (Раздел 8.2) устанавливает, что узел готов и способен получать пакеты, отправленные по определенному пути. Это помогает снизить влияние подмены адресов, ограничивая количество пакетов, отправляемых на поддельный адрес.</p>
<p>Данный раздел описывает предполагаемые свойства безопасности миграции соединений при различных типах DoS-атак.</p>
<h4 id="использование-ipv6-flow-label-и-миграция">Использование IPv6 Flow Label и миграция</h4>
<p>Злоумышленник, который может помпомешать наблюдаемому им пакету достичь намеченного получателя, считается злоумышленником на пути передачи данных. Когда злоумышленник находится между клиентом и сервером, конечные точки вынуждены отправлять пакеты через злоумышленника для установления соединения по данному пути.</p>
<p>Атакующий на пути передачи данных может:</p>
<ul>
<li>
<p>Проверка пакетов</p>
</li>
<li>
<p>Изменение заголовков IP и UDP пакетов</p>
</li>
<li>
<p>Внедрение новых пакетов</p>
</li>
<li>
<p>Задержка пакетов</p>
</li>
<li>
<p>Переупорядочивание пакетов</p>
</li>
<li>
<p>Сбрасывать пакеты</p>
</li>
<li>
<p>Разделение и объединение датаграмм по границам пакетов</p>
</li>
</ul>
<p>Атакующий на пути не может:</p>
<ul>
<li>Изменить аутентифицированную часть пакета и заставить
получателя принять этот пакет</li>
</ul>
<p>Атакующий, находящийся на пути передачи данных, имеет возможность модифицировать наблюдаемые им пакеты; однако любые изменения аутентифицированной части пакета приведут к тому, что он будет отброшен принимающей стороной как недействительный, поскольку полезная нагрузка пакетов как аутентифицируется, так и шифруется.</p>
<p>QUIC направлен на ограничение возможностей атакующего на пути передачи данных следующим образом:</p>
<ol>
<li>
<p>Атакующий на пути может предотвратить использование пути для
соединения, что приведет к сбою соединения, если оно не может использовать
другой путь, не содержащий атакующего. Это может быть достигнуто путем
отбрасывания всех пакетов, их модификации таким образом, чтобы они не
смогли быть расшифрованы, или другими методами.</p>
</li>
<li>
<p>Атакующий на пути может предотвратить миграцию на новый путь, на котором
атакующий также находится, вызвав сбой валидации пути
на новом пути.</p>
</li>
<li>
<p>Атакующий на пути не может помешать клиенту мигрировать на
путь, на котором атакующий не находится.</p>
</li>
<li>
<p>Атакующий на пути передачи данных может снизить пропускную способность соединения, задерживая пакеты или отбрасывая их.</p>
</li>
<li>
<p>Атакующий на пути передачи данных не может заставить конечную точку принять пакет,
аутентифицированная часть которого была им модифицирована.</p>
</li>
</ol>
<h4 id="off-path-active-attacks">Off-Path Active Attacks</h4>
<p>Атакующий вне пути не находится непосредственно на пути между клиентом и сервером, но может получить копии некоторых или всех пакетов, отправляемых между клиентом и сервером. Он также может отправлять копии этих пакетов любой из конечных точек.</p>
<p>Атакующий вне маршрута может:</p>
<ul>
<li>
<p>Проверка пакетов</p>
</li>
<li>
<p>Внедрение новых пакетов</p>
</li>
<li>
<p>Переупорядочить внедренные пакеты</p>
</li>
</ul>
<p>Атакующий вне пути не может:</p>
<ul>
<li>
<p>Изменение пакетов, отправляемых конечными точками</p>
</li>
<li>
<p>Задержка пакетов</p>
</li>
<li>
<p>Отбрасывать пакеты</p>
</li>
<li>
<p>Переупорядочить исходные пакеты</p>
</li>
</ul>
<p>Атакующий вне пути может создавать модифицированные копии пакетов, которые он наблюдал, и внедрять эти копии в сеть, потенциально с подделанными адресами источника и назначения.</p>
<p>Для целей данного обсуждения предполагается, что атакующий, находящийся вне пути передачи данных, имеет возможность внедрить модифицированную копию пакета в сеть, которая достигнет конечной точки назначения раньше прибытия оригинального пакета, наблюдаемого атакующим. Иными словами, атакующий имеет возможность постоянно &ldquo;выигрывать&rdquo; в гонке с легитимными пакетами между конечными точками, потенциально приводя к тому, что оригинальный пакет будет проигнорирован получателем.</p>
<p>Также предполагается, что злоумышленник обладает ресурсами, необходимыми для воздействия на состояние NAT. В частности, злоумышленник может заставить конечную точку потерять свою NAT-привязку, а затем получить тот же порт для использования в своем собственном трафике.</p>
<p>QUIC нацелен на ограничение возможностей атакующего вне маршрута следующим образом:</p>
<ol>
<li>
<p>Атакующий вне маршрута может участвовать в гонке пакетов и пытаться стать &ldquo;ограниченным&rdquo; атакующим на маршруте.</p>
</li>
<li>
<p>Атакующий вне маршрута может заставить проверку пути успешно пройти для пересылаемых пакетов с исходным адресом, указанным как атакующий вне маршрута, при условии, что он может обеспечить улучшенную связность между клиентом и сервером.</p>
</li>
<li>
<p>Атакующий вне маршрута не может вызвать закрытие соединения после завершения handshake.</p>
</li>
<li>
<p>Атакующий вне пути не может вызвать сбой миграции на новый путь,
если он не может наблюдать новый путь.</p>
</li>
<li>
<p>Атакующий вне маршрута может стать ограниченным атакующим на маршруте во время миграции на новый путь, для которого он также является атакующим вне маршрута.</p>
</li>
<li>
<p>Атакующий вне пути может стать ограниченным атакующим на пути, воздействуя на общее состояние NAT таким образом, чтобы он отправлял пакеты на сервер с того же IP-адреса и порта, которые изначально использовал клиент.</p>
</li>
</ol>
<h4 id="обзор-свойств-безопасности">Обзор свойств безопасности</h4>
<p>Ограниченный атакующий на пути - это атакующий вне пути, который предложил улучшенную маршрутизацию пакетов путем дублирования и пересылки оригинальных пакетов между сервером и клиентом, заставляя эти пакеты прибывать раньше оригинальных копий, так что оригинальные пакеты отбрасываются конечной точкой назначения.</p>
<p>Ограниченный атакующий на пути отличается от атакующего на пути тем, что он не находится на исходном пути между конечными точками, и поэтому исходные пакеты, отправленные конечной точкой, всё ещё достигают места назначения. Это означает, что будущая неспособность маршрутизировать скопированные пакеты к месту назначения быстрее, чем по их исходному пути, не помешает исходным пакетам достичь места назначения.</p>
<p>Ограниченный атакующий на пути может:</p>
<ul>
<li>
<p>Проверка пакетов</p>
</li>
<li>
<p>Внедрение новых пакетов</p>
</li>
<li>
<p>Изменение незашифрованных заголовков пакетов</p>
</li>
<li>
<p>Переупорядочить пакеты</p>
</li>
</ul>
<p>Ограниченный атакующий на пути не может:</p>
<ul>
<li>
<p>Задерживать пакеты так, чтобы они приходили позже пакетов, отправленных по
исходному пути</p>
</li>
<li>
<p>Отбрасывать пакеты</p>
</li>
<li>
<p>Изменить аутентифицированную и зашифрованную часть пакета и
заставить получателя принять этот пакет</p>
</li>
</ul>
<p>Ограниченный атакующий на пути может только задерживать пакеты до того момента, когда оригинальные пакеты прибудут раньше дублированных пакетов, что означает, что он не может предложить маршрутизацию с худшей задержкой, чем оригинальный путь. Если ограниченный атакующий на пути отбрасывает пакеты, оригинальная копия всё равно прибудет в конечную точку назначения.</p>
<p>QUIC нацелен на ограничение возможностей ограниченного внепутевого злоумышленника следующим образом:</p>
<ol>
<li>
<p>Ограниченный атакующий на пути не может закрыть соединение
после завершения handshake.</p>
</li>
<li>
<p>Ограниченный атакующий на пути передачи данных не может закрыть неактивное соединение, если клиент первым возобновляет активность.</p>
</li>
<li>
<p>Ограниченный атакующий на пути может привести к тому, что бездействующее соединение будет считаться потерянным, если сервер первым возобновит активность.</p>
</li>
</ol>
<p>Обратите внимание, что эти гарантии являются теми же гарантиями, которые предоставляются для любого NAT, по тем же причинам.</p>
<h4 id="рукопожатие">Рукопожатие</h4>
<p>Как зашифрованный и аутентифицированный транспорт, QUIC обеспечивает широкий спектр защиты от атак типа отказ в обслуживании. После завершения криптографического рукопожатия, QUIC-конечные точки отбрасывают большинство пакетов, которые не прошли аутентификацию, что значительно ограничивает возможность злоумышленника вмешиваться в существующие соединения.</p>
<p>После установления соединения QUIC endpoints могут принимать некоторые неаутентифицированные ICMP-пакеты (см. раздел 14.2.1), но использование этих пакетов крайне ограничено. Единственным другим типом пакетов, который endpoint может принимать, является stateless reset (раздел 10.3), который полагается на то, что токен остается секретным до момента его использования.</p>
<p>Во время создания соединения QUIC обеспечивает защиту только от атак извне сетевого пути. Все QUIC-пакеты содержат подтверждение того, что получатель видел предыдущий пакет от своего узла.</p>
<p>Адреса не могут изменяться во время handshake, поэтому конечные точки могут отбрасывать пакеты, полученные по другому сетевому пути.</p>
<p>Поля Source и Destination Connection ID являются основным средством защиты от атак вне пути во время рукопожатия; см. раздел 8.1. Они должны соответствовать тем, что установлены узлом. За исключением Initial и Stateless Resets, конечная точка принимает только пакеты, которые включают поле Destination Connection ID, соответствующее значению, ранее выбранному конечной точкой. Это единственная защита, предоставляемая для пакетов Version Negotiation.</p>
<p>Поле Destination Connection ID в Initial-пакете выбирается клиентом как непредсказуемое, что служит дополнительной цели. Пакеты, которые несут криптографическое рукопожатие, защищены ключом, который выводится из этого connection ID и соли, специфичной для версии QUIC. Это позволяет конечным точкам использовать тот же процесс для аутентификации получаемых пакетов, который они используют после завершения криптографического рукопожатия. Пакеты, которые не могут быть аутентифицированы, отбрасываются. Защита пакетов таким образом обеспечивает надежную гарантию того, что отправитель пакета видел Initial-пакет и понял его.</p>
<p>Эти меры защиты не предназначены для эффективной работы против злоумышленника, который способен получать QUIC-пакеты до установления соединения. Такой злоумышленник потенциально может отправлять пакеты, которые будут приняты QUIC endpoints. Данная версия QUIC пытается обнаружить подобного рода атаку, но ожидается, что endpoints не смогут установить соединение, а не восстановятся. По большей части, криптографический протокол handshake <a href="https://datatracker.ietf.org/doc/html/rfc9001">QUIC-TLS</a>
 отвечает за обнаружение несанкционированного вмешательства во время handshake.</p>
<p>Конечным точкам разрешается использовать другие методы для обнаружения и попытки восстановления после вмешательства в рукопожатие. Недействительные пакеты могут быть идентифицированы и отброшены с использованием других методов, но конкретный метод не предписан в данном документе.</p>
<h4 id="противодействие-усилению">Противодействие усилению</h4>
<p>Злоумышленник может получить токен валидации адреса (Раздел 8) от сервера, а затем освободить IP-адрес, который использовался для получения этого токена. Позднее злоумышленник может инициировать 0-RTT соединение с сервером, подменив этот же адрес, который теперь может принадлежать другой (жертве) конечной точке. Таким образом, злоумышленник потенциально может заставить сервер отправить объем данных размером с начальное окно перегрузки в направлении жертвы.</p>
<p>Серверы ДОЛЖНЫ предоставлять меры защиты от этой атаки путем ограничения использования и времени жизни токенов валидации адресов; см. Раздел 8.1.3.</p>
<h4 id="dos-на-стороне-сервера">DoS на стороне сервера</h4>
<p>Конечная точка, которая подтверждает пакеты, которые она не получила, может заставить контроллер перегрузок разрешить отправку со скоростями, превышающими те, которые поддерживает сеть. Конечная точка МОЖЕТ пропускать номера пакетов при отправке пакетов для обнаружения такого поведения. Конечная точка может затем немедленно закрыть соединение с ошибкой соединения типа PROTOCOL_VIOLATION; см. Раздел 10.2.</p>
<h4 id="завершение-handshake-на-пути-передачи">Завершение handshake на пути передачи</h4>
<p>Атака подделки запросов происходит, когда конечная точка заставляет своего партнера отправить запрос к жертве, при этом запрос контролируется конечной точкой. Атаки подделки запросов направлены на предоставление злоумышленнику доступа к возможностям его партнера, которые иначе могут быть недоступны злоумышленнику. Для сетевого протокола атака подделки запросов часто используется для эксплуатации любой неявной авторизации, предоставленной партнеру жертвой из-за местоположения партнера в сети.</p>
<p>Для эффективной подделки запросов злоумышленнику необходимо иметь возможность влиять на то, какие пакеты отправляет peer и куда эти пакеты направляются. Если злоумышленник может нацелить уязвимую службу с контролируемой полезной нагрузкой, эта служба может выполнить действия, которые приписываются peer&rsquo;у злоумышленника, но решения о которых принимает злоумышленник.</p>
<p>Например, эксплойты межсайтовой подделки запроса <a href="https://owasp.org/www-community/attacks/csrf">CSRF</a>
 в Интернете заставляют клиента отправлять запросы, которые включают авторизационные cookies <a href="https://datatracker.ietf.org/doc/html/rfc6265">COOKIE</a>
, позволяя одному сайту получить доступ к информации и действиям, которые предназначены для ограничения другим сайтом.</p>
<p>Поскольку QUIC работает поверх UDP, основной тип атаки, вызывающий беспокойство, — это атака, при которой злоумышленник может выбирать адрес, на который его узел отправляет UDP-дейтаграммы, и может контролировать часть незащищенного содержимого этих пакетов. Поскольку большая часть данных, отправляемых конечными точками QUIC, защищена, это включает контроль над зашифрованным текстом. Атака считается успешной, если злоумышленник может заставить узел отправить UDP-дейтаграмму на хост, который выполнит какое-либо действие на основе содержимого дейтаграммы.</p>
<p>Этот раздел обсуждает способы, которыми QUIC может быть использован для атак подделки запросов.</p>
<p>В данном разделе также описываются ограниченные контрмеры, которые могут быть реализованы конечными точками QUIC. Эти средства защиты могут применяться в одностороннем порядке реализацией или развертыванием QUIC без необходимости принятия мер со стороны потенциальных целей атак подделки запросов. Однако эти контрмеры могут оказаться недостаточными, если UDP-сервисы не осуществляют должную авторизацию запросов.</p>
<p>Поскольку атака миграции, описанная в разделе 21.5.4, довольно мощная и не имеет адекватных контрмер, реализации QUIC-серверов должны предполагать, что злоумышленники могут заставить их генерировать произвольные UDP-пакеты для произвольных назначений. QUIC-серверы НЕ ДОЛЖНЫ развертываться в сетях, которые не используют входящую фильтрацию <a href="https://datatracker.ietf.org/doc/html/rfc2827">BCP38</a>
 и также имеют недостаточно защищенные UDP-конечные точки.</p>
<p>Хотя в общем случае невозможно гарантировать, что клиенты не находятся в одном месте с уязвимыми конечными точками, данная версия QUIC не позволяет серверам выполнять миграцию, тем самым предотвращая атаки с подделкой миграции на клиентов. Любое будущее расширение, которое разрешает миграцию серверов, ДОЛЖНО также определять контрмеры против атак подделки.</p>
<h4 id="согласование-параметров">Согласование параметров</h4>
<p>QUIC предоставляет злоумышленнику некоторые возможности для влияния или контроля того, куда его узел отправляет UDP дейтаграммы:</p>
<ul>
<li>
<p>установление первоначального соединения (раздел 7), где сервер
может выбирать, куда клиент отправляет датаграммы &ndash; например, путем
заполнения DNS записей;</p>
</li>
<li>
<p>предпочтительные адреса (Раздел 9.6), где сервер может
выбрать, куда клиент отправляет датаграммы;</p>
</li>
<li>
<p>подделанные миграции соединений (Раздел 9.3.1), где клиент
может использовать подделку исходного адреса для выбора места, куда сервер отправляет
последующие дейтаграммы; и</p>
</li>
<li>
<p>поддельные пакеты, которые заставляют сервер отправить пакет
Version Negotiation (Раздел 21.5.5).</p>
</li>
</ul>
<p>Во всех случаях атакующий может заставить своего узла отправлять датаграммы жертве, которая может не понимать QUIC. То есть, эти пакеты отправляются узлом до проверки адреса; см. Раздел 8.</p>
<p>За пределами зашифрованной части пакетов QUIC предоставляет конечной точке несколько вариантов для управления содержимым UDP-дейтаграмм, которые отправляет её партнёр. Поле Destination Connection ID обеспечивает прямое управление байтами, которые появляются в начале пакетов, отправляемых партнёром; см. Раздел 5.1. Поле Token в Initial пакетах предоставляет серверу контроль над другими байтами Initial пакетов; см. Раздел 17.2.2.</p>
<p>В данной версии QUIC отсутствуют меры по предотвращению косвенного контроля над зашифрованными частями пакетов. Необходимо предполагать, что конечные точки способны контролировать содержимое фреймов, которые отправляет узел-партнер, особенно те фреймы, которые передают данные приложения, такие как STREAM фреймы. Хотя это в некоторой степени зависит от деталей протокола приложения, определенный контроль возможен во многих контекстах использования протокола. Поскольку у атакующего есть доступ к ключам защиты пакетов, он, вероятно, способен предсказать, как узел-партнер будет шифровать будущие пакеты. Успешный контроль над содержимым датаграммы тогда требует только того, чтобы атакующий был способен с некоторой степенью надежности предсказать номер пакета и размещение фреймов в пакетах.</p>
<p>В данном разделе предполагается, что ограничение контроля над содержимым датаграмм неосуществимо. Меры защиты в последующих разделах сосредоточены на ограничении способов использования датаграмм, отправленных до валидации адреса, для подделки запросов.</p>
<h4 id="защищённые-пакеты">Защищённые пакеты</h4>
<p>Злоумышленник, действующий в качестве сервера, может выбирать IP-адрес и порт, на которых он рекламирует свою доступность, поэтому начальные пакеты от клиентов предположительно доступны для использования в атаках такого типа. Проверка адреса, неявно присутствующая в handshake, гарантирует, что — для нового соединения — клиент не будет отправлять другие типы пакетов в место назначения, которое не понимает QUIC или не желает принимать QUIC-соединение.</p>
<p>Защита начальных пакетов (Раздел 5.2 <a href="https://datatracker.ietf.org/doc/html/rfc9001">QUIC-TLS</a>
) затрудняет для серверов контроль содержимого начальных пакетов, отправляемых клиентами. Клиент, выбирающий непредсказуемый идентификатор соединения назначения, гарантирует, что серверы не смогут контролировать любую часть зашифрованной части начальных пакетов от клиентов.</p>
<p>Однако поле Token подвержено контролю со стороны сервера и позволяет серверу использовать клиентов для осуществления атак подделки запросов. Использование токенов, предоставляемых с помощью фрейма NEW_TOKEN (Раздел 8.1.3), предлагает единственный вариант для подделки запросов во время установления соединения.</p>
<p>Клиенты, однако, не обязаны использовать кадр NEW_TOKEN. Атак подделки запросов, которые основываются на поле Token, можно избежать, если клиенты отправляют пустое поле Token, когда адрес сервера изменился с момента получения кадра NEW_TOKEN.</p>
<p>Клиенты могли бы избежать использования NEW_TOKEN, если адрес сервера изменяется. Однако отсутствие поля Token может негативно сказаться на производительности. Серверы могли бы полагаться на NEW_TOKEN для обеспечения отправки данных сверх трёхкратного ограничения на отправку данных; см. раздел 8.1. В частности, это затрагивает случаи, когда клиенты используют 0-RTT для запроса данных с серверов.</p>
<p>Отправка пакета Retry (Раздел 17.2.5) предоставляет серверу возможность изменить поле Token. После отправки Retry сервер также может контролировать поле Destination Connection ID последующих пакетов Initial от клиента. Это также может позволить косвенное управление зашифрованным содержимым пакетов Initial. Однако обмен пакетом Retry подтверждает адрес сервера, тем самым предотвращая использование последующих пакетов Initial для подделки запросов.</p>
<h4 id="миграция-соединений">Миграция соединений</h4>
<p>Серверы могут указать предпочтительный адрес, на который клиенты затем мигрируют после подтверждения handshake; см. раздел 9.6. Поле Destination Connection ID пакетов, которые клиент отправляет на предпочтительный адрес, может быть использовано для подделки запросов.</p>
<p>Клиент НЕ ДОЛЖЕН отправлять не-зондирующие фреймы на предпочтительный адрес до валидации этого адреса; см. Раздел 8. Это значительно сокращает возможности сервера по контролю зашифрованной части датаграмм.</p>
<p>Данный документ не предлагает никаких дополнительных контрмер, которые специфичны для использования предпочтительных адресов и могут быть реализованы endpoints. Общие меры, описанные в разделе 21.5.6, могут быть использованы для дополнительного смягчения угроз.</p>
<h4 id="активные-атаки-на-пути-передачи-данных">Активные атаки на пути передачи данных</h4>
<p>Клиенты могут представить поддельный адрес источника в рамках кажущейся миграции соединения, чтобы заставить сервер отправлять датаграммы на этот адрес.</p>
<p>Поле Destination Connection ID в любых пакетах, которые сервер впоследствии отправляет на этот поддельный адрес, может быть использовано для подделки запросов. Клиент также может влиять на шифртекст.</p>
<p>Сервер, который отправляет только пробные пакеты (Раздел 9.1) на адрес до проверки адреса, предоставляет атакующему только ограниченный контроль над зашифрованной частью датаграмм. Однако, особенно для NAT rebinding, это может негативно повлиять на производительность. Если сервер отправляет фреймы с данными приложения, атакующий может получить возможность контролировать большую часть содержимого датаграмм.</p>
<p>Данный документ не предлагает конкретных контрмер, которые могут быть реализованы конечными точками, помимо общих мер, описанных в разделе 21.5.6. Однако контрмеры против подмены адресов на сетевом уровне — в частности, входящая фильтрация <a href="https://datatracker.ietf.org/doc/html/rfc2827">BCP38</a>
 — особенно эффективны против атак, использующих подмену и исходящих из внешней сети.</p>
<h4 id="атаки-с-использованием-активного-воздействия-вне-маршрута">Атаки с использованием активного воздействия вне маршрута</h4>
<p>Клиенты, которые могут представить подделанный адрес источника в пакете, могут заставить сервер отправить пакет Version Negotiation (раздел 17.2.1) на этот адрес.</p>
<p>Отсутствие ограничений по размеру полей идентификатора соединения для пакетов неизвестной версии увеличивает объем данных, которые клиент контролирует в результирующей датаграмме. Первый байт этого пакета не находится под контролем клиента, и следующие четыре байта равны нулю, но клиент может контролировать до 512 байт, начиная с пятого байта.</p>
<p>Специальные контрмеры против данной атаки не предусмотрены, хотя могут применяться общие средства защиты (Раздел 21.5.6). В данном случае также эффективна фильтрация входящего трафика <a href="https://datatracker.ietf.org/doc/html/rfc2827">BCP38</a>
.</p>
<h4 id="ограниченные-активные-атаки-по-маршруту">Ограниченные активные атаки по маршруту</h4>
<p>Наиболее эффективной защитой от атак с подделкой запросов является модификация уязвимых служб для использования строгой аутентификации. Однако это не всегда находится под контролем развертывания QUIC. В данном разделе описываются некоторые другие шаги, которые QUIC-конечные точки могли бы предпринять в одностороннем порядке. Все эти дополнительные шаги являются дискреционными, поскольку, в зависимости от обстоятельств, они могут помешать или предотвратить законное использование.</p>
<p>Сервисы, предоставляемые через loopback-интерфейсы, часто не имеют надлежащей аутентификации. Конечные точки МОГУТ предотвращать попытки подключения или миграцию на loopback-адрес. Конечные точки НЕ ДОЛЖНЫ разрешать подключения или миграцию на loopback-адрес, если тот же сервис был ранее доступен на другом интерфейсе или если адрес был предоставлен сервисом с не-loopback адреса. Конечные точки, которые зависят от этих возможностей, могут предложить опцию для отключения этих защитных мер.</p>
<p>Аналогично, конечные точки могли бы рассматривать изменение адреса на link-local адрес <a href="https://datatracker.ietf.org/doc/html/rfc4291">RFC4291</a>
 или адрес в диапазоне частного использования <a href="https://datatracker.ietf.org/doc/html/rfc1918">RFC1918</a>
 с глобального, unique-local <a href="https://datatracker.ietf.org/doc/html/rfc4193">RFC4193</a>
 или не частного адреса как потенциальную попытку подделки запроса. Конечные точки могли бы полностью отказаться от использования таких адресов, но это несет значительный риск вмешательства в законное использование. Конечные точки НЕ ДОЛЖНЫ отказываться от использования адреса, если у них нет конкретных знаний о сети, указывающих на то, что отправка датаграмм на непроверенные адреса в данном диапазоне небезопасна.</p>
<p>Конечные точки МОГУТ выбрать снижение риска подделки запросов, не включая значения из фреймов NEW_TOKEN в пакеты Initial или отправляя только пробные фреймы в пакетах до завершения проверки адреса. Обратите внимание, что это не предотвращает использование атакующим поля Destination Connection ID для атаки.</p>
<p>Конечные точки не должны иметь специфической информации о расположении серверов, которые могли бы стать уязвимыми целями атаки подделки запросов. Однако со временем может стать возможным выявление определенных UDP-портов, которые являются распространенными целями атак, или конкретных шаблонов в датаграммах, используемых для атак. Конечные точки МОГУТ выбрать избегание отправки датаграмм на эти порты или не отправлять датаграммы, соответствующие этим шаблонам, до проверки адреса назначения. Конечные точки МОГУТ отзывать идентификаторы соединений, содержащие шаблоны, известные как проблемные, без их использования.</p>
<p>Примечание: Изменение конечных точек для применения этих мер защиты более эффективно, чем развертывание сетевых средств защиты, поскольку конечным точкам не требуется выполнять дополнительную обработку при отправке на адрес, который был проверен.</p>
<h4 id="отказ-в-обслуживании-при-рукопожатии">Отказ в обслуживании при рукопожатии</h4>
<p>Атаки, широко известные как Slowloris <a href="https://owasp.org/www-community/attacks/Slowloris_Attack">SLOWLORIS</a>
, пытаются поддерживать множество соединений с целевой конечной точкой открытыми и удерживать их открытыми как можно дольше. Эти атаки могут быть выполнены против QUIC-конечной точки путем генерирования минимального количества активности, необходимой для избежания закрытия из-за бездействия. Это может включать отправку небольших объемов данных, постепенное открытие окон управления потоком для контроля скорости отправителя или изготовление ACK-фреймов, которые имитируют высокий уровень потерь.</p>
<p>Развертывания QUIC ДОЛЖНЫ обеспечивать средства защиты от атак Slowloris, такие как увеличение максимального количества клиентов, которое сервер будет обслуживать, ограничение количества соединений, которые может устанавливать один IP-адрес, наложение ограничений на минимальную скорость передачи данных для соединения, и ограничение времени, в течение которого конечная точка может оставаться подключенной.</p>
<h4 id="атака-усиления">Атака усиления</h4>
<p>Злонамеренный отправитель может намеренно не отправлять части данных потока, заставляя получателя выделять ресурсы для неотправленных данных. Это может привести к непропорциональному выделению памяти для буфера приема и/или созданию большой и неэффективной структуры данных на стороне получателя.</p>
<p>Злонамеренный получатель может намеренно не подтверждать пакеты, содержащие потоковые данные, пытаясь заставить отправителя хранить неподтвержденные потоковые данные для повторной передачи.</p>
<p>Атака на получателей смягчается, если окна управления потоком соответствуют доступной памяти. Однако некоторые получатели будут избыточно выделять память и рекламировать смещения управления потоком в совокупности, которые превышают фактически доступную память. Стратегия избыточного выделения может привести к лучшей производительности, когда конечные точки ведут себя корректно, но делает конечные точки уязвимыми к атаке фрагментации потока.</p>
<p>QUIC развертывания ДОЛЖНЫ обеспечивать меры защиты от атак фрагментации потоков. Меры защиты могут состоять из избегания чрезмерного выделения памяти, ограничения размера структур данных отслеживания, задержки повторной сборки STREAM фреймов, реализации эвристик на основе возраста и продолжительности дыр в повторной сборке, или некоторой комбинации этих методов.</p>
<h4 id="атака-оптимистичного-ack">Атака оптимистичного ACK</h4>
<p>Злонамеренная конечная точка может открыть большое количество потоков, исчерпывая состояние на конечной точке. Злонамеренная конечная точка может повторить этот процесс для большого количества соединений, подобно атакам SYN flooding в TCP.</p>
<p>Обычно клиенты будут открывать потоки последовательно, как объясняется в Разделе 2.1. Однако, когда несколько потоков инициируются через короткие интервалы, потери или переупорядочивание могут привести к тому, что кадры STREAM, которые открывают потоки, будут получены не по порядку. При получении ID потока с большим номером получатель обязан открыть все промежуточные потоки того же типа; см. Раздел 3.2. Таким образом, при новом соединении открытие потока 4000000 открывает 1 миллион и 1 инициированный клиентом двунаправленный поток.</p>
<p>Количество активных потоков ограничено транспортными параметрами initial_max_streams_bidi и initial_max_streams_uni, которые обновляются любыми полученными фреймами MAX_STREAMS, как объясняется в разделе 4.6. При разумном выборе эти ограничения смягчают эффект атаки обязательства потоков. Однако установка слишком низкого ограничения может повлиять на производительность, когда приложения ожидают открытия большого количества потоков.</p>
<h4 id="атаки-с-подделкой-запросов">Атаки с подделкой запросов</h4>
<p>QUIC и TLS содержат кадры или сообщения, которые имеют законные применения в некоторых контекстах, но эти кадры или сообщения могут быть использованы злонамеренно для принуждения узла к расходованию вычислительных ресурсов без какого-либо наблюдаемого воздействия на состояние соединения.</p>
<p>Сообщения также могут использоваться для изменения и возврата состояния незначительными или несущественными способами, например, путем отправки небольших приращений к лимитам управления потоком.</p>
<p>Если затраты на обработку непропорционально велики по сравнению с потреблением полосы пропускания или влиянием на состояние, то это может позволить злонамеренному узлу исчерпать вычислительную мощность.</p>
<p>Хотя все сообщения имеют законные варианты использования, реализации ДОЛЖНЫ отслеживать стоимость обработки относительно прогресса и рассматривать чрезмерное количество любых непродуктивных пакетов как признак атаки. Конечные точки МОГУТ отвечать на это условие ошибкой соединения или сбросом пакетов.</p>
<h4 id="параметры-управления-для-конечных-точек">Параметры управления для конечных точек</h4>
<p>Атакующий на пути следования пакетов может манипулировать значением полей ECN в IP-заголовке, чтобы повлиять на скорость отправителя. <a href="https://datatracker.ietf.org/doc/html/rfc3168">RFC3168</a>
 более подробно обсуждает манипуляции и их эффекты.</p>
<p>Ограниченный атакующий на пути может дублировать и отправлять пакеты с модифицированными полями ECN, чтобы повлиять на скорость отправителя. Если дублированные пакеты отбрасываются получателем, атакующему потребуется опередить дублированный пакет по отношению к оригинальному, чтобы добиться успеха в этой атаке. Поэтому конечные точки QUIC игнорируют поле ECN в IP-пакете, если по крайней мере один пакет QUIC в этом IP-пакете не был успешно обработан; см. раздел 13.4.</p>
<h4 id="подделка-запросов-с-помощью-начальных-пакетов-клиента">Подделка запросов с помощью начальных пакетов клиента</h4>
<p>Stateless сбросы создают возможную атаку типа «отказ в обслуживании», аналогичную инъекции TCP reset. Эта атака возможна, если злоумышленник способен заставить сгенерировать stateless reset token для соединения с выбранным connection ID. Злоумышленник, который может заставить сгенерировать этот токен, может сбросить активное соединение с тем же connection ID.</p>
<p>Если пакет может быть направлен к различным экземплярам, которые используют один статический ключ &ndash; например, путем изменения IP-адреса или порта &ndash; то злоумышленник может заставить сервер отправить сброс без сохранения состояния. Для защиты от подобного типа отказа в обслуживании, конечные точки, которые используют общий статический ключ для сбросов без сохранения состояния (см. Раздел 10.3.2), ДОЛЖНЫ быть организованы таким образом, чтобы пакеты с данным идентификатором соединения всегда поступали к экземпляру, который имеет состояние соединения, если только это соединение больше не активно.</p>
<p>В более общем случае серверы НЕ ДОЛЖНЫ генерировать stateless reset, если соединение с соответствующим connection ID может быть активным на любой конечной точке, использующей тот же статический ключ.</p>
<p>В случае кластера, который использует динамическую балансировку нагрузки, возможно, что изменение конфигурации балансировщика нагрузки может произойти в то время, когда активный экземпляр сохраняет состояние соединения. Даже если экземпляр сохраняет состояние соединения, изменение маршрутизации и последующий сброс без состояния приведут к завершению соединения. Если нет возможности направить пакет к правильному экземпляру, лучше отправить сброс без состояния, чем ждать истечения времени ожидания соединения. Однако это приемлемо только в том случае, если на маршрутизацию не может повлиять злоумышленник.</p>
<h4 id="подделка-запросов-с-предпочтительными-адресами">Подделка запросов с предпочтительными адресами</h4>
<p>Данный документ определяет пакеты согласования версии QUIC (Раздел 6), которые могут использоваться для согласования версии QUIC между двумя конечными точками. Однако данный документ не определяет, как будет выполняться это согласование между данной версией и последующими будущими версиями. В частности, пакеты согласования версии не содержат никакого механизма для предотвращения атак понижения версии. Будущие версии QUIC, использующие пакеты согласования версии, ДОЛЖНЫ определять механизм, который устойчив против атак понижения версии.</p>
<h4 id="подделка-запроса-со-спуфингом-миграции">Подделка запроса со спуфингом миграции</h4>
<p>Развертывания должны ограничивать возможность атакующего направлять новое соединение на конкретный экземпляр сервера. В идеале решения о маршрутизации принимаются независимо от значений, выбранных клиентом, включая адреса. После выбора экземпляра можно выбрать идентификатор соединения таким образом, чтобы последующие пакеты маршрутизировались на тот же экземпляр.</p>
<h4 id="подделка-запроса-с-согласованием-версии">Подделка запроса с согласованием версии</h4>
<p>Длина QUIC пакетов может раскрывать информацию о длине содержимого этих пакетов. Фрейм PADDING предоставляется для того, чтобы конечные точки имели некоторую возможность скрыть длину содержимого пакета; см. Раздел 19.1.</p>
<p>Победить анализ трафика сложно, и это является предметом активных исследований. Длина — не единственный способ утечки информации. Конечные точки также могут раскрывать конфиденциальную информацию через другие побочные каналы, такие как временные характеристики пакетов.</p>
<h3 id="relay-security">Relay Security</h3>
<p>Ниже приведен анализ Relay Request, Relay Response, Relay Intro и Hole Punch в SSU1.</p>
<p>Ограничения: Важно, чтобы Relay были быстрыми. Количество циклов передачи данных должно быть минимизировано. Пропускная способность и процессор не так важны.</p>
<p>SSU 1: Алиса сначала подключается к introducer Бобу, который передает запрос Чарли (который находится за файрволом). После hole punch сессия устанавливается между Алисой и Чарли как при прямом установлении соединения.</p>
<pre tabindex="0"><code>Alice                         Bob                  Charlie
1. RelayRequest ----------------------&gt;
2.      &lt;-------------- RelayResponse    RelayIntro -----------&gt;
3.      &lt;-------------------------------------------- HolePunch
4. SessionRequest --------------------------------------------&gt;
5.      &lt;-------------------------------------------- SessionCreated
6. SessionConfirmed ------------------------------------------&gt;
</code></pre><p>Аутентификация: Relay Request и Relay Response не защищены безопасной аутентификацией, поскольку Alice и Bob обычно не имеют существующей сессии; эти сообщения используют опубликованные intro ключи. Внутрисессионные Relay Request/Response разрешены и предпочтительны, если сессия существует.</p>
<p>Relay Intro от Bob к Charlie требуется в существующей сессии, поэтому предполагается безопасным.</p>
<p>Bob может подделать Relay Intros или изменить IP/порт из Relay Request. Отсутствуют механизмы для криптографической привязки запросов к интро или иного предотвращения или обнаружения злонамеренных Bob.</p>
<p>Хеш router&rsquo;а Боба в настоящее время не опубликован в Router Info Чарли, поэтому это необходимо добавить, если мы хотим, чтобы сообщения Алиса-Боб были аутентифицированы. Дополнительно, другие параметры SSU2 должны были бы быть опубликованы в Router Info Чарли, или Алисе пришлось бы искать Router Info Боба в netDb, что добавило бы дополнительную задержку. Аутентификация добавила бы обмен данными туда-обратно между Алисой и Бобом.</p>
<p>Передавая хеш router&rsquo;а Алисы Чарли, Чарли мог бы легче определить, желает ли он получить соединение от Алисы, проверив локальный список запрещенных. Не существует механизма для Чарли отклонить релей, отправив отказ через Боба Алисе. Не существует механизма для Чарли принять релей, отправив подтверждение через Боба Алисе. Алиса должна ждать HolePunch или просто отправить SessionRequest вслепую. HolePunch может прийти с другого порта, чем ожидала Алиса, из-за NAT, что может затруднить распознавание того, от какого router&rsquo;а пришел HolePunch.</p>
<p>Алиса могла бы отправить свою полную Router Info в Relay Request к Бобу и переслать Чарли в Relay Intro.</p>
<p>Relay Request не содержит временную метку, поэтому у него нет защиты от повторных атак. Исходный IP может быть подделан, чтобы заставить Чарли отправить Hole Punch на любой IP/порт. Relay Request не подписан, и даже если бы был подписан и содержал временную метку, у Чарли нет полной Router Identity для возможности проверить подпись.</p>
<p>Протокол определяет поле вызова переменной длины 0-255 байт. Вызов в Relay Request передается Чарли в Relay Intro. Однако протокол не указывает, как создавать, использовать или проверять вызов, и это не реализовано. Если бы HolePunch содержал вызов, Алиса смогла бы легко соотнести HolePunch с Чарли.</p>
<p>Четырехбайтовый nonce может потребоваться заменить или дополнить 8-байтовым connection ID.</p>
<p>Пустое сообщение Hole Punch является уникальным и может использоваться наблюдателями на пути для идентификации протокола, это следует изменить.</p>
<h3 id="дополнительное-обсуждение-dpi">Дополнительное обсуждение DPI</h3>
<p>Далее приводится анализ Peer Test в SSU1.</p>
<p>Ограничения: Не особенно важно, чтобы тесты пиров были быстрыми, низкополосными или требовали мало процессорного времени, за исключением, возможно, запуска router&rsquo;а, где мы предпочитаем, чтобы router довольно быстро обнаружил свою доступность.</p>
<p>SSU 1:</p>
<pre tabindex="0"><code>Alice                     Bob                  Charlie
1. PeerTest -------------------&gt;
2.                          PeerTest--------------------&gt;
3.                             &lt;-------------------PeerTest
4.      &lt;-------------------PeerTest

5.      &lt;------------------------------------------PeerTest
6. PeerTest------------------------------------------&gt;
7.      &lt;------------------------------------------PeerTest
</code></pre><p>Поскольку спецификацию SSU1 сложно понять, мы документируем содержимое сообщений ниже.</p>
<table>
  <thead>
      <tr>
          <th>Message</th>
          <th>Path</th>
          <th>Alice IP incl?</th>
          <th>Intro Key</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>A-&gt;B session</td>
          <td>no</td>
          <td>Alice</td>
      </tr>
      <tr>
          <td>2</td>
          <td>B-&gt;C session</td>
          <td>yes</td>
          <td>Alice</td>
      </tr>
      <tr>
          <td>3</td>
          <td>C-&gt;B session</td>
          <td>yes</td>
          <td>Charlie</td>
      </tr>
      <tr>
          <td>4</td>
          <td>B-&gt;A session</td>
          <td>yes</td>
          <td>Charlie</td>
      </tr>
      <tr>
          <td>5</td>
          <td>C-&gt;A</td>
          <td>yes</td>
          <td>Charlie</td>
      </tr>
      <tr>
          <td>6</td>
          <td>A-&gt;C</td>
          <td>no</td>
          <td>Alice</td>
      </tr>
      <tr>
          <td>7</td>
          <td>C-&gt;A</td>
          <td>yes</td>
          <td>Charlie</td>
      </tr>
      <tr>
          <td>Аутентификация: Алиса всегда выберет Боба с существующей сессией. Боб будет отклонять PeerTests от узлов без установленной сессии. Сообщение 1 отправляется внутри сессии. Следовательно, сообщение 1 является безопасным и аутентифицированным.</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>Боб выбирает Чарли, с которым у него есть существующая сессия. Сообщения 2 и 3 отправляются внутри сессии. Поэтому сообщения 2 и 3 являются безопасными и аутентифицированными.</p>
<p>Сообщение 4 должно отправляться внутри сессии; однако, спецификация SSU 1 ранее указывала, что оно отправляется с опубликованным intro key Алисы, что означает не внутри сессии. До версии 0.9.52 Java I2P действительно отправлял с intro key. Начиная с версии 0.9.52, спецификация гласит, что должен использоваться ключ сессии, и Java I2P отправляет сообщение внутри сессии начиная с версии 0.9.52.</p>
<p>Алиса не должна иметь существующую сессию с Чарли для продолжения теста; Алиса прерывает тест, если Боб выбирает Чарли, у которого есть сессия с Алисой. Поэтому сообщения 5-7 не являются безопасными и аутентифицированными.</p>
<p>Все сообщения Peer Test содержат 4-байтовый nonce, который выбирается Alice. Этот nonce не используется криптографически.</p>
<p>Возможные атаки на сообщения 5-7: требует исследования.</p>
<p>Хеш router&rsquo;а Алисы неизвестен Чарли. Хеш router&rsquo;а Чарли неизвестен Алисе. Они должны быть добавлены в протокол, если мы хотим, чтобы сообщения между Алисой и Чарли были аутентифицированы. Дополнительно, другие параметры SSU2 должны были бы предоставляться в сообщениях Peer Test, или Чарли пришлось бы искать Router Info Алисы в сетевой базе данных, что добавило бы дополнительную задержку. Аутентификация добавила бы один round-trip между Чарли и Алисой.</p>
<p>Пересылая хеш router&rsquo;а Алисы Чарли, Чарли мог бы легче определить, желает ли он участвовать в Peer Test с Алисой, проверив локальный список блокировок.</p>
<p>Четырехбайтовый nonce может потребовать замены или дополнения 8-байтовым идентификатором соединения.</p>
<h3 id="relay-and-peer-test-design-goals">Relay and Peer Test Design Goals</h3>
<p>Relay и Peer Test имеют схожие конструкции. В обоих случаях Алиса запрашивает Боба переслать служебный запрос Чарли, и затем Чарли выполняет этот запрос.</p>
<p>Текущие проблемы SSU1 Peer Test:</p>
<ul>
<li>Peer Test не имеет защиты от злонамеренного Bob</li>
<li>Peer Test не предоставляет способа для Bob или Charlie отклонить запрос</li>
<li>Peer Test не предоставляет способа для Alice узнать личность Charlie
или для Alice отклонить Charlie</li>
<li>Peer Test не предоставляет способа для Charlie узнать личность Alice
или для Charlie отклонить Alice</li>
<li>Peer Test использует собственную специализированную схему повторной передачи</li>
<li>Peer Test требует сложной машины состояний для определения
какое сообщение для какого состояния</li>
<li>Не зная, что Charlie отклонил её,
Alice будет рассматривать тест как неудачу.</li>
</ul>
<p>Текущие проблемы SSU1 Relay:</p>
<p>Большинство проблем Peer Test, перечисленных выше, также относятся к Peer Test.</p>
<p>У нас есть следующие цели по улучшению безопасности Relay и Peer Test:</p>
<ul>
<li>
<p>Чарли должен опубликовать достаточно информации о своих представителях (Бобах)
в netDb, чтобы Алиса могла проверить информацию при необходимости.
Например, публикация хеша роутера для каждого представителя
позволила бы Алисе, при наличии времени, получить информацию о роутере из netDb.</p>
</li>
<li>
<p>Защита от подмены адресов или угроз типа man-in-the-middle, которые могут
подделывать, изменять, фальсифицировать или повторно отправлять запросы от Alice к Bob.
Bob должен убедиться, что Alice является настоящим I2P router и что
представленные запрос и тестовый адрес действительны.</p>
</li>
<li>
<p>Защита от вредоносных Bob, которые могут подделывать, изменять, фальсифицировать или повторно отправлять
запросы, переадресованные Charlie.
Charlie должен убедиться, что и Alice, и Bob являются настоящими I2P router&rsquo;ами и что
представленные запрос и тестовый адрес являются действительными.</p>
</li>
<li>
<p>Боб должен получить достаточно информации от Алисы, чтобы иметь возможность проверить
запрос и затем принять или отклонить его.
Боб должен иметь механизм для отправки принятия или отказа обратно
Алисе.
Боб никогда не должен быть обязан выполнять запрошенное действие.</p>
</li>
<li>
<p>Чарли должен получить достаточно информации от Боба, чтобы иметь возможность проверить
запрос, а затем принять или отклонить его.
Чарли должен иметь механизм для отправки принятия или отклонения обратно
Бобу для передачи Алисе.
От Чарли никогда не должно требоваться выполнение запрашиваемого действия.</p>
</li>
<li>
<p>Алиса должна иметь возможность проверить, что ответ, переданный через Боба, действительно поступил от Чарли.</p>
</li>
<li>
<p>Алиса и Чарли должны иметь возможность проверить, что их последующие прямые
сообщения (не переданные через Боба) исходят от ожидаемого источника
и являются настоящими I2P роутерами.</p>
</li>
</ul>
<p>Следующие механизмы могут помочь в достижении этих целей:</p>
<ul>
<li>
<p>Временные метки</p>
</li>
<li>
<p>Подписи с использованием ключа подписи router</p>
</li>
<li>
<p>Использование данных вызова, включенных в запрос</p>
</li>
<li>
<p>Шифрование с использованием ключа шифрования router</p>
</li>
<li>
<p>Отправка хешей роутеров, Router Identities или Router Infos,
а не только IP-адресов и портов.</p>
</li>
<li>
<p>Валидация информации router путем запроса к базе данных сети</p>
</li>
<li>
<p>Проверка информации маршрутизатора, IP-адресов и портов по спискам блокировки</p>
</li>
<li>
<p>Ограничение скорости</p>
</li>
<li>
<p>Требование установки сессии</p>
</li>
</ul>
<p>Эти возможные механизмы могут увеличить время обработки и задержку функций Relay или Peer Test. Все эффекты должны быть оценены.</p>
<p>Кросс-версионная ретрансляция и тестирование узлов также должны поддерживаться, если это возможно. Это облегчит постепенный переход с SSU 1 на SSU 2. Возможные комбинации версий:</p>
<table>
  <thead>
      <tr>
          <th>Alice/Bob</th>
          <th>Bob/Charlie</th>
          <th>Alice/Charlie</th>
          <th>Supported</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>SSU 1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>2</td>
          <td>no, use 1/1/1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>Relay: yes? Peer Test: no</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2</td>
          <td>2</td>
          <td>no, use 1/2/1</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>1</td>
          <td>Relay: yes? Peer Test: no</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>2</td>
          <td>Relay: yes? Peer Test: no</td>
      </tr>
      <tr>
          <td>2</td>
          <td>2</td>
          <td>1</td>
          <td>no, use 2/2/2</td>
      </tr>
      <tr>
          <td>2</td>
          <td>2</td>
          <td>2</td>
          <td>yes</td>
      </tr>
  </tbody>
</table>
<h2 id="цели-безопасности">Цели безопасности</h2>
<h3 id="summary">Summary</h3>
<p>Мы опираемся на несколько существующих протоколов, как внутри I2P, так и внешних стандартов, для вдохновения, руководства и повторного использования кода:</p>
<ul>
<li>
<p>Модели угроз: Из NTCP2 <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
, со значительными дополнительными угрозами, относящимися к UDP-транспорту, как проанализировано в QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
.</p>
</li>
<li>
<p>Криптографические решения: Из <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
.</p>
</li>
<li>
<p>Handshake: Noise XK из <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
 и <a href="https://noiseprotocol.org/noise.html">NOISE</a>
. Значительные упрощения
по сравнению с NTCP2 возможны благодаря инкапсуляции (встроенные границы сообщений),
обеспечиваемой UDP.</p>
</li>
<li>
<p>Обфускация эфемерного ключа рукопожатия: Адаптировано из <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
,
но с использованием ChaCha20 из <a href="../../../ru/docs/specs/ecies/">ECIES</a>
 вместо AES.</p>
</li>
<li>
<p>Заголовки пакетов: Адаптированы из WireGuard <a href="https://www.wireguard.com/protocol/">WireGuard</a>
 и QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
.</p>
</li>
<li>
<p>Обфускация заголовков пакетов: Адаптирована из <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
,
но использует ChaCha20 из <a href="../../../ru/docs/specs/ecies/">ECIES</a>
 вместо AES.</p>
</li>
<li>
<p>Защита заголовков пакетов: Адаптировано из QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
 и <a href="https://eprint.iacr.org/2019/624.pdf">Nonces</a>
</p>
</li>
<li>
<p>Заголовки, используемые как AEAD ассоциированные данные, как в <a href="../../../ru/docs/specs/ecies/">ECIES</a>
.</p>
</li>
<li>
<p>Нумерация пакетов: Адаптировано из WireGuard <a href="https://www.wireguard.com/protocol/">WireGuard</a>
 и QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
.</p>
</li>
<li>
<p>Сообщения: Адаптировано из <a href="../../../ru/docs/specs/ssu2/">SSU</a>
</p>
</li>
<li>
<p>Фрагментация I2NP: Адаптировано из <a href="../../../ru/docs/specs/ssu2/">SSU</a>
</p>
</li>
<li>
<p>Relay и Peer Testing: Адаптировано из <a href="../../../ru/docs/specs/ssu2/">SSU</a>
</p>
</li>
<li>
<p>Подписи данных Relay и Peer Test: Из спецификации общих структур <a href="../../../ru/docs/specs/common-structures/">Common</a>
</p>
</li>
<li>
<p>Формат блока: Из <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
 и <a href="../../../ru/docs/specs/ecies/">ECIES</a>
.</p>
</li>
<li>
<p>Заполнение и опции: Из <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
 и <a href="../../../ru/docs/specs/ecies/">ECIES</a>
.</p>
</li>
<li>
<p>Acks, nacks: Адаптировано из QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
.</p>
</li>
<li>
<p>Управление потоком: TBD</p>
</li>
</ul>
<p>В I2P не используются новые криптографические примитивы, которые не применялись в I2P ранее.</p>
<h3 id="валидация-адресов">Валидация адресов</h3>
<p>Как и другие транспорты I2P — NTCP, NTCP2 и SSU 1, — данный транспорт не является универсальным средством для доставки упорядоченного потока байтов. Он предназначен для транспортировки сообщений I2NP. Абстракция «потока» не предоставляется.</p>
<p>Кроме того, как и для SSU, он содержит дополнительные возможности для обхода NAT с помощью пиров и тестирования доступности (входящих соединений).</p>
<p>Что касается SSU 1, он НЕ обеспечивает упорядоченную доставку I2NP сообщений. Также он не гарантирует доставку I2NP сообщений. Для повышения эффективности, или из-за неупорядоченной доставки UDP датаграмм или их потери, I2NP сообщения могут быть доставлены на дальний конец в неправильном порядке или могут вообще не быть доставлены. I2NP сообщение может быть повторно передано несколько раз при необходимости, но доставка может в конечном итоге завершиться неудачей без разрыва всего соединения. Кроме того, новые I2NP сообщения могут продолжать отправляться даже во время повторной передачи (восстановления после потерь) других I2NP сообщений.</p>
<p>Этот протокол НЕ предотвращает полностью дублированную доставку I2NP сообщений. Router должен обеспечивать истечение срока действия I2NP и использовать фильтр Блума или другой механизм, основанный на ID I2NP сообщения. См. раздел &ldquo;Дублирование I2NP сообщений&rdquo; ниже.</p>
<h3 id="noise-protocol-framework">Noise Protocol Framework</h3>
<p>Данное предложение определяет требования на основе Noise Protocol Framework <a href="https://noiseprotocol.org/noise.html">NOISE</a>
 (редакция 33, 2017-10-04). Noise имеет схожие свойства с протоколом Station-To-Station (STS), который является основой для протокола <a href="../../../ru/docs/specs/ssu2/">SSU</a>
. В терминологии Noise Алиса является инициатором, а Боб - ответчиком.</p>
<p>SSU2 основан на протоколе Noise Noise_XK_25519_ChaChaPoly_SHA256. (Фактический идентификатор для функции первоначального извлечения ключа - &ldquo;Noise_XKchaobfse+hs1+hs2+hs3_25519_ChaChaPoly_SHA256&rdquo;, указывающий на расширения I2P - см. раздел KDF 1 ниже)</p>
<p>ПРИМЕЧАНИЕ: Этот идентификатор отличается от используемого для NTCP2, поскольку все три сообщения рукопожатия используют заголовок в качестве ассоциированных данных.</p>
<p>Этот протокол Noise использует следующие примитивы:</p>
<ul>
<li>
<p>Handshake Pattern: XK
Алиса передает свой ключ Бобу (X)
Алиса уже знает статический ключ Боба (K)</p>
</li>
<li>
<p>DH Function: X25519
X25519 DH с длиной ключа 32 байта, как указано в <a href="https://tools.ietf.org/html/rfc7748">RFC 7748</a>
.</p>
</li>
<li>
<p>Cipher Function: ChaChaPoly
AEAD_CHACHA20_POLY1305 как указано в <a href="https://tools.ietf.org/html/rfc7539">RFC 7539</a>
 разделе 2.8.
12-байтовый nonce, где первые 4 байта установлены в ноль.</p>
</li>
<li>
<p>Hash Function: SHA256
Стандартный 32-байтный хеш, уже широко используемый в I2P.</p>
</li>
</ul>
<h3 id="additions-to-the-framework">Additions to the Framework</h3>
<p>Данное предложение определяет следующие улучшения для Noise_XK_25519_ChaChaPoly_SHA256. Они в целом следуют рекомендациям в разделе 13 <a href="https://noiseprotocol.org/noise.html">NOISE</a>
.</p>
<ol>
<li>
<p>Сообщения handshake (Session Request, Created, Confirmed) включают заголовок размером 16 или 32 байта.</p>
</li>
<li>
<p>Заголовки для сообщений handshake (Session Request, Created, Confirmed) используются как входные данные для mixHash() перед шифрованием/расшифрованием для привязки заголовков к сообщению.</p>
</li>
<li>
<p>Заголовки зашифрованы и защищены.</p>
</li>
<li>
<p>Открытые эфемерные ключи маскируются шифрованием ChaCha20 с использованием известного ключа и IV. Это быстрее, чем elligator2.</p>
</li>
<li>
<p>Формат полезной нагрузки определен для сообщений 1, 2 и фазы данных. Конечно, это не определено в Noise.</p>
</li>
</ol>
<p>Фаза данных использует шифрование, похожее на фазу данных Noise, но не совместимое с ней.</p>
<h3 id="processing-overhead-estimate">Processing overhead estimate</h3>
<p>Будет определено позднее</p>
<h2 id="definitions">Definitions</h2>
<p>Мы определяем следующие функции, соответствующие используемым криптографическим блокам.</p>
<p>ZEROLEN</p>
<pre><code>zero-length byte array
</code></pre>
<p>H(p, d)</p>
<pre><code>SHA-256 hash function that takes a personalization string p and data d, and
produces an output of length 32 bytes.
As defined in [NOISE](https://noiseprotocol.org/noise.html).
|| below means append.

Use SHA-256 as follows::

    H(p, d) := SHA-256(p || d)
</code></pre>
<p>MixHash(d)</p>
<pre><code>SHA-256 hash function that takes a previous hash h and new data d,
and produces an output of length 32 bytes.
|| below means append.

Use SHA-256 as follows::

    MixHash(d) := h = SHA-256(h || d)
</code></pre>
<p>STREAM</p>
<pre><code>The ChaCha20/Poly1305 AEAD as specified in [RFC 7539](https://tools.ietf.org/html/rfc7539).
S_KEY_LEN = 32 and S_IV_LEN = 12.

ENCRYPT(k, n, plaintext, ad)
    Encrypts plaintext using the cipher key k, and nonce n which MUST be unique for
    the key k.
    Associated data ad is optional.
    Returns a ciphertext that is the size of the plaintext + 16 bytes for the HMAC.

    The entire ciphertext must be indistinguishable from random if the key is secret.

DECRYPT(k, n, ciphertext, ad)
    Decrypts ciphertext using the cipher key k, and nonce n.
    Associated data ad is optional.
    Returns the plaintext.
</code></pre>
<p>DH</p>
<pre><code>X25519 public key agreement system. Private keys of 32 bytes, public keys of 32
bytes, produces outputs of 32 bytes. It has the following
functions:

GENERATE_PRIVATE()
    Generates a new private key.

DERIVE_PUBLIC(privkey)
    Returns the public key corresponding to the given private key.

DH(privkey, pubkey)
    Generates a shared secret from the given private and public keys.
</code></pre>
<p>HKDF(salt, ikm, info, n)</p>
<pre><code>A cryptographic key derivation function which takes some input key material ikm (which
should have good entropy but is not required to be a uniformly random string), a salt
of length 32 bytes, and a context-specific 'info' value, and produces an output
of n bytes suitable for use as key material.

Use HKDF as specified in [RFC 5869](https://tools.ietf.org/html/rfc5869), using the HMAC hash function SHA-256
as specified in [RFC 2104](https://tools.ietf.org/html/rfc2104). This means that SALT_LEN is 32 bytes max.
</code></pre>
<p>MixKey(d)</p>
<pre><code>Use HKDF() with a previous chainKey and new data d, and
sets the new chainKey and k.
As defined in [NOISE](https://noiseprotocol.org/noise.html).

Use HKDF as follows::

    MixKey(d) := output = HKDF(chainKey, d, &quot;&quot;, 64)
                 chainKey = output[0:31]
                 k = output[32:63]
</code></pre>
<h2 id="messages">Messages</h2>
<p>Каждая UDP дейтаграмма содержит ровно одно сообщение. Длина дейтаграммы (после IP и UDP заголовков) равна длине сообщения. Padding, если присутствует, содержится в блоке padding внутри сообщения. В этом документе мы используем термины &ldquo;дейтаграмма&rdquo; и &ldquo;пакет&rdquo; в основном как взаимозаменяемые. Каждая дейтаграмма (или пакет) содержит одно сообщение (в отличие от QUIC, где дейтаграмма может содержать несколько QUIC пакетов). &ldquo;Заголовок пакета&rdquo; - это часть после IP/UDP заголовка.</p>
<p>Исключение: Сообщение Session Confirmed уникально тем, что оно может быть фрагментировано на несколько пакетов. Смотрите раздел Session Confirmed Fragmentation ниже для получения дополнительной информации.</p>
<p>Все сообщения SSU2 имеют длину не менее 40 байт. Любое сообщение длиной 1-39 байт является недействительным. Все сообщения SSU2 имеют длину менее или равную 1472 (IPv4) или 1452 (IPv6) байт. Формат сообщения основан на сообщениях Noise с модификациями для кадрирования и неразличимости. Реализации, использующие стандартные библиотеки Noise, должны предварительно обрабатывать полученные сообщения до стандартного формата сообщений Noise. Все зашифрованные поля представляют собой шифртексты AEAD.</p>
<p>Определены следующие сообщения:</p>
<table>
  <thead>
      <tr>
          <th>Type</th>
          <th>Message</th>
          <th>Header Length</th>
          <th>Header Encr. Length</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>SessionRequest</td>
          <td>32</td>
          <td>64</td>
      </tr>
      <tr>
          <td>1</td>
          <td>SessionCreated</td>
          <td>32</td>
          <td>64</td>
      </tr>
      <tr>
          <td>2</td>
          <td>SessionConfirmed</td>
          <td>16</td>
          <td>16</td>
      </tr>
      <tr>
          <td>6</td>
          <td>Data</td>
          <td>16</td>
          <td>16</td>
      </tr>
      <tr>
          <td>7</td>
          <td>PeerTest</td>
          <td>32</td>
          <td>32</td>
      </tr>
      <tr>
          <td>9</td>
          <td>Retry</td>
          <td>32</td>
          <td>32</td>
      </tr>
      <tr>
          <td>10</td>
          <td>Token Request</td>
          <td>32</td>
          <td>32</td>
      </tr>
      <tr>
          <td>11</td>
          <td>HolePunch</td>
          <td>32</td>
          <td>32</td>
      </tr>
  </tbody>
</table>
<h3 id="session-establishment">Session Establishment</h3>
<p>Стандартная последовательность установления соединения, когда у Алисы есть действительный токен, ранее полученный от Боба, выглядит следующим образом:</p>
<pre tabindex="0"><code>Alice                           Bob

SessionRequest -------------------&gt;
&lt;------------------- SessionCreated
SessionConfirmed -----------------&gt;
</code></pre><p>Когда у Alice нет действительного токена, последовательность установления соединения выглядит следующим образом:</p>
<pre tabindex="0"><code>Alice                           Bob

TokenRequest ---------------------&gt;
&lt;---------------------------  Retry
SessionRequest -------------------&gt;
&lt;------------------- SessionCreated
SessionConfirmed -----------------&gt;
</code></pre><p>Когда Alice считает, что у неё есть действительный токен, но Bob отклоняет его (возможно, потому что Bob перезапустился), последовательность установления соединения выглядит следующим образом:</p>
<pre tabindex="0"><code>Alice                           Bob

SessionRequest -------------------&gt;
&lt;---------------------------  Retry
SessionRequest -------------------&gt;
&lt;------------------- SessionCreated
SessionConfirmed -----------------&gt;
</code></pre><p>Боб может отклонить запрос Session или Token, ответив сообщением Retry, содержащим блок Termination с кодом причины. На основе кода причины Алиса не должна предпринимать другую попытку запроса в течение определенного периода времени:</p>
<pre tabindex="0"><code>Alice                           Bob

SessionRequest -------------------&gt;
&lt;---------------------------  Retry containing a Termination block

or

TokenRequest ---------------------&gt;
&lt;---------------------------  Retry containing a Termination block
</code></pre><p>Используя терминологию Noise, последовательность установления соединения и передачи данных выглядит следующим образом: (Свойства безопасности полезной нагрузки)</p>
<pre tabindex="0"><code>XK(s, rs):           Authentication   Confidentiality
    &lt;- s
    ...
    -&gt; e, es                  0                2
    &lt;- e, ee                  2                1
    -&gt; s, se                  2                5
    &lt;-                        2                5
</code></pre><p>После установления сессии Алиса и Боб могут обмениваться сообщениями Data.</p>
<h3 id="packet-header">Packet Header</h3>
<p>Все пакеты начинаются с обфусцированного (зашифрованного) заголовка. Существует два типа заголовков: длинный и короткий. Обратите внимание, что первые 13 байт (Destination Connection ID, номер пакета и тип) одинаковы для всех заголовков.</p>
<h4 id="контрмеры-против-общих-атак-подделки-запросов">Контрмеры против общих атак подделки запросов</h4>
<p>Длинный заголовок составляет 32 байта. Он используется до создания сессии для Token Request, SessionRequest, SessionCreated и Retry. Он также используется для сообщений Peer Test и Hole Punch вне сессии.</p>
<p>До шифрования заголовка:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: 8 bytes, unsigned big endian integer

  Packet Number :: 4 bytes, unsigned big endian integer

  type :: The message type = 0, 1, 7, 9, 10, or 11

  ver :: The protocol version, equal to 2

  id :: 1 byte, the network ID (currently 2, except for test networks)

  flag :: 1 byte, unused, set to 0 for future compatibility

  Source Connection ID :: 8 bytes, unsigned big endian integer

  Token :: 8 bytes, unsigned big endian integer
</code></pre><h4 id="атаки-slowloris">Атаки Slowloris</h4>
<p>Короткий заголовок составляет 16 байт. Он используется для сообщений Session Created и Data. Неаутентифицированные сообщения, такие как Session Request, Retry и Peer Test, всегда будут использовать длинный заголовок.</p>
<p>16 байт требуется, потому что получатель должен расшифровать первые 16 байт, чтобы получить тип сообщения, а затем должен расшифровать дополнительные 16 байт, если это действительно длинный заголовок, как указывает тип сообщения.</p>
<p>Для Session Confirmed, до шифрования заголовка:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type|frag|  flags  |
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: 8 bytes, unsigned big endian integer

  Packet Number :: 4 bytes, all zeros

  type :: The message type = 2

  frag :: 1 byte fragment info:
         bit order: 76543210 (bit 7 is MSB)
         bits 7-4: fragment number 0-14, big endian
         bits 3-0: total fragments 1-15, big endian

  flags :: 2 bytes, unused, set to 0 for future compatibility
</code></pre><p>Смотрите раздел Session Confirmed Fragmentation ниже для получения дополнительной информации о поле frag.</p>
<p>Для Data сообщений, перед шифрованием заголовка:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type|flag|moreflags|
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: 8 bytes, unsigned big endian integer

  Packet Number :: 4 bytes, unsigned big endian integer

  type :: The message type = 6

  flag :: 1 byte flags:
         bit order: 76543210 (bit 7 is MSB)
         bits 7-1: unused, set to 0 for future compatibility
         bits 0: when set to 1, immediate ack requested

  moreflags :: 2 bytes, unused, set to 0 for future compatibility
</code></pre><h4 id="атаки-фрагментации-и-повторной-сборки-потоков">Атаки фрагментации и повторной сборки потоков</h4>
<p>Идентификаторы соединений должны генерироваться случайным образом. Идентификаторы источника и назначения НЕ должны быть идентичными, чтобы злоумышленник на пути не мог перехватить пакет и отправить его обратно отправителю так, чтобы он выглядел валидным. НЕ используйте счетчик для генерации идентификаторов соединений, чтобы злоумышленник на пути не мог создать пакет, который выглядит валидным.</p>
<p>В отличие от QUIC, мы не изменяем идентификаторы соединения во время или после рукопожатия, даже после сообщения Retry. Идентификаторы остаются постоянными с первого сообщения (Token Request или Session Request) до последнего сообщения (Data with Termination). Кроме того, идентификаторы соединения не изменяются во время или после проверки пути или миграции соединения.</p>
<p>Также отличием от QUIC является то, что идентификаторы соединений в заголовках всегда зашифрованы на уровне заголовков. См. ниже.</p>
<h4 id="атака-с-обязательством-потока">Атака с обязательством потока</h4>
<p>Если в рукопожатии не отправляется блок First Packet Number, пакеты нумеруются в рамках одной сессии для каждого направления, начиная с 0, до максимума (2**32 -1). Сессия должна быть завершена и создана новая сессия задолго до отправки максимального количества пакетов.</p>
<p>Если блок First Packet Number отправляется в рукопожатии, пакеты нумеруются в рамках одной сессии для данного направления, начиная с этого номера пакета. Номер пакета может обернуться во время сессии. Когда отправлено максимум 2**32 пакетов, что приводит к обёртыванию номера пакета обратно к первому номеру пакета, эта сессия больше не является действительной. Сессия должна быть завершена и создана новая сессия задолго до отправки максимального количества пакетов.</p>
<p>TODO ротация ключей, уменьшить максимальный номер пакета?</p>
<p>Пакеты handshake, которые определены как потерянные, передаются повторно целиком, с идентичным заголовком, включая номер пакета. Сообщения handshake Session Request, Session Created и Session Confirmed ДОЛЖНЫ передаваться повторно с тем же номером пакета и идентичным зашифрованным содержимым, чтобы для шифрования ответа использовался тот же цепочечный хеш. Сообщение Retry никогда не передается.</p>
<p>Пакеты фазы данных, которые определяются как потерянные, никогда не передаются повторно целиком (кроме завершения, см. ниже). То же самое относится к блокам, которые содержатся в потерянных пакетах. Вместо этого информация, которая может переноситься в блоках, отправляется снова в новых пакетах по мере необходимости. Пакеты данных никогда не передаются повторно с тем же номером пакета. Любая повторная передача содержимого пакета (независимо от того, остается ли содержимое тем же) должна использовать следующий неиспользованный номер пакета.</p>
<p>Повторная передача неизмененного целого пакета как есть, с тем же номером пакета, не разрешена по нескольким причинам. Для получения справочной информации см. QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 раздел 12.3.</p>
<ul>
<li>Неэффективно хранить пакеты для повторной передачи</li>
<li>Новый пакет данных выглядит по-другому для наблюдателя на пути, нельзя определить, что он повторно передан</li>
<li>С новым пакетом отправляется обновленный блок подтверждений, а не старый блок подтверждений</li>
<li>Вы повторно передаете только то, что необходимо. некоторые фрагменты могли уже быть переданы повторно и подтверждены</li>
<li>Вы можете поместить столько, сколько нужно, в каждый повторно передаваемый пакет, если есть еще ожидающие данные</li>
<li>Конечные точки, которые отслеживают все отдельные пакеты с целью
обнаружения дубликатов, рискуют накопить избыточное состояние.
Данные, необходимые для обнаружения дубликатов, могут быть ограничены
поддержанием минимального номера пакета, ниже которого все пакеты
немедленно отбрасываются.</li>
<li>Эта схема гораздо более гибкая</li>
</ul>
<p>Новые пакеты используются для передачи информации, которая была определена как потерянная. В общем случае информация отправляется повторно, когда пакет, содержащий эту информацию, определяется как потерянный, и отправка прекращается, когда пакет, содержащий эту информацию, остается неизменным) подтверждается.</p>
<p>Исключение: Пакет фазы данных, содержащий блок завершения, может быть, но не обязан быть, повторно передан целиком, как есть. См. раздел &ldquo;Завершение сессии&rdquo; ниже.</p>
<p>Следующие пакеты содержат случайный номер пакета, который игнорируется:</p>
<ul>
<li>Session Request</li>
<li>Session Created</li>
<li>Token Request</li>
<li>Retry</li>
<li>Peer Test</li>
<li>Hole Punch</li>
</ul>
<p>Для Алисы нумерация исходящих пакетов начинается с 0 с Session Confirmed. Для Боба нумерация исходящих пакетов начинается с 0 с первого пакета Data, который должен быть ACK для Session Confirmed. Номера пакетов в примере стандартного рукопожатия будут:</p>
<pre tabindex="0"><code>Alice                           Bob

SessionRequest (r)    ------------&gt;
&lt;-------------   SessionCreated (r)
SessionConfirmed (0)  ------------&gt;
&lt;-------------             Data (0) (Ack-only)
Data (1)              ------------&gt; (May be sent before Ack is received)
&lt;-------------             Data (1)
Data (2)              ------------&gt;
Data (3)              ------------&gt;
Data (4)              ------------&gt;
&lt;-------------             Data (2)

r = random packet number (ignored)
Token Request, Retry, and Peer Test
also have random packet numbers.
</code></pre><p>Любая повторная передача handshake сообщений (SessionRequest, SessionCreated или SessionConfirmed) должна быть отправлена без изменений, с тем же номером пакета. Не используйте разные эфемерные ключи и не изменяйте полезную нагрузку при повторной передаче этих сообщений.</p>
<h4 id="отказ-в-обслуживании-пира">Отказ в обслуживании пира</h4>
<p>Заголовок (до обфускации и защиты) всегда включается в ассоциированные данные для функции AEAD, чтобы криптографически связать заголовок с данными.</p>
<h4 id="атаки-с-явным-уведомлением-о-перегрузке">Атаки с явным уведомлением о перегрузке</h4>
<p>Шифрование заголовков имеет несколько целей. См. раздел &ldquo;Дополнительное обсуждение DPI&rdquo; выше для контекста и предпосылок.</p>
<ul>
<li>Предотвратить идентификацию протокола онлайн DPI</li>
<li>Предотвратить паттерны в серии сообщений в одном и том же соединении,
за исключением повторных передач рукопожатия</li>
<li>Предотвратить паттерны в сообщениях одного типа в разных соединениях</li>
<li>Предотвратить дешифрование заголовков рукопожатия
без знания introduction key, найденного в netDb</li>
<li>Предотвратить идентификацию эфемерных ключей X25519
без знания introduction key, найденного в netDb</li>
<li>Предотвратить дешифрование номера пакета и типа фазы данных
любым онлайн или офлайн атакующим</li>
<li>Предотвратить инъекцию валидных пакетов рукопожатия наблюдателем на пути или вне пути
без знания introduction key, найденного в netDb</li>
<li>Предотвратить инъекцию валидных пакетов данных наблюдателем на пути или вне пути</li>
<li>Обеспечить быструю и эффективную классификацию входящих пакетов</li>
<li>Обеспечить сопротивление &ldquo;прощупыванию&rdquo;, чтобы не было ответа на плохой
Session Request, или если есть Retry ответ,
ответ не идентифицируется как I2P
без знания introduction key, найденного в netDb</li>
<li>Destination Connection ID не является критичными данными,
и допустимо, если их может расшифровать наблюдатель
со знанием introduction key, найденного в netDb</li>
<li>Номер пакета пакета фазы данных является AEAD nonce и критичными данными.
Он не должен быть расшифровываемым наблюдателем даже
со знанием introduction key, найденного в netDb.
См. <a href="https://eprint.iacr.org/2019/624.pdf">Nonces</a>
.</li>
</ul>
<p>Заголовки шифруются с помощью известных ключей, опубликованных в базе данных сети или вычисленных позже. На этапе handshake это служит только для сопротивления DPI, поскольку ключ является публичным, а ключ и nonce повторно используются, поэтому это фактически просто обфускация. Обратите внимание, что шифрование заголовков также используется для обфускации эфемерных ключей X (в Session Request) и Y (в Session Created).</p>
<p>Смотрите раздел &ldquo;Обработка входящих пакетов&rdquo; ниже для получения дополнительных указаний.</p>
<p>Байты 0-15 всех заголовков шифруются с использованием схемы защиты заголовков путем операции XOR с данными, вычисленными из известных ключей, используя ChaCha20, аналогично QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
 и <a href="https://eprint.iacr.org/2019/624.pdf">Nonces</a>
. Это обеспечивает то, что зашифрованный короткий заголовок и первая часть длинного заголовка будут выглядеть случайными.</p>
<p>Для Session Request и Session Created байты 16-31 длинного заголовка и 32-байтовый Noise эфемерный ключ шифруются с использованием ChaCha20. Незашифрованные данные являются случайными, поэтому зашифрованные данные будут выглядеть как случайные.</p>
<p>Для Retry байты 16-31 длинного заголовка шифруются с использованием ChaCha20. Нешифрованные данные являются случайными, поэтому зашифрованные данные будут выглядеть случайными.</p>
<p>В отличие от схемы защиты заголовков QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
, ВСЕ части всех заголовков, включая идентификаторы соединения назначения и источника, зашифрованы. QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9001">RFC 9001</a>
 и <a href="https://eprint.iacr.org/2019/624.pdf">Nonces</a>
 в первую очередь сосредоточены на шифровании &ldquo;критической&rdquo; части заголовка, т.е. номера пакета (nonce ChaCha20). Хотя шифрование идентификатора сессии делает классификацию входящих пакетов немного более сложной, это затрудняет некоторые атаки. QUIC определяет разные идентификаторы соединения для разных фаз, а также для проверки пути и миграции соединения. Здесь мы используем одни и те же идентификаторы соединения на протяжении всего процесса, поскольку они зашифрованы.</p>
<p>Существует семь фаз ключей защиты заголовков:</p>
<ul>
<li>Запрос сессии и запрос токена</li>
<li>Сессия создана</li>
<li>Повторная попытка</li>
<li>Сессия подтверждена</li>
<li>Фаза данных</li>
<li>Тест узла</li>
<li>Пробивка NAT</li>
</ul>
<table>
  <thead>
      <tr>
          <th>Message</th>
          <th>Key k_header_1</th>
          <th>Key k_header_2</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Token Request</td>
          <td>Bob Intro Key</td>
          <td>Bob Intro Key</td>
      </tr>
      <tr>
          <td>Session Request</td>
          <td>Bob Intro Key</td>
          <td>Bob Intro Key</td>
      </tr>
      <tr>
          <td>Session Created</td>
          <td>Bob Intro Key</td>
          <td>See Session Request K</td>
      </tr>
      <tr>
          <td>Session Confirmed</td>
          <td>Bob Intro Key</td>
          <td>See Session Created K</td>
      </tr>
      <tr>
          <td>Retry</td>
          <td>Bob Intro Key</td>
          <td>Bob Intro Key</td>
      </tr>
      <tr>
          <td>Data</td>
          <td>Alice/Bob Intro Key</td>
          <td>See data phase KDF</td>
      </tr>
      <tr>
          <td>Peer Test 5,7</td>
          <td>Alice Intro Key</td>
          <td>Alice Intro Key</td>
      </tr>
      <tr>
          <td>Peer Test 6</td>
          <td>Charlie Intro Key</td>
          <td>Charlie Intro Key</td>
      </tr>
      <tr>
          <td>Hole Punch</td>
          <td>Alice Intro Key</td>
          <td>Alice Intro Key</td>
      </tr>
      <tr>
          <td>Шифрование заголовка предназначено для быстрой классификации входящих пакетов без сложной эвристики или резервных механизмов. Это достигается за счёт использования одного и того же ключа k_header_1 для почти всех входящих сообщений. Даже когда исходный IP или порт соединения изменяется из-за фактического изменения IP или поведения NAT, пакет может быть быстро сопоставлен с сессией при помощи единственного поиска connection ID.</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>Обратите внимание, что Session Created и Retry — это ЕДИНСТВЕННЫЕ сообщения, которые требуют резервной обработки для k_header_1 для расшифровки Connection ID, поскольку они используют intro key отправителя (Bob). ВСЕ остальные сообщения используют intro key получателя для k_header_1. Резервная обработка должна только искать ожидающие исходящие соединения по IP/порту источника.</p>
<p>Если резервная обработка по исходному IP/порту не может найти ожидающее исходящее соединение, это может быть вызвано несколькими причинами:</p>
<ul>
<li>Не является сообщением SSU2</li>
<li>Поврежденное сообщение SSU2</li>
<li>Ответ подделан или изменен злоумышленником</li>
<li>Bob имеет симметричный NAT</li>
<li>Bob изменил IP или порт во время обработки сообщения</li>
<li>Bob отправил ответ через другой интерфейс</li>
</ul>
<p>Хотя возможна дополнительная обработка с резервными вариантами для попытки найти ожидающее исходящее соединение и расшифровать идентификатор соединения, используя k_header_1 для этого соединения, это вероятно не является необходимым. Если у Bob есть проблемы с его NAT или маршрутизацией пакетов, вероятно лучше позволить соединению завершиться неудачей. Данная архитектура полагается на то, что конечные точки сохраняют стабильный адрес в течение всего процесса установления соединения.</p>
<p>См. раздел &ldquo;Обработка входящих пакетов&rdquo; ниже для получения дополнительных рекомендаций.</p>
<p>Смотрите отдельные разделы KDF ниже для получения ключей шифрования заголовков для этой фазы.</p>
<h4 id="stateless-reset-oracle">Stateless Reset Oracle</h4>
<pre tabindex="0"><code>// incoming encrypted packet
  packet = incoming encrypted packet
  len = packet.length

  // take the next-to-last 12 bytes of the packet
  iv = packet[len-24:len-13]
  k_header_1 = header encryption key 1
  data = {0, 0, 0, 0, 0, 0, 0, 0}
  mask = ChaCha20.encrypt(k_header_1, iv, data)

  // encrypt the first part of the header by XORing with the mask
  packet[0:7] ^= mask[0:7]

  // take the last 12 bytes of the packet
  iv = packet[len-12:len-1]
  k_header_2 = header encryption key 2
  data = {0, 0, 0, 0, 0, 0, 0, 0}
  mask = ChaCha20.encrypt(k_header_2, iv, data)

  // encrypt the second part of the header by XORing with the mask
  packet[8:15] ^= mask[0:7]


  // For Session Request and Session Created only:
  iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

  // encrypt the third part of the header and the ephemeral key
  packet[16:63] = ChaCha20.encrypt(k_header_2, iv, packet[16:63])


  // For Retry, Token Request, Peer Test, and Hole Punch only:
  iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

  // encrypt the third part of the header
  packet[16:31] = ChaCha20.encrypt(k_header_2, iv, packet[16:31])
</code></pre><p>Данная KDF использует последние 24 байта пакета в качестве IV для двух операций ChaCha20. Поскольку все пакеты заканчиваются 16-байтовым MAC, это требует, чтобы все полезные нагрузки пакетов имели минимальный размер 8 байт. Данное требование дополнительно документировано в разделах сообщений ниже.</p>
<h4 id="понижение-версии">Понижение версии</h4>
<p>После расшифровки первых 8 байт заголовка получатель узнает Destination Connection ID. Отсюда получатель знает, какой ключ шифрования заголовка использовать для остальной части заголовка, основываясь на фазе ключа сессии.</p>
<p>Расшифровка следующих 8 байт заголовка затем раскроет тип сообщения и позволит определить, является ли он коротким или длинным заголовком. Если это длинный заголовок, получатель должен проверить поля версии и netid. Если версия != 2, или netid != ожидаемое значение (обычно 2, за исключением тестовых сетей), получатель должен отбросить сообщение.</p>
<h3 id="packet-integrity">Packet Integrity</h3>
<p>Все сообщения содержат либо три, либо четыре части:</p>
<ul>
<li>Заголовок сообщения</li>
<li>Только для Session Request и Session Created, эфемерный ключ</li>
<li>Полезная нагрузка, зашифрованная ChaCha20</li>
<li>MAC Poly1305</li>
</ul>
<p>Во всех случаях заголовок (и при наличии эфемерный ключ) связан с MAC аутентификации для обеспечения целостности всего сообщения.</p>
<ul>
<li>Для handshake сообщений Session Request, Session Created и Session Confirmed,
заголовок сообщения обрабатывается mixHash() перед фазой обработки Noise</li>
<li>Эфемерный ключ, если присутствует, покрывается стандартным Noise misHash()</li>
<li>Для сообщений вне handshake Noise, заголовок используется
как Associated Data для шифрования ChaCha20/Poly1305.</li>
</ul>
<p>Обработчики входящих пакетов всегда должны расшифровывать полезную нагрузку ChaCha20 и проверять MAC перед обработкой сообщения, за одним исключением: Для смягчения DoS-атак от пакетов с подменённым адресом, содержащих кажущиеся сообщения Session Request с недействительным токеном, обработчик НЕ ДОЛЖЕН пытаться расшифровать и проверить полное сообщение (что требует дорогостоящей операции DH в дополнение к расшифровке ChaCha20/Poly1305). Обработчик может ответить сообщением Retry, используя значения, найденные в заголовке сообщения Session Request.</p>
<h3 id="authenticated-encryption">Authenticated Encryption</h3>
<p>Существует три отдельных экземпляра аутентифицированного шифрования (CipherStates). Один во время фазы handshake, и два (передача и прием) для фазы данных. Каждый имеет свой собственный ключ из KDF.</p>
<p>Зашифрованные/аутентифицированные данные будут представлены как</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   Encrypted and authenticated data    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><h4 id="целенаправленные-атаки-через-маршрутизацию">Целенаправленные атаки через маршрутизацию</h4>
<p>Зашифрованный и аутентифицированный формат данных.</p>
<p>Входные данные для функций шифрования/дешифрования:</p>
<pre tabindex="0"><code>
k :: 32 byte cipher key, as generated from KDF

  nonce :: Counter-based nonce, 12 bytes.
           Starts at 0 and incremented for each message.
           First four bytes are always zero.
           Last eight bytes are the counter, little-endian encoded.
           Maximum value is 2**64 - 2.
           Connection must be dropped and restarted after
           it reaches that value.
           The value 2**64 - 1 must never be sent.

  ad :: In handshake phase:
        Associated data, 32 bytes.
        The SHA256 hash of all preceding data.
        In data phase:
        The packet header, 16 bytes.

  data :: Plaintext data, 0 or more bytes
</code></pre><p>Результат функции шифрования, входные данные для функции расшифрования:</p>
<pre tabindex="0"><code>
+----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |       ChaCha20 encrypted data         |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Poly1305 Message Authentication Code |
  +              (MAC)                    +
  |             16 bytes                  |
  +----+----+----+----+----+----+----+----+

  encrypted data :: Same size as plaintext data, 0 - 65519 bytes

  MAC :: Poly1305 message authentication code, 16 bytes
</code></pre><p>Для ChaCha20 то, что описано здесь, соответствует <a href="https://tools.ietf.org/html/rfc7539">RFC 7539</a>
, который также используется аналогичным образом в TLS <a href="https://tools.ietf.org/html/rfc7905">RFC 7905</a>
.</p>
<h4 id="анализ-трафика">Анализ трафика</h4>
<ul>
<li>
<p>Поскольку ChaCha20 является потоковым шифром, открытые тексты не требуют дополнения.
Дополнительные байты ключевого потока отбрасываются.</p>
</li>
<li>
<p>Ключ для шифра (256 бит) согласовывается с помощью SHA256 KDF.
Детали KDF для каждого сообщения приведены в отдельных разделах ниже.</p>
</li>
</ul>
<h4 id="aead-error-handling">AEAD Error Handling</h4>
<ul>
<li>
<p>Во всех сообщениях размер AEAD сообщения известен заранее.
При сбое AEAD аутентификации получатель должен остановить дальнейшую обработку сообщения и
отбросить сообщение.</p>
</li>
<li>
<p>Bob должен поддерживать чёрный список IP-адресов с
повторяющимися сбоями.</p>
</li>
</ul>
<h3 id="kdf-for-session-request">KDF for Session Request</h3>
<p>Функция вывода ключа (KDF) генерирует ключ шифрования k для фазы handshake из результата DH, используя HMAC-SHA256(key, data) как определено в <a href="https://tools.ietf.org/html/rfc2104">RFC 2104</a>
. Это функции InitializeSymmetric(), MixHash() и MixKey(), точно как определено в спецификации Noise.</p>
<h4 id="kdf-for-initial-chainkey">KDF for Initial ChainKey</h4>
<pre tabindex="0"><code>
// Define protocol_name.
  Set protocol_name = &#34;Noise_XKchaobfse+hs1+hs2+hs3_25519_ChaChaPoly_SHA256&#34;
   (52 bytes, US-ASCII encoded, no NULL termination).

  // Define Hash h = 32 bytes
  h = SHA256(protocol_name);

  Define ck = 32 byte chaining key. Copy the h data to ck.
  Set ck = h

  // MixHash(null prologue)
  h = SHA256(h);

  // up until here, can all be precalculated by Alice for all outgoing connections

  // Bob&#39;s X25519 static keys
  // bpk is published in routerinfo
  bsk = GENERATE_PRIVATE()
  bpk = DERIVE_PUBLIC(bsk)

  // Bob static key
  // MixHash(bpk)
  // || below means append
  h = SHA256(h || bpk);

  // Bob introduction key
  // bik is published in routerinfo
  bik = RANDOM(32)

  // up until here, can all be precalculated by Bob for all incoming connections
</code></pre><h4 id="kdf-for-session-request-1">KDF for Session Request</h4>
<pre tabindex="0"><code>
// MixHash(header)
  h = SHA256(h || header)

  This is the &#34;e&#34; message pattern:

  // Alice&#39;s X25519 ephemeral keys
  aesk = GENERATE_PRIVATE()
  aepk = DERIVE_PUBLIC(aesk)

  // Alice ephemeral key X
  // MixHash(aepk)
  h = SHA256(h || aepk);

  // h is used as the associated data for the AEAD in Session Request
  // Retain the Hash h for the Session Created KDF


  End of &#34;e&#34; message pattern.

  This is the &#34;es&#34; message pattern:

  // DH(e, rs) == DH(s, re)
  sharedSecret = DH(aesk, bpk) = DH(bsk, aepk)

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  // ChaChaPoly parameters to encrypt/decrypt
  keydata = HKDF(chainKey, sharedSecret, &#34;&#34;, 64)
  chainKey = keydata[0:31]

  // AEAD parameters
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, payload, ad)

  // retain the chainKey for Session Created KDF


  End of &#34;es&#34; message pattern.

  // Header encryption keys for this message
  // bik = Bob&#39;s intro key
  k_header_1 = bik
  k_header_2 = bik

  // Header encryption keys for next message (Session Created)
  k_header_1 = bik
  k_header_2 = HKDF(chainKey, ZEROLEN, &#34;SessCreateHeader&#34;, 32)

  // Header encryption keys for next message (Retry)
  k_header_1 = bik
  k_header_2 = bik
</code></pre><h3 id="sessionrequest-type-0">SessionRequest (Type 0)</h3>
<p>Alice отправляет Bob&rsquo;у, либо как первое сообщение в handshake, либо в ответ на сообщение Retry. Bob отвечает сообщением Session Created. Размер: 80 + размер payload. Минимальный размер: 88</p>
<p>Если у Алисы нет действительного токена, Алиса должна отправить сообщение Token Request вместо Session Request, чтобы избежать накладных расходов на асимметричное шифрование при генерации Session Request.</p>
<p>Длинный заголовок. Содержимое Noise: эфемерный ключ Алисы X Полезная нагрузка Noise: DateTime и другие блоки Максимальный размер полезной нагрузки: MTU - 108 (IPv4) или MTU - 128 (IPv6). Для MTU 1280: Максимальная полезная нагрузка составляет 1172 (IPv4) или 1152 (IPv6). Для MTU 1500: Максимальная полезная нагрузка составляет 1392 (IPv4) или 1372 (IPv6).</p>
<p>Свойства безопасности полезной нагрузки:</p>
<pre tabindex="0"><code>XK(s, rs):           Authentication   Confidentiality
    -&gt; e, es                  0                2

    Authentication: None (0).
    This payload may have been sent by any party, including an active attacker.

    Confidentiality: 2.
    Encryption to a known recipient, forward secrecy for sender compromise
    only, vulnerable to replay.  This payload is encrypted based only on DHs
    involving the recipient&#39;s static key pair.  If the recipient&#39;s static
    private key is compromised, even at a later date, this payload can be
    decrypted.  This message can also be replayed, since there&#39;s no ephemeral
    contribution from the recipient.

    &#34;e&#34;: Alice generates a new ephemeral key pair and stores it in the e
         variable, writes the ephemeral public key as cleartext into the
         message buffer, and hashes the public key along with the old h to
         derive a new h.

    &#34;es&#34;: A DH is performed between the Alice&#39;s ephemeral key pair and the
          Bob&#39;s static key pair.  The result is hashed along with the old ck to
          derive a new ck and k, and n is set to zero.
</code></pre><p>Значение X зашифровано для обеспечения неразличимости и уникальности полезной нагрузки, что является необходимыми мерами противодействия DPI. Мы используем шифрование ChaCha20 для достижения этого, а не более сложные и медленные альтернативы, такие как elligator2. Асимметричное шифрование открытым ключом router Боба было бы слишком медленным. Шифрование ChaCha20 использует intro key Боба, опубликованный в базе данных сети.</p>
<p>Шифрование ChaCha20 предназначено только для противодействия DPI. Любая сторона, знающая ключ представления Боба, который опубликован в базе данных сети, может расшифровать заголовок и значение X в этом сообщении.</p>
<p>Необработанное содержимое:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Long Header bytes 0-15, ChaCha20     |
  +  encrypted with Bob intro key         +
  |    See Header Encryption KDF          |
  +----+----+----+----+----+----+----+----+
  |  Long Header bytes 16-31, ChaCha20    |
  +  encrypted with Bob intro key n=0     +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       X, ChaCha20 encrypted           +
  |       with Bob intro key n=0          |
  +              (32 bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaCha20 encrypted data             |
  +          (length varies)              +
  |  k defined in KDF for Session Request |
  +  n = 0                                +
  |  see KDF for associated data          |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+

  X :: 32 bytes, ChaCha20 encrypted X25519 ephemeral key, little endian
          key: Bob&#39;s intro key
          n: 1
          data: 48 bytes (bytes 16-31 of the header, followed by encrypted X)
</code></pre><p>Незашифрованные данные (тег аутентификации Poly1305 не показан):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                   X                   |
  +              (32 bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     Noise payload (block data)        |
  +          (length varies)              +
  |     see below for allowed blocks      |
  +----+----+----+----+----+----+----+----+


  Destination Connection ID :: Randomly generated by Alice

  id :: 1 byte, the network ID (currently 2, except for test networks)

  ver :: 2

  type :: 0

  flag :: 1 byte, unused, set to 0 for future compatibility

  Packet Number :: Random 4 byte number generated by Alice, ignored

  Source Connection ID :: Randomly generated by Alice,
                          must not be equal to Destination Connection ID

  Token :: 0 if not previously received from Bob

  X :: 32 bytes, X25519 ephemeral key, little endian
</code></pre><h4 id="payload">Payload</h4>
<ul>
<li>Блок DateTime</li>
<li>Блок Options (опциональный)</li>
<li>Блок Relay Tag Request (опциональный)</li>
<li>Блок Padding (опциональный)</li>
</ul>
<p>Минимальный размер полезной нагрузки составляет 8 байт. Поскольку блок DateTime содержит только 7 байт, должен присутствовать как минимум один другой блок.</p>
<h4 id="notes">Notes</h4>
<ul>
<li>
<p>Уникальное значение X в начальном блоке ChaCha20 гарантирует, что шифротекст
будет различным для каждой сессии.</p>
</li>
<li>
<p>Для обеспечения устойчивости к зондированию, Bob не должен отправлять сообщение Retry
в ответ на сообщение Session Request, если только
поля типа сообщения, версии протокола и сетевого ID в сообщении Session Request
не являются действительными.</p>
</li>
<li>
<p>Bob должен отклонять соединения, где значение временной метки слишком сильно отклоняется от
текущего времени. Назовём максимальную дельту времени &ldquo;D&rdquo;. Bob должен поддерживать локальный
кэш ранее использованных значений handshake и отклонять дубликаты для предотвращения
replay-атак. Значения в кэше должны иметь время жизни не менее 2*D.
Значения кэша зависят от реализации, однако может использоваться 32-байтовое значение X
(или его зашифрованный эквивалент).
Отклонить, отправив сообщение Retry, содержащее нулевой token и блок завершения.</p>
</li>
<li>
<p>Эфемерные ключи Диффи-Хеллмана никогда не должны использоваться повторно во избежание криптографических атак,
и повторное использование будет отклонено как replay-атака.</p>
</li>
<li>
<p>Опции &ldquo;KE&rdquo; и &ldquo;auth&rdquo; должны быть совместимы, т.е. общий секрет K должен
иметь соответствующий размер. Если будет добавлено больше опций &ldquo;auth&rdquo;, это может
неявно изменить значение флага &ldquo;KE&rdquo; для использования другого KDF или
другого размера усечения.</p>
</li>
<li>
<p>Bob должен проверить, что эфемерный ключ Alice является действительной точкой на кривой здесь.</p>
</li>
<li>
<p>Заполнение должно быть ограничено разумным количеством. Bob может отклонять соединения
с избыточным заполнением. Bob укажет свои параметры заполнения в Session Created.
Рекомендации по мин/макс значениям TBD. Случайный размер от 0 до 31 байта минимум?
(Распределение подлежит определению, см. Приложение A.)
TODO ЕСЛИ НЕ принудительный минимальный размер пакета для PMTU.</p>
</li>
<li>
<p>При большинстве ошибок, включая AEAD, DH, очевидный повтор или
ошибку валидации ключа, Боб должен остановить дальнейшую обработку
сообщения и отбросить сообщение без ответа.</p>
</li>
<li>
<p>Bob МОЖЕТ отправить сообщение Retry, содержащее нулевой токен и блок Termination с
кодом причины расхождения часов, если временная метка в блоке DateTime слишком
сильно расходится.</p>
</li>
<li>
<p>Предотвращение DoS-атак: DH является относительно ресурсоемкой операцией. Как и в случае с предыдущим протоколом NTCP, роутеры должны принимать все необходимые меры для предотвращения истощения CPU или соединений.
Установите ограничения на максимальное количество активных соединений и максимальное количество установок соединений в процессе.
Применяйте таймауты чтения (как на одно чтение, так и общее для &ldquo;slowloris&rdquo;).
Ограничивайте повторные или одновременные соединения с одного источника.
Ведите чёрные списки источников, которые регулярно терпят неудачу.
Не отвечайте на сбой AEAD. Альтернативно, отвечайте сообщением Retry
перед операцией DH и проверкой AEAD.</p>
</li>
<li>
<p>Поле &ldquo;ver&rdquo;: Общий протокол Noise, расширения и протокол SSU2,
включая спецификации полезной нагрузки, указывающий на SSU2.
Это поле может использоваться для обозначения поддержки будущих изменений.</p>
</li>
<li>
<p>Поле network ID используется для быстрой идентификации межсетевых соединений.
Если это поле не совпадает с network ID узла Bob,
Bob должен разорвать соединение и блокировать будущие подключения.</p>
</li>
<li>
<p>Bob должен отбросить сообщение, если Source Connection ID равен
Destination Connection ID.</p>
</li>
</ul>
<h3 id="kdf-for-session-created-and-session-confirmed-part-1">KDF for Session Created and Session Confirmed part 1</h3>
<pre tabindex="0"><code>
// take h saved from Session Request KDF
  // MixHash(ciphertext)
  h = SHA256(h || encrypted Noise payload from Session Request)

  // MixHash(header)
  h = SHA256(h || header)

  This is the &#34;e&#34; message pattern:

  // Bob&#39;s X25519 ephemeral keys
  besk = GENERATE_PRIVATE()
  bepk = DERIVE_PUBLIC(besk)

  // h is from KDF for Session Request
  // Bob ephemeral key Y
  // MixHash(bepk)
  h = SHA256(h || bepk);

  // h is used as the associated data for the AEAD in Session Created
  // Retain the Hash h for the Session Confirmed KDF

  End of &#34;e&#34; message pattern.

  This is the &#34;ee&#34; message pattern:

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  sharedSecret = DH(aesk, bepk) = DH(besk, aepk)
  keydata = HKDF(chainKey, sharedSecret, &#34;&#34;, 64)
  chainKey = keydata[0:31]

  // AEAD parameters
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, payload, ad)

  // retain the chaining key ck for Session Confirmed KDF

  End of &#34;ee&#34; message pattern.

  // Header encryption keys for this message
  // bik = Bob&#39;s intro key
  k_header_1 = bik
  k_header_2: See Session Request KDF above

  // Header protection keys for next message (Session Confirmed)
  k_header_1 = bik
  k_header_2 = HKDF(chainKey, ZEROLEN, &#34;SessionConfirmed&#34;, 32)
</code></pre><h3 id="миграция-соединений-1">Миграция соединений</h3>
<p>Боб отправляет Алисе в ответ на сообщение Session Request. Алиса отвечает сообщением Session Confirmed. Размер: 80 + размер полезной нагрузки. Минимальный размер: 88</p>
<p>Содержимое Noise: эфемерный ключ Боба Y Полезная нагрузка Noise: DateTime, Address и другие блоки Максимальный размер полезной нагрузки: MTU - 108 (IPv4) или MTU - 128 (IPv6). Для MTU 1280: Максимальная полезная нагрузка составляет 1172 (IPv4) или 1152 (IPv6). Для MTU 1500: Максимальная полезная нагрузка составляет 1392 (IPv4) или 1372 (IPv6).</p>
<p>Свойства безопасности полезной нагрузки:</p>
<pre tabindex="0"><code>XK(s, rs):           Authentication   Confidentiality
    &lt;- e, ee                  2                1

    Authentication: 2.
    Sender authentication resistant to key-compromise impersonation (KCI).
    The sender authentication is based on an ephemeral-static DH (&#34;es&#34; or &#34;se&#34;)
    between the sender&#39;s static key pair and the recipient&#39;s ephemeral key pair.
    Assuming the corresponding private keys are secure, this authentication cannot be forged.

    Confidentiality: 1.
    Encryption to an ephemeral recipient.
    This payload has forward secrecy, since encryption involves an ephemeral-ephemeral DH (&#34;ee&#34;).
    However, the sender has not authenticated the recipient,
    so this payload might be sent to any party, including an active attacker.


    &#34;e&#34;: Bob generates a new ephemeral key pair and stores it in the e variable,
    writes the ephemeral public key as cleartext into the message buffer,
    and hashes the public key along with the old h to derive a new h.

    &#34;ee&#34;: A DH is performed between the Bob&#39;s ephemeral key pair and the Alice&#39;s ephemeral key pair.
    The result is hashed along with the old ck to derive a new ck and k, and n is set to zero.
</code></pre><p>Значение Y зашифровано для обеспечения неразличимости и уникальности полезной нагрузки, что является необходимыми мерами противодействия DPI. Мы используем шифрование ChaCha20 для достижения этого, а не более сложные и медленные альтернативы, такие как elligator2. Асимметричное шифрование с использованием публичного ключа router&rsquo;а Alice было бы слишком медленным. Шифрование ChaCha20 использует intro key Боба, опубликованный в базе данных сети.</p>
<p>Шифрование ChaCha20 предназначено только для противодействия DPI. Любая сторона, знающая intro key Боба, который опубликован в базе данных сети, и захватившая первые 32 байта Session Request, может расшифровать значение Y в этом сообщении.</p>
<p>Исходное содержимое:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Long Header bytes 0-15, ChaCha20     |
  +  encrypted with Bob intro key and     +
  | derived key, see Header Encryption KDF|
  +----+----+----+----+----+----+----+----+
  |  Long Header bytes 16-31, ChaCha20    |
  +  encrypted with derived key n=0       +
  |  See Header Encryption KDF            |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +       Y, ChaCha20 encrypted           +
  |       with derived key n=0            |
  +              (32 bytes)               +
  |       See Header Encryption KDF       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |   ChaCha20 data                       |
  +   Encrypted and authenticated data    +
  |  length varies                        |
  +  k defined in KDF for Session Created +
  |  n = 0; see KDF for associated data   |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+

  Y :: 32 bytes, ChaCha20 encrypted X25519 ephemeral key, little endian
          key: Bob&#39;s intro key
          n: 1
          data: 48 bytes (bytes 16-31 of the header, followed by encrypted Y)
</code></pre><p>Незашифрованные данные (Poly1305 auth tag не показан):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |                  Y                    |
  +              (32 bytes)               +
  |                                       |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |     Noise payload (block data)        |
  +          (length varies)              +
  |      see below for allowed blocks     |
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: The Source Connection ID
                               received from Alice in Session Request

  id :: 1 byte, the network ID (currently 2, except for test networks)

  ver :: 2

  type :: 0

  flag :: 1 byte, unused, set to 0 for future compatibility

  Packet Number :: Random 4 byte number generated by Bob, ignored

  Source Connection ID :: The Destination Connection ID
                          received from Alice in Session Request

  Token :: 0 (unused)

  Y :: 32 bytes, X25519 ephemeral key, little endian
</code></pre><h4 id="payload-1">Payload</h4>
<ul>
<li>Блок DateTime</li>
<li>Блок Address</li>
<li>Блок Relay Tag (опциональный)</li>
<li>Блок New Token (опциональный)</li>
<li>Блок First Packet Number (опциональный)</li>
<li>Блок Options (опциональный)</li>
<li>Блок Termination (не рекомендуется, вместо этого отправляйте в retry сообщении)</li>
<li>Блок Padding (опциональный)</li>
</ul>
<p>Минимальный размер полезной нагрузки составляет 8 байт. Поскольку блоки DateTime и Address в сумме превышают это значение, требование выполняется только с этими двумя блоками.</p>
<h4 id="notes-1">Notes</h4>
<ul>
<li>
<p>Alice должна подтвердить, что эфемерный ключ Bob является действительной точкой на кривой здесь.</p>
</li>
<li>
<p>Отступы должны быть ограничены разумным количеством.
Alice может отклонять соединения с чрезмерными отступами.
Alice укажет свои опции отступов в Session Confirmed.
Рекомендации по мин/макс TBD. Случайный размер от 0 до 31 байта минимум?
(Распределение будет определено, см. Приложение A.)
TODO ЕСЛИ НЕ применяется минимальный размер пакета для PMTU.</p>
</li>
<li>
<p>При любой ошибке, включая AEAD, DH, временные метки, очевидный повтор или ошибку проверки ключа, Alice должна остановить дальнейшую обработку сообщений и закрыть соединение без ответа.</p>
</li>
<li>
<p>Alice должна отклонять соединения, где значение временной метки слишком сильно отличается от текущего времени. Назовем максимальную разность времени &ldquo;D&rdquo;. Alice должна поддерживать локальный кэш ранее использованных значений handshake и отклонять дубликаты для предотвращения атак повторного воспроизведения. Значения в кэше должны иметь время жизни не менее 2*D. Значения кэша зависят от реализации, однако может использоваться 32-байтовое значение Y (или его зашифрованный эквивалент).</p>
</li>
<li>
<p>Alice должна отбросить сообщение, если исходный IP-адрес и порт не соответствуют IP-адресу назначения и порту Session Request.</p>
</li>
<li>
<p>Алиса должна отбросить сообщение, если Destination и Source Connection IDs не соответствуют Source и Destination Connection IDs из Session Request.</p>
</li>
<li>
<p>Bob отправляет блок relay tag, если это запрошено Alice в Session Request.</p>
</li>
</ul>
<h4 id="issues">Issues</h4>
<ul>
<li>Включить опции минимального/максимального заполнения здесь?</li>
</ul>
<h3 id="kdf-for-session-confirmed-part-1-using-session-created-kdf">KDF for Session Confirmed part 1, using Session Created KDF</h3>
<pre tabindex="0"><code>
// take h saved from Session Created KDF
  // MixHash(ciphertext)
  h = SHA256(h || encrypted Noise payload from Session Created)

  // MixHash(header)
  h = SHA256(h || header)
  // h is used as the associated data for the AEAD in Session Confirmed part 1, below

  This is the &#34;s&#34; message pattern:

  // Alice&#39;s X25519 static keys
  ask = GENERATE_PRIVATE()
  apk = DERIVE_PUBLIC(ask)

  // AEAD parameters
  // k is from Session Request
  n = 1
  ad = h
  ciphertext = ENCRYPT(k, n++, apk, ad)

  // MixHash(ciphertext)
  h = SHA256(h || ciphertext);

  // h is used as the associated data for the AEAD in Session Confirmed part 2

  End of &#34;s&#34; message pattern.

  // Header encryption keys for this message
  See Session Confirmed part 2 below
</code></pre><h3 id="kdf-for-session-confirmed-part-2">KDF for Session Confirmed part 2</h3>
<pre tabindex="0"><code>
This is the &#34;se&#34; message pattern:

  // DH(ask, bepk) == DH(besk, apk)
  sharedSecret = DH(ask, bepk) = DH(besk, apk)

  // MixKey(DH())
  //[chainKey, k] = MixKey(sharedSecret)
  keydata = HKDF(chainKey, sharedSecret, &#34;&#34;, 64)
  chainKey = keydata[0:31]

  // AEAD parameters
  k = keydata[32:63]
  n = 0
  ad = h
  ciphertext = ENCRYPT(k, n, payload, ad)

  // h from Session Confirmed part 1 is used as the associated data for the AEAD in Session Confirmed part 2
  // MixHash(ciphertext)
  h = SHA256(h || ciphertext);

  // retain the chaining key ck for the data phase KDF
  // retain the hash h for the data phase KDF

  End of &#34;se&#34; message pattern.

  // Header encryption keys for this message
  // bik = Bob&#39;s intro key
  k_header_1 = bik
  k_header_2: See Session Created KDF above

  // Header protection keys for data phase
  See data phase KDF below
</code></pre><h3 id="sessionconfirmed-type-2">SessionConfirmed (Type 2)</h3>
<p>Алиса отправляет Бобу в ответ на сообщение Session Created. Боб немедленно отвечает сообщением Data, содержащим блок ACK. Размер: 80 + размер полезной нагрузки. Минимальный размер: Около 500 (минимальный размер блока router info составляет около 420 байт)</p>
<p>Содержимое Noise: статический ключ Alice Часть 1 полезной нагрузки Noise: Нет Часть 2 полезной нагрузки Noise: RouterInfo Alice и другие блоки Максимальный размер полезной нагрузки: MTU - 108 (IPv4) или MTU - 128 (IPv6). Для MTU 1280: Максимальная полезная нагрузка составляет 1172 (IPv4) или 1152 (IPv6). Для MTU 1500: Максимальная полезная нагрузка составляет 1392 (IPv4) или 1372 (IPv6).</p>
<p>Свойства безопасности полезной нагрузки:</p>
<pre tabindex="0"><code>XK(s, rs):           Authentication   Confidentiality
    -&gt; s, se                  2                5

    Authentication: 2.
    Sender authentication resistant to key-compromise impersonation (KCI).  The
    sender authentication is based on an ephemeral-static DH (&#34;es&#34; or &#34;se&#34;)
    between the sender&#39;s static key pair and the recipient&#39;s ephemeral key
    pair.  Assuming the corresponding private keys are secure, this
    authentication cannot be forged.

    Confidentiality: 5.
    Encryption to a known recipient, strong forward secrecy.  This payload is
    encrypted based on an ephemeral-ephemeral DH as well as an ephemeral-static
    DH with the recipient&#39;s static key pair.  Assuming the ephemeral private
    keys are secure, and the recipient is not being actively impersonated by an
    attacker that has stolen its static private key, this payload cannot be
    decrypted.

    &#34;s&#34;: Alice writes her static public key from the s variable into the
    message buffer, encrypting it, and hashes the output along with the old h
    to derive a new h.

    &#34;se&#34;: A DH is performed between the Alice&#39;s static key pair and the Bob&#39;s
    ephemeral key pair.  The result is hashed along with the old ck to derive a
    new ck and k, and n is set to zero.
</code></pre><p>Это содержит два ChaChaPoly фрейма. Первый — это зашифрованный статический публичный ключ Alice. Второй — это полезная нагрузка Noise: зашифрованная RouterInfo Alice, опциональные параметры и опциональное заполнение. Они используют разные ключи, поскольку функция MixKey() вызывается между ними.</p>
<p>Необработанное содержимое:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Short Header 16 bytes, ChaCha20      |
  +  encrypted with Bob intro key and     +
  | derived key, see Header Encryption KDF|
  +----+----+----+----+----+----+----+----+
  |   ChaCha20 frame (32 bytes)           |
  +   Encrypted and authenticated data    +
  +   Alice static key S                  +
  | k defined in KDF for Session Created  |
  +     n = 1                             +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  + Length varies (remainder of packet)   +
  |                                       |
  +   ChaChaPoly frame                    +
  |   Encrypted and authenticated         |
  +   see below for allowed blocks        +
  |                                       |
  +     k defined in KDF for              +
  |     Session Confirmed part 2          |
  +     n = 0                             +
  |     see KDF for associated data       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+

  S :: 32 bytes, ChaChaPoly encrypted Alice&#39;s X25519 static key, little endian
       inside 48 byte ChaChaPoly frame
</code></pre><p>Незашифрованные данные (теги аутентификации Poly1305 не показаны):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type|frag|  flags  |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |              S                        |
  +       Alice static key                +
  |          (32 bytes)                   |
  +                                       +
  |                                       |
  +                                       +
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |        Noise Payload                  |
  +        (length varies)                +
  |        see below for allowed blocks   |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: As sent in Session Request,
                               or one received in Session Confirmed?

  Packet Number :: 0 always, for all fragments, even if retransmitted

  type :: 2

  frag :: 1 byte fragment info:
         bit order: 76543210 (bit 7 is MSB)
         bits 7-4: fragment number 0-14, big endian
         bits 3-0: total fragments 1-15, big endian

  flags :: 2 bytes, unused, set to 0 for future compatibility

  S :: 32 bytes, Alice&#39;s X25519 static key, little endian
</code></pre><h4 id="payload-2">Payload</h4>
<ul>
<li>Блок RouterInfo (должен быть первым блоком)</li>
<li>Блок Options (опциональный)</li>
<li>Блок New Token (опциональный)</li>
<li>Блок Relay Request (опциональный)</li>
<li>Блок Peer Test (опциональный)</li>
<li>Блок First Packet Number (опциональный)</li>
<li>Блоки I2NP, First Fragment или Follow-on Fragment (опциональные, но вероятно нет места)</li>
<li>Блок Padding (опциональный)</li>
</ul>
<p>Минимальный размер полезной нагрузки составляет 8 байт. Поскольку блок RouterInfo будет значительно больше этого значения, требование выполняется только с этим блоком.</p>
<h4 id="notes-2">Notes</h4>
<ul>
<li>
<p>Боб должен выполнить обычную проверку Router Info.
Убедиться, что тип подписи поддерживается, проверить подпись,
проверить, что временная метка находится в допустимых пределах, и выполнить любые другие необходимые проверки.
См. ниже примечания по обработке фрагментированных Router Info.</p>
</li>
<li>
<p>Боб должен проверить, что статический ключ Алисы, полученный в первом кадре, соответствует
статическому ключу в Router Info. Боб должен сначала найти в Router Info
адрес NTCP или SSU2 router с соответствующей опцией версии (v).
См. разделы Published Router Info и Unpublished Router Info ниже.
См. ниже примечания по обработке фрагментированных Router Infos.</p>
</li>
<li>
<p>Если у Bob есть более старая версия RouterInfo Alice в его netDb, проверить, что статический ключ в router info одинаков в обеих версиях, если присутствует, и если более старая версия младше XXX (см. время ротации ключей ниже)</p>
</li>
<li>
<p>Bob должен проверить, что статический ключ Alice является действительной точкой на кривой здесь.</p>
</li>
<li>
<p>Следует включить опции для указания параметров заполнения (padding).</p>
</li>
<li>
<p>При любой ошибке, включая сбой валидации AEAD, RI, DH, временной метки или ключа,
Боб должен остановить дальнейшую обработку сообщений и закрыть соединение без
ответа.</p>
</li>
<li>
<p>Содержимое фрейма части 2 сообщения 3: Формат этого фрейма такой же, как формат фреймов фазы данных, за исключением того, что длина фрейма отправляется Алисой в Session Request. См. ниже формат фрейма фазы данных. Фрейм должен содержать от 1 до 4 блоков в следующем порядке:</p>
<ol>
<li>Блок Router Info Алисы (обязательный)</li>
<li>Блок Options (необязательный)</li>
<li>Блоки I2NP (необязательные)</li>
<li>Блок Padding (необязательный)
Этот фрейм никогда не должен содержать никаких других типов блоков.
TODO: что насчет relay и peer test?</li>
</ol>
</li>
<li>
<p>Рекомендуется блок заполнения части 2 сообщения 3.</p>
</li>
<li>
<p>Может не быть места или быть только небольшое количество места для
I2NP блоков, в зависимости от MTU и размера Router Info.
НЕ включайте I2NP блоки, если Router Info фрагментирован.
Простейшая реализация может заключаться в том, чтобы никогда не включать I2NP блоки в
сообщение Session Confirmed и отправлять все I2NP блоки в
последующих сообщениях Data.
См. раздел блока Router Info ниже для максимального размера блока.</p>
</li>
</ul>
<h4 id="session-confirmed-fragmentation">Session Confirmed Fragmentation</h4>
<p>Сообщение Session Confirmed должно содержать полную подписанную Router Info от Alice, чтобы Bob мог выполнить несколько обязательных проверок:</p>
<ul>
<li>Статический ключ &ldquo;s&rdquo; в RI соответствует статическому ключу в handshake</li>
<li>Ключ введения &ldquo;i&rdquo; в RI должен быть извлечен и действителен для использования
в фазе данных</li>
<li>Подпись RI действительна</li>
</ul>
<p>К сожалению, Router Info, даже при сжатии gzip в блоке RI, может превышать MTU. Поэтому Session Confirmed может быть фрагментирован на два или более пакетов. Это ЕДИНСТВЕННЫЙ случай в протоколе SSU2, когда AEAD-защищенная полезная нагрузка фрагментируется на два или более пакетов.</p>
<p>Заголовки для каждого пакета формируются следующим образом:</p>
<ul>
<li>ВСЕ заголовки являются короткими заголовками с одним и тем же номером пакета 0</li>
<li>ВСЕ заголовки содержат поле &ldquo;frag&rdquo; с номером фрагмента и
общим количеством фрагментов</li>
<li>Незашифрованный заголовок фрагмента 0 является ассоциированными данными (AD) для &ldquo;jumbo&rdquo; сообщения</li>
<li>Каждый заголовок шифруется, используя последние 24 байта данных в ЭТОМ пакете</li>
</ul>
<p>Постройте серию пакетов следующим образом:</p>
<ul>
<li>Создать один блок RI (фрагмент 0 из 1 в поле фрагментации блока RI).
Мы не используем фрагментацию блоков RI, это было для альтернативного метода
решения той же проблемы.</li>
<li>Создать &ldquo;джамбо&rdquo; полезную нагрузку с блоком RI и любыми другими блоками для включения</li>
<li>Вычислить общий размер данных (не включая заголовок),
который является размером полезной нагрузки + 64 байта для статического ключа и двух MAC</li>
<li>Вычислить доступное пространство в каждом пакете, которое составляет
MTU минус IP заголовок (20 или 40), минус UDP заголовок (8),
минус короткий заголовок SSU2 (16). Общие накладные расходы на пакет составляют
44 (IPv4) или 64 (IPv6).</li>
<li>Вычислить количество пакетов.</li>
<li>Вычислить размер данных в последнем пакете. Он должен быть больше или
равен 24 байтам, чтобы шифрование заголовка работало.
Если он слишком мал, либо добавить блок заполнения, ИЛИ увеличить размер
блока заполнения, если он уже присутствует, ИЛИ уменьшить размер одного из других пакетов,
чтобы последний пакет был достаточно большим.</li>
<li>Создать нешифрованный заголовок для первого пакета с общим количеством
фрагментов в поле фрагментации и зашифровать &ldquo;джамбо&rdquo;
полезную нагрузку с помощью Noise, используя заголовок как AD, как обычно.</li>
<li>Разделить зашифрованный джамбо пакет на фрагменты</li>
<li>Добавить нешифрованный заголовок для каждого фрагмента 1-n</li>
<li>Зашифровать заголовок для каждого фрагмента 0-n. Каждый заголовок использует ТЕ ЖЕ
k_header_1 и k_header_2, как определено выше в KDF Session Confirmed.</li>
<li>Передать все фрагменты</li>
</ul>
<p>Процесс сборки:</p>
<p>Когда Боб получает любое сообщение Session Confirmed, он расшифровывает заголовок, проверяет поле frag и определяет, что Session Confirmed фрагментировано. Он не расшифровывает (и не может расшифровать) сообщение до тех пор, пока все фрагменты не будут получены и собраны заново.</p>
<ul>
<li>Сохранить заголовок для фрагмента 0, поскольку он используется как Noise AD</li>
<li>Отбросить заголовки для других фрагментов перед повторной сборкой</li>
<li>Повторно собрать &ldquo;jumbo&rdquo; payload с заголовком для фрагмента 0 как AD,
и расшифровать с помощью Noise</li>
<li>Проверить блок RI как обычно</li>
<li>Перейти к фазе данных и отправить ACK 0, как обычно</li>
</ul>
<p>У Bob нет механизма для подтверждения отдельных фрагментов. Когда Bob получает все фрагменты, собирает их, расшифровывает и проверяет содержимое, Bob выполняет split() как обычно, переходит в фазу данных и отправляет ACK пакета номер 0.</p>
<p>Если Алиса не получает подтверждение ACK для пакета номер 0, она должна повторно передать все подтвержденные пакеты сессии как есть.</p>
<p>Примеры:</p>
<p>Для MTU 1500 через IPv6 максимальная полезная нагрузка составляет 1372, накладные расходы блока RI составляют 5, максимальный размер данных RI (сжатых gzip) составляет 1367 (при условии отсутствия других блоков). При использовании двух пакетов накладные расходы второго пакета составляют 64, поэтому он может содержать еще 1436 байт полезной нагрузки. Таким образом, двух пакетов достаточно для сжатого RI размером до 2803 байт.</p>
<p>Наибольший сжатый RI, наблюдаемый в текущей сети, составляет около 1400 байт; поэтому на практике двух фрагментов должно быть достаточно, даже при минимальном MTU 1280. Протокол позволяет использовать максимум 15 фрагментов.</p>
<p>Анализ безопасности:</p>
<p>Целостность и безопасность фрагментированного Session Confirmed такая же, как у нефрагментированного. Любое изменение любого фрагмента приведет к сбою Noise AEAD после пересборки. Заголовки фрагментов после фрагмента 0 используются только для идентификации фрагмента. Даже если атакующий на пути передачи получил бы ключ k_header_2, используемый для шифрования заголовка (что маловероятно, поскольку он выводится из handshake), это не позволило бы атакующему подставить валидный фрагмент.</p>
<h3 id="kdf-for-data-phase">KDF for data phase</h3>
<p>Фаза данных использует заголовок для связанных данных.</p>
<p>KDF генерирует два ключа шифрования k_ab и k_ba из ключа цепочки ck, используя HMAC-SHA256(key, data) как определено в <a href="https://tools.ietf.org/html/rfc2104">RFC 2104</a>
. Это функция split(), точно как определено в спецификации Noise.</p>
<pre tabindex="0"><code>// split()
  // chainKey = from handshake phase
  keydata = HKDF(chainKey, ZEROLEN, &#34;&#34;, 64)
  k_ab = keydata[0:31]
  k_ba = keydata[32:63]

  // key is k_ab for Alice to Bob
  // key is k_ba for Bob to Alice

  keydata = HKDF(key, ZEROLEN, &#34;HKDFSSU2DataKeys&#34;, 64)
  k_data = keydata[0:31]
  k_header_2 = keydata[32:63]


  // AEAD parameters
  k = k_data
  n = 4 byte packet number from header
  ad = 16 byte header, before header encryption
  ciphertext = ENCRYPT(k, n, payload, ad)

  // Header encryption keys for data phase
  // aik = Alice&#39;s intro key
  // bik = Bob&#39;s intro key
  k_header_1 = Receiver&#39;s intro key (aik or bik)
  k_header_2: from above
</code></pre><h3 id="data-message-type-6">Data Message (Type 6)</h3>
<p>Noise payload: Разрешены все типы блоков. Максимальный размер payload: MTU - 60 (IPv4) или MTU - 80 (IPv6). Для MTU 1500: Максимальный payload составляет 1440 (IPv4) или 1420 (IPv6).</p>
<p>Начиная со 2-й части Session Confirmed, все сообщения находятся внутри аутентифицированной и зашифрованной полезной нагрузки ChaChaPoly. Все отступы находятся внутри сообщения. Внутри полезной нагрузки находится стандартный формат с нулевым или большим количеством &ldquo;блоков&rdquo;. Каждый блок имеет однобайтовый тип и двухбайтовую длину. Типы включают дату/время, I2NP сообщение, опции, завершение и отступы.</p>
<p>Примечание: Боб может, но не обязан, отправить свою RouterInfo Алисе в качестве первого сообщения Алисе на этапе передачи данных.</p>
<p>Свойства безопасности полезной нагрузки:</p>
<pre tabindex="0"><code>XK(s, rs):           Authentication   Confidentiality
    &lt;-                        2                5
    -&gt;                        2                5

    Authentication: 2.
    Sender authentication resistant to key-compromise impersonation (KCI).
    The sender authentication is based on an ephemeral-static DH (&#34;es&#34; or &#34;se&#34;)
    between the sender&#39;s static key pair and the recipient&#39;s ephemeral key pair.
    Assuming the corresponding private keys are secure, this authentication cannot be forged.

    Confidentiality: 5.
    Encryption to a known recipient, strong forward secrecy.
    This payload is encrypted based on an ephemeral-ephemeral DH as well as
    an ephemeral-static DH with the recipient&#39;s static key pair.
    Assuming the ephemeral private keys are secure, and the recipient is not being actively impersonated
    by an attacker that has stolen its static private key, this payload cannot be decrypted.
</code></pre><h4 id="notes-3">Notes</h4>
<ul>
<li>Роутер должен отбросить сообщение с ошибкой AEAD.</li>
</ul>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Short Header 16 bytes, ChaCha20      |
  +  encrypted with intro key and         +
  |  derived key, see Data Phase KDF      |
  +----+----+----+----+----+----+----+----+
  |   ChaCha20 data                       |
  +   Encrypted and authenticated data    +
  |  length varies                        |
  +  k defined in Data Phase KDF          +
  |  n = packet number from header        |
  +                                       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><p>Незашифрованные данные (тег аутентификации Poly1305 не показан):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type|    flags     |
  +----+----+----+----+----+----+----+----+
  |     Noise payload (block data)        |
  +          (length varies)              +
  |                                       |
  +----+----+----+----+----+----+----+----+

  Destination Connection ID :: As specified in session setup

  Packet Number :: 4 byte big endian integer

  type :: 6

  flags :: 3 bytes, unused, set to 0 for future compatibility
</code></pre><h4 id="notes-4">Notes</h4>
<ul>
<li>
<p>Минимальный размер полезной нагрузки составляет 8 байт. Это требование будет выполнено
любым блоком ACK, I2NP, First Fragment или Follow-on Fragment.
Если требование не выполняется, должен быть включен блок Padding.</p>
</li>
<li>
<p>Каждый номер пакета может быть использован только один раз.
При повторной передаче I2NP сообщений или фрагментов
должен использоваться новый номер пакета.</p>
</li>
</ul>
<h3 id="kdf-for-peer-test">KDF for Peer Test</h3>
<pre tabindex="0"><code>
// AEAD parameters
  // bik = Bob&#39;s intro key
  k = bik
  n = 4 byte packet number from header
  ad = 32 byte header, before header encryption
  ciphertext = ENCRYPT(k, n, payload, ad)

  // Header encryption keys for this message
  k_header_1 = bik
  k_header_2 = bik
</code></pre><h3 id="peer-test-type-7">Peer Test (Type 7)</h3>
<p>Чарли отправляет Алисе, а Алиса отправляет Чарли, только для фаз Peer Test 5-7. Фазы Peer Test 1-4 должны отправляться внутри сессии с использованием блока Peer Test в Data сообщении. Смотрите разделы Peer Test Block и Peer Test Process ниже для получения дополнительной информации.</p>
<p>Размер: 48 + размер полезной нагрузки.</p>
<p>Полезная нагрузка Noise: См. ниже.</p>
<p>Необработанное содержимое:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Long Header bytes 0-15, ChaCha20     |
  +  encrypted with Alice or Charlie      +
  |  intro key                            |
  +----+----+----+----+----+----+----+----+
  |  Long Header bytes 16-31, ChaCha20    |
  +  encrypted with Alice or Charlie      +
  |  intro key                            |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaCha20 encrypted data             |
  +          (length varies)              +
  |                                       |
  +  see KDF for key and n                +
  |  see KDF for associated data          |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><p>Незашифрованные данные (тег аутентификации Poly1305 не показан):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+
  |    ChaCha20 payload (block data)      |
  +          (length varies)              +
  |    see below for allowed blocks       |
  +----+----+----+----+----+----+----+----+


  Destination Connection ID :: See below

  type :: 7

  ver :: 2

  id :: 1 byte, the network ID (currently 2, except for test networks)

  flag :: 1 byte, unused, set to 0 for future compatibility

  Packet Number :: Random number generated by Alice or Charlie

  Source Connection ID :: See below

  Token :: Randomly generated by Alice or Charlie, ignored
</code></pre><h4 id="длинный-заголовок">Длинный заголовок</h4>
<ul>
<li>Блок DateTime</li>
<li>Блок Address (обязателен для сообщений 6 и 7, см. примечание ниже)</li>
<li>Блок Peer Test</li>
<li>Блок Padding (опционально)</li>
</ul>
<p>Минимальный размер полезной нагрузки составляет 8 байт. Поскольку блок Peer Test в общей сложности превышает это значение, требование выполняется только с этим блоком.</p>
<p>В сообщениях 5 и 7 блок Peer Test может быть идентичен блоку из внутрисессионных сообщений 3 и 4, содержащему соглашение, подписанное Чарли, или может быть перегенерирован. Подпись опциональна.</p>
<p>В сообщении 6 блок Peer Test может быть идентичен блоку из внутрисессионных сообщений 1 и 2, содержащему запрос, подписанный Alice, или может быть сгенерирован заново. Подпись необязательна.</p>
<p>Connection IDs: Два connection ID выводятся из тестового nonce. Для сообщений 5 и 7, отправленных от Charlie к Alice, Destination Connection ID представляет собой две копии 4-байтного big-endian тестового nonce, т.е. ((nonce &laquo; 32) | nonce). Source Connection ID является обратным для Destination Connection ID, т.е. ~((nonce &laquo; 32) | nonce). Для сообщения 6, отправленного от Alice к Charlie, поменяйте местами два connection ID.</p>
<p>Содержимое блока адреса:</p>
<ul>
<li>В сообщении 5: Не требуется.</li>
<li>В сообщении 6: IP и порт Чарли, выбранные из RI Чарли.</li>
<li>В сообщении 7: Фактические IP и порт Алисы, с которых было получено сообщение 6.</li>
</ul>
<h3 id="kdf-for-retry">KDF for Retry</h3>
<p>Требование к сообщению Retry заключается в том, что Bob не должен расшифровывать сообщение Session Request для генерации сообщения Retry в ответ. Кроме того, это сообщение должно быстро генерироваться, используя только симметричное шифрование.</p>
<pre tabindex="0"><code>
// AEAD parameters
  // bik = Bob&#39;s intro key
  k = bik
  n = 4 byte packet number from header
  ad = 32 byte header, before header encryption
  ciphertext = ENCRYPT(k, n, payload, ad)

  // Header encryption keys for this message
  k_header_1 = bik
  k_header_2 = bik
</code></pre><h3 id="retry-type-9">Retry (Type 9)</h3>
<p>Bob отправляет Alice в ответ на сообщение Session Request или Token Request. Alice отвечает новым Session Request. Размер: 48 + размер полезной нагрузки.</p>
<p>Также служит как сообщение завершения (т.е. &ldquo;Не повторять&rdquo;), если включён блок завершения.</p>
<p>Полезная нагрузка Noise: См. ниже.</p>
<p>Необработанное содержимое:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Long Header bytes 0-15, ChaCha20     |
  +  encrypted with Bob intro key         +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Long Header bytes 16-31, ChaCha20    |
  +  encrypted with Bob intro key         +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaCha20 encrypted data             |
  +          (length varies)              +
  |                                       |
  +  see KDF for key and n                +
  |  see KDF for associated data          |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><p>Незашифрованные данные (тег аутентификации Poly1305 не показан):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+
  |    ChaCha20 payload (block data)      |
  +          (length varies)              +
  |    see below for allowed blocks       |
  +----+----+----+----+----+----+----+----+


  Destination Connection ID :: The Source Connection ID
                               received from Alice in Token Request
                               or Session Request

  Packet Number :: Random number generated by Bob

  type :: 9

  ver :: 2

  id :: 1 byte, the network ID (currently 2, except for test networks)

  flag :: 1 byte, unused, set to 0 for future compatibility

  Source Connection ID :: The Destination Connection ID
                          received from Alice in Token Request
                          or Session Request

  Token :: 8 byte unsigned integer, randomly generated by Bob, nonzero,
           or zero if session is rejected and a termination block is included
</code></pre><h4 id="короткий-заголовок">Короткий заголовок</h4>
<ul>
<li>Блок DateTime</li>
<li>Блок Address</li>
<li>Блок Options (опциональный)</li>
<li>Блок Termination (опциональный, если сессия отклонена)</li>
<li>Блок Padding (опциональный)</li>
</ul>
<p>Минимальный размер полезной нагрузки составляет 8 байт. Поскольку блоки DateTime и Address в сумме составляют больше этого значения, требование выполняется только с этими двумя блоками.</p>
<h4 id="нумерация-идентификаторов-соединений">Нумерация идентификаторов соединений</h4>
<ul>
<li>
<p>Для обеспечения устойчивости к зондированию router не должен отправлять сообщение Retry в ответ на сообщение Session Request или Token Request, если поля типа сообщения, версии протокола и идентификатора сети в сообщении Request не являются действительными.</p>
</li>
<li>
<p>Чтобы ограничить масштаб любой атаки усиления, которая может быть проведена с использованием поддельных адресов источника,
сообщение Retry не должно содержать большого количества дополнительных данных.
Рекомендуется, чтобы размер сообщения Retry не превышал трёхкратный размер
сообщения, на которое оно отвечает.
Альтернативно, используйте простой метод, такой как добавление случайного количества дополнительных данных
в диапазоне 1-64 байта.</p>
</li>
</ul>
<h3 id="kdf-for-token-request">KDF for Token Request</h3>
<p>Это сообщение должно быстро генерироваться, используя только симметричное шифрование.</p>
<pre tabindex="0"><code>
// AEAD parameters
  // bik = Bob&#39;s intro key
  k = bik
  n = 4 byte packet number from header
  ad = 32 byte header, before header encryption
  ciphertext = ENCRYPT(k, n, payload, ad)

  // Header encryption keys for this message
  k_header_1 = bik
  k_header_2 = bik
</code></pre><h3 id="token-request-type-10">Token Request (Type 10)</h3>
<p>Алиса отправляет Бобу. Боб отвечает сообщением Retry. Размер: 48 + размер полезной нагрузки.</p>
<p>Если у Alice нет действительного токена, Alice должна отправить это сообщение вместо Session Request, чтобы избежать накладных расходов асимметричного шифрования при генерации Session Request.</p>
<p>Полезная нагрузка Noise: См. ниже.</p>
<p>Необработанное содержимое:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Long Header bytes 0-15, ChaCha20     |
  +  encrypted with Bob intro key         +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Long Header bytes 16-31, ChaCha20    |
  +  encrypted with Bob intro key         +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaCha20 encrypted data             |
  +          (length varies)              +
  |                                       |
  +  see KDF for key and n                +
  |  see KDF for associated data          |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><p>Незашифрованные данные (тег аутентификации Poly1305 не показан):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+
  |    ChaCha20 payload (block data)      |
  +          (length varies)              +
  |    see below for allowed blocks       |
  +----+----+----+----+----+----+----+----+


  Destination Connection ID :: Randomly generated by Alice

  Packet Number :: Random number generated by Alice

  type :: 10

  ver :: 2

  id :: 1 byte, the network ID (currently 2, except for test networks)

  flag :: 1 byte, unused, set to 0 for future compatibility

  Source Connection ID :: Randomly generated by Alice,
                          must not be equal to Destination Connection ID

  Token :: zero
</code></pre><h4 id="нумерация-пакетов">Нумерация пакетов</h4>
<ul>
<li>Блок DateTime</li>
<li>Блок Padding</li>
</ul>
<p>Минимальный размер полезной нагрузки составляет 8 байт.</p>
<h4 id="привязка-заголовка">Привязка заголовка</h4>
<ul>
<li>
<p>Для обеспечения устойчивости к зондированию router не должен отправлять сообщение Retry
в ответ на сообщение Token Request, если только
поля типа сообщения, версии протокола и идентификатора сети в сообщении Token Request
не являются валидными.</p>
</li>
<li>
<p>Это НЕ стандартное Noise сообщение и не является частью handshake.
Оно не связано с сообщением Session Request, кроме как через идентификаторы соединения.</p>
</li>
<li>
<p>При большинстве ошибок, включая AEAD, или очевидный replay
Bob должен остановить дальнейшую обработку сообщений и
отбросить сообщение без ответа.</p>
</li>
<li>
<p>Bob должен отклонять соединения, где значение временной метки слишком сильно отличается от текущего времени. Назовем максимальную разность времени &ldquo;D&rdquo;. Bob должен поддерживать локальный кэш ранее использованных значений рукопожатия и отклонять дубликаты, чтобы предотвратить атаки повтора. Значения в кэше должны иметь время жизни не менее 2*D. Значения кэша зависят от реализации, однако может использоваться 32-байтное значение X (или его зашифрованный эквивалент).</p>
</li>
<li>
<p>Bob МОЖЕТ отправить сообщение Retry, содержащее нулевой токен и блок Termination с
кодом причины расхождения часов, если временная метка в блоке DateTime слишком
сильно смещена.</p>
</li>
<li>
<p>Минимальный размер: TBD, те же правила, что и для Session Created?</p>
</li>
</ul>
<h3 id="kdf-for-hole-punch">KDF for Hole Punch</h3>
<p>Это сообщение должно быть быстрым для генерации, используя только симметричное шифрование.</p>
<pre tabindex="0"><code>
// AEAD parameters
  // aik = Alice&#39;s intro key
  k = aik
  n = 4 byte packet number from header
  ad = 32 byte header, before header encryption
  ciphertext = ENCRYPT(k, n, payload, ad)

  // Header encryption keys for this message
  k_header_1 = aik
  k_header_2 = aik
</code></pre><h3 id="hole-punch-type-11">Hole Punch (Type 11)</h3>
<p>Чарли отправляет Алисе в ответ на полученное от Боба сообщение Relay Intro. Алиса отвечает новым Session Request. Размер: 48 + размер полезной нагрузки.</p>
<p>Noise payload: См. ниже.</p>
<p>Необработанное содержимое:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  Long Header bytes 0-15, ChaCha20     |
  +  encrypted with Alice intro key       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |  Long Header bytes 16-31, ChaCha20    |
  +  encrypted with Alice intro key       +
  |                                       |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |   ChaCha20 encrypted data             |
  +          (length varies)              +
  |                                       |
  +  see KDF for key and n                +
  |  see KDF for associated data          |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +        Poly1305 MAC (16 bytes)        +
  |                                       |
  +----+----+----+----+----+----+----+----+
</code></pre><p>Незашифрованные данные (тег аутентификации Poly1305 не показан):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |      Destination Connection ID        |
  +----+----+----+----+----+----+----+----+
  |   Packet Number   |type| ver| id |flag|
  +----+----+----+----+----+----+----+----+
  |        Source Connection ID           |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+
  |    ChaCha20 payload (block data)      |
  +          (length varies)              +
  |    see below for allowed blocks       |
  +----+----+----+----+----+----+----+----+


  Destination Connection ID :: See below

  Packet Number :: Random number generated by Charlie

  type :: 11

  ver :: 2

  id :: 1 byte, the network ID (currently 2, except for test networks)

  flag :: 1 byte, unused, set to 0 for future compatibility

  Source Connection ID :: See below

  Token :: 8 byte unsigned integer, randomly generated by Charlie, nonzero.
</code></pre><h4 id="шифрование-заголовков">Шифрование заголовков</h4>
<ul>
<li>Блок DateTime</li>
<li>Блок Address</li>
<li>Блок Relay Response</li>
<li>Блок Padding (опционально)</li>
</ul>
<p>Минимальный размер полезной нагрузки составляет 8 байт. Поскольку блоки DateTime и Address в сумме превышают это значение, требование выполняется только с этими двумя блоками.</p>
<p>Идентификаторы соединения: Два идентификатора соединения извлекаются из relay nonce. Destination Connection ID представляет собой две копии 4-байтового relay nonce в формате big-endian, то есть ((nonce &laquo; 32) | nonce). Source Connection ID является инверсией Destination Connection ID, то есть ~((nonce &laquo; 32) | nonce).</p>
<p>Alice должна игнорировать токен в заголовке. Токен, который следует использовать в Session Request, находится в блоке Relay Response.</p>
<h2 id="noise-payload">Noise Payload</h2>
<p>Каждая полезная нагрузка Noise содержит ноль или более &ldquo;блоков&rdquo;.</p>
<p>Это использует тот же формат блоков, как определено в спецификациях <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
 и <a href="../../../ru/docs/specs/ecies/">ECIES</a>
. Отдельные типы блоков определяются по-разному. Эквивалентный термин в QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 — это &ldquo;фреймы&rdquo;.</p>
<p>Существуют опасения, что поощрение разработчиков к совместному использованию кода может привести к проблемам с парсингом. Разработчики должны тщательно рассмотреть преимущества и риски совместного использования кода и обеспечить, чтобы правила упорядочивания и валидных блоков различались для двух контекстов.</p>
<h3 id="соображения-безопасности">Соображения безопасности</h3>
<p>В зашифрованной полезной нагрузке содержится один или несколько блоков. Блок представляет собой простой формат Tag-Length-Value (TLV). Каждый блок содержит однобайтовый идентификатор, двухбайтовую длину и ноль или более байтов данных. Этот формат идентичен используемому в <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
 и <a href="../../../ru/docs/specs/ecies/">ECIES</a>
, однако определения блоков отличаются.</p>
<p>Для расширяемости получатели должны игнорировать блоки с неизвестными идентификаторами и обрабатывать их как заполнение.</p>
<p>(Тег аутентификации Poly1305 не показан):</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |blk |  size   |       data             |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  |blk |  size   |       data             |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+
  ~               .   .   .               ~

  blk :: 1 byte, see below
  size :: 2 bytes, big endian, size of data to follow, 0 - TBD
  data :: the data
</code></pre><p>Шифрование заголовка использует последние 24 байта пакета в качестве IV для двух операций ChaCha20. Поскольку все пакеты заканчиваются 16-байтовым MAC, это требует, чтобы все полезные нагрузки пакетов были минимум 8 байт. Если полезная нагрузка иначе не соответствует этому требованию, должен быть включен блок Padding.</p>
<p>Максимальная полезная нагрузка ChaChaPoly варьируется в зависимости от типа сообщения, MTU и типа IPv4 или IPv6 адреса. Максимальная полезная нагрузка составляет MTU - 60 для IPv4 и MTU - 80 для IPv6. Максимальные данные полезной нагрузки составляют MTU - 63 для IPv4 и MTU - 83 для IPv6. Верхний предел составляет около 1440 байт для IPv4, 1500 MTU, сообщение Data. Максимальный общий размер блока равен максимальному размеру полезной нагрузки. Максимальный размер одного блока равен максимальному общему размеру блока. Тип блока составляет 1 байт. Длина блока составляет 2 байта. Максимальный размер данных одного блока равен максимальному размеру одного блока минус 3.</p>
<p>Примечания:</p>
<ul>
<li>
<p>Разработчики должны обеспечить, чтобы при чтении блока
некорректные или вредоносные данные не приводили к выходу
чтения за границы следующего блока или за пределы полезной нагрузки.</p>
</li>
<li>
<p>Реализации должны игнорировать неизвестные типы блоков для
обеспечения прямой совместимости.</p>
</li>
</ul>
<p>Типы блоков:</p>
<table>
  <thead>
      <tr>
          <th>Payload Block Type</th>
          <th>Type Number</th>
          <th>Block Length</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>DateTime</td>
          <td>0</td>
          <td>7</td>
      </tr>
      <tr>
          <td>Options</td>
          <td>1</td>
          <td>15+</td>
      </tr>
      <tr>
          <td>Router Info</td>
          <td>2</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>I2NP Message</td>
          <td>3</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>First Fragment</td>
          <td>4</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Follow-on Fragment</td>
          <td>5</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Termination</td>
          <td>6</td>
          <td>9 typ.</td>
      </tr>
      <tr>
          <td>Relay Request</td>
          <td>7</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Relay Response</td>
          <td>8</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Relay Intro</td>
          <td>9</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Peer Test</td>
          <td>10</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Next Nonce</td>
          <td>11</td>
          <td>TBD</td>
      </tr>
      <tr>
          <td>ACK</td>
          <td>12</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Address</td>
          <td>13</td>
          <td>9 or 21</td>
      </tr>
      <tr>
          <td>reserved</td>
          <td>14</td>
          <td>&ndash;</td>
      </tr>
      <tr>
          <td>Relay Tag Request</td>
          <td>15</td>
          <td>3</td>
      </tr>
      <tr>
          <td>Relay Tag</td>
          <td>16</td>
          <td>7</td>
      </tr>
      <tr>
          <td>New Token</td>
          <td>17</td>
          <td>15</td>
      </tr>
      <tr>
          <td>Path Challenge</td>
          <td>18</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>Path Response</td>
          <td>19</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>First Packet Number</td>
          <td>20</td>
          <td>7</td>
      </tr>
      <tr>
          <td>Congestion</td>
          <td>21</td>
          <td>4</td>
      </tr>
      <tr>
          <td>reserved for experimental features</td>
          <td>224-253</td>
          <td></td>
      </tr>
      <tr>
          <td>Padding</td>
          <td>254</td>
          <td>varies</td>
      </tr>
      <tr>
          <td>reserved for future extension</td>
          <td>255</td>
          <td></td>
      </tr>
  </tbody>
</table>
<h3 id="block-ordering-rules">Block Ordering Rules</h3>
<p>В Session Confirmed блок Router Info должен быть первым.</p>
<p>Во всех остальных сообщениях порядок не определен, за исключением следующих требований: Padding, если присутствует, должен быть последним блоком. Termination, если присутствует, должен быть последним блоком, за исключением Padding. Множественные блоки Padding не разрешены в одной полезной нагрузке.</p>
<h3 id="block-specifications">Block Specifications</h3>
<h4 id="функция-вывода-ключа-для-шифрования-заголовка">Функция вывода ключа для шифрования заголовка</h4>
<p>Для синхронизации времени:</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+
  | 0  |    4    |     timestamp     |
  +----+----+----+----+----+----+----+

  blk :: 0
  size :: 2 bytes, big endian, value = 4
  timestamp :: Unix timestamp, unsigned seconds.
               Wraps around in 2106
</code></pre><p>Примечания:</p>
<ul>
<li>В отличие от SSU 1, в SSU 2 нет отметки времени в заголовке пакета для фазы данных.</li>
<li>Реализации должны периодически отправлять блоки DateTime в фазе данных.</li>
<li>Реализации должны округлять до ближайшей секунды, чтобы предотвратить смещение часов в сети.</li>
</ul>
<h4 id="валидация-заголовков">Валидация заголовков</h4>
<p>Передать обновленные параметры. Параметры включают: минимальное и максимальное заполнение.</p>
<p>Блок опций будет иметь переменную длину.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 1  |  size   |tmin|tmax|rmin|rmax|tdmy|
  +----+----+----+----+----+----+----+----+
  |tdmy|  rdmy   |  tdelay |  rdelay |    |
  ~----+----+----+----+----+----+----+    ~
  |              more_options             |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 1
  size :: 2 bytes, big endian, size of options to follow, 12 bytes minimum

  tmin, tmax, rmin, rmax :: requested padding limits
      tmin and rmin are for desired resistance to traffic analysis.
      tmax and rmax are for bandwidth limits.
      tmin and tmax are the transmit limits for the router sending this options block.
      rmin and rmax are the receive limits for the router sending this options block.
      Each is a 4.4 fixed-point float representing 0 to 15.9375
      (or think of it as an unsigned 8-bit integer divided by 16.0).
      This is the ratio of padding to data. Examples:
      Value of 0x00 means no padding
      Value of 0x01 means add 6 percent padding
      Value of 0x10 means add 100 percent padding
      Value of 0x80 means add 800 percent (8x) padding
      Alice and Bob will negotiate the minimum and maximum in each direction.
      These are guidelines, there is no enforcement.
      Sender should honor receiver&#39;s maximum.
      Sender may or may not honor receiver&#39;s minimum, within bandwidth constraints.

  tdmy: Max dummy traffic willing to send, 2 bytes big endian, bytes/sec average
  rdmy: Requested dummy traffic, 2 bytes big endian, bytes/sec average
  tdelay: Max intra-message delay willing to insert, 2 bytes big endian, msec average
  rdelay: Requested intra-message delay, 2 bytes big endian, msec average

  Padding distribution specified as additional parameters?
  Random delay specified as additional parameters?

  more_options :: Format TBD
</code></pre><p>Проблемы с опциями:</p>
<ul>
<li>Согласование опций TBD.</li>
</ul>
<h4 id="routerinfo">RouterInfo</h4>
<p>Передать RouterInfo Алисы Бобу. Используется только в полезной нагрузке части 2 Session Confirmed. Не использовать в фазе данных; вместо этого используйте I2NP сообщение DatabaseStore.</p>
<p>Минимальный размер: Около 420 байт, если только идентичность router и подпись в router info не сжимаемы, что маловероятно.</p>
<p>ПРИМЕЧАНИЕ: Блок Router Info никогда не фрагментируется. Поле frag всегда имеет значение 0/1. См. раздел &ldquo;Фрагментация Session Confirmed&rdquo; выше для получения дополнительной информации.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 2  |  size   |flag|frag|              |
  +----+----+----+----+----+              +
  |                                       |
  +       Router Info fragment            +
  | (Alice RI in Session Confirmed)       |
  + (Alice, Bob, or third-party           +
  |  RI in data phase)                    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 2
  size :: 2 bytes, big endian, 2 + fragment size
  flag :: 1 byte flags
         bit order: 76543210 (bit 7 is MSB)
         bit 0: 0 for local store, 1 for flood request
         bit 1: 0 for uncompressed, 1 for gzip compressed
         bits 7-2: Unused, set to 0 for future compatibility
  frag :: 1 byte fragment info:
         bit order: 76543210 (bit 7 is MSB)
         bits 7-4: fragment number, always 0
         bits 3-0: total fragments, always 1, big endian

  routerinfo :: Alice&#39;s or Bob&#39;s RouterInfo
</code></pre><p>Примечания:</p>
<ul>
<li>
<p>Router Info опционально сжимается с помощью gzip,
что указывается битом флага 1.
Это отличается от NTCP2, где он никогда не сжимается,
и от сообщения DatabaseStore, где он всегда сжимается.
Сжатие является опциональным, поскольку обычно оно приносит мало пользы
для небольших Router Info, где мало сжимаемого содержимого,
но очень полезно для больших Router Info с несколькими
сжимаемыми Router Address.
Сжатие рекомендуется, если оно позволяет Router Info поместиться
в один пакет Session Confirmed без фрагментации.</p>
</li>
<li>
<p>Максимальный размер первого или единственного фрагмента в сообщении Session Confirmed:
MTU - 113 для IPv4 или MTU - 133 для IPv6.
Предполагая стандартный MTU в 1500 байт и отсутствие других блоков в сообщении,
1387 для IPv4 или 1367 для IPv6.
97% текущих router info меньше 1367 без сжатия gzip.
99.9% текущих router info меньше 1367 при сжатии gzip.
Предполагая минимальный MTU в 1280 байт и отсутствие других блоков в сообщении,
1167 для IPv4 или 1147 для IPv6.
94% текущих router info меньше 1147 без сжатия gzip.
97% текущих router info меньше 1147 при сжатии gzip.</p>
</li>
<li>
<p>Байт frag теперь не используется, блок Router Info никогда не фрагментируется.
Байт frag должен быть установлен в fragment 0, total fragments 1.
См. раздел Session Confirmed Fragmentation выше для получения дополнительной информации.</p>
</li>
<li>
<p>Flooding не должен запрашиваться, если в RouterInfo нет опубликованных
RouterAddresses. Принимающий router
не должен выполнять flood RouterInfo, если в нём нет опубликованных
RouterAddresses.</p>
</li>
<li>
<p>Этот протокол не предоставляет подтверждение о том, что RouterInfo
была сохранена или распространена через flood.
Если требуется подтверждение, и получатель является floodfill,
отправитель должен вместо этого отправить стандартное I2NP DatabaseStoreMessage
с токеном ответа.</p>
</li>
</ul>
<h4 id="i2np-message">I2NP Message</h4>
<p>Полное I2NP сообщение с модифицированным заголовком.</p>
<p>Это использует те же 9 байт для заголовка I2NP, как и в <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
 (тип, идентификатор сообщения, короткий срок истечения).</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 3  |  size   |type|    msg id         |
  +----+----+----+----+----+----+----+----+
  |   short exp       |     message       |
  +----+----+----+----+                   +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 3
  size :: 2 bytes, big endian, size of type + msg id + exp + message to follow
          I2NP message body size is (size - 9).
  type :: 1 byte, I2NP msg type, see I2NP spec
  msg id :: 4 bytes, big endian, I2NP message ID
  short exp :: 4 bytes, big endian, I2NP message expiration, Unix timestamp, unsigned seconds.
               Wraps around in 2106
  message :: I2NP message body
</code></pre><p>Примечания:</p>
<ul>
<li>
<p>Это тот же самый 9-байтный формат заголовка I2NP, используемый в NTCP2.</p>
</li>
<li>
<p>Это точно такой же формат, как и блок First Fragment,
но тип блока указывает, что это полное сообщение.</p>
</li>
<li>
<p>Максимальный размер, включая 9-байтный заголовок I2NP, составляет MTU - 63 для IPv4 и MTU - 83 для IPv6.</p>
</li>
</ul>
<h4 id="chacha20poly1305">ChaCha20/Poly1305</h4>
<p>Первый фрагмент (фрагмент #0) I2NP сообщения с модифицированным заголовком.</p>
<p>Это использует те же 9 байт для заголовка I2NP, как в <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
 (тип, идентификатор сообщения, короткое время истечения).</p>
<p>Общее количество фрагментов не указано.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 4  |  size   |type|    msg id         |
  +----+----+----+----+----+----+----+----+
  |   short exp       |                   |
  +----+----+----+----+                   +
  |          partial message              |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 4
  size :: 2 bytes, big endian, size of data to follow
          Fragment size is (size - 9).
  type :: 1 byte, I2NP msg type, see I2NP spec
  msg id :: 4 bytes, big endian, I2NP message ID
  short exp :: 4 bytes, big endian, I2NP message expiration, Unix timestamp, unsigned seconds.
               Wraps around in 2106
  message :: Partial I2NP message body, bytes 0 - (size - 10)
</code></pre><p>Примечания:</p>
<ul>
<li>
<p>Это тот же 9-байтовый формат заголовка I2NP, используемый в NTCP2.</p>
</li>
<li>
<p>Это точно такой же формат, как блок I2NP Message,
но тип блока указывает, что это первый фрагмент сообщения.</p>
</li>
<li>
<p>Длина частичного сообщения должна быть больше нуля.</p>
</li>
<li>
<p>Как и в SSU 1, рекомендуется отправлять последний фрагмент первым,
чтобы получатель знал общее количество фрагментов и мог
эффективно выделить буферы для приема.</p>
</li>
<li>
<p>Максимальный размер включая 9-байтовый I2NP заголовок составляет MTU - 63 для IPv4 и MTU - 83 для IPv6.</p>
</li>
</ul>
<h4 id="примечания">Примечания</h4>
<p>Дополнительный фрагмент (номер фрагмента больше нуля) I2NP сообщения.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 5  |  size   |frag|    msg id         |
  +----+----+----+----+----+----+----+----+
  |                                       |
  +                                       +
  |          partial message              |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 5
  size :: 2 bytes, big endian, size of data to follow
          Fragment size is (size - 5).
  frag :: Fragment info:
          Bit order: 76543210 (bit 7 is MSB)
          bits 7-1: fragment number 1 - 127 (0 not allowed)
          bit 0: isLast (1 = true)
  msg id :: 4 bytes, big endian, I2NP message ID
  message :: Partial I2NP message body
</code></pre><p>Примечания:</p>
<ul>
<li>
<p>Длина частичного сообщения должна быть больше нуля.</p>
</li>
<li>
<p>Как и в SSU 1, рекомендуется отправлять последний фрагмент первым,
чтобы получатель знал общее количество фрагментов и мог
эффективно выделить буферы для приёма.</p>
</li>
<li>
<p>Как и в SSU 1, максимальный номер фрагмента составляет 127, но практический
предел составляет 63 или меньше. Реализации могут ограничивать максимум до
того, что практично для максимального размера I2NP сообщения около 64 КБ,
что составляет около 55 фрагментов с минимальным MTU 1280.
См. раздел Максимальный размер I2NP сообщения ниже.</p>
</li>
<li>
<p>Максимальный размер частичного сообщения (не включая frag и message id) составляет MTU - 68 для IPv4 и MTU - 88 для IPv6.</p>
</li>
</ul>
<h4 id="обработка-ошибок-aead">Обработка ошибок AEAD</h4>
<p>Разорвать соединение. Это должен быть последний блок без заполнения в полезной нагрузке.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 6  |  size   |    valid data packets  |
  +----+----+----+----+----+----+----+----+
      received   | rsn|     addl data     |
  +----+----+----+----+                   +
  ~               .   .   .               ~
  +----+----+----+----+----+----+----+----+

  blk :: 6
  size :: 2 bytes, big endian, value = 9 or more
  valid data packets received :: The number of valid packets received
                                (current receive nonce value)
                                0 if error occurs in handshake phase
                                8 bytes, big endian
  rsn :: reason, 1 byte:
         0: normal close or unspecified
         1: termination received
         2: idle timeout
         3: router shutdown
         4: data phase AEAD failure
         5: incompatible options
         6: incompatible signature type
         7: clock skew
         8: padding violation
         9: AEAD framing error
         10: payload format error
         11: Session Request error
         12: Session Created error
         13: Session Confirmed error
         14: Timeout
         15: RI signature verification fail
         16: s parameter missing, invalid, or mismatched in RouterInfo
         17: banned
         18: bad token
         19: connection limits
         20: incompatible version
         21: wrong net ID
         22: replaced by new session
  addl data :: optional, 0 or more bytes, for future expansion, debugging,
               or reason text.
               Format unspecified and may vary based on reason code.
</code></pre><p>Примечания:</p>
<ul>
<li>Не все причины могут фактически использоваться, зависит от реализации.
Большинство сбоев обычно приведет к отбрасыванию сообщения, а не к завершению.
См. примечания в разделах сообщений handshake выше.
Дополнительные перечисленные причины предназначены для согласованности, логирования, отладки или в случае изменения политики.</li>
<li>Рекомендуется включать ACK блок вместе с Termination блоком.</li>
<li>В фазе данных, по любой причине, отличной от &ldquo;termination received&rdquo;,
узел должен ответить termination блоком с причиной &ldquo;termination received&rdquo;.</li>
</ul>
<h4 id="relayrequest">RelayRequest</h4>
<p>Отправляется в сообщении Data внутри сессии, от Alice к Bob. См. раздел Relay Process ниже.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  7 |  size   |flag|       nonce       |
  +----+----+----+----+----+----+----+----+
  |     relay tag     |     timestamp     |
  +----+----+----+----+----+----+----+----+
  | ver| asz|AlicePort|  Alice IP address |
  +----+----+----+----+----+----+----+----+
  |              signature                |
  +            length varies              +
  |         64 bytes for Ed25519          |
  ~                                       ~
  |                 . . .                 |
  +----+----+----+----+----+----+----+----+

  blk :: 7
  size :: 2 bytes, big endian, size of data to follow
  flag :: 1 byte flags, Unused, set to 0 for future compatibility

  The data below here is covered
  by the signature, and Bob forwards it unmodified.

  nonce :: 4 bytes, randomly generated by Alice
  relay tag :: 4 bytes, the itag from Charlie&#39;s RI
  timestamp :: Unix timestamp, unsigned seconds.
               Wraps around in 2106
  ver ::  1 byte SSU version to be used for the introduction:
         1: SSU 1
         2: SSU 2
  asz :: 1 byte endpoint (port + IP) size (6 or 18)
  AlicePort :: 2 byte Alice&#39;s port number, big endian
  Alice IP :: (asz - 2) byte representation of Alice&#39;s IP address,
              network byte order
  signature :: length varies, 64 bytes for Ed25519.
               Signature of prologue, Bob&#39;s hash,
               and signed data above, as signed by
               Alice.
</code></pre><p>Примечания:</p>
<ul>
<li>IP-адрес всегда включен (в отличие от SSU 1)
и может отличаться от IP, используемого для сессии.</li>
</ul>
<p>Подпись:</p>
<p>Алиса подписывает запрос и включает его в этот блок; Боб пересылает его в блоке Relay Intro к Чарли. Алгоритм подписи: Подписать следующие данные ключом подписи router-а Алисы:</p>
<ul>
<li>prologue: 16 байт &ldquo;RelayRequestData&rdquo;, не завершается нулём (не включается в сообщение)</li>
<li>bhash: 32-байтовый хеш router&rsquo;а Боба (не включается в сообщение)</li>
<li>chash: 32-байтовый хеш router&rsquo;а Чарли (не включается в сообщение)</li>
<li>nonce: 4-байтовый nonce</li>
<li>relay tag: 4-байтовый relay tag</li>
<li>timestamp: 4-байтовая временная метка (в секундах)</li>
<li>ver: 1-байтовая версия SSU</li>
<li>asz: 1-байтовый размер endpoint&rsquo;а (порт + IP) (6 или 18)</li>
<li>AlicePort: 2-байтовый номер порта Алисы</li>
<li>Alice IP: (asz - 2)-байтовый IP-адрес Алисы</li>
</ul>
<h4 id="kdf-для-начального-chainkey">KDF для начального ChainKey</h4>
<p>Отправляется в сообщении Data внутри сессии, от Чарли к Бобу или от Боба к Алисе, И в сообщении Hole Punch от Чарли к Алисе. См. раздел Relay Process ниже.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  8 |  size   |flag|code|    nonce
  +----+----+----+----+----+----+----+----+
       |     timestamp     | ver| csz|Char
  +----+----+----+----+----+----+----+----+
   Port|   Charlie IP addr |              |
  +----+----+----+----+----+              +
  |              signature                |
  +            length varies              +
  |         64 bytes for Ed25519          |
  ~                                       ~
  |                 . . .                 |
  +----+----+----+----+----+----+----+----+
  |                 Token                 |
  +----+----+----+----+----+----+----+----+

  blk :: 8
  size :: 2 bytes, 6
  flag :: 1 byte flags, Unused, set to 0 for future compatibility
  code :: 1 byte status code:
         0: accept
         1: rejected by Bob, reason unspecified
         2: rejected by Bob, Charlie is banned
         3: rejected by Bob, limit exceeded
         4: rejected by Bob, signature failure
         5: rejected by Bob, relay tag not found
         6: rejected by Bob, Alice RI not found
         7-63: other rejected by Bob codes TBD
         64: rejected by Charlie, reason unspecified
         65: rejected by Charlie, unsupported address
         66: rejected by Charlie, limit exceeded
         67: rejected by Charlie, signature failure
         68: rejected by Charlie, Alice is already connected
         69: rejected by Charlie, Alice is banned
         70: rejected by Charlie, Alice is unknown
         71-127: other rejected by Charlie codes TBD
         128: reject, source and reason unspecified
         129-255: other reject codes TBD

  The data below is covered by the signature if the code is 0 (accept).
  Bob forwards it unmodified.

  nonce :: 4 bytes, as received from Bob or Alice

  The data below is present only if the code is 0 (accept).

  timestamp :: Unix timestamp, unsigned seconds.
               Wraps around in 2106
  ver ::  1 byte SSU version to be used for the introduction:
         1: SSU 1
         2: SSU 2
  csz :: 1 byte endpoint (port + IP) size (0 or 6 or 18)
         may be 0 for some rejection codes
  CharliePort :: 2 byte Charlie&#39;s port number, big endian
                 not present if csz is 0
  Charlie IP :: (csz - 2) byte representation of Charlie&#39;s IP address,
                network byte order
                not present if csz is 0
  signature :: length varies, 64 bytes for Ed25519.
               Signature of prologue, Bob&#39;s hash,
               and signed data above, as signed by
               Charlie.
               Not present if rejected by Bob.
  token :: Token generated by Charlie for Alice to use
           in the Session Request.
           Only present if code is 0 (accept)
</code></pre><p>Примечания:</p>
<p>Токен должен быть немедленно использован Алисой в Session Request.</p>
<p>Подпись:</p>
<p>Если Чарли согласен (код ответа 0) или отклоняет (код ответа 64 или выше), Чарли подписывает ответ и включает его в этот блок; Боб пересылает его в блоке Relay Response Алисе. Алгоритм подписи: Подписать следующие данные ключом подписи router&rsquo;а Чарли:</p>
<ul>
<li>prologue: 16 байт &ldquo;RelayAgreementOK&rdquo;, без null-завершения (не включается в сообщение)</li>
<li>bhash: 32-байтный хеш router&rsquo;а Bob&rsquo;а (не включается в сообщение)</li>
<li>nonce: 4-байтный nonce</li>
<li>timestamp: 4-байтная временная метка (секунды)</li>
<li>ver: 1 байт версии SSU</li>
<li>csz: 1 байт размера endpoint&rsquo;а (порт + IP) (0 или 6 или 18)</li>
<li>CharliePort: 2-байтный номер порта Charlie (отсутствует, если csz равно 0)</li>
<li>Charlie IP: (csz - 2) байт IP-адреса Charlie (отсутствует, если csz равно 0)</li>
</ul>
<p>Если Боб отклоняет запрос (код ответа 1-63), Боб подписывает ответ и включает его в этот блок. Алгоритм подписи: Подписать следующие данные ключом подписи router&rsquo;а Боба:</p>
<ul>
<li>prologue: 16 байт &ldquo;RelayAgreementOK&rdquo;, без null-терминатора (не включается в сообщение)</li>
<li>bhash: 32-байтный router hash Боба (не включается в сообщение)</li>
<li>nonce: 4-байтный nonce</li>
<li>timestamp: 4-байтный timestamp (секунды)</li>
<li>ver: 1 байт версии SSU</li>
<li>csz: 1 байт = 0</li>
</ul>
<h4 id="kdf-для-session-request">KDF для Session Request</h4>
<p>Отправляется в сообщении Data внутри сессии, от Bob к Charlie. См. раздел Процесс ретрансляции ниже.</p>
<p>Должен предшествовать блок RouterInfo или блок I2NP сообщения DatabaseStore (или фрагмент), содержащий Router Info Алисы, либо в той же полезной нагрузке (если есть место), либо в предыдущем сообщении.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |  9 |  size   |flag|                   |
  +----+----+----+----+                   +
  |                                       |
  +                                       +
  |         Alice Router Hash             |
  +             32 bytes                  +
  |                                       |
  +                   +----+----+----+----+
  |                   |      nonce        |
  +----+----+----+----+----+----+----+----+
  |     relay tag     |     timestamp     |
  +----+----+----+----+----+----+----+----+
  | ver| asz|AlicePort|  Alice IP address |
  +----+----+----+----+----+----+----+----+
  |              signature                |
  +            length varies              +
  |         64 bytes for Ed25519          |
  ~                                       ~
  |                 . . .                 |
  +----+----+----+----+----+----+----+----+

  blk :: 9
  size :: 2 bytes, big endian, size of data to follow
  flag :: 1 byte flags, Unused, set to 0 for future compatibility
  hash :: Alice&#39;s 32-byte router hash,

  The data below here is covered
  by the signature, as received from Alice in the Relay Request,
  and Bob forwards it unmodified.

  nonce :: 4 bytes, as received from Alice
  relay tag :: 4 bytes, the itag from Charlie&#39;s RI
  timestamp :: Unix timestamp, unsigned seconds.
               Wraps around in 2106
  ver ::  1 byte SSU version to be used for the introduction:
         1: SSU 1
         2: SSU 2
  asz :: 1 byte endpoint (port + IP) size (6 or 18)
  AlicePort :: 2 byte Alice&#39;s port number, big endian
  Alice IP :: (asz - 2) byte representation of Alice&#39;s IP address,
              network byte order
  signature :: length varies, 64 bytes for Ed25519.
               Signature of prologue, Bob&#39;s hash,
               and signed data above, as signed by
               Alice.
</code></pre><p>Примечания:</p>
<ul>
<li>
<p>Для IPv4 IP-адрес Alice всегда составляет 4 байта, поскольку Alice пытается подключиться к Charlie через IPv4.
IPv6 поддерживается, и IP-адрес Alice может составлять 16 байт.</p>
</li>
<li>
<p>Для IPv4 это сообщение должно быть отправлено через установленное IPv4 соединение,
поскольку это единственный способ для Боба узнать IPv4 адрес Чарли, чтобы вернуть его Алисе в RelayResponse_.
IPv6 поддерживается, и это сообщение может быть отправлено через установленное IPv6 соединение.</p>
</li>
<li>
<p>Любой SSU адрес, опубликованный с introducers, должен содержать &ldquo;4&rdquo; или &ldquo;6&rdquo; в опции &ldquo;caps&rdquo;.</p>
</li>
</ul>
<p>Подпись:</p>
<p>Алиса подписывает запрос, и Боб пересылает его в этом блоке Чарли. Алгоритм верификации: Проверьте следующие данные с помощью ключа подписи router&rsquo;а Алисы:</p>
<ul>
<li>prologue: 16 байт &ldquo;RelayRequestData&rdquo;, не завершается нулем (не включается в сообщение)</li>
<li>bhash: 32-байтный хеш router&rsquo;а Боба (не включается в сообщение)</li>
<li>chash: 32-байтный хеш router&rsquo;а Чарли (не включается в сообщение)</li>
<li>nonce: 4-байтный nonce</li>
<li>relay tag: 4-байтный relay tag</li>
<li>timestamp: 4-байтный timestamp (секунды)</li>
<li>ver: 1-байтная версия SSU</li>
<li>asz: 1-байтный размер endpoint (порт + IP) (6 или 18)</li>
<li>AlicePort: 2-байтный номер порта Алисы</li>
<li>Alice IP: (asz - 2) байт IP-адреса Алисы</li>
</ul>
<h4 id="peertest">PeerTest</h4>
<p>Отправляется либо в сообщении Data внутри сессии, либо в сообщении Peer Test вне сессии. См. раздел &ldquo;Процесс тестирования пиров&rdquo; ниже.</p>
<p>Для сообщения 2 должен предшествовать блок RouterInfo или блок I2NP сообщения DatabaseStore (или фрагмент), содержащий Router Info Алисы, либо в той же полезной нагрузке (если есть место), либо в предыдущем сообщении.</p>
<p>Для сообщения 4, если relay принят (код причины 0), должен предшествовать блок RouterInfo или блок I2NP сообщения DatabaseStore (или фрагмент), содержащий Router Info Чарли, либо в той же полезной нагрузке (если есть место), либо в предыдущем сообщении.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 10 |  size   | msg|code|flag|         |
  +----+----+----+----+----+----+         +
  | Alice router hash (message 2 only)    |
  +             or                        +
  | Charlie router hash (message 4 only)  |
  + or all zeros if rejected by Bob       +
  | Not present in messages 1,3,5,6,7     |
  +                             +----+----+
  |                             | ver|
  +----+----+----+----+----+----+----+----+
     nonce       |     timestamp     | asz|
  +----+----+----+----+----+----+----+----+
  |AlicePort|  Alice IP address |         |
  +----+----+----+----+----+----+         +
  |              signature                |
  +            length varies              +
  |         64 bytes for Ed25519          |
  ~                                       ~
  |                 . . .                 |
  +----+----+----+----+----+----+----+----+

  blk :: 10
  size :: 2 bytes, big endian, size of data to follow
  msg :: 1 byte message number 1-7
  code :: 1 byte status code:
         0: accept
         1: rejected by Bob, reason unspecified
         2: rejected by Bob, no Charlie available
         3: rejected by Bob, limit exceeded
         4: rejected by Bob, signature failure
         5: rejected by Bob, address unsupported
         6-63: other rejected by Bob codes TBD
         64: rejected by Charlie, reason unspecified
         65: rejected by Charlie, unsupported address
         66: rejected by Charlie, limit exceeded
         67: rejected by Charlie, signature failure
         68: rejected by Charlie, Alice is already connected
         69: rejected by Charlie, Alice is banned
         70: rejected by Charlie, Alice is unknown
         70-127: other rejected by Charlie codes TBD
         128: reject, source and reason unspecified
         129-255: other reject codes TBD
         reject codes only allowed in messages 3 and 4
  flag :: 1 byte flags, Unused, set to 0 for future compatibility
  hash :: Alice&#39;s or Charlie&#39;s 32-byte router hash,
          only present in messages 2 and 4.
          All zeros (fake hash) in message 4 if rejected by Bob.

  For messages 1-4, the data below here is covered
  by the signature, if present, and Bob forwards it unmodified.

  ver :: 1 byte SSU version:
         1: SSU 1 (not supported)
         2: SSU 2 (required)
  nonce :: 4 byte test nonce, big endian
  timestamp :: Unix timestamp, unsigned seconds.
               Wraps around in 2106
  asz :: 1 byte endpoint (port + IP) size (6 or 18)
  AlicePort :: 2 byte Alice&#39;s port number, big endian
  Alice IP :: (asz - 2) byte representation of Alice&#39;s IP address,
              network byte order
  signature :: length varies, 64 bytes for Ed25519.
               Signature of prologue, Bob&#39;s hash,
               and signed data above, as signed by
               Alice or Charlie.
               Only present for messages 1-4.
               Optional in message 5-7.
</code></pre><p>Примечания:</p>
<ul>
<li>
<p>В отличие от SSU 1, сообщение 1 должно включать IP-адрес и порт Alice.</p>
</li>
<li>
<p>Тестирование IPv6-адресов поддерживается,
и связь Alice-Bob и Alice-Charlie может осуществляться через IPv6,
если Bob и Charlie указывают поддержку с помощью возможности &lsquo;B&rsquo; в своих опубликованных IPv6-адресах.
См. Proposal 126 для получения подробной информации.</p>
</li>
</ul>
<p>Алиса отправляет запрос Бобу, используя существующую сессию через транспорт (IPv4 или IPv6), который она желает протестировать. Когда Боб получает запрос от Алисы через IPv4, Боб должен выбрать Чарли, который анонсирует IPv4-адрес. Когда Боб получает запрос от Алисы через IPv6, Боб должен выбрать Чарли, который анонсирует IPv6-адрес. Фактическая коммуникация между Бобом и Чарли может происходить через IPv4 или IPv6 (т.е. независимо от типа адреса Алисы).</p>
<ul>
<li>
<p>Сообщения 1-4 должны содержаться в Data сообщении в существующей сессии.</p>
</li>
<li>
<p>Bob должен отправить RI Alice к Charlie перед отправкой сообщения 2.</p>
</li>
<li>
<p>Боб должен отправить RI Чарли Алисе до отправки сообщения 4, если принято (код причины 0).</p>
</li>
<li>
<p>Сообщения 5-7 должны содержаться в сообщении Peer Test вне сессии.</p>
</li>
<li>
<p>Сообщения 5 и 7 могут содержать те же подписанные данные, что были отправлены в сообщениях 3 и 4, или они могут быть сгенерированы заново с новой временной меткой. Подпись необязательна.</p>
</li>
<li>
<p>Сообщение 6 может содержать те же подписанные данные, что были отправлены в сообщениях 1 и 2, или может быть сгенерировано заново с новой временной меткой. Подпись является опциональной.</p>
</li>
</ul>
<p>Подписи:</p>
<p>Алиса подписывает запрос и включает его в сообщение 1; Боб пересылает его в сообщении 2 Чарли. Чарли подписывает ответ и включает его в сообщение 3; Боб пересылает его в сообщении 4 Алисе. Алгоритм подписи: Подпишите или проверьте следующие данные с помощью ключа подписи Алисы или Чарли:</p>
<ul>
<li>prologue: 16 байт &ldquo;PeerTestValidate&rdquo;, не завершается нулем (не включается в сообщение)</li>
<li>bhash: 32-байтовый хеш router&rsquo;а Bob (не включается в сообщение)</li>
<li>ahash: 32-байтовый хеш router&rsquo;а Alice
(Используется только в подписи для сообщений 3 и 4; не включается в сообщения 3 или 4)</li>
<li>ver: 1 байт версии SSU</li>
<li>nonce: 4 байта тестового nonce</li>
<li>timestamp: 4 байта временной метки (секунды)</li>
<li>asz: 1 байт размера конечной точки (порт + IP) (6 или 18)</li>
<li>AlicePort: 2 байта номера порта Alice</li>
<li>Alice IP: (asz - 2) байт IP-адреса Alice</li>
</ul>
<h4 id="полезная-нагрузка">Полезная нагрузка</h4>
<p>TODO только если мы ротируем ключи</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 11 |  size   |      TBD               |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 11
  size :: 2 bytes, big endian, size of data to follow
</code></pre><h4 id="примечания-1">Примечания</h4>
<p>4-байтовое подтверждение через, за которым следует счетчик подтверждений и ноль или более диапазонов nack/ack.</p>
<p>Данная схема адаптирована и упрощена из QUIC. Цели проектирования следующие:</p>
<ul>
<li>Мы хотим эффективно закодировать &ldquo;битовое поле&rdquo;, которое представляет
последовательность битов, обозначающих подтвержденные пакеты.</li>
<li>Битовое поле состоит в основном из единиц. И единицы, и нули
обычно идут последовательными &ldquo;группами&rdquo;.</li>
<li>Количество места в пакете, доступное для подтверждений, варьируется.</li>
<li>Самый важный бит — это бит с наибольшим номером.
Биты с меньшими номерами менее важны.
Ниже определенного расстояния от старшего бита самые старые
биты будут &ldquo;забыты&rdquo; и больше никогда не отправлены.</li>
</ul>
<p>Кодирование, описанное ниже, достигает этих целей проектирования путем отправки номера старшего бита, который установлен в 1, вместе с дополнительными последовательными битами младше этого, которые также установлены в 1. После этого, если есть место, одного или более &ldquo;диапазонов&rdquo;, указывающих количество последовательных битов 0 и последовательных битов 1 младше этого. См. QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 раздел 13.2.3 для дополнительной информации.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 12 |  size   |    Ack Through    |acnt|
  +----+----+----+----+----+----+----+----+
  |  range  |  range  |     .   .   .     |
  +----+----+----+----+                   +
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 12
  size :: 2 bytes, big endian, size of data to follow,
          5 minimum
  ack through :: highest packet number acked
  acnt :: number of acks lower than ack through also acked,
          0-255
  range :: If present,
           1 byte nack count followed by 1 byte ack count,
           0-255 each
</code></pre><p>Примеры:</p>
<p>Мы хотим отправить ACK только для пакета 10:</p>
<ul>
<li>Ack Through: 10</li>
<li>acnt: 0</li>
<li>диапазоны не включены</li>
</ul>
<p>Мы хотим отправить ACK только для пакетов 8-10:</p>
<ul>
<li>Ack Through: 10</li>
<li>acnt: 2</li>
<li>диапазоны не включены</li>
</ul>
<p>Мы хотим ACK 10 9 8 6 5 2 1 0, и NACK 7 4 3. Кодирование ACK Block:</p>
<ul>
<li>Ack Through: 10</li>
<li>acnt: 2 (ack 9 8)</li>
<li>range: 1 2 (nack 7, ack 6 5)</li>
<li>range: 2 3 (nack 4 3, ack 2 1 0)</li>
</ul>
<p>Примечания:</p>
<ul>
<li>Диапазоны могут отсутствовать. Максимальное количество диапазонов не указано,
может быть столько, сколько поместится в пакет.</li>
<li>Range nack может быть равен нулю при подтверждении более 255 последовательных пакетов.</li>
<li>Range ack может быть равен нулю при отклонении более 255 последовательных пакетов.</li>
<li>Range nack и ack не могут быть одновременно равны нулю.</li>
<li>После последнего диапазона пакеты не подтверждаются и не отклоняются.
Длина блока подтверждений и обработка старых подтверждений/отклонений
зависит от отправителя блока подтверждений.
См. разделы о подтверждениях ниже для обсуждения.</li>
<li>Ack through должен быть наивысшим номером полученного пакета,
и любые пакеты с большими номерами не были получены.
Однако в ограниченных ситуациях он может быть меньше, например,
при подтверждении одного пакета, который &ldquo;заполняет пробел&rdquo;, или при упрощенной
реализации, которая не поддерживает состояние всех полученных пакетов.
Выше наивысшего полученного пакеты не подтверждаются и не отклоняются,
но после нескольких блоков подтверждений может быть уместно перейти
в режим быстрой повторной передачи.</li>
<li>Этот формат является упрощенной версией формата из QUIC.
Он разработан для эффективного кодирования большого количества ACK,
вместе с всплесками NACK.</li>
<li>Блоки ACK используются для подтверждения пакетов фазы данных.
Они должны включаться только для пакетов фазы данных в рамках сессии.</li>
</ul>
<h4 id="address">Address</h4>
<p>2-байтный порт и 4- или 16-байтный IP-адрес. Адрес Alice, отправленный Alice от Bob, или адрес Bob, отправленный Bob от Alice.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 13 | 6 or 18 |   Port  | IP Address    
  +----+----+----+----+----+----+----+----+
       |
  +----+

  blk :: 13
  size :: 2 bytes, big endian, 6 or 18
  port :: 2 bytes, big endian
  ip :: 4 byte IPv4 or 16 byte IPv6 address,
        big endian (network byte order)
</code></pre><h4 id="relay-tag-request">Relay Tag Request</h4>
<p>Это может быть отправлено Alice в сообщении Session Request, Session Confirmed или Data. Не поддерживается в сообщении Session Created, поскольку Bob еще не имеет RI Alice и не знает, поддерживает ли Alice relay. Также, если Bob получает входящее соединение, ему, вероятно, не нужны introducers (за исключением, возможно, другого типа ipv4/ipv6).</p>
<p>При отправке в Session Request, Bob может ответить Relay Tag в сообщении Session Created, или может выбрать подождать до получения RouterInfo от Alice в Session Confirmed для проверки личности Alice перед ответом в Data сообщении. Если Bob не желает выполнять ретрансляцию для Alice, он не отправляет блок Relay Tag.</p>
<pre tabindex="0"><code>+----+----+----+
  | 15 |    0    |
  +----+----+----+

  blk :: 15
  size :: 2 bytes, big endian, value = 0
</code></pre><h4 id="полезная-нагрузка-1">Полезная нагрузка</h4>
<p>Это может быть отправлено Бобом в сообщении Session Confirmed или Data в ответ на Relay Tag Request от Алисы.</p>
<p>Когда Relay Tag Request отправляется в Session Request, Bob может ответить с Relay Tag в сообщении Session Created, или может выбрать подождать до получения RouterInfo от Alice в Session Confirmed, чтобы проверить личность Alice перед ответом в Data сообщении. Если Bob не желает выполнять relay для Alice, он не отправляет блок Relay Tag.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+
  | 16 |    4    |    relay tag      |
  +----+----+----+----+----+----+----+

  blk :: 16
  size :: 2 bytes, big endian, value = 4
  relay tag :: 4 bytes, big endian, nonzero
</code></pre><h4 id="примечания-2">Примечания</h4>
<p>Для последующего подключения. Обычно включается в сообщения Session Created и Session Confirmed. Также может быть отправлен повторно в сообщении Data долгоживущей сессии, если предыдущий токен истекает.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 17 |   12    |     expires       |
  +----+----+----+----+----+----+----+----+
                  token              |
  +----+----+----+----+----+----+----+

  blk :: 17
  size :: 2 bytes, big endian, value = 12
  expires :: Unix timestamp, unsigned seconds.
             Wraps around in 2106
  token :: 8 bytes, big endian
</code></pre><h4 id="проблемы">Проблемы</h4>
<p>Ping с произвольными данными, которые должны быть возвращены в Path Response, используется как keep-alive или для проверки изменения IP/порта.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 18 |  size   |    Arbitrary Data      |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 18
  size :: 2 bytes, big endian, size of data to follow
  data :: Arbitrary data to be returned in a Path Response
          length as selected by sender
</code></pre><p>Примечания:</p>
<p>Рекомендуется, но не требуется минимальный размер данных в 8 байт, содержащих случайные данные.</p>
<h4 id="path-response">Path Response</h4>
<p>Pong с данными, полученными в Path Challenge, как ответ на Path Challenge, используется для поддержания соединения или для валидации изменения IP/порта.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  | 19 |  size   |                        |
  +----+----+----+                        +
  |    Data received in Path Challenge    |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 19
  size :: 2 bytes, big endian, size of data to follow
  data :: As received in a Path Challenge
</code></pre><h4 id="first-packet-number">First Packet Number</h4>
<p>Опционально включается в handshake в каждом направлении для указания номера первого пакета, который будет отправлен. Это обеспечивает дополнительную безопасность для шифрования заголовков, аналогично TCP.</p>
<p>Не полностью определено, в настоящее время не поддерживается.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+
  | 20 |  size   |  First pkt number |
  +----+----+----+----+----+----+----+

  blk :: 20
  size :: 4
  pkt num :: The first packet number to be sent in the data phase
</code></pre><h4 id="congestion">Congestion</h4>
<p>Этот блок предназначен для использования в качестве расширяемого метода обмена информацией о контроле перегрузок. Контроль перегрузок может быть сложным и может развиваться по мере получения большего опыта работы с протоколом в ходе живого тестирования или после полного внедрения.</p>
<p>Это позволяет исключить любую информацию о перегрузках из часто используемых блоков I2NP, First Fragment, Followon Fragment и ACK, где нет места для выделенных флагов. Хотя в заголовке пакета Data есть три байта неиспользуемых флагов, это также обеспечивает ограниченное пространство для расширяемости и более слабую защиту шифрования.</p>
<p>Хотя использование 4-байтного блока для двух битов информации несколько расточительно, размещение этого в отдельном блоке позволяет нам легко расширить его дополнительными данными, такими как текущие размеры окон, измеренный RTT или другие флаги. Опыт показал, что одних только флаговых битов часто недостаточно и это неудобно для реализации продвинутых схем контроля перегрузки. Попытка добавить поддержку любой возможной функции контроля перегрузки, например, в блок ACK, привела бы к трате места и усложнению парсинга этого блока.</p>
<p>Реализации не должны предполагать, что другой router поддерживает какой-либо конкретный флаговый бит или функцию, включенные здесь, если только реализация не требуется будущей версией данной спецификации.</p>
<p>Этот блок должен быть, вероятно, последним блоком без заполнения в полезной нагрузке.</p>
<pre tabindex="0"><code>+----+----+----+----+
  | 21 |  size   |flag|
  +----+----+----+----+

  blk :: 21
  size :: 1 (or more if extended)
  flag :: 1 byte flags
         bit order: 76543210 (bit 7 is MSB)
         bit 0: 1 to request immediate ack
         bit 1: 1 for explicit congestion notification (ECN)
         bits 7-2: Unused, set to 0 for future compatibility
</code></pre><h4 id="полезная-нагрузка-2">Полезная нагрузка</h4>
<p>Это предназначено для заполнения внутри полезных нагрузок AEAD. Заполнение для всех сообщений находится внутри полезных нагрузок AEAD.</p>
<p>Заполнение должно приблизительно соответствовать согласованным параметрам. Bob отправил свои запрошенные параметры tx/rx min/max в Session Created. Alice отправила свои запрошенные параметры tx/rx min/max в Session Confirmed. Обновлённые опции могут быть отправлены во время фазы передачи данных. См. информацию о блоке опций выше.</p>
<p>Если присутствует, то должен быть последним блоком в полезной нагрузке.</p>
<pre tabindex="0"><code>+----+----+----+----+----+----+----+----+
  |254 |  size   |      padding           |
  +----+----+----+                        +
  |                                       |
  ~               .   .   .               ~
  |                                       |
  +----+----+----+----+----+----+----+----+

  blk :: 254
  size :: 2 bytes, big endian, size of padding to follow
  padding :: random data
</code></pre><p>Примечания:</p>
<ul>
<li>
<p>Размер = 0 разрешен.</p>
</li>
<li>
<p>Стратегии заполнения подлежат определению.</p>
</li>
<li>
<p>Минимальное заполнение подлежит определению.</p>
</li>
<li>
<p>Полезные нагрузки, содержащие только заполнение, разрешены.</p>
</li>
<li>
<p>Заполнение по умолчанию подлежит определению.</p>
</li>
<li>
<p>См. блок опций для согласования параметров заполнения</p>
</li>
<li>
<p>См. блок опций для параметров мин./макс. заполнения</p>
</li>
<li>
<p>Не превышать MTU. Если необходимо больше заполнения, отправьте несколько сообщений.</p>
</li>
<li>
<p>Ответ router&rsquo;а на нарушение согласованного заполнения зависит от реализации.</p>
</li>
<li>
<p>Длина padding должна определяться либо для каждого сообщения отдельно с учетом оценок распределения длины, либо должны добавляться случайные задержки. Эти контрмеры должны быть включены для противодействия DPI, поскольку размеры сообщений иначе выдавали бы, что I2P трафик передается транспортным протоколом. Точная схема padding является областью будущих исследований, Приложение A документа <a href="../../../ru/docs/specs/ntcp2/">NTCP2</a>
 предоставляет дополнительную информацию по этой теме.</p>
</li>
</ul>
<h2 id="replay-prevention">Replay Prevention</h2>
<p>SSU2 спроектирован для минимизации воздействия сообщений, повторно отправленных атакующим.</p>
<p>Сообщения Token Request, Retry, Session Request, Session Created, Hole Punch и внесессионные Peer Test должны содержать блоки DateTime.</p>
<p>И Алиса, и Боб проверяют, что время для этих сообщений находится в пределах допустимого отклонения (рекомендуется +/- 2 минуты). Для &ldquo;устойчивости к зондированию&rdquo; Боб не должен отвечать на сообщения Token Request или Session Request, если отклонение недопустимо, поскольку эти сообщения могут быть атакой повтора или зондирования.</p>
<p>Боб может выбрать отклонение дублирующихся сообщений Token Request и Retry, даже если расхождение времени действительно, с помощью фильтра Блума или другого механизма. Однако размер и затраты процессора на ответ на эти сообщения невелики. В худшем случае повторно отправленное сообщение Token Request может аннулировать ранее отправленный токен.</p>
<p>Система токенов значительно минимизирует воздействие повторно отправленных сообщений Session Request. Поскольку токены могут использоваться только один раз, повторно отправленное сообщение Session Request никогда не будет иметь действительный токен. Боб может выбрать отклонение дублированных сообщений Session Request, даже если смещение действительно, через фильтр Блума или другой механизм. Однако размер и CPU-затраты на ответ сообщением Retry невелики. В худшем случае отправка сообщения Retry может аннулировать ранее отправленный токен.</p>
<p>Дублированные сообщения Session Created и Session Confirmed не будут проходить валидацию, поскольку состояние рукопожатия Noise не будет находиться в правильном состоянии для их расшифровки. В худшем случае узел может повторно передать Session Confirmed в ответ на очевидно дублированное сообщение Session Created.</p>
<p>Повторные сообщения Hole Punch и Peer Test должны иметь незначительное влияние или не влиять вообще.</p>
<p>Router-ы должны использовать номер пакета сообщения данных для обнаружения и отбрасывания дублированных сообщений фазы данных. Каждый номер пакета должен использоваться только один раз. Повторно переданные сообщения должны игнорироваться.</p>
<h2 id="handshake-retransmission">Handshake Retransmission</h2>
<h3 id="session-request">Session Request</h3>
<p>Если Alice не получает Session Created или Retry:</p>
<p>Сохраняйте те же идентификаторы источника и соединения, эфемерный ключ и номер пакета 0. Или просто сохраните и повторно передайте тот же зашифрованный пакет. Номер пакета не должен увеличиваться, поскольку это изменит значение цепочечного хеша, используемого для шифрования сообщения Session Created.</p>
<p>Рекомендуемые интервалы повторной передачи: 1.25, 2.5 и 5 секунд (1.25, 3.75 и 8.75 секунд после первой отправки). Рекомендуемый таймаут: всего 15 секунд</p>
<h3 id="session-created">Session Created</h3>
<p>Если Bob не получает Session Confirmed:</p>
<p>Сохраняйте те же идентификаторы источника и соединения, эфемерный ключ и номер пакета 0. Или просто сохраните зашифрованный пакет. Номер пакета не должен увеличиваться, поскольку это изменило бы значение связанного хеша, используемого для шифрования сообщения Session Confirmed.</p>
<p>Рекомендуемые интервалы повторной передачи: 1, 2 и 4 секунды (1, 3 и 7 секунд после первой отправки). Рекомендуемый таймаут: 12 секунд общее время</p>
<h3 id="session-confirmed">Session Confirmed</h3>
<p>В SSU 1 Alice не переходит к фазе данных, пока не получит первый пакет данных от Bob. Это делает SSU 1 установкой соединения в два round-trip.</p>
<p>Для SSU 2, рекомендуемые интервалы повторной передачи Session Confirmed: 1,25, 2,5 и 5 секунд (1,25, 3,75 и 8,75 секунд после первой отправки).</p>
<p>Существует несколько альтернатив. Все имеют 1 RTT:</p>
<ol>
<li>
<p>Алиса предполагает, что Session Confirmed было получено, отправляет сообщения данных немедленно, никогда не передает Session Confirmed повторно. Пакеты данных, полученные не по порядку (до Session Confirmed), будут нерасшифруемыми, но будут переданы повторно. Если Session Confirmed потеряно, все отправленные сообщения данных будут отброшены.</p>
</li>
<li>
<p>Как в 1), отправлять сообщения с данными немедленно, но также повторно передавать Session Confirmed до получения сообщения с данными.</p>
</li>
<li>
<p>Мы могли бы использовать IK вместо XK, поскольку он имеет только два сообщения в handshake, но он использует дополнительный DH (4 вместо 3).</p>
</li>
</ol>
<p>Рекомендуемая реализация — это вариант 2). Alice должен сохранить информацию, необходимую для повторной передачи сообщения Session Confirmed. Alice также должен повторно передать все сообщения Data после того, как сообщение Session Confirmed будет повторно передано.</p>
<p>При ретрансляции Session Confirmed сохраняйте те же идентификаторы источника и соединения, эфемерный ключ и номер пакета 1. Или просто сохраните зашифрованный пакет. Номер пакета не должен увеличиваться, поскольку это изменит значение цепного хеша, которое является входным параметром для функции split().</p>
<p>Боб может сохранить (поставить в очередь) сообщения с данными, полученные до сообщения Session Confirmed. Ни ключи защиты заголовков, ни ключи дешифрования недоступны до получения сообщения Session Confirmed, поэтому Боб не знает, что это сообщения с данными, но это можно предположить. После получения сообщения Session Confirmed Боб может расшифровать и обработать сообщения с данными из очереди. Если это слишком сложно, Боб может просто отбросить нерасшифровываемые сообщения с данными, так как Алиса их ретранслирует.</p>
<p>Примечание: Если подтверждающие сессию пакеты потеряны, Bob повторно передаст session created. Заголовок session created не сможет быть расшифрован с помощью intro key Alice, поскольку он установлен с intro key Bob (если только не выполняется резервная расшифровка с intro key Bob). Bob может немедленно повторно передать подтверждающие сессию пакеты, если они ранее не были подтверждены, и получен нерасшифровываемый пакет.</p>
<h3 id="token-request">Token Request</h3>
<p>Если Алиса не получает Retry:</p>
<p>Сохраняйте одинаковые идентификаторы источника и соединения. Реализация может сгенерировать новый случайный номер пакета и зашифровать новый пакет; или может повторно использовать тот же номер пакета или просто сохранить и повторно передать тот же зашифрованный пакет. Номер пакета не должен увеличиваться, поскольку это изменило бы значение цепочного хеша, используемого для шифрования сообщения Session Created.</p>
<p>Рекомендуемые интервалы повторной передачи: 3 и 6 секунд (3 и 9 секунд после первой отправки). Рекомендуемый таймаут: 15 секунд общее время</p>
<h3 id="retry">Retry</h3>
<p>Если Bob не получает Session Request:</p>
<p>Сообщение Retry не передается повторно при истечении времени ожидания, чтобы снизить воздействие подложных адресов отправителей.</p>
<p>Однако сообщение Retry может быть повторно передано в ответ на получение повторного сообщения Session Request с исходным (недействительным) токеном, или в ответ на повторное сообщение Token Request. В любом из случаев это указывает на то, что сообщение Retry было потеряно.</p>
<p>Если получено второе сообщение Session Request с другим, но по-прежнему недействительным токеном, отбросить ожидающую сессию и не отвечать.</p>
<p>При повторной отправке сообщения Retry: Сохраняйте те же идентификаторы источника и соединения, а также токен. Реализация может сгенерировать новый случайный номер пакета и зашифровать новый пакет; Или может повторно использовать тот же номер пакета или просто сохранить и повторно передать тот же зашифрованный пакет.</p>
<h3 id="total-timeout">Total Timeout</h3>
<p>Рекомендуемый общий таймаут для handshake составляет 20 секунд.</p>
<h3 id="duplicates-and-error-handling">Duplicates and Error Handling</h3>
<p>Дубликаты трех сообщений Noise handshake Session Request, Session Created и Session Confirmed должны быть обнаружены до выполнения MixHash() заголовка. Хотя обработка Noise AEAD предположительно не удастся после этого, хэш handshake уже будет поврежден.</p>
<p>Если любое из трех сообщений повреждено и не проходит AEAD, рукопожатие не может быть впоследствии восстановлено даже при повторной передаче, поскольку MixHash() уже был вызван для поврежденного сообщения.</p>
<h2 id="tokens">Tokens</h2>
<p>Токен в заголовке Session Request используется для защиты от DoS-атак, предотвращения подмены адреса источника и обеспечения устойчивости к атакам повторного воспроизведения.</p>
<p>Если Bob не принимает токен в сообщении Session Request, Bob НЕ расшифровывает сообщение, поскольку это требует дорогостоящей операции DH. Bob просто отправляет сообщение Retry с новым токеном.</p>
<p>Если затем получено последующее сообщение Session Request с этим токеном, Боб приступает к расшифровке этого сообщения и продолжает процедуру handshake.</p>
<p>Токен должен быть случайно сгенерированным 8-байтным значением, если генератор токена сохраняет значения и связанные IP и порт (в памяти или постоянно). Генератор не может создавать непрозрачное значение, например, используя SipHash (с секретным ключом K0, K1) от IP, порта и текущего часа или дня, для создания токенов, которые не нужно сохранять в памяти, поскольку этот метод затрудняет отклонение повторно используемых токенов и replay-атак.</p>
<p>Токены могут использоваться только один раз. Токен, отправленный от Bob к Alice в сообщении Retry, должен быть использован немедленно и истекает через несколько секунд. Токен, отправленный в блоке New Token в установленной сессии, может быть использован в последующем соединении, и он истекает в время, указанное в этом блоке. Время истечения указывается отправителем; рекомендуемые значения составляют минимум один час, максимум несколько часов.</p>
<p>Если IP-адрес или порт router&rsquo;а изменяется, он должен удалить все сохранённые токены (как входящие, так и исходящие) для старого IP-адреса или порта, поскольку они больше не действительны. Токены могут опционально сохраняться при перезапуске router&rsquo;а, в зависимости от реализации. Принятие неистёкшего токена не гарантируется; если Bob забыл или удалил свои сохранённые токены, он отправит Retry сообщение Alice. Router может выбрать ограничение хранения токенов и удалять самые старые сохранённые токены, даже если они ещё не истекли.</p>
<p>Блоки New Token могут отправляться от Алисы к Бобу или от Боба к Алисе. Обычно они отправляются один раз, во время или вскоре после установления сессии. Token может быть повторно отправлен до или после истечения срока действия с новым временем истечения, или может быть отправлен новый token. Роутеры должны предполагать, что действителен только последний полученный token; нет требования хранить несколько входящих или исходящих token для одного и того же IP/порта.</p>
<p>Токен привязан к комбинации исходного IP/порта и целевого IP/порта. Токен, полученный по IPv4, не может использоваться для IPv6 и наоборот.</p>
<p>Если любой из узлов мигрирует на новый IP или порт во время сессии (см. раздел Connection Migration), любые ранее обмененные токены становятся недействительными, и необходимо обменяться новыми токенами.</p>
<p>Реализации могут, но не обязаны, сохранять токены на диске и перезагружать их при перезапуске. Если они сохраняются, реализация должна убедиться, что IP-адрес и порт не изменились с момента завершения работы, прежде чем перезагружать их.</p>
<h2 id="i2np-message-fragmentation">I2NP Message Fragmentation</h2>
<p>Различия от SSU 1</p>
<p>Примечание: Как и в SSU 1, начальный фрагмент не содержит информации об общем количестве фрагментов или общей длине. Последующие фрагменты не содержат информации о своем смещении. Это предоставляет отправителю гибкость фрагментации &ldquo;на лету&rdquo; на основе доступного места в пакете. (Java I2P этого не делает; он выполняет &ldquo;предварительную фрагментацию&rdquo; перед отправкой первого фрагмента) Однако это возлагает на получателя бремя хранения фрагментов, полученных не по порядку, и задержки сборки до получения всех фрагментов.</p>
<p>Как и в SSU 1, любая повторная передача фрагментов должна сохранять длину (и неявное смещение) предыдущей передачи фрагмента.</p>
<p>SSU 2 разделяет три случая (полное сообщение, начальный фрагмент и последующий фрагмент) на три различных типа блоков для повышения эффективности обработки.</p>
<h2 id="i2np-message-duplication">I2NP Message Duplication</h2>
<p>Этот протокол НЕ предотвращает полностью дублированную доставку I2NP сообщений. Дубликаты на IP-уровне или атаки повторного воспроизведения будут обнаружены на уровне SSU2, поскольку каждый номер пакета может использоваться только один раз.</p>
<p>Когда I2NP сообщения или фрагменты повторно передаются в новых пакетах, это не обнаруживается на уровне SSU2. Роутер должен принудительно применять истечение срока I2NP (как слишком старые, так и слишком далекие в будущем) и использовать фильтр Блума или другой механизм, основанный на идентификаторе I2NP сообщения.</p>
<p>Дополнительные механизмы могут использоваться router&rsquo;ом или в реализации SSU2 для обнаружения дубликатов. Например, SSU2 может поддерживать кэш недавно полученных идентификаторов сообщений. Это зависит от реализации.</p>
<h2 id="congestion-control">Congestion Control</h2>
<p>Данное предложение определяет протокол для нумерации пакетов и ACK блоков. Это обеспечивает достаточную информацию в реальном времени для передатчика, чтобы реализовать эффективный и отзывчивый алгоритм контроля перегрузки, при этом позволяя гибкость и инновации в данной реализации. Этот раздел обсуждает цели реализации и предоставляет рекомендации. Общие руководящие принципы можно найти в <a href="https://datatracker.ietf.org/doc/html/rfc9002">RFC 9002</a>
. См. также <a href="https://tools.ietf.org/html/rfc6298">RFC 6298</a>
 для руководства по таймерам повторной передачи.</p>
<p>Пакеты данных, содержащие только ACK, не должны учитываться в количестве байтов или пакетов в пути и не подлежат контролю перегрузок. В отличие от TCP, SSU2 может обнаруживать потерю таких пакетов, и эта информация может использоваться для корректировки состояния перегрузки. Однако в данном документе не определяется механизм для этого.</p>
<p>Пакеты, содержащие некоторые другие блоки, не являющиеся данными, также могут быть исключены из контроля перегрузки по желанию, в зависимости от реализации. Например:</p>
<ul>
<li>Тест узла</li>
<li>Запрос/представление/ответ ретранслятора</li>
<li>Вызов/ответ пути</li>
</ul>
<p>Рекомендуется, чтобы контроль перегрузки основывался на подсчете байтов, а не пакетов, следуя рекомендациям TCP RFC и QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9002">RFC 9002</a>
. Дополнительное ограничение по количеству пакетов также может быть полезным для предотвращения переполнения буфера в ядре или в промежуточных устройствах, в зависимости от реализации, хотя это может значительно усложнить систему. Если вывод пакетов по сессиям и/или общий вывод пакетов ограничен по пропускной способности и/или регулируется по времени, это может снизить необходимость в ограничении количества пакетов.</p>
<h3 id="packet-numbers">Packet Numbers</h3>
<p>В SSU 1 подтверждения (ACK) и отрицательные подтверждения (NACK) содержали номера сообщений I2NP и битовые маски фрагментов. Передатчики отслеживали статус подтверждения исходящих сообщений (и их фрагментов) и повторно передавали фрагменты по мере необходимости.</p>
<p>В SSU 2 ACK и NACK содержат номера пакетов. Передатчики должны поддерживать структуру данных с сопоставлением номеров пакетов и их содержимого. Когда пакет получает ACK или NACK, передатчик должен определить, какие I2NP сообщения и фрагменты находились в этом пакете, чтобы решить, что повторно передавать.</p>
<h3 id="session-confirmed-ack">Session Confirmed ACK</h3>
<p>Боб отправляет ACK пакета 0, который подтверждает сообщение Session Confirmed и позволяет Алисе перейти к фазе передачи данных, а также отбросить большое сообщение Session Confirmed, сохраненное для возможной повторной передачи. Это заменяет DeliveryStatusMessage, отправляемое Бобом в SSU 1.</p>
<p>Боб должен отправить ACK как можно скорее после получения сообщения Session Confirmed. Небольшая задержка (не более 50 мс) допустима, поскольку по крайней мере одно сообщение Data должно прибыть почти сразу после сообщения Session Confirmed, чтобы ACK мог подтвердить как сообщение Session Confirmed, так и сообщение Data. Это предотвратит необходимость повторной передачи сообщения Session Confirmed со стороны Боба.</p>
<h3 id="generating-acks">Generating ACKs</h3>
<p>Определение: Пакеты, требующие подтверждения: Пакеты, содержащие блоки, требующие подтверждения, вызывают ACK от получателя в пределах максимальной задержки подтверждения и называются пакетами, требующими подтверждения.</p>
<p>Router&rsquo;ы подтверждают все пакеты, которые они получают и обрабатывают. Однако только пакеты, требующие подтверждения, вызывают отправку блока ACK в пределах максимальной задержки подтверждения. Пакеты, которые не требуют подтверждения, подтверждаются только тогда, когда блок ACK отправляется по другим причинам.</p>
<p>При отправке пакета по любой причине конечная точка должна попытаться включить блок ACK, если он не был отправлен недавно. Это помогает своевременному обнаружению потерь у партнера.</p>
<p>В целом, частая обратная связь от получателя улучшает реакцию на потери и перегрузки, но это должно быть сбалансировано с избыточной нагрузкой, создаваемой получателем, который отправляет ACK блок в ответ на каждый пакет, требующий подтверждения. Приведённые ниже рекомендации направлены на достижение этого баланса.</p>
<p>Пакеты данных внутри сессии, содержащие любой блок ЗА ИСКЛЮЧЕНИЕМ следующих, требуют подтверждения:</p>
<ul>
<li>Блок ACK</li>
<li>Блок адреса</li>
<li>Блок DateTime</li>
<li>Блок заполнения</li>
<li>Блок завершения</li>
<li>Любые блоки в том же пакете, что и блок завершения</li>
<li>Другие?</li>
</ul>
<p>Пакеты, содержащие блок Termination с причиной, отличной от &ldquo;termination received&rdquo;, подтверждаются пакетом, содержащим блок Termination с &ldquo;termination received&rdquo;.</p>
<p>Пакеты вне сессии, включая сообщения handshake и сообщения peer test 5-7, имеют свои собственные механизмы подтверждения. См. ниже.</p>
<h3 id="handshake-acks">Handshake ACKs</h3>
<p>Это особые случаи:</p>
<ul>
<li>Запрос токена неявно подтверждается через Retry</li>
<li>Запрос сессии неявно подтверждается через Session Created или Retry</li>
<li>Retry неявно подтверждается через Session Request</li>
<li>Session Created неявно подтверждается через Session Confirmed</li>
<li>Session Confirmed должен быть подтвержден немедленно</li>
</ul>
<h3 id="sending-ack-blocks">Sending ACK Blocks</h3>
<p>ACK блоки используются для подтверждения пакетов фазы данных. Они должны включаться только для пакетов фазы данных в рамках сессии.</p>
<p>Каждый пакет должен быть подтвержден по крайней мере один раз, а пакеты, требующие подтверждения, должны быть подтверждены по крайней мере один раз в течение максимальной задержки.</p>
<p>Конечная точка должна немедленно подтверждать все пакеты handshake, требующие подтверждения, в пределах своей максимальной задержки, со следующим исключением. До подтверждения handshake конечная точка может не иметь ключей шифрования заголовков пакетов для расшифровки пакетов при их получении. Поэтому она может буферизовать их и подтверждать, когда необходимые ключи станут доступными.</p>
<p>Поскольку пакеты, содержащие только блоки ACK, не подлежат контролю перегрузок, конечная точка не должна отправлять более одного такого пакета в ответ на получение пакета, требующего подтверждения.</p>
<p>Конечная точка не должна отправлять пакет, не требующий подтверждения, в ответ на пакет, не требующий подтверждения, даже если есть пропуски в пакетах, предшествующие полученному пакету. Это позволяет избежать бесконечного цикла обратной связи подтверждений, который мог бы помешать соединению когда-либо перейти в состояние простоя. Пакеты, не требующие подтверждения, в конечном итоге подтверждаются, когда конечная точка отправляет ACK блок в ответ на другие события.</p>
<p>Конечная точка, которая отправляет только ACK блоки, не будет получать подтверждения от своего партнера, если эти подтверждения не включены в пакеты с блоками, требующими подтверждения. Конечная точка должна отправлять ACK блок с другими блоками, когда есть новые пакеты, требующие подтверждения, которые нужно подтвердить. Когда нужно подтвердить только пакеты, не требующие подтверждения, конечная точка МОЖЕТ выбрать не отправлять ACK блок с исходящими блоками до тех пор, пока не будет получен пакет, требующий подтверждения.</p>
<p>Конечная точка, которая отправляет только пакеты, не требующие подтверждения, может иногда добавлять к таким пакетам блок, требующий подтверждения, чтобы гарантировать получение acknowledgment. В таком случае конечная точка НЕ ДОЛЖНА отправлять блок, требующий подтверждения, во всех пакетах, которые иначе не требовали бы подтверждения, чтобы избежать бесконечного цикла обратной связи подтверждений.</p>
<p>Чтобы помочь отправителю обнаружить потери, конечная точка должна генерировать и отправлять блок ACK без задержки при получении пакета, вызывающего подтверждение, в любом из следующих случаев:</p>
<ul>
<li>
<p>Когда полученный пакет имеет номер пакета меньше, чем у другого
пакета, требующего подтверждения, который уже был получен</p>
</li>
<li>
<p>Когда пакет имеет номер пакета больше, чем у пакета с наивысшим
номером, требующего подтверждения, который был получен, и есть
пропущенные пакеты между тем пакетом и этим пакетом.</p>
</li>
<li>
<p>Когда установлен флаг ack-immediate в заголовке пакета</p>
</li>
</ul>
<p>Ожидается, что алгоритмы будут устойчивы к получателям, которые не следуют приведенным выше рекомендациям. Однако реализация должна отклоняться от этих требований только после тщательного рассмотрения влияния изменения на производительность, как для соединений, устанавливаемых конечной точкой, так и для других пользователей сети.</p>
<h3 id="ack-frequency">ACK Frequency</h3>
<p>Получатель определяет, как часто отправлять подтверждения в ответ на пакеты, требующие подтверждения. Это решение включает в себя компромисс.</p>
<p>Конечные точки полагаются на своевременное подтверждение для обнаружения потерь. Контроллеры перегрузок, основанные на окне, полагаются на подтверждения для управления своим окном перегрузки. В обоих случаях задержка подтверждений может негативно повлиять на производительность.</p>
<p>С другой стороны, снижение частоты пакетов, которые содержат только подтверждения, уменьшает затраты на передачу и обработку пакетов на обеих конечных точках. Это может улучшить пропускную способность соединения на сильно асимметричных линиях связи и снизить объем трафика подтверждений, использующего пропускную способность обратного пути; см. раздел 3 <a href="https://tools.ietf.org/html/rfc3449">RFC 3449</a>
.</p>
<p>Получатель должен отправить блок ACK после получения как минимум двух пакетов, требующих подтверждения. Данная рекомендация носит общий характер и согласуется с рекомендациями для поведения конечных точек TCP <a href="https://tools.ietf.org/html/rfc5681">RFC 5681</a>
. Знание сетевых условий, знание контроллера перегрузки узла или дальнейшие исследования и эксперименты могут предложить альтернативные стратегии подтверждения с лучшими характеристиками производительности.</p>
<p>Получатель может обработать несколько доступных пакетов перед тем, как определить, следует ли отправить блок ACK в ответ. В общем случае, получатель не должен задерживать ACK более чем на RTT / 6, или максимум 150 мс.</p>
<p>Флаг ack-immediate в заголовке пакета данных является запросом на то, чтобы получатель отправил подтверждение вскоре после получения, вероятно, в течение нескольких миллисекунд. В общем случае получатель не должен задерживать немедленное ACK более чем на RTT / 16 или максимум 5 мс.</p>
<h3 id="immediate-ack-flag">Immediate ACK Flag</h3>
<p>Получатель не знает размер окна отправки отправителя и поэтому не знает, как долго задерживать отправку ACK. Флаг немедленного ACK в заголовке пакета данных является важным способом поддержания максимальной пропускной способности путем минимизации эффективного RTT. Флаг немедленного ACK находится в байте 13 заголовка, бит 0, т.е. (header[13] &amp; 0x01). Когда установлен, запрашивается немедленный ACK. См. раздел о коротком заголовке выше для подробностей.</p>
<p>Существует несколько возможных стратегий, которые отправитель может использовать для определения того, когда устанавливать флаг immediate-ack:</p>
<ul>
<li>Устанавливается один раз каждые N пакетов, для некоторого малого N</li>
<li>Устанавливается на последнем пакете в серии пакетов</li>
<li>Устанавливается когда окно отправки почти заполнено, например заполнено более чем на 2/3</li>
<li>Устанавливается на всех пакетах с повторно переданными фрагментами</li>
</ul>
<p>Флаги немедленного ACK должны быть необходимы только для пакетов данных, содержащих I2NP сообщения или фрагменты сообщений.</p>
<h3 id="ack-block-size">ACK Block Size</h3>
<p>Когда отправляется блок ACK, включаются один или несколько диапазонов подтвержденных пакетов. Включение подтверждений для более старых пакетов снижает вероятность ложных повторных передач, вызванных потерей ранее отправленных блоков ACK, за счет увеличения размера блоков ACK.</p>
<p>Блоки ACK всегда должны подтверждать самые недавно полученные пакеты, и чем больше нарушен порядок пакетов, тем важнее быстро отправить обновленный блок ACK, чтобы предотвратить объявление пира о потере пакета и ложную ретрансмиссию содержащихся в нем блоков. Блок ACK должен помещаться в один пакет. Если это не так, то более старые диапазоны (те, что с наименьшими номерами пакетов) опускаются.</p>
<p>Получатель ограничивает количество диапазонов ACK, которые он запоминает и отправляет в блоках ACK, как для ограничения размера блоков ACK, так и для предотвращения исчерпания ресурсов. После получения подтверждений для блока ACK получатель должен прекратить отслеживание этих подтвержденных диапазонов ACK. Отправители могут ожидать подтверждения для большинства пакетов, но данный протокол не гарантирует получение подтверждения для каждого пакета, который обрабатывает получатель.</p>
<p>Возможно, что сохранение множества ACK диапазонов может привести к тому, что ACK блок станет слишком большим. Получатель может отбросить неподтверждённые ACK диапазоны для ограничения размера ACK блока, ценой увеличения повторных передач от отправителя. Это необходимо, если ACK блок будет слишком большим для размещения в пакете. Получатели также могут дополнительно ограничивать размер ACK блока для сохранения места для других блоков или для ограничения пропускной способности, потребляемой подтверждениями.</p>
<p>Получатель должен сохранять диапазон ACK, если только он не может гарантировать, что впоследствии не будет принимать пакеты с номерами в этом диапазоне. Поддержание минимального номера пакета, который увеличивается по мере отбрасывания диапазонов, является одним из способов достижения этого с минимальным состоянием.</p>
<p>Получатели могут отбросить все диапазоны ACK, но они должны сохранить наибольший номер пакета, который был успешно обработан, поскольку он используется для восстановления номеров пакетов из последующих пакетов.</p>
<p>Следующий раздел описывает примерный подход для определения, какие пакеты подтверждать в каждом ACK блоке. Хотя целью данного алгоритма является генерация подтверждения для каждого обработанного пакета, всё ещё возможна потеря подтверждений.</p>
<h3 id="limiting-ranges-by-tracking-ack-blocks">Limiting Ranges by Tracking ACK Blocks</h3>
<p>Когда отправляется пакет, содержащий блок ACK, поле Ack Through в этом блоке может быть сохранено. Когда пакет, содержащий блок ACK, подтверждается, получатель может прекратить подтверждение пакетов меньше или равных полю Ack Through в отправленном блоке ACK.</p>
<p>Получатель, который отправляет только пакеты, не требующие подтверждения, такие как блоки ACK, может не получать подтверждение в течение длительного периода времени. Это может привести к тому, что получатель будет поддерживать состояние для большого количества блоков ACK в течение длительного периода времени, и отправляемые им блоки ACK могут быть излишне большими. В таком случае получатель мог бы периодически отправлять PING или другой небольшой блок, требующий подтверждения, например, один раз за цикл передачи, чтобы получить ACK от узла.</p>
<p>В случаях без потери блоков ACK этот алгоритм позволяет минимальную переупорядоченность в 1 RTT. В случаях с потерей блоков ACK и переупорядочиванием этот подход не гарантирует, что каждое подтверждение будет получено отправителем до того, как оно больше не будет включено в блок ACK. Пакеты могут быть получены не по порядку, и все последующие блоки ACK, содержащие их, могут быть потеряны. В этом случае алгоритм восстановления после потерь может вызвать ложные повторные передачи, но отправитель будет продолжать продвигаться вперед.</p>
<h3 id="congestion-1">Congestion</h3>
<p>I2P транспорты не гарантируют доставку I2NP сообщений в порядке отправки. Поэтому потеря Data сообщения, содержащего одно или несколько I2NP сообщений или фрагментов, НЕ препятствует доставке других I2NP сообщений; блокировки начала очереди не происходит. Реализации должны продолжать отправку новых сообщений во время фазы восстановления после потерь, если окно отправки это позволяет.</p>
<h3 id="retransmission">Retransmission</h3>
<p>Отправитель не должен сохранять полное содержимое сообщения для идентичной повторной передачи (за исключением сообщений handshake, см. выше). Отправитель должен собирать сообщения, содержащие актуальную информацию (ACK, NACK и неподтвержденные данные) каждый раз при отправке сообщения. Отправитель должен избегать повторной передачи информации из сообщений после их подтверждения. Это включает сообщения, которые подтверждаются после того, как они были объявлены потерянными, что может произойти при изменении порядка пакетов в сети.</p>
<h3 id="window">Window</h3>
<p>TBD. Общие рекомендации можно найти в <a href="https://datatracker.ietf.org/doc/html/rfc9002">RFC 9002</a>
.</p>
<h2 id="connection-migration-1">Connection Migration</h2>
<p>IP-адрес или порт пира может изменяться в течение жизни сессии. Изменение IP может быть вызвано ротацией временных адресов IPv6, периодическим изменением IP со стороны провайдера, переходом мобильного клиента между WiFi и сотовыми IP, или другими изменениями в локальной сети. Изменение порта может быть вызвано повторной привязкой NAT после истечения времени действия предыдущей привязки.</p>
<p>IP-адрес или порт узла может показаться изменившимся из-за различных атак на пути передачи данных и вне его, включая модификацию или внедрение пакетов.</p>
<p>Миграция соединения — это процесс, при котором проверяется новая исходная конечная точка (IP+порт), предотвращая изменения, которые не были проверены. Этот процесс представляет собой упрощенную версию процесса, определенного в QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
. Данный процесс определен только для фазы передачи данных сессии. Миграция не разрешена во время хэндшейка. Все пакеты хэндшейка должны быть проверены как отправленные с того же IP и порта, что и ранее отправленные и полученные пакеты. Другими словами, IP и порт узла должны оставаться постоянными во время хэндшейка.</p>
<h3 id="threat-model">Threat Model</h3>
<p>(Адаптировано из QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
)</p>
<h4 id="примечания-3">Примечания</h4>
<p>Пир может подделать свой исходный адрес, чтобы заставить конечную точку отправлять чрезмерные объемы данных на нежелающий хост. Если конечная точка отправляет значительно больше данных, чем подделывающий пир, миграция соединения может быть использована для усиления объема данных, которые атакующий может генерировать в направлении жертвы.</p>
<h4 id="фрагментация-подтвержденной-сессии">Фрагментация подтвержденной сессии</h4>
<p>Атакующий на пути передачи может вызвать ложную миграцию соединения, скопировав и переслав пакет с поддельным адресом таким образом, чтобы он прибыл раньше исходного пакета. Пакет с поддельным адресом будет рассматриваться как пришедший от мигрирующего соединения, а исходный пакет будет расценен как дубликат и отброшен. После ложной миграции валидация исходного адреса не удастся, поскольку объект по исходному адресу не имеет необходимых криптографических ключей для чтения или ответа на Path Challenge, который отправляется ему, даже если бы он этого хотел.</p>
<h4 id="off-path-packet-forwarding">Off-Path Packet Forwarding</h4>
<p>Атакующий, находящийся вне пути передачи данных и способный наблюдать за пакетами, может пересылать копии подлинных пакетов конечным точкам. Если скопированный пакет прибудет раньше подлинного пакета, это будет выглядеть как повторное связывание NAT. Любой подлинный пакет будет отброшен как дубликат. Если атакующий сможет продолжать пересылку пакетов, он может вызвать миграцию на путь через атакующего. Это помещает атакующего на путь передачи данных, давая ему возможность наблюдать или отбрасывать все последующие пакеты.</p>
<h4 id="privacy-implications">Privacy Implications</h4>
<p>QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 определяет изменение идентификаторов соединения при смене сетевых путей. Использование стабильного идентификатора соединения на нескольких сетевых путях позволило бы пассивному наблюдателю коррелировать активность между этими путями. Конечная точка, которая перемещается между сетями, может не желать, чтобы её активность коррелировалась каким-либо субъектом, кроме её партнёра. Однако QUIC не шифрует идентификаторы соединения в заголовке. SSU2 это делает, поэтому утечка конфиденциальности потребовала бы от пассивного наблюдателя также иметь доступ к базе данных сети для получения ключа представления, необходимого для расшифровки идентификатора соединения. Даже с ключом представления это не является сильной атакой, и мы не изменяем идентификаторы соединения после миграции в SSU2, поскольку это было бы значительным усложнением.</p>
<h3 id="initiating-path-validation">Initiating Path Validation</h3>
<p>Во время фазы данных пиры должны проверять исходный IP-адрес и порт каждого полученного пакета данных. Если IP-адрес или порт отличается от ранее полученных, И пакет не является дублирующим по номеру, И пакет успешно расшифровывается, сессия переходит в фазу валидации пути.</p>
<p>Дополнительно, узел должен проверить, что новые IP и порт являются действительными согласно локальным правилам валидации (не заблокированы, не являются запрещенными портами и т.д.). Узлы НЕ обязаны поддерживать миграцию между IPv4 и IPv6, и могут рассматривать новый IP из другого семейства адресов как недействительный, поскольку это не ожидаемое поведение и может добавить значительную сложность реализации. При получении пакета с недействительного IP/порта, реализация может просто отбросить его, или может инициировать валидацию пути со старым IP/портом.</p>
<p>После входа в фазу валидации пути выполните следующие шаги:</p>
<ul>
<li>Запустить таймер тайм-аута валидации пути на несколько секунд,
или несколько раз больше текущего RTO (уточняется)</li>
<li>Уменьшить окно перегрузки до минимума</li>
<li>Уменьшить PMTU до минимума (1280)</li>
<li>Отправить пакет данных, содержащий блок Path Challenge,
блок Address (содержащий новый IP/порт),
и, как правило, блок ACK, на новый IP и порт.
Этот пакет использует тот же connection ID и ключи шифрования,
что и текущая сессия.
Данные блока Path Challenge должны содержать достаточную энтропию
(не менее 8 байт), чтобы их нельзя было подделать.</li>
<li>Опционально, также отправить Path Challenge на старый IP/порт,
с другими данными блока. См. ниже.</li>
<li>Запустить таймер тайм-аута Path Response на основе текущего
RTO (обычно RTT + кратное RTTdev)</li>
</ul>
<p>Во время фазы валидации пути сессия может продолжать обрабатывать входящие пакеты. Как от старого, так и от нового IP/порта. Сессия также может продолжать отправлять и подтверждать пакеты данных. Однако окно перегрузки и PMTU должны оставаться на минимальных значениях во время фазы валидации пути, чтобы предотвратить их использование для атак типа &ldquo;отказ в обслуживании&rdquo; путем отправки больших объемов трафика на подложный адрес.</p>
<p>Реализация может, но не обязана, пытаться проверить несколько путей одновременно. Вероятно, это не стоит сложности. Она может, но не обязана, запоминать предыдущий IP/порт как уже проверенный и пропускать проверку пути, если узел возвращается к своему предыдущему IP/порту.</p>
<p>Если получен Path Response, содержащий идентичные данные, отправленные в Path Challenge, то Path Validation прошла успешно. Исходный IP/порт сообщения Path Response не обязан совпадать с тем, на который был отправлен Path Challenge.</p>
<p>Если Path Response не получен до истечения таймера Path Response, отправить другой Path Challenge и удвоить таймер Path Response.</p>
<p>Если Path Response не получен до истечения таймера Path Validation, то проверка пути не удалась.</p>
<h3 id="message-contents">Message Contents</h3>
<p>Сообщения Data должны содержать следующие блоки. Порядок не указан, за исключением того, что Padding должен быть последним:</p>
<ul>
<li>Блок Path Validation или Path Response.
Path Validation содержит непрозрачные данные, рекомендуется минимум 8 байт.
Path Response содержит данные из Path Validation.</li>
<li>Блок Address, содержащий видимый IP получателя</li>
<li>Блок DateTime</li>
<li>Блок ACK</li>
<li>Блок Padding</li>
</ul>
<p>Не рекомендуется включать какие-либо другие блоки (например, I2NP) в сообщение.</p>
<p>Разрешается включать блок Path Validation в сообщение, содержащее Path Response, для инициации валидации в обратном направлении.</p>
<p>Блоки Path Challenge и Path Response вызывают подтверждение. Path Challenge будет подтвержден Data-сообщением, содержащим блоки Path Response и ACK. Path Response должен быть подтвержден Data-сообщением, содержащим блок ACK.</p>
<h3 id="routing-during-path-validation">Routing during Path Validation</h3>
<p>Спецификация QUIC не является четкой относительно того, куда отправлять пакеты данных во время валидации пути - на старый или новый IP/порт? Необходимо найти баланс между быстрым реагированием на изменения IP/порта и предотвращением отправки трафика на поддельные адреса. Также поддельные пакеты не должны существенно влиять на существующую сессию. Изменения только порта, вероятно, вызваны повторным связыванием NAT после периода простоя; изменения IP могут происходить во время фаз высокого трафика в одном или обоих направлениях.</p>
<p>Стратегии подлежат исследованию и усовершенствованию. Возможности включают:</p>
<ul>
<li>Не отправлять пакеты данных на новый IP/порт до валидации</li>
<li>Продолжать отправлять пакеты данных на старый IP/порт до тех пор, пока
новый IP/порт не будет валидирован</li>
<li>Одновременно повторно валидировать старый IP/порт</li>
<li>Не отправлять никаких данных до тех пор, пока не будет валидирован старый или новый IP/порт</li>
<li>Различные стратегии для изменения только порта и для изменения IP</li>
<li>Различные стратегии для изменения IPv6 в той же подсети /32, вероятно вызванного
ротацией временных адресов</li>
</ul>
<h3 id="responding-to-path-challenge">Responding to Path Challenge</h3>
<p>При получении Path Challenge, узел должен ответить пакетом данных, содержащим Path Response, с данными из Path Challenge. TODO Возможно???: Path Response должен быть отправлен на IP/порт, с которого был получен Path Challenge. Это НЕ ОБЯЗАТЕЛЬНО тот же IP/порт, который был ранее установлен для узла. Это гарантирует, что валидация пути узлом успешна только в том случае, если путь функционален в обоих направлениях. См. раздел &ldquo;Валидация после локального изменения&rdquo; ниже.</p>
<p>Если IP/порт отличается от ранее известного IP/порта для пира, обрабатывайте Path Challenge как простой ping и отвечайте безусловно с помощью Path Response. Получатель не сохраняет и не изменяет никакого состояния на основе полученного Path Challenge. Если IP/порт отличается, пир должен проверить, что новый IP и порт являются действительными согласно локальным правилам валидации (не заблокированы, не являются запрещенными портами и т.д.). Пиры НЕ обязаны поддерживать межсемейственные ответы между IPv4 и IPv6 и могут рассматривать новый IP в другом семействе адресов как недействительный, поскольку это неожиданное поведение.</p>
<p>Если не ограничено управлением перегрузкой, Path Response должен отправляться немедленно. Реализации должны принимать меры для ограничения скорости Path Response или используемой пропускной способности при необходимости.</p>
<p>Блок Path Challenge обычно сопровождается блоком Address в том же сообщении. Если блок адреса содержит новый IP/порт, узел может проверить этот IP/порт и инициировать тестирование узла для этого нового IP/порта с сессионным узлом или любым другим узлом. Если узел считает, что он находится за firewall, и изменился только порт, это изменение вероятно вызвано повторной привязкой NAT, и дальнейшее тестирование узла вероятно не требуется.</p>
<h3 id="successful-path-validation">Successful Path Validation</h3>
<p>При успешной валидации пути соединение полностью мигрирует на новый IP/порт. При успехе:</p>
<ul>
<li>Выйти из фазы валидации пути</li>
<li>Все пакеты отправляются на новый IP и порт.</li>
<li>Ограничения на окно перегрузки и PMTU снимаются, и им
разрешается увеличиваться. Не следует просто восстанавливать их до
старых значений, поскольку новый путь может иметь другие характеристики.</li>
<li>Если IP изменился, установить рассчитанные RTT и RTO в исходные значения.
Поскольку изменения только порта обычно являются результатом NAT rebinding или другой активности middlebox,
узел может вместо этого сохранить свое состояние контроля перегрузки и оценку времени приема-передачи в таких случаях
вместо возврата к исходным значениям.</li>
<li>Удалить (аннулировать) любые токены, отправленные или полученные для старого IP/порта (необязательно)</li>
<li>Отправить новый блок токенов для нового IP/порта (необязательно)</li>
</ul>
<h3 id="cancelling-path-validation">Cancelling Path Validation</h3>
<p>Во время фазы проверки пути любые допустимые, не дублирующиеся пакеты, которые получены со старого IP/порта и успешно расшифрованы, приведут к отмене проверки пути. Важно, чтобы отменённая проверка пути, вызванная поддельным пакетом, не приводила к завершению действительной сессии или её значительному нарушению.</p>
<p>При отмене валидации пути:</p>
<ul>
<li>Выйти из фазы валидации пути</li>
<li>Все пакеты отправляются на старый IP и порт.</li>
<li>Ограничения на окно перегрузки и PMTU снимаются, и им
разрешается увеличиваться, или, опционально, восстанавливать предыдущие значения</li>
<li>Повторно передать любые пакеты данных, которые ранее были отправлены на новый IP/порт,
на старый IP/порт.</li>
</ul>
<h3 id="failed-path-validation">Failed Path Validation</h3>
<p>Важно, чтобы неудачная проверка пути, вызванная поддельным пакетом, не приводила к завершению или значительному нарушению работы действительной сессии.</p>
<p>При неудачной проверке пути:</p>
<ul>
<li>Выйти из фазы валидации пути</li>
<li>Все пакеты отправляются на старый IP и порт.</li>
<li>Ограничения на окно перегрузки и PMTU снимаются, и им
разрешается увеличиваться.</li>
<li>Опционально, запустить валидацию пути на старом IP и порту.
Если она не удается, завершить сессию.</li>
<li>В противном случае, следовать стандартным правилам тайм-аута и завершения сессии.</li>
<li>Повторно передать любые пакеты данных, которые ранее были отправлены на новый IP/порт,
на старый IP/порт.</li>
</ul>
<h3 id="validation-after-local-change">Validation After Local Change</h3>
<p>Описанный выше процесс определен для peers, которые получают пакет с измененного IP/порта. Однако он также может быть инициирован в обратном направлении peer&rsquo;ом, который обнаруживает, что его IP или порт изменились. Peer может быть способен обнаружить, что его локальный IP изменился; однако гораздо менее вероятно, что он обнаружит изменение своего порта из-за повторного связывания NAT. Поэтому это необязательно.</p>
<p>При получении path challenge от peer, чей IP или порт изменился, другой peer должен инициировать path challenge в обратном направлении.</p>
<h3 id="безопасность-релея">Безопасность релея</h3>
<p>Блоки Path Validation и Path Response могут использоваться в любое время как пакеты Ping/Pong. Получение блока Path Validation не изменяет никакого состояния у получателя, если только он не получен с другого IP/порта.</p>
<h2 id="multiple-sessions">Multiple Sessions</h2>
<p>Пиры не должны устанавливать несколько сессий с одним и тем же пиром, будь то SSU 1 или 2, или с одним и тем же или разными IP-адресами. Однако это может произойти либо из-за ошибок, либо из-за потери предыдущего сообщения о завершении сессии, либо в состоянии гонки, когда сообщение о завершении еще не пришло.</p>
<p>Если Боб имеет существующую сессию с Алисой, когда Боб получает Session Confirmed от Алисы, завершая handshake и устанавливая новую сессию, Боб должен:</p>
<ul>
<li>Перенести все неотправленные или неподтверждённые исходящие I2NP сообщения из
старой сессии в новую</li>
<li>Отправить завершение с кодом причины 22 в старой сессии</li>
<li>Удалить старую сессию и заменить её новой</li>
</ul>
<h2 id="session-termination">Session Termination</h2>
<h3 id="безопасность-тестирования-пиров">Безопасность тестирования пиров</h3>
<p>Сессии в фазе handshake обычно завершаются простым истечением времени ожидания или прекращением дальнейшего ответа. При желании они могут быть завершены включением блока Termination в ответ, но на большинство ошибок невозможно ответить из-за отсутствия криптографических ключей. Даже если ключи доступны для ответа, включающего блок завершения, обычно не стоит тратить процессорное время на выполнение DH для ответа. Исключением МОЖЕТ быть блок Termination в сообщении повторной попытки, который недорого генерировать.</p>
<h3 id="цели-проектирования-relay-и-peer-test">Цели проектирования Relay и Peer Test</h3>
<p>Сессии в фазе передачи данных завершаются отправкой сообщения с данными, которое включает блок Termination. Это сообщение также должно включать блок ACK. Оно может, если сессия была активна достаточно долго, чтобы ранее отправленный токен истёк или вот-вот истечёт, включать блок New Token. Это сообщение не требует подтверждения. При получении блока Termination с любой причиной, кроме &ldquo;Termination Received&rdquo;, узел отвечает сообщением с данными, содержащим блок Termination с причиной &ldquo;Termination Received&rdquo;.</p>
<p>После отправки или получения блока Termination сессия должна войти в фазу закрытия на некоторый максимальный период времени TBD. Состояние закрытия необходимо для защиты от потери пакета, содержащего блок Termination, и пакетов, находящихся в пути в другом направлении. Во время фазы закрытия нет требования обрабатывать какие-либо дополнительные полученные пакеты. Сессия в состоянии закрытия отправляет пакет, содержащий блок Termination, в ответ на любой входящий пакет, который она относит к данной сессии. Сессия должна ограничивать скорость, с которой она генерирует пакеты в состоянии закрытия. Например, сессия могла бы ждать прогрессивно увеличивающегося количества полученных пакетов или времени перед ответом на полученные пакеты.</p>
<p>Для минимизации состояния, которое router поддерживает для закрывающейся сессии, сессии могут, но не обязаны, отправлять точно такой же пакет с тем же номером пакета как есть в ответ на любой полученный пакет. Примечание: Разрешение повторной передачи пакета завершения является исключением из требования использовать новый номер пакета для каждого пакета. Отправка новых номеров пакетов в первую очередь выгодна для восстановления потерь и контроля перегрузок, что не ожидается быть актуальным для закрытого соединения. Повторная передача финального пакета требует меньше состояния.</p>
<p>После получения блока Termination с причиной &ldquo;Termination Received&rdquo;, сессия может выйти из фазы закрытия.</p>
<h3 id="cleanup">Cleanup</h3>
<p>При любом нормальном или аномальном завершении работы router&rsquo;ы должны обнулить все временные данные в памяти, включая эфемерные ключи handshake, симметричные криптографические ключи и связанную информацию.</p>
<h2 id="mtu">MTU</h2>
<p>Требования различаются в зависимости от того, используется ли опубликованный адрес совместно с SSU 1. Текущий минимум для SSU 1 IPv4 составляет 620, что определенно слишком мало.</p>
<p>Минимальный SSU2 MTU составляет 1280 для IPv4 и IPv6, что соответствует спецификации в <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
. См. ниже. Увеличение минимального MTU позволяет сообщениям туннелей размером 1 КБ и коротким сообщениям построения туннелей помещаться в одну датаграмму, что значительно снижает типичный объем фрагментации. Это также позволяет увеличить максимальный размер I2NP сообщения. Потоковые сообщения размером 1820 байт должны помещаться в две датаграммы.</p>
<p>Маршрутизатор не должен включать SSU2 или публиковать адрес SSU2, если MTU для этого адреса составляет менее 1280.</p>
<p>Router-ы должны публиковать MTU, отличный от значения по умолчанию, в каждом SSU или SSU2 адресе router-а.</p>
<h3 id="резюме">Резюме</h3>
<p>Общий адрес с SSU 1, должен следовать правилам SSU 1. IPv4: По умолчанию и максимум составляет 1484. Минимум 1292. (IPv4 MTU + 4) должно быть кратно 16. IPv6: Должно быть опубликовано, минимум 1280 и максимум 1488. IPv6 MTU должно быть кратно 16.</p>
<h3 id="гарантии-доставки">Гарантии доставки</h3>
<p>IPv4: По умолчанию и максимум 1500. Минимум 1280. IPv6: По умолчанию и максимум 1500. Минимум 1280. Нет правил кратности 16, но вероятно должно быть кратным 2 как минимум.</p>
<h3 id="фреймворк-протокола-noise">Фреймворк протокола Noise</h3>
<p>Для SSU 1 текущая Java I2P выполняет обнаружение PMTU, начиная с малых пакетов и постепенно увеличивая размер, или увеличивая на основе размера полученного пакета. Это грубый подход, который значительно снижает эффективность. Продолжение этой функции в SSU 2 еще предстоит определить.</p>
<p>Недавние исследования <a href="https://aura.abdn.ac.uk/bitstream/handle/2164/11693/tma2018_paper57.pdf">PMTU</a>
 предполагают, что минимум для IPv4 в 1200 или более байт будет работать для более чем 99% соединений. QUIC <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
 требует минимальный размер IP-пакета в 1280 байт.</p>
<p>цитата <a href="https://datatracker.ietf.org/doc/html/rfc9000">RFC 9000</a>
:</p>
<p>Максимальный размер датаграммы определяется как наибольший размер UDP payload, который может быть отправлен по сетевому пути с использованием одной UDP датаграммы. QUIC НЕ ДОЛЖЕН использоваться, если сетевой путь не может поддерживать максимальный размер датаграммы не менее 1200 байт.</p>
<p>QUIC предполагает минимальный размер IP-пакета не менее 1280 байт. Это минимальный размер IPv6 [IPv6], который также поддерживается большинством современных IPv4 сетей. Учитывая минимальный размер IP-заголовка в 40 байт для IPv6 и 20 байт для IPv4, а также размер UDP-заголовка в 8 байт, это приводит к максимальному размеру датаграммы в 1232 байта для IPv6 и 1252 байта для IPv4. Таким образом, ожидается, что современные IPv4 и все IPv6 сетевые пути смогут поддерживать QUIC.</p>
<p>Примечание: Это требование поддержки UDP-полезной нагрузки размером 1200 байт ограничивает доступное пространство для заголовков расширения IPv6 до 32 байт или для опций IPv4 до 52 байт, если путь поддерживает только минимальный MTU IPv6 в 1280 байт. Это влияет на Initial пакеты и валидацию пути.</p>
<p>конец цитаты</p>
<h3 id="дополнения-к-framework">Дополнения к Framework</h3>
<p>QUIC требует, чтобы начальные датаграммы в обоих направлениях были не менее 1200 байт, чтобы предотвратить атаки усиления и убедиться, что PMTU поддерживает это в обоих направлениях.</p>
<p>Мы могли бы потребовать это для Session Request и Session Created, с существенными затратами пропускной способности. Возможно, мы могли бы делать это только если у нас нет токена, или после получения сообщения Retry. TBD</p>
<p>QUIC требует, чтобы Боб отправлял не более чем в три раза больше данных, чем получено, пока адрес клиента не будет проверен. SSU2 по своей природе соответствует этому требованию, поскольку сообщение Retry примерно такого же размера, как сообщение Token Request, и меньше, чем сообщение Session Request. Также сообщение Retry отправляется только один раз.</p>
<h3 id="оценка-накладных-расходов-на-обработку">Оценка накладных расходов на обработку</h3>
<p>QUIC требует, чтобы сообщения, содержащие блоки PATH_CHALLENGE или PATH_RESPONSE, имели размер не менее 1200 байт, чтобы предотвратить атаки усиления и обеспечить поддержку PMTU в обоих направлениях.</p>
<p>Мы могли бы потребовать это также, ценой значительных затрат пропускной способности. Однако такие случаи должны быть редкими. TBD</p>
<h3 id="max-i2np-message-size">Max I2NP Message Size</h3>
<p>IPv4: Предполагается отсутствие IP-фрагментации. Заголовок IP + датаграммы составляет 28 байт. Это предполагает отсутствие IPv4-опций. Максимальный размер сообщения равен MTU - 28. Заголовок фазы данных составляет 16 байт, а MAC — 16 байт, в сумме 32 байта. Размер полезной нагрузки равен MTU - 60. Максимальная полезная нагрузка фазы данных составляет 1440 для максимального MTU 1500. Максимальная полезная нагрузка фазы данных составляет 1220 для минимального MTU 1280.</p>
<p>IPv6: Фрагментация IP не разрешена. Заголовок IP + датаграммы составляет 48 байт. Это предполагает отсутствие расширенных заголовков IPv6. Максимальный размер сообщения равен MTU - 48. Заголовок фазы данных составляет 16 байт, а MAC - 16 байт, всего 32 байта. Размер полезной нагрузки равен MTU - 80. Максимальная полезная нагрузка фазы данных составляет 1420 для максимального MTU 1500. Максимальная полезная нагрузка фазы данных составляет 1200 для минимального MTU 1280.</p>
<p>В SSU 1 рекомендации предусматривали строгий максимум около 32 КБ для I2NP сообщения на основе максимум 64 фрагментов и минимального MTU 620. Из-за накладных расходов на объединенные LeaseSet&rsquo;ы и ключи сессии, практический лимит на уровне приложения был примерно на 6КБ ниже, или около 26КБ. Протокол SSU 1 допускает 128 фрагментов, но текущие реализации ограничивают это до 64 фрагментов.</p>
<p>Увеличив минимальный MTU до 1280, с полезной нагрузкой фазы данных приблизительно 1200, SSU 2 сообщение размером около 76 КБ возможно в 64 фрагментах и 152 КБ в 128 фрагментах. Это легко позволяет максимум в 64 КБ.</p>
<p>Из-за фрагментации в туннелях и фрагментации в SSU 2 вероятность потери сообщений экспоненциально возрастает с увеличением размера сообщения. Мы продолжаем рекомендовать практическое ограничение примерно в 10 КБ на уровне приложения для I2NP датаграмм.</p>
<h2 id="peer-test-process">Peer Test Process</h2>
<p>Смотрите раздел &ldquo;Безопасность тестирования узлов&rdquo; выше для анализа SSU1 Peer Test и целей SSU2 Peer Test.</p>
<pre tabindex="0"><code>Alice                     Bob                  Charlie
1. PeerTest -------------------&gt;
                              Alice RI -------------------&gt;
2.                          PeerTest -------------------&gt;
3.                             &lt;------------------ PeerTest
          &lt;---------------- Charlie RI
4.      &lt;------------------ PeerTest

5.      &lt;----------------------------------------- PeerTest
6. PeerTest -----------------------------------------&gt;
7.      &lt;----------------------------------------- PeerTest
</code></pre><p>Когда отклонено Бобом:</p>
<pre tabindex="0"><code>Alice                     Bob                  Charlie
1. PeerTest -------------------&gt;
4.      &lt;------------------ PeerTest (reject)
</code></pre><p>Когда отклонено Charlie:</p>
<pre tabindex="0"><code>Alice                     Bob                  Charlie
1. PeerTest -------------------&gt;
                              Alice RI -------------------&gt;
2.                          PeerTest -------------------&gt;
3.                             &lt;------------------ PeerTest (reject)
                        (optional: Bob could try another Charlie here)
4.      &lt;------------------ PeerTest (reject)
</code></pre><p>ПРИМЕЧАНИЕ: RI может отправляться либо в сообщениях I2NP Database Store в блоках I2NP, либо как блоки RI (если достаточно малы). Они могут содержаться в тех же пакетах, что и блоки peer test, если достаточно малы.</p>
<p>Сообщения 1-4 находятся в сеансе с использованием блоков Peer Test в сообщении Data. Сообщения 5-7 находятся вне сеанса с использованием блоков Peer Test в сообщении Peer Test.</p>
<p>ПРИМЕЧАНИЕ: Как и в SSU 1, сообщения 4 и 5 могут прибыть в любом порядке. Сообщение 5 и/или 7 могут вообще не быть получены, если Alice находится за файрволом. Когда сообщение 5 прибывает раньше сообщения 4, Alice не может немедленно отправить сообщение 6, потому что у неё ещё нет intro key Чарли для шифрования заголовка. Когда сообщение 4 прибывает раньше сообщения 5, Alice не должна немедленно отправлять сообщение 6, потому что ей следует подождать и посмотреть, прибудет ли сообщение 5, не открывая файрвол сообщением 6.</p>
<table>
  <thead>
      <tr>
          <th>Message</th>
          <th>Path</th>
          <th>Intro Key</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>A-&gt;B session</td>
          <td>in-session</td>
      </tr>
      <tr>
          <td>2</td>
          <td>B-&gt;C session</td>
          <td>in-session</td>
      </tr>
      <tr>
          <td>3</td>
          <td>C-&gt;B session</td>
          <td>in-session</td>
      </tr>
      <tr>
          <td>4</td>
          <td>B-&gt;A session</td>
          <td>in-session</td>
      </tr>
      <tr>
          <td>5</td>
          <td>C-&gt;A</td>
          <td>Alice</td>
      </tr>
      <tr>
          <td>6</td>
          <td>A-&gt;C</td>
          <td>Charlie</td>
      </tr>
      <tr>
          <td>7</td>
          <td>C-&gt;A</td>
          <td>Alice</td>
      </tr>
  </tbody>
</table>
<h3 id="versions">Versions</h3>
<p>Кросс-версионное тестирование peers не поддерживается. Единственная допустимая комбинация версий — когда все peers используют версию 2.</p>
<table>
  <thead>
      <tr>
          <th>Alice/Bob</th>
          <th>Bob/Charlie</th>
          <th>Alice/Charlie</th>
          <th>Supported</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>SSU 1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>2</td>
          <td>no, use 1/1/1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>no, Bob must s</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2</td>
          <td>2</td>
          <td>no, Bob must s</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>1</td>
          <td>no, Bob must s</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>2</td>
          <td>no, Bob must s</td>
      </tr>
      <tr>
          <td>2</td>
          <td>2</td>
          <td>1</td>
          <td>no, use 2/2/2</td>
      </tr>
      <tr>
          <td>2</td>
          <td>2</td>
          <td>2</td>
          <td>yes</td>
      </tr>
  </tbody>
</table>
<h3 id="установка-сессии">Установка сессии</h3>
<p>Сообщения 1-4 находятся в сессии и покрываются процессами ACK фазы данных и повторной передачи. Блоки Peer Test требуют подтверждения.</p>
<p>Сообщения 5-7 могут быть переданы повторно без изменений.</p>
<h3 id="заголовок-пакета">Заголовок пакета</h3>
<p>Как и в SSU 1, поддерживается тестирование IPv6-адресов, и связь между Alice-Bob и Alice-Charlie может осуществляться через IPv6, если Bob и Charlie указывают поддержку с помощью возможности &lsquo;B&rsquo; в своем опубликованном IPv6-адресе. Подробности см. в Proposal 126.</p>
<p>Как и в SSU 1 до версии 0.9.50, Алиса отправляет запрос Бобу, используя существующую сессию по транспорту (IPv4 или IPv6), который она хочет протестировать. Когда Боб получает запрос от Алисы по IPv4, Боб должен выбрать Чарли, который анонсирует IPv4-адрес. Когда Боб получает запрос от Алисы по IPv6, Боб должен выбрать Чарли, который анонсирует IPv6-адрес. Фактическая коммуникация между Бобом и Чарли может происходить по IPv4 или IPv6 (т.е. независимо от типа адреса Алисы). Это НЕ поведение SSU 1 начиная с версии 0.9.50, где разрешены смешанные IPv4/v6 запросы.</p>
<h3 id="processing-by-bob">Processing by Bob</h3>
<p>В отличие от SSU 1, Alice указывает запрашиваемый тестовый IP и порт в сообщении 1. Bob должен проверить этот IP и порт, и отклонить с кодом 5, если они недействительны. Рекомендуемая проверка IP заключается в том, что для IPv4 он должен совпадать с IP Alice, а для IPv6 должны совпадать по крайней мере первые 8 байтов IP. Проверка порта должна отклонять привилегированные порты и порты для известных протоколов.</p>
<h2 id="relay-process">Relay Process</h2>
<p>См. раздел &ldquo;Безопасность ретрансляции&rdquo; выше для анализа SSU1 Relay и целей SSU2 Relay.</p>
<pre tabindex="0"><code>Alice                         Bob                  Charlie
     lookup Bob RI

     SessionRequest --------------------&gt;
          &lt;------------  SessionCreated
     SessionConfirmed  -----------------&gt;

1. RelayRequest ----------------------&gt;
                                           Alice RI  ------------&gt;
2.                                       RelayIntro -----------&gt;
3.                                  &lt;-------------- RelayResponse
4.      &lt;-------------- RelayResponse

5.      &lt;-------------------------------------------- HolePunch
6. SessionRequest --------------------------------------------&gt;
7.      &lt;-------------------------------------------- SessionCreated
8. SessionConfirmed ------------------------------------------&gt;
</code></pre><p>Когда отклонено Бобом:</p>
<pre tabindex="0"><code>Alice                         Bob                  Charlie
     lookup Bob RI

     SessionRequest --------------------&gt;
          &lt;------------  SessionCreated
     SessionConfirmed  -----------------&gt;

1. RelayRequest ----------------------&gt;
4.      &lt;-------------- RelayResponse
</code></pre><p>Когда отклонено Charlie:</p>
<pre tabindex="0"><code>Alice                         Bob                  Charlie
     lookup Bob RI

     SessionRequest --------------------&gt;
          &lt;------------  SessionCreated
     SessionConfirmed  -----------------&gt;

1. RelayRequest ----------------------&gt;
                                           Alice RI  ------------&gt;
2.                                       RelayIntro -----------&gt;
3.                                  &lt;-------------- RelayResponse
4.      &lt;-------------- RelayResponse
</code></pre><p>ПРИМЕЧАНИЕ: RI может отправляться либо в виде I2NP Database Store сообщений в I2NP блоках, либо в виде RI блоков (если достаточно малы). Они могут содержаться в тех же пакетах, что и relay блоки, если достаточно малы.</p>
<p>В SSU 1 информация о роутере Чарли содержит IP, порт, intro key, relay tag и время истечения каждого introducer.</p>
<p>В SSU 2 информация о роутере Чарли содержит хеш роутера, тег ретрансляции и время истечения каждого introducer.</p>
<p>Alice должна сократить количество необходимых циклов передачи данных, сначала выбрав introducer (Bob), к которому у неё уже есть соединение. Во-вторых, если такого нет, выбрать introducer, информацию о router которого у неё уже есть.</p>
<p>Cross-version relaying также должна поддерживаться, если это возможно. Это облегчит постепенный переход с SSU 1 на SSU 2. Допустимые комбинации версий (TODO):</p>
<table>
  <thead>
      <tr>
          <th>Alice/Bob</th>
          <th>Bob/Charlie</th>
          <th>Alice/Charlie</th>
          <th>Supported</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>SSU 1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>1</td>
          <td>2</td>
          <td>no, use 1/1/1</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>yes?</td>
      </tr>
      <tr>
          <td>1</td>
          <td>2</td>
          <td>2</td>
          <td>no, use 1/2/1</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>1</td>
          <td>yes?</td>
      </tr>
      <tr>
          <td>2</td>
          <td>1</td>
          <td>2</td>
          <td>yes?</td>
      </tr>
      <tr>
          <td>2</td>
          <td>2</td>
          <td>1</td>
          <td>no, use 2/2/2</td>
      </tr>
      <tr>
          <td>2</td>
          <td>2</td>
          <td>2</td>
          <td>yes</td>
      </tr>
  </tbody>
</table>
<h3 id="retransmissions">Retransmissions</h3>
<p>Relay Request, Relay Intro и Relay Response являются внутрисеансовыми и покрываются процессами подтверждения и повторной передачи фазы данных. Блоки Relay Request, Relay Intro и Relay Response требуют подтверждения.</p>
<p>Hole punch может быть повторно передан, как в SSU 1.</p>
<h3 id="ipv4v6">IPv4/v6</h3>
<p>Все функции SSU 1 relay поддерживаются, включая те, что документированы в <a href="../../../ru/proposals/158-ipv6-transport-enhancements/">Предложении 158</a>
 и поддерживаются начиная с версии 0.9.50. IPv4 и IPv6 представления поддерживаются. Relay Request может быть отправлен через IPv4 сессию для IPv6 представления, и Relay Request может быть отправлен через IPv6 сессию для IPv4 представления.</p>
<h3 id="processing-by-alice">Processing by Alice</h3>
<p>Ниже приведены отличия от SSU 1 и рекомендации для реализации SSU 2.</p>
<h4 id="примечания-4">Примечания</h4>
<p>В SSU 1 введение относительно недорого, и Alice обычно отправляет Relay Request всем introducers. В SSU 2 введение более затратно, поскольку сначала необходимо установить соединение с introducer. Для минимизации задержки и накладных расходов на введение рекомендуются следующие шаги обработки:</p>
<ul>
<li>Игнорировать любые introducers, которые истекли на основании значения iexp в адресе</li>
<li>Если SSU2 соединение уже установлено с одним или несколькими introducers,
выбрать один и отправить Relay Request только этому introducer.</li>
<li>В противном случае, если Router Info локально известен для одного или нескольких introducers,
выбрать один и подключиться только к этому introducer.</li>
<li>В противном случае, найти Router Infos для всех introducers,
подключиться к introducer, чей Router Info получен первым.</li>
</ul>
<h4 id="примечания-5">Примечания</h4>
<p>В SSU 1 и SSU 2 Relay Response и Hole Punch могут быть получены в любом порядке или могут не быть получены вообще.</p>
<p>В SSU 1 Алиса обычно получает Relay Response (1 RTT) раньше Hole Punch (1 1/2 RTT). Это может быть не очень хорошо задокументировано в тех спецификациях, но Алиса должна получить Relay Response от Боба перед продолжением, чтобы получить IP-адрес Чарли. Если Hole Punch получен первым, Алиса его не распознает, поскольку он не содержит данных, а исходный IP не распознан. После получения Relay Response Алиса должна ждать ЛИБО получения Hole Punch от Чарли, ЛИБО короткой задержки (рекомендуется 500 мс) перед началом рукопожатия с Чарли.</p>
<p>В SSU 2 Алиса обычно получит Hole Punch (1 1/2 RTT) раньше, чем Relay Response (2 RTT). SSU 2 Hole Punch легче обрабатывать, чем в SSU 1, поскольку это полное сообщение с определенными ID соединений (производными от relay nonce) и содержимым, включающим IP-адрес Чарли. Relay Response (сообщение Data) и сообщение Hole Punch содержат идентичный подписанный блок Relay Response. Поэтому Алиса может инициировать handshake с Чарли после ЛЮБОГО из событий: получения Hole Punch от Чарли ИЛИ получения Relay Response от Боба.</p>
<p>Проверка подписи Hole Punch включает хеш router&rsquo;а представителя (Bob&rsquo;а). Если Relay Request&rsquo;ы были отправлены более чем одному представителю, существует несколько вариантов для валидации подписи:</p>
<ul>
<li>Попробуйте каждый хеш, на который был отправлен запрос</li>
<li>Используйте разные nonce для каждого introducer и используйте это, чтобы определить, какой
introducer этот Hole Punch был в ответ на</li>
<li>Не переvalidируйте подпись, если содержимое идентично
тому, что в Relay Response, если уже получено</li>
<li>Вообще не проверяйте подпись</li>
</ul>
<p>Если Чарли находится за симметричным NAT, его указанный порт в Relay Response и Hole Punch может быть неточным. Поэтому Алиса должна проверить UDP порт источника сообщения Hole Punch и использовать его, если он отличается от указанного порта.</p>
<h3 id="tag-requests-by-bob">Tag Requests by Bob</h3>
<p>В SSU 1 только Алиса могла запросить тег в Session Request. Боб никогда не мог запросить тег, и Алиса не могла ретранслировать для Боба.</p>
<p>В SSU2 Алиса обычно запрашивает тег в Session Request, но и Алиса, и Боб могут также запросить тег в фазе данных. Боб обычно не находится за файрволом после получения входящего запроса, но это может произойти после relay, или состояние Боба может измениться, или он может запросить introducer для другого типа адреса (IPv4/v6). Таким образом, в SSU2 возможно, чтобы и Алиса, и Боб одновременно были relay для другой стороны.</p>
<h2 id="published-router-info">Published Router Info</h2>
<h3 id="address-properties">Address Properties</h3>
<p>Следующие свойства адресов могут быть опубликованы без изменений по сравнению с SSU 1, включая изменения в <a href="../../../ru/proposals/158-ipv6-transport-enhancements/">Предложении 158</a>
, поддерживаемые начиная с API 0.9.50:</p>
<ul>
<li>
<p>caps: возможности [B,C,4,6]</p>
</li>
<li>
<p>host: IP (IPv4 или IPv6).
Разрешены сокращенные IPv6-адреса (с &ldquo;::&rdquo;).
Может присутствовать или отсутствовать при наличии firewall.
Имена хостов не разрешены.</p>
</li>
<li>
<p>iexp[0-2]: Истечение срока действия этого introducer.
ASCII цифры, в секундах с начала эпохи.
Присутствует только если брандмауэр активен и introducers требуются.
Необязательно (даже если присутствуют другие свойства для этого introducer).</p>
</li>
<li>
<p>ihost[0-2]: IP-адрес introducer&rsquo;а (IPv4 или IPv6).
Сокращённый IPv6-адрес (с &ldquo;::&rdquo;) разрешён.
Присутствует только если за файрволлом, и требуются introducer&rsquo;ы.
Имена хостов не разрешены.
Только для SSU-адресов.</p>
</li>
<li>
<p>ikey[0-2]: Base 64 ключ представления вводящего узла.
Присутствует только если находится за файрволом и требуются вводящие узлы.
Только для SSU адреса.</p>
</li>
<li>
<p>iport[0-2]: Порт introducer&rsquo;а 1024 - 65535.
Присутствует только если заблокирован файрволлом и требуются introducer&rsquo;ы.
Только для SSU адреса.</p>
</li>
<li>
<p>itag[0-2]: Тег представляющего (introducer) 1 - (2**32 - 1)
ASCII цифры.
Присутствует только если находится за файрволом и требуются представляющие (introducers).</p>
</li>
<li>
<p>key: Ключ введения Base 64.</p>
</li>
<li>
<p>mtu: Опционально. См. раздел MTU выше.</p>
</li>
<li>
<p>port: 1024 - 65535
Может присутствовать или отсутствовать при наличии файрвола.</p>
</li>
</ul>
<h3 id="published-addresses">Published Addresses</h3>
<p>Опубликованный RouterAddress (часть RouterInfo) будет иметь идентификатор протокола либо &ldquo;SSU&rdquo;, либо &ldquo;SSU2&rdquo;.</p>
<p>RouterAddress должен содержать три опции для указания поддержки SSU2:</p>
<ul>
<li>
<p>s=(Base64 key)
Текущий статический публичный ключ Noise (s) для данного RouterAddress.
Кодируется в Base 64 с использованием стандартного алфавита I2P Base 64.
32 байта в двоичном формате, 44 байта в кодировке Base 64,
публичный ключ X25519 в little-endian формате.</p>
</li>
<li>
<p>i=(Base64 key)
Текущий ключ введения для шифрования заголовков данного RouterAddress.
Кодируется в Base 64 с использованием стандартного алфавита I2P Base 64.
32 байта в двоичном формате, 44 байта в кодировке Base 64,
ключ ChaCha20 в формате big-endian.</p>
</li>
<li>
<p>v=2
Текущая версия (2).
При публикации как &ldquo;SSU&rdquo; подразумевается дополнительная поддержка версии 1.
Поддержка будущих версий будет осуществляться через значения, разделенные запятыми,
например v=2,3
Реализация должна проверять совместимость, включая несколько
версий при наличии запятой. Версии, разделенные запятыми, должны
быть в числовом порядке.</p>
</li>
</ul>
<p>Алиса должна проверить, что все три опции присутствуют и действительны перед подключением с использованием протокола SSU2.</p>
<p>Когда опубликовано как &ldquo;SSU&rdquo; с опциями &ldquo;s&rdquo;, &ldquo;i&rdquo; и &ldquo;v&rdquo;, а также с опциями &ldquo;host&rdquo; и &ldquo;port&rdquo;, router должен принимать входящие соединения на этом хосте и порту для обоих протоколов SSU и SSU2, и автоматически определять версию протокола.</p>
<p>Когда опубликован как &ldquo;SSU2&rdquo; с опциями &ldquo;s&rdquo;, &ldquo;i&rdquo; и &ldquo;v&rdquo;, а также с опциями &ldquo;host&rdquo; и &ldquo;port&rdquo;, маршрутизатор принимает входящие соединения на этом хосте и порту только для протокола SSU2.</p>
<p>Если роутер поддерживает как SSU1, так и SSU2 соединения, но не реализует автоматическое определение версии для входящих соединений, он должен объявлять как адреса &ldquo;SSU&rdquo;, так и &ldquo;SSU2&rdquo;, и включать опции SSU2 только в адрес &ldquo;SSU2&rdquo;. Роутер должен установить более низкое значение стоимости (более высокий приоритет) в адресе &ldquo;SSU2&rdquo;, чем в адресе &ldquo;SSU&rdquo;, чтобы SSU2 имел предпочтение.</p>
<p>Если несколько SSU2 RouterAddresses (как &ldquo;SSU&rdquo;, так и &ldquo;SSU2&rdquo;) публикуются в одном RouterInfo (для дополнительных IP-адресов или портов), все адреса, указывающие один и тот же порт, должны содержать идентичные SSU2 опции и значения. В частности, все они должны содержать один и тот же статический ключ &ldquo;s&rdquo; и ключ представления &ldquo;i&rdquo;.</p>
<h4 id="introducers">Introducers</h4>
<p>При публикации как SSU или SSU2 с introducers присутствуют следующие опции:</p>
<ul>
<li>
<p>ih[0-2]=(Base64 hash)
Хэш router&rsquo;а для introducer&rsquo;а.
Кодируется в Base 64 с использованием стандартного алфавита I2P Base 64.
32 байта в двоичном формате, 44 байта в кодировке Base 64</p>
</li>
<li>
<p>iexp[0-2]: Истечение срока действия этого introducer.
Не изменено по сравнению с SSU 1.</p>
</li>
<li>
<p>itag[0-2]: Тег представляющего узла 1 - (2**32 - 1)
Не изменился с SSU 1.</p>
</li>
</ul>
<p>Следующие опции предназначены только для SSU и не используются для SSU2. В SSU2 Алиса получает эту информацию из RI Чарли вместо этого.</p>
<ul>
<li>ihost[0-2]</li>
<li>ikey[0-2]</li>
<li>itag[0-2]</li>
</ul>
<p>Router не должен публиковать хост или порт в адресе при публикации introducers. Router должен публиковать caps 4 и/или 6 в адресе при публикации introducers для указания поддержки IPv4 и/или IPv6. Это то же самое, что и текущая практика для недавних SSU 1 адресов.</p>
<p>Примечание: Если публикуется как SSU, и имеется смесь introducer-ов SSU 1 и SSU2, introducer-ы SSU 1 должны находиться под меньшими индексами, а introducer-ы SSU2 должны находиться под большими индексами, для совместимости со старыми router-ами.</p>
<h3 id="unpublished-ssu2-address">Unpublished SSU2 Address</h3>
<p>Если Alice не публикует свой SSU2 адрес (как &ldquo;SSU&rdquo; или &ldquo;SSU2&rdquo;) для входящих соединений, она должна опубликовать адрес роутера &ldquo;SSU2&rdquo;, содержащий только её статический ключ и версию SSU2, чтобы Bob мог валидировать ключ после получения RouterInfo Alice в части 2 Session Confirmed.</p>
<ul>
<li>
<p>s=(Base64 key)
Как определено выше для опубликованных адресов.</p>
</li>
<li>
<p>i=(Base64 key)
Как определено выше для опубликованных адресов.</p>
</li>
<li>
<p>v=2
Как определено выше для опубликованных адресов.</p>
</li>
</ul>
<p>Этот адрес маршрутизатора не будет содержать опции &ldquo;host&rdquo; или &ldquo;port&rdquo;, поскольку они не требуются для исходящих SSU2 соединений. Опубликованная стоимость для этого адреса не имеет строгого значения, так как он предназначен только для входящих соединений; однако, это может быть полезно для других маршрутизаторов, если стоимость установлена выше (более низкий приоритет), чем у других адресов. Рекомендуемое значение — 14.</p>
<p>Алиса также может просто добавить параметры &ldquo;i&rdquo;, &ldquo;s&rdquo; и &ldquo;v&rdquo; к существующему опубликованному адресу &ldquo;SSU&rdquo;.</p>
<h3 id="целостность-пакетов">Целостность пакетов</h3>
<p>Использование одинаковых статических ключей для NTCP2 и SSU2 разрешено, но не рекомендуется.</p>
<p>Из-за кэширования RouterInfo роутеры не должны ротировать статический публичный ключ или IV, пока роутер работает, независимо от того, находится ли он в опубликованном адресе или нет. Роутеры должны постоянно хранить этот ключ и IV для повторного использования после немедленной перезагрузки, чтобы входящие соединения продолжали работать и время перезагрузки не раскрывалось. Роутеры должны постоянно хранить или иным образом определять время последнего выключения, чтобы можно было рассчитать предыдущее время простоя при запуске.</p>
<p>С учетом опасений относительно раскрытия времени перезапуска, router&rsquo;ы могут ротировать этот ключ или IV при запуске, если router был отключен в течение некоторого времени (по крайней мере, несколько дней).</p>
<p>Если router имеет какие-либо опубликованные SSU2 RouterAddresses (как SSU или SSU2), минимальное время простоя перед ротацией должно быть намного больше, например один месяц, если только локальный IP-адрес не изменился или router не выполнил &ldquo;rekeys&rdquo;.</p>
<p>Если router имеет какие-либо опубликованные SSU RouterAddresses, но не SSU2 (как SSU или SSU2), минимальное время простоя перед ротацией должно быть больше, например один день, если только локальный IP-адрес не изменился или router не выполнил &ldquo;rekeys&rdquo;. Это применимо даже если опубликованный SSU адрес имеет introducers.</p>
<p>Если router не имеет опубликованных RouterAddresses (SSU, SSU2 или SSU), минимальное время простоя перед ротацией может составлять всего два часа, даже при смене IP-адреса, если только router не выполняет &ldquo;rekeys&rdquo;.</p>
<p>Если router &ldquo;перегенерирует ключи&rdquo; на другой Router Hash, он должен также сгенерировать новый noise ключ и intro ключ.</p>
<p>Реализации должны учитывать, что изменение статического публичного ключа или IV заблокирует входящие SSU2 соединения от роутеров, которые кэшировали старую RouterInfo. Публикация RouterInfo, выбор партнеров туннеля (включая как OBGW, так и ближайший IB хоп), выбор zero-hop туннеля, выбор транспорта и другие стратегии реализации должны это учитывать.</p>
<p>Ротация intro ключей подчиняется тем же правилам, что и ротация ключей.</p>
<p>Примечание: Минимальное время простоя перед повторным созданием ключей может быть изменено для обеспечения работоспособности сети и предотвращения повторного получения начальных данных router&rsquo;ом, который был отключен в течение умеренного периода времени.</p>
<h4 id="identity-hiding">Identity Hiding</h4>
<p>Отрицание не является целью. См. обзор выше.</p>
<p>Каждому паттерну назначаются свойства, описывающие конфиденциальность, предоставляемую статическому открытому ключу инициатора и статическому открытому ключу респондента. Базовые предположения заключаются в том, что эфемерные закрытые ключи являются безопасными, и что стороны прерывают handshake, если они получают статический открытый ключ от другой стороны, которой они не доверяют.</p>
<p>Данный раздел рассматривает только утечку идентификационных данных через статические поля открытых ключей в handshake-процедурах. Разумеется, идентичности участников Noise могут быть раскрыты другими способами, включая поля полезной нагрузки, анализ трафика или метаданные, такие как IP-адреса.</p>
<p>Алиса: (8) Зашифровано с прямой секретностью для аутентифицированной стороны.</p>
<p>Боб: (3) Не передается, но пассивный атакующий может проверить кандидатов для приватного ключа отвечающей стороны и определить, правильный ли кандидат.</p>
<p>Боб публикует свой статический публичный ключ в netDb. Алиса может не делать этого, но должна включить его в RI, отправляемый Бобу.</p>
<h2 id="packet-guidelines">Packet Guidelines</h2>
<h3 id="аутентифицированное-шифрование">Аутентифицированное шифрование</h3>
<p>Сообщения handshake (Session Request/Created/Confirmed, Retry) основные шаги, по порядку:</p>
<ul>
<li>Создать заголовок размером 16 или 32 байта</li>
<li>Создать полезную нагрузку</li>
<li>Выполнить mixHash() для заголовка (кроме Retry)</li>
<li>Зашифровать полезную нагрузку с использованием Noise (кроме Retry, использовать ChaChaPoly с заголовком в качестве AD)</li>
<li>Зашифровать заголовок, а для Session Request/Created — ephemeral key</li>
</ul>
<p>Основные этапы сообщений фазы данных, по порядку:</p>
<ul>
<li>Создать 16-байтовый заголовок</li>
<li>Создать полезную нагрузку</li>
<li>Зашифровать полезную нагрузку, используя ChaChaPoly с заголовком в качестве AD</li>
<li>Зашифровать заголовок</li>
</ul>
<h3 id="inbound-packet-handling">Inbound Packet Handling</h3>
<h4 id="полезная-нагрузка-3">Полезная нагрузка</h4>
<p>Первоначальная обработка всех входящих сообщений:</p>
<ul>
<li>Расшифровать первые 8 байт заголовка (Destination Connection ID)
с помощью intro key</li>
<li>Найти соединение по Destination Connection ID</li>
<li>Если соединение найдено и находится в фазе передачи данных, перейти к
разделу фазы передачи данных</li>
<li>Если соединение не найдено, перейти к разделу handshake</li>
<li>Примечание: Сообщения Peer Test и Hole Punch также могут быть найдены
по Destination Connection ID, созданному из test или relay nonce.</li>
</ul>
<p>Обработка сообщений handshake (Session Request/Created/Confirmed, Retry, Token Request) и других сообщений вне сессии (Peer Test, Hole Punch):</p>
<ul>
<li>Расшифровать байты 8-15 заголовка
(тип пакета, версию и net ID) с помощью intro key. Если это
валидный Session Request, Token Request, Peer Test или Hole Punch, продолжить</li>
<li>Если не валидное сообщение, найти ожидающее исходящее соединение по IP/порту
источника пакета, обработать пакет как Session Created или Retry.
Заново расшифровать первые 8 байтов заголовка с правильным ключом,
и байты 8-15 заголовка
(тип пакета, версию и net ID). Если это
валидный Session Created или Retry, продолжить</li>
<li>Если не валидное сообщение, завершить с ошибкой или поставить в очередь как возможный пакет фазы данных вне очереди</li>
<li>Для Session Request/Created, Retry, Token Request, Peer Test и Hole Punch расшифровать байты 16-31 заголовка</li>
<li>Для Session Request/Created расшифровать эфемерный ключ</li>
<li>Проверить все поля заголовка, остановиться если не валидны</li>
<li>mixHash() заголовка</li>
<li>Для Session Request/Created/Confirmed расшифровать полезную нагрузку используя Noise</li>
<li>Для Retry и фазы данных расшифровать полезную нагрузку используя ChaChaPoly</li>
<li>Обработать заголовок и полезную нагрузку</li>
</ul>
<p>Обработка сообщений фазы данных:</p>
<ul>
<li>Расшифровать байты 8-15 заголовка
(тип пакета, версию и net ID) правильным ключом</li>
<li>Расшифровать полезную нагрузку с помощью ChaChaPoly, используя заголовок как AD</li>
<li>Обработать заголовок и полезную нагрузку</li>
</ul>
<h4 id="details">Details</h4>
<p>В SSU 1 классификация входящих пакетов затруднена, поскольку отсутствует заголовок для указания номера сессии. Маршрутизаторы должны сначала сопоставить исходный IP и порт с существующим состоянием узла, а если совпадение не найдено, попытаться выполнить множественные расшифровки с различными ключами, чтобы найти подходящее состояние узла или начать новое. В случае изменения исходного IP или порта для существующей сессии, возможно из-за поведения NAT, маршрутизатор может использовать ресурсозатратные эвристики для попытки сопоставления пакета с существующей сессией и восстановления содержимого.</p>
<p>SSU 2 разработан для минимизации усилий по классификации входящих пакетов при сохранении устойчивости к DPI и другим угрозам на пути передачи. Номер Connection ID включен в заголовок для всех типов сообщений и зашифрован (обфусцирован) с использованием ChaCha20 с известным ключом и nonce. Дополнительно, тип сообщения также включен в заголовок (зашифрован с защитой заголовка известным ключом, а затем обфусцирован с помощью ChaCha20) и может использоваться для дополнительной классификации. Ни в коем случае не требуется пробная операция DH или другая асимметричная криптографическая операция для классификации пакета.</p>
<p>Для почти всех сообщений от всех узлов ключ ChaCha20 для шифрования Connection ID является introduction key целевого router, как опубликовано в netDb.</p>
<p>Единственными исключениями являются первые сообщения, отправленные от Bob к Alice (Session Created или Retry), где ключ знакомства Alice еще неизвестен Bob. В этих случаях в качестве ключа используется ключ знакомства Bob.</p>
<p>Протокол разработан для минимизации обработки классификации пакетов, которая может потребовать дополнительных криптографических операций в нескольких резервных шагах или сложной эвристики. Кроме того, подавляющее большинство получаемых пакетов не будет требовать (возможно, дорогостоящего) резервного поиска по исходному IP/порту и второй расшифровки заголовка. Только Session Created и Retry (и возможно другие, которые будут определены) потребуют резервной обработки. Если конечная точка изменит IP или порт после создания сессии, ID соединения по-прежнему используется для поиска сессии. Никогда не требуется использовать эвристику для поиска сессии, например, путем поиска другой сессии с тем же IP, но другим портом.</p>
<p>Поэтому рекомендуемые шаги обработки в логике цикла получателя:</p>
<ol>
<li>Расшифруйте первые 8 байт с помощью ChaCha20, используя локальный ключ введения,    чтобы восстановить Destination Connection ID.    Если Connection ID соответствует текущей или ожидающей входящей сессии:</li>
</ol>
<p>a) Используя соответствующий ключ, расшифровать байты заголовка 8-15</p>
<pre><code>  to recover the version, net ID, and message type.
</code></pre>
<p>b) Если тип сообщения Session Confirmed, это длинный заголовок.</p>
<pre><code>  Verify the net ID and protocol version are valid.
  Decrypt the bytes 15-31 of the header with ChaCha20
  using the local intro key. Then MixHash() the
  decrypted 32 byte header and decrypt the message with Noise.
</code></pre>
<p>в) Если тип сообщения действителен, но не Session Confirmed,</p>
<pre><code>  it is a short header.
  Verify the net ID and protocol version are valid.
  decrypt the rest of the message with ChaCha20/Poly1305
  using the session key, using the decrypted 16-byte header
  as the AD.
</code></pre>
<p>d) (необязательно) Если connection ID является ожидающей входящей сессией</p>
<pre><code>  awaiting a Session Confirmed message,
  but the net ID, protocol, or message type is not valid,
  it could be a Data message received out-of-order before the
  Session Confirmed, so the data phase header protection keys are not yet known,
  and the header bytes 8-15 were incorrectly decrypted.
  Queue the message, and attempt to decrypt it once the
  Session Confirmed message is received.
</code></pre>
<p>е) Если b) или c) не удается, отбросить сообщение.</p>
<ol start="2">
<li>Если ID соединения не соответствует текущей сессии:    Проверить, что заголовок открытого текста в байтах 8-15 является корректным    (без выполнения каких-либо операций защиты заголовка).    Убедиться, что net ID и версия протокола корректны, а    тип сообщения — Session Request или другой тип сообщения,    разрешённый вне сессии (TBD).</li>
</ol>
<p>a) Если все корректно и тип сообщения — Session Request,</p>
<pre><code>  decrypt bytes 16-31 of the header and the 32-byte X value
  with ChaCha20 using the local intro key.
</code></pre>
<ul>
<li>Если токен в байтах заголовка 24-31 принят,
то выполнить MixHash() расшифрованного 32-байтного заголовка и
расшифровать сообщение с помощью Noise.
Отправить Session Created в ответ.
<ul>
<li>Если токен не принят, отправить сообщение Retry на
исходный IP/порт с токеном. Не пытаться
расшифровать сообщение с помощью Noise во избежание DDoS-атак.</li>
</ul>
</li>
</ul>
<p>b) Если тип сообщения является каким-либо другим действительным сообщением</p>
<pre><code>  out-of-session, presumably with a short header,
  decrypt the rest of the message with ChaCha20/Poly1305
  using the intro key, and using the decrypted 16-byte header
  as the AD. Process the message.
</code></pre>
<p>c) Если a) или b) не удается, переходите к шагу 3)</p>
<ol start="3">
<li>Найти ожидающую исходящую сессию по IP-адресу/порту источника пакета.</li>
</ol>
<p>a) Если найден, повторно расшифровать первые 8 байт с помощью ChaCha20, используя introduction key Боба</p>
<pre><code>  to recover the Destination Connection ID.
</code></pre>
<p>б) Если ID соединения соответствует ожидающей сессии:</p>
<pre><code>  Using the correct key, decrypt bytes 8-15 of the header
  to recover the version, net ID, and message type.
  Verify the net ID and protocol version are valid, and
  the message type is Session Created or Retry, or other message type
  allowed out-of-session (TBD).
</code></pre>
<ul>
<li>
<p>Если все действительно и тип сообщения — Session Created,
расшифровать следующие 16 байт заголовка и 32-байтное значение Y
с помощью ChaCha20, используя intro key Боба.
Затем выполнить MixHash() для расшифрованного 32-байтного заголовка и
расшифровать сообщение с помощью Noise.
Отправить Session Confirmed в ответ.</p>
<ul>
<li>Если все действительно и тип сообщения — Retry,
расшифровать байты 16-31 заголовка
с помощью ChaCha20, используя intro key Боба.
Расшифровать и проверить сообщение, используя ChaCha20/Poly1305 с
TBD в качестве ключа и TBD в качестве nonce, и расшифрованный 32-байтный заголовок в качестве AD.
Повторно отправить Session Request с полученным токеном в ответ.</li>
<li>Если тип сообщения — какое-то другое сообщение, которое действительно
вне сессии, предположительно с коротким заголовком,
расшифровать остальную часть сообщения с помощью ChaCha20/Poly1305,
используя intro key и расшифрованный 16-байтный заголовок
в качестве AD. Обработать сообщение.</li>
</ul>
<p>c) If a pending outbound session is not found,
or the connection ID does not match the pending session, drop the message,
unless the port is shared with SSU 1.</p>
</li>
</ul>
<ol start="4">
<li>Если SSU 1 работает на том же порту, попытаться обработать сообщение как SSU 1 пакет.</li>
</ol>
<h4 id="error-handling">Error Handling</h4>
<p>В целом, сессия (в фазе handshake или передачи данных) никогда не должна быть уничтожена после получения пакета с неожиданным типом сообщения. Это предотвращает атаки внедрения пакетов. Такие пакеты также часто будут получены после повторной передачи handshake пакета, когда ключи дешифрования заголовка больше не действительны.</p>
<p>В большинстве случаев просто отбрасывайте пакет. Реализация может, но не обязана, повторно передать ранее отправленный пакет (handshake сообщение или ACK 0) в ответ.</p>
<p>После отправки Session Created как Bob, неожиданными пакетами обычно являются пакеты Data, которые не могут быть расшифрованы, поскольку пакеты Session Confirmed были потеряны или получены не по порядку. Поместите пакеты в очередь и попытайтесь расшифровать их после получения пакетов Session Confirmed.</p>
<p>После получения Session Confirmed в качестве Bob, неожиданные пакеты обычно представляют собой повторно переданные пакеты Session Confirmed, поскольку ACK 0 пакета Session Confirmed был утерян. Неожиданные пакеты могут быть отброшены. Реализация может, но не обязана, отправить пакет Data, содержащий блок ACK в ответ.</p>
<h3 id="notes-5">Notes</h3>
<p>Для Session Created и Session Confirmed реализации должны тщательно проверять все расшифрованные поля заголовка (Connection IDs, номер пакета, тип пакета, версия, id, frag и флаги) ПЕРЕД вызовом mixHash() на заголовке и попыткой расшифровки полезной нагрузки с помощью Noise AEAD. Если расшифровка Noise AEAD не удается, дальнейшая обработка не может быть выполнена, поскольку mixHash() повредит состояние handshake, если только реализация не сохраняет и не &ldquo;откатывает&rdquo; состояние хеша.</p>
<h3 id="version-detection">Version Detection</h3>
<p>Возможно, не удастся эффективно определить, являются ли входящие пакеты версии 1 или 2 на одном и том же входящем порту. Описанные выше шаги имеет смысл выполнять до обработки SSU 1, чтобы избежать попыток пробных DH операций с использованием обеих версий протокола.</p>
<p>Будет определено при необходимости.</p>
<h2 id="recommended-constants">Recommended Constants</h2>
<ul>
<li>Таймаут повторной передачи исходящего handshake: 1,25 секунды, с экспоненциальным откатом
(повторные передачи через 1,25, 3,75 и 8,75 секунд)</li>
<li>Общий таймаут исходящего handshake: 15 секунд</li>
<li>Таймаут повторной передачи входящего handshake: 1 секунда, с экспоненциальным откатом
(повторные передачи через 1, 3 и 7 секунд)</li>
<li>Общий таймаут входящего handshake: 12 секунд</li>
<li>Таймаут после отправки повтора: 9 секунд</li>
<li>Задержка ACK: max(10, min(rtt/6, 150)) мс</li>
<li>Задержка немедленного ACK: min(rtt/16, 5) мс</li>
<li>Максимальное количество диапазонов ACK: 256?</li>
<li>Максимальная глубина ACK: 512?</li>
<li>Распределение дополнения: 0-15 байт или больше</li>
</ul>
<h2 id="variants-fallbacks-and-general-issues">Variants, Fallbacks, and General Issues</h2>
<p>Будет определено позже</p>
<h2 id="packet-overhead-analysis">Packet Overhead Analysis</h2>
<p>Предполагает IPv4, не включая дополнительное заполнение, не включая размеры заголовков IP и UDP. Заполнение представляет собой выравнивание по модулю 16 только для SSU 1.</p>
<p>SSU 1</p>
<table>
  <thead>
      <tr>
          <th>Message</th>
          <th>Header+MAC</th>
          <th>Keys</th>
          <th>Data</th>
          <th>Padding</th>
          <th>Total</th>
          <th>Notes</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Session Request</td>
          <td>40</td>
          <td>256</td>
          <td>5</td>
          <td>3</td>
          <td>304</td>
          <td>Incl.</td>
      </tr>
      <tr>
          <td>Session Created</td>
          <td>37</td>
          <td>256</td>
          <td>79</td>
          <td>1</td>
          <td>336</td>
          <td>Incl.</td>
      </tr>
      <tr>
          <td>Session Confirmed</td>
          <td>37</td>
          <td></td>
          <td>462</td>
          <td>13</td>
          <td>512</td>
          <td>Incl.</td>
      </tr>
      <tr>
          <td>Data (RI)</td>
          <td>37</td>
          <td></td>
          <td>1014</td>
          <td></td>
          <td>1051</td>
          <td>Incl.</td>
      </tr>
      <tr>
          <td>Data (1 full msg)</td>
          <td>37</td>
          <td></td>
          <td>14</td>
          <td></td>
          <td>51</td>
          <td>Incl.</td>
      </tr>
      <tr>
          <td>Total</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>2254</td>
          <td></td>
      </tr>
      <tr>
          <td>SSU 2</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<table>
  <thead>
      <tr>
          <th>Message</th>
          <th>Header+MACs</th>
          <th>Keys</th>
          <th>Data</th>
          <th>Padding</th>
          <th>Total</th>
          <th>Notes</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Session Request</td>
          <td>48</td>
          <td>32</td>
          <td>7</td>
          <td></td>
          <td>87</td>
          <td>DateTi</td>
      </tr>
      <tr>
          <td>Session Created</td>
          <td>48</td>
          <td>32</td>
          <td>16</td>
          <td></td>
          <td>96</td>
          <td>DateTi</td>
      </tr>
      <tr>
          <td>Session Confirmed</td>
          <td>48</td>
          <td>32</td>
          <td>1005</td>
          <td></td>
          <td>1085</td>
          <td>1000 b</td>
      </tr>
      <tr>
          <td>Data (1 full msg)</td>
          <td>32</td>
          <td></td>
          <td>14</td>
          <td></td>
          <td>46</td>
          <td></td>
      </tr>
      <tr>
          <td>Total</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td>1314</td>
          <td></td>
      </tr>
      <tr>
          <td>TODO ЕСЛИ минимальный размер пакета в Session Request и Created не обеспечивается для PMTU.</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>

                </article>

                
                <nav class="page-nav">
                    <a href="../../../ru/proposals/" class="page-nav-link">
                        ← Back to Proposals
                    </a>
                    
                    
                    
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                            
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                    <a href="../../../proposals/159-ssu2.txt" class="page-nav-link" download>
                        Download Source (.txt)
                    </a>
                    
                </nav>
            </div>
        </div>
    </div>
</div>

<style>
.proposals-page {
    min-height: 100vh;
    padding: var(--spacing-xl) 0;
}

.breadcrumbs {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
    margin-bottom: var(--spacing-lg);
    font-size: 0.875rem;
    color: var(--color-text-muted);
}

.breadcrumbs a {
    color: var(--color-text-muted);
    text-decoration: none;
    transition: color var(--transition-fast);
}

.breadcrumbs a:hover {
    color: var(--color-primary);
}

.separator {
    color: var(--color-border);
}

.current {
    color: var(--color-text);
}

 
.translation-disclaimer {
    background: #fef3c7;
    border: 1px solid #f59e0b;
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--spacing-md);
    flex-wrap: wrap;
}

.dark .translation-disclaimer {
    background: #78350f;
    border-color: #d97706;
}

.disclaimer-message {
    color: #92400e;
    font-size: 0.875rem;
}

.dark .disclaimer-message {
    color: #fde047;
}

.disclaimer-link {
    color: #92400e;
    font-weight: 600;
    text-decoration: underline;
    white-space: nowrap;
}

.dark .disclaimer-link {
    color: #fde047;
}

 
.proposal-header {
    margin-bottom: var(--spacing-2xl);
}

.proposal-title-section {
    margin-bottom: var(--spacing-lg);
}

.proposal-title {
    font-size: 2.5rem;
    margin: 0 0 var(--spacing-sm) 0;
    color: var(--color-text);
}

.proposal-number {
    font-size: 0.875rem;
    color: var(--color-text-muted);
    font-weight: 600;
}

 
.proposal-meta-box {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--spacing-lg);
}

.proposal-status {
    display: inline-block;
    padding: var(--spacing-xs) var(--spacing-md);
    border-radius: var(--radius-md);
    font-weight: 600;
    font-size: 0.875rem;
    margin-bottom: var(--spacing-md);
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

 
.status-open {
    background: #dbeafe;
    color: #0369a1;
}

.dark .status-open {
    background: #0c4a6e;
    color: #7dd3fc;
}

.status-accepted {
    background: #dbeafe;
    color: #0369a1;
}

.dark .status-accepted {
    background: #0c4a6e;
    color: #7dd3fc;
}

.status-finished {
    background: #dcfce7;
    color: #15803d;
}

.dark .status-finished {
    background: #164e63;
    color: #86efac;
}

.status-closed {
    background: #dcfce7;
    color: #15803d;
}

.dark .status-closed {
    background: #164e63;
    color: #86efac;
}

.status-rejected {
    background: #fee2e2;
    color: #991b1b;
}

.dark .status-rejected {
    background: #7f1d1d;
    color: #fca5a5;
}

.status-draft,
.status-needs-revision,
.status-dead,
.status-needs-research {
    background: #fef3c7;
    color: #92400e;
}

.dark .status-draft,
.dark .status-needs-revision,
.dark .status-dead,
.dark .status-needs-research {
    background: #78350f;
    color: #fde047;
}

.status-meta,
.status-informational,
.status-reserve {
    background: #e9d5ff;
    color: #6b21a8;
}

.dark .status-meta,
.dark .status-informational,
.dark .status-reserve {
    background: #581c87;
    color: #e879f9;
}

 
.proposal-info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
}

.info-item {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-xs);
}

.info-label {
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-text-muted);
}

.info-value {
    font-size: 0.9375rem;
    color: var(--color-text);
    font-weight: 500;
}

 
.proposal-relationships {
    border-top: 1px solid var(--color-border);
    padding-top: var(--spacing-md);
}

.relationship {
    display: flex;
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
}

.relationship:last-child {
    margin-bottom: 0;
}

.relationship-label {
    font-weight: 600;
    color: var(--color-text-muted);
    min-width: 120px;
}

.relationship-value {
    color: var(--color-text);
}

 
.proposal-layout {
    display: block;
}

.proposal-layout--with-toc {
    display: grid;
    grid-template-columns: 260px 1fr;
    gap: var(--spacing-2xl);
    align-items: start;
}

 
.proposal-toc-sidebar {
    position: sticky;
    top: 100px;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
}

.toc-nav {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--spacing-md);
}

.toc-header {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    font-weight: 700;
    font-size: 0.875rem;
    color: var(--color-text);
    padding-bottom: var(--spacing-md);
    margin-bottom: var(--spacing-md);
    border-bottom: 1px solid var(--color-border);
}

.toc-content {
    max-height: calc(100vh - 250px);
    overflow-y: auto;
}

.toc-content::-webkit-scrollbar {
    width: 4px;
}

.toc-content::-webkit-scrollbar-track {
    background: transparent;
}

.toc-content::-webkit-scrollbar-thumb {
    background: var(--color-border);
    border-radius: 2px;
}

.toc-content::-webkit-scrollbar-thumb:hover {
    background: var(--color-text-muted);
}

.toc-nav ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
}

.toc-nav li {
    margin-bottom: 0.25rem;
}

.toc-nav ul ul {
    padding-left: var(--spacing-md);
    margin-top: 0.25rem;
}

.toc-nav a {
    color: var(--color-text-secondary);
    text-decoration: none;
    font-size: 0.8125rem;
    display: block;
    padding: 0.25rem 0.5rem;
    border-radius: var(--radius-sm);
    transition: all var(--transition-fast);
    line-height: 1.4;
}

.toc-nav a:hover {
    color: var(--color-primary);
    background: var(--color-bg-tertiary);
}

 
.proposal-main {
    min-width: 0;
}

 
.proposal-content {
    line-height: 1.8;
    color: var(--color-text);
    max-width: 900px;
}

.proposal-content h2 {
    margin-top: var(--spacing-2xl);
    margin-bottom: var(--spacing-md);
    font-size: 1.75rem;
    scroll-margin-top: 100px;
}

.proposal-content h3 {
    margin-top: var(--spacing-xl);
    margin-bottom: var(--spacing-sm);
    font-size: 1.375rem;
    scroll-margin-top: 100px;
}

.proposal-content h4 {
    margin-top: var(--spacing-lg);
    margin-bottom: var(--spacing-xs);
    font-size: 1.125rem;
    scroll-margin-top: 100px;
}

.proposal-content p {
    margin-bottom: var(--spacing-md);
}

.proposal-content ul,
.proposal-content ol {
    margin-bottom: var(--spacing-md);
    padding-left: var(--spacing-xl);
}

.proposal-content li {
    margin-bottom: var(--spacing-xs);
}

.proposal-content code {
    background: var(--color-bg-secondary);
    padding: 0.125rem 0.375rem;
    border-radius: var(--radius-sm);
    font-size: 0.875em;
    font-family: 'Courier New', monospace;
}

.proposal-content pre {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    overflow-x: auto;
    margin-bottom: var(--spacing-md);
    font-size: 0.875rem;
}

.proposal-content pre code {
    background: none;
    padding: 0;
}

.proposal-content blockquote {
    border-left: 4px solid var(--color-primary);
    padding-left: var(--spacing-md);
    margin-left: 0;
    margin-bottom: var(--spacing-md);
    font-style: italic;
    color: var(--color-text-secondary);
}

.proposal-content a {
    color: var(--color-primary);
    text-decoration: none;
    border-bottom: 1px solid transparent;
    transition: border-color var(--transition-fast);
}

.proposal-content a:hover {
    border-bottom-color: var(--color-primary);
}

.proposal-content table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: var(--spacing-md);
}

.proposal-content table th {
    background: var(--color-bg-secondary);
    padding: var(--spacing-sm);
    text-align: left;
    font-weight: 600;
    border-bottom: 2px solid var(--color-border);
}

.proposal-content table td {
    padding: var(--spacing-sm);
    border-bottom: 1px solid var(--color-border);
}

.proposal-content img {
    max-width: 100%;
    height: auto;
    border-radius: var(--radius-md);
    border: 1px solid var(--color-border);
    margin: var(--spacing-lg) 0;
    display: block;
}

 
.page-nav {
    margin-top: var(--spacing-2xl);
    padding-top: var(--spacing-xl);
    border-top: 1px solid var(--color-border);
    display: flex;
    gap: var(--spacing-md);
    flex-wrap: wrap;
}

.page-nav-link {
    display: inline-block;
    padding: var(--spacing-md) var(--spacing-lg);
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    color: var(--color-text);
    text-decoration: none;
    transition: all var(--transition-fast);
}

.page-nav-link:hover {
    border-color: var(--color-primary);
    color: var(--color-primary);
}

 
@media (max-width: 1024px) {
    .proposal-layout--with-toc {
        grid-template-columns: 1fr;
    }

    .proposal-toc-sidebar {
        position: static;
        max-height: none;
        margin-bottom: var(--spacing-xl);
    }

    .toc-content {
        max-height: 300px;
    }
}

@media (max-width: 768px) {
    .proposal-title {
        font-size: 1.75rem;
    }

    .proposal-info-grid {
        grid-template-columns: 1fr;
    }
}
</style>



<script>
document.addEventListener('DOMContentLoaded', function() {
    const tocLinks = document.querySelectorAll('.toc-nav a');
    const headings = [];

    tocLinks.forEach(link => {
        const href = link.getAttribute('href');
        if (href && href.startsWith('#')) {
            const heading = document.getElementById(href.slice(1));
            if (heading) {
                headings.push({ element: heading, link: link });
            }
        }
    });

    function updateActiveLink() {
        const scrollPos = window.scrollY + 120;
        let activeIndex = 0;

        for (let i = 0; i < headings.length; i++) {
            if (headings[i].element.offsetTop <= scrollPos) {
                activeIndex = i;
            }
        }

        tocLinks.forEach(link => link.classList.remove('active'));
        if (headings[activeIndex]) {
            headings[activeIndex].link.classList.add('active');
        }
    }

    window.addEventListener('scroll', updateActiveLink);
    updateActiveLink();
});
</script>
<style>
.toc-nav a.active {
    color: var(--color-primary);
    background: var(--color-bg-tertiary);
    font-weight: 600;
}
</style>



    </main>

    <footer class="site-footer">
    <div class="container">
        <div class="footer-grid">
            <div class="footer-col footer-brand">
                <img src="../../../images/i2plogo_lightmode.svg" alt="I2P Logo" class="footer-logo logo-light" loading="lazy" decoding="async">
                <img src="../../../images/i2plogo_darkmode.svg" alt="I2P Logo" class="footer-logo logo-dark" loading="lazy" decoding="async">
                <p class="footer-tagline">Privacy. Security. Freedom.</p>
                <p class="footer-description">The Invisible Internet Project - A privacy-focused, anonymous network layer</p>

                <div class="footer-social-newsletter">
                    <div class="social-links">
                        <a href="https://mastodon.social/@i2p" target="_blank" rel="noopener" aria-label="Mastodon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M21.327 8.566c0-4.339-2.843-5.61-2.843-5.61-1.433-.658-3.894-.935-6.451-.956h-.063c-2.557.021-5.016.298-6.45.956 0 0-2.843 1.272-2.843 5.61 0 .993-.019 2.181.012 3.441.103 4.243.778 8.425 4.701 9.463 1.809.479 3.362.579 4.612.51 2.268-.126 3.541-.809 3.541-.809l-.075-1.646s-1.621.511-3.441.449c-1.804-.062-3.707-.194-3.999-2.409a4.523 4.523 0 0 1-.04-.621s1.77.433 4.014.536c1.372.063 2.658-.08 3.965-.236 2.506-.299 4.688-1.843 4.962-3.254.434-2.223.398-5.424.398-5.424zm-3.353 5.59h-2.081V9.057c0-1.075-.452-1.62-1.357-1.62-1 0-1.501.647-1.501 1.927v2.791h-2.069V9.364c0-1.28-.501-1.927-1.502-1.927-.905 0-1.357.546-1.357 1.62v5.099H6.026V8.903c0-1.074.273-1.927.823-2.558.566-.631 1.307-.955 2.228-.955 1.065 0 1.872.409 2.405 1.228l.518.869.519-.869c.533-.819 1.34-1.228 2.405-1.228.92 0 1.662.324 2.228.955.549.631.822 1.484.822 2.558v5.253z"/>
                            </svg>
                        </a>
                        <a href="https://twitter.com/GetI2P" target="_blank" rel="noopener" aria-label="Twitter">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                            </svg>
                        </a>
                        <a href="https://old.reddit.com/r/i2p" target="_blank" rel="noopener" aria-label="Reddit">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z"/>
                            </svg>
                        </a>
                        <a href="https://signal.group/#CjQKIOSUTtxlhbumAKcRsthPFkxkTUrkWcX39bbN6njLEgAIEhCTNsR0KDuiehAXZnkt42v5" target="_blank" rel="noopener" aria-label="Signal" class="signal-link">
                            <img src="../../../images/Signal-Logo-Black.svg" alt="Signal" class="signal-logo signal-logo-light" loading="lazy" decoding="async">
                            <img src="../../../images/Signal-Logo-White.svg" alt="Signal" class="signal-logo signal-logo-dark" loading="lazy" decoding="async">
                        </a>
                    </div>

                    
                    <div class="footer-newsletter-inline">
                        <p class="newsletter-description">Следите за новостями I2P:</p>
                        <form action="https://feedback.i2p.net/api/mailing-list/subscribe" method="POST" class="newsletter-form">
                            <input type="email" name="email" placeholder="Введите ваш email" required>
                            <button type="submit">Подписаться</button>
                        </form>
                    </div>
                </div>
            </div>

            <div class="footer-col">
                <h3>Быстрые ссылки</h3>
                <ul>
                    <li><a href="../../../ru/financial-support/">Пожертвовать</a></li>
                    <li><a href="../../../ru/docs/overview/intro/">Введение в I2P</a></li>
                </ul>
            </div>

            <div class="footer-col">
                <h3>Сообщество</h3>
                <ul>
                    <li><a href="../../../ru/get-involved/">Присоединяйтесь</a></li>
                    <li><a href="../../../ru/blog/">Блог</a></li>
                    <li><a href="http://i2pforum.net/" target="_blank" rel="noopener">Официальные форумы</a></li>
                    <li><a href="../../../ru/contact/">Контакты</a></li>
                </ul>
            </div>

            <div class="footer-col">
                <h3>Ресурсы</h3>
                <ul>
                    <li><a href="https://i2p-metrics.np-tokumei.net/" target="_blank" rel="noopener">I2P Метрики</a></li>
                    <li><a href="../../../ru/papers/">Исследование</a></li>
                    <li><a href="https://i2pgit.org/" target="_blank" rel="noopener">GitLab</a></li>
                    <li><a href="https://www.stormycloud.org/" target="_blank" rel="noopener">StormyCloud</a></li>
                </ul>
            </div>
        </div>

        <div class="footer-bottom">
            <p class="copyright">&copy; 2025 Проект Невидимый Интернет. Лицензировано под Creative Commons.</p>
            <div class="footer-links">
                <a href="../../../ru/privacy/">Конфиденциальность</a>
                <a href="../../../ru/terms/">Условия</a>
                <a href="../../../ru/about/media/">Пресса</a>
            </div>
        </div>
    </div>
</footer>


    
    
<div class="modal-overlay" id="poll">
    <div class="modal-content poll-modal-content">
        <a href="#" class="modal-close" aria-label="Закрыть">
            <span aria-hidden="true">&times;</span>
        </a>

        <div class="modal-header">
            <h2>Опрос сообщества</h2>
            <p class="modal-subtitle">Мы хотели бы услышать ваше мнение</p>
        </div>

        <div class="modal-body">
            
            <iframe 
                id="poll-iframe"
                data-poll-id="2"
                data-api-url="https://feedback.i2p.net"
                frameborder="0"
                scrolling="no"
                style="width: 100%; border: none; min-height: 400px;">
            </iframe>
        </div>

        <div class="modal-footer">
            <p class="modal-disclaimer">
                Ваш голос помогает формировать будущее I2P.
            </p>
        </div>
    </div>
</div>


<script>
(function() {
    const iframe = document.getElementById('poll-iframe');
    if (!iframe) return;
    
    const hostname = window.location.hostname;
    let apiUrl = 'https://feedback.i2p.net';
    const pollId = iframe.getAttribute('data-poll-id') || '1';

    
    if (hostname.endsWith('.b32.i2p') || hostname.endsWith('.i2p')) {
        apiUrl = 'http://5kwyynf3eetgqa2nors6ctwo7doi7yu73k7uvypy5eqmm326zkiq.b32.i2p';
    }
    
    else if (hostname.endsWith('.onion')) {
        apiUrl = 'http://gfonxmohvarpmocsvllscsuszdu5rikipm6innvcwq4vpng7zzqmmfyd.onion';
    }

    
    const pollUrl = apiUrl + '/widgets/poll.html?poll_id=' + encodeURIComponent(pollId) + '&api_url=' + encodeURIComponent(apiUrl);
    iframe.src = pollUrl;
})();
</script>



    
    



    
    <script>
        (function () {
            'use strict';
            var hostname = window.location.hostname;
            var baseUrl;

            
            if (hostname.endsWith('.b32.i2p') || hostname.endsWith('.i2p')) {
                baseUrl = 'http://5kwyynf3eetgqa2nors6ctwo7doi7yu73k7uvypy5eqmm326zkiq.b32.i2p';
            } else if (hostname.endsWith('.onion')) {
                baseUrl = 'http://gfonxmohvarpmocsvllscsuszdu5rikipm6innvcwq4vpng7zzqmmfyd.onion';
            } else {
                baseUrl = 'https://feedback.i2p.net';
            }

            window.feedbackBaseUrl = baseUrl;

            
            document.querySelectorAll('[data-api-url]').forEach(function (widget) {
                widget.setAttribute('data-api-url', baseUrl);
            });

            
            document.write('<link rel="stylesheet" href="' + baseUrl + '/widgets/styles.css">');
            
        })();
    </script>

    

    
    
    

    

</body>

</html>